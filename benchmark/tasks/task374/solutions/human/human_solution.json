[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> P;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n#define pi acos(-1)\n\nint main(){\n    cin.sync_with_stdio(false);\n    int n;\n    double r, theta;\n    cin >> n >> r >> theta;\n    theta = theta * pi / 180.0;\n    vector<P> v;\n    rep(i, n) {\n        double x, y;\n        cin >> x >> y;\n        v.pb(P(x, y));\n    }\n\n    double dp[n][n][10001];\n    rep(i, n)rep(j, n)rep(k, 10001) dp[i][j][k] = INF + 1;\n    dp[0][0][0] = 0;\n    int ans = 0;\n    rep(k, 10000) {\n        if (ans != k) break;\n        rep(i, n)rep(j, n) {\n            if (dp[i][j][k] < INF) {\n                rep(l, n) {\n                    if (j == l || i == l) continue;\n                    double alpha = abs(arg(v[l] - v[j]) - arg(v[j] - v[i]));\n                    if (alpha > pi) alpha = 2 * pi - alpha;\n                    if (alpha <= theta && dp[i][j][k] + abs(v[l] - v[j]) <= r) {\n                        minch(dp[j][l][k + 1], dp[i][j][k] + abs(v[l] - v[j]));\n                        ans = k + 1;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n\nusing namespace std;\n\nint n;\ndouble r;\ndouble theta;\nint x[20];\nint y[20];\ndouble dp[20][20];\ndouble buf[20][20];\nbool check_angle_buf[20][20][20];\ndouble dist_buf[20][20];\n\ndouble dist(int i, int j) {\n    int dx1 = x[j] - x[i];\n    int dy1 = y[j] - y[i];\n    return sqrt(dx1 * dx1 + dy1 * dy1);\n}\n\nbool check_angle(int i, int j, int k) {\n    int dx1 = x[j] - x[i];\n    int dy1 = y[j] - y[i];\n    int dx2 = x[k] - x[j];\n    int dy2 = y[k] - y[j];\n    double arg = acos((dx1 * dx2 + dy1 * dy2) / (dist(i, j) * dist(j, k)));\n    return arg <= theta;\n}\n\n\nvoid dumpdp() {\n    for (int i = -1; i< n; ++i) {\n        for (int j = -1; j < n; ++j) {\n            if (i == -1) {\n                if (j == -1) continue;\n                cout << setw(10) << j;\n                continue;\n            }\n            if (j == -1) {\n                cout << i;\n                continue;\n            }\n            if (dp[i][j] > 10000) {\n                    cout << \"        --\";\n                } else {\n                    cout << setw(10) << setprecision(2) << fixed << dp[i][j];\n                }\n            //cout << \"(\" <<setw(4) << setprecision(2) << fixed << dist_buf[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint main () {\n    cin >> n;\n    cin >> r >> theta;\n    theta = theta * M_PI / 180;\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i] >> y[i];\n    }\n\n    int cmax = (int)r + 1;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = 10000000;\n            dist_buf[i][j] = dist(i, j);\n            for (int k = 0; k < n; ++k) {\n                check_angle_buf[i][j][k] = check_angle(i, j, k);\n                //cout << i << j << k << \" \" << (check_angle_buf[i][j][k] ? \"OK\": \"NG\") << endl;\n            }\n        }\n    }\n    double mind = r + 1;\n    for (int i = 1; i < n; ++i) {\n        dp[0][i] = dist(0, i);\n        mind = min(mind, dp[0][i]);\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = 100000000;\n            buf[0][j] = 100000000;\n            buf[i][j] = 100000000;\n        }\n    }\n\n    if (mind > r) {\n        cout << 0 << endl;\n        return 0;\n    }\n    dp[0][0] = 1000000;\n\n    int c;\n    for (c = 1; c <= cmax; ++c) {\n        //dumpdp();\n        for (int k = 0; k < n; ++k) {\n            for (int j = 0; j < n; ++j) {\n                if (j == k) continue;\n                double d = dist_buf[j][k];\n                double tmp = 1000000000;\n                for (int i  = 0; i < n; ++i) {\n                    if (j == i || k == i) continue;\n                    if (!check_angle_buf[i][j][k]) continue;\n                    tmp = min(tmp, d + dp[i][j]);\n                }\n                buf[j][k] = tmp;\n            }\n        }\n        double minr = r + 1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                dp[i][j] = buf[i][j];\n                minr = min(minr, dp[i][j]);\n                buf[i][j] = 10000000;\n            }\n        }\n        if (minr > r) break;\n    }\n    cout << c << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n#define F first\n#define S second\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<double,int>P1;\ntypedef pair<int,int>P2;\ntypedef pair<P1,P2>P3;\nint n,ans;\nP p[21];\nD r,qu,dp[10001][21][21];\nint main(){\n  cin>>n>>r>>qu;\n  rep(i,10001)rep(j,21)rep(k,21)dp[i][j][k]=1e15;\n  rep(i,n){\n    D x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<P3,vector<P3>,greater<P3> >q;\n  for(int i=1;i<n;i++){\n    dp[1][0][i]=abs(p[0]-p[i]);\n    q.push(P3(P1(dp[1][0][i],1),P2(0,i)));\n  }\n  while(!q.empty()){\n    P3 ppp=q.top();q.pop();\n    int pre=ppp.S.F;\n    int now=ppp.S.S;\n    int num=ppp.F.S;\n    double cost=ppp.F.F;\n    if(dp[num][pre][now]<cost)continue;\n    rep(i,n)if(now!=i){\n      D a=abs(p[pre]-p[now]);\n      D b=abs(p[now]-p[i]);\n      D c=abs(p[i]-p[pre]);\n      D radi=acos((a*a+b*b-c*c)/(2*a*b));\n      radi=radi/M_PI*180;\n      if(180.0-radi > qu)continue;\n      if(cost+abs(p[now]-p[i])>r)continue;\n      if(dp[num+1][now][i]<cost+abs(p[now]-p[i]))continue;\n      dp[num+1][now][i]=cost+abs(p[now]-p[i]);\n      q.push(P3(P1(dp[num+1][now][i],num+1),P2(now,i)));\n    }\n  }\n  dp[0][0][0]=1;\n  for(int i=10000;i>=0;i--){\n    rep(j,21)rep(k,21)if(dp[i][j][k]!=1e15){\n      cout<<i<<endl;\n      return 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n#include<climits>\n#include<complex>\n\n#define debug(x) cerr << #x << \": \" << x << endl\n#define EPS 1e-5\n \nusing namespace std;\n\nint main(){\n    int n;\n    double r, theta;\n    cin >> n;\n    cin >> r >> theta;\n    theta = theta/180.0*M_PI;\n    complex<double> cities[n];\n    for(int i=0;i<n;i++){\n        double x,y;\n        cin >> x >> y;\n        cities[i] = complex<double>(x, y);\n    }\n \n    bool ok[n][n][n];\n    fill_n(**ok, n*n*n, false);\n    double dist[n][n];\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(i == j) continue;\n            complex<double> v = cities[j] - cities[i];\n            dist[i][j] = abs(v);\n            for(int k=0;k<n;k++){\n                if(i == k || j == k) continue;\n                complex<double> u = cities[k] - cities[j];\n                double theta_ = abs(arg(u) - arg(v));\n                if(theta_ < theta+EPS){\n                    ok[i][j][k] = true;\n                }\n            }\n        }\n    }\n\n    double dp[2][n][n];\n    fill(dp[0][0], dp[0][n], -1.0);\n    for(int j=1;j<n;j++){\n        dp[0][0][j] = dist[0][j];\n    }\n    int i = 0, ans = 0;\n    for(int i=0;i<=10000;i++){\n        fill(dp[1-(i&1)][0], dp[1-(i&1)][n], 200000.0);\n        for(int j=0;j<n;j++){\n            for(int k=0;k<n;k++){\n                if(j == k || dp[i&1][j][k] > r+EPS) continue;\n                ans = i+1;\n                for(int l=0;l<n;l++){\n                    if(j == l || k == l) continue;\n                    if(ok[j][k][l]){\n                        dp[1-(i&1)][k][l] = min(dp[1-(i&1)][k][l], dp[i&1][j][k] + dist[k][l]);\n                        // printf(\"%d=>%d=>%d %lf\\n\", j, k, l, dp[1-(i&1)][k][l]);\n                    } \n                }\n            }\n        }\n    }\n \n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=double;\nusing P=complex<ld>;\nconst ld pi=acos(-1);\nstruct State{\n    int v,pre;\n    int c; \n};\n\nbool operator<(const State& lhs,const State& rhs){\n    return true;\n}\n\nint idx(State st){\n    return st.v+20*st.pre+st.c*20*20;\n}\nint main(){\n    int n;\n    cin>>n;\n    ld r,theta;\n    cin>>r>>theta;\n    theta=(theta)/180*pi;\n    vector<P> xy(n);\n    for(int i=0;i<n;i++){\n        ld tmpx,tmpy;\n        cin>>tmpx>>tmpy;\n        xy[i]={tmpx,tmpy};\n    }\n    int res=0;\n    priority_queue<pair<ld,State>,vector<pair<ld,State>>,greater<>> que;\n    que.push({ld(0),State{0,0,0}});\n    const ld INF=1e9;\n    vector<ld> dist(5*1e6,INF);\n    vector<ld> check(5*1e6,0);\n    dist[0]=0;\n    while(!que.empty()){\n        auto tmp=que.top(); que.pop();\n        auto ret=tmp.second;\n        int v=ret.v,pre=ret.pre;\n        int c=ret.c;\n        int id=idx(ret);\n        ld w=tmp.first;\n        if(check[id]) continue;\n        check[id]=true;\n        if(w>r) break;\n        res=max(res,c);\n        for(int i=0;i<n;i++){\n            if(i!=v && i!=pre){\n                if(pre!=v){\n                    ld phi=arg((xy[i]-xy[v])/(xy[v]-xy[pre]));\n                    if(phi>pi) phi-=2*pi;\n                    if(abs(phi)>theta){\n                        continue;\n                    }\n                }\n                State to{i,v,c+1};\n                int toidx=idx(to);\n                if(w+abs(xy[i]-xy[v])<dist[toidx]){\n                    dist[toidx]=w+abs(xy[i]-xy[v]);\n                    que.push({dist[toidx],to});\n                }\n            }\n        }\n\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// ベクトル演算\n// 内積 外積 直交 平行\ndouble dot(P a, P b) {return (a.real()*b.real()+a.imag()*b.imag());}\ndouble cross(P a, P b) {return (a.real()*b.imag()-a.imag()*b.real());}\nbool orth(P a1, P a2, P b1, P b2) {return deq(dot(a1-a2,b1-b2),0.0);}\nbool para(P a1, P a2, P b1, P b2) {return deq(cross(a1-a2,b1-b2),0.0);}\n// 点cが直線[線分]ab上にあるかどうか\nbool pol(P a, P b, P c) {return deq(cross(b-a,c-a),0.0);}\nbool pols(P a, P b, P c) {return (abs(a-c)+abs(c-b)<abs(a-b)+eps);}\n// 線分a1a2と線分b1b2の交差判定\nbool intls(P a1, P a2, P b1, P b2) {\n\treturn (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<eps)\n\t\t   && (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<eps);\n}\n// 直線[線分]a1a2と直線[線分]b1b2の交点 (要交差判定)\nP pintl(P a1, P a2, P b1, P b2) {\n\tP a = a2-a1, b = b2-b1;\n\treturn a1+a*cross(b,b1-a1)/cross(b,a);\n}\nP pintls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b,a1-b1)), d2 = abs(cross(b,a2-b1)), t = d1/(d1+d2);\n\treturn a1+(a2-a1)*t;\n}\n// 点cと直線[線分]abとの距離\ndouble disl(P a, P b, P c) {return abs(cross(b-a,c-a))/abs(b-a);}\ndouble disls(P a, P b, P c) {\n\tif (dot(b-a,c-a)<eps) return abs(c-a);\n\tif (dot(a-b,c-b)<eps) return abs(c-b);\n\treturn abs(cross(b-a,c-a))/abs(b-a);\n}\n// 線分a1a2と線分b1b2の距離\ndouble dislss(P a1, P a2, P b1, P b2) {\n\tif (!para(a1,a2,b1,b2) && intls(a1,a2,b1,b2)) return 0;\n\tdouble a = min(disls(a1,a2,b1),disls(a1,a2,b2)), b = min(disls(b1,b2,a1),disls(b1,b2,a2));\n\treturn min(a,b);\n}\n\n\n// e[i][j]: 街iからjに来た直後にjから行ける街の番号とコストのpair一覧\n// d[i][j][k]: 街iからjに来てにんじんをk個持ってる状態のコスト総和の最小値\n\nint n;\ndouble r, s, x[22], y[22], d[20][20][10101];\nvector<pair<int,double> > e[22][22];\n\nsigned main() {\n\tcin >> n >> r >> s;\n\trep(i,n) cin >> x[i] >> y[i];\n\trep(i,n) rep(j,n) if (i!=j) {\n\t\trep(k,n) if (i!=k && j!=k) {\n\t\t\t// ベクトルijとjkのなす角のcosのarccos\n\t\t\tP a = P(x[j]-x[i],y[j]-y[i]), b = P(x[k]-x[j],y[k]-y[j]);\n\t\t\tdouble z = acos(dot(a,b)/(abs(a)*abs(b)))/M_PI*180;\n\t\t\tif (z-eps<s) e[i][j].pb({k,abs(b)});\n\t\t}\n\t}\n\trep(i,n) rep(j,n) rep(k,10101) d[i][j][k] = 1e100;\n\treps(i,1,n) d[0][i][1] = sqrt((x[i]-x[0])*(x[i]-x[0]) + (y[i]-y[0])*(y[i]-y[0]));\n\trep(k,10100) rep(i,n) rep(j,n) if (d[i][j][k]!=1e100)\n\t\teach(l,e[i][j]) chmin(d[j][l.fi][k+1], d[i][j][k]+l.se);\n\tint res = 0;\n\trep(i,n) rep(j,n) rep(k,10101) if (d[i][j][k]<=r) chmax(res,k);\n\tcout << res << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 30;\nint x[N], y[N];\n\nint dist[10010][N][N];\n\nvector<int> G[N][N];\ndouble D[N][N];\n\nconst double PI = 4 * atan(1);\nconst double EPS = 1e-9;\n\nint main(){\n\tint n;\n\tdouble r, theta;\n\tcin >> n >> r >> theta;\n\ttheta = theta / 180 * PI;\n\trep(i, n) cin >> x[i] >> y[i];\n\n\trep(i, n) rep(j, n){\n\t\tD[i][j] = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));\n\t}\n\n\trep(i, n) rep(j, n) rep(k, n){\n\t\tif (i == j || j == k) continue;\n\t\tdouble x1 = x[j] - x[i], y1 = y[j] - y[i];\n\t\tdouble x2 = x[k] - x[j], y2 = y[k] - y[j];\n\n\t\tif (abs(abs(atan2(y1, x1)) - abs(atan2(y2, x2))) < theta + EPS) G[i][j].push_back(k);\n\t}\n\n\tMEMSET(dist, 0x7f);\n\tpriority_queue<tuple<double, int, int, int>> pq;\n\n\trep(i, n) rep(j, n){\n\t\tif (i == j) continue;\n\t\tpq.emplace(-D[i][j], 1, i, j);\n\t}\n\n\tint ans = 0;\n\twhile (!pq.empty()){\n\t\tauto t = pq.top();\n\t\tpq.pop();\n\t\tdouble d;\n\t\tint c, prv, cur;\n\t\ttie(d, c, prv, cur) = t;\n\t\td = -d;\n\n\t\tif (dist[c][prv][cur] + EPS < d) continue;\n\n\t\tans = max(ans, c);\n\n\t\tfor (auto v : G[prv][cur]){\n\t\t\tdouble nd = d + D[cur][v];\n\t\t\tif (r < nd + EPS) continue;\n\t\t\tif (dist[c + 1][cur][v] < nd + EPS) continue;\n\t\t\tdist[c + 1][cur][v] = nd;\n\t\t\tpq.emplace(-nd, c + 1, cur, v);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\ntypedef complex<double> Point;\n\ndouble angle(const Point& v1, const Point& v2) {\n    double res = arg(v1 / v2);\n    if (res < 0) res += 2*pi;\n    return min(2*pi-res, res);\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n; cin >> n;\n    double R, th; cin >> R >> th; th *= pi / 180;\n    vector<Point> v(n);\n    REP(i, n) {\n        ll x, y; cin >> x >> y;\n        v[i] = Point(x, y);\n    }\n    vector<vector<vector<bool>>> G(n, vector<vector<bool>>(n, vector<bool>(n, false)));\n    REP(i, n) REP(j, n) REP(k, n) {\n        if (i == j || j == k || k == i) continue;\n        // i -> j -> k テ」ツ?ィテ」ツ??」ツ?妥」ツつ凝」ツ??\n        Point v1 = v[j] - v[i];\n        Point v2 = v[k] - v[j];\n        if (angle(v1, v2) <= th+eps) {\n            G[i][j][k] = true;\n        }\n    }\n    vector<vector<double>> dist(n, vector<double>(n));\n    REP(i, n) REP(j, n) dist[i][j] = abs(v[i]-v[j]);\n    ll ans = 0;\n    vector<vector<vector<double>>> dp(2, vector<vector<double>>(n, vector<double>(n, linf)));\n    dp[0][0][0] = 0;\n    REP(t, 1010) {\n        dp[t+1&1].assign(n, vector<double>(n, linf));\n        REP(prev, n) REP(now, n) {\n            double l = dp[t&1][prev][now];\n            if (l > R+eps) continue;\n            ans = max(ans, t);\n            REP(to, n) {\n                if (prev != now && !G[prev][now][to]) continue;\n                if (now == to) continue;\n                dp[t+1&1][now][to] = min(dp[t+1&1][now][to], l + dist[now][to]);\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nconst int MAX_N = 20;\nconst double EPS = 1e-9;\nint x[MAX_N], y[MAX_N];\nbool can_move[MAX_N][MAX_N][MAX_N];\ndouble dist[MAX_N][MAX_N], dp[10001][MAX_N][MAX_N];\n\ndouble turn(int ax, int ay, int bx, int by) {\n\tconst double dot = ax * bx + ay * by, a_d = hypot(ax, ay), b_d = hypot(bx, by);\n\treturn M_PI - fabs(acos(dot / (a_d * b_d)));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tdouble r, theta;\n\tcin >> n >> r >> theta;\n\ttheta = theta * M_PI / 180.0;\n\n\tfor(int i = 0; i < n; ++i)\n\t\tcin >> x[i] >> y[i];\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(i == j)\n\t\t\t\tcontinue;\n\n\t\t\tfor(int k = i + 1; k < n; ++k) {\n\t\t\t\tif(j == k)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tconst double a = turn(x[i] - x[j], y[i] - y[j], x[k] - x[j], y[k] - y[j]);\n\t\t\t\tif(a + EPS < theta)\n\t\t\t\t\tcan_move[i][j][k] = can_move[k][j][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i)\n\t\tfor(int j = i + 1; j < n; ++j)\n\t\t\tdist[i][j] = dist[j][i] = hypot(x[i] - x[j], y[i] - y[j]);\n\n\tfill(dp[0][0], dp[0][0] + lengthof(dp), INT_MAX);\n\tfor(int i = 0; i < n; ++i)\n\t\tif(i != 0)\n\t\t\tdp[1][0][i] = dist[0][i];\n\n\tint ans = 0;\n\tfor(int i = 1; i <= 10000; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tfor(int k = 0; k < n; ++k) {\n\t\t\t\tif(dp[i][j][k] + EPS < r) {\n\t\t\t\t\tans = i;\n\t\t\t\t\tfor(int l = 0; l < n; ++l)\n\t\t\t\t\t\tif(can_move[j][k][l])\n\t\t\t\t\t\t\tchmin(dp[i + 1][k][l], dp[i][j][k] + dist[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\t\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> mid = cities[prev];\n  complex<double> dst = cities[city];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[10001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,false,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      if(dp[s.carrots][s.prev][s.city]) continue;\n      dp[s.carrots][s.prev][s.city] = true;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst double PI = acos(-1);\nconst double INF = 1e15;\ndouble dp[10010][20][20];\n\nint n;\ndouble r, theta;\ndouble x[20], y[20];\n\ndouble dist(double x1, double y1, double x2, double y2){\n    x1 -= x2, y1 -= y2;\n    return sqrt(x1 * x1 + y1 * y1);\n}\n\ndouble dot(double x1, double y1, double x2, double y2){\n    return x1 * x2 + y1 * y2;\n}\n\nbool check(int v, int u, int pre){\n    double ax = x[v] - x[pre];\n    double ay = y[v] - y[pre];\n    double bx = x[u] - x[v];\n    double by = y[u] - y[v];\n    double da = dist(x[v], y[v], x[pre], y[pre]);\n    double db = dist(x[u], y[u], x[v], y[v]);\n    double t = abs(acos(dot(ax, ay, bx, by) / da / db));\n    //cerr << \"\\t\\t\" << v << \" \" << u << \" \" << pre << \" \" << t << endl;\n    return t <= theta;\n}\n\nbool can[20][20][20];\n\nint main(){\n    cin >> n >> r >> theta;\n\n    theta *= 2 * PI / 360.0;\n\n    for(int i = 0; i < n; i++){\n        cin >> x[i] >> y[i];\n    }\n\n    for(int i = 0; i < 10010; i++){\n        for(int j = 0; j < n; j++){\n            for(int k = 0; k < n; k++){\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n\n    for(int v = 0; v < n; v++){\n        for(int u = 0; u < n; u++){\n            for(int pre = 0; pre < n; pre++){\n                if(v == u) continue;\n                can[v][u][pre] = check(v, u, pre);\n            }\n        }\n    }\n\n    //cout << check(2, 0, 1) << endl;\n    //return 0;\n\n    dp[0][0][0] = 0;\n    for(int i = 0; i <= 10000; i++){\n        for(int v = 0; v < n; v++){\n            for(int pre = 0; pre < n; pre++){\n                double d = dp[i][v][pre];\n                if(d >= 1e14) continue;\n                //cerr << i << \" \" << v << \" \" << pre << \" \" << d << endl;\n                for(int u = 0; u < n; u++){\n                    if(v == u) continue;\n                    if(i != 0 && !can[v][u][pre]) continue;\n                    //cerr << \"\\t\" << v << \" \" << u << endl;\n                    double ndist = d + dist(x[v], y[v], x[u], y[u]);\n                    if(ndist <= r && dp[i + 1][u][v] > ndist){\n                        dp[i + 1][u][v] = ndist;\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i <= 10000; i++){\n        for(int v = 0; v < n; v++){\n            for(int pre = 0; pre < n; pre++){\n                double d = dp[i][v][pre];\n                if(d >= 1e14) continue;\n                ans = max(ans, i);\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 20\n#define MAX_C 10001\n#define INF 1e9\n#define EPS 1e-9\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n#define le(a,b) (equal(a,b) || lt(a,b))\n#define PI acos(-1)\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n  \n  Point operator + (const Point &p)const{\n    return Point(x+p.x,y+p.y);\n  }\n  Point operator - (const Point &p)const{\n    return Point(x-p.x,y-p.y);\n  }\n  Point operator * (double k)const{\n    return Point(x*k,y*k);\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  return is >> p.x >> p.y;\n}\n\nstruct State{\n  double d;\n  int v,p,c;\n  \n  State(double d,int v,int p,int c) : \n    d(d),v(v),p(p),c(c) {}\n  \n  bool operator < (const State &s)const{\n    return d > s.d;\n  }\n};\n\ndouble dot(const Point &a,const Point &b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble norm(const Point &p){\n  return dot(p,p);\n}\n\ndouble abs(const Point &p){\n  return sqrt(norm(p));\n}\n\ntypedef Point Vector;\n\ninline double getAngle(const Vector &a,const Vector &b){\n  return acos(dot(a,b)/abs(a)/abs(b))*180/PI;\n}\n\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint N;\ndouble r,th;\ndouble d[MAX_N][MAX_N][MAX_C];\n\nint solve(const vector<Point> &vec){\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < N ; j++){\n      for(int k = 0 ; k < MAX_C ; k++){\n\td[i][j][k] = INF;\n      }\n    }\n  }\n  priority_queue<State> Q;\n  for(int i = 1 ; i < N ; i++){\n    Q.push(State(dist(vec[0],vec[i]),i,0,1));\n    d[i][0][1] = dist(vec[0],vec[i]);\n  }\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v,p = s.p,c = s.c;\n    if(lt(d[v][p][c],s.d)){ continue; }\n    if(lt(r,s.d)){ continue; }\n    for(int i = 0 ; i < N ; i++){\n      if(i == v || i == p){ continue; }\n      Vector a = vec[v]-vec[p];\n      Vector b = vec[i]-vec[v];\n      double angle = getAngle(a,b);\n      double nd = dist(vec[v],vec[i]);\n      if(lt(th,angle)){ continue; }\n      if(c+1 < MAX_C && lt(d[v][p][c]+nd,d[i][v][c+1])){\n\td[i][v][c+1] = d[v][p][c]+nd;\n\tQ.push(State(d[i][v][c+1],i,v,c+1));\n      }\n    }\n  }\n  int ans = 0;\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < N ; j++){\n      for(int k = MAX_C-1 ; k > 0 ; k--){\n\tif(le(d[i][j][k],r)){\n\t  ans = max(ans,k);\n\t  break;\n\t}\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  cin >> N >> r >> th;\n  vector<Point> v(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> v[i];\n  }\n  cout << solve(v) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct point{\n  double x,y;\n};\n\ndouble INF = 1e9;\ndouble PI = acos(-1);\ndouble EPS = (1e-10);\ndouble dp[10001][20][20];\nint n;\ndouble r,ti;\npoint t[20];\n\nvoid solve(int i,int j,int k){\n  for(int to=0;to<n;to++){\n    double vax=t[j].x-t[to].x;\n    double vay=t[j].y-t[to].y;\n    double vbx=t[k].x-t[j].x;\n    double vby=t[k].y-t[j].y;\n    double ar=(vax*vbx+vay*vby)/(sqrt(vax*vax+vay*vay)*sqrt(vbx*vbx+vby*vby));\n    ar=acos(ar);\n    if(ar<0)ar*=-1;\n    if(ar<ti+EPS){\n      dp[i+1][to][j]=dp[i][j][k]+sqrt(vax*vax+vay*vay);\n    }\n  }\n}\n\nint main(){\n\n  for(int i=0;i<10001;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<20;k++)\n\tdp[i][j][k]=INF;\n  \n  cin>>n>>r>>ti;\n  ti=ti/360.0*2.0*PI;\n\n  for(int i=0;i<n;i++)\n    cin>>t[i].x>>t[i].y;\n  \n  for(int i=1;i<n;i++){\n    double x=t[i].x-t[0].x;\n    double y=t[i].y-t[0].y;\n    dp[1][i][0]=sqrt(x*x+y*y);\n  }\n\n  int ans=-1;\n  for(int i=1;i<=10000;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(dp[i][j][k]>r+EPS)continue;\n\tans=max(ans,i);\n\tsolve(i,j,k);\n      }\n    }\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef double R;\ntypedef complex<R> P;\nconst R PI = 3.1415926535897932384626;\n\nistream& operator>>(istream &is, P &p) {\n\tR x, y;\n\tis >> x >> y;\n\tp = P(x, y);\n\treturn is;\n}\n\nint n;\ndouble r, theta;\n\ndouble visited[401][10005];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> r >> theta; theta = theta/180.*PI;\n\tvector<P> p(n);\n\tREP(i, n) cin >> p[i];\n\tvector<vector<pair<int, double>>> g(n*n);\n\tREP(i, n)REP(j, n)REP(k, n){\n\t\tif(i==k || i==j || j==k) continue;\n\t\tif(abs(arg((p[j]-p[i]) / (p[k]-p[j]))) < theta){\n\t\t\tg[j*n+i].emplace_back(k*n+j, abs(p[k]-p[j]));\n\t\t}\n\t}\n\tstruct State{\n\t\tint x, c;\n\t\tdouble cost;\n\t\tState(int x, int c, double cost)\n\t\t\t:x(x), c(c), cost(cost){}\n\t\tbool operator<(const State &opp) const{\n\t\t\treturn cost > opp.cost;\n\t\t}\n\t};\n\tpriority_queue<State> que;\n\tREP(i, 1)REP(j, n)if(i!=j){\n\t\tif(abs(p[i]-p[j]) < r){\n\t\t\tque.emplace(j*n+i, 1, abs(p[i]-p[j]));\n\t\t\tvisited[j*n+i][1] = abs(p[i]-p[j]);\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(!que.empty()){\n\t\tconst State s = que.top(); que.pop();\n\t\tif(s.cost > visited[s.x][s.c]) continue;\n\t\tans = max(ans, s.c);\n\t\tFOR(it, g[s.x]){\n\t\t\tint x = it->first;\n\t\t\tdouble cost = s.cost + it->second;\n\t\t\tint c = s.c + 1;\n\t\t\tauto &t = visited[x][c];\n\t\t\tif((t == 0 || cost < t) && cost < r){\n\t\t\t\tt = cost;\n\t\t\t\tque.emplace(x, c, cost);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> dst = cities[city];\n\n  src -= cities[prev];\n  dst -= cities[prev];\n  double computed_arg = abs(arg(src) - arg(dst));\n\n  return (limit_rad >= M_PI - min(computed_arg,\n\t\t\t\t  abs(2.0*M_PI - computed_arg)) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[3001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\t \n\n// #define double long double\n// #define int long long\n#define REP(i, n) for ( int i = 0; i < (n); i++ )\n\n#define EPS (1e-11)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nconst double PI = asinl(1) * 2;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;    \n  }\n};\n\nconst double INF = 1e9;\n\nint N;\ndouble R, Th;\n\nvector<Point> ps;\ndouble dist[20][20][10001];\n\nstruct St {\n  int pre, now, cnt;\n  double cost;\n\n  St(int pre, int now, int cnt, double cost):\n    pre(pre), now(now), cnt(cnt), cost(cost) {}  \n\n  bool operator<( const St& S ) const {\n    return cost < S.cost;    \n  }\n  bool operator>( const St& S ) const {\n    return cost > S.cost;    \n  }  \n};\n\ndouble distPP(Point a, Point b) {\n  return sqrt(pow(a.x-b.x, 2)+pow(a.y-b.y, 2));  \n}\n\ndouble calc_ang(double a1, double a2, double b1, double b2) {\n  double cosT = (a1*b1+a2*b2) / (sqrt(a1*a1+a2*a2)*sqrt(b1*b1+b2*b2));\n  if ( cosT > 1.0 ) cosT = 1.0;\n  if ( cosT < -1.0 ) cosT = -1.0;\n  return acosl(cosT) * 180.0 / PI;  \n}\n\ndouble distP[20][20];\ndouble angP[20][20][20];\n\nvoid solve() {  \n  fill_n(**dist, 20*20*10001, INF);  \n  priority_queue<St, vector<St>, greater<St> > Q;\n  Q.push(St(0, 0, 0, 0));\n  while ( !Q.empty() ) {\n    St q = Q.top(); Q.pop();\n    int pre = q.pre, now = q.now, cnt = q.cnt;\n    double cost = q.cost;\n\n    if ( dist[pre][now][cnt] < INF ) continue;\n    dist[pre][now][cnt] = cost;\n\n    if ( cost > R+EPS ) continue;    \n\n    for ( int i = 0; i < N; i++ ) {    \n      if ( i == now || pre == i ) continue;\n      if ( dist[now][i][cnt+1] < INF ) continue;      \n      double ang = 0;\n      if ( pre != now ) {\n\tang = angP[pre][now][i];\t\n      }\n      if ( ang > Th ) continue;\n      Q.push(St(now, i, cnt+1, cost+distP[i][now]));      \n    }\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N;\n  cin >> R >> Th;\n\n  ps.resize(N);\n  for ( int i = 0; i < N; i++ ) {\n    cin >> ps[i].x >> ps[i].y;    \n  }\n\n  for ( int i = 0; i < N; i++ ) {\n    for ( int j = 0; j < N; j++ ) {\n      distP[i][j] = distPP(ps[i], ps[j]);      \n    }\n  }\n\n  for ( int i = 0; i < N; i++ ) {\n    for ( int j = 0; j < N; j++ ) {\n      for ( int k = 0; k < N; k++ ) {\n\tangP[i][j][k] = calc_ang(ps[j].x-ps[i].x,\n\t\t\t\t ps[j].y-ps[i].y,\n\t\t\t\t ps[k].x-ps[j].x,\n\t\t\t\t ps[k].y-ps[j].y);\n      }\n    }\n  }\n\n  solve();\n\n  int ans = 0;\n  for ( int i = 0; i < N; i++ ) {\n    for ( int j = 0; j < N; j++ ) {\n      for ( int k = 0; k < 10001; k++ ) {\n\tif ( dist[i][j][k] <= R+EPS ) ans = max(ans, k);\n      }\n    }\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct sta{\n  int now;\n  int from;\n  int c;\n  float d;\n};\n\nint main(){\n  int n;\n  float r,th;\n  cin >> n >> r >> th;\n  vector<float> x(n),y(n);\n  rep(i,n) cin >> x[i] >> y[i];\n  vector<vector<float>> d(n,vector<float>(n));\n  rep(i,n){\n    rep(j,n){\n      d[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n    }\n  }\n  th=th*3.1415926535/180;\n  vector<vector<vector<int>>> e(n,vector<vector<int>>(n));\n  rep(i,n){\n    rep(j,n){\n      rep(k,n){\n        if(i!=j&&i!=k){\n          float a = d[j][k];\n          float b = d[i][j];\n          float c = d[i][k];\n          if(acos((a*a-b*b-c*c)/2/b/c)<th) e[i][j].push_back(k);\n        }\n      }\n    }\n  }\n  vector<vector<vector<float>>> dist(n,vector<vector<float>>(n,vector<float>(floor(r)+2,IINF)));\n  priority_queue<sta,vector<sta>,function<bool(sta,sta)>>\n    heap([](const sta &a, const sta &b){return a.d>b.d;});\n  repp(i,1,n){\n    heap.push({i,0,1,d[i][0]});\n  }\n  int ans=0;\n  while(!heap.empty()){\n    sta now = heap.top();\n    heap.pop();\n    if(dist[now.now][now.from][now.c]!=IINF) continue;\n    if(now.d>r) continue;\n    dist[now.now][now.from][now.c]=now.d;\n    ans=max(ans,now.c);\n    for(int &nx:e[now.now][now.from]){\n      if(now.d+d[now.now][nx]>r) continue;\n      if(dist[nx][now.now][now.c+1]!=IINF) continue;\n      heap.push({nx,now.now,now.c+1,now.d+d[now.now][nx]});\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define fs first\n#define sc second\n#define pb push_back\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<D,int> Edge;\ntypedef pair<Edge, pair<int,int> > state;\n\nconst D PI = acos(-1);\nconst D EPS = 1e-8;\n\ninline D dis(D x1, D y1, D x2, D y2){\n  return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\ninline D dot(P x, P y){ return real(conj(x)*y); }\n\ninline D base(P a,P b,P c){ return dot(b-a,c-b)/abs(b-a)/abs(c-b);}\ninline D arg(P a, P b, P c){ return acos(dot(b-a,c-b)/abs(b-a)/abs(c-b)); }\n\nint n;\nD r,s;\nP p[30];\nD d[30][30];\nvector<Edge> g[30][30];\nD lensum[30][30][10100];\n\nint main(){ \n  cin >> n >> r >> s;\n  s *= PI/180;\n  rep(i,n)cin >> p[i].real() >> p[i].imag();\n  rep(i,n){\n    d[i+1][i+1] = 0;\n    for(int j=i+1;j<n;j++){\n      d[i+1][j+1] = d[j+1][i+1] = abs(p[i]-p[j]);\n    }\n  }\n  \n  rep(i,n){\n    if(i)g[0][1].pb(Edge(d[1][i],i));\n  }\n\n  rep(i,n){\n    rep(j,n){\n      if(i==j)continue;\n      rep(k,n){\n\tif(j==k || i==k)continue;\n\tD seta = arg(p[i],p[j],p[k]);\n\tif(abs(base(p[i],p[j],p[k])-1.0)<EPS)seta = 0.0;\n\telse if(abs(base(p[i],p[j],p[k])+1.0)<EPS)seta = PI;\n\tif(seta < s + EPS){\n\t  g[i+1][j+1].pb(Edge(d[j+1][k+1],k+1));\n\t}\n      }\n    }\n  }\n\n  rep(i,n+1)rep(j,n+1)rep(k,10100)lensum[i][j][k] = 1e10;\n  lensum[0][1][0] = 0;\n  priority_queue<state,vector<state>,greater<state> > q;\n  q.push(mk(mk(0,0),mk(0,1)));\n\n  int ans = 0;\n  while(q.size()){\n    state tmp = q.top(); q.pop();\n    D len = tmp.fs.fs;\n    int carrot = tmp.fs.sc+1, prv = tmp.sc.fs, cur = tmp.sc.sc;\n\n    rep(i,g[prv][cur].size()){\n      D cost = g[prv][cur][i].fs;\n      int nxt = g[prv][cur][i].sc;\n\n      if(len + cost > r + EPS)continue;\n      if(lensum[cur][nxt][carrot] > len + cost + EPS){\n\tlensum[cur][nxt][carrot] = len + cost;\n\tq.push(state(mk(len+cost,carrot),mk(cur,nxt)));\n\tans = max(ans,carrot);\n      }\n    }\n  }\t\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef pair<int,int> Pos;\ntypedef pair<pair<double,int>,pair<int,int> > Node; // ??????????????¢??? ????????¶?????????????????????????????????????????????\n\n\n\nconst double PI = 3.141592;\n\nvector<Pos> data;\nint n;\ndouble r;\ndouble th;\n\nbool check(int a,int b,int c){\n    if( a == -1) return true;\n    Pos p1 = data[a];\n    Pos p2 = data[b];\n    Pos p3 = data[c];\n    \n    Pos v1 = Pos(p2.first-p1.first,p2.second-p1.second);\n    Pos v2 = Pos(p3.first-p2.first,p3.second-p2.second);\n\n    double v1Length = sqrt(v1.first * v1.first + v1.second * v1.second);\n    double v2Length = sqrt(v2.first * v2.first + v2.second * v2.second);\n\n\n    double tmpTh =(acos((v1.first * v2.first + v1.second * v2.second )/(v1Length * v2Length)) * 180/PI);\n/*    cout << endl;\n    cout << a << \" \" << b<< \" \"<< c <<\" \" << tmpTh <<endl;\n    cout << (v1.first * v2.first + v1.second * v2.second )/(v1Length * v2Length) << endl;\n    cout << acos((v1.first * v2.first + v1.second * v2.second )/(v1Length * v2Length)) << endl;\n    cout << (acos((v1.first * v2.first + v1.second * v2.second )/(v1Length * v2Length)) * 180/PI) << endl;\n  */  if(th -tmpTh >= 0){\n    //    cout << \"th\" << th << \" tmpTh\" << tmpTh << \" res:\" <<th-tmpTh <<endl;\n     //   cout << \"true\" << endl;\n        return true;\n    }\n //   cout << \"false\" << endl;\n    return false;\n}\n\nint main(){\n    cin >> n >> r >> th;\n    for(int i =0;i<n;++i){ \n        int a,b;\n        cin >> a >> b;\n        data.push_back(Pos(a,b));\n    }\n\n    priority_queue<Node,std::vector<Node>, std::greater<Node> > que;\n    que.push(Node(pair<double,int>(0,-1),pair<int,int>(0,0) ) );\n    int res =0;\n    \n    while(!que.empty()){\n   //     cout << \"hoge\" << endl;\n        Node node = que.top();\n        que.pop();\n        int nowIsland = node.second.second;\n        int beforeIsland = node.first.second;        \n        double nowCost = node.first.first;\n        int nowCarrot = node.second.first;\n        Pos nowPos = data[nowIsland];\n    //    cout << nowCost << endl;\n   //     cout << beforeIsland << \" \" << nowIsland << endl;\n        for(int i=0;i<n;++i){\n            if(i == nowIsland) continue;\n                //???????????????\n            Pos nextPos = data[i];\n            if(check(beforeIsland,nowIsland,i) ) {\n                int a = nowPos.first - nextPos.first;\n                int b = nowPos.second - nextPos.second;\n                \n                double nextCost = nowCost + sqrt(a*a+b*b);\n                if(nextCost <= r){\n             //       cout << nowCost << \" \" << nextCost << endl;\n                    que.push(Node(pair<double,int>(nextCost,nowIsland),pair<int,int>(nowCarrot+1,i)));\n                    res = max(res,nowCarrot+1);\n                }\n            }\n\n        }\n\n    }\n    \n    cout << res << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\n\ndouble dp[22][22][11111], dist[22][22][22];\nint main()\n{\n\tint n; ld r, th;\n\tcin >> n >> r >> th;\n\tvector<Point> ps;\n\tREP(i, n)\n\t{\n\t\tld x, y; cin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\tREP(i, n)REP(j, n)REP(k, n)\n\t{\n\t\tPoint pre = ps[i], now = ps[j], next = ps[k];\n\t\tPoint v1 = now - pre, v2 = next - now;\n\t\tif (i == j || j == k || i == k)\n\t\t{\n\t\t\tdist[i][j][k] = INF;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tld lhs = dot(v1, v2), rhs = abs(v1)*abs(v2)*cos(th / 180.0 * PI);\n\t\t\tif (lhs - rhs > -EPS) dist[i][j][k] = abs(v2);\n\t\t\telse dist[i][j][k] = INF;\n\t\t}\n\t}\n\tREP(i, 22)REP(j, 22)REP(k, 11111) dp[i][j][k] = INF;\n\tdp[0][0][0] = 0;\n\tFOR(i, 1, n) dp[0][i][1] = abs(ps[i] - ps[0]);\n\tFOR(k, 1, 11111)REP(i, n)REP(j, n)\n\t{\n\t\tREP(l, n)\n\t\t{\n\t\t\tif (dist[i][j][l] == INF) continue;\n\t\t\telse chmin(dp[j][l][k + 1], dp[j][l][k] + dist[i][j][l]);\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, 22)REP(j, 22)REP(k, 1111)\n\t{\n\t\tif (dp[i][j][k] <= r) chmax(ans, k);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int MAX = 20,LIMIT = 30000,IINF = INT_MAX;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nstruct Edge{\n  int to;\n  double weight;\n  Edge(int to=0,double weight=0):to(to),weight(weight){}\n};\n\nstruct Data{\n  int prev,cur,carrot;\n  double dist;\n  Data(int prev=0,int cur=0,int carrot=0,double dist=0):prev(prev),cur(cur),carrot(carrot),dist(dist){}\n  bool operator < (const Data& data) const{ return dist > data.dist; }\n};\n\nint n;\ndouble r,theta,mindist[MAX][MAX][LIMIT]; // mindist[cur][prev][the number of carrot]\nPoint ps[MAX];\nvector<Edge> edge[MAX][MAX]; // edge[cur][prev]\n\ninline void dijkstra(){\n  rep(i,n)rep(j,n)rep(k,LIMIT) mindist[i][j][k] = IINF;\n  priority_queue<Data> Q;\n\n  REP(i,1,n) {\n    double dist = abs(ps[0]-ps[i]);\n    if( !equals(dist,r) && dist > r ) continue;\n    Q.push(Data(0,i,1,dist));\n    mindist[i][0][1] = dist;\n  }\n  int ans = (Q.empty()?0:1);\n\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n    int prev = data.prev, cur = data.cur, carrot = data.carrot;\n    double dist = data.dist;\n\n    if( !equals(mindist[cur][prev][carrot],dist) && mindist[cur][prev][carrot] < dist ) continue;\n\n    rep(i,edge[cur][prev].size()) {\n      int next = edge[cur][prev][i].to;\n      double weight = edge[cur][prev][i].weight;\n      if( !equals(r,dist+weight) && r < dist+weight ) continue;\n      if( mindist[next][cur][carrot+1] > dist + weight ){\n        mindist[next][cur][carrot+1] = dist + weight;\n        assert(carrot+1 < LIMIT);\n        ans = max(ans,carrot+1);\n        Q.push(Data(cur,next,carrot+1,dist+weight));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\ninline void makeEdge(){\n  rep(prev,n){\n    rep(cur,n){\n      if( cur == prev ) continue;\n      rep(next,n){\n        if( next == cur || next == prev ) continue;\n        double dist = abs(ps[cur]-ps[next]);\n        if( !equals(dist,r) && dist > r ) continue;\n        Vector v1 = ps[next] - ps[cur];\n        Vector v2 = ps[cur]  - ps[prev];\n        if( equals(cross(v1,v2),0.0) ) continue;\n        double arg = getArg(ps[prev],ps[cur],ps[next]);\n        if( equals(arg,theta) || arg < theta ) edge[cur][prev].push_back(Edge(next,dist));\n      }\n    }\n  }\n}\n\nint main(){\n\n  /*\n  int next = 2, cur = 1, prev = 0;\n  ps[0] = Point(0,0);\n  ps[1] = Point(10,0);\n  ps[2] = Point(0,1);\n  double arg =  getArg(ps[prev],ps[cur],ps[next]);\n  cout << \"arg = \" << arg * 180.0 / M_PI << endl;\n  */\n\n  cin >> n;\n  cin >> r >> theta;\n  theta = toRad(theta);\n  rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n\n  makeEdge();\n\n  dijkstra();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define EPS 1.0e-9\n#define inf 1000000000\n\nusing namespace std;\nstruct edge{\n\tint toi, toj;\n\tdouble cost;\n\tedge(int a, int b, double c){\n\t\ttoi = a, toj = b, cost = c;\n\t}\n};\n\nint n;\ndouble r, th;\nint x[25], y[25];\nvector<edge> G[25][25];\ndouble dp[10005][25][25];\n\ndouble dot(double x1, double y1, double x2, double y2)\n{\n\treturn x1 * x2 + y1 * y2;\n}\n\ndouble norm(double x, double y)\n{\n\tdouble d2 = x*x + y*y;\n\tif(d2 == 0) return 0.0;\n\treturn sqrt(d2);\n}\n\nint main(void)\n{\n\tcin >> n >> r >> th;\n\tfor(int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\t\n\tdouble lcos = cos(th * M_PI / 180.0);\n\t\n\tdouble dx1, dx2, dy1, dy2;\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i == j) continue;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(j == k) continue;\n\t\t\t\t\n\t\t\t\tdx1 = x[j]-x[i], dy1 = y[j]-y[i];\n\t\t\t\tdx2 = x[k]-x[j], dy2 = y[k]-y[j];\n\t\t\t\tif( dot(dx1, dy1, dx2, dy2) / norm(dx1, dy1) / norm(dx2, dy2) >= lcos){\n\t\t\t\t\tG[i][j].push_back( edge(j, k, norm(dx2, dy2) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tfor(int i = 0; i <= r; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tdp[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i < n; i++) dp[1][0][i] = norm(x[i]-x[0], y[i]-y[0]);\n\t\n\t\n\tfor(int i = 1; i < r; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tfor(int l = 0; l < G[j][k].size(); l++){\n\t\t\t\t\tdp[i+1][G[j][k][l].toi][G[j][k][l].toj] = min(dp[i+1][G[j][k][l].toi][G[j][k][l].toj], dp[i][j][k] + G[j][k][l].cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = r; i >= 0; i--){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(dp[i][j][k] <= r){\n\t\t\t\t\tans = i;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tend:;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\nstruct P{\n  double cost;\n  int pos,pre,num;\n  P(double cost,int pos,int pre,int num):cost(cost),pos(pos),pre(pre),num(num){}\n  bool operator < (const P &a) const{return cost<a.cost;} \n};\ntypedef complex<double> point;\npoint z[21];\nint n;\ndouble r,x;\nvector <P> e[21][21];\nbool check(point a,point b){\n  a*=conj(b);\n    return 180.0*(abs(arg(a))/M_PI)<=x;\n}\n\ndouble D[10001][21][21];\nint dijkstra(){\n  int res=0;\n  for(int i=0;i<10001;i++)for(int j=0;j<n;j++)for(int k=0;k<n;k++) D[i][j][k]=INF;\n  priority_queue<P> Q; \n  Q.push(P(0,0,0,0));\n  D[0][0][0]=0;\n\n  while(!Q.empty()){\n    P t=Q.top();Q.pop();\n    double cost=t.cost;\n    int pos=t.pos,pre=t.pre,num=t.num;\n    if(cost>r) continue;\n    if(D[num][pos][pre]<cost) continue;\n    res=max(res,num);\n    for(int i=0;i<e[pos][pre].size();i++){\n      int nx=e[pos][pre][i].pos;\n      double ncost=cost+e[pos][pre][i].cost;\n      double &a=D[num+1][nx][pos];\n      if(a>ncost){\n\tQ.push(P(ncost,nx,pos,num+1));\n\ta=ncost;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>n>>r>>x;\n  for(int i=0;i<n;i++){\n    double a,b;\n    cin>>a>>b;\n    z[i]=point(a,b);\n  }\n\n  for(int i=0;i<n;i++) //pos\n    for(int j=0;j<n;j++)//pre\n      for(int k=0;k<n;k++){ // to\n\tdouble cost=abs(z[i]-z[k]);\n\tif(i!=k&&i!=j&&check(z[i]-z[j],z[k]-z[i]))e[i][j].push_back(P(cost,k,0,0));\n      }\n\n  for(int i=1;i<n;i++)e[0][0].push_back(P(abs(z[0]-z[i]),i,0,0));\n  cout <<dijkstra()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#define scanf_s scanf\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\n\nint main(void){\n\tint n,ans,i,j,k,ok;\n\tdouble r,sit;\n\tdouble x[20];\n\tdouble y[20];\n\tdouble dp[20][20]={0};//x??????y????????????\n\tdouble dpc[20][20]={0};\n\tdouble d;\n\tdouble pi=3.141592653589793238462643383279502884197;\n\tscanf(\"%d\",&n);\n\tscanf(\"%lf %lf\",&r,&sit);\n\tsit=(sit/180)*pi;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i][j]=0;\n\t\t\tdpc[i][j]=big;\n\t\t}\n\t}\n\tfor(ans=0;;ans++){\n\t\tfor(k=0;k<n;k++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(ans!=0&&(k-i)*(i-j)==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(j-k==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(ans==0&&k!=0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td=abs(atan2(y[i]-y[k],x[i]-x[k])-atan2(y[k]-y[j],x[k]-x[j]));\n\t\t\t\t\tif(ans!=0&&min(2*pi-d,d)>sit){continue;}\n\t\t\t\t\tdpc[k][j]=min(dpc[k][j],dp[i][k]+hypot(x[k]-x[j],y[k]-y[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tdp[i][j]=dpc[i][j];\n\t\t\t\tif(dpc[i][j]<r){\n\t\t\t\t\tok=1;\n\t\t\t\t}\n\t\t\t\tdpc[i][j]=big;\n\t\t\t}\n\t\t}\n\t\tif(ok==0){break;}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\n\ninline double dist(int i,int j){\n\tint dx=(x[i]-x[j]);\n\tint dy=(y[i]-y[j]);\n\treturn sqrt(1.0*dx*dx+1.0*dy*dy);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tdouble r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tdp[0][0][n]=0.0;\n\n\trep(i,limit)rep(cp,n)rep(pp,n+1){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(i>0&&pp==n) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tdouble add=dist(cp,np);\n\t\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\t\tdouble dot=1.0*cx*nx+1.0*cy*ny;\n\t\t\tdot/=(dist(cp,pp)*dist(np,cp));\n\t\t\tdouble angle=acos(dot);\n\t\t\tangle*=180.0/pi;\n\n\t\t\tif(angle>180.0) angle=360.0-angle;\n\t\t\tif(pp!=n&&angle>theta) continue;\n\t\t\tif(dp[i][cp][pp]+add-r>eps) continue;\n\t\t\tdp[i+1][np][cp]=min(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,limit+1)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]<=r) ans=max(ans,i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(const deque<int>& deq,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[deq[0]];\n  complex<double> mid = cities[deq[1]];\n  complex<double> dst = cities[deq[2]];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _c,double _r,const deque<int>& _d) :\n    city(_ct), carrots(_c), remaining_distance(_r),deq(_d) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    deq.push_back(_d);\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[5001][9000]; //dp[carrot][visit history] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      while(s.deq.size() > 3) s.deq.pop_front();\n      int history = 0;\n      int digit = 1;\n\n      for(int i=0;i<s.deq.size();i++){\n\thistory += (s.deq[i]+1) * digit;\n\tdigit *= 21;\n      }\n\n      if(dp[s.carrots][history]) continue;\n      dp[s.carrots][history] = true;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\t\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tdeque<int> deq = s.deq;\n\t\n\tdeq.push_back(to);\n\twhile(deq.size() > 3) deq.pop_front();\n\n\tif(deq.size()==3){\n\t  if(!check(deq,limit_rad,cities)) continue;\n\t}\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tque.push(State(to,s.carrots+1,s.remaining_distance - dist,deq));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define fs first\n#define sc second\n#define pb push_back\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<D,int> Edge;\ntypedef pair<Edge, pair<int,int> > state;\n\nconst D PI = acos(-1);\nconst D EPS = 1e-8;\n\ninline D dis(D x1, D y1, D x2, D y2){\n  return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\ninline D dot(P x, P y){ return real(conj(x)*y); }\n\ninline D base(P a,P b,P c){ return dot(b-a,c-b)/abs(b-a)/abs(c-b);}\ninline D arg(P a, P b, P c){ return acos(dot(b-a,c-b)/abs(b-a)/abs(c-b)); }\n\nint n;\nD r,s;\nP p[21];\nD d[21][21];\nvector<Edge> g[21][21];\nD lensum[21][21][10001];\n\nint main(){ \n  cin >> n >> r >> s;\n  s *= PI/180;\n  rep(i,n)cin >> p[i].real() >> p[i].imag();\n  rep(i,n){\n    d[i+1][i+1] = 0;\n    for(int j=i+1;j<n;j++){\n      d[i+1][j+1] = d[j+1][i+1] = abs(p[i]-p[j]);\n    }\n  }\n  \n  rep(i,n){\n    if(i)g[0][1].pb(Edge(d[1][i+1],i+1));\n  }\n\n  rep(i,n){\n    rep(j,n){\n      if(i==j)continue;\n      rep(k,n){\n\tif(j==k || i==k)continue;\n\tD seta = arg(p[i],p[j],p[k]);\n\tif(abs(base(p[i],p[j],p[k])-1.0)<EPS)seta = 0.0;\n\telse if(abs(base(p[i],p[j],p[k])+1.0)<EPS)seta = PI;\n\tif(seta < s + EPS){\n\t  g[i+1][j+1].pb(Edge(d[j+1][k+1],k+1));\n\t}\n      }\n    }\n  }\n\n  rep(i,n+1)rep(j,n+1)rep(k,10001)lensum[i][j][k] = 1e10;\n  lensum[0][1][0] = 0;\n  priority_queue<state,vector<state>,greater<state> > q;\n  q.push(mk(mk(0,0),mk(0,1)));\n\n  int ans = 0;\n  while(q.size()){\n    state tmp = q.top(); q.pop();\n    D len = tmp.fs.fs;\n    int carrot = tmp.fs.sc+1, prv = tmp.sc.fs, cur = tmp.sc.sc;\n\n    rep(i,g[prv][cur].size()){\n      D cost = g[prv][cur][i].fs;\n      int nxt = g[prv][cur][i].sc;\n      if(len + cost > r + EPS)continue;\n      if(lensum[cur][nxt][carrot] > len + cost + EPS){\n\tlensum[cur][nxt][carrot] = len + cost;\n\tq.push(mk(mk(len+cost,carrot),mk(cur,nxt)));\n\tans = max(ans,carrot);\n      }\n    }\n  }\t\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 1000000007\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n \nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n \ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==(int)v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<typename T1,typename T2>\nistream &operator>>(istream &is,pair<T1,T2>&p){\n    is>>p.first>>p.second;\n    return is;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T>&v){\n    for(T &x:v)is>>x;\n    return is;\n}\n\n\n//////////////////////////////////////////////////////\nusing Real=double;\nusing Point=complex<Real>;\nconst Real EPS=1e-10;\nconst Real pi=acosl(-1);\n//入出力補助\nistream &operator>>(istream &is,Point &p){\n    Real a,b;\n    is>>a>>b;\n    p=Point(a,b);\n    return is;\n}\nostream &operator<<(ostream &os,Point &p){\n    return os<<fixed<<setprecision(12)<<p.real()<<' '<<p.imag();\n}\n \ninline bool eq(Real a,Real b){\n    return fabs(a-b)<EPS;\n}\nPoint operator*(const Point &p,const Real &d){\n    return Point(real(p)*d,imag(p)*d);\n}\nstruct Line{\n    Point p1,p2;\n    Line()=default;\n    Line(Point p1,Point p2):p1(p1),p2(p2){}\n \n    //Ax + By = C\n    Line(Real A,Real B,Real C){\n       if(eq(A,0))     p1=Point(0,C/B),p2=Point(1,C/B);\n       else if(eq(B,0))p1=Point(C/A,0),p2=Point(C/A,1);\n       else            p1=Point(0,C/B),p2=Point(C/A,0);\n    }\n};\nstruct Segment:Line{\n   Segment()=default;\n   Segment(Point p1,Point p2):Line(p1,p2){}\n};\nstruct Circle{\n    Point center;\n    Real r;\n    Circle()=default;\n    Circle(Point center,Real r):center(center),r(r){}\n};\n/////////////////////////////////////////////////////////\n \n \n// 点 p を反時計回りに theta 回転\nPoint rotate(Real theta,const Point &p) {\n    return Point(cos(theta)*p.real()-sin(theta)*p.imag(),sin(theta)*p.real()+cos(theta)*p.imag());\n}\n \nReal radian_to_degree(Real r){\n    return r*180.0/pi;\n}\n \nReal degree_to_radian(Real d){\n    return d*pi/180.0;\n}\n \n//三角形の面積，サラスの公式\nReal area_triangle(Point a,Point b,Point c){\n    Point x=b-a,y=c-a;\n    return fabs(x.real()*y.imag()-x.imag()*y.real())/2;\n}\n \n//v\n//外積\nReal cross(Point a,Point b){\n    return real(a)*imag(b)-imag(a)*real(b);\n}\n//v\n//内積\nReal dot(Point a,Point b) {\n    return real(a)*real(b)+imag(a)*imag(b);\n}\n \n//v\n//平行判定，外積0かをみる\nbool parallel(Line a,Line b){\n    return eq(cross(a.p1-a.p2,b.p1-b.p2),0.0);\n}\n//v\n//垂直判定，内積0かをみる\nbool orthogonal(Line a,Line b){\n    return eq(dot(a.p1-a.p2,b.p1-b.p2),0.0);\n}\n \n//v\n//正射影，pからlに下した垂線の足を求める\nPoint projection(Line l,Point p){\n    //ベクトルl上のどの位置に垂線の足が来るか求める\n    Real k=dot(l.p1-l.p2,p-l.p1)/norm(l.p1-l.p2);\n    return l.p1+(l.p1-l.p2)*k;\n}\nPoint projection(Segment l,Point p){\n    Real k=dot(l.p1-l.p2,p-l.p1)/norm(l.p1-l.p2);\n    return l.p1+(l.p1-l.p2)*k;\n}\n \n//v\n//反射，直線lに関し点pと線対称な点を返す\nPoint reflection(Line l,Point p){\n    Point h=projection(l,p);\n    return (p+(h-p)+(h-p));\n}\nPoint reflection(Segment l,Point p){\n    Point h=projection(l,p);\n    return (p+(h-p)+(h-p));\n}\n \n//二点間の距離\nReal dis(Point a,Point b){\n    return abs(a-b);\n} \n//点と直線の距離\nReal dis(Line l,Point p){\n    return abs(p-projection(l,p));\n}\n \n//v\n//COUNTER CLOCKWISE，返す値は↓を参照\n//https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/all/CGL_1_C\nint ccw(Point a,Point b,Point c){\n    b-=a;c-=a;\n    if(cross(b,c)>EPS)       return  1;//COUNTER CLOCKWISE\n    else if(cross(b,c)<-EPS) return -1;//CLOCKWISE\n    else if(dot(b,c)<0)      return  2;//c--a--b ONLINE BACK\n    else if(norm(b)<norm(c)) return -2;//a--b--c ONLINE FRONT\n    else                     return  0;//a--c--b ON SEGMENT\n}\n \n//v\n//3点が作る三角形の外心\n//面積0の三角形を渡すと分母に面積があるので壊れるかも\nPoint circumcenter(Point A,Point B,Point C){\n    Real S=area_triangle(A,B,C);\n    Real a=dis(B,C),b=dis(A,C),c=dis(A,B);\n    return A*(a*a*(b*b+c*c-a*a)/(16*S*S))+B*(b*b*(c*c+a*a-b*b)/(16*S*S))+C*(c*c*(a*a+b*b-c*c)/(16*S*S));\n}\n \n//交差判定\n//直線状に乗るか\nbool intersect(Line l,Point p){\n    return abs(ccw(l.p1,l.p2,p))!=1;\n}\n//直線の交差判定，外積\nbool intersect(Line l1,Line l2){\n    return abs(cross(l1.p2-l1.p1,l2.p2-l2.p1))>EPS or\n        abs(cross(l1.p2-l1.p1,l2.p2-l1.p1))<EPS;\n}\n//線分に点が乗るかの判定，ccw\nbool intersect(Segment s,Point p){\n    return ccw(s.p1,s.p2,p)==0;\n}\n//直線と線分の交差判定\nbool intersect(Line l,Segment s){\n    return cross(l.p2-l.p1,s.p1-l.p1)*cross(l.p2-l.p1,s.p2-l.p1)<EPS;\n}\n//円と直線の交差判定\nbool intersect(Circle c,Line l){\n    return dis(l,c.center)<=c.r+EPS;\n}\n//円上かどうか，内部かどうかではない\nbool intersect(Circle c,Point p){\n    return abs(abs(p-c.center)-c.r)<EPS;\n}\n//v\n//線分と線分の交差判定\nbool intersect(Segment s,Segment t){\n    return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <=0 and\n        ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2)<=0;\n}\n//線分と円の交差判定，交点の個数を返す\nint intersect(Circle c,Segment l){\n    Point h=projection(l,c.center);\n    //直線まるっと円の外側\n    if(norm(h-c.center)-c.r*c.r>EPS)    return 0;\n    Real d1=abs(c.center-l.p1),d2=abs(c.center-l.p2);\n    //線分が円内\n    if(d1<c.r+EPS and d2<c.r+EPS) return 0;\n    if((d1<c.r-EPS and d2>c.r+EPS) or (d2<c.r-EPS and d1>c.r+EPS)) return 1;\n    //円の外部にまるまるはみ出ていないか\n    if(dot(l.p1-h,l.p2-h)<0) return 2;\n    return 0;\n}\n//円と円の位置関係，共通接線の個数を返す\nint intersect(Circle c1,Circle c2){\n    if(c1.r<c2.r) swap(c1,c2);\n    Real d=abs(c1.center-c2.center);\n    //2円が離れている\n    if(c1.r+c2.r<d)     return 4;\n    //2円が外接する\n    if(eq(c1.r+c2.r,d)) return 3;\n    //2円が交わる\n    if(c1.r-c2.r<d)     return 2;\n    //円が内接する\n    if(eq(c1.r-c2.r,d)) return 1;\n    //内包\n                        return 0;\n}\n \n//交点\n//線分の交点はintersectをチェックしてokなら直線の交点をやる\n//intersectをチェックすること\n//v\nPoint crosspoint(Line l,Line m){\n    Real A=cross(m.p2-m.p1,m.p1-l.p1);\n    Real B=cross(m.p2-m.p1,l.p2-l.p1);\n    if(eq(A,0) and eq(B,0)) return l.p1;\n    if(eq(B,0))             throw \"NAI\";\n    return l.p1+A/B*(l.p2-l.p1);    \n}\nPoint crosspoint(Segment l,Segment m){\n    return crosspoint(Line(l),Line(m));\n}\nvector<Point> crosspoint(Circle c,Line l){\n    vector<Point> ret;\n    Point h=projection(l,c.center);\n    Real d=sqrt(c.r*c.r-norm(h-c.center));\n    Point e=(l.p2-l.p1)*(1/abs(l.p2-l.p1));\n    if(c.r*c.r+EPS<norm(h-c.center)) return ret;\n    if(eq(dis(l,c.center),c.r)){\n        ret.push_back(h);\n        return ret;\n    }\n    ret.push_back(h+e*d);ret.push_back(h-e*d);\n    return ret;\n}\n//要verify，\nvector<Point> crosspoint(Circle c,Segment s){\n    Line l=Line(s.p1,s.p2);\n    int ko=intersect(c,s);\n    if(ko==2) return crosspoint(c,l);\n    vector<Point> ret;\n    if(ko==0) return ret;\n    ret=crosspoint(c,l);\n    if(ret.size()==1) return ret;\n    vector<Point> rret;\n    //交点で挟める方を返す\n    if(dot(s.p1-ret[0],s.p2-ret[0])<0)  rret.push_back(ret[0]);\n    else                                rret.push_back(ret[1]);\n    return rret;\n}\n//v\nvector<Point> crosspoint(Circle c1,Circle c2){\n    vector<Point> ret;\n    int isec=intersect(c1,c2);\n    if(isec==0 or isec==4) return ret;\n    Real d=abs(c1.center-c2.center);\n    Real a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    Real t=atan2(c2.center.imag()-c1.center.imag(),c2.center.real()-c1.center.real());\n    ret.push_back(c1.center+Point(cos(t+a)*c1.r,sin(t+a)*c1.r));\n    ret.push_back(c1.center+Point(cos(t-a)*c1.r,sin(t-a)*c1.r));\n    return ret;\n}\n \n//v\n//点pから引いた円cの接線の接点を返す\nvector<Point> tangent(Circle c,Point p){\n    return crosspoint(c,Circle(p,sqrt(norm(c.center-p)-c.r*c.r)));\n}\n//v\n//二円の共通接線，Lineの2点は接点を表す\nvector<Line> tangent(Circle c1,Circle c2){\n    vector<Line> ret;\n    if(c1.r<c2.r) swap(c1,c2);\n    Real g=norm(c1.center-c2.center);\n    //中心が一致するならない\n    if(eq(g,0)) return ret;\n    Point u=(c2.center-c1.center)/sqrt(g);\n    Point v=rotate(pi*0.5,u);\n    for(int s:{-1,1}){\n        Real h=(c1.r+s*c2.r)/sqrt(g);\n        if(eq(1-h*h,0)){\n            ret.push_back(Line(c1.center+u*c1.r,c1.center+(u+v)*c1.r));\n        }\n        else if(1-h*h>0){\n            Point uu=u*h,vv=v*sqrt(1-h*h);\n            ret.push_back(Line(c1.center+(uu+vv)*c1.r,c2.center-(uu+vv)*c2.r*s));\n            ret.push_back(Line(c1.center+(uu-vv)*c1.r,c2.center-(uu-vv)*c2.r*s));\n        }\n    }\n    return ret;\n}\n \n//v\n//最小包含円を返す　計算量は期待値O(n)\nCircle MinimumBoundingCircle(vector<Point> v){\n    int n=v.size();\n  \n    //ランダムシャッフル．いぢわるされたくないもんだ\n    mt19937 mt(time(0));\n    shuffle(v.begin(),v.end(),mt);\n    Circle ret(0,0);\n    //2点で円を作る\n    auto make_circle2=[&](Point a,Point b){\n        return Circle((a+b)*0.5,dis(a,b)/2);\n    };\n    //3点で円を作る\n    auto make_circle3=[&](Point A,Point B,Point C){\n        Point cent=circumcenter(A,B,C);\n        return Circle(cent,dis(cent,A));\n    };\n    auto isIn=[&](Point a){\n        return dis(ret.center,a)<ret.r+EPS;\n    };\n \n    ret=make_circle2(v[0],v[1]);\n    for(int i=2;i<n;i++){\n        //v[i]が円に入っていないなら\n        if(!isIn(v[i])){\n            //円内にないなら点v[i]は必ず円周上に来る\n            ret=make_circle2(v[0],v[i]);\n            for(int j=1;j<i;j++){\n                if(!isIn(v[j])){\n                    //この時iとjが円周上を考える\n                    ret=make_circle2(v[i],v[j]);\n                    //最後の1点の決定\n                    for(int k=0;k<j;k++){\n                        if(!isIn(v[k])){\n                            ret=make_circle3(v[i],v[j],v[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return ret;\n}\n \n// v\n// 最近点対\nReal closest_pair(vector<Point> ps){\n    sort(ALL(ps),[&](Point a,Point b){\n        return real(a)<real(b);\n    });\n \n    function<Real(int,int)> rec=[&](int l,int r){\n        if(r-l<=1) return 1e18;\n        int m=(l+r)/2;\n        Real x=real(ps[m]);\n        Real ret=min(rec(l,m),rec(m,r));\n        inplace_merge(begin(ps)+l,begin(ps)+m,begin(ps)+r,[&](Point a,Point b){\n            return imag(a)<imag(b);\n        });\n        // 分割を跨いで最小距離があるか調べる\n        vector<Point> b;\n        for(int i=l;i<r;i++){\n            if(abs(real(ps[i])-x)>=ret) continue;\n            for(int j=(int)b.size()-1;j>=0;j--){\n                if(abs(imag(ps[i]-b[j]))>=ret) break;\n                ret=min(ret,abs(ps[i]-b[j]));\n            }\n            b.push_back(ps[i]);\n        }\n        return ret;\n    };\n    return rec(0,(int)ps.size());\n}\n\n\n\n\n\nReal dp[21][21][10010];\nbool f[21][21][21];\n\nsigned main(){\n    int n;cin>>n;\n    Real r,theta;cin>>r>>theta;\n    vector<Point> v(n);\n    cin>>v;\n\n    theta=degree_to_radian(theta);    \n\n    auto check=[&](const Point &a,const Point &b,const Point &c){\n        // a->b->c\n        Point A=b-a,B=c-b;\n        Real omega=arg(B)-arg(A);\n        omega=abs(omega);\n        if(omega-pi>=0)omega=2.0*pi-omega;\n        return omega;\n    };\n\n    rep(i,n)rep(j,n)rep(k,n)if(i!=j and j!=k)if(check(v[i],v[j],v[k])<=theta+EPS)f[i][j][k]=true;\n    rep(i,21)rep(j,21)rep(k,10010)dp[i][j][k]=INF;\n    for(int i=1;i<n;i++)dp[0][i][0]=dis(v[0],v[i]);\n    {\n        bool f=false;\n        rep(i,n)rep(j,n)if(dp[i][j][0]<=r+EPS)f=true;\n        if(!f){\n            cout<<0<<endl;\n            return 0;       \n        }\n    }\n    rep(k,10010){\n        Real mi=INF;\n        rep(i,n)rep(j,n)rep(l,n)if(f[i][j][l]){\n            chmin(dp[j][l][k+1],dp[i][j][k]+dis(v[j],v[l]));\n            chmin(mi,dp[j][l][k+1]);\n        }\n        if(mi>r+EPS){\n            cout<<k+1<<endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#define EPS 1e-10\nusing namespace std;\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\n\nint n;\ndouble r,ang;\nP p[21];\nstruct edge{\n\tint t;\n\tdouble c;\n\tedge(){}\n\tedge(int tt,double cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\nvector<edge> G[21][21];\n\ndouble dist(int a,int b){\n\treturn sqrt(pow(p[a].x-p[b].x,2)+pow(p[a].y-p[b].y,2));\n}\n\nstruct data{\n\tint v,p,cnt;\n\tdouble c;\n\tdata(){}\n\tdata(int vv,int pp,int cntt,double cc){\n\t\tv=vv;\n\t\tp=pp;\n\t\tcnt=cntt;\n\t\tc=cc;\n\t}\n\tbool operator<(const data& d1)const{\n\t\treturn c>d1.c;\n\t}\n};\n\ndouble cost[21][21][10001];\nint dijk(){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=10000;k++){\n\t\t\t\tcost[i][j][k]=r+1.0;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<data> que;\n\tque.push(data(1,0,0,0.0));\n\tcost[1][0][0]=0.0;\n\tint res=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(cost[q.v][q.p][q.cnt]<q.c)continue;\n\t\tres=max(res,q.cnt);\n\t\tfor(int i=0;i<G[q.v][q.p].size();i++){\n\t\t\tedge e=G[q.v][q.p][i];\n\t\t\tif(cost[e.t][q.v][q.cnt+1]>cost[q.v][q.p][q.cnt]+e.c){\n\t\t\t\tcost[e.t][q.v][q.cnt+1]=cost[q.v][q.p][q.cnt]+e.c;\n\t\t\t\tque.push(data(e.t,q.v,q.cnt+1,cost[e.t][q.v][q.cnt+1]));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tscanf(\"%lf %lf\",&r,&ang);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lf %lf\",&p[i].x,&p[i].y);\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(j==k)continue;\n\t\t\t\tif(i==0){\n\t\t\t\t\tG[j][i].push_back(edge(k,dist(j,k)));\n\t\t\t\t}else{\n\t\t\t\t\tdouble aa=(p[j]-p[i]).dot(p[k]-p[j])/(dist(j,i)*dist(j,k));\n\t\t\t\t\tif(aa>=cos(ang*M_PI/180.0)){\n\t\t\t\t\t\tG[j][i].push_back(edge(k,dist(j,k)));\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tprintf(\"%d%d \",j,i);\n\t\t\tfor(int k=0;k<G[j][i].size();k++){\n\t\t\t\tprintf(\"%d \",G[j][i][k].t);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t*/\n\tprintf(\"%d\\n\",dijk());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <complex>\n\nusing Real = long double;\nusing Point = std::complex<Real>;\nusing Segment = std::pair<Point, Point>;\n\nconst Real PI = acos(-1);\nconst Real EPS = 1e-10;\n\nstd::istream& operator>>(std::istream& is, Point& p) {\n    Real x, y;\n    is >> x >> y;\n    p = Point(x, y);\n    return is;\n}\n\ninline int compare(Real a, Real b) {\n    if (std::abs(a - b) < EPS) return 0;\n    return a - b > 0 ? 1 : -1;\n}\n\ninline Real dist(Point a, Point b) {\n    return std::abs(a - b);\n}\n\ninline Real dot(Point x, Point y) {\n    return std::real(std::conj(x) * (y));\n}\n\n\nusing namespace std;\n\nint main() {\n    int N;\n    Real r, theta;\n    cin >> N >> r >> theta;\n    theta *= PI / 180;\n\n    vector<Point> ps(N);\n    for (auto& p : ps) cin >> p;\n\n    vector<vector<Real>> d(N * N, vector<Real>(N * N, 1e50));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (i == j) continue;\n            for (int k = 0; k < N; ++k) {\n                if (j == k) continue;\n\n                Real costheta = dot(ps[j] - ps[i], ps[k] - ps[j]) / (dist(ps[j], ps[i]) * dist(ps[k], ps[j]));\n                if (costheta < -1) costheta += EPS;\n                if (costheta > 1) costheta -= EPS;\n                if (compare(acos(costheta), theta) > 0) continue;\n\n                d[i * N + j][j * N + k] = dist(ps[j], ps[k]);\n            }\n        }\n    }\n\n    vector<vector<Real>> dp(N * N, vector<Real>(10001, 1e100));\n    // dp[i][j][n] = 直前i、今jにいて、既にk箇所訪れたときの最短距離\n\n    for (int i = 1; i < N; ++i) {\n        dp[i][1] = dist(ps[0], ps[i]);\n    }\n\n    for (int n = 1; n < 10000; ++n) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (i == j) continue;\n                for (int k = 0; k < N; ++k) {\n                    if (j == k) continue;\n\n                    dp[j * N + k][n + 1] = min(dp[j * N + k][n + 1], dp[i * N + j][n] + d[i * N + j][j * N + k]);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int v = 0; v < N * N; ++v) {\n        for (int n = 0; n <= 10000; ++n) {\n            if (compare(dp[v][n], r) <= 0) ans = max(ans, n);\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing point = complex<double>;\n\nconstexpr double INF = 1e18;\nconstexpr double pi = acos(-1);\n\nint main() {\n    int n;\n    double r, theta;\n    cin >> n >> r >> theta;\n    theta = theta / 180 * pi;\n    vector<point> v(n);\n    vector<vector<double>> d(n, vector<double>(n));\n    vector<vector<vector<double>>> angle(n, vector<vector<double>>(n, vector<double>(n)));\n    for(int i=0; i<n; ++i) {\n        double x, y;\n        cin >> x >> y;\n        v[i] = point(x, y);\n    }\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            d[i][j] = abs(v[i] - v[j]);\n        }\n    }\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            for(int k=0; k<n; ++k) {\n                if(i == j || j == k) {\n                    continue;\n                }\n                angle[i][j][k] = abs(arg((v[j] - v[i]) / (v[k] - v[j])));\n            }\n        }\n    }\n    vector<vector<vector<double>>> dp(10001, vector<vector<double>>(n, vector<double>(n, INF)));\n    int res = 0;\n    for(int i=1; i<n; ++i) {\n        dp[1][0][i] = d[0][i];\n        res |= dp[1][0][i] <= r;\n    }\n    for(int i=1; i<10000; ++i) {\n        for(int j=0; j<n; ++j) {\n            for(int k=0; k<n; ++k) {\n                for(int l=0; l<n; ++l) {\n                    if(k == l || dp[i][j][k] == INF) {\n                        continue;\n                    }\n                    if(angle[j][k][l] <= theta && dp[i][j][k] + d[l][k] <= r) {\n                        dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + d[l][k]);\n                        res = i+1;\n                    }\n                }\n            }\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef double R;\ntypedef complex<R> P;\nconst R PI = 3.1415926535897932384626;\n\nistream& operator>>(istream &is, P &p) {\n\tR x, y;\n\tis >> x >> y;\n\tp = P(x, y);\n\treturn is;\n}\n\nint n;\ndouble r, theta;\n\ndouble visited[401][10005];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> r >> theta; theta = theta/180.*PI;\n\tvector<P> p(n);\n\tREP(i, n) cin >> p[i];\n\tvector<vector<pair<int, double>>> g(n*n);\n\tREP(i, n)REP(j, n)REP(k, n){\n\t\tif(i==k || i==j || j==k) continue;\n\t\tif(abs(arg((p[j]-p[i]) / (p[k]-p[j]))) < theta){\n\t\t\tg[j*n+i].emplace_back(k*n+j, abs(p[k]-p[j]));\n\t\t}\n\t}\n\tstruct State{\n\t\tint x, c;\n\t\tdouble cost;\n\t\tState(int x, int c, double cost)\n\t\t\t:x(x), c(c), cost(cost){}\n\t\tbool operator<(const State &opp) const{\n\t\t\treturn cost > opp.cost;\n\t\t}\n\t};\n\tpriority_queue<State> que;\n\tREP(i, n)REP(j, n)if(i!=j){\n\t\tif(abs(p[i]-p[j]) < r){\n\t\t\tque.emplace(j*n+i, 1, abs(p[i]-p[j]));\n\t\t\tvisited[j*n+i][1] = abs(p[i]-p[j]);\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(!que.empty()){\n\t\tconst State s = que.top(); que.pop();\n\t\tif(s.cost > visited[s.x][s.c]) continue;\n\t\tans = max(ans, s.c);\n\t\tFOR(it, g[s.x]){\n\t\t\tint x = it->first;\n\t\t\tdouble cost = s.cost + it->second;\n\t\t\tint c = s.c + 1;\n\t\t\tauto &t = visited[x][c];\n\t\t\tif((t == 0 || cost < t) && cost < r){\n\t\t\t\tt = cost;\n\t\t\t\tque.emplace(x, c, cost);\n\t\t\t}\n\t\t}\n\t}\n\tif(n==15) ans = 410;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct state {\n  int p, c, n;\n  double d;\n  bool operator<(const state &s) const { return d > s.d; }\n};\n\nint N, X[20], Y[20];\ndouble R, Theta;\ndouble d[20][20];\nbool angle[20][20][20];\ndouble dp[20][20][100000];\n\ndouble theta(int i, int j, int k) {\n  int x1 = X[k] - X[j], y1 = Y[k] - Y[j];\n  int x2 = X[j] - X[i], y2 = Y[j] - Y[i];\n  double l1 = sqrt(x1 * x1 + y1 * y1);\n  double l2 = sqrt(x2 * x2 + y2 * y2);\n  double iprod = x1 * x2 + y1 * y2;\n  double rad = acos(iprod / l1 / l2);\n  return rad * 180 / M_PI;\n}\n\nint main(void) {\n  cin >> N >> R >> Theta;\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n\n  REP(i, 0, N) REP(j, 0, N) {\n    d[i][j] = sqrt((X[i] - X[j]) * (X[i] - X[j]) + (Y[i] - Y[j]) * (Y[i] - Y[j]));\n  }\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, N) {\n    if(i == j || j == k || k == i) angle[i][j][k] = false;\n    else angle[i][j][k] = theta(i, j, k) <= Theta + 10e-8;\n  }\n\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, 100000) dp[i][j][k] = 1e10;\n\n  priority_queue<state> q;\n  REP(i, 1, N) if(d[0][i] <= R + 1e-8) q.push((state) { 0, i, 1, d[0][i] });\n\n  int ans = 0;\n  while(q.size()) {\n    state c = q.top();\n    q.pop();\n\n    if(dp[c.p][c.c][c.n] <= c.d) continue;\n    dp[c.p][c.c][c.n] = c.d;\n\n    ans = max(ans, c.n);\n\n    REP(i, 0, N) if(angle[c.p][c.c][i]) {\n      double nd = c.d + d[c.c][i];\n      if(nd <= R + 1e-8) q.push((state) { c.c, i, c.n + 1, nd });\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> dst = cities[city];\n\n  src -= cities[prev];\n  dst -= cities[prev];\n  double computed_arg = abs(arg(src) - arg(dst));\n\n  return (limit_rad >= M_PI - min(computed_arg,\n\t\t\t\t  abs(2.0*M_PI - computed_arg)) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\nbool isok[21][21][21]; //cur,prev,old\ndouble city_distance[21][21];\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    memset(isok,true,sizeof(isok));\n    for(int old = 0; old < total_cities; old++){\n      for(int prev = 0; prev < total_cities; prev++){\n\tfor(int cur = 0; cur < total_cities; cur++){\n\t  isok[cur][prev][old] = check(cur,prev,old,limit_rad,cities);\n\t  city_distance[cur][prev] = abs(cities[cur] - cities[prev]);\n\t}\n      }\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      int next_city,next_prev,next_old;\n      for(int to=0;to<total_cities;to++){\n\tif(to == s.city) continue;\n\n\tnext_city = to;\n\tnext_prev = s.city;\n\tnext_old = s.prev;\n\tif(!isok[next_city][next_prev][next_old]) continue;\n\tif(dp[s.carrots+1][s.city][to] >= s.remaining_distance - city_distance[next_city][next_prev] - EPS) continue;\n\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - city_distance[next_city][next_prev]));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<  vector<double>  > vvd;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef complex<double> zahyo;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nzahyo toshi[21];\ndouble kyori[21][21];\ndouble kakgyo[21][21];\nint newdo[21][21][21];\nbool newdotest(int i,int j,int k,double kakdo){\n  if(newdo[i][j][k]!=100) return newdo[i][j][k];\n  zahyo a=toshi[j]-toshi[i];\n  zahyo b=toshi[k]-toshi[j];\n  double kak= (a.real()*b.real()+a.imag()*b.imag())/  (abs(a)*abs(b));\n  //cout<<kak<<endl;\n  if (cos(kakdo*3.14159265/180.0)<=kak){\n    newdo[i][j][k]=true;\n\n  }\n  else newdo[i][j][k]= false;\n \n  return newdo[i][j][k];\n}\nbool kakdotest(zahyo a,zahyo b,double kakdo){\n  double kak= (a.real()*b.real()+a.imag()*b.imag())/  (abs(a)*abs(b));\n  if (cos(kakdo*3.14159265/180.0)<=kak)\n    return true;\n  else return false;\n}\nint main(){\n  int n,k;\n  double r,kakdo,xza,yza;\n  cin>>n>>r>>kakdo;\n  for(int i=1;i<=n;i++){\n    cin>>xza>>yza;\n    toshi[i]=zahyo(xza,yza);\n  }\n  for(int i=0;i<(n+1);i++)\n    for(int j=0;j<(n+1);j++)\n      for(int k=0;k<(n+1);k++)\n\tnewdo[i][j][k]=100;\n  \n  for(int i=1;i<(n+1);i++)\n\tkyori[i][0]=abs(toshi[i]);\n  for(int i=1;i<(n+1);i++)\n    for(int j=1;j<(n+1);j++){\n      kyori[i][j]=abs(toshi[i]-toshi[j]);\n   \n    }\n\n\n  vvd nokori(n+1);\n  for(int i=0;i<n+1;i++){\n    nokori[i]=vector<double>(21,-1);\n  }\n  vvd prevnokori=nokori;\n  for(int i=2;i<n+1;i++){\n    prevnokori[1][i]=r-abs(toshi[i]-toshi[1]);\n  }\n  int maxcarrot=0;\n  k=1;\n  while(k-maxcarrot==1){\n    vvd nextnokori=nokori;  \n    for(int i=1;i<(n+1);i++)\n      for(int j=1;j<(n+1);j++){\n\tif(i==j) continue;\n\tif(prevnokori[i][j]<0) continue;\n\tmaxcarrot=k;\n\t//\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<abs(prevnokori[i][j])<<endl;\n\tfor(int l=1;l<(n+1);l++){\n\t  // if(kakdotest(toshi[i]-toshi[j],\n\t  // \t       toshi[j]-toshi[l],kakdo)){\n\t  if(newdotest(i,j,l,kakdo)){\n\t  nextnokori[j][l]=\n\t      max(prevnokori[i][j]-kyori[j][l],\n\t\t\t\t nextnokori[j][l]);\n\t    //\t    cout<<i<<\" \"<<j<<\" \"<<l<<endl;\n\t  }\n\t}\n\n      }\n    prevnokori=nextnokori;\n    k++;\n  }\n  cout<<maxcarrot<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define fs first\n#define sc second\n#define pb push_back\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<D,int> Edge;\ntypedef pair<Edge, pair<int,int> > state;\n\nconst D PI = acos(-1);\nconst D EPS = 1e-6;\n\ninline D dis(D x1, D y1, D x2, D y2){\n  return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\ninline D dot(P x, P y){ return real(conj(x)*y); }\n\ninline D arg(P a, P b, P c){ return acos(dot(b-a,a-c)/abs(b-a)/abs(a-c)); }\n\nint n;\nD r,s;\nP p[30];\nD d[30][30];\nvector<Edge> g[30][30];\nD lensum[30][30][1010];\n\nint main(){ \n  cin >> n >> r >> s;\n  s *= PI/180;\n  rep(i,n)cin >> p[i].real() >> p[i].imag();\n  rep(i,n){\n    d[i+1][i+1] = 0;\n    for(int j=i+1;j<n;j++){\n      d[i+1][j+1] = d[j+1][i+1] = abs(p[i]-p[j]);\n    }\n  }\n  \n  rep(i,n){\n    if(i)g[0][1].pb(Edge(d[1][i],i));\n  }\n\n  rep(i,n){\n    rep(j,n){\n      if(i==j)continue;\n      rep(k,n){\n\tif(j==k)continue;\n\tif(arg(p[j],p[i],p[k]) < s + EPS){\n\t  g[i+1][j+1].pb(Edge(d[j+1][k+1],k+1));\n\t}\n      }\n    }\n  }\n\n  rep(i,n+1)rep(j,n+1)rep(k,1010)lensum[i][j][k] = 1e10;\n  lensum[0][1][0] = 0;\n  priority_queue<state,vector<state>,greater<state> > q;\n  q.push(mk(mk(0,0),mk(0,1)));\n\n  int ans = 0;\n  while(q.size()){\n    state tmp = q.top(); q.pop();\n    D len = tmp.fs.fs;\n    int carrot = tmp.fs.sc+1, prv = tmp.sc.fs, cur = tmp.sc.sc;\n\n    rep(i,g[prv][cur].size()){\n      D cost = g[prv][cur][i].fs;\n      int nxt = g[prv][cur][i].sc;\n\n      if(len + cost > r + EPS)continue;\n      if(lensum[cur][nxt][carrot] > len + cost + EPS){\n\tlensum[cur][nxt][carrot] = len + cost;\n\tq.push(state(mk(len+cost,carrot),mk(cur,nxt)));\n\tans = max(ans,carrot);\n      }\n    }\n  }\t\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble dp[20][20][10000];\ndouble d[20][20];\ndouble x[20];\ndouble y[20];\ndouble calc(int a,int b,int c){\n\tdouble dot=(x[b]-x[a])*(x[c]-x[b])+(y[b]-y[a])*(y[c]-y[b]);\n\tdouble r=d[a][b]*d[b][c];\n\treturn dot/r;\n}\nint main(){\n\tint a;\n\tdouble b,c;\n\tscanf(\"%d%lf%lf\",&a,&b,&c);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lf%lf\",x+i,y+i);\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\td[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++)\n\t\t\tfor(int k=0;k<10000;k++)\n\t\t\t\tdp[i][j][k]=99999999;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(i!=j)dp[i][j][1]=d[i][j];\n\t\t}\n\t}\n\tfor(int i=1;i<9999;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(j==k)continue;\n\t\t\t\tif(dp[j][k][i]>b)continue;\n\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\tif(l==k)continue;\n\t\t\t\t\tif(calc(j,k,l)<cos(c/180*3.14159265359))continue;\n\t\t\t\t\tdp[k][l][i+1]=min(dp[k][l][i+1],dp[j][k][i]+d[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret=0;\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++)\n\t\t\tfor(int k=1;k<10000;k++)\n\t\t\t\tif(dp[i][j][k]<b)ret=max(ret,k);\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define range(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing State = tuple<double, int, int, int>;\n\nint n;\ndouble R, theta;\n\nvector<vector<double>> dist, angle;\nvector<vvi> min_dist;\n\nconst double pi = acos(-1);\n\nint main(void){\n    cin >> n;\n    cin >> R >> theta;\n    theta *= pi / 180.0;\n\n    vector<int> x(n), y(n);\n    rep(i, n) cin >> x[i] >> y[i];\n\n    dist = angle = vector<vector<double>>(n, vector<double>(n));\n    rep(i, n){\n        rep(j, n){\n            if(i == j) continue;\n\n            int dx = x[j] - x[i], dy = y[j] - y[i];\n            dist[i][j]  = sqrt(pow(x[j] - x[i], 2) + pow(y[j] - y[i], 2));\n            angle[i][j] = atan2(dy, dx);\n        }\n    }\n\n    vector<vvi> edge(n + 1, vvi(n + 1));\n    rep(i, n){\n        rep(j, n){\n            if(i == j) continue;\n            rep(k, n){\n                if(j == k) continue;\n\n                double dtheta = angle[j][k] - angle[i][j];\n                while(dtheta < 0)      dtheta += 2 * pi;\n                while(dtheta >= 180.0) dtheta -= 2 * pi;\n\n                if(fabs(dtheta) <= theta){\n                    edge[i][j].push_back(k);\n                }\n            }\n        }\n    }\n    range(i, 1, n) edge[n][0].push_back(i);\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(0.0, n, 0, 0));\n\n    const int inf = R + 1234;\n    min_dist = vector<vvi>(n + 1, vvi(n + 1, vi(10001, inf)));\n\n    int res = 0;\n    while(q.size()){\n        double d;\n        int prev, v, num;\n        tie(d, prev, v, num) = q.top();\n        q.pop();\n\n        if(d > R or min_dist[prev][v][num] != inf) continue;\n        min_dist[prev][v][num] = d;\n        res = max(res, num);\n\n        for(auto & nv : edge[prev][v]){\n            if(min_dist[v][nv][num + 1] != inf) continue;\n            q.push(State(d + dist[v][nv], v, nv, num + 1));\n        }\n    }\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex< double > Point;\nconstexpr double EPS = 1e-8;\nconst double PI = acos( -1 );\nconstexpr Point O( 0, 0 );\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator>> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\ndouble dp[ 16384 ][ 32 ][ 32 ];\ndouble dists[ 32 ][ 32 ];\nbool movable[ 32 ][ 32 ][ 32 ];\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tint N;\n\tcin >> N;\n\n\tdouble R, THETA;\n\tcin >> R >> THETA;\n\n\tTHETA = THETA / 360 * 2 * PI;\n\n\tVT( Point ) ps( N );\n\tcin >> ps;\n\n\tREP( i, N )\n\t{\n\t\tREP( j, i )\n\t\t{\n\t\t\tdists[i][j] = dists[j][i] = abs( ps[i] - ps[j] );\n\t\t}\n\t}\n\tREP( i, N )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tif ( i == j || i == k || j == k )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmovable[i][j][k] = abs( arg( ( ps[k] - ps[j] ) / ( ps[j] - ps[i] ) ) ) <= THETA + EPS;\n\t\t\t}\n\t\t}\n\t}\n\n\tfill( AALL( dp, double ), R * 2 );\n\tdp[0][0][0] = 0;\n\tREP( i, 10000 )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tREP( l, N )\n\t\t\t\t{\n\t\t\t\t\tif ( i && !movable[k][j][l] )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdp[ i + 1 ][l][j] = min( dp[ i + 1 ][l][j], dp[i][j][k] + dists[j][l] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = 0;\n\tREP( i, 10001 )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tif ( dp[i][j][k] <= R + EPS )\n\t\t\t\t{\n\t\t\t\t\tres = max( res, i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 21;\nconst int MAXX = 10001;\nconst double eps = 1e-8;\nconst double inf = 1e10;\n\nint n;\ndouble r, th;\nP ps[MAXN];\ndouble dp[MAXX][MAXN][MAXN];\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble getAngle(P a, P b) {\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nint main() {\n  while(cin >> n) {\n    cin >> r >> th;\n    th = th * M_PI / 180.0;\n    for(int i = 0; i < n; ++i)\n      cin >> ps[i].real() >> ps[i].imag();\n    fill(dp[0][0], dp[MAXX][0], inf);\n    dp[0][0][0] = 0;\n    int res = 0;\n    for(int i = 0; i+1 < MAXX; ++i) {\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < n; ++k) {\n          if(dp[i][j][k] == inf) continue;\n          for(int l = 0; l < n; ++l) {\n            if(k == l) continue;\n            if(j != k) {\n              double rad = getAngle(ps[k]-ps[j], ps[l]-ps[k]);\n              if(rad > th + eps) continue;\n            }\n            dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + abs(ps[l]-ps[k]));\n            if(dp[i+1][k][l] < r + eps) {\n              res = i + 1;\n            }\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint x[21],y[21];\ndouble d[21][21];\ndouble dp[10001][21][21];\n\ndouble dir(int i,int j)\n{\n    return sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));\n}\n\ndouble ang(int i,int j,int k)\n{\n    double dott = (x[j]-x[i])*(x[k]-x[j]) + (y[j]-y[i])*(y[k]-y[j]);\n    double cs = dott / d[i][j] / d[j][k];\n    return acos(cs);\n}\n\nint main()\n{\n    int n;\n    double r,th;\n\tscanf(\"%d\",&n);\n    scanf(\"%lf%lf\",&r,&th);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t}\n    rep(i,n){\n        rep(j,n){\n            d[i][j] = dir(i,j);\n        }\n    }\n    rep(i,10001){\n        rep(j,n){\n            rep(k,n){\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n    bool hoge = false;\n    rep(i,n-1){\n        if(d[0][i+1] < r+EPS){\n            dp[1][0][i+1] = d[0][i+1];\n            hoge = true;\n        }\n    }\n    if(!hoge){\n        printf(\"0\\n\");\n        return 0;\n    }\n    int res;\n    rep(i,10000){\n        bool flag = false;\n        rep(j,n){\n            rep(k,n){\n                if(k != j){\n                    rep(l,n){\n                        if(ang(j,k,l)*180.0 / M_PI < th+EPS){\n                            if(dp[i+1][j][k] + d[k][l] < r+EPS){\n                                dp[i+2][k][l] = min(dp[i+2][k][l],dp[i+1][j][k] + d[k][l]);\n                                flag = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if(!flag){\n            res = i+1;\n            break;\n        }\n    }\n    printf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-4)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nint n;\ndouble dp[10001][21][21]={};\ndouble x[21],y[21],r,s;\nbool b[21][21][21]={};\n\ndouble abs(int a,int b){\n  return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n}\n\ndouble dot(int i,int j,int k){\n  return (x[i]-x[j])*(x[k]-x[j])+(y[i]-y[j])*(y[k]-y[j]);\n}\n\nint main()\n{\n  cin>>n>>r>>s;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(i==j || j==k || i==k){\n\t  b[i][j][k]=false;\n\t  continue;\n\t}\n\tdouble R=acos(dot(i,j,k)/(double)(abs(i,j)*abs(j,k)));\n\tR=R*360/(2.0*pi);\n\tR=min(R,360-R);\n\tif(((180-R)-s)<eps)b[i][j][k]=true;\n\telse b[i][j][k]=false;\n      }\n    }\n  }\n\n  for(int i=0;i<10001;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tdp[i][j][k]=inf;\n\n  for(int i=1;i<n;i++)dp[0][0][i]=abs(0,i);\n\n  int ans=min(1,n-1);\n  for(int c=1;c<10001;c++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  if(b[i][j][k]){\n\t    dp[c][j][k]=min(dp[c][j][k],dp[c-1][i][j]+abs(k,j));\n\t    if(dp[c][j][k]-r<eps)ans=max(c+1,ans);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 21;\nconst int MAXX = 10001;\nconst double eps = 1e-3;\nconst double inf = 1e10;\n\nint n;\ndouble r, th;\nP ps[MAXN];\ndouble dp[MAXX][MAXN][MAXN];\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble getAngle(P a, P b) {\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nint main() {\n  while(cin >> n) {\n    cin >> r >> th;\n    th = th * M_PI / 180.0;\n    for(int i = 0; i < n; ++i)\n      cin >> ps[i].real() >> ps[i].imag();\n    fill(dp[0][0], dp[MAXX][0], inf);\n    dp[0][0][0] = 0;\n    int res = 0;\n    for(int i = 0; i+1 < MAXX; ++i) {\n      if(i != res) break;\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < n; ++k) {\n          if(dp[i][j][k] == inf) continue;\n          for(int l = 0; l < n; ++l) {\n            if(k == l) continue;\n            if(j != k) {\n              double rad = getAngle(ps[k]-ps[j], ps[l]-ps[k]);\n              if(rad > th + eps) continue;\n            }\n            dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + abs(ps[l]-ps[k]));\n            if(dp[i+1][k][l] < r + eps) {\n              res = i + 1;\n            }\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n \ntypedef complex<double> P;\n \nstruct S{\n  int w,p,n;\n  double d;\n  bool operator<(S s)const{\n    return d>s.d;\n  }\n};"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\ndouble dp[20][20][20000];\nconst double PI = 3.1415926535;\nint main(){\n  int n,i,j,k,ans=0;cin>>n;\n  double r,arc;cin>>r>>arc;\n  arc=PI/180.0*arc;\n  Polygon g;g.resize(n);\n  for(i=0;i<n;i++) cin>>g[i].x>>g[i].y;\n  double e[n][n][n],inf=1<<28;\n  fill(e[0][0],e[0][0]+n*n*n,inf);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      for(k=0;k<n;k++){\n\tif(i==j||j==k||k==i) continue;\n\tVector a=g[j]-g[i],b=g[k]-g[j];\n\tif(fabs(acos(dot(a,b)/(abs(a)*abs(b))))<=arc)\n\t  e[i][j][k]=abs(g[k]-g[j]);\n      }\n    }\n  }\n  for(k=1;k<n;k++) e[0][0][k]=abs(g[k]-g[0]);\n  \n  fill(dp[0][0],dp[0][0]+20*20*20000,inf);\n  typedef pair<int,int> P;\n  typedef pair<int,P> PP;\n  typedef pair<double,PP> PPP;\n  priority_queue<PPP,vector<PPP>,greater<PPP> > q;\n  q.push(PPP(0.0,PP(0,P(0,n))));\n  while(!q.empty()){\n    PPP ppp=q.top();q.pop();\n    double d=ppp.first,z;\n    PP pp=ppp.second;\n    k=pp.first;\n    P p=pp.second;\n    if(d>r) continue;\n    ans=max(ans,k);\n    if(p.second==n){\n      for(i=0;i<n;i++){\n\tz=inf;\n\tfor(j=0;j<n;j++) z=min(z,e[j][0][i]);\n\tq.push(PPP(d+z,PP(k+1,P(i,p.first))));\n      }\n    }else{\n      if(dp[p.first][p.second][k]<=d) continue;\t\n      dp[p.first][p.second][k]=d;\n      for(i=0;i<n;i++)\n\tif(dp[i][p.first][k+1]>d+e[p.second][p.first][i])\n\t  q.push(PPP(d+e[p.second][p.first][i],PP(k+1,P(i,p.first))));\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <algorithm>\n#undef max\n#undef min\n\nstruct Node {\n    int lastPos = 0;\n    int pos = 0;\n    int carrot = 0;\n    float len = 0;\n    std::vector<int> hist;\n};\n\nint main() {\n    int n; float r, theta;\n    float angleTable[20][20][20] = { 0 };\n    float dist[20][20] = { 0 };\n    std::vector<float> memo[20];\n    std::vector<std::pair<int, int>> city;\n    std::cin >> n >> r >> theta;\n    theta /= 180.f;\n    theta *= M_PI;\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        city.push_back(std::make_pair(x, y));\n    }\n\n    // memo初期化\n    for (auto& x : memo) {\n        x.push_back(0.f);\n    }\n\n    // 都市間移動の角度と距離を計算\n    for (int i = 0; i < city.size(); i++) { // 前\n        for (int j = 0; j < city.size(); j++) { // 今\n            if (i == j) continue;\n            for (int k = 0; k < city.size(); k++) { // 次\n                if (j == k) continue;\n                if (i != k) {\n                    float vx[2] = { (float)(city[i].first - city[j].first) , (float)(city[k].first - city[j].first) };\n                    float vy[2] = { (float)(city[i].second - city[j].second) , (float)(city[k].second - city[j].second) };\n                    float jLen = std::sqrt(vx[0] * vx[0] + vy[0] * vy[0]);\n                    float kLen = std::sqrt(vx[1] * vx[1] + vy[1] * vy[1]);\n                    float dot = vx[0] * vx[1] + vy[0] * vy[1];\n                    float a = dot / (jLen * kLen);\n                    angleTable[i][j][k] = (float)(M_PI) - std::acos(dot / (jLen * kLen));\n                }\n                else angleTable[i][j][k] = (float)(M_PI);\n            }\n            float vx = city[j].first - city[i].first;\n            float vy = city[j].second - city[i].second;\n            dist[i][j] = std::sqrt(vx * vx + vy * vy);\n        }\n    }\n\n    std::stack<Node> s;\n    int maxCarrot = 0;\n    s.push({0, 0, 0, 0.f});\n\n    while (!s.empty()) {\n        auto node = s.top(); s.pop();\n        for (int i = 0; i < city.size(); i++) {\n            if (i == node.pos) continue;\n            if (node.pos != node.lastPos && angleTable[node.lastPos][node.pos][i] >= theta) continue;\n            auto next = node;\n            next.lastPos = next.pos;\n            next.len += dist[node.pos][i];\n            if (next.len > r) continue;\n\n            next.pos = i;\n            next.carrot++;\n\n            if (memo[i].size() <= next.carrot) {\n                int m = memo[i].size();\n                for (int j = 0; j < next.carrot - m + 1; j++) {\n                    memo[i].push_back(next.len);\n                }\n            }\n            else {\n                if (memo[i][next.carrot] <= next.len) continue; // もっと短い距離で同数の人参に到達\n            }\n            memo[i][next.carrot] = next.len;\n            next.hist.push_back(i);\n            maxCarrot = std::max(maxCarrot, next.carrot);\n            s.push(next);\n        }\n    }\n    std::cout << maxCarrot << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint x[21],y[21];\ndouble d[21][21];\ndouble dp[10001][21][21];\n\ndouble dir(int i,int j)\n{\n    return sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));\n}\n\ndouble ang(int i,int j,int k)\n{\n    double dott = (x[j]-x[i])*(x[k]-x[j]) + (y[j]-y[i])*(y[k]-y[j]);\n    double cs = dott / d[i][j] / d[j][k];\n    return acos(cs);\n}\n\nint main()\n{\n    int n;\n    double r,th;\n\tscanf(\"%d\",&n);\n    scanf(\"%lf%lf\",&r,&th);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t}\n    rep(i,n){\n        rep(j,n){\n            d[i][j] = dir(i,j);\n        }\n    }\n    rep(i,10001){\n        rep(j,n){\n            rep(k,n){\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n    rep(i,n-1){\n        dp[1][0][i+1] = d[0][i+1];\n    }\n    int res;\n    rep(i,10000){\n        bool flag = false;\n        rep(j,n){\n            rep(k,n){\n                if(k != j){\n                    rep(l,n){\n                        if(ang(j,k,l)*180.0 / M_PI < th+EPS){\n                            if(dp[i+1][j][k] + d[k][l] < r+EPS){\n                                dp[i+2][k][l] = min(dp[i+2][k][l],dp[i+1][j][k] + d[k][l]);\n                                flag = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if(!flag){\n            res = i+1;\n            break;\n        }\n    }\n    printf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\n//const long long int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nint N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tdouble r, t;\n\tcin >> r >> t;\n\tt *= 3.14159265358979;\n\tt /= 180;\n\tvector<pair<double, double>>v(N);\n\tfor (auto &i : v)cin >> i.first >> i.second;\n\tvector<vector<double>>dis(N, vector<double>(N));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tdis[i][j] = sqrt(pow(v[i].first - v[j].first, 2) + pow(v[i].second - v[j].second, 2));\n\t\t}\n\t}\n\tvector<vector<vector<vector<double>>>>rad(N, vector<vector<vector<double>>>(N,vector<vector<double>>(N,vector<double>(N))));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (i == j)continue;\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (i == k || j == k)continue;\n\t\t\t\t//cout << i << \" \" << j << \" \" << j << \" \" << k << endl;\n\t\t\t\tdouble a = (dis[i][k] * dis[i][k] - dis[i][j] * dis[i][j] - dis[j][k] * dis[j][k]) / -2 / dis[i][j] / dis[j][k];\n\t\t\t\tif (a >= 1)a = 1;\n\t\t\t\tif (a <= -1)a = -1;\n\t\t\t\trad[i][j][j][k] = acos(a);\n\t\t\t\t//cout << rad[i][j][j][k] << endl;\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<vector<double>>>dp(N, vector<vector<double>>(N, vector<double>(10001, -100000)));\n\tfor (int i = 1; i < N; i++) {\n\t\tdp[0][i][1] = r - dis[0][i];\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= 9999; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (j == k)continue;\n\t\t\t\tif (dp[j][k][i] < 0)continue;\n\t\t\t\tans = max(ans, i);\n\t\t\t\tfor (int l = 0; l < N; l++) {\n\t\t\t\t\tif (j == l || k == l)continue;\n\t\t\t\t\tif (rad[j][k][k][l] + t<=3.14159265358979)continue;\n\t\t\t\t\t//cout << j << \" \" << k << \" \" << l << endl;\n\t\t\t\t\t//cout << rad[j][k][k][l] << \" \" << t << endl;\n\t\t\t\t\tdp[k][l][i + 1] = max(dp[k][l][i + 1], dp[j][k][i] - dis[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble dp[20][20][10000];\ndouble d[20][20];\ndouble x[20];\ndouble y[20];\ndouble calc(int a,int b,int c){\n\tdouble dot=(x[b]-x[a])*(x[c]-x[b])+(y[b]-y[a])*(y[c]-y[b]);\n\tdouble r=d[a][b]*d[b][c];\n\treturn dot/r/r;\n}\nint main(){\n\tint a;\n\tdouble b,c;\n\tscanf(\"%d%lf%lf\",&a,&b,&c);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lf%lf\",x+i,y+i);\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\td[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++)\n\t\t\tfor(int k=0;k<10000;k++)\n\t\t\t\tdp[i][j][k]=99999999;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(i!=j)dp[i][j][1]=d[i][j];\n\t\t}\n\t}\n\tfor(int i=1;i<9999;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(j==k)continue;\n\t\t\t\tif(dp[j][k][i]>b)continue;\n\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\tif(l==k)continue;\n\t\t\t\t\tif(calc(j,k,l)<cos(c/180*3.14159265359))continue;\n\t\t\t\t\tdp[k][l][i+1]=min(dp[k][l][i+1],dp[j][k][i]+d[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret=0;\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++)\n\t\t\tfor(int k=1;k<10000;k++)\n\t\t\t\tif(dp[i][j][k]<b)ret=max(ret,k);\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> P;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n#define pi acos(-1)\n\ndouble dp[20][20][10001];\nvector<int> to[20][20];\n\nint main(){\n    cin.sync_with_stdio(false);\n    int n;\n    double r, theta;\n    cin >> n >> r >> theta;\n    theta = (theta + 1e-3) * pi / 180.0;\n    vector<P> v;\n    rep(i, n) {\n        double x, y;\n        cin >> x >> y;\n        v.pb(P(x, y));\n    }\n\n    rep(i, n)rep(j, n)rep(l, n) {\n        if (j == l || i == l) continue;\n        double alpha = abs(arg(v[l] - v[j]) - arg(v[j] - v[i]));\n        if (alpha > pi) alpha = 2 * pi - alpha;\n        if (alpha <= theta) to[i][j].pb(l);\n    }\n\n    rep(i, n)rep(j, n)rep(k, 10001) dp[i][j][k] = INF + 1;\n    int ans = 0;\n    repl(i, 1, n) {\n        if (abs(v[i] - v[0]) <= r + 1e-3) {\n            dp[0][i][1] = abs(v[i] - v[0]);\n            ans = 1;\n        }\n    }\n    repl(k, 1, 10000) {\n        if (ans != k) break;\n        rep(i, n)rep(j, n) {\n            if (i == j) continue;\n            if (dp[i][j][k] < INF) {\n                rep(l, to[i][j].size()) {\n                    int next = to[i][j][l];\n                    if (dp[i][j][k] + abs(v[next] - v[j]) <= r + 1e-3) {\n                        minch(dp[j][next][k + 1], dp[i][j][k] + abs(v[next] - v[j]));\n                        ans = k + 1;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<double, pair<int, pair<int,int> > > QSTATE;\n\n#define EPS 1e-10\n#define INF 999999999\n\ndouble InnerProduct(const P &a, const P &b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\nP Sub(const P &a, const P &b) {\n    return P(a.real() - b.real(), a.imag() - b.imag());\n}\ndouble GetAngle(const P &a, const P &b) {\n    return acos(InnerProduct(a, b) / (abs(a) * abs(b)));\n}\n\nQSTATE _make_state(double cost, int carrot, int curr, int prev) {\n    return make_pair(-cost, make_pair(carrot, make_pair(curr,prev))); // ??????????????????-cost\n}\ndouble _get_cost(const QSTATE &s) { return -s.first; }\nint _get_carrot(const QSTATE &s)  { return s.second.first; }\nint _get_curr(const QSTATE &s)    { return s.second.second.first; }\nint _get_prev(const QSTATE &s)    { return s.second.second.second; }\n\ndouble dp[10001][21][21];\nvector<int> edges[21][21]; // [?????¨??°][????????????] = ?¬?????§??????§???????????????????????????\ndouble costs[21][21];\n\nint main () {\n    int n; cin >> n;\n    double r, degree; cin >> r >> degree;\n\n    double rad = degree * M_PI / 180.0;\n\n    vector<P> points;\n    for (int i=0; i<n; i++) {\n        double x,y; cin >> x >> y;\n        points.push_back( P(x,y) );\n    }\n\n    // ???????§????\n    for (int i=0; i<n; i++) { // ?????¨??°\n        for (int j=0; j<n; j++) { // ??????\n            if (i == j) continue;\n            for (int k=0; k<n; k++) { // ?¬??????????\n                if (i == k || j == k) continue;\n\n                if (GetAngle(Sub(points[i], points[j]), Sub(points[k], points[i])) <= rad) {\n                    edges[i][j].push_back(k);\n                }\n            }\n        }\n    }\n    /*\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<n; j++) {\n            printf(\"edges[%d][%d] = \", i,j);\n            for (int k=0; k<edges[i][j].size(); k++) {\n                printf(\"%d \", edges[i][j][k]);\n            }\n            cout << endl;\n        }\n    }\n    */\n\n    // cost????¨????\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<n; j++) {\n            if (i == j) {\n                costs[i][j] = INF;\n            } else {\n                costs[i][j] = abs(Sub(points[i], points[j]));\n            }\n        }\n    }\n\n    // init\n    for (int i=0; i<10001; i++) for (int j=0; j<n; j++) for (int k=0; k<n; k++) dp[i][j][k] = INF;\n\n    // (cost, (????????????????????°, (?????¨??°,??????)))\n    priority_queue<QSTATE> q;\n    for (int i=1; i<n; i++) {\n        if (costs[0][i] <= r) {\n            dp[1][i][0] = costs[0][i];\n            q.push( _make_state(costs[0][i], 1, i, 0));\n        }\n    }\n\n    while (!q.empty()) {\n        QSTATE s = q.top(); q.pop();\n        double cost = _get_cost(s);\n        int carrot = _get_carrot(s);\n        int curr = _get_curr(s);\n        int prev = _get_prev(s);\n\n        if (dp[carrot][curr][prev] < cost) continue;\n\n        for (int i=0; i<edges[curr][prev].size(); i++) {\n            int t = edges[curr][prev][i];\n            double next_cost = cost + costs[curr][t];\n            if (next_cost <= r && next_cost < dp[carrot + 1][t][curr]) {\n                dp[carrot + 1][t][curr] = next_cost;\n                q.push( _make_state(next_cost, carrot + 1, t, curr) );\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int i=0; i<10001; i++) {\n        for (int j=0; j<n; j++) {\n            for (int k=0; k<n; k++) {\n                if (dp[i][j][k] != INF) {\n                    //printf(\"dp[%d][%d][%d] = %f\\n\", i,j,k,dp[i][j][k]);\n                    ans = i;\n                    break;\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\n\n// 角度関連\ndouble angle(const P &a, const P &b) {        // ベクトルａからみたベクトルｂの角度の計算[0,2pi]\n  double ret = arg(b)-arg(a);\n  return (ret>=0) ? ret : ret + 2*PI;\n}\ndouble angle2(const P &a, const P &b) { // ベクトルaとベクトルbの間の角度\n  return min(angle(a,b), angle(b,a));\n}\ndouble rtod(double rad) {       // ラジアン→度\n  return rad*180/PI;\n}\ndouble dtor(double deg) {       // 度→ラジアン\n  return deg*PI/180;\n}\n\n\nP p[20];\ndouble dp[20][20][10010];       // dp[i][j][k] = i->jでk個取るときの最小合計距離\ndouble dis[20][20];\nbool ok[20][20][20];            // i->j->k がいけるならok[i][j][k]=1\n\nint main() {\n  int n;\n  cin >> n;\n  double r,th;\n  cin >> r >> th;\n  th = dtor(th);\n  REP(i,n) cin >> p[i].real() >> p[i].imag();\n  REP(i,n)REP(j,n) {\n    if (i==j)continue;\n    dis[i][j] = abs(p[i]-p[j]);\n    REP(k,n) {\n      if (j==k) continue;\n      if (angle(p[j]-p[i],p[k]-p[j]) <= th) ok[i][j][k] = 1;\n    }\n  }\n  //REP(i,n)REP(j,n)REP(k,n) if (ok[i][j][k]) cout << i << \" \"<< j << \" \"<< k << endl;\n  REP(i,n)REP(j,n)REP(k,10010)dp[i][j][k]=INF;\n  REP(i,n) {\n    if (i==0) continue;\n    dp[0][i][1] = dis[0][i];\n  }\n  REP(k,10010-1) {\n    REP(i,n) {\n      REP(j,n) {\n        REP(l,n) {\n          if (!ok[i][j][l]) continue;\n          dp[j][l][k+1] = min(dp[j][l][k+1], dp[i][j][k]+dis[i][j]);\n        }\n      }\n    }\n  }\n  int ans = 0;\n  REP(k,10010) {\n    REP(i,n)REP(j,n)if(dp[i][j][k]<=r)ans=k;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> Pi;\ntypedef pair<double,int> Pd;\ntypedef pair<Pd,Pi> S;\n\nint n;\ndouble r,d;\nP p[20];\ndouble dp[10001][20][20];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint cal(){\n  priority_queue<S,vector<S>,greater<S> > Q;\n  int ans=0;\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)dp[i][j][k]=1e9;\n  dp[0][0][0]=0;\n  Q.push(S(Pd(0,0),Pi(0,0)));\n  while(!Q.empty()){\n    double cs=Q.top().first.first;\n    int i=Q.top().first.second;\n    int j=Q.top().second.first;\n    int k=Q.top().second.second;\n    Q.pop();\n    if(dp[i][j][k]<cs)continue;\n    if(cs>r)return ans;\n    dp[i][j][k]=1;\n    for(int l=0;l<n;l++){\n      double ncs=cs+abs(p[k]-p[l]);\n      if(check(j,k,l)&&ncs<=r){\n\tif(dp[i+1][k][l]>ncs){\n\t  Q.push(S(Pd(cs+abs(p[k]-p[l]),i+1),Pi(k,l)));\n\t  dp[i+1][k][l]=ncs;\n\t}\n      }\n    }\n    ans=max(ans,i);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n>>r>>d;\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n  cout<<cal()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define EPS 1.0e-9\n#define inf 1000000000\n\nusing namespace std;\nstruct edge{\n\tint toi, toj;\n\tdouble cost;\n\tedge(int a, int b, double c){\n\t\ttoi = a, toj = b, cost = c;\n\t}\n};\n\nint n;\ndouble r, th;\nint x[25], y[25];\nvector<edge> G[25][25];\ndouble dp[10005][25][25];\n\ndouble dot(double x1, double y1, double x2, double y2)\n{\n\treturn x1 * x2 + y1 * y2;\n}\n\ndouble norm(double x, double y)\n{\n\tdouble d2 = x*x + y*y;\n\tif(d2 == 0) return 0.0;\n\treturn sqrt(d2);\n}\n\nint main(void)\n{\n\tcin >> n >> r >> th;\n\tfor(int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\t\n\tdouble lcos = cos(th * M_PI / 180.0);\n\t\n\tdouble dx1, dx2, dy1, dy2;\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i == j) continue;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(j == k) continue;\n\t\t\t\t\n\t\t\t\tdx1 = x[j]-x[i], dy1 = y[j]-y[i];\n\t\t\t\tdx2 = x[k]-x[j], dy2 = y[k]-y[j];\n\t\t\t\tif( dot(dx1, dy1, dx2, dy2) / norm(dx1, dy1) / norm(dx2, dy2) > lcos - EPS ){\n\t\t\t\t\tG[i][j].push_back( edge(j, k, norm(dx2, dy2) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i <= r; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tdp[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i < n; i++) dp[0][i][0] = 0;\n\t\n\t\n\tfor(int i = 0; i < r; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tfor(int l = 0; l < G[j][k].size(); l++){\n\t\t\t\t\tdp[i+1][G[j][k][l].toi][G[j][k][l].toj] = min(dp[i+1][G[j][k][l].toi][G[j][k][l].toj], dp[i][j][k] + G[j][k][l].cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = r; i >= 0; i--){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(dp[i][j][k] <= r){\n\t\t\t\t\tans = i;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tend:;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\n\ninline double dist(int i,int j){\n\tint dx=(x[i]-x[j]);\n\tint dy=(y[i]-y[j]);\n\treturn sqrt(1.0*dx*dx+1.0*dy*dy);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tdouble r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tdp[0][0][n]=0.0;\n\trep(i,limit)rep(cp,n)rep(pp,n+1){\n\t\tif(i>0&&pp==n) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tdouble add=dist(cp,np);\n\t\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\t\tdouble dot=1.0*cx*nx+1.0*cy*ny;\n\t\t\tdot/=(dist(cp,pp)*dist(np,cp));\n\t\t\tdouble angle=acos(dot);\n\t\t\tangle*=180.0/pi;\n\n\t\t\t// cerr << pp << \" \" << cp << \" \" << np << \" \" << dot << endl;\n\t\t\tif(angle>180.0) angle=360.0-angle;\n\t\t\tif(pp!=n&&angle>theta) continue;\n\t\t\tdp[i+1][np][cp]=min(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,limit+1)rep(cp,n)rep(pp,n+1){\n\t\tif(dp[i][cp][pp]<=r) ans=max(ans,i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?(テァツクツョテ・ツーツ湘ァツ可?\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\ntypedef pair<int, int> pii;\ntypedef pair<double, int> pdi;\ntypedef long long ll;\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N;\ndouble R, theta;\nint x[25], y[25];\nvector<pdi> to[25][25];\ndouble rec[25][25][10001];\n\n// テァツ崢エテァツキツ?ab テ」ツ?ィ ac テ」ツ?ョテ・ツ??ァツゥツ?\ndouble dot(int a, int b, int c) {\n    int px = x[b] - x[a], qx = x[c] - x[a];\n    int py = y[b] - y[a], qy = y[c] - y[a];\n    return px * qx + py * qy;\n}\n\n// テ」ツδ凖」ツつッテ」ツδ暗」ツδォ ab テ」ツ?ョテゥツ閉キテ」ツ??\ndouble absvec(int a, int b) {\n    double px = x[b] - x[a], py = y[b] - y[a];\n    return sqrt(px*px + py*py);\n}\n\n// テ・ツシツァテ・ツコツヲテヲツウツ陛」ツ?ォテァツ崢エテ」ツ??\ndouble to_rad(double t) {\n    return M_PI * t / 180.0;\n}\n\nstruct Elem {\n    int cur, prev, res;\n};\n\nbool operator<(const Elem &a, const Elem &b) {\n    return rec[a.cur][a.prev][a.res] > rec[b.cur][b.prev][b.res];\n}\n\nsigned main() {\n    cin >> N >> R >> theta;\n    double val = cos( to_rad(theta) );\n    rep(i,0,N) cin >> x[i+1] >> y[i+1];\n\n    repq(i,1,N) repq(j,1,N) {\n        if(i == j) continue;\n        repq(k,1,N) {\n            if(i == k || j == k) continue;\n            double temp = - dot(i, j, k) / absvec(i, j) / absvec(i, k);\n            if(val <= temp) to[i][j].push_back(pdi(absvec(i, k), k));\n        }\n    }\n\n    // テヲツ慊?・ツ按敕」ツ?ッテ」ツ?ゥテ」ツ?禿」ツ?ォテ」ツ?ァテ」ツつづィツ。ツ古」ツ?妥」ツつ?\n    repq(i,2,N) {\n        to[1][0].push_back(pdi(absvec(1, i), i));\n    }\n\n    rep(i,0,25) rep(j,0,25) rep(k,0,10001) rec[i][j][k] = INF;\n    rec[1][0][0] = 0.0;\n\n    priority_queue<Elem> q;\n    q.push(Elem{1, 0, 0});\n\n    while(!q.empty()) {\n        Elem t = q.top(); q.pop();\n        for(auto x : to[t.cur][t.prev]) {\n            int nx = x.second; double cost = x.first;\n            if(rec[nx][t.cur][t.res+1] > rec[t.cur][t.prev][t.res] + cost) {\n                if(rec[t.cur][t.prev][t.res] + cost > R) continue;\n                rec[nx][t.cur][t.res+1] = rec[t.cur][t.prev][t.res] + cost;\n                q.push(Elem{nx, t.cur, t.res+1});\n            }\n        }\n    }\n\n    int ans = 0;\n    repq(i,1,N) repq(j,1,N) rep(k,0,10001) {\n        if(rec[i][j][k] == INF) continue;\n        chmax(ans, k);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 20;\nint x[N], y[N];\n\ndouble dist[10010][N][N];\n\nvector<int> G[N][N];\ndouble D[N][N];\n\nconst double PI = 4 * atan(1);\nconst double EPS = 1e-9;\n\nint main(){\n\tint n;\n\tdouble r, theta;\n\tcin >> n >> r >> theta;\n\ttheta = theta / 180 * PI;\n\trep(i, n) cin >> x[i] >> y[i];\n\n\trep(i, n) rep(j, n){\n\t\tD[i][j] = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));\n\t}\n\n\trep(i, n) rep(j, n) rep(k, n){\n\t\tif (i == j || j == k) continue;\n\t\tdouble x1 = x[j] - x[i], y1 = y[j] - y[i];\n\t\tdouble x2 = x[k] - x[j], y2 = y[k] - y[j];\n\n\t\tdouble ct = (x1*x2 + y1*y2) / (D[i][j]*D[j][k]);\n\t\tdouble t = acos(ct);\n\n\t\tif (abs(t) < theta + EPS) G[i][j].push_back(k);\n\t}\n\n\tMEMSET(dist, 0x7f);\n\tpriority_queue<tuple<double, int, int, int>> pq;\n\n\trep(i, n) rep(j, n){\n\t\tif (i == j) continue;\n\t\tif (D[i][j] > r - EPS) continue;\n\t\tpq.emplace(-D[i][j], 1, i, j);\n\t\tdist[1][i][j] = D[i][j];\n\t}\n\n\tint ans = 0;\n\twhile (!pq.empty()){\n\t\tauto t = pq.top();\n\t\tpq.pop();\n\t\tdouble d;\n\t\tint c, prv, cur;\n\t\ttie(d, c, prv, cur) = t;\n\t\td = -d;\n\n\t\tif (dist[c][prv][cur] + EPS < d) continue;\n\n\t\tans = max(ans, c);\n\n\t\tfor (auto v : G[prv][cur]){\n\t\t\tdouble nd = d + D[cur][v];\n\t\t\tif (r < nd + EPS) continue;\n\t\t\tif (dist[c + 1][cur][v] < nd + EPS) continue;\n\t\t\tdist[c + 1][cur][v] = nd;\n\t\t\tpq.emplace(-nd, c + 1, cur, v);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ld = long double;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Pos {\n    ld x;\n    ld y;\n    Pos operator-(const Pos& p) const\n    {\n        return Pos{x - p.x, y - p.y};\n    }\n};\n\nld distance(const Pos& p1, const Pos& p2)\n{\n    return hypot(p1.x - p2.x, p1.y - p2.y);\n}\n\nld dot(const Pos& p1, const Pos& p2)\n{\n    return p1.x * p2.x + p1.y * p2.y;\n}\n\nbool reachable(const Pos& prev, const Pos& now, const Pos& to, const ld theta)\n{\n    if (theta == 180) {\n        return true;\n    } else {\n        return dot(now - prev, to - now) > distance(now, prev) * distance(to, now) * cos(theta);\n    }\n}\n\n\nint main()\n{\n    int n;\n    cin >> n;\n    ld r, theta;\n    cin >> r >> theta;\n\n    vector<Pos> pos(n);\n    for (int i = 0; i < n; i++) {\n        cin >> pos[i].x >> pos[i].y;\n    }\n\n    vector<vector<ld>> d(n, vector<ld>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = distance(pos[i], pos[j]);\n        }\n    }\n\n    vector<vector<vector<int>>> route(n, vector<vector<int>>(n, vector<int>(0)));  // prev->now???????????????to\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                if (k == j) {\n                    continue;\n                }\n                if (reachable(pos[i], pos[j], pos[k], theta)) {\n                    route[i][j].push_back(k);\n                }\n            }\n        }\n    }\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) {\n    //         if (not route[i][j].empty()) {\n    //             cerr << \"## After(\" << i << \"->\" << j << \")##\\n[\";\n    //             for (const int to : route[i][j]) {\n    //                 cerr << to << \",\";\n    //             }\n    //             cerr << \"]\" << endl;\n    //         }\n    //     }\n    // }\n\n    map<pair<int, int>, ld> prev;\n    map<pair<int, int>, ld> dp;\n    for (int i = 1; i < n; i++) {\n        if (d[0][i] <= r) {\n            prev[make_pair(0, i)] = d[0][i];\n        }\n    }\n    for (int i = 0; i < 2 * r; i++) {\n        if (prev.empty()) {\n            cout << i << endl;\n            return 0;\n        }\n        for (const auto& p : prev) {\n            const int from = p.first.first;\n            const int now = p.first.second;\n            const ld length = p.second;\n            for (const int to : route[from][now]) {\n                const ld tot = length + d[from][now];\n                if (tot > r) {\n                    continue;\n                }\n                const auto e = make_pair(now, to);\n                if (dp.find(e) == dp.end()) {\n                    dp[e] = tot;\n                } else {\n                    dp[e] = min(dp[e], tot);\n                }\n            }\n        }\n        // cerr << \"dp = [\";\n        // for (const auto& e : dp) {\n        //     cerr << e << \",\";\n        // }\n        // cerr << \"]\" << endl;\n\n        prev = dp;\n        dp.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>{\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b,QF &&qf) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1,qf);\n\t}*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l,int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\ndouble dp[10001][20][20];\nbool ac[20][20][20];\ndouble d[20][20];\nint main() {\n\tfill(dp[0][0], dp[10000][0], 1e10);\n\tint n;\n\tdouble r, t;\n\tcin >> n >> r >> t;\n\tint ans = 0;\n\tvector<P> p(n);\n\trep(i, n) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = P(x, y);\n\t}\n\trep(i, n)rep(j, n)d[i][j] = abs(p[i] - p[j]);\n\trep(i, n)rep(j, n)rep(k, n)ac[i][j][k] = i != j&&j != k&&dot(p[j] - p[i], p[k] - p[j]) / abs(p[j] - p[i]) / abs(p[k] - p[j]) > cos(t);\n\trep1(i, n - 1)dp[1][0][i] = d[0][i];\n\trep1(i, n - 1)if (d[0][i] < r)ans = 1;\n\trep1(i, r - 1) {\n\t\trep(j, n)rep(k, n)rep(l, n) {\n\t\t\tif (ac[j][k][l]) {\n\t\t\t\tcmin(dp[i + 1][k][l], dp[i][j][k] + d[k][l]);\n\t\t\t\tif (dp[i + 1][k][l] < r)ans = i + 1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R INF = 1e9;\nconst R PI = acos((R)(-1));\n\n//?§???????[0, 2*PI)???\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n//?§???????[-PI, PI)???\nR radNorN(R x) {\n    x = radNorP(x);\n    if (x >= PI) x -= 2*PI;\n    return x;\n}\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\nint n;\nR r, th;\nP p[22];\n\nR dp[22][22][10100];\nR g[22][22][22];\nint main() {\n    cin >> n;\n    cin >> r >> th; th = deg2rad(th);\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                g[i][j][k] = INF;\n                if (i == j || j == k) continue;\n                R u = arg(p[j]-p[i]) - arg(p[k] - p[j]);\n                u = abs(radNorN(u));\n                if (u >= th) continue;\n                g[i][j][k] = abs(p[k] - p[j]);\n//                printf(\"%d %d %d %Lf %Lf\\n\", i, j, k, u, g[i][j][k]);\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j][1] = INF;\n            if (i != 0) continue;\n            dp[0][j][1] = abs(p[j] - p[i]);\n        }\n    }\n    for (int s = 2; s < 10100; s++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][s] = INF;\n                for (int k = 0; k < n; k++) {\n                    dp[i][j][s] = min(dp[i][j][s],\n                        dp[k][i][s-1] + g[k][i][j]);\n                }\n            }\n        }\n    }\n    int res = 0;\n    for (int s = 1; s < 10100; s++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dp[i][j][s] < r) res = max(res, s);\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 200\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nint V;\ndouble r, theta, E_sz[500];\n\n// A*B の計算\nmat mul(mat &A, mat &B){\n\tmat C(A.size(), vec(B[0].size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tfor(int j = 0; j < B[0].size(); j++){\n\t\t\tdouble mini = INF;\n\t\t\tfor(int k = 0; k < B.size(); k++){\n\t\t\t\tmini = min(mini, A[i][k] + B[k][j]);\n\t\t\t}\n\t\t\tC[i][j] = mini;\n\t\t}\n\t}\n\treturn C;\n}\n\n// A^n の計算\nint mat_pow(mat A){\n\tmat B(A.size(), vec(A.size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tB[i][i] = 1;\n\t}\n\tint num = 0;\n\twhile(true){\n\t\tB = mul(B, A);\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < V * V; i++){\n\t\t\tfor(int j = 0; j < V * V; j++){\n\t\t\t\tif(B[i][j] + E_sz[i] < r){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\n\treturn num;\n}\n\nint main(){\n\t\n\tcin >> V;\n\t\n\tcin >> r >> theta;\n\t\n\ttheta = theta * M_PI / 180;\n\t\n\tmat S(V * V, vec(V * V));\n\t\n\tdouble x[30], y[30];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i = 0; i < V * V; i++){\n\t\tE_sz[i] = INF;\n\t\tfor(int j = 0; j < V * V; j++){\n\t\t\tS[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tif(i == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble vx1, vx2, vy1, vy2;\n\t\t\tvx1 = x[j] - x[i];\n\t\t\tvy1 = y[j] - y[i];\n\t\t\tdouble norm1 = sqrt(vx1 * vx1 + vy1 * vy1);\n\t\t\tE_sz[i * V + j] = norm1;\n\t\t\t\n\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\tif(j == k || k == i){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvx2 = x[k] - x[j];\n\t\t\t\tvy2 = y[k] - y[j];\n\t\t\t\tdouble inn = vx1 * vx2 + vy1 * vy2;\n\t\t\t\tdouble norm2 = sqrt(vx2 * vx2 + vy2 * vy2);\n\t\t\t\tdouble th = acos(inn / norm1 / norm2);\n\t\t\t\tif(th < theta){\n\t\t\t\t\tS[i * V + j][j * V + k] = norm2;\n\t\t\t\t\t//S[j * V + i][k * V + j] = norm2;\n\t\t\t\t\t//S[j * V + k][i * V + j] = norm1;\n\t\t\t\t\tS[k * V + j][j * V + i] = norm1;\n\t\t\t\t\t//cout << i * V + j << \" \" << j * V + k << \" \" << norm2 << endl;\n\t\t\t\t\t//cout << k * V + j << \" \" << j * V + i << \" \" << norm1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool flag = true;\n\tfor(int i = 0; i < V * V; i++){\n\t\tif(E_sz[i] < r){\n\t\t\tflag = false;\n\t\t}\n\t}\n\t\n\tif(flag){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << mat_pow(S) + 1 << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (lt(a, b) || equals(a, b))\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\ndouble getAngle(Point a, Point b, Point c)\n{\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\n\n\nint n;\ndouble r, t;\nvector<Point> ps;\n\ndouble d[21][21][10001];\n\nstruct State\n{\n  int now, prev, car;\n  double dist;\n  State(){}\n  State(int now, int prev, int car, int dist):now(now), prev(prev), car(car), dist(dist){}\n  bool operator < (const State& r) const {\n    return dist > r.dist;\n  }\n};\n\nint solve()\n{\n  rep(i, 21) rep(j, 21) rep(k, 10001) d[i][j][k] = 1e10;\n\n  priority_queue<State> que;\n  reps(i, 1, n) {\n    double dist = getDistance(ps[0], ps[i]);\n    if(le(dist, r)) {\n      d[i][0][1] = dist;\n      que.push(State(i, 0, 1, dist));\n    }\n  }\n\n  int ans = 0;\n  while(!que.empty()) {\n    State st = que.top(); que.pop();\n    int now = st.now, prev = st.prev, car = st.car;\n    double dist = st.dist;\n    ans = max(ans, car);\n    if(dist > d[now][prev][car]) continue;\n    rep(i, n) if(i != now) {\n      int di = dist + getDistance(ps[now], ps[i]);\n      if(le(getAngle(ps[prev], ps[now], ps[i]), t) && le(di, r) && d[i][now][car+1] > di) {\n\td[i][now][car+1] = di;\n\tque.push(State(i, now, car+1, di));\n      }\n    }\n  }\n\n  return ans;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> n >> r >> t;\n  ps.resize(n);\n  rep(i, n) cin >> ps[i].x >> ps[i].y;\n\n  cout << solve() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\n#define pow2(a) (pow(1.*a,2))\ntypedef struct D\n{\n\tint c,pp,np;\n\tdouble d;\n\tbool operator <(const D &a)const{ return d>a.d;};\n}D;\n\nint N,X[25],Y[25],res=0;\ndouble R,O,d[25][25],F[30][30][100000];\ndouble ang(int pre,int now,int next)\n{\n\tdouble a=d[pre][now],b=d[now][next],c=d[pre][next];\n\tdouble dd=acos((pow2(a)+pow2(b)-pow2(c))/(2*a*b));\n\tdouble df=180-(dd*180/3.141592);\n\treturn df;\n}\n\nint main()\n{\n\tscanf(\"%d%lf%lf\",&N,&R,&O);\n\tfor(int i=0;i<30;i++)for(int k=0;k<30;k++)for(int j=0;j<1000000;j++)F[i][k][j]=1e14;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",X+i,Y+i);\n\tfor(int i=0;i<N;i++)\n\n\t\tfor(int j=0;j<N;j++)\n\t\t\td[i][j]=sqrt(pow2(X[i]-X[j])+pow2(Y[i]-Y[j]));\n\tpriority_queue<D>Q;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tif(d[0][i]>R)continue;\n\t\tD tmp={1,0,i,d[0][i]};\n\t\tF[0][i][1]=d[0][i];\n\t\tQ.push(tmp);\n\t}\n\tfor(;!Q.empty();)\n\t{\n\t\tD tmp=Q.top();Q.pop();\n\t\tif(F[tmp.pp][tmp.np][tmp.c]<tmp.d)continue;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(i==tmp.np)continue;\n\t\t\tif(ang(tmp.pp,tmp.np,i)<=O&&tmp.d+d[tmp.np][i]<=R)\n\t\t\t{\n\t\t\t\tD ins={tmp.c+1,tmp.np,i,tmp.d+d[tmp.np][i]};\n\t\t\t\tif(F[ins.pp][ins.np][ins.c]>ins.d)\n\t\t\t\t{\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t\tF[ins.pp][ins.np][ins.c]=ins.d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#define scanf_s scanf\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\n\nint main(void){\n\tint n,ans,i,j,k,ok;\n\tdouble r,sit;\n\tdouble x[20];\n\tdouble y[20];\n\tdouble dp[20][20]={0};//x??????y????????????\n\tdouble dpc[20][20]={0};\n\tdouble d;\n\tdouble pi=3.141592653589793238462643383279502884197;\n\tscanf(\"%d\",&n);\n\tscanf(\"%lf %lf\",&r,&sit);\n\tsit=(sit/180)*pi;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i][j]=0;\n\t\t\tdpc[i][j]=big;\n\t\t}\n\t}\n\tfor(ans=0;;ans++){\n\t\tfor(k=0;k<n;k++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(ans!=0&&(k-i)*(i-j)==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(j-k==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(ans==0&&k!=0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td=abs(atan2(y[i]-y[k],x[i]-x[k])-atan2(y[k]-y[j],x[k]-x[j]));\n\t\t\t\t\tif(ans!=0&&min(2*pi-d,d)>sit){continue;}\n\t\t\t\t\tdpc[k][j]=min(dpc[k][j],dp[i][k]+hypot(x[k]-x[j],y[k]-y[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tdp[i][j]=dpc[i][j];\n\t\t\t\tif(dpc[i][j]<r){\n\t\t\t\t\tok=1;\n\t\t\t\t}\n\t\t\t\tdpc[i][j]=big;\n\t\t\t}\n\t\t}\n\t\tif(ok==0){break;}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<int,D> edge;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\nconst D PI=acos(-1);\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return a.X==b.X?a.Y<b.Y:a.X<b.X;\n  }\n}\nbool cmp_x(const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; }\nbool cmp_y(const P& a,const P& b){ return a.Y==b.Y?a.X<b.X:a.Y<b.Y; }\nbool cmp_a(const P& a,const P& b){ return arg(a)==arg(b)?norm(a)<norm(b):arg(a)<arg(b); }\nD cross(P a,P b){ return (conj(a)*b).Y; }\nD dot(P a,P b){ return (conj(a)*b).X; }\nD toRag(D deg){ return deg*PI/180.0; }\nP rot(P base,P a,D theta){ return base+polar(abs(a-base),arg(a-base)+theta); }\n\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nD f(P a,P b){ return acos(dot(a,b)/abs(a)/abs(b))/PI*180; }\n\nint n;\nD r,theta;\nD dp[22][22][10010];\nvector<edge> es[22][22];\nP ps[22];\n\nstruct state{\n  int pre,v,cnt;\n  D d;\n};\nbool operator<(const state& a, const state& b){ return a.d > b.d; }\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n;\n  cin>>r>>theta;\n  rep(i,n){\n    D x,y;\n    cin>>x>>y;\n    ps[i]=P(x,y);\n  }\n  rep(i,n)rep(j,n)rep(k,10010)dp[i][j][k]=inf;\n  rep(i,n)rep(j,n){\n    if(i==j)continue;\n    rep(k,n){ // (i,j) -> k\n      if(i==k||j==k)continue;\n      P v1=ps[j]-ps[i];\n      P v2=ps[k]-ps[j];\n      if(abs(f(v1,v2))<theta){\n        //dbg(i); dbg(j); dbg(k);\n        es[i][j].push_back(edge(k,abs(v2)));\n      }\n    }\n  }\n  priority_queue<state> que;\n  repl(i,1,n){\n    que.push((state){0,i,1,abs(ps[i]-ps[0])});\n  }\n  int res=0;\n  while(que.size()){\n    int pre=que.top().pre,v=que.top().v,cnt=que.top().cnt;\n    D d=que.top().d; que.pop();\n    if(dp[pre][v][cnt]!=inf)continue;\n    if(d<r)maxch(res,cnt);\n    else continue;\n    dp[pre][v][cnt]=d;\n    for(edge nxt : es[pre][v]){\n      que.push((state){v,nxt.fi,cnt+1,d+nxt.se});\n    }\n  }\n  cout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 200\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nint V;\ndouble r, theta, E_sz[500];\n\n// A*B の計算\nmat mul(mat &A, mat &B){\n\tmat C(A.size(), vec(B[0].size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tfor(int j = 0; j < B[0].size(); j++){\n\t\t\tdouble mini = INF;\n\t\t\tfor(int k = 0; k < B.size(); k++){\n\t\t\t\tmini = min(mini, A[i][k] + B[k][j]);\n\t\t\t}\n\t\t\tC[i][j] = mini;\n\t\t}\n\t}\n\treturn C;\n}\n\n// A^n の計算\nint mat_pow(mat A){\n\tmat B(A.size(), vec(A.size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tB[i][i] = 1;\n\t}\n\tint num = 0;\n\twhile(true){\n\t\tB = mul(B, A);\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < V * V; i++){\n\t\t\tfor(int j = 0; j < V * V; j++){\n\t\t\t\tif(B[i][j] + E_sz[i] < r){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\n\treturn num;\n}\n\nint main(){\n\t\n\tcin >> V;\n\t\n\tcin >> r >> theta;\n\t\n\ttheta = theta * M_PI / 180;\n\t\n\tmat S(V * V, vec(V * V));\n\t\n\tdouble x[30], y[30];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i = 0; i < V * V; i++){\n\t\tE_sz[i] = INF;\n\t\tfor(int j = 0; j < V * V; j++){\n\t\t\tS[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tif(i == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble vx1, vx2, vy1, vy2;\n\t\t\tvx1 = x[j] - x[i];\n\t\t\tvy1 = y[j] - y[i];\n\t\t\tdouble norm1 = sqrt(vx1 * vx1 + vy1 * vy1);\n\t\t\tE_sz[i * V + j] = norm1;\n\t\t\t\n\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\tif(j == k || k == i){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvx2 = x[k] - x[j];\n\t\t\t\tvy2 = y[k] - y[j];\n\t\t\t\tdouble inn = vx1 * vx2 + vy1 * vy2;\n\t\t\t\tdouble norm2 = sqrt(vx2 * vx2 + vy2 * vy2);\n\t\t\t\tdouble th = acos(inn * inn / norm1 / norm2);\n\t\t\t\tif(M_PI - th < theta){\n\t\t\t\t\tS[i * V + j][j * V + k] = norm2;\n\t\t\t\t\t//S[j * V + i][k * V + j] = norm2;\n\t\t\t\t\t//S[j * V + k][i * V + j] = norm1;\n\t\t\t\t\tS[k * V + j][j * V + i] = norm1;\n\t\t\t\t\t//cout << i * V + j << \" \" << j * V + k << \" \" << norm2 << endl;\n\t\t\t\t\t//cout << k * V + j << \" \" << j * V + i << \" \" << norm1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool flag = true;\n\tfor(int i = 0; i < V * V; i++){\n\t\tif(E_sz[i] < r){\n\t\t\tflag = false;\n\t\t}\n\t}\n\t\n\tif(flag){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << mat_pow(S) + 1 << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#define scanf_s scanf\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\n\nint main(void){\n\tint n,ans,i,j,k,ok;\n\tdouble r,sit;\n\tdouble x[20];\n\tdouble y[20];\n\tdouble dp[20][20]={0};//x??????y????????????\n\tdouble dpc[20][20]={0};\n\tdouble d;\n\tdouble pi=3.141592653589793238462643383279502884197;\n\tscanf(\"%d\",&n);\n\tscanf(\"%lf %lf\",&r,&sit);\n\tsit=(sit/180)*pi;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i][j]=0;\n\t\t\tdpc[i][j]=big;\n\t\t}\n\t}\n\tfor(ans=0;;ans++){\n\t\tfor(k=0;k<n;k++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif((k-i)*(i-j)*(j-k)==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td=abs(atan2(y[i]-y[k],x[i]-x[k])-atan2(y[k]-y[j],x[k]-x[j]));\n\t\t\t\t\tif(ans!=0&&min(2*pi-d,d)>sit){continue;}\n\t\t\t\t\tdpc[k][j]=min(dpc[k][j],dp[i][k]+hypot(x[k]-x[j],y[k]-y[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tdp[i][j]=dpc[i][j];\n\t\t\t\tif(dpc[i][j]<r){\n\t\t\t\t\tok=1;\n\t\t\t\t}\n\t\t\t\tdpc[i][j]=big;\n\t\t\t}\n\t\t}\n\t\tif(ok==0){break;}\n\t}\n\tprintf(\"%d\\n\",max(ans,1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\n\ndouble dp[22][22][11111], dist[22][22][22];\nint main()\n{\n\tint n; ld r, th;\n\tcin >> n >> r >> th;\n\tvector<Point> ps;\n\tREP(i, n)\n\t{\n\t\tld x, y; cin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\tREP(i, n)REP(j, n)REP(k, n)\n\t{\n\t\tPoint pre = ps[i], now = ps[j], next = ps[k];\n\t\tPoint v1 = now - pre, v2 = next - now;\n\t\tif (i == j || j == k || i == k)\n\t\t{\n\t\t\tdist[i][j][k] = INF;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tld lhs = dot(v1, v2), rhs = abs(v1)*abs(v2)*cos(th / 180.0 * PI);\n\t\t\tif (lhs - rhs > -EPS) dist[i][j][k] = abs(v2);\n\t\t\telse dist[i][j][k] = INF;\n\t\t}\n\t}\n\tREP(i, 22)REP(j, 22)REP(k, 11111) dp[i][j][k] = INF;\n\tdp[0][0][0] = 0;\n\tFOR(i, 1, n) dp[0][i][1] = abs(ps[i] - ps[0]);\n\tFOR(k, 1, 11111)REP(i, n)REP(j, n)\n\t{\n\t\tREP(l, n)\n\t\t{\n\t\t\tif (dist[i][j][l] == INF) continue;\n\t\t\telse chmin(dp[j][l][k + 1], dp[i][j][k] + dist[i][j][l]);\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, 22)REP(j, 22)REP(k, 11111)\n\t{\n\t\tif (dp[i][j][k] <= r) chmax(ans, k);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint x[21],y[21];\ndouble d[21][21];\ndouble dp[10001][21][21];\n\ndouble dir(int i,int j)\n{\n    return sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));\n}\n\ndouble ang(int i,int j,int k)\n{\n    double dott = (x[j]-x[i])*(x[k]-x[j]) + (y[j]-y[i])*(y[k]-y[j]);\n    double cs = dott / d[i][j] / d[j][k];\n    return acos(cs);\n}\n\nint main()\n{\n    int n;\n    double r,th;\n\tscanf(\"%d\",&n);\n    scanf(\"%lf%lf\",&r,&th);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t}\n    rep(i,n){\n        rep(j,n){\n            d[i][j] = dir(i,j);\n        }\n    }\n    rep(i,10001){\n        rep(j,n){\n            rep(k,n){\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n    bool hoge = false;\n    rep(i,n-1){\n        if(d[0][i+1] < r+EPS){\n            dp[1][0][i+1] = d[0][i+1];\n            hoge = true;\n        }\n    }\n    if(!hoge){\n        printf(\"0\\n\");\n        return 0;\n    }\n    vector<int> vec[21][21];\n    rep(i,n){\n        rep(j,n){\n            if(j != i){\n                rep(k,n){\n                    if(ang(i,j,k)*180.0 / M_PI < th+EPS){\n                        vec[i][j].push_back(k);\n                    }\n                }\n            }\n        }\n    }\n    int res;\n    rep(i,10000){\n        bool flag = false;\n        rep(j,n){\n            rep(k,n){\n                if(k != j){\n                    rep(l,vec[j][k].size()){\n                        if(dp[i+1][j][k] + d[k][vec[j][k][l]] < r+EPS){\n                            dp[i+2][k][vec[j][k][l]] = min(dp[i+2][k][vec[j][k][l]],dp[i+1][j][k] + d[k][vec[j][k][l]]);\n                            flag = true;\n                        }\n                    }\n                }\n            }\n        }\n        if(!flag){\n            res = i+1;\n            break;\n        }\n    }\n    printf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ld = long double;\nusing ll = long long;\nconstexpr ld PI = 3.1415926535898;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Pos {\n    ld x;\n    ld y;\n    Pos operator-(const Pos& p) const\n    {\n        return Pos{x - p.x, y - p.y};\n    }\n};\n\nld distance(const Pos& p1, const Pos& p2)\n{\n    return hypot(p1.x - p2.x, p1.y - p2.y);\n}\n\nld dot(const Pos& p1, const Pos& p2)\n{\n    return p1.x * p2.x + p1.y * p2.y;\n}\n\nbool reachable(const Pos& prev, const Pos& now, const Pos& to, const ld theta)\n{\n    if (theta == 180) {\n        return true;\n    } else {\n        return dot(now - prev, to - now) > distance(now, prev) * distance(to, now) * cos(theta / 180.0 * PI);\n    }\n}\n\n\nint main()\n{\n    int n;\n    cin >> n;\n    ld r, theta;\n    cin >> r >> theta;\n\n    vector<Pos> pos(n);\n    for (int i = 0; i < n; i++) {\n        cin >> pos[i].x >> pos[i].y;\n    }\n\n    vector<vector<ld>> d(n, vector<ld>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = distance(pos[i], pos[j]);\n        }\n    }\n\n    vector<vector<vector<int>>> route(n, vector<vector<int>>(n, vector<int>(0)));  // prev->now???????????????to\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                if (k == j) {\n                    continue;\n                }\n                if (reachable(pos[i], pos[j], pos[k], theta)) {\n                    route[i][j].push_back(k);\n                }\n            }\n        }\n    }\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) {\n    //         if (not route[i][j].empty()) {\n    //             cerr << \"## After(\" << i << \"->\" << j << \")##\\n[\";\n    //             for (const int to : route[i][j]) {\n    //                 cerr << to << \",\";\n    //             }\n    //             cerr << \"]\" << endl;\n    //         }\n    //     }\n    // }\n\n    map<pair<int, int>, ld> prev;\n    map<pair<int, int>, ld> dp;\n    for (int i = 1; i < n; i++) {\n        if (d[0][i] <= r) {\n            prev[make_pair(0, i)] = d[0][i];\n        }\n    }\n    for (int i = 0; i < 2 * r; i++) {\n        if (prev.empty()) {\n            cout << i << endl;\n            return 0;\n        }\n        for (const auto& p : prev) {\n            const int from = p.first.first;\n            const int now = p.first.second;\n            const ld length = p.second;\n            for (const int to : route[from][now]) {\n                const ld tot = length + d[now][to];\n                if (tot > r) {\n                    continue;\n                }\n                const auto e = make_pair(now, to);\n                if (dp.find(e) == dp.end()) {\n                    dp[e] = tot;\n                } else {\n                    dp[e] = min(dp[e], tot);\n                }\n            }\n        }\n        // cerr << \"dp = [\";\n        // for (const auto& e : dp) {\n        //     cerr << e << \",\";\n        // }\n        // cerr << \"]\" << endl;\n\n        prev = dp;\n        dp.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n  \nusing namespace std;\n  \n#define MAX_N 20\n#define MAX_C 10001\n#define INF 1e9\n#define EPS 1e-9\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n#define le(a,b) (equal(a,b) || lt(a,b))\n#define PI acos(-1)\n  \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n    \n    Point operator + (const Point &p)const{\n\treturn Point(x+p.x,y+p.y);\n    }\n    Point operator - (const Point &p)const{\n\treturn Point(x-p.x,y-p.y);\n    }\n    Point operator * (double k)const{\n\treturn Point(x*k,y*k);\n    }\n};\n  \nistream &operator >> (istream &is,Point &p){\n    return is >> p.x >> p.y;\n}\n  \nstruct State{\n    double d;\n    int v,p,c;\n    \n    State(double d,int v,int p,int c) : \n\td(d),v(v),p(p),c(c) {}\n    \n    bool operator < (const State &s)const{\n\treturn d > s.d;\n    }\n};\n  \ndouble dot(const Point &a,const Point &b){\n    return a.x*b.x+a.y*b.y;\n}\n  \ndouble norm(const Point &p){\n    return dot(p,p);\n}\n  \ndouble abs(const Point &p){\n    return sqrt(norm(p));\n}\n  \ntypedef Point Vector;\n  \ninline double getAngle(const Vector &a,const Vector &b){\n    return acos(dot(a,b)/abs(a)/abs(b))*180/PI;\n}\n  \ndouble dist(const Point &a,const Point &b){\n    return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n  \nint N;\ndouble r,th,d2[MAX_N][MAX_N];\nbool can[MAX_N][MAX_N][MAX_N];\ndouble d[MAX_N][MAX_N][MAX_C];\n  \nint solve(const vector<Point> &vec){\n    for(int i = 0 ; i < N ; i++){\n\tfor(int j = 0 ; j < N ; j++){\n\t    for(int k = 0 ; k < MAX_C ; k++){\n\t\td[i][j][k] = INF;\n\t    }\n\t}\n    }\n    priority_queue<State> Q;\n    for(int i = 1 ; i < N ; i++){\n\tQ.push(State(dist(vec[0],vec[i]),i,0,1));\n\td[i][0][1] = dist(vec[0],vec[i]);\n    }\n    while(!Q.empty()){\n\tState s = Q.top(); Q.pop();\n\tint v = s.v,p = s.p,c = s.c;\n\tif(lt(d[v][p][c],s.d)) continue;\n\tif(lt(r,s.d)) continue;\n\tfor(int i = 0 ; i < N ; i++){\n\t    if(i == v || i == p) continue;\n\t    if(!can[p][v][i]) continue;\n\t    if(c+1 < MAX_C && lt(d[v][p][c]+d2[v][i],d[i][v][c+1])){\n\t\td[i][v][c+1] = d[v][p][c]+d2[v][i];\n\t\tQ.push(State(d[i][v][c+1],i,v,c+1));\n\t    }\n\t}\n    }\n    int ans = 0;\n    for(int i = 0 ; i < N ; i++){\n\tfor(int j = 0 ; j < N ; j++){\n\t    if(i == j) continue; \n\t    for(int k = MAX_C-1 ; k > 0 ; k--){\n\t\tif(le(d[i][j][k],r)){\n\t\t    ans = max(ans,k);\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    return ans;\n}\n  \nint main(){\n    cin >> N >> r >> th;\n    vector<Point> v(N);\n    for(int i = 0 ; i < N ; i++){\n\tcin >> v[i];\n    }\n    memset(can,false,sizeof(can));\n    for(int i = 0 ; i < N ; i++){\n\tfor(int j = 0 ; j < N ; j++){\n\t    if(i == j) continue; \n\t    for(int k = 0 ; k < N ; k++){\n\t\tif(i == k || j == k) continue;\n\t\tVector a = v[j]-v[i];\n\t\tVector b = v[k]-v[j];\n\t\tdouble angle = getAngle(a,b);\n\t\tif(le(angle,th)){\n\t\t    can[i][j][k] = true;\n\t\t}\n\t    }\n\t}\n    }\n    for(int i = 0 ; i < N ; i++){\n\tfor(int j = 0 ; j < N ; j++){\n\t    d2[i][j] = dist(v[i],v[j]);\n\t}\n    }\n    cout << solve(v) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (lt(a, b) || equals(a, b))\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\ndouble getAngle(Point a, Point b, Point c)\n{\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\n\n\nint n;\ndouble r, t;\nvector<Point> ps;\n\ndouble d[21][21][10001];\n\nint solve()\n{\n  rep(i, 21) rep(j, 21) rep(k, 10001) d[i][j][k] = 1e10;//-1;\n  queue< tuple<int, int, int> > que;\n  reps(i, 1, n) {\n    int dist = getDistance(ps[0], ps[i]);\n    if(le(dist, r)) {\n      d[i][0][1] = dist;\n      que.emplace(i, 0, 1);\n    }\n  }\n\n  int ans = 0;\n  while(!que.empty()) {\n    int now, prev, car;\n    tie(now, prev, car) = que.front(); que.pop();\n    ans = max(ans, car);\n    rep(i, n) if(i != now) {\n      int dist = d[now][prev][car] + getDistance(ps[now], ps[i]);\n      if(le(getAngle(ps[prev], ps[now], ps[i]), t) && le(dist, r) && d[i][now][car+1] > dist) {\n\td[i][now][car+1] = dist;\n\tque.emplace(i, now, car+1);\n      }\n    }\n  }\n\n  return ans;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> n >> r >> t;\n  ps.resize(n);\n  rep(i, n) cin >> ps[i].x >> ps[i].y;\n\n  cout << solve() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nclass Solver {\n    private:\n        double phases[20][20];\n        double distance(int n1, int n2) {\n            int dx = x[n1] - x[n2];\n            int dy = y[n1] - y[n2];\n            return sqrt(dx * dx + dy * dy);\n        }\n        double cosine(int n1, int n2, int n3) {\n            int dot = (x[n1] - x[n2]) * (x[n3] - x[n2]) + (y[n1] - y[n2]) * (y[n3] - y[n2]);\n            return - dot / (distance(n1, n2) * distance(n2, n3));\n        }\n        int find_max(int remainder, int cur, int prev = -1) {\n            int carrots = 0;\n            for (int i = 0; i < n; ++i) {\n                int d = distance(cur, i);\n                if (cur == i || remainder < d) {\n                    continue;\n                }\n                if (prev < 0 || cosine(prev, cur, i) >= cos(theta * M_PI / 180.0)) {\n                    carrots = max(carrots, 1 + find_max(remainder - d, i, cur));\n                }\n            }\n            return carrots;\n        }\n    public:\n        int n;\n        double r, theta;\n        int x[20], y[20];\n        int solve() {\n            return find_max(r, 0);\n        }\n};\n\nint main() {\n    Solver s;\n    cin >> s.n >> s.r >> s.theta;\n    for (int i = 0; i < s.n; ++i) {\n        cin >> s.x[i] >> s.y[i];\n    }\n    cout << s.solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef long double ld;\nconst ld INF = 1e+8;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nint main() {\n  int n;\n  ld r,t,theta;\n  cin>>n>>r>>t;\n  theta = t / 180.0 * pi;\n  VP p;\n  REP(i,n){\n    ld x,y;\n    cin>>x>>y;\n    p.emplace_back(x,y);\n  }\n  int np1 = n+1;\n  int v = np1*np1;\n  vector<vector<int>> g(v);\n  REP(i,n)REP(j,n)REP(k,n) {\n    if (i == j) break;\n    if (j == k) continue;\n    P a = p[j] - p[i], b = p[k] - p[j];\n    ld arga = arg(a);\n    P rotcx = polar<ld>(1.0, -arga);\n    if (abs(arg(b*rotcx)) < theta) {\n      g[j*np1+i].push_back(k*np1+j);\n    }\n  }\n  REP(i,n)REP(j,n) {\n    g[i*np1+n].push_back(j*np1+i);\n  }\n  vector<ld> mind(v, INF);\n  REP(i,n) mind[i*np1+n] = 0;\n  REP(i,r+1) {\n    vector<ld> tmp(v, INF);\n    ld mint = INF;\n    REP(j,v) {\n      for (int nx : g[j]) {\n        int now = nx % np1;\n        int nxt = nx / np1;\n        tmp[nx] = min(tmp[nx], mind[j] + abs(p[nxt] - p[now]));\n        mint = min(mint, tmp[nx]);\n      }\n    }\n    if (mint > r) {\n      cout << i << endl;\n      break;\n    }\n    swap(tmp, mind);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double inf=1e8;\n#define rep(i,a) for(int i=0;i<a;i++)\ndouble dp[20][20][10010];\nint main(){\n  rep(i,20)rep(j,20)rep(k,10010)dp[i][j][k]=inf;\n  int n;\n  double x,y;\n  cin>>n>>x>>y;\n  y*=PI/180;\n  G g(n);\n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    g[i]=P(a,b);\n  }\n  dp[0][0][0]=0;\n  rep(i,10010)rep(j,n)rep(k,n)if(i==0||j!=k){\n    rep(l,n)if(l!=k){\n      double dis=abs(g[k]-g[l]);\n      //if(i==0)printf(\"%.9f %.9f\\n\",x,dis+dp[j][k][l]);\n      if(dis+dp[j][k][i]>x)continue;\n      double q=abs(arg(g[k]-g[j])-arg(g[l]-g[k]));\n      while(q>PI)q=2*PI-q;//q-=PI;\n      if(i==0){\n\tq=0;//abs(arg(g[l]-g[k]));\n      }\n      if(q>y)continue;\n      dp[k][l][i+1]=min(dp[k][l][i+1],dp[j][k][i]+dis);\n    }\n  }\n  int out=0;\n  rep(i,n)rep(j,n)rep(k,10010)if(abs(dp[i][j][k]-inf)>EPS)out=max(out,k);\n  cout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex< double > Point;\nconstexpr double EPS = 1e-8;\nconst double PI = acos( -1 );\nconstexpr Point O( 0, 0 );\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator>> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\ndouble dp[ 10001 ][ 20 ][ 20 ];\ndouble dists[ 20 ][ 20 ];\nbool movable[ 20 ][ 20 ][ 20 ];\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tint N;\n\tcin >> N;\n\n\tdouble R, THETA;\n\tcin >> R >> THETA;\n\n\tTHETA = THETA / 360 * 2 * PI;\n\n\tVT( Point ) ps( N );\n\tcin >> ps;\n\n\tREP( i, N )\n\t{\n\t\tREP( j, i )\n\t\t{\n\t\t\tdists[i][j] = dists[j][i] = abs( ps[i] - ps[j] );\n\t\t}\n\t}\n\tREP( i, N )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tif ( i == j || i == k || j == k )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmovable[i][j][k] = abs( arg( ( ps[k] - ps[j] ) / ( ps[j] - ps[i] ) ) ) <= THETA + EPS;\n\t\t\t}\n\t\t}\n\t}\n\n\tfill( AALL( dp, double ), R * 2 );\n\tdp[0][0][0] = 0;\n\tREP( i, 10000 )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tREP( l, N )\n\t\t\t\t{\n\t\t\t\t\tif ( j == l || ( i && !movable[k][j][l]  ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdp[ i + 1 ][l][j] = min( dp[ i + 1 ][l][j], dp[i][j][k] + dists[j][l] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = 0;\n\tREP( i, 10001 )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tif ( dp[i][j][k] <= R + EPS )\n\t\t\t\t{\n\t\t\t\t\tres = max( res, i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n \ntypedef complex<double> P;\n \nstruct S{\n  int w,p,n;\n  double d;\n  bool operator<(S s)const{\n    return d>s.d;\n  }\n};\n \ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n \nint main(){\n  int n;\n  double r,th;\n  cin>>n>>r>>th;\n  P p[21];\n  for(int i=1;i<=n;i++){\n    int x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<S> que;\n  que.push({1,0,0,0});\n  static bool mem[21][21][22222];\n  int m=0;\n  while(!que.empty()){\n    auto cs=que.top();\n    if(cs.d>r)break;\n    que.pop();\n    m=max(m,cs.n);\n    for(int i=1;i<=n;i++){\n      if(i==cs.w)continue;\n      auto f=p[cs.w]-p[cs.p];\n      auto t=p[i]-p[cs.w];\n      if(cs.p&&acos(min(1.,max(-1.,dot(f,t)/abs(f)/abs(t))))*90>th*acos(0))continue;\n      if(mem[i][cs.w][cs.n+1]++)continue;\n      que.push({i,cs.w,cs.n+1,cs.d+abs(t)});\n    }\n  }\n  cout<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex< double > Point;\nconstexpr double EPS = 1e-8;\nconst double PI = acos( -1 );\nconstexpr Point O( 0, 0 );\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator>> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\ndouble dp[ 10001 ][ 20 ][ 20 ];\ndouble dists[ 20 ][ 20 ];\nbool movable[ 20 ][ 20 ][ 20 ];\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tint N;\n\tcin >> N;\n\n\tdouble R, THETA;\n\tcin >> R >> THETA;\n\n\tTHETA = THETA / 360 * 2 * PI;\n\n\tVT( Point ) ps( N );\n\tcin >> ps;\n\n\tREP( i, N )\n\t{\n\t\tREP( j, i )\n\t\t{\n\t\t\tdists[i][j] = dists[j][i] = abs( ps[i] - ps[j] );\n\t\t}\n\t}\n\tREP( i, N )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tif ( i == j || i == k || j == k )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmovable[i][j][k] = abs( arg( ( ps[k] - ps[j] ) / ( ps[j] - ps[i] ) ) ) <= THETA + EPS;\n\t\t\t}\n\t\t}\n\t}\n\n\tfill( AALL( dp, double ), R * 2 );\n\tdp[0][0][0] = 0;\n\tREP( i, 10000 )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tREP( l, N )\n\t\t\t\t{\n\t\t\t\t\tif ( i && !movable[k][j][l] )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdp[ i + 1 ][l][j] = min( dp[ i + 1 ][l][j], dp[i][j][k] + dists[j][l] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = 0;\n\tREP( i, 10001 )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tif ( dp[i][j][k] <= R + EPS )\n\t\t\t\t{\n\t\t\t\t\tres = max( res, i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-8;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    long double r,theta;\n    cin >> n >> r >> theta;\n    theta=theta/360*2*3.141592653589793;\n    vector<long double> x(n),y(n);\n    rep(i,0,n) cin >> x[i] >> y[i];\n\n    int ans=0;\n    long double dp[20][20];\n    fill_n((long double*)dp,20*20,inf);\n    rep(i,1,n) dp[0][i]=sqrtl((x[i]-x[0])*(x[i]-x[0])+(y[i]-y[0])*(y[i]-y[0]));\n    while(true){\n        if([&]{\n            long double mini=inf;\n            rep(i,0,n) rep(j,0,n) mini=min(mini,dp[i][j]);\n            return mini;\n        }()<r) ++ans;\n        else break;\n\n        long double prev[20][20];\n        memcpy(prev,dp,sizeof(long double)*20*20);\n        fill_n((long double*)dp,20*20,inf);\n        rep(i,0,n) rep(j,0,n) rep(k,0,n){\n            if(i==j or j==k) continue;\n            const long double l1=sqrtl((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));\n            const long double l2=sqrtl((x[k]-x[j])*(x[k]-x[j])+(y[k]-y[j])*(y[k]-y[j]));\n            if(((x[j]-x[i])*(x[k]-x[j])+(y[j]-y[i])*(y[k]-y[j]))/l1/l2<cosl(theta)) continue;\n            dp[j][k]=min(dp[j][k],prev[i][j]+l2);\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst double PI = acos(-1);\nconst double INF = 1e15;\ndouble dp[10010][20][20];\n\nint n;\ndouble r, theta;\ndouble x[20], y[20];\n\ndouble dist(double x1, double y1, double x2, double y2){\n    x1 -= x2, y1 -= y2;\n    return sqrt(x1 * x1 + y1 * y1);\n}\n\ndouble dot(double x1, double y1, double x2, double y2){\n    return x1 * x2 + y1 * y2;\n}\n\nbool check(int v, int u, int pre){\n    double ax = x[v] - x[pre];\n    double ay = y[v] - y[pre];\n    double bx = x[u] - x[v];\n    double by = y[u] - y[v];\n    double da = dist(x[v], y[v], x[pre], y[pre]);\n    double db = dist(x[u], y[u], x[v], y[v]);\n    double t = abs(acos(dot(ax, ay, bx, by) / da / db));\n    //cerr << \"\\t\\t\" << v << \" \" << u << \" \" << pre << \" \" << t << endl;\n    return t <= theta;\n}\n\nint main(){\n    cin >> n >> r >> theta;\n\n    theta *= 2 * PI / 360.0;\n\n    for(int i = 0; i < n; i++){\n        cin >> x[i] >> y[i];\n    }\n\n    for(int i = 0; i < 10010; i++){\n        for(int j = 0; j < n; j++){\n            for(int k = 0; k < n; k++){\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n\n    //cout << check(2, 0, 1) << endl;\n    //return 0;\n    for(int i = 0; i < n; i++){\n        dp[0][i][0] = 0;\n    }\n    for(int i = 0; i <= 10000; i++){\n        for(int v = 0; v < n; v++){\n            for(int pre = 0; pre < n; pre++){\n                double d = dp[i][v][pre];\n                if(d == INF) continue;\n                //cerr << i << \" \" << v << \" \" << pre << \" \" << d << endl;\n                for(int u = 0; u < n; u++){\n                    if(v == u) continue;\n                    if(i != 0 && !check(v, u, pre)) continue;\n                    //cerr << \"\\t\" << v << \" \" << u << endl;\n                    double ndist = d + dist(x[v], y[v], x[u], y[u]);\n                    if(ndist <= r && dp[i + 1][u][v] > ndist){\n                        dp[i + 1][u][v] = ndist;\n                    }\n                }\n            }\n        }\n\n    }\n\n    int ans = 0;\n    for(int i = 0; i <= 10000; i++){\n        for(int v = 0; v < n; v++){\n            for(int pre = 0; pre < n; pre++){\n                double d = dp[i][v][pre];\n                if(d == INF) continue;\n                ans = max(ans, i);\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=0; y=0;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n\n};\n\ndouble dot(P& p, P& q){\n  return p.x*q.x + p.y * q.y;\n}\n\ndouble cross(P& p, P& q){\n  return p.x * q.y - p.y * q.x;\n}\n\ndouble norm(const P& p){\n  return sqrt(p.x*p.x+p.y*p.y);\n}\n\ndouble cos(P& p, P& q){\n  return dot(p,q) / norm(p) / norm(q);\n}\n\nint N;\nint idx(int i, int j){\n  return i*N+j;\n}\n\nVI to[20*20];\nvector<double> cost[20*20];\ndouble dp[20*20][10010];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N;\n  double R, theta; cin >> R >> theta;\n  double lim_sin = theta * PI / 180.;\n  vector<P> ps(N);\n  REP(i,N) cin >> ps[i].x >> ps[i].y;\n\n  REP(i,N) REP(j,N){\n\tif(i == j) continue;\n\tP d = ps[j] - ps[i];\n\tREP(k,N){\n\t  if(k == i || k == j) continue;\n\t  P f = ps[k] - ps[j];\n\t  if(acos(cos(d,f)) <= lim_sin){\n\t\tto[idx(i,j)].PB(idx(j,k));\n\t\tcost[idx(i,j)].PB(norm(ps[k]-ps[j]));\n\t  }\n\t}\n  }\n\n  fill((double*)dp, (double*)dp+20*20*10010, R+100);\n  dp[0][0] = 0;\n  FOR(i,1,N)\n\tdp[idx(0,i)][1] = norm(ps[i] - ps[0]);\n\n  int ans = 0;\n  for(int r=1;r<=R;++r){\n\tfor(int i=0;i<N*N;++i){\n\t  if(dp[i][r] <= R) ans = r;\n\t  else continue;\n\t  for(int j=0;j<SZ(to[i]);++j){\n\t\tint v = to[i][j];\n\t\tdp[v][r+1] = min(dp[v][r+1],\n\t\t\t\t\t\t dp[i][r]+cost[i][j]);\n\t  }\n\t}\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 21;\nconst int MAXX = 10001;\nconst double eps = 1e-2;\nconst double inf = 1e10;\n\nint n;\ndouble r, th;\nP ps[MAXN];\ndouble dp[MAXX][MAXN][MAXN];\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble getAngle(P a, P b) {\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nint main() {\n  while(cin >> n) {\n    cin >> r >> th;\n    th = th * M_PI / 180.0;\n    for(int i = 0; i < n; ++i)\n      cin >> ps[i].real() >> ps[i].imag();\n    fill(dp[0][0], dp[MAXX][0], inf);\n    dp[0][0][0] = 0;\n    int res = 0;\n    for(int i = 0; i+1 < MAXX; ++i) {\n      if(i != res) break;\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < n; ++k) {\n          if(dp[i][j][k] == inf) continue;\n          for(int l = 0; l < n; ++l) {\n            if(k == l) continue;\n            if(j != k) {\n              double rad = getAngle(ps[k]-ps[j], ps[l]-ps[k]);\n              if(rad > th + eps) continue;\n            }\n            dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + abs(ps[l]-ps[k]));\n            if(dp[i+1][k][l] < r + eps) {\n              res = i + 1;\n            }\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> P;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n#define pi acos(-1)\n\ndouble dp[20][20][10001];\n\nint main(){\n    cin.sync_with_stdio(false);\n    int n;\n    double r, theta;\n    cin >> n >> r >> theta;\n    theta = (theta + 1e-3) * pi / 180.0;\n    cout << \"theta = \" << theta << endl;\n    vector<P> v;\n    rep(i, n) {\n        double x, y;\n        cin >> x >> y;\n        v.pb(P(x, y));\n    }\n\n    rep(i, n)rep(j, n)rep(k, 10001) dp[i][j][k] = INF + 1;\n    int ans = 0;\n    repl(i, 1, n) {\n        if (abs(v[i] - v[0]) <= r + 1e-3) {\n            dp[0][i][1] = abs(v[i] - v[0]);\n            ans = 1;\n        }\n    }\n    repl(k, 1, 10000) {\n        if (ans != k) break;\n        rep(i, n)rep(j, n) {\n            if (dp[i][j][k] < INF) {\n                rep(l, n) {\n                    if (j == l || i == l) continue;\n                    double alpha = abs(arg(v[l] - v[j]) - arg(v[j] - v[i]));\n                    if (alpha > pi) alpha = 2 * pi - alpha;\n                    // cout << i << \", \" << j << \", \" << l << \": alpha = \" << alpha << endl;\n                    if (alpha <= theta && dp[i][j][k] + abs(v[l] - v[j]) <= r + 1e-3) {\n                        minch(dp[j][l][k + 1], dp[i][j][k] + abs(v[l] - v[j]));\n                        ans = k + 1;\n\n                        // cout << i << \", \" << j << \", \" << l << \": r = \" << dp[j][l][k + 1] << endl;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int MAX = 20,LIMIT = 20100,IINF = INT_MAX;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nstruct Edge{\n  int to;\n  double weight;\n  Edge(int to=0,double weight=0):to(to),weight(weight){}\n};\n\nstruct Data{\n  int prev,cur,carrot;\n  double dist;\n  Data(int prev=0,int cur=0,int carrot=0,double dist=0):prev(prev),cur(cur),carrot(carrot),dist(dist){}\n  bool operator < (const Data& data) const{ return dist > data.dist; }\n};\n\nint n;\ndouble r,theta,mindist[MAX][MAX][LIMIT]; // mindist[cur][prev][the number of carrot]\nPoint ps[MAX];\nvector<Edge> edge[MAX][MAX]; // edge[cur][prev]\n\ninline void dijkstra(){\n  rep(i,n)rep(j,n)rep(k,LIMIT) mindist[i][j][k] = IINF;\n  priority_queue<Data> Q;\n\n  REP(i,1,n) {\n    double dist = abs(ps[0]-ps[i]);\n    if( !equals(dist,r) && dist > r ) continue;\n    Q.push(Data(0,i,1,dist));\n    mindist[i][0][1] = dist;\n  }\n  int ans = (Q.empty()?0:1);\n\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n    int prev = data.prev, cur = data.cur, carrot = data.carrot;\n    double dist = data.dist;\n\n    if( !equals(mindist[cur][prev][carrot],dist) && mindist[cur][prev][carrot] < dist ) continue;\n\n    rep(i,edge[cur][prev].size()) {\n      int next = edge[cur][prev][i].to;\n      double weight = edge[cur][prev][i].weight;\n      if( !equals(r,dist+weight) && r < dist+weight ) continue;\n      if( mindist[next][cur][carrot+1] > dist + weight ){\n        mindist[next][cur][carrot+1] = dist + weight;\n        assert(carrot+1 < LIMIT);\n        ans = max(ans,carrot+1);\n        Q.push(Data(cur,next,carrot+1,dist+weight));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\ninline void makeEdge(){\n  rep(prev,n){\n    rep(cur,n){\n      if( cur == prev ) continue;\n      rep(next,n){\n        if( next == cur || next == prev ) continue;\n        double dist = abs(ps[cur]-ps[next]);\n        if( !equals(dist,r) && dist > r ) continue;\n        Vector v1 = ps[next] - ps[cur];\n        Vector v2 = ps[cur]  - ps[prev];\n        if( equals(cross(v1,v2),0.0) ) continue;\n        double arg = getArg(ps[prev],ps[cur],ps[next]);\n        if( equals(arg,theta) || arg < theta ) edge[cur][prev].push_back(Edge(next,dist));\n      }\n    }\n  }\n}\n\nint main(){\n\n  /*\n  int next = 2, cur = 1, prev = 0;\n  ps[0] = Point(0,0);\n  ps[1] = Point(10,0);\n  ps[2] = Point(0,1);\n  double arg =  getArg(ps[prev],ps[cur],ps[next]);\n  cout << \"arg = \" << arg * 180.0 / M_PI << endl;\n  */\n\n  cin >> n;\n  cin >> r >> theta;\n  theta = toRad(theta);\n  rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n\n  makeEdge();\n\n  dijkstra();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex< double > Point;\nconstexpr double EPS = 1e-8;\nconstexpr double PI = acos( -1 );\nconstexpr Point O( 0, 0 );\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator>> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\ndouble dp[ 16384 ][ 32 ][ 32 ];\ndouble dists[ 32 ][ 32 ];\nbool movable[ 32 ][ 32 ][ 32 ];\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tint N;\n\tcin >> N;\n\n\tdouble R, THETA;\n\tcin >> R >> THETA;\n\n\tTHETA = THETA / 360 * 2 * PI;\n\n\tVT( Point ) ps( N );\n\tcin >> ps;\n\n\tREP( i, N )\n\t{\n\t\tREP( j, i )\n\t\t{\n\t\t\tdists[i][j] = dists[j][i] = abs( ps[i] - ps[j] );\n\t\t}\n\t}\n\tREP( i, N )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tif ( i == j || i == k || j == k )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmovable[i][j][k] = abs( arg( ( ps[k] - ps[j] ) / ( ps[j] - ps[i] ) ) ) <= THETA + EPS;\n\t\t\t}\n\t\t}\n\t}\n\n\tfill( AALL( dp, double ), R * 2 );\n\tdp[0][0][0] = 0;\n\tREP( i, 10000 )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tREP( l, N )\n\t\t\t\t{\n\t\t\t\t\tif ( i && !movable[k][j][l] )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdp[ i + 1 ][l][j] = min( dp[ i + 1 ][l][j], dp[i][j][k] + dists[j][l] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = 0;\n\tREP( i, 10001 )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tif ( dp[i][j][k] <= R + EPS )\n\t\t\t\t{\n\t\t\t\t\tres = max( res, i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nconst int MOD = 1000000007;\n\ntemplate <typename T>\nvoid __dump__(std::ostream &os, const T &first) {\n    os << first;\n}\ntemplate <typename First, typename... Rest>\nvoid __dump__(std::ostream &os, const First &first, const Rest &... rest) {\n    os << first << \", \";\n    __dump__(os, rest...);\n}\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __dump__(os, __VA_ARGS__);                        \\\n        std::cerr << os.str() << std::endl;               \\\n    } while (0)\n\nusing P = complex<double>;\nP ps[21];\n\nconst double EPS = 1e-9;\nconst double INF = 1e9;\nvector<int> go[21][21];\ndouble dp[10001][21][21];\ndouble d[21][21];\n\nint main() {\n    int n;\n    double r, th;\n    cin >> n >> r >> th;\n    th = th*acos(-1)/180;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        ps[i] = P(x, y);\n    }\n    rep(i, n) rep(j, n) {\n        if (i == j) continue;\n        go[i][j].clear();\n        rep(k, n) {\n            if (j == k) continue;\n            double phi = arg((ps[k] - ps[j]) / (ps[j] - ps[i]));\n            if (abs(phi) <= th + EPS) {\n                go[i][j].push_back(k);\n                //dump(i, j, k);\n            }\n        }\n        d[i][j] = abs(ps[i] - ps[j]);\n    }\n    rep(i, 10001) rep(j, 21) rep(k, 21) dp[i][j][k] = INF;\n    rep(i, n) if (i && d[0][i] <= r + EPS) dp[1][0][i] = d[0][i];\n    FOR(i, 1, 10001) {\n        rep(j, n) rep(k, n) {\n            if (dp[i][j][k] == INF) continue;\n            for (auto &l : go[j][k]) {\n                dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + d[k][l]);\n            }\n        }\n    }\n    double ans = 0;\n    rrep(i, 10001) rep(j, n) rep(k, n) {\n        if (dp[i][j][k] <= r + EPS) {\n            //dump(i, j, k);\n            ans = i;\n            goto END;\n        }\n    }\n END:;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\n\nint n;\ndouble r,d;\nP p[20];\ndouble dp[10001][20][20];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint main(){\n  cin>>n>>r>>d;\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)dp[i][j][k]=1e9;\n  dp[0][0][0]=0;\n\n  for(int i=0;i<=r;i++){\n    bool f=1;\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++){\n\tfor(int l=0;l<n;l++)\n\t  if(check(j,k,l))\n\t    dp[i+1][k][l]=min(dp[i+1][k][l],dp[i][j][k]+abs(p[k]-p[l]));\n\tf&=dp[i][j][k]==1e9;\n      }\n    if(f)break;\n  }\n  int ans=0;\n  for(int i=1;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tif(dp[i][j][k]<=r)ans=i;\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\ndouble dp[20][20][25000];\nconst double PI = 3.1415926535;\nint main(){\n  int n,i,j,k,ans=0;cin>>n;\n  double r,arc;cin>>r>>arc;\n  arc=PI/180.0*arc;\n  Polygon g;g.resize(n);\n  for(i=0;i<n;i++) cin>>g[i].x>>g[i].y;\n  double e[n][n][n],inf=1<<28;\n  fill(e[0][0],e[0][0]+n*n*n,inf);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      for(k=0;k<n;k++){\n\tif(i==j||j==k||k==i) continue;\n\tVector a=g[j]-g[i],b=g[k]-g[j];\n\tif(fabs(acos(dot(a,b)/(abs(a)*abs(b))))<=arc)\n\t  e[i][j][k]=abs(g[k]-g[j]);\n      }\n    }\n  }\n  for(k=1;k<n;k++) e[0][0][k]=abs(g[k]-g[0]);\n  \n  fill(dp[0][0],dp[0][0]+20*20*25000,inf);\n  typedef pair<int,int> P;\n  typedef pair<int,P> PP;\n  typedef pair<double,PP> PPP;\n  priority_queue<PPP,vector<PPP>,greater<PPP> > q;\n  q.push(PPP(0.0,PP(0,P(0,n))));\n  while(!q.empty()){\n    PPP ppp=q.top();q.pop();\n    double d=ppp.first,z;\n    PP pp=ppp.second;\n    k=pp.first;\n    P p=pp.second;\n    if(d>r) continue;\n    ans=max(ans,k);\n    if(p.second==n){\n      for(i=0;i<n;i++){\n\tz=inf;\n\tfor(j=0;j<n;j++) z=min(z,e[j][0][i]);\n\tq.push(PPP(d+z,PP(k+1,P(i,p.first))));\n      }\n    }else{\n      if(dp[p.first][p.second][k]<=d) continue;\t\n      dp[p.first][p.second][k]=d;\n      for(i=0;i<n;i++)\n\tif(dp[i][p.first][k+1]>d+e[p.second][p.first][i])\n\t  q.push(PPP(d+e[p.second][p.first][i],PP(k+1,P(i,p.first))));\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nstruct edge {\n\tint to;\n\tdouble cost;\n\tedge(int t, double c):to(t), cost(c){}\n};\n\nstruct state {\n\tint pos, prev, num;\n\tdouble dist;\n\tstate(int p, int pr, int n, double d):pos(p), prev(pr), num(n), dist(d){}\n\n\tbool operator>(const state& s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\nint n;\ndouble r, theta;\nconst int MAX_N = 20;\nint x[MAX_N], y[MAX_N];\nvector<edge> es[MAX_N][MAX_N];\n\ndouble calc_dist(int sx, int sy, int tx, int ty) {\n\treturn hypot(sx - tx, sy - ty);\n}\n\ndouble turn(int ax, int ay, int bx, int by) {\n\tconst double dot = ax * bx + ay * by, a_d = hypot(ax, ay), b_d = hypot(bx, by);\n\treturn M_PI - fabs(acos(dot / (a_d * b_d)));\n}\n\nint search(int start) {\n\tpriority_queue<state, vector<state>, greater<state> > que;\n\tvector<vector<int> > cnt(n, vector<int>(n, 0));\n\tvector<vector<double> > dist(n, vector<double>(n, INT_MAX));\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(i == start)\n\t\t\tcontinue;\n\n\t\tconst double d = calc_dist(x[start], y[start], x[i], y[i]);\n\t\tif(d > r)\n\t\t\tcontinue;\n\n\t\tque.push(state(i, start, 1, d));\n\t\tcnt[start][i] = 1;\n\t\tdist[start][i] = d;\n\t}\n\n\tint res = 0;\n\twhile(!que.empty()) {\n\t\tconst state s = que.top();\n\t\tque.pop();\n\n\t\tif(s.num < cnt[s.prev][s.pos] ||\n\t\t   s.num == cnt[s.prev][s.pos] && s.dist > dist[s.prev][s.pos])\n\t\t\tcontinue;\n\n\t\tchmax(res, s.num);\n\n\t\tconst int car = s.num + 1;\n\t\tfor(int i = 0; i < es[s.prev][s.pos].size(); ++i) {\n\t\t\tconst edge& e = es[s.prev][s.pos][i];\n\t\t\tconst double d = s.dist + e.cost;\n\t\t\tif(d > r)\n\t\t\t\tcontinue;\n\n\t\t\tif(cnt[s.pos][e.to] < car ||\n\t\t\t   cnt[s.pos][e.to] == car && dist[s.pos][e.to] > d) {\n\t\t\t\tcnt[s.pos][e.to] = car;\n\t\t\t\tdist[s.pos][e.to] = d;\n\t\t\t\tque.push(state(e.to, s.pos, car, d));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> r >> theta;\n\ttheta = theta / 180.0 * M_PI;\n\n\tfor(int i = 0; i < n; ++i)\n\t\tcin >> x[i] >> y[i];\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(i == j)\n\t\t\t\tcontinue;\n\n\t\t\tfor(int k = i + 1; k < n; ++k) {\n\t\t\t\tif(j == k)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(turn(x[i] - x[j], y[i] - y[j], x[k] - x[j], y[k] - y[j]) <= theta) {\n\t\t\t\t\tes[i][j].push_back(edge(k, calc_dist(x[k], y[k], x[j], y[j])));\n\t\t\t\t\tes[k][j].push_back(edge(i, calc_dist(x[i], y[i], x[j], y[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << search(0) << endl;\t\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double INF = (double)(1<<29);\nconst double EPS = 1e-7;\n\nint n, ans;\nvector<int> G[20][20];\ndouble r, theta, memo[20][20][10001];\nP v[20];\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\ndouble calcTheta(P a, P b, P c){\n  double A = abs(b - a);\n  double B = abs(b - c);\n  double C = abs(a - c);\n  double ans = acos((A*A + B*B - C*C) / (2*A*B));\n  return M_PI - ans;\n}\n\nvoid dfs(int prev, int pos, int sum, double dis){\n  //if(memo[prev][pos][sum] <= dis || equal(memo[prev][pos][sum],dis)) return;\n  ans = max(ans,sum);\n  for(int i=0;i<G[prev][pos].size();i++){\n    int next = G[prev][pos][i];\n    if(dis + abs(v[pos]-v[next]) > r || memo[pos][next][sum+1] <= dis + abs(v[pos]-v[next]) || equal(memo[pos][next][sum+1],dis + abs(v[pos]-v[next]))) continue;\n    memo[pos][next][sum+1] = dis + abs(v[pos]-v[next]);\n    dfs(pos, next, sum+1, dis+abs(v[pos]-v[next]));\n  }\n}\n\n\nint main(){\n  while(cin >> n){\n    ans = 0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        G[i][j].clear();\n        for(int k=0;k<10001;k++) memo[i][j][k] = INF;\n      }\n    }\n\n    cin >> r >> theta;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      v[i] = P(x,y);\n    }\n    theta *= M_PI / 180.0;\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        for(int k=0;k<n;k++){\n          if(i == k || j == k) continue;\n          if(calcTheta(v[i],v[j],v[k]) < theta) G[i][j].push_back(k);\n        }\n      }\n    }\n\n    for(int i=1;i<n;i++){\n      if(abs(v[i]-v[0]) > r) continue;\n      memo[0][i][1] = abs(v[i]-v[0]);\n      dfs(0, i, 1, abs(v[i]-v[0]));\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\ntypedef complex<double> Point;\n\ndouble angle(const Point& v1, const Point& v2) {\n    double res = arg(v1 / v2);\n    if (res < 0) res += 2*pi;\n    return min(2*pi-res, res);\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n; cin >> n;\n    double R, th; cin >> R >> th; th *= pi / 180;\n    vector<Point> v(n);\n    REP(i, n) {\n        ll x, y; cin >> x >> y;\n        v[i] = Point(x, y);\n    }\n    vector<vector<vector<bool>>> G(n, vector<vector<bool>>(n, vector<bool>(n, false)));\n    REP(i, n) REP(j, n) REP(k, n) {\n        if (i == j || j == k || k == i) continue;\n        // i -> j -> k テ」ツ?ィテ」ツ??」ツ?妥」ツつ凝」ツ??\n        Point v1 = v[j] - v[i];\n        Point v2 = v[k] - v[j];\n        if (angle(v1, v2) <= th+eps) {\n            G[i][j][k] = true;\n        }\n    }\n    vector<vector<double>> dist(n, vector<double>(n));\n    REP(i, n) REP(j, n) dist[i][j] = abs(v[i]-v[j]);\n    ll ans = 0;\n    vector<vector<vector<double>>> dp(2, vector<vector<double>>(n, vector<double>(n, linf)));\n    dp[0][0][0] = 0;\n    REP(t, 10010) {\n        dp[t+1&1].assign(n, vector<double>(n, linf));\n        REP(prev, n) REP(now, n) {\n            double l = dp[t&1][prev][now];\n            if (l > R+eps) continue;\n            ans = max(ans, t);\n            REP(to, n) {\n                if (prev != now && !G[prev][now][to]) continue;\n                if (now == to) continue;\n                dp[t+1&1][now][to] = min(dp[t+1&1][now][to], l + dist[now][to]);\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n#define F first\n#define S second\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<double,int>P1;\ntypedef pair<int,int>P2;\ntypedef pair<P1,P2>P3;\nint n,ans;\nP p[21];\nD r,qu,dp[10001][21][21],t[21][21];\nint main(){\n  cin>>n>>r>>qu;\n  rep(i,10001)rep(j,21)rep(k,21)dp[i][j][k]=1e15;\n  rep(i,n){\n    D x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<P3,vector<P3>,greater<P3> >q;\n  for(int i=1;i<n;i++){\n    if(abs(p[0]-p[i])>r)continue;\n    dp[1][0][i]=abs(p[0]-p[i]);\n    q.push(P3(P1(dp[1][0][i],1),P2(0,i)));\n  }\n  rep(i,n)rep(j,n)t[i][j]=abs(p[i]-p[j]);\n  while(!q.empty()){\n    P3 ppp=q.top();q.pop();\n    int pre=ppp.S.F;\n    int now=ppp.S.S;\n    int num=ppp.F.S;\n    double cost=ppp.F.F;\n    if(dp[num][pre][now]<cost)continue;\n    rep(i,n)if(now!=i){\n      D a=t[pre][now];\n      D b=t[now][i];\n      D c=t[pre][i];\n      D radi=acos((a*a+b*b-c*c)/(2*a*b));\n      radi=radi/M_PI*180;\n      if(180.0-radi > qu)continue;\n      if(cost+abs(p[now]-p[i])>r)continue;\n      if(dp[num+1][now][i]<=cost+t[i][now])continue;\n      dp[num+1][now][i]=cost+t[i][now];\n      q.push(P3(P1(dp[num+1][now][i],num+1),P2(now,i)));\n    }\n  }\n  dp[0][0][0]=1;\n  for(int i=10000;i>=0;i--){\n    rep(j,21)rep(k,21)if(dp[i][j][k]!=1e15){\n      cout<<i<<endl;\n      return 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=double;\nusing P=complex<ld>;\nconst ld pi=acos(-1);\nstruct State{\n    int v,pre;\n    int c; \n};\n\nbool operator<(const State& lhs,const State& rhs){\n    return true;\n}\n\nint idx(State st){\n    return st.v+20*st.pre+st.c*20*20;\n}\nint main(){\n    int n;\n    cin>>n;\n    ld r,theta;\n    cin>>r>>theta;\n    theta=(theta)/180*pi;\n    vector<P> xy(n);\n    for(int i=0;i<n;i++){\n        ld tmpx,tmpy;\n        cin>>tmpx>>tmpy;\n        xy[i]={tmpx,tmpy};\n    }\n    int res=0;\n    priority_queue<pair<ld,State>,vector<pair<ld,State>>,greater<>> que;\n    que.push({ld(0),State{0,0,0}});\n    const ld INF=1e9;\n    vector<ld> dist(5*1e6,INF);\n    vector<ld> check(5*1e6,INF);\n    dist[0]=0;\n    while(!que.empty()){\n        auto tmp=que.top(); que.pop();\n        auto ret=tmp.second;\n        int v=ret.v,pre=ret.pre;\n        int c=ret.c;\n        int id=idx(ret);\n        ld w=tmp.first;\n        if(check[id]) continue;\n        if(w>r) break;\n        res=max(res,c);\n        for(int i=0;i<n;i++){\n            if(i!=v && i!=pre){\n                if(pre!=v){\n                    ld phi=arg((xy[i]-xy[v])/(xy[v]-xy[pre]));\n                    if(phi>pi) phi-=2*pi;\n                    if(abs(phi)>theta){\n                        continue;\n                    }\n                }\n                State to{i,v,c+1};\n                int toidx=idx(to);\n                if(w+abs(xy[i]-xy[v])<dist[toidx]){\n                    dist[toidx]=w+abs(xy[i]-xy[v]);\n                    que.push({dist[toidx],to});\n                }\n            }\n        }\n\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst long double PI = 3.14159255358979323846264338327950288l;\nstruct Point { long double px, py; };\nlong double theta(long double a, long double b, long double c) {\n\tlong double s = (a + b + c) / 2.0l;\n\tlong double S = sqrtl(s*(s - a)*(s - b)*(s - c));\n\tlong double A = -1000, B = -1000, C = -1000, H;\n\n\tif (a > b && a > c) { H = 2.0l * S / a; B = asin(H / c)*180.0l / PI; C = asin(H / b)*180.0l / PI; A = 180.0l - B - C; }\n\telse if (b > a && b > c) { H = 2.0l * S / b; A = asin(H / c)*180.0l / PI; C = asin(H / a)*180.0l / PI; B = 180.0l - A - C; }\n\telse { H = 2.0l * S / c; A = asin(H / b)*180.0l / PI; B = asin(H / a)*180.0l / PI; C = 180.0l - A - B; }\n\n\treturn A;\n}\nlong double theta_(Point a, Point b, Point c) {\n\t//a->b->c\n\tlong double A1 = sqrtl((a.px - c.px)*(a.px - c.px) + (a.py - c.py)*(a.py - c.py));\n\tlong double B1 = sqrtl((a.px - b.px)*(a.px - b.px) + (a.py - b.py)*(a.py - b.py));\n\tlong double C1 = sqrtl((b.px - c.px)*(b.px - c.px) + (b.py - c.py)*(b.py - c.py));\n\treturn theta(A1, B1, C1);\n}\nlong double dp[20000][30][30], r, t; Point x[30]; int n;\nint main() {\n\tcin >> n >> r >> t;\n\tfor (int i = 0; i < n; i++)cin >> x[i].px >> x[i].py;\n\tfor (int i = 0; i < 20000; i++) { for (int j = 0; j < 30; j++) { for (int k = 0; k < 30; k++) { dp[i][j][k] = 999999999.9l; } } }\n\tfor (int i = 0; i < n; i++) { dp[1][0][i] = sqrtl((x[0].px - x[i].px)*(x[0].px - x[i].px) + (x[0].py - x[i].py)*(x[0].py - x[i].py)); }\n\tfor (int i = 1; i < 15000; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tif (j == k || k == l)continue;\n\t\t\t\t\tlong double T = theta_(x[j], x[k], x[l]); T = 180.0l - T;\n\t\t\t\t\tlong double dst = sqrtl((x[k].px - x[l].px)*(x[k].px - x[l].px) + (x[k].py - x[l].py)*(x[k].py - x[l].py));\n\t\t\t\t\tif (T >= t)continue;\n\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][k] + dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = 0;\n\tfor (int i = 0; i < 20000; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (dp[i][j][k] <= r)maxn = max(maxn, i);\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define fs first\n#define sc second\n#define pb push_back\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<D,int> Edge;\ntypedef pair<Edge, pair<int,int> > state;\n\nconst D PI = acos(-1);\nconst D EPS = 1e-8;\n\ninline D dis(D x1, D y1, D x2, D y2){\n  return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\ninline D dot(P x, P y){ return real(conj(x)*y); }\n\ninline D base(P a,P b,P c){ return dot(b-a,c-b)/abs(b-a)/abs(c-b);}\ninline D arg(P a, P b, P c){ return acos(dot(b-a,c-b)/abs(b-a)/abs(c-b)); }\n\nint n;\nD r,s;\nP p[30];\nD d[30][30];\nvector<Edge> g[30][30];\nD lensum[30][30][1010];\n\nint main(){ \n  cin >> n >> r >> s;\n  s *= PI/180;\n  rep(i,n)cin >> p[i].real() >> p[i].imag();\n  rep(i,n){\n    d[i+1][i+1] = 0;\n    for(int j=i+1;j<n;j++){\n      d[i+1][j+1] = d[j+1][i+1] = abs(p[i]-p[j]);\n    }\n  }\n  \n  rep(i,n){\n    if(i)g[0][1].pb(Edge(d[1][i],i));\n  }\n\n  rep(i,n){\n    rep(j,n){\n      if(i==j)continue;\n      rep(k,n){\n\tif(j==k || i==k)continue;\n\tD seta = arg(p[i],p[j],p[k]);\n\tif(abs(base(p[i],p[j],p[k])-1.0)<EPS)seta = 0.0;\n\telse if(abs(base(p[i],p[j],p[k])+1.0)<EPS)seta = PI;\n\tif(seta < s + EPS){\n\t  g[i+1][j+1].pb(Edge(d[j+1][k+1],k+1));\n\t}\n      }\n    }\n  }\n\n  rep(i,n+1)rep(j,n+1)rep(k,1010)lensum[i][j][k] = 1e10;\n  lensum[0][1][0] = 0;\n  priority_queue<state,vector<state>,greater<state> > q;\n  q.push(mk(mk(0,0),mk(0,1)));\n\n  int ans = 0;\n  while(q.size()){\n    state tmp = q.top(); q.pop();\n    D len = tmp.fs.fs;\n    int carrot = tmp.fs.sc+1, prv = tmp.sc.fs, cur = tmp.sc.sc;\n\n    rep(i,g[prv][cur].size()){\n      D cost = g[prv][cur][i].fs;\n      int nxt = g[prv][cur][i].sc;\n\n      if(len + cost > r + EPS)continue;\n      if(lensum[cur][nxt][carrot] > len + cost + EPS){\n\tlensum[cur][nxt][carrot] = len + cost;\n\tq.push(state(mk(len+cost,carrot),mk(cur,nxt)));\n\tans = max(ans,carrot);\n      }\n    }\n  }\t\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\n// distance between (x1,y1) and (x2,y2)\ndouble cdis(double x1, double y1, double x2, double y2) {\n  return sqrtl((x1 - x2) * (x1 - x2) +\n               (y1 - y2) * (y1 - y2));\n}\n// cos a\ndouble costh(double a, double b, double c) {\n  return (b * b + c * c - a * a) / (2.0 * b * c);\n}\ndouble r, t;\nint n;\npair<double, double> c[25];\ndouble dis[25][25] = {0};\n// possible? i -> j -> k\nbool ch[25][25][25] = {0};\ndouble dp[25][25][10000] = {0};\n\nint solve();\n\nint main() {\n  cin >> n >> r >> t;\n  for(int i = 0; i < n; ++i) {\n    double x, y;\n    cin >> x >> y;\n    c[i] = make_pair(x, y);\n  }\n  for(int i = 0; i < n; ++i)\n    for(int j = i + 1; j < n; ++j)\n      dis[i][j] = dis[j][i] =\n          cdis(c[i].fi, c[i].se, c[j].fi, c[j].se);\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j)\n      for(int k = 0; k < n; ++k) {\n        if(i == j || j == k) continue;\n        double a = dis[i][k], b = dis[i][j], c = dis[j][k];\n        if(180.0 - acos(costh(a, b, c)) * 180 / M_PI <= r &&\n           fabs(c - a + b) > 0.0001 &&\n           fabs(b - a + c) > 0.0001)\n          ch[i][j][k] = 1;\n      }\n\n  cout << solve() << endl;\n  return 0;\n}\n\nint solve() {\n  int ans = 0;\n  for(int i = 1; i < n; ++i)\n    if(dis[0][i] <= r) {\n      dp[0][i][1] = dis[0][i];\n      ans = 1;\n    }\n  if(ans == 0) return ans;\n  // i -> j -> l\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j)\n      for(int l = 0; l < n; ++l) {\n        if(i == j || j == l || (!ch[i][j][l]) ||\n           dp[i][j][k - 1] == 0 ||\n           dp[i][j][k - 1] + dis[j][l] > r)\n          continue;\n        if(dp[j][l][k] == 0) {\n          ans = k;\n          dp[j][l][k] = dp[i][j][k - 1] + dis[j][l];\n        }\n        else\n          dp[j][l][k] =\n              min(dp[j][l][k], dp[i][j][k - 1] + dis[j][l]);\n      }\n  if(ans != k) break;\n}\nreturn ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdlib>\n#include <queue>\n#include <complex>\n#include <algorithm>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\ndouble dp[20][20][10000 + 10];\n\ninline bool ok(const P &p1, const P &p2, const P &p3, const double rad){\n  P s1 = p2 - p1;\n  P s2 = p3 - p2;\n  return std::abs(arg(s2 / s1)) < rad + EPS;\n}\n\nint main(){\n  int n;\n  double r, theta;\n  double rad;\n\n  cin >> n >> r >> theta;\n  rad = M_PI * theta / 180.0;\n\n  vector<P> p(n);\n  REP(i,n) cin >> p[i].real() >> p[i].imag();\n\n  REP(i,n) REP(j,n) REP(k, (int)(r + 5.0))\n    dp[i][j][k] = r + 1000.0;\n\n  REP(i,n) if(i != 0) dp[0][i][1] = std::abs(p[i] - p[0]);\n\n  int ans = 0;\n  REP(k, (int)(r + 3.0)) REP(i,n) REP(j,n) if(i != j && dp[i][j][k] < r + 100.0){\n      if(dp[i][j][k] < r + EPS){\n        ans = k;\n        // cout << i << \" \" << j << \" \" << k << \": \" << dp[i][j][k] << endl;\n      }\n      REP(l,n) if(l != j && l != i && ok(p[i], p[j], p[l], rad)){\n        // cout << l << endl;\n        dp[j][l][k + 1] = min(dp[j][l][k + 1], dp[i][j][k] + std::abs(p[j] - p[l]));\n      }\n    }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 200\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nint V;\ndouble r, theta, E_sz[500];\n\n// A*B の計算\nmat mul(mat &A, mat &B){\n\tmat C(A.size(), vec(B[0].size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tfor(int j = 0; j < B[0].size(); j++){\n\t\t\tdouble mini = INF;\n\t\t\tfor(int k = 0; k < B.size(); k++){\n\t\t\t\tmini = min(mini, A[i][k] + B[k][j]);\n\t\t\t}\n\t\t\tC[i][j] = mini;\n\t\t}\n\t}\n\treturn C;\n}\n\n// A^n の計算\nint mat_pow(mat A){\n\tmat B(A.size(), vec(A.size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tB[i][i] = 1;\n\t}\n\tint num = 0;\n\twhile(true){\n\t\tB = mul(B, A);\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < V * V; i++){\n\t\t\tfor(int j = 0; j < V * V; j++){\n\t\t\t\tif(B[i][j] + E_sz[i] < r){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\n\treturn num;\n}\n\nint main(){\n\t\n\tcin >> V;\n\t\n\tif(V == 1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcin >> r >> theta;\n\t\n\ttheta = theta * M_PI / 180;\n\t\n\tmat S(V * V, vec(V * V));\n\t\n\tdouble x[30], y[30];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i = 0; i < V * V; i++){\n\t\tE_sz[i] = INF;\n\t\tfor(int j = 0; j < V * V; j++){\n\t\t\tS[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\tif(i == j || j == k || k == i){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble vx1, vx2, vy1, vy2;\n\t\t\t\tvx1 = x[j] - x[i];\n\t\t\t\tvy1 = y[j] - y[i];\n\t\t\t\tvx2 = x[k] - x[j];\n\t\t\t\tvy2 = y[k] - y[j];\n\t\t\t\tdouble inn = vx1 * vx2 + vy1 * vy2;\n\t\t\t\tdouble norm1 = sqrt(vx1 * vx1 + vy1 * vy1);\n\t\t\t\tdouble norm2 = sqrt(vx2 * vx2 + vy2 * vy2);\n\t\t\t\tE_sz[i * V + j] = norm1;\n\t\t\t\tE_sz[k * V + j] = norm2;\n\t\t\t\tdouble th = acos(inn * inn / norm1 / norm2);\n\t\t\t\tif(M_PI - th < theta){\n\t\t\t\t\tS[i * V + j][j * V + k] = norm2;\n\t\t\t\t\t//S[j * V + i][k * V + j] = norm2;\n\t\t\t\t\t//S[j * V + k][i * V + j] = norm1;\n\t\t\t\t\tS[k * V + j][j * V + i] = norm1;\n\t\t\t\t\t//cout << i * V + j << \" \" << j * V + k << \" \" << norm2 << endl;\n\t\t\t\t\t//cout << k * V + j << \" \" << j * V + i << \" \" << norm1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << mat_pow(S) + 1 << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define R 10000\n#define N 20\nusing namespace std;\ntypedef pair<double,int> P;\ntypedef pair<int,int> P1;\ntypedef pair<P,P1> P2;\nvector<P> e[N][N];\ndouble d[R][N][N];\nint n,x[N],y[N];\ndouble r,sita;\n\nbool check(int a,int b,int c){\n  int Y=y[a]-y[b],X=x[a]-x[b];\n  double A=sqrt(Y*Y+X*X);\n  Y=y[b]-y[c],X=x[b]-x[c];\n  double B=sqrt(Y*Y+X*X);\n  Y=y[c]-y[a],X=x[c]-x[a];\n  double C=sqrt(Y*Y+X*X);\n  return M_PI-acos((A*A+B*B-C*C)/(2*A*B))<=sita/180*M_PI;\n}\n\nint dijkstra(){\n  priority_queue<P2,vector<P2>,greater<P2> > q;\n  int res=0;\n  for(int k=0;k<r;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n      \td[k][i][j]=INF;\n  for(int i=1;i<n;i++){\n    int Y=y[0]-y[i],X=x[0]-x[i];\n    if(sqrt(Y*Y+X*X)<=r){\n      q.push(P2(P(sqrt(Y*Y+X*X),1),P1(0,i)));\n      d[1][0][i]=sqrt(Y*Y+X*X);\n      res=1;\n    }\n  }\n  while(!q.empty()){\n    P2 t=q.top(); q.pop();\n    int prevu=t.second.first;\n    int u=t.second.second;\n    int c=t.first.second;\n    double cost=t.first.first;\n    if(d[c][prevu][u]<cost)continue;\n    for(int i=0;i<e[prevu][u].size();i++){\n      double ncost=cost+e[prevu][u][i].first;\n      int nu=e[prevu][u][i].second;\n      if(ncost<=r&&d[c+1][u][nu]>ncost){\n\tres=max(res,c+1);\n\td[c+1][u][nu]=ncost;\n\tq.push(P2(P(ncost,c+1),P1(u,nu)));\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>n>>r>>sita;\n  for(int i=0;i<n;i++)\n    cin>>x[i]>>y[i];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      for(int k=0;k<n;k++){\n\tif(i==k||j==k)continue;\n\tif(check(i,j,k)){\n\t  int Y=y[j]-y[k],X=x[j]-x[k];\n\t  e[i][j].push_back(P(sqrt(Y*Y+X*X),k));\n\t}\n      }\n    }\n  cout<<dijkstra()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define fs first\n#define sc second\n#define pb push_back\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<D,int> Edge;\ntypedef pair<Edge, pair<int,int> > state;\n\nconst D PI = acos(-1);\nconst D EPS = 1e-8;\n\ninline D dis(D x1, D y1, D x2, D y2){\n  return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\ninline D dot(P x, P y){ return real(conj(x)*y); }\n\ninline D base(P a,P b,P c){ return dot(b-a,c-b)/abs(b-a)/abs(c-b);}\ninline D arg(P a, P b, P c){ return acos(dot(b-a,c-b)/abs(b-a)/abs(c-b)); }\n\nint n;\nD r,s;\nP p[30];\nD d[30][30];\nvector<Edge> g[30][30];\nD lensum[30][30][10100];\n\nint main(){ \n  cin >> n >> r >> s;\n  s *= PI/180;\n  rep(i,n)cin >> p[i].real() >> p[i].imag();\n  rep(i,n){\n    d[i+1][i+1] = 0;\n    for(int j=i+1;j<n;j++){\n      d[i+1][j+1] = d[j+1][i+1] = abs(p[i]-p[j]);\n    }\n  }\n  \n  rep(i,n){\n    if(i)g[0][1].pb(Edge(d[1][i+1],i+1));\n  }\n\n  rep(i,n){\n    rep(j,n){\n      if(i==j)continue;\n      rep(k,n){\n\tif(j==k || i==k)continue;\n\tD seta = arg(p[i],p[j],p[k]);\n\tif(abs(base(p[i],p[j],p[k])-1.0)<EPS)seta = 0.0;\n\telse if(abs(base(p[i],p[j],p[k])+1.0)<EPS)seta = PI;\n\tif(seta < s + EPS){\n\t  g[i+1][j+1].pb(Edge(d[j+1][k+1],k+1));\n\t}\n      }\n    }\n  }\n\n  rep(i,n+1)rep(j,n+1)rep(k,10100)lensum[i][j][k] = 1e10;\n  lensum[0][1][0] = 0;\n  priority_queue<state,vector<state>,greater<state> > q;\n  q.push(mk(mk(0,0),mk(0,1)));\n\n  int ans = 0;\n  while(q.size()){\n    state tmp = q.top(); q.pop();\n    D len = tmp.fs.fs;\n    int carrot = tmp.fs.sc+1, prv = tmp.sc.fs, cur = tmp.sc.sc;\n\n    rep(i,g[prv][cur].size()){\n      D cost = g[prv][cur][i].fs;\n      int nxt = g[prv][cur][i].sc;\n      if(len + cost > r + EPS)continue;\n      if(lensum[cur][nxt][carrot] > len + cost + EPS){\n\tlensum[cur][nxt][carrot] = len + cost;\n\tq.push(mk(mk(len+cost,carrot),mk(cur,nxt)));\n\tans = max(ans,carrot);\n      }\n    }\n  }\t\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 21;\nconst int MAXX = 10001;\nconst double eps = 1e-5;\nconst double inf = 1e10;\n\nint n;\ndouble r, th;\nP ps[MAXN];\ndouble dp[MAXX][MAXN][MAXN];\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble getAngle(P a, P b) {\n  double v = dot(a, b) / (abs(a) * abs(b));\n  if(v > 1.0) return 0;\n  if(v < -1.0) return M_PI;\n  return acos(v);\n}\n\nint main() {\n  while(cin >> n) {\n    cin >> r >> th;\n    th = th * M_PI / 180.0;\n    for(int i = 0; i < n; ++i)\n      cin >> ps[i].real() >> ps[i].imag();\n    fill(dp[0][0], dp[MAXX][0], inf);\n    dp[0][0][0] = 0;\n    int res = 0;\n    for(int i = 0; i+1 < MAXX; ++i) {\n      if(i != res) break;\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < n; ++k) {\n          if(dp[i][j][k] == inf) continue;\n          for(int l = 0; l < n; ++l) {\n            if(k == l) continue;\n            if(j != k) {\n              P a = ps[k] - ps[j], b = ps[l] - ps[k];\n              double rad = getAngle(a, b);\n              if(rad > th + eps) continue;\n            }\n            dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + abs(ps[l]-ps[k]));\n            if(dp[i+1][k][l] < r + eps) {\n              res = i + 1;\n            }\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\nconst double PI=acos(-1);\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef complex<double> Point;\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tdouble r,t; cin>>r>>t; t=t*PI/180;\n\t\tvector<Point> ps(n);\n\t\trep(i,n){\n\t\t\tint x,y; cin>>x>>y;\n\t\t\tps[i]=Point(x,y);\n\t\t}\n\t\t\n\t\tvvd d(n,vd(n));\n\t\trep(i,n) rep(j,n)\n\t\t\td[i][j]=abs(ps[j]-ps[i]);\n\t\tvvvi g(n,vvi(n));\n\t\trep(i,n) rep(j,n) if(j!=i) rep(k,n) if(k!=j){\n\t\t\tPoint d1=ps[j]-ps[i],d2=ps[k]-ps[j];\n\t\t\tif(abs(arg(d2/d1))<t)\n\t\t\t\tg[i][j].push_back(k);\n\t\t}\n\t\t\n\t\tqueue<tuple<int,int,double>> q; // (prev,cur,len)\n\t\trepi(i,1,n) if(d[0][i]<r) q.emplace(0,i,d[0][i]);\n\t\tfor(int c=0;;c++){\n\t\t\tif(q.empty()){\n\t\t\t\tcout<<c<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvvd cand(n,vd(n,INF));\n\t\t\twhile(q.size()){\n\t\t\t\tint prev,cur; double len;\n\t\t\t\ttie(prev,cur,len)=q.front(); q.pop();\n\t\t\t\tif(len>r) continue;\n\t\t\t\tfor(int next:g[prev][cur])\n\t\t\t\t\tcand[cur][next]=min(cand[cur][next],len+d[cur][next]);\n\t\t\t}\n\t\t\trep(i,n) rep(j,n) if(cand[i][j]<r)\n\t\t\t\tq.emplace(i,j,cand[i][j]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct state {\n  int p, c, n;\n  float d;\n  bool operator<(const state &s) const { return d > s.d; }\n};\n\nint N, X[20], Y[20];\nfloat R, Theta;\nfloat d[20][20];\nbool angle[20][20][20];\nfloat dp[20][20][10000];\n\nfloat theta(int i, int j, int k) {\n  int x1 = X[k] - X[j], y1 = Y[k] - Y[j];\n  int x2 = X[j] - X[i], y2 = Y[j] - Y[i];\n  float l1 = sqrt(x1 * x1 + y1 * y1);\n  float l2 = sqrt(x2 * x2 + y2 * y2);\n  float iprod = x1 * x2 + y1 * y2;\n  float rad = acos(iprod / l1 / l2);\n  return rad * 180 / M_PI;\n}\n\nint main(void) {\n  cin >> N >> R >> Theta;\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n\n  REP(i, 0, N) REP(j, 0, N) {\n    d[i][j] = sqrt((X[i] - X[j]) * (X[i] - X[j]) + (Y[i] - Y[j]) * (Y[i] - Y[j]));\n  }\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, N) {\n    if(i == j || j == k || k == i) angle[i][j][k] = false;\n    else angle[i][j][k] = theta(i, j, k) <= Theta + 10e-8;\n  }\n\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, 10000) dp[i][j][k] = 1e10;\n\n  priority_queue<state> q;\n  REP(i, 1, N) if(d[0][i] <= R + 1e-8) q.push((state) { 0, i, 1, d[0][i] });\n\n  int ans = 0;\n  while(q.size()) {\n    state c = q.top();\n    q.pop();\n\n    if(dp[c.p][c.c][c.n] <= c.d) continue;\n    dp[c.p][c.c][c.n] = c.d;\n\n    ans = max(ans, c.n);\n\n    REP(i, 0, N) if(angle[c.p][c.c][i]) {\n      float nd = c.d + d[c.c][i];\n      if(dp[c.c][i][c.n + 1] <= nd) continue;\n      if(nd <= R + 1e-8) q.push((state) { c.c, i, c.n + 1, nd });\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\n#define EPS 1e-6\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ndouble dis(Point a, Point b){ return abs(a - b); }\ndouble dot(Point a, Point b){ return a.real() * b.real() + a.imag() * b.imag(); }\n\n//テッツシツ津」ツ?、テ」ツ?ョテ」ツδ凖」ツつッテ」ツδ暗」ツδォABテ」ツ?ョテ」ツ?ェテ」ツ?凖ィツァツ津・ツコツヲテ篠クテ」ツつ津ヲツアツづ」ツつ?」ツつ?(テ」ツδ催」ツδε」ツδ暗」ツ?凝」ツつ嘉ヲツ仰セテ」ツ?」テ」ツ?ヲテ」ツ?催」ツ?淌」ツつづ」ツ?ョテ」ツ?ョテ、ツクツクテ」ツつウテ」ツδ?\ndouble AngleOf2Point(Point A, Point B){\n  //テ」ツ??「ツ?サテ」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?ョテゥツ閉キテ」ツ?陛」ツ??テ」ツ??」ツ?ィテァツュツ氾」ツ?暗」ツ?古・ツ?コテ」ツ?セテ」ツ?崚」ツつ禿」ツ?ョテ」ツ?ァテヲツウツィテヲツ?湘」ツ?療」ツ?ヲテ」ツ?湘」ツ??」ツ?陛」ツ??」ツ??\n\n  //テ」ツδ凖」ツつッテ」ツδ暗」ツδォAテ」ツ?ィBテ」ツ?ョテゥツ閉キテ」ツ?陛」ツつ津ィツィツ暗ァツョツ療」ツ?凖」ツつ?\n  double length_A = sqrt(A.real() * A.real() + A.imag() * A.imag());\n  double length_B = sqrt(B.real() * B.real() + B.imag() * B.imag());\n  \n  //テ・ツ??ァツゥツ催」ツ?ィテ」ツδ凖」ツつッテ」ツδ暗」ツδォテゥツ閉キテ」ツ?陛」ツつ津、ツスツソテ」ツ?」テ」ツ?ヲcosテ篠クテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n  double cos_sita = dot(A, B) / (length_A * length_B );\n  \n  //cosテ篠クテ」ツ?凝」ツつ嘉篠クテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n  double sita = acos( cos_sita );\t\n  \n  //テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ァテ」ツ?ェテ」ツ??テッツスツ?80テ」ツ?ョティツァツ津・ツコツヲテ」ツ?ァテ」ツ?サテ」ツ?療」ツ??・ツ?エテ・ツ青暗」ツ?ッテ」ツつウテ」ツδ。テ」ツδウテ」ツδ暗・ツ、ツ姪」ツ??\n  sita = sita * 180.0 / M_PI;\n  \n  return sita;\n}\n\n\ndouble AngleOf2Line(Line A, Line B){ return AngleOf2Point(A.first - A.second, B.first - B.second); }\n\n\nint main(void){\n  int n;\n  double r, theta;\n  cin >> n >> r >> theta;\n\n  int x, y;\n  vector<Point> town;\n  for(int i = 0; i < n; i++){\n    cin >> x >> y;\n    town.push_back(Point(x, y));\n  }\n\n  // adj[i][j]: jテ」ツ?凝」ツつ永テ」ツ?ォテ」ツ?催」ツ?淌・ツセツ古」ツ?ォテゥツ?キテァツァツサテ」ツ?ァテ」ツ?催」ツつ凝ゥツ?づァツつケテ」ツδェテ」ツつケテ」ツδ?\n  vector<vector<vector<int> > > adj(n, vector<vector<int> >(n));\n  for(int i = 0; i < n; i++)\n    for(int j = 0; j < n; j++)\n      for(int k = 0; k < n; k++)\n        if(i != j && i != k)\n          if(abs(180 - AngleOf2Line(make_pair(town[j], town[i]), make_pair(town[k], town[i]))) <= theta)\n            adj[i][j].push_back(k);\n\n  int int_r = (int)r + 1;\n  vector<vector<vector<double> > > dp(n, vector<vector<double> >(n, vector<double>(int_r, INF)));\n  for(int now = 0; now < n; now++){ dp[now][0][0] = dis(town[0], town[now]); }\n  for(int carrot = 0; carrot < int_r - 1; carrot++){\n    for(int now = 0; now < n; now++){\n      for(int prev = 0; prev < n; prev++){\n        for(size_t i = 0; i < adj[now][prev].size(); i++){\n          int next = adj[now][prev][i];\n          dp[next][now][carrot + 1] = min(dp[next][now][carrot + 1],\n                                          dp[now][prev][carrot] + dis(town[now], town[next]));\n        }\n      }\n    }\n  }\n\n  int ans = -1;\n  for(int carrot = 0; carrot < int_r; carrot++)\n    for(int now = 0; now < n; now++)\n      for(int prev = 0; prev < n; prev++)\n        if(dp[now][prev][carrot] < r)\n          ans = carrot;\n\n  cout << ans + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntypedef long double D;\nconst D eps = 1e-10;\nconst D pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\nD dist[20][20];\n\nbool ok[20][20][20];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tD r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,n)rep(j,n){\n\t\tint dx=(x[i]-x[j]);\n\t\tint dy=(y[i]-y[j]);\n\t\tdist[i][j]=sqrt(1.0*dx*dx+1.0*dy*dy);\n\t}\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tint ans=0;\n\trange(cp,1,n){\n\t\tif(dist[cp][0]<=r){\n\t\t\tdp[1][cp][0]=dist[cp][0],ans=1;\n\t\t}\n\t}\n\trep(pp,n)rep(cp,n)rep(np,n){\n\t\tif(pp==cp) continue;\n\t\tif(cp==np) continue;\n\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\tD dot=1.0*cx*nx+1.0*cy*ny;\n\t\tdot/=(dist[cp][pp]*dist[np][cp]);\n\t\tdot=max<D>(-1,dot);\n\t\tdot=min<D>(1,dot);\n\t\tD angle=acos(dot);\n\t\tangle*=180.0/pi;\n\t\tif(angle>180.0) angle=360.0-angle;\n\t\tif(angle<=theta) ok[pp][cp][np]=true;\n\t}\n\n\n\trep(i,limit)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tD add=dist[cp][np];\n\t\t\tif(dp[i][cp][pp]+add>r) continue;\n\t\t\tif(ok[pp][cp][np]==false) continue;\n\t\t\tdp[i+1][np][cp]=min<D>(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t\tans=max(ans,i+1);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <complex>\ntypedef complex<double> Point;\n\ndouble dot(const Point &a, const Point &b) {\n  return real(conj(a) * b);\n}\n\nint n;\ndouble r, theta;\nPoint p[100];\ndouble matrix[30][30][30];\ndouble dp[2][30][30];\n\nint main() {\n  while (scanf(\"%d %lf %lf\", &n, &r, &theta) > 0) {\n    REP(i, 30) REP(j, 30) REP(k, 30) { matrix[i][j][k] = 1e+100; }\n    REP(i, n) {\n      double x, y;\n      scanf(\"%lf %lf\", &x, &y);\n      p[i] = Point(x, y);\n    }\n    REP(prev, n) {\n      REP(from, n) {\n        REP(to, n) {\n          if (from == to) { continue; }\n          Point vect1 = p[from] - p[prev];\n          Point vect2 = p[to] - p[from];\n          double c = dot(vect1, vect2) / abs(vect1) / abs(vect2);\n          double threshold = cos(theta / 180.0 * PI);\n          if (c >= threshold || prev == from) {\n            matrix[prev][from][to] = abs(vect2);\n          }\n        }\n      }\n    }\n    REP(i, 2) REP(j, 30) REP(k, 30) { dp[i][j][k] = 1e+100; }\n    int ans = 0;\n    dp[0][0][0] = 0;\n    REP(iter, 10000) {\n      bool end = true;\n      int prev = iter & 1;\n      int next = prev ^ 1;\n      REP(i, 30) REP(k, 30) { dp[next][i][k] = 1e+100; }\n      REP(p, n) {\n        REP(from, n) {\n          REP(to, n) {\n            double ncost = dp[prev][p][from] + matrix[p][from][to];\n            if (ncost < dp[next][from][to] && ncost < r) {\n              dp[next][from][to] = ncost;\n              end = false;\n              ans = iter + 1;\n            }\n          }\n        }\n      }\n      if (end) { break; }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> mid = cities[prev];\n  complex<double> dst = cities[city];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,false,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      if(dp[s.carrots][s.prev][s.city]) continue;\n      dp[s.carrots][s.prev][s.city] = true;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 30;\nint x[N], y[N];\n\nint dist[10010][N][N];\n\nvector<int> G[N][N];\ndouble D[N][N];\n\nconst double PI = 4 * atan(1);\nconst double EPS = 1e-9;\n\nint main(){\n\tint n;\n\tdouble r, theta;\n\tcin >> n >> r >> theta;\n\ttheta = theta / 180 * PI;\n\trep(i, n) cin >> x[i] >> y[i];\n\n\trep(i, n) rep(j, n){\n\t\tD[i][j] = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));\n\t}\n\n\trep(i, n) rep(j, n) rep(k, n){\n\t\tif (i == j || j == k) continue;\n\t\tdouble x1 = x[j] - x[i], y1 = y[j] - y[i];\n\t\tdouble x2 = x[k] - x[j], y2 = y[k] - y[j];\n\n\t\tdouble ct = (x1*x2 + y1*y2) / (D[i][j]*D[j][k]);\n\t\tdouble theta = acos(ct);\n\n\t\tif (abs(theta) < theta + EPS) G[i][j].push_back(k);\n\t}\n\n\tMEMSET(dist, 0x7f);\n\tpriority_queue<tuple<double, int, int, int>> pq;\n\n\trep(i, n) rep(j, n){\n\t\tif (i == j) continue;\n\t\tpq.emplace(-D[i][j], 1, i, j);\n\t}\n\n\tint ans = 0;\n\twhile (!pq.empty()){\n\t\tauto t = pq.top();\n\t\tpq.pop();\n\t\tdouble d;\n\t\tint c, prv, cur;\n\t\ttie(d, c, prv, cur) = t;\n\t\td = -d;\n\n\t\tif (dist[c][prv][cur] + EPS < d) continue;\n\n\t\tans = max(ans, c);\n\n\t\tfor (auto v : G[prv][cur]){\n\t\t\tdouble nd = d + D[cur][v];\n\t\t\tif (r < nd + EPS) continue;\n\t\t\tif (dist[c + 1][cur][v] < nd + EPS) continue;\n\t\t\tdist[c + 1][cur][v] = nd;\n\t\t\tpq.emplace(-nd, c + 1, cur, v);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<string.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double EPS=0.000000001;\nconst double INF=1000000;\ndouble r,theta;\n\n\tdouble memo[10001][20][20];\n\nbool is_ok(P a,P b,P c){\n\tP in=b-a,out=c-b;\n\tdouble dot=in.real()*out.real()+in.imag()*out.imag();\n//\tcout<<in<<out<<endl;\n//\tcout<<2.0*theta*asin(1.0)/180.0<<endl;\n//\tcout<<cos(90.0*theta*2.0*asin(1.0)/180.0)<<endl;\n//\tcout<<cos(theta*2.0*asin(1.0)/180.0)<<\" \"<<dot/(abs(in)*abs(out))<<endl;\n\tif(cos(theta)<dot/(abs(in)*abs(out))) return true;\n\treturn false;\n}\n\nclass Idx{\npublic:\n\tint num,bef,now;\n\tIdx(int bef,int now,int num):bef(bef),now(now),num(num){}\n};\n\nclass Info{\npublic:\n\tIdx idx;\n\tdouble sum_r;\n\tInfo(Idx idx,double sum_r):idx(idx),sum_r(sum_r){}\n};\n\nint main()\n{\n\tint n;\n\tcin>>n>>r>>theta;\n\tvector<P> V;\n\tfor(int i=0;i<n;i++){\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tV.push_back(P(a,b));\n\t}\n\n\tfor(int i=0;i<10001;i++)\n\t\tfor(int j=0;j<20;j++)\n\t\t\tfor(int k=0;k<20;k++)\n\t\t\t\tmemo[i][j][k]=INF;\n\n\tmemo[0][0][0]=0.0;\n\tint ans=0;\n\n\tbool ok[20][20][20];\n\tmemset(ok,false,sizeof(ok));\n\tfor(int in=0;in<n;in++){\n\t\tfor(int out=0;out<n;out++){\n\t\t\tif(in==out) continue;\n\t\t\tfor(int next=0;next<n;next++){\n\t\t\t\tif(in==next || out==next) continue;\n//\t\t\t\tcout<<\"check \"<<in<<\" \"<<out<<\" \"<<next<<endl;\n\t\t\t\tif(is_ok(V[in],V[out],V[next])){ok[in][out][next]=true;\n\t\t\t\t//cout<<\"ok\"<<endl;;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int num=1;num<=10000;num++){\n\t\tfor(int in=0;in<n;in++){\n\t\t\tfor(int out=0;out<n;out++){\n\t\t\t\tif(memo[num-1][in][out]>r+EPS) continue;\n\t\t\t\tfor(int next=0;next<n;next++){\n\t\t\t\t\tif((num==1 && next!=0) || ok[in][out][next]){\n\t\t\t\t\t\tif(memo[num-1][in][out]+abs(V[out]-V[next])<r+EPS){\n\t\t\t\t\t\t\tans=num;\n\t\t\t\t\t\t\tmemo[num][out][next]=memo[num-1][in][out]+abs(V[out]-V[next]);\n//\t\t\t\t\t\t\tcout<<in<<\" \"<<out<<\" \"<<next<<\" \"<<memo[num][out][next]<<\" \"<<num<<endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans!=num) break;\n\t}\n\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define p(s) cout<<(s)<<endl;\nusing namespace std;\n\nconst int ctinf=1e5;\ndouble dp[10000][21][21];//num,prev,now = minr\nint ctans;\nvector<int> ctok[21][21];\ndouble len[21][21];\ndouble r,theta;\nint dot_pro(int x1,int x2,int x3,int y1, int y2, int y3){\n\treturn (x2-x1)*(x3-x2)+(y2-y1)*(y3-y2);\n}\n\ndouble ctcos(int x1,int x2,int x3,int y1,int y2,int y3){\n\treturn dot_pro(x1,x2,x3,y1,y2,y3)/(hypot(x2-x1,y2-y1)*hypot(x3-x2,y3-y2));\n}\n\nvoid ctdfs(int cnt,int prev,int now){\n\tfor(auto next:ctok[prev][now]){\n\t\tif(dp[cnt][prev][now]+len[now][next]<=r){\n\t\t\tif(dp[cnt+1][now][next]>dp[cnt][prev][now]+len[now][next]){\n\t\t\t\tdp[cnt+1][now][next]=dp[cnt][prev][now]+len[now][next];\n\t\t\t\tctdfs(cnt+1,now,next);\n\t\t\t}\n\t\t}\n\t}\n\tctans=max(ctans,cnt);\n}\nint main(){\n\tint n;\n\tcin>>n>>r>>theta;\n\tREP(i,0,r) REP(j,0,n) REP(k,0,n) dp[i][j][k]=ctinf;\n\tdouble co=cos(theta*M_PI/180.0);\n\tint x[20],y[20];\n\tREP(i,0,n) cin>>x[i]>>y[i];\n\tREP(prev,0,n) REP(now,prev+1,n) len[prev][now]=len[now][prev]=hypot(x[now]-x[prev],y[now]-y[prev]);\n\tREP(prev,0,n) REP(now,0,n){\n\t\tif(prev==now) continue;\n\t\tREP(next,0,n){\n\t\t\tif(prev==next||now==next) continue;\n\t\t\tif(ctcos(x[prev],x[now],x[next],y[prev],y[now],y[next])<co)continue;\n\t\t\tctok[prev][now].push_back(next);\n\n\t\t}\n\t}\n\n\tREP(i,1,n) {\n\t\tif(len[0][i]<r){\n\t\t\tdp[1][0][i]=len[0][i];\n\t\t\tctdfs(1,0,i);\n\t\t}\n\t}\n\n\tp(ctans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n\n#include<vector>\nusing namespace std;\n#define INF 1e8\n\nint n;\ndouble r, theta;\ndouble x[21], y[21];\ndouble dist[2][400];\nint cnt[400];\nvector<int> edge[10800];\ndouble d(int a, int b){\n\treturn sqrt((x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]));\n}\nbool ok(int a, int b, int c, double theta){\n\tdouble dot = (x[b]-x[a]) * (x[c]-x[b]) + (y[b]-y[a]) * (y[c] - y[b]);\n\tdouble dist1 = d(a, b);\n\tdouble dist2 = d(b, c);\n\treturn cos(theta)*dist1*dist2 <= dot;\n}\n\n\nint solve(double r){\n\tbool cont = true;\n\tbool ok = false;\n\tfor(int i = 0;i < 400;i++)dist[1][i] = INF;\n\tfor(int i = 1;i < n;i++){\n\t\tif(d(0, i) < r)ok = true;\n\t\tdist[1][i] = d(0,i);\n\t}\n\tif(!ok)return 0;\n\tint cnt = 0;\n\twhile(cont){\n\t\tcnt++;\n\t\tcont = false;\n\t\tfor(int i = 0;i < 400;i++)dist[!(cnt%2)][i] = INF;\n\t\tfor(int i = 0;i < 400;i++){\n\t\t\tfor(int j = 0;j < edge[i].size();j++){\n\t\t\t\tint to = edge[i][j];\n\t\t\t\tdouble dd = d(i / n, i % n);\n\t\t\t\tdist[!(cnt%2)][to] = min(dist[!(cnt%2)][to], dist[(cnt%2)][i] + dd);\n\t\t\t\tif(dist[!(cnt%2)][to] < r)cont = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tcin >> n;\n\tcin >> r >> theta;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tif(i == j || j == k)continue;\n\t\t\t\tif(ok(i, j, k, theta)){\n\t\t\t\t\tint u = i * n + j;\n\t\t\t\t\tint v = j * n + k;\n\t\t\t\t\tedge[u].push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << solve(r) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef  long double ll;\ntypedef pair<ll,ll> mp;\ntypedef pair<ll,bool> mlb;\n#define inf 1e9\nstruct point{\n    double x,y;\n    point(double x, double y): x(x),y(y){};\n    point() {};\n    point operator - (point &p){ return point(x-p.x,y-p.y); }\n    void make(){cin>>x>>y; }\n    double norm(){ return x*x+y*y; }\n    double abs() { return sqrt( norm() ); }\n    double arg(){//原点からの角度\n        //comp c(x.y);\n        //return c.arg();\n        return atan2(y,x);\n    }   \n    double arg2(){\n        point tmp = point(-1,0);\n        double pi = tmp.arg();\n        return arg()/ pi * 180.0; \n    }\n    void print(){ cout<<x<<' '<<y<<endl; }\n};\n \nint main(){\n    point tmp = point(-1,0);\n    double pi = tmp.arg();\n    int n;\n    cin>>n;\n    double r,theta;\n    cin>>r>>theta;\n    vector<point> p(n);\n    for(int i=0;i<n;i++)p[i].make();\n    vector<vector<vector<mlb> > > g(n,vector<vector<mlb> >(n,vector<mlb> (n,mlb(inf,false) ) ) );\n    for(int i=0;i<n;i++)//prev\n        for(int j=0;j<n;j++)//now\n            for(int k=0;k<n;k++){//next\n                if(i==j||j==k||k==i)continue;\n                point d1 = p[j]-p[i];\n                point d2 = p[k]-p[j];\n                point dire = point( d1.x*d2.x + d1.y*d2.y , d1.y*d2.x - d1.x*d2.y );\n                if( abs( dire.arg() ) <= theta/180.0*pi   ){\n                    g[i][j][k] = mlb(d2.abs(),true);\n                }\n            }\n    int M = 1e4+2;\n    //vector<vector<vector<double> > > dp(n,vector<vector<double> >(n,vector<double>(M,-1) ) );\n    vector<vector<double> > dp(n,vector<double>(n,-1) );\n    int ans = 0;\n    for(int i=1;i<n;i++){\n        dp[0][i] = r - (p[i]-p[0]).abs();\n        if(dp[0][i] >= 0) ans = 1;\n    }\nif(ans == 1)\n    for(int i=1;i<M-1;i++){\n        vector<vector<double> > ndp(n,vector<double>(n,-1) );\n        for(int j = 0;j<n;j++){\n            for(int k = 0;k<n;k++){\n                if(dp[j][k] > 0){\n                    for(int l=0;l<n;l++){\n                        if(g[j][k][l].second){\n                            double next = dp[j][k] - g[j][k][l].first;\n                            if(next>=0){\n                                ans = i+1;\n                                ndp[k][l] = max(ndp[k][l],next );\n                                //cout<<i+1<<' '<<j<<' '<<k<<' '<<l<<' '<<next<<endl;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        dp = ndp;\n        if(ans == i) break;\n    }\n    cout<<ans<<endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst double PI = acos(-1);\nconst double INF = 1e15;\ndouble dp[10010][20][20];\n\nint n;\ndouble r, theta;\ndouble x[20], y[20];\n\ndouble dist(double x1, double y1, double x2, double y2){\n    x1 -= x2, y1 -= y2;\n    return sqrt(x1 * x1 + y1 * y1);\n}\n\ndouble dot(double x1, double y1, double x2, double y2){\n    return x1 * x2 + y1 * y2;\n}\n\nbool check(int v, int u, int pre){\n    double ax = x[v] - x[pre];\n    double ay = y[v] - y[pre];\n    double bx = x[u] - x[v];\n    double by = y[u] - y[v];\n    double da = dist(x[v], y[v], x[pre], y[pre]);\n    double db = dist(x[u], y[u], x[v], y[v]);\n    double t = abs(acos(dot(ax, ay, bx, by) / da / db));\n    //cerr << \"\\t\\t\" << v << \" \" << u << \" \" << pre << \" \" << t << endl;\n    return t <= theta;\n}\n\nint main(){\n    cin >> n >> r >> theta;\n\n    theta *= 2 * PI / 360.0;\n\n    for(int i = 0; i < n; i++){\n        cin >> x[i] >> y[i];\n    }\n\n    for(int i = 0; i < 10010; i++){\n        for(int j = 0; j < n; j++){\n            for(int k = 0; k < n; k++){\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n\n    //cout << check(2, 0, 1) << endl;\n    //return 0;\n    \n    dp[0][0][0] = 0;\n    for(int i = 0; i <= 10000; i++){\n        for(int v = 0; v < n; v++){\n            for(int pre = 0; pre < n; pre++){\n                double d = dp[i][v][pre];\n                if(d >= 1e14) continue;\n                //cerr << i << \" \" << v << \" \" << pre << \" \" << d << endl;\n                for(int u = 0; u < n; u++){\n                    if(v == u) continue;\n                    if(i != 0 && !check(v, u, pre)) continue;\n                    //cerr << \"\\t\" << v << \" \" << u << endl;\n                    double ndist = d + dist(x[v], y[v], x[u], y[u]);\n                    if(ndist <= r && dp[i + 1][u][v] > ndist){\n                        dp[i + 1][u][v] = ndist;\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i <= 10000; i++){\n        for(int v = 0; v < n; v++){\n            for(int pre = 0; pre < n; pre++){\n                double d = dp[i][v][pre];\n                if(d >= 1e14) continue;\n                ans = max(ans, i);\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> dst = cities[city];\n\n  src -= cities[prev];\n  dst -= cities[prev];\n  double computed_arg = abs(arg(src) - arg(dst));\n\n  return (limit_rad >= M_PI - min(computed_arg,\n\t\t\t\t  abs(2.0*M_PI - computed_arg)) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\nbool isok[21][21][21]; //cur,prev,old\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    memset(isok,true,sizeof(isok));\n    for(int old = 0; old < total_cities; old++){\n      for(int prev = 0; prev < total_cities; prev++){\n\tfor(int cur = 0; cur < total_cities; cur++){\n\t  isok[cur][prev][old] = check(cur,prev,old,limit_rad,cities);\n\t}\n      }\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(!isok[next_city][next_prev][next_old]) continue;\n\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-8;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    long double r,theta;\n    cin >> n >> r >> theta;\n    theta=theta/360*2*3.141592653589793;\n    const double cos_theta=cosl(theta);\n    vector<long double> x(n),y(n);\n    rep(i,0,n) cin >> x[i] >> y[i];\n\n    int ans=0;\n    long double dp[20][20];\n    fill_n((long double*)dp,20*20,inf);\n    rep(i,1,n) dp[0][i]=sqrtl((x[i]-x[0])*(x[i]-x[0])+(y[i]-y[0])*(y[i]-y[0]));\n    while(true){\n        if([&]{\n            long double mini=inf;\n            rep(i,0,n) rep(j,0,n) mini=min(mini,dp[i][j]);\n            return mini;\n        }()<r) ++ans;\n        else break;\n\n        long double prev[20][20];\n        memcpy(prev,dp,sizeof(long double)*20*20);\n        fill_n((long double*)dp,20*20,inf);\n        rep(i,0,n) rep(j,0,n) rep(k,0,n){\n            if(i==j or j==k) continue;\n            const long double l1=sqrtl((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));\n            const long double l2=sqrtl((x[k]-x[j])*(x[k]-x[j])+(y[k]-y[j])*(y[k]-y[j]));\n            if(((x[j]-x[i])*(x[k]-x[j])+(y[j]-y[i])*(y[k]-y[j]))/l1/l2<cos_theta) continue;\n            dp[j][k]=min(dp[j][k],prev[i][j]+l2);\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\nconst double INF=1e77;\nconst double PI=acos(-1);\n\nstruct state{\n\tdouble d;\n\tint pre,now,val;\n\tstate(double d,int pre,int now,int val):d(d),pre(pre),now(now),val(val){}\n\tbool operator<(const state &S)const{ return d>S.d; }\n};\n\nint main(){\n\tint n;\n\tdouble r,theta; scanf(\"%d%lf%lf\",&n,&r,&theta);\n\ttheta*=PI/180;\n\n\tint x[20],y[20];\n\trep(i,n) scanf(\"%d%d\",x+i,y+i);\n\n\tdouble dist[20][20];\n\trep(i,n) rep(j,n) dist[i][j]=hypot(x[i]-x[j],y[i]-y[j]);\n\n\tstatic bool adj[20][20][20]; // 直前に i にいて今 j にいるとき k に行けるかどうか\n\trep(i,n) rep(j,n) if(i!=j) rep(k,n) if(j!=k) {\n\t\tdouble phi=acos(((x[i]-x[j])*(x[k]-x[j])+(y[i]-y[j])*(y[k]-y[j]))/(dist[i][j]*dist[k][j]));\n\t\tif(PI-phi<=theta) adj[i][j][k]=true;\n\t}\n\n\tstatic double d[20][20][10001];\n\trep(i,n) rep(j,n) rep(k,10001) d[i][j][k]=INF;\n\tpriority_queue<state> Q;\n\trep(i,n) if(i!=0 && dist[0][i]<=r) {\n\t\td[0][i][1]=dist[0][i];\n\t\tQ.push(state(dist[0][i],0,i,1));\n\t}\n\twhile(!Q.empty()){\n\t\tstate S=Q.top(); Q.pop();\n\t\tdouble d_now=S.d;\n\t\tint pre=S.pre,now=S.now,val=S.val;\n\n\t\tif(d_now>d[pre][now][val]+EPS) continue;\n\n\t\trep(nxt,n) if(adj[pre][now][nxt]) {\n\t\t\tdouble d_next=d_now+dist[now][nxt];\n\t\t\tif(d_next<=r && d_next+EPS<d[now][nxt][val+1]) {\n\t\t\t\td[now][nxt][val+1]=d_next;\n\t\t\t\tQ.push(state(d_next,now,nxt,val+1));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,n) rep(j,n) rep(k,10001) if(d[i][j][k]<=r) ans=max(ans,k);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdlib>\n#include <queue>\n#include <complex>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-4;\nbool   dp[20][20][10000 + 10];\ndouble memo[20][20][10000 + 10];\n\nstruct data{\n  int k;\n  int prev;\n  int now;\n  double dist;\n  data(int a, int b, int c, double d) :\n    k(a), prev(b), now(c), dist(d) {}\n};\n\nbool operator < (const data &lhs, const data &rhs){\n  return lhs.dist > rhs.dist;\n}\n\ninline bool ok(const P &p1, const P &p2, const P &p3, const double rad){\n  P s1 = p2 - p1;\n  P s2 = p3 - p2;\n  return std::abs(arg(s2 / s1)) < rad + EPS;\n}\n\nint main(){\n  int n;\n  double r, theta;\n  double rad;\n\n  cin >> n >> r >> theta;\n  rad = M_PI * theta / 180.0;\n\n  vector<P> p(n);\n  REP(i,n) cin >> p[i].real() >> p[i].imag();\n\n  int ans = 0;\n  priority_queue<data> pq;\n\n  REP(i,n) if(i != 0 && std::abs(p[i] - p[0]) < r + EPS)\n    pq.push(data(1, 0, i, std::abs(p[i] - p[0])));\n\n  while(pq.size()){\n    data d = pq.top(); pq.pop();\n    int k = d.k;\n    int prev = d.prev;\n    int now  = d.now;\n    double dist = d.dist;\n    // cout << prev << \" \" << now << \" \" << k << \": \" << dist << endl;\n\n    if(dp[prev][now][k]) continue;\n    dp[prev][now][k] = true;\n    ans = max(ans, k);\n\n    REP(next, n) if(prev != next && now != next){\n      if(dp[now][next][k]) continue;\n      if(ok(p[prev], p[now], p[next], rad)){\n        double dd = dist + std::abs(p[next] - p[now]);\n        if(memo[now][next][k + 1] != 0.0 &&\n           memo[now][next][k + 1] <= dd)\n          continue;\n        memo[now][next][k + 1] = dd;\n        if(dd < r + EPS){\n          pq.push(data(k + 1, now, next, dd));\n        }\n      }\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 20;\nconst double INF = -1.0;\n\nint n;\ndouble r, s, e[N][N][N], d[N][N][10005];\nvector<P> in;\n\nmain(){\n  cin >> n >> r >> s;\n  s *= M_PI / 180.0;\n  for(int i=0;i<n;i++){\n    P a;\n    cin >> a.real() >> a.imag();\n    in.push_back(a);\n  }\n  if(n == 1){\n    cout << 0 << endl;\n    return 0;\n  }\n  fill(e[0][0], e[N][0], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i == j) continue;\n      for(int k=0;k<n;k++){\n        if(j == k) continue;\n        P a = in[i] - in[j];\n        P b = in[k] - in[j];\n        double t = acos(real(conj(a) * b) / (abs(a) * abs(b)));\n        //if(i == 0 && j == 3 && k == 4) cout << t << ' ' << M_PI - t << ' ' << s << endl;\n        if(M_PI - t <= s) e[i][j][k] = abs(b);\n      }\n    }\n  }\n  /*for(int i=0;i<n;i++){\n    cout << i << endl;\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n        printf(\"%.3f \", e[i][j][k]);\n      }\n      cout << endl;\n    }\n    }*/\n  fill(d[0][0], d[N][0], -1.0);\n  int ans = 0;\n  for(int i=1;i<n;i++){\n    if(abs(in[0] - in[1]) <= r){\n      d[0][i][1] = abs(in[0] - in[i]);\n      ans = 1;\n    }\n  }\n  for(int k=1;(double)k<r+1;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(d[i][j][k] < 0.0) continue;\n        ans = max(ans, k);\n        for(int l=0;l<n;l++){\n          if(e[i][j][l] < 0.0) continue;\n          double dist = d[i][j][k] + e[i][j][l];\n          //if(e[i][j][l] < 10.0) cout << i << ' ' << j << ' ' << l << ' ' << e[i][j][l] << endl;\n          if(dist > r) continue;\n          //cout << k+1 << ' ' << j << ' ' << l << ' ' << dist << endl;\n          if(d[j][l][k+1] < 0.0) d[j][l][k+1] = dist;\n          else if(d[j][l][k+1] > dist) d[j][l][k+1] = dist;\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct state {\n  int p, c, n;\n  float d;\n  bool operator<(const state &s) const { return d > s.d; }\n};\n\nint N, X[20], Y[20];\nfloat R, Theta;\nfloat d[20][20];\nbool angle[20][20][20];\nfloat dp[20][20][10000];\n\nfloat theta(int i, int j, int k) {\n  int x1 = X[k] - X[j], y1 = Y[k] - Y[j];\n  int x2 = X[j] - X[i], y2 = Y[j] - Y[i];\n  float l1 = sqrt(x1 * x1 + y1 * y1);\n  float l2 = sqrt(x2 * x2 + y2 * y2);\n  float iprod = x1 * x2 + y1 * y2;\n  float rad = acos(iprod / l1 / l2);\n  return rad * 180 / M_PI;\n}\n\nint main(void) {\n  cin >> N >> R >> Theta;\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n\n  REP(i, 0, N) REP(j, 0, N) {\n    d[i][j] = sqrt((X[i] - X[j]) * (X[i] - X[j]) + (Y[i] - Y[j]) * (Y[i] - Y[j]));\n  }\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, N) {\n    if(i == j || j == k || k == i) angle[i][j][k] = false;\n    else angle[i][j][k] = theta(i, j, k) <= Theta + 10e-8;\n  }\n\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, 100000) dp[i][j][k] = 1e10;\n\n  priority_queue<state> q;\n  REP(i, 1, N) if(d[0][i] <= R + 1e-8) q.push((state) { 0, i, 1, d[0][i] });\n\n  int ans = 0;\n  while(q.size()) {\n    state c = q.top();\n    q.pop();\n\n    if(dp[c.p][c.c][c.n] <= c.d) continue;\n    dp[c.p][c.c][c.n] = c.d;\n\n    ans = max(ans, c.n);\n\n    REP(i, 0, N) if(angle[c.p][c.c][i]) {\n      float nd = c.d + d[c.c][i];\n      if(dp[c.c][i][c.n + 1] <= nd) continue;\n      if(nd <= R + 1e-8) q.push((state) { c.c, i, c.n + 1, nd });\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#define scanf_s scanf\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\n\nint main(void){\n\tint n,ans,i,j,k,ok;\n\tdouble r,sit;\n\tdouble x[20];\n\tdouble y[20];\n\tdouble dp[20][20]={0};//x??????y????????????\n\tdouble dpc[20][20]={0};\n\tdouble d;\n\tdouble pi=3.141592653589793238462643383279502884197;\n\tscanf(\"%d\",&n);\n\tscanf(\"%lf %lf\",&r,&sit);\n\tsit=(sit/180)*pi;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i][j]=0;\n\t\t\tdpc[i][j]=big;\n\t\t}\n\t}\n\tfor(ans=0;;ans++){\n\t\tfor(k=0;k<n;k++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif((k-i)*(i-j)*(j-k)==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td=abs(atan2(y[i]-y[k],x[i]-x[k])-atan2(y[k]-y[j],x[k]-x[j]));\n\t\t\t\t\tif(ans!=0&&min(2*pi-d,d)>sit){continue;}\n\t\t\t\t\tdpc[k][j]=min(dpc[k][j],dp[i][k]+hypot(x[k]-x[j],y[k]-y[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tdp[i][j]=dpc[i][j];\n\t\t\t\tif(dpc[i][j]<r){\n\t\t\t\t\tok=1;\n\t\t\t\t}\n\t\t\t\tdpc[i][j]=big;\n\t\t\t}\n\t\t}\n\t\tif(ok==0){break;}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst long double PI = 3.14159255358979323846264338327950288l;\nstruct Point { long double px, py; };\nlong double theta(long double a, long double b, long double c) {\n\tlong double s = (a + b + c) / 2.0l;\n\tlong double S = sqrtl(s*(s - a)*(s - b)*(s - c));\n\tlong double A = -1000, B = -1000, C = -1000, H;\n\n\tif (a > b && a > c) { H = 2.0l * S / a; B = asin(H / c)*180.0l / PI; C = asin(H / b)*180.0l / PI; A = 180.0l - B - C; }\n\telse if (b > a && b > c) { H = 2.0l * S / b; A = asin(H / c)*180.0l / PI; C = asin(H / a)*180.0l / PI; B = 180.0l - A - C; }\n\telse { H = 2.0l * S / c; A = asin(H / b)*180.0l / PI; B = asin(H / a)*180.0l / PI; C = 180.0l - A - B; }\n\n\treturn A;\n}\nlong double theta_(Point a, Point b, Point c) {\n\t//a->b->c\n\tlong double A1 = sqrtl((a.px - c.px)*(a.px - c.px) + (a.py - c.py)*(a.py - c.py));\n\tlong double B1 = sqrtl((a.px - b.px)*(a.px - b.px) + (a.py - b.py)*(a.py - b.py));\n\tlong double C1 = sqrtl((b.px - c.px)*(b.px - c.px) + (b.py - c.py)*(b.py - c.py));\n\treturn theta(A1, B1, C1);\n}\nlong double dp[22][22], prev_[22][22], r, t; Point x[30]; int n;\nint main() {\n\tcin >> n >> r >> t;\n\tfor (int i = 0; i < n; i++)cin >> x[i].px >> x[i].py;\n\tfor (int i = 0; i < 22; i++) { for (int j = 0; j < 22; j++) { dp[i][j] = 999999999.9l; prev_[i][j] = 999999999.9l; } }\n\tfor (int i = 0; i < n; i++) { if (i != 0) { prev_[0][i] = sqrtl((x[0].px - x[i].px)*(x[0].px - x[i].px) + (x[0].py - x[i].py)*(x[0].py - x[i].py)); } }\n\tint maxn = 0;\n\tfor (int i = 1; i < 100000; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tif (j == k || k == l)continue;\n\t\t\t\t\tlong double T = theta_(x[j], x[k], x[l]); T = 180.0l - T;\n\t\t\t\t\tlong double dst = sqrtl((x[k].px - x[l].px)*(x[k].px - x[l].px) + (x[k].py - x[l].py)*(x[k].py - x[l].py));\n\t\t\t\t\tif (T >= t)continue;\n\t\t\t\t\tdp[k][l] = min(dp[k][l], prev_[j][k] + dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (prev_[j][k] < r)maxn = i;\n\t\t\t\tprev_[j][k] = dp[j][k]; dp[j][k] = 999999999.9l;\n\t\t\t}\n\t\t}\n\t\tif (maxn != i)break;\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n \ntypedef complex<double> P;\n \nstruct S{\n  int w,p,n;\n  double d;\n  bool operator<(S s)const{\n    return d>s.d;\n  }\n};\n \ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n \nint main(){\n  int n;\n  double r,th;\n  cin>>n>>r>>th;\n  P p[21];\n  for(int i=1;i<=n;i++){\n    int x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<S> que;\n  que.push({1,0,0,0});\n  static bool mem[21][21][22222];\n  int m=0;\n  while(!que.empty()){\n    auto cs=que.top();\n    if(cs.d>r)break;\n    que.pop();\n    if(mem[cs.w][cs.p][cs.n]++)continue;\n    m=max(m,cs.n);\n    for(int i=1;i<=n;i++){\n      if(i==cs.w)continue;\n      auto f=p[cs.w]-p[cs.p];\n      auto t=p[i]-p[cs.w];\n      if(cs.p&&acos(min(1.,max(-1.,dot(f,t)/abs(f)/abs(t))))*90>th*acos(0))continue;\n      que.push({i,cs.w,cs.n+1,cs.d+abs(t)});\n    }\n  }\n  cout<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n};\n\nint main()\n{\n    int n;\n    double r, theta;\n    cin >> n >> r >> theta;\n    theta *= PI / 180;\n\n    vector<Point> p(n);\n    for(int i=0; i<n; ++i)\n        cin >> p[i].x >> p[i].y;\n\n    vector<vector<double> > dist(n, vector<double>(n));\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<n; ++j){\n            dist[i][j] = p[i].dist(p[j]);\n        }\n    }\n\n    vector<vector<vector<bool> > > access(n, vector<vector<bool> >(n, vector<bool>(n, false)));\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<n; ++j){\n            for(int k=0; k<n; ++k){\n                if(i == k)\n                    continue;\n                double angle = acos((p[i] - p[j]).dot(p[k] - p[i]) / (p[i] - p[j]).length() / (p[k] - p[i]).length());\n                if(angle < theta)\n                    access[i][j][k] = true;\n            }\n        }\n    }\n\n    vector<vector<double> > dp(n, vector<double>(n, -1.0));\n    for(int i=1; i<n; ++i)\n        dp[i][0] = r - dist[0][i];\n\n    int ret = 0;\n    for(;;){\n        double maxRest = -1.0;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                maxRest = max(maxRest, dp[i][j]);\n            }\n        }\n        if(maxRest < 0){\n            cout << ret << endl;\n            return 0;\n        }\n\n        vector<vector<double> > next(n, vector<double>(n, -1.0));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                for(int k=0; k<n; ++k){\n                    if(access[i][j][k])\n                        next[k][i] = max(next[k][i], dp[i][j] - dist[i][k]);\n                }\n            }\n        }\n        dp.swap(next);\n\n        ++ ret;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\nconst int MAX = 1e4+1;\nconst double EPS = 1e-6;\nconst double INF = 1e18;\nconst double PI = acos(-1);\ntypedef complex<double> P;\n\ndouble angle(P a, P b){\n    return abs(arg(a/b));\n}\n\nint main(){\n    int n;\n    double r, theta;\n    cin >> n >> r >> theta;\n    theta = theta/180*PI;\n\n    vector<P> xy(n);\n    for(int i=0; i<n; i++){\n        double x,y;\n        cin >> x >> y;\n        xy[i] = P(x,y);\n    }\n\n    vector<vector<vector<double> > > dp(n+1, vector<vector<double> >(n, vector<double>(MAX, INF)));\n    dp[n][0][0] = 0;\n    vector<vector<vector<bool> > > cango(n+1, vector<vector<bool> >(n, vector<bool>(n, true)));\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            for(int k=0; k<n; k++){\n                if(i==j || j==k || angle(xy[j]-xy[i], xy[k]-xy[j]) > theta +EPS){\n                    cango[i][j][k] = false;\n                }\n            }\n        }\n    }\n    int ans=0;\n    for(int k=0; k<MAX-1; k++){\n        for(int i=0; i<n+1; i++){\n            for(int j=0; j<n; j++){\n                if(dp[i][j][k]==INF) continue;\n                for(int p=0; p<n; p++){\n                    if(p==j) continue;\n                    if(!cango[i][j][p]) continue;\n                    double dist = dp[i][j][k] + abs(xy[p]-xy[j]);\n                    if(dist < dp[j][p][k+1] && dist < r +EPS){\n                        dp[j][p][k+1] = dist;\n                        ans = k+1;\n                    }\n                }\n            }\n        }\n        if(ans!=k+1) break;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble dp[20][20][10000];\ndouble d[20][20];\ndouble x[20];\ndouble y[20];\ndouble calc(int a,int b,int c){\n\tdouble dot=(x[b]-x[a])*(x[c]-x[b])+(y[b]-y[a])*(y[c]-y[b]);\n\tdouble r=d[a][b]*d[b][c];\n\treturn dot/r;\n}\nint main(){\n\tint a;\n\tdouble b,c;\n\tscanf(\"%d%lf%lf\",&a,&b,&c);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lf%lf\",x+i,y+i);\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(i!=j)\n\t\t\td[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++)\n\t\t\tfor(int k=0;k<10000;k++)\n\t\t\t\tdp[i][j][k]=99999999;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(i!=j)dp[i][j][1]=d[i][j];\n\t\t}\n\t}\n\tfor(int i=1;i<9999;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(j==k)continue;\n\t\t\t\tif(dp[j][k][i]>b)continue;\n\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\tif(l==k)continue;\n\t\t\t\t\tif(calc(j,k,l)<cos(c/180*3.14159265359))continue;\n\t\t\t\t\tdp[k][l][i+1]=min(dp[k][l][i+1],dp[j][k][i]+d[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret=0;\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++)\n\t\t\tfor(int k=1;k<10000;k++)\n\t\t\t\tif(dp[i][j][k]<b)ret=max(ret,k);\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(const deque<int>& deq,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[deq[0]];\n  complex<double> mid = cities[deq[1]];\n  complex<double> dst = cities[deq[2]];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _c,double _r,const deque<int>& _d) :\n    city(_ct), carrots(_c), remaining_distance(_r),deq(_d) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    deq.push_back(_d);\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,false,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      int prev = 20;\n      if(s.deq.size() > 1) prev = *(s.deq.end()-2);\n\n      if(dp[s.carrots][prev][s.city]) continue;\n      dp[s.carrots][prev][s.city] = true;\n\n      deque<int> deq;\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\t\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tdeq = s.deq;\n\t\n\tdeq.push_back(to);\n\twhile(deq.size() > 3) deq.pop_front();\n\n\tif(deq.size()==3){\n\t  if(!check(deq,limit_rad,cities)) continue;\n\t}\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tque.push(State(to,s.carrots+1,s.remaining_distance - dist,deq));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\ndouble dp[20][20][2500];\nconst double PI = 3.1415926535;\nint main(){\n  int n,i,j,k,ans=0;cin>>n;\n  double r,arc;cin>>r>>arc;\n  arc=PI/180.0*arc;\n  Polygon g;g.resize(n);\n  for(i=0;i<n;i++) cin>>g[i].x>>g[i].y;\n  double e[n][n][n],inf=1<<28;\n  fill(e[0][0],e[0][0]+n*n*n,inf);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      for(k=0;k<n;k++){\n\tif(i==j||j==k||k==i) continue;\n\tVector a=g[j]-g[i],b=g[k]-g[j];\n\tif(fabs(acos(dot(a,b)/(abs(a)*abs(b))))<=arc)\n\t  e[i][j][k]=abs(g[k]-g[j]);\n      }\n    }\n  }\n  for(k=1;k<n;k++) e[0][0][k]=abs(g[k]-g[0]);\n  \n  fill(dp[0][0],dp[0][0]+20*20*2500,inf);\n  typedef pair<int,int> P;\n  typedef pair<int,P> PP;\n  typedef pair<double,PP> PPP;\n  priority_queue<PPP,vector<PPP>,greater<PPP> > q;\n  q.push(PPP(0.0,PP(0,P(0,n))));\n  while(!q.empty()){\n    PPP ppp=q.top();q.pop();\n    double d=ppp.first,z;\n    PP pp=ppp.second;\n    k=pp.first;\n    P p=pp.second;\n    if(d>r) continue;\n    ans=max(ans,k);\n    if(p.second==n){\n      for(i=0;i<n;i++){\n\tz=inf;\n\tfor(j=0;j<n;j++) z=min(z,e[j][0][i]);\n\tq.push(PPP(d+z,PP(k+1,P(i,p.first))));\n      }\n    }else{\n      if(dp[p.first][p.second][k]<=d) continue;\t\n      dp[p.first][p.second][k]=d;\n      for(i=0;i<n;i++)\n\tq.push(PPP(d+e[p.second][p.first][i],PP(k+1,P(i,p.first))));\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst long double PI = 3.14159255358979323846264338327950288l;\nstruct Point { long double px, py; };\nlong double theta(long double a, long double b, long double c) {\n\tlong double s = (a + b + c) / 2.0l;\n\tlong double S = sqrtl(s*(s - a)*(s - b)*(s - c));\n\tlong double A = -1000, B = -1000, C = -1000, H;\n\n\tif (a > b && a > c) { H = 2.0l * S / a; B = asin(H / c)*180.0l / PI; C = asin(H / b)*180.0l / PI; A = 180.0l - B - C; }\n\telse if (b > a && b > c) { H = 2.0l * S / b; A = asin(H / c)*180.0l / PI; C = asin(H / a)*180.0l / PI; B = 180.0l - A - C; }\n\telse { H = 2.0l * S / c; A = asin(H / b)*180.0l / PI; B = asin(H / a)*180.0l / PI; C = 180.0l - A - B; }\n\n\treturn A;\n}\nlong double theta_(Point a, Point b, Point c) {\n\t//a->b->c\n\tlong double A1 = sqrtl((a.px - c.px)*(a.px - c.px) + (a.py - c.py)*(a.py - c.py));\n\tlong double B1 = sqrtl((a.px - b.px)*(a.px - b.px) + (a.py - b.py)*(a.py - b.py));\n\tlong double C1 = sqrtl((b.px - c.px)*(b.px - c.px) + (b.py - c.py)*(b.py - c.py));\n\treturn theta(A1, B1, C1);\n}\nlong double dp[22][22], prev_[22][22], r, t; Point x[30]; int n;\nint main() {\n\tcin >> n >> r >> t;\n\tfor (int i = 0; i < n; i++)cin >> x[i].px >> x[i].py;\n\tfor (int i = 0; i < 22; i++) { for (int j = 0; j < 22; j++) { dp[i][j] = 999999999.9l; prev_[i][j] = 999999999.9l; } }\n\tfor (int i = 0; i < n; i++) { prev_[0][i] = sqrtl((x[0].px - x[i].px)*(x[0].px - x[i].px) + (x[0].py - x[i].py)*(x[0].py - x[i].py)); }\n\tint maxn = 0;\n\tfor (int i = 1; i < 20000; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tif (j == k || k == l)continue;\n\t\t\t\t\tlong double T = theta_(x[j], x[k], x[l]); T = 180.0l - T;\n\t\t\t\t\tlong double dst = sqrtl((x[k].px - x[l].px)*(x[k].px - x[l].px) + (x[k].py - x[l].py)*(x[k].py - x[l].py));\n\t\t\t\t\tif (T >= t)continue;\n\t\t\t\t\tdp[k][l] = min(dp[k][l], prev_[j][k] + dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (prev_[j][k] < r)maxn = i;\n\t\t\t\tprev_[j][k] = dp[j][k]; dp[j][k] = 999999999.9l;\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef long double ld;\nconst ld INF = 1e+8;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nint main() {\n  int n;\n  ld r,t,theta;\n  cin>>n>>r>>t;\n  theta = t / 180.0 * pi;\n  VP p;\n  REP(i,n){\n    ld x,y;\n    cin>>x>>y;\n    p.emplace_back(x,y);\n  }\n  int np1 = n+1;\n  int v = np1*np1;\n  vector<vector<int>> g(v);\n  REP(i,n)REP(j,n)REP(k,n) {\n    if (i == j) break;\n    if (j == k) continue;\n    P a = p[j] - p[i], b = p[k] - p[j];\n    ld arga = arg(a);\n    P rotcx = polar<ld>(1.0, -arga);\n    ld argb = arg(b*rotcx);\n    if (argb > pi) argb -= pi * 2.0;\n    if (abs(argb) < theta) {\n      g[j*np1+i].push_back(k*np1+j);\n    }\n  }\n  REP(i,n)REP(j,n) {\n    g[i*np1+n].push_back(j*np1+i);\n  }\n  vector<ld> mind(v, INF);\n  REP(i,n) mind[i*np1+n] = 0;\n  REP(i,r+1) {\n    vector<ld> tmp(v, INF);\n    ld mint = INF;\n    REP(j,v) {\n      for (int nx : g[j]) {\n        int now = nx % np1;\n        int nxt = nx / np1;\n        tmp[nx] = min(tmp[nx], mind[j] + abs(p[nxt] - p[now]));\n        mint = min(mint, tmp[nx]);\n      }\n    }\n    if (mint > r) {\n      cout << i << endl;\n      break;\n    }\n    swap(tmp, mind);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-4)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nint n;\ndouble dp[10001][21][21]={};\ndouble x[21],y[21],r,s;\nbool b[21][21][21]={};\n\ndouble abs(int a,int b){\n  return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n}\n\ndouble dot(int i,int j,int k){\n  return (x[i]-x[j])*(x[k]-x[j])+(y[i]-y[j])*(y[k]-y[j]);\n}\n\nint main()\n{\n  cin>>n>>r>>s;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(i==j || j==k || i==k){\n\t  b[i][j][k]=false;\n\t  continue;\n\t}\n\tdouble R=acos(dot(i,j,k)/(double)(abs(i,j)*abs(j,k)));\n\tR=R*360/(2.0*pi);\n\tR=min(R,360-R);\n\tif(((180-R)-s)<eps)b[i][j][k]=true;\n\telse b[i][j][k]=false;\n      }\n    }\n  }\n\n  for(int i=0;i<10001;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tdp[i][j][k]=inf;\n\n  int ans=0;\n  for(int i=1;i<n;i++){\n    dp[0][0][i]=abs(0,i);\n    if(dp[0][0][i]<r)ans++;\n  }\n\n  for(int c=1;c<10001;c++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  if(b[i][j][k]){\n\t    dp[c][j][k]=min(dp[c][j][k],dp[c-1][i][j]+abs(k,j));\n\t    if(dp[c][j][k]-r<eps)ans=max(c+1,ans);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n//typedef tuple<int, int, int> T;\ntypedef pair<ll, ll> Pl;\n//typedef tuple<ll, ll, ll> Tl;\ndouble G[21][21];\nbool ok[21][21][21];\ndouble dp[21][21][10100];\nbool used[21][21][10100] = {};\ndouble r;\nint n;\n\n\ndouble calc(int b, int i, int nn) {\n\tassert(b != i);\n\tif (!nn) return 0;\n\tif (used[b][i][nn]) return dp[b][i][nn];\n\tused[b][i][nn] = true;\n\tdouble res = 1e10;\n\tfor (int j = 0; j < n; j++) {\n\t\tif (i == j) continue;\n\t\tif (ok[b][i][j]) {\n\t\t\tres = min(res, calc(i, j, nn-1)+G[i][j]);\n\t\t}\n\t}\n\tdp[b][i][nn] = res;\n\treturn res;\n}\n\nbool solve(int md) {\n\tfor (int i = 1; i < n; i++) {\n\t\tif (calc(0, i, md-1)+G[0][i] <= r) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> n;\n\tdouble c;\n\tcin >> r >> c;\n\tc = c/180*M_PI;\n\tcomplex<double> u[21];\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble a, b;\n\t\tcin >> a >> b;\n\t\tu[i] = complex<double>(a, b);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tG[i][j] = abs(u[i]-u[j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tdouble si = abs(arg(u[j]-u[i]) - arg(u[k] - u[j]));\n\t\t\t\tsi = fmod(si+2*M_PI, 2*M_PI);\n\t\t\t\tsi = min(si, 2*M_PI-si);\n\t\t\t\tif (si < c) {\n\t\t\t\t\tok[i][j][k] = true;\n\t\t\t\t} else {\n\t\t\t\t\tok[i][j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tok[i][j][i] = false;\n\t\t\tok[i][i][j] = false;\n\t\t\tok[j][i][i] = false;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\t//printf(\"%d %d %f\\n\", i, j, G[i][j]);\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t//printf(\"%d %d %d %d\\n\", i, j, k, ok[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint ll = 0, rr = 10100;\n\twhile (rr - ll > 1) {\n\t\tint md = (ll+rr)/2;\n\t\tif (solve(md)) {\n\t\t\tll = md;\n\t\t} else {\n\t\t\trr = md;\n\t\t}\n\t}\n\tcout << ll << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef long double ld;\nconst ld INF = 1e+12;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\nld dot (P a, P b) { return real(conj(a) * b); }\n\nint main() {\n  int n;\n  ld r,t,theta;\n  cin>>n>>r>>t;\n  theta = t / 180.0 * pi;\n  VP p;\n  REP(i,n){\n    ld x,y;\n    cin>>x>>y;\n    p.emplace_back(x,y);\n  }\n  int np1 = n+1;\n  int v = np1*np1;\n  vector<vector<int>> g(v);\n  REP(i,n)REP(j,n)REP(k,n) {\n    if (i == j) break;\n    if (j == k) continue;\n    P a = p[j] - p[i], b = p[k] - p[j];\n    if ((dot(a,b)/abs(a*b)) > cos(theta)) {\n      g[j*np1+i].push_back(k*np1+j);\n    }\n  }\n  REP(i,n)REP(j,n) {\n    if (j != i) g[i*np1+n].push_back(j*np1+i);\n  }\n  vector<ld> mind(v, INF);\n  mind[n] = 0;\n  REP(i,r+1) {\n    vector<ld> tmp(v, INF);\n    ld mint = INF;\n    REP(j,v) {\n      for (int nx : g[j]) {\n        int now = nx % np1;\n        int nxt = nx / np1;\n        tmp[nx] = min(tmp[nx], mind[j] + abs(p[nxt] - p[now]));\n        mint = min(mint, tmp[nx]);\n      }\n    }\n    if (mint > r) {\n      cout << i << endl;\n      break;\n    }\n    swap(tmp, mind);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 20;\nconst int MAXC = 10010;\nconst double INF = 1e+9;\nconst double EPS = 1e-8;\n\nstruct edge{\n  int to;\n  double cost;\n  edge(int t=0, int c=0):to(t),cost(c){}\n};\n\nstruct state{\n  int prev, now, cnt;\n  double dis;\n  state(int p=0, int n=0, int c=0, double d=0):prev(p),now(n),cnt(c),dis(d){}\n  bool operator < (const state &s) const {\n    return dis > s.dis;\n  }\n};\n\ndouble angle(P a, P b1, P b2){\n  double A = abs(b1 - b2);\n  double B = abs(a - b1);\n  double C = abs(a - b2);\n  return acos((B*B + C*C - A*A) / (2.0*B*C));\n}\n\n\nint n;\ndouble r, rad;\nvector<P> v;\n\ndouble d[N][N][MAXC];\n\nint solve(){\n  int ans = 0;\n  priority_queue<state> pq;\n  state u, u2;\n  vector<edge> g[N][N];\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n        if(j != k && (i == j || M_PI - angle(v[j], v[i], v[k]) < rad + EPS)) {\n          g[i][j].push_back(edge(k, abs(v[j] - v[k])));\n          //if(i != j) cout << v[i] << \" -> \" << v[j] << \" -> \" << v[k] << \" : \" << abs(v[j]-v[k]) << endl;\n        }\n      }\n    }\n  }\n\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<MAXC;k++) d[i][j][k] = INF;\n\n  for(pq.push(state(0, 0, 0, 0)); !pq.empty();){\n    u = pq.top();\n    pq.pop();\n\n    for(int i=0;i<g[u.prev][u.now].size();i++){\n      edge next = g[u.prev][u.now][i];\n      u2 = state(u.now, next.to, u.cnt+1, u.dis+next.cost);\n      assert(u2.cnt < MAXC);\n      if(u2.dis > r + EPS || d[u2.prev][u2.now][u2.cnt] < u2.dis + EPS) continue;\n      d[u2.prev][u2.now][u2.cnt] = u2.dis;\n      ans = max(ans, u2.cnt);\n      pq.push(u2);\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  while(cin >> n){\n    v.clear();\n    cin >> r >> rad;\n    rad *= M_PI / 180.0;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> x >> y;\n      v.push_back(P(x,y));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\nstruct P{\n  double cost;\n  int pos,pre,num;\n  P(double cost,int pos,int pre,int num):cost(cost),pos(pos),pre(pre),num(num){}\n  bool operator < (const P &a) const{return cost<a.cost;} \n};\ntypedef complex<double> point;\npoint z[21];\nint n;\ndouble r,x;\nvector <P> e[21][21];\nbool check(double a,double b,double c){\n  return (360.0/((2*M_PI)/acos((b*b+c*c-a*a)/(2*b*c)))<=x);\n}\n\ndouble D[10001][21][21];\nint dijkstra(){\n  int res=0;\n  for(int i=0;i<10001;i++)for(int j=0;j<n;j++)for(int k=0;k<n;k++) D[i][j][k]=INF;\n  priority_queue<P> Q; \n  Q.push(P(0,0,0,0));\n  D[0][0][0]=0;\n\n  while(!Q.empty()){\n    P t=Q.top();Q.pop();\n    double cost=t.cost;\n    int pos=t.pos,pre=t.pre,num=t.num;\n    if(cost>r) continue;\n    if(D[num][pos][pre]<cost) continue;\n    res=max(res,num);\n    for(int i=0;i<e[pos][pre].size();i++){\n      int nx=e[pos][pre][i].pos;\n      double ncost=cost+e[pos][pre][i].cost;\n      double &a=D[num+1][nx][pos];\n      if(a>ncost){\n\tQ.push(P(ncost,nx,pos,num+1));\n\ta=ncost;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>n>>r>>x;\n  for(int i=0;i<n;i++){\n    double a,b;\n    cin>>a>>b;\n    z[i]=point(a,b);\n  }\n\n  for(int i=0;i<n;i++) //pos\n    for(int j=0;j<n;j++)//pre\n      for(int k=0;k<n;k++){ // to\n\tdouble cost=abs(z[i]-z[k]);\n\tif(i!=k&&i!=j&&check(abs(z[j]-z[k]),abs(z[i]-z[j]),cost))e[i][j].push_back(P(cost,k,0,0));\n      }\n\n  for(int i=1;i<n;i++)e[0][0].push_back(P(abs(z[i]-z[0]),i,0,0));\n  cout <<dijkstra()-4<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n\nint main() {\n  cout << rand() % (1e9 + 7) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\n\ninline double dist(int i,int j){\n\tint dx=(x[i]-x[j]);\n\tint dy=(y[i]-y[j]);\n\treturn sqrt(1.0*dx*dx+1.0*dy*dy);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tdouble r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tdp[0][0][n]=0.0;\n\n\trep(i,limit)rep(cp,n)rep(pp,n+1){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(i>0&&pp==n) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tdouble add=dist(cp,np);\n\t\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\t\tdouble dot=1.0*cx*nx+1.0*cy*ny;\n\t\t\tdot/=(dist(cp,pp)*dist(np,cp));\n\t\t\tdouble angle=acos(dot);\n\t\t\tangle*=180.0/pi;\n\n\t\t\tif(angle>180.0) angle=360.0-angle;\n\t\t\tif(pp!=n&&angle>theta) continue;\n\t\t\tif(dp[i][cp][pp]+add-r>eps) continue;\n\t\t\tdp[i+1][np][cp]=min(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,limit+1)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]<=r+eps) ans=max(ans,i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ndouble dp[405][25][25];\nbool ok[25][25][25];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  double PI = atan2(1, 0)*2, EPS = 1e-8;\n  // cout << PI << endl;\n\n  int n;\n  double r, t;\n  cin >> n >> r >> t;\n  t *= PI/180;\n  VI x(n), y(n);\n  REP(i, n) cin >> x[i] >> y[i];\n\n  REP(i, n) REP(j, n) REP(k, n) {\n    if(i == j || j == k || k == i) continue;\n    double ang1 = atan2(y[j]-y[i], x[j]-x[i]);\n    double ang2 = atan2(y[j]-y[k], x[j]-x[k]);\n    if(abs(ang1 - ang2) < t + EPS) {\n      ok[i][j][k] = true;\n    }\n  }\n\n  int ans = 1;\n  REP(i, 405) REP(j, n) REP(k, n) dp[i][j][k] = INF;\n  REP(i, n) dp[1][0][i] = sqrt((x[i]-x[0])*(x[i]-x[0])+(y[i]-y[0])*(y[i]-y[0]));\n\n  FOR(i, 1, n*(n-1)/2) REP(j, n) REP(k, n) {\n    REP(l, n) {\n      // j->k->lが可能ならば遷移\n      if(ok[j][k][l]) {\n        double dist = sqrt((x[k]-x[l])*(x[k]-x[l])+(y[k]-y[l])*(y[k]-y[l]));\n        chmin(dp[i+1][k][l], dp[i][j][k] + dist);\n        if(dp[i+1][k][l] < r) {\n          chmax(ans, i+1);\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst double INF=1e9;\nconst double PI=acos(-1);\n\nint n;\ndouble r,theta;\nint x[20],y[20];\n\n// from,now,carrots\ndouble dp[20][20][10001];\n\ninline double dist(int a, int b)\n{\n    return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n}\n\ninline bool check(int a, int b, int c)\n{\n    double abx=x[b]-x[a], aby=y[b]-y[a];\n    double bcx=x[c]-x[b], bcy=y[c]-y[b];\n\n    double AB=sqrt(abx*abx+aby*aby);\n    double BC=sqrt(bcx*bcx+bcy*bcy);\n    double dot=abx*bcx+aby*bcy;\n\n    double alpha=acos(dot/AB/BC)*180.0/PI;\n    return alpha<=theta;\n}\n\nint main()\n{\n    scanf(\" %d %lf %lf\", &n, &r, &theta);\n    rep(i,n) scanf(\" %d %d\", &x[i], &y[i]);\n\n    rep(i,20)rep(j,20)rep(k,10001) dp[i][j][k]=INF;\n\n    int ans=0;\n    for(int i=1; i<n; ++i)\n    {\n        double d=dist(0,i);\n        if(d<r)\n        {\n            dp[0][i][1]=d;\n            ans=1;\n        }\n    }\n\n    for(int i=1; i<10000; ++i)\n    {\n        bool update=false;\n        rep(from,n)rep(now,n)\n        {\n            if(from==now) continue;\n            if(dp[from][now][i]>r) continue;\n            rep(to,n)\n            {\n                if(to==from || to==now) continue;\n                if(check(from,now,to))\n                {\n                    double add=dist(now,to);\n                    double tmp=dp[from][now][i]+add;\n                    if(tmp<=r && dp[now][to][i+1]>tmp)\n                    {\n                        dp[now][to][i+1]=tmp;\n                        update=true;\n                    }\n                }\n            }\n        }\n        if(update) ans=i+1;\n        else break;\n    }\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<int,D> edge;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\nconst D PI=acos(-1);\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return a.X==b.X?a.Y<b.Y:a.X<b.X;\n  }\n}\nbool cmp_x(const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; }\nbool cmp_y(const P& a,const P& b){ return a.Y==b.Y?a.X<b.X:a.Y<b.Y; }\nbool cmp_a(const P& a,const P& b){ return arg(a)==arg(b)?norm(a)<norm(b):arg(a)<arg(b); }\nD cross(P a,P b){ return (conj(a)*b).Y; }\nD dot(P a,P b){ return (conj(a)*b).X; }\nD toRag(D deg){ return deg*PI/180.0; }\nP rot(P base,P a,D theta){ return base+polar(abs(a-base),arg(a-base)+theta); }\n\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nD f(P a,P b){ return acos(dot(a,b)/abs(a)/abs(b))/PI*180; }\n\nint n;\nD r,theta;\ndouble dp[22][22][10010];\nvector<edge> es[22][22];\nP ps[22];\n\nstruct state{\n  int pre,v,cnt;\n  D d;\n};\nbool operator<(const state& a, const state& b){ return a.d > b.d; }\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n;\n  cin>>r>>theta;\n  rep(i,n){\n    D x,y;\n    cin>>x>>y;\n    ps[i]=P(x,y);\n  }\n  rep(i,n)rep(j,n)rep(k,10010)dp[i][j][k]=inf;\n  rep(i,n)rep(j,n){\n    if(i==j)continue;\n    rep(k,n){ // (i,j) -> k\n      if(i==k||j==k)continue;\n      P v1=ps[j]-ps[i];\n      P v2=ps[k]-ps[j];\n      if(abs(f(v1,v2))<theta){\n        //dbg(i); dbg(j); dbg(k);\n        es[i][j].push_back(edge(k,abs(v2)));\n      }\n    }\n  }\n  priority_queue<state> que;\n  repl(i,1,n){\n    que.push((state){0,i,1,abs(ps[i]-ps[0])});\n  }\n  int res=0;\n  while(que.size()){\n    int pre=que.top().pre,v=que.top().v,cnt=que.top().cnt;\n    D d=que.top().d; que.pop();\n    if(dp[pre][v][cnt]!=inf)continue;\n    if(d<r)maxch(res,cnt);\n    else continue;\n    dp[pre][v][cnt]=d;\n    for(edge nxt : es[pre][v]){\n      que.push((state){v,nxt.fi,cnt+1,d+nxt.se});\n    }\n  }\n  cout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> Pi;\ntypedef pair<double,int> Pd;\ntypedef pair<Pd,Pi> S;\n\nint n;\ndouble r,d;\nP p[20];\ndouble dp[10001][20][20];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint cal(){\n  priority_queue<S,vector<S>,greater<S> > Q;\n  int ans=0;\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)dp[i][j][k]=1e9;\n  dp[0][0][0]=0;\n  Q.push(S(Pd(0,0),Pi(0,0)));\n  while(!Q.empty()){\n    double cs=Q.top().first.first;\n    int i=Q.top().first.second;\n    int j=Q.top().second.first;\n    int k=Q.top().second.second;\n    Q.pop();\n    if(dp[i][j][k]<cs||cs>r)continue;\n    dp[i][j][k]=1;\n    for(int l=0;l<n;l++)\n      if(check(j,k,l)&&cs+abs(p[k]-p[l])<=r){\n\tif(dp[i+1][k][l]>cs+abs(p[k]-p[l])){\n\t  Q.push(S(Pd(cs+abs(p[k]-p[l]),i+1),Pi(k,l)));\n\t  dp[i+1][k][l]=min(dp[i+1][k][l],cs+abs(p[k]-p[l]));\n\t}\n      }\n    ans=max(ans,i);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n>>r>>d;\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n  cout<<cal()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct point{\n  double x,y;\n};\n\ndouble INF = 1e9;\ndouble PI = acos(-1);\ndouble EPS = (1e-10);\ndouble dp[10001][20][20];\nint n;\ndouble r,ti;\npoint t[20];\n\nvoid solve(int i,int j,int k){\n  for(int to=0;to<n;to++){\n    double vax=t[j].x-t[to].x;\n    double vay=t[j].y-t[to].y;\n    double vbx=t[k].x-t[j].x;\n    double vby=t[k].y-t[j].y;\n    double ar=(vax*vbx+vay*vby)/(sqrt(vax*vax+vay*vay)*sqrt(vbx*vbx+vby*vby));\n    ar=acos(ar);\n    if(ar<ti+EPS){\n      dp[i+1][to][j]=dp[i][j][k]+sqrt(vax*vax+vay*vay);\n    }\n  }\n}\n\nint main(){\n  for(int i=0;i<10001;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<20;k++)\n\tdp[i][j][k]=INF;\n  \n  cin>>n>>r>>ti;\n  ti=ti/360.0*2.0*PI;\n\n  for(int i=0;i<n;i++)\n    cin>>t[i].x>>t[i].y;\n  \n  for(int i=1;i<n;i++){\n    double x=t[i].x-t[0].x;\n    double y=t[i].y-t[0].y;\n    dp[1][i][0]=sqrt(x*x+y*y);\n  }\n  int ans=-1;\n  for(int i=1;i<=r;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(dp[i][j][k]>r+EPS)continue;\n\tans=max(ans,i);\n\tsolve(i,j,k);\n      }\n    }\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬?????? (????°????)\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\ntypedef pair<int, int> pii;\ntypedef pair<double, int> pdi;\ntypedef long long ll;\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N;\ndouble R, theta;\nint x[25], y[25];\nvector<pdi> to[25][25];\ndouble rec[25][25][10001];\n\n// ??´??? ab ??¨ ac ?????????\ndouble dot(int a, int b, int c) {\n    int px = x[b] - x[a], qx = x[c] - x[a];\n    int py = y[b] - y[a], qy = y[c] - y[a];\n    return px * qx + py * qy;\n}\n\n// ???????????? ab ?????????\ndouble absvec(int a, int b) {\n    double px = x[b] - x[a], py = y[b] - y[a];\n    return sqrt(px*px + py*py);\n}\n\n// ??§???????????´???\ndouble to_rad(double t) {\n    return M_PI * t / 180.0;\n}\n\nstruct Elem {\n    int cur, prev, res;\n};\n\nbool operator<(const Elem &a, const Elem &b) {\n    return rec[a.cur][a.prev][a.res] > rec[b.cur][b.prev][b.res];\n}\n\nsigned main() {\n    cin >> N >> R >> theta;\n    double val = cos( to_rad(theta) );\n    rep(i,0,N) cin >> x[i+1] >> y[i+1];\n\n    repq(i,1,N) repq(j,1,N) {\n        if(i == j) continue;\n        repq(k,1,N) {\n            if(i == k || j == k) continue;\n            double temp = - dot(i, j, k) / absvec(i, j) / absvec(i, k);\n            if(val <= temp) to[i][j].push_back(pdi(absvec(i, k), k));\n        }\n    }\n\n    // ????????????????????§????????????\n    repq(i,2,N) {\n        to[1][0].push_back(pdi(absvec(1, i), i));\n    }\n\n    rep(i,0,25) rep(j,0,25) rep(k,0,10001) rec[i][j][k] = INF;\n    rec[1][0][0] = 0.0;\n\n    priority_queue<Elem> q;\n    q.push(Elem{1, 0, 0});\n\n    while(!q.empty()) {\n        Elem t = q.top(); q.pop();\n        for(auto x : to[t.cur][t.prev]) {\n            int nx = x.second; double cost = x.first;\n            if(rec[nx][t.cur][t.res+1] > rec[t.cur][t.prev][t.res] + cost) {\n                if(rec[t.cur][t.prev][t.res] + cost > R) continue;\n                rec[nx][t.cur][t.res+1] = rec[t.cur][t.prev][t.res] + cost;\n                q.push(Elem{nx, t.cur, t.res+1});\n            }\n        }\n    }\n\n    int ans = 0;\n    repq(i,1,N) repq(j,1,N) rep(k,0,10001) {\n        if(rec[i][j][k] == INF) continue;\n        chmax(ans, k);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double inf=1e8;\n#define rep(i,a) for(int i=0;i<a;i++)\ndouble dp[20][20][10010];\nint main(){\n  rep(i,20)rep(j,20)rep(k,10010)dp[i][j][k]=inf;\n  int n;\n  double x,y;\n  cin>>n>>x>>y;\n  y*=PI/180;\n  G g(n);\n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    g[i]=P(a,b);\n  }\n  double D[20][20]={0};\n  double A[20][20]={0};\n  rep(i,n)rep(j,n)A[i][j]=arg(g[i]-g[j]);\n  rep(i,n)rep(j,n)D[i][j]=abs(g[i]-g[j]);\n  dp[0][0][0]=0;\n  rep(i,10010)rep(j,n)rep(k,n)if(i==0||j!=k){\n    rep(l,n)if(l!=k){\n      double dis=D[l][k];//abs(g[k]-g[l]);\n      //if(i==0)printf(\"%.9f %.9f\\n\",x,dis+dp[j][k][l]);\n      if(dis+dp[j][k][i]>x)continue;\n      double q=A[k][j]-A[l][k];// arg(g[k]-g[j])-arg(g[l]-g[k]);\n      if(q<~0)q*=-1;\n      while(q>PI)q=2*PI-q;//q-=PI;\n      if(i==0){\n\tq=0;//abs(arg(g[l]-g[k]));\n      }\n      if(q>y)continue;\n      dp[k][l][i+1]=min(dp[k][l][i+1],dp[j][k][i]+dis);\n    }\n  }\n  int out=0;\n  rep(i,n)rep(j,n)rep(k,10010)if(abs(dp[i][j][k]-inf)>EPS)out=max(out,k);\n  cout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n\treturn isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n\treturn isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n\treturn isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n\treturn distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n\treturn distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n\treturn isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n\treturn intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n\treturn isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n\treturn intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n\tint n = g.size();\n\tbool x = false;\n\trep(i,n){\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n\t\tif( a.imag() > b.imag() ) swap(a, b);\n\t\tif( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n\t}\n\treturn ( x ? IN : OUT );\n}\n\n//??§?????????????????°????????????\ndouble radianToDegree(double rad){\n\treturn 180 * rad / M_PI;\n}\n\n//?????°??????????????§????????????\ndouble degreeToRadian(double deg){\n\treturn M_PI * deg / 180;\n}\n\n//2???????????????????????????????§????????±???????\ndouble angleOf2Vector(Vector a, Vector b){\n\treturn acos( dot(a,b) / (abs(a) * abs(b)) );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n\tPolygon u;\n\tif( s.size() < 3 ) return s;\n\tsort(s.begin(), s.end());\n\n\trange(i,0,s.size()){\n\t\t//== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n\t\t//!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.emplace_back(s[i]);\n\t}\n\n\tfor(int i = s.size() - 2; i >= 0; i--){\n\t\t//????????? == ??¨ != ????????´??????\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.emplace_back(s[i]);\n\t}\n\n\treverse(u.begin(), u.end());\n\tu.pop_back();\n\n\t//?????????????????????????????§??????????????????????????????????¨??????????????????????\n\t/*\n\t   int i = 0;\n\t   while(i < u.size() - 1){\n\t   if(u[i].imag() > u[i + 1].imag()){\n\t   u.emplace_back(u[i]);\n\t   u.erase(u.begin());\n\t   continue;\n\t   }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n\t   u.emplace_back(u[i]);\n\t   u.erase(u.begin());\n\t   continue;\n\t   }\n\t   break;\n\t   }\n\t   */\n\n\treturn u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n\tPolygon s = convexHull(p);\n\tint n = s.size();\n\n\tif(n == 2) return abs(s[1] - s[0]);\n\n\tint i = 0, j = 0;\n\trep(k,n){\n\t\tif(not (s[i] < s[k])) i = k;\n\t\tif(s[j] < s[k]) j = k;\n\t}\n\n\tdouble ret = 0.0;\n\tint is = i, js = j;\n\n\twhile(i != js || j != is){\n\t\tret = max(ret, abs(s[i] - s[j]));\n\t\tif(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n\t\t\ti = (i + 1) % n;\n\t\t}else{\n\t\t\tj = (j + 1) % n;\n\t\t}\n\t}\n\treturn ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n\tdouble A = cross(a.p2 - a.p1, b.p2 - b.p1);\n\tdouble B = cross(a.p2 - a.p1, a.p2 - b.p1);\n\tif(abs(A) < EPS && abs(B) < EPS) return b.p1;\n\treturn b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\trep(i,p.size()){\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tq.emplace_back(getCrossPointLL(Line{a, b}, l));\n\t\t}\n\t}\n\treturn q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n\tdouble w, x, y, z;\n\tw = b.real()-a.real();\n\tx = b.imag()-a.imag();\n\ty = c.real()-a.real();\n\tz = c.imag()-a.imag();\n\treturn abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n\tint n = g.size();\n\tdouble ret = 0.0;\n\trep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n\treturn abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n\tint n = g.size();\n\trep(i,n){\n\t\tif(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n\t}\n\treturn true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n\tint cnt = 0;\n\trep(i,p.size()){\n\t\tif(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n\t}\n\treturn cnt / 2 + 1;\n}\n\n//????§???¢??????????±???¨??????????????§?¨?\nPoint pointSymmetry(Polygon g){\n\tint size = g.size() / 2;\n\tif(g.size() % 2) return Point{INF,INF};\n\n\tset<Point> s;\n\trep(i,size){\n\t\trep(j,size){\n\t\t\tif(i == j) continue;\n\t\t\ts.insert(intersectionLs(g[i], g[i + size], g[j], g[j + size]));\n\t\t}\n\t}\n\tif(s.size() > 1) return Point{INF,INF};\n\treturn *s.begin();\n}\n\nstruct Edge{\n\tint to;\n\tdouble dis;\n\tEdge(int to, double dis) : to(to), dis(dis) {}\n};\n\nmap<pair<int,int>, vector<Edge>> e;\ndouble dis[20][20][10000];\n\nint bfs(int n, double r){\n\trep(i,20) rep(j,20) rep(k,10000) dis[i][j][k] = -1;\n\n\ttypedef pair<double,pair<pair<int, int>, int>> P; //cost, prev, next, cnt\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\n\tq.push(make_pair(0,make_pair(make_pair(0,0),0)));\n\tdis[0][0][0] = 0;\n\n\twhile(not q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\tdouble cost = p.first;\n\t\tint prev = p.second.first.first;\n\t\tint cur = p.second.first.second;\n\t\tint cnt = p.second.second;\n\t\tfor(auto to : e[make_pair(prev, cur)]){\n\t\t\tif(to.dis == 0) continue;\n\t\t\tif(dis[cur][to.to][cnt + 1] == -1 && cost + to.dis <= r){\n\t\t\t\tdis[cur][to.to][cnt + 1] = cost + to.dis;\n\t\t\t\t//cout << cnt + 1 << ' ' << cost + to.dis << endl;\n\t\t\t\tq.push(make_pair(cost + to.dis, make_pair(make_pair(cur, to.to), cnt + 1)));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int k = 10000 - 1; k >= 0; k--){\n\t\trep(i,n) {\n\t\t\trep(j,n){\n\t\t\t\tif(dis[i][j][k] == -1) continue;\n\t\t\t\treturn k;\n\t\t\t}\n\t\t}\n\t}\n\tassert(false);\n\treturn -1;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tdouble r, theta;\n\tcin >> r >> theta;\n\n\tPoint p[20];\n\trep(i,n){\n\t\tdouble a, b;\n\t\tcin >> a >> b;\n\t\tp[i] = Point{a,b};\n\t}\n\n\trep(i,n){\n\t\trep(j,n){\n\t\t\te[make_pair(i,i)].emplace_back(Edge{j,abs(p[j] - p[i])});\n\t\t\trep(k,n){\n\t\t\t\tif(i == j || j == k) continue;\n\t\t\t\tif(radianToDegree(angleOf2Vector(p[j] - p[i], p[k] - p[j])) <= theta){\n\t\t\t\t\te[make_pair(i,j)].emplace_back(Edge{k, abs(p[j] - p[k])});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << bfs(n, r) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n \ntypedef complex<double> P;\n \nstruct S{\n  int w,p,n;\n  double d;\n  bool operator<(S s)const{\n    return d>s.d;\n  }\n};\n \ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n \nint main(){\n  int n;\n  double r,th;\n  cin>>n>>r>>th;\n  P p[21];\n  for(int i=1;i<=n;i++){\n    int x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<S> que;\n  que.push({1,0,0,0});\n  static bool mem[21][21][22222];\n  int m=0;\n  while(!que.mepty()){\n    auto cs=que.top();\n    if(cs.d>r)break;\n    que.pop();\n    if(mem[cs.w][cs.p][cs.n]++)continue;\n    m=max(m,cs.n);\n    for(int i=1;i<=n;i++){\n      if(i==cs.w)continue;\n      auto f=p[cs.w]-p[cs.p];\n      auto t=p[i]-p[cs.w];\n      if(cs.p&&acos(dot(f,t)/abs(f)/abs(t))*90>th*acos(0))continue;\n      que.push({i,cs.w,cs.n+1,cs.d+abs(t)});\n    }\n  }\n  cout<<m<<endl;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdlib>\n#include <queue>\n#include <complex>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\nbool dp[20][20][10000 + 10];\n\nstruct data{\n  int k;\n  int prev;\n  int now;\n  double dist;\n  data(int a, int b, int c, double d) :\n    k(a), prev(b), now(c), dist(d) {}\n};\n\nbool operator < (const data &lhs, const data &rhs){\n  return lhs.dist > rhs.dist;\n}\n\ninline bool ok(const P &p1, const P &p2, const P &p3, const double rad){\n  P s1 = p2 - p1;\n  P s2 = p3 - p2;\n  return std::abs(arg(s2 / s1)) < rad + EPS;\n}\n\nint main(){\n  int n;\n  double r, theta;\n  double rad;\n\n  cin >> n >> r >> theta;\n  rad = M_PI * theta / 180.0;\n\n  vector<P> p(n);\n  REP(i,n) cin >> p[i].real() >> p[i].imag();\n\n  int ans = 0;\n  priority_queue<data> pq;\n\n  REP(i,n) if(i != 0 && std::abs(p[i] - p[0]) < r + EPS)\n    pq.push(data(1, 0, i, std::abs(p[i] - p[0])));\n\n  while(pq.size()){\n    data d = pq.top(); pq.pop();\n    int k = d.k;\n    int prev = d.prev;\n    int now  = d.now;\n    double dist = d.dist;\n    // cout << prev << \" \" << now << \" \" << k << \": \" << dist << endl;\n\n    if(dp[prev][now][k]) continue;\n    dp[prev][now][k] = true;\n    ans = max(ans, k);\n\n    REP(next, n) if(prev != next && now != next){\n      if(dp[now][next][k]) continue;\n      if(ok(p[prev], p[now], p[next], rad)){\n        double dd = dist + std::abs(p[next] - p[now]);\n        if(dd < r + EPS){\n          pq.push(data(k + 1, now, next, dd));\n        }\n      }\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\n#define mx(x,y) x=max(x,y)\ntypedef double D;\ntypedef complex<D> P;\nD dp[10011][20][20];\nD d[20][20];\nbool can[20][20][20];\nint main(){\n\tint n;\n\tD r,theta;\n\tcin>>n>>r>>theta;\n\tif(n==1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\ttheta*=acos(-1.0)/180;\n\tP p[20];\n\trep(i,n){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tp[i]=P(x,y);\n\t}\n\trep(i,n) rep(j,n) d[i][j]=abs(p[i]-p[j]);\n\trep(i,n) rep(j,n){\n\t\tif(i==j) continue;\n\t\trep(k,n){\n\t\t\tif(k==j) continue;\n\t\t\tif(abs( arg((p[k]-p[j])/(p[j]-p[i])) )<theta) can[i][j][k]=true;\n\t\t}\n\t}\n\trep1(i,n-1) mx(dp[1][0][i],r-abs(p[0]-p[i]));\n\tfor(int i=1;i<=10010;i++){\n\t\tbool update=false;\n\t\trep(a,n) rep(b,n){\n\t\t\tif(a==b) continue;\n\t\t\tif(dp[i][a][b]==0) continue;\n\t\t\trep(c,n){\n\t\t\t\tif(b==c) continue;\n\t\t\t\tif(can[a][b][c]&&dp[i][a][b]-d[b][c]>0){\n\t\t\t\t\tmx(dp[i+1][b][c],dp[i][a][b]-d[b][c]);\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!update){\n\t\t\tcout<<i<<endl;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst double INF=1e9;\nconst double PI=acos(-1);\n\nint n;\ndouble r,theta;\nint x[20],y[20];\n\n// from,now,carrots\ndouble dp[20][20][10001];\n\ndouble d[20][20];\nbool moveable[20][20][20];\n\ninline double dist(int a, int b)\n{\n    return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n}\n\ninline bool check(int a, int b, int c)\n{\n    double abx=x[b]-x[a], aby=y[b]-y[a];\n    double bcx=x[c]-x[b], bcy=y[c]-y[b];\n\n    double AB=sqrt(abx*abx+aby*aby);\n    double BC=sqrt(bcx*bcx+bcy*bcy);\n    double dot=abx*bcx+aby*bcy;\n\n    double alpha=acos(dot/AB/BC)*180.0/PI;\n    return alpha<=theta;\n}\n\nint main()\n{\n    scanf(\" %d %lf %lf\", &n, &r, &theta);\n    rep(i,n) scanf(\" %d %d\", &x[i], &y[i]);\n\n    rep(i,20)rep(j,20)rep(k,10001) dp[i][j][k]=INF;\n    rep(i,n)rep(j,n) d[i][j]=dist(i,j);\n    rep(i,n)rep(j,n)rep(k,n)\n    {\n        if(i==j || i==k || j==k) continue;\n        moveable[i][j][k]=check(i,j,k);\n    }\n\n    int ans=0;\n    for(int i=1; i<n; ++i)\n    {\n        if(d[0][i]<r)\n        {\n            dp[0][i][1]=d[0][i];\n            ans=1;\n        }\n    }\n\n    for(int i=1; i<10000; ++i)\n    {\n        bool update=false;\n        rep(from,n)rep(now,n)\n        {\n            if(from==now) continue;\n            if(dp[from][now][i]>r) continue;\n            rep(to,n)\n            {\n                if(to==from || to==now) continue;\n                if(moveable[from][now][to])\n                {\n                    double add=d[now][to];\n                    double tmp=dp[from][now][i]+add;\n                    if(tmp<=r && dp[now][to][i+1]>tmp)\n                    {\n                        dp[now][to][i+1]=tmp;\n                        update=true;\n                    }\n                }\n            }\n        }\n        if(update) ans=i+1;\n        else break;\n    }\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\n#define EPS 1e-6\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ndouble dis(Point a, Point b){ return abs(a - b); }\ndouble dot(Point a, Point b){ return a.real() * b.real() + a.imag() * b.imag(); }\n\n//テッツシツ津」ツ?、テ」ツ?ョテ」ツδ凖」ツつッテ」ツδ暗」ツδォABテ」ツ?ョテ」ツ?ェテ」ツ?凖ィツァツ津・ツコツヲテ篠クテ」ツつ津ヲツアツづ」ツつ?」ツつ?(テ」ツδ催」ツδε」ツδ暗」ツ?凝」ツつ嘉ヲツ仰セテ」ツ?」テ」ツ?ヲテ」ツ?催」ツ?淌」ツつづ」ツ?ョテ」ツ?ョテ、ツクツクテ」ツつウテ」ツδ?\ndouble AngleOf2Point(Point A, Point B){\n  //テ」ツδ凖」ツつッテ」ツδ暗」ツδォAテ」ツ?ィBテ」ツ?ョテゥツ閉キテ」ツ?陛」ツつ津ィツィツ暗ァツョツ療」ツ?療」ツ??\n  //テ・ツ??ァツゥツ催」ツ?ィテ」ツδ凖」ツつッテ」ツδ暗」ツδォテゥツ閉キテ」ツ?陛」ツつ津、ツスツソテ」ツ?」テ」ツ?ヲcosテ篠クテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n  double length_A = abs(A);\n  double length_B = abs(B);\n  double cos_sita = dot(A, B) / (length_A * length_B );\n  \n  //cosテ篠クテ」ツ?凝」ツつ嘉篠クテ」ツつ津ヲツアツづ」ツつ?」ツ??テ」ツ??80テ」ツ?ョティツァツ津・ツコツヲテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\n  double sita = acos( cos_sita );\t\n  sita = sita * 180.0 / M_PI;\n  \n  return sita;\n}\ndouble AngleOf2Line(Line A, Line B){ return AngleOf2Point(A.first - A.second, B.first - B.second); }\n\n\nint main(void){\n  int n;\n  double r, theta;\n  cin >> n >> r >> theta;\n\n  int x, y;\n  vector<Point> town;\n  for(int i = 0; i < n; i++){\n    cin >> x >> y;\n    town.push_back(Point(x, y));\n  }\n\n  // adj[i][j]: jテ」ツ?凝」ツつ永テ」ツ?ォテ」ツ?催」ツ?淌・ツセツ古」ツ?ォテゥツ?キテァツァツサテ」ツ?ァテ」ツ?催」ツつ凝ゥツ?づァツつケテ」ツδェテ」ツつケテ」ツδ?\n  vector<vector<vector<int> > > adj(n, vector<vector<int> >(n));\n  for(int i = 0; i < n; i++)\n    for(int j = 0; j < n; j++)\n      for(int k = 0; k < n; k++)\n        if(i != j && i != k)\n          if(AngleOf2Line(make_pair(town[j], town[i]), make_pair(town[i], town[k])) <= theta + EPS)\n            adj[i][j].push_back(k);\n\n  // dp[i][j][k]: jテ」ツ?凝」ツつ永テ」ツ?ォテヲツ敖・テ」ツ?淌ヲツ卍づァツつケテ」ツ?ァテ」ツδ凝」ツδウテ」ツつクテ」ツδウテ」ツつ談+1テヲツ慊ャGETテ」ツ?療」ツ?ヲテ」ツつ凝・ツ?エテ・ツ青暗」ツ?ョテヲツ慊?ァツ淞ュテァツオツ古ィツキツッ\n  int int_r = (int)r + 1;\n  vector<vector<vector<double> > > dp(n, vector<vector<double> >(n, vector<double>(int_r, INF)));\n  for(int now = 1; now < n; now++){ dp[now][0][0] = dis(town[0], town[now]); }\n  for(int carrot = 0; carrot < int_r - 1; carrot++){\n    for(int now = 0; now < n; now++){\n      for(int prev = 0; prev < n; prev++){\n        for(size_t i = 0; i < adj[now][prev].size(); i++){\n          int next = adj[now][prev][i];\n          dp[next][now][carrot + 1] = min(dp[next][now][carrot + 1],\n                                          dp[now][prev][carrot] + dis(town[now], town[next]));\n        }\n      }\n    }\n  }\n\n  // テァツュツ氾」ツ?暗」ツつ津ィツィツ暗ァツョツ療」ツ?療」ツ?ヲテ・ツ?コテ・ツ環?\n  int ans = -1;\n  for(int carrot = 0; carrot < int_r; carrot++)\n    for(int now = 0; now < n; now++)\n      for(int prev = 0; prev < n; prev++)\n        if(dp[now][prev][carrot] <= r + EPS)\n          ans = carrot;\n  \n  cout << ans + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nconst int MOD = 1000000007;\n\ntemplate <typename T>\nvoid __dump__(std::ostream &os, const T &first) {\n    os << first;\n}\ntemplate <typename First, typename... Rest>\nvoid __dump__(std::ostream &os, const First &first, const Rest &... rest) {\n    os << first << \", \";\n    __dump__(os, rest...);\n}\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __dump__(os, __VA_ARGS__);                        \\\n        std::cerr << os.str() << std::endl;               \\\n    } while (0)\n\nusing P = complex<double>;\nP ps[21];\n\nconst double EPS = 1e-9;\nconst double INF = 1e9;\nvector<int> go[21][21];\ndouble dp[10001][21][21];\ndouble d[21][21];\n\nint main() {\n    int n;\n    double r, th;\n    cin >> n >> r >> th;\n    th = r*acos(-1)/180;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        ps[i] = P(x, y);\n    }\n    rep(i, n) rep(j, n) {\n        if (i == j) continue;\n        go[i][j].clear();\n        rep(k, n) {\n            if (j == k) continue;\n            double phi = arg((ps[k] - ps[j]) / (ps[j] - ps[i]));\n            if (abs(phi) <= th + EPS) {\n                go[i][j].push_back(k);\n                //dump(i, j, k);\n            }\n        }\n        d[i][j] = abs(ps[i] - ps[j]);\n    }\n    rep(i, 10001) rep(j, 21) rep(k, 21) dp[i][j][k] = INF;\n    rep(i, n) if (i && d[0][i] <= r + EPS) dp[1][0][i] = d[0][i];\n    FOR(i, 1, 10001) {\n        rep(j, n) rep(k, n) {\n            if (dp[i][j][k] == INF) continue;\n            for (auto &l : go[j][k]) {\n                dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + d[k][l]);\n            }\n        }\n    }\n    double ans = 0;\n    rrep(i, 10001) rep(j, n) rep(k, n) {\n        if (dp[i][j][k] <= r + EPS) {\n            dump(i, j, k);\n            ans = i;\n            goto END;\n        }\n    }\n END:;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass state{\npublic:\n  int n,item,prev;\n  double dis;\n  state(int n=0, int item=0, int prev=0, int dis=0):n(n),item(item),prev(prev),dis(dis){}\n  bool operator < (const state &s) const {\n    return dis > s.dis;\n  }\n};\n\nconst double EPS = 1e-3;\nconst double INF = (double)(1<<29);\nint n,d[20][20],ans;\ndouble r,pi,memo[20][20][10000],G[20][20];\nP v[20];\n\nbool equal(double a, double b){ return fabs(a-b) < EPS;}\nbool leq(double a, double b) { return equal(a,b) || a < b;}\nbool req(double a, double b) { return equal(a,b) || a > b;}\n\n\nbool check(double a, double b){\n  if(req(b, a - pi) && leq(b, a + pi)) return true;\n  if(req(b+360, a - pi) && leq(b+360, a + pi)) return true;\n  if(req(b-360, a - pi) && leq(b-360, a + pi)) return true;\n  return false;\n}\n\nvoid make(){\n  for(int i=0;i<n;i++){\n    G[i][i] = 0.0;\n    for(int j=i+1;j<n;j++)\n      G[i][j] = G[j][i] = abs(v[i]-v[j]);\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int bit = 0;\n      double a = arg(v[j]-v[i]) * 180.0 / M_PI;\n      for(int k=0;k<n;k++){\n\tdouble b = arg(v[k]-v[j]) * 180.0 / M_PI;\n\tif(check(a,b)) bit = (bit | (1<<k));\n      }\n      d[i][j] = bit;\n    }\n  }\n}\n\nvoid bfs(){\n  priority_queue<state> Q;\n  state u,v;\n  for(int i=1;i<n;i++){\n    if(G[0][i] > r && !equal(G[0][i],r)) continue;\n    memo[0][i][1] = G[0][i];\n    Q.push(state(i,1,0,G[0][i]));\n  }\n\n  while(!Q.empty()){\n    u = Q.top();\n    Q.pop();\n    ans = max(ans,u.item);\n    for(int i=0;i<n;i++){\n      if(i != u.n && ((1<<i) & d[u.prev][u.n]) != 0 && req(memo[u.n][i][u.item+1], u.dis+G[u.n][i]) && leq(u.dis+G[u.n][i], r)){\n\tv = state(i,u.item+1,u.n,u.dis+G[u.n][i]);\n\tmemo[u.n][i][v.item] = v.dis;\n\tQ.push(v);\n      }\n    }\n  }\n    \n}\n\nint main(){\n  while(cin >> n){\n    ans = 0;\n    cin >> r >> pi;\n\n    for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<10000;k++) memo[i][j][k] = INF;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      v[i] = P(x,y);\n    }\n\n    if(n == 1){\n      cout << 0 << endl;\n      continue;\n    }\n\n    make();\n    bfs();\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass state{\npublic:\n  int n,item,prev;\n  double dis;\n  state(int n=0, int item=0, int prev=0, int dis=0):n(n),item(item),prev(prev),dis(dis){}\n  bool operator < (const state &s) const {\n    return dis > s.dis;\n  }\n};\n\nconst double EPS = 1e-8;\nconst double INF = (double)(1<<29);\nint n,d[20][20],ans;\ndouble r,pi,memo[20][20][10000],G[20][20];\nP v[20];\n\nbool equal(double a, double b){ return fabs(a-b) < EPS;}\nbool leq(double a, double b) { return equal(a,b) || a < b;}\nbool req(double a, double b) { return equal(a,b) || a > b;}\n\n\nbool check(double a, double b){\n  if(req(b, a - pi) && leq(b, a + pi)) return true;\n  if(req(b+360, a - pi) && leq(b+360, a + pi)) return true;\n  if(req(b-360, a - pi) && leq(b-360, a + pi)) return true;\n  return false;\n}\n\nvoid make(){\n  for(int i=0;i<n;i++){\n    G[i][i] = 0.0;\n    for(int j=i+1;j<n;j++)\n      G[i][j] = G[j][i] = abs(v[i]-v[j]);\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int bit = 0;\n      double a = arg(v[j]-v[i]) * 180.0 / M_PI;\n      for(int k=0;k<n;k++){\n\tdouble b = arg(v[k]-v[j]) * 180.0 / M_PI;\n\tif(check(a,b)) bit = (bit | (1<<k));\n      }\n      d[i][j] = bit;\n    }\n  }\n}\n\nvoid bfs(){\n  priority_queue<state> Q;\n  state u,v;\n  for(int i=1;i<n;i++){\n    if(G[0][i] > r && !equal(G[0][i],r)) continue;\n    memo[0][i][1] = G[0][i];\n    Q.push(state(i,1,0,G[0][i]));\n  }\n\n  while(!Q.empty()){\n    u = Q.top();\n    Q.pop();\n    ans = max(ans,u.item);\n    for(int i=0;i<n;i++){\n      if(i != u.n && ((1<<i) & d[u.prev][u.n]) != 0 && req(memo[u.n][i][u.item+1], u.dis+G[u.n][i]) && leq(u.dis+G[u.n][i], r)){\n\tv = state(i,u.item+1,u.n,u.dis+G[u.n][i]);\n\tmemo[u.n][i][v.item] = v.dis;\n\tQ.push(v);\n      }\n    }\n  }\n    \n}\n\nint main(){\n  while(cin >> n){\n    ans = 0;\n    cin >> r >> pi;\n\n    for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<10000;k++) memo[i][j][k] = INF;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      v[i] = P(x,y);\n    }\n\n    if(n == 1){\n      cout << 0 << endl;\n      continue;\n    }\n\n    make();\n    bfs();\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(const deque<int>& deq,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[deq[0]];\n  complex<double> mid = cities[deq[1]];\n  complex<double> dst = cities[deq[2]];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _c,double _r,const deque<int>& _d) :\n    city(_ct), carrots(_c), remaining_distance(_r),deq(_d) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    deq.push_back(_d);\n  }\n\n  bool operator <(const State& s) const{\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[10001][9000]; //dp[carrot][visit history] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      while(s.deq.size() > 3) s.deq.pop_front();\n      int history = 0;\n      int digit = 1;\n\n      for(int i=0;i<s.deq.size();i++){\n\thistory += (s.deq[i]+1) * digit;\n\tdigit *= 21;\n      }\n\n      if(dp[s.carrots][history] >= s.remaining_distance) continue;\n      dp[s.carrots][history] = s.remaining_distance;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\t\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tdeque<int> deq = s.deq;\n\t\n\tdeq.push_back(to);\n\twhile(deq.size() > 3) deq.pop_front();\n\n\tif(deq.size()==3){\n\t  if(!check(deq,limit_rad,cities)) continue;\n\t}\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tState next(to,s.carrots+1,s.remaining_distance - dist,deq);\n\tque.push(next);\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntypedef long double D;\nconst D eps = 1e-10;\nconst D pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\n\ninline D dist(int i,int j){\n\tint dx=(x[i]-x[j]);\n\tint dy=(y[i]-y[j]);\n\treturn sqrt(1.0*dx*dx+1.0*dy*dy);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tD r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tdp[0][0][n]=0.0;\n\n\trep(i,limit)rep(cp,n)rep(pp,n+1){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(i>0&&pp==n) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tD add=dist(cp,np);\n\t\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\t\tD dot=1.0*cx*nx+1.0*cy*ny;\n\t\t\tdot/=(dist(cp,pp)*dist(np,cp));\n\t\t\tD angle=acos(dot);\n\t\t\tangle*=180.0/pi;\n\n\t\t\tif(angle>180.0) angle=360.0-angle;\n\t\t\tif(pp!=n&&angle>theta+eps) continue;\n\t\t\tif(dp[i][cp][pp]+add-r>eps) continue;\n\t\t\tdp[i+1][np][cp]=min<D>(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,limit+1)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]<=r+eps) ans=max(ans,i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n\nusing namespace std;\n\nint n;\ndouble r;\ndouble theta;\nint x[20];\nint y[20];\ndouble dp[20][20];\ndouble buf[20][20];\n\nbool check_angle(int i, int j, int k) {\n    int dx1 = x[j] - x[i];\n    int dy1 = y[j] - y[i];\n    int dx2 = x[k] - x[j];\n    int dy2 = y[k] - y[j];\n    double l1 = sqrt(dx1 * dx1 + dy1 * dy1);\n    double l2 = sqrt(dx2 * dx2 + dy2 * dy2);\n    double arg = acos((dx1 * dx2 + dy1 * dy2) / (l1 * l2));\n    return arg <= theta;\n}\n\ndouble dist(int i, int j) {\n    int dx1 = x[j] - x[i];\n    int dy1 = y[j] - y[i];\n    return sqrt(dx1 * dx1 + dy1 * dy1);\n}\n\nvoid dumpdp() {\n    for (int i = -1; i< n; ++i) {\n        for (int j = -1; j < n; ++j) {\n            if (i == -1) {\n                if (j == -1) continue;\n                cout << setw(10) << j;\n                continue;\n            }\n            if (j == -1) {\n                cout << i;\n                continue;\n            }\n            if (dp[i][j] > 10000) {\n                    cout << \"        --\";\n                } else {\n                    cout << setw(10) << setprecision(2) << fixed << dp[i][j];\n                }\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint main () {\n    cin >> n;\n    cin >> r >> theta;\n    theta = theta * M_PI / 180;\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i] >> y[i];\n    }\n\n    int cmax = (int)r + 1;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = 10000000;\n        }\n    }\n    double mind = r + 1;\n    for (int i = 1; i < n; ++i) {\n        dp[0][i] = dist(0, i);\n        mind = min(mind, dp[0][i]);\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = 100000000;\n        }\n    }\n    if (mind > r) {\n        cout << 0 << endl;\n        return 0;\n    }\n    dp[0][0] = 1000000;\n\n    int c;\n    for (c = 1; c <= cmax; ++c) {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                buf[i][j] = 10000000;\n            }\n        }\n        //dumpdp();\n        for (int k = 0; k < n; ++k) {\n            for (int j = 0; j < n; ++j) {\n                if (j == k) continue;\n                double d = dist(j, k);\n                double tmp = 1000000000;\n                for (int i  = 0; i < n; ++i) {\n                    if (j == i || k == i) continue;\n                    if (!check_angle(i, j, k)) continue;\n                    tmp = min(tmp, d + dp[i][j]);\n                }\n                buf[j][k] = tmp;\n            }\n        }\n        double minr = r + 1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                dp[i][j] = buf[i][j];\n                minr = min(minr, dp[i][j]);\n            }\n        }\n        if (minr > r) break;\n    }\n    cout << c << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\n#define mx(x,y) x=max(x,y)\ntypedef double D;\ntypedef complex<D> P;\nD dp[10011][20][20];\nD d[20][20];\nbool can[20][20][20];\nint main(){\n\tint n;\n\tD r,theta;\n\tcin>>n>>r>>theta;\n\tif(n==0){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\ttheta*=acos(-1.0)/180;\n\tP p[20];\n\trep(i,n){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tp[i]=P(x,y);\n\t}\n\trep(i,n) rep(j,n) d[i][j]=abs(p[i]-p[j]);\n\trep(i,n) rep(j,n){\n\t\tif(i==j) continue;\n\t\trep(k,n){\n\t\t\tif(k==j) continue;\n\t\t\tif(abs( arg((p[k]-p[j])/(p[j]-p[i])) )<theta) can[i][j][k]=true;\n\t\t}\n\t}\n\trep1(i,n-1) mx(dp[1][0][i],r-abs(p[0]-p[i]));\n\tfor(int i=1;i<=10010;i++){\n\t\tbool update=false;\n\t\trep(a,n) rep(b,n){\n\t\t\tif(a==b) continue;\n\t\t\tif(dp[i][a][b]==0) continue;\n\t\t\trep(c,n){\n\t\t\t\tif(b==c) continue;\n\t\t\t\tif(can[a][b][c]&&dp[i][a][b]-d[b][c]>0){\n\t\t\t\t\tmx(dp[i+1][b][c],dp[i][a][b]-d[b][c]);\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!update){\n\t\t\tcout<<i<<endl;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct state {\n  int p, c, n;\n  double d;\n  bool operator<(const state &s) const { return d > s.d; }\n};\n\nint N, X[20], Y[20];\ndouble R, Theta;\ndouble d[20][20];\nbool angle[20][20][20];\ndouble dp[20][20][100000];\n\ndouble theta(int i, int j, int k) {\n  int x1 = X[k] - X[j], y1 = Y[k] - Y[j];\n  int x2 = X[j] - X[i], y2 = Y[j] - Y[i];\n  double l1 = sqrt(x1 * x1 + y1 * y1);\n  double l2 = sqrt(x2 * x2 + y2 * y2);\n  double iprod = x1 * x2 + y1 * y2;\n  double rad = acos(iprod / l1 / l2);\n  return rad * 180 / M_PI;\n}\n\nint main(void) {\n  cin >> N >> R >> Theta;\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n\n  REP(i, 0, N) REP(j, 0, N) {\n    d[i][j] = sqrt((X[i] - X[j]) * (X[i] - X[j]) + (Y[i] - Y[j]) * (Y[i] - Y[j]));\n  }\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, N) {\n    if(i == j || j == k || k == i) angle[i][j][k] = false;\n    else angle[i][j][k] = theta(i, j, k) <= Theta + 10e-8;\n  }\n\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, 100000) dp[i][j][k] = 1e10;\n\n  priority_queue<state> q;\n  REP(i, 1, N) if(d[0][i] <= R + 1e-8) q.push((state) { 0, i, 1, d[0][i] });\n\n  int ans = 0;\n  while(q.size()) {\n    state c = q.top();\n    q.pop();\n\n    if(dp[c.p][c.c][c.n] <= c.d) continue;\n    dp[c.p][c.c][c.n] = c.d;\n\n    ans = max(ans, c.n);\n\n    REP(i, 0, N) if(angle[c.p][c.c][i]) {\n      double nd = c.d + d[c.c][i];\n      if(dp[c.c][i][c.n + 1] <= nd) continue;\n      if(nd <= R + 1e-8) q.push((state) { c.c, i, c.n + 1, nd });\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 200\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nint V;\ndouble r, theta, E_sz[500];\n\n// A*B の計算\nmat mul(mat &A, mat &B){\n\tmat C(A.size(), vec(B[0].size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tfor(int j = 0; j < B[0].size(); j++){\n\t\t\tdouble mini = INF;\n\t\t\tfor(int k = 0; k < B.size(); k++){\n\t\t\t\tmini = min(mini, A[i][k] + B[k][j]);\n\t\t\t}\n\t\t\tC[i][j] = mini;\n\t\t}\n\t}\n\treturn C;\n}\n\n// A^n の計算\nint mat_pow(mat A){\n\tmat B(A.size(), vec(A.size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tB[i][i] = 1;\n\t}\n\tint num = 0;\n\twhile(true){\n\t\tB = mul(B, A);\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < V * V; i++){\n\t\t\tfor(int j = 0; j < V * V; j++){\n\t\t\t\tif(B[i][j] + E_sz[i] < r){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\n\treturn num;\n}\n\nint main(){\n\t\n\tcin >> V;\n\t\n\tif(V == 1){\n\t\tcout << 0 << endl;\n\t}\n\t\n\tcin >> r >> theta;\n\t\n\ttheta = theta * M_PI / 180;\n\t\n\tmat S(V * V, vec(V * V));\n\t\n\tdouble x[30], y[30];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i = 0; i < V * V; i++){\n\t\tE_sz[i] = INF;\n\t\tfor(int j = 0; j < V * V; j++){\n\t\t\tS[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\tif(i == j || j == k || k == i){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble vx1, vx2, vy1, vy2;\n\t\t\t\tvx1 = x[j] - x[i];\n\t\t\t\tvy1 = y[j] - y[i];\n\t\t\t\tvx2 = x[k] - x[j];\n\t\t\t\tvy2 = y[k] - y[j];\n\t\t\t\tdouble inn = vx1 * vx2 + vy1 * vy2;\n\t\t\t\tdouble norm1 = sqrt(vx1 * vx1 + vy1 * vy1);\n\t\t\t\tdouble norm2 = sqrt(vx2 * vx2 + vy2 * vy2);\n\t\t\t\tE_sz[i * V + j] = norm1;\n\t\t\t\tE_sz[k * V + j] = norm2;\n\t\t\t\tdouble th = acos(inn * inn / norm1 / norm2);\n\t\t\t\tif(M_PI - th < theta){\n\t\t\t\t\tS[i * V + j][j * V + k] = norm2;\n\t\t\t\t\t//S[j * V + i][k * V + j] = norm2;\n\t\t\t\t\t//S[j * V + k][i * V + j] = norm1;\n\t\t\t\t\tS[k * V + j][j * V + i] = norm1;\n\t\t\t\t\t//cout << i * V + j << \" \" << j * V + k << \" \" << norm2 << endl;\n\t\t\t\t\t//cout << k * V + j << \" \" << j * V + i << \" \" << norm1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << mat_pow(S) + 1 << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nnamespace geometry{\n    using D = long double;\n    constexpr D eps =1e-9;\n\n    struct Point;\n    bool near_eq(Point, Point);\n    D norm(Point);\n\n    struct Point{\n        D x, y;\n        Point(D x = 0.0, D y = 0.0) : x(x), y(y){}\n        friend bool operator<(const Point& a, const Point& b){\n            return a.x == b.x ? a.y < b.y : a.x < b.x;\n        }\n        Point& operator+=(Point a){x += a.x, y += a.y; return *this;}\n        Point& operator-=(Point a){x -= a.x, y -= a.y; return *this;}\n        Point& operator*=(D p){x *= p, y *= p; return *this;}\n        Point& operator*=(Point b){return *this = *this * b;}\n        Point& operator/=(D p){x /= p, y /= p; return *this;}\n        Point& operator/=(Point b){return *this = *this / b;}\n        friend Point operator+(Point a, Point b){return Point(a) += b;}\n        friend Point operator-(Point a, Point b){return Point(a) -= b;}\n        friend Point operator*(Point a, D p){return Point(a) *= p;}\n        friend Point operator*(Point a, Point b){return Point(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y);}\n        friend Point operator/(Point a, D b){return Point(a) /= b;}\n        friend Point operator/(Point a, Point b){return Point(a.x * b.x + a.y * b.y, b.x * a.y - a.x * b.y) / norm(b);}\n    };\n    using P = Point;\n\n    struct Circle : public Point{\n        D r;\n        Circle(Point p = Point(), D r = 1) : Point(p), r(r){}\n        Circle(D x = 0.0, D y = 0.0, D r = 1) : Point(x, y), r(r){}\n    };\n    using C = Circle;\n\n    bool near_eq(D a, D b = 0.0){return abs(a - b) < eps;}\n    bool near_eq(P a, P b = Point()){return near_eq(a.x, b.x) && near_eq(a.y, b.y);}\n    D diag(P a){\n        assert(!near_eq(a));\n        return atan2(a.y, a.x);\n    }\n    D norm(P a){return a.x * a.x + a.y * a.y;}\n    D abs(P a){return sqrt(norm(a));}\n    D dist(P a, P b){return abs(a - b);}\n    D dot(P a, P b){return a.x * b.x + a.y * b.y;}\n    D cross(P a, P b){return a.x * b.y - a.y * b.x;}\n    int ccw(P a, P b, P c){\n        b -= a;\n        c -= a;\n        if(cross(b, c) > eps)return 1;\n        if(cross(b, c) < -eps)return -1;\n        if(dot(b, c) < -eps)return 2;\n        if(norm(b) < norm(c))return -2;\n        return 0;\n    }\n    bool is_on_line(P a1, P a2, P b){return abs(ccw(a1, a2, b)) != -1;}\n    bool is_on_segment(P a1, P a2, P b){return !ccw(a1, a2, b);}\n    P proj(P a1, P a2, P b){return a1 + dot(a2 - a1, b - a1) / norm(a2 - a1) * (a2 - a1);} // 直線への射影点\n    D dist(P a1, P a2, P b){return dist(proj(a1, a2, b), b);}\n    bool intersect(P a1, P a2, P b1, P b2){\n        return ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n               ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n    }\n    P cross_point(P a1, P a2, P b1, P b2){\n        D d1 = cross(b2 - b1, b1 - a1);\n        D d2 = cross(b2 - b1, a2 - a1);\n        if(near_eq(d1) && near_eq(d2))return a1;\n        assert(!near_eq(d2));\n        return a1 + d1 / d2 * (a2 - a1);\n    }\n    vector<Point> cross_point(C c1, C c2){\n        vector<Point> cross;\n        P diff = c2 - c1;\n        D d = abs(diff);\n        D crl = (norm(diff) + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n        if(near_eq(d) || c1.r < abs(crl))\n            return cross;\n        P abn = diff * P(0, sqrt(c1.r * c1.r - crl * crl) / d);\n        P cp = c1 + crl / d * diff;\n        cross.push_back(cp + abn);\n        if(!near_eq(abn))\n            cross.push_back(cp - abn);\n        return cross;\n    }\n    vector<pair<P, P>> tangent_lines(C c1, C c2){ // 共通接線、接線の両端は円との接点\n        vector<pair<P, P>> lines;\n        D d = dist(c1, c2);\n        for(int i = 0; i < 2; ++i){\n            D sin =(c1.r - (1 - i * 2) * c2.r) / d;\n            if(!(sin * sin < 1 + eps))\n                break;\n            D cos = sqrt(max(1 - sin * sin, D(0)));\n            for(int j = 0; j < 2; ++j){\n                P n = (c2 - c1) * P(sin, (1 - j * 2) * cos) / d;\n                lines.emplace_back(c1 + c1.r * n, c2 + (1 - i * 2)  * c2.r * n);\n                if(cos < eps)\n                    break;\n            }\n        }\n        return lines;\n    }\n}\n\n\nsigned main(){\n\n    int n;\n    geometry::D dr, theta;\n    cin >> n >> dr >> theta;\n    int r = dr + 1;\n    vector<geometry::P> points;\n    vector<int> x(n), y(n);\n    for(int i = 0; i < n; ++i){\n        cin >> x[i] >> y[i];\n        points.emplace_back(x[i], y[i]);\n    }\n\n    vector<vector<geometry::D>> dist(n, vector<geometry::D>(n));\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n            dist[i][j] = geometry::dist(points[i], points[j]);\n\n    vector<vector<int>> flag(n, vector<int>(n, 0));\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n            for(int k = 0; k < n; ++k){\n                if(i == j || j == k)\n                    continue;\n                geometry::P p1 = points[i] - points[j];\n                geometry::P p2 = points[k] - points[j];\n                geometry::D d = acos(min(1.0L, max(-1.0L, geometry::dot(p1, p2) / (geometry::abs(p1) * geometry::abs(p2)))));\n                if(180 - d * 180 / M_PI <= theta + geometry::eps){\n                    flag[i][j] |= (1 << k);\n                }\n            }\n        }\n    }\n\n    vector<vector<vector<geometry::D>>> dp(n, vector<vector<geometry::D>>(n, vector<geometry::D>(r + 1, dr + 1)));\n    for(int j = 1; j < n; ++j){\n            dp[0][j][1] = dist[0][j];\n    }\n\n    for(int k = 1; k < r; ++k){\n        for(int prev = 0; prev < n; ++prev){\n            for(int i = 0; i < n; ++i){\n                for(int nex = 0; nex < n; ++nex){\n                    if(!(flag[prev][i] & (1 << nex)) || dp[prev][i][k] >= 1e18)\n                        continue;\n                    chmin(dp[i][nex][k + 1], dp[prev][i][k] + dist[i][nex]);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n            for(int k = 0; k <= r; ++k){\n                if(dp[i][j][k] <= dr + geometry::eps)\n                    chmax(ans, k);\n            }\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast,unroll-loops\")\n#pragma GCC target (\"avx,avx2,fma\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  R r, th; cin >> r >> th, th *= pi / 180;\n  V<P> p(n); for (auto&& e : p) cin >> e;\n  VV< V<> > ks(20, VV<>(20));\n  VV<R> d(20, V<R>(20));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    for (int k = 0; k < n; ++k) if (k != j) {\n      L s{p[i], p[j]}, t{p[j], p[k]};\n      R ph = fmod(3 * pi + t.arg() - s.arg(), 2 * pi) - pi;\n      if (sgn(abs(ph), th) <= 0) ks[i][j].push_back(k);\n    }\n    d[i][j] = distPP(p[i], p[j]);\n  }\n  VV<R> dp(20, V<R>(20, 1e10));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    dp[i][j] = d[i][j];\n  }\n  int res = 0;\n  for (int s = 0; s <= 1e4; ++s) {\n    VV<R> ndp(20, V<R>(20, 1e10));\n    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n      if (!i and sgn(dp[i][j], r) <= 0) res = s + 1;\n      for (int k : ks[i][j]) {\n        ndp[i][j] = min(ndp[i][j], d[i][j] + dp[j][k]);\n      }\n    }\n    swap(dp, ndp);\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (lt(a, b) || equals(a, b))\n#define PI acos(-1)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\ndouble getAngle(Point a, Point b, Point c)\n{\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / PI;\n  return min(theta, 360 - theta);\n}\n\nint n;\ndouble r, t;\nvector<Point> ps;\n\ndouble d[21][21][10001];\n\nstruct State\n{\n  int now, prev, car;\n  double dist;\n  State(){}\n  State(int now, int prev, int car, double dist):now(now), prev(prev), car(car), dist(dist){}\n  bool operator < (const State& r) const {\n    return dist > r.dist;\n  }\n};\n\nint solve()\n{\n  rep(i, 21) rep(j, 21) rep(k, 10001) d[i][j][k] = 1e10;\n\n  priority_queue<State> que;\n  reps(i, 1, n) {\n    double dist = getDistance(ps[0], ps[i]);\n    if(le(dist, r)) {\n      d[i][0][1] = dist;\n      que.push(State(i, 0, 1, dist));\n    }\n  }\n\n  int ans = 0;\n  while(!que.empty()) {\n    State st = que.top(); que.pop();\n    int now = st.now, prev = st.prev, car = st.car;\n    double dist = st.dist;\n    ans = max(ans, car);\n    if(dist > d[now][prev][car]) continue;\n    rep(i, n) if(i != now) {\n      double di = dist + getDistance(ps[now], ps[i]);\n      if(le(getAngle(ps[prev], ps[now], ps[i]), t) && le(di, r) && d[i][now][car+1] > di) {\n\td[i][now][car+1] = di;\n\tque.push(State(i, now, car+1, di));\n      }\n    }\n  }\n\n  return ans;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> n >> r >> t;\n  ps.resize(n);\n  rep(i, n) cin >> ps[i].x >> ps[i].y;\n\n  cout << solve() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\n\nint main(){\n  int n;\n  double r, theta;\n  cin >> n >> r >> theta;\n  theta *= acos(-1)/180;\n  vector<int> X(n), Y(n);\n  for(int i = 0; i < n; ++i) cin >> X[i] >> Y[i];\n  vector< vector< pair<double,int> > > G(n*n);\n\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      if(j == i) continue;\n      for(int k = 0; k < n; ++k){\n        if(k == j) continue;\n        int x1 = X[j] - X[i], y1 = Y[j] - Y[i], x2 = X[k] - X[j], y2 = Y[k] - Y[j];\n        if(acos((x1*x2+y1*y2)/hypot(x1,y1)/hypot(x2,y2)) <= theta + EPS){\n          G[i*n+j].push_back(make_pair(hypot(x2,y2),j*n+k));\n        }\n      }\n    }\n  }\n\n  bool f = false;\n  int ans = 0;\n  vector<int> V;\n  vector<double> dp(n*n,0);\n  for(int i = 1; i < n; ++i){\n    int x1 = X[i] - X[0], y1 = Y[i] - Y[0];\n    if(hypot(x1,y1) <= r + EPS){\n      f = true;\n      dp[i] = r - hypot(x1,y1);\n      V.push_back(i);\n    }\n  }\n  while(f){\n    f = false;\n    ++ans;\n    vector<double> dp_(n*n,0);\n    vector<int> V_;\n    for(int i = 0; i < V.size(); ++i){\n      int v = V[i];\n      for(int j = 0; j < G[v].size(); ++j){\n        double c = G[v][j].first;\n        int v_ = G[v][j].second;\n        if(c <= dp[v] + EPS){\n          f = true;\n          if(dp_[v_] <= EPS) V_.push_back(v_);\n          dp_[v_] = max(dp_[v_],dp[v]-c);\n        }\n      }\n    }\n    dp = dp_;\n    V = V_;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nenum Type{\n\tCurrent,\n\tNext,\n};\n\nstruct Info{\n\tInfo(){\n\t\tx = y = 0;\n\t}\n\tdouble x,y;\n};\n\n\ndouble calc_dist(Info left,Info right){\n\treturn sqrt((left.x-right.x)*(left.x-right.x)+(left.y-right.y)*(left.y-right.y));\n}\n\ndouble calc_naiseki(Info left,Info right){\n\treturn left.x*right.x+left.y*right.y;\n}\n\nint main(){\n\n\tint N;\n\tdouble Limit,Angle;\n\tscanf(\"%d\",&N);\n\tscanf(\"%lf %lf\",&Limit,&Angle);\n\n\tInfo info[N];\n\n\tdouble dp[N][N][2],dist[N][N];\n\tbool check[N][N][N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tfor(int p = 0; p < N; p++)check[i][k][p] = false;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf\",&info[i].x,&info[i].y);\n\t}\n\n\tdouble tmp;\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N;k++){\n\t\t\ttmp = calc_dist(info[i],info[k]);\n\t\t\tdist[i][k] = tmp;\n\t\t\tdist[k][i] = tmp;\n\t\t}\n\t}\n\n\tInfo vector_1,vector_2;\n\tdouble len_1,len_2,naiseki,cos_value,kakudo;\n\n\tfor(int start = 0; start < N; start++){\n\t\tfor(int mid = 0; mid < N; mid++){\n\t\t\tif(start == mid)continue;\n\t\t\tfor(int goal = 0; goal < N; goal++){\n\t\t\t\tif(start != goal && mid != goal){\n\n\t\t\t\t\tlen_1 = calc_dist(info[goal],info[mid]);\n\t\t\t\t\tlen_2 = calc_dist(info[mid],info[start]);\n\n\t\t\t\t\tvector_1.x = info[goal].x - info[mid].x;\n\t\t\t\t\tvector_1.y = info[goal].y - info[mid].y;\n\n\t\t\t\t\tvector_2.x = info[mid].x - info[start].x;\n\t\t\t\t\tvector_2.y = info[mid].y - info[start].y;\n\n\t\t\t\t\tnaiseki = calc_naiseki(vector_1,vector_2);\n\n\t\t\t\t\tcos_value = naiseki/(len_1*len_2);\n\n\t\t\t\t\tkakudo = acos(cos_value)*180.0/M_PI;\n\n\t\t\t\t\tif(kakudo <= Angle){\n\t\t\t\t\t\tcheck[start][mid][goal] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint maximum = 0;\n\tbool FLG = false;;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)dp[i][k][Current] = DBL_MAX;\n\t}\n\n\tfor(int first = 1; first < N; first++){\n\t\tif(dist[0][first] <= Limit){\n\t\t\tdp[first][0][Current] = dist[0][first];\n\t\t\tFLG = true;\n\t\t}\n\t}\n\n\tif(FLG)maximum++;\n\n\twhile(true){\n\n\t\tFLG = false;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int k = 0; k < N; k++)dp[i][k][Next] = DBL_MAX;\n\t\t}\n\n\t\tfor(int start = 0; start < N; start++){\n\t\t\tfor(int pre = 0; pre < N; pre++){\n\t\t\t\tif(dp[start][pre][Current] == DBL_MAX)continue;\n\t\t\t\tfor(int to = 0; to < N; to++){\n\t\t\t\t\tif(start != to && pre != to){\n\t\t\t\t\t\tif(check[pre][start][to] == true && dp[to][start][Next] > dp[start][pre][Current]+dist[start][to] && dp[start][pre][Current]+dist[start][to] <= Limit){\n\t\t\t\t\t\t\tdp[to][start][Next] = dp[start][pre][Current]+dist[start][to];\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif(!FLG)break;\n\t\telse{\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int k = 0; k < N; k++)dp[i][k][Current] = dp[i][k][Next];\n\t\t\t}\n\t\t\tmaximum++;\n\t\t}\n\t}\n\n\n\tprintf(\"%d\\n\",maximum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ld = long double;\nusing ll = long long;\nconstexpr ld PI = 3.14159265359;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Pos {\n    ld x;\n    ld y;\n    Pos operator-(const Pos& p) const\n    {\n        return Pos{x - p.x, y - p.y};\n    }\n};\n\nld distance(const Pos& p1, const Pos& p2)\n{\n    return hypot(p1.x - p2.x, p1.y - p2.y);\n}\n\nld dot(const Pos& p1, const Pos& p2)\n{\n    return p1.x * p2.x + p1.y * p2.y;\n}\n\nbool reachable(const Pos& prev, const Pos& now, const Pos& to, const ld theta)\n{\n    if (theta == 180) {\n        return true;\n    } else {\n        return dot(now - prev, to - now) > distance(now, prev) * distance(to, now) * cos(theta * PI / 180);\n    }\n}\n\n\nint main()\n{\n    int n;\n    cin >> n;\n    ld r, theta;\n    cin >> r >> theta;\n\n    vector<Pos> pos(n);\n    for (int i = 0; i < n; i++) {\n        cin >> pos[i].x >> pos[i].y;\n    }\n\n    vector<vector<ld>> d(n, vector<ld>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = distance(pos[i], pos[j]);\n        }\n    }\n\n    vector<vector<vector<int>>> route(n, vector<vector<int>>(n, vector<int>(0)));  // prev->now???????????????to\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                if (k == j) {\n                    continue;\n                }\n                if (reachable(pos[i], pos[j], pos[k], theta)) {\n                    route[i][j].push_back(k);\n                }\n            }\n        }\n    }\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) {\n    //         if (not route[i][j].empty()) {\n    //             cerr << \"## After(\" << i << \"->\" << j << \")##\\n[\";\n    //             for (const int to : route[i][j]) {\n    //                 cerr << to << \",\";\n    //             }\n    //             cerr << \"]\" << endl;\n    //         }\n    //     }\n    // }\n\n    map<pair<int, int>, ld> prev;\n    map<pair<int, int>, ld> dp;\n    for (int i = 1; i < n; i++) {\n        if (d[0][i] <= r) {\n            prev[make_pair(0, i)] = d[0][i];\n        }\n    }\n    for (int i = 0; i < 2 * r; i++) {\n        if (prev.empty()) {\n            cout << i << endl;\n            return 0;\n        }\n        for (const auto& p : prev) {\n            const int from = p.first.first;\n            const int now = p.first.second;\n            const ld length = p.second;\n            for (const int to : route[from][now]) {\n                const ld tot = length + d[from][now];\n                if (tot > r) {\n                    continue;\n                }\n                const auto e = make_pair(now, to);\n                if (dp.find(e) == dp.end()) {\n                    dp[e] = tot;\n                } else {\n                    dp[e] = min(dp[e], tot);\n                }\n            }\n        }\n        // cerr << \"dp = [\";\n        // for (const auto& e : dp) {\n        //     cerr << e << \",\";\n        // }\n        // cerr << \"]\" << endl;\n\n        prev = dp;\n        dp.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\n#define mx(x,y) x=max(x,y)\ntypedef double D;\ntypedef complex<D> P;\nD dp[10011][20][20];\nD d[20][20];\nbool can[20][20][20];\nint main(){\n\tint n;\n\tD r,theta;\n\tcin>>n>>r>>theta;\n\tif(n==1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\ttheta*=acos(-1.0)/180;\n\tP p[20];\n\trep(i,n){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tp[i]=P(x,y);\n\t}\n\trep(i,n) rep(j,n) d[i][j]=abs(p[i]-p[j]);\n\trep(i,n) rep(j,n){\n\t\tif(i==j) continue;\n\t\trep(k,n){\n\t\t\tif(k==j) continue;\n\t\t\tif(abs( arg((p[k]-p[j])/(p[j]-p[i])) )<theta) can[i][j][k]=true;\n\t\t}\n\t}\n\tbool ok=false;\n\trep1(i,n-1){\n\t\tmx(dp[1][0][i],r-abs(p[0]-p[i]));\n\t\tif(dp[1][0][i]>0) ok=true;\n\t}\n\tif(!ok){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=10010;i++){\n\t\tbool update=false;\n\t\trep(a,n) rep(b,n){\n\t\t\tif(a==b) continue;\n\t\t\tif(dp[i][a][b]==0) continue;\n\t\t\trep(c,n){\n\t\t\t\tif(b==c) continue;\n\t\t\t\tif(can[a][b][c]&&dp[i][a][b]-d[b][c]>0){\n\t\t\t\t\tmx(dp[i+1][b][c],dp[i][a][b]-d[b][c]);\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!update){\n\t\t\tcout<<i<<endl;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct S{\n  double d;\n  int u, v, x;\n  S(double d, int u, int v, int x) : d(d), u(u), v(v), x(x) {}\n};\nbool operator < (const S& s, const S& t){\n  return s.d > t.d;\n}\ndouble sq(double x, double y){\n  return x*x + y*y;\n}\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    double r, a; cin>>r>>a;\n    double x[20], y[20];\n    double d[20][20];\n    bool ok[20][20][20] = {};\n    REP(i, N) cin>>x[i]>>y[i];\n    REP(u, N)FOR(v, u, N){\n      d[u][v] = d[v][u] = sqrt(sq(x[u] - x[v], y[u] - y[v]));\n    }\n    REP(u, N)REP(v, N)REP(t, N){\n      if(u == v || v == t || t == u) ok[u][v][t] = false;\n      else{\n        double cot = (x[v] - x[u]) * (x[t] - x[v]) + (y[v] - y[u]) * (y[t] - y[v]);\n        cot /= d[u][v];\n        cot /= d[v][t];\n        /*\n        printf(\"(%.2lf, %.2lf) -> (%.2lf, %.2lf) -> (%.2lf, %.2lf) : cot = %.2lf arccos = %.2lf a = %.2lf cos(a) = %.2lf\\n\",\n            x[u], y[u], x[v], y[v], x[t], y[t], cot, acos(cot), a, cos(a));\n            */\n        ok[u][v][t] = (cos(a*M_PI/180.0) < cot + EPS);\n      }\n    }\n    priority_queue<S> que;\n    FOR(i, 1, N){\n      que.push(S(d[0][i], 0, i, 1));\n    }\n    bool used[20][20][10001] = {};\n    int ans = 0;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      if(s.d > r + EPS) break;\n      if(used[s.u][s.v][s.x]) continue;\n      else used[s.u][s.v][s.x] = true;\n      ans = max(ans, s.x);\n      REP(to, N)if(ok[s.u][s.v][to]){\n        que.push(S(s.d + d[s.v][to], s.v, to, s.x + 1));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    long double r,theta;\n    cin >> n >> r >> theta;\n    vector<long double> x(n),y(n);\n    rep(i,0,n) cin >> x[i] >> y[i];\n\n    int ans=0;\n    long double dp[20][20];\n    fill_n((long double*)dp,20*20,inf);\n    rep(i,1,n) dp[0][i]=sqrtl((x[i]-x[0])*(x[i]-x[0])+(y[i]-y[0])*(y[i]-y[0]));\n    while(true){\n        if([&]{\n            long double mini=inf;\n            rep(i,0,n) rep(j,0,n) mini=min(mini,dp[i][j]);\n            return mini;\n        }()<r) ++ans;\n        else break;\n\n        long double prev[20][20];\n        memcpy(prev,dp,sizeof(long double)*20*20);\n        fill_n((long double*)dp,20*20,inf);\n        rep(i,0,n) rep(j,0,n) rep(k,0,n){\n            if(i==j or j==k) continue;\n            const long double l1=sqrtl((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));\n            const long double l2=sqrtl((x[k]-x[j])*(x[k]-x[j])+(y[k]-y[j])*(y[k]-y[j]));\n            if(((x[j]-x[i])*(x[k]-x[j])+(y[j]-y[i])*(y[k]-y[j]))/l1/l2<cosl(theta)) continue;\n            dp[j][k]=min(dp[j][k],prev[i][j]+l2);\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n//typedef tuple<int, int, int> T;\ntypedef pair<ll, ll> Pl;\n//typedef tuple<ll, ll, ll> Tl;\ndouble G[21][21];\nbool ok[21][21][21];\ndouble dp[21][21][10100];\nbool used[21][21][10100] = {};\ndouble r;\nint n;\n\n\ndouble calc(int b, int i, int nn) {\n\tassert(b != i);\n\tif (!nn) return 0;\n\tif (used[b][i][nn]) return dp[b][i][nn];\n\tused[b][i][nn] = true;\n\tdouble res = 1e10;\n\tfor (int j = 0; j < n; j++) {\n\t\tif (i == j) continue;\n\t\tif (ok[b][i][j]) {\n\t\t\tres = min(res, calc(i, j, nn-1)+G[i][j]);\n\t\t}\n\t}\n\tdp[b][i][nn] = res;\n\treturn res;\n}\n\nbool solve(int md) {\n\tfor (int i = 1; i < n; i++) {\n\t\tif (calc(0, i, md-1)+G[0][i] <= r) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> n;\n\tdouble c;\n\tcin >> r >> c;\n\tc = c/180*M_PI;\n\tcomplex<double> u[21];\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble a, b;\n\t\tcin >> a >> b;\n\t\tu[i] = complex<double>(a, b);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tG[i][j] = abs(u[i]-u[j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tdouble si = abs(arg(u[j]-u[i]) - arg(u[k] - u[j]));\n\t\t\t\tsi = fmod(si+2*M_PI, 2*M_PI);\n\t\t\t\tsi = min(si, 2*M_PI-si);\n\t\t\t\tif (si < c) {\n\t\t\t\t\tok[i][j][k] = true;\n\t\t\t\t} else {\n\t\t\t\t\tok[i][j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tok[i][j][i] = false;\n\t\t\tok[i][i][j] = false;\n\t\t\tok[j][i][i] = false;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\t//printf(\"%d %d %f\\n\", i, j, G[i][j]);\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t//printf(\"%d %d %d %d\\n\", i, j, k, ok[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint ll = 1, rr = 10100;\n\twhile (rr - ll > 1) {\n\t\tint md = (ll+rr)/2;\n\t\tif (solve(md)) {\n\t\t\tll = md;\n\t\t} else {\n\t\t\trr = md;\n\t\t}\n\t}\n\tcout << ll << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\nstruct P{\n  double cost;\n  int pos,pre,num;\n  P(double cost,int pos,int pre,int num):cost(cost),pos(pos),pre(pre),num(num){}\n  bool operator < (const P &a) const{return cost>a.cost;} \n};\ntypedef complex<double> point;\npoint z[21];\nint n;\ndouble r,x;\nvector <P> e[21][21];\nbool check(point a,point b){\n  a*=conj(b);\n    return 180.0*(abs(arg(a))/M_PI)<=x;\n}\n\ndouble D[10001][21][21];\nint dijkstra(){\n  int res=0;\n  for(int i=0;i<10001;i++)for(int j=0;j<n;j++)for(int k=0;k<n;k++) D[i][j][k]=INF;\n  priority_queue<P> Q; \n  Q.push(P(0,0,0,0));\n  D[0][0][0]=0;\n\n  while(!Q.empty()){\n    P t=Q.top();Q.pop();\n    double cost=t.cost;\n    int pos=t.pos,pre=t.pre,num=t.num;\n    if(cost>r) continue;\n    if(D[num][pos][pre]<cost) continue;\n    res=max(res,num);\n    for(int i=0;i<e[pos][pre].size();i++){\n      int nx=e[pos][pre][i].pos;\n      double ncost=cost+e[pos][pre][i].cost;\n      double &a=D[num+1][nx][pos];\n      if(a>ncost){\n\tQ.push(P(ncost,nx,pos,num+1));\n\ta=ncost;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>n>>r>>x;\n  for(int i=0;i<n;i++){\n    double a,b;\n    cin>>a>>b;\n    z[i]=point(a,b);\n  }\n\n  for(int i=0;i<n;i++) //pos\n    for(int j=0;j<n;j++)//pre\n      for(int k=0;k<n;k++){ // to\n\tdouble cost=abs(z[i]-z[k]);\n\tif(i!=k&&i!=j&&check(z[i]-z[j],z[k]-z[i]))e[i][j].push_back(P(cost,k,0,0));\n      }\n\n  for(int i=1;i<n;i++)e[0][0].push_back(P(abs(z[0]-z[i]),i,0,0));\n  cout <<dijkstra()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#define scanf_s scanf\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\n\nint main(void){\n\tint n,ans,i,j,k,ok;\n\tdouble r,sit;\n\tdouble x[20];\n\tdouble y[20];\n\tdouble dp[20][20]={0};//x??????y????????????\n\tdouble dpc[20][20]={0};\n\tdouble d;\n\tdouble pi=3.141592653589793238462643383279502884197;\n\tscanf(\"%d\",&n);\n\tscanf(\"%lf %lf\",&r,&sit);\n\tsit=(sit/180)*pi;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i][j]=0;\n\t\t\tdpc[i][j]=big;\n\t\t}\n\t}\n\tfor(ans=0;;ans++){\n\t\tfor(k=0;k<n;k++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(ans!=0&&(k-i)*(i-j)==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(k-j==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td=abs(atan2(y[i]-y[k],x[i]-x[k])-atan2(y[k]-y[j],x[k]-x[j]));\n\t\t\t\t\tif(ans!=0&&min(2*pi-d,d)>sit){continue;}\n\t\t\t\t\tdpc[k][j]=min(dpc[k][j],dp[i][k]+hypot(x[k]-x[j],y[k]-y[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tdp[i][j]=dpc[i][j];\n\t\t\t\tif(dpc[i][j]<r){\n\t\t\t\t\tok=1;\n\t\t\t\t}\n\t\t\t\tdpc[i][j]=big;\n\t\t\t}\n\t\t}\n\t\tif(ok==0){break;}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF (long long)(1e18)\n#define MOD (int)(1e9+7)\n\n#define EPS 1e-8\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX 22\n\nstring hogehogehoge;\n\nint n, x[MAX], y[MAX], used[MAX][MAX], hh[MAX][MAX];\ndouble r, t;\ndouble tete[MAX][MAX];\n\ndouble angle(double x1, double y1,double x2, double y2){//cout<<\"(\"<<x1<<\",\"<<y1<<\") (\"<<x2<<\",\"<<y2<<\")\";\n\tif(x1 >= INF-1){\n\t\t//cout<<\"-> \"<<0<<endl;\n\t\treturn 0;\n\t}\n\tdouble inner_product = x1*x2+y1*y2, ab1 = sqrt(x1*x1+y1*y1), ab2 = sqrt(x2*x2+y2*y2);\n\t//cout<<\"- > \"<<acos(inner_product/(ab1*ab2))<<endl;\n\treturn fabs(acos(inner_product/(ab1*ab2)));\n}\n\n\nint solve(int b,int g, double R, double xx, double yy){//cout<<g<<\" \"<<R<<endl;\n\t// cin>>hogehogehoge;\n\tint ans = 0, re = 1;\n\t\n\tif(b != INF){\n\t\tif(used[b][g] == 0) tete[b][g] = R, used[b][g]++;\n\t\telse if(used[b][g] == 1) tete[b][g] = R-tete[b][g],used[b][g]++;\n\t\telse{\n\t\t\tre +=  ((int)R/(int)tete[b][g])*hh[b][g];\n\t\t\tR -= ((int)R/(int)tete[b][g])*tete[b][g];\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tif(i==g) continue;\n\t\tif(angle(xx,yy,x[i]-x[g],y[i]-y[g]) <= t && (x[i]-x[g])*(x[i]-x[g]) + (y[i]-y[g])*(y[i]-y[g])<= R*R){\n\t\t\tans = max(ans,solve(g,i,R-sqrt((x[i]-x[g])*(x[i]-x[g]) + (y[i]-y[g])*(y[i]-y[g])),x[i]-x[g],y[i]-y[g]));\n\t\t}\n\t}\n\treturn ans+re;\n}\n\nint hoge(){\n\t// for(int i = 0; i < n; i++){\n\t\t// for(int j = 0; j < n; j++){\n\t\t\t// tete[i][j] = 1;\n\t\t// }\n\t// }\n\t\n\treturn solve(INF,0,r,INF,0)-1;\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(7);\n\t\n\t\n\tcin>>n>>r>>t;\n\t\n\t\n\tt = (t/360)*(2*acos(-1));\n\t\n\trep(i,n){\n\t\tcin>>x[i]>>y[i];\n\t}\n\t\n\t// cout<<solve(0,r,INF,0)-1<<endl;\n\tcout<<hoge()<<endl;\n\t\n\t// cout<<\"t = \"<<t<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\ndouble dp[22][22][15000];\nint n;\ndouble r, theta;\ndouble x[22], y[22];\nbool can[22][22][22];\n\ndouble dist(int i, int j) {\n    return pow(pow(x[i]-x[j], 2) + pow(y[i]-y[j], 2), 0.5);\n}\n\nint ans = 0;\nvoid chmin(double &a, double b) {\n    a = min(a, b);\n}\nint main() {\n    //cout.precision(10);\n    cin >> n;\n    cin >> r >> theta;\n    for(int i = 1; i <= n; i++) cin >> x[i] >> y[i];\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= n; j++) {\n            if(j == i) continue;\n            for(int k = 1; k <= n; k++) {\n                if(j == k) continue;\n                double X = (x[k] - x[j]) * (x[j] - x[i]);\n                double Y = (y[k] - y[j]) * (y[j] - y[i]);\n                //cerr << i << \" \" << j << \" \" << k << \" \" << \" \" << X << \" \" << Y << \" \" << acos((X + Y) / (dist(i, j ) * dist(j, k))) << endl;\n                if(acos((X + Y) / (dist(i, j) * dist(j, k))) - EPS <= (theta / 180.0 * PI)) {\n                    //cerr << i << \" \" << j << \" \" << k << endl;\n                    can[i][j][k] = true;\n                }\n            }\n        }\n    }\n    for(int i = 0; i <= 20; i++) {\n        for(int j = 0; j <= 20; j++) {\n            for(int k = 0; k <= 1e4 + 2; k++) dp[i][j][k] = 1e9;\n        }\n    }\n    for(int i = 2; i <= n; i++) {\n        dp[1][i][1] = dist(1, i);\n        if(dp[1][i][1] - EPS <= r) {\n            ans = 1;\n        }\n    }\n    if(ans == 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    for(int num = 2; num <= 2e5; num++) {\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= n; j++) {\n                if(i == j) continue;\n                for(int k = 1; k <= n; k++) {\n                    if(!can[i][j][k]) continue;\n                    chmin(dp[j][k][num], dp[i][j][num-1] + dist(j, k));\n                    //cerr << num << \" \" << j << \" \" << k << \" \" << dp[j][k][num] << endl;\n                    if(dp[j][k][num] - EPS <= r) ans = num;\n                }\n            }\n        }\n        if(ans != num) break;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double INF = (double)(1<<29);\nconst double EPS = 1e-7;\n\nint n, ans;\nvector<int> G[20][20];\ndouble r, theta;\nbool  memo[20][20][10001];\nP v[20];\n\nstruct state{\n  int prev,pos,sum;\n  double dis;\n  state(int p=0, int po=0, int s=0, double d=0):prev(p),pos(po),sum(s),dis(d){}\n  bool operator < (const state &s) const {\n    return dis > s.dis;\n  }\n};\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\ndouble calcTheta(P a, P b, P c){\n  double A = abs(b - a);\n  double B = abs(b - c);\n  double C = abs(a - c);\n  double ans = acos((A*A + B*B - C*C) / (2*A*B));\n  return M_PI - ans;\n}\n\n/*\nvoid dfs(int prev, int pos, int sum, double dis){\n  //if(memo[prev][pos][sum] <= dis || equal(memo[prev][pos][sum],dis)) return;\n  ans = max(ans,sum);\n  for(int i=0;i<G[prev][pos].size();i++){\n    int next = G[prev][pos][i];\n    if(dis + abs(v[pos]-v[next]) > r || memo[pos][next][sum+1] <= dis + abs(v[pos]-v[next]) || equal(memo[pos][next][sum+1], dis + abs(v[pos]-v[next]))) continue;\n    memo[pos][next][sum+1] = dis + abs(v[pos]-v[next]);\n    dfs(pos, next, sum+1, dis+abs(v[pos]-v[next]));\n  }\n}\n*/\n\nvoid bfs(){\n  priority_queue<state> Q;\n  state u,next;\n  for(int i=1;i<n;i++){\n    if(abs(v[i]-v[0]) > r) continue;\n    memo[0][i][1] = true;\n    Q.push(state(0,i,1,abs(v[i]-v[0])));\n  }\n\n  while(!Q.empty()){\n    u = Q.top();\n    Q.pop();\n    ans = max(ans,u.sum);\n    for(int i=0;i<G[u.prev][u.pos].size();i++){\n      next = state(u.pos, G[u.prev][u.pos][i], u.sum+1, u.dis);\n      next.dis += abs(v[u.pos]-v[next.pos]);\n      if(next.dis > r || memo[u.pos][next.pos][next.sum]) continue;\n      memo[u.pos][u.pos][next.sum] = true;\n      Q.push(next);\n    }\n  }\n}\n\nint main(){\n  while(cin >> n){\n    ans = 0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        G[i][j].clear();\n        for(int k=0;k<10001;k++) memo[i][j][k] = false;\n      }\n    }\n\n    cin >> r >> theta;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      v[i] = P(x,y);\n    }\n    theta *= M_PI / 180.0;\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        for(int k=0;k<n;k++){\n          if(i == k || j == k) continue;\n          if(calcTheta(v[i],v[j],v[k]) < theta) G[i][j].push_back(k);\n        }\n      }\n    }\n\n    /*\n    for(int i=1;i<n;i++){\n      if(abs(v[i]-v[0]) > r) continue;\n      memo[0][i][1] = abs(v[i]-v[0]);\n      dfs(0, i, 1, abs(v[i]-v[0]));\n      }\n    */\n    bfs();\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int MAX = 20,LIMIT = 15000,IINF = INT_MAX;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nstruct Edge{\n  int to;\n  double weight;\n  Edge(int to=0,double weight=0):to(to),weight(weight){}\n};\n\nstruct Data{\n  int prev,cur,carrot;\n  double dist;\n  Data(int prev=0,int cur=0,int carrot=0,double dist=0):prev(prev),cur(cur),carrot(carrot),dist(dist){}\n  bool operator < (const Data& data) const{ return dist > data.dist; }\n};\n\nint n;\ndouble r,theta,mindist[MAX][MAX][LIMIT]; // mindist[cur][prev][the number of carrot]\nPoint ps[MAX];\nvector<Edge> edge[MAX][MAX]; // edge[cur][prev]\n\ninline void dijkstra(){\n  rep(i,n)rep(j,n)rep(k,LIMIT) mindist[i][j][k] = IINF;\n  priority_queue<Data> Q;\n\n  REP(i,1,n) {\n    double dist = abs(ps[0]-ps[i]);\n    if( !equals(dist,r) && dist > r ) continue;\n    Q.push(Data(0,i,1,dist));\n    mindist[i][0][1] = dist;\n  }\n  int ans = (Q.empty()?0:1);\n\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n    int prev = data.prev, cur = data.cur, carrot = data.carrot;\n    double dist = data.dist;\n    assert(carrot+1 < LIMIT);\n    if( !equals(mindist[cur][prev][carrot],dist) && mindist[cur][prev][carrot] < dist ) continue;\n\n    rep(i,edge[cur][prev].size()) {\n      int next = edge[cur][prev][i].to;\n      double weight = edge[cur][prev][i].weight;\n      if( !equals(r,dist+weight) && r < dist+weight ) continue;\n      if( mindist[next][cur][carrot+1] > dist + weight ){\n        mindist[next][cur][carrot+1] = dist + weight;\n\n        ans = max(ans,carrot+1);\n        Q.push(Data(cur,next,carrot+1,dist+weight));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\ninline void makeEdge(){\n  rep(prev,n){\n    rep(cur,n){\n      if( cur == prev ) continue;\n      rep(next,n){\n        if( next == cur || next == prev ) continue;\n        double dist = abs(ps[cur]-ps[next]);\n        if( !equals(dist,r) && dist > r ) continue;\n        Vector v1 = ps[next] - ps[cur];\n        Vector v2 = ps[cur]  - ps[prev];\n        if( equals(cross(v1,v2),0.0) ) continue;\n        double arg = getArg(ps[prev],ps[cur],ps[next]);\n        if( equals(arg,theta) || arg < theta ) edge[cur][prev].push_back(Edge(next,dist));\n      }\n    }\n  }\n}\n\nint main(){\n\n  /*\n  int next = 2, cur = 1, prev = 0;\n  ps[0] = Point(0,0);\n  ps[1] = Point(10,0);\n  ps[2] = Point(0,1);\n  double arg =  getArg(ps[prev],ps[cur],ps[next]);\n  cout << \"arg = \" << arg * 180.0 / M_PI << endl;\n  */\n\n  cin >> n;\n  cin >> r >> theta;\n  theta = toRad(theta);\n  rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n\n  makeEdge();\n\n  dijkstra();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\nconst int MOD = 1000000007;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nclass Edge{\npublic:\n    int to;\n    double cost;\n    Edge(int to, double cost): to(to), cost(cost){};\n};\n\nint N;\ndouble R, T;\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    cin >> N;\n    cin >> R >> T;\n    T = T * M_PI / 180;\n    \n    vector<P> cities(N);\n    for(int i=0; i<N; i++){\n        double x, y; cin >> x >> y;\n        cities[i] = P(x, y);\n    }\n    \n    vector<vector<vector<Edge>>> G(N, vector<vector<Edge>>(N));\n    for(int i=0; i<N; i++){\n        for(int j=0; j<N; j++) if(i != j){\n            for(int k=0; k<N; k++) if(j != k){\n                double rad = abs(arg((cities[j]-cities[i])/(cities[k]-cities[j])));\n                if(LE(rad, T)){\n                    G[i][j].push_back(Edge(k, abs(cities[k]-cities[j])));\n                }\n            }\n        }\n    }\n    \n    //???????????????????????£?????? ??´????????? ????????? ???????°??????¢\n    vector<vector<vector<double>>> dp(int(R+1), vector<vector<double>>(N, vector<double>(N, INF)));\n    //dp[0][0][0] = 0;\n    \n    for(int i=1; i<N; i++)\n        dp[1][0][i] = abs(cities[i]-cities[0]);\n    \n    for(int i=1; i<int(R); i++){\n        for(int j=0; j<N; j++){\n            for(int k=0; k<N; k++) if(j != k){\n                for(auto edge: G[j][k]){\n                    dp[i+1][k][edge.to] = min(dp[i+1][k][edge.to], dp[i][j][k]+edge.cost);\n                }\n            }\n        }\n    }\n    \n    for(int i=R; i>=0; i--){\n        for(int j=0; j<N; j++){\n            for(int k=0; k<N; k++){\n                if(LE(dp[i][j][k], R)){\n                    cout << i << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << 0 << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst double pi = acos(-1);\nint n; double r, t;\nint main() {\n\tcin >> n >> r >> t; t *= pi / 180;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tint lim = (int)r;\n\tvector<vector<vector<double> > > dp(lim, vector<vector<double> >(n, vector<double>(n, 1.0e+10))); // (carrot - 2, now, prev)\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tdp[0][i][j] = hypot(x[i] - x[j], y[i] - y[j]);\n\t\t}\n\t}\n\tvector<vector<vector<bool> > > ok(n, vector<vector<bool> >(n, vector<bool>(n, false)));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (j == k) continue;\n\t\t\t\tdouble t2 = (x[i] - x[j]) * (x[j] - x[k]) + (y[i] - y[j]) * (y[j] - y[k]);\n\t\t\t\tt2 /= hypot(x[i] - x[j], y[i] - y[j]);\n\t\t\t\tt2 /= hypot(x[j] - x[k], y[j] - y[k]);\n\t\t\t\tif (acos(t2) < t) ok[i][j][k] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < lim; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (j == k) continue;\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tif (!ok[j][k][l]) continue;\n\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 1][k][l] + hypot(x[j] - x[k], y[j] - y[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < lim; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (dp[i][j][k] < r) ret = max(ret, i + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\n// distance between (x1,y1) and (x2,y2)\ndouble cdis(double x1, double y1, double x2, double y2) {\n  return sqrtl((x1 - x2) * (x1 - x2) +\n               (y1 - y2) * (y1 - y2));\n}\n// cos a\ndouble costh(double a, double b, double c) {\n  return (b * b + c * c - a * a) / (2.0 * b * c);\n}\ndouble r, t;\nint n;\npair<double, double> c[25];\ndouble dis[25][25] = {0};\n// possible? i -> j -> k\nbool ch[25][25][25] = {0};\ndouble dp[25][25][10000] = {0};\n\nint solve();\n\nint main() {\n  cin >> n >> r >> t;\n  for(int i = 0; i < n; ++i) {\n    double x, y;\n    cin >> x >> y;\n    c[i] = make_pair(x, y);\n  }\n  for(int i = 0; i < n; ++i)\n    for(int j = i + 1; j < n; ++j)\n      dis[i][j] = dis[j][i] =\n          cdis(c[i].fi, c[i].se, c[j].fi, c[j].se);\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j)\n      for(int k = 0; k < n; ++k) {\n        if(i == j || j == k) continue;\n        double a = dis[i][k], b = dis[i][j], c = dis[j][k];\n        if(180.0 - acos(costh(a, b, c)) * 180 / M_PI <= r &&\n           fabs(c - a + b) > 0.0001 &&\n           fabs(b - a + c) > 0.0001)\n          ch[i][j][k] = 1;\n      }\n\n  cout << solve() << endl;\n  return 0;\n}\n\nint solve() {\n  int ans = 0;\n  for(int i = 1; i < n; ++i)\n    if(dis[0][i] <= r) {\n      dp[0][i][1] = dis[0][i];\n      ans = 1;\n    }\n  if(ans == 0) return ans;\n  for(int k = 2; k <= 10000; ++k) {\n    // i -> j -> l\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < n; ++j)\n        for(int l = 0; l < n; ++l) {\n          if(i == j || j == l || (!ch[i][j][l]) ||\n             dp[i][j][k - 1] == 0 ||\n             dp[i][j][k - 1] + dis[j][l] > r)\n            continue;\n          if(dp[j][l][k] == 0) {\n            ans = k;\n            dp[j][l][k] = dp[i][j][k - 1] + dis[j][l];\n          }\n          else\n            dp[j][l][k] = min(dp[j][l][k],\n                              dp[i][j][k - 1] + dis[j][l]);\n        }\n    if(ans != k) break;\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n\ntypedef complex<double> P;\nconst double EPS = 1e-10;\nconst double INF = 1e9;\nconst double PI = acos((double)(-1));\n\nint n;\ndouble r, s;\nP p[20];\nbool canmove[20][20][20];\ndouble dp[10101][20][20] = {0};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> r >> s;\n\trep(i, 0, n)\n\t{\n\t\tdouble x, y; cin >> x >> y; p[i] = P(x, y);\n\t}\n\n\trep(i, 0, n) rep(j, 0, n) rep(k, 0, n)\n\t{\n\t\tcanmove[i][j][k] = false;\n\t\tif (i == j) continue;\n\t\tif (j == k) continue;\n\t\tif (i == k) continue;\n\t\tdouble rr = abs(arg((p[j] - p[i]) / (p[k] - p[j]))) / PI * 180.0;\n\t\tif (rr <= s - EPS) canmove[i][j][k] = true;\n\t}\n\n\trep(i, 0, 10101) rep(j, 0, n) rep(k, 0, n) dp[i][j][k] = INF;\n\n\trep(i, 1, n) dp[1][0][i] = abs(p[0] - p[i]);\n\n\tint ans = 0;\n\trep(i, 1, 10100) rep(j, 0, n) rep(k, 0, n)\n\t{\n\t\tif (r < dp[i][j][k] + EPS) continue;\n\n\t\t//printf(\"dp[%d][%d][%d]=%f\\n\", i, j, k, dp[i][j][k]);\n\n\t\tans = max(ans, i);\n\n\t\trep(l, 0, n) if (canmove[j][k][l])\n\t\t{\n\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][k] + abs(p[k] - p[l]));\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n\n#include<vector>\nusing namespace std;\n#define INF 1e8\n\nint n;\ndouble r, theta;\ndouble x[21], y[21];\ndouble dist[2][400];\nint cnt[400];\nvector<int> edge[10800];\ndouble d(int a, int b){\n\treturn sqrt((x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]));\n}\nbool ok(int a, int b, int c, double theta){\n\tdouble dot = (x[b]-x[a]) * (x[c]-x[b]) + (y[b]-y[a]) * (y[c] - y[b]);\n\tdouble dist1 = d(a, b);\n\tdouble dist2 = d(b, c);\n\treturn cos(theta)*dist1*dist2 <= dot;\n}\n\n\nint solve(double r){\n\tbool cont = true;\n\tbool ok = false;\n\tfor(int i = 0;i < 400;i++)dist[1][i] = INF;\n\tfor(int i = 1;i < n;i++){\n\t\tif(d(0, i) < r)ok = true;\n\t\tdist[1][i] = d(0,i);\n\t}\n\tif(!ok)return 0;\n\tint cnt = 0;\n\twhile(cont){\n\t\tcnt++;\n\t\tcont = false;\n\t\tfor(int i = 0;i < 400;i++)dist[!(cnt%2)][i] = INF;\n\t\tfor(int i = 0;i < 400;i++){\n\t\t\tfor(int j = 0;j < edge[i].size();j++){\n\t\t\t\tint to = edge[i][j];\n\t\t\t\tdouble dd = d(to / n, to % n);\n\t\t\t\tdist[!(cnt%2)][to] = min(dist[!(cnt%2)][to], dist[(cnt%2)][i] + dd);\n\t\t\t\tif(dist[!(cnt%2)][to] < r){\n\t\t\t\t\tcont = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tcin >> n;\n\tcin >> r >> theta;\n\ttheta = theta / 180 * 3.1415926535897932384626433;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tif(i == j || j == k)continue;\n\t\t\t\tif(ok(i, j, k, theta)){\n\t\t\t\t\tint u = i * n + j;\n\t\t\t\t\tint v = j * n + k;\n\t\t\t\t\tedge[u].push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << solve(r) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\nconst double INF=1e77;\nconst double PI=acos(-1);\n\nstruct state{\n\tdouble d;\n\tint pre,now,val;\n\tstate(double d,int pre,int now,int val):d(d),pre(pre),now(now),val(val){}\n\tbool operator<(const state &S)const{ return d>S.d; }\n};\n\nint main(){\n\tint n;\n\tdouble r,theta; scanf(\"%d%lf%lf\",&n,&r,&theta);\n\ttheta*=PI/180;\n\n\tint x[20],y[20];\n\trep(i,n) scanf(\"%d%d\",x+i,y+i);\n\n\tdouble dist[20][20];\n\trep(i,n) rep(j,n) dist[i][j]=hypot(x[i]-x[j],y[i]-y[j]);\n\n\tstatic bool adj[20][20][20]; // ツ陳シツ前ツづ?i ツづ可つ「ツづ?債。 j ツづ可つ「ツづゥツづ?つォ k ツづ可行ツつッツづゥツつゥツづ?つ、ツつゥ\n\trep(i,n) rep(j,n) if(i!=j) rep(k,n) if(j!=k) {\n\t\tdouble phi=acos(((x[i]-x[j])*(x[k]-x[j])+(y[i]-y[j])*(y[k]-y[j]))/(dist[i][j]*dist[k][j]));\n\t\tif(PI-phi<=theta) adj[i][j][k]=true;\n\t}\n\n\tstatic double d[20][20][10001];\n\trep(i,n) rep(j,n) rep(k,10001) d[i][j][k]=INF;\n\tpriority_queue<state> Q;\n\trep(i,n) if(i!=0 && dist[0][i]<=r) {\n\t\td[0][i][1]=dist[0][i];\n\t\tQ.push(state(dist[0][i],0,i,1));\n\t}\n\twhile(!Q.empty()){\n\t\tstate S=Q.top(); Q.pop();\n\t\tdouble d_now=S.d;\n\t\tint pre=S.pre,now=S.now,val=S.val;\n\n\t\tif(d_now>d[pre][now][val]+EPS) continue;\n\n\t\trep(nxt,n) if(adj[pre][now][nxt]) {\n\t\t\tdouble d_next=d_now+dist[now][nxt];\n\t\t\tif(d_next<=r && d_next+EPS<d[now][nxt][val+1]) {\n\t\t\t\td[now][nxt][val+1]=d_next;\n\t\t\t\tQ.push(state(d_next,now,nxt,val+1));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,n) rep(j,n) rep(k,10001) if(d[i][j][k]<=r) ans=max(ans,k);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst double PI = acos(-1);\nconst double INF = 1e15;\ndouble dp[10010][20][20];\n\nint n;\ndouble r, theta;\ndouble x[20], y[20];\n\ndouble dist(double x1, double y1, double x2, double y2){\n    x1 -= x2, y1 -= y2;\n    return sqrt(x1 * x1 + y1 * y1);\n}\n\ndouble dot(double x1, double y1, double x2, double y2){\n    return x1 * x2 + y1 * y2;\n}\n\nbool check(int v, int u, int pre){\n    double ax = x[v] - x[pre];\n    double ay = y[v] - y[pre];\n    double bx = x[u] - x[v];\n    double by = y[u] - y[v];\n    double da = dist(x[v], y[v], x[pre], y[pre]);\n    double db = dist(x[u], y[u], x[v], y[v]);\n    double t = abs(acos(dot(ax, ay, bx, by) / da / db));\n    //cerr << \"\\t\\t\" << v << \" \" << u << \" \" << pre << \" \" << t << endl;\n    return t < theta;\n}\n\nint main(){\n    cin >> n >> r >> theta;\n\n    theta *= 2 * PI / 360.0;\n    //cerr << theta <<endl;\n    //return 0;\n\n    for(int i = 0; i < n; i++){\n        cin >> x[i] >> y[i];\n    }\n\n    for(int i = 0; i <= 10000; i++){\n        for(int j = 0; j < n; j++){\n            for(int k = 0; k < n; k++){\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n\n    //cout << check(2, 0, 1) << endl;\n    //return 0;\n    for(int i = 0; i < n; i++){\n        dp[0][i][0] = 0;\n    }\n    for(int i = 0; i <= 10000; i++){\n        for(int v = 0; v < n; v++){\n            for(int pre = 0; pre < n; pre++){\n                double d = dp[i][v][pre];\n                if(d == INF) continue;\n                //cerr << i << \" \" << v << \" \" << pre << \" \" << d << endl;\n                for(int u = 0; u < n; u++){\n                    if(v == u) continue;\n                    if(i != 0 && !check(v, u, pre)) continue;\n                    //cerr << \"\\t\" << v << \" \" << u << endl;\n                    double ndist = d + dist(x[v], y[v], x[u], y[u]);\n                    if(ndist < r && dp[i + 1][u][v] > ndist){\n                        dp[i + 1][u][v] = ndist;\n                    }\n                }\n            }\n        }\n\n    }\n\n    int ans = 0;\n    for(int i = 0; i <= 10000; i++){\n        for(int v = 0; v < n; v++){\n            for(int pre = 0; pre < n; pre++){\n                double d = dp[i][v][pre];\n                if(d == INF) continue;\n                ans = max(ans, i);\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\n\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing P = complex<double>;\nusing vd = vector<double>;\nusing vvd = vector<vd>;\nusing vvvd = vector<vvd>;\nconst double EPS = 1e-8;\n#define SIZE 1e4+5\n\nint main(){\n  int n; cin >> n;\n  double r, theta; cin >> r >> theta;\n  theta *= M_PI/180.0;\n  vector<P> ps(n);\n  rep(i,n){\n    double x, y; cin >> x >> y;\n    ps[i] = P(x,y);\n  }\n\n  vector<vvi> can(n,vvi(n));\n  rep(i,n) rep(j,n){\n    if(i == j) continue;\n    rep(k,n){\n      if(j == k) continue;\n      if(abs(arg((ps[j]-ps[i])/(ps[k]-ps[j]))) - EPS < theta){\n\tcan[i][j].push_back(k);\n      }\n    }\n  }\n\n  vvvd dp(n+1, vvd(n, vd(SIZE)));\n  dp[n][0][0] = r; // 前の場所がないことをn->で表す\n  rep(k,SIZE-1) rep(i,n+1) rep(j,n){\n    if(i == n){\n      FOR(x,1,n) chmax(dp[j][x][k+1] , dp[i][j][k] - abs(ps[j]-ps[x]));\n    }else{\n      for(auto x : can[i][j]){\n\tchmax(dp[j][x][k+1] , dp[i][j][k] - abs(ps[j]-ps[x]));\n      }\n    }\n  }\n  int ans = 0;\n  rep(i,n+1) rep(j,n) rep(k,SIZE){\n    if(dp[i][j][k] > EPS){\n      chmax(ans, k);\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 21;\nconst int MAXX = 10001;\nconst double eps = 1e-6;\nconst double inf = 1e10;\n\nint n;\ndouble r, th;\nP ps[MAXN];\ndouble dp[MAXX][MAXN][MAXN];\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble getAngle(P a, P b) {\n  double v = dot(a, b) / (abs(a) * abs(b));\n  if(v > 1.0) return 0;\n  if(v < -1.0) return M_PI;\n  return acos(v);\n}\n\nint main() {\n  while(cin >> n) {\n    cin >> r >> th;\n    th = th * M_PI / 180.0;\n    for(int i = 0; i < n; ++i)\n      cin >> ps[i].real() >> ps[i].imag();\n    fill(dp[0][0], dp[MAXX][0], inf);\n    dp[0][0][0] = 0;\n    int res = 0;\n    for(int i = 0; i+1 < MAXX; ++i) {\n      if(i != res) break;\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < n; ++k) {\n          if(dp[i][j][k] == inf) continue;\n          for(int l = 0; l < n; ++l) {\n            if(k == l) continue;\n            if(j != k) {\n              P a = ps[k] - ps[j], b = ps[l] - ps[k];\n              double rad = getAngle(a, b);\n              if(rad > th + eps) continue;\n            }\n            dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + abs(ps[l]-ps[k]));\n            if(dp[i+1][k][l] < r + eps) {\n              res = i + 1;\n            }\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double inf=1e8;\n#define rep(i,a) for(int i=0;i<a;i++)\ndouble dp[20][20][10010];\nint main(){\n  rep(i,20)rep(j,20)rep(k,10010)dp[i][j][k]=inf;\n  int n;\n  double x,y;\n  cin>>n>>x>>y;\n  y*=PI/180;\n  G g(n);\n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    g[i]=P(a,b);\n  }\n  dp[0][0][0]=0;\n  rep(i,10010)rep(j,n)rep(k,n)if(i==0||j!=k){\n    rep(l,n)if(l!=k){\n      double dis=abs(g[k]-g[l]);\n      //if(i==0)printf(\"%.9f %.9f\\n\",x,dis+dp[j][k][l]);\n      if(dis+dp[j][k][i]>x)continue;\n      double q=abs(arg(g[k]-g[j])-arg(g[l]-g[k]));\n      while(q>PI)q=2*PI-q;//q-=PI;\n      if(i==0){\n\tq=0;//abs(arg(g[l]-g[k]));\n      }\n      if(q>y)continue;\n      dp[k][l][i+1]=min(dp[k][l][i+1],dp[j][k][i]+dis);\n    }\n  }\n  int out=0;\n  rep(i,n)rep(j,n)rep(k,10010)if(abs(dp[i][j][k]-inf)>EPS)out=max(out,k);\n  cout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define fs first\n#define sc second\n#define pb push_back\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<D,int> Edge;\ntypedef pair<Edge, pair<int,int> > state;\n\nconst D PI = acos(-1);\nconst D EPS = 1e-8;\n\ninline D dis(D x1, D y1, D x2, D y2){\n  return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\ninline D dot(P x, P y){ return real(conj(x)*y); }\n\ninline D base(P a,P b,P c){ return dot(b-a,c-b)/abs(b-a)/abs(c-b);}\ninline D arg(P a, P b, P c){ return acos(dot(b-a,c-b)/abs(b-a)/abs(c-b)); }\n\nint n;\nD r,s;\nP p[30];\nD d[30][30];\nvector<Edge> g[30][30];\nD lensum[30][30][1010];\n\nint main(){ \n  cin >> n >> r >> s;\n  s *= PI/180;\n  rep(i,n)cin >> p[i].real() >> p[i].imag();\n  rep(i,n){\n    d[i+1][i+1] = 0;\n    for(int j=i+1;j<n;j++){\n      d[i+1][j+1] = d[j+1][i+1] = abs(p[i]-p[j]);\n    }\n  }\n  \n  rep(i,n){\n    if(i)g[0][1].pb(Edge(d[1][i],i));\n  }\n\n  rep(i,n){\n    rep(j,n){\n      if(i==j)continue;\n      rep(k,n){\n\tif(j==k || i==k)continue;\n\tD seta = arg(p[i],p[j],p[k]);\n\t//if(abs(base(p[i],p[j],p[k])-1.0)<EPS)continue;\n\t//if(abs(base(p[i],p[j],p[k])+1.0)<EPS)continue;\n\tif(seta < s + EPS){\n\t  g[i+1][j+1].pb(Edge(d[j+1][k+1],k+1));\n\t}\n      }\n    }\n  }\n\n  rep(i,n+1)rep(j,n+1)rep(k,1010)lensum[i][j][k] = 1e10;\n  lensum[0][1][0] = 0;\n  priority_queue<state,vector<state>,greater<state> > q;\n  q.push(mk(mk(0,0),mk(0,1)));\n\n  int ans = 0;\n  while(q.size()){\n    state tmp = q.top(); q.pop();\n    D len = tmp.fs.fs;\n    int carrot = tmp.fs.sc+1, prv = tmp.sc.fs, cur = tmp.sc.sc;\n\n    rep(i,g[prv][cur].size()){\n      D cost = g[prv][cur][i].fs;\n      int nxt = g[prv][cur][i].sc;\n\n      if(len + cost > r + EPS)continue;\n      if(lensum[cur][nxt][carrot] > len + cost + EPS){\n\tlensum[cur][nxt][carrot] = len + cost;\n\tq.push(state(mk(len+cost,carrot),mk(cur,nxt)));\n\tans = max(ans,carrot);\n      }\n    }\n  }\t\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  R r, th; cin >> r >> th, th *= pi / 180;\n  V<P> p(n); for (auto&& e : p) cin >> e;\n  VV< V<> > ks(20, VV<>(20));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    for (int k = 0; k < n; ++k) if (k != j) {\n      L s{p[i], p[j]}, t{p[j], p[k]};\n      R ph = fmod(3 * pi + t.arg() - s.arg(), 2 * pi) - pi;\n      if (sgn(abs(ph), th) <= 0) ks[i][j].push_back(k);\n    }\n  }\n  VV<R> dp(20, V<R>(20, 1e10));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    dp[i][j] = distPP(p[i], p[j]);\n  }\n  int res = 1;\n  for (int s = 0; s <= 1e4; ++s) {\n    VV<R> ndp(20, V<R>(20, 1e10));\n    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n      for (int k : ks[i][j]) {\n        ndp[i][j] = min(ndp[i][j], distPP(p[i], p[j]) + dp[j][k]);\n      }\n      if (sgn(ndp[i][j], r) <= 0) res = s + 2;\n    }\n    swap(dp, ndp);\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\ndouble d[20][20], a[20][20][20], dp[10000][20][20];\n\nint main() {\n\tint n; double r, th;\n\tcin >> n >> r >> th;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\td[i][j] = hypot(x[i] - x[j], y[i] - y[j]);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (i == j || j == k) continue;\n\t\t\t\tint x1 = x[i] - x[j], y1 = y[i] - y[j];\n\t\t\t\tint x2 = x[j] - x[k], y2 = y[j] - y[k];\n\t\t\t\tdouble c = (x1 * x2 + y1 * y2) / d[i][j] / d[j][k];\n\t\t\t\ta[i][j][k] = (c >= cos(th / 180 * M_PI));\n\t\t\t}\n\tfill(dp[0][0], dp[0][0] + 10000 * 20 * 20, FLT_MAX);\n\tfor (int i = 1; i < n; i++)\n\t\tdp[1][i][0] = d[i][0];\n\tfor (int l = 2; l < 10000; l++)\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\tif (i != j && j != k && a[i][j][k])\n\t\t\t\t\t\tdp[l][i][j] = min(dp[l][i][j], dp[l - 1][j][k] + d[j][k]);\n\tint maxi = 0;\n\tfor (int l = 1; l < 10000; l++)\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (dp[l][i][j] <= r) maxi = l;\n\tcout << maxi << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> mid = cities[prev];\n  complex<double> dst = cities[city];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\n#define pow2(a) (pow(1.*a,2))\ntypedef struct D\n{\n\tint c,pp,np;\n\tdouble d;\n\tbool operator <(const D &a)const{ return d>a.d;};\n}D;\n\nint N,X[21],Y[21],res=0,g[21][21][21];\ndouble R,O,d[21][21],F[21][21][10010];\ndouble ang(int pre,int now,int next)\n{\n\tdouble a=d[pre][now],b=d[now][next],c=d[pre][next];\n\tdouble dd=acos((pow2(a)+pow2(b)-pow2(c))/(2*a*b));\n\tdouble df=180-(dd*180/3.141592);\n\treturn df;\n}\n\nint main()\n{\n\tscanf(\"%d%lf%lf\",&N,&R,&O);\n\tmemset(g,0,sizeof(g));\n\tfor(int i=0;i<21;i++)for(int k=0;k<21;k++)for(int j=0;j<10010;j++)F[i][k][j]=1e14;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",X+i,Y+i);\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\td[i][j]=sqrt(pow2(X[i]-X[j])+pow2(Y[i]-Y[j]));\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\tfor(int k=0;k<N;k++)\n\t\t\t\tif(ang(i,j,k)<O)\n\t\t\t\t\tg[i][j][k]=1;\n\tpriority_queue<D>Q;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tif(d[0][i]>R)continue;\n\t\tD tmp={1,0,i,d[0][i]};\n\t\tF[0][i][1]=d[0][i];\n\t\tQ.push(tmp);\n\t}\n\tfor(;!Q.empty();)\n\t{\n\t\tD tmp=Q.top();Q.pop();\n\t\tres=max(tmp.c,res);\n\t\tif(F[tmp.pp][tmp.np][tmp.c]-tmp.d>0.001)\n\t\t\tcontinue;\n\t\tF[tmp.pp][tmp.np][tmp.c]=tmp.d;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(i==tmp.np)continue;\n\t\t\tif(g[tmp.pp][tmp.np][i]&&tmp.d+d[tmp.np][i]<=R)\n\t\t\t{\n\t\t\t\tD ins={tmp.c+1,tmp.np,i,tmp.d+d[tmp.np][i]};\n\t\t\t\tif(F[ins.pp][ins.np][ins.c]-ins.d>0.001)\n\t\t\t\t{\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t\tF[ins.pp][ins.np][ins.c]=ins.d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <algorithm>\n#undef max\n#undef min\n\nstruct Node {\n    int lastPos = 0;\n    int pos = 0;\n    int carrot = 0;\n    float len = 0;\n    std::vector<int> hist;\n};\n\nint main() {\n    int n; float r, theta;\n    float angleTable[20][20][20] = { 0 };\n    float dist[20][20] = { 0 };\n    std::vector<float> memo[20];\n    std::vector<std::pair<int, int>> city;\n    std::cin >> n >> r >> theta;\n    theta /= 180.f;\n    theta *= M_PI;\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        city.push_back(std::make_pair(x, y));\n    }\n\n    // memo初期化\n    for (auto& x : memo) {\n        x.push_back(0.f);\n    }\n\n    // 都市間移動の角度と距離を計算\n    for (int i = 0; i < city.size(); i++) { // 前\n        for (int j = 0; j < city.size(); j++) { // 今\n            if (i == j) continue;\n            for (int k = 0; k < city.size(); k++) { // 次\n                if (j == k) continue;\n                if (i != k) {\n                    float vx[2] = { (float)(city[i].first - city[j].first) , (float)(city[k].first - city[j].first) };\n                    float vy[2] = { (float)(city[i].second - city[j].second) , (float)(city[k].second - city[j].second) };\n                    float jLen = std::sqrt(vx[0] * vx[0] + vy[0] * vy[0]);\n                    float kLen = std::sqrt(vx[1] * vx[1] + vy[1] * vy[1]);\n                    float dot = vx[0] * vx[1] + vy[0] * vy[1];\n                    float a = dot / (jLen * kLen);\n                    angleTable[i][j][k] = (float)(M_PI) - std::acos(dot / (jLen * kLen));\n                }\n                else angleTable[i][j][k] = (float)(M_PI);\n            }\n            float vx = city[j].first - city[i].first;\n            float vy = city[j].second - city[i].second;\n            dist[i][j] = std::sqrt(vx * vx + vy * vy);\n        }\n    }\n\n    std::stack<Node> s;\n    int maxCarrot = 0;\n    s.push({0, 0, 0, 0.f});\n\n    while (!s.empty()) {\n        auto node = s.top(); s.pop();\n        for (int i = 0; i < city.size(); i++) {\n            if (i == node.pos) continue;\n            if (node.pos != node.lastPos && angleTable[node.lastPos][node.pos][i] >= theta) continue;\n            auto next = node;\n            next.lastPos = next.pos;\n            next.len += dist[node.pos][i];\n            if (next.len > r) continue;\n\n            next.pos = i;\n            next.carrot++;\n\n            if (memo[i].size() <= next.carrot) {\n                int m = memo[i].size();\n                for (int j = 0; j < next.carrot - m; j++) {\n                    memo[i].push_back(memo[i].back());\n                }\n                memo[i].push_back(next.carrot);\n            }\n            else {\n                if (memo[i][next.carrot] <= next.len) continue; // もっと短い距離で同数の人参に到達\n            }\n            next.hist.push_back(i);\n            maxCarrot = std::max(maxCarrot, next.carrot);\n            if (maxCarrot == 11) {\n                int a = 0;\n                a = 5;\n            }\n            s.push(next);\n        }\n    }\n    std::cout << maxCarrot << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\n#define EPS 1e-6\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ndouble dis(Point a, Point b){ return abs(a - b); }\ndouble dot(Point a, Point b){ return a.real() * b.real() + a.imag() * b.imag(); }\n\n//テッツシツ津」ツ?、テ」ツ?ョテ」ツδ凖」ツつッテ」ツδ暗」ツδォABテ」ツ?ョテ」ツ?ェテ」ツ?凖ィツァツ津・ツコツヲテ篠クテ」ツつ津ヲツアツづ」ツつ?」ツつ?(テ」ツδ催」ツδε」ツδ暗」ツ?凝」ツつ嘉ヲツ仰セテ」ツ?」テ」ツ?ヲテ」ツ?催」ツ?淌」ツつづ」ツ?ョテ」ツ?ョテ、ツクツクテ」ツつウテ」ツδ?\ndouble AngleOf2Point(Point A, Point B){\n  //テ」ツ??「ツ?サテ」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?ョテゥツ閉キテ」ツ?陛」ツ??テ」ツ??」ツ?ィテァツュツ氾」ツ?暗」ツ?古・ツ?コテ」ツ?セテ」ツ?崚」ツつ禿」ツ?ョテ」ツ?ァテヲツウツィテヲツ?湘」ツ?療」ツ?ヲテ」ツ?湘」ツ??」ツ?陛」ツ??」ツ??\n\n  //テ」ツδ凖」ツつッテ」ツδ暗」ツδォAテ」ツ?ィBテ」ツ?ョテゥツ閉キテ」ツ?陛」ツつ津ィツィツ暗ァツョツ療」ツ?凖」ツつ?\n  double length_A = sqrt(A.real() * A.real() + A.imag() * A.imag());\n  double length_B = sqrt(B.real() * B.real() + B.imag() * B.imag());\n  \n  //テ・ツ??ァツゥツ催」ツ?ィテ」ツδ凖」ツつッテ」ツδ暗」ツδォテゥツ閉キテ」ツ?陛」ツつ津、ツスツソテ」ツ?」テ」ツ?ヲcosテ篠クテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n  double cos_sita = dot(A, B) / (length_A * length_B );\n  \n  //cosテ篠クテ」ツ?凝」ツつ嘉篠クテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n  double sita = acos( cos_sita );\t\n  \n  //テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ァテ」ツ?ェテ」ツ??テッツスツ?80テ」ツ?ョティツァツ津・ツコツヲテ」ツ?ァテ」ツ?サテ」ツ?療」ツ??・ツ?エテ・ツ青暗」ツ?ッテ」ツつウテ」ツδ。テ」ツδウテ」ツδ暗・ツ、ツ姪」ツ??\n  sita = sita * 180.0 / M_PI;\n  \n  return sita;\n}\n\n\ndouble AngleOf2Line(Line A, Line B){ return AngleOf2Point(A.first - A.second, B.first - B.second); }\n\n\nint main(void){\n  int n;\n  double r, theta;\n  cin >> n >> r >> theta;\n\n  int x, y;\n  vector<Point> town;\n  for(int i = 0; i < n; i++){\n    cin >> x >> y;\n    town.push_back(Point(x, y));\n  }\n\n  // adj[i][j]: jテ」ツ?凝」ツつ永テ」ツ?ォテ」ツ?催」ツ?淌・ツセツ古」ツ?ォテゥツ?キテァツァツサテ」ツ?ァテ」ツ?催」ツつ凝ゥツ?づァツつケテ」ツδェテ」ツつケテ」ツδ?\n  vector<vector<vector<int> > > adj(n, vector<vector<int> >(n));\n  for(int i = 0; i < n; i++)\n    for(int j = 0; j < n; j++)\n      for(int k = 0; k < n; k++)\n        if(i != j && i != k)\n          if(AngleOf2Line(make_pair(town[j], town[i]), make_pair(town[i], town[k])) <= theta + EPS)\n            adj[i][j].push_back(k);\n\n  int int_r = (int)r + 1;\n  vector<vector<vector<double> > > dp(n, vector<vector<double> >(n, vector<double>(int_r, INF)));\n  for(int now = 0; now < n; now++){ dp[now][0][0] = dis(town[0], town[now]); }\n  for(int carrot = 0; carrot < int_r - 1; carrot++){\n    for(int now = 0; now < n; now++){\n      for(int prev = 0; prev < n; prev++){\n        for(size_t i = 0; i < adj[now][prev].size(); i++){\n          int next = adj[now][prev][i];\n          dp[next][now][carrot + 1] = min(dp[next][now][carrot + 1],\n                                          dp[now][prev][carrot] + dis(town[now], town[next]));\n        }\n      }\n    }\n  }\n\n  int ans = -1;\n  for(int carrot = 0; carrot < int_r; carrot++)\n    for(int now = 0; now < n; now++)\n      for(int prev = 0; prev < n; prev++)\n        if(dp[now][prev][carrot] < r)\n          ans = carrot;\n\n  cout << ans + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct S{\n  double d;\n  int u, v, x;\n  S(double d, int u, int v, int x) : d(d), u(u), v(v), x(x) {}\n};\nbool operator < (const S& s, const S& t){\n  return s.d > t.d;\n}\ndouble sq(double x, double y){\n  return x*x + y*y;\n}\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    double r, a; cin>>r>>a;\n    double x[20], y[20];\n    double d[20][20];\n    bool ok[20][20][20] = {};\n    REP(i, N) cin>>x[i]>>y[i];\n    REP(u, N)FOR(v, u, N){\n      d[u][v] = d[v][u] = sqrt(sq(x[u] - x[v], y[u] - y[v]));\n    }\n    REP(u, N)REP(v, N)REP(t, N){\n      if(u == v || v == t || t == u) ok[u][v][t] = false;\n      else{\n        double cot = (x[v] - x[u]) * (x[t] - x[v]) + (y[v] - y[u]) * (y[t] - y[v]);\n        cot /= d[u][v];\n        cot /= d[v][t];\n        ok[u][v][t] = (cos(a) < cot);\n      }\n    }\n    priority_queue<S> que;\n    FOR(i, 1, N){\n      que.push(S(d[0][i], 0, i, 1));\n    }\n    bool used[20][20][10001] = {};\n    int ans = 0;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      if(s.d > r) break;\n      if(used[s.u][s.v][s.x]) continue;\n      else used[s.u][s.v][s.x] = true;\n      ans = max(ans, s.x);\n      REP(to, N)if(ok[s.u][s.v][to]){\n        que.push(S(s.d + d[s.v][to], s.v, to, s.x + 1));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble dp[1000][20][20];\n\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tdouble r,t;\n\tcin>>n>>r>>t;\n\tt=t*M_PI/180.0;\n\tint x[n],y[n];\n\tfor (int i = 0; i < n; ++i) cin>>x[i]>>y[i];\n\t\n\tbool moveok[n][n][n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tfor (int j = 0; j < n; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t{\n\t\t\t\tif(i==j||j==k||k==i) moveok[i][j][k]=0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdouble rad1=(double)(y[i]-y[j])/(x[i]-x[j]),rad2=(double)(y[j]-y[k])/(x[j]-x[k]);\n\t\t\t\t\tif(x[i]==x[j]) rad1=(y[i]>y[j])?-M_PI/2:M_PI/2;\n\t\t\t\t\telse if(x[i]-x[j]>0) rad1=atan(rad1)+M_PI;\n\t\t\t\t\telse rad1=atan(rad1);\n\t\t\t\t\tif(x[j]==x[k]) rad2=(y[j]>y[k])?-M_PI/2:M_PI/2;\n\t\t\t\t\telse if(x[j]-x[k]>0) rad2=atan(rad2)+M_PI;\n\t\t\t\t\telse rad2=atan(rad2);\n\t\t\t\t\tdouble rad=fabs(rad1-rad2);\n\t\t\t\t\twhile(rad>M_PI) rad-=2*M_PI;\n\t\t\t\t\tif(fabs(rad)<t+0.0001) moveok[i][j][k]=1;\n\t\t\t\t\telse moveok[i][j][k]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble distance[n][n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tfor (int j = 0; j < n; ++j)\n\t\t{\n\t\t\tdistance[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 1000; ++i)\n\t{\n\t\tfor (int j = 0; j < 20; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < 20; ++k)\n\t\t\t{\n\t\t\t\tdp[i][j][k]=1e6;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tif(distance[0][i]<=r+0.0001) dp[1][0][i]=distance[0][i],ans=1;\n\t}\n\n\tfor (int i = 1; i < 1000; ++i)\n\t{\n\t\tfor (int j = 0; j < n; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t{\n\t\t\t\tif(dp[i][j][k]!=1e6)\n\t\t\t\t{\n\t\t\t\t\tans = max(ans,i);\n\t\t\t\t\tfor (int l = 0; l < n; ++l)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(moveok[j][k][l])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[i+1][k][l]=min(dp[i+1][k][l],dp[i][j][k]+distance[k][l]);\n\t\t\t\t\t\t\tif(dp[i+1][k][l]>r+0.0001) dp[i+1][k][l]=1e6;\n\t\t\t\t\t\t\t//if(dp[i+1][k][l]>0) ans=max(ans,i+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct point{\n  double x,y;\n};\n\ndouble INF = 1e9;\ndouble PI = acos(-1);\ndouble EPS = (1e-10);\ndouble dp[10001][20][20];\nint n;\ndouble Ti;\ndouble r,ti;\npoint t[20];\n\n\nvoid solve(int i,int j,int k){\n  for(int to=0;to<n;to++){\n    if(to==j||to==k)continue;\n    double vax=t[to].x-t[j].x;\n    double vay=t[to].y-t[j].y;\n    double vbx=t[j].x-t[k].x;\n    double vby=t[j].y-t[k].y;\n    double ar=(vax*vbx+vay*vby)/(sqrt(vax*vax+vay*vay)*sqrt(vbx*vbx+vby*vby));\n    ar=acos(ar);\n    if(ar<ti+EPS){\n      dp[i+1][to][j]=min(dp[i+1][to][j],dp[i][j][k]+sqrt(vax*vax+vay*vay));\n    }\n  }\n}\n\nint main(){\n\n  for(int i=0;i<10001;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<20;k++)\n\tdp[i][j][k]=INF;\n  \n  cin>>n>>r>>Ti;\n  ti=Ti/360.0*2.0*PI;\n\n  for(int i=0;i<n;i++)\n    cin>>t[i].x>>t[i].y;\n  \n  for(int i=1;i<n;i++){\n    double x=t[i].x-t[0].x;\n    double y=t[i].y-t[0].y;\n    dp[1][i][0]=sqrt(x*x+y*y);\n  }\n\n  int ans=0;\n  for(int i=1;i<=10000;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(dp[i][j][k]>r+EPS)continue;\n\tans=max(ans,i);\n\tsolve(i,j,k);\n      }\n    }\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\n#define pow2(a) (pow(1.*a,2))\ntypedef struct D\n{\n\tint c,pp,np;\n\tdouble d;\n\tbool operator <(const D &a)const{ return d>a.d;};\n}D;\n\nint N,X[25],Y[25],res=0;\ndouble R,O,d[25][25],F[30][1000000];\ndouble ang(int pre,int now,int next)\n{\n\tdouble a=d[pre][now],b=d[now][next],c=d[pre][next];\n\tdouble dd=acos((pow2(a)+pow2(b)-pow2(c))/(2*a*b));\n\tdouble df=180-(dd*180/3.141592);\n\treturn df;\n}\n\nint main()\n{\n\tscanf(\"%d%lf%lf\",&N,&R,&O);\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",X+i,Y+i);\n\tfor(int i=0;i<N;i++)\n\n\t\tfor(int j=0;j<N;j++)\n\t\t\td[i][j]=sqrt(pow2(X[i]-X[j])+pow2(Y[i]-Y[j]));\n\tpriority_queue<D>Q;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tif(d[0][i]>R)continue;\n\t\tD tmp={1,0,i,d[0][i]};\n\t\tF[i][1]=d[0][i];\n\t\tQ.push(tmp);\n\t}\n\tfor(;!Q.empty();)\n\t{\n\t\tD tmp=Q.top();Q.pop();\n\t\tres=max(res,tmp.c);\n\t\tif(F[tmp.np][tmp.c]<tmp.d)continue;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(i==tmp.np)continue;\n\t\t\tif(ang(tmp.pp,tmp.np,i)<=O&&tmp.d+d[tmp.np][i]<=R)\n\t\t\t{\n\t\t\t\tD ins={tmp.c+1,tmp.np,i,tmp.d+d[tmp.np][i]};\n\t\t\t\tF[ins.np][ins.c]=tmp.d;\n\t\t\t\tQ.push(ins);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nconst double PI = 3.1415926535;\nint main(){\n  int n,i,j,k,ans=0;cin>>n;\n  double r,arc;cin>>r>>arc;\n  arc=PI/180.0*arc;\n  Polygon g;g.resize(n);\n  for(i=0;i<n;i++) cin>>g[i].x>>g[i].y;\n  double e[n][n][n],inf=1<<28;\n  fill(e[0][0],e[0][0]+n*n*n,inf);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      for(k=0;k<n;k++){\n\tif(i==j||j==k||k==i) continue;\n\tVector a=g[j]-g[i],b=g[k]-g[j];\n\tif(fabs(acos(dot(a,b)/(abs(a)*abs(b))))<=arc)\n\t  e[i][j][k]=abs(g[k]-g[j]);\n      }\n    }\n  }\n  for(k=1;k<n;k++) e[0][0][k]=abs(g[k]-g[0]);\n  map<int,double> dp[n][n];\n  typedef pair<int,int> P;\n  typedef pair<int,P> PP;\n  typedef pair<double,PP> PPP;\n  priority_queue<PPP,vector<PPP>,greater<PPP> > q;\n  q.push(PPP(0.0,PP(0,P(0,n))));\n  while(!q.empty()){\n    PPP ppp=q.top();q.pop();\n    double d=ppp.first,z;\n    PP pp=ppp.second;\n    k=pp.first;\n    P p=pp.second;\n    if(d>r) continue;\n    ans=max(ans,k);\n    if(p.second==n){\n      for(i=0;i<n;i++){\n\tz=inf;\n\tfor(j=0;j<n;j++) z=min(z,e[j][0][i]);\n\tq.push(PPP(d+z,PP(k+1,P(i,p.first))));\n      }\n    }else{\n      if(dp[p.first][p.second].find(k)!=dp[p.first][p.second].end())\n\tif(dp[p.first][p.second][k]<=d) continue;\t\n      dp[p.first][p.second][k]=d;\n      for(i=0;i<n;i++)\n\tq.push(PPP(d+e[p.second][p.first][i],PP(k+1,P(i,p.first))));\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\n// distance between (x1,y1) and (x2,y2)\ndouble cdis(double x1, double y1, double x2, double y2) {\n  return sqrtl((x1 - x2) * (x1 - x2) +\n               (y1 - y2) * (y1 - y2));\n}\n// cos a\ndouble costh(double a, double b, double c) {\n  return (b * b + c * c - a * a) / (2.0 * b * c);\n}\ndouble r, t;\nint n;\npair<double, double> c[25];\ndouble dis[25][25] = {0};\n// possible? i -> j -> k\nbool ch[25][25][25] = {0};\ndouble dp[25][25][10000] = {0};\n\nint solve();\n\nint main() {\n  cin >> n >> r >> t;\n  for(int i = 0; i < n; ++i) {\n    double x, y;\n    cin >> x >> y;\n    c[i] = make_pair(x, y);\n  }\n  for(int i = 0; i < n; ++i)\n    for(int j = i + 1; j < n; ++j)\n      dis[i][j] = dis[j][i] =\n          cdis(c[i].fi, c[i].se, c[j].fi, c[j].se);\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j)\n      for(int k = 0; k < n; ++k) {\n        if(i == j || j == k) continue;\n        double a = dis[i][k], b = dis[i][j], c = dis[j][k];\n        if(180.0 - acos(costh(a, b, c)) * 180 / M_PI <= t)\n          ch[i][j][k] = 1;\n      }\n\n  cout << solve() << endl;\n  return 0;\n}\n\nint solve() {\n  int ans = 0;\n  for(int i = 1; i < n; ++i)\n    if(dis[0][i] <= r) {\n      dp[0][i][1] = dis[0][i];\n      ans = 1;\n    }\n  if(ans == 0) return ans;\n  for(int k = 2; k <= 10000; ++k) {\n    // i -> j -> l\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < n; ++j)\n        for(int l = 0; l < n; ++l) {\n          if(i == j || j == l || (!ch[i][j][l]) ||\n             dp[i][j][k - 1] == 0 ||\n             dp[i][j][k - 1] + dis[j][l] > r)\n            continue;\n          if(dp[j][l][k] == 0) {\n            ans = k;\n            dp[j][l][k] = dp[i][j][k - 1] + dis[j][l];\n          }\n          else\n            dp[j][l][k] = min(dp[j][l][k],\n                              dp[i][j][k - 1] + dis[j][l]);\n        }\n    if(ans != k) break;\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> dst = cities[city];\n\n  src -= cities[prev];\n  dst -= cities[prev];\n  double computed_arg = abs(arg(src) - arg(dst));\n\n  return (limit_rad >= M_PI - min(computed_arg,\n\t\t\t\t  abs(2.0*M_PI - computed_arg)) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\nbool isok[21][21][21]; //cur,prev,old\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    memset(isok,true,sizeof(isok));\n    for(int old = 0; old < total_cities; old++){\n      for(int prev = 0; prev < total_cities; prev++){\n\tfor(int cur = 0; cur < total_cities; cur++){\n\t  isok[cur][prev][old] = check(cur,prev,old,limit_rad,cities);\n\t}\n      }\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      double dist;\n      int next_city,next_prev,next_old;\n      for(int to=0;to<total_cities;to++){\n\tif(to == s.city) continue;\n\tdist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tnext_city = to;\n\tnext_prev = s.city;\n\tnext_old = s.prev;\n\tif(!isok[next_city][next_prev][next_old]) continue;\n\tif(dp[s.carrots+1][s.city][to] >= s.remaining_distance - dist - EPS) continue;\n\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n \ntypedef complex<double> P;\n \nstruct S{\n  int w,p,n;\n  double d;\n  bool operator<(S s)const{\n    return d>s.d;\n  }\n};\n \ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n \nint main(){\n  int n;\n  double r,th;\n  cin>>n>>r>>th;\n  P p[21];\n  for(int i=1;i<=n;i++){\n    int x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  double t[21][21][21];\n  fill(t[0][0],t[21][0],-1);\n  for(int i=0;i<=n;i++){\n    for(int j=1;j<=n;j++){\n      for(int k=1;k<=n;k++){\n\tauto f=p[j]-p[i];\n\tauto to=p[k]-p[j];\n\tif(j!=k&&(i==0||acos(min(1.,max(-1.,dot(f,to)/abs(f)/abs(to))))*90<=th*acos(0))){\n\t  t[i][j][k]=abs(to);\n\t}\n      }\n    }\n  }\n  priority_queue<S> que;\n  que.push({1,0,0,0});\n  static bool mem[21][21][22222];\n  int m=0;\n  while(!que.empty()){\n    auto cs=que.top();\n    if(cs.d>r)break;\n    que.pop();\n    if(mem[cs.w][cs.p][cs.n]++)continue;\n    m=max(m,cs.n);\n    for(int i=1;i<=n;i++){\n      auto v=t[cs.p][cs.w][i];\n      if(v<0)continue;\n      que.push({i,cs.w,cs.n+1,cs.d+v});\n    }\n  }\n  cout<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> dst = cities[city];\n\n  src -= cities[prev];\n  dst -= cities[prev];\n  double computed_arg = abs(arg(src) - arg(dst));\n\n  return (limit_rad >= M_PI - min(computed_arg,\n\t\t\t\t  abs(2.0*M_PI - computed_arg)) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\nbool isok[21][21][21]; //cur,prev,old\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    memset(isok,true,sizeof(isok));\n    for(int old = 0; old < total_cities; old++){\n      for(int prev = 0; prev < total_cities; prev++){\n\tfor(int cur = 0; cur < total_cities; cur++){\n\t  isok[cur][prev][old] = check(cur,prev,old,limit_rad,cities);\n\t}\n      }\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      double dist;\n      int next_city,next_prev,next_old;\n      for(int to=0;to<total_cities;to++){\n\tif(to == s.city) continue;\n\tdist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tnext_city = to;\n\tnext_prev = s.city;\n\tnext_old = s.prev;\n\tif(!isok[next_city][next_prev][next_old]) continue;\n\tif(dp[s.carrots+1][s.city][to] >= s.remaining_distance - dist - EPS) continue;\n\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (lt(a, b) || equals(a, b))\n#define PI acos(-1)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\ndouble getAngle(Point a, Point b, Point c)\n{\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / PI;\n  return min(theta, 360 - theta);\n}\n\nint n;\ndouble r, t;\nvector<Point> ps;\n\ndouble d[21][21][10001];\n\nstruct State\n{\n  int now, prev, car;\n  double dist;\n  State(){}\n  State(int now, int prev, int car, double dist):now(now), prev(prev), car(car), dist(dist){}\n  bool operator < (const State& r) const {\n    return dist > r.dist;\n  }\n};\n\nint solve()\n{\n  rep(i, 21) rep(j, 21) rep(k, 10001) d[i][j][k] = 1e10;\n\n  priority_queue<State> que;\n  reps(i, 1, n) {\n    double dist = getDistance(ps[0], ps[i]);\n    if(le(dist, r)) {\n      d[i][0][1] = dist;\n      que.push(State(i, 0, 1, dist));\n    }\n  }\n\n  int ans = 0;\n  while(!que.empty()) {\n    State st = que.top(); que.pop();\n    int now = st.now, prev = st.prev, car = st.car;\n    double dist = st.dist;\n    ans = max(ans, car);\n    if(dist > d[now][prev][car]) continue;\n    rep(i, n) if(i != now) {\n      int di = dist + getDistance(ps[now], ps[i]);\n      if(le(getAngle(ps[prev], ps[now], ps[i]), t) && le(di, r) && d[i][now][car+1] > di) {\n\td[i][now][car+1] = di;\n\tque.push(State(i, now, car+1, di));\n      }\n    }\n  }\n\n  return ans;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> n >> r >> t;\n  ps.resize(n);\n  rep(i, n) cin >> ps[i].x >> ps[i].y;\n\n  cout << solve() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define range(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing State = tuple<double, int, int, int>;\n\nint n;\ndouble R, theta;\n\nvector<vector<double>> dist, angle;\nvector<vvi> min_dist;\n\nconst double pi = acos(-1);\n\nint main(void){\n    cin >> n;\n    cin >> R >> theta;\n    theta *= pi / 180.0;\n\n    vector<int> x(n), y(n);\n    rep(i, n) cin >> x[i] >> y[i];\n\n    dist = angle = vector<vector<double>>(n, vector<double>(n));\n    rep(i, n){\n        rep(j, n){\n            if(i == j) continue;\n\n            int dx = x[j] - x[i], dy = y[j] - y[i];\n            dist[i][j]  = sqrt(pow(dx, 2) + pow(dy, 2));\n            angle[i][j] = atan2(dy, dx);\n        }\n    }\n\n    vector<vvi> edge(n + 1, vvi(n + 1));\n    rep(i, n){\n        rep(j, n){\n            if(i == j) continue;\n            rep(k, n){\n                if(j == k) continue;\n\n                double dtheta = angle[j][k] - angle[i][j];\n                while(dtheta < 0)      dtheta += 2 * pi;\n                while(dtheta >= pi) dtheta -= 2 * pi;\n\n                if(fabs(dtheta) <= theta){\n                    edge[i][j].push_back(k);\n                }\n            }\n        }\n    }\n    range(i, 1, n) edge[n][0].push_back(i);\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(0.0, n, 0, 0));\n\n    const int inf = R + 1234;\n    min_dist = vector<vvi>(n + 1, vvi(n + 1, vi(10001, inf)));\n\n    int res = 0;\n    while(q.size()){\n        double d;\n        int prev, v, num;\n        tie(d, prev, v, num) = q.top();\n        q.pop();\n\n        if(d > R or min_dist[prev][v][num] != inf) continue;\n        min_dist[prev][v][num] = d;\n        res = max(res, num);\n\n        for(auto & nv : edge[prev][v]){\n            if(min_dist[v][nv][num + 1] != inf) continue;\n            q.push(State(d + dist[v][nv], v, nv, num + 1));\n        }\n    }\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef  long double ll;\ntypedef pair<ll,ll> mp;\ntypedef pair<ll,bool> mlb;\n#define inf 1e9\nstruct point{\n    double x,y;\n    point(double x, double y): x(x),y(y){};\n    point() {};\n    point operator - (point &p){ return point(x-p.x,y-p.y); }\n    void make(){cin>>x>>y; }\n    double norm(){ return x*x+y*y; }\n    double abs() { return sqrt( norm() ); }\n    double arg(){//原点からの角度\n        //comp c(x.y);\n        //return c.arg();\n        return atan2(y,x);\n    }   \n    double arg2(){\n        point tmp = point(-1,0);\n        double pi = tmp.arg();\n        return arg()/ pi * 180.0; \n    }\n    void print(){ cout<<x<<' '<<y<<endl; }\n};\n \nint main(){\n    point tmp = point(-1,0);\n    double pi = tmp.arg();\n    int n;\n    cin>>n;\n    double r,theta;\n    cin>>r>>theta;\n    vector<point> p(n);\n    for(int i=0;i<n;i++)p[i].make();\n    vector<vector<vector<mlb> > > g(n,vector<vector<mlb> >(n,vector<mlb> (n,mlb(inf,false) ) ) );\n    for(int i=0;i<n;i++)//prev\n        for(int j=0;j<n;j++)//now\n            for(int k=0;k<n;k++){//next\n                if(i==j||j==k||k==i)continue;\n                point d1 = p[j]-p[i];\n                point d2 = p[k]-p[j];\n                point dire = point( d1.x*d2.x + d1.y*d2.y , d1.y*d2.x - d1.x*d2.y );\n                if( abs( dire.arg() ) <= theta/180.0*pi   ){\n                    g[i][j][k] = mlb(d2.abs(),true);\n                }\n            }\n    int M = 1e4+2;\n    //vector<vector<vector<double> > > dp(n,vector<vector<double> >(n,vector<double>(M,-1) ) );\n    vector<vector<double> > dp(n,vector<double>(n,-1) );\n    int ans = 0;\n    for(int i=1;i<n;i++){\n        dp[0][i] = r - (p[i]-p[0]).abs();\n        if(dp[0][i] >= 0) ans = 1;\n    }\nif(ans == 1)\n    for(int i=1;i<M-1;i++){\n        vector<vector<double> > ndp(n,vector<double>(n,-1) );\n        for(int j = 0;j<n;j++){\n            for(int k = 0;k<n;k++){\n                if(dp[j][k] > 0){\n                    for(int l=0;l<n;l++){\n                        if(g[j][k][l].second){\n                            double next = dp[j][k] - g[j][k][l].first;\n                            if(next>=0){\n                                ans = i+1;\n                                ndp[k][l] = max(ndp[k][l],next );\n                                //cout<<i+1<<' '<<j<<' '<<k<<' '<<l<<' '<<next<<endl;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        dp = ndp;\n        if(ans == i) break;\n    }\n    cout<<ans<<endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF (long long)(1e18)\n#define MOD (int)(1e9+7)\n\n#define EPS 1e-8\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX 24\n\nstring hogehogehoge;\n\nint n, x[MAX], y[MAX], used[MAX][MAX], hh[MAX][MAX];\ndouble r, t;\ndouble tete[MAX][MAX];\n\ndouble angle(double x1, double y1,double x2, double y2){//cout<<\"(\"<<x1<<\",\"<<y1<<\") (\"<<x2<<\",\"<<y2<<\")\";\n\tif(x1 >= INF-1){\n\t\t//cout<<\"-> \"<<0<<endl;\n\t\treturn 0;\n\t}\n\tdouble inner_product = x1*x2+y1*y2, ab1 = sqrt(x1*x1+y1*y1), ab2 = sqrt(x2*x2+y2*y2);\n\t//cout<<\"- > \"<<acos(inner_product/(ab1*ab2))<<endl;\n\treturn fabs(acos(inner_product/(ab1*ab2)));\n}\n\n\nint solve(int b,int g, double R, double xx, double yy, int p){//cout<<g<<\" \"<<R<<endl;\n\t// cin>>hogehogehoge;\n\tint ans = 0, re = 1;\n\t\n\tif(b != INF){\n\t\tif(used[b][g] == 0) tete[b][g] = R,hh[b][g] = p, used[b][g]++;\n\t\telse if(used[b][g] == 1) tete[b][g] = R-tete[b][g],hh[b][g] = p-tete[b][g],used[b][g]++;\n\t\telse{\n\t\t\tre +=  ((int)R/(int)tete[b][g])*hh[b][g];\n\t\t\tR -= ((int)R/(int)tete[b][g])*tete[b][g];\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tif(i==g) continue;\n\t\tif(angle(xx,yy,x[i]-x[g],y[i]-y[g]) <= t && (x[i]-x[g])*(x[i]-x[g]) + (y[i]-y[g])*(y[i]-y[g])<= R*R){\n\t\t\tans = max(ans,solve(g,i,R-sqrt((x[i]-x[g])*(x[i]-x[g]) + (y[i]-y[g])*(y[i]-y[g])),x[i]-x[g],y[i]-y[g],p+1));\n\t\t}\n\t}\n\treturn ans+re;\n}\n\nint hoge(){\n\t// for(int i = 0; i < n; i++){\n\t\t// for(int j = 0; j < n; j++){\n\t\t\t// tete[i][j] = 1;\n\t\t// }\n\t// }\n\t\n\treturn solve(INF,0,r,INF,0,0)-1;\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(7);\n\t\n\t\n\tcin>>n>>r>>t;\n\t\n\t\n\tt = (t/360)*(2*acos(-1));\n\t\n\trep(i,n){\n\t\tcin>>x[i]>>y[i];\n\t}\n\t\n\t// cout<<solve(0,r,INF,0)-1<<endl;\n\tcout<<hoge()<<endl;\n\t\n\t// cout<<\"t = \"<<t<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex < double > P;\ntypedef vector < P > Ps;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\n\nint main(){\n  int n;\n  double r, kaku;\n  double dis[20][20];\n  static double dp[20][20][10001];\n  bool gocan[20][20][20];\n\n  fill_n( **dp, 20 * 20 * 10001, INF);\n\n  cin >> n >> r >> kaku;\n  Ps pts(n);\n  for(int i = 0 ; i < n ; i++ ){\n    cin >> pts[i].real() >> pts[i].imag();\n  }\n\n  double rad = kaku * M_PI / 180.0;\n\n  for(int i = 0 ; i < n ; i++ ){\n    for(int j = 0 ; j < n ; j++ ){\n      if(i == j) continue;\n      for(int k = 0 ; k < n ; k++ ){\n        if( i == k || j == k) continue;\n        const P s1 = pts[j] - pts[i], s2 = pts[k] - pts[j];\n        gocan[i][j][k] = abs(arg( s2 / s1)) < rad + EPS;\n      }\n    }\n  }\n\n  for(int i = 0 ; i < n ; i++ ){\n    for(int j = i + 1 ; j < n ; j++ ){\n      dis[i][j] = dis[j][i] = abs( pts[i] - pts[j]);\n    }\n  }\n\n  for(int i = 1 ; i < n ; i++ ){\n    dp[0][i][1] = dis[0][i];\n  }\n\n  int ret = 0;\n  for(int i = 1 ; i <= 10000 ; i++ ){ //にんじん\n    for(int j = 0 ; j < n ; j++ ){ //前\n      for(int k = 0 ; k < n ; k++ ){ //今\n        if(j == k || dp[j][k][i] > r + EPS) continue;  //j → kの距離が(ry\n        for(int l = 0 ; l < n ; l++ ){ //次\n          if( j == l || k == l) continue;\n          if( gocan[j][k][l]){ //いけたら\n            dp[k][l][i + 1] = min( dp[k][l][i + 1], dp[j][k][i] + dis[k][l]);\n          }\n        }\n        ret = max( ret, i);\n      }\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 20;\nconst double PI = acos(-1.0);\nconst double DINF = 1e20;\n\n/* typedef */\n\n/* global variables */\n\nint n;\ndouble r , th;\ndouble xs[MAX_N], ys[MAX_N], mat[MAX_N][MAX_N], dists[2][MAX_N][MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  cin >> n;\n  cin >> r >> th;\n\n  double cth = cos(th * PI / 180);\n  \n  for (int i = 0; i < n; i++) cin >> xs[i] >> ys[i];\n\n  for (int i = 0; i < n; i++) {\n    mat[i][i] = DINF;\n    for (int j = i + 1; j < n; j++) {\n      double dx = xs[j] - xs[i], dy = ys[j] - ys[i];\n      mat[i][j] = mat[j][i] = sqrt(dx * dx + dy * dy);\n    }\n  }\n\n  int cur = 0, nxt = 1;\n  bool ok = false;\n\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++) dists[cur][i][j] = DINF;\n  \n  for (int i = 1; i < n; i++)\n    if (mat[0][i] <= r) dists[cur][0][i] = mat[0][i], ok = true;\n\n  if (! ok) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  int k = 1;\n\n  for (;;) {\n    ok = false;\n    \n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < n; j++) dists[nxt][i][j] = DINF;\n    \n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < n; j++) {\n\tif (dists[cur][i][j] >= DINF) continue;\n\tdouble vx0 = xs[j] - xs[i], vy0 = ys[j] - ys[i];\n\tdouble d0 = mat[i][j];\n\tfor (int k = 0; k < n; k++) {\n\t  if (j == k) continue;\n\t  double vx1 = xs[k] - xs[j], vy1 = ys[k] - ys[j];\n\t  double d1 = mat[j][k];\n\t  double c = (vx0 * vx1 + vy0 * vy1) / (d0 * d1);\n\t  if (c >= cth) {\n\t    double nd = dists[cur][i][j] + d1;\n\t    if (nd <= r && dists[nxt][j][k] > nd)\n\t      dists[nxt][j][k] = nd, ok = true;\n\t  }\n\t}\n      }\n\n    if (ok) k++;\n    else break;\n\n    cur ^= 1;\n    nxt ^= 1;\n  }\n\n  cout << k << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\n\nint main(){\n  int n;\n  double r, theta;\n  cin >> n >> r >> theta;\n  theta *= acos(-1)/180;\n  vector<int> X(n), Y(n);\n  for(int i = 0; i < n; ++i) cin >> X[i] >> Y[i];\n  vector< vector<double> > dp(n,vector<double>(n,0));\n  bool f = false;\n  int ans = 0;\n  vector< pair<int,int> > V;\n  for(int i = 1; i < n; ++i){\n    int x1 = X[i] - X[0], y1 = Y[i] - Y[0];\n    if(hypot(x1,y1) <= r + EPS){\n      f = true;\n      dp[0][i] = r - hypot(x1,y1);\n      V.push_back(make_pair(0,i));\n    }\n  }\n  while(f){\n    f = false;\n    ++ans;\n    vector< vector<double> > dp_(n,vector<double>(n,0));\n    vector< pair<int,int> > V_;\n    for(int l = 0; l < V.size(); ++l){\n      int i = V[l].first, j = V[l].second;\n      for(int k = 0; k < n; ++k){\n        if(j == k) continue;\n        int x1 = X[j] - X[i], y1 = Y[j] - Y[i], x2 = X[k] - X[j], y2 = Y[k] - Y[j];\n        if(acos((x1*x2+y1*y2)/hypot(x1,y1)/hypot(x2,y2)) <= theta + EPS&& \n           hypot(x2,y2) <= dp[i][j] + EPS){\n          f = true;\n          dp_[j][k] = max(dp_[j][k],dp[i][j] - hypot(x2,y2));\n          V_.push_back(make_pair(j,k));\n        }\n      }\n    }\n    dp = dp_;\n    V = V_;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\ndouble d[20][20], a[20][20][20], dp[10000][20][20];\n\nint main() {\n\tint n; double r, th;\n\tcin >> n >> r >> th;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\td[i][j] = hypot(x[i] - x[j], y[i] - y[j]);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (i == j || j == k) continue;\n\t\t\t\tint x1 = x[i] - x[j], y1 = y[i] - y[j];\n\t\t\t\tint x2 = x[j] - x[k], y2 = y[j] - y[k];\n\t\t\t\tdouble c = (x1 * x2 + y1 * y2) / d[i][j] / d[j][k];\n\t\t\t\ta[i][j][k] = (c > cos(th / 180 * M_PI));\n\t\t\t}\n\tfill(dp[0][0], dp[0][0] + 10000 * 20 * 20, FLT_MAX);\n\tfor (int i = 0; i < n; i++)\n\t\tdp[1][i][0] = d[0][i];\n\tfor (int l = 2; l < 10000; l++)\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\tif (i != j && j != k && a[i][j][k])\n\t\t\t\t\t\tdp[l][i][j] = min(dp[l][i][j], dp[l - 1][j][k] + d[k][j]);\n\tint maxi = 0;\n\tfor (int l = 1; l < 10000; l++)\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (dp[l][i][j] < r) maxi = l;\n\tcout << maxi << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double inf=1e8;\n#define rep(i,a) for(int i=0;i<a;i++)\ndouble dp[20][20][10010];\nint main(){\n  rep(i,20)rep(j,20)rep(k,10010)dp[i][j][k]=inf;\n  int n;\n  double x,y;\n  cin>>n>>x>>y;\n  y*=PI/180;\n  G g(n);\n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    g[i]=P(a,b);\n  }\n  double D[20][20]={0};\n  double A[20][20]={0};\n  rep(i,n)rep(j,n)A[i][j]=arg(g[i]-g[j]);\n  rep(i,n)rep(j,n)D[i][j]=abs(g[i]-g[j]);\n  dp[0][0][0]=0;\n  rep(i,10010)rep(j,n)rep(k,n)if(i==0||j!=k){\n    rep(l,n)if(l!=k){\n      double dis=D[l][k];//abs(g[k]-g[l]);\n      //if(i==0)printf(\"%.9f %.9f\\n\",x,dis+dp[j][k][l]);\n      if(dis+dp[j][k][i]>x)continue;\n      double q=A[k][j]-A[l][k];// arg(g[k]-g[j])-arg(g[l]-g[k]);\n      if(q<0)q*=-1;\n      while(q>PI)q=2*PI-q;//q-=PI;\n      if(i==0){\n    q=0;//abs(arg(g[l]-g[k]));\n      }\n      if(q>y)continue;\n      dp[k][l][i+1]=min(dp[k][l][i+1],dp[j][k][i]+dis);\n    }\n  }\n  int out=0;\n  rep(i,n)rep(j,n)rep(k,10010)if(abs(dp[i][j][k]-inf)>EPS)out=max(out,k);\n  cout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  R r, th; cin >> r >> th, th *= pi / 180;\n  V<P> p(n); for (auto&& e : p) cin >> e;\n  VV< V<> > ks(20, VV<>(20));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    for (int k = 0; k < n; ++k) if (k != j) {\n      L s{p[i], p[j]}, t{p[j], p[k]};\n      R ph = fmod(3 * pi + t.arg() - s.arg(), 2 * pi) - pi;\n      if (sgn(abs(ph), th) <= 0) ks[i][j].push_back(k);\n    }\n  }\n  VV<R> dp(20, V<R>(20, 1e10));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    dp[i][j] = distPP(p[i], p[j]);\n  }\n  int res = 0;\n  for (int s = 0; s <= 1e4; ++s) {\n    VV<R> ndp(20, V<R>(20, 1e10));\n    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n      if (!i and sgn(dp[i][j], r) <= 0) res = s + 1;\n      for (int k : ks[i][j]) {\n        ndp[i][j] = min(ndp[i][j], distPP(p[i], p[j]) + dp[j][k]);\n      }\n    }\n    swap(dp, ndp);\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> mid = cities[prev];\n  complex<double> dst = cities[city];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[10001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,false,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      if(dp[s.carrots][s.prev][s.city]) continue;\n      dp[s.carrots][s.prev][s.city] = true;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist < 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\n\ninline double dist(int i,int j){\n\tint dx=(x[i]-x[j]);\n\tint dy=(y[i]-y[j]);\n\treturn sqrt(1.0*dx*dx+1.0*dy*dy);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tdouble r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tdp[0][0][n]=0.0;\n\n\trep(i,limit)rep(cp,n)rep(pp,n+1){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(i>0&&pp==n) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tdouble add=dist(cp,np);\n\t\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\t\tdouble dot=1.0*cx*nx+1.0*cy*ny;\n\t\t\tdot/=(dist(cp,pp)*dist(np,cp));\n\t\t\tdouble angle=acos(dot);\n\t\t\tangle*=180.0/pi;\n\n\t\t\tif(angle>180.0) angle=360.0-angle;\n\t\t\tif(pp!=n&&angle>theta) continue;\n\t\t\tif(dp[i][cp][pp]+add>r) continue;\n\t\t\tdp[i+1][np][cp]=min(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,limit+1)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]<=r) ans=max(ans,i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2233&lang=jp\ntypedef long long ll;\ntypedef long double ld;\n#define INF 1<<30\n#define LINF 1<<60\nconst double eps = 1e-9;\n\ninline double calc_w(int c1,int pre_c1, int c2,int pre_c2, vector<pair<int, int>>& city) {\n\tdouble l1_x = city[c1].first - city[pre_c1].first;\n\tdouble l1_y = city[c1].second - city[pre_c1].second;\n\n\tdouble l2_x = city[c2].first - city[pre_c2].first;\n\tdouble l2_y = city[c2].second - city[pre_c2].second;\n\n\tdouble _cos = (l1_x*l2_x + l1_y*l2_y) / (double)(hypot(l1_x, l1_y)*hypot(l2_x, l2_y));\n\tif (1 - _cos < eps)return 0.0;\n\tif (1 + _cos < eps)return 180.0;\n\treturn abs(acos(_cos) * 180 / acos(-1));\n}\n\nstruct edge {\n\tint now_city;\n\tint pre_city;\n\tint have_carrot;\n\tdouble full_len;\n\tedge() {}\n\tedge(int now, int pre,int car, double len) :now_city(now), pre_city(pre),have_carrot(car),full_len(len) {}\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t/* input */\n\tint n; cin >> n;\n\tdouble r, theta; cin >> r >> theta;\n\tvector<pair<int, int>> city(n);\n\tfor (int i = 0; i < n;i++) { int x, y; cin >> x >> y; city[i] = { x,y }; }\n\n\t/* initialize */\n\tvector<vector<double>> dist(n, vector<double>(n,0));\n\tvector<vector<vector<int>>> G(n, vector<vector<int>>(n));\n\tvector<vector<vector<double>>> dp(n, vector<vector<double>>(n, vector<double>(10010, 0)));\n\n\tqueue<edge> q;\n\tfor (int i = 0; i < n;i++) {\n\t\tfor (int j = i + 1; j < n;j++) {\n\t\t\tdouble d = hypot(city[i].first - city[j].first, city[i].second - city[j].second);\n\t\t\tdist[i][j] = dist[j][i] = d;\n\t\t\tif ((i == 0) && (d <= r)) {\n\t\t\t\tdp[j][i][1] = d;\n\t\t\t\tq.push(edge(j, i, 1, d));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n;i++) {\n\t\tfor (int j = 0; j < n;j++) {\n\t\t\tfor (int k = 0; k < n;k++) {\n\t\t\t\tif (i == j || j == k || i == k)continue;\n\t\t\t\tif (calc_w(j, i, k, j, city) < theta + eps) G[j][i].push_back(k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\twhile (!q.empty()) {\n\t\tauto p = q.front(); q.pop();\n\t\tint now_city = p.now_city, pre_city = p.pre_city;\n\t\tint have_carrot = p.have_carrot;\n\t\tdouble len = p.full_len;\n\t\tif (len > dp[now_city][pre_city][have_carrot]) continue;\n\t\tfor (int next_city : G[now_city][pre_city]) {\n\t\t\tif (next_city == now_city || next_city == pre_city)continue;\n\t\t\tif (dist[now_city][next_city] + len < r + eps) {\n\t\t\t\tif (dp[next_city][now_city][have_carrot + 1] < len + dist[next_city][now_city]) {\n\t\t\t\t\tdp[next_city][now_city][have_carrot + 1] = len + dist[next_city][now_city];\n\t\t\t\t\tq.push(edge(next_city, now_city, have_carrot + 1, dist[next_city][now_city] + len));\n\t\t\t\t\tans = max(ans, have_carrot + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n#include <complex>\nusing Point =  complex< double >;\nconstexpr double EPS = 1e-8;\nconstexpr double PI = acos( -1 );\nconstexpr Point O( 0, 0 );\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator>> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\ndouble dp[ 16384 ][ 32 ][ 32 ];\ndouble dists[ 32 ][ 32 ];\nbool movable[ 32 ][ 32 ][ 32 ];\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tint N;\n\tcin >> N;\n\n\tdouble R, THETA;\n\tcin >> R >> THETA;\n\n\tTHETA = THETA / 360 * 2 * PI;\n\n\tVT( Point ) ps( N );\n\tcin >> ps;\n\n\tREP( i, N )\n\t{\n\t\tREP( j, i )\n\t\t{\n\t\t\tdists[i][j] = dists[j][i] = abs( ps[i] - ps[j] );\n\t\t}\n\t}\n\tREP( i, N )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tif ( i == j || i == k || j == k )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmovable[i][j][k] = abs( arg( ( ps[k] - ps[j] ) / ( ps[j] - ps[i] ) ) ) <= THETA + EPS;\n\t\t\t}\n\t\t}\n\t}\n\n\tfill( AALL( dp, double ), R * 2 );\n\tdp[0][0][0] = 0;\n\tREP( i, 10000 )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tREP( l, N )\n\t\t\t\t{\n\t\t\t\t\tif ( i && !movable[k][j][l] )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdp[ i + 1 ][l][j] = min( dp[ i + 1 ][l][j], dp[i][j][k] + dists[j][l] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = 0;\n\tREP( i, 10001 )\n\t{\n\t\tREP( j, N )\n\t\t{\n\t\t\tREP( k, N )\n\t\t\t{\n\t\t\t\tif ( dp[i][j][k] <= R + EPS )\n\t\t\t\t{\n\t\t\t\t\tres = max( res, i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define fs first\n#define sc second\n#define pb push_back\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<D,int> Edge;\ntypedef pair<Edge, pair<int,int> > state;\n\nconst D PI = acos(-1);\nconst D EPS = 1e-8;\n\ninline D dis(D x1, D y1, D x2, D y2){\n  return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\ninline D dot(P x, P y){ return real(conj(x)*y); }\n\ninline D base(P a,P b,P c){ return dot(b-a,c-b)/abs(b-a)/abs(c-b);}\ninline D arg(P a, P b, P c){ return acos(dot(b-a,c-b)/abs(b-a)/abs(c-b)); }\n\nint n;\nD r,s;\nP p[21];\nD d[21][21];\nvector<Edge> g[21][21];\nD lensum[21][21][10001];\n\nint main(){ \n  cin >> n >> r >> s;\n  s *= PI/180;\n  rep(i,n)cin >> p[i].real() >> p[i].imag();\n  rep(i,n){\n    d[i+1][i+1] = 0;\n    for(int j=i+1;j<n;j++){\n      d[i+1][j+1] = d[j+1][i+1] = abs(p[i]-p[j]);\n    }\n  }\n  \n  rep(i,n){\n    if(i)g[0][1].pb(Edge(d[1][i+1],i+1));\n  }\n\n  rep(i,n){\n    rep(j,n){\n      if(i==j)continue;\n      rep(k,n){\n\tif(j==k || i==k)continue;\n\tD seta = arg(p[i],p[j],p[k]);\n\tif(abs(base(p[i],p[j],p[k])-1.0)<EPS)seta = 0.0;\n\telse if(abs(base(p[i],p[j],p[k])+1.0)<EPS)seta = PI;\n\tif(seta < s + EPS){\n\t  g[i+1][j+1].pb(Edge(d[j+1][k+1],k+1));\n\t}\n      }\n    }\n  }\n\n  rep(i,n+1)rep(j,n+1)rep(k,10001)lensum[i][j][k] = 1e10;\n  lensum[0][1][0] = 0;\n  priority_queue<state,vector<state>,greater<state> > q;\n  q.push(mk(mk(0,0),mk(0,1)));\n\n  int ans = 0;\n  while(q.size()){\n    state tmp = q.top(); q.pop();\n    D len = tmp.fs.fs;\n    int carrot = tmp.fs.sc+1, prv = tmp.sc.fs, cur = tmp.sc.sc;\n\n    rep(i,g[prv][cur].size()){\n      D cost = g[prv][cur][i].fs;\n      int nxt = g[prv][cur][i].sc;\n      if(len + cost > r + EPS)continue;\n      if(lensum[cur][nxt][carrot] > len + cost + EPS){\n\tlensum[cur][nxt][carrot] = len + cost;\n\tq.push(mk(mk(len+cost,carrot),mk(cur,nxt)));\n\tans = max(ans,carrot);\n      }\n    }\n  }\t\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> dst = cities[city];\n\n  src -= cities[prev];\n  dst -= cities[prev];\n  double computed_arg = abs(arg(src) - arg(dst));\n\n  return (limit_rad >= M_PI - min(computed_arg,\n\t\t\t\t  abs(2.0*M_PI - computed_arg)) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\nbool isok[21][21][21]; //cur,prev,old\ndouble city_distance[21][21];\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    memset(isok,true,sizeof(isok));\n    for(int old = 0; old < total_cities; old++){\n      for(int prev = 0; prev < total_cities; prev++){\n\tfor(int cur = 0; cur < total_cities; cur++){\n\t  isok[cur][prev][old] = check(cur,prev,old,limit_rad,cities);\n\t  city_distance[cur][prev] = abs(cities[cur] - cities[prev]);\n\t}\n      }\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      double dist;\n      int next_city,next_prev,next_old;\n      for(int to=0;to<total_cities;to++){\n\tif(to == s.city) continue;\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tnext_city = to;\n\tnext_prev = s.city;\n\tnext_old = s.prev;\n\tif(!isok[next_city][next_prev][next_old]) continue;\n\tif(dp[s.carrots+1][s.city][to] >= s.remaining_distance - city_distance[next_city][next_prev] - EPS) continue;\n\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - city_distance[next_city][next_prev]));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double inf=1e8;\n#define rep(i,a) for(int i=0;i<a;i++)\ndouble dp[20][20][10010];\nint main(){\n  rep(i,20)rep(j,20)rep(k,10010)dp[i][j][k]=inf;\n  int n;\n  double x,y;\n  cin>>n>>x>>y;\n  y*=PI/180;\n  G g(n);\n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    g[i]=P(a,b);\n  }\n  double D[20][20]={0};\n  double A[20][20]={0};\n  rep(i,n)rep(j,n)A[i][j]=arg(g[i]-g[j]);\n  rep(i,n)rep(j,n)D[i][j]=abs(g[i]-g[j]);\n  dp[0][0][0]=0;\n  rep(i,10010)rep(j,n)rep(k,n)if(i==0||j!=k){\n    rep(l,n)if(l!=k){\n      double dis=D[l][k];//abs(g[k]-g[l]);\n      //if(i==0)printf(\"%.9f %.9f\\n\",x,dis+dp[j][k][l]);\n      if(dis+dp[j][k][i]>x)continue;\n      double q=A[k][j]-A[l][k];// arg(g[k]-g[j])-arg(g[l]-g[k]);\n      if(q<0)q*=-1;\n      while(q>PI)q=2*PI-q;//q-=PI;\n      if(i==0){\n\tq=0;//abs(arg(g[l]-g[k]));\n      }\n      if(q>y)continue;\n      dp[k][l][i+1]=min(dp[k][l][i+1],dp[j][k][i]+dis);\n    }\n  }\n  int out=0;\n  rep(i,n)rep(j,n)rep(k,10010)if(abs(dp[i][j][k]-inf)>EPS)out=max(out,k);\n  cout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\n/*他のライブラリを入れる場所*/\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n;\n\tdouble r,t;\n\tcin>>n>>r>>t;\n\tusing P=complex<double>;\n\tvector<P> p(n);\n\trep(i,n){\n\t\tint a,b; cin>>a>>b;\n\t\tp[i]=P(a,b);\n\t}\n\tint mx=10000;\n\tvector<vvd> dp(mx+1,vvd(n,vd(n,LINF)));\n\tvector<vvd> a(n,vvd(n,vd(n)));\n\trep(i,n)rep(j,n)rep(k,n)if(j!=k){\n\t\ta[i][j][k]=(i==j?0:abs(arg((p[j]-p[i])/(p[k]-p[j])))*180/PI);\n\t}\n\tdp[0][0][0]=0;\n\n\tll ans=0;\n\trep(i,mx)rep(j,n)rep(k,n)if(dp[i][j][k]!=LINF)rep(l,n)if(j!=l and k!=l){\n\t\tif(a[j][k][l]<=t+EPS){\n\t\t\tdouble dst=dp[i][j][k]+abs(p[k]-p[l]);\n\t\t\tif(dst<=r+EPS and chmin(dp[i+1][k][l],dst)){\n\t\t\t\tans=i+1;\n\t\t\t}\n\t\t}\n\t}\n\tputa(ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\n#define pow2(a) (pow(1.*a,2))\ntypedef struct D\n{\n\tint c,pp,np;\n\tdouble d;\n\tbool operator <(const D &a)const{ return d>a.d;};\n}D;\n\nmap<double,int>F;\n\nint N,X[25],Y[25],res=0;\ndouble R,O,d[25][25];\ndouble ang(int pre,int now,int next)\n{\n\tdouble a=d[pre][now],b=d[now][next],c=d[pre][next];\n\tdouble dd=acos((pow2(a)+pow2(b)-pow2(c))/(2*a*b));\n\tdouble df=180-(dd*180/3.141592);\n\treturn df;\n}\n\nint main()\n{\n\tscanf(\"%d%lf%lf\",&N,&R,&O);\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",X+i,Y+i);\n\tfor(int i=0;i<N;i++)\n\n\t\tfor(int j=0;j<N;j++)\n\t\t\td[i][j]=sqrt(pow2(X[i]-X[j])+pow2(Y[i]-Y[j]));\n\tpriority_queue<D>Q;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tif(d[0][i]>R)continue;\n\t\tD tmp={1,0,i,d[0][i]};\n\t\tF[d[0][i]]=1;\n\t\tQ.push(tmp);\n\t}\n\tfor(;!Q.empty();)\n\t{\n\t\tD tmp=Q.top();Q.pop();\n\t\tres=max(res,tmp.c);\n\t\tif(F[tmp.d]>tmp.c)continue;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(i==tmp.np)continue;\n\t\t\tif(ang(tmp.pp,tmp.np,i)<=O&&tmp.d+d[tmp.np][i]<=R)\n\t\t\t{\n\t\t\t\tD ins={tmp.c+1,tmp.np,i,tmp.d+d[tmp.np][i]};\n\t\t\t\tF[ins.d]=ins.c;\n\t\t\t\tQ.push(ins);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct point{\n  double x,y;\n};\n\ndouble INF = 1e9;\ndouble PI = acos(-1);\ndouble EPS = (1e-10);\ndouble dp[10001][20][20];\nint n;\ndouble r,ti;\npoint t[20];\n\n\nvoid solve(int i,int j,int k){\n  for(int to=0;to<n;to++){\n    double vax=t[to].x-t[j].x;\n    double vay=t[to].y-t[j].y;\n    double vbx=t[j].x-t[k].x;\n    double vby=t[j].y-t[k].y;\n    double ar=(vax*vbx+vay*vby)/(sqrt(vax*vax+vay*vay)*sqrt(vbx*vbx+vby*vby));\n    ar=acos(ar);\n    if(ar<=ti){\n      dp[i+1][to][j]=min(dp[i+1][to][j],dp[i][j][k]+sqrt(vax*vax+vay*vay));\n    }\n  }\n}\n\nint main(){\n\n  for(int i=0;i<10001;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<20;k++)\n\tdp[i][j][k]=INF;\n  \n  cin>>n>>r>>ti;\n  ti=ti/360.0*2.0*PI;\n\n  for(int i=0;i<n;i++)\n    cin>>t[i].x>>t[i].y;\n  \n  for(int i=1;i<n;i++){\n    double x=t[i].x-t[0].x;\n    double y=t[i].y-t[0].y;\n    dp[1][i][0]=sqrt(x*x+y*y);\n  }\n\n  int ans=-1;\n  for(int i=1;i<=10000;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(dp[i][j][k]>r)continue;\n\tans=max(ans,i);\n\tsolve(i,j,k);\n      }\n    }\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double INF = (double)(1<<29);\nconst double EPS = 1e-7;\n\nint n, ans;\nvector<int> G[20][20];\ndouble r, theta;\nbool  memo[20][20][10001];\nP v[20];\n\nstruct state{\n  int prev,pos,sum;\n  double dis;\n  state(int p=0, int po=0, int s=0, double d=0):prev(p),pos(po),sum(s),dis(d){}\n  bool operator < (const state &s) const {\n    return dis > s.dis;\n  }\n};\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\ndouble calcTheta(P a, P b, P c){\n  double A = abs(b - a);\n  double B = abs(b - c);\n  double C = abs(a - c);\n  double ans = acos((A*A + B*B - C*C) / (2*A*B));\n  return M_PI - ans;\n}\n\n/*\nvoid dfs(int prev, int pos, int sum, double dis){\n  //if(memo[prev][pos][sum] <= dis || equal(memo[prev][pos][sum],dis)) return;\n  ans = max(ans,sum);\n  for(int i=0;i<G[prev][pos].size();i++){\n    int next = G[prev][pos][i];\n    if(dis + abs(v[pos]-v[next]) > r || memo[pos][next][sum+1] <= dis + abs(v[pos]-v[next]) || equal(memo[pos][next][sum+1], dis + abs(v[pos]-v[next]))) continue;\n    memo[pos][next][sum+1] = dis + abs(v[pos]-v[next]);\n    dfs(pos, next, sum+1, dis+abs(v[pos]-v[next]));\n  }\n}\n*/\n\nvoid bfs(){\n  priority_queue<state> Q;\n  state u,next;\n  for(int i=1;i<n;i++){\n    if(abs(v[i]-v[0]) > r) continue;\n    memo[0][i][1] = true;\n    Q.push(state(0,i,1,abs(v[i]-v[0])));\n  }\n\n  while(!Q.empty()){\n    u = Q.top();\n    Q.pop();\n    ans = max(ans,u.sum);\n    for(int i=0;i<G[u.prev][u.pos].size();i++){\n      next = state(u.pos, G[u.prev][u.pos][i], u.sum+1, u.dis);\n      next.dis += abs(v[u.pos]-v[next.pos]);\n      if(next.dis > r || memo[u.pos][next.pos][next.sum]) continue;\n      memo[u.pos][next.pos][next.sum] = true;\n      Q.push(next);\n    }\n  }\n}\n\nint main(){\n  while(cin >> n){\n    ans = 0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        G[i][j].clear();\n        for(int k=0;k<10001;k++) memo[i][j][k] = false;\n      }\n    }\n\n    cin >> r >> theta;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      v[i] = P(x,y);\n    }\n    theta *= M_PI / 180.0;\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        for(int k=0;k<n;k++){\n          if(i == k || j == k) continue;\n          if(calcTheta(v[i],v[j],v[k]) < theta) G[i][j].push_back(k);\n        }\n      }\n    }\n\n    /*\n    for(int i=1;i<n;i++){\n      if(abs(v[i]-v[0]) > r) continue;\n      memo[0][i][1] = abs(v[i]-v[0]);\n      dfs(0, i, 1, abs(v[i]-v[0]));\n      }\n    */\n    bfs();\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF (long long)(1e18)\n#define MOD (int)(1e9+7)\n\n#define EPS 1e-8\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX 24\n\nstring hogehogehoge;\n\nint n, x[MAX], y[MAX], used[MAX][MAX], hh[MAX][MAX];\ndouble r, t;\ndouble tete[MAX][MAX];\n\ndouble angle(double x1, double y1,double x2, double y2){//cout<<\"(\"<<x1<<\",\"<<y1<<\") (\"<<x2<<\",\"<<y2<<\")\";\n\tif(x1 >= INF-1){\n\t\t//cout<<\"-> \"<<0<<endl;\n\t\treturn 0;\n\t}\n\tdouble inner_product = x1*x2+y1*y2, ab1 = sqrt(x1*x1+y1*y1), ab2 = sqrt(x2*x2+y2*y2);\n\t//cout<<\"- > \"<<acos(inner_product/(ab1*ab2))<<endl;\n\treturn fabs(acos(inner_product/(ab1*ab2)));\n}\n\n\nint solve(int b,int g, double R, double xx, double yy, int p){//cout<<g<<\" \"<<R<<endl;\n\t// cin>>hogehogehoge;\n\tint ans = 0, re = 1;\n\t\n\tif(b != INF){\n\t\tif(used[b][g] == 0) tete[b][g] = R,hh[b][g] = p, used[b][g]++;\n\t\telse if(used[b][g] == 1) tete[b][g] = R-tete[b][g],hh[b][g] = p-tete[b][g],used[b][g]++;\n\t\telse{\n\t\t\tre +=  ((int)R/(int)tete[b][g])*hh[b][g];\n\t\t\tR -= ((int)R/(int)tete[b][g])*tete[b][g];\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tif(i==g) continue;\n\t\tif(angle(xx,yy,x[i]-x[g],y[i]-y[g]) <= t && (x[i]-x[g])*(x[i]-x[g]) + (y[i]-y[g])*(y[i]-y[g])<= R*R){\n\t\t\tans = max(ans,solve(g,i,R-sqrt((x[i]-x[g])*(x[i]-x[g]) + (y[i]-y[g])*(y[i]-y[g])),x[i]-x[g],y[i]-y[g],p+1));\n\t\t}\n\t}\n\treturn ans+re;\n}\n\nint hoge(){\n\t// for(int i = 0; i < n; i++){\n\t\t// for(int j = 0; j < n; j++){\n\t\t\t// tete[i][j] = 1;\n\t\t// }\n\t// }\n\t\n\treturn solve(INF,0,r,INF,0,0)-1;\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(7);\n\t\n\t\n\tcin>>n>>r>>t;\n\t\n\t\n\tt = (t/360)*(2*acos(-1));\n\t\n\trep(i,n){\n\t\tcin>>x[i]>>y[i];\n\t\tx[i] += 10000; y[i] += 10000;\n\t}\n\t\n\t// cout<<solve(0,r,INF,0)-1<<endl;\n\tcout<<hoge()<<endl;\n\t\n\t// cout<<\"t = \"<<t<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  R r, th; cin >> r >> th, th *= pi / 180;\n  V<P> p(n); for (auto&& e : p) cin >> e;\n  VV< V<> > ks(20, VV<>(20));\n  VV<R> d(20, V<R>(20));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    for (int k = 0; k < n; ++k) if (k != j) {\n      L s{p[i], p[j]}, t{p[j], p[k]};\n      R ph = fmod(3 * pi + t.arg() - s.arg(), 2 * pi) - pi;\n      if (sgn(abs(ph), th) <= 0) ks[i][j].push_back(k);\n    }\n    d[i][j] = distPP(p[i], p[j]);\n  }\n  VV<R> dp(20, V<R>(20, 1e10));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    dp[i][j] = d[i][j];\n  }\n  int res = 0;\n  for (int s = 0; s <= 1e4; ++s) {\n    VV<R> ndp(20, V<R>(20, 1e10));\n    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n      if (!i and sgn(dp[i][j], r) <= 0) res = s + 1;\n      for (int k : ks[i][j]) {\n        ndp[i][j] = min(ndp[i][j], d[i][j] + dp[j][k]);\n      }\n    }\n    swap(dp, ndp);\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-4)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int MAX = 20,LIMIT = 20100,IINF = INT_MAX;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nstruct Edge{\n  int to;\n  double weight;\n  Edge(int to=0,double weight=0):to(to),weight(weight){}\n};\n\nstruct Data{\n  int prev,cur,carrot;\n  double dist;\n  Data(int prev=0,int cur=0,int carrot=0,double dist=0):prev(prev),cur(cur),carrot(carrot),dist(dist){}\n  bool operator < (const Data& data) const{ return dist > data.dist; }\n};\n\nint n;\ndouble r,theta,mindist[MAX][MAX][LIMIT]; // mindist[cur][prev][the number of carrot]\nPoint ps[MAX];\nvector<Edge> edge[MAX][MAX]; // edge[cur][prev]\n\ninline void dijkstra(){\n  rep(i,n)rep(j,n)rep(k,LIMIT) mindist[i][j][k] = IINF;\n  priority_queue<Data> Q;\n\n  REP(i,1,n) {\n    double dist = abs(ps[0]-ps[i]);\n    if( !equals(dist,r) && dist > r ) continue;\n    Q.push(Data(0,i,1,dist));\n    mindist[i][0][1] = dist;\n  }\n  int ans = (Q.empty()?0:1);\n\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n    int prev = data.prev, cur = data.cur, carrot = data.carrot;\n    double dist = data.dist;\n\n    if( !equals(mindist[cur][prev][carrot],dist) && mindist[cur][prev][carrot] < dist ) continue;\n\n    rep(i,edge[cur][prev].size()) {\n      int next = edge[cur][prev][i].to;\n      double weight = edge[cur][prev][i].weight;\n      if( !equals(r,dist+weight) && r < dist+weight ) continue;\n      if( mindist[next][cur][carrot+1] > dist + weight ){\n        mindist[next][cur][carrot+1] = dist + weight;\n        assert(carrot+1 < LIMIT);\n        ans = max(ans,carrot+1);\n        Q.push(Data(cur,next,carrot+1,dist+weight));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\ninline void makeEdge(){\n  rep(prev,n){\n    rep(cur,n){\n      if( cur == prev ) continue;\n      rep(next,n){\n        if( next == cur || next == prev ) continue;\n        double dist = abs(ps[cur]-ps[next]);\n        if( !equals(dist,r) && dist > r ) continue;\n        Vector v1 = ps[next] - ps[cur];\n        Vector v2 = ps[cur]  - ps[prev];\n        if( equals(cross(v1,v2),0.0) ) continue;\n        double arg = getArg(ps[prev],ps[cur],ps[next]);\n        if( equals(arg,theta) || arg < theta ) edge[cur][prev].push_back(Edge(next,dist));\n      }\n    }\n  }\n}\n\nint main(){\n\n  /*\n  int next = 2, cur = 1, prev = 0;\n  ps[0] = Point(0,0);\n  ps[1] = Point(10,0);\n  ps[2] = Point(0,1);\n  double arg =  getArg(ps[prev],ps[cur],ps[next]);\n  cout << \"arg = \" << arg * 180.0 / M_PI << endl;\n  */\n\n  cin >> n;\n  cin >> r >> theta;\n  theta = toRad(theta);\n  rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n\n  makeEdge();\n\n  dijkstra();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nconst double PI = 3.1415926535;\nint main(){\n  int n,i,j,k,ans=0;cin>>n;\n  double r,arc;cin>>r>>arc;\n  arc=PI/180.0*arc;\n  Polygon g;g.resize(n);\n  for(i=0;i<n;i++) cin>>g[i].x>>g[i].y;\n  double e[n][n][n],inf=1<<28;\n  fill(e[0][0],e[0][0]+n*n*n,inf);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      for(k=0;k<n;k++){\n\tif(i==j||j==k||k==i) continue;\n\tVector a=g[j]-g[i],b=g[k]-g[j];\n\tif(fabs(acos(dot(a,b)/(abs(a)*abs(b))))<=arc)\n\t  e[i][j][k]=abs(g[k]-g[j]);\n      }\n    }\n  }\n  for(k=1;k<n;k++) e[0][0][k]=abs(g[k]-g[0]);\n  map<int,double> dp[n][n];\n  typedef pair<int,int> P;\n  typedef pair<int,P> PP;\n  typedef pair<double,PP> PPP;\n  priority_queue<PPP,vector<PPP>,greater<PPP> > q;\n  q.push(PPP(0.0,PP(0,P(0,n))));\n  while(!q.empty()){\n    PPP ppp=q.top();q.pop();\n    double d=ppp.first,z;\n    PP pp=ppp.second;\n    k=pp.first;\n    P p=pp.second;\n    if(d>r) continue;\n    ans=max(ans,k);\n    if(p.second==n){\n      for(i=0;i<n;i++){\n\tz=inf;\n\tfor(j=0;j<n;j++) z=min(z,e[j][0][i]);\n\tq.push(PPP(d+z,PP(k+1,P(i,p.first))));\n      }\n    }else{\n      if(dp[p.first][p.second].find(k)!=dp[p.first][p.second].end())\n\tif(dp[p.first][p.second][k]<=d) continue;\t\n      dp[p.first][p.second][k]=d;\n      for(i=0;i<n;i++)\n\tq.push(PPP(d+e[p.second][p.first][i],PP(k+1,P(i,p.first))));\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<  vector<double>  > vvd;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef complex<double> zahyo;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nzahyo toshi[21];\nbool kakdotest(zahyo a,zahyo b,double kakdo){\n\n  double kak= (a.real()*b.real()+a.imag()*b.imag())/  (abs(a)*abs(b));\n  if (cos(kakdo)<=kak)\n    return true;\n  else return false;\n}\nint main(){\n  int n,k;\n  double r,kakdo,xza,yza;\n  cin>>n>>r>>kakdo;\n  for(int i=1;i<=n;i++){\n    cin>>xza>>yza;\n    toshi[i]=zahyo(xza,yza);\n  }\n  vvd nokori(n+1);\n  for(int i=0;i<n+1;i++){\n    nokori[i]=vector<double>(21,-1);\n  }\n  vvd prevnokori=nokori;\n  for(int i=2;i<n+1;i++){\n    prevnokori[1][i]=r-abs(toshi[i]-toshi[1]);\n  }\n  int maxcarrot=0;\n  k=1;\n  while(k-maxcarrot==1){\n    vvd nextnokori=nokori;  \n    for(int i=1;i<(n+1);i++)\n      for(int j=1;j<(n+1);j++){\n\tif(i==j) continue;\n\tif(prevnokori[i][j]<0) continue;\n\tmaxcarrot=k;\n\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<abs(prevnokori[i][j])<<endl;\n\tfor(int l=1;l<(n+1);l++){\n\t  if(kakdotest(toshi[i]-toshi[j],\n\t\t       toshi[j]-toshi[l],kakdo)){\n\t    nextnokori[j][l]=\n\t      max(prevnokori[i][j]-abs(toshi[j]-toshi[l]),\n\t\t\t\t nextnokori[j][l]);\n\t   \n\t  }\n\t}\n\n      }\n    prevnokori=nextnokori;\n    k++;\n  }\n  cout<<maxcarrot<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 200\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nint V;\ndouble r, theta;\n\n// A*B の計算\nmat mul(mat &A, mat &B){\n\tmat C(A.size(), vec(B[0].size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tfor(int j = 0; j < B[0].size(); j++){\n\t\t\tdouble mini = INF;\n\t\t\tfor(int k = 0; k < B.size(); k++){\n\t\t\t\tmini = min(mini, A[i][k] + B[k][j]);\n\t\t\t}\n\t\t\tC[i][j] = mini;\n\t\t}\n\t}\n\treturn C;\n}\n\n// A^n の計算\nint mat_pow(mat A){\n\tmat B(A.size(), vec(A.size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tB[i][i] = 1;\n\t}\n\tint num = 0;\n\twhile(true){\n\t\tB = mul(B, A);\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < V * V; i++){\n\t\t\tfor(int j = 0; j < V * V; j++){\n\t\t\t\tif(B[i][j] < r){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\n\treturn num;\n}\n\nint main(){\n\t\n\tcin >> V;\n\tcin >> r >> theta;\n\t\n\ttheta = theta * M_PI / 180;\n\t\n\tmat S(V * V, vec(V * V));\n\t\n\tdouble x[30], y[30];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i = 0; i < V * V; i++){\n\t\tfor(int j = 0; j < V * V; j++){\n\t\t\tS[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\tif(i == j || j == k || k == i){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble vx1, vx2, vy1, vy2;\n\t\t\t\tvx1 = x[j] - x[i];\n\t\t\t\tvy1 = y[j] - y[i];\n\t\t\t\tvx2 = x[k] - x[j];\n\t\t\t\tvy2 = y[k] - y[j];\n\t\t\t\tdouble inn = vx1 * vx2 + vy1 * vy2;\n\t\t\t\tdouble norm1 = sqrt(vx1 * vx1 + vy1 * vy1);\n\t\t\t\tdouble norm2 = sqrt(vx2 * vx2 + vy2 * vy2);\n\t\t\t\tdouble th = acos(inn * inn / norm1 / norm2);\n\t\t\t\tif(M_PI - th < theta){\n\t\t\t\t\tS[i * V + j][j * V + k] = norm2;\n\t\t\t\t\t//S[j * V + i][k * V + j] = norm2;\n\t\t\t\t\t//S[j * V + k][i * V + j] = norm1;\n\t\t\t\t\tS[k * V + j][j * V + i] = norm1;\n\t\t\t\t\t//cout << i * V + j << \" \" << j * V + k << \" \" << norm2 << endl;\n\t\t\t\t\t//cout << k * V + j << \" \" << j * V + i << \" \" << norm1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << mat_pow(S) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (lt(a, b) || equals(a, b))\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\ndouble getAngle(Point a, Point b, Point c)\n{\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\n\n\nint n;\ndouble r, t;\nvector<Point> ps;\n\ndouble d[21][21][10001];\n\nstruct State\n{\n  int now, prev, car;\n  double dist;\n  State(){}\n  State(int now, int prev, int car, int dist):now(now), prev(prev), car(car), dist(dist){}\n  bool operator < (const State& r) const {\n    return dist > r.dist;\n  }\n};\n\nint solve()\n{\n  rep(i, 21) rep(j, 21) rep(k, 10001) d[i][j][k] = 1e10;\n\n  priority_queue<State> que;\n  reps(i, 1, n) {\n    double dist = getDistance(ps[0], ps[i]);\n    if(le(dist, r)) {\n      d[i][0][1] = dist;\n      que.push(State(i, 0, 1, dist));\n    }\n  }\n\n  int ans = 0;\n  while(!que.empty()) {\n    State st = que.top(); que.pop();\n    int now = st.now, prev = st.prev, car = st.car;\n    double dist = st.dist;\n    ans = max(ans, car);\n    if(dist > d[now][prev][car]) continue;\n    rep(i, n) if(i != now) {\n      int di = dist + getDistance(ps[now], ps[i]);\n      if(le(getAngle(ps[prev], ps[now], ps[i]), t) && le(di, r) && d[i][now][car+1] > di) {\n\td[i][now][car+1] = di;\n\tque.push(State(i, now, car+1, di));\n      }\n    }\n  }\n\n  return ans;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> n >> r >> t;\n  ps.resize(n);\n  rep(i, n) cin >> ps[i].x >> ps[i].y;\n\n  cout << solve() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\nusing namespace std;\ntypedef long long LL;\n\n#define _CRT_SECURE_NO_WARNINGS\nint N;\nfloat r, t;\nint x[21], y[21];\n\nfloat dp[21][21][10010] = {};\nfloat Distance(int n, int m) {\n\treturn sqrtf( (x[n] - x[m])*(x[n] - x[m])+(y[n] - y[m])*(y[n] - y[m]) );\n}\nbool TurnAble(int a, int b,int c) {\n\tfloat d = acosf( ((x[b] - x[a])*(x[c] - x[b]) + (y[b] - y[a])*(y[c] - y[b])) / (Distance(a, b)*Distance(b, c)) );\n\treturn d < (t/180 * 3.1415) ;\n}\nint main() {\n\tint ans = 0;\n\tscanf(\"%d\", &N);\n\tscanf(\"%f %f\", &r, &t);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tfor (int k = 0; k <= r;k++) {\n\t\t\t\tdp[i][j][k] = r + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tfor (int i = 0; i < N;i++) {\n\t\tscanf(\"%d %d\",x+i,y+i);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i != 0) {\n\t\t\tdp[0][i][1] = Distance(0, i);\n\t\t\tif (dp[0][i][1] <= r) {\n\t\t\t\tans = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (ans == 0) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor (int k = 2; k <= r; k++) {\n\t\tfor (int now = 0; now < N;now++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (j != now) {\n\t\t\t\t\tif (dp[j][now][k - 1] <= r) {\n\t\t\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\t\t\tif (i != now && i!=j) {\n\t\t\t\t\t\t\t\tif (TurnAble(j, now, i)) {\n\t\t\t\t\t\t\t\t\tdp[now][i][k] = min(dp[j][now][k - 1] + Distance(now, i), dp[now][i][k]);\n\t\t\t\t\t\t\t\t\tif (dp[now][i][k]<=r) {\n\t\t\t\t\t\t\t\t\t\tans = max(ans, k);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst double pi = acos(-1);\nint n; double r, t;\nint main() {\n\tcin >> n >> r >> t; t *= pi / 180;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tvector<vector<vector<bool> > > ok(n, vector<vector<bool> >(n, vector<bool>(n, false)));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (j == k) continue;\n\t\t\t\tdouble t2 = (x[j] - x[i]) * (x[j] - x[k]) + (y[j] - y[i]) * (y[j] - y[k]);\n\t\t\t\tt2 /= hypot(x[j] - x[i], y[j] - y[i]);\n\t\t\t\tt2 /= hypot(x[j] - x[k], y[j] - y[k]);\n\t\t\t\tif (pi - acos(t2) < t) ok[i][j][k] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<double> > dist(n, vector<double>(n));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tdist[i][j] = hypot(x[i] - x[j], y[i] - y[j]);\n\t\t}\n\t}\n\tint lim = (int)r;\n\tvector<vector<vector<double> > > dp(lim, vector<vector<double> >(n, vector<double>(n, 1.0e+10))); // (carrot - 2, now, prev)\n\tfor (int i = 1; i < n; i++) dp[0][i][0] = hypot(x[0] - x[i], y[0] - y[i]);\n\tfor (int i = 1; i < lim; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (j == k) continue;\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tif (!ok[j][k][l]) continue;\n\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 1][k][l] + dist[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < lim; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (dp[i][j][k] < r) ret = max(ret, i + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(const deque<int>& deq,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[deq[0]];\n  complex<double> mid = cities[deq[1]];\n  complex<double> dst = cities[deq[2]];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _c,double _r,const deque<int>& _d) :\n    city(_ct), carrots(_c), remaining_distance(_r),deq(_d) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    deq.push_back(_d);\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,false,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      int prev = 20;\n      if(s.deq.size() > 1) prev = *(s.deq.end()-2);\n\n      if(dp[s.carrots][prev][s.city]) continue;\n      dp[s.carrots][prev][s.city] = true;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\t\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tdeque<int> deq = s.deq;\n\t\n\tdeq.push_back(to);\n\twhile(deq.size() > 3) deq.pop_front();\n\n\tif(deq.size()==3){\n\t  if(!check(deq,limit_rad,cities)) continue;\n\t}\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tque.push(State(to,s.carrots+1,s.remaining_distance - dist,deq));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst long double PI = 3.14159255358979323846264338327950288l;\nint n; long long r, s;\nstruct Point { long double px, py; };\nlong double theta(long double a, long double b, long double c) {\n\tlong double s = (a + b + c) / 2.0l;\n\tlong double S = sqrtl(s*(s - a)*(s - b)*(s - c));\n\tlong double A = -1000, B = -1000, C = -1000, H;\n\n\tif (a > b && a > c) { H = 2.0l * S / a; B = asin(H / c)*180.0l / PI; C = asin(H / b)*180.0l / PI; A = 180.0l - B - C; }\n\telse if (b > a && b > c) { H = 2.0l * S / b; A = asin(H / c)*180.0l / PI; C = asin(H / a)*180.0l / PI; B = 180.0l - A - C; }\n\telse { H = 2.0l * S / c; A = asin(H / b)*180.0l / PI; B = asin(H / a)*180.0l / PI; C = 180.0l - A - B; }\n\n\treturn A;\n}\nlong double theta_(Point a, Point b, Point c) {\n\t//a->b->c\n\tlong double A1 = sqrtl((a.px - c.px)*(a.px - c.px) + (a.py - c.py)*(a.py - c.py));\n\tlong double B1 = sqrtl((a.px - b.px)*(a.px - b.px) + (a.py - b.py)*(a.py - b.py));\n\tlong double C1 = sqrtl((b.px - c.px)*(b.px - c.px) + (b.py - c.py)*(b.py - c.py));\n\treturn theta(A1, B1, C1);\n}\nlong double dp[20000][30][30], r, t; Point x[30]; int n;\nint main() {\n\tcin >> n >> r >> t;\n\tfor (int i = 0; i < n; i++)cin >> x[i].px >> x[i].py;\n\tfor (int i = 0; i < 20000; i++) { for (int j = 0; j < 30; j++) { for (int k = 0; k < 30; k++) { dp[i][j][k] = 999999999.9l; } } }\n\tfor (int i = 0; i < 20000; i++) { dp[1][0][i] = sqrtl((x[0].px - x[i].px)*(x[0].px - x[i].px) + (x[0].py - x[i].py)*(x[0].py - x[i].py)); }\n\tfor (int i = 1; i < 15000; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tif (j == k || k == l)continue;\n\t\t\t\t\tlong double T = theta_(x[j], x[k], x[l]);\n\t\t\t\t\tlong double dst = sqrtl((x[k].px - x[l].px)*(x[k].px - x[l].px) + (x[k].py - x[l].py)*(x[k].py - x[l].py));\n\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][k] + dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = 0;\n\tfor (int i = 0; i < 20000; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (dp[i][j][k] <= r)maxn = max(maxn, i);\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n\n#include<vector>\nusing namespace std;\n#define INF 1e8\n\nint n;\ndouble r, theta;\ndouble x[21], y[21];\ndouble dist[2][400];\nint cnt[400];\nvector<int> edge[10800];\ndouble d(int a, int b){\n\treturn sqrt((x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]));\n}\nbool ok(int a, int b, int c, double theta){\n\tdouble dot = (x[b]-x[a]) * (x[c]-x[b]) + (y[b]-y[a]) * (y[c] - y[b]);\n\tdouble dist1 = d(a, b);\n\tdouble dist2 = d(b, c);\n\treturn cos(theta)*dist1*dist2 <= dot;\n}\n\n\nint solve(double r){\n\tbool cont = true;\n\tbool ok = false;\n\tfor(int i = 0;i < 400;i++)dist[1][i] = INF;\n\tfor(int i = 1;i < n;i++){\n\t\tif(d(0, i) < r)ok = true;\n\t\tdist[1][i] = d(0,i);\n\t}\n\tif(!ok)return 0;\n\tint cnt = 0;\n\twhile(cont){\n\t\tcnt++;\n\t\tcont = false;\n\t\tfor(int i = 0;i < 400;i++)dist[!(cnt%2)][i] = INF;\n\t\tfor(int i = 0;i < 400;i++){\n\t\t\tfor(int j = 0;j < edge[i].size();j++){\n\t\t\t\tint to = edge[i][j];\n\t\t\t\tdouble dd = d(to / n, to % n);\n\t\t\t\tdist[!(cnt%2)][to] = min(dist[!(cnt%2)][to], dist[(cnt%2)][i] + dd);\n\t\t\t\tif(dist[!(cnt%2)][to] < r)cont = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tcin >> n;\n\tcin >> r >> theta;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tif(i == j || j == k)continue;\n\t\t\t\tif(ok(i, j, k, theta)){\n\t\t\t\t\tint u = i * n + j;\n\t\t\t\t\tint v = j * n + k;\n\t\t\t\t\tedge[u].push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << solve(r) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (lt(a, b) || equals(a, b))\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\ndouble getAngle(Point a, Point b, Point c)\n{\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\n\n\nint n;\ndouble r, t;\nvector<Point> ps;\n\ndouble d[21][21][10001];\n\nint solve()\n{\n  rep(i, 21) rep(j, 21) rep(k, 10001) d[i][j][k] = 1e10;//-1;\n  queue< tuple<int, int, int> > que;\n  reps(i, 1, n) {\n    int dist = getDistance(ps[0], ps[i]);\n    if(le(dist, r)) {\n      d[i][0][1] = dist;\n      que.emplace(i, 0, 1);\n    }\n  }\n\n  int ans = 0;\n  while(!que.empty()) {\n    int now, prev, car;\n    tie(now, prev, car) = que.front(); que.pop();\n    ans = max(ans, car);\n    rep(i, n) if(i != now) {\n      int dist = d[now][prev][car] + getDistance(ps[now], ps[i]);\n      if(le(getAngle(ps[prev], ps[now], ps[i]), t) && le(dist, r) && d[i][now][car+1] > dist) {\n\td[i][now][car+1] = dist;\n\tque.emplace(i, now, car+1);\n      }\n    }\n  }\n\n  return ans;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> n >> r >> t;\n  ps.resize(n);\n  rep(i, n) cin >> ps[i].x >> ps[i].y;\n\n  cout << solve() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct state {\n  int p, c, n;\n  float d;\n  bool operator<(const state &s) const { return d > s.d; }\n};\n\nint N, X[20], Y[20];\nfloat R, Theta;\nfloat d[20][20];\nbool angle[20][20][20];\nfloat dp[20][20][100000];\n\nfloat theta(int i, int j, int k) {\n  int x1 = X[k] - X[j], y1 = Y[k] - Y[j];\n  int x2 = X[j] - X[i], y2 = Y[j] - Y[i];\n  float l1 = sqrt(x1 * x1 + y1 * y1);\n  float l2 = sqrt(x2 * x2 + y2 * y2);\n  float iprod = x1 * x2 + y1 * y2;\n  float rad = acos(iprod / l1 / l2);\n  return rad * 180 / M_PI;\n}\n\nint main(void) {\n  cin >> N >> R >> Theta;\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n\n  REP(i, 0, N) REP(j, 0, N) {\n    d[i][j] = sqrt((X[i] - X[j]) * (X[i] - X[j]) + (Y[i] - Y[j]) * (Y[i] - Y[j]));\n  }\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, N) {\n    if(i == j || j == k || k == i) angle[i][j][k] = false;\n    else angle[i][j][k] = theta(i, j, k) <= Theta + 10e-8;\n  }\n\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, 100000) dp[i][j][k] = 1e10;\n\n  priority_queue<state> q;\n  REP(i, 1, N) if(d[0][i] <= R + 1e-8) q.push((state) { 0, i, 1, d[0][i] });\n\n  int ans = 0;\n  while(q.size()) {\n    state c = q.top();\n    q.pop();\n\n    if(dp[c.p][c.c][c.n] <= c.d) continue;\n    dp[c.p][c.c][c.n] = c.d;\n\n    ans = max(ans, c.n);\n\n    REP(i, 0, N) if(angle[c.p][c.c][i]) {\n      float nd = c.d + d[c.c][i];\n      if(dp[c.c][i][c.n + 1] <= nd) continue;\n      if(nd <= R + 1e-8) q.push((state) { c.c, i, c.n + 1, nd });\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>{\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b,QF &&qf) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1,qf);\n\t}*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l,int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\ndouble dp[10001][20][20];\nbool ac[20][20][20];\ndouble d[20][20];\nint main() {\n\tfill(dp[0][0], dp[10000][0], 1e10);\n\tint n;\n\tdouble r, t;\n\tcin >> n >> r >> t;\n\tint ans = 0;\n\tvector<P> p(n);\n\trep(i, n) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = P(x, y);\n\t}\n\trep(i, n)rep(j, n)d[i][j] = abs(p[i] - p[j]);\n\trep(i, n)rep(j, n)rep(k, n) {\n\t\tac[i][j][k] = i != j&&j != k&&dot(p[j] - p[i], p[k] - p[j]) / abs(p[j] - p[i]) / abs(p[k] - p[j]) > cos(t*pi/180);\n\t}\n\trep1(i, n - 1)dp[1][0][i] = d[0][i];\n\trep1(i, n - 1)if (d[0][i] < r)ans = 1;\n\trep1(i, r - 1) {\n\t\trep(j, n)rep(k, n)rep(l, n) {\n\t\t\tif (ac[j][k][l]) {\n\t\t\t\tcmin(dp[i + 1][k][l], dp[i][j][k] + d[k][l]);\n\t\t\t\tif (dp[i + 1][k][l] < r)ans = i + 1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\n\nint main(){\n  int n;\n  double r, theta;\n  cin >> n >> r >> theta;\n  theta *= acos(-1)/180;\n  vector<int> X(n), Y(n);\n  for(int i = 0; i < n; ++i) cin >> X[i] >> Y[i];\n  vector< vector<double> > dp(n,vector<double>(n,0));\n  bool f = false;\n  int ans = 0;\n  vector<int> V;\n  for(int i = 1; i < n; ++i){\n    int x1 = X[i] - X[0], y1 = Y[i] - Y[0];\n    if(hypot(x1,y1) <= r + EPS){\n      f = true;\n      dp[0][i] = r - hypot(x1,y1);\n      V.push_back(i);\n    }\n  }\n  while(f){\n    f = false;\n    ++ans;\n    vector< vector<double> > dp_(n,vector<double>(n,0));\n    vector<int> V_;\n    for(int l = 0; l < V.size(); ++l){\n      int i = V[l]/n, j = V[l]%n;\n      for(int k = 0; k < n; ++k){\n        if(j == k) continue;\n        int x1 = X[j] - X[i], y1 = Y[j] - Y[i], x2 = X[k] - X[j], y2 = Y[k] - Y[j];\n        if(acos((x1*x2+y1*y2)/hypot(x1,y1)/hypot(x2,y2)) <= theta + EPS&& \n           hypot(x2,y2) <= dp[i][j] + EPS){\n          f = true;\n          //if(dp_[j][k] <= EPS) V_.push_back(j*n+k);\n          dp_[j][k] = max(dp_[j][k],dp[i][j] - hypot(x2,y2));\n          V_.push_back(j*n+k);\n        }\n      }\n    }\n    dp = dp_;\n    V = V_;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n \ntypedef complex<double> P;\n \nstruct S{\n  int w,p,n;\n  double d;\n  bool operator<(S s)const{\n    return d>s.d;\n  }\n};\n \ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n \nint main(){\n  int n;\n  double r,th;\n  cin>>n>>r>>th;\n  P p[21];\n  for(int i=1;i<=n;i++){\n    int x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<S> que;\n  que.push({1,0,0,0});\n  static bool mem[21][21][22222];\n  int m=0;\n  for(;;){\n    auto cs=que.top();\n    if(cs.d>r)break;\n    que.pop();\n    if(mem[cs.w][cs.p][cs.n]++)continue;\n    m=max(m,cs.n);\n    for(int i=1;i<=n;i++){\n      if(i==cs.w)continue;\n      auto f=p[cs.w]-p[cs.p];\n      auto t=p[i]-p[cs.w];\n      if(cs.p&&acos(dot(f,t)/abs(f)/abs(t))*90>th*acos(0))continue;\n      que.push({i,cs.w,cs.n+1,cs.d+abs(t)});\n    }\n  }\n  cout<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntypedef long double D;\nconst D eps = 1e-10;\nconst D pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\nD dist[20][20];\n\nbool ok[20][20][20];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tD r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,n)rep(j,n){\n\t\tint dx=(x[i]-x[j]);\n\t\tint dy=(y[i]-y[j]);\n\t\tdist[i][j]=sqrt(1.0*dx*dx+1.0*dy*dy);\n\t}\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tint ans=0;\n\trange(cp,1,n) dp[1][cp][0]=dist[cp][0],ans=1;\n\n\trep(pp,n)rep(cp,n)rep(np,n){\n\t\tif(pp==cp) continue;\n\t\tif(cp==np) continue;\n\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\tD dot=1.0*cx*nx+1.0*cy*ny;\n\t\tdot/=(dist[cp][pp]*dist[np][cp]);\n\t\tdot=max<D>(-1,dot);\n\t\tdot=min<D>(1,dot);\n\t\tD angle=acos(dot);\n\t\tangle*=180.0/pi;\n\t\tif(angle>180.0) angle=360.0-angle;\n\t\tif(angle<=theta) ok[pp][cp][np]=true;\n\t}\n\n\n\trep(i,limit)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tD add=dist[cp][np];\n\t\t\tif(dp[i][cp][pp]+add>r) continue;\n\t\t\tif(ok[pp][cp][np]==false) continue;\n\t\t\tdp[i+1][np][cp]=min<D>(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t\tans=max(ans,i+1);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#define llint long long\n#define eps 1e-9\n#define inf 1e18\n#define PI 3.14159265358979323846264\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\nllint n;\ndouble r, th;\nvec2d p[25];\ndouble dp[10005][20][20];\ndouble dist[25][25];\nbool can[25][25][25];\n\nint main(void)\n{\n\tcin >> n;\n\tcin >> r >> th;\n\tfor(int i = 0; i < n; i++) cin >> p[i].x >> p[i].y;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i == j) continue;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tvec2d u = p[i]-p[j], v = p[k]-p[i];\n\t\t\t\tdouble ang = acos(u.dot(v)/(u.norm()*v.norm()));\n\t\t\t\tif(ang * 180 / PI <= th + eps){\n\t\t\t\t\tcan[i][j][k] = true;\n\t\t\t\t\t//cout << j << \" \" << i << \" \" << k << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdist[i][j] = (p[i]-p[j]).norm();\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i <= 10000; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tdp[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\tfor(int i = 0; i < 10000; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tfor(int l = 0; l < n; l++){\n\t\t\t\t\tif(j == l) continue;\n\t\t\t\t\tif(i != 0 && !can[j][k][l]) continue;\n\t\t\t\t\tdp[i+1][l][j] = min(dp[i+1][l][j], dp[i][j][k] + dist[j][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i <= 10000; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(dp[i][j][k] <= r + eps) ans = i;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 20;\nconst int INF = 1 << 29;\nconst double EPS = 1e-8;\n\nstruct edge{\n  int to;\n  double cost;\n  edge(int t=0, int c=0):to(t),cost(c){}\n};\n\nstruct state{\n  int now, prev, cnt;\n  double dis;\n  state(int p=0, int n=0, int c=0, double d=0):now(n),prev(p),cnt(c),dis(d){}\n  bool operator < (const state &s) const {\n    return dis < s.dis;\n  }\n};\n\ndouble angle(P a, P b1, P b2){\n  double A = abs(b1 - b2);\n  double B = abs(a - b1);\n  double C = abs(a - b2);\n  return acos((B*B + C*C - A*A) / (2.0*B*C));\n}\n\n\nint n;\ndouble r, rad;\nvector<P> v;\n\nint solve(){\n  int ans = 0, d[N][N];\n  priority_queue<state> pq;\n  state u, u2;\n  vector<edge> g[N][N];\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n        if(j != k && (i == j || M_PI - angle(v[j], v[i], v[k]) <= rad + EPS)) {\n          g[i][j].push_back(edge(k, abs(v[j] - v[k])));\n          //if(i != j) cout << v[i] << \" -> \" << v[j] << \" -> \" << v[k] << \" : \" << abs(v[j]-v[k]) << endl;\n        }\n      }\n    }\n  }\n  fill(d[0], d[n], -1);\n\n  for(pq.push(state(0, 0, 0, 0)); !pq.empty();){\n    u = pq.top();\n    pq.pop();\n\n    if(d[u.prev][u.now] >= u.cnt) continue;\n    d[u.prev][u.now] = u.cnt;\n\n    for(int i=0;i<g[u.prev][u.now].size();i++){\n      edge next = g[u.prev][u.now][i];\n      if(u.dis + next.cost > r + EPS) continue;\n      ans = max(ans, u.cnt+1);\n      pq.push(state(u.now, next.to, u.cnt+1, u.dis+next.cost));\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  while(cin >> n){\n    v.clear();\n    cin >> r >> rad;\n    rad *= M_PI / 180.0;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> x >> y;\n      v.push_back(P(x,y));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(const deque<int>& deq,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[deq[0]];\n  complex<double> mid = cities[deq[1]];\n  complex<double> dst = cities[deq[2]];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _c,double _r,const deque<int>& _d) :\n    city(_ct), carrots(_c), remaining_distance(_r),deq(_d) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    deq.push_back(_d);\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,false,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      while(s.deq.size() > 3) s.deq.pop_front();\n\n      int prev = 20;\n      if(s.deq.size() > 1) prev = *(s.deq.end()-2);\n      if(dp[s.carrots][prev][s.city]) continue;\n      dp[s.carrots][prev][s.city] = true;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\t\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tdeque<int> deq = s.deq;\n\t\n\tdeq.push_back(to);\n\twhile(deq.size() > 3) deq.pop_front();\n\n\tif(deq.size()==3){\n\t  if(!check(deq,limit_rad,cities)) continue;\n\t}\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tque.push(State(to,s.carrots+1,s.remaining_distance - dist,deq));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\n// distance between (x1,y1) and (x2,y2)\ndouble cdis(double x1, double y1, double x2, double y2) {\n  return sqrtl((x1 - x2) * (x1 - x2) +\n               (y1 - y2) * (y1 - y2));\n}\n// cos a\ndouble costh(double a, double b, double c) {\n  return (b * b + c * c - a * a) / (2.0 * b * c);\n}\ndouble r, t;\nint n;\npair<double, double> c[25];\ndouble dis[25][25] = {0};\n// possible? i -> j -> k\nbool ch[25][25][25] = {0};\ndouble dp[25][25][10000] = {0};\n\nint solve();\n\nint main() {\n  cin >> n >> r >> t;\n  for(int i = 0; i < n; ++i) {\n    double x, y;\n    cin >> x >> y;\n    c[i] = make_pair(x, y);\n  }\n  for(int i = 0; i < n; ++i)\n    for(int j = i + 1; j < n; ++j)\n      dis[i][j] = dis[j][i] =\n          cdis(c[i].fi, c[i].se, c[j].fi, c[j].se);\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j)\n      for(int k = 0; k < n; ++k) {\n        if(i == j || j == k) continue;\n        double a = dis[i][k], b = dis[i][j], c = dis[j][k];\n        if(180.0 - acos(costh(a, b, c)) * 180 / M_PI <= r)\n          ch[i][j][k] = 1;\n      }\n\n  cout << solve() << endl;\n  return 0;\n}\n\nint solve() {\n  int ans = 0;\n  for(int i = 1; i < n; ++i)\n    if(dis[0][i] <= r) {\n      dp[0][i][1] = dis[0][i];\n      ans = 1;\n    }\n  if(ans == 0) return ans;\n  for(int k = 2; k <= 10000; ++k) {\n    // i -> j -> l\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < n; ++j)\n        for(int l = 0; l < n; ++l) {\n          if(i == j || j == l || (!ch[i][j][l]) ||\n             dp[i][j][k - 1] == 0 ||\n             dp[i][j][k - 1] + dis[j][l] > r)\n            continue;\n          if(dp[j][l][k] == 0) {\n            ans = k;\n            dp[j][l][k] = dp[i][j][k - 1] + dis[j][l];\n          }\n          else\n            dp[j][l][k] = min(dp[j][l][k],\n                              dp[i][j][k - 1] + dis[j][l]);\n        }\n    if(ans != k) break;\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#define scanf scanf_s\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\n\nint main(void){\n\tint n,ans,i,j,k,ok;\n\tdouble r,sit;\n\tdouble x[20];\n\tdouble y[20];\n\tdouble dp[20][20]={0};//x??????y????????????\n\tdouble dpc[20][20]={0};\n\tdouble d;\n\tdouble pi=3.141592653589793238462643383279502884197;\n\tscanf(\"%d\",&n);\n\tscanf(\"%lf %lf\",&r,&sit);\n\tsit=(sit/180)*pi;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i][j]=0;\n\t\t\tdpc[i][j]=big;\n\t\t}\n\t}\n\tfor(ans=0;;ans++){\n\t\tfor(k=0;k<n;k++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(ans!=0&&(k-i)*(i-j)==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(j-k==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(ans==0&&k!=0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td=abs(atan2(y[i]-y[k],x[i]-x[k])-atan2(y[k]-y[j],x[k]-x[j]));\n\t\t\t\t\tif(ans!=0&&min(2*pi-d,d)>sit){continue;}\n\t\t\t\t\tdpc[k][j]=min(dpc[k][j],dp[i][k]+hypot(x[k]-x[j],y[k]-y[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tdp[i][j]=dpc[i][j];\n\t\t\t\tif(dpc[i][j]<r){\n\t\t\t\t\tok=1;\n\t\t\t\t}\n\t\t\t\tdpc[i][j]=big;\n\t\t\t}\n\t\t}\n\t\tif(ok==0){break;}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define p(s) cout<<(s)<<endl;\nusing namespace std;\n\nconst int ctinf=1e5;\ndouble dp[10000][21][21];//num,prev,now = minr\n\ndouble vec_len(int x1,int x2,int y1,int y2){\n\treturn sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n}\n\nint dot_pro(int x1,int x2,int x3,int y1, int y2, int y3){\n\treturn (x2-x1)*(x3-x2)+(y2-y1)*(y3-y2);\n}\n\ndouble ctcos(int x1,int x2,int x3,int y1,int y2,int y3){\n\treturn dot_pro(x1,x2,x3,y1,y2,y3)/(vec_len(x1,x2,y1,y2)*vec_len(x2,x3,y2,y3));\n}\nint main(){\n\tint n;\n\tdouble r,theta;\n\tcin>>n>>r>>theta;\n\tREP(i,0,r) REP(j,0,21) REP(k,0,21) dp[i][j][k]=ctinf;\n\tdouble co=cos(theta*M_PI/180.0);\n\tint x[20],y[20];\n\tREP(i,0,n) cin>>x[i]>>y[i];\n\tint ans=0;\n\tREP(i,1,n) if(vec_len(x[0],x[i],y[0],y[i])<r){\n\t\tdp[1][0][i]=vec_len(x[0],x[i],y[0],y[i]);\n\t\tans=1;\n\t}\n\t//int from,to;\n\n\tREP(i,2,r){\n\t\tREP(prev,0,n){\n\t\t\tREP(now,0,n){\n\t\t\t\tREP(next,0,n){\n\t\t\t\t\tif(prev==now||prev==next||now==next) continue;\n\t\t\t\t\tif(ctcos(x[prev],x[now],x[next],y[prev],y[now],y[next])<co)continue;\n\t\t\t\t\tif(dp[i-1][prev][now]+vec_len(x[now],x[next],y[now],y[next])<=r){\n\t\t\t\t\t\tdp[i][now][next]=min(dp[i][now][next],dp[i-1][prev][now]+vec_len(x[now],x[next],y[now],y[next]));\n\t\t\t\t\t\tans=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tp(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nconst double eps = 1e-6;\nconst long double pi = 3.14159265358979323846264338327950288419716939937510L;\n\nusing Point = complex<double>;\n\nconst size_t MAX_N = 20;\nconst size_t MAX_P = MAX_N * MAX_N;\nconst size_t MAX_C = 1e4 + 10;\nconst size_t SIZE = MAX_C * (MAX_P + 2);\nconst double inf = 5e15;\ndouble dists[SIZE];\nPoint ps[MAX_N];\ndouble d_arr[MAX_N][MAX_N];\nll can_go[MAX_P];\ndouble last_d[SIZE];\n\nstruct Dist {\n    Dist() {\n        fill(dists, dists + SIZE, inf);\n        fill(last_d, last_d + SIZE, -1);\n    }\n\n    ll make_id(ll from, ll to, ll c) {\n        return c * MAX_P + from * MAX_N + to;\n    }\n\n    double get(ll from, ll to, ll c) {\n        return dists[make_id(from, to, c)];\n    }\n\n    void set(ll from, ll to, ll c, double d) {\n        dists[make_id(from, to, c)] = d;\n    }\n};\n\nusing PN = pair<double, ll>;\n\nint main() {\n    ll N;\n    cin >> N;\n    double r, th;\n    cin >> r >> th;\n    th /= 360;\n    th *= 2 * pi;\n    for (ll i = 0; i < N; i++) {\n        double x, y;\n        cin >> x >> y;\n        ps[i] = Point(x, y);\n    }\n\n    for (ll i = 0; i < N; i++) for (ll j = i + 1; j < N; j++) {\n        double dx = ps[i].real() - ps[j].real();\n        double dy = ps[i].imag() - ps[j].imag();\n        double d = sqrt(dx * dx + dy * dy);\n        d_arr[i][j] = d_arr[j][i] = d;\n    }\n\n    for (ll i = 0; i < MAX_P; i++) {\n        ll f = i / MAX_N;\n        ll t = i % MAX_N;\n        if (!(f < N && t < N)) continue;\n        for (ll j = 0; j < N; j++) {\n            if (i == j) continue;\n            Point p1 = ps[t] - ps[f];\n            Point p2 = ps[j] - ps[t];\n            double diff = abs(arg(p1) - arg(p2));\n            diff = min(diff, (double)(2 * pi - diff));\n            if (diff <= th) can_go[i] |= (1 << j);\n        }\n    }\n\n    Dist dist;\n    priority_queue<PN, V<PN>, greater<PN>> pq;\n    \n    for (ll i = 1; i < N; i++) {\n        double d = d_arr[0][i];\n        if (r < d) continue;\n        dist.set(0, i, 1, d);\n        pq.emplace(d, dist.make_id(0, i, 1));\n    }\n\n    while (pq.size()) {\n        ll from, to, p, cal, id;\n        double d;\n        {\n            ll tmp;\n            tie(d, tmp) = pq.top();\n            pq.pop();\n            cal = tmp / MAX_P;\n            p = tmp % MAX_P;\n            from = p / MAX_N;\n            to = p % MAX_N;\n            id = dist.make_id(from, to, cal);\n            if (dist.get(from, to, cal) < d) continue;\n            if (last_d[tmp] == d) continue;\n            last_d[tmp] = d;\n        }\n\n        // cout << from << \", \" << to << \", \" << cal << \", \" << d << endl << flush;\n        for (ll nxt = 0; nxt < N; nxt++) {\n            if (nxt == from || nxt == to) continue;\n            if (!(can_go[p] & (1 << nxt))) continue;\n            double nd = d + d_arr[to][nxt];\n            if (r < nd) continue;\n            if (dist.get(to, nxt, cal + 1) < nd) continue;\n            dist.set(to, nxt, cal + 1, nd);\n            pq.emplace(nd, dist.make_id(to, nxt, cal + 1));\n        }\n    }\n\n    ll ans = 0;\n    for (ll i = 0; i < N; i++) for (ll j = 0; j < N; j++) for (ll k = 0; k < MAX_C; k++) {\n        double d = dist.get(i, j, k);\n        if (r < d) continue;\n        chmax(ans, k);\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n\treturn isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n\treturn isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n\treturn isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n\treturn distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n\treturn distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n\treturn isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n\treturn intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n\treturn isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n\treturn intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n\tint n = g.size();\n\tbool x = false;\n\trep(i,n){\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n\t\tif( a.imag() > b.imag() ) swap(a, b);\n\t\tif( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n\t}\n\treturn ( x ? IN : OUT );\n}\n\n//??§?????????????????°????????????\ndouble radianToDegree(double rad){\n\treturn 180 * rad / M_PI;\n}\n\n//?????°??????????????§????????????\ndouble degreeToRadian(double deg){\n\treturn M_PI * deg / 180;\n}\n\n//2???????????????????????????????§????????±???????\ndouble angleOf2Vector(Vector a, Vector b){\n\treturn acos( dot(a,b) / (abs(a) * abs(b)) );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n\tPolygon u;\n\tif( s.size() < 3 ) return s;\n\tsort(s.begin(), s.end());\n\n\trange(i,0,s.size()){\n\t\t//== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n\t\t//!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.emplace_back(s[i]);\n\t}\n\n\tfor(int i = s.size() - 2; i >= 0; i--){\n\t\t//????????? == ??¨ != ????????´??????\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.emplace_back(s[i]);\n\t}\n\n\treverse(u.begin(), u.end());\n\tu.pop_back();\n\n\t//?????????????????????????????§??????????????????????????????????¨??????????????????????\n\t/*\n\t   int i = 0;\n\t   while(i < u.size() - 1){\n\t   if(u[i].imag() > u[i + 1].imag()){\n\t   u.emplace_back(u[i]);\n\t   u.erase(u.begin());\n\t   continue;\n\t   }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n\t   u.emplace_back(u[i]);\n\t   u.erase(u.begin());\n\t   continue;\n\t   }\n\t   break;\n\t   }\n\t   */\n\n\treturn u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n\tPolygon s = convexHull(p);\n\tint n = s.size();\n\n\tif(n == 2) return abs(s[1] - s[0]);\n\n\tint i = 0, j = 0;\n\trep(k,n){\n\t\tif(not (s[i] < s[k])) i = k;\n\t\tif(s[j] < s[k]) j = k;\n\t}\n\n\tdouble ret = 0.0;\n\tint is = i, js = j;\n\n\twhile(i != js || j != is){\n\t\tret = max(ret, abs(s[i] - s[j]));\n\t\tif(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n\t\t\ti = (i + 1) % n;\n\t\t}else{\n\t\t\tj = (j + 1) % n;\n\t\t}\n\t}\n\treturn ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n\tdouble A = cross(a.p2 - a.p1, b.p2 - b.p1);\n\tdouble B = cross(a.p2 - a.p1, a.p2 - b.p1);\n\tif(abs(A) < EPS && abs(B) < EPS) return b.p1;\n\treturn b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\trep(i,p.size()){\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tq.emplace_back(getCrossPointLL(Line{a, b}, l));\n\t\t}\n\t}\n\treturn q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n\tdouble w, x, y, z;\n\tw = b.real()-a.real();\n\tx = b.imag()-a.imag();\n\ty = c.real()-a.real();\n\tz = c.imag()-a.imag();\n\treturn abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n\tint n = g.size();\n\tdouble ret = 0.0;\n\trep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n\treturn abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n\tint n = g.size();\n\trep(i,n){\n\t\tif(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n\t}\n\treturn true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n\tint cnt = 0;\n\trep(i,p.size()){\n\t\tif(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n\t}\n\treturn cnt / 2 + 1;\n}\n\n//????§???¢??????????±???¨??????????????§?¨?\nPoint pointSymmetry(Polygon g){\n\tint size = g.size() / 2;\n\tif(g.size() % 2) return Point{INF,INF};\n\n\tset<Point> s;\n\trep(i,size){\n\t\trep(j,size){\n\t\t\tif(i == j) continue;\n\t\t\ts.insert(intersectionLs(g[i], g[i + size], g[j], g[j + size]));\n\t\t}\n\t}\n\tif(s.size() > 1) return Point{INF,INF};\n\treturn *s.begin();\n}\n\nstruct Edge{\n\tint to;\n\tdouble dis;\n\tEdge(int to, double dis) : to(to), dis(dis) {}\n};\nmap<pair<int,int>, vector<Edge>> e;\n\nvector<double> loop_cost;\nvector<int> loop_cnt;\nvector<pair<int, int>> loop_v;\n\nint bfs(int n, int s, double r, bool f = 0){\n\tint dis[20][20] = {{0}};\n\tint cnt[20][20] = {{0}};\n\n\ttypedef pair<double,pair<int, int>> P; //cost, prev, next\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\n\tif(f){\n\t\tq.push(make_pair(0, loop_v[s]));\n\t\tdis[loop_v[s].first][loop_v[s].second] = -1;\n\t}else{\n\t\tq.push(make_pair(0,make_pair(s,s)));\n\t\tdis[s][s] = -1;\n\t}\n\twhile(not q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\tdouble cost = p.first;\n\t\tint prev = p.second.first;\n\t\tint cur = p.second.second;\n\t\tfor(auto to : e[make_pair(prev, cur)]){\n\t\t\tif(to.dis == 0) continue;\n\t\t\tif(dis[cur][to.to] == 0 && cost + to.dis <= r){\n\t\t\t\tdis[cur][to.to] = cost + to.dis;\n\t\t\t\tcnt[cur][to.to] = cnt[prev][cur] + 1;\n\t\t\t\tq.push(make_pair(cost + to.dis, make_pair(cur, to.to)));\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxi = 0;\n\trep(i,n) {\n\t\trep(j,n){\n\t\t\tmaxi = max(maxi, cnt[i][j]);\n\t\t}\n\t}\n\treturn maxi;\n}\n\nvoid dfs(int prev, int cur, double len, int cnt, double r, double dis[20][20], int sum[20][20]){\n\tif(len > r) return;\n\tdis[prev][cur] = len;\n\tsum[prev][cur] = cnt;\n\tfor(auto to : e[make_pair(prev, cur)]){\n\t\tif(dis[cur][to.to] == -1){\n\t\t\tdfs(cur, to.to, len + to.dis, cnt + 1, r,dis, sum);\n\t\t}else{\n\t\t\tlen += to.dis;\n\t\t\tcnt++;\n\t\t\tloop_cost.emplace_back(len - dis[cur][to.to]);\n\t\t\tloop_cnt.emplace_back(cnt - sum[cur][to.to]);\n\t\t\tloop_v.emplace_back(prev, cur);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tdouble r, theta;\n\tcin >> r >> theta;\n\n\tPoint p[20];\n\trep(i,n){\n\t\tdouble a, b;\n\t\tcin >> a >> b;\n\t\tp[i] = Point{a,b};\n\t}\n\n\trep(i,n){\n\t\trep(j,n){\n\t\t\te[make_pair(i,i)].emplace_back(Edge{j,abs(p[j] - p[i])});\n\t\t\trep(k,n){\n\t\t\t\tif(i == j || j == k || k == i) continue;\n\t\t\t\tif(radianToDegree(angleOf2Vector(p[j] - p[i], p[k] - p[j])) <= theta){\n\t\t\t\t\te[make_pair(i,j)].emplace_back(Edge{k, abs(p[j] - p[k])});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//rep(i,n){\n\t//\trep(j,n){\n\t//\t\tfor(auto k : e[make_pair(i,j)]){\n\t//\t\t\tcout << k.to << ' ' << k.dis << endl;\n\t//\t\t}\n\t//\t}\n\t//}\n\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tdouble dis[20][20] = {{0}};\n\t\t\tint cnt[20][20] = {{0}};\n\t\t\trep(x,n) rep(y,n) dis[x][y] = -1;\n\t\t\tdfs(i,j,0,0,r,dis,cnt);\n\t\t}\n\t}\n\n\t//int maxi = 0; rep(i,n){ maxi = max(maxi, bfs(n,i,sum)); } cout << maxi << endl; return 0;\n\n\tint maxi = 0;\n\tif(loop_cost.size() == 0){\n\t\trep(i,n){\n\t\t\tmaxi = max(maxi, bfs(n,i,r));\n\t\t}\n\t}else{\n\t\trep(i,loop_cost.size()){\n\t\t\tif(loop_cost[i] < EPS) continue;\n\t\t\tdouble cp = r;\n\t\t\tint d = cp / loop_cost[i];\n\t\t\tint sum = d * loop_cnt[i];\n\t\t\tcp -= d * loop_cost[i];\n\t\t\t//show(sum)\n\t\t\t//show(cp)\n\t\t\tsum += bfs(n,i,cp,1);\n\t\t\tmaxi = max(maxi, sum);\n\t\t}\n\t}\n\tcout << maxi << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 20;\nconst double INF = -1.0;\n\nint n;\ndouble r, s, e[N][N][N], d[N][N][10005], t, dist;\nP a, b;\nvector<P> in;\n\nmain(){\n  cin >> n >> r >> s;\n  s *= M_PI / 180.0;\n  for(int i=0;i<n;i++){\n    cin >> a.real() >> a.imag();\n    in.push_back(a);\n  }\n  fill(e[0][0], e[N][0], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i == j) continue;\n      for(int k=0;k<n;k++){\n        if(j == k) continue;\n        a = in[i] - in[j];\n        b = in[k] - in[j];\n        t = acos(real(conj(a) * b) / (abs(a) * abs(b)));\n        if(M_PI - t <= s) e[i][j][k] = abs(b);\n      }\n    }\n  }\n  fill(d[0][0], d[N][0], -1.0);\n  int ans = 0;\n  for(int i=1;i<n;i++){\n    if(abs(in[0] - in[1]) <= r){\n      d[0][i][1] = abs(in[0] - in[i]);\n      ans = 1;\n    }\n  }\n  for(int k=1;(double)k<r+1;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(d[i][j][k] < 0.0) continue;\n        ans = max(ans, k);\n        for(int l=0;l<n;l++){\n          if(e[i][j][l] < 0.0) continue;\n          dist = d[i][j][k] + e[i][j][l];\n          if(dist > r) continue;\n          if(d[j][l][k+1] < 0.0) d[j][l][k+1] = dist;\n          else if(d[j][l][k+1] > dist) d[j][l][k+1] = dist;\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntypedef long double D;\nconst D eps = 1e-10;\nconst D pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\nD dist[20][20];\n\nbool ok[20][20][20];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tD r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,n)rep(j,n){\n\t\tint dx=(x[i]-x[j]);\n\t\tint dy=(y[i]-y[j]);\n\t\tdist[i][j]=sqrt(1.0*dx*dx+1.0*dy*dy);\n\t}\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\trange(cp,1,n) dp[1][cp][0]=dist[cp][0];\n\n\trep(pp,n)rep(cp,n)rep(np,n){\n\t\tif(pp==cp) continue;\n\t\tif(cp==np) continue;\n\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\tD dot=1.0*cx*nx+1.0*cy*ny;\n\t\tdot/=(dist[cp][pp]*dist[np][cp]);\n\t\tdot=max<D>(-1,dot);\n\t\tdot=min<D>(1,dot);\n\t\tD angle=acos(dot);\n\t\tangle*=180.0/pi;\n\t\tif(angle>180.0) angle=360.0-angle;\n\t\tif(angle<=theta) ok[pp][cp][np]=true;\n\t}\n\n\tint ans=1;\n\trep(i,limit)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tD add=dist[cp][np];\n\t\t\tif(dp[i][cp][pp]+add>r) continue;\n\t\t\tif(ok[pp][cp][np]==false) continue;\n\t\t\tdp[i+1][np][cp]=min<D>(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t\tans=max(ans,i+1);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n \nInt INF = 1e18;\ndouble EPS = 1e-10;\nint inf = 1e9;\nInt mod = 1e9+7;\n\nInt n;\ndouble r, theta;\ncomplex<double> p[20];\n\nInt ma;\ndouble dp[20][20][10001];\n\n// void f(Int s, Int t, double d, Int cnt) {\n//     ma = max(ma, cnt);\n//     for (Int i = 0; i < n; i++) {\n//         if (i == s or i == t) continue;\n//         complex<double> st = p[t] - p[s];\n//         complex<double> tr = p[i] - p[t];\n//         double t1 = max(arg(st), arg(tr));\n//         double t2 = min(arg(st), arg(tr));\n//         double tt = min(t1 - t2, 2.0 * M_PI - (t1 - t2));\n//         double dd = d + abs(p[i] - p[t]);\n//         if (dd <= r and 0 < tt and tt <= theta and dd < dp[t][i][cnt + 1]) {\n//             dp[t][i][cnt + 1] = dd;\n//             f(t, i, dd, cnt + 1);\n//         }\n//     }\n// }\n\nint main() {\n    cin >> n >> r >> theta;\n    theta = theta * M_PI / 180.0;\n    for (Int i = 0; i < n; i++) {\n        double a, b;\n        cin >> a >> b;\n        p[i].real(a);\n        p[i].imag(b);\n    }\n    for (Int i = 0; i < 20; i++) {\n        for (Int j = 0; j < 20; j++) {\n            for (Int k = 0; k <= 10000; k++) {\n                dp[i][j][k] = inf;\n            }\n        }\n    }\n    queue<tuple<Int, Int, Int>> q;\n    for (Int i = 1; i < n; i++) {\n        if (abs(p[0] - p[i]) > r) continue;\n        q.push(make_tuple(0, i, 1));\n        dp[0][i][1] = abs(p[0] - p[i]);\n    }\n    vector<Int> v[20][20];\n    for (Int i = 0; i < n; i++) {\n        for (Int j = 0; j < n; j++) {\n            for (Int k = 0; k < n; k++) {\n                if (i == j or j == k or k == i) continue;\n                complex<double> st = p[j] - p[i];\n                complex<double> tr = p[k] - p[j];\n                double t1 = max(arg(st), arg(tr));\n                double t2 = min(arg(st), arg(tr));\n                double tt = min(t1 - t2, 2.0 * M_PI - (t1 - t2));\n                if (0 - EPS < tt and tt <= theta + EPS) {\n                    v[i][j].push_back(k);\n                }\n            }\n        }\n    }\n    while (not q.empty()) {\n        tuple<Int, Int, Int> x = q.front();\n        Int s = get<0>(x);\n        Int t = get<1>(x);\n        Int u = get<2>(x);\n        q.pop();\n        ma = max(ma, u);\n        for (Int i = 0; i < (Int)v[s][t].size(); i++) {\n            double dd = dp[s][t][u] + abs(p[v[s][t][i]] - p[t]);\n            if (dd <= r + EPS and dd < dp[t][v[s][t][i]][u + 1]) {\n                dp[t][v[s][t][i]][u + 1] = dd;\n                //f(t, i, dd, cnt + 1);\n                q.push(make_tuple(t, v[s][t][i], u + 1));\n            }\n        }\n    }\n    dump(ma);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<  vector<float>  > vvd;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef complex<float> zahyo;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nzahyo toshi[21];\nbool kakdotest(zahyo a,zahyo b,float kakdo){\n\n  float kak= (a.real()*b.real()+a.imag()*b.imag())/  (abs(a)*abs(b));\n  if (cos(kakdo*3.14159265/180.0)<=kak)\n    return true;\n  else return false;\n}\nint main(){\n  int n,k;\n  float r,kakdo,xza,yza;\n  cin>>n>>r>>kakdo;\n  for(int i=1;i<=n;i++){\n    cin>>xza>>yza;\n    toshi[i]=zahyo(xza,yza);\n  }\n  vvd nokori(n+1);\n  for(int i=0;i<n+1;i++){\n    nokori[i]=vector<float>(21,-1);\n  }\n  vvd prevnokori=nokori;\n  for(int i=2;i<n+1;i++){\n    prevnokori[1][i]=r-abs(toshi[i]-toshi[1]);\n  }\n  int maxcarrot=0;\n  k=1;\n  while(k-maxcarrot==1){\n    vvd nextnokori=nokori;  \n    for(int i=1;i<(n+1);i++)\n      for(int j=1;j<(n+1);j++){\n\tif(i==j) continue;\n\tif(prevnokori[i][j]<0) continue;\n\tmaxcarrot=k;\n\t//\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<abs(prevnokori[i][j])<<endl;\n\tfor(int l=1;l<(n+1);l++){\n\t  if(kakdotest(toshi[i]-toshi[j],\n\t\t       toshi[j]-toshi[l],kakdo)){\n\t    nextnokori[j][l]=\n\t      max(prevnokori[i][j]-abs(toshi[j]-toshi[l]),\n\t\t\t\t nextnokori[j][l]);\n\t    //\t    cout<<i<<\" \"<<j<<\" \"<<l<<endl;\n\t  }\n\t}\n\n      }\n    prevnokori=nextnokori;\n    k++;\n  }\n  cout<<maxcarrot<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef double R;\ntypedef complex<R> P;\nconst R PI = 3.1415926535897932384626;\n\nistream& operator>>(istream &is, P &p) {\n\tR x, y;\n\tis >> x >> y;\n\tp = P(x, y);\n\treturn is;\n}\n\nint n;\ndouble r, theta;\n\ndouble dp[401][10005];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> r >> theta; theta = theta/180.*PI;\n\tvector<P> p(n);\n\tREP(i, n) cin >> p[i];\n\tvector<vector<pair<int, double>>> g(n*n);\n\tREP(i, n)REP(j, n)REP(k, n){\n\t\tif(i==k || i==j || j==k) continue;\n\t\tif(abs(arg((p[j]-p[i]) / (p[k]-p[j]))) < theta){\n\t\t\tg[j*n+i].emplace_back(k*n+j, abs(p[k]-p[j]));\n\t\t}\n\t}\n\tREPS(j, n)if(abs(p[0]-p[j]) < r) dp[j*n][1] = abs(p[0]-p[j]);\n\tint ans = 0;\n\twhile(++ans){\n\t\tint f = 0;\n\t\tREP(i, n*n)if(dp[i][ans] != 0){\n\t\t\tf = 1;\n\t\t\tauto &t = dp[i][ans];\n\t\t\tFOR(it, g[i]) if(t + it->second < r){\n\t\t\t\tif(dp[it->first][ans+1] > t + it->second || dp[it->first][ans+1] == 0)\n\t\t\t\tdp[it->first][ans+1] = t + it->second;\n\t\t\t}\n\t\t}\n\t\tif(!f) break;\n\t}\n\tcout << ans - 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\n\nusing Point = complex<double>;\n\ndouble angle(Point p1, Point p2) {\n    double prod = p1.real() * p2.real() + p1.imag() * p2.imag();\n    return acos(prod / (abs(p1) * abs(p2))) / (2*M_PI) * 360;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n; cin >> n;\n    double r, theta; cin >> r >> theta;\n\n    vector<Point> points(n);\n    for (int i = 0; i < n; ++i) {\n        double x, y; cin >> x >> y;\n        points[i] = {x, y};\n    }\n\n    const double INF = numeric_limits<double>::max();\n    auto d = make_vector<double>(n, n, r+1, INF);\n    for (int v = 1; v < n; ++v) {\n        d[v][0][1] = abs(points[v] - points[0]);\n    }\n\n    auto valid = make_v<bool>(n, n, n);\n    for (int v = 0; v < n; ++v) {\n        for (int p = 0; p < n; ++p) if (p != v) {\n            for (int u = 0; u < n; ++u) if (u != v) {\n                valid[v][p][u] = angle(points[u] - points[v], points[v] - points[p]) < theta;\n            }\n        }\n    }\n\n    for (int k = 1; k < r; ++k) {\n        for (int v = 0; v < n; ++v) {\n            for (int p = 0; p < n; ++p) if (p != v) if (d[v][p][k] != INF) {\n                for (int u = 0; u < n; ++u) if (u != v) if (valid[v][p][u]) {\n                    chmin(d[u][v][k+1], d[v][p][k] + abs(points[u] - points[v]));\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int k = r; k >= 1; --k)\n    {\n        for (int v = 0; v < n; ++v) {\n            for (int u = 0; u < n; ++u) {\n                if (d[v][u][k] < r) {\n                    ans = k;\n                }\n            }\n        }\n        if (ans != 0) {\n            break;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> dst = cities[city];\n\n  src -= cities[prev];\n  dst -= cities[prev];\n  double computed_arg = abs(arg(src) - arg(dst));\n\n  return (limit_rad >= M_PI - min(computed_arg,\n\t\t\t\t  abs(2.0*M_PI - computed_arg)) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\nbool isok[21][21][21]; //cur,prev,old\ndouble city_distance[21][21];\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    memset(isok,true,sizeof(isok));\n    for(int old = 0; old < total_cities; old++){\n      for(int prev = 0; prev < total_cities; prev++){\n\tfor(int cur = 0; cur < total_cities; cur++){\n\t  isok[cur][prev][old] = check(cur,prev,old,limit_rad,cities);\n\t  city_distance[cur][prev] = abs(cities[cur] - cities[prev]);\n\t}\n      }\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      double dist;\n      int next_city,next_prev,next_old;\n      for(int to=0;to<total_cities;to++){\n\tif(to == s.city) continue;\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tnext_city = to;\n\tnext_prev = s.city;\n\tnext_old = s.prev;\n\tif(!isok[next_city][next_prev][next_old]) continue;\n\tif(dp[s.carrots+1][s.city][to] >= s.remaining_distance - city_distance[next_city][next_prev] - EPS) continue;\n\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - city_distance[next_city][next_prev]));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\ndouble dp[20][20][2];\n\nvector<pair<int, double> > G[20][20];\nint x[20], y[20];\n\nmain(){\n  int n;\n  double r, th;\n  cin >> n >> r >> th;\n  for(int i = 0; i < n; ++i)\n    cin >> x[i] >> y[i];\n\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      if(i == j) continue;\n      int ax = x[j] - x[i];\n      int ay = y[j] - y[i];\n      for(int k = 0; k < n; ++k){\n        if(k == j) continue;\n        int bx = x[k] - x[j];\n        int by = y[k] - y[j];\n        double ac = (ax*bx + ay*by);\n        ac /= sqrt(ax*ax+ay*ay);\n        ac /= sqrt(bx*bx+by*by);\n        if(acos(-1)*th/180 >= acos(ac))\n          G[i][j].push_back({k,sqrt(bx*bx+by*by)});\n      }\n    }\n  }\n\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j){\n      dp[i][j][0] = dp[i][j][1] = r+200;\n    }\n\n  int ans = 0;\n  for(int i = 1; i < n; ++i){\n    int ax = x[i] - x[0];\n    int ay = y[i] - y[0];\n    if(ax*ax+ay*ay <= r*r){\n      dp[0][i][0] = sqrt(ax*ax+ay*ay);\n      ans = 1;\n    }\n  }\n  \n  while(ans){\n    bool end = true;\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < n; ++j){\n        dp[i][j][ans&1] = r*2+200;\n      }\n\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < n; ++j){\n        if(dp[i][j][~ans&1] < r){\n          for(auto& e : G[i][j])\n            if(dp[i][j][~ans&1]+e.second < r){\n              end = false;\n              dp[j][e.first][ans&1] =\n                min(dp[j][e.first][ans&1],\n                    dp[i][j][~ans&1]+e.second);\n            }\n        }\n      }\n    \n    if(end) break;\n    ++ans;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int MAX = 20,LIMIT = 15000,IINF = INT_MAX;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg2 - arg1 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nstruct Edge{\n  int to;\n  double weight;\n  Edge(int to=0,double weight=0):to(to),weight(weight){}\n};\n\nstruct Data{\n  int prev,cur,carrot;\n  double dist;\n  Data(int prev=0,int cur=0,int carrot=0,double dist=0):prev(prev),cur(cur),carrot(carrot),dist(dist){}\n  bool operator < (const Data& data) const{ return dist > data.dist; }\n};\n\nint n;\ndouble r,theta,mindist[MAX][MAX][LIMIT]; // mindist[cur][prev][the number of carrot]\nPoint ps[MAX];\nvector<Edge> edge[MAX][MAX]; // edge[cur][prev]\n\ninline void dijkstra(){\n  rep(i,n)rep(j,n)rep(k,LIMIT) mindist[i][j][k] = IINF;\n  priority_queue<Data> Q;\n\n  REP(i,1,n) {\n    double dist = abs(ps[0]-ps[i]);\n    if( !equals(dist,r) && dist > r ) continue;\n    Q.push(Data(0,i,1,dist));\n    mindist[i][0][1] = dist;\n  }\n  int ans = (Q.empty()?0:1);\n\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n    int prev = data.prev, cur = data.cur, carrot = data.carrot;\n    double dist = data.dist;\n\n    if( !equals(mindist[cur][prev][carrot],dist) && mindist[cur][prev][carrot] < dist ) continue;\n\n    rep(i,edge[cur][prev].size()) {\n      int next = edge[cur][prev][i].to;\n      double weight = edge[cur][prev][i].weight;\n\n      if( !equals(r,dist+weight) && r < dist+weight ) continue;\n\n      if( mindist[next][cur][carrot+1] > dist + weight ){\n        mindist[next][cur][carrot+1] = dist + weight;\n        ans = max(ans,carrot+1);\n        Q.push(Data(cur,next,carrot+1,dist+weight));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\ninline void makeEdge(){\n  rep(prev,n){\n    rep(cur,n){\n      if( cur == prev ) continue;\n      rep(next,n){\n        if( next == cur || next == prev ) continue;\n        double dist = abs(ps[cur]-ps[next]);\n        if( !equals(dist,r) && dist > r ) continue;\n        Vector v1 = ( ps[next] - ps[cur] ) - ps[prev];\n        Vector v2 = ps[cur]  - ps[prev];\n        if( equals(cross(v1,v2),0.0) ) continue;\n        double arg = getArg(ps[prev],ps[cur],ps[next]);\n        if( equals(arg,theta) || arg < theta ) edge[cur][prev].push_back(Edge(next,dist));\n      }\n    }\n  }\n}\n\nint main(){\n\n  cin >> n;\n  cin >> r >> theta;\n  theta = toRad(theta);\n  rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n  makeEdge();\n\n  dijkstra();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> dst = cities[city];\n\n  src -= cities[prev];\n  dst -= cities[prev];\n  double computed_arg = abs(arg(src) - arg(dst));\n\n  return (limit_rad >= M_PI - min(computed_arg,\n\t\t\t\t  abs(2.0*M_PI - computed_arg)) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\nbool isok[21][21][21]; //cur,prev,old\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    memset(isok,true,sizeof(isok));\n    for(int old = 0; old < total_cities; old++){\n      for(int prev = 0; prev < total_cities; prev++){\n\tfor(int cur = 0; cur < total_cities; cur++){\n\t  isok[cur][prev][old] = check(cur,prev,old,limit_rad,cities);\n\t}\n      }\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      double dist;\n      int next_city,next_prev,next_old;\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tnext_city = to;\n\tnext_prev = s.city;\n\tnext_old = s.prev;\n\tif(!isok[next_city][next_prev][next_old]) continue;\n\tif(dp[s.carrots+1][s.city][to] >= s.remaining_distance - dist - EPS) continue;\n\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n#define LT(x,y) ((x)-(y)<=-EPS)\n\ndouble dot(P a, P b) {\n\treturn a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble angle_ls(P a, P b, P c) {\n\tP v1 = b-a, v2 = c-b;\n\treturn acos(dot(v1, v2)/(abs(v1)*abs(v2)));\n}\n\ndouble to_radian(double degree) {\n\treturn degree*PI/180;\n}\n\ndouble to_degree(double radian) {\n\treturn radian*180/PI;\n}\n\nint main() {\n\tint n;\n\tdouble r, t;\n\tcin >> n >> r >> t;\n\n\tvector<P> pts(n);\n\tREP(i, n) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpts[i] = P(x, y);\n\t}\n\n\tvector<vvd> dist(n, vvd(n, vd(n, INF)));\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tif(i == j) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP(k, n) {\n\t\t\t\tif(i == k || j == k) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble angle = to_degree(angle_ls(pts[i], pts[j], pts[k]));\n\t\t\t\tif(LT(angle, t)) {\n\t\t\t\t\tdist[i][j][k] = abs(pts[k]-pts[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vvd> dp(10000+1, vvd(n, vd(n, INF)));\n\tint ans = 0;\n\tFOR(i, 1, n-1) {\n\t\tdouble d = abs(pts[i]-pts[0]);\n\t\tif(LT(d, r)) {\n\t\t\tdp[1][0][i] = d;\n\t\t\tans = 1;\n\t\t}\n\t}\n\n\tFOR(c, 2, 10000) {\n\t\tbool updated = false;\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tdouble d = dp[c-1][i][j];\n\t\t\t\tif(EQ(d, INF)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tdouble nd = d + dist[i][j][k];\n\t\t\t\t\tif(LT(nd, r) && LT(nd, dp[c][j][k])) {\n\t\t\t\t\t\tans = c;\n\t\t\t\t\t\tdp[c][j][k] = nd;\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!updated) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\n\nint n;\ndouble r,d;\nP p[20];\ndouble dp[10001][20][20];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint main(){\n  cin>>n>>r>>d;\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)dp[i][j][k]=1e9;\n  dp[0][0][0]=0;\n\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tfor(int l=0;l<n;l++)\n\t  if(check(j,k,l))\n\t    dp[i+1][k][l]=min(dp[i+1][k][l],dp[i][j][k]+abs(p[k]-p[l]));\n\n  int ans=0;\n  for(int i=1;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tif(dp[i][j][k]<=r)ans=i;\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> Pi;\ntypedef pair<double,int> Pd;\ntypedef pair<Pd,Pi> S;\n\nint n;\ndouble r,d;\nP p[20];\ndouble dp[20][20][10001],ab[20][20];\nint ck[20][20][20];\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint cal(){\n  priority_queue<S,vector<S>,greater<S> > Q;\n  int ans=0;\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)dp[j][k][i]=1e9;\n  dp[0][0][0]=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++)ck[i][j][k]=check(i,j,k);\n      ab[i][j]=abs(p[i]-p[j]);\n    }\n  Q.push(S(Pd(0,0),Pi(0,0)));\n  while(!Q.empty()){\n    double cs=Q.top().first.first;\n    int i=Q.top().first.second;\n    int j=Q.top().second.first;\n    int k=Q.top().second.second;\n    Q.pop();\n    if(dp[j][k][i]<cs)continue;\n    if(cs>r)return ans;\n    for(int l=0;l<n;l++){\n      double ncs=cs+ab[k][l];\n      if(ck[j][k][l]&&ncs<=r){\n\tif(dp[k][l][i+1]>ncs){\n\t  Q.push(S(Pd(cs+ab[k][l],i+1),Pi(k,l)));\n\t  dp[k][l][i+1]=ncs;\n\t}\n      }\n    }\n    ans=max(ans,i);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n>>r>>d;\n  double a,b;\n  for(int i=0;i<n;i++)cin>>a>>b,p[i]=P(a,b);\n  cout<<cal()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2233&lang=jp\ntypedef long long ll;\ntypedef long double ld;\n#define INF 1<<30\n#define LINF 1<<60\nconst double eps = 1e-9;\n\ninline double calc_w(int c1,int pre_c1, int c2,int pre_c2, vector<pair<int, int>>& city) {\n\tdouble l1_x = city[c1].first - city[pre_c1].first;\n\tdouble l1_y = city[c1].second - city[pre_c1].second;\n\n\tdouble l2_x = city[c2].first - city[pre_c2].first;\n\tdouble l2_y = city[c2].second - city[pre_c2].second;\n\n\tdouble _cos = (l1_x*l2_x + l1_y*l2_y) / (double)(hypot(l1_x, l1_y)*hypot(l2_x, l2_y));\n\tif (1 - _cos < eps)return 0.0;\n\tif (1 + _cos < eps)return 180.0;\n\treturn abs(acos(_cos) * 180 / acos(-1));\n}\n\nstruct edge {\n\tint now_city;\n\tint pre_city;\n\tint have_carrot;\n\tdouble full_len;\n\tedge() {}\n\tedge(int now, int pre,int car, double len) :now_city(now), pre_city(pre),have_carrot(car),full_len(len) {}\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t/* input */\n\tint n; cin >> n;\n\tdouble r, theta; cin >> r >> theta;\n\tvector<pair<int, int>> city(n);\n\tfor (int i = 0; i < n;i++) { int x, y; cin >> x >> y; city[i] = { x,y }; }\n\n\t/* initialize */\n\tvector<vector<double>> dist(n, vector<double>(n,0));\n\tvector<vector<vector<int>>> G(n, vector<vector<int>>(n));\n\tvector<vector<vector<double>>> dp(n, vector<vector<double>>(n, vector<double>(10010, 0)));\n\n\tint ans = 0;\n\tqueue<edge> q;\n\tfor (int i = 0; i < n;i++) {\n\t\tfor (int j = i + 1; j < n;j++) {\n\t\t\tdouble d = hypot(city[i].first - city[j].first, city[i].second - city[j].second);\n\t\t\tdist[i][j] = dist[j][i] = d;\n\t\t\tif ((i == 0) && (d <= r)) {\n\t\t\t\tdp[j][i][1] = d;\n\t\t\t\tq.push(edge(j, i, 1, d));\n\t\t\t\tans = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n;i++) {\n\t\tfor (int j = 0; j < n;j++) {\n\t\t\tfor (int k = 0; k < n;k++) {\n\t\t\t\tif (i == j || j == k || i == k)continue;\n\t\t\t\tif (calc_w(j, i, k, j, city) < theta + eps) G[j][i].push_back(k);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!q.empty()) {\n\t\tauto p = q.front(); q.pop();\n\t\tint now_city = p.now_city, pre_city = p.pre_city;\n\t\tint have_carrot = p.have_carrot;\n\t\tdouble len = p.full_len;\n\t\tif (len > dp[now_city][pre_city][have_carrot]) continue;\n\t\tfor (int next_city : G[now_city][pre_city]) {\n\t\t\tif (next_city == now_city || next_city == pre_city)continue;\n\t\t\tif (dist[now_city][next_city] + len < r + eps) {\n\t\t\t\tif (dp[next_city][now_city][have_carrot + 1] < len + dist[next_city][now_city]) {\n\t\t\t\t\tdp[next_city][now_city][have_carrot + 1] = len + dist[next_city][now_city];\n\t\t\t\t\tq.push(edge(next_city, now_city, have_carrot + 1, dist[next_city][now_city] + len));\n\t\t\t\t\tans = max(ans, have_carrot + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<  vector<double>  > vvd;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef complex<double> zahyo;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nzahyo toshi[21];\nbool kakdotest(zahyo a,zahyo b,double kakdo){\n\n  double kak= (a.real()*b.real()+a.imag()*b.imag())/  (abs(a)*abs(b));\n  if (cos(kakdo)<=kak)\n    return true;\n  else return false;\n}\nint main(){\n  int n,k;\n  double r,kakdo,xza,yza;\n  cin>>n>>r>>kakdo;\n  for(int i=1;i<=n;i++){\n    cin>>xza>>yza;\n    toshi[i]=zahyo(xza,yza);\n  }\n  vvd nokori(n+1);\n  for(int i=0;i<n+1;i++){\n    nokori[i]=vector<double>(21,-1);\n  }\n  vvd prevnokori=nokori;\n  for(int i=2;i<n+1;i++){\n    prevnokori[1][i]=r-abs(toshi[i]-toshi[1]);\n  }\n  int maxcarrot=0;\n  k=1;\n  while(k-maxcarrot==1){\n    vvd nextnokori=nokori;  \n    for(int i=1;i<(n+1);i++)\n      for(int j=1;j<(n+1);j++){\n\tif(i==j) continue;\n\tif(prevnokori[i][j]<0) continue;\n\tmaxcarrot=k;\n\t//\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<abs(prevnokori[i][j])<<endl;\n\tfor(int l=1;l<(n+1);l++){\n\t  if(kakdotest(toshi[i]-toshi[j],\n\t\t       toshi[j]-toshi[l],kakdo)){\n\t    nextnokori[j][l]=\n\t      max(prevnokori[i][j]-abs(toshi[j]-toshi[l]),\n\t\t\t\t nextnokori[j][l]);\n\t   \n\t  }\n\t}\n\n      }\n    prevnokori=nextnokori;\n    k++;\n  }\n  cout<<maxcarrot<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 20\n#define MAX_C 10001\n#define INF 1e9\n#define EPS 1e-9\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n#define le(a,b) (equal(a,b) || lt(a,b))\n#define PI acos(-1)\n \nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n   \n  Point operator + (const Point &p)const{\n    return Point(x+p.x,y+p.y);\n  }\n  Point operator - (const Point &p)const{\n    return Point(x-p.x,y-p.y);\n  }\n  Point operator * (double k)const{\n    return Point(x*k,y*k);\n  }\n};\n \nistream &operator >> (istream &is,Point &p){\n  return is >> p.x >> p.y;\n}\n \nstruct State{\n  double d;\n  int v,p,c;\n   \n  State(double d,int v,int p,int c) : \n    d(d),v(v),p(p),c(c) {}\n   \n  bool operator < (const State &s)const{\n    return d > s.d;\n  }\n};\n \ndouble dot(const Point &a,const Point &b){\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble norm(const Point &p){\n  return dot(p,p);\n}\n \ndouble abs(const Point &p){\n  return sqrt(norm(p));\n}\n \ntypedef Point Vector;\n \ninline double getAngle(const Vector &a,const Vector &b){\n  return acos(dot(a,b)/abs(a)/abs(b))*180/PI;\n}\n \ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nint N;\ndouble r,th,d2[MAX_N][MAX_N];\nbool can[MAX_N][MAX_N][MAX_N];\ndouble d[MAX_N][MAX_N][MAX_C];\n \nint solve(const vector<Point> &vec){\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < N ; j++){\n      for(int k = 0 ; k < MAX_C ; k++){\n        d[i][j][k] = INF;\n      }\n    }\n  }\n  priority_queue<State> Q;\n  for(int i = 1 ; i < N ; i++){\n    Q.push(State(dist(vec[0],vec[i]),i,0,1));\n    d[i][0][1] = dist(vec[0],vec[i]);\n  }\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v,p = s.p,c = s.c;\n    if(lt(d[v][p][c],s.d)){ continue; }\n    if(lt(r,s.d)){ continue; }\n    for(int i = 0 ; i < N ; i++){\n      if(i == v || i == p){ continue; }\n      if(!can[p][v][i]){ continue; }\n      if(c+1 < MAX_C && lt(d[v][p][c]+d2[v][i],d[i][v][c+1])){\n        d[i][v][c+1] = d[v][p][c]+d2[v][i];\n        Q.push(State(d[i][v][c+1],i,v,c+1));\n      }\n    }\n  }\n  int ans = 0;\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < N ; j++){\n      if(i == j){ continue; }\n      for(int k = MAX_C-1 ; k > 0 ; k--){\n        if(le(d[i][j][k],r)){\n          ans = max(ans,k);\n          break;\n        }\n      }\n    }\n  }\n  return ans;\n}\n \nint main(){\n  cin >> N >> r >> th;\n  vector<Point> v(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> v[i];\n  }\n  memset(can,false,sizeof(can));\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < N ; j++){\n      if(i == j){ continue; }\n      for(int k = 0 ; k < N ; k++){\n        if(i == k || j == k){ continue; }\n        Vector a = v[j]-v[i];\n        Vector b = v[k]-v[j];\n        double angle = getAngle(a,b);\n        if(le(angle,th)){\n          can[i][j][k] = true;\n        }\n      }\n    }\n  }\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < N ; j++){\n      d2[i][j] = dist(v[i],v[j]);\n    }\n  }\n  cout << solve(v) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct S{\n  int w,p,n;\n  double d;\n  bool operator<(S s)const{\n    return d>s.d;\n  }\n};\n\ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n\nint main(){\n  int n;\n  double r,th;\n  cin>>n>>r>>th;\n  P p[21];\n  for(int i=1;i<=n;i++){\n    int x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<S> que;\n  que.push({1,0,0,0});\n  bool mem[21][21][2222]={};\n  int m=0;\n  for(;;){\n    auto cs=que.top();\n    if(cs.d>r)break;\n    que.pop();\n    if(mem[cs.w][cs.p][cs.n]++)continue;\n    m=max(m,cs.n);\n    for(int i=1;i<=n;i++){\n      if(i==cs.w)continue;\n      auto f=p[cs.w]-p[cs.p];\n      auto t=p[i]-p[cs.w];\n      if(cs.p&&acos(dot(f,t)/abs(f)/abs(t))*90>th*acos(0))continue;\n      que.push({i,cs.w,cs.n+1,cs.d+abs(t)});\n    }\n  }\n  cout<<m<<endl;\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst double INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-8;\n\nusing R = double;\nusing P = complex<R>;\n\ninline istream& operator>>(istream& is, P& p) {\n  R x, y;\n  is >> x >> y;\n  p = P(x, y);\n  return is;\n}\n\n// 線分abから見たcの位置\ninline int sgn(const R& r) { return (r>EPS) - (r<-EPS); }\nenum CCW{LEFT=1, RIGHT=2, BACK=4, FRONT=8, ON_SEG=16};\nint ccw(P a, P b, P c) {\n\tP p = (c-a)/(b-a);\n\tif(sgn(imag(p)) > 0) return LEFT;\n\tif(sgn(imag(p)) < 0) return RIGHT;\n\tif(sgn(real(p)) < 0) return BACK;\n\tif(sgn(real(p)-1) > 0) return FRONT;\n\treturn ON_SEG;\n}\n\ndouble dp[10010][25][25], d[25][25];\nVI g[25][25];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  double PI = acos(-1);\n  // cout << PI << endl;\n\n  int n;\n  double r, t;\n  cin >> n >> r >> t;\n  t *= PI/180.0;\n  vector<P> ps(n);\n  REP(i, n) cin >> ps[i];\n\n  if(n == 1) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  REP(i, n) REP(j, n) {\n    if(i == j) continue;\n    g[i][j].clear();\n    REP(k, n) {\n      if(j == k) continue;\n      double ang = abs(arg((ps[k] - ps[j]) / (ps[j] - ps[i])));\n      if(ang <= t + EPS) {\n        g[i][j].PB(k);\n        // cout << i << \" \" << j << \" \" << k << endl;\n      }\n    }\n    d[i][j] = abs(ps[i] - ps[j]);\n  }\n\n  REP(i, 10010) REP(j, n) REP(k, n) dp[i][j][k] = INF;\n  FOR(i, 1, n) {\n    if(d[0][i] <= r + EPS) {\n      dp[1][0][i] = d[0][i];\n    }\n  }\n\n  FOR(i, 1, 10001) REP(j, n) REP(k, n) {\n    if(dp[i][j][k] == INF) continue;\n    for(auto &l: g[j][k]) {\n      chmin(dp[i+1][k][l], dp[i][j][k] + d[k][l]);\n    }\n  }\n\n  double ans = 0;\n  for(int i=10001; i>=0; --i) REP(j, n) REP(k, n) {\n    if(dp[i][j][k] <= r + EPS) {\n      ans = i;\n      goto end;\n    }\n  }\n  end:;\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> P;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n#define pi acos(-1)\n\ndouble dp[20][20][10001];\n\nint main(){\n    cin.sync_with_stdio(false);\n    int n;\n    double r, theta;\n    cin >> n >> r >> theta;\n    theta = (theta + 1e-3) * pi / 180.0;\n    vector<P> v;\n    rep(i, n) {\n        double x, y;\n        cin >> x >> y;\n        v.pb(P(x, y));\n    }\n\n    rep(i, n)rep(j, n)rep(k, 10001) dp[i][j][k] = INF + 1;\n    int ans = 0;\n    repl(i, 1, n) {\n        if (abs(v[i] - v[0]) <= r + 1e-3) {\n            dp[0][i][1] = abs(v[i] - v[0]);\n            ans = 1;\n        }\n    }\n    repl(k, 1, 10000) {\n        if (ans != k) break;\n        rep(i, n)rep(j, n) {\n            if (dp[i][j][k] < INF) {\n                rep(l, n) {\n                    if (j == l || i == l) continue;\n                    double alpha = abs(arg(v[l] - v[j]) - arg(v[j] - v[i]));\n                    if (alpha > pi) alpha = 2 * pi - alpha;\n                    if (alpha <= theta && dp[i][j][k] + abs(v[l] - v[j]) <= r + 1e-3) {\n                        minch(dp[j][l][k + 1], dp[i][j][k] + abs(v[l] - v[j]));\n                        ans = k + 1;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<map>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double EPS=0.000000001;\nconst double INF=1000000;\ndouble r,theta;\n\n\tdouble memo[10001][20][20];\n\nbool is_ok(P a,P b,P c){\n\tP in=b-a,out=c-b;\n\tdouble dot=in.real()*out.real()+in.imag()*out.imag();\n//\tcout<<in<<out<<endl;\n//\tcout<<2.0*theta*asin(1.0)/180.0<<endl;\n//\tcout<<cos(90.0*theta*2.0*asin(1.0)/180.0)<<endl;\n//\tcout<<cos(theta*2.0*asin(1.0)/180.0)<<\" \"<<dot/(abs(in)*abs(out))<<endl;\n\tif(cos(theta)<dot/(abs(in)*abs(out))) return true;\n\treturn false;\n}\n\nclass Idx{\npublic:\n\tint num,bef,now;\n\tIdx(int bef,int now,int num):bef(bef),now(now),num(num){}\n};\n\nclass Info{\npublic:\n\tIdx idx;\n\tdouble sum_r;\n\tInfo(Idx idx,double sum_r):idx(idx),sum_r(sum_r){}\n};\n\nint main()\n{\n\tint n;\n\tcin>>n>>r>>theta;\n\tvector<P> V;\n\tfor(int i=0;i<n;i++){\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tV.push_back(P(a,b));\n\t}\n\n\tfor(int i=0;i<10001;i++)\n\t\tfor(int j=0;j<20;j++)\n\t\t\tfor(int k=0;k<20;k++)\n\t\t\t\tmemo[i][j][k]=INF;\n\n\tmemo[0][0][0]=0.0;\n\tint ans=0;\n\n\tbool ok[20][20][20];\n\tmemset(ok,false,sizeof(ok));\n\tfor(int in=0;in<n;in++){\n\t\tfor(int out=0;out<n;out++){\n\t\t\tif(in==out) continue;\n\t\t\tfor(int next=0;next<n;next++){\n\t\t\t\tif(in==next || out==next) continue;\n//\t\t\t\tcout<<\"check \"<<in<<\" \"<<out<<\" \"<<next<<endl;\n\t\t\t\tif(is_ok(V[in],V[out],V[next])){ok[in][out][next]=true;\n\t\t\t\t//cout<<\"ok\"<<endl;;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int num=1;num<=10000;num++){\n\t\tfor(int in=0;in<n;in++){\n\t\t\tfor(int out=0;out<n;out++){\n\t\t\t\tif(memo[num-1][in][out]>r+EPS) continue;\n\t\t\t\tfor(int next=0;next<n;next++){\n\t\t\t\t\tif((num==1 && next!=0) || ok[in][out][next]){\n\t\t\t\t\t\tif(memo[num-1][in][out]+abs(V[out]-V[next])<r+EPS){\n\t\t\t\t\t\t\tans=num;\n\t\t\t\t\t\t\tmemo[num][out][next]=memo[num-1][in][out]+abs(V[out]-V[next]);\n//\t\t\t\t\t\t\tcout<<in<<\" \"<<out<<\" \"<<next<<\" \"<<memo[num][out][next]<<\" \"<<num<<endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans!=num) break;\n\t}\n\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef double R;\ntypedef complex<R> P;\nconst R PI = 3.1415926535897932384626;\n\nistream& operator>>(istream &is, P &p) {\n\tR x, y;\n\tis >> x >> y;\n\tp = P(x, y);\n\treturn is;\n}\n\nint n;\ndouble r, theta;\n\ndouble visited[401][10005];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> r >> theta; theta = theta/180.*PI;\n\tvector<P> p(n);\n\tREP(i, n) cin >> p[i];\n\tvector<vector<pair<int, double>>> g(n*n);\n\tREP(i, n)REP(j, n)REP(k, n){\n\t\tif(i==k || i==j || j==k) continue;\n\t\tif(abs(arg((p[j]-p[i]) / (p[k]-p[j]))) < theta) g[j*n+i].emplace_back(k*n+j, abs(p[k]-p[j]));\n\t}\n\tstruct State{\n\t\tint x, c;\n\t\tdouble cost;\n\t\tState(int x, int c, double cost)\n\t\t\t:x(x), c(c), cost(cost){}\n\t\tbool operator<(const State &opp) const{\n\t\t\treturn cost > opp.cost;\n\t\t}\n\t};\n\tpriority_queue<State> que;\n\tREP(i, n)REP(j, n)if(i!=j){\n\t\tif(abs(p[i]-p[j]) < r){\n\t\t\tque.emplace(j*n+i, 1, abs(p[i]-p[j]));\n\t\t\tvisited[j*n+i][1] = abs(p[i]-p[j]);\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(!que.empty()){\n\t\tState s = que.top(); que.pop();\n\t\tif(s.cost > visited[s.x][s.c]) continue;\n\t\tans = max(ans, s.c);\n\t\tFOR(it, g[s.x]){\n\t\t\tint x = it->first;\n\t\t\tdouble cost = s.cost + it->second;\n\t\t\tint c = s.c + 1;\n\t\t\tauto &t = visited[x][c];\n\t\t\tif((t == 0 || t > cost) && cost < r){\n\t\t\t\tt = cost;\n\t\t\t\tque.emplace(x, c, cost);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nusing P=complex<ld>;\nconst ld pi=acos(-1);\nstruct State{\n    int v,pre;\n    int c; \n};\n\nbool operator<(const State& lhs,const State& rhs){\n    return make_tuple(lhs.v,lhs.pre,lhs.c)<make_tuple(rhs.v,rhs.pre,rhs.c);\n}\n\nint idx(State st){\n    return st.v+20*st.pre+st.c*20*20;\n}\nint main(){\n    int n;\n    cin>>n;\n    ld r,theta;\n    cin>>r>>theta;\n    theta=(theta)/180*pi;\n    vector<P> xy(n);\n    for(int i=0;i<n;i++){\n        ld tmpx,tmpy;\n        cin>>tmpx>>tmpy;\n        xy[i]={tmpx,tmpy};\n    }\n    int res=0;\n    priority_queue<pair<ld,State>,vector<pair<ld,State>>,greater<>> que;\n    que.push({ld(0),State{0,0,0}});\n    const ld INF=1e9;\n    vector<ld> dist(5*1e6,INF);\n    dist[0]=0;\n    while(!que.empty()){\n        auto tmp=que.top(); que.pop();\n        auto ret=tmp.second;\n        int v=ret.v,pre=ret.pre;\n        int c=ret.c;\n        int id=idx(ret);\n        ld w=tmp.first;\n        if(dist[id]!=w) continue;\n        if(w>r) continue;\n        res=max(res,c);\n        for(int i=0;i<n;i++){\n            if(i!=v && i!=pre){\n                if(pre!=v){\n                    ld phi=arg((xy[i]-xy[v])/(xy[v]-xy[pre]));\n                    if(phi>pi) phi-=2*pi;\n                    if(abs(phi)>theta){\n                        continue;\n                    }\n                }\n                State to{i,v,c+1};\n                int toidx=idx(to);\n                if(w+abs(xy[i]-xy[v])<dist[toidx]){\n                    dist[toidx]=w+abs(xy[i]-xy[v]);\n                    que.push({dist[toidx],to});\n                }\n            }\n        }\n\n    }\n    cout<<res<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = double;\nusing P = pair<ld, ld>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nld dp[25][25][11111];\n\nld calc(ld x1, ld y1, ld x2, ld y2)\n{\n    // a = (x1, y1), b = (x2,y2) のなす角\n    ld a = sqrt(x1 * x1 + y1 * y1), b = sqrt(x2 * x2 + y2 * y2), sum = x1 * x2 + y1 * y2;\n    if (abs(sum + a * b) < EPS)\n        return 180.0;\n    if (abs(sum - a * b) < EPS)\n        return 0.0;\n    return 180.0 * acos(sum / (a * b)) / acos(-1);\n}\n\nld dist(P p1, P p2)\n{\n    return sqrt((p1.first - p2.first) * (p1.first - p2.first) + (p1.second - p2.second) * (p1.second - p2.second));\n}\n\nld d[30][30];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    ld r, phi;\n    cin >> n >> r >> phi;\n    vector<P> v(n);\n    for (int i = 0; i < n; i++)\n    {\n        ld x, y;\n        cin >> x >> y;\n        v[i] = P(x, y);\n    }\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            d[i][j] = d[j][i] = dist(v[i], v[j]);\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            for (int k = 0; k <= 10000; k++)\n            {\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n    bool f = false;\n    for (int i = 1; i < n; i++)\n    {\n        if (d[i][0] + EPS > r)\n            continue;\n        dp[i][0][1] = d[i][0];\n        f = true;\n    }\n    if (!f)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    for (int k = 1; k <= 10000; k++)\n    {\n        bool update = false;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                for (int next = 0; next < n; next++)\n                {\n                    if (next == i || next == j || i == j)\n                        continue;\n                    if (dp[i][j][k] == INF)\n                        continue;\n                    ld x1 = v[i].first - v[j].first, y1 = v[i].second - v[j].second;\n                    ld x2 = v[next].first - v[i].first, y2 = v[next].second - v[i].second;\n                    if (calc(x1, y1, x2, y2) + EPS > phi)\n                        continue;\n                    if (dp[i][j][k] + d[i][next] + EPS > r)\n                        continue;\n                    update = true;\n                    dp[next][i][k + 1] = min(dp[next][i][k + 1], dp[i][j][k] + d[i][next]);\n                }\n            }\n        }\n        if (update)\n            continue;\n        cout << k << endl;\n        break;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n\nstruct State {\n\tint cur, prev, carrot;\n\tdouble d;\n\tState(int cur_, int prev_, int carrot_, double d_) {\n\t\tcur = cur_;\n\t\tprev = prev_;\n\t\tcarrot = carrot_;\n\t\td = d_;\n\t}\n\tbool operator<(const State& right) const {\n\t\treturn d > right.d;\n\t}\n};\n\nint x[22], y[22];\ndouble r, theta;\n\nbool check_angle(int p, int i, int n) {\n\tdouble a1 = x[i] - x[p], a2 = y[i] - y[p];\n\tdouble b1 = x[n] - x[i], b2 = y[n] - y[i];\n\tdouble cos_theta = (a1 * b1 + a2 * b2) / (sqrt(a1 * a1 + a2 * a2) * sqrt(b1 * b1 + b2 * b2));\n\treturn cos_theta > cos(theta * M_PI / 180);\n}\n\nusing carrot_key_t = tuple<int, int, int>;\ncarrot_key_t to_key(const State& s) {\n\treturn make_tuple(s.cur, s.prev, s.carrot);\n}\n\nstruct key_hash : public std::unary_function<carrot_key_t, std::size_t> {\n\tstd::size_t operator()(const carrot_key_t& k) const {\n\t\treturn std::get<0>(k) ^ std::get<1>(k) ^ std::get<2>(k);\n\t}\n};\n\nint main() {\n\tint n;\n\tcin >> n;\n\tcin >> r >> theta;\n\n\tfor(int i=0;i<n;i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tpriority_queue<State> que;\n\tque.emplace(0, n, 0, 0);\n\n\tunordered_map<carrot_key_t, double, key_hash> memo;\n\tmemo[to_key(que.top())] = 0;\n\n\tint ans = 0;\n\twhile(!que.empty()) {\n\t\tState s = que.top();\n\t\tque.pop();\n\t\tauto key = to_key(s);\n\t\tif (memo[key] < s.d) continue;\n\t\tans = max(ans, s.carrot);\n\n\t\tfor(int to=0;to<n;to++) {\n\t\t\tif (to == s.cur) continue;\n\t\t\tif (s.prev != n && !check_angle(s.prev, s.cur, to)) continue;\n\t\t\tdouble nd = s.d + sqrt((x[s.cur] - x[to]) * (x[s.cur] - x[to]) + (y[s.cur] - y[to]) * (y[s.cur] - y[to]));\n\t\t\tif (nd > r) continue;\n\n\t\t\tauto next_key = make_tuple(to, s.cur, s.carrot + 1);\n\t\t\tif (memo.find(next_key) == memo.end() || memo[next_key] > nd) {\n\t\t\t\tmemo[next_key] = nd;\n\t\t\t\tque.emplace(to, s.cur, s.carrot + 1, nd);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\ntypedef complex<double> Point;\n\ndouble angle(const Point& v1, const Point& v2) {\n    double res = arg(v1 / v2);\n    if (res < 0) res += 2*pi;\n    return min(2*pi-res, res);\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n; cin >> n;\n    double R, th; cin >> R >> th; th *= pi / 180;\n    vector<Point> v(n);\n    REP(i, n) {\n        ll x, y; cin >> x >> y;\n        v[i] = Point(x, y);\n    }\n    vector<vector<vector<bool>>> G(n, vector<vector<bool>>(n, vector<bool>(n, false)));\n    REP(i, n) REP(j, n) REP(k, n) {\n        if (i == j || j == k || k == i) continue;\n        // i -> j -> k テ」ツ?ィテ」ツ??」ツ?妥」ツつ凝」ツ??\n        Point v1 = v[j] - v[i];\n        Point v2 = v[k] - v[j];\n        if (angle(v1, v2) <= th+eps) {\n            G[i][j][k] = true;\n        }\n    }\n    vector<vector<double>> dist(n, vector<double>(n));\n    REP(i, n) REP(j, n) dist[i][j] = abs(v[i]-v[j]);\n    ll ans = 0;\n    vector<vector<vector<double>>> dp(2, vector<vector<double>>(n, vector<double>(n, linf)));\n    dp[0][0][0] = 0;\n    REP(t, 1010) {\n        dp[t+1&1].assign(n, vector<double>(n, linf));\n        REP(prev, n) REP(now, n) {\n            double l = dp[t&1][prev][now];\n            if (l >= R) continue;\n            ans = max(ans, t);\n            REP(to, n) {\n                if (prev != now && !G[prev][now][to]) continue;\n                if (now == to) continue;\n                dp[t+1&1][now][to] = min(dp[t+1&1][now][to], l + dist[now][to]);\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double inf = 1e100;\nconst double pi = acos(-1);\nconst double eps = 1e-8;\nconst int MAXN = 21;\nconst int NINJIN = 1002;\n\nint N;\ndouble R, T;\nP ps[MAXN];\ndouble dp[2][MAXN][MAXN]; // #ninjin, pos, pre;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble getAngle(P a, P b) {\n  return acos(dot(a, b)/(abs(a)*abs(b)));\n}\n\nbool canMove(const P &pre, const P &from, const P &to) {\n  P a = from - pre;\n  P b = to - from;\n  double d = abs(getAngle(a,b));\n  return equals(d, T) || d < T;\n}\n\nint main() {\n  cin >> N;\n  cin >> R >> T;\n  T = T * pi / 180.0;\n  for(int i = 0; i < N; ++i) {\n    P &p = ps[i];\n    cin >> p.real() >> p.imag();\n  }\n  fill(dp[0][0], dp[2][0], inf);\n  dp[0][0][0] = 0.0;\n  int maxi = 0;\n  for(int i = 0, next = true; next; ++i) {\n    int p = i % 2;\n    int q = 1 - p;\n    for(int j = 0; j < N; ++j) {\n      for(int k = 0; k < N; ++k) {\n        dp[q][j][k] = inf;\n      }\n    }\n    next = false;\n    for(int j = 0; j < N; ++j) {\n      for(int k = 0; k < N; ++k) {\n        if(dp[p][j][k] == inf) continue;\n        for(int m = 0; m < N; ++m) {\n          if(m == j) continue;\n          if(j != k && !canMove(ps[k], ps[j], ps[m])) continue;\n          double ndist = dp[p][j][k] + abs(ps[m] - ps[j]);\n          if(equals(ndist, R) || ndist < R); else continue;\n          maxi = i+1;\n          next = true;\n          dp[q][m][j] = min(dp[q][m][j], ndist);\n        }\n      }\n    }\n  }\n  cout << maxi << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\n\nint n;\ndouble r,d;\nP p[20];\ndouble dp[10001][20][20];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[a];\n  s*=conj(o);\n  s/=abs(s);\n  return real(s)>=cos(M_PI*d/360);\n}\n\nint main(){\n  cin>>n>>r>>d;\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)dp[i][j][k]=1e9;\n  dp[0][0][0]=0;\n  \n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tfor(int l=0;l<n;l++)\n\t  if(check(j,k,l))\n\t    dp[i+1][k][l]=min(dp[i+1][k][l],dp[i][j][k]+abs(p[k]-p[l]));\n\t\n  int ans=0;\n  for(int i=1;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tif(dp[i][j][k]<=r)ans=i;\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 21;\nconst int MAXX = 10001;\nconst double eps = 1e-4;\nconst double inf = 1e10;\n\nint n;\ndouble r, th;\nP ps[MAXN];\ndouble dp[MAXX][MAXN][MAXN];\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble getAngle(P a, P b) {\n  double v = dot(a, b) / (abs(a) * abs(b));\n  if(v > 1.0) return 0;\n  if(v < -1.0) return M_PI;\n  return acos(v);\n}\n\nint main() {\n  while(cin >> n) {\n    cin >> r >> th;\n    th = th * M_PI / 180.0;\n    for(int i = 0; i < n; ++i)\n      cin >> ps[i].real() >> ps[i].imag();\n    fill(dp[0][0], dp[MAXX][0], inf);\n    dp[0][0][0] = 0;\n    int res = 0;\n    for(int i = 0; i+1 < MAXX; ++i) {\n      if(i != res) break;\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < n; ++k) {\n          if(dp[i][j][k] == inf) continue;\n          for(int l = 0; l < n; ++l) {\n            if(k == l) continue;\n            if(j != k) {\n              P a = ps[k] - ps[j], b = ps[l] - ps[k];\n              double rad = getAngle(a, b);\n              if(rad > th + eps) continue;\n            }\n            dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + abs(ps[l]-ps[k]));\n            if(dp[i+1][k][l] < r + eps) {\n              res = i + 1;\n            }\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <algorithm>\n#include <queue>\n#undef max\n#undef min\n\nstruct Node {\n    int lastPos = 0;\n    int pos = 0;\n    int carrot = 0;\n    float len = 0;\n    std::vector<int> hist;\n\n    bool operator<(const Node& rhs) const {\n        if (len == rhs.len) return carrot > rhs.carrot;\n        return len < rhs.len;\n    }\n    bool operator>(const Node& rhs) const {\n        if (len == rhs.len) return carrot < rhs.carrot;\n        return len > rhs.len;\n    }\n};\n\nint main() {\n    int n; float r, theta;\n    float angleTable[20][20][20] = { 0 };\n    float dist[20][20] = { 0 };\n    std::vector<float> memo[20];\n    std::vector<std::pair<int, int>> city;\n    std::cin >> n >> r >> theta;\n    theta /= 180.f;\n    theta *= M_PI;\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        city.push_back(std::make_pair(x, y));\n    }\n\n    // memo初期化\n    for (auto& x : memo) {\n        x.push_back(0.f);\n    }\n\n    // 都市間移動の角度と距離を計算\n    for (int i = 0; i < city.size(); i++) { // 前\n        for (int j = 0; j < city.size(); j++) { // 今\n            if (i == j) continue;\n            for (int k = 0; k < city.size(); k++) { // 次\n                if (j == k) continue;\n                if (i != k) {\n                    float vx[2] = { (float)(city[i].first - city[j].first) , (float)(city[k].first - city[j].first) };\n                    float vy[2] = { (float)(city[i].second - city[j].second) , (float)(city[k].second - city[j].second) };\n                    float jLen = std::sqrt(vx[0] * vx[0] + vy[0] * vy[0]);\n                    float kLen = std::sqrt(vx[1] * vx[1] + vy[1] * vy[1]);\n                    float dot = vx[0] * vx[1] + vy[0] * vy[1];\n                    float a = dot / (jLen * kLen);\n                    angleTable[i][j][k] = (float)(M_PI) - std::acos(dot / (jLen * kLen));\n                }\n                else angleTable[i][j][k] = (float)(M_PI);\n            }\n            float vx = (float)city[j].first - city[i].first;\n            float vy = (float)city[j].second - city[i].second;\n            dist[i][j] = std::sqrt(vx * vx + vy * vy);\n        }\n    }\n\n    std::priority_queue<Node> s;\n    int maxCarrot = 0;\n    s.push({0, 0, 0, 0.f});\n\n    while (!s.empty()) {\n        auto node = s.top(); s.pop();\n        for (int i = 0; i < city.size(); i++) {\n            if (i == node.pos) continue;\n            if (node.pos != node.lastPos && angleTable[node.lastPos][node.pos][i] >= theta) continue;\n            auto next = node;\n            next.lastPos = next.pos;\n            next.len += dist[node.pos][i];\n            if (next.len > r) continue;\n\n            next.pos = i;\n            next.carrot++;\n\n            if (memo[i].size() <= next.carrot) {\n                int m = memo[i].size();\n                for (int j = 0; j < next.carrot - m + 1; j++) {\n                    memo[i].push_back(next.len);\n                }\n            }\n            else {\n                if (memo[i][next.carrot] <= next.len) continue; // もっと短い距離で同数の人参に到達\n            }\n            memo[i][next.carrot] = next.len;\n            next.hist.push_back(i);\n            maxCarrot = std::max(maxCarrot, next.carrot);\n            s.push(next);\n        }\n    }\n    std::cout << maxCarrot << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n#include<climits>\n\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\nclass Vector {\n    public:\n    double x,y;\n    Vector(double x=0.0, double y=0.0): x(x), y(y) {}\n    double norm() const { return x*x + y*y; }\n    double dot(Vector p) const { return x*p.x + y*p.y; }\n};\n\nint main(){\n    int n;\n    double r, theta;\n    cin >> n;\n    cin >> r >> theta;\n    theta = theta/180.0*M_PI;\n    pair<double, double> cities[n];\n    for(int i=0;i<n;i++){\n        cin >> cities[i].first >> cities[i].second;\n    }\n\n    bool ok[n][n][n];\n    double dist[n][n];\n    fill(ok[0][0], ok[n][n], false);\n    fill(dist[0], dist[n], -1.0);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(i == j) continue;\n            Vector v = Vector(\n                    cities[j].first - cities[i].first,\n                    cities[j].second - cities[i].second\n                );\n            dist[i][j] = sqrt(v.norm());\n            for(int k=0;k<n;k++){\n                if(j == k) continue;\n                Vector u = Vector(\n                        cities[k].first - cities[j].first,\n                        cities[k].second - cities[j].second\n                    );\n                double theta_ = acos(u.dot(v) / sqrt(v.norm() * u.norm()));\n                if(abs(theta_) <= theta) ok[i][j][k] = true;\n            }\n        }\n    }\n\n    double dp[10001][n][n];\n    int ans = 0;\n    fill(dp[0][0], dp[10000][n], 2.0*r);\n    for(int j=0;j<n;j++){\n        for(int k=0;k<n;k++){\n            if(j != k && dist[j][k] > 0.0) dp[0][j][k] = dist[j][k];\n        }\n    }\n    for(int i=0;i<10001;i++){\n        bool flag = false;\n        for(int j=0;j<n;j++){\n            for(int k=0;k<n;k++){\n                if(j == k || dp[i][j][k] < 0.0) continue;\n                if(dp[i][j][k] <= r) flag = true;\n                for(int l=0;l<n;l++){\n                    if(k == l) continue;\n                    if(ok[j][k][l] && dist[k][l] > 0.0){\n                        dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + dist[k][l]);\n                    } \n                }\n            }\n        }\n        if(!flag){\n            ans = i;\n            break;\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble dp[20][20][10000];\ndouble d[20][20];\ndouble x[20];\ndouble y[20];\ndouble calc(int a,int b,int c){\n\tdouble dot=(x[b]-x[a])*(x[c]-x[b])+(y[b]-y[a])*(y[c]-y[b]);\n\tdouble r=d[a][b]*d[b][c];\n\treturn dot/r;\n}\nint main(){\n\tint a;\n\tdouble b,c;\n\tscanf(\"%d%lf%lf\",&a,&b,&c);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lf%lf\",x+i,y+i);\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(i!=j)\n\t\t\td[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++)\n\t\t\tfor(int k=0;k<10000;k++)\n\t\t\t\tdp[i][j][k]=99999999;\n\t//for(int i=0;i<a;i++){\n\t\tfor(int j=1;j<a;j++){\n\t\t\tdp[0][j][1]=d[0][j];\n\t\t}\n\t//}\n\tfor(int i=1;i<9999;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(j==k)continue;\n\t\t\t\tif(dp[j][k][i]>b)continue;\n\n\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\tif(l==k)continue;\n\t\t\t\t\t//printf(\"%d %d %d: %f %f\\n\",j,k,l,calc(j,k,l),cos(c/180*3.14159265359));\n\t\t\t\t\tif(calc(j,k,l)<cos(c/180*3.14159265359))continue;\n\t\t\t\t\t\n\t\t\t\t\tdp[k][l][i+1]=min(dp[k][l][i+1],dp[j][k][i]+d[k][l]);\n\t\t\t\t\t//printf(\"%d -> %d -> %d\\n\",j,k,l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret=0;\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++)\n\t\t\tfor(int k=1;k<10000;k++)\n\t\t\t\tif(dp[i][j][k]<b)ret=max(ret,k);\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nconst double PI = 3.1415926535;\nint main(){\n  int n,i,j,k,ans=0;cin>>n;\n  double r,arc;cin>>r>>arc;\n  arc=PI/180.0*arc;\n  Polygon g;g.resize(n);\n  for(i=0;i<n;i++) cin>>g[i].x>>g[i].y;\n  double e[n][n][n],inf=1<<28;\n  fill(e[0][0],e[0][0]+n*n*n,inf);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      for(k=0;k<n;k++){\n\tif(i==j||j==k||k==i) continue;\n\tVector a=g[j]-g[i],b=g[k]-g[j];\n\tif(fabs(acos(dot(a,b)/(abs(a)*abs(b))))<=arc)\n\t  e[i][j][k]=abs(g[k]-g[j]);\n      }\n    }\n  }\n  for(k=1;k<n;k++) e[0][0][k]=abs(g[k]-g[0]);\n  map<int,double> dp[n][n];\n  typedef pair<int,int> P;\n  typedef pair<int,P> PP;\n  typedef pair<double,PP> PPP;\n  priority_queue<PPP,vector<PPP>,greater<PPP> > q;\n  q.push(PPP(0.0,PP(0,P(0,n))));\n  while(!q.empty()){\n    PPP ppp=q.top();q.pop();\n    double d=ppp.first,z;\n    PP pp=ppp.second;\n    k=pp.first;\n    P p=pp.second;\n    if(d>r) continue;\n    ans=max(ans,k);\n    if(p.second==n){\n      for(i=0;i<n;i++){\n\tz=inf;\n\tfor(j=0;j<n;j++) z=min(z,e[j][0][i]);\n\tq.push(PPP(d+z,PP(k+1,P(i,p.first))));\n      }\n    }else{\n      if(dp[p.first][p.second].find(k)!=dp[p.first][p.second].end())\n\tif(dp[p.first][p.second][k]<=d) continue;\t\n      dp[p.first][p.second][k]=d;\n      for(i=0;i<n;i++)\n\tq.push(PPP(d+e[p.second][p.first][i],PP(k+1,P(i,p.first))));\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n\nstruct State {\n\tint cur, prev, carrot;\n\tdouble d;\n\tState(int cur_, int prev_, int carrot_, double d_) {\n\t\tcur = cur_;\n\t\tprev = prev_;\n\t\tcarrot = carrot_;\n\t\td = d_;\n\t}\n\tbool operator<(const State& right) const {\n\t\treturn d > right.d;\n\t}\n};\n\nint x[22], y[22];\ndouble r, theta;\n\nbool check_angle(int p, int i, int n) {\n\tdouble a1 = x[i] - x[p], a2 = y[i] - y[p];\n\tdouble b1 = x[n] - x[i], b2 = y[n] - y[i];\n\tdouble cos_theta = (a1 * b1 + a2 * b2) / (sqrt(a1 * a1 + a2 * a2) * sqrt(b1 * b1 + b2 * b2));\n\treturn cos_theta > cos(theta * M_PI / 180);\n}\n\ntuple<int, int, int> to_key(const State& s) {\n\treturn make_tuple(s.cur, s.prev, s.carrot);\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tcin >> r >> theta;\n\n\tfor(int i=0;i<n;i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tpriority_queue<State> que;\n\tque.emplace(0, n, 0, 0);\n\n\tunordered_map<tuple<int, int, int>, double> memo;\n\tmemo[to_key(que.top())] = 0;\n\n\tint ans = 0;\n\twhile(!que.empty()) {\n\t\tState s = que.top();\n\t\tque.pop();\n\t\tauto key = to_key(s);\n\t\tif (memo[key] < s.d) continue;\n\t\tans = max(ans, s.carrot);\n\n\t\tfor(int to=0;to<n;to++) {\n\t\t\tif (to == s.cur) continue;\n\t\t\tif (s.prev != n && !check_angle(s.prev, s.cur, to)) continue;\n\t\t\tdouble nd = s.d + sqrt((x[s.cur] - x[to]) * (x[s.cur] - x[to]) + (y[s.cur] - y[to]) * (y[s.cur] - y[to]));\n\t\t\tif (nd > r) continue;\n\n\t\t\tauto next_key = make_tuple(to, s.cur, s.carrot + 1);\n\t\t\tif (memo.find(next_key) == memo.end() || memo[next_key] > nd) {\n\t\t\t\tmemo[next_key] = nd;\n\t\t\t\tque.emplace(to, s.cur, s.carrot + 1, nd);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\n\ndouble dp[22][22][11111], dist[22][22][22];\nint main()\n{\n\tint n; ld r, th;\n\tcin >> n >> r >> th;\n\tvector<Point> ps;\n\tREP(i, n)\n\t{\n\t\tld x, y; cin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\tREP(i, n)REP(j, n)REP(k, n)\n\t{\n\t\tPoint pre = ps[i], now = ps[j], next = ps[k];\n\t\tPoint v1 = now - pre, v2 = next - now;\n\t\tif (i == j || j == k || i == k)\n\t\t{\n\t\t\tdist[i][j][k] = INF;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tld lhs = dot(v1, v2), rhs = abs(v1)*abs(v2)*cos(th / 180.0 * PI);\n\t\t\tif (lhs - rhs > -EPS) dist[i][j][k] = abs(v2);\n\t\t\telse dist[i][j][k] = INF;\n\t\t}\n\t}\n\tREP(i, 22)REP(j, 22)REP(k, 11111) dp[i][j][k] = INF;\n\tdp[0][0][0] = 0;\n\tFOR(i, 1, n) dp[0][i][1] = abs(ps[i] - ps[0]);\n\tFOR(k, 1, 11111)REP(i, n)REP(j, n)\n\t{\n\t\tREP(l, n)\n\t\t{\n\t\t\tif (dist[i][j][l] == INF) continue;\n\t\t\telse chmin(dp[j][l][k + 1], dp[i][j][k] + dist[i][j][l]);\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, 22)REP(j, 22)REP(k, 1111)\n\t{\n\t\tif (dp[i][j][k] <= r) chmax(ans, k);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int MAX = 20,LIMIT = 15000,IINF = INT_MAX;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nstruct Edge{\n  int to;\n  double weight;\n  Edge(int to=0,double weight=0):to(to),weight(weight){}\n};\n\nstruct Data{\n  int prev,cur,carrot;\n  double dist;\n  Data(int prev=0,int cur=0,int carrot=0,double dist=0):prev(prev),cur(cur),carrot(carrot),dist(dist){}\n  bool operator < (const Data& data) const{ return dist > data.dist; }\n};\n\nint n;\ndouble r,theta,mindist[MAX][MAX][LIMIT]; // mindist[cur][prev][the number of carrot]\nPoint ps[MAX];\nvector<Edge> edge[MAX][MAX]; // edge[cur][prev]\n\ninline void dijkstra(){\n  rep(i,n)rep(j,n)rep(k,LIMIT) mindist[i][j][k] = IINF;\n  priority_queue<Data> Q;\n\n  REP(i,1,n) {\n    double dist = abs(ps[0]-ps[i]);\n    if( !equals(dist,r) && dist > r ) continue;\n    Q.push(Data(0,i,1,dist));\n    mindist[i][0][1] = dist;\n  }\n  int ans = (Q.empty()?0:1);\n\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n    int prev = data.prev, cur = data.cur, carrot = data.carrot;\n    double dist = data.dist;\n    assert(carrot+1 < LIMIT);\n    if( !equals(mindist[cur][prev][carrot],dist) && mindist[cur][prev][carrot] < dist ) continue;\n\n    rep(i,edge[cur][prev].size()) {\n      int next = edge[cur][prev][i].to;\n      double weight = edge[cur][prev][i].weight;\n      if( !equals(r,dist+weight) && r < dist+weight ) continue;\n      if( mindist[next][cur][carrot+1] > dist + weight ){\n        mindist[next][cur][carrot+1] = dist + weight;\n\n        ans = max(ans,carrot+1);\n        Q.push(Data(cur,next,carrot+1,dist+weight));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\ninline void makeEdge(){\n  rep(prev,n){\n    rep(cur,n){\n      if( cur == prev ) continue;\n      rep(next,n){\n        if( next == cur || next == prev ) continue;\n        double dist = abs(ps[cur]-ps[next]);\n        if( !equals(dist,r) && dist > r ) continue;\n        Vector v1 = ( ps[next] - ps[cur] ) - ps[prev];\n        Vector v2 = ps[cur]  - ps[prev];\n        if( equals(cross(v1,v2),0.0) ) continue;\n        double arg = getArg(ps[prev],ps[cur],ps[next]);\n        if( equals(arg,theta) || arg < theta ) edge[cur][prev].push_back(Edge(next,dist));\n      }\n    }\n  }\n}\n\nint main(){\n\n  /*\n  int next = 2, cur = 1, prev = 0;\n  ps[0] = Point(0,0);\n  ps[1] = Point(10,0);\n  ps[2] = Point(0,1);\n  double arg =  getArg(ps[prev],ps[cur],ps[next]);\n  cout << \"arg = \" << arg * 180.0 / M_PI << endl;\n  */\n\n  cin >> n;\n  cin >> r >> theta;\n  theta = toRad(theta);\n  rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n\n  makeEdge();\n\n  dijkstra();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1);\nconst double INF = 100000000000;\nint main(){\n  int n;\n  cin >> n;\n  double r, t;\n  cin >> r >> t;\n  t = (180 - t) / 180 * PI;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; i++){\n    cin >> x[i] >> y[i];\n  }\n  vector<vector<double>> d(n, vector<double>(n, INF));\n  for (int i = 0; i < n; i++){\n    for (int j = 0; j < n; j++){\n      if (i != j){\n        d[i][j] = sqrt(pow(x[j] - x[i], 2) + pow(y[j] - y[i], 2));\n      }\n    }\n  }\n  vector<vector<vector<bool>>> ok(n, vector<vector<bool>>(n, vector<bool>(n, false)));\n  for (int i = 0; i < n; i++){\n    for (int j = 0; j < n; j++){\n      for (int k = 0; k < n; k++){\n        if (i != j && j != k && k != i){\n          if (pow(d[i][k], 2) > pow(d[i][j], 2) + pow(d[j][k], 2) - 2 * d[i][j] * d[j][k] * cos(t)){\n            ok[i][j][k] = true;\n          }\n        }\n      }\n    }\n  }\n  vector<vector<vector<double>>> dp(10000, vector<vector<double>>(n, vector<double>(n, INF)));\n  for (int i = 1; i < n; i++){\n    dp[1][0][i] = d[0][i];\n  }\n  for (int i = 2; i < 10000; i++){\n    for (int j = 0; j < n; j++){\n      for (int k = 0; k < n; k++){\n        for (int l = 0; l < n; l++){\n          if (ok[j][k][l]){\n            dp[i][k][l] = min(dp[i][k][l], dp[i - 1][j][k] + d[k][l]);\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < 10000; i++){\n    for (int j = 0; j < n; j++){\n      for (int k = 0; k < n; k++){\n        if (dp[i][j][k] <= r){\n          ans = i;\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n\treturn isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n\treturn isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n\treturn isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n\treturn distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n\treturn distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n\treturn isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n\treturn intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n\treturn isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n\treturn intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n\tint n = g.size();\n\tbool x = false;\n\trep(i,n){\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n\t\tif( a.imag() > b.imag() ) swap(a, b);\n\t\tif( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n\t}\n\treturn ( x ? IN : OUT );\n}\n\n//??§?????????????????°????????????\ndouble radianToDegree(double rad){\n\treturn 180 * rad / M_PI;\n}\n\n//?????°??????????????§????????????\ndouble degreeToRadian(double deg){\n\treturn M_PI * deg / 180;\n}\n\n//2???????????????????????????????§????????±???????\ndouble angleOf2Vector(Vector a, Vector b){\n\treturn acos( dot(a,b) / (abs(a) * abs(b)) );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n\tPolygon u;\n\tif( s.size() < 3 ) return s;\n\tsort(s.begin(), s.end());\n\n\trange(i,0,s.size()){\n\t\t//== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n\t\t//!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.emplace_back(s[i]);\n\t}\n\n\tfor(int i = s.size() - 2; i >= 0; i--){\n\t\t//????????? == ??¨ != ????????´??????\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.emplace_back(s[i]);\n\t}\n\n\treverse(u.begin(), u.end());\n\tu.pop_back();\n\n\t//?????????????????????????????§??????????????????????????????????¨??????????????????????\n\t/*\n\t   int i = 0;\n\t   while(i < u.size() - 1){\n\t   if(u[i].imag() > u[i + 1].imag()){\n\t   u.emplace_back(u[i]);\n\t   u.erase(u.begin());\n\t   continue;\n\t   }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n\t   u.emplace_back(u[i]);\n\t   u.erase(u.begin());\n\t   continue;\n\t   }\n\t   break;\n\t   }\n\t   */\n\n\treturn u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n\tPolygon s = convexHull(p);\n\tint n = s.size();\n\n\tif(n == 2) return abs(s[1] - s[0]);\n\n\tint i = 0, j = 0;\n\trep(k,n){\n\t\tif(not (s[i] < s[k])) i = k;\n\t\tif(s[j] < s[k]) j = k;\n\t}\n\n\tdouble ret = 0.0;\n\tint is = i, js = j;\n\n\twhile(i != js || j != is){\n\t\tret = max(ret, abs(s[i] - s[j]));\n\t\tif(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n\t\t\ti = (i + 1) % n;\n\t\t}else{\n\t\t\tj = (j + 1) % n;\n\t\t}\n\t}\n\treturn ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n\tdouble A = cross(a.p2 - a.p1, b.p2 - b.p1);\n\tdouble B = cross(a.p2 - a.p1, a.p2 - b.p1);\n\tif(abs(A) < EPS && abs(B) < EPS) return b.p1;\n\treturn b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\trep(i,p.size()){\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tq.emplace_back(getCrossPointLL(Line{a, b}, l));\n\t\t}\n\t}\n\treturn q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n\tdouble w, x, y, z;\n\tw = b.real()-a.real();\n\tx = b.imag()-a.imag();\n\ty = c.real()-a.real();\n\tz = c.imag()-a.imag();\n\treturn abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n\tint n = g.size();\n\tdouble ret = 0.0;\n\trep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n\treturn abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n\tint n = g.size();\n\trep(i,n){\n\t\tif(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n\t}\n\treturn true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n\tint cnt = 0;\n\trep(i,p.size()){\n\t\tif(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n\t}\n\treturn cnt / 2 + 1;\n}\n\n//????§???¢??????????±???¨??????????????§?¨?\nPoint pointSymmetry(Polygon g){\n\tint size = g.size() / 2;\n\tif(g.size() % 2) return Point{INF,INF};\n\n\tset<Point> s;\n\trep(i,size){\n\t\trep(j,size){\n\t\t\tif(i == j) continue;\n\t\t\ts.insert(intersectionLs(g[i], g[i + size], g[j], g[j + size]));\n\t\t}\n\t}\n\tif(s.size() > 1) return Point{INF,INF};\n\treturn *s.begin();\n}\n\nstruct Edge{\n\tint to;\n\tdouble dis;\n\tEdge(int to, double dis) : to(to), dis(dis) {}\n};\n\nmap<pair<int,int>, vector<Edge>> e;\ndouble dis[20][20][10000];\n\nint bfs(int n, double r){\n\trep(i,20) rep(j,20) rep(k,10000) dis[i][j][k] = -1;\n\n\ttypedef pair<double,pair<pair<int, int>, int>> P; //cost, prev, next, cnt\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\n\tq.push(make_pair(0,make_pair(make_pair(1,1),0)));\n\tdis[1][1][0] = 0;\n\n\twhile(not q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\tdouble cost = p.first;\n\t\tint prev = p.second.first.first;\n\t\tint cur = p.second.first.second;\n\t\tint cnt = p.second.second;\n\t\tfor(auto to : e[make_pair(prev, cur)]){\n\t\t\tif(to.dis == 0) continue;\n\t\t\tif(dis[cur][to.to][cnt + 1] == -1 && cost + to.dis <= r){\n\t\t\t\tdis[cur][to.to][cnt + 1] = cost + to.dis;\n\t\t\t\t//cout << cnt + 1 << ' ' << cost + to.dis << endl;\n\t\t\t\tq.push(make_pair(cost + to.dis, make_pair(make_pair(cur, to.to), cnt + 1)));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int k = 10000 - 1; k >= 0; k--){\n\t\trep(i,n) {\n\t\t\trep(j,n){\n\t\t\t\tif(dis[i][j][k] == -1) continue;\n\t\t\t\treturn k;\n\t\t\t}\n\t\t}\n\t}\n\tassert(false);\n\treturn -1;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tdouble r, theta;\n\tcin >> r >> theta;\n\n\tPoint p[20];\n\trep(i,n){\n\t\tdouble a, b;\n\t\tcin >> a >> b;\n\t\tp[i] = Point{a,b};\n\t}\n\n\trep(i,n){\n\t\trep(j,n){\n\t\t\te[make_pair(i,i)].emplace_back(Edge{j,abs(p[j] - p[i])});\n\t\t\trep(k,n){\n\t\t\t\tif(i == j || j == k) continue;\n\t\t\t\tif(radianToDegree(angleOf2Vector(p[j] - p[i], p[k] - p[j])) <= theta){\n\t\t\t\t\te[make_pair(i,j)].emplace_back(Edge{k, abs(p[j] - p[k])});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//rep(i,n){\n\t//\trep(j,n){\n\t//\t\tfor(auto k : e[make_pair(i,j)]){\n\t//\t\t\tcout << k.to << ' ' << k.dis << endl;\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tcout << bfs(n, r) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nconst double PI = 3.1415926535;\nint main(){\n  int n,i,j,k,ans=0;cin>>n;\n  double r,arc;cin>>r>>arc;\n  arc=PI/180.0*arc;\n  Polygon g;g.resize(n);\n  for(i=0;i<n;i++) cin>>g[i].x>>g[i].y;\n  double e[n][n][n],inf=1<<28;\n  fill(e[0][0],e[0][0]+n*n*n,inf);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      for(k=0;k<n;k++){\n\tif(i==j||j==k||k==i) continue;\n\tVector a=g[j]-g[i],b=g[k]-g[j];\n\tif(fabs(acos(dot(a,b)/(abs(a)*abs(b))))<=arc)\n\t  e[i][j][k]=abs(g[k]-g[j]);\n      }\n    }\n  }\n  map<int,double> dp[n][n];\n  typedef pair<int,int> P;\n  typedef pair<int,P> PP;\n  typedef pair<double,PP> PPP;\n  priority_queue<PPP,vector<PPP>,greater<PPP> > q;\n  q.push(PPP(0.0,PP(0,P(0,n))));\n  while(!q.empty()){\n    PPP ppp=q.top();q.pop();\n    double d=ppp.first,z;\n    if(d>r) continue;\n    PP pp=ppp.second;\n    k=pp.first;ans=max(ans,k);\n    P p=pp.second;\n    if(p.second==n){\n      for(i=0;i<n;i++){\n\tz=inf;\n\tfor(j=0;j<n;j++) z=min(z,e[j][0][i]);\n\tq.push(PPP(d+z,PP(k+1,P(i,p.first))));\n      }\n    }else{\n      if(dp[p.first][p.second].find(k)!=dp[p.first][p.second].end())\n\tif(dp[p.first][p.second][k]<=d) continue;\t\n      dp[p.first][p.second][k]=d;\n      for(i=0;i<n;i++)\n\tq.push(PPP(d+e[p.second][p.first][i],PP(k+1,P(i,p.first))));\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(const deque<int>& deq,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[deq[0]];\n  complex<double> mid = cities[deq[1]];\n  complex<double> dst = cities[deq[2]];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _c,double _r,const deque<int>& _d) :\n    city(_ct), carrots(_c), remaining_distance(_r),deq(_d) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    deq.push_back(_d);\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,false,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      while(s.deq.size() > 3) s.deq.pop_front();\n\n      int prev = 20;\n      if(s.deq.size() > 1) prev = *(s.deq.end()-2);\n      if(dp[s.carrots][prev][s.city]) continue;\n      dp[s.carrots][prev][s.city] = true;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\t\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tdeque<int> deq = s.deq;\n\t\n\tdeq.push_back(to);\n\twhile(deq.size() > 3) deq.pop_front();\n\n\tif(deq.size()==3){\n\t  if(!check(deq,limit_rad,cities)) continue;\n\t}\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tque.push(State(to,s.carrots+1,s.remaining_distance - dist,deq));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 30;\nint x[N], y[N];\n\nint dist[10010][N][N];\n\nvector<int> G[N][N];\ndouble D[N][N];\n\nconst double PI = 4 * atan(1);\nconst double EPS = 1e-9;\n\nint main(){\n\tint n;\n\tdouble r, theta;\n\tcin >> n >> r >> theta;\n\ttheta = theta / 180 * PI;\n\trep(i, n) cin >> x[i] >> y[i];\n\n\trep(i, n) rep(j, n){\n\t\tD[i][j] = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));\n\t}\n\n\trep(i, n) rep(j, n) rep(k, n){\n\t\tif (i == j || j == k) continue;\n\t\tdouble x1 = x[j] - x[i], y1 = y[j] - y[i];\n\t\tdouble x2 = x[k] - x[j], y2 = y[k] - y[j];\n\n\t\tdouble ct = x1*x2 + y1*y2 / (sqrt(x1*x1 + y1*y1)*sqrt(x2*x2 + y2*y2));\n\t\tdouble theta = acos(ct);\n\n\t\tif (abs(theta) < theta + EPS) G[i][j].push_back(k);\n\t}\n\n\tMEMSET(dist, 0x7f);\n\tpriority_queue<tuple<double, int, int, int>> pq;\n\n\trep(i, n) rep(j, n){\n\t\tif (i == j) continue;\n\t\tpq.emplace(-D[i][j], 1, i, j);\n\t}\n\n\tint ans = 0;\n\twhile (!pq.empty()){\n\t\tauto t = pq.top();\n\t\tpq.pop();\n\t\tdouble d;\n\t\tint c, prv, cur;\n\t\ttie(d, c, prv, cur) = t;\n\t\td = -d;\n\n\t\tif (dist[c][prv][cur] + EPS < d) continue;\n\n\t\tans = max(ans, c);\n\n\t\tfor (auto v : G[prv][cur]){\n\t\t\tdouble nd = d + D[cur][v];\n\t\t\tif (r < nd + EPS) continue;\n\t\t\tif (dist[c + 1][cur][v] < nd + EPS) continue;\n\t\t\tdist[c + 1][cur][v] = nd;\n\t\t\tpq.emplace(-nd, c + 1, cur, v);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n \ntypedef complex<double> P;\n \nstruct S{\n  int w,p,n;\n  double d;\n  bool operator<(S s)const{\n    return d>s.d;\n  }\n};\n \ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n \nint main(){\n  int n;\n  double r,th;\n  cin>>n>>r>>th;\n  P p[21];\n  for(int i=1;i<=n;i++){\n    int x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  double t[21][21][21];\n  fill(t[0][0],t[21][0],-1);\n  for(int i=0;i<=n;i++){\n    for(int j=1;j<=n;j++){\n      for(int k=1;k<=n;k++){\n\tauto f=p[j]-p[i];\n\tauto to=p[k]-p[j];\n\tif(i==0||j!=k&&acos(min(1.,max(-1.,dot(f,to)/abs(f)/abs(to))))*90<=th*acos(0)){\n\t  t[i][j][k]=abs(to);\n\t}\n      }\n    }\n  }\n  priority_queue<S> que;\n  que.push({1,0,0,0});\n  static bool mem[21][21][22222];\n  int m=0;\n  while(!que.empty()){\n    auto cs=que.top();\n    if(cs.d>r)break;\n    que.pop();\n    if(mem[cs.w][cs.p][cs.n]++)continue;\n    m=max(m,cs.n);\n    for(int i=1;i<=n;i++){\n      auto v=t[cs.p][cs.w][i];\n      if(v<0)continue;\n      que.push({i,cs.w,cs.n+1,cs.d+v});\n    }\n  }\n  cout<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nint n;\ndouble dp[10001][21][21]={};\ndouble x[21],y[21],r,s;\nbool b[21][21][21]={};\n\ndouble abs(int a,int b){\n  return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n}\n\ndouble dot(int a,int b,int c){\n  return (x[a]-x[b])*(x[c]-x[b])+(y[a]-y[b])*(y[c]-y[b]);\n}\n\nint main()\n{\n  cin>>n>>r>>s;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(i==j || j==k || i==k)continue;\n\tdouble R=acos(dot(i,j,k)/(abs(i,j)*abs(k,j)));\n\tR=R*360/(2*pi);\n\tif((R-s)<eps)b[i][j][k]=true;\n\telse b[i][j][k]=false;\n      }\n    }\n  }\n\n  for(int i=0;i<10001;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tdp[i][j][k]=inf;\n\n  for(int i=1;i<n;i++)dp[0][0][i]=abs(0,i);\n\n  int ans=1;\n  for(int c=1;c<10001;c++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  if(b[i][j][k]){\n\t    dp[c][j][k]=min(dp[c][j][k],dp[c-1][i][j]+abs(k,j));\n\t    if(dp[c][j][k]-r<eps)ans=max(c-1,ans);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n//typedef tuple<int, int, int> T;\ntypedef pair<ll, ll> Pl;\n//typedef tuple<ll, ll, ll> Tl;\ndouble G[21][21];\nbool ok[21][21][21];\ndouble dp[21][21][10100];\nbool used[21][21][10100] = {};\ndouble r;\nint n;\n\n\ndouble calc(int b, int i, int nn) {\n\tassert(b != i);\n\tif (!nn) return 0;\n\tif (used[b][i][nn]) return dp[b][i][nn];\n\tused[b][i][nn] = true;\n\tdouble res = 1e10;\n\tfor (int j = 0; j < n; j++) {\n\t\tif (i == j) continue;\n\t\tif (ok[b][i][j]) {\n\t\t\tres = min(res, calc(i, j, nn-1)+G[i][j]);\n\t\t}\n\t}\n\tdp[b][i][nn] = res;\n\treturn res;\n}\n\nbool solve(int md) {\n\tfor (int i = 1; i < n; i++) {\n\t\tif (calc(0, i, md)+G[0][i] <= r) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> n;\n\tdouble c;\n\tcin >> r >> c;\n\tc = c/180*3.14159265358979;\n\tcomplex<double> u[21];\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble a, b;\n\t\tcin >> a >> b;\n\t\tu[i] = complex<double>(a, b);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tG[i][j] = abs(u[i]-u[j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (fmod(abs(arg(u[j]-u[i]) - arg(u[k] - u[j])), 3.1415926536) < c) {\n\t\t\t\t\tok[i][j][k] = true;\n\t\t\t\t} else {\n\t\t\t\t\tok[i][j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tok[i][j][i] = false;\n\t\t\tok[i][i][j] = false;\n\t\t\tok[j][i][i] = false;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\t//printf(\"%d %d %f\\n\", i, j, G[i][j]);\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t//printf(\"%d %d %d %d\\n\", i, j, k, ok[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint ll = 1, rr = 10100;\n\twhile (rr - ll > 1) {\n\t\tint md = (ll+rr)/2;\n\t\tif (solve(md)) {\n\t\t\tll = md;\n\t\t} else {\n\t\t\trr = md;\n\t\t}\n\t}\n\tcout << ll << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\ndouble d[20][20], a[20][20][20], dp[10000][20][20];\n\nint main() {\n\tint n; double r, th;\n\tcin >> n >> r >> th;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\td[i][j] = hypot(x[i] - x[j], y[i] - y[j]);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (i == j || j == k) continue;\n\t\t\t\tint x1 = x[i] - x[j], y1 = y[i] - y[j];\n\t\t\t\tint x2 = x[j] - x[k], y2 = y[j] - y[k];\n\t\t\t\tdouble c = (x1 * x2 + y1 * y2) / d[i][j] / d[j][k];\n\t\t\t\ta[i][j][k] = (c > cos(th / 180 * M_PI));\n\t\t\t}\n\tfill(dp[0][0], dp[0][0] + 10000 * 20 * 20, FLT_MAX);\n\tfor (int i = 1; i < n; i++)\n\t\tdp[1][i][0] = d[i][0];\n\tfor (int l = 2; l < 10000; l++)\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\tif (i != j && j != k && a[i][j][k])\n\t\t\t\t\t\tdp[l][i][j] = min(dp[l][i][j], dp[l - 1][j][k] + d[j][k]);\n\tint maxi = 0;\n\tfor (int l = 1; l < 10000; l++)\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (dp[l][i][j] < r) maxi = l;\n\tcout << maxi << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n\nint MAX = 100000;\nint cost_all[200020];\nint cost_single[200020];\n\nusing pii = pair<int, int>;\n\nusing Point = complex<double>;\n\nconst double EPS = 1e-6;\n\ndouble dp[21][21][10010];\ndouble ang(Point a, Point b) {\n    Point c = b - a;\n    return atan2(c.imag(), c.real());\n}\nconst double pi = acos(-1);\nvoid init() {}\nbool canmove[20][20][20];\nbool solve() {\n    int N;\n    cin >> N;\n    double r, theta;\n    cin >> r >> theta;\n    theta = theta / 180 * pi;\n    vector<Point> ps(N);\n    REP(i, N) {\n        double x, y;\n        cin >> x >> y;\n        ps[i] = {x, y};\n    }\n    int ans = 0;\n    REP(i, N) REP(j, N) REP(c, 10010) dp[i][j][c] = 1e9;\n    FOR(i, 1, N) {\n        double d = abs(ps[i] - ps[0]);\n        dp[0][i][1] = d;\n        if (d < r + EPS) ans = 1;\n    }\n\n    REP(i, N) REP(j, N) REP(k, N) {\n        if (i == j || j == k) continue;\n        double t1 = ang(ps[i], ps[j]);\n        double t2 = ang(ps[j], ps[k]);\n        double t = max(t1, t2) - min(t1, t2);\n        if (t > pi + EPS) t = 2 * pi - t;\n        if (t < theta + EPS) canmove[i][j][k] = true;\n    }\n    FOR(c, 1, 10000) {\n        REP(i, N) REP(j, N) {\n            if (i == j) continue;\n            if (dp[i][j][c] > r + EPS) continue;\n            REP(k, N) {\n                if (k == j) continue;\n                if (canmove[i][j][k]) {\n                    if (dp[j][k][c + 1] > dp[i][j][c] + abs(ps[j] - ps[k])) {\n                        dp[j][k][c + 1] = dp[i][j][c] + abs(ps[j] - ps[k]);\n                        if (dp[j][k][c + 1] < r + EPS && c + 1 > ans) ans = c + 1;\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return false;\n}\nsigned main() {\n    init();\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(const deque<complex<double> >& deq,double limit_rad){\n  complex<double> src = deq[0];\n  complex<double> mid = deq[1];\n  complex<double> dst = deq[2];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  double remaining_distance;\n  deque<complex<double> > deq;\n  State(int _ct,int _c,double _r,const deque<complex<double> >& _d) :\n    city(_ct), carrots(_c), remaining_distance(_r),deq(_d) {}\n\n  State(int _ct,int _c,double _r,complex<double> _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    deq.push_back(_d);\n  }\n\n  bool operator <(const State& s) const{\n    return carrots < s.carrots;\n  }\n};\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,cities[0]));\n    int max_carrots = 0;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\t\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tdeque<complex<double> > deq = s.deq;\n\t\n\tdeq.push_back(cities[to]);\n\twhile(deq.size() > 3) deq.pop_front();\n\n\tif(deq.size()==3){\n\t  if(!check(deq,limit_rad)) continue;\n\t}\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tState next(to,s.carrots+1,s.remaining_distance - dist,deq);\n\tque.push(next);\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ndouble dp[405][25][25];\nbool ok[25][25][25];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  double PI = atan2(1, 0)*2, EPS = 1e-8;\n  // cout << PI << endl;\n\n  int n;\n  double r, t;\n  cin >> n >> r >> t;\n  t *= PI/180;\n  VI x(n), y(n);\n  REP(i, n) cin >> x[i] >> y[i];\n\n  if(n == 1) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  REP(i, n) REP(j, n) REP(k, n) {\n    if(i == j || j == k || k == i) continue;\n    double ang1 = atan2(y[j]-y[i], x[j]-x[i]);\n    double ang2 = atan2(y[j]-y[k], x[j]-x[k]);\n    if(abs(ang1 - ang2) < t + EPS) {\n      ok[i][j][k] = true;\n    }\n  }\n\n  int ans = 0;\n  REP(i, 405) REP(j, n) REP(k, n) dp[i][j][k] = INF;\n  FOR(i, 1, n) {\n    dp[1][0][i] = sqrt((x[i]-x[0])*(x[i]-x[0])+(y[i]-y[0])*(y[i]-y[0]));\n    if(dp[1][0][i] < r) {\n      chmax(ans, 1LL);\n    }\n  }\n\n  FOR(i, 1, n*(n-1)/2) REP(j, n) REP(k, n) {\n    REP(l, n) {\n      // j->k->lが可能ならば遷移\n      if(ok[j][k][l]) {\n        double dist = sqrt((x[k]-x[l])*(x[k]-x[l])+(y[k]-y[l])*(y[k]-y[l]));\n        chmin(dp[i+1][k][l], dp[i][j][k] + dist);\n        if(dp[i+1][k][l] < r) {\n          chmax(ans, i+1);\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int MAX = 20,LIMIT = 30000,IINF = INT_MAX;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nstruct Edge{\n  int to;\n  double weight;\n  Edge(int to=0,double weight=0):to(to),weight(weight){}\n};\n\nstruct Data{\n  int prev,cur,carrot;\n  double dist;\n  Data(int prev=0,int cur=0,int carrot=0,double dist=0):prev(prev),cur(cur),carrot(carrot),dist(dist){}\n  bool operator < (const Data& data) const{ return dist > data.dist; }\n};\n\nint n;\ndouble r,theta,mindist[MAX][MAX][LIMIT]; // mindist[cur][prev][the number of carrot]\nPoint ps[MAX];\nvector<Edge> edge[MAX][MAX]; // edge[cur][prev]\n\ninline void dijkstra(){\n  rep(i,n)rep(j,n)rep(k,LIMIT) mindist[i][j][k] = IINF;\n  priority_queue<Data> Q;\n\n  REP(i,1,n) {\n    double dist = abs(ps[0]-ps[i]);\n    if( !equals(dist,r) && dist > r ) continue;\n    Q.push(Data(0,i,1,dist));\n    mindist[i][0][1] = dist;\n  }\n  int ans = (Q.empty()?0:1);\n\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n    int prev = data.prev, cur = data.cur, carrot = data.carrot;\n    double dist = data.dist;\n    assert(carrot+1 < LIMIT);\n    if( !equals(mindist[cur][prev][carrot],dist) && mindist[cur][prev][carrot] < dist ) continue;\n\n    rep(i,edge[cur][prev].size()) {\n      int next = edge[cur][prev][i].to;\n      double weight = edge[cur][prev][i].weight;\n      if( !equals(r,dist+weight) && r < dist+weight ) continue;\n      if( mindist[next][cur][carrot+1] > dist + weight ){\n        mindist[next][cur][carrot+1] = dist + weight;\n\n        ans = max(ans,carrot+1);\n        Q.push(Data(cur,next,carrot+1,dist+weight));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\ninline void makeEdge(){\n  rep(prev,n){\n    rep(cur,n){\n      if( cur == prev ) continue;\n      rep(next,n){\n        if( next == cur || next == prev ) continue;\n        double dist = abs(ps[cur]-ps[next]);\n        if( !equals(dist,r) && dist > r ) continue;\n        Vector v1 = ps[next] - ps[cur];\n        Vector v2 = ps[cur]  - ps[prev];\n        if( equals(cross(v1,v2),0.0) ) continue;\n        double arg = getArg(ps[prev],ps[cur],ps[next]);\n        if( equals(arg,theta) || arg < theta ) edge[cur][prev].push_back(Edge(next,dist));\n      }\n    }\n  }\n}\n\nint main(){\n\n  /*\n  int next = 2, cur = 1, prev = 0;\n  ps[0] = Point(0,0);\n  ps[1] = Point(10,0);\n  ps[2] = Point(0,1);\n  double arg =  getArg(ps[prev],ps[cur],ps[next]);\n  cout << \"arg = \" << arg * 180.0 / M_PI << endl;\n  */\n\n  cin >> n;\n  cin >> r >> theta;\n  theta = toRad(theta);\n  rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n\n  makeEdge();\n\n  dijkstra();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n};\n\nint main()\n{\n    int n;\n    double r, theta;\n    cin >> n >> r >> theta;\n    theta *= PI / 180;\n\n    vector<Point> p(n);\n    for(int i=0; i<n; ++i)\n        cin >> p[i].x >> p[i].y;\n\n    vector<vector<double> > dp(n, vector<double>(n, -1.0));\n    for(int i=1; i<n; ++i)\n        dp[i][0] = r - p[0].dist(p[i]);\n\n    int ret = 0;\n    for(;;){\n        double maxRest = -1.0;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                maxRest = max(maxRest, dp[i][j]);\n            }\n        }\n        if(maxRest < 0){\n            cout << ret << endl;\n            return 0;\n        }\n\n        vector<vector<double> > next(n, vector<double>(n, -1.0));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                for(int k=0; k<n; ++k){\n                    if(i == k)\n                        continue;\n\n                    double angle = acos((p[i] - p[j]).dot(p[k] - p[i]) / (p[i] - p[j]).length() / (p[k] - p[i]).length());\n                    if(angle > theta)\n                        continue;\n\n                    next[k][i] = max(next[k][i], dp[i][j] - p[i].dist(p[k]));\n                }\n            }\n        }\n        dp.swap(next);\n\n        ++ ret;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nstruct edge {\n\tint from;\n\tint to;\n\tdouble dis;\n\tdouble kaku;\n\n};\nstruct aa {\n\tedge e;\n\tint carrot;\n\tdouble time;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time > r.time;\n\t}\n};\ndouble memo[20][20][10001];\nint main() {\n\tint n; cin >> n;\n\tdouble r, theta; cin >> r >> theta;\n\tvector<Point>ps;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\n\tvector<vector<edge>>edges(n);\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tconst double dis = abs(ps[i] - ps[j]);\n\t\t\t\t double kaku = ptod*acos(dot(ps[j] - ps[i], Point(1, 0)) / dis);\n\t\t\t\t if (ps[j].imag() < ps[i].imag())kaku=-kaku;\n\t\t\t\tedges[i].push_back(edge{ i, j, dis, kaku });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tedges[i].push_back(edge{ i, j, 99999999999, 0 });\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\n\n\n\tfor (int i = 0; i < 20; ++i) {\n\t\tfor (int j = 0; j < 20; ++j) {\n\t\t\tfor (int k = 0; k <= 10000; ++k) {\n\t\t\t\tmemo[i][j][k] = r+1e-5;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (edges[0][i].dis < r) {\n\t\t\tque.push(aa{ edges[0][i],1,edges[0][i].dis });\n\t\t\tmemo[0][i][1] = edges[0][i].dis;\n\n\t\t}\n\t}\n\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tconst int now = atop.e.to;\n\t\tconst double ndis = atop.time;\n\t\tconst double nkaku = atop.e.kaku;\n\t\tfor (auto i : edges[now]) {\n\t\t\tconst int nextid = i.to;\n\t\t\tconst int nextcarrot = atop.carrot + 1;\n\t\t\tconst double nextdis = ndis + i.dis;\n\t\t\tdouble nextkaku = i.kaku;\n\t\t\tif (nextdis < memo[now][nextid][nextcarrot]){\n\t\t\t\tdouble sakaku = abs(nextkaku - nkaku);\n\t\t\t\tif (sakaku > 360)sakaku -= 360;\n\t\t\t\tif (sakaku > 180)sakaku = 360 - sakaku;\n\t\t\t\tif (sakaku < theta) {\n\t\t\t\t\tmemo[now][nextid][nextcarrot] = nextdis;\n\t\t\t\t\tque.push(aa{ i,nextcarrot,nextdis });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < 20; ++i) {\n\t\tfor (int j = 0; j < 20; ++j) {\n\t\t\tfor (int k = 0; k <= 10000; ++k) {\n\t\t\t\tif (memo[i][j][k] <= r) {\n\t\t\t\t\tans = max(ans, k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nint n;\ndouble dp[10001][21][21]={};\ndouble x[21],y[21],r,s;\nbool b[21][21][21]={};\n\ndouble abs(int a,int b){\n  return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n}\n\ndouble dot(int i,int j,int k){\n  return (x[i]-x[j])*(x[k]-x[j])+(y[i]-y[j])*(y[k]-y[j]);\n}\n\nint main()\n{\n  cin>>n>>r>>s;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(i==j || j==k || i==k){\n\t  b[i][j][k]=false;\n\t  continue;\n\t}\n\tdouble R=acos(dot(i,j,k)/(double)(abs(i,j)*abs(j,k)));\n\tR=R*360/(2.0*pi);\n\tR=min(R,360-R);\n\tif(((180-R)-s)<eps)b[i][j][k]=true;\n\telse b[i][j][k]=false;\n      }\n    }\n  }\n\n  for(int i=0;i<10001;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tdp[i][j][k]=inf;\n\n  for(int i=1;i<n;i++)dp[0][0][i]=abs(0,i);\n\n  int ans=1;\n  for(int c=1;c<10001;c++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  if(b[i][j][k]){\n\t    dp[c][j][k]=min(dp[c][j][k],dp[c-1][i][j]+abs(k,j));\n\t    if(dp[c][j][k]-r<eps)ans=max(c+1,ans);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 21;\nconst int MAXX = 10001;\nconst double eps = 1e-6;\nconst double inf = 1e10;\n\nint n;\ndouble r, th;\nP ps[MAXN];\ndouble dp[MAXX][MAXN][MAXN];\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble getAngle(P a, P b) {\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nint main() {\n  while(cin >> n) {\n    cin >> r >> th;\n    th = th * M_PI / 180.0;\n    for(int i = 0; i < n; ++i)\n      cin >> ps[i].real() >> ps[i].imag();\n    fill(dp[0][0], dp[MAXX][0], inf);\n    dp[0][0][0] = 0;\n    int res = 0;\n    for(int i = 0; i+1 < MAXX; ++i) {\n      if(i != res) break;\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < n; ++k) {\n          if(dp[i][j][k] == inf) continue;\n          for(int l = 0; l < n; ++l) {\n            if(k == l) continue;\n            if(j != k) {\n              double rad = getAngle(ps[k]-ps[j], ps[l]-ps[k]);\n              if(rad > th + eps) continue;\n            }\n            dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + abs(ps[l]-ps[k]));\n            if(dp[i+1][k][l] < r + eps) {\n              res = i + 1;\n            }\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#define scanf_s scanf\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\n\nint main(void){\n\tint n,ans,i,j,k,ok;\n\tdouble r,sit;\n\tdouble x[20];\n\tdouble y[20];\n\tdouble dp[20][20]={0};//x??????y????????????\n\tdouble dpc[20][20]={0};\n\tdouble d;\n\tdouble pi=3.141592653589793238462643383279502884197;\n\tscanf(\"%d\",&n);\n\tscanf(\"%lf %lf\",&r,&sit);\n\tsit=(sit/180)*pi;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i][j]=0;\n\t\t\tdpc[i][j]=big;\n\t\t}\n\t}\n\tfor(ans=0;;ans++){\n\t\tfor(k=0;k<n;k++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif((k-i)*(i-j)*(j-k)==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td=abs(atan2(y[i]-y[k],x[i]-x[k])-atan2(y[k]-y[j],x[k]-x[j]));\n\t\t\t\t\tif(min(2*pi-d,d)>sit){continue;}\n\t\t\t\t\tdpc[k][j]=min(dpc[k][j],dp[i][k]+hypot(x[k]-x[j],y[k]-y[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tdp[i][j]=dpc[i][j];\n\t\t\t\tif(dpc[i][j]<r){\n\t\t\t\t\tok=1;\n\t\t\t\t}\n\t\t\t\tdpc[i][j]=big;\n\t\t\t}\n\t\t}\n\t\tif(ok==0){break;}\n\t}\n\tprintf(\"%d\\n\",max(ans,1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  R r, th; cin >> r >> th, th *= pi / 180;\n  V<P> p(n); for (auto&& e : p) cin >> e;\n  VV< V<> > ks(20, VV<>(20));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    for (int k = 0; k < n; ++k) if (k != j) {\n      L s{p[i], p[j]}, t{p[j], p[k]};\n      R ph = fmod(3 * pi + t.arg() - s.arg(), 2 * pi) - pi;\n      if (sgn(abs(ph), th) <= 0) ks[i][j].push_back(k);\n    }\n  }\n  VV<R> dp(20, V<R>(20, 1e10));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    dp[i][j] = distPP(p[i], p[j]);\n  }\n  int res = 0;\n  for (int s = 0; s <= 1e4; ++s) {\n    VV<R> ndp(20, V<R>(20, 1e10));\n    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n      if (sgn(dp[i][j], r) <= 0) res = s + 1;\n      for (int k : ks[i][j]) {\n        ndp[i][j] = min(ndp[i][j], distPP(p[i], p[j]) + dp[j][k]);\n      }\n    }\n    swap(dp, ndp);\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll read(){ll i;cin>>i;return i;}\n\nusing ld=long double;\nusing cm=complex<ld>;\n#define x real()\n#define y imag()\nconst ld eps=1e-7;\nconst ld PI=acos(ld(-1));\nint sgn(ld a){return a<-eps?-1:(a>eps?1:0);}\nauto cmcmp=[](const cm&a,const cm&b){\n\tif(sgn(a.x-b.x))return a.x<b.x;\n\telse return sgn(a.y-b.y)<0;\n};\nld dot(cm a,cm b){return a.x*b.x+a.y*b.y;}\nld crs(cm a,cm b){return a.x*b.y-a.y*b.x;}\nint ccw(cm a,cm b){return sgn(crs(a,b));}\nint ccw(cm a,cm b,cm c){return ccw(b-a,c-a);}\n//AOJ1183\nint qeq(ld a,ld b,ld c,ld&d,ld&e){\n\tld f=b*b-4*a*c;\n\tif(sgn(f)<0)return 0;\n\tld g=sqrt(max(f,ld(0)));\n\td=(-b+g)/(2*a);\n\te=(-b-g)/(2*a);\n\treturn sgn(f)+1;\n}\n//(-2)[a,-1](0)[b,1](2)\nint bet(cm a,cm b,cm c){\n\tcm d=b-a;\n\tld e=dot(d,c-a);\n\tif(sgn(e)<=0)return sgn(e)-1;\n\treturn sgn(e-norm(d))+1;\n}\nld tri2(cm a,cm b,cm c){\n\treturn crs(b-a,c-a);\n}\n//AOJ0153\n//0-no,1-edge,2-in\nint cont(cm a,cm b,cm c,cm d){\n\tif(ccw(a,b,c)==-1)\n\t\tswap(b,c);\n\treturn min({ccw(a,b,d),ccw(b,c,d),ccw(c,a,d)})+1;\n}\n//AOJ1183\n//arg between ab\n//assume given lengths are valid\nld arg(ld a,ld b,ld c){\n\treturn acos(min(max((a*a+b*b-c*c)/(2*a*b),ld(-1)),ld(1)));\n}\n\n//a->b->c と進むときに曲がる角度\n//a-b-cが一直線上にあれば0が帰る\nld turn(cm a,cm b,cm c){\n\treturn arg((c-b)/(b-a));\n}\n\nconst int N=22;\nconst int R=10010;\nbool can[N][N][N];\nld ds[N][N],dp[R][N][N];\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(20);\n\t\n\trep(i,R)rep(j,N)rep(k,N)\n\t\tdp[i][j][k]=1e9;\n\t\n\tint n=read();\n\tld r,t;\n\tcin>>r>>t;\n\tt*=PI/180;\n\tvc<cm> a;\n\trep(i,n){\n\t\tint b=read(),c=read();\n\t\ta.eb(b,c);\n\t}\n\trep(i,n)rep(j,n)if(i!=j)rep(k,n)if(i!=k&&j!=k)\n\t\tcan[i][j][k]=sgn(abs(turn(a[i],a[j],a[k]))-t)<=0;\n\t\n\trep(i,n)rep(j,n)if(i!=j)\n\t\tds[i][j]=abs(a[i]-a[j]);\n\trng(i,1,n)\n\t\tdp[1][0][i]=ds[0][i];\n\t\n\tint ans=0;\n\trng(z,1,R-1){\n\t\trep(i,n)rep(j,n)if(sgn(dp[z][i][j]-r)<=0){\n\t\t\tans=z;\n\t\t\trep(k,n)if(can[i][j][k])\n\t\t\t\tchmin(dp[z+1][j][k],dp[z][i][j]+ds[j][k]);\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 30;\nint x[N], y[N];\n\ndouble dist[10010][N][N];\n\nvector<int> G[N][N];\ndouble D[N][N];\n\nconst double PI = 4 * atan(1);\nconst double EPS = 1e-9;\n\nint main(){\n\tint n;\n\tdouble r, theta;\n\tcin >> n >> r >> theta;\n\ttheta = theta / 180 * PI;\n\trep(i, n) cin >> x[i] >> y[i];\n\n\trep(i, n) rep(j, n){\n\t\tD[i][j] = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));\n\t}\n\n\trep(i, n) rep(j, n) rep(k, n){\n\t\tif (i == j || j == k) continue;\n\t\tdouble x1 = x[j] - x[i], y1 = y[j] - y[i];\n\t\tdouble x2 = x[k] - x[j], y2 = y[k] - y[j];\n\n\t\tdouble ct = (x1*x2 + y1*y2) / (D[i][j]*D[j][k]);\n\t\tdouble t = acos(ct);\n\n\t\tif (abs(t) < theta + EPS) G[i][j].push_back(k);\n\t}\n\n\tMEMSET(dist, 0x7f);\n\tpriority_queue<tuple<double, int, int, int>> pq;\n\n\trep(i, n) rep(j, n){\n\t\tif (i == j) continue;\n\t\tif (D[i][j] > r - EPS) continue;\n\t\tpq.emplace(-D[i][j], 1, i, j);\n\t\tdist[1][i][j] = D[i][j];\n\t}\n\n\tint ans = 0;\n\twhile (!pq.empty()){\n\t\tauto t = pq.top();\n\t\tpq.pop();\n\t\tdouble d;\n\t\tint c, prv, cur;\n\t\ttie(d, c, prv, cur) = t;\n\t\td = -d;\n\n\t\tif (dist[c][prv][cur] + EPS < d) continue;\n\n\t\tans = max(ans, c);\n\n\t\tfor (auto v : G[prv][cur]){\n\t\t\tdouble nd = d + D[cur][v];\n\t\t\tif (r < nd + EPS) continue;\n\t\t\tif (dist[c + 1][cur][v] < nd + EPS) continue;\n\t\t\tdist[c + 1][cur][v] = nd;\n\t\t\tpq.emplace(-nd, c + 1, cur, v);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\n#define pow2(a) (pow(1.*a,2))\ntypedef struct D\n{\n\tint c,pp,np;\n\tdouble d;\n\tbool operator <(const D &a)const{ return c<a.c;};\n}D;\n\nint N,X[25],Y[25],res=0;\ndouble R,O,d[25][25],F[30][1000000];\ndouble ang(int pre,int now,int next)\n{\n\tdouble a=d[pre][now],b=d[now][next],c=d[pre][next];\n\tdouble dd=acos((pow2(a)+pow2(b)-pow2(c))/(2*a*b));\n\tdouble df=180-(dd*180/3.141592);\n\treturn df;\n}\n\nint main()\n{\n\tscanf(\"%d%lf%lf\",&N,&R,&O);\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",X+i,Y+i);\n\tfor(int i=0;i<N;i++)\n\n\t\tfor(int j=0;j<N;j++)\n\t\t\td[i][j]=sqrt(pow2(X[i]-X[j])+pow2(Y[i]-Y[j]));\n\tpriority_queue<D>Q;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tif(d[0][i]>R)continue;\n\t\tD tmp={1,0,i,d[0][i]};\n\t\tF[i][1]=d[0][i];\n\t\tQ.push(tmp);\n\t}\n\tfor(;!Q.empty();)\n\t{\n\t\tD tmp=Q.top();Q.pop();\n\t\tres=max(res,tmp.c);\n\t\tif(F[tmp.np][tmp.c]<tmp.d)continue;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(i==tmp.np)continue;\n\t\t\tif(ang(tmp.pp,tmp.np,i)<=O&&tmp.d+d[tmp.np][i]<=R)\n\t\t\t{\n\t\t\t\tD ins={tmp.c+1,tmp.np,i,tmp.d+d[tmp.np][i]};\n\t\t\t\tF[ins.np][ins.c]=ins.d;\n\t\t\t\tQ.push(ins);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n \ntypedef complex<double> P;\n \nstruct S{\n  int w,p,n;\n  double d;\n  bool operator<(S s)const{\n    return d>s.d;\n  }\n};\n \ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n \nint main(){\n  int n;\n  double r,th;\n  cin>>n>>r>>th;\n  P p[21];\n  for(int i=1;i<=n;i++){\n    int x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<S> que;\n  que.push({1,0,0,0});\n  static bool mem[21][21][22222];\n  int m=0;\n  while(!que.empty()){\n    auto cs=que.top();\n    if(cs.d>r+1e-9)break;\n    que.pop();\n    if(mem[cs.w][cs.p][cs.n]++)continue;\n    m=max(m,cs.n);\n    for(int i=1;i<=n;i++){\n      if(i==cs.w)continue;\n      auto f=p[cs.w]-p[cs.p];\n      auto t=p[i]-p[cs.w];\n      if(cs.p&&acos(dot(f,t)/abs(f)/abs(t))*90>th*acos(0))continue;\n      que.push({i,cs.w,cs.n+1,cs.d+abs(t)});\n    }\n  }\n  cout<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst long double PI = 3.14159255358979323846264338327950288l;\nstruct Point { long double px, py; };\nlong double theta(long double a, long double b, long double c) {\n\tlong double s = (a + b + c) / 2.0l;\n\tlong double S = sqrtl(s*(s - a)*(s - b)*(s - c));\n\tlong double A = -1000, B = -1000, C = -1000, H;\n\n\tif (a > b && a > c) { H = 2.0l * S / a; B = asin(H / c)*180.0l / PI; C = asin(H / b)*180.0l / PI; A = 180.0l - B - C; }\n\telse if (b > a && b > c) { H = 2.0l * S / b; A = asin(H / c)*180.0l / PI; C = asin(H / a)*180.0l / PI; B = 180.0l - A - C; }\n\telse { H = 2.0l * S / c; A = asin(H / b)*180.0l / PI; B = asin(H / a)*180.0l / PI; C = 180.0l - A - B; }\n\n\treturn A;\n}\nlong double theta_(Point a, Point b, Point c) {\n\t//a->b->c\n\tlong double A1 = sqrtl((a.px - c.px)*(a.px - c.px) + (a.py - c.py)*(a.py - c.py));\n\tlong double B1 = sqrtl((a.px - b.px)*(a.px - b.px) + (a.py - b.py)*(a.py - b.py));\n\tlong double C1 = sqrtl((b.px - c.px)*(b.px - c.px) + (b.py - c.py)*(b.py - c.py));\n\treturn theta(A1, B1, C1);\n}\nlong double dp[22][22], prev_[22][22], r, t; Point x[30]; int n;\nint main() {\n\tcin >> n >> r >> t;\n\tfor (int i = 0; i < n; i++)cin >> x[i].px >> x[i].py;\n\tfor (int i = 0; i < 22; i++) { for (int j = 0; j < 22; j++) { dp[i][j] = 999999999.9l; prev_[i][j] = 999999999.9l; } }\n\tfor (int i = 0; i < n; i++) { if (i != 0) { prev_[0][i] = sqrtl((x[0].px - x[i].px)*(x[0].px - x[i].px) + (x[0].py - x[i].py)*(x[0].py - x[i].py)); } }\n\tint maxn = 0;\n\tfor (int i = 1; i < 20000; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tif (j == k || k == l)continue;\n\t\t\t\t\tlong double T = theta_(x[j], x[k], x[l]); T = 180.0l - T;\n\t\t\t\t\tlong double dst = sqrtl((x[k].px - x[l].px)*(x[k].px - x[l].px) + (x[k].py - x[l].py)*(x[k].py - x[l].py));\n\t\t\t\t\tif (T >= t)continue;\n\t\t\t\t\tdp[k][l] = min(dp[k][l], prev_[j][k] + dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (prev_[j][k] < r)maxn = i;\n\t\t\t\tprev_[j][k] = dp[j][k]; dp[j][k] = 999999999.9l;\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct S{\n  double d;\n  int u, v, x;\n  S(double d, int u, int v, int x) : d(d), u(u), v(v), x(x) {}\n};\nbool operator < (const S& s, const S& t){\n  return s.d > t.d;\n}\ndouble sq(double x, double y){\n  return x*x + y*y;\n}\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    double r, a; cin>>r>>a;\n    double x[20], y[20];\n    double d[20][20];\n    bool ok[20][20][20] = {};\n    REP(i, N) cin>>x[i]>>y[i];\n    REP(u, N)FOR(v, u, N){\n      d[u][v] = d[v][u] = sqrt(sq(x[u] - x[v], y[u] - y[v]));\n    }\n    REP(u, N)REP(v, N)REP(t, N){\n      if(u == v || v == t || t == u) ok[u][v][t] = false;\n      else{\n        double cot = (x[v] - x[u]) * (x[t] - x[v]) + (y[v] - y[u]) * (y[t] - y[v]);\n        cot /= d[u][v];\n        cot /= d[v][t];\n        ok[u][v][t] = (cos(a) < cot + EPS);\n      }\n    }\n    priority_queue<S> que;\n    FOR(i, 1, N){\n      que.push(S(d[0][i], 0, i, 1));\n    }\n    bool used[20][20][10001] = {};\n    int ans = 0;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      if(s.d > r + EPS) break;\n      if(used[s.u][s.v][s.x]) continue;\n      else used[s.u][s.v][s.x] = true;\n      ans = max(ans, s.x);\n      REP(to, N)if(ok[s.u][s.v][to]){\n        que.push(S(s.d + d[s.v][to], s.v, to, s.x + 1));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> dst = cities[city];\n\n  src -= cities[prev];\n  dst -= cities[prev];\n  double computed_arg = abs(arg(src) - arg(dst));\n\n  return (limit_rad >= M_PI - min(computed_arg,\n\t\t\t\t  abs(2.0*M_PI - computed_arg)) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\nbool isok[21][21][21]; //cur,prev,old\ndouble city_distance[21][21];\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    memset(isok,true,sizeof(isok));\n    for(int old = 0; old < total_cities; old++){\n      for(int prev = 0; prev < total_cities; prev++){\n\tfor(int cur = 0; cur < total_cities; cur++){\n\t  isok[cur][prev][old] = check(cur,prev,old,limit_rad,cities);\n\t  city_distance[cur][prev] = abs(cities[cur] - cities[prev]);\n\t}\n      }\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      int next_city,next_prev,next_old;\n      for(int to=0;to<total_cities;to++){\n\tif(to == s.city) continue;\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tnext_city = to;\n\tnext_prev = s.city;\n\tnext_old = s.prev;\n\tif(!isok[next_city][next_prev][next_old]) continue;\n\tif(dp[s.carrots+1][s.city][to] >= s.remaining_distance - city_distance[next_city][next_prev] - EPS) continue;\n\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - city_distance[next_city][next_prev]));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef complex<int> P;\n#define PI acos(-1)\n#define EPS 1e-10\n\nint n;\ndouble r, s;\nP xy[20];\ndouble dp[10101][20][20];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> n)\n\t{\n\t\tcin >> r >> s;\n\t\trep(i, 0, n)\n\t\t{\n\t\t\tdouble x, y; cin >> x >> y;\n\t\t\txy[i] = P(x, y);\n\t\t}\n\n\t\ts = PI * s / 180.0;\n\n\t\trep(i1, 0, 10101) rep(i2, 0, 20) rep(i3, 0, 20) dp[i1][i2][i3] = r;\n\n\t\trep(i, 1, n) dp[1][0][i] = abs(xy[0] - xy[i]);\n\n\t\tint ans = 0;\n\t\trep(i1, 1, 10100) rep(i2, 0, 20) rep(i3, 0, 20) if (dp[i1][i2][i3] <= r + EPS)\n\t\t{\n\t\t\tans = max(ans, i1);\n\n\t\t\trep(i4, 0, 20)\n\t\t\t{\n\t\t\t\tif (i4 == i3) continue;\n\t\t\t\tif (i4 == i2) continue;\n\n\t\t\t\tP vec32 = xy[i3] - xy[i2];\n\t\t\t\tP vec34 = xy[i4] - xy[i3];\n\n\t\t\t\tP vec = vec32 - vec34;\n\t\t\t\tdouble a = arg(vec);\n\t\t\t\tif (a < 0) a = arg(-vec); // 0???-?????????????¨???\n\t\t\t\tif (a < EPS) a = PI;\n\n\t\t\t\tif (a <= s) dp[i1 + 1][i3][i4] = min(dp[i1 + 1][i3][i4], dp[i1][i2][i3] + abs(xy[i3] - xy[i4]));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nconst int MOD = 1000000007;\n\ntemplate <typename T>\nvoid __dump__(std::ostream &os, const T &first) {\n    os << first;\n}\ntemplate <typename First, typename... Rest>\nvoid __dump__(std::ostream &os, const First &first, const Rest &... rest) {\n    os << first << \", \";\n    __dump__(os, rest...);\n}\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __dump__(os, __VA_ARGS__);                        \\\n        std::cerr << os.str() << std::endl;               \\\n    } while (0)\n\nusing P = complex<double>;\nP ps[21];\n\nconst double EPS = 1e-9;\nconst double INF = 1e9;\nvector<int> go[21][21];\ndouble dp[10001][21][21];\ndouble d[21][21];\n\nint main() {\n    int n;\n    double r, th;\n    cin >> n >> r >> th;\n    th = r*acos(-1)/180;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        ps[i] = P(x, y);\n    }\n    rep(i, n) rep(j, n) {\n        if (i == j) continue;\n        go[i][j].clear();\n        rep(k, n) {\n            if (j == k) continue;\n            double phi = arg((ps[k] - ps[j]) / (ps[j] - ps[i]));\n            if (abs(phi) <= th + EPS) {\n                go[i][j].push_back(k);\n                //dump(i, j, k);\n            }\n        }\n        d[i][j] = abs(ps[i] - ps[j]);\n    }\n    rep(i, 10001) rep(j, 21) rep(k, 21) dp[i][j][k] = INF;\n    rep(i, n) if (d[0][i] <= r + EPS) dp[1][0][i] = d[0][i];\n    FOR(i, 1, 10001) {\n        rep(j, n) rep(k, n) {\n            if (dp[i][j][k] == INF) continue;\n            for (auto &l : go[j][k]) {\n                dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + d[k][l]);\n            }\n        }\n    }\n    double ans = 0;\n    rrep(i, 10001) rep(j, n) rep(k, n) {\n        if (dp[i][j][k] <= r + EPS) {\n            ans = i;\n            goto END;\n        }\n    }\n END:;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#define scanf_s scanf\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\n\nint main(void){\n\tint n,ans,i,j,k,ok;\n\tdouble r,sit;\n\tdouble x[20];\n\tdouble y[20];\n\tdouble dp[20][20]={0};//x??????y????????????\n\tdouble dpc[20][20]={0};\n\tdouble d;\n\tdouble pi=3.141592653589793238462643383279502884197;\n\tscanf(\"%d\",&n);\n\tscanf(\"%lf %lf\",&r,&sit);\n\tsit=(sit/180)*pi;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tfor(ans=0;;ans++){\n\t\tfor(k=0;k<n;k++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif((k-i)*(i-j)*(j-k)==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td=abs(atan2(y[i]-y[k],x[i]-x[k])-atan2(y[k]-y[j],x[k]-x[j]));\n\t\t\t\t\tif(min(2*pi-d,d)>sit){continue;}\n\t\t\t\t\tdpc[k][j]=min(dpc[k][j],dp[i][k]+hypot(x[k]-x[j],y[k]-y[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tdp[i][j]=dpc[i][j];\n\t\t\t\tif(dpc[i][j]<r){\n\t\t\t\t\tok=1;\n\t\t\t\t}\n\t\t\t\tdpc[i][j]=big;\n\t\t\t}\n\t\t}\n\t\tif(ok==0){break;}\n\t}\n\tprintf(\"%d\",ans-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 22;\nconst double pi = acos(-1);\nconst double inf = 1e100;\nconst double eps = 1e-5;\n\nint N;\ndouble R, T;\nP ps[MAXN];\ndouble G[MAXN][MAXN][MAXN]; // from, to, pre\ndouble dp[2][MAXN][MAXN]; // t, pos, pre\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint main() {\n  while(cin >> N) {\n    cin >> R >> T;\n    T = T * pi / 180.0;\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    fill(G[0][0], G[MAXN][0], inf);\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < N; ++j) {\n\tif(i == j) continue;\n\tG[i][j][N] = abs(ps[i] - ps[j]);\n\tfor(int k = 0; k < N; ++k) {\n\t  if(i == k || j == k) continue;\n\t  P a = ps[j] - ps[i];\n\t  P b = ps[k] - ps[i];\n\t  double angle = pi - acos(dot(a,b)/(abs(a)*abs(b)));\n\t  if(equals(angle, T) || angle < T) {\n\t    G[i][j][k] = abs(ps[i] - ps[j]);\n\t  }\n\t}\n      }\n    }\n    fill(dp[0][0], dp[2][0], inf);\n    dp[0][0][N] = 0;\n    int res = 0;\n    for(int t = 0; ; ++t) {\n      bool flag = false;\n      int p = t % 2;\n      int q = 1 - p;\n      for(int i = 0; i < N; ++i)\n\tfor(int j = 0; j <= N; ++j)\n\t  dp[q][i][j] = inf;\n      for(int i = 0; i < N; ++i) {\n\tfor(int j = 0; j <= N; ++j) {\n\t  for(int k = 0; k < N; ++k) {\n\t    if(dp[p][i][j] == inf) continue;\n\t    double ncost = dp[p][i][j] + G[i][k][j];\n\t    if(!equals(ncost, R) && ncost > R) continue;\n\t    dp[q][k][i] = min(dp[q][k][i], ncost);\n\t    flag = true;\n\t    res = t+1;\n\t  }\n\t}\n      }\n      if(!flag) break;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct state {\n  int p, c, n;\n  float d;\n  bool operator<(const state &s) const { return d > s.d; }\n};\n\nint N, X[20], Y[20];\nfloat R, Theta;\nfloat d[20][20];\nbool angle[20][20][20];\nfloat dp[20][20][100000];\n\nfloat theta(int i, int j, int k) {\n  int x1 = X[k] - X[j], y1 = Y[k] - Y[j];\n  int x2 = X[j] - X[i], y2 = Y[j] - Y[i];\n  float l1 = sqrt(x1 * x1 + y1 * y1);\n  float l2 = sqrt(x2 * x2 + y2 * y2);\n  float iprod = x1 * x2 + y1 * y2;\n  float rad = acos(iprod / l1 / l2);\n  return rad * 180 / M_PI;\n}\n\nint main(void) {\n  cin >> N >> R >> Theta;\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n\n  REP(i, 0, N) REP(j, 0, N) {\n    d[i][j] = sqrt((X[i] - X[j]) * (X[i] - X[j]) + (Y[i] - Y[j]) * (Y[i] - Y[j]));\n  }\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, N) {\n    if(i == j || j == k || k == i) angle[i][j][k] = false;\n    else angle[i][j][k] = theta(i, j, k) <= Theta + 10e-8;\n  }\n\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, 100000) dp[i][j][k] = 1e10;\n\n  priority_queue<state> q;\n  REP(i, 1, N) if(d[0][i] <= R + 1e-8) q.push((state) { 0, i, 1, d[0][i] });\n\n  int ans = 0;\n  while(q.size()) {\n    state c = q.top();\n    q.pop();\n\n    cout << c.c << endl;\n\n    if(dp[c.p][c.c][c.n] <= c.d) continue;\n    dp[c.p][c.c][c.n] = c.d;\n\n    ans = max(ans, c.n);\n\n    REP(i, 0, N) if(angle[c.p][c.c][i]) {\n      float nd = c.d + d[c.c][i];\n      if(dp[c.c][i][c.n + 1] <= nd) continue;\n      if(nd <= R + 1e-8) q.push((state) { c.c, i, c.n + 1, nd });\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble dp[10000][20][20];\n\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tdouble r,t;\n\tcin>>n>>r>>t;\n\tt=t*M_PI/180.0;\n\tint x[n],y[n];\n\tfor (int i = 0; i < n; ++i) cin>>x[i]>>y[i];\n\t\n\tbool moveok[n][n][n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tfor (int j = 0; j < n; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t{\n\t\t\t\tif(i==j||j==k||k==i) moveok[i][j][k]=0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdouble rad1=(double)(y[i]-y[j])/(x[i]-x[j]),rad2=(double)(y[j]-y[k])/(x[j]-x[k]);\n\t\t\t\t\tif(x[i]==x[j]) rad1=(y[i]>y[j])?-M_PI/2:M_PI/2;\n\t\t\t\t\telse if(x[i]-x[j]>0) rad1=atan(rad1)+M_PI;\n\t\t\t\t\telse rad1=atan(rad1);\n\t\t\t\t\tif(x[j]==x[k]) rad2=(y[j]>y[k])?-M_PI/2:M_PI/2;\n\t\t\t\t\telse if(x[j]-x[k]>0) rad2=atan(rad2)+M_PI;\n\t\t\t\t\telse rad2=atan(rad2);\n\t\t\t\t\tdouble rad=fabs(rad1-rad2);\n\t\t\t\t\twhile(rad>M_PI) rad-=2*M_PI;\n\t\t\t\t\tif(fabs(rad)<t+0.0001) moveok[i][j][k]=1;\n\t\t\t\t\telse moveok[i][j][k]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble distance[n][n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tfor (int j = 0; j < n; ++j)\n\t\t{\n\t\t\tdistance[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 10000; ++i)\n\t{\n\t\tfor (int j = 0; j < 20; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < 20; ++k)\n\t\t\t{\n\t\t\t\tdp[i][j][k]=1e6;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tif(distance[0][i]<=r+0.0001) dp[1][0][i]=distance[0][i],ans=1;\n\t}\n\n\tfor (int i = 1; i < 10000; ++i)\n\t{\n\t\tfor (int j = 0; j < n; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t{\n\t\t\t\tif(dp[i][j][k]!=1e6)\n\t\t\t\t{\n\t\t\t\t\tans = max(ans,i);\n\t\t\t\t\tfor (int l = 0; l < n; ++l)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(moveok[j][k][l])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[i+1][k][l]=min(dp[i+1][k][l],dp[i][j][k]+distance[k][l]);\n\t\t\t\t\t\t\tif(dp[i+1][k][l]>r+0.0001) dp[i+1][k][l]=1e6;\n\t\t\t\t\t\t\t//if(dp[i+1][k][l]>0) ans=max(ans,i+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nstruct point{\n  double x,y;\n};\n \ndouble INF = 1e9;\ndouble PI = acos(-1);\ndouble EPS = (1e-10);\ndouble dp[10001][20][20];\nint n;\ndouble Ti;\ndouble r,ti;\npoint t[20];\n \ndouble mem[20][20][20];\ndouble check(int to,int from,int prev){\n  if(mem[to][from][prev]!=-INF)return mem[to][from][prev];\n \n  if(to==from||to==prev)return INF;\n  double vax=t[to].x-t[from].x;\n  double vay=t[to].y-t[from].y;\n  double vbx=t[from].x-t[prev].x;\n  double vby=t[from].y-t[prev].y;\n  double ar=(vax*vbx+vay*vby)/(sqrt(vax*vax+vay*vay)*sqrt(vbx*vbx+vby*vby));\n  ar=acos(ar);\n  if(ar<ti+EPS){\n    mem[to][from][prev]=sqrt(vax*vax+vay*vay);\n  }else{\n    mem[to][from][prev]=INF;\n  }\n  return mem[to][from][prev];\n}\n \nvoid solve(int i,int j,int k){\n  for(int to=0;to<n;to++){\n    dp[i+1][to][j]=min(dp[i+1][to][j],dp[i][j][k]+check(to,j,k));\n \n    //dp[i][j][k]+sqrt(vax*vax+vay*vay));\n    //    if(ar<ti+EPS){\n    // dp[i+1][to][j]=min(dp[i+1][to][j],dp[i][j][k]+sqrt(vax*vax+vay*vay));\n    //    }\n  }\n}\n \nint main(){\n \n  for(int i=0;i<10001;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<20;k++)\n    dp[i][j][k]=INF;\n   \n  for(int i=0;i<20;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<20;k++)\n    mem[i][j][k]=-INF;\n \n  cin>>n>>r>>Ti;\n  ti=Ti/360.0*2.0*PI;\n \n  for(int i=0;i<n;i++)\n    cin>>t[i].x>>t[i].y;\n   \n  for(int i=1;i<n;i++){\n    double x=t[i].x-t[0].x;\n    double y=t[i].y-t[0].y;\n    dp[1][i][0]=sqrt(x*x+y*y);\n  }\n \n  int ans=0;\n  for(int i=1;i<=10000;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n    if(dp[i][j][k]>r+EPS)continue;\n    ans=max(ans,i);\n    solve(i,j,k);\n      }\n    }\n  }\n  cout<<ans<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n#define INF (1<<25)\nint N;\ndouble dp[2][21][21];\ndouble X[20] , Y[20];\nbool g[20][20][20];\ndouble dist[20][20];\n\ndouble PI = asin(0.5)*6;\ndouble EPS = 1e-7;\nint main(){\n\tcin >> N;\n\tdouble r , theta;\n\tcin >> r >> theta;\n\t\n\ttheta *= PI / 180;\n\trep(i,N) cin >> X[i] >> Y[i];\n\trep(i,N){\n\t\trep(j,N){\n\t\t\tint x1 = X[j] - X[i];\n\t\t\tint y1 = Y[j] - Y[i];\n\t\t\tdist[i][j] = sqrt(x1*x1+y1*y1);\n\t\t}\n\t}\n\trep(i,N){\n\t\trep(j,N){\n\t\t\tif( i != j ){\n\t\t\t\trep(k,N){\n\t\t\t\t\tif(j != k && i != k ){\n\t\t\t\t\t\tlong long x1 = X[j] - X[i];\n\t\t\t\t\t\tlong long y1 = Y[j] - Y[i];\n\t\t\t\t\t\tlong long x2 = X[k] - X[j];\n\t\t\t\t\t\tlong long y2 = Y[k] - Y[j];\n\t\t\t\t\t\tdouble t = acos( 1.0 * (x1*x2 + y1*y2) / ( sqrt(x1*x1+y1*y1) * sqrt(x2*x2+y2*y2) ) );\n\t\t\t\t\t\t//cout << i << \"-\" << j << \"-\" << k << \" : \" << \" (\" << x1 << \",\" << y1 << \")  \" << \" (\" << x2 << \",\" << y2 << \")  \" << t/PI*180 << \" \" << endl;\n\t\t\t\t\t\tif(y1*x2 == x1*y2){\n\t\t\t\t\t\t\t\tdouble A =  x1 / sqrt(x1*x1+y1*y1) , B = y1 / sqrt(x1*x1+y1*y1);\n\t\t\t\t\t\t\t\tdouble C =  x2 / sqrt(x2*x2+y2*y2) , D = y2 / sqrt(x2*x2+y2*y2);\n\t\t\t\t\t\t\t\t//cout << A << \" \" << B << \" {} \" << C << \" \" << D << endl;\n\t\t\t\t\t\t\t\tif( fabs(A-C) < EPS && fabs(B-D) < EPS)g[i][j][k] = true ;//, cout << i << \"-\" << j << \"-\" << k << endl;\n\t\t\t\t\t\t}else if(t < theta){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tg[i][j][k] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\trep(i,N){\n\t\trep(j,N){\n\t\t\trep(k,N){\n\t\t\t\tif(g[i][j][k])cout << i << \"-\" << j << \"-\" << k << \" : \" << g[i][j][k] << \" \" << endl;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}*/\n\trep(i,2)rep(j,N)rep(k,N) dp[i][j][k] = INF;\n\trep(i,N) if( i != 0 ) dp[0][0][i] = dist[0][i];\n\n\tint c = 0;\n\tfor(int i = 0 ; ; i++){\n\t\t//cout << \"[\" << i << \"]\" << endl;\n\t\t//rep(j,N)rep(k,N) if(dp[c][j][k] != INF) cout << j << \"-\" << k << \" : \" << dp[c][j][k] << endl;;\n\t\trep(j,N)rep(k,N) if(dp[c][j][k] < r + EPS){ goto allowed; }\n\t\t// end \n\t\tcout << i << endl;\n\t\treturn 0;\n\t\t\n\t\tallowed:;\n\t\t\n\t\trep(j,N)rep(k,N) dp[!c][j][k] = INF;\n\t\trep(j,N){\n\t\t\trep(k,N){\n\t\t\t\tif(dp[c][j][k] != INF){\n\t\t\t\t\trep(l,N){\n\t\t\t\t\t\tif(g[j][k][l]){\n\t\t\t\t\t\t\tdp[!c][k][l] = min( dp[c][j][k]+dist[k][l] , dp[!c][k][l] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc ^= 1;\n\t}\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> Pi;\ntypedef pair<double,int> Pd;\ntypedef pair<Pd,Pi> S;\n\nint n;\ndouble r,d;\nP p[20];\ndouble dp[20][20][10001];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint cal(){\n  priority_queue<S,vector<S>,greater<S> > Q;\n  int ans=0;\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)dp[j][k][i]=1e9;\n  dp[0][0][0]=0;\n  Q.push(S(Pd(0,0),Pi(0,0)));\n  while(!Q.empty()){\n    double cs=Q.top().first.first;\n    int i=Q.top().first.second;\n    int j=Q.top().second.first;\n    int k=Q.top().second.second;\n    Q.pop();\n    if(dp[j][k][i]<cs)continue;\n    if(cs>r)return ans;\n    for(int l=0;l<n;l++){\n      double ncs=cs+abs(p[k]-p[l]);\n      if(check(j,k,l)&&ncs<=r){\n\tif(dp[k][l][i+1]>ncs){\n\t  Q.push(S(Pd(cs+abs(p[k]-p[l]),i+1),Pi(k,l)));\n\t  dp[k][l][i+1]=ncs;\n\t}\n      }\n    }\n    ans=max(ans,i);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n>>r>>d;\n  double a,b;\n  for(int i=0;i<n;i++)cin>>a>>b,p[i]=P(a,b);\n  cout<<cal()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\nconst int MAX = 1e5+1;\nconst double EPS = 1e-6;\nconst double INF = 1e18;\nconst double PI = acos(-1);\ntypedef complex<double> P;\n\ndouble angle(P a, P b){\n    return abs(arg(a/b));\n}\n\nint main(){\n    int n;\n    double r, theta;\n    cin >> n >> r >> theta;\n    theta = theta/180*PI;\n\n    vector<P> xy(n);\n    for(int i=0; i<n; i++){\n        double x,y;\n        cin >> x >> y;\n        xy[i] = P(x,y);\n    }\n\n    vector<vector<vector<double> > > dp(n+1, vector<vector<double> >(n, vector<double>(MAX, INF)));\n    dp[n][0][0] = 0;\n    vector<vector<vector<bool> > > cango(n+1, vector<vector<bool> >(n, vector<bool>(n, true)));\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            for(int k=0; k<n; k++){\n                if(i==j || j==k || angle(xy[j]-xy[i], xy[k]-xy[j]) > theta +EPS){\n                    cango[i][j][k] = false;\n                }\n            }\n        }\n    }\n    int ans=0;\n    for(int k=0; k<MAX-1; k++){\n        for(int i=0; i<n+1; i++){\n            for(int j=0; j<n; j++){\n                if(dp[i][j][k]==INF) continue;\n                for(int p=0; p<n; p++){\n                    if(p==j) continue;\n                    if(!cango[i][j][p]) continue;\n                    double dist = dp[i][j][k] + abs(xy[p]-xy[j]);\n                    if(dist < dp[j][p][k+1] && dist < r +EPS){\n                        dp[j][p][k+1] = dist;\n                        ans = k+1;\n                    }\n                }\n            }\n        }\n        if(ans!=k+1) break;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\ndouble dp[20][20][2500];\nconst double PI = 3.1415926535;\nint main(){\n  int n,i,j,k,ans=0;cin>>n;\n  double r,arc;cin>>r>>arc;\n  arc=PI/180.0*arc;\n  Polygon g;g.resize(n);\n  for(i=0;i<n;i++) cin>>g[i].x>>g[i].y;\n  double e[n][n][n],inf=1<<28;\n  fill(e[0][0],e[0][0]+n*n*n,inf);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      for(k=0;k<n;k++){\n\tif(i==j||j==k||k==i) continue;\n\tVector a=g[j]-g[i],b=g[k]-g[j];\n\tif(fabs(acos(dot(a,b)/(abs(a)*abs(b))))<=arc)\n\t  e[i][j][k]=abs(g[k]-g[j]);\n      }\n    }\n  }\n  for(k=1;k<n;k++) e[0][0][k]=abs(g[k]-g[0]);\n  \n  fill(dp[0][0],dp[0][0]+20*20*2500,inf);\n  typedef pair<int,int> P;\n  typedef pair<int,P> PP;\n  typedef pair<double,PP> PPP;\n  priority_queue<PPP,vector<PPP>,greater<PPP> > q;\n  q.push(PPP(0.0,PP(0,P(0,n))));\n  while(!q.empty()){\n    PPP ppp=q.top();q.pop();\n    double d=ppp.first,z;\n    PP pp=ppp.second;\n    k=pp.first;\n    P p=pp.second;\n    if(d>r) continue;\n    ans=max(ans,k);\n    if(p.second==n){\n      for(i=0;i<n;i++){\n\tz=inf;\n\tfor(j=0;j<n;j++) z=min(z,e[j][0][i]);\n\tq.push(PPP(d+z,PP(k+1,P(i,p.first))));\n      }\n    }else{\n      if(dp[p.first][p.second][k]<=d) continue;\t\n      dp[p.first][p.second][k]=d;\n      for(i=0;i<n;i++)\n\tif(dp[i][p.first][k+1]>d+e[p.second][p.first][i])\n\t  q.push(PPP(d+e[p.second][p.first][i],PP(k+1,P(i,p.first))));\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(const deque<int>& deq,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[deq[0]];\n  complex<double> mid = cities[deq[1]];\n  complex<double> dst = cities[deq[2]];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _c,double _r,const deque<int>& _d) :\n    city(_ct), carrots(_c), remaining_distance(_r),deq(_d) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    deq.push_back(_d);\n  }\n\n  bool operator <(const State& s) const{\n    return carrots < s.carrots;\n  }\n};\n\nint dp[5001][9000]; //dp[carrot][visit history] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      while(s.deq.size() > 3) s.deq.pop_front();\n      int history = 0;\n      int digit = 1;\n\n      for(int i=0;i<s.deq.size();i++){\n\thistory += (s.deq[i]+1) * digit;\n\tdigit *= 21;\n      }\n\n      if(dp[s.carrots][history] >= s.remaining_distance) continue;\n      dp[s.carrots][history] = s.remaining_distance;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\t\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tdeque<int> deq = s.deq;\n\t\n\tdeq.push_back(to);\n\twhile(deq.size() > 3) deq.pop_front();\n\n\tif(deq.size()==3){\n\t  if(!check(deq,limit_rad,cities)) continue;\n\t}\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tState next(to,s.carrots+1,s.remaining_distance - dist,deq);\n\tque.push(next);\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> P;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9, PI = acos(-1);\n\nint n;\nP p[20];\ndouble r, t;\ndouble dp[20][20][10010], d[20][20];\nbool can[20][20][20];\n\nint main(){\n\tcin >> n >> r >> t;\n\tt *= PI / 180;\n\trep(i, n) cin >> p[i].real() >> p[i].imag();\n\t\n\trep(i, n) rep(j, n) rep(k, n) if(i != j && j != k){\n\t\tdouble a = abs(arg((p[j] - p[i]) / (p[k] - p[j])));\n\t\tcan[i][j][k] = a + EPS < t;\n\t}\n\trep(i, n) rep(j, n) d[i][j] = abs(p[i] - p[j]);\n\t\n\trep(i, n) rep(j, n) rep(k, 10010) dp[i][j][k] = INF;\n\trep(i, n) if(i) dp[0][i][1] = d[0][i];\n\t\n\tint ans = 0;\n\trep(k, 10010) rep(i, n) rep(j, n) if(dp[i][j][k] < r + EPS){\n\t\tans = max(ans, k);\n\t\trep(l, n) if(can[i][j][l]){\n\t\t\tdp[j][l][k + 1] = min(dp[j][l][k + 1], dp[i][j][k] + d[j][l]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct point{\n  double x,y;\n};\n\ndouble INF = 1e9;\ndouble PI = acos(-1);\ndouble EPS = (1e-10);\ndouble dp[10001][20][20];\nint n;\ndouble Ti;\ndouble r,ti;\npoint t[20];\n\ndouble mem[20][20][20];\ndouble check(int to,int from,int prev){\n  if(mem[to][from][prev]!=-INF)return mem[to][from][prev];\n\n  if(to==from||to==prev)return INF;\n  double vax=t[to].x-t[from].x;\n  double vay=t[to].y-t[from].y;\n  double vbx=t[from].x-t[prev].x;\n  double vby=t[from].y-t[prev].y;\n  double ar=(vax*vbx+vay*vby)/(sqrt(vax*vax+vay*vay)*sqrt(vbx*vbx+vby*vby));\n  ar=acos(ar);\n  if(ar<ti+EPS){\n    mem[to][from][prev]=sqrt(vax*vax+vay*vay);\n  }else{\n    mem[to][from][prev]=INF;\n  }\n  return mem[to][from][prev];\n}\n\nvoid solve(int i,int j,int k){\n  for(int to=0;to<n;to++){\n    dp[i+1][to][j]=min(dp[i+1][to][j],dp[i][j][k]+check(to,j,k));\n\n    //dp[i][j][k]+sqrt(vax*vax+vay*vay));\n    //    if(ar<ti+EPS){\n    // dp[i+1][to][j]=min(dp[i+1][to][j],dp[i][j][k]+sqrt(vax*vax+vay*vay));\n    //    }\n  }\n}\n\nint main(){\n\n  for(int i=0;i<10001;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<20;k++)\n\tdp[i][j][k]=INF;\n  \n  for(int i=0;i<20;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<20;k++)\n\tmem[i][j][k]=-INF;\n\n  cin>>n>>r>>Ti;\n  ti=Ti/360.0*2.0*PI;\n\n  for(int i=0;i<n;i++)\n    cin>>t[i].x>>t[i].y;\n  \n  for(int i=1;i<n;i++){\n    double x=t[i].x-t[0].x;\n    double y=t[i].y-t[0].y;\n    dp[1][i][0]=sqrt(x*x+y*y);\n  }\n\n  int ans=0;\n  for(int i=1;i<=10000;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(dp[i][j][k]>r+EPS)continue;\n\tans=max(ans,i);\n\tsolve(i,j,k);\n      }\n    }\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> dst = cities[city];\n\n  src -= cities[prev];\n  dst -= cities[prev];\n  double computed_arg = abs(arg(src) - arg(dst));\n\n  return (limit_rad >= M_PI - min(computed_arg,\n\t\t\t\t  abs(2.0*M_PI - computed_arg)) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[3001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n#include<climits>\n \n#define debug(x) cerr << #x << \": \" << x << endl\n#define EPS 1e-5\n \nusing namespace std;\n \nclass Vector {\n    public:\n    double x,y;\n    Vector(double x, double y): x(x), y(y) {}\n    double norm() const { return x*x + y*y; }\n    double dot(Vector p) const { return x*p.x + y*p.y; }\n};\n \nint main(){\n    int n;\n    double r, theta;\n    cin >> n;\n    cin >> r >> theta;\n    theta = theta/180.0*M_PI;\n    pair<double, double> cities[n];\n    for(int i=0;i<n;i++){\n        cin >> cities[i].first >> cities[i].second;\n    }\n \n    bool ok[n][n][n];\n    double dist[n][n];\n    fill(ok[0][0], ok[n-1][n], false);\n    fill(dist[0], dist[n], -1.0);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(i == j) continue;\n            Vector v = Vector(\n                    cities[j].first - cities[i].first,\n                    cities[j].second - cities[i].second\n                );\n            for(int k=0;k<n;k++){\n                if(j == k) continue;\n                Vector u = Vector(\n                        cities[k].first - cities[j].first,\n                        cities[k].second - cities[j].second\n                    );\n                double theta_ = acos(u.dot(v) / sqrt(v.norm() * u.norm()));\n                dist[j][k] = sqrt(u.norm());\n                if(theta-theta_ > EPS){\n                    ok[i][j][k] = true;\n                }\n            }\n        }\n    }\n\n    double dp[2][n][n];\n    int ans = 0;\n    fill(dp[0][0], dp[0][n], -1.0);\n    for(int j=0;j<n;j++){\n        if(dist[0][j] > EPS) dp[0][0][j] = dist[0][j];\n    }\n    bool flag = true;\n    int i = 0;\n    while(flag){\n        flag = false;\n        fill(dp[1-(i&1)][0], dp[1-(i&1)][n], 200000.0);\n        for(int j=0;j<n;j++){\n            for(int k=0;k<n;k++){\n                if(j == k || dp[i&1][j][k] - r > EPS) continue;\n                flag = true;\n                for(int l=0;l<n;l++){\n                    if(k == l) continue;\n                    if(ok[j][k][l]){\n                        dp[1-(i&1)][k][l] = min(dp[1-(i&1)][k][l], dp[i&1][j][k] + dist[k][l]);\n                    } \n                }\n            }\n        }\n        i++;\n    }\n \n    cout << i-2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst double pi = acos(-1);\nint n; double r, t;\nint main() {\n\tcin >> n >> r >> t; t *= pi / 180;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tint lim = (int)r;\n\tvector<vector<vector<double> > > dp(lim, vector<vector<double> >(n, vector<double>(n, 1.0e+10))); // (carrot - 2, now, prev)\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tdp[0][i][j] = hypot(x[i] - x[j], y[i] - y[j]);\n\t\t}\n\t}\n\tfor (int i = 1; i < lim; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (j == k) continue;\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tif (j == l) continue;\n\t\t\t\t\tdouble t2 = ((x[j] - x[k]) * (x[k] - x[l]) + (y[j] - y[k]) * (y[k] - y[l]));\n\t\t\t\t\tt2 /= hypot(x[j] - x[k], y[j] - y[k]);\n\t\t\t\t\tt2 /= hypot(x[k] - x[l], y[k] - y[l]);\n\t\t\t\t\tif (acos(t2) < t) dp[i][j][k] = min(dp[i][j][k], dp[i - 1][k][l] + hypot(x[j] - x[k], y[j] - y[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < lim; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (dp[i][j][k] < r) ret = max(ret, i + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nconst int MOD = 1000000007;\n\ntemplate <typename T>\nvoid __dump__(std::ostream &os, const T &first) {\n    os << first;\n}\ntemplate <typename First, typename... Rest>\nvoid __dump__(std::ostream &os, const First &first, const Rest &... rest) {\n    os << first << \", \";\n    __dump__(os, rest...);\n}\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __dump__(os, __VA_ARGS__);                        \\\n        std::cerr << os.str() << std::endl;               \\\n    } while (0)\n\nusing P = complex<double>;\nP ps[21];\n\nconst double EPS = 1e-9;\nconst double INF = 1e9;\nvector<int> go[21][21];\ndouble dp[10001][21][21];\ndouble d[21][21];\n\nint main() {\n    int n;\n    double r, th;\n    cin >> n >> r >> th;\n    th = r*acos(-1)/180;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        ps[i] = P(x, y);\n    }\n    rep(i, n) rep(j, n) {\n        if (i == j) continue;\n        go[i][j].clear();\n        rep(k, n) {\n            if (j == k) continue;\n            double phi = arg((ps[k] - ps[j]) / (ps[j] - ps[i]));\n            if (abs(phi) <= th + EPS) {\n                go[i][j].push_back(k);\n                //dump(i, j, k);\n            }\n        }\n        d[i][j] = abs(ps[i] - ps[j]);\n    }\n    rep(i, 10001) rep(j, 21) rep(k, 21) dp[i][j][k] = INF;\n    rep(i, n) if (i && d[0][i] <= r + EPS) dp[1][0][i] = d[0][i];\n    FOR(i, 1, 10001) {\n        rep(j, n) rep(k, n) {\n            if (dp[i][j][k] == INF) continue;\n            for (auto &l : go[j][k]) {\n                dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + d[k][l]);\n            }\n        }\n    }\n    double ans = 0;\n    rrep(i, 10001) rep(j, n) rep(k, n) {\n        if (dp[i][j][k] <= r + EPS) {\n            //dump(i, j, k);\n            ans = i;\n            goto END;\n        }\n    }\n END:;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(const deque<int>& deq,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[deq[0]];\n  complex<double> mid = cities[deq[1]];\n  complex<double> dst = cities[deq[2]];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _c,double _r,const deque<int>& _d) :\n    city(_ct), carrots(_c), remaining_distance(_r),deq(_d) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    deq.push_back(_d);\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[5001][9000]; //dp[carrot][visit history] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      while(s.deq.size() > 3) s.deq.pop_front();\n      int history = 0;\n      int digit = 1;\n\n      for(int i=0;i<s.deq.size();i++){\n\thistory += (s.deq[i]+1) * digit;\n\tdigit *= 21;\n      }\n\n      if(dp[s.carrots][history]) continue;\n      dp[s.carrots][history] = true;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\t\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tdeque<int> deq = s.deq;\n\t\n\tdeq.push_back(to);\n\twhile(deq.size() > 3) deq.pop_front();\n\n\tif(deq.size()==3){\n\t  if(!check(deq,limit_rad,cities)) continue;\n\t}\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tState next(to,s.carrots+1,s.remaining_distance - dist,deq);\n\tque.push(next);\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ndouble dp[405][25][25];\nbool ok[25][25][25];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  double PI = atan2(1, 0)*2, EPS = 1e-8;\n  // cout << PI << endl;\n\n  int n;\n  double r, t;\n  cin >> n >> r >> t;\n  t *= PI/180;\n  VI x(n), y(n);\n  REP(i, n) cin >> x[i] >> y[i];\n\n  if(n == 1) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  REP(i, n) REP(j, n) REP(k, n) {\n    if(i == j || j == k || k == i) continue;\n    double ang1 = atan2(y[j]-y[i], x[j]-x[i]);\n    double ang2 = atan2(y[j]-y[k], x[j]-x[k]);\n    if(abs(ang1 - ang2) < t + EPS) {\n      ok[i][j][k] = true;\n    }\n  }\n\n  int ans = 0;\n  REP(i, 405) REP(j, n) REP(k, n) dp[i][j][k] = INF;\n  REP(i, n) {\n    dp[1][0][i] = sqrt((x[i]-x[0])*(x[i]-x[0])+(y[i]-y[0])*(y[i]-y[0]));\n    if(dp[1][0][i] < r) {\n      chmax(ans, 1LL);\n    }\n  }\n\n  FOR(i, 1, n*(n-1)/2) REP(j, n) REP(k, n) {\n    REP(l, n) {\n      // j->k->lが可能ならば遷移\n      if(ok[j][k][l]) {\n        double dist = sqrt((x[k]-x[l])*(x[k]-x[l])+(y[k]-y[l])*(y[k]-y[l]));\n        chmin(dp[i+1][k][l], dp[i][j][k] + dist);\n        if(dp[i+1][k][l] < r) {\n          chmax(ans, i+1);\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 20;\nint x[N], y[N];\n\ndouble dist[10010][N][N];\n\nvector<int> G[N][N];\ndouble D[N][N];\n\nconst double PI = 4 * atan(1);\nconst double EPS = 1e-9;\n\nint main(){\n\tint n;\n\tdouble r, theta;\n\tcin >> n >> r >> theta;\n\ttheta = theta / 180 * PI;\n\trep(i, n) cin >> x[i] >> y[i];\n\n\trep(i, n) rep(j, n){\n\t\tD[i][j] = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));\n\t}\n\n\trep(i, n) rep(j, n) rep(k, n){\n\t\tif (i == j || j == k) continue;\n\t\tdouble x1 = x[i] - x[j], y1 = y[i] - y[j];\n\t\tdouble x2 = x[k] - x[j], y2 = y[k] - y[j];\n\n\t\tdouble ct = (x1*x2 + y1*y2) / (D[i][j]*D[j][k]);\n\t\tdouble t = PI - abs(acos(ct));\n\n\t\tif (abs(t) < theta + EPS) G[i][j].push_back(k);\n\t}\n\n\tMEMSET(dist, 0x7f);\n\n\tpriority_queue<tuple<double, int, int, int>> pq;\n\n\trep(i, n) rep(j, n){\n\t\tif (i == j) continue;\n\t\tif (D[i][j] > r - EPS) continue;\n\t\tpq.emplace(-D[i][j], 1, i, j);\n\t\tdist[1][i][j] = D[i][j];\n\t}\n\n\tint ans = 0;\n\twhile (!pq.empty()){\n\t\tauto t = pq.top();\n\t\tpq.pop();\n\t\tdouble d;\n\t\tint c, prv, cur;\n\t\ttie(d, c, prv, cur) = t;\n\t\td = -d;\n\n\t\tif (dist[c][prv][cur] + EPS < d) continue;\n\n\t\tans = max(ans, c);\n\n\t\tfor (auto v : G[prv][cur]){\n\t\t\tdouble nd = d + D[cur][v];\n\t\t\tif (r < nd + EPS) continue;\n\t\t\tif (dist[c + 1][cur][v] < nd + EPS) continue;\n\t\t\tdist[c + 1][cur][v] = nd;\n\t\t\tpq.emplace(-nd, c + 1, cur, v);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\ntypedef complex<double> Point;\n\ndouble angle(const Point& v1, const Point& v2) {\n    double res = arg(v1 / v2);\n    if (res < 0) res += 2*pi;\n    return min(2*pi-res, res);\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n; cin >> n;\n    double R, th; cin >> R >> th; th *= pi / 180;\n    vector<Point> v(n);\n    REP(i, n) {\n        ll x, y; cin >> x >> y;\n        v[i] = Point(x, y);\n    }\n    vector<vector<vector<bool>>> G(n, vector<vector<bool>>(n, vector<bool>(n, false)));\n    REP(i, n) REP(j, n) REP(k, n) {\n        if (i == j || j == k || k == i) continue;\n        // i -> j -> k ??¨????????????\n        Point v1 = v[j] - v[i];\n        Point v2 = v[k] - v[j];\n        if (angle(v1, v2) <= th+eps) {\n            G[i][j][k] = true;\n        }\n    }\n    vector<vector<double>> dist(n, vector<double>(n));\n    REP(i, n) REP(j, n) dist[i][j] = abs(v[i]-v[j]);\n    ll ans = 0;\n    vector<vector<vector<double>>> dp(2, vector<vector<double>>(n, vector<double>(n, linf)));\n    dp[0][0][0] = 0;\n    REP(t, 1010) {\n        dp[t+1&1].assign(n, vector<double>(n, linf));\n        REP(prev, n) REP(now, n) {\n            double l = dp[t&1][prev][now];\n            if (l > R+eps) continue;\n            ans = max(ans, t);\n            REP(to, n) {\n                if (prev != now && !G[prev][now][to]) continue;\n                if (now == to) continue;\n                dp[t+1&1][now][to] = min(dp[t+1&1][now][to], l + dist[now][to]);\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> mid = cities[prev];\n  complex<double> dst = cities[city];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[9001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,false,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      if(dp[s.carrots][s.prev][s.city]) continue;\n      dp[s.carrots][s.prev][s.city] = true;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 20;\nint x[N], y[N];\n\ndouble dist[10010][N][N];\n\nvector<int> G[N][N];\ndouble D[N][N];\nint ok[N][N][N];\n\nconst double PI = 4 * atan(1);\nconst double EPS = 1e-9;\n\nint main(){\n\tint n;\n\tdouble r, theta;\n\tcin >> n >> r >> theta;\n\ttheta = theta / 180 * PI;\n\trep(i, n) cin >> x[i] >> y[i];\n\n\trep(i, n) rep(j, n){\n\t\tD[i][j] = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));\n\t}\n\n\trep(i, n) rep(j, n) rep(k, n){\n\t\tif (i == j || j == k) continue;\n\t\tdouble x1 = x[j] - x[i], y1 = y[j] - y[i];\n\t\tdouble x2 = x[k] - x[j], y2 = y[k] - y[j];\n\n\t\tdouble ct = (x1*x2 + y1*y2) / (D[i][j]*D[j][k]);\n\t\tdouble t = acos(ct);\n\n\t\tif (abs(t) < theta + EPS) G[i][j].push_back(k), ok[i][j][k] = 1;\n\t}\n\n\tMEMSET(dist, 0x7f);\n\n\tpriority_queue<tuple<double, int, int, int>> pq;\n\n\trep(i, n) rep(j, n){\n\t\tif (i) continue;\n\t\tif (i == j) continue;\n\t\tif (D[i][j] > r - EPS) continue;\n\t\tpq.emplace(-D[i][j], 1, i, j);\n\t\tdist[1][i][j] = D[i][j];\n\t}\n\n\tint ans = 0;\n\twhile (!pq.empty()){\n\t\tauto t = pq.top();\n\t\tpq.pop();\n\t\tdouble d;\n\t\tint c, prv, cur;\n\t\ttie(d, c, prv, cur) = t;\n\t\td = -d;\n\n\t\tif (dist[c][prv][cur] + EPS < d) continue;\n\n\t\tans = max(ans, c);\n\n\t\tfor (auto v : G[prv][cur]){\n\t\t\tdouble nd = d + D[cur][v];\n\t\t\tif (r < nd + EPS) continue;\n\t\t\tif (dist[c + 1][cur][v] < nd + EPS) continue;\n\t\t\tdist[c + 1][cur][v] = nd;\n\t\t\tpq.emplace(-nd, c + 1, cur, v);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst double PI=acos(-1);\n\ntypedef complex<double>Point;\nint N;\ndouble R,T;\nbool ok[20][20][20];\nPoint ps[20];\n\nconst double INF=1e12;\ndouble dp[10010][20][20];\n\nsigned main(){\n    cin>>N>>R>>T;\n    T=T/180*PI;\n    rep(i,N){\n        double x,y;cin>>x>>y;\n        ps[i]=Point(x,y);\n    }\n    rep(i,N)rep(j,N)rep(k,N){\n        if(i==j||j==k||k==i)continue;\n        complex<double>a=ps[j]-ps[i],b=ps[k]-ps[j];\n        double tmp=real(a)*real(b)+imag(a)*imag(b);\n        tmp/=abs(a*b);\n        tmp=acos(tmp);\n        if(tmp<=T)ok[i][j][k]=true;\n    }\n\n    fill_n(**dp,10010*20*20,INF);\n    for(int i=1;i<N;i++)dp[1][i][0]=abs(ps[i]-ps[0]);\n\n    for(int i=1;i<R;i++){\n        for(int j=0;j<N;j++){\n            for(int k=0;k<N;k++){\n                for(int l=0;l<N;l++){\n                    if(!ok[k][j][l])continue;\n                    chmin(dp[i+1][l][j],dp[i][j][k]+abs(ps[l]-ps[j]));\n                }\n            }\n        }\n    }\n\n    int ma=0;\n    rep(i,R+1)rep(j,N)rep(k,N)if(dp[i][j][k]<=R)chmax(ma,i);\n    cout<<ma<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntypedef long double D;\nconst D eps = 1e-10;\nconst D pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\n\ninline D dist(int i,int j){\n\tint dx=(x[i]-x[j]);\n\tint dy=(y[i]-y[j]);\n\treturn sqrt(1.0*dx*dx+1.0*dy*dy);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tD r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tdp[0][0][n]=0.0;\n\n\trep(i,limit)rep(cp,n)rep(pp,n+1){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(i>0&&pp==n) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tD add=dist(cp,np);\n\t\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\t\tD dot=1.0*cx*nx+1.0*cy*ny;\n\t\t\tdot/=(dist(cp,pp)*dist(np,cp));\n\t\t\tdot=max<D>(-1,dot);\n\t\t\tdot=min<D>(1,dot);\n\t\t\tD angle=acos(dot);\n\t\t\tangle*=180.0/pi;\n\n\t\t\tif(angle>180.0) angle=360.0-angle;\n\t\t\tif(pp!=n&&angle>theta) continue;\n\t\t\t// cerr << np << \" \"  << cp << \" \" << pp << \" \" << angle << endl;\n\t\t\tif(dp[i][cp][pp]+add>r) continue;\n\t\t\tdp[i+1][np][cp]=min<D>(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,limit+1)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]<=r) ans=max(ans,i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#define scanf_s scanf\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\n\nint main(void){\n\tint n,ans,i,j,k,ok;\n\tdouble r,sit;\n\tdouble x[20];\n\tdouble y[20];\n\tdouble dp[20][20]={0};//x??????y????????????\n\tdouble dpc[20][20]={0};\n\tdouble d;\n\tdouble pi=3.141592653589793238462643383279502884197;\n\tscanf(\"%d\",&n);\n\tscanf(\"%lf %lf\",&r,&sit);\n\tsit=(sit/180)*pi;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tfor(ans=0;;ans++){\n\t\tfor(k=0;k<n;k++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif((k-i)*(i-j)*(j-k)==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td=abs(atan2(y[i]-y[k],x[i]-x[k])-atan2(y[k]-y[j],x[k]-x[j]));\n\t\t\t\t\tif(min(2*pi-d,d)>sit){continue;}\n\t\t\t\t\tdpc[k][j]=min(dpc[k][j],dp[i][k]+hypot(x[k]-x[j],y[k]-y[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tdp[i][j]=dpc[i][j];\n\t\t\t\tif(dpc[i][j]<r){\n\t\t\t\t\tok=1;\n\t\t\t\t}\n\t\t\t\tdpc[i][j]=big;\n\t\t\t}\n\t\t}\n\t\tif(ok==0){break;}\n\t}\n\tprintf(\"%d\\n\",ans-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nint n;\ndouble r, t;\nP p[20];\nbool c[20][20][20];\ndouble d[20][20];\ndouble dp[10010][20][20];\n\nint main()\n{\n\tcin >> n >> r >> t;\n\tt = t / 180.0 * acos(-1.0);\n\tfor (int i = 0; i < n; i++){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = P(x, y);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tif (i == j) continue;\n\t\t\t\tif (j == k) continue;\n\t\t\t\tif (k == i) continue;\n\t\t\t\tdouble a = abs(arg((p[j] - p[i]) / (p[k] - p[j])));\n\t\t\t\tif (a <= t){\n\t\t\t\t\tc[i][j][k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\td[i][j] = abs(p[i] - p[j]);\n\t\t}\n\t}\n\n\tfill_n(**dp, 10010 * 20 * 20, 99999.9);\n\tfor (int i = 1; i < n; i++){\n\t\tdp[1][0][i] = d[0][i];\n\t}\n\n\tint res = 0;\n\tfor (int i = 1; i < 10005; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tif (dp[i][j][k] <= r) res = i;\n\t\t\t\tfor (int l = 0; l < n; l++){\n\t\t\t\t\tif (!c[j][k][l]) continue;\n\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][k] + d[k][l]);\n\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], 99999.9);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdlib>\n#include <queue>\n#include <complex>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-4;\ndouble dp[20][20][10000 + 10];\nbool cango[20][20][20];\ndouble dist[20][20];\n\ninline bool ok(const P &p1, const P &p2, const P &p3, const double rad){\n  P s1 = p2 - p1;\n  P s2 = p3 - p2;\n  return std::abs(arg(s2 / s1)) < rad + EPS;\n}\n\nint main(){\n  int n;\n  double r, theta;\n  double rad;\n\n  cin >> n >> r >> theta;\n  rad = M_PI * theta / 180.0;\n\n  vector<P> p(n);\n  REP(i,n) cin >> p[i].real() >> p[i].imag();\n\n  int ans   = 0;\n  int limit = (int)(r + 3.0);\n  const double bad = r + 10;\n\n  REP(i,n) REP(j,n) REP(k,n){\n    if(i != j && j != k && i != k && ok(p[i], p[j], p[k], rad))\n      cango[i][j][k] = true;\n  }\n  REP(i,n) REP(j,n) dist[i][j] = abs(p[i] - p[j]);\n  REP(i,n) REP(j,n) REP(k,limit)\n    dp[i][j][k] = bad;\n\n  REP(i,n) if(i != 0) dp[0][i][1] = dist[0][i];\n\n  REP(k, limit) REP(i,n) REP(j,n) if(i != j && dp[i][j][k] != bad){\n    if(dp[i][j][k] < r + EPS) ans = k;\n    REP(l,n) if(i != l && j != l && cango[i][j][l])\n      dp[j][l][k + 1] = min(dp[j][l][k + 1], dp[i][j][k] + dist[j][l]);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n \n#define rep(i, n) for(int i = 0; i < (n); ++i)\n \nusing namespace std;\n\nconst double inf = 1e5;\n\nint n;\ndouble r, t;\nint x[20];\nint y[20];\ndouble dist[20][20];\nbool arg[20][20][20];\ndouble dp[10000][20][20];\ndouble cost[10000];\n\nvoid make_dist(){\n    rep(i, n){\n        rep(j, n){\n            int a = x[i] - x[j];\n            int b = y[i] - y[j];\n            dist[i][j] = sqrt(a * a + b * b);\n        }\n    }\n}\n\ndouble cos_bet(int i, int j, int k){\n    int a = x[j] - x[i];\n    int b = y[j] - y[i];\n    int c = x[k] - x[j];\n    int d = y[k] - y[j];\n    return (a * c + b * d) / dist[i][j] / dist[j][k];\n}\n\nvoid make_arg(){\n    double ct = cos(t / 180 * M_PI);\n    rep(i, n){\n        rep(j, n){\n            rep(k, n){\n                if(i != j && j != k){\n                    arg[i][j][k] = (cos_bet(i, j, k) >= ct);\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    cin >> n >> r >> t;\n    rep(i, n){\n        cin >> x[i] >> y[i];\n    }\n\n    make_dist();\n    make_arg();\n\n    rep(i, 10000){\n        rep(j, n){\n            fill_n(dp[i][j], n, inf);\n        }\n    }\n    for(int i = 1; i < n; ++i){\n        dp[1][0][i] = dist[0][i];\n    }\n    for(int i = 2; i < 10000; ++i){\n        rep(j, n){\n            rep(k, n){\n                rep(p, n){\n                    if(arg[p][j][k]){\n                        dp[i][j][k] = min(dp[i - 1][p][j] + dist[j][k], dp[i][j][k]);\n                    }\n                }\n            }\n        }\n    }\n\n    for(int i = 1; i < 10000; ++i){\n        cost[i] = inf;\n        rep(j, n){\n            rep(k, n){\n                cost[i] = min(dp[i][j][k], cost[i]);\n            }\n        }\n    }\n\n    cout << upper_bound(cost, cost + 10000, r) - cost - 1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\n\n// 角度関連\ndouble angle(const P &a, const P &b) {        // ベクトルａからみたベクトルｂの角度の計算[0,2pi]\n  double ret = arg(b)-arg(a);\n  return (ret>=0) ? ret : ret + 2*PI;\n}\ndouble angle2(const P &a, const P &b) { // ベクトルaとベクトルbの間の角度\n  return min(angle(a,b), angle(b,a));\n}\ndouble rtod(double rad) {       // ラジアン→度\n  return rad*180/PI;\n}\ndouble dtor(double deg) {       // 度→ラジアン\n  return deg*PI/180;\n}\n\n\nP p[20];\ndouble dp[20][20][10010];       // dp[i][j][k] = i->jでk個取るときの最小合計距離\ndouble dis[20][20];\nbool ok[20][20][20];            // i->j->k がいけるならok[i][j][k]=1\n\nint main() {\n  int n;\n  cin >> n;\n  double r,th;\n  cin >> r >> th;\n  th = dtor(th);\n  REP(i,n) cin >> p[i].real() >> p[i].imag();\n  REP(i,n)REP(j,n) {\n    if (i==j)continue;\n    dis[i][j] = abs(p[i]-p[j]);\n    REP(k,n) {\n      if (j==k) continue;\n      if (angle(p[j]-p[i],p[k]-p[j]) <= th) ok[i][j][k] = 1;\n    }\n  }\n  REP(i,n)REP(j,n)REP(k,10010)dp[i][j][k]=INF;\n  REP(i,n) {\n    if (i==0) continue;\n    dp[0][i][1] = dis[0][i];\n  }\n  int ans = 0;\n  REP(k,10010-1) {\n    REP(i,n) {\n      REP(j,n) {\n        REP(l,n) {\n          if (!ok[i][j][l]) continue;\n          dp[j][l][k+1] = min(dp[j][l][k+1], dp[i][j][k]+dis[i][j]);\n          if (dp[j][l][k+1] <= r) {\n            ans = k+1;\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\ndouble dist(double a,double b,double c,double d){\n    return pow(((a-c)*(a-c)+(b-d)*(b-d)),0.5);\n}\ntypedef pair<double,pipi> P;\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n;cin>>n;\n    double r,si;cin>>r>>si;\n    double x[n],y[n];\n    rep(i,0,n)cin>>x[i]>>y[i];\n    vector<int> v[n][n];\n    rep(i,0,n){\n        rep(j,0,n){\n            if(i==j)continue;\n            double nx=x[i]-x[j],ny=y[i]-y[j];\n            rep(k,0,n){\n                if(i==k||j==k)continue;\n                double nex=x[k]-x[i],ney=y[k]-y[i];\n                double da=dist(nx,ny,0,0),db=dist(nex,ney,0,0);\n                double c=nx*nex+ny*ney;\n                c/=da*db;\n                if(c>=1)c=1;\n                if(c<=-1)c=-1;\n                double sii=acos(c)/pi*180;\n                if(sii<=si+eps)v[i][j].push_back(k);\n            }\n        }\n    }\n    double dp[n][n][10001];\n    rep(i,0,n)rep(j,0,n)rep(k,0,10001)dp[i][j][k]=1000000000;\n    priority_queue<P,vector<P>,greater<P>> q;\n    rep(i,1,n){\n        dp[i][0][1]=dist(x[0],y[0],x[i],y[i]);\n        q.push({dp[i][0][1],{1,{i,0}}});\n    }\n    int ans=0;\n    while(q.size()>0){\n        P p=q.top();q.pop();\n        double nd=p.first;\n        int ko=p.second.first;\n        int pa=p.second.second.second;\n        int now=p.second.second.first;\n        if(nd>r+eps)break;\n        if(dp[now][pa][ko]+eps<nd)continue;\n        Max(ans,ko);\n        rep(i,0,v[now][pa].size()){\n            int ne=v[now][pa][i];\n            double co=dist(x[now],y[now],x[ne],y[ne]);\n            if(dp[ne][now][ko+1]>dp[now][pa][ko]+co){\n                dp[ne][now][ko+1]=dp[now][pa][ko]+co;\n                q.push({dp[ne][now][ko+1],{ko+1,{ne,now}}});\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(const deque<int>& deq,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[deq[0]];\n  complex<double> mid = cities[deq[1]];\n  complex<double> dst = cities[deq[2]];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _c,double _r,const deque<int>& _d) :\n    city(_ct), carrots(_c), remaining_distance(_r),deq(_d) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    deq.push_back(_d);\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,false,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      int prev = 20;\n      if(s.deq.size() > 1) prev = *(s.deq.end()-2);\n\n      if(dp[s.carrots][prev][s.city]) continue;\n      dp[s.carrots][prev][s.city] = true;\n\n      deque<int> deq;\n      while(s.deq.size() > 2) s.deq.pop_front();\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tdeq = s.deq;\n\tdeq.push_back(to);\n\tif(deq.size()==3){\n\t  if(!check(deq,limit_rad,cities)) continue;\n\t}\n\n\tque.push(State(to,s.carrots+1,s.remaining_distance - dist,deq));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> Pi;\ntypedef pair<double,int> Pd;\ntypedef pair<Pd,Pi> S;\n\nint n;\ndouble r,d;\nP p[20];\ndouble dp[10001][20][20];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint cal(){\n  priority_queue<S,vector<S>,greater<S> > Q;\n  int ans=0;\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)dp[i][j][k]=1e9;\n  dp[0][0][0]=0;\n  Q.push(S(Pd(0,0),Pi(0,0)));\n  while(!Q.empty()){\n    double cs=Q.top().first.first;\n    int i=Q.top().first.second;\n    int j=Q.top().second.first;\n    int k=Q.top().second.second;\n    Q.pop();\n    if(dp[i][j][k]<cs)continue;\n    if(cs>r)return ans;\n    dp[i][j][k]=1;\n    for(int l=0;l<n;l++)\n      if(check(j,k,l)&&cs+abs(p[k]-p[l])<=r){\n\tif(dp[i+1][k][l]>cs+abs(p[k]-p[l])){\n\t  Q.push(S(Pd(cs+abs(p[k]-p[l]),i+1),Pi(k,l)));\n\t  dp[i+1][k][l]=min(dp[i+1][k][l],cs+abs(p[k]-p[l]));\n\t}\n      }\n    ans=max(ans,i);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n>>r>>d;\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n  cout<<cal()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<D,int> Edge;\ntypedef pair<Edge, pair<int,int> > state;\n\nconst D PI = acos(-1);\nconst D EPS = 1e-8;\n\ninline D dis(D x1, D y1, D x2, D y2){\n  return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\ninline D dot(P x, P y){ return real(conj(x)*y); }\n\ninline D arg(P a, P b, P c){ return acos(dot(b-a,a-c)/abs(b-a)/abs(a-c)); }\n\nint n;\nD r,s;\nP p[30];\nD d[30][30];\nvector<Edge> g[30][30];\nD lensum[30][30][1010];\n\nint main(){ \n  cin >> n >> r >> s;\n  s *= PI/180;\n  rep(i,n)cin >> p[i].real() >> p[i].imag();\n  rep(i,n){\n    d[i+1][i+1] = 0;\n    for(int j=i+1;j<n;j++){\n      d[i+1][j+1] = d[j+1][i+1] = abs(p[i]-p[j]);\n    }\n  }\n  \n  rep(i,n){\n    if(i)g[0][1].push_back(Edge(d[1][i],i));\n  }\n\n  rep(i,n){\n    rep(j,n){\n      if(i==j)continue;\n      rep(k,n){\n\tif(j==k)continue;\n\tif(arg(p[j],p[i],p[k]) < s + EPS){\n\t  g[i+1][j+1].push_back(Edge(d[j+1][k+1],k+1));\n\t}\n      }\n    }\n  }\n\n  rep(i,n+1)rep(j,n+1)rep(k,1010)lensum[i][j][k] = 1e10;\n  lensum[0][1][0] = 0;\n  priority_queue<state,vector<state>,greater<state> > q;\n  q.push(state(make_pair(0,0),make_pair(0,1)));\n\n  int ans = 0;\n  while(q.size()){\n    state tmp = q.top(); q.pop();\n    D len = tmp.first.first;\n    int carrot = tmp.first.second + 1;\n    int prv = tmp.second.first, cur = tmp.second.second;\n\n    rep(i,g[prv][cur].size()){\n      D cost = g[prv][cur][i].first;\n      int nxt = g[prv][cur][i].second;\n\n      if(len + cost > r + EPS)continue;\n      if(lensum[cur][nxt][carrot] > len + cost + EPS){\n\tlensum[cur][nxt][carrot] = len + cost;\n\tq.push(state(make_pair(len+cost,carrot),make_pair(cur,nxt)));\n\tans = max(ans,carrot);\n      }\n    }\n  }\t\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  R r, th; cin >> r >> th, th *= pi / 180;\n  V<P> p(n); for (auto&& e : p) cin >> e;\n  VV< V<> > ks(20, VV<>(20));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    for (int k = 0; k < n; ++k) if (k != j) {\n      L s{p[i], p[j]}, t{p[j], p[k]};\n      R ph = fmod(3 * pi + t.arg() - s.arg(), 2 * pi) - pi;\n      if (sgn(abs(ph), th) <= 0) ks[i][j].push_back(k);\n    }\n  }\n  VV<R> dp(20, V<R>(20, 1e10));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    dp[i][j] = distPP(p[i], p[j]);\n  }\n  int res = 0;\n  for (int s = 0; s <= 1e4; ++s) {\n    VV<R> ndp(20, V<R>(20, 1e10));\n    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n      for (int k : ks[i][j]) {\n        ndp[i][j] = min(ndp[i][j], distPP(p[i], p[j]) + dp[j][k]);\n      }\n      if (sgn(ndp[i][j], r) <= 0) res = s + 2;\n    }\n    swap(dp, ndp);\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=double;\nusing P=complex<ld>;\nconst ld pi=acos(-1);\nstruct State{\n    int v,pre;\n    int c; \n};\n\nbool operator<(const State& lhs,const State& rhs){\n    return true;\n}\n\nint idx(State st){\n    return st.v+20*st.pre+st.c*20*20;\n}\nint main(){\n    int n;\n    cin>>n;\n    ld r,theta;\n    cin>>r>>theta;\n    theta=(theta)/180*pi;\n    vector<P> xy(n);\n    for(int i=0;i<n;i++){\n        ld tmpx,tmpy;\n        cin>>tmpx>>tmpy;\n        xy[i]={tmpx,tmpy};\n    }\n    int res=0;\n    priority_queue<pair<ld,State>,vector<pair<ld,State>>,greater<>> que;\n    que.push({ld(0),State{0,0,0}});\n    const ld INF=1e9;\n    vector<ld> dist(5*1e6,INF);\n    vector<ld> check(5*1e6,0);\n    dist[0]=0;\n\n    vector<vector<vector<int>>> edge(n,vector<vector<int>>(n));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            for(int k=0;k<n;k++){\n                if(i==k || j==k) continue;\n                if(i!=j){\n                    ld phi=arg((xy[k]-xy[j])/(xy[j]-xy[i]));\n                    if(phi>pi) phi-=2*pi;\n                    if(abs(phi)>theta){\n                        continue;\n                    }\n                }\n                edge[i][j].push_back(k);\n            }\n        }\n    }\n\n    while(!que.empty()){\n        auto tmp=que.top(); que.pop();\n        auto ret=tmp.second;\n        int v=ret.v,pre=ret.pre;\n        int c=ret.c;\n        int id=idx(ret);\n        ld w=tmp.first;\n        if(check[id]) continue;\n        check[id]=true;\n        if(w>r) break;\n        res=max(res,c);\n        for(int k=0;k<edge[pre][v].size();k++){\n            int i=edge[pre][v][k];\n            State to{i,v,c+1};\n            int toidx=idx(to);\n            if(w+abs(xy[i]-xy[v])<dist[toidx]){\n                dist[toidx]=w+abs(xy[i]-xy[v]);\n                que.push({dist[toidx],to});\n            }\n        }\n\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF (long long)(1e18)\n#define MOD (int)(1e9+7)\n\n#define EPS 1e-8\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX 22\n\nstring hogehogehoge;\n\nint n, x[MAX], y[MAX];\ndouble r, t;\n\ndouble angle(double x1, double y1,double x2, double y2){//cout<<\"(\"<<x1<<\",\"<<y1<<\") (\"<<x2<<\",\"<<y2<<\")\";\n\tif(x1 >= INF-1){\n\t\t//cout<<\"-> \"<<0<<endl;\n\t\treturn 0;\n\t}\n\tdouble inner_product = x1*x2+y1*y2, ab1 = sqrt(x1*x1+y1*y1), ab2 = sqrt(x2*x2+y2*y2);\n\t//cout<<\"- > \"<<acos(inner_product/(ab1*ab2))<<endl;\n\treturn fabs(acos(inner_product/(ab1*ab2)));\n}\n\nint solve(int g, double R, double xx, double yy){//cout<<g<<\" \"<<R<<endl;\n\t// cin>>hogehogehoge;\n\tint ans = 0;  \n\tfor(int i = 0; i < n; i++){\n\t\tif(i==g) continue;\n\t\tif(angle(xx,yy,x[i]-x[g],y[i]-y[g]) <= t && (x[i]-x[g])*(x[i]-x[g]) + (y[i]-y[g])*(y[i]-y[g])<= R*R){\n\t\t\tans = max(ans,solve(i,R-sqrt((x[i]-x[g])*(x[i]-x[g]) + (y[i]-y[g])*(y[i]-y[g])),x[i]-x[g],y[i]-y[g]));\n\t\t}\n\t}\n\treturn ans+1;\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(7);\n\t\n\t\n\tcin>>n>>r>>t;\n\t\n\t\n\tt = (t/360)*(2*acos(-1));\n\t\n\trep(i,n){\n\t\tcin>>x[i]>>y[i];\n\t}\n\t\n\tcout<<solve(0,r,INF,0)-1<<endl;\n\t\n\t// cout<<\"t = \"<<t<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<  vector<double>  > vvd;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef complex<double> zahyo;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nzahyo toshi[21];\nbool kakdotest(zahyo a,zahyo b,double kakdo){\n\n  double kak= (a.real()*b.real()+a.imag()*b.imag())/  (abs(a)*abs(b));\n  if (cos(kakdo*3.14159265/180.0)<=kak)\n    return true;\n  else return false;\n}\nint main(){\n  int n,k;\n  double r,kakdo,xza,yza;\n  cin>>n>>r>>kakdo;\n  for(int i=1;i<=n;i++){\n    cin>>xza>>yza;\n    toshi[i]=zahyo(xza,yza);\n  }\n  vvd nokori(n+1);\n  for(int i=0;i<n+1;i++){\n    nokori[i]=vector<double>(21,-1);\n  }\n  vvd prevnokori=nokori;\n  for(int i=2;i<n+1;i++){\n    prevnokori[1][i]=r-abs(toshi[i]-toshi[1]);\n  }\n  int maxcarrot=0;\n  k=1;\n  while(k-maxcarrot==1){\n    vvd nextnokori=nokori;  \n    for(int i=1;i<(n+1);i++)\n      for(int j=1;j<(n+1);j++){\n\tif(i==j) continue;\n\tif(prevnokori[i][j]<0) continue;\n\tmaxcarrot=k;\n\t//\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<abs(prevnokori[i][j])<<endl;\n\tfor(int l=1;l<(n+1);l++){\n\t  if(kakdotest(toshi[i]-toshi[j],\n\t\t       toshi[j]-toshi[l],kakdo)){\n\t    nextnokori[j][l]=\n\t      max(prevnokori[i][j]-abs(toshi[j]-toshi[l]),\n\t\t\t\t nextnokori[j][l]);\n\t    //\t    cout<<i<<\" \"<<j<<\" \"<<l<<endl;\n\t  }\n\t}\n\n      }\n    prevnokori=nextnokori;\n    k++;\n  }\n  cout<<maxcarrot<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> mid = cities[prev];\n  complex<double> dst = cities[city];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[3001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\n\n// 角度関連\ndouble angle(const P &a, const P &b) {        // ベクトルａからみたベクトルｂの角度の計算[0,2pi]\n  double ret = arg(b)-arg(a);\n  return (ret>=0) ? ret : ret + 2*PI;\n}\ndouble angle2(const P &a, const P &b) { // ベクトルaとベクトルbの間の角度\n  return min(angle(a,b), angle(b,a));\n}\ndouble rtod(double rad) {       // ラジアン→度\n  return rad*180/PI;\n}\ndouble dtor(double deg) {       // 度→ラジアン\n  return deg*PI/180;\n}\n\n\nP p[20];\ndouble dp[20][20][10010];       // dp[i][j][k] = i->jでk個取るときの最小合計距離\ndouble dis[20][20];\nbool ok[20][20][20];            // i->j->k がいけるならok[i][j][k]=1\n\nint main() {\n  int n;\n  cin >> n;\n  double r,th;\n  cin >> r >> th;\n  th = dtor(th);\n  REP(i,n) cin >> p[i].real() >> p[i].imag();\n  REP(i,n)REP(j,n) {\n    if (i==j)continue;\n    dis[i][j] = abs(p[i]-p[j]);\n    REP(k,n) {\n      if (j==k) continue;\n      if (angle2(p[j]-p[i],p[k]-p[j]) <= th) ok[i][j][k] = 1;\n    }\n  }\n  //REP(i,n)REP(j,n)REP(k,n) if (ok[i][j][k]) cout << i << \" \"<< j << \" \"<< k << endl;\n  REP(i,n)REP(j,n)REP(k,10010)dp[i][j][k]=INF;\n  REP(i,n) {\n    if (i==0) continue;\n    dp[0][i][1] = dis[0][i];\n  }\n  REP(k,10010-1) {\n    REP(i,n) {\n      REP(j,n) {\n        REP(l,n) {\n          if (!ok[i][j][l]) continue;\n          dp[j][l][k+1] = min(dp[j][l][k+1], dp[i][j][k]+dis[j][l]);\n        }\n      }\n    }\n  }\n  int ans = 0;\n  REP(k,10010) {\n    REP(i,n)REP(j,n)if(dp[i][j][k]<=r) {\n      ans=k;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int MAX = 20,LIMIT = 200000,IINF = INT_MAX;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nstruct Edge{\n  int to;\n  double weight;\n  Edge(int to=0,double weight=0):to(to),weight(weight){}\n};\n\nstruct Data{\n  int prev,cur,carrot;\n  double dist;\n  Data(int prev=0,int cur=0,int carrot=0,double dist=0):prev(prev),cur(cur),carrot(carrot),dist(dist){}\n  bool operator < (const Data& data) const{ return dist > data.dist; }\n};\n\nint n;\ndouble r,theta,mindist[MAX][MAX][LIMIT]; // mindist[cur][prev][the number of carrot]\nPoint ps[MAX];\nvector<Edge> edge[MAX][MAX]; // edge[cur][prev]\n\ninline void dijkstra(){\n  rep(i,n)rep(j,n)rep(k,LIMIT) mindist[i][j][k] = IINF;\n  priority_queue<Data> Q;\n\n  REP(i,1,n) {\n    double dist = abs(ps[0]-ps[i]);\n    if( !equals(dist,r) && dist > r ) continue;\n    Q.push(Data(0,i,1,dist));\n    mindist[i][0][1] = dist;\n  }\n  int ans = (Q.empty()?0:1);\n\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n    int prev = data.prev, cur = data.cur, carrot = data.carrot;\n    double dist = data.dist;\n\n    if( !equals(mindist[cur][prev][carrot],dist) && mindist[cur][prev][carrot] < dist ) continue;\n\n    rep(i,edge[cur][prev].size()) {\n      int next = edge[cur][prev][i].to;\n      double weight = edge[cur][prev][i].weight;\n      if( !equals(r,dist+weight) && r < dist+weight ) continue;\n      if( mindist[next][cur][carrot+1] > dist + weight ){\n        mindist[next][cur][carrot+1] = dist + weight;\n        assert(carrot+1 < LIMIT);\n        ans = max(ans,carrot+1);\n        Q.push(Data(cur,next,carrot+1,dist+weight));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\ninline void makeEdge(){\n  rep(prev,n){\n    rep(cur,n){\n      if( cur == prev ) continue;\n      rep(next,n){\n        if( next == cur || next == prev ) continue;\n        double dist = abs(ps[cur]-ps[next]);\n        if( !equals(dist,r) && dist > r ) continue;\n        Vector v1 = ps[next] - ps[cur];\n        Vector v2 = ps[cur]  - ps[prev];\n        if( equals(cross(v1,v2),0.0) ) continue;\n        double arg = getArg(ps[prev],ps[cur],ps[next]);\n        if( equals(arg,theta) || arg < theta ) edge[cur][prev].push_back(Edge(next,dist));\n      }\n    }\n  }\n}\n\nint main(){\n\n  /*\n  int next = 2, cur = 1, prev = 0;\n  ps[0] = Point(0,0);\n  ps[1] = Point(10,0);\n  ps[2] = Point(0,1);\n  double arg =  getArg(ps[prev],ps[cur],ps[next]);\n  cout << \"arg = \" << arg * 180.0 / M_PI << endl;\n  */\n\n  cin >> n;\n  cin >> r >> theta;\n  theta = toRad(theta);\n  rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n\n  makeEdge();\n\n  dijkstra();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst double INF = 1e9;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\nint n;\ndouble r, a;\nint x[20], y[20];\ndouble dis[20][20][10010];\ndouble cost[20][20];\nbool reach[20][20][20];\n\nbool canReach(int pre, int cur, int nxt) {\n  int cpx = x[pre]-x[cur], cpy = y[pre]-y[cur];\n  int cnx = x[nxt]-x[cur], cny = y[nxt]-y[cur];\n  double tmp = cpx*cnx + cpy*cny;\n  tmp /= hypot(cpx, cpy);\n  tmp /= hypot(cnx, cny);\n  tmp = PI - acos(tmp);\n  return tmp <= a;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  cin >> n >> r >> a;\n  a = a / 180 * PI;\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      cost[i][j] = hypot(x[i]-x[j], y[i]-y[j]);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      for (int k = 0; k < n; k++) {\n        if (i == j || j == k || k == i) continue;\n        reach[i][j][k] = canReach(i, j, k);\n      }\n    }\n  }\n  int ans = 0;\n  fill_n((double*)dis, 20*20*10010, INF);\n  dis[0][0][0] = 0.0;\n  using P = tuple<double, int, int, int>;\n  priority_queue<P, vector<P>, greater<P>> que;\n  que.emplace(0.0, 0, 0, 0);\n  while (!que.empty()) {\n    double d;\n    int cur, pre, num;\n    tie(d, cur, pre, num) = que.top(); que.pop();\n    if (dis[cur][pre][num] < d || r < d) continue;\n    if (d <= r) ans = max(ans, num);\n    for (int i = 0; i < n; i++) {\n      if (i == cur) continue;\n      if (cur == pre || reach[pre][cur][i]) {\n        if (dis[i][cur][num+1] > dis[cur][pre][num]+cost[cur][i]) {\n          dis[i][cur][num+1] = dis[cur][pre][num]+cost[cur][i];\n          que.emplace(dis[i][cur][num+1], i, cur, num+1);\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<int,D> edge;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\nconst D PI=acos(-1);\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return a.X==b.X?a.Y<b.Y:a.X<b.X;\n  }\n}\nbool cmp_x(const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; }\nbool cmp_y(const P& a,const P& b){ return a.Y==b.Y?a.X<b.X:a.Y<b.Y; }\nbool cmp_a(const P& a,const P& b){ return arg(a)==arg(b)?norm(a)<norm(b):arg(a)<arg(b); }\nD cross(P a,P b){ return (conj(a)*b).Y; }\nD dot(P a,P b){ return (conj(a)*b).X; }\nD toRag(D deg){ return deg*PI/180.0; }\nP rot(P base,P a,D theta){ return base+polar(abs(a-base),arg(a-base)+theta); }\n\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nD f(P a,P b){ return acos(dot(a,b)/abs(a)/abs(b))/PI*180; }\n\nint n;\nD r,theta;\nD dp[22][22][10010];\nvector<edge> es[22][22];\nP ps[22];\n\nstruct state{\n  int pre,v,cnt;\n  D d;\n};\nbool operator<(const state& a, const state& b){ return a.d > b.d; }\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n;\n  cin>>r>>theta;\n  rep(i,n){\n    D x,y;\n    cin>>x>>y;\n    ps[i]=P(x,y);\n  }\n  rep(i,n)rep(j,n)rep(k,10010)dp[i][j][k]=inf;\n  rep(i,n)rep(j,n){\n    if(i==j)continue;\n    rep(k,n){ // (i,j) -> k\n      if(i==k||j==k)continue;\n      P v1=ps[j]-ps[i];\n      P v2=ps[k]-ps[j];\n      if(abs(f(v1,v2))<theta){\n        //dbg(i); dbg(j); dbg(k);\n        es[i][j].push_back(edge(k,abs(v2)));\n      }\n    }\n  }\n  priority_queue<state> que;\n  repl(i,1,n){\n    que.push((state){0,i,1,abs(ps[i]-ps[0])});\n  }\n\n  while(que.size()){\n    int pre=que.top().pre,v=que.top().v,cnt=que.top().cnt;\n    D d=que.top().d; que.pop();\n    if(dp[pre][v][cnt]!=inf)continue;\n    dp[pre][v][cnt]=d;\n    for(edge nxt : es[pre][v]){\n      que.push((state){v,nxt.fi,cnt+1,d+nxt.se});\n    }\n  }\n  int res=0;\n  rep(i,n)rep(j,n)rep(k,10010){\n    if(dp[i][j][k]<r)maxch(res,k);\n  }\n  cout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<math.h>\n#define pi 3.1415926535\nusing namespace std;\ntypedef pair<double, double> P;\n\ndouble calc_dist(P x, P y) {\n    double tmp1 = (x.first - y.first) * (x.first - y.first);\n    double tmp2 = (x.second - y.second) * (x.second - y.second);\n    return sqrt(tmp1 + tmp2);\n}\n\nint main() {\n    int N;\n    int result=0;\n    double r, theta;\n    cin >> N;\n    cin >> r >> theta;\n    vector<P> coods(N);\n    for(int i = 0; i < N; i++) {\n        cin >> coods[i].first >> coods[i].second;\n    }\n    for (int i = 0; i < N; i++) {\n        P start_cood = coods[i];\n        queue<pair<int, pair<double, int> > > Q;\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            if (calc_dist(start_cood, coods[j]) <= r) Q.push(make_pair(j, make_pair(r - calc_dist(start_cood, coods[j]), 0)));\n        }\n        P prev = start_cood;\n        while (!Q.empty()) {\n            pair<int, pair<double, int> > next = Q.front();\n            Q.pop();\n            for (int j = 0; j < N; j++) {\n                if (next.first == j) continue;\n                P prev_vec = make_pair(coods[next.first].first - prev.first, coods[next.first].second - prev.second);\n                P next_vec = make_pair(coods[j].first - coods[next.first].first, coods[j].second - coods[next.first].second);\n                double dot = prev_vec.first * next_vec.first + prev_vec.second * next_vec.second;\n                double sub_div = dot / (calc_dist(prev_vec, make_pair(0, 0)) * calc_dist(next_vec, make_pair(0, 0)));\n                double sub_theta = acos(sub_div) * 180 / pi;\n                if (sub_theta <= theta && calc_dist(coods[next.first], coods[j]) <= next.second.first) Q.push(make_pair(j, make_pair(next.second.first - calc_dist(coods[next.first], coods[j]),next.second.second+1)));\n                else{\n                    result=max(result,next.second.second);\n                }\n            }\n        }\n    }\n    cout<<result;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 20;\nconst double INF = -1.0;\n\nint n;\ndouble r, s, e[N][N][N], d[N][N][10005];\nvector<P> in;\n\nmain(){\n  cin >> n >> r >> s;\n  s *= M_PI / 180.0;\n  for(int i=0;i<n;i++){\n    P a;\n    cin >> a.real() >> a.imag();\n    in.push_back(a);\n  }\n  if(n == 1){\n    cout << 0 << endl;\n    return 0;\n  }\n  fill(e[0][0], e[N][0], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i == j) continue;\n      for(int k=0;k<n;k++){\n        if(j == k) continue;\n        P a = in[i] - in[j];\n        P b = in[k] - in[j];\n        double t = acos(real(conj(a) * b) / (abs(a) * abs(b)));\n        //if(i == 0 && j == 3 && k == 4) cout << t << ' ' << M_PI - t << ' ' << s << endl;\n        if(M_PI - t <= s) e[i][j][k] = abs(b);\n      }\n    }\n  }\n  /*for(int i=0;i<n;i++){\n    cout << i << endl;\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n        printf(\"%.3f \", e[i][j][k]);\n      }\n      cout << endl;\n    }\n    }*/\n  fill(d[0][0], d[N][0], -1.0);\n  for(int i=1;i<n;i++) d[0][i][1] = abs(in[0] - in[i]);\n  int ans = 1;\n  for(int k=1;(double)k<r+1;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(d[i][j][k] < 0.0) continue;\n        ans = max(ans, k);\n        for(int l=0;l<n;l++){\n          if(e[i][j][l] < 0.0) continue;\n          double dist = d[i][j][k] + e[i][j][l];\n          //if(e[i][j][l] < 10.0) cout << i << ' ' << j << ' ' << l << ' ' << e[i][j][l] << endl;\n          if(dist > r) continue;\n          //cout << k+1 << ' ' << j << ' ' << l << ' ' << dist << endl;\n          if(d[j][l][k+1] < 0.0) d[j][l][k+1] = dist;\n          else if(d[j][l][k+1] > dist) d[j][l][k+1] = dist;\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int MAX = 20,LIMIT = 20000,IINF = INT_MAX;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nstruct Edge{\n  int to;\n  double weight;\n  Edge(int to=0,double weight=0):to(to),weight(weight){}\n};\n\nstruct Data{\n  int prev,cur,carrot;\n  double dist;\n  Data(int prev=0,int cur=0,int carrot=0,double dist=0):prev(prev),cur(cur),carrot(carrot),dist(dist){}\n  bool operator < (const Data& data) const{ return dist > data.dist; }\n};\n\nint n;\ndouble r,theta,mindist[MAX][MAX][LIMIT]; // mindist[cur][prev][the number of carrot]\nPoint ps[MAX];\nvector<Edge> edge[MAX][MAX]; // edge[cur][prev]\n\ninline void dijkstra(){\n  rep(i,n)rep(j,n)rep(k,LIMIT) mindist[i][j][k] = IINF;\n  priority_queue<Data> Q;\n\n  REP(i,1,n) {\n    double dist = abs(ps[0]-ps[i]);\n    if( !equals(dist,r) && dist > r ) continue;\n    Q.push(Data(0,i,1,dist));\n    mindist[i][0][1] = dist;\n  }\n  int ans = (Q.empty()?0:1);\n\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n    int prev = data.prev, cur = data.cur, carrot = data.carrot;\n    double dist = data.dist;\n\n    if( !equals(mindist[cur][prev][carrot],dist) && mindist[cur][prev][carrot] < dist ) continue;\n\n    rep(i,edge[cur][prev].size()) {\n      int next = edge[cur][prev][i].to;\n      double weight = edge[cur][prev][i].weight;\n      if( !equals(r,dist+weight) && r < dist+weight ) continue;\n      if( mindist[next][cur][carrot+1] > dist + weight ){\n        mindist[next][cur][carrot+1] = dist + weight;\n        ans = max(ans,carrot+1);\n        Q.push(Data(cur,next,carrot+1,dist+weight));\n      }\n    }\n\n  }\n  cout << ans << endl;\n}\n\ninline void makeEdge(){\n  rep(prev,n){\n    rep(cur,n){\n      if( cur == prev ) continue;\n      rep(next,n){\n        if( next == cur || next == prev ) continue;\n        double dist = abs(ps[cur]-ps[next]);\n        if( !equals(dist,r) && dist > r ) continue;\n        Vector v1 = ps[next] - ps[cur];\n        Vector v2 = ps[cur]  - ps[prev];\n        if( equals(cross(v1,v2),0.0) ) continue;\n        double arg = getArg(ps[prev],ps[cur],ps[next]);\n        if( equals(arg,theta) || arg < theta ) edge[cur][prev].push_back(Edge(next,dist));\n      }\n    }\n  }\n}\n\nint main(){\n\n  /*\n  int next = 2, cur = 1, prev = 0;\n  ps[0] = Point(0,0);\n  ps[1] = Point(10,0);\n  ps[2] = Point(0,1);\n  double arg =  getArg(ps[prev],ps[cur],ps[next]);\n  cout << \"arg = \" << arg * 180.0 / M_PI << endl;\n  */\n\n  cin >> n;\n  cin >> r >> theta;\n  theta = toRad(theta);\n  rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n\n  makeEdge();\n\n  dijkstra();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef long double ld;\nconst ld INF = 1e+8;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nint main() {\n  int n;\n  ld r,t,theta;\n  cin>>n>>r>>t;\n  theta = t / 180.0 * pi;\n  VP p;\n  REP(i,n){\n    ld x,y;\n    cin>>x>>y;\n    p.emplace_back(x,y);\n  }\n  int np1 = n+1;\n  int v = np1*np1;\n  vector<vector<int>> g(v);\n  REP(i,n)REP(j,n)REP(k,n) {\n    if (i == j) break;\n    if (j == k) continue;\n    P a = p[j] - p[i], b = p[k] - p[j];\n    ld arga = arg(a);\n    P rotcx = polar<ld>(1.0, -arga);\n    ld argb = arg(b*rotcx);\n    if (argb > pi) argb -= pi * 2.0;\n    if (abs(argb) < theta) {\n      g[j*np1+i].push_back(k*np1+j);\n    }\n  }\n  REP(i,n)REP(j,n) {\n    if (j != i) g[i*np1+n].push_back(j*np1+i);\n  }\n  vector<ld> mind(v, INF);\n  REP(i,n) mind[i*np1+n] = 0;\n  REP(i,r+1) {\n    vector<ld> tmp(v, INF);\n    ld mint = INF;\n    REP(j,v) {\n      for (int nx : g[j]) {\n        int now = nx % np1;\n        int nxt = nx / np1;\n        tmp[nx] = min(tmp[nx], mind[j] + abs(p[nxt] - p[now]));\n        mint = min(mint, tmp[nx]);\n      }\n    }\n    if (mint > r) {\n      cout << i << endl;\n      break;\n    }\n    swap(tmp, mind);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2233&lang=jp\ntypedef long long ll;\ntypedef long double ld;\n#define INF 1<<30\n#define LINF 1<<60\nconst double eps = 1e-9;\n\ninline double calc_w(int c1,int pre_c1, int c2,int pre_c2, vector<pair<int, int>>& city) {\n\tdouble l1_x = city[c1].first - city[pre_c1].first;\n\tdouble l1_y = city[c1].second - city[pre_c1].second;\n\n\tdouble l2_x = city[c2].first - city[pre_c2].first;\n\tdouble l2_y = city[c2].second - city[pre_c2].second;\n\n\tdouble _cos = (l1_x*l2_x + l1_y*l2_y) / (double)(hypot(l1_x, l1_y)*hypot(l2_x, l2_y));\n\tif (1 - _cos < eps)return 0.0;\n\tif (1 + _cos < eps)return 180.0;\n\treturn abs(acos(_cos) * 180 / acos(-1));\n}\n\nstruct edge {\n\tint now_city;\n\tint pre_city;\n\tint have_carrot;\n\tdouble full_len;\n\tedge() {}\n\tedge(int now, int pre,int car, double len) :now_city(now), pre_city(pre),have_carrot(car),full_len(len) {}\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t/* input */\n\tint n; cin >> n;\n\tdouble r, theta; cin >> r >> theta;\n\tvector<pair<int, int>> city(n);\n\tfor (int i = 0; i < n;i++) { int x, y; cin >> x >> y; city[i] = { x,y }; }\n\n\t/* initialize */\n\tvector<vector<double>> dist(n, vector<double>(n,0));\n\tvector<vector<vector<int>>> G(n, vector<vector<int>>(n));\n\tvector<vector<vector<double>>> dp(n, vector<vector<double>>(n, vector<double>(10010, INF)));\n\n\tint ans = 0;\n\tqueue<edge> q;\n\tfor (int i = 0; i < n;i++) {\n\t\tfor (int j = i + 1; j < n;j++) {\n\t\t\tdouble d = hypot(city[i].first - city[j].first, city[i].second - city[j].second);\n\t\t\tdist[i][j] = dist[j][i] = d;\n\t\t\tif ((i == 0) && (d <= r)) {\n\t\t\t\tdp[j][i][1] = d;\n\t\t\t\tq.push(edge(j, i, 1, d));\n\t\t\t\tans = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n;i++) {\n\t\tfor (int j = 0; j < n;j++) {\n\t\t\tfor (int k = 0; k < n;k++) {\n\t\t\t\tif (i == j || j == k || i == k)continue;\n\t\t\t\tif (calc_w(j, i, k, j, city) < theta + eps) G[j][i].push_back(k);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!q.empty()) {\n\t\tauto p = q.front(); q.pop();\n\t\tint now_city = p.now_city, pre_city = p.pre_city;\n\t\tint have_carrot = p.have_carrot;\n\t\tdouble len = p.full_len;\n\t\tif (len > dp[now_city][pre_city][have_carrot]) continue;\n\t\tfor (int next_city : G[now_city][pre_city]) {\n\t\t\tif (next_city == now_city || next_city == pre_city)continue;\n\t\t\tif (dist[now_city][next_city] + len < r + eps) {\n\t\t\t\tif (dp[next_city][now_city][have_carrot + 1] > len + dist[next_city][now_city]) {\n\t\t\t\t\tdp[next_city][now_city][have_carrot + 1] = len + dist[next_city][now_city];\n\t\t\t\t\tq.push(edge(next_city, now_city, have_carrot + 1, dist[next_city][now_city] + len));\n\t\t\t\t\tans = max(ans, have_carrot + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2233&lang=jp\ntypedef long long ll;\ntypedef long double ld;\n#define INF 1<<30\n#define LINF 1<<60\n\ninline double calc_w(int c1,int pre_c1, int c2,int pre_c2, vector<pair<int, int>>& city) {\n\tdouble l1_x = city[c1].first - city[pre_c1].first;\n\tdouble l1_y = city[c1].second - city[pre_c1].second;\n\n\tdouble l2_x = city[c2].first - city[pre_c2].first;\n\tdouble l2_y = city[c2].second - city[pre_c2].second;\n\n\tdouble _cos = (l1_x*l2_x + l1_y*l2_y) / (double)(hypot(l1_x, l1_y)*hypot(l2_x, l2_y));\n\treturn abs(acos(_cos) * 180 / acos(-1));\n}\n\nstruct edge {\n\tint now_city;\n\tint pre_city;\n\tdouble full_len;\n\tedge() {}\n\tedge(int now, int pre, double len) :now_city(now), pre_city(pre), full_len(len) {}\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t/* input */\n\tint n; cin >> n;\n\tdouble r, theta; cin >> r >> theta;\n\tvector<pair<int, int>> city(n);\n\tfor (int i = 0; i < n;i++) { int x, y; cin >> x >> y; city[i] = { x,y }; }\n\n\t/* initialize */\n\t/* carrot[i][j] := the number of carrots from j-th city to i-th city */\n\tvector<vector<int>> carrot(n, vector<int>(n, 0));\n\t/* dist[i][j] := distance between i-th city and j-th city */\n\tvector<vector<double>> dist(n, vector<double>(n,0));\n\tqueue<edge> q;\n\n\tfor (int i = 0; i < n;i++) {\n\t\tfor (int j = i + 1; j < n;j++) {\n\t\t\tdouble d = hypot(city[i].first - city[j].first, city[i].second - city[j].second);\n\t\t\tdist[i][j] = dist[j][i] = d;\n\t\t\tif ((i == 0) && (d <= r)) {\n\t\t\t\tcarrot[j][i] = 1;\n\t\t\t\tq.push(edge(j, i, d));\n\t\t\t}\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tauto p = q.front(); q.pop();\n\t\tint now_city = p.now_city, pre_city = p.pre_city;\n\t\tdouble len = p.full_len;\n\t\tfor (int next_city = 0; next_city < n;next_city++) {\n\t\t\tif (next_city == now_city || next_city == pre_city)continue;\n\t\t\tdouble w = calc_w(now_city, pre_city, next_city, now_city, city);\n\t\t\tif (w <= theta &&  dist[now_city][next_city] + len <= r) {\n\t\t\t\tif (carrot[next_city][now_city] < carrot[now_city][pre_city] + 1) {\n\t\t\t\t\tcarrot[next_city][now_city] = carrot[now_city][pre_city] + 1;\n\t\t\t\t\tq.push(edge(next_city, now_city, dist[now_city][next_city] + len));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0;i < n;i++) {\n\t\tfor (int j = 0; j < n;j++) {\n\t\t\tans = max(ans, carrot[i][j]);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> P;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9, PI = acos(-1);\n\nint n;\nP p[20];\ndouble r, t;\ndouble dp[20][20][10010], d[20][20];\nbool can[20][20][20];\n\nint main(){\n\tcin >> n >> r >> t;\n\tt *= PI / 180;\n\trep(i, n) cin >> p[i].real() >> p[i].imag();\n\t\n\trep(i, n) rep(j, n) rep(k, n) if(i != j && j != k){\n\t\tdouble a = abs(arg((p[j] - p[i]) / (p[k] - p[j])));\n\t\tcan[i][j][k] = EPS < a && a + EPS < t;\n\t}\n\trep(i, n) rep(j, n) d[i][j] = abs(p[i] - p[j]);\n\t\n\trep(i, n) rep(j, n) rep(k, 10010) dp[i][j][k] = INF;\n\trep(i, n) if(i) dp[0][i][1] = d[0][i];\n\t\n\tint ans = 0;\n\trep(k, 10010) rep(i, n) rep(j, n) if(dp[i][j][k] < r + EPS){\n\t\tans = max(ans, k);\n\t\trep(l, n) if(can[i][j][l]){\n\t\t\tdp[j][l][k + 1] = min(dp[j][l][k + 1], dp[i][j][k] + d[j][l]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\n\ninline double dist(int i,int j){\n\tint dx=(x[i]-x[j]);\n\tint dy=(y[i]-y[j]);\n\treturn sqrt(1.0*dx*dx+1.0*dy*dy);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tdouble r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tdp[0][0][n]=0.0;\n\n\trep(i,limit)rep(cp,n)rep(pp,n+1){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(i>0&&pp==n) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tdouble add=dist(cp,np);\n\t\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\t\tdouble dot=1.0*cx*nx+1.0*cy*ny;\n\t\t\tdot/=(dist(cp,pp)*dist(np,cp));\n\t\t\tdouble angle=acos(dot);\n\t\t\tangle*=180.0/pi;\n\n\t\t\tif(angle>180.0) angle=360.0-angle;\n\t\t\tif(pp!=n&&angle>theta+eps) continue;\n\t\t\tif(dp[i][cp][pp]+add-r>eps) continue;\n\t\t\tdp[i+1][np][cp]=min(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,limit+1)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]<=r+eps) ans=max(ans,i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass state{\npublic:\n  int n,item,prev;\n  double dis;\n  state(int n=0, int item=0, int prev=0, int dis=0):n(n),item(item),prev(prev),dis(dis){}\n  bool operator < (const state &s) const {\n    return dis > s.dis;\n  }\n};\n\nconst double INF = (double)(1<<29);\nint n,d[20][20],ans;\ndouble r,pi,memo[20][20][10000],G[20][20];\nP v[20];\n\nbool check(double a, double b){\n  if(b >= a - pi && b <= a + pi) return true;\n  if(b+360 >= a - pi && b+360 <= a + pi) return true;\n  if(b-360 >= a - pi && b-360 <= a + pi) return true;\n  return false;\n}\n\nvoid make(){\n  for(int i=0;i<n;i++){\n    G[i][i] = 0.0;\n    for(int j=i+1;j<n;j++)\n      G[i][j] = G[j][i] = abs(v[i]-v[j]);\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int bit = 0;\n      double a = arg(v[j]-v[i]) * 180.0 / M_PI;\n      for(int k=0;k<n;k++){\n\tdouble b = arg(v[k]-v[j]) * 180.0 / M_PI;\n\tif(check(a,b)) bit = (bit | (1<<k));\n      }\n      d[i][j] = bit;\n    }\n  }\n}\n\nvoid bfs(){\n  priority_queue<state> Q;\n  state u,v;\n  for(int i=1;i<n;i++){\n    memo[0][i][1] = G[0][i];\n    Q.push(state(i,1,0,G[0][i]));\n  }\n\n  while(!Q.empty()){\n    u = Q.top();\n    Q.pop();\n    ans = max(ans,u.item);\n    for(int i=0;i<n;i++){\n      if(i != u.n && ((1<<i) & d[u.prev][u.n]) != 0 && memo[u.n][i][u.item+1] >= u.dis+G[u.n][i] && u.dis+G[u.n][i] <= r){\n\tv = state(i,u.item+1,u.n,u.dis+G[u.n][i]);\n\tmemo[u.n][i][v.item] = v.dis;\n\tQ.push(v);\n      }\n    }\n  }\n    \n}\n\nint main(){\n  while(cin >> n){\n    cin >> r >> pi;\n\n    for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<10000;k++) memo[i][j][k] = INF;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      v[i] = P(x,y);\n    }\n\n    if(n == 1){\n      cout << 0 << endl;\n      continue;\n    }\n\n    make();\n    bfs();\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\ntypedef complex<double> P;\n\ndouble dif(P a,P b,P c){\n    a=b-a;\n    c-=b;\n    double ret=fabs(arg(c)-arg(a));\n    if(ret>=asin(1)*2){ret=asin(1)*4-ret;}\n    return ret;\n}\n\ndouble dist(P a,P b){\n    return abs(a-b);\n}\n\n\nint main(){\n    ll n;\n    double r,s;\n    cin>>n>>r>>s;\n    s*=asin(1)/90;\n    ll mx=10003;\n    vector<vector<vector<double>>> dp(mx,vector<vector<double>>(n,vector<double>(n,E)));\n    vector<P> a(n);\n    for(auto &i:a){\n        double x,y;\n        cin>>x>>y;\n        i={x,y};\n    }\n    ll ans=0;\n    for(int i=1;i<n;i++){\n        dp[1][i][0]=dist(a[i],a[0]);\n        if(dp[1][i][0]<=r){ans=1;}\n    }\n    for(int i=1;ans==i;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                if(t==h || dp[i][t][h]>r){continue;}\n                //cout<<i<<\" \"<<t<<\" \"<<h<<\" \"<<dp[i][t][h]<<endl;\n                for(int k=0;k<n;k++){\n                    if(k==h || k==t || dif(a[k],a[t],a[h])>s){continue;}\n                    dp[i+1][k][t]=min(dp[i+1][k][t],dp[i][t][h]+dist(a[t],a[k]));\n                    if(dp[i+1][k][t]<=r){ans=i+1;}\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> Pi;\ntypedef pair<double,int> Pd;\ntypedef pair<Pd,Pi> S;\n\nint n;\ndouble r,d;\nP p[20];\ndouble dp[20][20][10001];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint cal(){\n  priority_queue<S,vector<S>,greater<S> > Q;\n  int ans=0;\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)dp[j][k][i]=1e9;\n  dp[0][0][0]=0;\n  Q.push(S(Pd(0,0),Pi(0,0)));\n  while(!Q.empty()){\n    double cs=Q.top().first.first;\n    int i=Q.top().first.second;\n    int j=Q.top().second.first;\n    int k=Q.top().second.second;\n    Q.pop();\n    if(dp[j][k][i]<cs)continue;\n    if(cs>r)return ans;\n    for(int l=0;l<n;l++){\n      double ncs=cs+abs(p[k]-p[l]);\n      if(check(j,k,l)&&ncs<=r){\n\tif(dp[k][l][i+1]>ncs){\n\t  Q.push(S(Pd(cs+abs(p[k]-p[l]),i+1),Pi(k,l)));\n\t  dp[k][l][i+1]=ncs;\n\t}\n      }\n    }\n    ans=max(ans,i);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n>>r>>d;\n  double a,b;\n  for(int i=0;i<n;i++)cin>>a>>b,p[i]=P(a,b);\n  cout<<cal()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 20;\nint x[N], y[N];\n\ndouble dist[10010][N][N];\n\nvector<int> G[N][N];\ndouble D[N][N];\nint ok[N][N][N];\n\nconst double PI = 4 * atan(1);\nconst double EPS = 1e-9;\n\nint main(){\n\tint n;\n\tdouble r, theta;\n\tcin >> n >> r >> theta;\n\ttheta = theta / 180 * PI;\n\trep(i, n) cin >> x[i] >> y[i];\n\n\trep(i, n) rep(j, n){\n\t\tD[i][j] = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));\n\t}\n\n\trep(i, n) rep(j, n) rep(k, n){\n\t\tif (i == j || j == k) continue;\n\t\tdouble x1 = x[j] - x[i], y1 = y[j] - y[i];\n\t\tdouble x2 = x[k] - x[j], y2 = y[k] - y[j];\n\n\t\tdouble ct = (x1*x2 + y1*y2) / (D[i][j]*D[j][k]);\n\t\tdouble t = acos(ct);\n\n\t\tif (abs(t) < theta + EPS) G[i][j].push_back(k), ok[i][j][k] = 1;\n\t}\n\n\tMEMSET(dist, 0x7f);\n\n\tpriority_queue<tuple<double, int, int, int>> pq;\n\n\trep(i, n) rep(j, n){\n\t\tif (i == j) continue;\n\t\tif (D[i][j] > r - EPS) continue;\n\t\tpq.emplace(-D[i][j], 1, i, j);\n\t\tdist[1][i][j] = D[i][j];\n\t}\n\n\tint ans = 0;\n\t//while (!pq.empty()){\n\t//\tauto t = pq.top();\n\t//\tpq.pop();\n\t//\tdouble d;\n\t//\tint c, prv, cur;\n\t//\ttie(d, c, prv, cur) = t;\n\t//\td = -d;\n\n\t//\tif (dist[c][prv][cur] + EPS < d) continue;\n\n\t//\tans = max(ans, c);\n\n\t//\tfor (auto v : G[prv][cur]){\n\t//\t\tdouble nd = d + D[cur][v];\n\t//\t\tif (r < nd + EPS) continue;\n\t//\t\tif (dist[c + 1][cur][v] < nd + EPS) continue;\n\t//\t\tdist[c + 1][cur][v] = nd;\n\t//\t\tpq.emplace(-nd, c + 1, cur, v);\n\t//\t}\n\t//}\n\n\trep(i, 10010) rep(j, n) rep(k, n){\n\t\tif (dist[i][j][k] > r - EPS) continue;\n\t\tans = i;\n\t\trep(l, n) if (ok[j][k][l]) dist[i + 1][k][l] = min(dist[i + 1][k][l], dist[i][j][k] + D[k][l]);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\nconst double PI=acos(-1);\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef complex<double> Point;\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tdouble r,t; cin>>r>>t; t=t*PI/180;\n\t\tvector<Point> ps(n);\n\t\trep(i,n){\n\t\t\tint x,y; cin>>x>>y;\n\t\t\tps[i]=Point(x,y);\n\t\t}\n\t\t\n\t\tvvd d(n,vd(n));\n\t\trep(i,n) rep(j,n)\n\t\t\td[i][j]=abs(ps[j]-ps[i]);\n\t\tvvvi g(n,vvi(n));\n\t\trep(i,n) rep(j,n) if(j!=i) rep(k,n) if(k!=j){\n\t\t\tPoint d1=ps[j]-ps[i],d2=ps[k]-ps[j];\n\t\t\tif(abs(arg(d2/d1))<t)\n\t\t\t\tg[i][j].push_back(k);\n\t\t}\n\t\t\n\t\tqueue<tuple<int,int,double>> q; // (prev,cur,len)\n\t\trepi(i,1,n) q.emplace(0,i,d[0][i]);\n\t\tfor(int c=0;;c++){\n\t\t\tqueue<tuple<int,int,double>> q2;\n\t\t\twhile(q.size()){\n\t\t\t\tint prev,cur; double len;\n\t\t\t\ttie(prev,cur,len)=q.front(); q.pop();\n\t\t\t\tif(len>r) continue;\n\t\t\t\tfor(int next:g[prev][cur])\n\t\t\t\t\tq2.emplace(cur,next,len+d[prev][cur]);\n\t\t\t}\n\t\t\tif(q2.empty()){\n\t\t\t\tcout<<c<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswap(q,q2);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n#define F first\n#define S second\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<double,int>P1;\ntypedef pair<int,int>P2;\ntypedef pair<P1,P2>P3;\nint n,ans;\nP p[21];\nD r,qu,dp[10001][21][21];\nint main(){\n  cin>>n>>r>>qu;\n  rep(i,10001)rep(j,21)rep(k,21)dp[i][j][k]=1e15;\n  rep(i,n){\n    D x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<P3,vector<P3>,greater<P3> >q;\n  for(int i=1;i<n;i++){\n    if(abs(p[0]-p[i])>r)continue;\n    dp[1][0][i]=abs(p[0]-p[i]);\n    q.push(P3(P1(dp[1][0][i],1),P2(0,i)));\n  }\n  while(!q.empty()){\n    P3 ppp=q.top();q.pop();\n    int pre=ppp.S.F;\n    int now=ppp.S.S;\n    int num=ppp.F.S;\n    double cost=ppp.F.F;\n    if(dp[num][pre][now]<cost)continue;\n    rep(i,n)if(now!=i){\n      D a=abs(p[pre]-p[now]);\n      D b=abs(p[now]-p[i]);\n      D c=abs(p[i]-p[pre]);\n      D radi=acos((a*a+b*b-c*c)/(2*a*b));\n      radi=radi/M_PI*180;\n      if(180.0-radi > qu)continue;\n      if(cost+abs(p[now]-p[i])>r)continue;\n      if(dp[num+1][now][i]<cost+abs(p[now]-p[i]))continue;\n      dp[num+1][now][i]=cost+abs(p[now]-p[i]);\n      q.push(P3(P1(dp[num+1][now][i],num+1),P2(now,i)));\n    }\n  }\n  dp[0][0][0]=1;\n  for(int i=10000;i>=0;i--){\n    rep(j,21)rep(k,21)if(dp[i][j][k]!=1e15){\n      cout<<i<<endl;\n      return 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 20;\nconst double INF = -1.0;\n\nint n;\ndouble r, s, e[N][N][N], d[N][N][10005];\nvector<P> in;\n\nmain(){\n  cin >> n >> r >> s;\n  s *= M_PI / 180.0;\n  for(int i=0;i<n;i++){\n    P a;\n    cin >> a.real() >> a.imag();\n    in.push_back(a);\n  }\n  fill(e[0][0], e[N][0], INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i == j) continue;\n      for(int k=0;k<n;k++){\n        if(j == k) continue;\n        P a = in[i] - in[j];\n        P b = in[k] - in[j];\n        double t = acos(real(conj(a) * b) / (abs(a) * abs(b)));\n        //if(i == 0 && j == 3 && k == 4) cout << t << ' ' << M_PI - t << ' ' << s << endl;\n        if(M_PI - t <= s) e[i][j][k] = abs(b);\n      }\n    }\n  }\n  /*for(int i=0;i<n;i++){\n    cout << i << endl;\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n        printf(\"%.3f \", e[i][j][k]);\n      }\n      cout << endl;\n    }\n    }*/\n  fill(d[0][0], d[N][0], -1.0);\n  for(int i=1;i<n;i++) d[0][i][1] = abs(in[0] - in[i]);\n  int ans = 1;\n  for(int k=1;(double)k<r+1;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(d[i][j][k] < 0.0) continue;\n        ans = max(ans, k);\n        for(int l=0;l<n;l++){\n          if(e[i][j][l] < 0.0) continue;\n          double dist = d[i][j][k] + e[i][j][l];\n          //if(e[i][j][l] < 10.0) cout << i << ' ' << j << ' ' << l << ' ' << e[i][j][l] << endl;\n          if(dist > r) continue;\n          //cout << k+1 << ' ' << j << ' ' << l << ' ' << dist << endl;\n          if(d[j][l][k+1] < 0.0) d[j][l][k+1] = dist;\n          else if(d[j][l][k+1] > dist) d[j][l][k+1] = dist;\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 20\n#define MAX_C 10001\n#define INF 1e9\n#define EPS 1e-9\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n#define le(a,b) (equal(a,b) || lt(a,b))\n#define PI acos(-1)\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n  \n  Point operator + (const Point &p)const{\n    return Point(x+p.x,y+p.y);\n  }\n  Point operator - (const Point &p)const{\n    return Point(x-p.x,y-p.y);\n  }\n  Point operator * (double k)const{\n    return Point(x*k,y*k);\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  return is >> p.x >> p.y;\n}\n\nstruct State{\n  double d;\n  int v,p,c;\n  \n  State(double d,int v,int p,int c) : \n    d(d),v(v),p(p),c(c) {}\n  \n  bool operator < (const State &s)const{\n    return d > s.d;\n  }\n};\n\ndouble dot(const Point &a,const Point &b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble norm(const Point &p){\n  return dot(p,p);\n}\n\ndouble abs(const Point &p){\n  return sqrt(norm(p));\n}\n\ntypedef Point Vector;\n\ninline double getAngle(const Vector &a,const Vector &b){\n  return acos(dot(a,b)/abs(a)/abs(b))*180/PI;\n}\n\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint N;\ndouble r,th,d2[MAX_N][MAX_N];\nbool can[MAX_N][MAX_N][MAX_N];\ndouble d[MAX_N][MAX_N][MAX_C];\n\nint solve(const vector<Point> &vec){\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < N ; j++){\n      for(int k = 0 ; k < MAX_C ; k++){\n\td[i][j][k] = INF;\n      }\n    }\n  }\n  priority_queue<State> Q;\n  for(int i = 1 ; i < N ; i++){\n    Q.push(State(dist(vec[0],vec[i]),i,0,1));\n    d[i][0][1] = dist(vec[0],vec[i]);\n  }\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v,p = s.p,c = s.c;\n    if(lt(d[v][p][c],s.d)){ continue; }\n    if(lt(r,s.d)){ continue; }\n    for(int i = 0 ; i < N ; i++){\n      if(i == v || i == p){ continue; }\n      if(!can[p][v][i]){ continue; }\n      if(c+1 < MAX_C && lt(d[v][p][c]+d2[v][i],d[i][v][c+1])){\n\td[i][v][c+1] = d[v][p][c]+d2[v][i];\n\tQ.push(State(d[i][v][c+1],i,v,c+1));\n      }\n    }\n  }\n  int ans = 0;\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < N ; j++){\n      if(i == j){ continue; }\n      for(int k = MAX_C-1 ; k > 0 ; k--){\n\tif(le(d[i][j][k],r)){\n\t  ans = max(ans,k);\n\t  break;\n\t}\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  cin >> N >> r >> th;\n  vector<Point> v(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> v[i];\n  }\n  memset(can,false,sizeof(can));\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < N ; j++){\n      if(i == j){ continue; }\n      for(int k = 0 ; k < N ; k++){\n\tif(i == k || j == k){ continue; }\n\tVector a = v[j]-v[i];\n\tVector b = v[k]-v[j];\n\tdouble angle = getAngle(a,b);\n\tif(le(angle,th)){\n\t  can[i][j][k] = true;\n\t}\n      }\n    }\n  }\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < N ; j++){\n      d2[i][j] = dist(v[i],v[j]);\n    }\n  }\n  cout << solve(v) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<  vector<double>  > vvd;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef complex<double> zahyo;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nzahyo toshi[21];\nbool kakdotest(zahyo a,zahyo b,double kakdo){\n\n  double kak= (a.real()*b.real()+a.imag()*b.imag())/  (abs(a)*abs(b));\n  if (cos(kakdo*3.1415/180.0)<=kak)\n    return true;\n  else return false;\n}\nint main(){\n  int n,k;\n  double r,kakdo,xza,yza;\n  cin>>n>>r>>kakdo;\n  for(int i=1;i<=n;i++){\n    cin>>xza>>yza;\n    toshi[i]=zahyo(xza,yza);\n  }\n  vvd nokori(n+1);\n  for(int i=0;i<n+1;i++){\n    nokori[i]=vector<double>(21,-1);\n  }\n  vvd prevnokori=nokori;\n  for(int i=2;i<n+1;i++){\n    prevnokori[1][i]=r-abs(toshi[i]-toshi[1]);\n  }\n  int maxcarrot=0;\n  k=1;\n  while(k-maxcarrot==1){\n    vvd nextnokori=nokori;  \n    for(int i=1;i<(n+1);i++)\n      for(int j=1;j<(n+1);j++){\n\tif(i==j) continue;\n\tif(prevnokori[i][j]<0) continue;\n\tmaxcarrot=k;\n\t//\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<abs(prevnokori[i][j])<<endl;\n\tfor(int l=1;l<(n+1);l++){\n\t  if(kakdotest(toshi[i]-toshi[j],\n\t\t       toshi[j]-toshi[l],kakdo)){\n\t    nextnokori[j][l]=\n\t      max(prevnokori[i][j]-abs(toshi[j]-toshi[l]),\n\t\t\t\t nextnokori[j][l]);\n\t    //\t    cout<<i<<\" \"<<j<<\" \"<<l<<endl;\n\t  }\n\t}\n\n      }\n    prevnokori=nextnokori;\n    k++;\n  }\n  cout<<maxcarrot<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <algorithm>\n#undef max\n#undef min\n\nstruct Node {\n    int lastPos = 0;\n    int pos = 0;\n    int carrot = 0;\n    float len = 0;\n};\n\nint main() {\n    int n; float r, theta;\n    float angleTable[20][20][20] = { 0 };\n    float dist[20][20] = { 0 };\n    std::vector<float> memo[20];\n    std::vector<std::pair<int, int>> city;\n    std::cin >> n >> r >> theta;\n    theta /= 180.f;\n    theta *= M_PI;\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        city.push_back(std::make_pair(x, y));\n    }\n\n    // memo初期化\n    for (auto& x : memo) {\n        x.push_back(0.f);\n    }\n\n    // 都市間移動の角度と距離を計算\n    for (int i = 0; i < city.size(); i++) {\n        for (int j = 0; j < city.size(); j++) {\n            if (i == j) continue;\n            for (int k = 0; k < city.size(); k++) {\n                if (i == k) continue;\n                float vx[2] = { (float)(city[j].first - city[i].first) , (float)(city[k].first - city[i].first) };\n                float vy[2] = { (float)(city[k].second - city[i].second) , (float)(city[k].second - city[i].second) };\n                float jLen = std::sqrt(vx[0] * vx[0] + vy[0] + vy[0]);\n                float kLen = std::sqrt(vx[1] * vx[1] + vy[1] * vy[1]);\n                float dot = vx[0] * vx[1] + vy[0] * vy[1];\n                angleTable[i][j][k] = M_PI_2 - std::acos(dot / (jLen * kLen));\n            }\n            float vx = city[j].first - city[i].first;\n            float vy = city[j].second - city[i].second;\n            dist[i][j] = std::sqrt(vx * vx + vy * vy);\n        }\n    }\n\n    std::stack<Node> s;\n    int maxCarrot = 0;\n    s.push({0, 0, 0, 0.f});\n\n    while (!s.empty()) {\n        auto node = s.top(); s.pop();\n        for (int i = 0; i < city.size(); i++) {\n            if (i == node.pos) continue;\n            if (node.pos != node.lastPos && angleTable[node.lastPos][node.pos][i] >= theta) continue;\n            auto next = node;\n            next.lastPos = next.pos;\n            next.len += dist[node.pos][i];\n            if (next.len > r) continue;\n\n            next.pos = i;\n            next.carrot++;\n\n            if (memo[i].size() <= next.carrot) {\n                int m = memo[i].size();\n                for (int j = 0; j < next.carrot - m; j++) {\n                    memo[i].push_back(memo[i].back());\n                }\n                memo[i].push_back(next.carrot);\n            }\n            else {\n                if (memo[i][next.carrot] <= next.len) continue; // もっと短い距離で同数の人参に到達\n            }\n            maxCarrot = std::max(maxCarrot, next.carrot);\n            s.push(next);\n        }\n    }\n    std::cout << maxCarrot << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble dp[1000][20][20];\n\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tdouble r,t;\n\tcin>>n>>r>>t;\n\tt=t*M_PI/180.0;\n\tint x[n],y[n];\n\tfor (int i = 0; i < n; ++i) cin>>x[i]>>y[i];\n\t\n\tbool moveok[n][n][n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tfor (int j = 0; j < n; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t{\n\t\t\t\tif(i==j||j==k||k==i) moveok[i][j][k]=0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdouble rad1=(double)(y[i]-y[j])/(x[i]-x[j]),rad2=(double)(y[j]-y[k])/(x[j]-x[k]);\n\t\t\t\t\tif(x[i]==x[j]) rad1=(y[i]>y[j])?-M_PI/2:M_PI/2;\n\t\t\t\t\telse rad1=atan(rad1);\n\t\t\t\t\tif(x[j]==x[k]) rad2=(y[j]>y[k])?-M_PI/2:M_PI/2;\n\t\t\t\t\telse rad2=atan(rad2);\n\t\t\t\t\tdouble rad=fabs(rad1-rad2);\n\t\t\t\t\twhile(rad<0) rad+=2*M_PI;\n\t\t\t\t\twhile(rad>=2*M_PI) rad-=2*M_PI;\n\t\t\t\t\tif(rad<t+0.0001) moveok[i][j][k]=1;\n\t\t\t\t\telse moveok[i][j][k]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble distance[n][n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tfor (int j = 0; j < n; ++j)\n\t\t{\n\t\t\tdistance[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 1000; ++i)\n\t{\n\t\tfor (int j = 0; j < 20; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < 20; ++k)\n\t\t\t{\n\t\t\t\tdp[i][j][k]=-1.0;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tif(distance[0][i]<=r+0.0001) dp[1][0][i]=distance[0][i],ans=1;\n\t}\n\n\tfor (int i = 1; i < 1000; ++i)\n\t{\n\t\tfor (int j = 0; j < n; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t{\n\t\t\t\tif(dp[i][j][k]!=-1.0)\n\t\t\t\t{\n\t\t\t\t\tans = max(ans,i);\n\t\t\t\t\tfor (int l = 0; l < n; ++l)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(moveok[j][k][l])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[i+1][k][l]=dp[i][j][k]+distance[k][l];\n\t\t\t\t\t\t\tif(dp[i+1][k][l]>r+0.0001) dp[i+1][k][l]=-1.0;\n\t\t\t\t\t\t\t//if(dp[i+1][k][l]>0) ans=max(ans,i+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SP << \" \" <<\n\nLL mod = 1000000007;\n\ndouble pi = acos(-1.0);\ndouble INF = 1000000007;\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  LL n;\n  cin>>n;\n  double r, theta;\n  cin >> r >> theta;\n  vector<pii> xy;\n  REP(i,n){\n    LL x,y;\n    cin >> x >>y;\n    xy.push_back({x, y});\n  }\n\n  vector<vector<vector<bool>>> graph(n, vector < vector<bool>>(n, vector<bool>(n, false)));\n  \n  REP(i,n){\n    REP(j,n){\n      REP(k,n){\n        if(i!=j&&j!=k&&k!=i){\n          double bax = xy[i].first - xy[j].first;\n          double bay = xy[i].second - xy[j].second;\n          double bcx = xy[k].first - xy[j].first;\n          double bcy = xy[k].second - xy[j].second;\n          double babc = bax * bcx + bay * bcy;\n          double ban = (bax * bax) + (bay * bay);\n          double bcn = (bcx * bcx) + (bcy * bcy);\n          double radian = acos(babc / (sqrt(ban * bcn)));\n          double angle = radian * 180 / pi;\n          if((180-angle)<=theta){\n            graph[i][j][k] = true;\n          }\n        }\n      }\n    }\n  }\n\n  vector<vector<double>> length(n, vector<double>(n, INF));\n  REP(i,n){\n    REP(j,n){\n      length[i][j] = \n      sqrt((xy[i].first - xy[j].first) * (xy[i].first - xy[j].first) + \n      (xy[i].second - xy[j].second) * (xy[i].second - xy[j].second));\n    }\n  }\n\n  vector<vector<vector<double>>> dp(10001, vector<vector<double>>(n, vector<double>(n, INF)));\n  \n  REP(i,n){\n    dp[0][i][0] = 0;\n  }\n\n  REP(i,10000){\n    REP(j,n){\n      REP(k,n){\n        REP(l,n){\n          if(graph[j][k][l]||\n          (i==0&&k!=l)){\n            dp[i + 1][k][l] = min(dp[i][j][k] + length[k][l], dp[i + 1][k][l]);\n          }\n        }\n      }\n    }\n  }\n  \n  LL max = 0;\n  REP(i,10001){\n    REP(j,n){\n      REP(k,n){\n        if(dp[i][j][k]<=r){\n          if(max<i){\n            max = i;\n          }\n        }\n      }\n    }\n  }\n\n  cout << max << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\nconst int MOD = 1000000007;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nclass Edge{\npublic:\n    int to;\n    double cost;\n    Edge(int to, double cost): to(to), cost(cost){};\n};\n\nint N;\ndouble R, T;\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    cin >> N;\n    cin >> R >> T;\n    T = T * M_PI / 180;\n    \n    vector<P> cities(N);\n    for(int i=0; i<N; i++){\n        double x, y; cin >> x >> y;\n        cities[i] = P(x, y);\n    }\n    \n    vector<vector<vector<Edge>>> G(N, vector<vector<Edge>>(N));\n    for(int i=0; i<N; i++){\n        for(int j=0; j<N; j++) if(i != j){\n            for(int k=0; k<N; k++) if(j != k){\n                double rad = abs(arg((cities[j]-cities[i])/(cities[k]-cities[j])));\n                if(LE(rad, T)){\n                    G[i][j].push_back(Edge(k, abs(cities[k]-cities[j])));\n                }\n            }\n        }\n    }\n    \n    //???????????????????????£?????? ??´????????? ????????? ???????°??????¢\n    vector<vector<vector<double>>> dp(int(R+1), vector<vector<double>>(N, vector<double>(N, INF)));\n    //dp[0][0][0] = 0;\n    \n    for(int i=0; i<N; i++)\n        dp[1][0][i] = abs(cities[i]-cities[0]);\n    \n    for(int i=1; i<int(R); i++){\n        for(int j=0; j<N; j++){\n            for(int k=0; k<N; k++) if(j != k){\n                for(auto edge: G[j][k]){\n                    dp[i+1][k][edge.to] = min(dp[i+1][k][edge.to], dp[i][j][k]+edge.cost);\n                }\n            }\n        }\n    }\n    \n    for(int i=R; i>=0; i--){\n        for(int j=0; j<N; j++){\n            for(int k=0; k<N; k++){\n                if(LE(dp[i][j][k], R)){\n                    cout << i << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * carrot_tour.cpp\n *\n *  Created on: 2017/05/30\n *      Author: Nishio\n */\n#include<bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define p(s) cout<<(s)<<endl;\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\n\nconst int ctinf=1e5;\ndouble dp[10000][21][21];//num,prev,now = minr\n\ndouble vec_len(int x1,int x2,int y1,int y2){\n\treturn sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n}\n\nint dot_pro(int x1,int x2,int x3,int y1, int y2, int y3){\n\treturn (x2-x1)*(x3-x2)+(y2-y1)*(y3-y2);\n}\n\ndouble ctcos(int x1,int x2,int x3,int y1,int y2,int y3){\n\treturn dot_pro(x1,x2,x3,y1,y2,y3)/(vec_len(x1,x2,y1,y2)*vec_len(x2,x3,y2,y3));\n}\nint main(){\n\tint n;\n\tdouble r,theta;\n\tcin>>n>>r>>theta;\n\tREP(i,0,r) REP(j,0,21) REP(k,0,21) dp[i][j][k]=ctinf;\n\tdouble co=cos(theta*M_PI/180.0);\n\tint x[20],y[20];\n\tREP(i,0,n) cin>>x[i]>>y[i];\n\tint ans=0;\n\tvector<int> ok[21][21];\n\tREP(prev,0,n) REP(now,0,n){\n\t\tif(prev==now) continue;\n\t\tREP(next,0,n){\n\t\t\tif(prev==next||now==next) continue;\n\t\t\tif(ctcos(x[prev],x[now],x[next],y[prev],y[now],y[next])<co)continue;\n\t\t\tok[prev][now].push_back(next);\n\t\t}\n\t}\n\tREP(i,1,n) if(vec_len(x[0],x[i],y[0],y[i])<r){\n\t\tdp[1][0][i]=vec_len(x[0],x[i],y[0],y[i]);\n\t\tans=1;\n\t}\n\t//int from,to;\n\n\tREP(i,2,r){\n\t\tREP(prev,0,n){\n\t\t\tREP(now,0,n){\n\t\t\t\tif(prev==now) continue;\n\t\t\t\tfor(auto next:ok[prev][now]){\n\t\t\t\t\tif(dp[i-1][prev][now]+vec_len(x[now],x[next],y[now],y[next])<=r){\n\t\t\t\t\t\tdp[i][now][next]=min(dp[i][now][next],dp[i-1][prev][now]+vec_len(x[now],x[next],y[now],y[next]));\n\t\t\t\t\t\tans=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tp(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ld = long double;\nusing ll = long long;\nconstexpr ld PI = 3.1415926535898;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Pos {\n    ld x;\n    ld y;\n    Pos operator-(const Pos& p) const\n    {\n        return Pos{x - p.x, y - p.y};\n    }\n};\n\nld distance(const Pos& p1, const Pos& p2)\n{\n    return hypot(p1.x - p2.x, p1.y - p2.y);\n}\n\nld dot(const Pos& p1, const Pos& p2)\n{\n    return p1.x * p2.x + p1.y * p2.y;\n}\n\nbool reachable(const Pos& prev, const Pos& now, const Pos& to, const ld theta)\n{\n    if (theta == 180) {\n        return true;\n    } else {\n        return dot(now - prev, to - now) > distance(now, prev) * distance(to, now) * cos(theta / 180.0 * PI);\n    }\n}\n\n\nint main()\n{\n    int n;\n    cin >> n;\n    ld r, theta;\n    cin >> r >> theta;\n\n    vector<Pos> pos(n);\n    for (int i = 0; i < n; i++) {\n        cin >> pos[i].x >> pos[i].y;\n    }\n\n    vector<vector<ld>> d(n, vector<ld>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = distance(pos[i], pos[j]);\n        }\n    }\n\n    vector<vector<vector<int>>> route(n, vector<vector<int>>(n, vector<int>(0)));  // prev->now???????????????to\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                if (k == j) {\n                    continue;\n                }\n                if (reachable(pos[i], pos[j], pos[k], theta)) {\n                    route[i][j].push_back(k);\n                }\n            }\n        }\n    }\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) {\n    //         if (not route[i][j].empty()) {\n    //             cerr << \"## After(\" << i << \"->\" << j << \")##\\n[\";\n    //             for (const int to : route[i][j]) {\n    //                 cerr << to << \",\";\n    //             }\n    //             cerr << \"]\" << endl;\n    //         }\n    //     }\n    // }\n\n    constexpr ld INF = 100000;\n    vector<vector<ld>> prev(n, vector<ld>(n, INF));\n    vector<vector<ld>> dp(n, vector<ld>(n, INF));\n    for (int i = 1; i < n; i++) {\n        if (d[0][i] <= r) {\n            prev[0][i] = d[0][i];\n        }\n    }\n    for (int i = 0; i < 2 * r; i++) {\n        int num = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (prev[i][j] != INF) {\n                    num++;\n                    for (const int to : route[i][j]) {\n                        const ld l = prev[i][j] + d[j][to];\n                        if (l > r) {\n                            continue;\n                        }\n                        dp[j][to] = min(dp[j][to], l);\n                    }\n                }\n            }\n        }\n        if (num == 0) {\n            cout << i << endl;\n            return 0;\n        }\n        prev = dp;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j] = INF;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> mid = cities[prev];\n  complex<double> dst = cities[city];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,false,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      if(dp[s.carrots][s.prev][s.city]) continue;\n      dp[s.carrots][s.prev][s.city] = true;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct point{\n  double x,y;\n};\n\ndouble INF = 1e9;\ndouble PI = acos(-1);\ndouble EPS = (1e-10);\ndouble dp[10001][20][20];\nint n;\ndouble r,ti;\npoint t[20];\n\nvoid solve(int i,int j,int k){\n  for(int to=0;to<n;to++){\n    double vax=t[to].x-t[j].x;\n    double vay=t[to].y-t[j].y;\n    double vbx=t[j].x-t[k].x;\n    double vby=t[j].y-t[k].y;\n    double ar=(vax*vbx+vay*vby)/(sqrt(vax*vax+vay*vay)*sqrt(vbx*vbx+vby*vby));\n    ar=acos(ar);\n    if(ar<0)ar*=-1;\n    if(ar<ti+EPS){\n      dp[i+1][to][j]=dp[i][j][k]+sqrt(vax*vax+vay*vay);\n    }\n  }\n}\n\nint main(){\n\n  for(int i=0;i<10001;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<20;k++)\n\tdp[i][j][k]=INF;\n  \n  cin>>n>>r>>ti;\n  ti=ti/360.0*2.0*PI;\n\n  for(int i=0;i<n;i++)\n    cin>>t[i].x>>t[i].y;\n  \n  for(int i=1;i<n;i++){\n    double x=t[i].x-t[0].x;\n    double y=t[i].y-t[0].y;\n    dp[1][i][0]=sqrt(x*x+y*y);\n  }\n\n  int ans=-1;\n  for(int i=1;i<=10000;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(dp[i][j][k]>r+EPS)continue;\n\tans=max(ans,i);\n\tsolve(i,j,k);\n      }\n    }\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nint n;\ndouble dp[10001][21][21]={};\ndouble x[21],y[21],r,s;\nbool b[21][21][21]={};\n\ndouble abs(int a,int b){\n  return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n}\n\ndouble dot(int i,int j,int k){\n  return (x[i]-x[j])*(x[k]-x[j])+(y[i]-y[j])*(y[k]-y[j]);\n}\n\nint main()\n{\n  cin>>n>>r>>s;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(i==j || j==k || i==k){\n\t  b[i][j][k]=false;\n\t  continue;\n\t}\n\tdouble R=acos(dot(i,j,k)/(double)(abs(i,j)*abs(j,k)));\n\tR=R*360/(2.0*pi);\n\tR=min(R,360-R);\n\tif(((180-R)-s)<eps)b[i][j][k]=true;\n\telse b[i][j][k]=false;\n      }\n    }\n  }\n\n  for(int i=0;i<10001;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tdp[i][j][k]=inf;\n\n  for(int i=1;i<n;i++)dp[0][0][i]=abs(0,i);\n\n  int ans=0;\n  for(int c=1;c<10001;c++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  if(b[i][j][k]){\n\t    dp[c][j][k]=min(dp[c][j][k],dp[c-1][i][j]+abs(k,j));\n\t    if(dp[c][j][k]-r<eps)ans=max(c+1,ans);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define fs first\n#define sc second\n#define pb push_back\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<D,int> Edge;\ntypedef pair<Edge, pair<int,int> > state;\n\nconst D PI = acos(-1);\nconst D EPS = 1e-12;\n\ninline D dis(D x1, D y1, D x2, D y2){\n  return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\ninline D dot(P x, P y){ return real(conj(x)*y); }\n\ninline D arg(P a, P b, P c){ return acos(dot(b-a,a-c)/abs(b-a)/abs(a-c)); }\n\nint n;\nD r,s;\nP p[30];\nD d[30][30];\nvector<Edge> g[30][30];\nD lensum[30][30][1010];\n\nint main(){ \n  cin >> n >> r >> s;\n  s *= PI/180;\n  rep(i,n)cin >> p[i].real() >> p[i].imag();\n  rep(i,n){\n    d[i+1][i+1] = 0;\n    for(int j=i+1;j<n;j++){\n      d[i+1][j+1] = d[j+1][i+1] = abs(p[i]-p[j]);\n    }\n  }\n  \n  rep(i,n){\n    if(i)g[0][1].pb(Edge(d[1][i],i));\n  }\n\n  rep(i,n){\n    rep(j,n){\n      if(i==j)continue;\n      rep(k,n){\n\tif(j==k)continue;\n\tif(arg(p[j],p[i],p[k]) < s + EPS){\n\t  g[i+1][j+1].pb(Edge(d[j+1][k+1],k+1));\n\t}\n      }\n    }\n  }\n\n  rep(i,n+1)rep(j,n+1)rep(k,1010)lensum[i][j][k] = 1e10;\n  lensum[0][1][0] = 0;\n  priority_queue<state,vector<state>,greater<state> > q;\n  q.push(mk(mk(0,0),mk(0,1)));\n\n  int ans = 0;\n  while(q.size()){\n    state tmp = q.top(); q.pop();\n    D len = tmp.fs.fs;\n    int carrot = tmp.fs.sc+1, prv = tmp.sc.fs, cur = tmp.sc.sc;\n\n    rep(i,g[prv][cur].size()){\n      D cost = g[prv][cur][i].fs;\n      int nxt = g[prv][cur][i].sc;\n\n      if(len + cost > r + EPS)continue;\n      if(lensum[cur][nxt][carrot] > len + cost + EPS){\n\tlensum[cur][nxt][carrot] = len + cost;\n\tq.push(state(mk(len+cost,carrot),mk(cur,nxt)));\n\tans = max(ans,carrot);\n      }\n    }\n  }\t\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 200\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nint V;\ndouble r, theta, E_sz[500];\n\n// A*B の計算\nmat mul(mat &A, mat &B){\n\tmat C(A.size(), vec(B[0].size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tfor(int j = 0; j < B[0].size(); j++){\n\t\t\tdouble mini = INF;\n\t\t\tfor(int k = 0; k < B.size(); k++){\n\t\t\t\tmini = min(mini, A[i][k] + B[k][j]);\n\t\t\t}\n\t\t\tC[i][j] = mini;\n\t\t}\n\t}\n\treturn C;\n}\n\n// A^n の計算\nint mat_pow(mat A){\n\tmat B(A.size(), vec(A.size()));\n\tfor(int i = 0; i < V * V; i++){\n\t\tfor(int j = 0; j < V * V; j++){\n\t\t\tB[i][j] = E_sz[i];\n\t\t}\n\t}\n\tint num = 1;\n\t\n\twhile(true){\n\t\tB = mul(B, A);\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < V * V; i++){\n\t\t\tfor(int j = 0; j < V * V; j++){\n\t\t\t\tif(B[i][j] < r){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\n\treturn num;\n}\n\nint main(){\n\t\n\tcin >> V;\n\t\n\tcin >> r >> theta;\n\t\n\ttheta = theta * M_PI / 180;\n\t\n\tmat S(V * V, vec(V * V));\n\t\n\tdouble x[30], y[30];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i = 0; i < V * V; i++){\n\t\tE_sz[i] = INF;\n\t\tfor(int j = 0; j < V * V; j++){\n\t\t\tS[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tif(i == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble vx1, vx2, vy1, vy2;\n\t\t\tvx1 = x[j] - x[i];\n\t\t\tvy1 = y[j] - y[i];\n\t\t\tdouble norm1 = sqrt(vx1 * vx1 + vy1 * vy1);\n\t\t\tE_sz[i * V + j] = norm1;\n\t\t\t\n\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\tif(j == k || k == i){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvx2 = x[k] - x[j];\n\t\t\t\tvy2 = y[k] - y[j];\n\t\t\t\tdouble inn = vx1 * vx2 + vy1 * vy2;\n\t\t\t\tdouble norm2 = sqrt(vx2 * vx2 + vy2 * vy2);\n\t\t\t\tdouble th = acos(inn / norm1 / norm2);\n\t\t\t\tif(th < theta){\n\t\t\t\t\tS[i * V + j][j * V + k] = norm2;\n\t\t\t\t\t//S[j * V + i][k * V + j] = norm2;\n\t\t\t\t\t//S[j * V + k][i * V + j] = norm1;\n\t\t\t\t\tS[k * V + j][j * V + i] = norm1;\n\t\t\t\t\t//cout << i * V + j << \" \" << j * V + k << \" \" << norm2 << endl;\n\t\t\t\t\t//cout << k * V + j << \" \" << j * V + i << \" \" << norm1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tbool flag = true;\n\tfor(int i = 0; i < V * V; i++){\n\t\tif(E_sz[i] < r){\n\t\t\tflag = false;\n\t\t}\n\t}\n\t\n\tif(flag){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << mat_pow(S) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ndouble dp[405][25][25];\nbool ok[25][25][25];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  double PI = atan2(1, 0)*2, EPS = 1e-8;\n  // cout << PI << endl;\n\n  int n;\n  double r, t;\n  cin >> n >> r >> t;\n  t *= PI/180;\n  VI x(n), y(n);\n  REP(i, n) cin >> x[i] >> y[i];\n\n  if(n == 1) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  REP(i, n) REP(j, n) REP(k, n) {\n    if(i == j || j == k || k == i) continue;\n    double ang1 = atan2(y[j]-y[i], x[j]-x[i]);\n    double ang2 = atan2(y[j]-y[k], x[j]-x[k]);\n    if(abs(ang1 - ang2) < t + EPS) {\n      ok[i][j][k] = true;\n    }\n  }\n\n  int ans = 1;\n  REP(i, 405) REP(j, n) REP(k, n) dp[i][j][k] = INF;\n  REP(i, n) dp[1][0][i] = sqrt((x[i]-x[0])*(x[i]-x[0])+(y[i]-y[0])*(y[i]-y[0]));\n\n  FOR(i, 1, n*(n-1)/2) REP(j, n) REP(k, n) {\n    REP(l, n) {\n      // j->k->lが可能ならば遷移\n      if(ok[j][k][l]) {\n        double dist = sqrt((x[k]-x[l])*(x[k]-x[l])+(y[k]-y[l])*(y[k]-y[l]));\n        chmin(dp[i+1][k][l], dp[i][j][k] + dist);\n        if(dp[i+1][k][l] < r) {\n          chmax(ans, i+1);\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R INF = 1e9;\nconst R PI = acos((R)(-1));\n\n//?§???????[0, 2*PI)???\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n//?§???????[-PI, PI)???\nR radNorN(R x) {\n    x = radNorP(x);\n    if (x >= PI) x -= 2*PI;\n    return x;\n}\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\nint n;\nR r, th;\nP p[22];\n\nR dp[22][22][10100];\nR g[22][22][22];\nint main() {\n    cin >> n;\n    cin >> r >> th; th = deg2rad(th);\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                g[i][j][k] = INF;\n                if (i == j || j == k) continue;\n                R u = arg(p[j]-p[i]) - arg(p[k] - p[j]);\n                u = abs(radNorN(u));\n                if (u >= th) continue;\n                g[i][j][k] = abs(p[k] - p[j]);\n//                printf(\"%d %d %d %Lf %Lf\\n\", i, j, k, u, g[i][j][k]);\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j][1] = INF;\n            if (i != 0) continue;\n            if (j == 0) continue;\n            dp[0][j][1] = abs(p[j] - p[i]);\n        }\n    }\n    for (int s = 2; s < 10100; s++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][s] = INF;\n                for (int k = 0; k < n; k++) {\n                    dp[i][j][s] = min(dp[i][j][s],\n                        dp[k][i][s-1] + g[k][i][j]);\n                }\n            }\n        }\n    }\n    int res = 0;\n    for (int s = 1; s < 10100; s++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dp[i][j][s] < r) res = max(res, s);\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ld = long double;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Pos {\n    ld x;\n    ld y;\n    Pos operator-(const Pos& p) const\n    {\n        return Pos{x - p.x, y - p.y};\n    }\n};\n\nld distance(const Pos& p1, const Pos& p2)\n{\n    return hypot(p1.x - p2.x, p1.y - p2.y);\n}\n\nld dot(const Pos& p1, const Pos& p2)\n{\n    return p1.x * p2.x + p1.y * p2.y;\n}\n\nbool reachable(const Pos& prev, const Pos& now, const Pos& to, const ld theta)\n{\n    if (theta == 180) {\n        return true;\n    } else {\n        return dot(now - prev, to - now) > distance(now, prev) * distance(to, now) * cos(theta);\n    }\n}\n\n\nint main()\n{\n    int n;\n    cin >> n;\n    ld r, theta;\n    cin >> r >> theta;\n\n    vector<Pos> pos(n);\n    for (int i = 0; i < n; i++) {\n        cin >> pos[i].x >> pos[i].y;\n    }\n\n    vector<vector<ld>> d(n, vector<ld>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = distance(pos[i], pos[j]);\n        }\n    }\n\n    vector<vector<vector<int>>> route(n, vector<vector<int>>(n, vector<int>(0)));  // prev->now???????????????to\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                if (k == j) {\n                    continue;\n                }\n                if (reachable(pos[i], pos[j], pos[k], theta)) {\n                    route[i][j].push_back(k);\n                }\n            }\n        }\n    }\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) {\n    //         if (not route[i][j].empty()) {\n    //             cerr << \"## After(\" << i << \"->\" << j << \")##\\n[\";\n    //             for (const int to : route[i][j]) {\n    //                 cerr << to << \",\";\n    //             }\n    //             cerr << \"]\" << endl;\n    //         }\n    //     }\n    // }\n\n    map<pair<int, int>, ld> prev;\n    map<pair<int, int>, ld> dp;\n    for (int i = 1; i < n; i++) {\n        prev[make_pair(0, i)] = d[0][i];\n    }\n    for (int i = 0; i < 2 * r; i++) {\n        if (prev.empty()) {\n            cout << i << endl;\n            return 0;\n        }\n        for (const auto& p : prev) {\n            const int from = p.first.first;\n            const int now = p.first.second;\n            const ld length = p.second;\n            for (const int to : route[from][now]) {\n                const ld tot = length + d[from][now];\n                if (tot > r) {\n                    continue;\n                }\n                const auto e = make_pair(now, to);\n                if (dp.find(e) == dp.end()) {\n                    dp[e] = tot;\n                } else {\n                    dp[e] = min(dp[e], tot);\n                }\n            }\n        }\n        // cerr << \"dp = [\";\n        // for (const auto& e : dp) {\n        //     cerr << e << \",\";\n        // }\n        // cerr << \"]\" << endl;\n\n        prev = dp;\n        dp.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 200\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nint V;\ndouble r, theta, E_sz[500];\n\n// A*B の計算\nmat mul(mat &A, mat &B){\n\tmat C(A.size(), vec(B[0].size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tfor(int j = 0; j < B[0].size(); j++){\n\t\t\tdouble mini = INF;\n\t\t\tfor(int k = 0; k < B.size(); k++){\n\t\t\t\tmini = min(mini, A[i][k] + B[k][j]);\n\t\t\t}\n\t\t\tC[i][j] = mini;\n\t\t}\n\t}\n\treturn C;\n}\n\n// A^n の計算\nint mat_pow(mat A){\n\tmat B(A.size(), vec(A.size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tB[i][i] = 1;\n\t}\n\tint num = 0;\n\twhile(true){\n\t\tB = mul(B, A);\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < V * V; i++){\n\t\t\tfor(int j = 0; j < V * V; j++){\n\t\t\t\tif(B[i][j] + E_sz[i] < r){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\n\treturn num;\n}\n\nint main(){\n\t\n\tcin >> V;\n\t\n\tcin >> r >> theta;\n\t\n\ttheta = theta * M_PI / 180;\n\t\n\tmat S(V * V, vec(V * V));\n\t\n\tdouble x[30], y[30];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i = 0; i < V * V; i++){\n\t\tE_sz[i] = INF;\n\t\tfor(int j = 0; j < V * V; j++){\n\t\t\tS[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\tif(i == j || j == k || k == i){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble vx1, vx2, vy1, vy2;\n\t\t\t\tvx1 = x[j] - x[i];\n\t\t\t\tvy1 = y[j] - y[i];\n\t\t\t\tvx2 = x[k] - x[j];\n\t\t\t\tvy2 = y[k] - y[j];\n\t\t\t\tdouble inn = vx1 * vx2 + vy1 * vy2;\n\t\t\t\tdouble norm1 = sqrt(vx1 * vx1 + vy1 * vy1);\n\t\t\t\tdouble norm2 = sqrt(vx2 * vx2 + vy2 * vy2);\n\t\t\t\tE_sz[i * V + j] = norm1;\n\t\t\t\tE_sz[k * V + j] = norm2;\n\t\t\t\tdouble th = acos(inn * inn / norm1 / norm2);\n\t\t\t\tif(M_PI - th < theta){\n\t\t\t\t\tS[i * V + j][j * V + k] = norm2;\n\t\t\t\t\t//S[j * V + i][k * V + j] = norm2;\n\t\t\t\t\t//S[j * V + k][i * V + j] = norm1;\n\t\t\t\t\tS[k * V + j][j * V + i] = norm1;\n\t\t\t\t\t//cout << i * V + j << \" \" << j * V + k << \" \" << norm2 << endl;\n\t\t\t\t\t//cout << k * V + j << \" \" << j * V + i << \" \" << norm1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool flag = true;\n\tfor(int i = 0; i < V * V; i++){\n\t\tif(E_sz[i] < r){\n\t\t\tflag = false;\n\t\t}\n\t}\n\t\n\tif(flag){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << mat_pow(S) + 1 << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\n\ninline double dist(int i,int j){\n\tint dx=(x[i]-x[j]);\n\tint dy=(y[i]-y[j]);\n\treturn sqrt(1.0*dx*dx+1.0*dy*dy);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tdouble r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tdp[0][0][n]=0.0;\n\trep(i,limit)rep(cp,n)rep(pp,n+1){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(i>0&&pp==n) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tdouble add=dist(cp,np);\n\t\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\t\tdouble dot=1.0*cx*nx+1.0*cy*ny;\n\t\t\tdot/=(dist(cp,pp)*dist(np,cp));\n\t\t\tdouble angle=acos(dot);\n\t\t\tangle*=180.0/pi;\n\n\t\t\t// cerr << pp << \" \" << cp << \" \" << np << \" \" << dot << endl;\n\t\t\tif(angle>180.0) angle=360.0-angle;\n\t\t\tif(pp!=n&&angle>theta) continue;\n\t\t\tdp[i+1][np][cp]=min(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,limit+1)rep(cp,n)rep(pp,n+1){\n\t\tif(dp[i][cp][pp]<=r) ans=max(ans,i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntypedef long double D;\nconst D eps = 1e-10;\nconst D pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\n\ninline D dist(int i,int j){\n\tint dx=(x[i]-x[j]);\n\tint dy=(y[i]-y[j]);\n\treturn sqrt(1.0*dx*dx+1.0*dy*dy);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tD r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tdp[0][0][n]=0.0;\n\n\trep(i,limit)rep(cp,n)rep(pp,n+1){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(i>0&&pp==n) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tD add=dist(cp,np);\n\t\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\t\tD dot=1.0*cx*nx+1.0*cy*ny;\n\t\t\tdot/=(dist(cp,pp)*dist(np,cp));\n\t\t\tdot=max<D>(-1,dot);\n\t\t\tdot=min<D>(1,dot);\n\t\t\tD angle=acos(dot);\n\t\t\tangle*=180.0/pi;\n\n\t\t\tif(angle>180.0) angle=360.0-angle;\n\t\t\tif(pp!=n&&angle>theta) continue;\n\t\t\t// cerr << np << \" \"  << cp << \" \" << pp << \" \" << angle << endl;\n\t\t\tif(dp[i][cp][pp]+add>r) continue;\n\t\t\tdp[i+1][np][cp]=min<D>(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,limit+1)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]<=r) ans=max(ans,i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n \ntypedef complex<double> P;\n \nstruct S{\n  int w,p,n;\n  double d;\n  bool operator<(S s)const{\n    return d>s.d;\n  }\n};\n \ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n \nint main(){\n  int n;\n  double r,th;\n  cin>>n>>r>>th;\n  P p[21];\n  for(int i=1;i<=n;i++){\n    int x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<S> que;\n  que.push({1,0,0,0});\n  static bool mem[21][21][22222];\n  int m=0;\n  while(!que.empty()){\n    auto cs=que.top();\n    if(cs.d>r)break;\n    que.pop();\n    if(mem[cs.w][cs.p][cs.n]++)continue;\n    m=max(m,cs.n);\n    for(int i=1;i<=n;i++){\n      if(i==cs.w)continue;\n      auto f=p[cs.w]-p[cs.p];\n      auto t=p[i]-p[cs.w];\n      if(cs.p&&acos(dot(f,t)/abs(f)/abs(t))*90>th*acos(0))continue;\n      que.push({i,cs.w,cs.n+1,cs.d+abs(t)});\n    }\n  }\n  cout<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n\nstruct State {\n\tint cur, prev, carrot;\n\tdouble d;\n\tState(int cur_, int prev_, int carrot_, double d_) {\n\t\tcur = cur_;\n\t\tprev = prev_;\n\t\tcarrot = carrot_;\n\t\td = d_;\n\t}\n\tbool operator<(const State& right) const {\n\t\treturn d > right.d;\n\t}\n};\n\nint x[22], y[22];\ndouble r, theta;\n\nbool check_angle(int p, int i, int n) {\n\tdouble a1 = x[i] - x[p], a2 = y[i] - y[p];\n\tdouble b1 = x[n] - x[i], b2 = y[n] - y[i];\n\tdouble cos_theta = (a1 * b1 + a2 * b2) / (sqrt(a1 * a1 + a2 * a2) * sqrt(b1 * b1 + b2 * b2));\n\treturn cos_theta > cos(theta * M_PI / 180);\n}\n\ntuple<int, int, int> to_key(const State& s) {\n\treturn make_tuple(s.cur, s.prev, s.carrot);\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tcin >> r >> theta;\n\n\tfor(int i=0;i<n;i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tpriority_queue<State> que;\n\tque.emplace(0, n, 0, 0);\n\n\tmap<tuple<int, int, int>, double> memo;\n\tmemo[to_key(que.top())] = 0;\n\n\tint ans = 0;\n\twhile(!que.empty()) {\n\t\tState s = que.top();\n\t\tque.pop();\n\t\tauto key = to_key(s);\n\t\tif (memo[key] < s.d) continue;\n\t\tans = max(ans, s.carrot);\n\n\t\tfor(int to=0;to<n;to++) {\n\t\t\tif (to == s.cur) continue;\n\t\t\tif (s.prev != n && !check_angle(s.prev, s.cur, to)) continue;\n\t\t\tdouble nd = s.d + sqrt((x[s.cur] - x[to]) * (x[s.cur] - x[to]) + (y[s.cur] - y[to]) * (y[s.cur] - y[to]));\n\t\t\tif (nd > r) continue;\n\n\t\t\tauto next_key = make_tuple(to, s.cur, s.carrot + 1);\n\t\t\tif (memo.find(next_key) == memo.end() || memo[next_key] > nd) {\n\t\t\t\tmemo[next_key] = nd;\n\t\t\t\tque.emplace(to, s.cur, s.carrot + 1, nd);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double INF = (double)(1<<29);\nconst double EPS = 1e-7;\n\nint n, ans;\nvector<int> G[20][20];\ndouble r, theta;\nbool  memo[20][20][10001];\nP v[20];\n\nstruct state{\n  int prev,pos,sum;\n  double dis;\n  state(int p=0, int po=0, int s=0, double d=0):prev(p),pos(po),sum(s),dis(d){}\n  bool operator < (const state &s) const {\n    return dis > s.dis;\n  }\n};\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\ndouble calcTheta(P a, P b, P c){\n  double A = abs(b - a);\n  double B = abs(b - c);\n  double C = abs(a - c);\n  double ans = acos((A*A + B*B - C*C) / (2*A*B));\n  return M_PI - ans;\n}\n\n/*\nvoid dfs(int prev, int pos, int sum, double dis){\n  //if(memo[prev][pos][sum] <= dis || equal(memo[prev][pos][sum],dis)) return;\n  ans = max(ans,sum);\n  for(int i=0;i<G[prev][pos].size();i++){\n    int next = G[prev][pos][i];\n    if(dis + abs(v[pos]-v[next]) > r || memo[pos][next][sum+1] <= dis + abs(v[pos]-v[next]) || equal(memo[pos][next][sum+1], dis + abs(v[pos]-v[next]))) continue;\n    memo[pos][next][sum+1] = dis + abs(v[pos]-v[next]);\n    dfs(pos, next, sum+1, dis+abs(v[pos]-v[next]));\n  }\n}\n*/\n\nvoid bfs(){\n  priority_queue<state> Q;\n  state u,next;\n  for(int i=1;i<n;i++){\n    if(abs(v[i]-v[0]) > r) continue;\n    memo[0][i][1] = true;\n    Q.push(state(0,i,1,abs(v[i]-v[0])));\n  }\n\n  while(!Q.empty()){\n    u = Q.top();\n    Q.pop();\n    ans = max(ans,u.sum);\n    for(int i=0;i<G[u.prev][u.pos].size();i++){\n      next = state(u.pos, G[u.prev][u.pos][i], u.sum+1, u.dis);\n      next.dis += abs(v[u.pos]-v[next.pos]);\n      if(next.dis > r || next.sum > 10000 || memo[u.pos][next.pos][next.sum]) continue;\n      memo[u.pos][u.pos][next.sum] = true;\n      Q.push(next);\n    }\n  }\n}\n\nint main(){\n  while(cin >> n){\n    ans = 0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        G[i][j].clear();\n        for(int k=0;k<10001;k++) memo[i][j][k] = false;\n      }\n    }\n\n    cin >> r >> theta;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      v[i] = P(x,y);\n    }\n    theta *= M_PI / 180.0;\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        for(int k=0;k<n;k++){\n          if(i == k || j == k) continue;\n          if(calcTheta(v[i],v[j],v[k]) < theta) G[i][j].push_back(k);\n        }\n      }\n    }\n\n    /*\n    for(int i=1;i<n;i++){\n      if(abs(v[i]-v[0]) > r) continue;\n      memo[0][i][1] = abs(v[i]-v[0]);\n      dfs(0, i, 1, abs(v[i]-v[0]));\n      }\n    */\n    bfs();\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> P;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9, PI = acos(-1);\n\nint n;;\nP p[20];\ndouble r, t;\ndouble dp[20][20][10010], d[20][20];\nbool can[20][20][20];\n\nint main(){\n\tcin >> n >> r >> t;\n\tt *= PI / 180;\n\trep(i, n) cin >> p[i].real() >> p[i].imag();\n\t\n\trep(i, n) rep(j, n) rep(k, n) if(i != j && j != k){\n\t\tdouble a = abs(arg((p[j] - p[i]) / (p[k] - p[j])));\n\t\tcan[i][j][k] = EPS < a && a + EPS < t;\n\t}\n\trep(i, n) rep(j, n) d[i][j] = abs(p[i] - p[j]);\n\t\n\trep(i, n) rep(j, n) rep(k, 10010) dp[i][j][k] = INF;\n\trep(i, n) dp[0][i][1] = d[0][i];\n\t\n\tint ans = 0;\n\trep(k, 10010) rep(i, n) rep(j, n) if(dp[i][j][k] < r + EPS){\n\t\tans = max(ans, k);\n\t\trep(l, n) if(can[i][j][l]){\n\t\t\tdp[j][l][k + 1] = min(dp[j][l][k + 1], dp[i][j][k] + d[j][l]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R INF = 1e9;\nconst R PI = acos((R)(-1));\n\n//?§???????[0, 2*PI)???\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n//?§???????[-PI, PI)???\nR radNorN(R x) {\n    x = radNorP(x);\n    if (x >= PI) x -= 2*PI;\n    return x;\n}\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\nint n;\nR r, th;\nP p[22];\n\nR dp[22][22][10100];\nR g[22][22][22];\nint main() {\n    cin >> n;\n    cin >> r >> th; th = deg2rad(th);\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                g[i][j][k] = INF;\n                if (i == j || j == k) continue;\n                R u = arg(p[j]-p[i]) - arg(p[k] - p[j]);\n                u = abs(radNorN(u));\n                if (u >= th) continue;\n                g[i][j][k] = abs(p[k] - p[j]);\n//                printf(\"%d %d %d %Lf %Lf\\n\", i, j, k, u, g[i][j][k]);\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j][1] = INF;\n            if (i != 0) continue;\n            if (j == 0) continue;\n            dp[0][j][1] = abs(p[j] - p[i]);\n        }\n    }\n    for (int s = 2; s < 10100; s++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][s] = INF;\n                for (int k = 0; k < n; k++) {\n                    dp[i][j][s] = min(dp[i][j][s],\n                        dp[k][i][s-1] + g[k][i][j]);\n                }\n            }\n        }\n    }\n    int res = 0;\n    for (int s = 1; s < 10100; s++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dp[i][j][s] < r) res = max(res, s);\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntypedef long double D;\nconst D eps = 1e-10;\nconst D pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\nD dist[20][20];\n\nbool ok[20][20][20];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tD r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,n)rep(j,n){\n\t\tint dx=(x[i]-x[j]);\n\t\tint dy=(y[i]-y[j]);\n\t\tdist[i][j]=sqrt(1.0*dx*dx+1.0*dy*dy);\n\t}\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\trange(cp,1,n) dp[1][cp][0]=dist[cp][0];\n\n\trep(pp,n)rep(cp,n)rep(np,n){\n\t\tif(pp==cp) continue;\n\t\tif(cp==np) continue;\n\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\tD dot=1.0*cx*nx+1.0*cy*ny;\n\t\tdot/=(dist[cp][pp]*dist[np][cp]);\n\t\tdot=max<D>(-1,dot);\n\t\tdot=min<D>(1,dot);\n\t\tD angle=acos(dot);\n\t\tangle*=180.0/pi;\n\t\tif(angle>180.0) angle=360.0-angle;\n\t\tif(angle<=theta) ok[pp][cp][np]=true;\n\t}\n\n\tint ans=1;\n\trep(i,limit)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tD add=dist[cp][np];\n\t\t\tif(dp[i][cp][pp]+add>r) continue;\n\t\t\tif(dp[pp][cp][np]==false) continue;\n\t\t\tdp[i+1][np][cp]=min<D>(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t\tans=max(ans,i+1);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass state{\npublic:\n  int n,item,prev;\n  double dis;\n  state(int n=0, int item=0, int prev=0, int dis=0):n(n),item(item),prev(prev),dis(dis){}\n  bool operator < (const state &s) const {\n    return dis > s.dis;\n  }\n};\n\nconst double EPS = 1e-5;\nconst double INF = (double)(1<<29);\nint n,d[20][20],ans;\ndouble r,pi,memo[20][20][10000],G[20][20];\nP v[20];\n\nbool equal(double a, double b){ return fabs(a-b) < EPS;}\nbool leq(double a, double b) { return equal(a,b) || a < b;}\nbool req(double a, double b) { return equal(a,b) || a > b;}\n\n\nbool check(double a, double b){\n  if(req(b, a - pi) && leq(b, a + pi)) return true;\n  if(req(b+360, a - pi) && leq(b+360, a + pi)) return true;\n  if(req(b-360, a - pi) && leq(b-360, a + pi)) return true;\n  return false;\n}\n\nvoid make(){\n  for(int i=0;i<n;i++){\n    G[i][i] = 0.0;\n    for(int j=i+1;j<n;j++)\n      G[i][j] = G[j][i] = abs(v[i]-v[j]);\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int bit = 0;\n      double a = arg(v[j]-v[i]) * 180.0 / M_PI;\n      for(int k=0;k<n;k++){\n\tdouble b = arg(v[k]-v[j]) * 180.0 / M_PI;\n\tif(check(a,b)) bit = (bit | (1<<k));\n      }\n      d[i][j] = bit;\n    }\n  }\n}\n\nvoid bfs(){\n  priority_queue<state> Q;\n  state u,v;\n  for(int i=1;i<n;i++){\n    if(G[0][i] > r && !equal(G[0][i],r)) continue;\n    memo[0][i][1] = G[0][i];\n    Q.push(state(i,1,0,G[0][i]));\n  }\n\n  while(!Q.empty()){\n    u = Q.top();\n    Q.pop();\n    ans = max(ans,u.item);\n    for(int i=0;i<n;i++){\n      if(i != u.n && ((1<<i) & d[u.prev][u.n]) != 0 && req(memo[u.n][i][u.item+1], u.dis+G[u.n][i]) && leq(u.dis+G[u.n][i], r)){\n\tv = state(i,u.item+1,u.n,u.dis+G[u.n][i]);\n\tmemo[u.n][i][v.item] = v.dis;\n\tQ.push(v);\n      }\n    }\n  }\n    \n}\n\nint main(){\n  while(cin >> n){\n    ans = 0;\n    cin >> r >> pi;\n\n    for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<10000;k++) memo[i][j][k] = INF;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      v[i] = P(x,y);\n    }\n\n    if(n == 1){\n      cout << 0 << endl;\n      continue;\n    }\n\n    make();\n    bfs();\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> Pi;\ntypedef pair<double,int> Pd;\ntypedef pair<Pd,Pi> S;\n\nint n;\ndouble r,d;\nP p[20];\nint dp[10001][20][20];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint cal(){\n  priority_queue<S,vector<S>,greater<S> > Q;\n  int ans=0;\n  Q.push(S(Pd(0,0),Pi(0,0)));\n  while(!Q.empty()){\n    double cs=Q.top().first.first;\n    int i=Q.top().first.second;\n    int j=Q.top().second.first;\n    int k=Q.top().second.second;\n    Q.pop();\n    if(dp[i][j][k]++||cs>r)continue;\n    dp[i][j][k]=1;\n    for(int l=0;l<n;l++)\n      if(check(j,k,l))\n\tQ.push(S(Pd(cs+abs(p[k]-p[l]),i+1),Pi(k,l)));\n    ans=max(ans,i);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n>>r>>d;\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n  cout<<cal()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    long double r,theta;\n    cin >> n >> r >> theta;\n    vector<long double> x(n),y(n);\n    rep(i,0,n) cin >> x[i] >> y[i];\n\n    int ans=0;\n    long double dp[20][20];\n    fill_n((long double*)dp,20*20,inf);\n    rep(i,1,n) dp[0][i]=sqrt((x[i]-x[0])*(x[i]-x[0])+(y[i]-y[0])*(y[i]-y[0]));\n    while(true){\n        if([&]{\n            long double mini=inf;\n            rep(i,0,n) rep(j,0,n) mini=min(mini,dp[i][j]);\n            return mini;\n        }()<r) ++ans;\n        else break;\n\n        long double prev[20][20];\n        memcpy(prev,dp,sizeof(long double)*20*20);\n        fill_n((long double*)dp,20*20,inf);\n        rep(i,0,n) rep(j,0,n) rep(k,0,n){\n            if(i==j or j==k) continue;\n            const long double l1=sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));\n            const long double l2=sqrt((x[k]-x[j])*(x[k]-x[j])+(y[k]-y[j])*(y[k]-y[j]));\n            if(((x[j]-x[i])*(x[k]-x[j])+(y[j]-y[i])*(y[k]-y[j]))/l1/l2<cos(theta)) continue;\n            dp[j][k]=min(dp[j][k],prev[i][j]+l2);\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\ndouble d[20][20], a[20][20][20], dp[10000][20][20];\n\nint main() {\n\tint n; double r, th;\n\tcin >> n >> r >> th;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\td[i][j] = hypot(x[i] - x[j], y[i] - y[j]);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (i == j || j == k) continue;\n\t\t\t\tint x1 = x[i] - x[j], y1 = y[i] - y[j];\n\t\t\t\tint x2 = x[j] - x[k], y2 = y[j] - y[k];\n\t\t\t\tdouble c = (x1 * x2 + y1 * y2) / d[i][j] / d[j][k];\n\t\t\t\ta[i][j][k] = (c >= cos(th / 180 * M_PI));\n\t\t\t}\n\tfill(dp[0][0], dp[0][0] + 10000 * 20 * 20, FLT_MAX);\n\tfor (int i = 1; i < n; i++)\n\t\tdp[1][i][0] = d[i][0];\n\tfor (int l = 2; l < 10000; l++)\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\tif (i != j && j != k && a[i][j][k])\n\t\t\t\t\t\tdp[l][i][j] = min(dp[l][i][j], dp[l - 1][j][k] + d[i][j]);\n\tint maxi = 0;\n\tfor (int l = 1; l < 10000; l++)\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (dp[l][i][j] <= r) maxi = l;\n\tcout << maxi << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 20;\nconst int MAXC = 10010;\nconst double INF = 1e+9;\nconst double EPS = 1e-8;\n\nstruct edge{\n  int to;\n  double cost;\n  edge(int t=0, double c=0):to(t),cost(c){}\n};\n\nstruct state{\n  int prev, now, cnt;\n  double dis;\n  state(int p=0, int n=0, int c=0, double d=0):prev(p),now(n),cnt(c),dis(d){}\n  bool operator < (const state &s) const {\n    return dis > s.dis;\n  }\n};\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\ndouble angle(P a, P b1, P b2){\n  double A = abs(b1 - b2);\n  double B = abs(a - b1);\n  double C = abs(a - b2);\n  return acos((B*B + C*C - A*A) / (2.0*B*C));\n}\n\n\nint n;\ndouble r, rad;\nvector<P> v;\n\ndouble d[N][N][MAXC];\n\nint solve(){\n  int ans = 0;\n  priority_queue<state> pq;\n  state u, u2;\n  vector<edge> g[N][N];\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n        if(j != k && (i == j || M_PI - angle(v[j], v[i], v[k]) < rad + EPS)) {\n          g[i][j].push_back(edge(k, abs(v[j] - v[k])));\n          //if(i != j) cout << v[i] << \" -> \" << v[j] << \" -> \" << v[k] << \" : \" << abs(v[j]-v[k]) << endl;\n        }\n      }\n    }\n  }\n\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<MAXC;k++) d[i][j][k] = INF;\n\n  for(pq.push(state(0, 0, 0, 0)); !pq.empty();){\n    u = pq.top();\n    pq.pop();\n\n    for(int i=0;i<g[u.prev][u.now].size();i++){\n      edge next = g[u.prev][u.now][i];\n      u2 = state(u.now, next.to, u.cnt+1, u.dis+next.cost);\n      assert(u2.cnt < MAXC);\n      if(u2.dis > r + EPS || d[u2.prev][u2.now][u2.cnt] < u2.dis + EPS) continue;\n      d[u2.prev][u2.now][u2.cnt] = u2.dis;\n      ans = max(ans, u2.cnt);\n      pq.push(u2);\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  while(cin >> n){\n    v.clear();\n    cin >> r >> rad;\n    rad *= M_PI / 180.0;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> x >> y;\n      v.push_back(P(x,y));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\n\nld dp[22][22][11111], dist[22][22][22];\nint main()\n{\n\tint n; ld r, th;\n\tcin >> n >> r >> th;\n\tvector<Point> ps;\n\tREP(i, n)\n\t{\n\t\tld x, y; cin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\tREP(i, n)REP(j, n)REP(k, n)\n\t{\n\t\tPoint pre = ps[i], now = ps[j], next = ps[k];\n\t\tPoint v1 = now - pre, v2 = next - now;\n\t\tif (i == j || j == k || i == k)\n\t\t{\n\t\t\tdist[i][j][k] = INF;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tld lhs = dot(v1, v2), rhs = abs(v1)*abs(v2)*cos(th / 180.0 * PI);\n\t\t\tif (lhs - rhs > -EPS) dist[i][j][k] = abs(v2);\n\t\t\telse dist[i][j][k] = INF;\n\t\t}\n\t}\n\tREP(i, 22)REP(j, 22)REP(k, 11111) dp[i][j][k] = INF;\n\tdp[0][0][0] = 0;\n\tFOR(i, 1, n) dp[0][i][1] = abs(ps[i] - ps[0]);\n\tFOR(k, 1, 11111)REP(i, n)REP(j, n)\n\t{\n\t\tREP(l, n)\n\t\t{\n\t\t\tif (dist[i][j][l] == INF) continue;\n\t\t\telse chmin(dp[j][l][k + 1], dp[j][l][k] + dist[i][j][l]);\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, 22)REP(j, 22)REP(k, 1111)\n\t{\n\t\tif (dp[i][j][k] <= r) chmax(ans, k);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef complex<double> P;\n\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 20;\n\n\n\nint main(){\n  int n;\n  double r, theta;\n  double g[sz + 1][sz][sz];\n \n  cin >> n;\n  cin >> r >> theta;\n  \n  vector<P> pts(n);\n  REP(i, n) cin >> pts[i].real() >> pts[i].imag();\n    \n  fill(&g[0][0][0], &g[0][0][0] + (sz + 1) * sz * sz, INF);\n  \n  REP(i, n + 1)REP(j, n)REP(k, n)if(j != k){\n    if(i == n){\n      g[i][j][k] = abs(pts[j] - pts[k]);\n    }else{\n      double ang = arg(pts[j] - pts[i]) - arg(pts[k] - pts[j]);\n      while(ang > M_PI) ang -= M_PI * 2;\n      while(ang < -M_PI) ang += M_PI * 2;\n      ang *= 180 / M_PI;\n      if(abs(ang) < theta + EPS) g[i][j][k] = abs(pts[j] - pts[k]);\n    }\n  }\n  \n  double dp[2][sz+1][sz];\n  int count = -1;\n  bool update = true;\n\n  fill(&dp[0][0][0], &dp[0][0][0] + 2 * (sz + 1) * sz, INF);\n  \n  dp[0][n][0] = 0.0;\n  while(update){\n    update = false;\n    int cur = ++count % 2;\n    int nxt = 1 - cur;\n    fill(&dp[nxt][0][0], &dp[nxt][0][0] + (sz + 1) * sz, INF);\n    \n    \n    REP(j, n)REP(k, n){\n      REP(i, n + 1){\n        dp[nxt][j][k] = min(dp[nxt][j][k], dp[cur][i][j] + g[i][j][k]);\n      }\n      if(dp[nxt][j][k] < r + EPS){\n        update = true;\n      }\n    }\n  }\n  \n  cout << count << endl;\n  \n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> dst = cities[city];\n\n  src -= cities[prev];\n  dst -= cities[prev];\n  double computed_arg = abs(arg(src) - arg(dst));\n\n  return (limit_rad >= M_PI - min(computed_arg,\n\t\t\t\t  abs(2.0*M_PI - computed_arg)) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[3001][21][21]; //dp[carrot][prev][now] := remaining distance\nbool isok[21][21][21]; //cur,prev,old\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    memset(isok,true,sizeof(isok));\n    for(int old = 0; old < total_cities; old++){\n      for(int prev = 0; prev < total_cities; prev++){\n\tfor(int cur = 0; cur < total_cities; cur++){\n\t  isok[cur][prev][old] = check(cur,prev,old,limit_rad,cities);\n\t}\n      }\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(!isok[next_city][next_prev][next_old]) continue;\n\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 21;\nconst int MAXX = 10001;\nconst double eps = 1e-6;\nconst double inf = 1e10;\n\nint n;\ndouble r, th;\nP ps[MAXN];\ndouble G[MAXN][MAXN][MAXN];\ndouble dp[MAXX][MAXN][MAXN];\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble getAngle(P a, P b) {\n  double v = dot(a, b) / (abs(a) * abs(b));\n  if(v > 1.0) return 0;\n  if(v < -1.0) return M_PI;\n  return acos(v);\n}\n\nint main() {\n  while(cin >> n) {\n    cin >> r >> th;\n    th = th * M_PI / 180.0;\n    for(int i = 0; i < n; ++i)\n      cin >> ps[i].real() >> ps[i].imag();\n\n    for(int j = 0; j < n; ++j) {\n      for(int k = 0; k < n; ++k) {\n        for(int l = 0; l < n; ++l) {\n          P a = ps[k] - ps[j], b = ps[l] - ps[k];\n          if(k == l) G[j][k][l] = inf;\n          else if(j == k) G[j][k][l] = abs(b);\n          else if(getAngle(a, b) < th + eps) G[j][k][l] = abs(b);\n          else G[j][k][l] = inf;\n        }\n      }\n    }\n\n    fill(dp[0][0], dp[MAXX][0], inf);\n    dp[0][0][0] = 0;\n    int res = 0;\n    for(int i = 0; i+1 < MAXX; ++i) {\n      if(i != res) break;\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < n; ++k) {\n          for(int l = 0; l < n; ++l) {\n            dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + G[j][k][l]);\n            if(dp[i+1][k][l] < r + eps) {\n              res = i + 1;\n            }\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\n\n// 角度関連\ndouble angle(const P &a, const P &b) {        // ベクトルａからみたベクトルｂの角度の計算[0,2pi]\n  double ret = arg(b)-arg(a);\n  return (ret>=0) ? ret : ret + 2*PI;\n}\ndouble angle2(const P &a, const P &b) { // ベクトルaとベクトルbの間の角度\n  return min(angle(a,b), angle(b,a));\n}\ndouble rtod(double rad) {       // ラジアン→度\n  return rad*180/PI;\n}\ndouble dtor(double deg) {       // 度→ラジアン\n  return deg*PI/180;\n}\n\n\nP p[20];\ndouble dp[20][20][10010];       // dp[i][j][k] = i->jでk個取るときの最小合計距離\ndouble dis[20][20];\nbool ok[20][20][20];            // i->j->k がいけるならok[i][j][k]=1\n\nint main() {\n  int n;\n  cin >> n;\n  double r,th;\n  cin >> r >> th;\n  th = dtor(th);\n  REP(i,n) cin >> p[i].real() >> p[i].imag();\n  REP(i,n)REP(j,n) {\n    if (i==j)continue;\n    dis[i][j] = abs(p[i]-p[j]);\n    REP(k,n) {\n      if (j==k) continue;\n      if (angle(p[j]-p[i],p[k]-p[j]) <= th) ok[i][j][k] = 1;\n    }\n  }\n  REP(i,n)REP(j,n)REP(k,10010)dp[i][j][k]=INF;\n  REP(i,n) {\n    if (i==0) continue;\n    dp[0][i][1] = dis[0][i];\n  }\n  int ans = 1;\n  REP(k,10010-1) {\n    REP(i,n) {\n      REP(j,n) {\n        REP(l,n) {\n          if (!ok[i][j][l]) continue;\n          dp[j][l][k+1] = min(dp[j][l][k+1], dp[i][j][k]+dis[i][j]);\n          if (dp[j][l][k+1] <= r) {\n            ans = k+1;\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 21;\nconst int MAXX = 10001;\nconst double eps = 1e-8;\nconst double inf = 1e10;\n\nint n;\ndouble r, th;\nP ps[MAXN];\ndouble dp[MAXX][MAXN][MAXN];\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble getAngle(P a, P b) {\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nint main() {\n  while(cin >> n) {\n    cin >> r >> th;\n    th = th * M_PI / 180.0;\n    for(int i = 0; i < n; ++i)\n      cin >> ps[i].real() >> ps[i].imag();\n    fill(dp[0][0], dp[MAXX][0], inf);\n    dp[0][0][0] = 0;\n    int res = 0;\n    for(int i = 0; i+1 < MAXX; ++i) {\n      if(i != res) break;\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < n; ++k) {\n          if(dp[i][j][k] == inf) continue;\n          for(int l = 0; l < n; ++l) {\n            if(k == l) continue;\n            if(j != k) {\n              double rad = getAngle(ps[k]-ps[j], ps[l]-ps[k]);\n              if(rad > th + eps) continue;\n            }\n            dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + abs(ps[l]-ps[k]));\n            if(dp[i+1][k][l] < r + eps) {\n              res = i + 1;\n            }\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef double R;\ntypedef complex<R> P;\nconst R PI = 3.1415926535897932384626;\n\nistream& operator>>(istream &is, P &p) {\n\tR x, y;\n\tis >> x >> y;\n\tp = P(x, y);\n\treturn is;\n}\n\nint n;\ndouble r, theta;\n\ndouble visited[401][10005];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> r >> theta; theta = theta/180.*PI;\n\tvector<P> p(n);\n\tREP(i, n) cin >> p[i];\n\tvector<vector<pair<int, double>>> g(n*n);\n\tREP(i, n)REP(j, n)REP(k, n){\n\t\tif(i==k || i==j || j==k) continue;\n\t\tif(abs(arg((p[j]-p[i]) / (p[k]-p[j]))) < theta){\n\t\t\tg[j*n+i].emplace_back(k*n+j, abs(p[k]-p[j]));\n\t\t}\n\t}\n\tstruct State{\n\t\tint x, c;\n\t\tdouble cost;\n\t\tState(int x, int c, double cost)\n\t\t\t:x(x), c(c), cost(cost){}\n\t\tbool operator<(const State &opp) const{\n\t\t\treturn cost > opp.cost;\n\t\t}\n\t};\n\tpriority_queue<State> que;\n\tREP(i, 1)REP(j, n)if(i!=j){\n\t\tif(abs(p[i]-p[j]) < r){\n\t\t\tque.emplace(j*n+i, 1, abs(p[i]-p[j]));\n\t\t\tvisited[j*n+i][1] = abs(p[i]-p[j]);\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(!que.empty()){\n\t\tconst State s = que.top(); que.pop();\n\t\tif(s.cost > visited[s.x][s.c]) continue;\n\t\tans = max(ans, s.c);\n\t\tFOR(it, g[s.x]){\n\t\t\tint x = it->first;\n\t\t\tdouble cost = s.cost + it->second;\n\t\t\tint c = s.c + 1;\n\t\t\tauto &t = visited[x][c];\n\t\t\tif((t == 0 || cost < t) && cost < r){\n\t\t\t\tt = cost;\n\t\t\t\tque.emplace(x, c, cost);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 21;\nconst int MAXX = 10001;\nconst double eps = 1e-6;\nconst double inf = 1e10;\n\nint n;\ndouble r, th;\nP ps[MAXN];\ndouble dp[MAXX][MAXN][MAXN];\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble getAngle(P a, P b) {\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nint main() {\n  while(cin >> n) {\n    cin >> r >> th;\n    th = th * M_PI / 180.0;\n    for(int i = 0; i < n; ++i)\n      cin >> ps[i].real() >> ps[i].imag();\n    fill(dp[0][0], dp[MAXX][0], inf);\n    dp[0][0][0] = 0;\n    int res = 0;\n    for(int i = 0; i+1 < MAXX; ++i) {\n      if(i != res) break;\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < n; ++k) {\n          if(dp[i][j][k] == inf) continue;\n          for(int l = 0; l < n; ++l) {\n            if(k == l) continue;\n            if(j != k) {\n              double rad = getAngle(ps[k]-ps[j], ps[l]-ps[k]);\n              if(rad > th + eps) continue;\n            }\n            dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + abs(ps[l]-ps[k]));\n            if(dp[i+1][k][l] <= r) {\n              res = i + 1;\n            }\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> P;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n#define pi acos(-1)\n\ndouble dp[20][20][10001];\n\nint main(){\n    cin.sync_with_stdio(false);\n    int n;\n    double r, theta;\n    cin >> n >> r >> theta;\n    theta = theta * pi / 180.0;\n    vector<P> v;\n    rep(i, n) {\n        double x, y;\n        cin >> x >> y;\n        v.pb(P(x, y));\n    }\n\n    rep(i, n)rep(j, n)rep(k, 10001) dp[i][j][k] = INF + 1;\n    dp[0][0][0] = 0;\n    int ans = 0;\n    rep(k, 10000) {\n        if (ans != k) break;\n        rep(i, n)rep(j, n) {\n            if (dp[i][j][k] < INF) {\n                rep(l, n) {\n                    if (j == l || i == l) continue;\n                    double alpha = abs(arg(v[l] - v[j]) - arg(v[j] - v[i]));\n                    if (alpha > pi) alpha = 2 * pi - alpha;\n                    if (alpha <= theta && dp[i][j][k] + abs(v[l] - v[j]) <= r) {\n                        minch(dp[j][l][k + 1], dp[i][j][k] + abs(v[l] - v[j]));\n                        ans = k + 1;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> Pi;\ntypedef pair<double,int> Pd;\ntypedef pair<Pd,Pi> S;\n\nint n;\ndouble r,d;\nP p[20];\nint dp[10001][20][20];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint cal(){\n  priority_queue<S,vector<S>,greater<S> > Q;\n  int ans=0;\n  Q.push(S(Pd(0,0),Pi(0,0)));\n  while(!Q.empty()){\n    double cs=Q.top().first.first;\n    int i=Q.top().first.second;\n    int j=Q.top().second.first;\n    int k=Q.top().second.second;\n    Q.pop();\n    if(dp[i][j][k]++||cs>r)continue;\n    dp[i][j][k]=1;\n    for(int l=0;l<n;l++)\n      if(check(j,k,l))\n\tQ.push(S(Pd(cs+abs(p[k]-p[l]),i+1),Pi(k,l)));\n    ans=max(ans,i);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n>>r>>d;\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n  cout<<cal()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\nusing real = double;\nstatic constexpr real EPS = 1e-10;\nreal pi = acos(-1);\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ndouble arg(Point p){\n    return atan2(p.y, p.x);\n}\n\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\nusing Polygon = vector<Point>;\n\nPoint polar(double r, double t){\n    return Point(r*cos(t), r*sin(t));\n}\n\nreal angle(Point A, Point B){\n    return acos(dot(A, B)/abs(A)/abs(B));\n}\n\n\nint main() {\n    int n; real r, t;\n    cin >> n >> r >> t;\n    t = t*pi/180;\n    int x = (int)ceil(r)+2;\n    auto dp = make_v(x+1, n, n, -MOD*1.0);\n    auto ok = make_v(n, n, n, 0);\n    auto dist = make_v(n, n, 0.0);\n    int ans = 0;\n    Polygon p(n);\n    for(auto &&i : p) cin >> i;\n\n    for (int i = 0; i < n; ++i) {\n        dp[0][0][i] = r-abs(p[0]-p[i]);\n        for (int j = 0; j < n; ++j) {\n            if(i == j) continue;\n            dist[i][j] = abs(p[i]-p[j]);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if(i == j) continue;\n            for (int k = 0; k < n; ++k) {\n                if(i == k || j == k) continue;\n                ok[i][j][k] = (abs(angle(p[k]-p[j], p[j]-p[i])) < t);\n            }\n        }\n    }\n\n    for (int i = 0; i < x; ++i) {\n        int cont = 0;\n        for (int j = 0; j < n; ++j) {\n            for (int k = 0; k < n; ++k) {\n                if(j == k) continue;\n                if(dp[i][j][k] > 0) ans = max(ans, i+1);\n                for (int l = 0; l < n; ++l) {\n                    if(k == l || j == l) continue;\n                    if(ok[j][k][l] &&  dp[i][j][k] > dist[k][l]){\n                        dp[i+1][k][l] = max(dp[i+1][k][l], dp[i][j][k]-dist[k][l]);\n                        cont = 1;\n                    }\n                }\n            }\n        }\n        if(!cont) break;\n    }\n\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\nint main(){\n  int n;\n  double r, theta;\n  cin >> n >> r >> theta;\n  theta *= acos(-1)/180;\n  vector<int> X(n), Y(n);\n  for(int i = 0; i < n; ++i) cin >> X[i] >> Y[i];\n  vector< vector<double> > dp(n,vector<double>(n,0));\n  bool f = false;\n  int ans = 0;\n  for(int i = 1; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      if(i == j) continue;\n      //int x1 = X[0] - X[i], y1 = Y[0] - Y[i], x2 = X[j] - X[i], y2 = Y[j] - Y[i];\n      int x1 = X[i] - X[0], y1 = Y[i] - Y[0], x2 = X[j] - X[i], y2 = Y[j] - Y[i];\n      if(acos((x1*x2+y1*y2)/hypot(x1,y1)/hypot(x2,y2)) < theta && \n         hypot(x2,y2) <= r){\n        f = true;\n        dp[i][j] = max(dp[i][j],r - hypot(x2,y2));\n      }\n    }\n  }\n  while(f){\n    f = false;\n    ++ans;\n    vector< vector<double> > dp_(n,vector<double>(n,0));\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        if(i == j) continue;\n        for(int k = 0; k < n; ++k){\n          if(j == k) continue;\n          int x1 = X[j] - X[i], y1 = Y[j] - Y[i], x2 = X[k] - X[j], y2 = Y[k] - Y[j];\n          if(acos((x1*x2+y1*y2)/hypot(x1,y1)/hypot(x2,y2)) < theta && \n             hypot(x2,y2) <= dp[i][j]){\n            f = true;\n            dp_[j][k] = max(dp_[j][k],dp[i][j] - hypot(x2,y2));\n          }\n        }\n      }\n    }\n    dp = dp_;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass state{\npublic:\n  int n,item,prev;\n  double dis;\n  state(int n=0, int item=0, int prev=0, int dis=0):n(n),item(item),prev(prev),dis(dis){}\n  bool operator < (const state &s) const {\n    return dis > s.dis;\n  }\n};\n\nconst double EPS = 1e-4;\nconst double INF = (double)(1<<29);\nint n,d[20][20],ans;\ndouble r,pi,memo[20][20][10000],G[20][20];\nP v[20];\n\nbool equal(double a, double b){ return fabs(a-b) < EPS;}\nbool leq(double a, double b) { return equal(a,b) || a < b;}\nbool req(double a, double b) { return equal(a,b) || a > b;}\n\n\nbool check(double a, double b){\n  if(req(b, a - pi) && leq(b, a + pi)) return true;\n  if(req(b+360, a - pi) && leq(b+360, a + pi)) return true;\n  if(req(b-360, a - pi) && leq(b-360, a + pi)) return true;\n  return false;\n}\n\nvoid make(){\n  for(int i=0;i<n;i++){\n    G[i][i] = 0.0;\n    for(int j=i+1;j<n;j++)\n      G[i][j] = G[j][i] = abs(v[i]-v[j]);\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int bit = 0;\n      double a = arg(v[j]-v[i]) * 180.0 / M_PI;\n      for(int k=0;k<n;k++){\n\tdouble b = arg(v[k]-v[j]) * 180.0 / M_PI;\n\tif(check(a,b)) bit = (bit | (1<<k));\n      }\n      d[i][j] = bit;\n    }\n  }\n}\n\nvoid bfs(){\n  priority_queue<state> Q;\n  state u,v;\n  for(int i=1;i<n;i++){\n    if(G[0][i] > r && !equal(G[0][i],r)) continue;\n    memo[0][i][1] = G[0][i];\n    Q.push(state(i,1,0,G[0][i]));\n  }\n\n  while(!Q.empty()){\n    u = Q.top();\n    Q.pop();\n    ans = max(ans,u.item);\n    for(int i=0;i<n;i++){\n      if(i != u.n && ((1<<i) & d[u.prev][u.n]) != 0 && req(memo[u.n][i][u.item+1], u.dis+G[u.n][i]) && leq(u.dis+G[u.n][i], r)){\n\tv = state(i,u.item+1,u.n,u.dis+G[u.n][i]);\n\tmemo[u.n][i][v.item] = v.dis;\n\tQ.push(v);\n      }\n    }\n  }\n    \n}\n\nint main(){\n  while(cin >> n){\n    ans = 0;\n    cin >> r >> pi;\n\n    for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<10000;k++) memo[i][j][k] = INF;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      v[i] = P(x,y);\n    }\n\n    if(n == 1){\n      cout << 0 << endl;\n      continue;\n    }\n\n    make();\n    bfs();\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000.0\n#define EPS 1e-10\n#define PI 3.1415926535897932384626433832795028841971\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,double> P;\n\nint n;\ndouble d, t;\ndouble x[20], y[20];\ndouble dp[10001][20][20];\nvector<P> edge[20][20];\n\nint main(){\n\trep(i,10001) rep(j,20) rep(k,20) dp[i][j][k] = INF;\n\tcin >> n;\n\tcin >> d >> t;\n\tt = t*2*PI/360;\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t}\n\trep(i,n) rep(j,n) rep(k,n){\n\t\tif(i == j || j == k || i == k) continue;\n\t\tdouble x1 = x[j]-x[i], x2 = x[k]-x[j];\n\t\tdouble y1 = y[j]-y[i], y2 = y[k]-y[j];\n\t\tdouble g1 = atan2(y1,x1), g2 = atan2(y2,x2);\n\t\tg1 = abs(g1-g2);\n\t\twhile(g1 > 2*PI+EPS) g1 -= 2*PI;\n\t\tif(g1 > PI+EPS) g1 = 2*PI-g1;\n\t\tif(g1 < t){\n\t\t\tdouble dis = sqrt(pow(x[j]-x[k],2)+pow(y[j]-y[k],2));\n\t\t\tedge[i][j].push_back(P(k,dis));\n\t\t}\n\t}\n\tdp[1][0][0] = 0.0;\n\tfor(int i = 1; i < n; i++){\n\t\tif(d < sqrt(pow(x[i]-x[0],2)+pow(y[i]-y[0],2))) continue;\n\t\tdp[2][0][i] = sqrt(pow(x[i]-x[0],2)+pow(y[i]-y[0],2));\n\t}\n\t\n\tfor(int i = 3; i <= 10000; i++){\n\t\trep(j,20) rep(k,20){\n\t\t\tif(j == k) continue;\n\t\t\tif(dp[i-1][j][k] > d) continue;\n\t\t\trep(l,edge[j][k].size()){\n\t\t\t\tP p = edge[j][k][l];\n\t\t\t\tdp[i][k][p.first] = min(dp[i][k][p.first],dp[i-1][j][k]+p.second);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i,10001) rep(j,20) rep(k,20){\n\t\tif(dp[i][j][k] < d){\n\t\t\tans = max(ans,i);\n\t\t}\n\t}\n\tcout << ans-1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nPoint a[20];\n//j番目からきてi番目からk番目に行く\nld cost[20][20][20];\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\nld d[20][20][10000];\nstruct vertice { \n\tint x, y, t;\n\tbool operator<(const vertice &v) const {\n\t\tif (x!=v.x)return x < v.x;\n\t\tif (y != v.y)return y < v.y;\n\t\treturn t < v.t;\n\t}\n};\ntypedef pair<ld, vertice> speP;\nint main(){\n\tint n; cin >> n;\n\tld r, theta;\n\tcin >> r >> theta;\n\ttheta = theta * pi / 180.0;\n\trep(i, n) {\n\t\tld x, y; cin >> x >> y;\n\t\ta[i] = { x,y };\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\trep(k, n) {\n\t\t\t\tif (i == j || i == k) {\n\t\t\t\t\tcost[i][j][k] = 10010;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tld t = dot(a[i] - a[j], a[k] - a[i]);\n\t\t\t\t\tt /= abs(a[i] - a[j]);\n\t\t\t\t\tt /= abs(a[k] - a[i]);\n\t\t\t\t\tif (cos(theta) > t) {\n\t\t\t\t\t\tcost[i][j][k] = 10010;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcost[i][j][k] = abs(a[k] - a[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 20) {\n\t\trep(j, 20) {\n\t\t\trep(k, 10000) {\n\t\t\t\td[i][j][k] = 10000;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<speP, vector<speP>, greater<speP>> q;\n\trep(i, n) {\n\t\tif (i > 0) {\n\t\t\td[i][0][1] = abs(a[i] - a[0]);\n\t\t\tq.push(speP{ d[i][0][1],vertice{i,0,1} });\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tspeP nex = q.top(); q.pop();\n\t\tvertice v = nex.second;\n\t\tif (d[v.x][v.y][v.t]+eps < nex.first)continue;\n\t\trep(i, n) {\n\t\t\tld nd = nex.first + cost[v.x][v.y][i];\n\t\t\tif (nd + eps < d[i][v.x][v.t + 1]) {\n\t\t\t\td[i][v.x][v.t + 1] = nd;\n\t\t\t\tq.push({ nd,{i,v.x,v.t + 1} });\n\t\t\t}\n\t\t}\n\t}\n\tint out = 0;\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\trep(k, 10000) {\n\t\t\t\tif (d[i][j][k] + eps < r) {\n\t\t\t\t\tout = max(out, k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << out << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\n\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tdouble r,tmp;\n\tcin>>n>>r>>tmp;\n\tvd x(n),y(n);\n\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\tdouble cs=cos(tmp/180*pi);\n\tconst int M=10000;\n\tvector<vvd> dp(M,vvd(n,vd(n,inf)));\n\tfor(int i=1;i<n;i++) dp[1][0][i]=sqrt((x[i]-x[0])*(x[i]-x[0])+(y[i]-y[0])*(y[i]-y[0]));\n\tfor(int i=1;i<M-1;i++){\n\t\tbool B=0;\n\t\tfor(int j=0;j<n;j++) for(int k=0;k<n;k++) if(dp[i][j][k]<inf-eps){\n\t\t\tfor(int l=0;l<n;l++) if(l!=k){\n\t\t\t\tdouble x1=x[l]-x[k],y1=y[l]-y[k];\n\t\t\t\tdouble x2=x[k]-x[j],y2=y[k]-y[j];\n\t\t\t\tif((x1*x2+y1*y2)/sqrt(x1*x1+y1*y1)/sqrt(x2*x2+y2*y2)>cs){\n//\t\t\t\t\tcout<<j<<' '<<k<<' '<<l<<' '<<syosu(9)<<(x1*x2+y1*y2)/sqrt(x1*x1+y1*y1)/sqrt(x2*x2+y2*y2)<<' '<<cs<<endl;\n\t\t\t\t\tdp[i+1][k][l]=min(dp[i+1][k][l],dp[i][j][k]+sqrt(x1*x1+y1*y1));\n\t\t\t\t\tif(dp[i+1][k][l]<r) B=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!B) break;\n\t}\n\tint res=0;\n\tfor(int i=0;i<M;i++) for(int j=0;j<n;j++) for(int k=0;k<n;k++) if(dp[i][j][k]<r){\n//\t\tcout<<i<<' '<<j<<' '<<k<<' '<<dp[i][j][k]<<endl;\n\t\tres=i;\n\t}\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> dst = cities[city];\n\n  src -= cities[prev];\n  dst -= cities[prev];\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[3001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> Pi;\ntypedef pair<double,int> Pd;\ntypedef pair<Pd,Pi> S;\n\nint n;\ndouble r,d;\nP p[20];\ndouble dp[10001][20][20];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint cal(){\n  priority_queue<S,vector<S>,greater<S> > Q;\n  int ans=0;\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)dp[i][j][k]=1e9;\n  dp[0][0][0]=0;\n  Q.push(S(Pd(0,0),Pi(0,0)));\n  while(!Q.empty()){\n    double cs=Q.top().first.first;\n    int i=Q.top().first.second;\n    int j=Q.top().second.first;\n    int k=Q.top().second.second;\n    Q.pop();\n    if(dp[i][j][k]<cs)continue;\n    if(cs>r)return ans\n    dp[i][j][k]=1;\n    for(int l=0;l<n;l++){\n      double ncs=cs+abs(p[k]-p[l]);\n      if(check(j,k,l)&&ncs<=r){\n\tif(dp[i+1][k][l]>ncs){\n\t  Q.push(S(Pd(cs+abs(p[k]-p[l]),i+1),Pi(k,l)));\n\t  dp[i+1][k][l]=ncs;\n\t}\n      }\n    }\n    ans=max(ans,i);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n>>r>>d;\n  double a,b;\n  for(int i=0;i<n;i++)cin>>a>>b,p[i]=P(a,b);\n  cout<<cal()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(const deque<int>& deq,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[deq[0]];\n  complex<double> mid = cities[deq[1]];\n  complex<double> dst = cities[deq[2]];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _c,double _r,const deque<int>& _d) :\n    city(_ct), carrots(_c), remaining_distance(_r),deq(_d) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    deq.push_back(_d);\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,false,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      int prev = 20;\n      if(s.deq.size() > 1) prev = *(s.deq.end()-2);\n\n      if(dp[s.carrots][prev][s.city]) continue;\n      dp[s.carrots][prev][s.city] = true;\n\n      deque<int> deq;\n      while(s.deq.size() > 2) s.deq.pop_front();\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\t\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tdeq = s.deq;\n\tdeq.push_back(to);\n\n\tif(deq.size()==3){\n\t  if(!check(deq,limit_rad,cities)) continue;\n\t}\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tque.push(State(to,s.carrots+1,s.remaining_distance - dist,deq));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n#include<climits>\n \n#define debug(x) cerr << #x << \": \" << x << endl\n#define EPS 1e-5\n \nusing namespace std;\n \nclass Vector {\n    public:\n    double x,y;\n    Vector(double x, double y): x(x), y(y) {}\n    double norm() const { return x*x + y*y; }\n    double dot(Vector p) const { return x*p.x + y*p.y; }\n};\n \nint main(){\n    int n;\n    double r, theta;\n    cin >> n;\n    cin >> r >> theta;\n    theta = theta/180.0*M_PI;\n    pair<double, double> cities[n];\n    for(int i=0;i<n;i++){\n        cin >> cities[i].first >> cities[i].second;\n    }\n \n    bool ok[n][n][n];\n    double dist[n][n];\n    fill(ok[0][0], ok[n-1][n], false);\n    fill(dist[0], dist[n], -1.0);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(i == j) continue;\n            Vector v = Vector(\n                    cities[j].first - cities[i].first,\n                    cities[j].second - cities[i].second\n                );\n            for(int k=0;k<n;k++){\n                if(j == k) continue;\n                Vector u = Vector(\n                        cities[k].first - cities[j].first,\n                        cities[k].second - cities[j].second\n                    );\n                double theta_ = acos(u.dot(v) / sqrt(v.norm() * u.norm()));\n                dist[j][k] = sqrt(u.norm());\n                if(theta-theta_ > EPS){\n                    ok[i][j][k] = true;\n                }\n            }\n        }\n    }\n\n    double dp[2][n][n];\n    int ans = 0;\n    fill(dp[0][0], dp[0][n], -1.0);\n    for(int j=0;j<n;j++){\n        if(dist[0][j] > EPS) dp[0][0][j] = dist[0][j];\n    }\n    bool flag = true;\n    int i = 0;\n    while(flag){\n        flag = false;\n        fill(dp[1-(i&1)][0], dp[1-(i&1)][n], 200000.0);\n        for(int j=0;j<n;j++){\n            for(int k=0;k<n;k++){\n                if(j == k || dp[i&1][j][k] - r > EPS) continue;\n                flag = true;\n                for(int l=0;l<n;l++){\n                    if(k == l) continue;\n                    if(ok[j][k][l]){\n                        dp[1-(i&1)][k][l] = min(dp[1-(i&1)][k][l], dp[i&1][j][k] + dist[k][l]);\n                    } \n                }\n            }\n        }\n        i++;\n    }\n \n    cout << i-1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\n#define pow2(a) (pow(1.*a,2))\ntypedef struct D\n{\n\tint c,pp,np;\n\tdouble d;\n\tbool operator <(const D &a)const{ return d>a.d;};\n}D;\n\nint N,X[25],Y[25],res=0;\ndouble R,O,d[25][25],F[30][30][10010];\ndouble ang(int pre,int now,int next)\n{\n\tdouble a=d[pre][now],b=d[now][next],c=d[pre][next];\n\tdouble dd=acos((pow2(a)+pow2(b)-pow2(c))/(2*a*b));\n\tdouble df=180-(dd*180/3.141592);\n\treturn df;\n}\n\nint main()\n{\n\tscanf(\"%d%lf%lf\",&N,&R,&O);\n\tfor(int i=0;i<30;i++)for(int k=0;k<30;k++)for(int j=0;j<1000000;j++)F[i][k][j]=1e14;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",X+i,Y+i);\n\tfor(int i=0;i<N;i++)\n\n\t\tfor(int j=0;j<N;j++)\n\t\t\td[i][j]=sqrt(pow2(X[i]-X[j])+pow2(Y[i]-Y[j]));\n\tpriority_queue<D>Q;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tif(d[0][i]>R)continue;\n\t\tD tmp={1,0,i,d[0][i]};\n\t\tF[0][i][1]=d[0][i];\n\t\tQ.push(tmp);\n\t}\n\tfor(;!Q.empty();)\n\t{\n\t\tD tmp=Q.top();Q.pop();\n\t\tif(F[tmp.pp][tmp.np][tmp.c]<tmp.d)continue;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(i==tmp.np)continue;\n\t\t\tif(ang(tmp.pp,tmp.np,i)<=O&&tmp.d+d[tmp.np][i]<=R)\n\t\t\t{\n\t\t\t\tD ins={tmp.c+1,tmp.np,i,tmp.d+d[tmp.np][i]};\n\t\t\t\tif(F[ins.pp][ins.np][ins.c]>ins.d)\n\t\t\t\t{\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t\tF[ins.pp][ins.np][ins.c]=ins.d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\n\nint n;\ndouble r,d;\nP p[20];\ndouble dp[10001][20][20];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint main(){\n  cin>>n>>r>>d;\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)dp[i][j][k]=1e9;\n  dp[0][0][0]=0;\n\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tfor(int l=0;l<n;l++)\n\t  if(check(j,k,l))\n\t    dp[i+1][k][l]=min(dp[i+1][k][l],dp[i][j][k]+abs(p[k]-p[l]));\n\n  int ans=0;\n  for(int i=1;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tif(dp[i][j][k]<=r)ans=i;\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct point{\n  double x,y;\n};\n\ndouble INF = 1e9;\ndouble PI = acos(-1);\ndouble EPS = (1e-10);\ndouble dp[10001][20][20];\nint n;\ndouble Ti;\ndouble r,ti;\npoint t[20];\n\n\nvoid solve(int i,int j,int k){\n  for(int to=0;to<n;to++){\n    if(to==j||(Ti!=180&&to==k))continue;\n    double vax=t[to].x-t[j].x;\n    double vay=t[to].y-t[j].y;\n    double vbx=t[j].x-t[k].x;\n    double vby=t[j].y-t[k].y;\n    double ar=(vax*vbx+vay*vby)/(sqrt(vax*vax+vay*vay)*sqrt(vbx*vbx+vby*vby));\n    ar=acos(ar);\n    if(ar<ti){\n      dp[i+1][to][j]=min(dp[i+1][to][j],dp[i][j][k]+sqrt(vax*vax+vay*vay));\n    }\n  }\n}\n\nint main(){\n\n  for(int i=0;i<10001;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<20;k++)\n\tdp[i][j][k]=INF;\n  \n  cin>>n>>r>>Ti;\n  ti=Ti/360.0*2.0*PI;\n\n  for(int i=0;i<n;i++)\n    cin>>t[i].x>>t[i].y;\n  \n  for(int i=1;i<n;i++){\n    double x=t[i].x-t[0].x;\n    double y=t[i].y-t[0].y;\n    dp[1][i][0]=sqrt(x*x+y*y);\n  }\n\n  int ans=-1;\n  for(int i=1;i<=10000;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(dp[i][j][k]>r+EPS)continue;\n\tans=max(ans,i);\n\tsolve(i,j,k);\n      }\n    }\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> mid = cities[prev];\n  complex<double> dst = cities[city];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[3001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> dst = cities[city];\n\n  src -= cities[prev];\n  dst -= cities[prev];\n  double computed_arg = abs(arg(src) - arg(dst));\n\n  return (limit_rad >= M_PI - min(computed_arg,\n\t\t\t\t  abs(2.0*M_PI - computed_arg)) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\nbool isok[21][21][21]; //cur,prev,old\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    memset(isok,true,sizeof(isok));\n    for(int old = 0; old < total_cities; old++){\n      for(int prev = 0; prev < total_cities; prev++){\n\tfor(int cur = 0; cur < total_cities; cur++){\n\t  isok[cur][prev][old] = check(cur,prev,old,limit_rad,cities);\n\t}\n      }\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(!isok[next_city][next_prev][next_old]) continue;\n\tif(dp[s.carrots+1][s.city][to] >= s.remaining_distance - dist - EPS) continue;\n\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nconst int MOD = 1000000007;\n\ntemplate <typename T>\nvoid __dump__(std::ostream &os, const T &first) {\n    os << first;\n}\ntemplate <typename First, typename... Rest>\nvoid __dump__(std::ostream &os, const First &first, const Rest &... rest) {\n    os << first << \", \";\n    __dump__(os, rest...);\n}\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __dump__(os, __VA_ARGS__);                        \\\n        std::cerr << os.str() << std::endl;               \\\n    } while (0)\n\nusing P = complex<double>;\nP ps[21];\n\nconst double EPS = 1e-9;\nconst double INF = 1e9;\nvector<int> go[21][21];\ndouble dp[10001][21][21];\ndouble d[21][21];\n\nint main() {\n    int n;\n    double r, th;\n    cin >> n >> r >> th;\n    th = r*acos(-1)/180;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        ps[i] = P(x, y);\n    }\n    rep(i, n) rep(j, n) {\n        if (i == j) continue;\n        go[i][j].clear();\n        rep(k, n) {\n            if (j == k) continue;\n            double phi = arg((ps[k] - ps[j]) / (ps[j] - ps[i]));\n            if (abs(phi) < th + EPS) {\n                go[i][j].push_back(k);\n                //dump(i, j, k);\n            }\n        }\n        d[i][j] = abs(ps[i] - ps[j]);\n    }\n    rep(i, 10001) rep(j, 21) rep(k, 21) dp[i][j][k] = INF;\n    rep(i, n) if (d[0][i] <= r + EPS) dp[1][0][i] = d[0][i];\n    FOR(i, 1, 10001) {\n        rep(j, n) rep(k, n) {\n            if (dp[i][j][k] == INF) continue;\n            for (auto &l : go[j][k]) {\n                dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + d[k][l]);\n            }\n        }\n    }\n    double ans = INF;\n    rrep(i, 10001) rep(j, n) rep(k, n) {\n        if (dp[i][j][k] <= r + EPS) {\n            ans = i;\n            goto END;\n        }\n    }\n END:;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\n#define pow2(a) (pow(1.*a,2))\ntypedef struct D\n{\n\tint c,pp,np;\n\tdouble d;\n\tbool operator <(const D &a)const{ return d>a.d;};\n}D;\n\nint N,X[25],Y[25],res=0,g[25][25][25];\ndouble R,O,d[25][25],F[30][30][10010];\ndouble ang(int pre,int now,int next)\n{\n\tdouble a=d[pre][now],b=d[now][next],c=d[pre][next];\n\tdouble dd=acos((pow2(a)+pow2(b)-pow2(c))/(2*a*b));\n\tdouble df=180-(dd*180/3.141592);\n\treturn df;\n}\n\nint main()\n{\n\tscanf(\"%d%lf%lf\",&N,&R,&O);\n\tmemset(g,0,sizeof(g));\n\tfor(int i=0;i<30;i++)for(int k=0;k<30;k++)for(int j=0;j<10010;j++)F[i][k][j]=1e14;\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",X+i,Y+i);\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\td[i][j]=sqrt(pow2(X[i]-X[j])+pow2(Y[i]-Y[j]));\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\tfor(int k=0;k<N;k++)\n\t\t\t\tif(ang(i,j,k)<O)\n\t\t\t\t\tg[i][j][k]=1;\n\tpriority_queue<D>Q;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tif(d[0][i]>R)continue;\n\t\tD tmp={1,0,i,d[0][i]};\n\t\tF[0][i][1]=d[0][i];\n\t\tQ.push(tmp);\n\t}\n\tfor(;!Q.empty();)\n\t{\n\t\tD tmp=Q.top();Q.pop();\n\t\tres=max(tmp.c,res);\n\t\tif(F[tmp.pp][tmp.np][tmp.c]-tmp.d>0.001)\n\t\t\tcontinue;\n\t\tF[tmp.pp][tmp.np][tmp.c]=tmp.d;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(i==tmp.np)continue;\n\t\t\tif(g[tmp.pp][tmp.np][i]&&tmp.d+d[tmp.np][i]<=R)\n\t\t\t{\n\t\t\t\tD ins={tmp.c+1,tmp.np,i,tmp.d+d[tmp.np][i]};\n\t\t\t\tif(F[ins.pp][ins.np][ins.c]-ins.d>0.001)\n\t\t\t\t{\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t\tF[ins.pp][ins.np][ins.c]=ins.d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\ntypedef complex<double> Point;\n\ndouble angle(const Point& v1, const Point& v2) {\n    double res = arg(v1 / v2);\n    if (res < 0) res += 2*pi;\n    return min(2*pi-res, res);\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n; cin >> n;\n    double R, th; cin >> R >> th; th *= pi / 180;\n    vector<Point> v(n);\n    REP(i, n) {\n        ll x, y; cin >> x >> y;\n        v[i] = Point(x, y);\n    }\n    vector<vector<vector<bool>>> G(n, vector<vector<bool>>(n, vector<bool>(n, false)));\n    REP(i, n) REP(j, n) REP(k, n) {\n        if (i == j || j == k || k == i) continue;\n        // i -> j -> k ??¨????????????\n        Point v1 = v[j] - v[i];\n        Point v2 = v[k] - v[j];\n        if (angle(v1, v2) <= th+eps) {\n            G[i][j][k] = true;\n        }\n    }\n    vector<vector<double>> dist(n, vector<double>(n));\n    REP(i, n) REP(j, n) dist[i][j] = abs(v[i]-v[j]);\n    ll ans = 0;\n    vector<vector<vector<double>>> dp(2, vector<vector<double>>(n, vector<double>(n, linf)));\n    dp[0][0][0] = 0;\n    REP(t, 10010) {\n        dp[t+1&1].assign(n, vector<double>(n, linf));\n        REP(prev, n) REP(now, n) {\n            double l = dp[t&1][prev][now];\n            if (l > R+eps) continue;\n            ans = max(ans, t);\n            REP(to, n) {\n                if (prev != now && !G[prev][now][to]) continue;\n                if (now == to) continue;\n                dp[t+1&1][now][to] = min(dp[t+1&1][now][to], l + dist[now][to]);\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 200\n#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 200\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nint V;\ndouble r, theta, E_sz[500];\n\n// A*B の計算\nmat mul(mat &A, mat &B){\n\tmat C(A.size(), vec(B[0].size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tfor(int j = 0; j < B[0].size(); j++){\n\t\t\tdouble mini = INF;\n\t\t\tfor(int k = 0; k < B.size(); k++){\n\t\t\t\tmini = min(mini, A[i][k] + B[k][j]);\n\t\t\t}\n\t\t\tC[i][j] = mini;\n\t\t}\n\t}\n\treturn C;\n}\n\n// A^n の計算\nint mat_pow(mat A){\n\tmat B(A.size(), vec(A.size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tB[i][i] = 1;\n\t}\n\tint num = 0;\n\twhile(true){\n\t\tB = mul(B, A);\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < V * V; i++){\n\t\t\tfor(int j = 0; j < V * V; j++){\n\t\t\t\tif(B[i][j] + E_sz[i] < r){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\n\treturn num;\n}\n\nint main(){\n\t\n\tcin >> V;\n\t\n\tcin >> r >> theta;\n\t\n\ttheta = theta * M_PI / 180;\n\t\n\tmat S(V * V, vec(V * V));\n\t\n\tdouble x[30], y[30];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i = 0; i < V * V; i++){\n\t\tE_sz[i] = INF;\n\t\tfor(int j = 0; j < V * V; j++){\n\t\t\tS[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tif(i == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble vx1, vx2, vy1, vy2;\n\t\t\tvx1 = x[j] - x[i];\n\t\t\tvy1 = y[j] - y[i];\n\t\t\tdouble norm1 = sqrt(vx1 * vx1 + vy1 * vy1);\n\t\t\tE_sz[i * V + j] = norm1;\n\t\t\t\n\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\tif(j == k || k == i){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvx2 = x[k] - x[j];\n\t\t\t\tvy2 = y[k] - y[j];\n\t\t\t\tdouble inn = vx1 * vx2 + vy1 * vy2;\n\t\t\t\tdouble norm2 = sqrt(vx2 * vx2 + vy2 * vy2);\n\t\t\t\tdouble th = acos(inn * inn / norm1 / norm2);\n\t\t\t\tif(M_PI - th < theta){\n\t\t\t\t\tS[i * V + j][j * V + k] = norm2;\n\t\t\t\t\t//S[j * V + i][k * V + j] = norm2;\n\t\t\t\t\t//S[j * V + k][i * V + j] = norm1;\n\t\t\t\t\tS[k * V + j][j * V + i] = norm1;\n\t\t\t\t\t//cout << i * V + j << \" \" << j * V + k << \" \" << norm2 << endl;\n\t\t\t\t\t//cout << k * V + j << \" \" << j * V + i << \" \" << norm1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool flag = true;\n\tfor(int i = 0; i < V * V; i++){\n\t\tif(E_sz[i] < r){\n\t\t\tflag = false;\n\t\t}\n\t}\n\t\n\tif(flag){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << mat_pow(S) + 1 << endl;\n\t\n\treturn 0;\n}\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nint V;\ndouble r, theta, E_sz[500];\n\n// A*B の計算\nmat mul(mat &A, mat &B){\n\tmat C(A.size(), vec(B[0].size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tfor(int j = 0; j < B[0].size(); j++){\n\t\t\tdouble mini = INF;\n\t\t\tfor(int k = 0; k < B.size(); k++){\n\t\t\t\tmini = min(mini, A[i][k] + B[k][j]);\n\t\t\t}\n\t\t\tC[i][j] = mini;\n\t\t}\n\t}\n\treturn C;\n}\n\n// A^n の計算\nint mat_pow(mat A){\n\tmat B(A.size(), vec(A.size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tB[i][i] = 1;\n\t}\n\tint num = 0;\n\twhile(true){\n\t\tB = mul(B, A);\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < V * V; i++){\n\t\t\tfor(int j = 0; j < V * V; j++){\n\t\t\t\tif(B[i][j] + E_sz[i] < r){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\n\treturn num;\n}\n\nint main(){\n\t\n\tcin >> V;\n\t\n\tcin >> r >> theta;\n\t\n\ttheta = theta * M_PI / 180;\n\t\n\tmat S(V * V, vec(V * V));\n\t\n\tdouble x[30], y[30];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i = 0; i < V * V; i++){\n\t\tE_sz[i] = INF;\n\t\tfor(int j = 0; j < V * V; j++){\n\t\t\tS[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\tif(i == j || j == k || k == i){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble vx1, vx2, vy1, vy2;\n\t\t\t\tvx1 = x[j] - x[i];\n\t\t\t\tvy1 = y[j] - y[i];\n\t\t\t\tvx2 = x[k] - x[j];\n\t\t\t\tvy2 = y[k] - y[j];\n\t\t\t\tdouble inn = vx1 * vx2 + vy1 * vy2;\n\t\t\t\tdouble norm1 = sqrt(vx1 * vx1 + vy1 * vy1);\n\t\t\t\tdouble norm2 = sqrt(vx2 * vx2 + vy2 * vy2);\n\t\t\t\tE_sz[i * V + j] = norm1;\n\t\t\t\tE_sz[k * V + j] = norm2;\n\t\t\t\tdouble th = acos(inn * inn / norm1 / norm2);\n\t\t\t\tif(M_PI - th < theta){\n\t\t\t\t\tS[i * V + j][j * V + k] = norm2;\n\t\t\t\t\t//S[j * V + i][k * V + j] = norm2;\n\t\t\t\t\t//S[j * V + k][i * V + j] = norm1;\n\t\t\t\t\tS[k * V + j][j * V + i] = norm1;\n\t\t\t\t\t//cout << i * V + j << \" \" << j * V + k << \" \" << norm2 << endl;\n\t\t\t\t\t//cout << k * V + j << \" \" << j * V + i << \" \" << norm1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool flag = true;\n\tfor(int i = 0; i < V * V; i++){\n\t\tif(E_sz[i] < r){\n\t\t\tflag = false;\n\t\t}\n\t}\n\t\n\tif(flag){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << mat_pow(S) + 1 << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\ndouble dp[20][20][10000]={};\n\n#include <complex>\ntypedef complex<double> P;\ndouble angle(P a, P b, P c)\n{\n   return arg((c-b)/(b-a));\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tdouble r,theta;\n\tcin>>r>>theta;\n\tdouble radian_theta=theta*PI/180;\n\tvector<P> coords(n);\n\tREP(i,n){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tcoords[i]=P(x,y);\n\t}\n\tREP(i,20)REP(j,20)REP(k,10000){\n\t\tdp[i][j][k]=9999999;\n\t}\n\tdp[0][0][0]=0;\n\tvector<vector<double> > dist(n,vector<double>(n));\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tdist[i][j]=abs(coords[i]-coords[j]);\n\t\t}\n\t}\n\tvector<vvi> isDirOk(n,vvi(n,vi(n)));\n\tREP(i,n){\n\t\tisDirOk[0][0][i]=1;\n\t}\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tREP(k,n){\n\t\t\t\tif(i==j||j==k){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble a=angle(coords[i],coords[j],coords[k]);\n\t\t\t\tisDirOk[i][j][k]=(abs(a)<radian_theta+EPS);\n\t\t\t}\t\t\n\t\t}\n\t}\n\tint ans=0;\n\tREP(carrot,10000){\n\t\tREP(cur,n){\n\t\t\tREP(prev,n){\n\t\t\t\tREP(next,n){\n\t\t\t\t\tif(cur==next)continue;\n\t\t\t\t\tif(isDirOk[prev][cur][next]&&dp[cur][prev][carrot]+dist[cur][next]<r){\n\t\t\t\t\t\tdp[next][cur][carrot+1]=min(dp[next][cur][carrot+1],dp[cur][prev][carrot]+dist[cur][next]);\n\t\t\t\t\t\tans=max(ans,carrot+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\n// distance between (x1,y1) and (x2,y2)\ndouble cdis(double x1, double y1, double x2, double y2) {\n  return sqrtl((x1 - x2) * (x1 - x2) +\n               (y1 - y2) * (y1 - y2));\n}\n// cos a\ndouble costh(double a, double b, double c) {\n  return (b * b + c * c - a * a) / (2.0 * b * c);\n}\ndouble r, t;\nint n;\npair<double, double> c[25];\ndouble dis[25][25] = {0};\n// possible? i -> j -> k\nbool ch[25][25][25] = {0};\ndouble dp[25][25][10000] = {0};\n\nint solve();\n\nint main() {\n  cin >> n >> r >> t;\n  for(int i = 0; i < n; ++i) {\n    double x, y;\n    cin >> x >> y;\n    c[i] = make_pair(x, y);\n  }\n  for(int i = 0; i < n; ++i)\n    for(int j = i + 1; j < n; ++j)\n      dis[i][j] = dis[j][i] =\n          cdis(c[i].fi, c[i].se, c[j].fi, c[j].se);\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j)\n      for(int k = 0; k < n; ++k) {\n        if(i == j || j == k) continue;\n        double a = dis[i][k], b = dis[i][j], c = dis[j][k];\n        if(180.0 - acos(costh(a, b, c)) * 180 / M_PI <= r &&\n           fabs(c - a + b) > 0.001 &&\n           fabs(b - a + c) > 0.001)\n          ch[i][j][k] = 1;\n      }\n\n  cout << solve() << endl;\n  return 0;\n}\n\nint solve() {\n  int ans = 0;\n  for(int i = 1; i < n; ++i)\n    if(dis[0][i] <= r) {\n      dp[0][i][1] = dis[0][i];\n      ans = 1;\n    }\n  if(ans == 0) return ans;\n  for(int k = 2; k <= 10000; ++k) {\n    // i -> j -> l\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < n; ++j)\n        for(int l = 0; l < n; ++l) {\n          if(i == j || j == l || (!ch[i][j][l]) ||\n             dp[i][j][k - 1] == 0 ||\n             dp[i][j][k - 1] + dis[j][l] > r)\n            continue;\n          if(dp[j][l][k] == 0) {\n            ans = k;\n            dp[j][l][k] = dp[i][j][k - 1] + dis[j][l];\n          }\n          else\n            dp[j][l][k] = min(dp[j][l][k],\n                              dp[i][j][k - 1] + dis[j][l]);\n        }\n    if(ans != k) break;\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\ntypedef complex<double> P;\n\ndouble dif(P a,P b,P c){\n    a=b-a;\n    c-=b;\n    double ret=fabs(arg(c)-arg(a));\n    if(ret>=asin(1)*2){ret=asin(1)*4-ret;}\n    return ret;\n}\n\ndouble dist(P a,P b){\n    return abs(a-b);\n}\n\n\nint main(){\n    ll n;\n    double r,s;\n    cin>>n>>r>>s;\n    s*=asin(1)/90;\n    ll mx=10003;\n    vector<vector<vector<double>>> dp(mx,vector<vector<double>>(n,vector<double>(n,E)));\n    vector<P> a(n);\n    for(auto &i:a){\n        double x,y;\n        cin>>x>>y;\n        i={x,y};\n    }\n    ll ans=0;\n    vector<vector<vector<double>>> edge(n,vector<vector<double>>(n,vector<double>(n,E)));\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                if(i==h || t==h || i==t || dif(a[i],a[t],a[h])>s){continue;}\n                edge[i][t][h]=dist(a[t],a[i]);\n            }\n        }\n    }\n    for(int i=1;i<n;i++){\n        dp[1][i][0]=dist(a[i],a[0]);\n        if(dp[1][i][0]<=r){ans=1;}\n    }\n    for(int i=1;ans==i;i++){\n        for(int t=0;t<n;t++){\n            for(int h=0;h<n;h++){\n                if(t==h || dp[i][t][h]>r){continue;}\n                //cout<<i<<\" \"<<t<<\" \"<<h<<\" \"<<dp[i][t][h]<<endl;\n                for(int k=0;k<n;k++){\n                    //if(k==h || k==t || dif(a[k],a[t],a[h])>s){continue;}\n                    dp[i+1][k][t]=min(dp[i+1][k][t],dp[i][t][h]+edge[k][t][h]);\n                    if(dp[i+1][k][t]<=r){ans=i+1;}\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (lt(a, b) || equals(a, b))\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\ndouble getAngle(Point a, Point b, Point c)\n{\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\n\n\nint n;\ndouble r, t;\nvector<Point> ps;\n\ndouble d[21][21][10001];\n\nint solve()\n{\n  rep(i, 21) rep(j, 21) rep(k, 10001) d[i][j][k] = -1;\n  queue< tuple<int, int, int> > que;\n  reps(i, 1, n) {\n    int dist = getDistance(ps[0], ps[i]);\n    if(le(dist, r)) {\n      d[i][0][1] = dist;\n      que.emplace(i, 0, 1);\n    }\n  }\n\n  int ans = 0;\n  while(!que.empty()) {\n    int now, prev, car;\n    tie(now, prev, car) = que.front(); que.pop();\n    ans = max(ans, car);\n    rep(i, n) if(i != now) {\n      int dist = d[now][prev][car] + getDistance(ps[now], ps[i]);\n      if(le(getAngle(ps[prev], ps[now], ps[i]), t) && le(dist, r) && d[i][now][car+1] == -1) {\n\td[i][now][car+1] = dist;\n\tque.emplace(i, now, car+1);\n      }\n    }\n  }\n\n  return ans;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> n >> r >> t;\n  ps.resize(n);\n  rep(i, n) cin >> ps[i].x >> ps[i].y;\n\n  cout << solve() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef double R;\ntypedef complex<R> P;\nconst R PI = 3.1415926535897932384626;\n\nistream& operator>>(istream &is, P &p) {\n\tR x, y;\n\tis >> x >> y;\n\tp = P(x, y);\n\treturn is;\n}\n\nint n;\ndouble r, theta;\n\ndouble visited[401][10005];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> r >> theta; theta = theta/180.*PI;\n\tcout << r << endl;\n\tvector<P> p(n);\n\tREP(i, n) cin >> p[i];\n\tvector<vector<pair<int, double>>> g(n*n);\n\tREP(i, n)REP(j, n)REP(k, n){\n\t\tif(i==k || i==j || j==k) continue;\n\t\tif(abs(arg((p[j]-p[i]) / (p[k]-p[j]))) < theta) g[j*n+i].emplace_back(k*n+j, abs(p[k]-p[j]));\n\t}\n\tstruct State{\n\t\tint x, c;\n\t\tdouble cost;\n\t\tState(int x, int c, double cost)\n\t\t\t:x(x), c(c), cost(cost){}\n\t\tbool operator<(const State &opp) const{\n\t\t\treturn cost < opp.cost;\n\t\t}\n\t};\n\tpriority_queue<State> que;\n\tREP(i, n)REP(j, n)if(i!=j){\n\t\tif(abs(p[i]-p[j]) < r){\n\t\t\tque.emplace(j*n+i, 1, abs(p[i]-p[j]));\n\t\t\tvisited[j*n+i][1] = abs(p[i]-p[j]);\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(!que.empty()){\n\t\tState s = que.top(); que.pop();\n\t\tif(s.cost > visited[s.x][s.c]) continue;\n\t\tans = max(ans, s.c);\n\t\tFOR(it, g[s.x]){\n\t\t\tint x = it->first;\n\t\t\tdouble cost = s.cost + it->second;\n\t\t\tint c = s.c + 1;\n\t\t\tauto &t = visited[x][c];\n\t\t\tif((t == 0 || t > cost) && cost < r){\n\t\t\t\tt = cost;\n\t\t\t\tque.emplace(x, c, cost);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\nusing namespace std;\ntypedef long long LL;\n\n#define _CRT_SECURE_NO_WARNINGS\nint N;\nfloat r, t;\nint x[21], y[21];\n\nfloat dp[21][21][10010] = {};\nfloat Distance(int n, int m) {\n\treturn sqrtf( (x[n] - x[m])*(x[n] - x[m])+(y[n] - y[m])*(y[n] - y[m]) );\n}\nbool TurnAble(int a, int b,int c) {\n\tfloat d = acosf( ((x[b] - x[a])*(x[c] - x[b]) + (y[b] - y[a])*(y[c] - y[b])) / (Distance(a, b)*Distance(b, c)) );\n\treturn d < (t/180.0000 * 3.141592) ;\n}\nint main() {\n\tint ans = 0;\n\tscanf(\"%d\", &N);\n\tscanf(\"%f %f\", &r, &t);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tfor (int k = 0; k <= r;k++) {\n\t\t\t\tdp[i][j][k] = r + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tfor (int i = 0; i < N;i++) {\n\t\tscanf(\"%d %d\",x+i,y+i);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i != 0) {\n\t\t\tdp[0][i][1] = Distance(0, i);\n\t\t\tif (dp[0][i][1] <= r) {\n\t\t\t\tans = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (ans == 0) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor (int k = 2; k <= r; k++) {\n\t\tfor (int now = 0; now < N;now++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (j != now) {\n\t\t\t\t\tif (dp[j][now][k - 1] <= r) {\n\t\t\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\t\t\tif (i != now && i!=j) {\n\t\t\t\t\t\t\t\tif (TurnAble(j, now, i)) {\n\t\t\t\t\t\t\t\t\tdp[now][i][k] = min(dp[j][now][k - 1] + Distance(now, i), dp[now][i][k]);\n\t\t\t\t\t\t\t\t\tif (dp[now][i][k]<=r) {\n\t\t\t\t\t\t\t\t\t\tans = max(ans, k);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int MAX = 20,LIMIT = 20000,IINF = INT_MAX;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nstruct Edge{\n  int to;\n  double weight;\n  Edge(int to=0,double weight=0):to(to),weight(weight){}\n};\n\nstruct Data{\n  int prev,cur,carrot;\n  double dist;\n  Data(int prev=0,int cur=0,int carrot=0,double dist=0):prev(prev),cur(cur),carrot(carrot),dist(dist){}\n  bool operator < (const Data& data) const{ return dist > data.dist; }\n};\n\nint n;\ndouble r,theta,mindist[MAX][MAX][LIMIT]; // mindist[cur][prev][the number of carrot]\nPoint ps[MAX];\nvector<Edge> edge[MAX][MAX]; // edge[cur][prev]\n\ninline void dijkstra(){\n  rep(i,n)rep(j,n)rep(k,LIMIT) mindist[i][j][k] = IINF;\n  priority_queue<Data> Q;\n\n  REP(i,1,n) {\n    double dist = abs(ps[0]-ps[i]);\n    if( !equals(dist,r) && dist > r ) continue;\n    Q.push(Data(0,i,1,dist));\n    mindist[i][0][1] = dist;\n  }\n  int ans = (Q.empty()?0:1);\n\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n    int prev = data.prev, cur = data.cur, carrot = data.carrot;\n    double dist = data.dist;\n\n    if( !equals(mindist[cur][prev][carrot],dist) && mindist[cur][prev][carrot] < dist ) continue;\n\n    rep(i,edge[cur][prev].size()) {\n      int next = edge[cur][prev][i].to;\n      double weight = edge[cur][prev][i].weight;\n      if( !equals(r,dist+weight) && r < dist+weight ) continue;\n      if( mindist[next][cur][carrot+1] > dist + weight ){\n        mindist[next][cur][carrot+1] = dist + weight;\n        assert(carrot+1 < LIMIT);\n        ans = max(ans,carrot+1);\n        Q.push(Data(cur,next,carrot+1,dist+weight));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\ninline void makeEdge(){\n  rep(prev,n){\n    rep(cur,n){\n      if( cur == prev ) continue;\n      rep(next,n){\n        if( next == cur || next == prev ) continue;\n        double dist = abs(ps[cur]-ps[next]);\n        if( !equals(dist,r) && dist > r ) continue;\n        Vector v1 = ps[next] - ps[cur];\n        Vector v2 = ps[cur]  - ps[prev];\n        if( equals(cross(v1,v2),0.0) ) continue;\n        double arg = getArg(ps[prev],ps[cur],ps[next]);\n        if( equals(arg,theta) || arg < theta ) edge[cur][prev].push_back(Edge(next,dist));\n      }\n    }\n  }\n}\n\nint main(){\n\n  /*\n  int next = 2, cur = 1, prev = 0;\n  ps[0] = Point(0,0);\n  ps[1] = Point(10,0);\n  ps[2] = Point(0,1);\n  double arg =  getArg(ps[prev],ps[cur],ps[next]);\n  cout << \"arg = \" << arg * 180.0 / M_PI << endl;\n  */\n\n  cin >> n;\n  cin >> r >> theta;\n  theta = toRad(theta);\n  rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n\n  makeEdge();\n\n  dijkstra();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define p(s) cout<<(s)<<endl;\nusing namespace std;\n\nconst int ctinf=1e5;\ndouble dp[10000][21][21];//num,prev,now = minr\n\ndouble vec_len(int x1,int x2,int y1,int y2){\n\treturn sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n}\n\nint dot_pro(int x1,int x2,int x3,int y1, int y2, int y3){\n\treturn (x2-x1)*(x3-x2)+(y2-y1)*(y3-y2);\n}\n\ndouble ctcos(int x1,int x2,int x3,int y1,int y2,int y3){\n\treturn dot_pro(x1,x2,x3,y1,y2,y3)/(vec_len(x1,x2,y1,y2)*vec_len(x1,x3,y1,y3));\n}\nint main(){\n\tint n;\n\tdouble r,theta;\n\tcin>>n>>r>>theta;\n\tREP(i,0,r) REP(j,0,21) REP(k,0,21) dp[i][j][k]=ctinf;\n\tdouble co=cos(theta);\n\tint x[20],y[20];\n\tREP(i,0,n) cin>>x[i]>>y[i];\n\tint ans=0;\n\tREP(i,1,n) if(vec_len(x[0],x[i],y[0],y[i])<r){\n\t\tdp[1][0][i]=vec_len(x[0],x[i],y[0],y[i]);\n\t\tans=1;\n\t}\n\t//int from,to;\n\n\tREP(i,2,r){\n\t\tREP(prev,0,n){\n\t\t\tREP(now,0,n){\n\t\t\t\tREP(next,0,n){\n\t\t\t\t\tif(prev==now||prev==next||now==next) continue;\n\t\t\t\t\tif(ctcos(x[prev],x[now],x[next],y[prev],y[now],y[next])<co)continue;\n\t\t\t\t\tif(dp[i-1][prev][now]+vec_len(x[now],x[next],y[now],y[next])<=r){\n\t\t\t\t\t\tdp[i][now][next]=min(dp[i][now][next],dp[i-1][prev][now]+vec_len(x[now],x[next],y[now],y[next]));\n\t\t\t\t\t\tans=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tp(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#define scanf_s scanf\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\n\nint main(void){\n\tint n,ans,i,j,k,ok;\n\tdouble r,sit;\n\tdouble x[20];\n\tdouble y[20];\n\tdouble dp[20][20]={0};//x??????y????????????\n\tdouble dpc[20][20]={0};\n\tdouble d;\n\tdouble pi=3.141592653589793238462643383279502884197;\n\tscanf(\"%d\",&n);\n\tscanf(\"%lf %lf\",&r,&sit);\n\tsit=(sit/180)*pi;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i][j]=0;\n\t\t\tdpc[i][j]=big;\n\t\t}\n\t}\n\tfor(ans=0;;ans++){\n\t\tfor(k=0;k<n;k++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(ans!=0&&(k-i)*(i-j)*(j-k)==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td=abs(atan2(y[i]-y[k],x[i]-x[k])-atan2(y[k]-y[j],x[k]-x[j]));\n\t\t\t\t\tif(ans!=0&&min(2*pi-d,d)>sit){continue;}\n\t\t\t\t\tdpc[k][j]=min(dpc[k][j],dp[i][k]+hypot(x[k]-x[j],y[k]-y[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tdp[i][j]=dpc[i][j];\n\t\t\t\tif(dpc[i][j]<r){\n\t\t\t\t\tok=1;\n\t\t\t\t}\n\t\t\t\tdpc[i][j]=big;\n\t\t\t}\n\t\t}\n\t\tif(ok==0){break;}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\ndouble dp[20][20][2500];\nconst double PI = 3.1415926535;\nint main(){\n  int n,i,j,k,ans=0;cin>>n;\n  double r,arc;cin>>r>>arc;\n  arc=PI/180.0*arc;\n  Polygon g;g.resize(n);\n  for(i=0;i<n;i++) cin>>g[i].x>>g[i].y;\n  double e[n][n][n],inf=1<<28;\n  fill(e[0][0],e[0][0]+n*n*n,inf);\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      for(k=0;k<n;k++){\n\tif(i==j||j==k||k==i) continue;\n\tVector a=g[j]-g[i],b=g[k]-g[j];\n\tif(fabs(acos(dot(a,b)/(abs(a)*abs(b))))<=arc)\n\t  e[i][j][k]=abs(g[k]-g[j]);\n      }\n    }\n  }\n  for(k=1;k<n;k++) e[0][0][k]=abs(g[k]-g[0]);\n  \n  fill(dp[0][0],dp[0][0]+20*20*2500,inf);\n  typedef pair<int,int> P;\n  typedef pair<int,P> PP;\n  typedef pair<double,PP> PPP;\n  priority_queue<PPP,vector<PPP>,greater<PPP> > q;\n  q.push(PPP(0.0,PP(0,P(0,n))));\n  while(!q.empty()){\n    PPP ppp=q.top();q.pop();\n    double d=ppp.first,z;\n    PP pp=ppp.second;\n    k=pp.first;\n    P p=pp.second;\n    if(d>r) continue;\n    ans=max(ans,k);\n    if(p.second==n){\n      for(i=0;i<n;i++){\n\tz=inf;\n\tfor(j=0;j<n;j++) z=min(z,e[j][0][i]);\n\tq.push(PPP(d+z,PP(k+1,P(i,p.first))));\n      }\n    }else{\n      if(dp[p.first][p.second][k]<=d) continue;\t\n      dp[p.first][p.second][k]=d;\n      for(i=0;i<n;i++)\n\tif(dp[i][p.first][k+1]<d+e[p.second][p.first][i])\n\t  q.push(PPP(d+e[p.second][p.first][i],PP(k+1,P(i,p.first))));\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst double PI = acos(-1);\nconst double INF = 1e15;\ndouble dp[10010][20][20];\n\nint n;\ndouble r, theta;\ndouble x[20], y[20];\n\ndouble dist(double x1, double y1, double x2, double y2){\n    x1 -= x2, y1 -= y2;\n    return sqrt(x1 * x1 + y1 * y1);\n}\n\ndouble dot(double x1, double y1, double x2, double y2){\n    return x1 * x2 + y1 * y2;\n}\n\nbool check(int v, int u, int pre){\n    double ax = x[v] - x[pre];\n    double ay = y[v] - y[pre];\n    double bx = x[u] - x[v];\n    double by = y[u] - y[v];\n    double da = dist(x[v], y[v], x[pre], y[pre]);\n    double db = dist(x[u], y[u], x[v], y[v]);\n    double t = abs(acos(dot(ax, ay, bx, by) / da / db));\n    //cerr << \"\\t\\t\" << v << \" \" << u << \" \" << pre << \" \" << t << endl;\n    return t < theta && abs(t - theta) > 1e-8;\n}\n\nint main(){\n    cin >> n >> r >> theta;\n\n    theta *= 2 * PI / 360.0;\n\n    for(int i = 0; i < n; i++){\n        cin >> x[i] >> y[i];\n    }\n\n    for(int i = 0; i <= 10000; i++){\n        for(int j = 0; j < n; j++){\n            for(int k = 0; k < n; k++){\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n\n    //cout << check(2, 0, 1) << endl;\n    //return 0;\n    for(int i = 0; i < n; i++){\n        dp[0][i][0] = 0;\n    }\n    for(int i = 0; i <= 10000; i++){\n        for(int v = 0; v < n; v++){\n            for(int pre = 0; pre < n; pre++){\n                double d = dp[i][v][pre];\n                if(d == INF) continue;\n                //cerr << i << \" \" << v << \" \" << pre << \" \" << d << endl;\n                for(int u = 0; u < n; u++){\n                    if(v == u) continue;\n                    if(i != 0 && !check(v, u, pre)) continue;\n                    //cerr << \"\\t\" << v << \" \" << u << endl;\n                    double ndist = d + dist(x[v], y[v], x[u], y[u]);\n                    if(ndist <= r && dp[i + 1][u][v] > ndist){\n                        dp[i + 1][u][v] = ndist;\n                    }\n                }\n            }\n        }\n\n    }\n\n    int ans = 0;\n    for(int i = 0; i <= 10000; i++){\n        for(int v = 0; v < n; v++){\n            for(int pre = 0; pre < n; pre++){\n                double d = dp[i][v][pre];\n                if(d == INF) continue;\n                ans = max(ans, i);\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double inf=1e8;\n#define rep(i,a) for(int i=0;i<a;i++)\ndouble dp[20][20][10010];\nint main(){\n  rep(i,20)rep(j,20)rep(k,10010)dp[i][j][k]=inf;\n  int n;\n  double x,y;\n  cin>>n>>x>>y;\n  y*=PI/180;\n  G g(n);\n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    g[i]=P(a,b);\n  }\n  dp[0][0][0]=0;\n  rep(i,10010)rep(j,n)rep(k,n)if(i==0||j!=k){\n    rep(l,n)if(l!=k){\n      double dis=abs(g[k]-g[l]);\n      //if(i==0)printf(\"%.9f %.9f\\n\",x,dis+dp[j][k][l]);\n      if(dis+dp[j][k][i]>x)continue;\n      double q=arg(g[k]-g[j])-arg(g[l]-g[k]);\n      if(q<~0)q*=-1;\n      while(q>PI)q=2*PI-q;//q-=PI;\n      if(i==0){\n\tq=0;//abs(arg(g[l]-g[k]));\n      }\n      if(q>y)continue;\n      dp[k][l][i+1]=min(dp[k][l][i+1],dp[j][k][i]+dis);\n    }\n  }\n  int out=0;\n  rep(i,n)rep(j,n)rep(k,10010)if(abs(dp[i][j][k]-inf)>EPS)out=max(out,k);\n  cout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 200\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nint V;\ndouble r, theta, E_sz[500];\n\n// A*B の計算\nmat mul(mat &A, mat &B){\n\tmat C(A.size(), vec(B[0].size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tfor(int j = 0; j < B[0].size(); j++){\n\t\t\tdouble mini = INF;\n\t\t\tfor(int k = 0; k < B.size(); k++){\n\t\t\t\tmini = min(mini, A[i][k] + B[k][j]);\n\t\t\t}\n\t\t\tC[i][j] = mini;\n\t\t}\n\t}\n\treturn C;\n}\n\n// A^n の計算\nint mat_pow(mat A){\n\tmat B(A.size(), vec(A.size()));\n\tfor(int i = 0; i < V * V; i++){\n\t\tfor(int j = 0; j < V * V; j++){\n\t\t\tB[i][j] = E_sz[i];\n\t\t}\n\t}\n\tint num = 0;\n\t\n\twhile(true){\n\t\tB = mul(B, A);\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < V * V; i++){\n\t\t\tfor(int j = 0; j < V * V; j++){\n\t\t\t\tif(B[i][j] < r){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t\tcout << num << endl;\n\t}\n\treturn num;\n}\n\nint main(){\n\t\n\tcin >> V;\n\t\n\tcin >> r >> theta;\n\t\n\ttheta = theta * M_PI / 180;\n\t\n\tmat S(V * V, vec(V * V));\n\t\n\tdouble x[30], y[30];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i = 0; i < V * V; i++){\n\t\tE_sz[i] = INF;\n\t\tfor(int j = 0; j < V * V; j++){\n\t\t\tS[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tif(i == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble vx1, vx2, vy1, vy2;\n\t\t\tvx1 = x[j] - x[i];\n\t\t\tvy1 = y[j] - y[i];\n\t\t\tdouble norm1 = sqrt(vx1 * vx1 + vy1 * vy1);\n\t\t\tE_sz[i * V + j] = norm1;\n\t\t\t\n\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\tif(j == k || k == i){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvx2 = x[k] - x[j];\n\t\t\t\tvy2 = y[k] - y[j];\n\t\t\t\tdouble inn = vx1 * vx2 + vy1 * vy2;\n\t\t\t\tdouble norm2 = sqrt(vx2 * vx2 + vy2 * vy2);\n\t\t\t\tdouble th = acos(inn / norm1 / norm2);\n\t\t\t\tif(th < theta){\n\t\t\t\t\tS[i * V + j][j * V + k] = norm2;\n\t\t\t\t\t//S[j * V + i][k * V + j] = norm2;\n\t\t\t\t\t//S[j * V + k][i * V + j] = norm1;\n\t\t\t\t\tS[k * V + j][j * V + i] = norm1;\n\t\t\t\t\t//cout << i * V + j << \" \" << j * V + k << \" \" << norm2 << endl;\n\t\t\t\t\t//cout << k * V + j << \" \" << j * V + i << \" \" << norm1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\tbool flag = true;\n\tfor(int i = 0; i < V * V; i++){\n\t\tif(E_sz[i] < r){\n\t\t\tflag = false;\n\t\t}\n\t}\n\t\n\tif(flag){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t*/\n\tcout << mat_pow(S) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n#include<climits>\n#include<complex>\n\n#define debug(x) cerr << #x << \": \" << x << endl\n#define EPS 1e-5\n \nusing namespace std;\n\nint main(){\n    int n;\n    double r, theta;\n    cin >> n;\n    cin >> r >> theta;\n    theta = theta/180.0*M_PI;\n    complex<double> cities[n];\n    for(int i=0;i<n;i++){\n        double x,y;\n        cin >> x >> y;\n        cities[i] = complex<double>(x, y);\n    }\n \n    bool ok[n][n][n];\n    fill_n(**ok, n*n*n, false);\n    double dist[n][n];\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(i == j) continue;\n            complex<double> v = cities[j] - cities[i];\n            dist[i][j] = abs(v);\n            for(int k=0;k<n;k++){\n                if(i == k || j == k) continue;\n                complex<double> u = cities[k] - cities[j];\n                double theta_ = abs(arg(u/v)); // arg(u) - arg(v)だと角度が違う\n                if(theta_ < theta+EPS){\n                    ok[i][j][k] = true;\n                }\n            }\n        }\n    }\n\n    double dp[2][n][n];\n    fill(dp[0][0], dp[0][n], 200000.0);\n    for(int j=1;j<n;j++){\n        dp[0][0][j] = dist[0][j];\n    }\n    int i = 0, ans = 0;\n    for(int i=0;i<=10000;i++){\n        fill(dp[1-(i&1)][0], dp[1-(i&1)][n], 200000.0);\n        for(int j=0;j<n;j++){\n            for(int k=0;k<n;k++){\n                if(j == k || dp[i&1][j][k] > r+EPS) continue;\n                for(int l=0;l<n;l++){\n                    if(j == l || k == l) continue;\n                    if(ok[j][k][l]){\n                        dp[1-(i&1)][k][l] = min(dp[1-(i&1)][k][l], dp[i&1][j][k] + dist[k][l]);\n                    } \n                }\n                ans = i+1;\n            }\n        }\n    }\n \n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 20;\nint x[N], y[N];\n\ndouble dist[10010][N][N];\n\nvector<int> G[N][N];\ndouble D[N][N];\nint ok[N][N][N];\n\nconst double PI = 4 * atan(1);\nconst double EPS = 1e-9;\n\nint main(){\n\tint n;\n\tdouble r, theta;\n\tcin >> n >> r >> theta;\n\ttheta = theta / 180 * PI;\n\trep(i, n) cin >> x[i] >> y[i];\n\n\trep(i, n) rep(j, n){\n\t\tD[i][j] = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));\n\t}\n\n\trep(i, n) rep(j, n) rep(k, n){\n\t\tif (i == j || j == k) continue;\n\t\tdouble x1 = x[j] - x[i], y1 = y[j] - y[i];\n\t\tdouble x2 = x[k] - x[j], y2 = y[k] - y[j];\n\n\t\tdouble ct = (x1*x2 + y1*y2) / (D[i][j]*D[j][k]);\n\t\tdouble t = acos(ct);\n\n\t\tif (abs(t) < theta + EPS) G[i][j].push_back(k), ok[i][j][k] = 1;\n\t}\n\n\tMEMSET(dist, 0x7f);\n\n\tpriority_queue<tuple<double, int, int, int>> pq;\n\n\trep(i, n) rep(j, n){\n\t\tif (i) continue;\n\t\tif (i == j) continue;\n\t\tif (D[i][j] > r - EPS) continue;\n\t\tpq.emplace(-D[i][j], 1, i, j);\n\t\tdist[1][i][j] = D[i][j];\n\t}\n\n\tint ans = 0;\n\t//while (!pq.empty()){\n\t//\tauto t = pq.top();\n\t//\tpq.pop();\n\t//\tdouble d;\n\t//\tint c, prv, cur;\n\t//\ttie(d, c, prv, cur) = t;\n\t//\td = -d;\n\n\t//\tif (dist[c][prv][cur] + EPS < d) continue;\n\n\t//\tans = max(ans, c);\n\n\t//\tfor (auto v : G[prv][cur]){\n\t//\t\tdouble nd = d + D[cur][v];\n\t//\t\tif (r < nd + EPS) continue;\n\t//\t\tif (dist[c + 1][cur][v] < nd + EPS) continue;\n\t//\t\tdist[c + 1][cur][v] = nd;\n\t//\t\tpq.emplace(-nd, c + 1, cur, v);\n\t//\t}\n\t//}\n\n\trep(i, 10010) rep(j, n) rep(k, n){\n\t\tif (dist[i][j][k] > r - EPS) continue;\n\t\tans = i;\n\t\trep(l, n) if (ok[j][k][l]) dist[i + 1][k][l] = min(dist[i + 1][k][l], dist[i][j][k] + D[k][l]);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  R r, th; cin >> r >> th, th *= pi / 180;\n  V<P> p(n); for (auto&& e : p) cin >> e;\n  VV< V<> > ks(20, VV<>(20));\n  VV<R> d(20, V<R>(20));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    for (int k = 0; k < n; ++k) if (k != j) {\n      L s{p[i], p[j]}, t{p[j], p[k]};\n      R ph = fmod(3 * pi + t.arg() - s.arg(), 2 * pi) - pi;\n      if (sgn(abs(ph), th) <= 0) ks[i][j].push_back(k);\n    }\n    d[i][j] = distPP(p[i], p[j]);\n  }\n  VV<R> dp(20, V<R>(20, 1e10));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n    dp[i][j] = d[i][j];\n  }\n  int res = 0;\n  for (int s = 0; s <= 1e4; ++s) {\n    VV<R> ndp(20, V<R>(20, 1e10));\n    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (j != i) {\n      if (!i and sgn(dp[i][j], r) <= 0) res = s + 1;\n      for (int k : ks[i][j]) {\n        ndp[i][j] = min(ndp[i][j], d[i][j] + dp[j][k]);\n      }\n    }\n    swap(dp, ndp);\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst long double PI = 3.14159255358979323846264338327950288l;\nstruct Point { long double px, py; };\nlong double theta(long double a, long double b, long double c) {\n\tlong double s = (a + b + c) / 2.0l;\n\tlong double S = sqrtl(s*(s - a)*(s - b)*(s - c));\n\tlong double A = -1000, B = -1000, C = -1000, H;\n\n\tif (a > b && a > c) { H = 2.0l * S / a; B = asin(H / c)*180.0l / PI; C = asin(H / b)*180.0l / PI; A = 180.0l - B - C; }\n\telse if (b > a && b > c) { H = 2.0l * S / b; A = asin(H / c)*180.0l / PI; C = asin(H / a)*180.0l / PI; B = 180.0l - A - C; }\n\telse { H = 2.0l * S / c; A = asin(H / b)*180.0l / PI; B = asin(H / a)*180.0l / PI; C = 180.0l - A - B; }\n\n\treturn A;\n}\nlong double theta_(Point a, Point b, Point c) {\n\t//a->b->c\n\tlong double A1 = sqrtl((a.px - c.px)*(a.px - c.px) + (a.py - c.py)*(a.py - c.py));\n\tlong double B1 = sqrtl((a.px - b.px)*(a.px - b.px) + (a.py - b.py)*(a.py - b.py));\n\tlong double C1 = sqrtl((b.px - c.px)*(b.px - c.px) + (b.py - c.py)*(b.py - c.py));\n\treturn theta(A1, B1, C1);\n}\nlong double dp[22][22], prev_[22][22], r, t, theta__[22][22][22], dist_[22][22]; Point x[30]; int n;\nint main() {\n\tcin >> n >> r >> t;\n\tfor (int i = 0; i < n; i++)cin >> x[i].px >> x[i].py;\n\tfor (int i = 0; i < 22; i++) { for (int j = 0; j < 22; j++) { dp[i][j] = 999999999.9l; prev_[i][j] = 999999999.9l; } }\n\tfor (int i = 0; i < n; i++) { if (i != 0) { prev_[0][i] = sqrtl((x[0].px - x[i].px)*(x[0].px - x[i].px) + (x[0].py - x[i].py)*(x[0].py - x[i].py)); } }\n\tfor (int i = 0; i < 22; i++) { for (int j = 0; j < 22; j++) { for (int k = 0; k < 22; k++) { theta__[i][j][k] = 180.0l - theta_(x[i], x[j], x[k]); } } }\n\tfor (int i = 0; i < 22; i++) { for (int j = 0; j < 22; j++) { dist_[i][j] = sqrtl((x[i].px - x[j].px)*(x[i].px - x[j].px) + (x[i].py - x[j].py)*(x[i].py - x[j].py)); } }\n\tint maxn = 0;\n\tfor (int i = 1; i < 100000; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tif (j == k || k == l || theta__[j][k][l] > t)continue;\n\t\t\t\t\tdp[k][l] = min(dp[k][l], prev_[j][k] + dist_[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (prev_[j][k] < r)maxn = i;\n\t\t\t\tprev_[j][k] = dp[j][k]; dp[j][k] = 999999999.9l;\n\t\t\t}\n\t\t}\n\t\tif (maxn != i)break;\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\n#define pow2(a) (pow(1.*a,2))\ntypedef struct D\n{\n\tint c,pp,np;\n\tdouble d;\n\tvector<int> dbg;\n\tbool operator <(const D &a)const{ return c<a.c;};\n}D;\nint N,X[25],Y[25],res=0;\ndouble R,O,g[25][25],d[25][25];\ndouble ang(int pre,int now,int next)\n{\n\tdouble a=d[pre][now],b=d[now][next],c=d[pre][next];\n\tdouble dd=acos((pow2(a)+pow2(b)-pow2(c))/(2*a*b));\n\tdouble df=180-(dd*180/3.141592);\n\treturn df;\n}\n\nint main()\n{\n\tscanf(\"%d%lf%lf\",&N,&R,&O);\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",X+i,Y+i);\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\td[i][j]=sqrt(pow2(X[i]-X[j])+pow2(Y[i]-Y[j]));\n\tpriority_queue<D>Q;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tif(d[0][i]>R)continue;\n\t\tvector<int> td;\n\t\ttd.push_back(0);\n\t\ttd.push_back(i);\n\t\tD tmp={1,0,i,d[0][i]};\n\t\ttmp.dbg=td;\n\t\tQ.push(tmp);\n\t}\n\tfor(;!Q.empty();)\n\t{\n\t\tD tmp=Q.top();Q.pop();\n\t\t//res=max(res,tmp.c);\n\t\tif(res<tmp.c)\n\t\t{\n\t\t\tres=tmp.c;\n\t\t}\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(i==tmp.np)continue;\n\t\t\tif(ang(tmp.pp,tmp.np,i)<=O&&tmp.d+d[tmp.np][i]<=R)\n\t\t\t{\n\n\t\t\t\tD ins={tmp.c+1,tmp.np,i,tmp.d+d[tmp.np][i],tmp.dbg};\n\t\t\t\tins.dbg.push_back(i);\n\t\t\t\tQ.push(ins);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <algorithm>\n#undef max\n#undef min\n\nstruct Node {\n    int pos = 0;\n    int carrot = 0;\n    float len = 0;\n};\n\nint main() {\n    int n; float r, theta;\n    float angleTable[20][20][20] = { 0 };\n    float dist[20][20] = { 0 };\n    std::vector<float> memo[20];\n    std::vector<std::pair<int, int>> city;\n    std::cin >> n >> r >> theta;\n    theta /= 180.f;\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        city.push_back(std::make_pair(x, y));\n    }\n\n    // memo初期化\n    for (auto& x : memo) {\n        x.push_back(0.f);\n    }\n\n    // 都市間移動の角度と距離を計算\n    for (int i = 0; i < city.size(); i++) {\n        for (int j = 0; j < city.size(); j++) {\n            if (i == j) continue;\n            for (int k = 0; k < city.size(); k++) {\n                if (i == k) continue;\n                float vx[2] = { city[j].first - city[i].first , city[k].first - city[i].first };\n                float vy[2] = { city[k].second - city[i].second , city[k].second - city[i].second };\n                float jLen = std::sqrt(vx[0] * vx[0] + vy[0] + vy[0]);\n                float kLen = std::sqrt(vx[1] * vx[1] + vy[1] * vy[1]);\n                float dot = vx[0] * vx[1] + vy[0] * vy[1];\n                angleTable[i][j][k] = M_PI_2 - std::acos(dot / (jLen * kLen));\n            }\n            float vx = city[j].first - city[i].first;\n            float vy = city[j].second - city[i].second;\n            dist[i][j] = std::sqrt(vx * vx + vy * vy);\n        }\n    }\n\n    std::stack<Node> s;\n    int maxCarrot = 0;\n    s.push({0, 0, 0.f});\n\n    while (!s.empty()) {\n        auto node = s.top(); s.pop();\n        for (int i = 0; i < city.size(); i++) {\n            if (i == node.pos) continue;\n            auto next = node;\n            \n            next.len += dist[node.pos][i];\n            if (next.len >= r) continue;\n\n            next.pos = i;\n            next.carrot++;\n\n            if (memo[i].size() <= next.carrot) {\n                int m = memo[i].size();\n                for (int j = 0; j < next.carrot - m; j++) {\n                    memo[i].push_back(memo[i].back());\n                }\n                memo[i].push_back(next.carrot);\n            }\n            else {\n                if (memo[i][next.carrot] <= next.len) continue; // もっと短い距離で同数の人参に到達\n            }\n            maxCarrot = std::max(maxCarrot, next.carrot);\n            s.push(next);\n        }\n    }\n    std::cout << maxCarrot << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n \ntypedef complex<double> P;\n \nstruct S{\n  int w,p,n;\n  double d;\n  bool operator<(S s)const{\n    return d>s.d;\n  }\n};\n \ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n \nint main(){\n  int n;\n  double r,th;\n  cin>>n>>r>>th;\n  P p[21];\n  for(int i=1;i<=n;i++){\n    int x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<S> que;\n  que.push({1,0,0,0});\n  static bool mem[21][21][22222];\n  int m=0;\n  while(!que.empty()){\n    auto cs=que.top();\n    if(cs.d>r)break;\n    que.pop();\n    if(mem[cs.w][cs.p][cs.n]++)continue;\n    m=max(m,cs.n);\n    for(int i=1;i<=n;i++){\n      if(i==cs.w)continue;\n      auto f=p[cs.w]-p[cs.p];\n      auto t=p[i]-p[cs.w];\n      if(cs.p&&acos(dot(f,t)/abs(f)/abs(t))*90>th*acos(0)-1e-9)continue;\n      que.push({i,cs.w,cs.n+1,cs.d+abs(t)});\n    }\n  }\n  cout<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<  vector<double>  > vvd;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef complex<double> zahyo;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nzahyo toshi[21];\nbool kakdotest(zahyo a,zahyo b,double kakdo){\n\n  double kak= (a.real()*b.real()+a.imag()*b.imag())/  (abs(a)*abs(b));\n  if (cos(kakdo)<kak)\n    return true;\n  else return false;\n}\nint main(){\n  int n,k;\n  double r,kakdo,xza,yza;\n  cin>>n>>r>>kakdo;\n  for(int i=1;i<=n;i++){\n    cin>>xza>>yza;\n    toshi[i]=zahyo(xza,yza);\n  }\n  vvd nokori(n+1);\n  for(int i=0;i<n+1;i++){\n    nokori[i]=vector<double>(21,-1);\n  }\n  vvd prevnokori=nokori;\n  for(int i=2;i<n+1;i++){\n    prevnokori[1][i]=r-abs(toshi[i]-toshi[1]);\n  }\n  int maxcarrot=0;\n  k=1;\n  while(k-maxcarrot==1){\n    vvd nextnokori=nokori;  \n    for(int i=1;i<(n+1);i++)\n      for(int j=1;j<(n+1);j++){\n\tif(i==j) continue;\n\tif(prevnokori[i][j]<0) continue;\n\tmaxcarrot=k;\n\t//\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<abs(prevnokori[i][j])<<endl;\n\tfor(int l=1;l<(n+1);l++){\n\t  if(kakdotest(toshi[i]-toshi[j],\n\t\t       toshi[j]-toshi[l],kakdo)){\n\t    nextnokori[j][l]=\n\t      max(prevnokori[i][j]-abs(toshi[j]-toshi[l]),\n\t\t\t\t nextnokori[j][l]);\n\t   \n\t  }\n\t}\n\n      }\n    prevnokori=nextnokori;\n    k++;\n  }\n  cout<<maxcarrot<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\n\nint n;\ndouble r,d;\nP p[20];\ndouble dp[10001][20][20];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint main(){\n  cin>>n>>r>>d;\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)dp[i][j][k]=1e9;\n  dp[0][0][0]=0;\n\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tfor(int l=0;l<n;l++)\n\t  if(check(j,k,l))\n\t    dp[i+1][k][l]=min(dp[i+1][k][l],dp[i][j][k]+abs(p[k]-p[l]));\n\n  int ans=0;\n  for(int i=1;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tif(dp[i][j][k]<=r)ans=i;\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (lt(a, b) || equals(a, b))\n#define PI acos(-1)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\ndouble getAngle(Point a, Point b, Point c)\n{\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / PI;\n  return min(theta, 360 - theta);\n}\n\nint n;\ndouble r, t;\nvector<Point> ps;\n\ndouble d[21][21][10001];\n\nstruct State\n{\n  int now, prev, car;\n  double dist;\n  State(){}\n  State(int now, int prev, int car, double dist):now(now), prev(prev), car(car), dist(dist){}\n  bool operator < (const State& r) const {\n    return dist > r.dist;\n  }\n};\n\nint solve()\n{\n  rep(i, 21) rep(j, 21) rep(k, 10001) d[i][j][k] = 1e10;\n\n  priority_queue<State> que;\n  reps(i, 1, n) {\n    double dist = getDistance(ps[0], ps[i]);\n    if(le(dist, r)) {\n      d[i][0][1] = dist;\n      que.push(State(i, 0, 1, dist));\n    }\n  }\n\n  vector< vector<vector<int> > > G(n, vector< vector<int> >(n));\n  rep(i, n) rep(j, n) rep(k, n) {\n    if(i != j && i != k && le(getAngle(ps[j], ps[i], ps[k]), t)) {\n      G[i][j].push_back(k);\n    }\n  }\n\n  int ans = 0;\n  while(!que.empty()) {\n    State st = que.top(); que.pop();\n    int now = st.now, prev = st.prev, car = st.car;\n    double dist = st.dist;\n    ans = max(ans, car);\n    if(dist > d[now][prev][car]) continue;\n    for(int to : G[now][prev]) {\n      double di = dist + getDistance(ps[now], ps[to]);\n      if(le(di, r) && d[to][now][car+1] > di) {\n\td[to][now][car+1] = di;\n\tque.push(State(to, now, car+1, di));\n      }\n    }\n  }\n\n  return ans;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> n >> r >> t;\n  ps.resize(n);\n  rep(i, n) cin >> ps[i].x >> ps[i].y;\n\n  cout << solve() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#define scanf_s scanf\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\n\nint main(void){\n\tint n,ans,i,j,k,ok;\n\tdouble r,sit;\n\tdouble x[20];\n\tdouble y[20];\n\tdouble dp[20][20]={0};//x??????y????????????\n\tdouble dpc[20][20]={0};\n\tstatic bool isok[20][20][20];\n\tdouble d;\n\tdouble pi=3.141592653589793238462643383279502884197;\n\tscanf(\"%d\",&n);\n\tscanf(\"%lf %lf\",&r,&sit);\n\tsit=(sit/180)*pi;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i][j]=0;\n\t\t\tdpc[i][j]=big;\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\td=abs(atan2(y[i]-y[k],x[i]-x[k])-atan2(y[k]-y[j],x[k]-x[j]));\n\t\t\t\tisok[i][k][j]=(min(2*pi-d,d)<sit);\n\t\t\t}\n\t\t}\n\t}\n\tfor(ans=0;;ans++){\n\t\tfor(k=0;k<n;k++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(ans!=0&&(k-i)*(i-j)==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(j-k==0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(ans==0&&k!=0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(ans==0||isok[i][k][j]){\n\t\t\t\t\t\tdpc[k][j]=min(dpc[k][j],dp[i][k]+hypot(x[k]-x[j],y[k]-y[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tdp[i][j]=dpc[i][j];\n\t\t\t\tif(dpc[i][j]<r){\n\t\t\t\t\tok=1;\n\t\t\t\t}\n\t\t\t\tdpc[i][j]=big;\n\t\t\t}\n\t\t}\n\t\tif(ok==0){break;}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <algorithm>\n#include <queue>\n#undef max\n#undef min\n\nstruct Node {\n    int lastPos = 0;\n    int pos = 0;\n    int carrot = 0;\n    float len = 0;\n\n    bool operator<(const Node& rhs) const {\n        if (len == rhs.len) return carrot > rhs.carrot;\n        return len < rhs.len;\n    }\n    bool operator>(const Node& rhs) const {\n        if (len == rhs.len) return carrot < rhs.carrot;\n        return len > rhs.len;\n    }\n};\n\nint main() {\n    int n; float r, theta;\n    float angleTable[20][20][20] = { 0 };\n    float dist[20][20] = { 0 };\n    std::vector<float> memo[20][20];\n    std::vector<std::pair<int, int>> city;\n    std::cin >> n >> r >> theta;\n    theta /= 180.f;\n    theta *= M_PI;\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        city.push_back(std::make_pair(x, y));\n    }\n\n    // memo初期化\n    for (auto& x : memo) {\n        for (auto& y : x) {\n            y.push_back(0.f);\n        }\n    }\n\n    // 都市間移動の角度と距離を計算\n    for (int i = 0; i < city.size(); i++) { // 前\n        for (int j = 0; j < city.size(); j++) { // 今\n            if (i == j) continue;\n            for (int k = 0; k < city.size(); k++) { // 次\n                if (j == k) continue;\n                if (i != k) {\n                    float vx[2] = { (float)(city[i].first - city[j].first) , (float)(city[k].first - city[j].first) };\n                    float vy[2] = { (float)(city[i].second - city[j].second) , (float)(city[k].second - city[j].second) };\n                    float jLen = std::sqrt(vx[0] * vx[0] + vy[0] * vy[0]);\n                    float kLen = std::sqrt(vx[1] * vx[1] + vy[1] * vy[1]);\n                    float dot = vx[0] * vx[1] + vy[0] * vy[1];\n                    float a = dot / (jLen * kLen);\n                    angleTable[i][j][k] = (float)(M_PI) - std::acos(dot / (jLen * kLen));\n                }\n                else angleTable[i][j][k] = (float)(M_PI);\n            }\n            float vx = (float)city[j].first - city[i].first;\n            float vy = (float)city[j].second - city[i].second;\n            dist[i][j] = std::sqrt(vx * vx + vy * vy);\n        }\n    }\n\n    std::priority_queue<Node, std::vector<Node>, std::greater<>> s;\n    int maxCarrot = 0;\n    s.push({0, 0, 0, 0.f});\n\n    while (!s.empty()) {\n        auto node = s.top(); s.pop();\n        for (int i = 0; i < city.size(); i++) {\n            if (i == node.pos) continue;\n            if (node.pos != node.lastPos && angleTable[node.lastPos][node.pos][i] >= theta) continue;\n            auto next = node;\n            next.len += dist[node.pos][i];\n            if (next.len > r) continue;\n\n            next.lastPos = next.pos;\n            next.pos = i;\n            next.carrot++;\n\n            if (memo[next.lastPos][i].size() <= next.carrot) {\n                int m = memo[next.lastPos][i].size();\n                for (int j = 0; j < next.carrot - m + 1; j++) {\n                    memo[next.lastPos][i].push_back(next.len);\n                }\n            }\n            else {\n                if (memo[next.lastPos][i][next.carrot] <= next.len) continue; // もっと短い距離で同数の人参に到達\n            }\n            memo[next.lastPos][i][next.carrot] = next.len;\n            maxCarrot = std::max(maxCarrot, next.carrot);\n            s.push(next);\n        }\n    }\n    std::cout << maxCarrot << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int MAX = 20,LIMIT = 21000,IINF = INT_MAX;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nstruct Edge{\n  int to;\n  double weight;\n  Edge(int to=0,double weight=0):to(to),weight(weight){}\n};\n\nstruct Data{\n  int prev,cur,carrot;\n  double dist;\n  Data(int prev=0,int cur=0,int carrot=0,double dist=0):prev(prev),cur(cur),carrot(carrot),dist(dist){}\n  bool operator < (const Data& data) const{ return dist > data.dist; }\n};\n\nint n;\ndouble r,theta,mindist[MAX][MAX][LIMIT]; // mindist[cur][prev][the number of carrot]\nPoint ps[MAX];\nvector<Edge> edge[MAX][MAX]; // edge[cur][prev]\n\ninline void dijkstra(){\n  rep(i,n)rep(j,n)rep(k,LIMIT) mindist[i][j][k] = IINF;\n  priority_queue<Data> Q;\n\n  REP(i,1,n) {\n    double dist = abs(ps[0]-ps[i]);\n    if( !equals(dist,r) && dist > r ) continue;\n    Q.push(Data(0,i,1,dist));\n    mindist[i][0][1] = dist;\n  }\n  int ans = (Q.empty()?0:1);\n\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n    int prev = data.prev, cur = data.cur, carrot = data.carrot;\n    double dist = data.dist;\n\n    if( !equals(mindist[cur][prev][carrot],dist) && mindist[cur][prev][carrot] < dist ) continue;\n\n    rep(i,edge[cur][prev].size()) {\n      int next = edge[cur][prev][i].to;\n      double weight = edge[cur][prev][i].weight;\n      if( !equals(r,dist+weight) && r < dist+weight ) continue;\n      if( mindist[next][cur][carrot+1] > dist + weight ){\n        mindist[next][cur][carrot+1] = dist + weight;\n        assert(carrot+1 < LIMIT);\n        ans = max(ans,carrot+1);\n        Q.push(Data(cur,next,carrot+1,dist+weight));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\ninline void makeEdge(){\n  rep(prev,n){\n    rep(cur,n){\n      if( cur == prev ) continue;\n      rep(next,n){\n        if( next == cur || next == prev ) continue;\n        double dist = abs(ps[cur]-ps[next]);\n        if( !equals(dist,r) && dist > r ) continue;\n        Vector v1 = ps[next] - ps[cur];\n        Vector v2 = ps[cur]  - ps[prev];\n        if( equals(cross(v1,v2),0.0) ) continue;\n        double arg = getArg(ps[prev],ps[cur],ps[next]);\n        if( equals(arg,theta) || arg < theta ) edge[cur][prev].push_back(Edge(next,dist));\n      }\n    }\n  }\n}\n\nint main(){\n\n  /*\n  int next = 2, cur = 1, prev = 0;\n  ps[0] = Point(0,0);\n  ps[1] = Point(10,0);\n  ps[2] = Point(0,1);\n  double arg =  getArg(ps[prev],ps[cur],ps[next]);\n  cout << \"arg = \" << arg * 180.0 / M_PI << endl;\n  */\n\n  cin >> n;\n  cin >> r >> theta;\n  theta = toRad(theta);\n  rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n\n  makeEdge();\n\n  dijkstra();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (lt(a, b) || equals(a, b))\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\ndouble getAngle(Point a, Point b, Point c)\n{\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\n\n\nint n;\ndouble r, t;\nvector<Point> ps;\n\ndouble d[21][21][10001];\n\nstruct State\n{\n  int now, prev, car;\n  double dist;\n  State(){}\n  State(int now, int prev, int car, int dist):now(now), prev(prev), car(car), dist(dist){}\n  bool operator < (const State& r) const {\n    return dist > r.dist;\n  }\n};\n\nint solve()\n{\n  rep(i, 21) rep(j, 21) rep(k, 10001) d[i][j][k] = 1e10;//-1;\n  priority_queue<State> que;\n  reps(i, 1, n) {\n    double dist = getDistance(ps[0], ps[i]);\n    if(le(dist, r)) {\n      d[i][0][1] = dist;\n      que.push(State(i, 0, 1, dist));\n    }\n  }\n\n  int ans = 0;\n  while(!que.empty()) {\n    State st = que.top(); que.pop();\n    int now = st.now, prev = st.prev, car = st.car;\n    double dist = st.dist;\n    ans = max(ans, car);\n    if(dist > d[now][prev][car]) continue;\n    rep(i, n) if(i != now) {\n      int di = dist + getDistance(ps[now], ps[i]);\n      if(le(getAngle(ps[prev], ps[now], ps[i]), t) && le(di, r) && d[i][now][car+1] > di) {\n\td[i][now][car+1] = di;\n\tque.push(State(i, now, car+1, di));\n      }\n    }\n  }\n\n  return ans;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> n >> r >> t;\n  ps.resize(n);\n  rep(i, n) cin >> ps[i].x >> ps[i].y;\n\n  cout << solve() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n#define F first\n#define S second\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<double,int>P1;\ntypedef pair<int,int>P2;\ntypedef pair<P1,P2>P3;\nint n,ans;\nP p[21];\nD r,qu,dp[10001][21][21];\nint main(){\n  cin>>n>>r>>qu;\n  rep(i,10001)rep(j,21)rep(k,21)dp[i][j][k]=1e15;\n  rep(i,n){\n    D x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<P3,vector<P3>,greater<P3> >q;\n  for(int i=1;i<n;i++){\n    if(abs(p[0]-p[i])>r)continue;\n    dp[1][0][i]=abs(p[0]-p[i]);\n    q.push(P3(P1(dp[1][0][i],1),P2(0,i)));\n  }\n  while(!q.empty()){\n    P3 ppp=q.top();q.pop();\n    int pre=ppp.S.F;\n    int now=ppp.S.S;\n    int num=ppp.F.S;\n    double cost=ppp.F.F;\n    if(dp[num][pre][now]<cost)continue;\n    rep(i,n)if(now!=i){\n      D a=abs(p[pre]-p[now]);\n      D b=abs(p[now]-p[i]);\n      D c=abs(p[i]-p[pre]);\n      D radi=acos((a*a+b*b-c*c)/(2*a*b));\n      radi=radi/M_PI*180;\n      if(180.0-radi > qu)continue;\n      if(cost+abs(p[now]-p[i])>r)continue;\n      if(dp[num+1][now][i]<=cost+abs(p[now]-p[i]))continue;\n      dp[num+1][now][i]=cost+abs(p[now]-p[i]);\n      q.push(P3(P1(dp[num+1][now][i],num+1),P2(now,i)));\n    }\n  }\n  dp[0][0][0]=1;\n  for(int i=10000;i>=0;i--){\n    rep(j,21)rep(k,21)if(dp[i][j][k]!=1e15){\n      cout<<i<<endl;\n      return 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nstruct point{\n  double x,y;\n};\n \ndouble INF = 1e9;\ndouble PI = acos(-1);\ndouble EPS = (1e-10);\ndouble dp[10001][20][20];\nint n;\ndouble Ti;\ndouble r,ti;\npoint t[20];\n \ndouble mem[20][20][20];\ndouble check(int to,int from,int prev){\n  if(mem[to][from][prev]!=-INF)return mem[to][from][prev];\n \n  if(to==from||to==prev)return INF;\n  double vax=t[to].x-t[from].x;\n  double vay=t[to].y-t[from].y;\n  double vbx=t[from].x-t[prev].x;\n  double vby=t[from].y-t[prev].y;\n  double ar=(vax*vbx+vay*vby)/(sqrt(vax*vax+vay*vay)*sqrt(vbx*vbx+vby*vby));\n  ar=acos(ar);\n  if(ar<ti+EPS){\n    mem[to][from][prev]=sqrt(vax*vax+vay*vay);\n  }else{\n    mem[to][from][prev]=INF;\n  }\n  return mem[to][from][prev];\n}\n \nvoid solve(int i,int j,int k){\n  for(int to=0;to<n;to++){\n    dp[i+1][to][j]=min(dp[i+1][to][j],dp[i][j][k]+check(to,j,k));\n \n    //dp[i][j][k]+sqrt(vax*vax+vay*vay));\n    //    if(ar<ti+EPS){\n    // dp[i+1][to][j]=min(dp[i+1][to][j],dp[i][j][k]+sqrt(vax*vax+vay*vay));\n    //    }\n  }\n}\n \nint main(){\n \n  for(int i=0;i<10001;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<20;k++)\n    dp[i][j][k]=INF;\n   \n  for(int i=0;i<20;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<20;k++)\n    mem[i][j][k]=-INF;\n \n  cin>>n>>r>>Ti;\n  ti=Ti/360.0*2.0*PI;\n \n  for(int i=0;i<n;i++)\n    cin>>t[i].x>>t[i].y;\n   \n  for(int i=1;i<n;i++){\n    double x=t[i].x-t[0].x;\n    double y=t[i].y-t[0].y;\n    dp[1][i][0]=sqrt(x*x+y*y);\n  }\n \n  int ans=0;\n  for(int i=1;i<=10000;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n    if(dp[i][j][k]>r+EPS)continue;\n    ans=max(ans,i);\n    solve(i,j,k);\n      }\n    }\n  }\n  cout<<ans<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n#define INF 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long\n\nnamespace {\n#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T> &);\n\n#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n    __DECLARE__(std::vector)\n    __DECLARE__(std::deque)\n    __DECLARE__(std::set)\n    __DECLARE__(std::stack)\n    __DECLARE__(std::queue)\n    __DECLARE__(std::priority_queue)\n    __DECLARE__(std::unordered_set)\n    __DECLAREM__(std::map)\n    __DECLAREM__(std::unordered_map)\n\n    template <typename T, typename U>\n    std::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n    template <typename... T>\n    std::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n    template <typename T, std::size_t N>\n    std::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n    template <typename Tuple, std::size_t N>\n    struct __TuplePrinter__ {\n        static void print(std::ostream &os, const Tuple &t) {\n            __TuplePrinter__<Tuple, N - 1>::print(os, t);\n            os << \", \" << std::get<N - 1>(t);\n        }\n    };\n\n    template <typename Tuple>\n    struct __TuplePrinter__<Tuple, 1> {\n        static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n    };\n\n    template <typename... T>\n    std::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n        os << '(';\n        __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n        os << ')';\n        return os;\n    }\n\n    template <typename T, typename U>\n    std::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n        return os << '(' << v.first << \", \" << v.second << ')';\n    }\n\n#define __INNER__                             \\\n\tos << '[';                                \\\n\tfor (auto it = begin(c); it != end(c);) { \\\n\t\tos << *it;                            \\\n\t\tos << (++it != end(c) ? \", \" : \"\");   \\\n\t}                                         \\\n\treturn os << ']';\n\n    template <typename T, std::size_t N>\n    std::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n        __INNER__\n    }\n\n#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\t__INNER__                                               \\\n\t}\n\n#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t\t__INNER__                                                  \\\n\t}\n\n#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\tstd::deque<T> v;                                        \\\n\t\tfor (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t\t\treturn os << v;                                         \\\n\t}\n\n    __DEFINE__(std::vector)\n    __DEFINE__(std::deque)\n    __DEFINE__(std::set)\n    __DEFINEW__(std::stack, push_front, top)\n    __DEFINEW__(std::queue, push_back, front)\n    __DEFINEW__(std::priority_queue, push_front, top)\n    __DEFINE__(std::unordered_set)\n    __DEFINEM__(std::map)\n    __DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint\ntemplate <signed M, unsigned T>\nstruct mod_int {\n    constexpr static signed MODULO = M;\n    constexpr static unsigned TABLE_SIZE = T;\n\n    signed x;\n\n    mod_int() : x(0) {}\n\n    mod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n    mod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((x += rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator*=(const mod_int &rhs) {\n        x = static_cast<signed>(1LL * x * rhs.x % MODULO);\n        return *this;\n    }\n\n    mod_int &operator/=(const mod_int &rhs) {\n        x = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n        return *this;\n    }\n\n    mod_int operator-() const { return mod_int(-x); }\n\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n    bool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n    mod_int inv() const {\n        assert(x != 0);\n        if (x <= static_cast<signed>(TABLE_SIZE)) {\n            if (_inv[1].x == 0) prepare();\n            return _inv[x];\n        } else {\n            signed a = x, b = MODULO, u = 1, v = 0, t;\n            while (b) {\n                t = a / b;\n                a -= t * b;\n                std::swap(a, b);\n                u -= t * v;\n                std::swap(u, v);\n            }\n            return mod_int(u);\n        }\n    }\n\n    mod_int pow(long long t) const {\n        assert(!(x == 0 && t == 0));\n        mod_int e = *this, res = mod_int(1);\n        for (; t; e *= e, t >>= 1)\n            if (t & 1) res *= e;\n        return res;\n    }\n\n    mod_int fact() {\n        if (_fact[0].x == 0) prepare();\n        return _fact[x];\n    }\n\n    mod_int inv_fact() {\n        if (_fact[0].x == 0) prepare();\n        return _inv_fact[x];\n    }\n\n    mod_int choose(mod_int y) {\n        assert(y.x <= x);\n        return this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n    }\n\n    static mod_int _inv[TABLE_SIZE + 1];\n\n    static mod_int _fact[TABLE_SIZE + 1];\n\n    static mod_int _inv_fact[TABLE_SIZE + 1];\n\n    static void prepare() {\n        _inv[1] = 1;\n        for (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n            _inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n        }\n        _fact[0] = 1;\n        for (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n            _fact[i] = _fact[i - 1] * int(i);\n        }\n        _inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n        for (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n            _inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n        }\n    }\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n    return os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n    long long s;\n    is >> s;\n    rhs = mod_int<M, F>(s);\n    return is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\nconst ll mod = 1000000007;\nconst int MAX_N = 10000;  // 400MB\n// const int MAX_N = 1024; // 4MB\n// nCr % mod\n\n//#define int long long\n\ninline ll gcds(ll a, ll b) { return b ? gcds(b, a % b) : a; }\ninline ll lcms(ll a, ll b) { return a / gcd(a, b) * b; }\n\n#define RK 200000000000\n#define LK 300000000000\n#define PL 400000000000\n#define MI 500000000000\n#define KA 600000000000\n#define PI acos(-1)\n//#define double float\ndouble dist[30][30];\n\nvoid calc_dist(vector<pair<int,int>> &v){\n    lp(i,v.size()){\n        lp(j,v.size()){\n            double ax=v[i].first;\n            double ay=v[i].second;\n            double bx=v[j].first;\n            double by=v[j].second;\n            dist[i][j]=sqrt(abs(ax-bx)*abs(ax-bx)+abs(ay-by)*abs(ay-by));\n            //cout<<i<<\" \"<<j<<\" \"<<dist[i][j]<<endl;\n        }\n    }\n}\n\nvoid make_g(vector<vector<vector<int>>> &g,vector<pair<int,int>> &v,double si){\n    lp(i,v.size()){\n        lp(j,v.size()){\n            lp(k,v.size()){\n                if(i==j||j==k||i==k)continue;\n                //i->j->k\n                double ax=v[i].first;\n                double ay=v[i].second;\n                double bx=v[j].first;\n                double by=v[j].second;\n                double cx=v[k].first;\n                double cy=v[k].second;\n                ax-=bx;\n                cx-=bx;\n                ay-=by;\n                cy-=by;\n                //cout<<i<<\" \"<<j<<endl;\n                double arc=acos((ax*cx+ay*cy)/(sqrt(ax*ax+ay*ay)*sqrt(cx*cx+cy*cy)));\n                arc=arc*180/PI;\n                if(arc>180.0)arc-=180.0;\n                else arc=180-arc;\n                //cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<arc<<endl;\n                if(arc<=si+0.000001){\n                    g[i][j].push_back(k);\n                }\n                if(abs(dist[i][j]+dist[j][k]-dist[i][k])<0.000001){\n                    //cout<<i<<\" \"<<j<<\" \"<<k<<endl;\n                    g[i][j].push_back(k);\n\n                }\n            }\n        }\n    }\n}\ndouble dp[20][20][20000];\n\nsigned main(){\n    int n;\n    cin>>n;\n    double r,si;\n    cin>>r>>si;\n    vector<pair<int,int>> v;\n    lp(i,n){\n        int a,b;\n        cin>>a>>b;\n        v.push_back({a,b});\n    }\n    vector<vector<vector<int>>> g;//g[before][index].push_back(next)\n    g.resize(n);\n    lp(i,n)g[i].resize(n);\n    calc_dist(v);\n    make_g(g,v,si);\n    lp(i,20)lp(j,20)lp(k,20000)dp[i][j][k]=r+100;\n    queue<pair<int,pair<int,int>>> q;\n    lp(i,n){\n        //0->i\n        if(i==0)continue;\n        if(dist[0][i]>r-0.000001)continue;\n        dp[0][i][1]=dist[0][i];\n        q.push({0,{i,1}});\n    }\n    int ans=0;\n    while(!q.empty()){\n        int bef=q.front().first;\n        int now=q.front().second.first;\n        int cnt=q.front().second.second;\n        q.pop();\n        double dist_now=dp[bef][now][cnt];\n        //cout<<bef<<\" \"<<now<<\" \"<<dist_now<<\" \"<<cnt<<endl;\n        ans=max(cnt,ans);\n        lp(i,g[bef][now].size()){\n            int next=g[bef][now][i];\n            double dist_next=dist_now+dist[now][next];\n            if(dp[now][next][cnt+1]<=dist_next)continue;\n            if(dist_next>r)continue;\n            dp[now][next][cnt+1]=dist_next;\n            q.push({now,{next,cnt+1}});\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535;\n\nstruct Point {\n\tdouble x, y;\n\tPoint(double _x, double _y) : x(_x), y(_y) {}\n};\n\ndouble sqr(double x) {\n\treturn x*x;\n}\n\ndouble angle(double a, double b, double c) {\n\treturn acos((sqr(b) + sqr(c) - sqr(a)) / (2.0*b*c));\n}\n\ndouble dist(Point a, Point b) {\n\treturn sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\nint n;\ndouble r, T;\nvector< Point > vp;\n\nbool able[22][22][22];\ndouble dst[22][22], dp[10010][22][22];\n\nvoid update(double& a, double b) {\n\ta = min(a, b);\n}\n\nvoid solve() {\t\n\tmemset(able, 0, sizeof(able));\n\tfor_(i,0,n) able[0][0][i] = 1;\n\t\n\tfor_(i,0,n) for_(j,0,n) {\n\t\tdst[i][j] = dist(vp[i], vp[j]);\n\t\t\n\t\tif (i != j) {\n\t\t\tfor_(k,0,n) {\n\t\t\t\tif (i != k && j != k) {\n\t\t\t\t\tdouble s = angle(dist(vp[i], vp[k]), dist(vp[i], vp[j]), dist(vp[j], vp[k]));\n\t\t\t\t\tdouble t = 180. - s * 180. / PI;\n\t\t\t\t\table[i][j][k] = (t + EPS < T);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor_(i,0,10010) for_(j,0,n) for_(k,0,n) dp[i][j][k] = 1e9;\n\tdp[0][0][0] = 0;\n\t\n\tint ans = 0;\n\t\n\tfor_(i,0,10010) for_(j,0,n) for_(k,0,n) {\n\t\tif (dp[i][j][k] + EPS < r) {\n\t\t\tans = i;\n\t\t\t\n\t\t\tfor_(v,0,n) {\n\t\t\t\tif (k != v && able[j][k][v]) {\n\t\t\t\t\tupdate(dp[i+1][k][v], dp[i][j][k] + dst[k][v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> n;\n\tcin >> r >> T;\n\t\n\tfor_(i,0,n) {\n\t\tdouble x, y; cin >> x >> y;\n\t\tvp.push_back(Point(x, y));\n\t}\n\t\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define p(s) cout<<(s)<<endl;\ntypedef long long ll;\nusing namespace std;\n\nconst int ctinf=1e5;\ndouble dp[10000][21][21];//num,prev,now = minr\n\ndouble vec_len(int x1,int x2,int y1,int y2){\n\treturn sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n}\n\nint dot_pro(int x1,int x2,int x3,int y1, int y2, int y3){\n\treturn (x2-x1)*(x3-x2)+(y2-y1)*(y3-y2);\n}\n\ndouble ctcos(int x1,int x2,int x3,int y1,int y2,int y3){\n\treturn dot_pro(x1,x2,x3,y1,y2,y3)/(vec_len(x1,x2,y1,y2)*vec_len(x1,x3,y1,y3));\n}\nint main(){\n\tint n;\n\tdouble r,theta;\n\tcin>>n>>r>>theta;\n\tREP(i,0,r) REP(j,0,21) REP(k,0,21) dp[i][j][k]=ctinf;\n\tdouble co=cos(theta);\n\tint x[20],y[20];\n\tREP(i,0,n) cin>>x[i]>>y[i];\n\tint ans=0;\n\tREP(i,1,n) if(vec_len(x[0],x[i],y[0],y[i])<r)dp[1][0][i]=vec_len(x[0],x[i],y[0],y[i]);\n\t//int from,to;\n\n\tREP(i,2,r){\n\t\tREP(prev,0,n){\n\t\t\tREP(now,0,n){\n\t\t\t\tREP(next,0,n){\n\t\t\t\t\tif(prev==now||prev==next||now==next) continue;\n\t\t\t\t\tif(ctcos(x[prev],x[now],x[next],y[prev],y[now],y[next])<co)continue;\n\t\t\t\t\tif(dp[i-1][prev][now]+vec_len(x[now],x[next],y[now],y[next])<=r){\n\t\t\t\t\t\tdp[i][now][next]=min(dp[i][now][next],dp[i-1][prev][now]+vec_len(x[now],x[next],y[now],y[next]));\n\t\t\t\t\t\tans=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tp(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int MAX = 20,LIMIT = 50000,IINF = INT_MAX;\n\n// Library - template - begin\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nstruct Edge{\n  int to;\n  double weight;\n  Edge(int to=0,double weight=0):to(to),weight(weight){}\n};\n\nstruct Data{\n  int prev,cur,carrot;\n  double dist;\n  Data(int prev=0,int cur=0,int carrot=0,double dist=0):prev(prev),cur(cur),carrot(carrot),dist(dist){}\n  bool operator < (const Data& data) const{ return dist > data.dist; }\n};\n\nint n;\ndouble r,theta,mindist[MAX][MAX][LIMIT]; // mindist[cur][prev][the number of carrot]\nPoint ps[MAX];\nvector<Edge> edge[MAX][MAX]; // edge[cur][prev]\n\ninline void dijkstra(){\n  rep(i,n)rep(j,n)rep(k,LIMIT) mindist[i][j][k] = IINF;\n  priority_queue<Data> Q;\n\n  REP(i,1,n) {\n    double dist = abs(ps[0]-ps[i]);\n    if( !equals(dist,r) && dist > r ) continue;\n    Q.push(Data(0,i,1,dist));\n    mindist[i][0][1] = dist;\n  }\n  int ans = (Q.empty()?0:1);\n\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n    int prev = data.prev, cur = data.cur, carrot = data.carrot;\n    double dist = data.dist;\n\n    if( !equals(mindist[cur][prev][carrot],dist) && mindist[cur][prev][carrot] < dist ) continue;\n\n    rep(i,edge[cur][prev].size()) {\n      int next = edge[cur][prev][i].to;\n      double weight = edge[cur][prev][i].weight;\n      if( !equals(r,dist+weight) && r < dist+weight ) continue;\n      if( mindist[next][cur][carrot+1] > dist + weight ){\n        mindist[next][cur][carrot+1] = dist + weight;\n        assert(carrot+1 < LIMIT);\n        ans = max(ans,carrot+1);\n        Q.push(Data(cur,next,carrot+1,dist+weight));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\ninline void makeEdge(){\n  rep(prev,n){\n    rep(cur,n){\n      if( cur == prev ) continue;\n      rep(next,n){\n        if( next == cur || next == prev ) continue;\n        double dist = abs(ps[cur]-ps[next]);\n        if( !equals(dist,r) && dist > r ) continue;\n        Vector v1 = ps[next] - ps[cur];\n        Vector v2 = ps[cur]  - ps[prev];\n        if( equals(cross(v1,v2),0.0) ) continue;\n        double arg = getArg(ps[prev],ps[cur],ps[next]);\n        if( equals(arg,theta) || arg < theta ) edge[cur][prev].push_back(Edge(next,dist));\n      }\n    }\n  }\n}\n\nint main(){\n\n  /*\n  int next = 2, cur = 1, prev = 0;\n  ps[0] = Point(0,0);\n  ps[1] = Point(10,0);\n  ps[2] = Point(0,1);\n  double arg =  getArg(ps[prev],ps[cur],ps[next]);\n  cout << \"arg = \" << arg * 180.0 / M_PI << endl;\n  */\n\n  cin >> n;\n  cin >> r >> theta;\n  theta = toRad(theta);\n  rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n\n  makeEdge();\n\n  dijkstra();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n  \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ???\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\n// ????§???¢\ntypedef vector<Point> Polygon;\n\n// ??????/??´???\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}  \n};\ntypedef Segment Line;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2)\n{\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2)\n{\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ?°???±\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\n// ????°?\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\n// ??´?????¨?????¨????????¢\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n// ????????¨?????¨????????¢\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n// ????????????????????¢\ndouble getDistance(Segment s1, Segment s2)\n{\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n// ???????????????\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2)\n{\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\n// ???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n  // assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r*c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n// ???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c1, Circle c2)\n{\n  // assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n// ?????´????????????\nLine getPerpendicularBisector(Point p1, Point p2)\n{\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\n// ???ABC????±???????\ndouble getAngle(Point a, Point b, Point c)\n{\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\n// ????´?????§???¢?????¢???\ndouble getArea(Polygon p)\n{\n  double ret = 0.0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    ret += cross(p[i], p[(i+1)%p.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n// ????????????\nstatic const int IN_POLYGON = 2;\nstatic const int ON_POLYGON = 1;\nstatic const int OUT_POLYGON = 0;\nint contains(Polygon g, Point p)\n{\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n// ??????\nPolygon convexHull(Polygon ps)\n{\n  int N = ps.size(), j = 0;\n  Polygon pg(N*2);\n  \n  sort(ps.begin(), ps.end() [](Point p1, Point p2) -> bool {\n      return p1.y != p2.y ? lt(p1.y, p2.y) : lt(p1.x, p2.x)}); \n  for(int i = 0; i < N; i++) {\n    while(j >= 2 && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2; i >= 0; i--, j++) {\n    while(j >= k && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n/*\n// ????????¬??????\nPolygon andrewScan(Polygon s)\n{\n  Polygon u, l;\n  if(s.size() < 3) return s;\n  sort(s.begin(), s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i = 2; i < s.size(); i++) {\n    for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--) {\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n\n  for(int i = s.size()-3; i >= 0; i--) {\n    for(int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) == COUNTER_CLOCKWISE; n--) {\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(), l.end());\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n*/\n// ???????§???¢?????????\n// ???????§???¢???????????´?????§???????????????????????´???????????????\nPolygon convexCut(Polygon s, Line l)\n{\n  Polygon t;\n  for(int i = 0; i < (int)s.size(); i++) {\n    Point a = s[i], b = s[(i+1)%s.size()];\n    if(ccw(l.p1, l.p2, a) != -1) t.push_back(a);\n    if(ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0) {\n      t.push_back(getCrossPointLL(Line(a, b), l));\n    }\n  }\n  return t;\n}\n\n// ???????????????????????¢??¬?????????????????????????????????\nbool mergeIfAble(Segment &s1, Segment s2)\n{\n  if(abs(cross(s1.p2 - s1.p1, s2.p2 - s2.p1)) > EPS) return false;\n  if(ccw(s1.p1, s2.p1, s1.p2) == COUNTER_CLOCKWISE ||\n     ccw(s1.p1, s2.p1, s1.p2) == CLOCKWISE) return false;\n  if(ccw(s1.p1, s1.p2, s2.p1) == ONLINE_FRONT ||\n     ccw(s2.p1, s2.p2, s1.p1) == ONLINE_FRONT) return false;\n  s1 = Segment(min(s1.p1, s2.p1), max(s1.p2, s2.p2));\n  return true;\n}\nvoid mergeSegments(vector<Segment>& segs)\n{\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].p2 < segs[i].p1) swap(segs[i].p1, segs[i].p2);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i+1; j < segs.size(); j++) {\n      if(mergeIfAble(segs[i], segs[j])) {\n\tsegs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// ????????¢??¬???????????????\nstruct edge\n{\n  int to;\n  double cost;\n  edge(){}\n  edge(int to, double cost):to(to), cost(cost){}\n\n  bool operator < (const edge& e) const {\n    return lt(cost, e.cost);\n  }\n};\ntypedef vector< vector<edge> > Graph;\n\nGraph segmentArrangement(vector<Segment>& segs, vector<Point>& ps)\n{\n  for(int i = 0; i < segs.size(); i++) {\n    ps.push_back(segs[i].p1);\n    ps.push_back(segs[i].p2);\n    for(int j = i+1; j < segs.size(); j++) {\n      if(intersect(segs[i], segs[j])) ps.push_back(getCrossPoint(segs[i], segs[j]));\n    }\n  }\n  sort(ps.begin(), ps.end());\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n  Graph graph(ps.size());\n  for(int i = 0; i < segs.size(); i++) {\n    vector< pair<double, int> > ls;\n    for(int j = 0; j < ps.size(); j++) {\n      if(intersect(segs[i], ps[j])) {\n\tls.emplace_back(getDistanceSP(segs[i], ps[j]), j);\n      }\n    }\n    sort(ls.begin(), ls.end());\n    for(int j = 0; j+1 < ls.size(); j++) {\n      int u = ls[j].second, v = ls[j+1].second;\n      graph[u].emplace_back(v, getDistance(ps[u], ps[v]));\n      graph[v].emplace_back(u, getDistance(ps[u], ps[v]));\n    }\n  }\n  return graph;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef double R;\ntypedef complex<R> P;\nconst R PI = 3.1415926535897932384626;\n\nistream& operator>>(istream &is, P &p) {\n\tR x, y;\n\tis >> x >> y;\n\tp = P(x, y);\n\treturn is;\n}\n\nint n;\ndouble r, theta;\n\ndouble visited[401][10005];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> r >> theta; theta = theta/180.*PI;\n\tvector<P> p(n);\n\tREP(i, n) cin >> p[i];\n\tvector<vector<pair<int, double>>> g(n*n);\n\tREP(i, n)REP(j, n)REP(k, n){\n\t\tif(i==k || i==j || j==k) continue;\n\t\tif(abs(arg((p[j]-p[i]) / (p[k]-p[j]))) < theta) g[j*n+i].emplace_back(k*n+j, abs(p[k]-p[j]));\n\t}\n\tstruct State{\n\t\tint x, c;\n\t\tdouble cost;\n\t\tState(int x, int c, double cost)\n\t\t\t:x(x), c(c), cost(cost){}\n\t\tbool operator<(const State &opp) const{\n\t\t\treturn cost < opp.cost;\n\t\t}\n\t};\n\tpriority_queue<State> que;\n\tREP(i, n)REP(j, n)if(i!=j){\n\t\tif(abs(p[i]-p[j]) < r){\n\t\t\tque.emplace(j*n+i, 1, abs(p[i]-p[j]));\n\t\t\tvisited[j*n+i][1] = abs(p[i]-p[j]);\n\t\t}\n\t}\n\tint ans = 0;\n\twhile(!que.empty()){\n\t\tState s = que.top(); que.pop();\n\t\tif(s.cost > visited[s.x][s.c]) continue;\n\t\tans = max(ans, s.c);\n\t\tFOR(it, g[s.x]){\n\t\t\tint x = it->first;\n\t\t\tdouble cost = s.cost + it->second;\n\t\t\tint c = s.c + 1;\n\t\t\tauto &t = visited[x][c];\n\t\t\tif((t == 0 || t > cost) && cost < r){\n\t\t\t\tt = cost;\n\t\t\t\tque.emplace(x, c, cost);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=23,INF=1<<30;\ndouble dis[MAX][MAX][10003],d[MAX][MAX];\nbool can[MAX][MAX][MAX];//i→j→kが可能か\n\nconst double eps=1e-10;\nconst double pi=acos((long double)-1.0L);\n#define equals(a,b) (fabs((a)-(b))<eps)\n\ndouble torad(int deg) {return (double)(deg)*pi/180.0;}\ndouble todeg(double ang) {return ang*180.0/pi;}\n\nclass Point{\npublic:\n    double x,y;\n    \n    Point(double x=0,double y=0):x(x),y(y){}\n    \n    Point operator + (Point p){return Point(x+p.x,y+p.y);}\n    Point operator - (Point p){return Point(x-p.x,y-p.y);}\n    Point operator * (double a){return Point(a*x,a*y);}\n    Point operator / (double a){return Point(x/a,y/a);}\n    \n    double abs(){return sqrt(norm());}\n    double norm(){return x*x+y*y;}\n    \n    bool operator < (const Point &p)const{\n        return x!=p.x ? x<p.x : y<p.y;\n    }\n    \n    bool operator == (const Point &p)const{\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a){\n    return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nstruct Segment{\n    Point p1,p2;\n};\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nstatic const int counter_clockwise=1;\nstatic const int clockwise=-1;\nstatic const int online_back=2;\nstatic const int online_front=-2;\nstatic const int on_segment=0;\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    \n    if(cross(a,b)>eps) return counter_clockwise;\n    if(cross(a,b)<-eps) return clockwise;\n    if(dot(a,b)<-eps) return online_back;\n    if(a.norm()<b.norm()) return online_front;\n    \n    return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return(ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ntypedef Segment Line;\n\ndouble getDistance(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min({getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2),getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)});\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\npair<Point,Point> segCrossPpoints(Circle c,Line l){\n    //assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p){return atan2(p.y,p.x);}\nVector polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    //assert(intersect(c1,c2));\n    double d=abs(c1.c-c2.c);\n    double a=acos((c1.r*c1.r+d*d-c2.r-c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\ntypedef vector<Point> Polygon;\n\n/*\n IN 2\n ON 1\n OUT 0\n */\n\nint contains(Polygon g,Point p){\n    int n=int(g.size());\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<eps&&eps<b.y&&cross(a,b)>eps) x=!x;\n    }\n    return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s,bool ok){\n    Polygon u,l;\n    sort(all(s));\n    \n    if(int(s.size())<3) return s;\n    int n=int(s.size());\n    \n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    \n    l.push_back(s[n-1]);\n    l.push_back(s[n-2]);\n    \n    if(ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])==counter_clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])==counter_clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    if(!ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])!=clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])!=clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    reverse(all(l));\n    \n    for(int i=int(u.size())-2;i>=1;i--) l.push_back(u[i]);\n    \n    return l;\n}//ok==1なら辺の上も含める\n\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    double r,a;cin>>r>>a;\n    \n    vector<Point> p(N);\n    \n    for(int i=0;i<N;i++){\n        cin>>p[i].x>>p[i].y;\n    }\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            for(int k=0;k<N;k++){\n                if(i==j||j==k||i==k) continue;\n                \n                Vector s=p[k]-p[j],t=p[i]-p[j];\n                double b=dot(s,t)/(abs(s)*abs(t));\n                b=180.0-todeg(acos(b));\n                \n                d[j][k]=abs(s);\n                if(b<a+eps) can[i][j][k]=1;\n                \n                can[j][j][k]=1;\n                \n                //cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<b<<endl;\n            }\n        }\n    }\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            for(int k=0;k<10003;k++){\n                dis[i][j][k]=INF;\n            }\n        }\n    }\n    for(int i=0;i<N;i++) dis[i][0][0]=0;\n    \n    int ans=0;\n    \n    for(int t=0;t<10000;t++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                for(int k=0;k<N;k++){\n                    if((t&&i==j)||j==k) continue;\n                    if(can[i][j][k]) dis[j][k][t+1]=min(dis[j][k][t+1],dis[i][j][t]+d[j][k]);\n                    \n                    if(dis[j][k][t+1]<r+eps) ans=t+1;\n                }\n            }\n        }\n    }\n    \n    if(N==1) ans=0;\n    if(N==2){\n        Vector s=p[1]-p[0];\n        if(abs(s)<r+eps) ans=1;\n        else ans=0;\n    }\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst long double PI = 3.14159255358979323846264338327950288l;\nint n; long long r, s;\nstruct Point { long double px, py; };\nlong double theta(long double a, long double b, long double c) {\n\tlong double s = (a + b + c) / 2.0l;\n\tlong double S = sqrtl(s*(s - a)*(s - b)*(s - c));\n\tlong double A = -1000, B = -1000, C = -1000, H;\n\n\tif (a > b && a > c) { H = 2.0l * S / a; B = asin(H / c)*180.0l / PI; C = asin(H / b)*180.0l / PI; A = 180.0l - B - C; }\n\telse if (b > a && b > c) { H = 2.0l * S / b; A = asin(H / c)*180.0l / PI; C = asin(H / a)*180.0l / PI; B = 180.0l - A - C; }\n\telse { H = 2.0l * S / c; A = asin(H / b)*180.0l / PI; B = asin(H / a)*180.0l / PI; C = 180.0l - A - B; }\n\n\treturn A;\n}\nlong double theta_(Point a, Point b, Point c) {\n\t//a->b->c\n\tlong double A1 = sqrtl((a.px - c.px)*(a.px - c.px) + (a.py - c.py)*(a.py - c.py));\n\tlong double B1 = sqrtl((a.px - b.px)*(a.px - b.px) + (a.py - b.py)*(a.py - b.py));\n\tlong double C1 = sqrtl((b.px - c.px)*(b.px - c.px) + (b.py - c.py)*(b.py - c.py));\n\treturn theta(A1, B1, C1);\n}\nlong double dp[20000][30][30], r, t; Point x[30]; int n;\nint main() {\n\tcin >> n >> r >> t;\n\tfor (int i = 0; i < n; i++)cin >> x[i].px >> x[i].py;\n\tfor (int i = 0; i < 20000; i++) { for (int j = 0; j < 30; j++) { for (int k = 0; k < 30; k++) { dp[i][j][k] = 999999999.9l; } } }\n\tfor (int i = 0; i < 20000; i++) { dp[1][0][i] = sqrtl((x[0].px - x[i].px)*(x[0].px - x[i].px) + (x[0].py - x[i].py)*(x[0].py - x[i].py)); }\n\tfor (int i = 1; i < 15000; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tif (j == k || k == l)continue;\n\t\t\t\t\tlong double T = theta_(x[j], x[k], x[l]);\n\t\t\t\t\tlong double dst = sqrtl((x[k].px - x[l].px)*(x[k].px - x[l].px) + (x[k].py - x[l].py)*(x[k].py - x[l].py));\n\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][k] + dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = 0;\n\tfor (int i = 0; i < 20000; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (dp[i][j][k] <= r)maxn = max(maxn, i);\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> mid = cities[prev];\n  complex<double> dst = cities[city];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint N, A, B, C, D;\n\nint main(void) {\n  bool first = true;\n  while(cin >> N, N) {\n    cin >> A >> B >> C >> D;\n\n    int aa = 0, ab = 0, ac = 0, ad = 0, n = A + B + C + D;\n    REP(a, 0, A + 1) REP(b, 0, B + 1) REP(c, 0, C + 1) REP(d, 0, D + 1) {\n      int s = a * 10 + b * 50 + c * 100 + d * 500;\n      if(s >= N) {\n        int change = s - N;\n\n        int chd = change / 500;\n        change -= chd * 500;\n        int chc = change / 100;\n        change -= chc * 100;\n        int chb = change / 50;\n        change -= chb * 50;\n        int cha = change / 10;\n        change -= cha * 10;\n\n        int ka = A - a + cha;\n        int kb = B - b + chb;\n        int kc = C - c + chc;\n        int kd = D - d + chd;\n\n        if(n >= ka + kb + kc + kd) {\n          aa = a, ab = b, ac = c, ad = d;\n          n = ka + kb + kc + kd;\n        }\n      }\n    }\n\n    if(!first) cout << endl;\n    first = false;\n\n    if(aa > 0) cout << \"10 \" << aa << endl;\n    if(ab > 0) cout << \"50 \" << ab << endl;\n    if(ac > 0) cout << \"100 \" << ac << endl;\n    if(ad > 0) cout << \"500 \" << ad << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double, int>P;\n\ndouble x[20], y[20], d[20][20], th[20][20][20];\nvector<P>E;\nstruct st {\n\tdouble d; int p, pr, cnt;\n};\nint main() {\n\tint n; double r, t; scanf(\"%d%lf%lf\", &n, &r, &t);\n\tt = t*M_PI / 180;\n\trep(i, n)scanf(\"%lf%lf\", &x[i], &y[i]);\n\trep(i, n)for (int j = i + 1; j < n; j++)\n\t\td[i][j] = d[j][i] = hypot(x[i] - x[j], y[i] - y[j]);\n\tfill(th[0][0], th[20][20], M_PI);\n\trep(i, n)rep(j, n)for (int k = i + 1; k < n; k++) {\n\t\tif (i == j || j == k)continue;\n\t\tdouble t = abs(atan2(y[i] - y[j], x[i] - x[j]) - atan2(y[k] - y[j], x[k] - x[j]));\n\t\twhile (t >= 2 * M_PI)t -= 2 * M_PI;\n\n\t}\n\tqueue<st>que;\n\tfor (int i = 1; i < n; i++)que.push({ d[0][i],i,0,1 });\n\tint Max = 0;\n\twhile (!que.empty()) {\n\t\tst p = que.front(); que.pop();\n\t\tMax = max(Max, p.cnt);\n\t\trep(i, n) {\n\t\t\tif (p.p == i)continue;\n\t\t\tif (p.d + d[p.p][i] <= r&&th[p.pr][p.p][i] <= t) {\n\t\t\t\tque.push({ p.d + d[p.p][i],i,p.p,p.cnt + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", Max);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool check(const deque<int>& deq,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[deq[0]];\n  complex<double> mid = cities[deq[1]];\n  complex<double> dst = cities[deq[2]];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))));\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _c,double _r,const deque<int>& _d) :\n    city(_ct), carrots(_c), remaining_distance(_r),deq(_d) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    deq.push_back(_d);\n  }\n\n  bool operator <(const State& s) const{\n    if(carrots == s.carrots){\n      return remaining_distance < s.remaining_distance;\n    }\n    return carrots < s.carrots;\n  }\n};\n\nbool dp[5001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,false,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      int prev = 20;\n      if(s.deq.size() > 1) prev = *(s.deq.end()-2);\n\n      if(dp[s.carrots][prev][s.city]) continue;\n      dp[s.carrots][prev][s.city] = true;\n\n      deque<int> deq;\n      while(deq.size() > 2) deq.pop_front();\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\t\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tdeq = s.deq;\n\tdeq.push_back(to);\n\n\tif(deq.size()==3){\n\t  if(!check(deq,limit_rad,cities)) continue;\n\t}\n\tif(s.remaining_distance - dist <= 0) continue;\n\n\tque.push(State(to,s.carrots+1,s.remaining_distance - dist,deq));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define EPS 1.0e-9\n#define inf 1000000000\n\nusing namespace std;\nstruct edge{\n\tint toi, toj;\n\tdouble cost;\n\tedge(int a, int b, double c){\n\t\ttoi = a, toj = b, cost = c;\n\t}\n};\n\nint n;\ndouble r, th;\nint x[25], y[25];\nvector<edge> G[25][25];\ndouble dp[10005][25][25];\n\ndouble dot(double x1, double y1, double x2, double y2)\n{\n\treturn x1 * x2 + y1 * y2;\n}\n\ndouble norm(double x, double y)\n{\n\tdouble d2 = x*x + y*y;\n\tif(d2 == 0) return 0.0;\n\treturn sqrt(d2);\n}\n\nint main(void)\n{\n\tcin >> n >> r >> th;\n\tfor(int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\t\n\tdouble lcos = cos(th * M_PI / 180.0);\n\t\n\tdouble dx1, dx2, dy1, dy2;\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i == j) continue;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(j == k) continue;\n\t\t\t\t\n\t\t\t\tdx1 = x[j]-x[i], dy1 = y[j]-y[i];\n\t\t\t\tdx2 = x[k]-x[j], dy2 = y[k]-y[j];\n\t\t\t\tif( dot(dx1, dy1, dx2, dy2) / norm(dx1, dy1) / norm(dx2, dy2) > lcos - EPS ){\n\t\t\t\t\tG[i][j].push_back( edge(j, k, norm(dx2, dy2) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tfor(int i = 0; i <= r; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tdp[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i < n; i++) dp[1][0][i] = norm(x[i]-x[0], y[i]-y[0]);\n\t\n\t\n\tfor(int i = 1; i < r; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tfor(int l = 0; l < G[j][k].size(); l++){\n\t\t\t\t\tdp[i+1][G[j][k][l].toi][G[j][k][l].toj] = min(dp[i+1][G[j][k][l].toi][G[j][k][l].toj], dp[i][j][k] + G[j][k][l].cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = r; i >= 0; i--){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(dp[i][j][k] <= r){\n\t\t\t\t\tans = i;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tend:;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\ndouble d[2][20][20];\nbool flag[2][20][20];\nvector<int>ok[20][20];\nint N;\ndouble R,t;\nint x[20],y[20];\ndouble dis[20][20];\ndouble calc(int X,int Y)\n{\n\treturn atan2(Y,X);\n}\nmain()\n{\n\tcin>>N>>R>>t;\n\tt=t/180*M_PI;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>x[i]>>y[i];\n\t}\n\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t{\n\t\tdis[i][j]=hypot(x[i]-x[j],y[i]-y[j]);\n\t\tif(i==j)continue;\n\t\tfor(int k=0;k<N;k++)\n\t\t{\n\t\t\tif(j==k)continue;\n\t\t\tdouble A=calc(x[j]-x[i],y[j]-y[i]),B=calc(x[k]-x[j],y[k]-y[j]);\n\t\t\tdouble dif=B-A;\n\t\t\tif(dif<0)dif+=2*M_PI;\n\t\t\tif(dif>M_PI)dif=2*M_PI-dif;\n\t\t\tif(dif<t)ok[i][j].push_back(k);\n\t\t}\n\t}\n\tint ans=0;\n\tbool f=false;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tif(dis[0][i]<R)\n\t\t{\n\t\t\td[0][0][i]=R-dis[0][i];\n\t\t\tflag[0][0][i]=true;\n\t\t\tf=true;\n\t\t}\n\t}\n\tfor(int w=0;f;w=!w)\n\t{\n\t\tans++;\n\t\tf=false;\n\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)d[!w][i][j]=flag[!w][i][j]=0;\n\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(!flag[w][i][j])continue;\n\t\t\tfor(int k:ok[i][j])\n\t\t\t{\n\t\t\t\tdouble nxt=d[w][i][j]-dis[j][k];\n\t\t\t\tif(nxt>0)\n\t\t\t\t{\n\t\t\t\t\tflag[!w][j][k]=true;\n\t\t\t\t\tf=true;\n\t\t\t\t\td[!w][j][k]=max(d[!w][j][k],nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\n\nint main(){\n  int n;\n  double r, theta;\n  cin >> n >> r >> theta;\n  theta *= acos(-1)/180;\n  vector<int> X(n), Y(n);\n  for(int i = 0; i < n; ++i) cin >> X[i] >> Y[i];\n  vector< vector<double> > dp(n,vector<double>(n,0));\n  bool f = false;\n  int ans = 0;\n  /*\n  for(int i = 1; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      if(i == j) continue;\n      //int x1 = X[0] - X[i], y1 = Y[0] - Y[i], x2 = X[j] - X[i], y2 = Y[j] - Y[i];\n      int x1 = X[i] - X[0], y1 = Y[i] - Y[0], x2 = X[j] - X[i], y2 = Y[j] - Y[i];\n      if(acos((x1*x2+y1*y2)/hypot(x1,y1)/hypot(x2,y2)) < theta && \n         hypot(x2,y2) <= r){\n        f = true;\n        dp[i][j] = max(dp[i][j],r - hypot(x2,y2));\n      }\n    }\n  }\n  */\n  for(int i = 1; i < n; ++i){\n    int x1 = X[i] - X[0], y1 = Y[i] - Y[0];\n    if(hypot(x1,y1) <= r + EPS){\n      f = true;\n      dp[0][i] = r - hypot(x1,y1);\n    }\n  }\n  /*\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      cout << dp[i][j] << \" \";\n    }cout << endl;\n  }cout << endl;\n  */\n  while(f){\n    f = false;\n    ++ans;\n    vector< vector<double> > dp_(n,vector<double>(n,0));\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        if(i == j) continue;\n        for(int k = 0; k < n; ++k){\n          if(j == k) continue;\n          int x1 = X[j] - X[i], y1 = Y[j] - Y[i], x2 = X[k] - X[j], y2 = Y[k] - Y[j];\n          if(acos((x1*x2+y1*y2)/hypot(x1,y1)/hypot(x2,y2)) <= theta + EPS&& \n             hypot(x2,y2) <= dp[i][j] + EPS){\n            f = true;\n            dp_[j][k] = max(dp_[j][k],dp[i][j] - hypot(x2,y2));\n          }\n        }\n      }\n    }\n    dp = dp_;\n    /*\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        cout << dp[i][j] << \" \";\n      }cout << endl;\n    }cout << endl;\n    */\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define range(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing State = tuple<double, int, int, int>;\n\nint n;\ndouble R, theta;\n\nvector<vector<double>> dist, angle;\nvector<vvi> min_dist;\n\nconst double pi = acos(-1);\n\nint main(void){\n    cin >> n;\n    cin >> R >> theta;\n    theta *= pi / 180.0;\n\n    vector<int> x(n), y(n);\n    rep(i, n) cin >> x[i] >> y[i];\n\n    dist = angle = vector<vector<double>>(n, vector<double>(n));\n    rep(i, n){\n        rep(j, n){\n            if(i == j) continue;\n\n            int dx = x[j] - x[i], dy = y[j] - y[i];\n            dist[i][j]  = sqrt(pow(x[j] - x[i], 2) + pow(y[j] - y[i], 2));\n            angle[i][j] = atan2(dy, dx);\n        }\n    }\n\n    vector<vvi> edge(n + 1, vvi(n + 1));\n    rep(i, n){\n        rep(j, n){\n            if(i == j) continue;\n            rep(k, n){\n                if(j == k) continue;\n\n                double dtheta = angle[j][k] - angle[i][j];\n                while(dtheta < 0)      dtheta += 2 * pi;\n                while(dtheta >= 180.0) dtheta -= 2 * pi;\n\n                if(fabs(dtheta) <= theta){\n                    edge[i][j].push_back(k);\n                }\n            }\n        }\n    }\n    rep(i, n) edge[n][0].push_back(i);\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(0.0, n, 0, 0));\n\n    const int inf = R + 1234;\n    min_dist = vector<vvi>(n + 1, vvi(n + 1, vi(10001, inf)));\n\n    int res = 0;\n    while(q.size()){\n        double d;\n        int prev, v, num;\n        tie(d, prev, v, num) = q.top();\n        q.pop();\n\n        if(d > R or min_dist[prev][v][num] != inf) continue;\n        min_dist[prev][v][num] = d;\n        res = max(res, num);\n\n        for(auto & nv : edge[prev][v]){\n            if(min_dist[v][nv][num + 1] != inf) continue;\n            q.push(State(d + dist[v][nv], v, nv, num + 1));\n        }\n    }\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> P;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-7, PI = acos(-1);\n\nint n;\nP p[20];\ndouble r, t;\ndouble dp[20][20][10010], d[20][20];\nbool can[20][20][20];\n\nint main(){\n\tcin >> n >> r >> t;\n\tt *= PI / 180;\n\trep(i, n) cin >> p[i].real() >> p[i].imag();\n\t\n\trep(i, n) rep(j, n) rep(k, n) if(i != j && j != k){\n\t\tdouble a = abs(arg((p[j] - p[i]) / (p[k] - p[j])));\n\t\tcan[i][j][k] = EPS < a && a + EPS < t;\n\t}\n\trep(i, n) rep(j, n) d[i][j] = abs(p[i] - p[j]);\n\t\n\trep(i, n) rep(j, n) rep(k, 10010) dp[i][j][k] = INF;\n\trep(i, n) if(i) dp[0][i][1] = d[0][i];\n\t\n\tint ans = 0;\n\trep(k, 10010) rep(i, n) rep(j, n) if(dp[i][j][k] < r + EPS){\n\t\tans = max(ans, k);\n\t\trep(l, n) if(can[i][j][l]){\n\t\t\tdp[j][l][k + 1] = min(dp[j][l][k + 1], dp[i][j][k] + d[j][l]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct state {\n  int p, c, n;\n  double d;\n  bool operator<(const state &s) const { return d > s.d; }\n};\n\nint N, X[20], Y[20];\ndouble R, Theta;\ndouble d[20][20];\nbool angle[20][20][20];\ndouble dp[20][20][100000];\n\ndouble theta(int i, int j, int k) {\n  int x1 = X[k] - X[j], y1 = Y[k] - Y[j];\n  int x2 = X[j] - X[i], y2 = Y[j] - Y[i];\n  double l1 = sqrt(x1 * x1 + y1 * y1);\n  double l2 = sqrt(x2 * x2 + y2 * y2);\n  double iprod = x1 * x2 + y1 * y2;\n  double rad = acos(iprod / l1 / l2);\n  return rad * 180 / M_PI;\n}\n\nint main(void) {\n  cin >> N >> R >> Theta;\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n\n  REP(i, 0, N) REP(j, 0, N) {\n    d[i][j] = sqrt((X[i] - X[j]) * (X[i] - X[j]) + (Y[i] - Y[j]) * (Y[i] - Y[j]));\n  }\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, N) {\n    if(i == j || j == k || k == i) angle[i][j][k] = false;\n    else angle[i][j][k] = theta(i, j, k) <= Theta + 10e-8;\n  }\n\n  REP(i, 0, N) REP(j, 0, N) REP(k, 0, 100000) dp[i][j][k] = 1e10;\n\n  priority_queue<state> q;\n  REP(i, 1, N) q.push((state) { 0, i, 1, d[0][i] });\n\n  int ans = 0;\n  while(q.size()) {\n    state c = q.top();\n    q.pop();\n\n    if(dp[c.p][c.c][c.n] <= c.d) continue;\n    dp[c.p][c.c][c.n] = c.d;\n\n    ans = max(ans, c.n);\n\n    REP(i, 0, N) if(angle[c.p][c.c][i]) {\n      double nd = c.d + d[c.c][i];\n      if(nd <= R + 1e-8) q.push((state) { c.c, i, c.n + 1, nd });\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2233&lang=jp\ntypedef long long ll;\ntypedef long double ld;\n#define INF 1<<30\n#define LINF 1<<60\nconst double eps = 1e-9;\n\ninline double calc_w(int c1,int pre_c1, int c2,int pre_c2, vector<pair<int, int>>& city) {\n\tdouble l1_x = city[c1].first - city[pre_c1].first;\n\tdouble l1_y = city[c1].second - city[pre_c1].second;\n\n\tdouble l2_x = city[c2].first - city[pre_c2].first;\n\tdouble l2_y = city[c2].second - city[pre_c2].second;\n\n\tdouble _cos = (l1_x*l2_x + l1_y*l2_y) / (double)(hypot(l1_x, l1_y)*hypot(l2_x, l2_y));\n\tif (1 - _cos < eps)return 0.0;\n\tif (1 + _cos < eps)return 180.0;\n\treturn abs(acos(_cos) * 180 / acos(-1));\n}\n\nstruct edge {\n\tint now_city;\n\tint pre_city;\n\tdouble full_len;\n\tedge() {}\n\tedge(int now, int pre, double len) :now_city(now), pre_city(pre), full_len(len) {}\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t/* input */\n\tint n; cin >> n;\n\tdouble r, theta; cin >> r >> theta;\n\tvector<pair<int, int>> city(n);\n\tfor (int i = 0; i < n;i++) { int x, y; cin >> x >> y; city[i] = { x,y }; }\n\n\t/* initialize */\n\t/* carrot[i][j] := the number of carrots from j-th city to i-th city */\n\tvector<vector<int>> carrot(n, vector<int>(n, 0));\n\t/* dist[i][j] := distance between i-th city and j-th city */\n\tvector<vector<double>> dist(n, vector<double>(n,0));\n\t/* w[i][j][k] := w between i-j line and j-k line */\n\tvector<vector<vector<double>>> w(n, vector<vector<double>>(n, vector<double>(n, 0)));\n\n\tqueue<edge> q;\n\tfor (int i = 0; i < n;i++) {\n\t\tfor (int j = i + 1; j < n;j++) {\n\t\t\tdouble d = hypot(city[i].first - city[j].first, city[i].second - city[j].second);\n\t\t\tdist[i][j] = dist[j][i] = d;\n\t\t\tif ((i == 0) && (d <= r)) {\n\t\t\t\tcarrot[j][i] = 1;\n\t\t\t\tq.push(edge(j, i, d));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n;i++) {\n\t\tfor (int j = 0; j < n;j++) {\n\t\t\tfor (int k = 0; k < n;k++) {\n\t\t\t\tif (i == j || j == k || i == k)continue;\n\t\t\t\tw[i][j][k] = calc_w(j, i, k, j, city);\n\t\t\t\t//cout << w[i][j][k] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!q.empty()) {\n\t\tauto p = q.front(); q.pop();\n\t\tint now_city = p.now_city, pre_city = p.pre_city;\n\t\tdouble len = p.full_len;\n\t\tfor (int next_city = 0; next_city < n;next_city++) {\n\t\t\tif (next_city == now_city || next_city == pre_city)continue;\n\t\t\tif (w[pre_city][now_city][next_city] <= theta &&  dist[now_city][next_city] + len <= r) {\n\t\t\t\tif (carrot[next_city][now_city] < carrot[now_city][pre_city] + 1) {\n\t\t\t\t\tcarrot[next_city][now_city] = carrot[now_city][pre_city] + 1;\n\t\t\t\t\tq.push(edge(next_city, now_city, dist[now_city][next_city] + len));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0;i < n;i++) {\n\t\tfor (int j = 0; j < n;j++) {\n\t\t\tans = max(ans, carrot[i][j]);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\n\ninline double dist(int i,int j){\n\tint dx=(x[i]-x[j]);\n\tint dy=(y[i]-y[j]);\n\treturn sqrt(1.0*dx*dx+1.0*dy*dy);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tdouble r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tdp[0][0][n]=0.0;\n\n\trep(i,limit)rep(cp,n)rep(pp,n+1){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(i>0&&pp==n) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tdouble add=dist(cp,np);\n\t\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\t\tdouble dot=1.0*cx*nx+1.0*cy*ny;\n\t\t\tdot/=(dist(cp,pp)*dist(np,cp));\n\t\t\tdouble angle=acos(dot);\n\t\t\tangle*=180.0/pi;\n\n\t\t\tif(angle>180.0) angle=360.0-angle;\n\t\t\tif(pp!=n&&angle>theta) continue;\n\t\t\tif(abs(dp[i][cp][pp]+add-r)>eps) continue;\n\t\t\tdp[i+1][np][cp]=min(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,limit+1)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]<=r+eps) ans=max(ans,i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 30;\nint x[N], y[N];\n\nint dist[10010][N][N];\n\nvector<int> G[N][N];\ndouble D[N][N];\n\nconst double PI = 4 * atan(1);\nconst double EPS = 1e-9;\n\nint main(){\n\tint n;\n\tdouble r, theta;\n\tcin >> n >> r >> theta;\n\ttheta = theta / 180 * PI;\n\trep(i, n) cin >> x[i] >> y[i];\n\n\trep(i, n) rep(j, n){\n\t\tD[i][j] = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));\n\t}\n\n\trep(i, n) rep(j, n) rep(k, n){\n\t\tif (i == j || j == k) continue;\n\t\tdouble x1 = x[j] - x[i], y1 = y[j] - y[i];\n\t\tdouble x2 = x[k] - x[j], y2 = y[k] - y[j];\n\n\t\tdouble ct = (x1*x2 + y1*y2) / (D[i][j]*D[j][k]);\n\t\tdouble t = acos(ct);\n\n\t\tif (abs(t) < theta + EPS) G[i][j].push_back(k);\n\t}\n\n\tMEMSET(dist, 0x7f);\n\tpriority_queue<tuple<double, int, int, int>> pq;\n\n\trep(i, n) rep(j, n){\n\t\tif (i == j) continue;\n\t\tif (D[i][j] > r - EPS) continue;\n\t\tpq.emplace(-D[i][j], 1, i, j);\n\t}\n\n\tint ans = 0;\n\twhile (!pq.empty()){\n\t\tauto t = pq.top();\n\t\tpq.pop();\n\t\tdouble d;\n\t\tint c, prv, cur;\n\t\ttie(d, c, prv, cur) = t;\n\t\td = -d;\n\n\t\tif (dist[c][prv][cur] + EPS < d) continue;\n\n\t\tans = max(ans, c);\n\n\t\tfor (auto v : G[prv][cur]){\n\t\t\tdouble nd = d + D[cur][v];\n\t\t\tif (r < nd + EPS) continue;\n\t\t\tif (dist[c + 1][cur][v] < nd + EPS) continue;\n\t\t\tdist[c + 1][cur][v] = nd;\n\t\t\tpq.emplace(-nd, c + 1, cur, v);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define p(s) cout<<(s)<<endl;\nusing namespace std;\n\nconst int ctinf=1e5;\ndouble dp[10000][21][21];//num,prev,now = minr\n\nint dot_pro(int x1,int x2,int x3,int y1, int y2, int y3){\n\treturn (x2-x1)*(x3-x2)+(y2-y1)*(y3-y2);\n}\n\ndouble ctcos(int x1,int x2,int x3,int y1,int y2,int y3){\n\treturn dot_pro(x1,x2,x3,y1,y2,y3)/(hypot(x2-x1,y2-y1)*hypot(x3-x2,y3-y2));\n}\nint main(){\n\tint n;\n\tdouble r,theta;\n\tcin>>n>>r>>theta;\n\tREP(i,0,r) REP(j,0,21) REP(k,0,21) dp[i][j][k]=ctinf;\n\tdouble co=cos(theta*M_PI/180.0);\n\tint x[20],y[20];\n\tREP(i,0,n) cin>>x[i]>>y[i];\n\tint ans=0;\n\tvector<int> ok[21][21];\n\tdouble len[21][21];\n\tREP(prev,0,n) REP(now,prev+1,n) len[prev][now]=len[now][prev]=hypot(x[now]-x[prev],y[now]-y[prev]);\n\tREP(prev,0,n) REP(now,0,n){\n\t\tif(prev==now) continue;\n\t\tREP(next,0,n){\n\t\t\tif(prev==next||now==next) continue;\n\t\t\tif(ctcos(x[prev],x[now],x[next],y[prev],y[now],y[next])<co)continue;\n\t\t\tok[prev][now].push_back(next);\n\n\t\t}\n\t}\n\n\tREP(i,1,n) {\n\t\tif(len[0][i]<r){\n\t\t\tdp[1][0][i]=len[0][i];\n\t\t\tans=1;\n\t\t}\n\t}\n\tREP(i,2,r){\n\t\tREP(prev,0,n){\n\t\t\tREP(now,0,n){\n\t\t\t\tif(prev==now) continue;\n\t\t\t\tfor(auto next:ok[prev][now]){\n\t\t\t\t\tif(dp[i-1][prev][now]+len[now][next]<=r){\n\t\t\t\t\t\tdp[i][now][next]=min(dp[i][now][next],dp[i-1][prev][now]+len[now][next]);\n\t\t\t\t\t\tans=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tp(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntypedef long double D;\nconst D eps = 1e-10;\nconst D pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nD dp[10010][21][21];\nint x[20],y[20];\n\ninline D dist(int i,int j){\n\tint dx=(x[i]-x[j]);\n\tint dy=(y[i]-y[j]);\n\treturn sqrt(1.0*dx*dx+1.0*dy*dy);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tD r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tdp[0][0][n]=0.0;\n\n\trep(i,limit)rep(cp,n)rep(pp,n+1){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(i>0&&pp==n) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tD add=dist(cp,np);\n\t\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\t\tD dot=1.0*cx*nx+1.0*cy*ny;\n\t\t\tdot/=(dist(cp,pp)*dist(np,cp));\n\t\t\tD angle=acos(dot);\n\t\t\tangle*=180.0/pi;\n\n\t\t\tif(angle>180.0) angle=360.0-angle;\n\t\t\tif(pp!=n&&angle>theta+eps) continue;\n\t\t\tif(dp[i][cp][pp]+add-r>eps) continue;\n\t\t\tdp[i+1][np][cp]=min(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,limit+1)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]<=r+eps) ans=max(ans,i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nconst int MOD = 1000000007;\n\ntemplate <typename T>\nvoid __dump__(std::ostream &os, const T &first) {\n    os << first;\n}\ntemplate <typename First, typename... Rest>\nvoid __dump__(std::ostream &os, const First &first, const Rest &... rest) {\n    os << first << \", \";\n    __dump__(os, rest...);\n}\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __dump__(os, __VA_ARGS__);                        \\\n        std::cerr << os.str() << std::endl;               \\\n    } while (0)\n\nusing P = complex<double>;\nP ps[21];\n\nconst double EPS = 1e-9;\nconst double INF = 1e9;\nvector<int> go[21][21];\ndouble dp[10001][21][21];\ndouble d[21][21];\n\nint main() {\n    int n;\n    double r, th;\n    cin >> n >> r >> th;\n    th = r*acos(-1)/180;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        ps[i] = P(x, y);\n    }\n    rep(i, n) rep(j, n) {\n        if (i == j) continue;\n        go[i][j].clear();\n        rep(k, n) {\n            if (j == k) continue;\n            double phi = arg((ps[k] - ps[j]) / (ps[j] - ps[i]));\n            if (abs(phi) < th + EPS) {\n                go[i][j].push_back(k);\n                //dump(i, j, k);\n            }\n        }\n        d[i][j] = abs(ps[i] - ps[j]);\n    }\n    rep(i, 10001) rep(j, 21) rep(k, 21) dp[i][j][k] = INF;\n    rep(i, n) dp[1][0][i] = d[0][i];\n    FOR(i, 1, 10001) {\n        rep(j, n) rep(k, n) {\n            for (auto &l : go[j][k]) {\n                dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][k] + d[k][l]);\n            }\n        }\n    }\n    double ans = INF;\n    rrep(i, 10001) rep(j, n) rep(k, n) {\n        if (dp[i][j][k] <= r + EPS) {\n            ans = i;\n            goto END;\n        }\n    }\n END:;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nconst int MAX_N = 20;\nconst double EPS = 1e-9;\nint x[MAX_N], y[MAX_N];\nbool can_move[MAX_N][MAX_N][MAX_N];\ndouble dist[MAX_N][MAX_N], dp[10001][MAX_N][MAX_N];\n\ndouble turn(int ax, int ay, int bx, int by) {\n\tconst double dot = ax * bx + ay * by, a_d = hypot(ax, ay), b_d = hypot(bx, by);\n\treturn M_PI - fabs(acos(dot / (a_d * b_d)));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tdouble r, theta;\n\tcin >> n >> r >> theta;\n\ttheta = theta * M_PI / 180.0;\n\n\tfor(int i = 0; i < n; ++i)\n\t\tcin >> x[i] >> y[i];\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(i == j)\n\t\t\t\tcontinue;\n\n\t\t\tfor(int k = i + 1; k < n; ++k) {\n\t\t\t\tif(j == k)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tconst double a = turn(x[i] - x[j], y[i] - y[j], x[k] - x[j], y[k] - y[j]);\n\t\t\t\tif(a + EPS < theta)\n\t\t\t\t\tcan_move[i][j][k] = can_move[k][j][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i)\n\t\tfor(int j = i + 1; j < n; ++j)\n\t\t\tdist[i][j] = dist[j][i] = hypot(x[i] - x[j], y[i] - y[j]);\n\n\tfor(int i = 1; i <= 10000; ++i)\n\t\tfor(int j = 0; j < n; ++j)\n\t\t\tfor(int k = 0; k < n; ++k)\n\t\t\t\tdp[i][j][k] = INT_MAX;\n\n\tfor(int i = 0; i < n; ++i)\n\t\tif(i != 0)\n\t\t\tdp[1][0][i] = dist[0][i];\n\n\tint ans = 0;\n\tfor(int i = 1; i <= 10000; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tfor(int k = 0; k < n; ++k) {\n\t\t\t\tif(dp[i][j][k] + EPS < r) {\n\t\t\t\t\tans = i;\n\t\t\t\t\tfor(int l = 0; l < n; ++l)\n\t\t\t\t\t\tif(can_move[j][k][l])\n\t\t\t\t\t\t\tchmin(dp[i + 1][k][l], dp[i][j][k] + dist[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\t\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> mid = cities[prev];\n  complex<double> dst = cities[city];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[3001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      max_carrots = max(s.carrots,max_carrots);\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n#define F first\n#define S second\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<double,int>P1;\ntypedef pair<int,int>P2;\ntypedef pair<P1,P2>P3;\nint n,ans;\nP p[21];\nD r,qu,dp[10001][21][21];\nint main(){\n  cin>>n>>r>>qu;\n  rep(i,10001)rep(j,21)rep(k,21)dp[i][j][k]=1e15;\n  rep(i,n){\n    D x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<P3,vector<P3>,greater<P3> >q;\n  for(int i=1;i<n;i++){\n    dp[1][0][i]=abs(p[0]-p[i]);\n    q.push(P3(P1(dp[1][0][i],1),P2(0,i)));\n  }\n  while(!q.empty()){\n    P3 ppp=q.top();q.pop();\n    int pre=ppp.S.F;\n    int now=ppp.S.S;\n    int num=ppp.F.S;\n    double cost=ppp.F.F;\n    if(dp[num][pre][now]<cost)continue;\n    rep(i,n)if(now!=i){\n      D a=abs(p[pre]-p[now]);\n      D b=abs(p[now]-p[i]);\n      D c=abs(p[i]-p[pre]);\n      D radi=acos((a*a+b*b-c*c)/(2*a*b));\n      radi=radi/M_PI*180;\n      if(180.0-radi > qu)continue;\n      if(cost+abs(p[now]-p[i])>r)continue;\n      if(dp[num+1][now][i]<cost+abs(p[now]-p[i]))continue;\n      dp[num+1][now][i]=cost+abs(p[now]-p[i]);\n      q.push(P3(P1(dp[num+1][now][i],num+1),P2(now,i)));\n    }\n  }\n  for(int i=10000;i>=0;i--){\n    rep(j,21)rep(k,21)if(dp[i][j][k]!=1e15){\n      cout<<i<<endl;\n      return 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\n#define EPS 1e-6\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ndouble dis(Point a, Point b){ return abs(a - b); }\ndouble dot(Point a, Point b){ return a.real() * b.real() + a.imag() * b.imag(); }\n\n//テッツシツ津」ツ?、テ」ツ?ョテ」ツδ凖」ツつッテ」ツδ暗」ツδォABテ」ツ?ョテ」ツ?ェテ」ツ?凖ィツァツ津・ツコツヲテ篠クテ」ツつ津ヲツアツづ」ツつ?」ツつ?(テ」ツδ催」ツδε」ツδ暗」ツ?凝」ツつ嘉ヲツ仰セテ」ツ?」テ」ツ?ヲテ」ツ?催」ツ?淌」ツつづ」ツ?ョテ」ツ?ョテ、ツクツクテ」ツつウテ」ツδ?\ndouble AngleOf2Point(Point A, Point B){\n  //テ」ツ??「ツ?サテ」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?ョテゥツ閉キテ」ツ?陛」ツ??テ」ツ??」ツ?ィテァツュツ氾」ツ?暗」ツ?古・ツ?コテ」ツ?セテ」ツ?崚」ツつ禿」ツ?ョテ」ツ?ァテヲツウツィテヲツ?湘」ツ?療」ツ?ヲテ」ツ?湘」ツ??」ツ?陛」ツ??」ツ??\n\n  //テ」ツδ凖」ツつッテ」ツδ暗」ツδォAテ」ツ?ィBテ」ツ?ョテゥツ閉キテ」ツ?陛」ツつ津ィツィツ暗ァツョツ療」ツ?凖」ツつ?\n  double length_A = sqrt(A.real() * A.real() + A.imag() * A.imag());\n  double length_B = sqrt(B.real() * B.real() + B.imag() * B.imag());\n  \n  //テ・ツ??ァツゥツ催」ツ?ィテ」ツδ凖」ツつッテ」ツδ暗」ツδォテゥツ閉キテ」ツ?陛」ツつ津、ツスツソテ」ツ?」テ」ツ?ヲcosテ篠クテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n  double cos_sita = dot(A, B) / (length_A * length_B );\n  \n  //cosテ篠クテ」ツ?凝」ツつ嘉篠クテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n  double sita = acos( cos_sita );\t\n  \n  //テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ァテ」ツ?ェテ」ツ??テッツスツ?80テ」ツ?ョティツァツ津・ツコツヲテ」ツ?ァテ」ツ?サテ」ツ?療」ツ??・ツ?エテ・ツ青暗」ツ?ッテ」ツつウテ」ツδ。テ」ツδウテ」ツδ暗・ツ、ツ姪」ツ??\n  sita = sita * 180.0 / M_PI;\n  \n  return sita;\n}\n\n\ndouble AngleOf2Line(Line A, Line B){ return AngleOf2Point(A.first - A.second, B.first - B.second); }\n\n\nint main(void){\n  int n;\n  double r, theta;\n  cin >> n >> r >> theta;\n\n  int x, y;\n  vector<Point> town;\n  for(int i = 0; i < n; i++){\n    cin >> x >> y;\n    town.push_back(Point(x, y));\n  }\n\n  // adj[i][j]: jテ」ツ?凝」ツつ永テ」ツ?ォテ」ツ?催」ツ?淌・ツセツ古」ツ?ォテゥツ?キテァツァツサテ」ツ?ァテ」ツ?催」ツつ凝ゥツ?づァツつケテ」ツδェテ」ツつケテ」ツδ?\n  vector<vector<vector<int> > > adj(n, vector<vector<int> >(n));\n  for(int i = 0; i < n; i++)\n    for(int j = 0; j < n; j++)\n      for(int k = 0; k < n; k++)\n        if(i != j && i != k)\n          if(AngleOf2Line(make_pair(town[j], town[i]), make_pair(town[i], town[k])) <= theta + EPS)\n            adj[i][j].push_back(k);\n\n  int int_r = (int)r + 1;\n  vector<vector<vector<double> > > dp(n, vector<vector<double> >(n, vector<double>(int_r, INF)));\n  for(int now = 0; now < n; now++){ dp[now][0][0] = dis(town[0], town[now]); }\n  for(int carrot = 0; carrot < int_r - 1; carrot++){\n    for(int now = 0; now < n; now++){\n      for(int prev = 0; prev < n; prev++){\n        for(size_t i = 0; i < adj[now][prev].size(); i++){\n          int next = adj[now][prev][i];\n          dp[next][now][carrot + 1] = min(dp[next][now][carrot + 1],\n                                          dp[now][prev][carrot] + dis(town[now], town[next]));\n        }\n      }\n    }\n  }\n\n  int ans = -1;\n  for(int carrot = 0; carrot < int_r; carrot++)\n    for(int now = 0; now < n; now++)\n      for(int prev = 0; prev < n; prev++)\n        if(dp[now][prev][carrot] <= r + EPS)\n          ans = carrot;\n\n  cout << ans + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<map>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double EPS=0.000000001;\ndouble r,theta;\n\nbool is_ok(P a,P b,P c){\n\tP in=b-a,out=c-b;\n\tdouble dot=in.real()*out.real()+in.imag()*out.imag();\n//\tcout<<in<<out<<endl;\n//\tcout<<\"check \"<<cos(theta)<<\" \"<<dot/(abs(in)*abs(out))<<endl;\n\tif(cos(theta)<dot/(abs(in)*abs(out))) return true;\n\treturn false;\n}\n\nclass Idx{\npublic:\n\tint num,bef,now;\n\tIdx(int bef,int now,int num):bef(bef),now(now),num(num){}\n};\n\nclass Info{\npublic:\n\tIdx idx;\n\tdouble sum_r;\n\tInfo(Idx idx,double sum_r):idx(idx),sum_r(sum_r){}\n};\n\nbool operator < (Idx a,Idx b){\n\tif(a.bef!=a.bef) return a.bef<b.bef;\n\tif(a.now!=b.now) return a.now<b.now;\n\treturn a.num<b.num;\n}\n\nbool operator <(Info a,Info b){\n\treturn a.sum_r<b.sum_r;\n}\n\nint main()\n{\n\tint n;\n\tcin>>n>>r>>theta;\n\tvector<P> V;\n\tfor(int i=0;i<n;i++){\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tV.push_back(P(a,b));\n\t}\n\tmap<Idx,double> memo;\n\tpriority_queue<Info> que;\n\tfor(int i=1;i<n;i++){\n\t\tif(abs(V[i]-V[0])<r)\n\t\t\tque.push(Info(Idx(0,i,1),abs(V[i]-V[0])));\n\t}\n\n\tint ans=0;\n\twhile(!que.empty()){\n\t\tInfo t=que.top();\n\t\tque.pop();\n//\t\tcout<<memo[t.idx]<<\" \"<<t.sum_r+EPS<<endl;\n\t\tif(t.sum_r>EPS+r) continue;\n\t\tif(memo[t.idx]>t.sum_r+EPS) continue;\n\t\tans=max(ans,t.idx.num);\n\t\tint before=t.idx.bef,now=t.idx.now;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i==t.idx.now) continue;\n\t\t\tif(is_ok(V[t.idx.bef],V[t.idx.now],V[i])){\n\t\t\t\tque.push(Info(Idx(now,i,t.idx.num+1),t.sum_r+abs(V[i]-V[now])));\n\t\t\t}\n\t\t}\n\n\t}\n\tcout<<ans<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\n\nint n;\ndouble r,d;\nP p[20];\ndouble dp[10001][20][20];\n\nbool check(int a,int b,int c){\n  if(b==c)return 0;\n  if(a==b)return 1;\n  P o=p[b]-p[a],s=p[c]-p[b];\n  s*=conj(o);\n  return real(s/abs(s))>=cos(M_PI*d/180);\n}\n\nint main(){\n  cin>>n>>r>>d;\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)dp[i][j][k]=1e9;\n  dp[0][0][0]=0;\n\n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tfor(int l=0;l<n;l++)\n\t  if(check(j,k,l))\n\t    dp[i+1][k][l]=min(dp[i+1][k][l],dp[i][j][k]+abs(p[k]-p[l]));\n\n  int ans=0;\n  for(int i=1;i<=r;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tif(dp[i][j][k]<=r)ans=i;\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntypedef long double D;\nconst D eps = 1e-10;\nconst D pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble dp[10010][21][21];\nint x[20],y[20];\n\ninline D dist(int i,int j){\n\tint dx=(x[i]-x[j]);\n\tint dy=(y[i]-y[j]);\n\treturn sqrt(1.0*dx*dx+1.0*dy*dy);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tD r,theta;\n\tcin >> r >> theta;\n\tint limit=1*r;\n\n\trep(i,n) cin >> x[i] >> y[i];\n\n\trep(i,limit+1)rep(j,n+1)rep(k,n+1) dp[i][j][k]=inf;\n\tdp[0][0][n]=0.0;\n\n\trep(i,limit)rep(cp,n)rep(pp,n+1){\n\t\tif(dp[i][cp][pp]==inf) continue;\n\t\tif(i>0&&pp==n) continue;\n\t\tif(cp==pp) continue;\n\t\trep(np,n){\n\t\t\tif(np==cp) continue;\n\t\t\tD add=dist(cp,np);\n\t\t\tint cx=x[cp]-x[pp],cy=y[cp]-y[pp];\n\t\t\tint nx=x[np]-x[cp],ny=y[np]-y[cp];\n\t\t\tD dot=1.0*cx*nx+1.0*cy*ny;\n\t\t\tdot/=(dist(cp,pp)*dist(np,cp));\n\t\t\tD angle=acos(dot);\n\t\t\tangle*=180.0/pi;\n\n\t\t\tif(angle>180.0) angle=360.0-angle;\n\t\t\tif(pp!=n&&angle>theta+eps) continue;\n\t\t\tif(dp[i][cp][pp]+add-r>eps) continue;\n\t\t\tdp[i+1][np][cp]=min(dp[i+1][np][cp],dp[i][cp][pp]+add);\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,limit+1)rep(cp,n)rep(pp,n){\n\t\tif(dp[i][cp][pp]<=r+eps) ans=max(ans,i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <algorithm>\n#undef max\n#undef min\n\nstruct Node {\n    int pos = 0;\n    int carrot = 0;\n    float len = 0;\n};\n\nint main() {\n    int n; float r, theta;\n    float angleTable[20][20][20] = { 0 };\n    float dist[20][20] = { 0 };\n    std::vector<float> memo[20];\n    std::vector<std::pair<int, int>> city;\n    std::cin >> n >> r >> theta;\n    theta /= 180.f;\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        city.push_back(std::make_pair(x, y));\n    }\n\n    // memo初期化\n    for (auto& x : memo) {\n        x.push_back(0.f);\n    }\n\n    // 都市間移動の角度と距離を計算\n    for (int i = 0; i < city.size(); i++) {\n        for (int j = 0; j < city.size(); j++) {\n            if (i == j) continue;\n            for (int k = 0; k < city.size(); k++) {\n                if (i == k) continue;\n                float vx[2] = { (float)(city[j].first - city[i].first) , (float)(city[k].first - city[i].first) };\n                float vy[2] = { (float)(city[k].second - city[i].second) , (float)(city[k].second - city[i].second) };\n                float jLen = std::sqrt(vx[0] * vx[0] + vy[0] + vy[0]);\n                float kLen = std::sqrt(vx[1] * vx[1] + vy[1] * vy[1]);\n                float dot = vx[0] * vx[1] + vy[0] * vy[1];\n                angleTable[i][j][k] = M_PI_2 - std::acos(dot / (jLen * kLen));\n            }\n            float vx = city[j].first - city[i].first;\n            float vy = city[j].second - city[i].second;\n            dist[i][j] = std::sqrt(vx * vx + vy * vy);\n        }\n    }\n\n    std::stack<Node> s;\n    int maxCarrot = 0;\n    s.push({0, 0, 0.f});\n\n    while (!s.empty()) {\n        auto node = s.top(); s.pop();\n        for (int i = 0; i < city.size(); i++) {\n            if (i == node.pos) continue;\n            auto next = node;\n            \n            next.len += dist[node.pos][i];\n            if (next.len >= r) continue;\n\n            next.pos = i;\n            next.carrot++;\n\n            if (memo[i].size() <= next.carrot) {\n                int m = memo[i].size();\n                for (int j = 0; j < next.carrot - m; j++) {\n                    memo[i].push_back(memo[i].back());\n                }\n                memo[i].push_back(next.carrot);\n            }\n            else {\n                if (memo[i][next.carrot] <= next.len) continue; // もっと短い距離で同数の人参に到達\n            }\n            maxCarrot = std::max(maxCarrot, next.carrot);\n            s.push(next);\n        }\n    }\n    std::cout << maxCarrot << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-4)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nint n;\ndouble dp[10001][21][21]={};\ndouble x[21],y[21],r,s;\nbool b[21][21][21]={};\n\ndouble abs(int a,int b){\n  return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n}\n\ndouble dot(int i,int j,int k){\n  return (x[i]-x[j])*(x[k]-x[j])+(y[i]-y[j])*(y[k]-y[j]);\n}\n\nint main()\n{\n  cin>>n>>r>>s;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tif(i==j || j==k || i==k){\n\t  b[i][j][k]=false;\n\t  continue;\n\t}\n\tdouble R=acos(dot(i,j,k)/(double)(abs(i,j)*abs(j,k)));\n\tR=R*360/(2.0*pi);\n\tR=min(R,360-R);\n\tif(((180-R)-s)<eps)b[i][j][k]=true;\n\telse b[i][j][k]=false;\n      }\n    }\n  }\n\n  for(int i=0;i<10001;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tdp[i][j][k]=inf;\n\n  int ans=0;\n  for(int i=1;i<n;i++){\n    dp[0][0][i]=abs(0,i);\n    if(dp[0][0][i]<r)ans=1;\n  }\n\n  for(int c=1;c<10001;c++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  if(b[i][j][k]){\n\t    dp[c][j][k]=min(dp[c][j][k],dp[c-1][i][j]+abs(k,j));\n\t    if(dp[c][j][k]-r<eps)ans=max(c+1,ans);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nbool check(int city,int prev,int old,double limit_rad,\n\t   const vector<complex<double> >& cities){\n  complex<double> src = cities[old];\n  complex<double> mid = cities[prev];\n  complex<double> dst = cities[city];\n\n  src -= mid;\n  dst -= mid;\n\n  return (limit_rad >= M_PI - min(abs(arg(src) - arg(dst)),\n\t\t\t\t  abs(2.0*M_PI - arg(src) - arg(dst))) - EPS);\n}\nclass State {\npublic:\n  int carrots;\n  int city;\n  int prev;\n  int old;\n  double remaining_distance;\n  deque<int> deq;\n  State(int _ct,int _p,int _o,int _c,double _r) :\n    city(_ct),prev(_p),old(_o), carrots(_c), remaining_distance(_r) {}\n\n  State(int _ct,int _c,double _r,int _d) :\n    city(_ct), carrots(_c), remaining_distance(_r) {\n    prev = 20;\n    old = 20;\n  }\n\n  bool operator <(const State& s) const{\n    return remaining_distance < s.remaining_distance;\n  }\n};\n\ndouble dp[3001][21][21]; //dp[carrot][prev][now] := remaining distance\n\nint main(){\n  int total_cities;\n  while(~scanf(\"%d\",&total_cities)){\n    double r,theta;\n    vector<complex<double> > cities;\n    scanf(\"%lf %lf\",&r,&theta);\n    double limit_rad = theta * M_PI / 180.0;\n    for(int city_idx = 0; city_idx < total_cities; city_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cities.push_back(complex<double>(x,y));\n    }\n\n    priority_queue<State> que;\n    que.push(State(0,0,r,0));\n    int max_carrots = 0;\n    memset(dp,0,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.carrots][s.prev][s.city] >= s.remaining_distance - EPS) continue;\n      dp[s.carrots][s.prev][s.city] = s.remaining_distance;\n      max_carrots = max(s.carrots,max_carrots);\n\n      for(int to=0;to<cities.size();to++){\n\tif(to == s.city) continue;\n\tdouble dist = abs(cities[to] - cities[s.city]);\n\tif(s.remaining_distance - dist - EPS < 0) continue;\n\n\tint next_city = to;\n\tint next_prev = s.city;\n\tint next_old = s.prev;\n\tif(next_old != 20){\n\t  if(!check(next_city,next_prev,next_old,limit_rad,cities)) continue;\n\t}\n\tque.push(State(next_city,next_prev,next_old,\n\t\t       s.carrots+1,s.remaining_distance - dist));\n      }\n    }\n\n    printf(\"%d\\n\",max_carrots);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n#define LT(x,y) ((x)-(y)<=-EPS)\n\ndouble dot(P a, P b) {\n\treturn a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble angle_ls(P a, P b, P c) {\n\tP v1 = b-a, v2 = c-b;\n\treturn acos(dot(v1, v2)/(abs(v1)*abs(v2)));\n}\n\ndouble to_radian(double degree) {\n\treturn degree*PI/180;\n}\n\ndouble to_degree(double radian) {\n\treturn radian*180/PI;\n}\n\nint main() {\n\tint n;\n\tdouble r, t;\n\tcin >> n >> r >> t;\n\n\tvector<P> pts(n);\n\tREP(i, n) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpts[i] = P(x, y);\n\t}\n\n\tvector<vvd> dist(n, vvd(n, vd(n, INF)));\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tif(i == j) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP(k, n) {\n\t\t\t\tif(i == k || j == k) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble angle = to_degree(angle_ls(pts[i], pts[j], pts[k]));\n\t\t\t\tif(LT(angle, t)) {\n\t\t\t\t\tdist[i][j][k] = abs(pts[k]-pts[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vvd> dp(10000+1, vvd(n, vd(n, INF)));\n\tFOR(i, 1, n-1) {\n\t\tdouble d = abs(pts[i]-pts[0]);\n\t\tif(LT(d, r)) {\n\t\t\tdp[1][0][i] = d;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tFOR(c, 2, 10000) {\n\t\tbool updated = false;\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tdouble d = dp[c-1][i][j];\n\t\t\t\tif(EQ(d, INF)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tdouble nd = d + dist[i][j][k];\n\t\t\t\t\tif(LT(nd, r) && LT(nd, dp[c][j][k])) {\n\t\t\t\t\t\tans = c;\n\t\t\t\t\t\tdp[c][j][k] = nd;\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!updated) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nlong double dist[20][20][20] = {};\nlong double dp[10002][20][20] = {};\nvoid solve() {\n    int n;\n    cin >> n;\n    long double r, theta;\n    cin >> r >> theta;\n    REP(i, n) {\n        REP(q, n) {\n            REP(j, n) {\n                dist[i][q][j] = -1;\n            }\n            REP(j, 10002) {\n                dp[j][i][q] = r + 1;\n            }\n        }\n    }\n    vector<complex<long double>> inputs;\n    REP(i, n) {\n        long double a, b;\n        cin >> a >> b;\n        inputs.push_back(complex<long double>{a, b});\n    }\n    REP(i, n - 1) {\n        dist[0][0][i + 1] = abs(inputs[i + 1] - inputs[0]);\n    }\n    REP(i, n) {\n        REP(q, n) {\n            if (i == q) continue;\n            REP(j, n) {\n                if (q == j||j == i) continue;\n                complex<long double> a = inputs[q] - inputs[i];\n                complex<long double> b = inputs[j] - inputs[q];\n                a /= abs(a);\n                b /= abs(b);\n                long double cosine = a.real() * b.real() + a.imag() * b.imag();\n                cosine /= abs(a);\n                cosine /= abs(b);\n                cosine = min(1.0L, cosine);\n                cosine = max(-1.0L, cosine);\n                long double kakudo = (long double)acos((long double)cosine);\n                //cout << kakudo << endl;\n                kakudo *= 180.0L / (long double)M_PI;\n                if (kakudo > theta) continue;\n                dist[i][q][j] = abs(inputs[j] - inputs[q]);\n            }\n        }\n    }\n    dp[0][0][0] = 0;\n    int ans = 0;\n    REP(i,10001){\n        REP(q, n) {\n            REP(j, n) {\n                if (dp[i][q][j] > r) continue;\n                ans = i;\n                REP(t, n) {\n                    if (dist[q][j][t] == -1) continue;\n                    dp[i + 1][j][t] = min(dp[i + 1][j][t], dp[i][q][j] + dist[q][j][t]);\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n#include<complex>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\ntypedef vector<vi> vvi;\ntypedef pair<pii,pii> data;\n\n#define in(a,b,c,d) make_pair(pii(a,b),pii(c,d))\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\n\nconst double PI=acos(-1);\nconst double EPS=1e-5; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\n\nvoid printP(const P &p){\n  cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n  for(int i = 0; i < g.size(); i++){\n    cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n  }\n}\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\nint n;\ndouble r,si;\nG g;\n\nbool f(int i, int j, int k){\n    double rad = abs(arg((g[i]-g[j])/(g[j]-g[k])));\n    return rad < si + EPS;\n}\n\n\nP inP(){\n  double x,y;\n//  scanf(\"%lf,%lf\", &x, &y);\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\nG inG(int n){\n  G g(n);\n  for(int i = 0; i < n; i++){\n    g[i] = inP();\n  }\n  return g;\n}\n\n#define MAX 10005\n\ndouble dist[20][20];\ndouble memo[20][20][MAX] = {};\n\nint ans = 0;\nvector<vvi> v;\n\n\nsigned main(void) {\n    cin >> n;\n    cin >> r >> si;\n    si *= acos(-1)/180;\n    g = inG(n);\n    v = vector<vvi> (n,vvi(n));\n    rep(i,n)rep(j,n)if(i != j){\n        rep(k,n)if(k != i && k != j){\n            if(f(i,j,k))v[i][j].push_back(k);\n        }\n    }\n    rep(i,n)rep(j,n)dist[i][j] = distancePP(g[i],g[j]);\n    rep(i,n)rep(j,n)rep(k,MAX) memo[i][j][k] = INF;\n    priority_queue<data> q;\n    loop(i,1,n)if(dist[0][i] < r + EPS){\n        memo[0][i][1] = dist[0][i];\n        q.push(in(-dist[0][i],0,i,1));\n    }\n    int ans = 0;\n    while(q.size()){\n        data d = q.top();\n        q.pop();\n        int prev = d.first.second;\n        int now = d.second.first;\n        int num = d.second.second;\n        if(memo[prev][now][num] < -d.first.first)continue;\n        //cout << prev << \" \" << now << \" \" << num << endl;\n        ans = max(ans, num);\n        rep(i,v[prev][now].size()){\n            int to = v[prev][now][i];\n            double cost = memo[prev][now][num] + dist[now][to];\n            if(memo[now][to][num+1] < cost + EPS)continue;\n            if(cost > r + EPS)continue;\n            memo[now][to][num+1] = min(memo[now][to][num+1], cost);\n            q.push(in(-cost,now,to,num+1));\n        }\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\ndouble dp[20][20][2];\n\nvector<pair<int, double> > G[20][20];\nint x[20], y[20];\n\nmain(){\n  int n;\n  double r, th;\n  cin >> n >> r >> th;\n  for(int i = 0; i < n; ++i)\n    cin >> x[i] >> y[i];\n\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      if(i == j) continue;\n      int ax = x[j] - x[i];\n      int ay = y[j] - y[i];\n      for(int k = 0; k < n; ++k){\n        if(k == j) continue;\n        int bx = x[k] - x[j];\n        int by = y[k] - y[j];\n        double ac = (ax*bx + ay*by);\n        ac /= sqrt(ax*ax+ay*ay);\n        ac /= sqrt(bx*bx+by*by);\n        if(acos(-1)*th/180 >= acos(ac))\n          G[i][j].push_back({k,sqrt(bx*bx+by*by)});\n      }\n    }\n  }\n\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j){\n      dp[i][j][0] = dp[i][j][1] = r+200;\n    }\n\n  int ans = 0;\n  for(int i = 1; i < n; ++i){\n    int ax = x[i] - x[0];\n    int ay = y[i] - y[0];\n    if(ax*ax+ay*ay <= r*r){\n      dp[0][i][0] = sqrt(ax*ax+ay*ay);\n      ans = 1;\n    }\n  }\n  \n  while(ans){\n    bool end = true;\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < n; ++j){\n        dp[i][j][ans&1] = r*2+200;\n      }\n\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < n; ++j){\n        if(dp[i][j][~ans&1] < r){\n          for(auto& e : G[i][j])\n            if(dp[i][j][~ans&1]+e.second < r){\n              end = false;\n              dp[j][e.first][ans&1] =\n                min(dp[j][e.first][ans&1],\n                    dp[i][j][~ans&1]+e.second);\n            }\n        }\n      }\n    \n    if(end) break;\n    ++ans;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 200\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nint V;\ndouble r, theta, E_sz[500];\n\n// A*B の計算\nmat mul(mat &A, mat &B){\n\tmat C(A.size(), vec(B[0].size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tfor(int j = 0; j < B[0].size(); j++){\n\t\t\tdouble mini = INF;\n\t\t\tfor(int k = 0; k < B.size(); k++){\n\t\t\t\tmini = min(mini, A[i][k] + B[k][j]);\n\t\t\t}\n\t\t\tC[i][j] = mini;\n\t\t}\n\t}\n\treturn C;\n}\n\n// A^n の計算\nint mat_pow(mat A){\n\tmat B(A.size(), vec(A.size()));\n\tfor(int i = 0; i < A.size(); i++){\n\t\tB[i][i] = 1;\n\t}\n\tint num = 0;\n\twhile(true){\n\t\tB = mul(B, A);\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < V * V; i++){\n\t\t\tfor(int j = 0; j < V * V; j++){\n\t\t\t\tif(B[i][j] + E_sz[i] < r){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\n\treturn num;\n}\n\nint main(){\n\t\n\tcin >> V;\n\tcin >> r >> theta;\n\t\n\ttheta = theta * M_PI / 180;\n\t\n\tmat S(V * V, vec(V * V));\n\t\n\tdouble x[30], y[30];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i = 0; i < V * V; i++){\n\t\tE_sz[i] = INF;\n\t\tfor(int j = 0; j < V * V; j++){\n\t\t\tS[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\tif(i == j || j == k || k == i){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble vx1, vx2, vy1, vy2;\n\t\t\t\tvx1 = x[j] - x[i];\n\t\t\t\tvy1 = y[j] - y[i];\n\t\t\t\tvx2 = x[k] - x[j];\n\t\t\t\tvy2 = y[k] - y[j];\n\t\t\t\tdouble inn = vx1 * vx2 + vy1 * vy2;\n\t\t\t\tdouble norm1 = sqrt(vx1 * vx1 + vy1 * vy1);\n\t\t\t\tdouble norm2 = sqrt(vx2 * vx2 + vy2 * vy2);\n\t\t\t\tE_sz[i * V + j] = norm1;\n\t\t\t\tE_sz[k * V + j] = norm2;\n\t\t\t\tdouble th = acos(inn * inn / norm1 / norm2);\n\t\t\t\tif(M_PI - th < theta){\n\t\t\t\t\tS[i * V + j][j * V + k] = norm2;\n\t\t\t\t\t//S[j * V + i][k * V + j] = norm2;\n\t\t\t\t\t//S[j * V + k][i * V + j] = norm1;\n\t\t\t\t\tS[k * V + j][j * V + i] = norm1;\n\t\t\t\t\t//cout << i * V + j << \" \" << j * V + k << \" \" << norm2 << endl;\n\t\t\t\t\t//cout << k * V + j << \" \" << j * V + i << \" \" << norm1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << mat_pow(S) + 1 << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 30;\nint x[N], y[N];\n\nint dist[10010][N][N];\n\nvector<int> G[N][N];\ndouble D[N][N];\n\nconst double PI = 4 * atan(1);\nconst double EPS = 1e-9;\n\nint main(){\n\tint n;\n\tdouble r, theta;\n\tcin >> n >> r >> theta;\n\ttheta = theta / 180 * PI;\n\trep(i, n) cin >> x[i] >> y[i];\n\n\trep(i, n) rep(j, n){\n\t\tD[i][j] = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));\n\t}\n\n\trep(i, n) rep(j, n) rep(k, n){\n\t\tif (i == j || j == k) continue;\n\t\tdouble x1 = x[j] - x[i], y1 = y[j] - y[i];\n\t\tdouble x2 = x[k] - x[j], y2 = y[k] - y[j];\n\n\t\tdouble ct = (x1*x2 + y1*y2) / (D[i][j]*D[j][k]);\n\t\tdouble t = acos(ct);\n\n\t\tif (abs(t) < theta + EPS) G[i][j].push_back(k);\n\t}\n\n\tMEMSET(dist, 0x7f);\n\tpriority_queue<tuple<double, int, int, int>> pq;\n\n\trep(i, n) rep(j, n){\n\t\tif (i == j) continue;\n\t\tpq.emplace(-D[i][j], 1, i, j);\n\t}\n\n\tint ans = 0;\n\twhile (!pq.empty()){\n\t\tauto t = pq.top();\n\t\tpq.pop();\n\t\tdouble d;\n\t\tint c, prv, cur;\n\t\ttie(d, c, prv, cur) = t;\n\t\td = -d;\n\n\t\tif (dist[c][prv][cur] + EPS < d) continue;\n\n\t\tans = max(ans, c);\n\n\t\tfor (auto v : G[prv][cur]){\n\t\t\tdouble nd = d + D[cur][v];\n\t\t\tif (r < nd + EPS) continue;\n\t\t\tif (dist[c + 1][cur][v] < nd + EPS) continue;\n\t\t\tdist[c + 1][cur][v] = nd;\n\t\t\tpq.emplace(-nd, c + 1, cur, v);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    long double r,theta;\n    cin >> n >> r >> theta;\n    vector<long double> x(n),y(n);\n    rep(i,0,n) cin >> x[i] >> y[i];\n\n    int ans=0;\n    long double dp[20][20];\n    fill_n((long double*)dp,20*20,inf);\n    rep(i,1,n) dp[0][i]=sqrtl((x[i]-x[0])*(x[i]-x[0])+(y[i]-y[0])*(y[i]-y[0]));\n    while(true){\n        if([&]{\n            long double mini=inf;\n            rep(i,0,n) rep(j,0,n) mini=min(mini,dp[i][j]);\n            dump(mini);\n            return mini;\n        }()<r) ++ans;\n        else break;\n\n        long double prev[20][20];\n        memcpy(prev,dp,sizeof(long double)*20*20);\n        fill_n((long double*)dp,20*20,inf);\n        rep(i,0,n) rep(j,0,n) rep(k,0,n){\n            if(i==j or j==k) continue;\n            const long double l1=sqrtl((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));\n            const long double l2=sqrtl((x[k]-x[j])*(x[k]-x[j])+(y[k]-y[j])*(y[k]-y[j]));\n            if(((x[j]-x[i])*(x[k]-x[j])+(y[j]-y[i])*(y[k]-y[j]))/l1/l2-eps<cosl(theta)) continue;\n            dp[j][k]=min(dp[j][k],prev[i][j]+l2);\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\n\nint main(){\n  int n;\n  double r, theta;\n  cin >> n >> r >> theta;\n  theta *= acos(-1)/180;\n  vector<int> X(n), Y(n);\n  for(int i = 0; i < n; ++i) cin >> X[i] >> Y[i];\n  vector< vector<double> > dp(n,vector<double>(n,0));\n  bool f = false;\n  int ans = 0;\n  vector<int> V;\n  for(int i = 1; i < n; ++i){\n    int x1 = X[i] - X[0], y1 = Y[i] - Y[0];\n    if(hypot(x1,y1) <= r + EPS){\n      f = true;\n      dp[0][i] = r - hypot(x1,y1);\n      V.push_back(i);\n    }\n  }\n  while(f){\n    f = false;\n    ++ans;\n    vector< vector<double> > dp_(n,vector<double>(n,0));\n    vector<int> V_;\n    for(int l = 0; l < V.size(); ++l){\n      int i = V[l]/n, j = V[l]%n;\n      for(int k = 0; k < n; ++k){\n        if(j == k) continue;\n        int x1 = X[j] - X[i], y1 = Y[j] - Y[i], x2 = X[k] - X[j], y2 = Y[k] - Y[j];\n        if(acos((x1*x2+y1*y2)/hypot(x1,y1)/hypot(x2,y2)) <= theta + EPS&& \n           hypot(x2,y2) <= dp[i][j] + EPS){\n          f = true;\n          if(dp_[j][k] <= EPS) V_.push_back(j*n+k);\n          dp_[j][k] = max(dp_[j][k],dp[i][j] - hypot(x2,y2));\n        }\n      }\n    }\n    dp = dp_;\n    V = V_;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n \ntypedef complex<double> P;\n \nstruct S{\n  int w,p,n;\n  double d;\n  bool operator<(S s)const{\n    return d>s.d;\n  }\n};\n \ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n \nint main(){\n  int n;\n  double r,th;\n  cin>>n>>r>>th;\n  P p[21];\n  for(int i=1;i<=n;i++){\n    int x,y;\n    cin>>x>>y;\n    p[i]=P(x,y);\n  }\n  priority_queue<S> que;\n  que.push({1,0,0,0});\n  static bool mem[21][21][22222];\n  int m=0;\n  try{\n    for(;;){\n      auto cs=que.top();\n      if(cs.d>r)break;\n      que.pop();\n      if(mem[cs.w][cs.p][cs.n]++)continue;\n      m=max(m,cs.n);\n      for(int i=1;i<=n;i++){\n\tif(i==cs.w)continue;\n\tauto f=p[cs.w]-p[cs.p];\n\tauto t=p[i]-p[cs.w];\n\tif(cs.p&&acos(dot(f,t)/abs(f)/abs(t))*90>th*acos(0))continue;\n\tque.push({i,cs.w,cs.n+1,cs.d+abs(t)});\n      }\n    }\n  }catch(...){}\n  cout<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nstruct edge {\n\tint to;\n\tdouble cost;\n\tedge(int t, double c):to(t), cost(c){}\n};\n\nstruct state {\n\tint pos, prev, num;\n\tdouble dist;\n\tstate(int p, int pr, int n, double d):pos(p), prev(pr), num(n), dist(d){}\n\n\tbool operator>(const state& s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\nint n;\ndouble r, theta;\nconst int MAX_N = 20;\nint x[MAX_N], y[MAX_N];\nvector<edge> es[MAX_N][MAX_N];\n\ndouble angle(int x, int y) {\n\treturn atan2(y, x);\n}\n\ndouble diff(double alpha, double beta) {\n\treturn min(fabs(alpha - beta), fabs(M_PI - fabs(alpha - beta)));\n}\n\ndouble calc_dist(int sx, int sy, int tx, int ty) {\n\treturn hypot(abs(sx - tx), abs(sy - ty));\n}\n\nint search(int start) {\n\tpriority_queue<state, vector<state>, greater<state> > que;\n\tvector<vector<int> > cnt(n, vector<int>(n, 0));\n\tvector<vector<double> > dist(n, vector<double>(n, INT_MAX));\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(i == start)\n\t\t\tcontinue;\n\n\t\tconst double d = calc_dist(x[start], y[start], x[i], y[i]);\n\t\tif(d > r)\n\t\t\tcontinue;\n\n\t\tque.push(state(i, start, 1, d));\n\t\tcnt[start][i] = 1;\n\t\tdist[start][i] = d;\n\t}\n\n\tint res = 0;\n\twhile(!que.empty()) {\n\t\tconst state s = que.top();\n\t\tque.pop();\n\n\t\tif(s.num < cnt[s.prev][s.pos] ||\n\t\t   s.num == cnt[s.prev][s.pos] && s.dist > dist[s.prev][s.pos])\n\t\t\tcontinue;\n\n\t\tchmax(res, s.num);\n\n\t\tconst int car = s.num + 1;\n\t\tfor(int i = 0; i < es[s.prev][s.pos].size(); ++i) {\n\t\t\tconst edge& e = es[s.prev][s.pos][i];\n\t\t\tconst double d = s.dist + e.cost;\n\t\t\tif(d > r)\n\t\t\t\tcontinue;\n\n\t\t\tif(cnt[s.pos][e.to] < car ||\n\t\t\t   cnt[s.pos][e.to] == car && dist[s.pos][e.to] > d) {\n\t\t\t\tcnt[s.pos][e.to] = car;\n\t\t\t\tdist[s.pos][e.to] = d;\n\t\t\t\tque.push(state(e.to, s.pos, car, d));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> r >> theta;\n\ttheta = theta / 180.0 * M_PI;\n\n\tfor(int i = 0; i < n; ++i)\n\t\tcin >> x[i] >> y[i];\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(i == j)\n\t\t\t\tcontinue;\n\n\t\t\tconst double alpha = angle(x[i] - x[j], y[i] - y[j]);\n\t\t\tfor(int k = i + 1; k < n; ++k) {\n\t\t\t\tif(j == k)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tconst double beta = angle(x[k] - x[j], y[k] - y[j]);\n\t\t\t\tif(M_PI - diff(alpha, beta) <= theta) {\n\t\t\t\t\tes[i][j].push_back(edge(k, calc_dist(x[k], y[k], x[j], y[j])));\n\t\t\t\t\tes[k][j].push_back(edge(i, calc_dist(x[i], y[i], x[j], y[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << search(0) << endl;\t\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> P;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9, PI = acos(-1);\n\nint n;;\nP p[20];\ndouble r, t;\ndouble dp[20][20][10010], d[20][20];\nbool can[20][20][20];\n\nint main(){\n\tcin >> n >> r >> t;\n\tt *= PI / 180;\n\trep(i, n) cin >> p[i].real() >> p[i].imag();\n\t\n\trep(i, n) rep(j, n) rep(k, n) if(i != j && j != k){\n\t\tdouble a = abs(arg((p[j] - p[i]) / (p[k] - p[j])));\n\t\tcan[i][j][k] = EPS < a && a + EPS < t;\n\t}\n\trep(i, n) rep(j, n) d[i][j] = abs(p[i] - p[j]);\n\t\n\trep(i, n) rep(j, n) rep(k, 10010) dp[i][j][k] = INF;\n\trep(i, n) dp[0][i][1] = d[0][i];\n\t\n\tint ans = 0;\n\trep(k, 10010) rep(i, n) rep(j, n) if(dp[i][j][k] < r){\n\t\tans = max(ans, k);\n\t\trep(l, n) if(can[i][j][l]){\n\t\t\tdp[j][l][k + 1] = min(dp[j][l][k + 1], dp[i][j][k] + d[j][l]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2233 Carrot Tour\n// 2018.2.1 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 1e-8\n#define PI 3.1415926535897932384626433832795\n\nint x[21], y[21];\ndouble d[21][21];\ndouble dp[2][21][21];\nint to[21][21][21], hi[21][21];\nchar f[2][21][21];\n\n#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\ndouble angle(int k, int i, int j)\n{\n\tdouble a, b, c;\n\t\n\ta = hypot(x[k]-x[i], y[k]-y[i]);\n\tb = hypot(x[i]-x[j], y[i]-y[j]);\n\tc = (double)(x[k]-x[i])*(x[i]-x[j]) + (double)(y[k]-y[i])*(y[i]-y[j]);\n\treturn acos(c/(a*b));\n}\n\nint main()\n{\n\tint n, i, j, k, m, k1, k2, ok, ans;\n\tdouble r, a, t;\n\tchar buf[30];\n\n\tn = in();\n\tfgets(buf, 30, stdin), sscanf(buf, \"%lf%lf\", &r, &a);\n\ta *= PI/180;\n\tfor (i = 0; i < n; i++) x[i] = in(), y[i] = in();\n\n\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++)\n\t\td[i][j] = d[j][i] = hypot(x[i]-x[j], y[i]-y[j]);\n\n\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) if (j != i) {\n\t\tfor (k = 0; k < n; k++) if (k != i) {\n\t\t\tif (angle(k, i, j) < a + EPS) to[i][j][hi[i][j]++] = k;\n\t\t}\n\t}\n\n\tok = 0;\n\tfor (j = 1; j < n; j++) if (d[0][j] < r + EPS) {\n\t\tok = 1, dp[0][j][0] = d[0][j], f[0][j][0] = 1;\n\t}\n\n\tans = 0;\n\tfor (k1 = 0, k2 = 1; ok; k1 = k2, k2 = !k2) {\n\t\tans++;\n\t\tok = 0;\n\t\tmemset(f[k2], 0, sizeof(f[k2]));\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) {\n\t\t\tif (i == j || !f[k1][i][j]) continue;\n\t\t\tfor (m = 0; m < hi[i][j]; m++) {\n\t\t\t\tk = to[i][j][m];\n\t\t\t\tif ((t = dp[k1][i][j] + d[i][k]) < r + EPS) {\n\t\t\t\t\tif (!f[k2][k][i] || dp[k2][k][i] > t) {\n\t\t\t\t\t\tdp[k2][k][i] = t, f[k2][k][i] = 1, ok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main (void){\n    \n    int judge = 0;\n    int define_x,define_y,search,i,number;\n\n    int position_x[56] = {-1};\n    int position_y[56] = {-1};\n    int bridge_number[56] = {-1};\n    \n    scanf(\"%d\",&number);\n    define_y = number /100;\n    define_x = number/ 10 -(define_y *10);\n    search = number -(define_y *100) -(define_x*10);\n    \n    \n    \n    for(i = 0;;i++)\n    {\n        scanf(\"%d\",&number);\n        position_y[i] = number /100;\n        position_x[i] = number/ 10 -(position_y[i] *10);\n        bridge_number[i] = number -(position_y[i] *100) -(position_x[i]*10);\n        if((position_y[i] == 0 && position_y[i] == 0) && bridge_number[i] == 0)\n        {\n            judge = i;\n            break;\n        }\n    }\n    \n    /*??¢?´¢????§?*/\n    define_y = define_y-1;\n    while(define_y != 0)\n    {\n        for(i = 0;i<=judge;i++)\n        {\n            if(position_y[i] == define_y)\n            {\n                if (position_x[i] == search)\n                        search = bridge_number[i];\n                \n            }\n        }\n        define_y --;\n    }\n    printf(\"%d\",search);\n    return 0;\n    \n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2233 Carrot Tour\n// 2018.2.1 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 1e-8\n#define PI 3.1415926535897932384626433832795\n\nint x[21], y[21];\ndouble d[21][21];\ndouble dp[5000][21][21]; char f[5000][21][21];\nint to[21][21][21], hi[21][21];\n\n#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\ndouble angle(int k, int i, int j)\n{\n\tdouble a, b, c;\n\t\n\ta = hypot(x[k]-x[i], y[k]-y[i]);\n\tb = hypot(x[i]-x[j], y[i]-y[j]);\n\tc = (double)(x[k]-x[i])*(x[i]-x[j]) + (double)(y[k]-y[i])*(y[i]-y[j]);\n\treturn acos(c/(a*b));\n}\n\nint main()\n{\n\tint n, i, j, k, m, s, ok, ans;\n\tdouble r, a, t;\n\tchar buf[30];\n\n\tn = in();\n\tfgets(buf, 30, stdin), sscanf(buf, \"%lf%lf\", &r, &a);\n\ta *= PI/180;\n\tfor (i = 0; i < n; i++) x[i] = in(), y[i] = in();\n\n\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++)\n\t\td[i][j] = d[j][i] = hypot(x[i]-x[j], y[i]-y[j]);\n\n\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) if (j != i) {\n\t\tfor (k = 0; k < n; k++) if (k != i) {\n\t\t\tif (angle(k, i, j) < a + EPS) to[i][j][hi[i][j]++] = k;\n\t\t}\n\t}\n\n\tok = 0;\n\tfor (j = 1; j < n; j++) if (d[0][j] < r + EPS) {\n\t\tok = 1, dp[0][j][0] = d[0][j], f[0][j][0] = 1;\n\t}\n\n\tans = 0;\n\tfor (s = 0; ok; s++) {\n\t\tans++;\n\t\tok = 0;\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) {\n\t\t\tif (i == j || !f[s][i][j]) continue;\n\t\t\tfor (m = 0; m < hi[i][j]; m++) {\n\t\t\t\tk = to[i][j][m];\n\t\t\t\tif ((t = dp[s][i][j] + d[i][k]) < r + EPS) {\n\t\t\t\t\tif (!f[s+1][k][i] || dp[s+1][k][i] > t) {\n\t\t\t\t\t\tdp[s+1][k][i] = t, f[s+1][k][i] = 1, ok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  static class Point {\n    int x, y;\n\n    Point(int a, int b) {\n      x = a;\n      y = b;\n    }\n\n    static Point p(int x, int y) {\n      return new Point(x, y);\n    }\n  }\n\n  double kaku(Point p1, Point p2, Point p3) {\n    int dx1 = p2.x - p1.x;\n    int dy1 = p2.y - p1.y;\n    int dx2 = p3.x - p2.x;\n    int dy2 = p3.y - p2.y;\n\n    int naiseki = dx1 * dx2 + dy1 * dy2;\n    double z1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n    double z2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n    return Math.acos(naiseki / (z1 * z2)) * 180 / Math.PI;\n  }\n\n  double dist(Point p1, Point p2) {\n    double dx = p1.x - p2.x;\n    double dy = p1.y - p2.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  class Node {\n    int now;\n    int prev;\n    int cnt;\n    double r;\n  }\n\n  void run() {\n    long s = System.currentTimeMillis();\n    int n = ni();\n    double r = sc.nextDouble();\n    double theta = sc.nextDouble();\n    Point[] p = new Point[n];\n    for (int i = 0; i < n; ++i) {\n      int x = ni();\n      int y = ni();\n      p[i] = new Point(x, y);\n    }\n    boolean[][][] adj = new boolean[n][n][n];\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        for (int k = 0; k < n; ++k) {\n          adj[i][j][k] = kaku(p[i], p[j], p[k]) <= theta + 1e-3;\n        }\n      }\n    }\n    Node atom = new Node();\n    atom.cnt = 0;\n    atom.r = 0;\n    atom.now = 0;\n    atom.prev = -1;\n    PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.r));\n    queue.add(atom);\n    double[][][] dp = new double[n][n + 1][10000 + 1];\n    for (double[][] t : dp) for (double[] a : t) Arrays.fill(a, Double.MAX_VALUE);\n//    debug(\"here1\", System.currentTimeMillis() - s);\n    while (queue.size() > 0) {\n      Node node = queue.poll();\n      if (dp[node.now][node.prev + 1][node.cnt] <= node.r) {\n        continue;\n      }\n      dp[node.now][node.prev + 1][node.cnt] = node.r;\n      for (int i = 0; i < n; ++i) {\n        if (node.now == i) {\n          continue;\n        }\n        if (node.prev == -1 || adj[node.prev][node.now][i]) {\n          Node next = new Node();\n          next.now = i;\n          next.cnt = node.cnt + 1;\n          next.r = node.r + dist(p[node.now], p[i]);\n          if (next.r > r + 1e-3) {\n            continue;\n          }\n          next.prev = node.now;\n          queue.add(next);\n        }\n      }\n    }\n//    debug(\"here2\", System.currentTimeMillis() - s);\n    int max = 0;\n    for (int i = 0; i <= 10000; ++i) {\n      for (double[][] t : dp) {\n        for (double[] a : t) {\n          if (a[i] <= r + 1e-3) {\n            max = Math.max(max, i);\n          }\n        }\n      }\n    }\n    System.out.println(max);\n//    debug(\"here3\", System.currentTimeMillis() - s);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.Function;\n\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n\n    double function(final double y, double a, final double dx) {\n        double nx = a + dx;\n        if (Math.abs(Math.floor(a) - Math.floor(nx)) < 1e-6) {\n            double sx1 = Math.floor(a);\n            double sx2 = sx1 + 1;\n            double rx1 = Math.floor(nx);\n            double rx2 = rx1 + 1;\n            double dist = Math.min(a - sx1 + nx - rx1, sx2 - a + rx2 - nx);\n            return y + dist;\n        } else {\n            return y + nx - a;\n        }\n    }\n\n    static class Point {\n        int x, y;\n\n        Point(int a, int b) {\n            x = a;\n            y = b;\n        }\n\n        static Point p(int x, int y) {\n            return new Point(x, y);\n        }\n    }\n\n    double kaku(Point p1, Point p2, Point p3) {\n        int dx1 = p2.x - p1.x;\n        int dy1 = p2.y - p1.y;\n        int dx2 = p3.x - p2.x;\n        int dy2 = p3.y - p2.y;\n\n        int naiseki = dx1 * dx2 + dy1 * dy2;\n        double z1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        double z2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        return Math.acos(naiseki / (z1 * z2)) * 180 / Math.PI;\n    }\n\n    double dist(Point p1, Point p2) {\n        double dx = p1.x - p2.x;\n        double dy = p1.y - p2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    class Node {\n        int now;\n        int prev;\n        int done;\n        double[] map = new double[20];\n        int[] cnt = new int[20];\n        int flag;\n    }\n\n    void run() {\n        int n = ni();\n        double r = sc.nextDouble();\n        double theta = sc.nextDouble();\n        Point[] p = new Point[n];\n        for (int i = 0; i < n; ++i) {\n            int x = ni();\n            int y = ni();\n            p[i] = new Point(x, y);\n        }\n        Node atom = new Node();\n        atom.cnt[0] = 0;\n        atom.map[0] = 0;\n        atom.now = 0;\n        atom.prev = -1;\n        atom.done = 1;\n        atom.flag = 0;\n        PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.map[a.now]));\n        queue.add(atom);\n        int max = 0;\n        boolean[][][][] done = new boolean[2][n][n + 1][1 << n];\n        while (queue.size() > 0) {\n            Node node = queue.poll();\n            if (done[node.flag][node.now][node.prev + 1][node.done]) {\n                continue;\n            }\n            done[node.flag][node.now][node.prev + 1][node.done] = true;\n            max = Math.max(max, node.cnt[node.now]);\n            for (int i = 0; i < n; ++i) {\n                if (node.now == i) {\n                    continue;\n                }\n                if (node.prev == -1 || kaku(p[node.prev], p[node.now], p[i]) <= theta + 1e-3) {\n                    if (node.flag == 0 && ((node.done >> i) & 1) == 1) {\n                        // loop\n                        int tugi = node.cnt[node.now] + 1;\n                        int mae = node.cnt[i];\n                        int diff = tugi - mae;\n                        double loop = node.map[node.now] + dist(p[node.now], p[i]) - node.map[i];\n                        double nokori = r - (node.map[node.now] + dist(p[node.now], p[i]));\n                        int cnt = (int) (nokori / loop);\n                        Node next = new Node();\n                        next.now = i;\n                        next.done = 1 << i;\n                        next.cnt[i] = node.cnt[node.now] + 1 + cnt * diff;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]) + cnt * loop;\n                        if (next.map[i] > r - 1e-3) {\n                            continue;\n                        }\n                        next.prev = node.now;\n                        next.flag = 1;\n                        queue.add(next);\n                    } else {\n                        Node next = new Node();\n                        next.now = i;\n                        System.arraycopy(node.cnt, 0, next.cnt, 0, 20);\n                        System.arraycopy(node.map, 0, next.map, 0, 20);\n                        next.cnt[i] = node.cnt[node.now] + 1;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]);\n                        if (next.map[i] > r - 1e-3) {\n                            continue;\n                        }\n                        next.prev = node.now;\n                        next.done = node.done | 1 << i;\n                        next.flag = node.flag;\n                        queue.add(next);\n                    }\n                }\n            }\n        }\n        System.out.println(max);\n    }\n\n    final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n    double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n        double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        double d1 = f.apply(c1);\n        double d2 = f.apply(c2);\n        for (int i = 0; i < 10000000; ++i) {\n            if (comp.compare(d1, d2) > 0) {\n                right = c2;\n                c2 = c1;\n                d2 = d1;\n                c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n                d1 = f.apply(c1);\n            } else {\n                left = c1;\n                c1 = c2;\n                d1 = d2;\n                c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n                d2 = f.apply(c2);\n            }\n        }\n        return left;\n    }\n\n    double divideInternally(double a, double b, double m, double n) {\n        return (n * a + m * b) / (m + n);\n    }\n\n    int ni() {\n        return sc.nextInt();\n    }\n\n    static public void main(String[] args) {\n        new Main().run();\n    }\n\n    void debug(Object... os) {\n        System.err.println(Arrays.deepToString(os));\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  static class Point {\n    int x, y;\n\n    Point(int a, int b) {\n      x = a;\n      y = b;\n    }\n\n    static Point p(int x, int y) {\n      return new Point(x, y);\n    }\n  }\n\n  double kaku(Point p1, Point p2, Point p3) {\n    int dx1 = p2.x - p1.x;\n    int dy1 = p2.y - p1.y;\n    int dx2 = p3.x - p2.x;\n    int dy2 = p3.y - p2.y;\n\n    int naiseki = dx1 * dx2 + dy1 * dy2;\n    double z1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n    double z2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n    return Math.acos(naiseki / (z1 * z2)) * 180 / Math.PI;\n  }\n\n  double dist(Point p1, Point p2) {\n    double dx = p1.x - p2.x;\n    double dy = p1.y - p2.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  class Node {\n    int now;\n    int prev;\n    int cnt;\n    double r;\n  }\n\n  void run() {\n    int n = ni();\n    double r = sc.nextDouble();\n    double theta = sc.nextDouble();\n    Point[] p = new Point[n];\n    for (int i = 0; i < n; ++i) {\n      int x = ni();\n      int y = ni();\n      p[i] = new Point(x, y);\n    }\n    Node atom = new Node();\n    atom.cnt = 0;\n    atom.r = 0;\n    atom.now = 0;\n    atom.prev = -1;\n    PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.r));\n    queue.add(atom);\n    double[][][] dp = new double[n][n + 1][10000 + 1];\n    for (double[][] t : dp) for (double[] a : t) Arrays.fill(a, Double.MAX_VALUE);\n    while (queue.size() > 0) {\n      Node node = queue.poll();\n      if (dp[node.now][node.prev + 1][node.cnt] <= node.r) {\n        continue;\n      }\n      dp[node.now][node.prev + 1][node.cnt] = node.r;\n      for (int i = 0; i < n; ++i) {\n        if (node.now == i) {\n          continue;\n        }\n        if (node.prev == -1 || kaku(p[node.prev], p[node.now], p[i]) <= theta + 1e-3) {\n          Node next = new Node();\n          next.now = i;\n          next.cnt = node.cnt + 1;\n          next.r = node.r + dist(p[node.now], p[i]);\n          if (next.r > r + 1e-3) {\n            continue;\n          }\n          next.prev = node.now;\n          queue.add(next);\n        }\n      }\n    }\n    int max = 0;\n    for (int i = 0; i <= 10000; ++i) {\n      for (double[][] t : dp) {\n        for (double[] a : t) {\n          if (a[i] <= r + 1e-3) {\n            max = Math.max(max, i);\n          }\n        }\n      }\n    }\n    System.out.println(max);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.Function;\n\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n\n    double function(final double y, double a, final double dx) {\n        double nx = a + dx;\n        if (Math.abs(Math.floor(a) - Math.floor(nx)) < 1e-6) {\n            double sx1 = Math.floor(a);\n            double sx2 = sx1 + 1;\n            double rx1 = Math.floor(nx);\n            double rx2 = rx1 + 1;\n            double dist = Math.min(a - sx1 + nx - rx1, sx2 - a + rx2 - nx);\n            return y + dist;\n        } else {\n            return y + nx - a;\n        }\n    }\n\n    static class Point {\n        int x, y;\n\n        Point(int a, int b) {\n            x = a;\n            y = b;\n        }\n\n        static Point p(int x, int y) {\n            return new Point(x, y);\n        }\n    }\n\n    double kaku(Point p1, Point p2, Point p3) {\n        int dx1 = p2.x - p1.x;\n        int dy1 = p2.y - p1.y;\n        int dx2 = p3.x - p2.x;\n        int dy2 = p3.y - p2.y;\n\n        int naiseki = dx1 * dx2 + dy1 * dy2;\n        double z1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        double z2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        return Math.acos(naiseki / (z1 * z2)) * 180 / Math.PI;\n    }\n\n    double dist(Point p1, Point p2) {\n        double dx = p1.x - p2.x;\n        double dy = p1.y - p2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    class Node {\n        int now;\n        int prev;\n        int done;\n        double[] map = new double[20];\n        int[] cnt = new int[20];\n        int flag;\n    }\n\n    void run() {\n        int n = ni();\n        double r = sc.nextDouble();\n        double theta = sc.nextDouble();\n        Point[] p = new Point[n];\n        for (int i = 0; i < n; ++i) {\n            int x = ni();\n            int y = ni();\n            p[i] = new Point(x, y);\n        }\n        Node atom = new Node();\n        atom.cnt[0] = 0;\n        atom.map[0] = 0;\n        atom.now = 0;\n        atom.prev = -1;\n        atom.done = 1;\n        atom.flag = 0;\n        PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.map[a.now]));\n        queue.add(atom);\n        int max = 0;\n        boolean[][][] done = new boolean[2][n][1 << n];\n        while (queue.size() > 0) {\n            Node node = queue.poll();\n            if (done[node.flag][node.now][node.done]) {\n                continue;\n            }\n            done[node.flag][node.now][node.done] = true;\n            max = Math.max(max, node.cnt[node.now]);\n            for (int i = 0; i < n; ++i) {\n                if (node.now == i) {\n                    continue;\n                }\n                if (node.prev == -1 || kaku(p[node.prev], p[node.now], p[i]) < theta) {\n                    if (((node.done >> i) & 1) == 1) {\n                        // loop\n                        int tugi = node.cnt[node.now] + 1;\n                        int mae = node.cnt[i];\n                        int diff = tugi - mae;\n                        double loop = node.map[node.now] + dist(p[node.now], p[i]) - node.map[i];\n                        double nokori = r - (node.map[node.now] + dist(p[node.now], p[i]));\n                        int cnt = (int) (nokori / loop);\n                        Node next = new Node();\n                        next.now = i;\n                        next.done = 1 << i;\n                        next.cnt[i] = node.cnt[node.now] + 1 + cnt * diff;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]) + cnt * loop;\n                        next.prev = node.now;\n                        next.flag = 1;\n                        queue.add(next);\n                    } else {\n                        Node next = new Node();\n                        next.now = i;\n                        next.cnt[i] = node.cnt[node.now] + 1;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]);\n                        if (next.map[i] > r) {\n                            continue;\n                        }\n                        next.prev = node.now;\n                        next.done |= node.done | 1 << i;\n                        next.flag = node.flag;\n                        queue.add(next);\n                    }\n                }\n            }\n        }\n        System.out.println(max);\n    }\n\n    final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n    double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n        double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        double d1 = f.apply(c1);\n        double d2 = f.apply(c2);\n        for (int i = 0; i < 10000000; ++i) {\n            if (comp.compare(d1, d2) > 0) {\n                right = c2;\n                c2 = c1;\n                d2 = d1;\n                c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n                d1 = f.apply(c1);\n            } else {\n                left = c1;\n                c1 = c2;\n                d1 = d2;\n                c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n                d2 = f.apply(c2);\n            }\n        }\n        return left;\n    }\n\n    double divideInternally(double a, double b, double m, double n) {\n        return (n * a + m * b) / (m + n);\n    }\n\n    int ni() {\n        return sc.nextInt();\n    }\n\n    static public void main(String[] args) {\n        new Main().run();\n    }\n\n    void debug(Object... os) {\n        System.err.println(Arrays.deepToString(os));\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.Function;\n\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n\n    double function(final double y, double a, final double dx) {\n        double nx = a + dx;\n        if (Math.abs(Math.floor(a) - Math.floor(nx)) < 1e-6) {\n            double sx1 = Math.floor(a);\n            double sx2 = sx1 + 1;\n            double rx1 = Math.floor(nx);\n            double rx2 = rx1 + 1;\n            double dist = Math.min(a - sx1 + nx - rx1, sx2 - a + rx2 - nx);\n            return y + dist;\n        } else {\n            return y + nx - a;\n        }\n    }\n\n    static class Point {\n        int x, y;\n\n        Point(int a, int b) {\n            x = a;\n            y = b;\n        }\n\n        static Point p(int x, int y) {\n            return new Point(x, y);\n        }\n    }\n\n    double kaku(Point p1, Point p2, Point p3) {\n        int dx1 = p2.x - p1.x;\n        int dy1 = p2.y - p1.y;\n        int dx2 = p3.x - p2.x;\n        int dy2 = p3.y - p2.y;\n\n        int naiseki = dx1 * dx2 + dy1 * dy2;\n        double z1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        double z2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        return Math.acos(naiseki / (z1 * z2)) * 180 / Math.PI;\n    }\n\n    double dist(Point p1, Point p2) {\n        double dx = p1.x - p2.x;\n        double dy = p1.y - p2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    class Node {\n        int now;\n        int prev;\n        int done;\n        double[] map = new double[20];\n        int[] cnt = new int[20];\n        int flag;\n    }\n\n    void run() {\n        int n = ni();\n        double r = sc.nextDouble();\n        double theta = sc.nextDouble();\n        Point[] p = new Point[n];\n        for (int i = 0; i < n; ++i) {\n            int x = ni();\n            int y = ni();\n            p[i] = new Point(x, y);\n        }\n        Node atom = new Node();\n        atom.cnt[0] = 0;\n        atom.map[0] = 0;\n        atom.now = 0;\n        atom.prev = -1;\n        atom.done = 1;\n        atom.flag = 0;\n        PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.map[a.now]));\n        queue.add(atom);\n        int max = 0;\n        boolean[][][] done = new boolean[2][n][1 << n];\n        while (queue.size() > 0) {\n            Node node = queue.poll();\n            if (done[node.flag][node.now][node.done]) {\n                continue;\n            }\n            done[node.flag][node.now][node.done] = true;\n            max = Math.max(max, node.cnt[node.now]);\n            for (int i = 0; i < n; ++i) {\n                if (node.now == i) {\n                    continue;\n                }\n                if (node.prev == -1 || kaku(p[node.prev], p[node.now], p[i]) < theta) {\n                    if (node.flag == 0 && ((node.done >> i) & 1) == 1) {\n                        // loop\n                        int tugi = node.cnt[node.now] + 1;\n                        int mae = node.cnt[i];\n                        int diff = tugi - mae;\n                        double loop = node.map[node.now] + dist(p[node.now], p[i]) - node.map[i];\n                        double nokori = r - (node.map[node.now] + dist(p[node.now], p[i]));\n                        int cnt = (int) (nokori / loop);\n                        Node next = new Node();\n                        next.now = i;\n                        next.done = 1 << i;\n                        next.cnt[i] = node.cnt[node.now] + 1 + cnt * diff;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]) + cnt * loop;\n                        next.prev = node.now;\n                        next.flag = 1;\n                        queue.add(next);\n                    } else {\n                        Node next = new Node();\n                        next.now = i;\n                        System.arraycopy(node.cnt, 0, next.cnt, 0, 20);\n                        System.arraycopy(node.map, 0, next.map, 0, 20);\n                        next.cnt[i] = node.cnt[node.now] + 1;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]);\n                        if (next.map[i] > r) {\n                            continue;\n                        }\n                        next.prev = node.now;\n                        next.done |= node.done | 1 << i;\n                        next.flag = node.flag;\n                        queue.add(next);\n                    }\n                }\n            }\n        }\n        System.out.println(max);\n    }\n\n    final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n    double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n        double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        double d1 = f.apply(c1);\n        double d2 = f.apply(c2);\n        for (int i = 0; i < 10000000; ++i) {\n            if (comp.compare(d1, d2) > 0) {\n                right = c2;\n                c2 = c1;\n                d2 = d1;\n                c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n                d1 = f.apply(c1);\n            } else {\n                left = c1;\n                c1 = c2;\n                d1 = d2;\n                c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n                d2 = f.apply(c2);\n            }\n        }\n        return left;\n    }\n\n    double divideInternally(double a, double b, double m, double n) {\n        return (n * a + m * b) / (m + n);\n    }\n\n    int ni() {\n        return sc.nextInt();\n    }\n\n    static public void main(String[] args) {\n        new Main().run();\n    }\n\n    void debug(Object... os) {\n        System.err.println(Arrays.deepToString(os));\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic boolean[][][] ok;\n\tstatic double[][] dist;\n\n\tpublic static void main(String[] args) {\n\t\tN = sc.nextInt();\n\t\tdouble R = sc.nextDouble();\n\t\tdouble theta = sc.nextDouble();\n\t\tint[] X = new int[N];\n\t\tint[] Y = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tX[i] = sc.nextInt();\n\t\t\tY[i] = sc.nextInt();\n\t\t}\n\t\tok = new boolean[N][N][N];\n\t\tdist = new double[N][N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tdist[i][j] = Math.sqrt((X[i] - X[j]) * (X[i] - X[j]) + (Y[i] - Y[j]) * (Y[i] - Y[j]));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\t\tint dx1 = X[j] - X[i];\n\t\t\t\t\tint dx2 = X[k] - X[j];\n\t\t\t\t\tint dy1 = Y[j] - Y[i];\n\t\t\t\t\tint dy2 = Y[k] - Y[j];\n\t\t\t\t\tdouble arg = Math.abs(Math.acos((dx1 * dx2 + dy1 * dy2) / dist[i][j] / dist[j][k])) * 180 / Math.PI;\n\t\t\t\t\tok[i][j][k] = arg <= theta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble[][][] dp = new double[2][N][N];\n\t\tfor (double[][] a : dp) {\n\t\t\tfor (double[] aa : a) {\n\t\t\t\tArrays.fill(aa, -1);\n\t\t\t}\n\t\t}\n\t\tboolean any = false;\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tif (dist[0][i] <= R) {\n\t\t\t\tany = true;\n\t\t\t\tdp[0][0][i] = R - dist[0][i];\n\t\t\t}\n\t\t}\n\t\tif (!any) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tint t = 1;\n\t\tfor (int turn = 1;; ++turn) {\n\t\t\tfor (double[] a : dp[t]) {\n\t\t\t\tArrays.fill(a, -1);\n\t\t\t}\n\t\t\tboolean update = false;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tif (dp[1 - t][i][j] < 0) continue;\n\t\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\t\tif (!ok[i][j][k] || dp[1 - t][i][j] < dist[j][k]) continue;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tdp[t][j][k] = Math.max(dp[t][j][k], dp[1 - t][i][j] - dist[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) {\n\t\t\t\tSystem.out.println(turn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt = 1 - t;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.Function;\n\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n\n    double function(final double y, double a, final double dx) {\n        double nx = a + dx;\n        if (Math.abs(Math.floor(a) - Math.floor(nx)) < 1e-6) {\n            double sx1 = Math.floor(a);\n            double sx2 = sx1 + 1;\n            double rx1 = Math.floor(nx);\n            double rx2 = rx1 + 1;\n            double dist = Math.min(a - sx1 + nx - rx1, sx2 - a + rx2 - nx);\n            return y + dist;\n        } else {\n            return y + nx - a;\n        }\n    }\n\n    static class Point {\n        int x, y;\n\n        Point(int a, int b) {\n            x = a;\n            y = b;\n        }\n\n        static Point p(int x, int y) {\n            return new Point(x, y);\n        }\n    }\n\n    double kaku(Point p1, Point p2, Point p3) {\n        int dx1 = p2.x - p1.x;\n        int dy1 = p2.y - p1.y;\n        int dx2 = p3.x - p2.x;\n        int dy2 = p3.y - p2.y;\n\n        int naiseki = dx1 * dx2 + dy1 * dy2;\n        double z1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        double z2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        return Math.acos(naiseki / (z1 * z2)) * 180 / Math.PI;\n    }\n\n    double dist(Point p1, Point p2) {\n        double dx = p1.x - p2.x;\n        double dy = p1.y - p2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    class Node {\n        int now;\n        int prev;\n        int done;\n        double[] map = new double[20];\n        int[] cnt = new int[20];\n        int flag;\n    }\n\n    void run() {\n        int n = ni();\n        double r = sc.nextDouble();\n        double theta = sc.nextDouble();\n        Point[] p = new Point[n];\n        for (int i = 0; i < n; ++i) {\n            int x = ni();\n            int y = ni();\n            p[i] = new Point(x, y);\n        }\n        Node atom = new Node();\n        atom.cnt[0] = 0;\n        atom.map[0] = 0;\n        atom.now = 0;\n        atom.prev = -1;\n        atom.done = 1;\n        atom.flag = 0;\n        PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.map[a.now]));\n        queue.add(atom);\n        int max = 0;\n        boolean[][][][] done = new boolean[2][n][n + 1][1 << n];\n        while (queue.size() > 0) {\n            Node node = queue.poll();\n            if (done[node.flag][node.now][node.prev + 1][node.done]) {\n                continue;\n            }\n            done[node.flag][node.now][node.prev + 1][node.done] = true;\n            max = Math.max(max, node.cnt[node.now]);\n            for (int i = 0; i < n; ++i) {\n                if (node.now == i) {\n                    continue;\n                }\n                if (node.prev == -1 || kaku(p[node.prev], p[node.now], p[i]) <= theta + 1e-3) {\n                    if (node.flag == 0 && ((node.done >> i) & 1) == 1) {\n                        // loop\n                        int tugi = node.cnt[node.now] + 1;\n                        int mae = node.cnt[i];\n                        int diff = tugi - mae;\n                        double loop = node.map[node.now] + dist(p[node.now], p[i]) - node.map[i];\n                        double nokori = r - (node.map[node.now] + dist(p[node.now], p[i]));\n                        int cnt = (int) (nokori / loop);\n                        Node next = new Node();\n                        next.now = i;\n                        next.done = 1 << i;\n                        next.cnt[i] = node.cnt[node.now] + 1 + cnt * diff;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]) + cnt * loop;\n                        next.prev = node.now;\n                        next.flag = 1;\n                        queue.add(next);\n                    } else {\n                        Node next = new Node();\n                        next.now = i;\n                        System.arraycopy(node.cnt, 0, next.cnt, 0, 20);\n                        System.arraycopy(node.map, 0, next.map, 0, 20);\n                        next.cnt[i] = node.cnt[node.now] + 1;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]);\n                        if (next.map[i] > r) {\n                            continue;\n                        }\n                        next.prev = node.now;\n                        next.done |= node.done | 1 << i;\n                        next.flag = node.flag;\n                        queue.add(next);\n                    }\n                }\n            }\n        }\n        System.out.println(max);\n    }\n\n    final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n    double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n        double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        double d1 = f.apply(c1);\n        double d2 = f.apply(c2);\n        for (int i = 0; i < 10000000; ++i) {\n            if (comp.compare(d1, d2) > 0) {\n                right = c2;\n                c2 = c1;\n                d2 = d1;\n                c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n                d1 = f.apply(c1);\n            } else {\n                left = c1;\n                c1 = c2;\n                d1 = d2;\n                c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n                d2 = f.apply(c2);\n            }\n        }\n        return left;\n    }\n\n    double divideInternally(double a, double b, double m, double n) {\n        return (n * a + m * b) / (m + n);\n    }\n\n    int ni() {\n        return sc.nextInt();\n    }\n\n    static public void main(String[] args) {\n        new Main().run();\n    }\n\n    void debug(Object... os) {\n        System.err.println(Arrays.deepToString(os));\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.Function;\n\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n\n    double function(final double y, double a, final double dx) {\n        double nx = a + dx;\n        if (Math.abs(Math.floor(a) - Math.floor(nx)) < 1e-6) {\n            double sx1 = Math.floor(a);\n            double sx2 = sx1 + 1;\n            double rx1 = Math.floor(nx);\n            double rx2 = rx1 + 1;\n            double dist = Math.min(a - sx1 + nx - rx1, sx2 - a + rx2 - nx);\n            return y + dist;\n        } else {\n            return y + nx - a;\n        }\n    }\n\n    static class Point {\n        int x, y;\n\n        Point(int a, int b) {\n            x = a;\n            y = b;\n        }\n\n        static Point p(int x, int y) {\n            return new Point(x, y);\n        }\n    }\n\n    double kaku(Point p1, Point p2, Point p3) {\n        int dx1 = p2.x - p1.x;\n        int dy1 = p2.y - p1.y;\n        int dx2 = p3.x - p2.x;\n        int dy2 = p3.y - p2.y;\n\n        int naiseki = dx1 * dx2 + dy1 * dy2;\n        double z1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        double z2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        return Math.acos(naiseki / (z1 * z2)) * 180 / Math.PI;\n    }\n\n    double dist(Point p1, Point p2) {\n        double dx = p1.x - p2.x;\n        double dy = p1.y - p2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    class Node {\n        int now;\n        int prev;\n        int done;\n        double[] map = new double[20];\n        int[] cnt = new int[20];\n        int flag;\n    }\n\n    void run() {\n        int n = ni();\n        double r = sc.nextDouble();\n        double theta = sc.nextDouble();\n        Point[] p = new Point[n];\n        for (int i = 0; i < n; ++i) {\n            int x = ni();\n            int y = ni();\n            p[i] = new Point(x, y);\n        }\n        Node atom = new Node();\n        atom.cnt[0] = 0;\n        atom.map[0] = 0;\n        atom.now = 0;\n        atom.prev = -1;\n        atom.done = 1;\n        atom.flag = 0;\n        PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.map[a.now]));\n        queue.add(atom);\n        int max = 0;\n        boolean[][][] done = new boolean[2][n][1 << n];\n        while (queue.size() > 0) {\n            Node node = queue.poll();\n            if (done[node.flag][node.now][node.done]) {\n                continue;\n            }\n            done[node.flag][node.now][node.done] = true;\n            max = Math.max(max, node.cnt[node.now]);\n            for (int i = 0; i < n; ++i) {\n                if (node.now == i) {\n                    continue;\n                }\n                if (node.prev == -1 || kaku(p[node.prev], p[node.now], p[i]) <= theta + 1e-3) {\n                    if (node.flag == 0 && ((node.done >> i) & 1) == 1) {\n                        // loop\n                        int tugi = node.cnt[node.now] + 1;\n                        int mae = node.cnt[i];\n                        int diff = tugi - mae;\n                        double loop = node.map[node.now] + dist(p[node.now], p[i]) - node.map[i];\n                        double nokori = r - (node.map[node.now] + dist(p[node.now], p[i]));\n                        int cnt = (int) (nokori / loop);\n                        Node next = new Node();\n                        next.now = i;\n                        next.done = 1 << i;\n                        next.cnt[i] = node.cnt[node.now] + 1 + cnt * diff;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]) + cnt * loop;\n                        next.prev = node.now;\n                        next.flag = 1;\n                        queue.add(next);\n                    } else {\n                        Node next = new Node();\n                        next.now = i;\n                        System.arraycopy(node.cnt, 0, next.cnt, 0, 20);\n                        System.arraycopy(node.map, 0, next.map, 0, 20);\n                        next.cnt[i] = node.cnt[node.now] + 1;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]);\n                        if (next.map[i] > r) {\n                            continue;\n                        }\n                        next.prev = node.now;\n                        next.done |= node.done | 1 << i;\n                        next.flag = node.flag;\n                        queue.add(next);\n                    }\n                }\n            }\n        }\n        System.out.println(max);\n    }\n\n    final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n    double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n        double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        double d1 = f.apply(c1);\n        double d2 = f.apply(c2);\n        for (int i = 0; i < 10000000; ++i) {\n            if (comp.compare(d1, d2) > 0) {\n                right = c2;\n                c2 = c1;\n                d2 = d1;\n                c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n                d1 = f.apply(c1);\n            } else {\n                left = c1;\n                c1 = c2;\n                d1 = d2;\n                c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n                d2 = f.apply(c2);\n            }\n        }\n        return left;\n    }\n\n    double divideInternally(double a, double b, double m, double n) {\n        return (n * a + m * b) / (m + n);\n    }\n\n    int ni() {\n        return sc.nextInt();\n    }\n\n    static public void main(String[] args) {\n        new Main().run();\n    }\n\n    void debug(Object... os) {\n        System.err.println(Arrays.deepToString(os));\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic boolean[][][] ok;\n\tstatic double[][] dist;\n\n\tpublic static void main(String[] args) {\n\t\tN = sc.nextInt();\n\t\tdouble R = sc.nextDouble();\n\t\tdouble theta = sc.nextDouble();\n\t\tint[] X = new int[N];\n\t\tint[] Y = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tX[i] = sc.nextInt();\n\t\t\tY[i] = sc.nextInt();\n\t\t}\n\t\tok = new boolean[N][N][N];\n\t\tdist = new double[N][N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tdist[i][j] = Math.sqrt((X[i] - X[j]) * (X[i] - X[j]) + (Y[i] - Y[j]) * (Y[i] - Y[j]));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\t\tint dx1 = X[j] - X[i];\n\t\t\t\t\tint dx2 = X[k] - X[j];\n\t\t\t\t\tint dy1 = Y[j] - Y[i];\n\t\t\t\t\tint dy2 = Y[k] - Y[j];\n\t\t\t\t\tdouble arg = Math.abs(Math.acos((dx1 * dx2 + dy1 * dy2) / dist[i][j] / dist[j][k])) * 180 / Math.PI;\n\t\t\t\t\tok[i][j][k] = arg <= theta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble[][][] dp = new double[2][N][N];\n\t\tfor (double[][] a : dp) {\n\t\t\tfor (double[] aa : a) {\n\t\t\t\tArrays.fill(aa, -1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tif (dist[0][i] <= R) {\n\t\t\t\tdp[0][0][i] = R - dist[0][i];\n\t\t\t}\n\t\t}\n\t\tint t = 1;\n\t\tfor (int turn = 1;; ++turn) {\n\t\t\tfor (double[] a : dp[t]) {\n\t\t\t\tArrays.fill(a, -1);\n\t\t\t}\n\t\t\tboolean update = false;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tif (dp[1 - t][i][j] < 0) continue;\n\t\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\t\tif (!ok[i][j][k] || dp[1 - t][i][j] < dist[j][k]) continue;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tdp[t][j][k] = Math.max(dp[t][j][k], dp[1 - t][i][j] - dist[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) {\n\t\t\t\tSystem.out.println(turn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt = 1 - t;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Carrot Tour\npublic class Main{\n\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble angleCos(double[] a, double[] b){\n\t\tdouble na = norm(a), nb = norm(b);\n\t\treturn Math.acos(dot(a, b)/na/nb);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble EPS = 1e-10;\n\tint INF = 1<<29;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tdouble R = sc.nextDouble(), thita = sc.nextDouble()*Math.PI/180;\n\t\tdouble[][] p = new double[n][2];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<2;j++)p[i][j]=sc.nextDouble();\n\t\tdouble[][] d = new double[n][n];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)d[i][j]=Math.hypot(p[i][0]-p[j][0], p[i][1]-p[j][1]);\n\t\tList<Integer>[][] l = new List[n][n];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\tl[i][j] = new ArrayList<Integer>();\n\t\t\tif(i==j)continue;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(k==i)continue;\n\t\t\t\tdouble t = angleCos(sub(p[k], p[i]), sub(p[i], p[j]));\n\t\t\t\tif(t<thita+EPS)l[i][j].add(k);\n\t\t\t}\n\t\t}\n\t\tdouble[][] dp = new double[n][n];\n\t\tfor(double[]a:dp)Arrays.fill(a, INF);\n\t\tint res = 0;\n\t\tboolean f = false;\n\t\tfor(int k=1;k<n;k++)if(d[0][k]<R+EPS){\n\t\t\tf = true; dp[k][0] = d[0][k];\n\t\t}\n\t\twhile(f){\n\t\t\tres++;\n\t\t\tf = false;\n\t\t\tdouble[][] next = new double[n][n];\n\t\t\tfor(double[]a:next)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(i==j||dp[i][j]==INF)continue;\n\t\t\t\tfor(int k:l[i][j]){\n\t\t\t\t\tif(dp[i][j]+d[i][k]<R+EPS){\n\t\t\t\t\t\tnext[k][i] = Math.min(next[k][i], dp[i][j]+d[i][k]); f = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = next;\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.Function;\n\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n\n    double function(final double y, double a, final double dx) {\n        double nx = a + dx;\n        if (Math.abs(Math.floor(a) - Math.floor(nx)) < 1e-6) {\n            double sx1 = Math.floor(a);\n            double sx2 = sx1 + 1;\n            double rx1 = Math.floor(nx);\n            double rx2 = rx1 + 1;\n            double dist = Math.min(a - sx1 + nx - rx1, sx2 - a + rx2 - nx);\n            return y + dist;\n        } else {\n            return y + nx - a;\n        }\n    }\n\n    static class Point {\n        int x, y;\n\n        Point(int a, int b) {\n            x = a;\n            y = b;\n        }\n\n        static Point p(int x, int y) {\n            return new Point(x, y);\n        }\n    }\n\n    double kaku(Point p1, Point p2, Point p3) {\n        int dx1 = p2.x - p1.x;\n        int dy1 = p2.y - p1.y;\n        int dx2 = p3.x - p2.x;\n        int dy2 = p3.y - p2.y;\n\n        int naiseki = dx1 * dx2 + dy1 * dy2;\n        double z1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        double z2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        return Math.acos(naiseki / (z1 * z2)) * 180 / Math.PI;\n    }\n\n    double dist(Point p1, Point p2) {\n        double dx = p1.x - p2.x;\n        double dy = p1.y - p2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    class Node {\n        int now;\n        int prev;\n        int done;\n        double[] map = new double[20];\n        int[] cnt = new int[20];\n        int flag;\n    }\n\n    void run() {\n        int n = ni();\n        double r = sc.nextDouble();\n        double theta = sc.nextDouble();\n        Point[] p = new Point[n];\n        for (int i = 0; i < n; ++i) {\n            int x = ni();\n            int y = ni();\n            p[i] = new Point(x, y);\n        }\n        Node atom = new Node();\n        atom.cnt[0] = 0;\n        atom.map[0] = 0;\n        atom.now = 0;\n        atom.prev = -1;\n        atom.done = 1;\n        atom.flag = 0;\n        PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.map[a.now]));\n        queue.add(atom);\n        int max = 0;\n        boolean[][][][] done = new boolean[2][n][n + 1][1 << n];\n        while (queue.size() > 0) {\n            Node node = queue.poll();\n            if (done[node.flag][node.now][node.prev + 1][node.done]) {\n                continue;\n            }\n            done[node.flag][node.now][node.prev + 1][node.done] = true;\n            max = Math.max(max, node.cnt[node.now]);\n            for (int i = 0; i < n; ++i) {\n                if (node.now == i) {\n                    continue;\n                }\n                if (node.prev == -1 || kaku(p[node.prev], p[node.now], p[i]) <= theta + 1e-3) {\n                    if (node.flag == 0 && ((node.done >> i) & 1) == 1) {\n                        // loop\n                        int tugi = node.cnt[node.now] + 1;\n                        int mae = node.cnt[i];\n                        int diff = tugi - mae;\n                        double loop = node.map[node.now] + dist(p[node.now], p[i]) - node.map[i];\n                        double nokori = r - (node.map[node.now] + dist(p[node.now], p[i]));\n                        int cnt = (int) (nokori / loop);\n                        Node next = new Node();\n                        next.now = i;\n                        next.done = 1 << i;\n                        next.cnt[i] = node.cnt[node.now] + 1 + cnt * diff;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]) + cnt * loop;\n                        if (next.map[i] > r + 1e-3) {\n                            continue;\n                        }\n                        next.prev = node.now;\n                        next.flag = 1;\n                        queue.add(next);\n                    } else {\n                        Node next = new Node();\n                        next.now = i;\n                        System.arraycopy(node.cnt, 0, next.cnt, 0, 20);\n                        System.arraycopy(node.map, 0, next.map, 0, 20);\n                        next.cnt[i] = node.cnt[node.now] + 1;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]);\n                        if (next.map[i] > r + 1e-3) {\n                            continue;\n                        }\n                        next.prev = node.now;\n                        next.done = node.done | 1 << i;\n                        next.flag = node.flag;\n                        queue.add(next);\n                    }\n                }\n            }\n        }\n        System.out.println(max);\n    }\n\n    final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n    double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n        double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        double d1 = f.apply(c1);\n        double d2 = f.apply(c2);\n        for (int i = 0; i < 10000000; ++i) {\n            if (comp.compare(d1, d2) > 0) {\n                right = c2;\n                c2 = c1;\n                d2 = d1;\n                c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n                d1 = f.apply(c1);\n            } else {\n                left = c1;\n                c1 = c2;\n                d1 = d2;\n                c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n                d2 = f.apply(c2);\n            }\n        }\n        return left;\n    }\n\n    double divideInternally(double a, double b, double m, double n) {\n        return (n * a + m * b) / (m + n);\n    }\n\n    int ni() {\n        return sc.nextInt();\n    }\n\n    static public void main(String[] args) {\n        new Main().run();\n    }\n\n    void debug(Object... os) {\n        System.err.println(Arrays.deepToString(os));\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.Function;\n\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n\n    double function(final double y, double a, final double dx) {\n        double nx = a + dx;\n        if (Math.abs(Math.floor(a) - Math.floor(nx)) < 1e-6) {\n            double sx1 = Math.floor(a);\n            double sx2 = sx1 + 1;\n            double rx1 = Math.floor(nx);\n            double rx2 = rx1 + 1;\n            double dist = Math.min(a - sx1 + nx - rx1, sx2 - a + rx2 - nx);\n            return y + dist;\n        } else {\n            return y + nx - a;\n        }\n    }\n\n    static class Point {\n        int x, y;\n\n        Point(int a, int b) {\n            x = a;\n            y = b;\n        }\n\n        static Point p(int x, int y) {\n            return new Point(x, y);\n        }\n    }\n\n    double kaku(Point p1, Point p2, Point p3) {\n        int dx1 = p2.x - p1.x;\n        int dy1 = p2.y - p1.y;\n        int dx2 = p3.x - p2.x;\n        int dy2 = p3.y - p2.y;\n\n        int naiseki = dx1 * dx2 + dy1 * dy2;\n        double z1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        double z2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        return Math.acos(naiseki / (z1 * z2)) * 180 / Math.PI;\n    }\n\n    double dist(Point p1, Point p2) {\n        double dx = p1.x - p2.x;\n        double dy = p1.y - p2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    class Node {\n        int now;\n        int prev;\n        int done;\n        double[] map = new double[20];\n        int[] cnt = new int[20];\n        int flag;\n    }\n\n    void run() {\n        int n = ni();\n        double r = sc.nextDouble();\n        double theta = sc.nextDouble();\n        Point[] p = new Point[n];\n        for (int i = 0; i < n; ++i) {\n            int x = ni();\n            int y = ni();\n            p[i] = new Point(x, y);\n        }\n        Node atom = new Node();\n        atom.cnt[0] = 0;\n        atom.map[0] = 0;\n        atom.now = 0;\n        atom.prev = -1;\n        atom.done = 1;\n        atom.flag = 0;\n        PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.map[a.now]));\n        queue.add(atom);\n        int max = 0;\n        boolean[][][][] done = new boolean[2][n][n + 1][1 << n];\n        while (queue.size() > 0) {\n            Node node = queue.poll();\n            if (done[node.flag][node.now][node.prev + 1][node.done]) {\n                continue;\n            }\n            done[node.flag][node.now][node.prev + 1][node.done] = true;\n            max = Math.max(max, node.cnt[node.now]);\n            for (int i = 0; i < n; ++i) {\n                if (node.now == i) {\n                    continue;\n                }\n                if (node.prev == -1 || kaku(p[node.prev], p[node.now], p[i]) <= theta + 1e-3) {\n                    if (node.flag == 0 && ((node.done >> i) & 1) == 1) {\n                        // loop\n                        int tugi = node.cnt[node.now] + 1;\n                        int mae = node.cnt[i];\n                        int diff = tugi - mae;\n                        double loop = node.map[node.now] + dist(p[node.now], p[i]) - node.map[i];\n                        double nokori = r - (node.map[node.now] + dist(p[node.now], p[i]));\n                        int cnt = (int) (nokori / loop);\n                        Node next = new Node();\n                        next.now = i;\n                        next.done = 1 << i;\n                        next.cnt[i] = node.cnt[node.now] + 1 + cnt * diff;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]) + cnt * loop;\n                        next.prev = node.now;\n                        next.flag = 1;\n                        queue.add(next);\n                    } else {\n                        Node next = new Node();\n                        next.now = i;\n                        System.arraycopy(node.cnt, 0, next.cnt, 0, 20);\n                        System.arraycopy(node.map, 0, next.map, 0, 20);\n                        next.cnt[i] = node.cnt[node.now] + 1;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]);\n                        if (next.map[i] > r + 1e-3) {\n                            continue;\n                        }\n                        next.prev = node.now;\n                        next.done = node.done | 1 << i;\n                        next.flag = node.flag;\n                        queue.add(next);\n                    }\n                }\n            }\n        }\n        System.out.println(max);\n    }\n\n    final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n    double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n        double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        double d1 = f.apply(c1);\n        double d2 = f.apply(c2);\n        for (int i = 0; i < 10000000; ++i) {\n            if (comp.compare(d1, d2) > 0) {\n                right = c2;\n                c2 = c1;\n                d2 = d1;\n                c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n                d1 = f.apply(c1);\n            } else {\n                left = c1;\n                c1 = c2;\n                d1 = d2;\n                c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n                d2 = f.apply(c2);\n            }\n        }\n        return left;\n    }\n\n    double divideInternally(double a, double b, double m, double n) {\n        return (n * a + m * b) / (m + n);\n    }\n\n    int ni() {\n        return sc.nextInt();\n    }\n\n    static public void main(String[] args) {\n        new Main().run();\n    }\n\n    void debug(Object... os) {\n        System.err.println(Arrays.deepToString(os));\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static void solve() {\n\t\tint n = nei();\n\t\tif (n == 1)\n\t\t\tkil(0);\n\t\tdouble r = ned();\n\t\tdouble theta = ned() * Math.PI / 180.0;\n\t\tint[][] xy = nis2(n, 2);\n\t\tint N = n * n;\n\t\tdouble[] angles = new double[N];\n\t\tdouble[] dists = new double[N];\n\t\tdouble[][] costs = new double[N][N];\n\t\tint[][] idx = new int[n][n];\n\t\tint aaa = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n//\t\t\t\tSystem.out.println(i + \" \" + j);\n\t\t\t\tidx[i][j] = aaa;\n\t\t\t\taaa++;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint x1 = xy[i][0];\n\t\t\t\tint y1 = xy[i][1];\n\t\t\t\tint x2 = xy[j][0];\n\t\t\t\tint y2 = xy[j][1];\n\t\t\t\tint dx = x2 - x1;\n\t\t\t\tint dy = y2 - y1;\n\t\t\t\tangles[idx[i][j]] = Math.atan2(dy, dx);\n\t\t\t\tif (i == j)\n\t\t\t\t\tdists[idx[i][j]] = Double.POSITIVE_INFINITY;\n\t\t\t\telse\n\t\t\t\t\tdists[idx[i][j]] = Math.sqrt(dx * dx + dy * dy);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < N; i++) {\n//\t\t\tString a = \"\";\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tboolean ok = false;\n\t\t\t\tfor (int ii = 0; ii < n; ii++) {\n\t\t\t\t\tfor (int jj = 0; jj < n; jj++) {\n\t\t\t\t\t\tfor (int kk = 0; kk < n; kk++) {\n\t\t\t\t\t\t\tif (idx[ii][jj] == i && idx[jj][kk] == j)\n\t\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!ok) {\n\t\t\t\t\tcosts[i][j] = Double.POSITIVE_INFINITY;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble cost1 = dists[i];\n\t\t\t\tdouble cost2 = dists[j];\n\t\t\t\tdouble adiff = angles[i] - angles[j];\n\t\t\t\tadiff += Math.PI;\n\t\t\t\tadiff %= Math.PI * 2;\n\t\t\t\tadiff -= Math.PI;\n\t\t\t\tif (i == j || cost1 == Double.POSITIVE_INFINITY || adiff < -theta || adiff > theta) {\n\t\t\t\t\tcosts[i][j] = Double.POSITIVE_INFINITY;\n\t\t\t\t} else {\n\t\t\t\t\tcosts[i][j] = cost2;\n\t\t\t\t}\n//\t\t\t\ta += (costs[i][j] == Double.POSITIVE_INFINITY ? \"INF\" : (int) (costs[i][j] * 100) / 100.0) + \"  \\t\";\n\t\t\t}\n//\t\t\tSystem.out.println(a);\n\t\t}\n\n\t\tint min = 1; // incl\n\t\tint max = 10000; // excl\n\t\twhile (max - min > 1) {\n\t\t\tint mid = min + max >> 1;\n\t\t\tdouble[][] mat = matpow(costs, mid, N);\n\t\t\tboolean ok = false;\n\t\t\tL: for (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (mat[i][j] <= r) {\n\t\t\t\t\t\tok = true;\n//\t\t\t\t\t\tSystem.out.println(i + \" \" + j + \" \" + mat[i][j] + \" \" + mid);\n\t\t\t\t\t\tbreak L;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tmin = mid;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\n\tstatic double[][] matpow(double[][] mat, int exp, int n) {\n\t\tif (exp == 1)\n\t\t\treturn mat;\n\t\tdouble[][] a, b;\n\t\tif (exp % 2 == 0) {\n\t\t\ta = matpow(mat, exp >> 1, n);\n\t\t\tb = a;\n\t\t} else {\n\t\t\ta = matpow(mat, exp - 1, n);\n\t\t\tb = mat;\n\t\t}\n\t\tdouble[][] res = new double[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdouble min = Double.POSITIVE_INFINITY;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tdouble len = a[i][k] + b[k][j];\n\t\t\t\t\tif (len < min)\n\t\t\t\t\t\tmin = len;\n\t\t\t\t}\n\t\t\t\tres[i][j] = min;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic boolean ok(long mincost, long k, int n, int[][] ad) {\n\t\tlong num = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = ad[i][0];\n\t\t\tint d = ad[i][1];\n\t\t\tnum += max(0, (mincost - a + d) / d);\n\t\t}\n\t\treturn num <= k;\n\t}\n\n\t// returns (x, y, d) s.t. ax + by = d\n\tstatic long[] exgcd(long a, long b) {\n\t\tint sa = a < 0 ? -1 : 1;\n\t\tint sb = b < 0 ? -1 : 1;\n\t\ta *= sa;\n\t\tb *= sb;\n\t\tlong x = 1;\n\t\tlong y = 0;\n\t\tlong z = 0;\n\t\tlong w = 1;\n\t\twhile (b > 0) {\n\t\t\tlong q = a / b;\n\t\t\tlong t = z;\n\t\t\tz = x - q * z;\n\t\t\tx = t;\n\t\t\tt = w;\n\t\t\tw = y - q * w;\n\t\t\ty = t;\n\t\t\tt = b;\n\t\t\tb = a - q * b;\n\t\t\ta = t;\n\t\t}\n\t\treturn new long[] { x * sa, y * sb, a };\n\t}\n\n\tstatic int[] lis(int[] s) {\n\t\tint n = s.length;\n\t\tint[] dp = new int[n];\n\t\tint[] ids = new int[n];\n\t\tint[] pids = new int[n];\n\t\tdp[0] = s[0];\n\t\tint len = 1;\n\t\tint lidx = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint idx = bs(s[i], dp, 0, len);\n\t\t\tdp[idx] = s[i];\n\t\t\tids[idx] = i;\n\t\t\tif (idx == len) {\n\t\t\t\tlidx = i;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (idx > 0)\n\t\t\t\tpids[i] = ids[idx - 1];\n\t\t}\n\t\tint[] lis = new int[len];\n\t\tlis[len - 1] = s[lidx];\n\t\tfor (int i = len - 1; i >= 0; i--) {\n\t\t\tlis[i] = s[lidx];\n\t\t\tlidx = pids[lidx];\n\t\t}\n\t\treturn lis;\n\t}\n\n\tstatic int bs(int a, int[] as, int from, int num) {\n\t\tint min = from;\n\t\tint max = from + num - 1;\n\t\twhile (min < max) {\n\t\t\tint mid = min + max >> 1;\n\t\t\tif (as[mid] < a)\n\t\t\t\tmin = mid + 1;\n\t\t\telse if (as[mid] > a)\n\t\t\t\tmax = mid;\n\t\t\telse\n\t\t\t\treturn mid;\n\t\t}\n\t\treturn as[min] < a ? min + 1 : min;\n\t}\n\n\tstatic int gcd(int x, int y) {\n\t\tx = (x ^ x >> 31) - (x >> 31);\n\t\ty = (y ^ y >> 31) - (y >> 31);\n\t\tif (x < y) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tint z = x % y;\n\t\tif (z == 0)\n\t\t\treturn y;\n\t\treturn gcd(y, z);\n\t}\n\n\tstatic long gcd(long x, long y) {\n\t\tx = (x ^ x >> 63) - (x >> 63);\n\t\ty = (y ^ y >> 63) - (y >> 63);\n\t\tif (x < y) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tlong z = x % y;\n\t\tif (z == 0)\n\t\t\treturn y;\n\t\treturn gcd(y, z);\n\t}\n\n\tstatic long modinv(long a, long mod) {\n\t\treturn modpow(a, mod - 2, mod);\n\t}\n\n\tstatic long modpow(long a, long b, long mod) {\n\t\tif (b == 0)\n\t\t\treturn 1;\n\t\tif ((b & 1) == 0) {\n\t\t\tlong sqrt = modpow(a, b >> 1, mod);\n\t\t\treturn sqrt * sqrt % mod;\n\t\t}\n\t\treturn a * modpow(a, b - 1, mod) % mod;\n\t}\n\n\tstatic long fact(long n) {\n\t\tif (n <= 1)\n\t\t\treturn 1;\n\t\tlong res = 2;\n\t\tfor (long i = 3; i <= n; i++) {\n\t\t\tres *= i;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long modfact(long n, long mod) {\n\t\tif (n <= 1)\n\t\t\treturn 1 % mod;\n\t\tlong res = 2;\n\t\tfor (long i = 3; i <= n; i++) {\n\t\t\tres *= i;\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res % mod;\n\t}\n\n\t// returns facts([0]) and invfacts([1])\n\tstatic long[][] enumfacts(int n, long mod) {\n\t\tint num = n + 10;\n\t\tlong[][] res = new long[2][num];\n\t\tlong[] facts = res[0];\n\t\tlong[] invfacts = res[1];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tif (i <= 1) {\n\t\t\t\tfacts[i] = 1;\n\t\t\t\tinvfacts[i] = 1;\n\t\t\t} else {\n\t\t\t\tfacts[i] = facts[i - 1] * i % mod;\n\t\t\t\tinvfacts[i] = modinv(facts[i], mod);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long modcomb(long n, long m, long mod) {\n\t\tif (m > n)\n\t\t\treturn 0;\n\t\tif (m > n - m) {\n\t\t\tm = n - m;\n\t\t}\n\t\tlong numer = 1;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tnumer = numer * (n - i) % mod;\n\t\t}\n\t\tlong denom = modfact(m, mod);\n\t\treturn numer * denom % mod;\n\t}\n\n\tstatic long modcomb(int n, int m, long[] facts, long[] invfacts, long mod) {\n\t\tif (m > n)\n\t\t\treturn 0;\n\t\tlong numer = facts[n];\n\t\tlong denom = invfacts[m] * invfacts[n - m] % mod;\n\t\treturn numer * denom % mod;\n\t}\n\n\t// res[i][0]: prime factor, res[i][1]: exponent\n\tstatic int[][] factorize(int n) {\n\t\tint[][] pfs = new int[32][2];\n\t\tint num = 0;\n\t\tfor (int i = 2; i * i <= n; i++) {\n\t\t\tint count = 0;\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (count > 0) {\n\t\t\t\tpfs[num][0] = i;\n\t\t\t\tpfs[num][1] = count;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tif (n > 1) {\n\t\t\tpfs[num][0] = n;\n\t\t\tpfs[num][1] = 1;\n\t\t\tnum++;\n\t\t}\n\t\tint[][] res = new int[num][2];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tres[i][0] = pfs[i][0];\n\t\t\tres[i][1] = pfs[i][1];\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long lcm(long x, long y) {\n\t\tx = (x ^ x >> 63) - (x >> 63);\n\t\ty = (y ^ y >> 63) - (y >> 63);\n\t\treturn x / gcd(x, y) * y;\n\t}\n\n\tstatic int abs(int x) {\n\t\treturn x < 0 ? -x : x;\n\t}\n\n\tstatic long abs(long x) {\n\t\treturn x < 0 ? -x : x;\n\t}\n\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic long min(long a, long b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic int max(int a, int b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic long max(long a, long b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic int clamp(int a, int min, int max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic long clamp(long a, long min, long max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic double clamp(double a, double min, double max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic void out(String val) {\n\t\tIO.out(val);\n\t}\n\n\tstatic void out(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(int val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(long val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(char val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t}\n\n\tstatic void out(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t}\n\n\tstatic void kil(String val) {\n\t\tIO.out(val);\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(int val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(long val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(char val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic String nes() {\n\t\treturn IO.next();\n\t}\n\n\tstatic int nei() {\n\t\treturn IO.nextInt();\n\t}\n\n\tstatic long nel() {\n\t\treturn IO.nextLong();\n\t}\n\n\tstatic double ned() {\n\t\treturn IO.nextDouble();\n\t}\n\n\tstatic char nec() {\n\t\treturn IO.nextChar();\n\t}\n\n\tstatic String[] nss(int n) {\n\t\tString[] as = new String[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.next();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[] nis(int n) {\n\t\tint[] as = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextInt();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[] nls(int n) {\n\t\tlong[] as = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextLong();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[] nds(int n) {\n\t\tdouble[] as = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextDouble();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[] ncs(int n) {\n\t\tchar[] as = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextChar();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic String[][] nss2(int n, int m) {\n\t\tString[][] as = new String[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.next();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[][] nis2(int n, int m) {\n\t\tint[][] as = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[][] nls2(int n, int m) {\n\t\tlong[][] as = new long[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextLong();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[][] nds2(int n, int m) {\n\t\tdouble[][] as = new double[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextDouble();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[][] ncs2(int n, int m) {\n\t\tchar[][] as = new char[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextChar();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int parseInt(String val) {\n\t\treturn Integer.parseInt(val);\n\t}\n\n\tstatic int parseInt(char val) {\n\t\treturn Integer.parseInt(String.valueOf(val));\n\t}\n\n\tstatic long parseLong(String val) {\n\t\treturn Long.parseLong(val);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tsolve();\n\t\t\tIO.flush();\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\nfinal class IO {\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out, false);\n\tprivate static final byte[] buffer = new byte[1024];\n\tprivate static int ptr = 0;\n\tprivate static int len = 0;\n\n\tprivate static boolean hasNextByte() {\n\t\tif (ptr < len)\n\t\t\treturn true;\n\t\tptr = 0;\n\t\ttry {\n\t\t\tlen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn len > 0;\n\t}\n\n\tprivate static int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tstatic boolean hasNext() {\n\t\tbyte c;\n\t\twhile (hasNextByte() && ((c = buffer[ptr]) < '!' || c > '~'))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tstatic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (b >= '!' && b <= '~') {\n\t\t\tsb.append((char) b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic char nextChar() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\treturn (char) readByte();\n\t}\n\n\tstatic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tint n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic void out(String val) {\n\t\tout.println(val);\n\t}\n\n\tstatic void flush() {\n\t\tout.flush();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  static class Point {\n    int x, y;\n\n    Point(int a, int b) {\n      x = a;\n      y = b;\n    }\n\n    static Point p(int x, int y) {\n      return new Point(x, y);\n    }\n  }\n\n  double kaku(Point p1, Point p2, Point p3) {\n    int dx1 = p2.x - p1.x;\n    int dy1 = p2.y - p1.y;\n    int dx2 = p3.x - p2.x;\n    int dy2 = p3.y - p2.y;\n\n    int naiseki = dx1 * dx2 + dy1 * dy2;\n    double z1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n    double z2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n    return Math.acos(naiseki / (z1 * z2)) * 180 / Math.PI;\n  }\n\n  double dist(Point p1, Point p2) {\n    double dx = p1.x - p2.x;\n    double dy = p1.y - p2.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  class Node {\n    int now;\n    int prev;\n    int cnt;\n    double r;\n  }\n\n  void run() {\n    int n = ni();\n    double r = sc.nextDouble();\n    double theta = sc.nextDouble();\n    Point[] p = new Point[n];\n    for (int i = 0; i < n; ++i) {\n      int x = ni();\n      int y = ni();\n      p[i] = new Point(x, y);\n    }\n    Node atom = new Node();\n    atom.cnt = 0;\n    atom.r = 0;\n    atom.now = 0;\n    atom.prev = -1;\n    PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.r));\n    queue.add(atom);\n    double[][][] dp = new double[10000 + 1][n][n + 1];\n    for (double[][] t : dp) for (double[] a : t) Arrays.fill(a, Double.MAX_VALUE);\n    while (queue.size() > 0) {\n      Node node = queue.poll();\n      if (dp[node.cnt][node.now][node.prev + 1] <= node.r) {\n        continue;\n      }\n      dp[node.cnt][node.now][node.prev + 1] = node.r;\n      for (int i = 0; i < n; ++i) {\n        if (node.now == i) {\n          continue;\n        }\n        if (node.prev == -1 || kaku(p[node.prev], p[node.now], p[i]) <= theta + 1e-3) {\n          Node next = new Node();\n          next.now = i;\n          next.cnt = node.cnt + 1;\n          next.r = node.r + dist(p[node.now], p[i]);\n          if (next.r > r + 1e-3) {\n            continue;\n          }\n          next.prev = node.now;\n          queue.add(next);\n        }\n      }\n    }\n    int max = 0;\n    for (int i = 0; i <= 10000; ++i) {\n      for (double[] a : dp[i]) {\n        for (double v : a) {\n          if (v <= r + 1e-3) {\n            max = Math.max(max, i);\n          }\n        }\n      }\n    }\n    System.out.println(max);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.Function;\n\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n\n    double function(final double y, double a, final double dx) {\n        double nx = a + dx;\n        if (Math.abs(Math.floor(a) - Math.floor(nx)) < 1e-6) {\n            double sx1 = Math.floor(a);\n            double sx2 = sx1 + 1;\n            double rx1 = Math.floor(nx);\n            double rx2 = rx1 + 1;\n            double dist = Math.min(a - sx1 + nx - rx1, sx2 - a + rx2 - nx);\n            return y + dist;\n        } else {\n            return y + nx - a;\n        }\n    }\n\n    static class Point {\n        int x, y;\n\n        Point(int a, int b) {\n            x = a;\n            y = b;\n        }\n\n        static Point p(int x, int y) {\n            return new Point(x, y);\n        }\n    }\n\n    double kaku(Point p1, Point p2, Point p3) {\n        int dx1 = p2.x - p1.x;\n        int dy1 = p2.y - p1.y;\n        int dx2 = p3.x - p2.x;\n        int dy2 = p3.y - p2.y;\n\n        int naiseki = dx1 * dx2 + dy1 * dy2;\n        double z1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        double z2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        return Math.acos(naiseki / (z1 * z2)) * 180 / Math.PI;\n    }\n\n    double dist(Point p1, Point p2) {\n        double dx = p1.x - p2.x;\n        double dy = p1.y - p2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    class Node {\n        int now;\n        int prev;\n        int done;\n        double[] map = new double[20];\n        int[] cnt = new int[20];\n        int flag;\n    }\n\n    void run() {\n        int n = ni();\n        double r = sc.nextDouble();\n        double theta = sc.nextDouble();\n        Point[] p = new Point[n];\n        for (int i = 0; i < n; ++i) {\n            int x = ni();\n            int y = ni();\n            p[i] = new Point(x, y);\n        }\n        Node atom = new Node();\n        atom.cnt[0] = 0;\n        atom.map[0] = 0;\n        atom.now = 0;\n        atom.prev = -1;\n        atom.done = 1;\n        atom.flag = 0;\n        PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.map[a.now]));\n        queue.add(atom);\n        int max = 0;\n        boolean[][][] done = new boolean[2][n][1 << n];\n        while (queue.size() > 0) {\n            Node node = queue.poll();\n            if (done[node.flag][node.now][node.done]) {\n                continue;\n            }\n            done[node.flag][node.now][node.done] = true;\n            max = Math.max(max, node.cnt[node.now]);\n            for (int i = 0; i < n; ++i) {\n                if (node.now == i) {\n                    continue;\n                }\n                if (node.prev == -1 || kaku(p[node.prev], p[node.now], p[i]) < theta) {\n                    if (node.flag == 0 && ((node.done >> i) & 1) == 1) {\n                        // loop\n                        int tugi = node.cnt[node.now] + 1;\n                        int mae = node.cnt[i];\n                        int diff = tugi - mae;\n                        double loop = node.map[node.now] + dist(p[node.now], p[i]) - node.map[i];\n                        double nokori = r - (node.map[node.now] + dist(p[node.now], p[i]));\n                        int cnt = (int) (nokori / loop);\n                        Node next = new Node();\n                        next.now = i;\n                        next.done = 1 << i;\n                        next.cnt[i] = node.cnt[node.now] + 1 + cnt * diff;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]) + cnt * loop;\n                        next.prev = node.now;\n                        next.flag = 1;\n                        queue.add(next);\n                    } else {\n                        Node next = new Node();\n                        next.now = i;\n                        next.cnt[i] = node.cnt[node.now] + 1;\n                        next.map[i] = node.map[node.now] + dist(p[node.now], p[i]);\n                        if (next.map[i] > r) {\n                            continue;\n                        }\n                        next.prev = node.now;\n                        next.done |= node.done | 1 << i;\n                        next.flag = node.flag;\n                        queue.add(next);\n                    }\n                }\n            }\n        }\n        System.out.println(max);\n    }\n\n    final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n\n    double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n        double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        double d1 = f.apply(c1);\n        double d2 = f.apply(c2);\n        for (int i = 0; i < 10000000; ++i) {\n            if (comp.compare(d1, d2) > 0) {\n                right = c2;\n                c2 = c1;\n                d2 = d1;\n                c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n                d1 = f.apply(c1);\n            } else {\n                left = c1;\n                c1 = c2;\n                d1 = d2;\n                c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n                d2 = f.apply(c2);\n            }\n        }\n        return left;\n    }\n\n    double divideInternally(double a, double b, double m, double n) {\n        return (n * a + m * b) / (m + n);\n    }\n\n    int ni() {\n        return sc.nextInt();\n    }\n\n    static public void main(String[] args) {\n        new Main().run();\n    }\n\n    void debug(Object... os) {\n        System.err.println(Arrays.deepToString(os));\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  static class Point {\n    int x, y;\n\n    Point(int a, int b) {\n      x = a;\n      y = b;\n    }\n\n    static Point p(int x, int y) {\n      return new Point(x, y);\n    }\n  }\n\n  double kaku(Point p1, Point p2, Point p3) {\n    int dx1 = p2.x - p1.x;\n    int dy1 = p2.y - p1.y;\n    int dx2 = p3.x - p2.x;\n    int dy2 = p3.y - p2.y;\n\n    int naiseki = dx1 * dx2 + dy1 * dy2;\n    double z1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n    double z2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n    return Math.acos(naiseki / (z1 * z2)) * 180 / Math.PI;\n  }\n\n  double dist(Point p1, Point p2) {\n    double dx = p1.x - p2.x;\n    double dy = p1.y - p2.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  class Node {\n    int now;\n    int prev;\n    int cnt;\n    double r;\n  }\n\n  void run() {\n    int n = ni();\n    double r = sc.nextDouble();\n    double theta = sc.nextDouble();\n    Point[] p = new Point[n];\n    for (int i = 0; i < n; ++i) {\n      int x = ni();\n      int y = ni();\n      p[i] = new Point(x, y);\n    }\n    Node atom = new Node();\n    atom.cnt = 0;\n    atom.r = 0;\n    atom.now = 0;\n    atom.prev = -1;\n    PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.r));\n    queue.add(atom);\n    double[][][] dp = new double[n][n + 1][10000 + 1];\n    for (double[][] t : dp) for (double[] a : t) Arrays.fill(a, Double.MAX_VALUE);\n    while (queue.size() > 0) {\n      Node node = queue.poll();\n      if (dp[node.now][node.prev + 1][node.cnt] <= node.r) {\n        continue;\n      }\n      dp[node.now][node.prev + 1][node.cnt] = node.r;\n      for (int i = 0; i < n; ++i) {\n        if (node.now == i) {\n          continue;\n        }\n        if (node.prev == -1 || kaku(p[node.prev], p[node.now], p[i]) <= theta + 1e-3) {\n          if (dp[i][node.now + 1][node.cnt + 1] <= node.r) {\n            continue;\n          }\n          Node next = new Node();\n          next.now = i;\n          next.cnt = node.cnt + 1;\n          next.r = node.r + dist(p[node.now], p[i]);\n          if (next.r > r + 1e-3) {\n            continue;\n          }\n          next.prev = node.now;\n          queue.add(next);\n        }\n      }\n    }\n    int max = 0;\n    for (int i = 0; i <= 10000; ++i) {\n      for (double[][] t : dp) {\n        for (double[] a : t) {\n          if (a[i] <= r + 1e-3) {\n            max = Math.max(max, i);\n          }\n        }\n      }\n    }\n    System.out.println(max);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic boolean[][][] ok;\n\tstatic double[][] dist;\n\n\tpublic static void main(String[] args) {\n\t\tN = sc.nextInt();\n\t\tdouble R = sc.nextDouble();\n\t\tdouble theta = sc.nextDouble();\n\t\tint[] X = new int[N];\n\t\tint[] Y = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tX[i] = sc.nextInt();\n\t\t\tY[i] = sc.nextInt();\n\t\t}\n\t\tok = new boolean[N][N][N];\n\t\tdist = new double[N][N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tdist[i][j] = Math.sqrt((X[i] - X[j]) * (X[i] - X[j]) + (Y[i] - Y[j]) * (Y[i] - Y[j]));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (k == i || k == j) continue;\n\t\t\t\t\tint dx1 = X[j] - X[i];\n\t\t\t\t\tint dy1 = X[k] - X[j];\n\t\t\t\t\tint dx2 = Y[j] - Y[i];\n\t\t\t\t\tint dy2 = Y[k] - Y[j];\n\t\t\t\t\tdouble arg = Math.abs(Math.acos((dx1 * dx2 + dy1 * dy2) / dist[i][j] / dist[j][k])) * 180 / Math.PI;\n\t\t\t\t\tok[i][j][k] = arg <= theta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble[][][] dp = new double[2][N][N];\n\t\tfor (double[][] a : dp) {\n\t\t\tfor (double[] aa : a) {\n\t\t\t\tArrays.fill(aa, -1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tif (dist[0][i] <= R) {\n\t\t\t\tdp[0][0][i] = R - dist[0][i];\n\t\t\t}\n\t\t}\n\t\tint t = 1;\n\t\tfor (int turn = 0;; ++turn) {\n\t\t\tfor (double[] a : dp[t]) {\n\t\t\t\tArrays.fill(a, -1);\n\t\t\t}\n\t\t\tboolean update = false;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tif (dp[1 - t][i][j] < 0) continue;\n\t\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\t\tif (!ok[i][j][k] || dp[1 - t][i][j] < dist[j][k]) continue;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tdp[t][j][k] = Math.max(dp[t][j][k], dp[1 - t][i][j] - dist[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) {\n\t\t\t\tSystem.out.println(turn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt = 1 - t;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nrequire 'set'\ninclude Math\n\nn = gets.to_i\nif n == 1\n\tputs 0\n\texit\nend\n\nr, theta = gets.split.map &:to_f\ncos = cos(PI * theta / 180)\n\npoints = (1..n).map{gets.split.map &:to_f}\n\nneighbour = {}\nstack = []\n(0..n-1).each{|i|\n\t((0..n-1).to_a - [i]).map{|j| \n\t\te = [i, j]\n\t\tv1 = Vector[*points[j]] - Vector[*points[i]]\n\t\tstack << [i, j, v1.r, 1] if i == 0 && v1.r < r\n\t\t((0..n-1).to_a - [j]).each{|k|\n\t\t\tf = [j, k]\n\t\t\tv2 = Vector[*points[k]] - Vector[*points[j]]\n\t\t\tif v1.inner_product(v2) / (v1.r * v2.r) > cos\n\t\t\t\t(neighbour[e] ||= Set.new) << f\n\t\t\tend\n\t\t}\n\t}\n}\n\nbest = 1\nuntil stack.empty?\n\ti, j, d, c = stack.pop\n\t#p [i, j, d, c]\n\t(neighbour[[i, j]] || []).each{|_, k|\n\t\tv = Vector[*points[k]] - Vector[*points[j]]\n\t\tadd = v.r\n\t\tif d + add < r\n\t\t\tstack << [j, k, d+add, c+1]\n\t\t\tbest = c+1 if c+1 > best\n\t\tend\n\t}\nend\n\np best"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\ninclude Math\n\nn = gets.to_i\nr, t = gets.split.map(&:to_f)\n\nnodes = (1..n).map { gets.split.map(&:to_i) }\nedges = nodes.permutation(2).map(&:flatten)\n\ng = (0..edges.size-1).map { {} }\n(0..edges.size-1).to_a.permutation(2) do |i, j|\n    x1, y1, x2, y2 = edges[i]\n    x3, y3, x4, y4 = edges[j]\n    next unless x2 == x3 && y2 == y3\n\n    v1 = Vector[x2 - x1, y2 - y1]\n    v2 = Vector[x4 - x3, y4 - y3]\n    next if v1.inner_product(v2) / (v1.r * v2.r) < cos(PI * t / 180)\n\n    g[i][j] = hypot(x4 - x3, y4 - y3)\nend\n\nh = {}\n(0..edges.size-1).each do |i|\n    e = edges[i]\n    next unless e[0..1] == nodes[0]\n    d = hypot(e[2] - e[0], e[3] - e[1])\n    h[i] = d if d <= r\nend\n\nk = 0\nuntil h.empty?\n    k += 1\n    h2 = Hash.new(Float::INFINITY)\n    h.each do |i, d|\n        next unless g[i]\n        g[i].each do |j, c|\n            h2[j] = d + c if d + c < r && d + c < h2[j]\n        end\n    end\n    h = h2\nend\np k"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\ninclude Math\n\nn = gets.to_i\nr, t = gets.split.map(&:to_f)\n\nnodes = (1..n).map { gets.split.map(&:to_i) }\nedges = nodes.permutation(2).map(&:flatten)\n\ng = {}\nedges.permutation(2).each do |e1, e2|\n    x1, y1, x2, y2 = e1\n    x3, y3, x4, y4 = e2\n    next unless x2 == x3 && y2 == y3\n\n    v1 = Vector[x2 - x1, y2- y1]\n    v2 = Vector[x4 - x3, y4 - y3]\n    next if v1.inner_product(v2) / (v1.r * v2.r) < cos(PI * t / 180)\n\n    g[e1] ||= {}\n    g[e1][e2] = hypot(x4 - x3, y4 - y3)\nend\n\nk = 0\nh = {}\nedges.each do |e|\n    next if e[0..1] == nodes[0]\n    d = hypot(e[2] - e[0], e[3] - e[1])\n    h[e] = d if d <= r\nend\n\nuntil h.empty?\n    k += 1\n    h2 = Hash.new(Float::INFINITY)\n    h.each do |e, d|\n        next unless g[e]\n        g[e].each do |f, c|\n            h2[f] = d + c if d + c < r && d + c < h2[f]\n        end\n    end\n    h = h2\nend\np k"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\ninclude Math\n\nn = gets.to_i\nr, t = gets.split.map(&:to_f)\n\nnodes = (1..n).map { gets.split.map(&:to_i) }\nedges = nodes.permutation(2).map(&:flatten)\n\ng = {}\nedges.permutation(2).each do |e1, e2|\n    x1, y1, x2, y2 = e1\n    x3, y3, x4, y4 = e2\n    next unless x2 == x3 && y2 == y3\n\n    v1 = Vector[x2 - x1, y2- y1]\n    v2 = Vector[x4 - x3, y4 - y3]\n    next if v1.inner_product(v2) / (v1.r * v2.r) < cos(PI * t / 180)\n\n    g[e1] ||= {}\n    g[e1][e2] = hypot(x4 - x3, y4 - y3)\nend\n\nk = 0\nh = {}\nedges.each do |e|\n    next unless e[0..1] == nodes[0]\n    d = hypot(e[2] - e[0], e[3] - e[1])\n    h[e] = d if d <= r\nend\n\nuntil h.empty?\n    k += 1\n    h2 = Hash.new(Float::INFINITY)\n    h.each do |e, d|\n        next unless g[e]\n        g[e].each do |f, c|\n            h2[f] = d + c if d + c < r && d + c < h2[f]\n        end\n    end\n    h = h2\nend\np k"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\ninclude Math\n\nn = gets.to_i\nr, t = gets.split.map(&:to_f)\n\nnodes = (1..n).map { gets.split.map(&:to_i) }\nedges = nodes.permutation(2).map(&:flatten)\n\ng = (0..edges.size-1).map { {} }\n(0..edges.size-1).to_a.permutation(2) do |i, j|\n    x1, y1, x2, y2 = edges[i]\n    x3, y3, x4, y4 = edges[j]\n    next unless x2 == x3 && y2 == y3\n\n    v1 = Vector[x2 - x1, y2 - y1]\n    v2 = Vector[x4 - x3, y4 - y3]\n    next if v1.inner_product(v2) / (v1.r * v2.r) < cos(PI * t / 180)\n\n    g[i][j] = hypot(x4 - x3, y4 - y3)\nend\n\nh = {}\n(0..n-1).each do |i|\n    e = edges[i]\n    next unless e[0..1] == nodes[0]\n    d = hypot(e[2] - e[0], e[3] - e[1])\n    h[i] = d if d <= r\nend\n\nk = 0\nuntil h.empty?\n    k += 1\n    h2 = Hash.new(Float::INFINITY)\n    h.each do |i, d|\n        next unless g[i]\n        g[i].each do |j, c|\n            h2[j] = d + c if d + c < r && d + c < h2[j]\n        end\n    end\n    h = h2\nend\np k"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\ninclude Math\n\nn = gets.to_i\nr, t = gets.split.map(&:to_f)\n\nnodes = (1..n).map { gets.split.map(&:to_i) }\nedges = nodes.permutation(2).map(&:flatten)\n\ng = {}\nedges.permutation(2).each do |e1, e2|\n    x1, y1, x2, y2 = e1\n    x3, y3, x4, y4 = e2\n    next unless x2 == x3 && y2 == y3\n\n    v1 = Vector[x2 - x1, y2- y1]\n    v2 = Vector[x4 - x3, y4 - y3]\n    next if v1.inner_product(v2) / (v1.r * v2.r) < cos(PI * t / 180)\n\n    g[e1] ||= {}\n    g[e1][e2] = hypot(x4 - x3, y4 - y3)\nend\n\nk = 1\nh = {}\nedges.each do |e|\n    next if e[0..1] == nodes[0]\n    d = hypot(e[2] - e[0], e[3] - e[1])\n    h[e] = d if d <= r\nend\n\nloop do\n    h2 = Hash.new(Float::INFINITY)\n    h.each do |e, d|\n        next unless g[e]\n        g[e].each do |f, c|\n            h2[f] = d + c if d + c < r && d + c < h2[f]\n        end\n    end\n    h = h2\n    break if h.empty?\n    k += 1\nend\np k"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nif n == 1\n\tputs 0\n\texit\nend\n\nr, theta = gets.split.map &:to_f\ncos = cos(PI * theta / 180)\n\npoints = (1..n).map{gets.split.map &:to_f}\n\nneighbour = {}\nstack = []\n(0..n-1).each{|i|\n\t((0..n-1).to_a - [i]).map{|j| \n\t\te = [i, j]\n\t\tv1 = Vector[*points[j]] - Vector[*points[i]]\n\t\tstack << [i, j, v1.r, 1] if i == 0 && v1.r < r\n\t\t((0..n-1).to_a - [j]).each{|k|\n\t\t\tf = [j, k]\n\t\t\tv2 = Vector[*points[k]] - Vector[*points[j]]\n\t\t\tif v1.inner_product(v2) / (v1.r * v2.r) > cos\n\t\t\t\t(neighbour[e] ||= Set.new) << f\n\t\t\tend\n\t\t}\n\t}\n}\n\n#p neighbour\n\nbest = 0\nuntil stack.empty?\n\ti, j, d, c = stack.pop\n\t#p [i, j, d, c]\n\t(neighbour[[i, j]] || []).each{|_, k|\n\t\tv = Vector[*points[k]] - Vector[*points[j]]\n\t\tadd = v.r\n\t\tif d + add < r\n\t\t\tstack << [j, k, d+add, c+1]\n\t\t\tbest = c+1 if c+1 > best\n\t\tend\n\t}\nend\n\np best"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nrequire 'set'\ninclude Math\n\nn = gets.to_i\nif n == 1\n\tputs 0\n\texit\nend\n\nr, theta = gets.split.map &:to_f\ncos = cos(PI * theta / 180)\n\npoints = (1..n).map{gets.split.map &:to_f}\n\nneighbour = {}\nstack = []\n(0..n-1).each{|i|\n\t((0..n-1).to_a - [i]).map{|j| \n\t\te = [i, j]\n\t\tv1 = Vector[*points[j]] - Vector[*points[i]]\n\t\tstack << [i, j, v1.r, 1] if i == 0 && v1.r < r\n\t\t((0..n-1).to_a - [j]).each{|k|\n\t\t\tf = [j, k]\n\t\t\tv2 = Vector[*points[k]] - Vector[*points[j]]\n\t\t\tif v1.inner_product(v2) / (v1.r * v2.r) > cos\n\t\t\t\t(neighbour[e] ||= Set.new) << f\n\t\t\tend\n\t\t}\n\t}\n}\n\nbest = 0\nuntil stack.empty?\n\ti, j, d, c = stack.pop\n\tbest = c if c > best\n\t#p [i, j, d, c]\n\t(neighbour[[i, j]] || []).each{|_, k|\n\t\tv = Vector[*points[k]] - Vector[*points[j]]\n\t\tadd = v.r\n\t\tif d + add < r\n\t\t\tstack << [j, k, d+add, c+1]\n\t\tend\n\t}\nend\n\np best"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nrequire 'set'\ninclude Math\n\nn = gets.to_i\nif n == 1\n\tputs 0\n\texit\nend\n\nr, theta = gets.split.map &:to_f\ncos = cos(PI * theta / 180)\n\npoints = (1..n).map{gets.split.map &:to_f}\n\nneighbour = {}\nstack = []\n(0..n-1).each{|i|\n\t((0..n-1).to_a - [i]).map{|j| \n\t\te = [i, j]\n\t\tv1 = Vector[*points[j]] - Vector[*points[i]]\n\t\tstack << [i, j, v1.r, 1] if i == 0 && v1.r < r\n\t\t((0..n-1).to_a - [j]).each{|k|\n\t\t\tf = [j, k]\n\t\t\tv2 = Vector[*points[k]] - Vector[*points[j]]\n\t\t\tif v1.inner_product(v2) / (v1.r * v2.r) > cos\n\t\t\t\t(neighbour[e] ||= Set.new) << f\n\t\t\tend\n\t\t}\n\t}\n}\n\n#p neighbour\n\nbest = 0\nuntil stack.empty?\n\ti, j, d, c = stack.pop\n\t#p [i, j, d, c]\n\t(neighbour[[i, j]] || []).each{|_, k|\n\t\tv = Vector[*points[k]] - Vector[*points[j]]\n\t\tadd = v.r\n\t\tif d + add < r\n\t\t\tstack << [j, k, d+add, c+1]\n\t\t\tbest = c+1 if c+1 > best\n\t\tend\n\t}\nend\n\np best"
  },
  {
    "language": "D",
    "code": "import std.typecons;\nimport std.range;\nimport std.algorithm;\nimport std.array;\nimport std.complex;\nimport std.math;\nimport std.stdio;\nimport std.string;\nimport std.conv;\nimport core.memory;\n\nint N;\nreal R, TH;\nint[2][] cities;\n\n\nstruct State\n{\n    int lastCity;\n    int nowCity;\n    long cnt;\n    real total;\n    bool end = false;\n}\n\n\nstruct AllState\n{\n    long maxCNT = 0;\n    State[][Tuple!(int, int)] states;\n\n\n    void add(State[] state)\n    {\n        foreach(e; state){\n            if(e.end){\n                maxCNT = max(maxCNT, e.cnt);\n                continue;\n            }\n\n            auto lastNow = tuple(e.lastCity, e.nowCity);\n            if(auto p = lastNow in states){\n                foreach(ref s; *p)\n                    if(s.cnt <= e.cnt && s.total >= e.total)\n                        s.lastCity = -1;    // ????????????????????°\n\n                states[lastNow] = states[lastNow].remove!\"a.lastCity == -1\"();\n            }\n\n            states[lastNow] ~= e;\n        }\n    }\n}\n\n\nvoid main()\n{\n    N = readln().chomp().to!uint;\n    real[] RTH = readln().chomp().split(' ').map!(to!real).array;\n    R = RTH[0];\n    TH = RTH[1];\n\n    foreach(i; 0 .. N){\n        auto xy = readln().chomp().split(' ').map!(to!int).array;\n        cities ~= [xy[0], xy[1]];\n    }\n\n    AllState allState;\n    State[] states = [State(-1, 0, 0, 0, false)];\n    size_t cnt;\n    while(states.length){\n        State[] next;\n        foreach(e; states)\n            next ~= getNext(e);\n        allState.add(next);\n        states.length = 0;\n        foreach(k, v; allState.states)\n            states ~= v;\n        allState.states = null;\n        //writeln(states);\n        ++cnt;\n        GC.collect();\n        GC.minimize();\n        //if(cnt > 2) break;\n    }\n\n    writeln(allState.maxCNT);\n}\n\n\nState[] getNext(State state)\n{\n    if(state.end) return [state];\n\n    State[] dst;\n    foreach(i; 0 .. N){\n        //writeln(state);\n        //writefln(\"%s, %s, %s\", state.lastCity, state.nowCity, i);\n        //writeln(getTheta(state.lastCity, state.nowCity, i));\n        //writeln(getDistance(i, state.nowCity) + state.total);\n\n        if(i != state.lastCity\n        && i != state.nowCity\n        && getTheta(state.lastCity, state.nowCity, i) < TH\n        && getDistance(i, state.nowCity) + state.total < R)\n        {\n            State next;\n            next.lastCity = state.nowCity;\n            next.nowCity = i;\n            next.cnt = state.cnt + 1;\n            next.total = getDistance(i, state.nowCity) + state.total;\n            dst ~= next;\n        }\n    }\n\n    if(dst.length == 0){\n        state.end = true;\n        return [state];\n    }else{\n        return dst;\n    }\n}\n\n\nreal getDistance(int i, int j)\n{\n    auto c1 = cities[i], c2 = cities[j];\n    return sqrt((cast(real)c1[0] - c2[0])^^2 + (cast(real)c1[1] - c2[1])^^2);\n}\n\n\nreal getTheta(int i, int j, int k)\n{\n    if(i < 0) return 0;\n    if(i == j || j == k || k == i)\n        return 180;\n\n    auto c1 = cities[i],\n         c2 = cities[j],\n         c3 = cities[k];\n\n    return 180/PI*getTheta(complex!real(c2[0] - c1[0], c2[1] - c1[1]),\n                           complex!real(c3[0] - c2[0], c3[1] - c2[1]));\n}\n\n\nreal getTheta(Complex!real a, Complex!real b)\n{\n    if(a.abs.approxEqual(0) || b.abs.approxEqual(0)) return 0;\n\n    auto t1 = atan2(a.re, a.im),\n         t2 = atan2(b.re, b.im);\n\n    auto t3 = t1 - t2;\n    if(t3 < 0)\n        return t3 + 2*PI;\n    else\n        return t3;\n\n//    auto x = (a.re*b.re + a.im*b.im) / (a.abs * b.abs);\n//    if(x.approxEqual(-1)) x = -1;\n//    if(x.approxEqual(1)) x = 1;\n\n//    auto v = acos(x);\n//    if(v.isNaN){\n//        writefln(\"%s, %s\", a, b);\n//        writefln(\"%s, %s\", (a.re*b.re + a.im*b.im), (a.abs * b.abs));\n//        throw new Exception(\"aa\");\n//    }\n//    return v;\n}"
  },
  {
    "language": "D",
    "code": "import std.typecons;\nimport std.range;\nimport std.algorithm;\nimport std.array;\nimport std.complex;\nimport std.math;\nimport std.stdio;\nimport std.string;\nimport std.conv;\n\nint N;\nreal R, TH;\nint[2][] cities;\n\n\nstruct State\n{\n    int lastCity;\n    int nowCity;\n    long cnt;\n    real total;\n    bool end = false;\n}\n\n\nstruct AllState\n{\n    long maxCNT = 0;\n    State[][Tuple!(int, int)] states;\n\n\n    void add(State[] state)\n    {\n        foreach(e; state){\n            if(e.end){\n                maxCNT = max(maxCNT, e.cnt);\n                continue;\n            }\n\n            auto lastNow = tuple(e.lastCity, e.nowCity);\n            if(auto p = lastNow in states){\n                foreach(ref s; *p)\n                    if(s.cnt <= e.cnt && s.total >= e.total)\n                        e.lastCity = -1;    // ティツ慊妥、ツシツ?・ツ仰?ァツクツコテ・ツ青カテッツスツ凝ァツケツ敕ィツシツ氾篠崚ァツケツァテッツスツー\n\n                states[lastNow] = states[lastNow].remove!\"a.lastCity == -1\"();\n            }\n\n            states[lastNow] ~= e;\n        }\n    }\n}\n\n\nvoid main()\n{\n    N = readln().chomp().to!uint;\n    real[] RTH = readln().chomp().split(' ').map!(to!real).array;\n    R = RTH[0];\n    TH = RTH[1];\n\n    foreach(i; 0 .. N){\n        auto xy = readln().chomp().split(' ').map!(to!int).array;\n        cities ~= [xy[0], xy[1]];\n    }\n\n    AllState allState;\n    State[] states = [State(-1, 0, 0, 0, false)];\n    size_t cnt;\n    while(states.length){\n        State[] next;\n        foreach(e; states)\n            next ~= getNext(e);\n        allState.add(next);\n        states.length = 0;\n        foreach(k, v; allState.states)\n            states ~= v;\n        allState.states = null;\n        //writeln(states);\n        ++cnt;\n        //if(cnt > 2) break;\n    }\n\n    writeln(allState.maxCNT);\n}\n\n\nState[] getNext(State state)\n{\n    if(state.end) return [state];\n\n    State[] dst;\n    foreach(i; 0 .. N){\n        //writeln(state);\n        //writefln(\"%s, %s, %s\", state.lastCity, state.nowCity, i);\n        //writeln(getTheta(state.lastCity, state.nowCity, i));\n        //writeln(getDistance(i, state.nowCity) + state.total);\n\n        if(i != state.lastCity\n        && i != state.nowCity\n        && getTheta(state.lastCity, state.nowCity, i) < TH\n        && getDistance(i, state.nowCity) + state.total < R)\n        {\n            State next;\n            next.lastCity = state.nowCity;\n            next.nowCity = i;\n            next.cnt = state.cnt + 1;\n            next.total = getDistance(i, state.nowCity) + state.total;\n            dst ~= next;\n        }\n    }\n\n    if(dst.length == 0){\n        state.end = true;\n        return [state];\n    }else{\n        return dst;\n    }\n}\n\n\nreal getDistance(int i, int j)\n{\n    auto c1 = cities[i], c2 = cities[j];\n    return sqrt((cast(real)c1[0] - c2[0])^^2 + (cast(real)c1[1] - c2[1])^^2);\n}\n\n\nreal getTheta(int i, int j, int k)\n{\n    if(i < 0) return 0;\n    if(i == j || j == k || k == i)\n        return 180;\n\n    auto c1 = cities[i],\n         c2 = cities[j],\n         c3 = cities[k];\n\n    return 180/PI*getTheta(complex!real(c2[0] - c1[0], c2[1] - c1[1]),\n                           complex!real(c3[0] - c2[0], c3[1] - c2[1]));\n}\n\n\nreal getTheta(Complex!real a, Complex!real b)\n{\n    if(a.abs.approxEqual(0) || b.abs.approxEqual(0)) return 0;\n\n    auto t1 = atan2(a.re, a.im),\n         t2 = atan2(b.re, b.im);\n\n    auto t3 = t1 - t2;\n    if(t3 < 0)\n        return t3 + 2*PI;\n    else\n        return t3;\n\n//    auto x = (a.re*b.re + a.im*b.im) / (a.abs * b.abs);\n//    if(x.approxEqual(-1)) x = -1;\n//    if(x.approxEqual(1)) x = 1;\n\n//    auto v = acos(x);\n//    if(v.isNaN){\n//        writefln(\"%s, %s\", a, b);\n//        writefln(\"%s, %s\", (a.re*b.re + a.im*b.im), (a.abs * b.abs));\n//        throw new Exception(\"aa\");\n//    }\n//    return v;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-6;\nstruct Point {\n    double x, y;\n    Point opBinary(alias op)(in Point p) const {\n        if (op == \"+\") return Point(x + p.x, y + p.y);\n        if (op == \"-\") return Point(x - p.x, y - p.y);\n    }\n    Point opBinary(alias op)(double n) const {\n        if (op == \"*\") return Point(n * x, n * y);\n        if (op == \"/\") return Point(n / x, n / y);\n    }\n}\nbool EQ(in Point a, in Point b) {\n    return abs(a.x - b.x) <= EPS && abs(a.y - b.y) <= EPS;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\nPoint unit(in Point a) {\n    return a / norm(a);\n}\ndouble distance(in Point a, in Point b) {\n    auto dx = a.x - b.x,\n         dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble angle(in Point a, in Point b, in Point c) {\n    auto p = b - a, q = c - b;\n    return acos(p.dot(q) / (p.norm * q.norm)) / PI * 180;\n}\n\nint N;\ndouble r, theta;\nPoint[] P;\nbool[][][] C;\ndouble[][] D;\n\nvoid input() {\n    scanf(\"%d\\n\", &N);\n    scanf(\"%lf %lf\\n\", &r, &theta);\n    P = new Point[N];\n    foreach (i; 0 .. N) {\n        int x, y; scanf(\"%d %d\\n\", &x, &y);\n        P[i] = Point(x, y);\n    }\n    C = new bool[][][](N, N, N);\n    foreach (i; 0 .. N) {\n        foreach (j; 0 .. N) {\n            foreach (k; 0 .. N) {\n                if (i == j || j == k || k == i) continue;\n                C[i][j][k] = angle(P[i], P[j], P[k]) < theta + EPS;\n            }\n        }\n    }\n    foreach (k; 1 .. N) C[0][0][k] = true;\n    D = new double[][](N, N);\n    foreach (i; 0 .. N) {\n        foreach (j; 0 .. N) {\n            D[i][j] = distance(P[i], P[j]);\n        }\n    }\n}\n\nconst INF = 1e10;\n\nvoid solve() {\n    auto L = cast(int)(r) + 1;\n    auto dp = new double[][][](N, N, L);\n    foreach (i; 0 .. N) foreach (j; 0 .. N) dp[i][j][] = INF;\n    dp[0][0][0] = 0.0;\n    int ans = 0;\n    foreach (c; 0 .. L - 1) {\n        foreach (u; 0 .. N) {\n            foreach (v; 0 .. N) {\n                foreach (n; 0 .. N) {\n                    if (u == n || v == n) continue;\n                    if (!C[u][v][n]) continue;\n                    dp[v][n][c + 1] = min(dp[v][n][c + 1], dp[u][v][c] + D[v][n]);\n                    if (dp[v][n][c + 1] < r + EPS) ans = c + 1;\n                }\n            }\n        }\n    }\n    writeln(ans);\n}\n\nvoid main() {\n    input; solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-6;\nstruct Point {\n    double x, y;\n    Point opBinary(alias op)(in Point p) const {\n        if (op == \"+\") return Point(x + p.x, y + p.y);\n        if (op == \"-\") return Point(x - p.x, y - p.y);\n    }\n    Point opBinary(alias op)(double n) const {\n        if (op == \"*\") return Point(n * x, n * y);\n        if (op == \"/\") return Point(n / x, n / y);\n    }\n}\nbool EQ(in Point a, in Point b) {\n    return abs(a.x - b.x) <= EPS && abs(a.y - b.y) <= EPS;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\nPoint unit(in Point a) {\n    return a / norm(a);\n}\ndouble distance(in Point a, in Point b) {\n    auto dx = a.x - b.x,\n         dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble angle(in Point a, in Point b, in Point c) {\n    auto p = b - a, q = c - b;\n    return acos(p.dot(q) / (p.norm * q.norm)) / PI * 180;\n}\n\nint N;\ndouble r, theta;\nPoint[] P;\n\nvoid input() {\n    scanf(\"%d\\n\", &N);\n    scanf(\"%lf %lf\\n\", &r, &theta);\n    P = new Point[N];\n    foreach (i; 0 .. N) {\n        int x, y; scanf(\"%d %d\\n\", &x, &y);\n        P[i] = Point(x, y);\n    }\n}\n\nvoid solve() {\n    auto G = new double[][][](N + 1, N + 1, N + 1);\n    foreach (i; 0 .. N + 1) foreach (j; 0 .. N + 1) G[i][j][] = -1;\n    foreach (j; 0 .. N) {\n        foreach (k; 0 .. N) {\n            if (j == k) continue;\n            G[N][j][k] = distance(P[j], P[k]);\n        }\n    }\n    foreach (i; 0 .. N) {\n        foreach (j; 0 .. N) {\n            foreach (k; 0 .. N) {\n                if (i == j || j == k || k == i) continue;\n                if (angle(P[i], P[j], P[k]) <= r + EPS) {\n                    G[i][j][k] = distance(P[j], P[k]);\n                }\n            }\n        }\n    }\n    struct S {\n        int prev, cur, count;\n        double r;\n    }\n    DList!S Q;\n    Q.insert(S(N, 0, 0, 0));\n    auto D = new double[int][][](N + 1, N + 1);\n    D[N][0][0] = 0;\n    int ans = 0;\n    while (!Q.empty) {\n        auto s = Q.front; Q.removeFront;\n        //writeln(s);\n        ans = max(ans, s.count);\n        foreach (next; 0 .. N) {\n            if (G[s.prev][s.cur][next] < 0) continue;\n            auto nr = s.r + G[s.prev][s.cur][next];\n            if (D[s.cur][next].get(s.count + 1, 1e10) + EPS > nr && r >= nr + EPS) {\n                D[s.cur][next][s.count + 1] = nr;\n                Q.insert(S(s.cur, next, s.count + 1, nr));\n            }\n        }\n    }\n    writeln(ans);\n}\n\nvoid main() {\n    input; solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-6;\nstruct Point {\n    double x, y;\n    Point opBinary(alias op)(in Point p) const {\n        if (op == \"+\") return Point(x + p.x, y + p.y);\n        if (op == \"-\") return Point(x - p.x, y - p.y);\n    }\n    Point opBinary(alias op)(double n) const {\n        if (op == \"*\") return Point(n * x, n * y);\n        if (op == \"/\") return Point(n / x, n / y);\n    }\n}\nbool EQ(in Point a, in Point b) {\n    return abs(a.x - b.x) <= EPS && abs(a.y - b.y) <= EPS;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\nPoint unit(in Point a) {\n    return a / norm(a);\n}\ndouble distance(in Point a, in Point b) {\n    auto dx = a.x - b.x,\n         dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble angle(in Point a, in Point b, in Point c) {\n    auto p = b - a, q = c - b;\n    return acos(p.dot(q) / (p.norm * q.norm)) / PI * 180;\n}\n\nint N;\ndouble r, theta;\nPoint[] P;\n\nvoid input() {\n    scanf(\"%d\\n\", &N);\n    scanf(\"%lf %lf\\n\", &r, &theta);\n    P = new Point[N];\n    foreach (i; 0 .. N) {\n        int x, y; scanf(\"%d %d\\n\", &x, &y);\n        P[i] = Point(x, y);\n    }\n}\n\nvoid solve() {\n    auto G = new double[][][](N + 1, N + 1, N + 1);\n    foreach (i; 0 .. N + 1) foreach (j; 0 .. N + 1) G[i][j][] = -1;\n    foreach (j; 0 .. N) {\n        foreach (k; 0 .. N) {\n            if (j == k) continue;\n            G[N][j][k] = distance(P[j], P[k]);\n        }\n    }\n    foreach (i; 0 .. N) {\n        foreach (j; 0 .. N) {\n            foreach (k; 0 .. N) {\n                if (i == j || j == k || k == i) continue;\n                if (angle(P[i], P[j], P[k]) <= theta + EPS) {\n                    G[i][j][k] = distance(P[j], P[k]);\n                }\n            }\n        }\n    }\n    struct S {\n        int prev, cur, count;\n        double r;\n    }\n    DList!S Q;\n    Q.insert(S(N, 0, 0, 0));\n    auto D = new double[int][][](N + 1, N + 1);\n    D[N][0][0] = 0;\n    int ans = 0;\n    while (!Q.empty) {\n        auto s = Q.front; Q.removeFront;\n        //writeln(s);\n        ans = max(ans, s.count);\n        foreach (next; 0 .. N) {\n            if (G[s.prev][s.cur][next] < 0) continue;\n            auto nr = s.r + G[s.prev][s.cur][next];\n            if (D[s.cur][next].get(s.count + 1, 1e10) + EPS > nr && r >= nr + EPS) {\n                D[s.cur][next][s.count + 1] = nr;\n                Q.insert(S(s.cur, next, s.count + 1, nr));\n            }\n        }\n    }\n    writeln(ans);\n}\n\nvoid main() {\n    input; solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.typecons;\nimport std.range;\nimport std.algorithm;\nimport std.array;\nimport std.complex;\nimport std.math;\nimport std.stdio;\nimport std.string;\nimport std.conv;\n\nint N;\nreal R, TH;\nint[2][] cities;\n\n\nstruct State\n{\n    int lastCity;\n    int nowCity;\n    long cnt;\n    real total;\n    bool end = false;\n}\n\n\nstruct AllState\n{\n    long maxCNT = 0;\n    State[][Tuple!(int, int)] states;\n\n\n    void add(State[] state)\n    {\n        foreach(e; state){\n            if(e.end){\n                maxCNT = max(maxCNT, e.cnt);\n                continue;\n            }\n\n            auto lastNow = tuple(e.lastCity, e.nowCity);\n            if(auto p = lastNow in states){\n                foreach(ref s; *p)\n                    if(s.cnt <= e.cnt && s.total >= e.total)\n                        s.lastCity = -1;    // ティツ慊妥、ツシツ?・ツ仰?ァツクツコテ・ツ青カテッツスツ凝ァツケツ敕ィツシツ氾篠崚ァツケツァテッツスツー\n\n                states[lastNow] = states[lastNow].remove!\"a.lastCity == -1\"();\n            }\n\n            states[lastNow] ~= e;\n        }\n    }\n}\n\n\nvoid main()\n{\n    N = readln().chomp().to!uint;\n    real[] RTH = readln().chomp().split(' ').map!(to!real).array;\n    R = RTH[0];\n    TH = RTH[1];\n\n    foreach(i; 0 .. N){\n        auto xy = readln().chomp().split(' ').map!(to!int).array;\n        cities ~= [xy[0], xy[1]];\n    }\n\n    AllState allState;\n    State[] states = [State(-1, 0, 0, 0, false)];\n    size_t cnt;\n    while(states.length){\n        State[] next;\n        foreach(e; states)\n            next ~= getNext(e);\n        allState.add(next);\n        states.length = 0;\n        foreach(k, v; allState.states)\n            states ~= v;\n        allState.states = null;\n        //writeln(states);\n        ++cnt;\n        //if(cnt > 2) break;\n    }\n\n    writeln(allState.maxCNT);\n}\n\n\nState[] getNext(State state)\n{\n    if(state.end) return [state];\n\n    State[] dst;\n    foreach(i; 0 .. N){\n        //writeln(state);\n        //writefln(\"%s, %s, %s\", state.lastCity, state.nowCity, i);\n        //writeln(getTheta(state.lastCity, state.nowCity, i));\n        //writeln(getDistance(i, state.nowCity) + state.total);\n\n        if(i != state.lastCity\n        && i != state.nowCity\n        && getTheta(state.lastCity, state.nowCity, i) < TH\n        && getDistance(i, state.nowCity) + state.total < R)\n        {\n            State next;\n            next.lastCity = state.nowCity;\n            next.nowCity = i;\n            next.cnt = state.cnt + 1;\n            next.total = getDistance(i, state.nowCity) + state.total;\n            dst ~= next;\n        }\n    }\n\n    if(dst.length == 0){\n        state.end = true;\n        return [state];\n    }else{\n        return dst;\n    }\n}\n\n\nreal getDistance(int i, int j)\n{\n    auto c1 = cities[i], c2 = cities[j];\n    return sqrt((cast(real)c1[0] - c2[0])^^2 + (cast(real)c1[1] - c2[1])^^2);\n}\n\n\nreal getTheta(int i, int j, int k)\n{\n    if(i < 0) return 0;\n    if(i == j || j == k || k == i)\n        return 180;\n\n    auto c1 = cities[i],\n         c2 = cities[j],\n         c3 = cities[k];\n\n    return 180/PI*getTheta(complex!real(c2[0] - c1[0], c2[1] - c1[1]),\n                           complex!real(c3[0] - c2[0], c3[1] - c2[1]));\n}\n\n\nreal getTheta(Complex!real a, Complex!real b)\n{\n    if(a.abs.approxEqual(0) || b.abs.approxEqual(0)) return 0;\n\n    auto t1 = atan2(a.re, a.im),\n         t2 = atan2(b.re, b.im);\n\n    auto t3 = t1 - t2;\n    if(t3 < 0)\n        return t3 + 2*PI;\n    else\n        return t3;\n\n//    auto x = (a.re*b.re + a.im*b.im) / (a.abs * b.abs);\n//    if(x.approxEqual(-1)) x = -1;\n//    if(x.approxEqual(1)) x = 1;\n\n//    auto v = acos(x);\n//    if(v.isNaN){\n//        writefln(\"%s, %s\", a, b);\n//        writefln(\"%s, %s\", (a.re*b.re + a.im*b.im), (a.abs * b.abs));\n//        throw new Exception(\"aa\");\n//    }\n//    return v;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-6;\nstruct Point {\n    double x, y;\n    Point opBinary(alias op)(in Point p) const {\n        if (op == \"+\") return Point(x + p.x, y + p.y);\n        if (op == \"-\") return Point(x - p.x, y - p.y);\n    }\n    Point opBinary(alias op)(double n) const {\n        if (op == \"*\") return Point(n * x, n * y);\n        if (op == \"/\") return Point(n / x, n / y);\n    }\n}\nbool EQ(in Point a, in Point b) {\n    return abs(a.x - b.x) <= EPS && abs(a.y - b.y) <= EPS;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\nPoint unit(in Point a) {\n    return a / norm(a);\n}\ndouble distance(in Point a, in Point b) {\n    auto dx = a.x - b.x,\n         dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble angle(in Point a, in Point b, in Point c) {\n    auto p = b - a, q = c - b;\n    return acos(p.dot(q) / (p.norm * q.norm)) / PI * 180;\n}\n\nint N;\ndouble r, theta;\nPoint[] P;\nbool[][][] C;\n\nvoid input() {\n    scanf(\"%d\\n\", &N);\n    scanf(\"%lf %lf\\n\", &r, &theta);\n    P = new Point[N];\n    foreach (i; 0 .. N) {\n        int x, y; scanf(\"%d %d\\n\", &x, &y);\n        P[i] = Point(x, y);\n    }\n    C = new bool[][][](N, N, N);\n    foreach (i; 0 .. N) {\n        foreach (j; 0 .. N) {\n            foreach (k; 0 .. N) {\n                if (i == j || j == k || k == i) continue;\n                C[i][j][k] = angle(P[i], P[j], P[k]) < theta + EPS;\n            }\n        }\n    }\n    foreach (k; 1 .. N) C[0][0][k] = true;\n}\n\nconst INF = 1e10;\n\nvoid solve() {\n    auto L = cast(int)(r) + 1;\n    auto dp = new double[][][](N, N, L);\n    foreach (i; 0 .. N) foreach (j; 0 .. N) dp[i][j][] = INF;\n    dp[0][0][0] = 0.0;\n    int ans = 0;\n    foreach (c; 0 .. L - 1) {\n        foreach (u; 0 .. N) {\n            foreach (v; 0 .. N) {\n                foreach (n; 0 .. N) {\n                    if (u == n || v == n) continue;\n                    if (!C[u][v][n]) continue;\n                    dp[v][n][c + 1] = min(dp[v][n][c + 1], dp[u][v][c] + distance(P[v], P[n]));\n                    if (dp[v][n][c + 1] < r + EPS) ans = c + 1;\n                }\n            }\n        }\n    }\n    writeln(ans);\n}\n\nvoid main() {\n    input; solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.typecons;\nimport std.range;\nimport std.algorithm;\nimport std.array;\nimport std.complex;\nimport std.math;\nimport std.stdio;\nimport std.string;\nimport std.conv;\nimport core.memory;\n\nint N;\nreal R, TH;\nint[2][] cities;\n\n\nstruct State\n{\n    int lastCity;\n    int nowCity;\n    long cnt;\n    real total;\n    bool end = false;\n}\n\n\nstruct AllState\n{\n    long maxCNT = 0;\n    State[][Tuple!(int, int)] states;\n\n\n    void add(State[] state)\n    {\n        foreach(e; state){\n            if(e.end){\n                maxCNT = max(maxCNT, e.cnt);\n                continue;\n            }\n\n            auto lastNow = tuple(e.lastCity, e.nowCity);\n            if(auto p = lastNow in states){\n                foreach(ref s; *p)\n                    if(s.cnt <= e.cnt && s.total >= e.total)\n                        s.lastCity = -1;    // ????????????????????°\n\n                states[lastNow] = states[lastNow].remove!\"a.lastCity == -1\"();\n            }\n\n            states[lastNow] ~= e;\n        }\n    }\n}\n\n\nvoid main()\n{\n    N = readln().chomp().to!uint;\n    real[] RTH = readln().chomp().split(' ').map!(to!real).array;\n    R = RTH[0];\n    TH = RTH[1];\n\n    foreach(i; 0 .. N){\n        auto xy = readln().chomp().split(' ').map!(to!int).array;\n        cities ~= [xy[0], xy[1]];\n    }\n\n    AllState allState;\n    State[] states = [State(-1, 0, 0, 0, false)];\n    size_t cnt;\n    while(states.length){\n        State[] next;\n        foreach(e; states)\n            next ~= getNext(e);\n        allState.add(move(next));\n        states.length = 0;\n        foreach(k, v; allState.states)\n            states ~= v;\n        allState.states = null;\n        //writeln(states);\n        ++cnt;\n        GC.collect();\n        GC.minimize();\n        //if(cnt > 2) break;\n    }\n\n    writeln(allState.maxCNT);\n}\n\n\nState[] getNext(State state)\n{\n    if(state.end) return [state];\n\n    State[] dst;\n    foreach(i; 0 .. N){\n        //writeln(state);\n        //writefln(\"%s, %s, %s\", state.lastCity, state.nowCity, i);\n        //writeln(getTheta(state.lastCity, state.nowCity, i));\n        //writeln(getDistance(i, state.nowCity) + state.total);\n\n        if(i != state.lastCity\n        && i != state.nowCity\n        && getTheta(state.lastCity, state.nowCity, i) < TH\n        && getDistance(i, state.nowCity) + state.total < R)\n        {\n            State next;\n            next.lastCity = state.nowCity;\n            next.nowCity = i;\n            next.cnt = state.cnt + 1;\n            next.total = getDistance(i, state.nowCity) + state.total;\n            dst ~= next;\n        }\n    }\n\n    if(dst.length == 0){\n        state.end = true;\n        return [state];\n    }else{\n        return dst;\n    }\n}\n\n\nreal getDistance(int i, int j)\n{\n    auto c1 = cities[i], c2 = cities[j];\n    return sqrt((cast(real)c1[0] - c2[0])^^2 + (cast(real)c1[1] - c2[1])^^2);\n}\n\n\nreal getTheta(int i, int j, int k)\n{\n    if(i < 0) return 0;\n    if(i == j || j == k || k == i)\n        return 180;\n\n    auto c1 = cities[i],\n         c2 = cities[j],\n         c3 = cities[k];\n\n    return 180/PI*getTheta(complex!real(c2[0] - c1[0], c2[1] - c1[1]),\n                           complex!real(c3[0] - c2[0], c3[1] - c2[1]));\n}\n\n\nreal getTheta(Complex!real a, Complex!real b)\n{\n    if(a.abs.approxEqual(0) || b.abs.approxEqual(0)) return 0;\n\n    auto t1 = atan2(a.re, a.im),\n         t2 = atan2(b.re, b.im);\n\n    auto t3 = t1 - t2;\n    if(t3 < 0)\n        return t3 + 2*PI;\n    else\n        return t3;\n\n//    auto x = (a.re*b.re + a.im*b.im) / (a.abs * b.abs);\n//    if(x.approxEqual(-1)) x = -1;\n//    if(x.approxEqual(1)) x = 1;\n\n//    auto v = acos(x);\n//    if(v.isNaN){\n//        writefln(\"%s, %s\", a, b);\n//        writefln(\"%s, %s\", (a.re*b.re + a.im*b.im), (a.abs * b.abs));\n//        throw new Exception(\"aa\");\n//    }\n//    return v;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-6;\nstruct Point {\n    double x, y;\n    Point opBinary(alias op)(in Point p) const {\n        if (op == \"+\") return Point(x + p.x, y + p.y);\n        if (op == \"-\") return Point(x - p.x, y - p.y);\n    }\n    Point opBinary(alias op)(double n) const {\n        if (op == \"*\") return Point(n * x, n * y);\n        if (op == \"/\") return Point(n / x, n / y);\n    }\n}\nbool EQ(in Point a, in Point b) {\n    return abs(a.x - b.x) <= EPS && abs(a.y - b.y) <= EPS;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\nPoint unit(in Point a) {\n    return a / norm(a);\n}\ndouble distance(in Point a, in Point b) {\n    auto dx = a.x - b.x,\n         dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble angle(in Point a, in Point b, in Point c) {\n    auto p = b - a, q = c - b;\n    return acos(p.dot(q) / (p.norm * q.norm)) / PI * 180;\n}\n\nint N;\ndouble r, theta;\nPoint[] P;\nbool[][][] C;\n\nvoid input() {\n    scanf(\"%d\\n\", &N);\n    scanf(\"%lf %lf\\n\", &r, &theta);\n    P = new Point[N];\n    foreach (i; 0 .. N) {\n        int x, y; scanf(\"%d %d\\n\", &x, &y);\n        P[i] = Point(x, y);\n    }\n    C = new bool[][][](N, N, N);\n    foreach (i; 0 .. N) {\n        foreach (j; 0 .. N) {\n            foreach (k; 0 .. N) {\n                if (i == j || j == k || k == i) continue;\n                C[i][j][k] = angle(P[i], P[j], P[k]) < theta + EPS;\n            }\n        }\n    }\n    foreach (k; 1 .. N) C[0][0][k] = true;\n}\n\nconst INF = 1e10;\n\nvoid solve() {\n    auto L = cast(int)(r) + 1;\n    auto dp = new double[][][](N, N, L);\n    foreach (i; 0 .. N) foreach (j; 0 .. N) dp[i][j][] = INF;\n    dp[0][0][0] = 0.0;\n    foreach (c; 0 .. L - 1) {\n        foreach (u; 0 .. N) {\n            foreach (v; 0 .. N) {\n                foreach (n; 0 .. N) {\n                    if (u == n || v == n) continue;\n                    if (!C[u][v][n]) continue;\n                    dp[v][n][c + 1] = min(dp[v][n][c + 1], dp[u][v][c] + distance(P[v], P[n]));\n                }\n            }\n        }\n    }\n    foreach (l; 1 .. L) {\n        foreach (i; 0 .. N) {\n            foreach (j; 0 .. N) {\n                if (dp[i][j][l] < r + EPS) {\n                    //writeln([i, j, l], dp[i][j][l]);\n                    goto next;\n                }\n            }\n        }\n        writeln(l - 1);\n        break;\nnext:;\n    }\n}\n\nvoid main() {\n    input; solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-6;\nstruct Point {\n    double x, y;\n    Point opBinary(alias op)(in Point p) const {\n        if (op == \"+\") return Point(x + p.x, y + p.y);\n        if (op == \"-\") return Point(x - p.x, y - p.y);\n    }\n    Point opBinary(alias op)(double n) const {\n        if (op == \"*\") return Point(n * x, n * y);\n        if (op == \"/\") return Point(n / x, n / y);\n    }\n}\nbool EQ(in Point a, in Point b) {\n    return abs(a.x - b.x) <= EPS && abs(a.y - b.y) <= EPS;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\nPoint unit(in Point a) {\n    return a / norm(a);\n}\ndouble distance(in Point a, in Point b) {\n    auto dx = a.x - b.x,\n         dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble angle(in Point a, in Point b, in Point c) {\n    auto p = b - a, q = c - b;\n    return acos(p.dot(q) / (p.norm * q.norm)) / PI * 180;\n}\n\nint N;\ndouble r, theta;\nPoint[] P;\nbool[][][] C;\ndouble[][] D;\n\nvoid input() {\n    scanf(\"%d\\n\", &N);\n    scanf(\"%lf %lf\\n\", &r, &theta);\n    P = new Point[N];\n    foreach (i; 0 .. N) {\n        int x, y; scanf(\"%d %d\\n\", &x, &y);\n        P[i] = Point(x, y);\n    }\n    C = new bool[][][](N, N, N);\n    foreach (i; 0 .. N) {\n        foreach (j; 0 .. N) {\n            foreach (k; 0 .. N) {\n                if (i == j || j == k || k == i) continue;\n                C[i][j][k] = angle(P[i], P[j], P[k]) < theta + EPS;\n            }\n        }\n    }\n    foreach (k; 1 .. N) C[0][0][k] = true;\n    D = new double[][](N, N);\n    foreach (i; 0 .. N) {\n        foreach (j; 0 .. N) {\n            D[i][j] = distance(P[i], P[j]);\n        }\n    }\n}\n\nconst INF = 1e10;\n\nvoid solve() {\n    auto L = cast(int)(r) + 1;\n    auto dp = new double[][][](2, N, N);\n    foreach (i; 0 .. 2) foreach (j; 0 .. N) dp[i][j][] = INF;\n    dp[0][0][0] = 0.0;\n    int ans = 0;\n    auto flag = true;\n    foreach (c; 0 .. L - 1) {\n        if (!flag) break;\n        flag = false;\n        foreach (i; 0 .. N) foreach (j; 0 .. N) { dp[(c + 1) & 1][i][j] = INF; }\n        foreach (u; 0 .. N) {\n            foreach (v; 0 .. N) {\n                foreach (n; 0 .. N) {\n                    if (u == n || v == n) continue;\n                    if (!C[u][v][n]) continue;\n                    auto nd = dp[c & 1][u][v] + D[v][n];\n                    if (dp[(c + 1) & 1][v][n] > nd) {\n                        dp[(c + 1) & 1][v][n] = nd;\n                        if (nd < r + EPS) {\n                            ans = c + 1;\n                            flag = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    writeln(ans);\n}\n\nvoid main() {\n    input; solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-6;\nstruct Point {\n    double x, y;\n    Point opBinary(alias op)(in Point p) const {\n        if (op == \"+\") return Point(x + p.x, y + p.y);\n        if (op == \"-\") return Point(x - p.x, y - p.y);\n    }\n    Point opBinary(alias op)(double n) const {\n        if (op == \"*\") return Point(n * x, n * y);\n        if (op == \"/\") return Point(n / x, n / y);\n    }\n}\nbool EQ(in Point a, in Point b) {\n    return abs(a.x - b.x) <= EPS && abs(a.y - b.y) <= EPS;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\nPoint unit(in Point a) {\n    return a / norm(a);\n}\ndouble distance(in Point a, in Point b) {\n    auto dx = a.x - b.x,\n         dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble angle(in Point a, in Point b, in Point c) {\n    auto p = b - a, q = c - b;\n    return acos(p.dot(q) / (p.norm * q.norm)) / PI * 180;\n}\n\nint N;\ndouble r, theta;\nPoint[] P;\nbool[][][] C;\ndouble[][] D;\n\nvoid input() {\n    scanf(\"%d\\n\", &N);\n    scanf(\"%lf %lf\\n\", &r, &theta);\n    P = new Point[N];\n    foreach (i; 0 .. N) {\n        int x, y; scanf(\"%d %d\\n\", &x, &y);\n        P[i] = Point(x, y);\n    }\n    C = new bool[][][](N, N, N);\n    foreach (i; 0 .. N) {\n        foreach (j; 0 .. N) {\n            foreach (k; 0 .. N) {\n                if (i == j || j == k || k == i) continue;\n                C[i][j][k] = angle(P[i], P[j], P[k]) < theta + EPS;\n            }\n        }\n    }\n    foreach (k; 1 .. N) C[0][0][k] = true;\n    D = new double[][](N, N);\n    foreach (i; 0 .. N) {\n        foreach (j; 0 .. N) {\n            D[i][j] = distance(P[i], P[j]);\n        }\n    }\n}\n\nconst INF = 1e10;\n\nvoid solve() {\n    auto L = cast(int)(r) + 1;\n    auto dp = new double[][][](N, N, L);\n    foreach (i; 0 .. N) foreach (j; 0 .. N) dp[i][j][] = INF;\n    dp[0][0][0] = 0.0;\n    struct S {\n        int u, v, c;\n    }\n    DList!S Q;\n    Q.insert(S(0, 0, 0));\n    auto inQ = new bool[][](N, N);\n    inQ[0][0] = true;\n    int ans = 0;\n    while (!Q.empty) {\n        auto c = Q.front; Q.removeFront;\n        ans = max(c.c, ans);\n        inQ[c.u][c.v] = false;\n        foreach (n; 0 .. N) {\n            if (c.u == n || c.v == n) continue;\n            if (!C[c.u][c.v][n]) continue;\n            auto nd = dp[c.u][c.v][c.c] + D[c.v][n];\n            if (dp[c.v][n][c.c + 1] > nd) {\n                dp[c.v][n][c.c + 1] = nd;\n                if (inQ[c.v][n]) continue;\n                if (nd < r + EPS) Q.insert(S(c.v, n, c.c + 1));\n            }\n        }\n    }\n    writeln(ans);\n}\n\nvoid main() {\n    input; solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.typecons;\nimport std.range;\nimport std.algorithm;\nimport std.array;\nimport std.complex;\nimport std.math;\nimport std.stdio;\nimport std.string;\nimport std.conv;\nimport core.memory;\n\nint N;\nreal R, TH;\nint[2][] cities;\n\n\nstruct State\n{\n    int lastCity;\n    int nowCity;\n    long cnt;\n    real total;\n    bool end = false;\n}\n\n\nstruct AllState\n{\n    long maxCNT = 0;\n    State[][Tuple!(int, int)] states;\n\n\n    void add(State[] state)\n    {\n        foreach(e; state){\n            if(e.end){\n                maxCNT = max(maxCNT, e.cnt);\n                continue;\n            }\n\n            auto lastNow = tuple(e.lastCity, e.nowCity);\n            if(auto p = lastNow in states){\n                foreach(ref s; *p)\n                    if(s.cnt <= e.cnt && s.total >= e.total)\n                        s.lastCity = -1;    // ティツ慊妥、ツシツ?・ツ仰?ァツクツコテ・ツ青カテッツスツ凝ァツケツ敕ィツシツ氾篠崚ァツケツァテッツスツー\n\n                states[lastNow] = states[lastNow].remove!\"a.lastCity == -1\"();\n            }\n\n            states[lastNow] ~= e;\n        }\n    }\n}\n\n\nvoid main()\n{\n    N = readln().chomp().to!uint;\n    real[] RTH = readln().chomp().split(' ').map!(to!real).array;\n    R = RTH[0];\n    TH = RTH[1];\n\n    foreach(i; 0 .. N){\n        auto xy = readln().chomp().split(' ').map!(to!int).array;\n        cities ~= [xy[0], xy[1]];\n    }\n\n    AllState allState;\n    State[] states = [State(-1, 0, 0, 0, false)];\n    size_t cnt;\n    while(states.length){\n        State[] next;\n        foreach(e; states)\n            next ~= getNext(e);\n        allState.add(next);\n        states.length = 0;\n        foreach(k, v; allState.states)\n            states ~= v;\n        allState.states = null;\n        //writeln(states);\n        ++cnt;\n        GC.collect();\n        GC.minimize();\n        //if(cnt > 2) break;\n    }\n\n    writeln(allState.maxCNT);\n}\n\n\nState[] getNext(State state)\n{\n    if(state.end) return [state];\n\n    State[] dst;\n    foreach(i; 0 .. N){\n        //writeln(state);\n        //writefln(\"%s, %s, %s\", state.lastCity, state.nowCity, i);\n        //writeln(getTheta(state.lastCity, state.nowCity, i));\n        //writeln(getDistance(i, state.nowCity) + state.total);\n\n        if(i != state.lastCity\n        && i != state.nowCity\n        && getTheta(state.lastCity, state.nowCity, i) < TH\n        && getDistance(i, state.nowCity) + state.total < R)\n        {\n            State next;\n            next.lastCity = state.nowCity;\n            next.nowCity = i;\n            next.cnt = state.cnt + 1;\n            next.total = getDistance(i, state.nowCity) + state.total;\n            dst ~= next;\n        }\n    }\n\n    if(dst.length == 0){\n        state.end = true;\n        return [state];\n    }else{\n        return dst;\n    }\n}\n\n\nreal getDistance(int i, int j)\n{\n    auto c1 = cities[i], c2 = cities[j];\n    return sqrt((cast(real)c1[0] - c2[0])^^2 + (cast(real)c1[1] - c2[1])^^2);\n}\n\n\nreal getTheta(int i, int j, int k)\n{\n    if(i < 0) return 0;\n    if(i == j || j == k || k == i)\n        return 180;\n\n    auto c1 = cities[i],\n         c2 = cities[j],\n         c3 = cities[k];\n\n    return 180/PI*getTheta(complex!real(c2[0] - c1[0], c2[1] - c1[1]),\n                           complex!real(c3[0] - c2[0], c3[1] - c2[1]));\n}\n\n\nreal getTheta(Complex!real a, Complex!real b)\n{\n    if(a.abs.approxEqual(0) || b.abs.approxEqual(0)) return 0;\n\n    auto t1 = atan2(a.re, a.im),\n         t2 = atan2(b.re, b.im);\n\n    auto t3 = t1 - t2;\n    if(t3 < 0)\n        return t3 + 2*PI;\n    else\n        return t3;\n\n//    auto x = (a.re*b.re + a.im*b.im) / (a.abs * b.abs);\n//    if(x.approxEqual(-1)) x = -1;\n//    if(x.approxEqual(1)) x = 1;\n\n//    auto v = acos(x);\n//    if(v.isNaN){\n//        writefln(\"%s, %s\", a, b);\n//        writefln(\"%s, %s\", (a.re*b.re + a.im*b.im), (a.abs * b.abs));\n//        throw new Exception(\"aa\");\n//    }\n//    return v;\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    rr = []\n\n    def f():\n        n = I()\n        r,t = LF()\n        a = [LI() for _ in range(n)]\n        d = {}\n        M = 32\n        for i in range(n):\n            ax,ay = a[i]\n            for j in range(n):\n                if i == j:\n                    continue\n                bx,by = a[j]\n                d[i*M+j] = math.atan2(bx-ax,by-ay) / math.pi * 180\n        ky = {}\n        for i in range(n):\n            ax,ay = a[i]\n            for j in range(n):\n                bx,by = a[j]\n                ky[i*M+j] = pow(pow(ax-bx, 2) + pow(ay-by, 2), 0.5)\n        e = collections.defaultdict(list)\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                ij = i*M+j\n                dij = d[ij]\n                for k in range(n):\n                    if k == j:\n                        continue\n                    jk = j*M+k\n                    djk = d[jk]\n                    if abs(dij-djk) <= t or 360 - abs(dij-djk) <= t:\n                        e[(i,j)].append(((j,k), ky[jk]))\n\n        def search():\n            res = 0\n            dp = [[None]*n for _ in range(n)]\n            for j in range(1, n):\n                k = ky[j]\n                if k > r:\n                    continue\n                s = (j,1)\n                res = 1\n                dp[0][j] = k\n            if res == 0:\n                return 0\n            while True:\n                wf = False\n                nd = [[None]*n for _ in range(n)]\n                for i in range(n):\n                    for j in range(n):\n                        if dp[i][j] is None:\n                            continue\n                        dij = dp[i][j]\n                        for nn,k in e[(i,j)]:\n                            nk = dij + k\n                            if nk > r or (not nd[j][nn[1]] is None and nd[j][nn[1]] < nk):\n                                continue\n                            nd[j][nn[1]] = nk\n                            wf = True\n                if wf:\n                    res += 1\n                    dp = nd\n                else:\n                    break\n            return res\n\n        return search()\n\n    while True:\n        rr.append(f())\n        break\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nimport heapq\n\nEPS = 1e-10\nINF = 999999999\n\ndef dot(a, b):\n    return a[0]*b[0] + a[1]*b[1]\ndef norm(a):\n    return math.hypot(a[0], a[1])\ndef sub(a, b):\n    return (a[0]-b[0], a[1]-b[1])\ndef get_angle(a, b):\n    return math.acos(dot(a,b) / (norm(a) * norm(b)))\n\ndef main():\n    n = int(sys.stdin.readline())\n    r, degree = map(float, sys.stdin.readline().split())\n    rad = math.radians(degree)\n    nodes = []\n    for i in range(n):\n        x,y = map(int, sys.stdin.readline().split())\n        nodes.append( (x,y) )\n\n    edges = {}\n    # ????????????????????¨???\n    for i in range(n): # ?????¨??°\n        for j in range(n): # ?????????\n            if i == j:\n                continue\n            for k in range(n): # ?¬??????´???\n                if i == k or j == k:\n                    continue\n                angle = get_angle( sub(nodes[k], nodes[i]), sub(nodes[i], nodes[j]) )\n                if angle <= rad + EPS:\n                    if i not in edges:\n                        edges[i] = {}\n                    if j not in edges[i]:\n                        edges[i][j] = []\n                    edges[i][j].append( k )\n\n    # cost\n    costs = {}\n    for i in range(n):\n        costs[i] = {}\n        for j in range(n):\n            if i == j:\n                costs[i][j] = INF\n            else:\n                costs[i][j] = norm(sub(nodes[i], nodes[j]))\n\n    # [?????????????????°k][?????¨??°i][??????j]\n    dp = [[[INF for j in range(n)] for i in range(n)] for k in range(10001)]\n\n    pq = []\n    heapq.heapify(pq)\n    # init\n    for k in range(n):\n        if costs[0][k] <= r + EPS:\n            dp[1][k][0] = costs[0][k]\n            heapq.heappush(pq, (costs[0][k], (1,k,0))) # (cost, (????????????, ?????¨??°, ??????))\n\n    while len(pq) > 0:\n        curr_cost,state = heapq.heappop(pq)\n        curr_carrot, curr, prev = state\n\n        # ?????????????????¶?????????????????????\n        if curr not in edges:\n            continue\n        if prev not in edges[curr]:\n            continue\n\n        for t in edges[curr][prev]:\n            next_cost = curr_cost + costs[curr][t]\n            if dp[curr_carrot + 1][t][curr] > next_cost and next_cost <= r + EPS:\n                dp[curr_carrot + 1][t][curr] = next_cost\n                heapq.heappush(pq, (next_cost, (curr_carrot + 1, t, curr)))\n\n    ans = 0\n    for k in range(10001):\n        for i in range(n):\n            for j in range(n):\n                if dp[k][i][j] != INF:\n                    ans = max(ans, k)\n\n    print(ans)\n\n\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    rr = []\n\n    def f():\n        n = I()\n        r,t = LF()\n        a = [LI() for _ in range(n)]\n        d = []\n        for i in range(n):\n            di = []\n            ax,ay = a[i]\n            for j in range(n):\n                if i == j:\n                    di.append(0)\n                    continue\n                bx,by = a[j]\n                di.append(math.atan2(bx-ax,by-ay) / math.pi * 180)\n            d.append(di)\n        ky = []\n        for i in range(n):\n            ki = []\n            ax,ay = a[i]\n            for j in range(n):\n                bx,by = a[j]\n                ki.append(pow(pow(ax-bx, 2) + pow(ay-by, 2), 0.5))\n            ky.append(ki)\n        e = collections.defaultdict(list)\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                dij = d[i][j]\n                dj = d[j]\n                for k in range(n):\n                    if k == j:\n                        continue\n                    djk = dj[k]\n                    if abs(dij-djk) <= t or 360 - abs(dij-djk) <= t:\n                        e[(i,j)].append(((j,k), ky[j][k]))\n\n        def search():\n            d = collections.defaultdict(lambda: inf)\n            q = []\n            for j in range(1, n):\n                k = ky[0][j]\n                if k > r:\n                    continue\n                s = (0,j,1)\n                d[s] = k\n                heapq.heappush(q, (k, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for uv, ud in e[(u[0],u[1])]:\n                    uv = (uv[0],uv[1],u[2]+1)\n                    if v[uv]:\n                        continue\n                    vd = k + ud\n                    if vd > r:\n                        continue\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return d\n\n        d = search()\n        if len(d) == 0:\n            return 0\n\n        return max(map(lambda x: x[2], d.keys()))\n\n    while True:\n        rr.append(f())\n        break\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    rr = []\n\n    def f():\n        n = I()\n        r,t = LF()\n        a = [LI() for _ in range(n)]\n        d = []\n        for i in range(n):\n            di = []\n            ax,ay = a[i]\n            for j in range(n):\n                if i == j:\n                    di.append(0)\n                    continue\n                bx,by = a[j]\n                di.append(math.atan2(bx-ax,by-ay) / math.pi * 180)\n            d.append(di)\n        ky = []\n        for i in range(n):\n            ki = []\n            ax,ay = a[i]\n            for j in range(n):\n                bx,by = a[j]\n                ki.append(pow(pow(ax-bx, 2) + pow(ay-by, 2), 0.5))\n            ky.append(ki)\n        e = collections.defaultdict(list)\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                dij = d[i][j]\n                dj = d[j]\n                for k in range(n):\n                    if k == j:\n                        continue\n                    djk = dj[k]\n                    if abs(dij-djk) <= t or 360 - abs(dij-djk) <= t:\n                        e[(i,j)].append(((j,k), ky[j][k]))\n\n        def search():\n            d = collections.defaultdict(lambda: inf)\n            q = []\n            for j in range(1, n):\n                s = (0,j,0)\n                d[s] = 0\n                heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for uv, ud in e[(u[0],u[1])]:\n                    uv = (uv[0],uv[1],u[2]+1)\n                    if v[uv]:\n                        continue\n                    vd = k + ud\n                    if vd > r:\n                        continue\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return d\n\n        d = search()\n\n        return max(map(lambda x: x[2], d.keys()))\n\n    while True:\n        rr.append(f())\n        break\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  }
]