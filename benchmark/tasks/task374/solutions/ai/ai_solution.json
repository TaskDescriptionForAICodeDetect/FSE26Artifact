[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n\n#define MAX_N 20\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint n;\ndouble r, theta;\nPoint cities[MAX_N];\nbool visited[MAX_N];\nint max_carrots = 0;\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble angle_between(Point a, Point b, Point c) {\n    double ab_x = b.x - a.x;\n    double ab_y = b.y - a.y;\n    double cb_x = b.x - c.x;\n    double cb_y = b.y - c.y;\n\n    double dot = (ab_x * cb_x + ab_y * cb_y);\n    double cross = (ab_x * cb_y - ab_y * cb_x);\n    double alpha = atan2(cross, dot);\n\n    return fabs(alpha * 180.0 / M_PI);\n}\n\nvoid dfs(int current, int carrots, double total_distance, Point prev_point, Point prev_prev_point) {\n    if (total_distance > r) {\n        return;\n    }\n    if (carrots > max_carrots) {\n        max_carrots = carrots;\n    }\n\n    for (int next = 0; next < n; next++) {\n        if (next == current) continue;\n\n        double dist = distance(cities[current], cities[next]);\n        if (total_distance + dist > r) continue;\n\n        if (carrots >= 2) {\n            double angle = angle_between(prev_prev_point, prev_point, cities[next]);\n            if (angle > theta) continue;\n        }\n\n        dfs(next, carrots + 1, total_distance + dist, cities[next], prev_point);\n    }\n}\n\nint main() {\n    scanf(\"%d %lf %lf\", &n, &r, &theta);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &cities[i].x, &cities[i].y);\n        visited[i] = false;\n    }\n\n    dfs(0, 1, 0.0, cities[0], cities[0]);\n\n    printf(\"%d\\n\", max_carrots);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:16:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\ndouble dist(const Point& a, const Point& b) {\n    return hypot(a.x - b.x, a.y - b.y);\n}\n\ndouble angle(const Point& a, const Point& b, const Point& c) {\n    double abx = b.x - a.x;\n    double aby = b.y - a.y;\n    double cbx = b.x - c.x;\n    double cby = b.y - c.y;\n    double dot = abx * cbx + aby * cby;\n    double cross = abx * cby - aby * cbx;\n    return atan2(cross, dot);\n}\n\nint main() {\n    int n;\n    double r, theta;\n    cin >> n >> r >> theta;\n    vector<Point> cities(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> cities[i].x >> cities[i].y;\n    }\n\n    // dp[mask][last] = {max_carrots, remaining_distance}\n    vector<vector<pair<int, double>>> dp(1 << n, vector<pair<int, double>>(n, {-1, 0}));\n    priority_queue<tuple<int, int, double, int>> pq; // carrots, mask, remaining_dist, last\n\n    for (int i = 0; i < n; ++i) {\n        double d = dist(cities[0], cities[i]);\n        if (d <= r) {\n            int mask = (1 << i);\n            dp[mask][i] = {1, r - d};\n            pq.push({1, mask, r - d, i});\n        }\n    }\n\n    int max_carrots = 0;\n    while (!pq.empty()) {\n        auto [carrots, mask, rem_dist, last] = pq.top();\n        pq.pop();\n        if (carrots < dp[mask][last].first) continue;\n        max_carrots = max(max_carrots, carrots);\n\n        for (int next = 0; next < n; ++next) {\n            if (next == last) continue;\n            double d = dist(cities[last], cities[next]);\n            if (d > rem_dist) continue;\n\n            if (mask & (1 << next)) {\n                // Already visited, can turn back\n                double ang = angle(cities[last], cities[next], cities[next]);\n                if (abs(ang) > theta * M_PI / 180.0) continue;\n                int new_mask = mask;\n                if (dp[new_mask][next].first < carrots + 1 || \n                    (dp[new_mask][next].first == carrots + 1 && dp[new_mask][next].second < rem_dist - d)) {\n                    dp[new_mask][next] = {carrots + 1, rem_dist - d};\n                    pq.push({carrots + 1, new_mask, rem_dist - d, next});\n                }\n            } else {\n                // Not visited yet\n                double ang = angle(cities[last], cities[next], cities[next]);\n                if (abs(ang) > theta * M_PI / 180.0) continue;\n                int new_mask = mask | (1 << next);\n                if (dp[new_mask][next].first < carrots + 1 || \n                    (dp[new_mask][next].first == carrots + 1 && dp[new_mask][next].second < rem_dist - d)) {\n                    dp[new_mask][next] = {carrots + 1, rem_dist - d};\n                    pq.push({carrots + 1, new_mask, rem_dist - d, next});\n                }\n            }\n        }\n    }\n\n    cout << max_carrots << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:17:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RabbitJourney {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        double r = scanner.nextDouble();\n        double theta = scanner.nextDouble();\n        theta = Math.toRadians(theta);\n\n        Point[] cities = new Point[n];\n        for (int i = 0; i < n; i++) {\n            double x = scanner.nextDouble();\n            double y = scanner.nextDouble();\n            cities[i] = new Point(x, y);\n        }\n\n        int maxCarrots = 0;\n        Queue<State> queue = new LinkedList<>();\n        queue.add(new State(0, 0.0, 0, -1, Double.NaN));\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            maxCarrots = Math.max(maxCarrots, current.carrots);\n\n            for (int next = 0; next < n; next++) {\n                if (next == current.currentCity) continue;\n\n                double distance = distance(cities[current.currentCity], cities[next]);\n                if (current.totalDistance + distance > r) continue;\n\n                if (current.lastCity != -1) {\n                    double angle = calculateAngle(cities[current.lastCity], cities[current.currentCity], cities[next]);\n                    if (angle > theta) continue;\n                }\n\n                queue.add(new State(next, current.totalDistance + distance, current.carrots + 1, current.currentCity, distance));\n            }\n        }\n\n        System.out.println(maxCarrots);\n    }\n\n    static double distance(Point a, Point b) {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n    }\n\n    static double calculateAngle(Point a, Point b, Point c) {\n        double angle1 = Math.atan2(b.y - a.y, b.x - a.x);\n        double angle2 = Math.atan2(c.y - b.y, c.x - b.x);\n        double angle = Math.abs(angle1 - angle2);\n        return Math.min(angle, 2 * Math.PI - angle);\n    }\n\n    static class State {\n        int currentCity;\n        double totalDistance;\n        int carrots;\n        int lastCity;\n        double lastDistance;\n\n        State(int currentCity, double totalDistance, int carrots, int lastCity, double lastDistance) {\n            this.currentCity = currentCity;\n            this.totalDistance = totalDistance;\n            this.carrots = carrots;\n            this.lastCity = lastCity;\n            this.lastDistance = lastDistance;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:17:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass RabbitTravel {\n    static class City {\n        int x, y;\n        City(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static int maxCarrots(int n, City[] cities, double r, double theta) {\n        int[] dp = new int[1 << n];\n        \n        for (int mask = 1; mask < (1 << n); mask++) {\n            if ((mask & 1) == 0) continue;\n            \n            for (int j = 0; j < n; j++) {\n                if (j == 0 || (mask & (1 << j)) == 0) continue;\n                \n                int prevMask = mask ^ (1 << j);\n                for (int k = 0; k < n; k++) {\n                    if (k == j || (prevMask & (1 << k)) == 0) continue;\n                    \n                    double dist = distance(cities[k], cities[j]);\n                    double angle = calculateAngle(cities[k], cities[0], cities[j]);\n                    \n                    if (dist <= r && angle <= theta) {\n                        dp[mask] = Math.max(dp[mask], dp[prevMask] + 1);\n                    }\n                }\n            }\n        }\n        \n        return Arrays.stream(dp).max().getAsInt();\n    }\n    \n    static double distance(City a, City b) {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n    }\n    \n    static double calculateAngle(City a, City b, City c) {\n        double ba = Math.atan2(a.y - b.y, a.x - b.x);\n        double bc = Math.atan2(c.y - b.y, c.x - b.x);\n        double angle = Math.abs(ba - bc) * 180 / Math.PI;\n        return Math.min(angle, 360 - angle);\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        City[] cities = new City[n];\n        cities[0] = new City(0, 0);\n        cities[1] = new City(1, 1);\n        cities[2] = new City(2, 2);\n        cities[3] = new City(3, 3);\n        cities[4] = new City(4, 4);\n        \n        double r = 10.0;\n        double theta = 90.0;\n        \n        System.out.println(maxCarrots(n, cities, r, theta));\n    }\n}",
    "timestamp": "2025-08-05 21:17:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#include <float.h>\n\n#define MAX_CITIES 100\n#define MAX_PATH_LENGTH 10000\n\ntypedef struct {\n    double x;\n    double y;\n} City;\n\ndouble calculate_distance(City a, City b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\ndouble calculate_angle(City prev, City curr, City next) {\n    double dx1 = curr.x - prev.x;\n    double dy1 = curr.y - prev.y;\n    double dx2 = next.x - curr.x;\n    double dy2 = next.y - curr.y;\n    \n    double dot_product = dx1 * dx2 + dy1 * dy2;\n    double mag1 = sqrt(dx1 * dx1 + dy1 * dy1);\n    double mag2 = sqrt(dx2 * dx2 + dy2 * dy2);\n    \n    return fabs(acos(dot_product / (mag1 * mag2)) * 180.0 / M_PI);\n}\n\nint max_carrots(int n, City cities[], double r, double theta) {\n    int max_carrots_count = 0;\n    \n    for (int start_city = 0; start_city < n; start_city++) {\n        for (int path_length = 1; path_length <= n; path_length++) {\n            int visited[MAX_CITIES] = {0};\n            double total_distance = 0;\n            int current_carrots = 0;\n            int current_city = start_city;\n            \n            visited[current_city] = 1;\n            current_carrots++;\n            \n            for (int step = 1; step < path_length; step++) {\n                int best_next_city = -1;\n                double min_angle_change = DBL_MAX;\n                \n                for (int next_city = 0; next_city < n; next_city++) {\n                    if (next_city == current_city) continue;\n                    \n                    double new_distance = total_distance + calculate_distance(cities[current_city], cities[next_city]);\n                    if (new_distance > r) continue;\n                    \n                    double angle_change = (step > 1) ? calculate_angle(cities[visited[step-2]], cities[current_city], cities[next_city]) : 0;\n                    if (angle_change > theta) continue;\n                    \n                    if (angle_change < min_angle_change) {\n                        min_angle_change = angle_change;\n                        best_next_city = next_city;\n                    }\n                }\n                \n                if (best_next_city == -1) break;\n                \n                total_distance += calculate_distance(cities[current_city], cities[best_next_city]);\n                current_city = best_next_city;\n                visited[step] = current_city;\n                current_carrots++;\n            }\n            \n            max_carrots_count = fmax(max_carrots_count, current_carrots);\n        }\n    }\n    \n    return max_carrots_count;\n}\n\nint main() {\n    int n;\n    double r, theta;\n    City cities[MAX_CITIES];\n    \n    scanf(\"%d %lf %lf\", &n, &r, &theta);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &cities[i].x, &cities[i].y);\n    }\n    \n    int result = max_carrots(n, cities, r, theta);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:17:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 105;\n\nstruct Point {\n    int x, y;\n};\n\nint n, r;\ndouble theta;\nPoint cities[MAXN];\nvector<int> best_path;\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble calculate_angle(Point a, Point b, Point c) {\n    double dx1 = b.x - a.x;\n    double dy1 = b.y - a.y;\n    double dx2 = c.x - b.x;\n    double dy2 = c.y - b.y;\n    \n    double dot = dx1 * dx2 + dy1 * dy2;\n    double mag1 = sqrt(dx1 * dx1 + dy1 * dy1);\n    double mag2 = sqrt(dx2 * dx2 + dy2 * dy2);\n    \n    return acos(dot / (mag1 * mag2)) * 180.0 / M_PI;\n}\n\nvoid dfs(int current, vector<int>& path, double total_distance, int carrots) {\n    if (total_distance > r) return;\n    \n    best_path = max(best_path, path);\n    \n    for (int next = 1; next <= n; next++) {\n        double segment_length = distance(cities[path.back()], cities[next]);\n        \n        if (path.size() >= 2) {\n            double turn_angle = calculate_angle(cities[path[path.size()-2]], \n                                                cities[path.back()], \n                                                cities[next]);\n            if (turn_angle > theta) continue;\n        }\n        \n        path.push_back(next);\n        dfs(next, path, total_distance + segment_length, carrots + 1);\n        path.pop_back();\n    }\n}\n\nint main() {\n    cin >> n >> r >> theta;\n    \n    for (int i = 1; i <= n; i++) {\n        cin >> cities[i].x >> cities[i].y;\n    }\n    \n    vector<int> initial_path = {1};\n    dfs(1, initial_path, 0, 1);\n    \n    cout << best_path.size() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef max_carrots(n, coords, r, theta):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def angle(p1, p2, p3):\n        a = (p1[0] - p2[0], p1[1] - p2[1])\n        b = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_prod = (a[0] * b[0] + a[1] * b[1])\n        length_product = math.hypot(*a) * math.hypot(*b)\n        if length_product == 0:\n            return 0\n        value = dot_prod / length_product\n        value = max(-1.0, min(1.0, value))\n        return math.degrees(math.acos(value))\n    \n    max_carrots_dp = [0] * (1 << n)\n    distances = [[distance(coords[i], coords[j]) for j in range(n)] for i in range(n)]\n\n    for mask in range(1 << n):\n        for u in range(n):\n            if not (mask & (1 << u)):\n                continue\n            for v in range(n):\n                if mask & (1 << v):\n                    continue\n                if u == v:\n                    continue\n\n                prev_mask = mask ^ (1 << u)\n                if prev_mask == 0:\n                    if distances[u][v] <= r:\n                        if max_carrots_dp[mask | (1 << v)] < 1:\n                            max_carrots_dp[mask | (1 << v)] = 1\n                    continue\n\n                for k in range(n):\n                    if not (prev_mask & (1 << k)) or k == u:\n                        continue\n                    if distances[u][v] <= r:\n                        if angle(coords[k], coords[u], coords[v]) <= theta:\n                            max_carrots_dp[mask | (1 << v)] = max(max_carrots_dp[mask | (1 << v)], max_carrots_dp[mask] + 1)\n\n    return max(max_carrots_dp)\n\nn = 4\ncoords = [(0, 0), (2, 2), (2, 0), (0, 2)]\nr = 5\ntheta = 90\n\nprint(max_carrots(n, coords, r, theta))",
    "timestamp": "2025-08-13 05:47:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RabbitJourney {\n    static class City {\n        int x, y;\n\n        City(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static int maxCarrots(int n, City[] cities, double r, double theta) {\n        return dfs(cities, 0, r, theta, -1, 0, new HashMap<>());\n    }\n\n    private static int dfs(City[] cities, int current, double remainingR, double maxTheta, int prevIndex, double prevAngle, Map<String, Integer> memo) {\n        String key = current + \"#\" + remainingR + \"#\" + prevIndex + \"#\" + prevAngle;\n        if (memo.containsKey(key)) return memo.get(key);\n\n        int maxCarrots = 0;\n        \n        for (int next = 0; next < cities.length; next++) {\n            if (next != current) {\n                double distance = calculateDistance(cities[current], cities[next]);\n                double angleWithPrev = prevIndex == -1 ? 0 : calculateAngle(cities[prevIndex], cities[current], cities[next]);\n                if (remainingR >= distance && (prevIndex == -1 || Math.abs(angleWithPrev - prevAngle) <= maxTheta)) {\n                    int carrots = 1 + dfs(cities, next, remainingR - distance, maxTheta, current, angleWithPrev, memo);\n                    maxCarrots = Math.max(maxCarrots, carrots);\n                }\n            }\n        }\n\n        memo.put(key, maxCarrots);\n        return maxCarrots;\n    }\n\n    private static double calculateDistance(City a, City b) {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n    }\n\n    private static double calculateAngle(City a, City b, City c) {\n        double abx = b.x - a.x;\n        double aby = b.y - a.y;\n        double bcx = c.x - b.x;\n        double bcy = c.y - b.y;\n        double dotProduct = abx * bcx + aby * bcy;\n        double crossProduct = abx * bcy - aby * bcx;\n        return Math.atan2(crossProduct, dotProduct);\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        City[] cities = {\n            new City(0, 0),\n            new City(2, 2),\n            new City(4, 4),\n            new City(6, 6),\n            new City(8, 8)\n        };\n        double r = 20.0;\n        double theta = Math.PI;\n        System.out.println(maxCarrots(n, cities, r, theta));\n    }\n}",
    "timestamp": "2025-08-13 05:47:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    int x, y;\n} City;\n\ndouble distance(City a, City b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble angle_change(City a, City b, City c) {\n    double angle1 = atan2(b.y - a.y, b.x - a.x);\n    double angle2 = atan2(c.y - b.y, c.x - b.x);\n    double angle_diff = fabs(angle2 - angle1);\n    return fmin(angle_diff, 2 * M_PI - angle_diff);  // normalize the angle change\n}\n\nvoid solve(int n, int r, double theta, City cities[]) {\n    int dp[100][100]; // dp[i][j] -> max carrots to reach city j with i total travel length\n    double travel_distance[100][100];\n\n    for (int i = 0; i < n; i++) \n        for (int j = 0; j < n; j++) \n            travel_distance[i][j] = distance(cities[i], cities[j]);\n\n    for (int i = 0; i < 100; i++)\n        for (int j = 0; j < 100; j++)\n            dp[i][j] = -1; // Initialize DP table with -1\n\n    dp[0][0] = 1;  // Start from city 1 (index 0 in array)\n\n    int max_carrots = 1;\n\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j] == -1) continue;\n            for (int k = 0; k < n; k++) {\n                double current_distance = travel_distance[j][k];\n                if (i + current_distance <= r) {\n                    if (i > 0) {\n                        for (int prev = 0; prev < n; prev++) {\n                            if (dp[i-1][prev] != -1 && angle_change(cities[prev], cities[j], cities[k]) <= theta) {\n                                dp[i + (int)current_distance][k] = fmax(dp[i + (int)current_distance][k], dp[i][j] + 1);\n                            }\n                        }\n                    } else {\n                        dp[i + (int)current_distance][k] = fmax(dp[i + (int)current_distance][k], dp[i][j] + 1);\n                    }\n                }\n                    max_carrots = fmax(max_carrots, dp[i + (int)current_distance][k]);\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max_carrots);\n}\n\nint main() {\n    int n = 4, r = 15;\n    double theta = M_PI / 2;\n    City cities[] = {\n        {0, 0}, {10, 0}, {10, 10}, {0, 10}\n    };\n    solve(n, r, theta, cities);\n    return 0;\n}",
    "timestamp": "2025-08-13 05:47:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\nimport math\n\ndef calculate_distance(city1, city2):\n    return math.sqrt((city1[0] - city2[0])**2 + (city1[1] - city2[1])**2)\n\ndef calculate_angle(prev_point, current_point, next_point):\n    vector1 = (current_point[0] - prev_point[0], current_point[1] - prev_point[1])\n    vector2 = (next_point[0] - current_point[0], next_point[1] - current_point[1])\n    \n    dot_product = vector1[0]*vector2[0] + vector1[1]*vector2[1]\n    magnitude1 = math.sqrt(vector1[0]**2 + vector1[1]**2)\n    magnitude2 = math.sqrt(vector2[0]**2 + vector2[1]**2)\n    \n    cos_angle = dot_product / (magnitude1 * magnitude2)\n    angle = math.acos(max(min(cos_angle, 1), -1))\n    \n    return math.degrees(angle)\n\ndef max_carrots(n, cities, r, theta):\n    def dfs(current_city, path, total_distance, visited_cities):\n        nonlocal max_carrots_count\n        \n        max_carrots_count = max(max_carrots_count, len(visited_cities))\n        \n        for next_city in range(1, n+1):\n            distance = calculate_distance(cities[current_city-1], cities[next_city-1])\n            \n            if total_distance + distance <= r:\n                new_path = path + [next_city]\n                \n                # Check angle constraint\n                if len(path) >= 2:\n                    angle = calculate_angle(cities[path[-2]-1], cities[current_city-1], cities[next_city-1])\n                    if angle > theta:\n                        continue\n                \n                new_visited_cities = visited_cities.copy()\n                new_visited_cities.add(next_city)\n                \n                dfs(next_city, new_path, total_distance + distance, new_visited_cities)\n    \n    max_carrots_count = 0\n    dfs(1, [1], 0, {1})\n    \n    return max_carrots_count\n\n# Example usage\nn = 5\ncities = [(0,0), (1,1), (2,2), (3,3), (4,4)]\nr = 10\ntheta = 90\n\nresult = max_carrots(n, cities, r, theta)\nprint(result)",
    "timestamp": "2025-08-13 05:47:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef max_carrots(n, r, theta, cities):\n    theta_rad = math.radians(theta)\n    max_carrots = 0\n    # Precompute all possible edges (i, j) with angle constraints\n    edges = {}\n    for i in range(n):\n        edges[i] = []\n        xi, yi = cities[i]\n        for j in range(n):\n            if i == j:\n                continue\n            xj, yj = cities[j]\n            dx = xj - xi\n            dy = yj - yi\n            length = math.hypot(dx, dy)\n            edges[i].append((j, length, math.atan2(dy, dx)))\n    \n    # DP state: (current_city, last_angle, total_length) -> max_carrots\n    from collections import defaultdict\n    dp = defaultdict(int)\n    dp[(0, None, 0)] = 1  # starts at city 1 (0-indexed), with 1 carrot\n    \n    queue = [(0, None, 0)]\n    \n    while queue:\n        new_queue = []\n        for current_city, last_angle, total_length in queue:\n            current_carrots = dp[(current_city, last_angle, total_length)]\n            max_carrots = max(max_carrots, current_carrots)\n            \n            for neighbor, length, angle in edges[current_city]:\n                new_total_length = total_length + length\n                if new_total_length > r:\n                    continue\n                if last_angle is not None:\n                    angle_diff = abs(angle - last_angle)\n                    angle_diff = min(angle_diff, 2 * math.pi - angle_diff)\n                    if angle_diff > theta_rad:\n                        continue\n                new_state = (neighbor, angle, new_total_length)\n                if new_state not in dp or dp[new_state] < current_carrots + 1:\n                    dp[new_state] = current_carrots + 1\n                    new_queue.append(new_state)\n        queue = new_queue\n    \n    return max_carrots\n\n# Sample usage:\n# n = 4\n# r = 10.0\n# theta = 90\n# cities = [(0, 0), (1, 0), (1, 1), (0, 1)]\n# print(max_carrots(n, r, theta, cities))",
    "timestamp": "2025-08-13 05:48:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nstruct City {\n    int x, y;\n};\n\n// Calculate the Euclidean distance between two cities\ndouble distance(const City &a, const City &b) {\n    return sqrt(pow(b.x - a.x, 2) + pow(b.y - a.y, 2));\n}\n\n// Calculate the angle in radians between three cities a->b->c\ndouble angle(const City &a, const City &b, const City &c) {\n    double angle1 = atan2(b.y - a.y, b.x - a.x);\n    double angle2 = atan2(c.y - b.y, c.x - b.x);\n    double result = angle2 - angle1;\n\n    if (result < -M_PI)\n        result += 2 * M_PI;\n    if (result > M_PI)\n        result -= 2 * M_PI;\n\n    return fabs(result);\n}\n\nint maxCarrots(int n, vector<City> &cities, double r, double theta) {\n    vector<vector<double>> dist(n, vector<double>(n, 0));\n    vector<vector<double>> angles(n, vector<double>(n, 0));\n\n    // Precompute distances and angles for all pairs of cities\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i == j) continue;\n            dist[i][j] = distance(cities[i], cities[j]);\n            if (i != 0) {\n                angles[i][j] = angle(cities[i - 1], cities[i], cities[j]);\n            }\n        }\n    }\n\n    vector<vector<double>> dp(n, vector<double>(n, -1));\n    vector<vector<int>> carrots(n, vector<int>(n, 0));\n\n    // Start the journey from city 0\n    dp[0][0] = 0;\n    carrots[0][0] = 1;\n\n    // Dynamic programming to find the maximum number of carrots\n    for (int len = 1; len < n; ++len) {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (dp[i][j] < 0) continue;\n                for (int k = 0; k < n; ++k) {\n                    if (k == j) continue;\n                    if (dp[i][j] + dist[j][k] <= r && (i == 0 || angles[i][j] <= theta)) {\n                        if (dp[j][k] < 0 || carrots[j][k] < carrots[i][j] + 1) {\n                            dp[j][k] = dp[i][j] + dist[j][k];\n                            carrots[j][k] = carrots[i][j] + 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Find the maximum number of carrots the rabbit can collect\n    int maxCarrots = 0;\n    for (int j = 0; j < n; ++j) {\n        maxCarrots = max(maxCarrots, carrots[j][n-1]);\n    }\n\n    return maxCarrots;\n}\n\nint main() {\n    int n;\n    double r, theta;\n    cin >> n >> r >> theta;\n    theta = theta * M_PI / 180; // Convert theta to radians\n\n    vector<City> cities(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> cities[i].x >> cities[i].y;\n    }\n\n    cout << maxCarrots(n, cities, r, theta) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:28:14"
  }
]