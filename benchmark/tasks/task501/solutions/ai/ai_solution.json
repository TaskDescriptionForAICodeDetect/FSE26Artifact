[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    int val;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* parseTree(char* s, int* pos) {\n    if (s[*pos] == '\\0' || s[*pos] == ')') return NULL;\n    \n    Node* node = malloc(sizeof(Node));\n    node->left = NULL;\n    node->right = NULL;\n    \n    if (s[*pos] == '(') {\n        (*pos)++;\n        node->left = parseTree(s, pos);\n        if (s[*pos] == ')') (*pos)++;\n    }\n    \n    int val = 0;\n    while (s[*pos] >= '0' && s[*pos] <= '9') {\n        val = val * 10 + (s[*pos] - '0');\n        (*pos)++;\n    }\n    node->val = val;\n    \n    if (s[*pos] == '(') {\n        (*pos)++;\n        node->right = parseTree(s, pos);\n        if (s[*pos] == ')') (*pos)++;\n    }\n    \n    return node;\n}\n\nvoid combineTree(Node* t1, Node* t2, char* result) {\n    if (!t1 && !t2) {\n        result[0] = '\\0';\n        return;\n    }\n    \n    int rootVal = (t1 ? t1->val : 0) + (t2 ? t2->val : 0);\n    char leftResult[1000] = {0};\n    char rightResult[1000] = {0};\n    \n    if (t1 && t1->left && t2 && t2->left) {\n        combineTree(t1->left, t2->left, leftResult);\n    }\n    \n    if (t1 && t1->right && t2 && t2->right) {\n        combineTree(t1->right, t2->right, rightResult);\n    }\n    \n    sprintf(result, \"%s%d%s\", \n        leftResult[0] ? \"(\":\"\", \n        rootVal, \n        leftResult[0] ? leftResult : \"\");\n    \n    if (rightResult[0]) {\n        int len = strlen(result);\n        sprintf(result + len, \"(%s)\", rightResult);\n    }\n}\n\nvoid freeTree(Node* node) {\n    if (!node) return;\n    freeTree(node->left);\n    freeTree(node->right);\n    free(node);\n}\n\nint main() {\n    char tree1[1000], tree2[1000], result[2000];\n    scanf(\"%s %s\", tree1, tree2);\n    \n    int pos1 = 0, pos2 = 0;\n    Node* root1 = parseTree(tree1, &pos1);\n    Node* root2 = parseTree(tree2, &pos2);\n    \n    combineTree(root1, root2, result);\n    printf(\"%s\\n\", result);\n    \n    freeTree(root1);\n    freeTree(root2);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:55:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct TreeNode {\n    int val;\n    struct TreeNode *left;\n    struct TreeNode *right;\n} TreeNode;\n\nTreeNode* parseTree(const char **s) {\n    if (**s == '\\0') return NULL;\n    \n    TreeNode *node = (TreeNode*)malloc(sizeof(TreeNode));\n    node->left = NULL;\n    node->right = NULL;\n    \n    if (**s == '(') {\n        (*s)++;\n        node->left = parseTree(s);\n        (*s)++; // skip ')'\n    }\n    \n    char numStr[20];\n    int i = 0;\n    while (**s >= '0' && **s <= '9') {\n        numStr[i++] = **s;\n        (*s)++;\n    }\n    numStr[i] = '\\0';\n    node->val = atoi(numStr);\n    \n    if (**s == '(') {\n        (*s)++;\n        node->right = parseTree(s);\n        (*s)++; // skip ')'\n    }\n    \n    return node;\n}\n\nTreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n    if (t1 == NULL && t2 == NULL) return NULL;\n    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));\n    node->val = (t1 ? t1->val : 0) + (t2 ? t2->val : 0);\n    node->left = mergeTrees(t1 ? t1->left : NULL, t2 ? t2->left : NULL);\n    node->right = mergeTrees(t1 ? t1->right : NULL, t2 ? t2->right : NULL);\n    return node;\n}\n\nvoid serializeTree(TreeNode* root, char* buffer) {\n    if (root == NULL) return;\n    \n    if (root->left != NULL) {\n        strcat(buffer, \"(\");\n        serializeTree(root->left, buffer);\n        strcat(buffer, \")\");\n    }\n    \n    char numStr[20];\n    sprintf(numStr, \"%d\", root->val);\n    strcat(buffer, numStr);\n    \n    if (root->right != NULL) {\n        strcat(buffer, \"(\");\n        serializeTree(root->right, buffer);\n        strcat(buffer, \")\");\n    }\n}\n\nvoid freeTree(TreeNode* root) {\n    if (root == NULL) return;\n    freeTree(root->left);\n    freeTree(root->right);\n    free(root);\n}\n\nint main() {\n    char s1[1000], s2[1000];\n    scanf(\"%s %s\", s1, s2);\n    \n    const char *p1 = s1;\n    const char *p2 = s2;\n    TreeNode *t1 = parseTree(&p1);\n    TreeNode *t2 = parseTree(&p2);\n    \n    TreeNode *merged = mergeTrees(t1, t2);\n    \n    char result[2000] = \"\";\n    serializeTree(merged, result);\n    printf(\"%s\\n\", result);\n    \n    freeTree(t1);\n    freeTree(t2);\n    freeTree(merged);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:55:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nTreeNode* parseTree(const string &s, int &pos) {\n    if (pos >= s.size()) return nullptr;\n    TreeNode* node = nullptr;\n    if (s[pos] == '(') {\n        pos++;\n        TreeNode* left = parseTree(s, pos);\n        if (s[pos] != ')') {\n            // error\n            return nullptr;\n        }\n        pos++;\n        node = new TreeNode(0);\n        node->left = left;\n    } else {\n        node = new TreeNode(0);\n    }\n    \n    int num = 0;\n    while (pos < s.size() && isdigit(s[pos])) {\n        num = num * 10 + (s[pos] - '0');\n        pos++;\n    }\n    node->val = num;\n    \n    if (pos < s.size() && s[pos] == '(') {\n        pos++;\n        TreeNode* right = parseTree(s, pos);\n        if (s[pos] != ')') {\n            // error\n            return nullptr;\n        }\n        pos++;\n        node->right = right;\n    }\n    return node;\n}\n\nTreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n    if (!t1 && !t2) return nullptr;\n    int val1 = t1 ? t1->val : 0;\n    int val2 = t2 ? t2->val : 0;\n    TreeNode* node = new TreeNode(val1 + val2);\n    node->left = mergeTrees(t1 ? t1->left : nullptr, t2 ? t2->left : nullptr);\n    node->right = mergeTrees(t1 ? t1->right : nullptr, t2 ? t2->right : nullptr);\n    return node;\n}\n\nstring serializeTree(TreeNode* root) {\n    if (!root) return \"\";\n    string left = root->left ? \"(\" + serializeTree(root->left) + \")\" : \"\";\n    string right = root->right ? \"(\" + serializeTree(root->right) + \")\" : \"\";\n    return left + to_string(root->val) + right;\n}\n\nint main() {\n    string s1, s2;\n    cin >> s1 >> s2;\n    int pos1 = 0, pos2 = 0;\n    TreeNode* t1 = parseTree(s1, pos1);\n    TreeNode* t2 = parseTree(s2, pos2);\n    TreeNode* merged = mergeTrees(t1, t2);\n    cout << serializeTree(merged) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:56:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String tree1Str = scanner.nextLine().trim();\n        String tree2Str = scanner.nextLine().trim();\n        TreeNode tree1 = parseTree(tree1Str);\n        TreeNode tree2 = parseTree(tree2Str);\n        TreeNode mergedTree = mergeTrees(tree1, tree2);\n        String result = serializeTree(mergedTree);\n        System.out.println(result);\n    }\n\n    private static TreeNode parseTree(String s) {\n        if (s.isEmpty()) {\n            return null;\n        }\n        int leftBracket = s.indexOf('(');\n        int rightBracket = s.lastIndexOf(')');\n        int rootVal;\n        String leftStr = \"\";\n        String rightStr = \"\";\n        if (leftBracket == -1) {\n            rootVal = Integer.parseInt(s);\n            return new TreeNode(rootVal);\n        } else {\n            rootVal = Integer.parseInt(s.substring(0, leftBracket));\n            String children = s.substring(leftBracket + 1, rightBracket);\n            int splitPos = findSplitPos(children);\n            if (splitPos != -1) {\n                leftStr = children.substring(0, splitPos);\n                rightStr = children.substring(splitPos + 1);\n            }\n        }\n        TreeNode root = new TreeNode(rootVal);\n        root.left = parseTree(leftStr);\n        root.right = parseTree(rightStr);\n        return root;\n    }\n\n    private static int findSplitPos(String s) {\n        int balance = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n            if (balance == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private static TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null && t2 == null) {\n            return null;\n        }\n        int val = (t1 == null ? 0 : t1.val) + (t2 == null ? 0 : t2.val);\n        TreeNode node = new TreeNode(val);\n        node.left = mergeTrees(t1 != null ? t1.left : null, t2 != null ? t2.left : null);\n        node.right = mergeTrees(t1 != null ? t1.right : null, t2 != null ? t2.right : null);\n        return node;\n    }\n\n    private static String serializeTree(TreeNode root) {\n        if (root == null) {\n            return \"\";\n        }\n        String leftStr = serializeTree(root.left);\n        String rightStr = serializeTree(root.right);\n        StringBuilder sb = new StringBuilder();\n        if (!leftStr.isEmpty() || !rightStr.isEmpty()) {\n            sb.append(\"(\").append(leftStr);\n            if (!leftStr.isEmpty() && !rightStr.isEmpty()) {\n                sb.append(\",\");\n            }\n            sb.append(rightStr).append(\")\");\n        }\n        sb.insert(0, root.val);\n        return sb.toString();\n    }\n}",
    "timestamp": "2025-08-05 21:56:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeOverlay {\n    static class Node {\n        int value;\n        Node left, right;\n        \n        Node(int value) {\n            this.value = value;\n            this.left = null;\n            this.right = null;\n        }\n    }\n    \n    public static Node parseTree(String s) {\n        if (s.isEmpty()) return null;\n        \n        int rootValue = 0;\n        int rootIndex = s.indexOf(\")\");\n        if (rootIndex != -1) {\n            rootValue = Integer.parseInt(s.substring(rootIndex + 1, s.lastIndexOf(\"(\")));\n        } else {\n            rootValue = Integer.parseInt(s);\n            return new Node(rootValue);\n        }\n        \n        Node root = new Node(rootValue);\n        String leftSubstr = s.substring(1, rootIndex);\n        String rightSubstr = s.substring(s.lastIndexOf(\"(\") + 1, s.length() - 1);\n        \n        root.left = parseTree(leftSubstr);\n        root.right = parseTree(rightSubstr);\n        \n        return root;\n    }\n    \n    public static Node combineTree(Node tree1, Node tree2) {\n        if (tree1 == null && tree2 == null) return null;\n        if (tree1 == null) return tree2;\n        if (tree2 == null) return tree1;\n        \n        Node newRoot = new Node(tree1.value + tree2.value);\n        newRoot.left = combineTree(tree1.left, tree2.left);\n        newRoot.right = combineTree(tree1.right, tree2.right);\n        \n        return newRoot;\n    }\n    \n    public static String serializeTree(Node root) {\n        if (root == null) return \"\";\n        \n        String leftStr = serializeTree(root.left);\n        String rightStr = serializeTree(root.right);\n        \n        if (leftStr.isEmpty() && rightStr.isEmpty()) {\n            return String.valueOf(root.value);\n        }\n        \n        return \"(\" + leftStr + \")\" + root.value + \"(\" + rightStr + \")\";\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String tree1Str = scanner.nextLine();\n        String tree2Str = scanner.nextLine();\n        \n        Node tree1 = parseTree(tree1Str);\n        Node tree2 = parseTree(tree2Str);\n        \n        Node combinedTree = combineTree(tree1, tree2);\n        \n        System.out.println(serializeTree(combinedTree));\n    }\n}",
    "timestamp": "2025-08-05 21:57:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    \n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* parseTree(const std::string& s) {\n        if (s.empty()) return nullptr;\n        \n        int rootVal = 0;\n        size_t valStart = s.find_first_of(\"0123456789\");\n        size_t valEnd = s.find_first_not_of(\"0123456789\", valStart);\n        \n        if (valStart != std::string::npos) {\n            rootVal = std::stoi(s.substr(valStart, valEnd - valStart));\n        }\n        \n        TreeNode* root = new TreeNode(rootVal);\n        \n        size_t leftStart = s.find('(');\n        size_t leftEnd = findMatchingParen(s, leftStart);\n        \n        if (leftStart != std::string::npos && leftEnd != std::string::npos) {\n            root->left = parseTree(s.substr(leftStart + 1, leftEnd - leftStart - 1));\n        }\n        \n        size_t rightStart = s.find_last_of('(');\n        size_t rightEnd = findMatchingParen(s, rightStart);\n        \n        if (rightStart != std::string::npos && rightEnd != std::string::npos) {\n            root->right = parseTree(s.substr(rightStart + 1, rightEnd - rightStart - 1));\n        }\n        \n        return root;\n    }\n    \n    TreeNode* combineTree(TreeNode* t1, TreeNode* t2) {\n        if (!t1 && !t2) return nullptr;\n        if (!t1) return t2;\n        if (!t2) return t1;\n        \n        TreeNode* newRoot = new TreeNode(t1->val + t2->val);\n        newRoot->left = combineTree(t1->left, t2->left);\n        newRoot->right = combineTree(t1->right, t2->right);\n        \n        return newRoot;\n    }\n    \n    std::string serializeTree(TreeNode* root) {\n        if (!root) return \"\";\n        \n        std::string result = \"\";\n        \n        if (root->left) {\n            result += \"(\" + serializeTree(root->left) + \")\";\n        }\n        \n        result += std::to_string(root->val);\n        \n        if (root->right) {\n            result += \"(\" + serializeTree(root->right) + \")\";\n        }\n        \n        return result;\n    }\n    \nprivate:\n    size_t findMatchingParen(const std::string& s, size_t start) {\n        if (start == std::string::npos) return std::string::npos;\n        \n        int depth = 1;\n        for (size_t i = start + 1; i < s.length(); ++i) {\n            if (s[i] == '(') depth++;\n            if (s[i] == ')') depth--;\n            if (depth == 0) return i;\n        }\n        \n        return std::string::npos;\n    }\n};\n\nint main() {\n    std::string tree1, tree2;\n    std::getline(std::cin, tree1);\n    std::getline(std::cin, tree2);\n    \n    Solution solution;\n    TreeNode* parsedTree1 = solution.parseTree(tree1);\n    TreeNode* parsedTree2 = solution.parseTree(tree2);\n    \n    TreeNode* combinedTree = solution.combineTree(parsedTree1, parsedTree2);\n    \n    std::string result = solution.serializeTree(combinedTree);\n    std::cout << result << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:57:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef parse_tree(s):\n    if not s:\n        return None, 0\n    idx = 0\n    if s[idx] == '(':\n        left_tree, left_len = parse_tree(s[1:])\n        idx += left_len + 2\n    else:\n        left_tree = None\n    num_start = idx\n    while s[idx].isdigit():\n        idx += 1\n    root_val = int(s[num_start:idx])\n    if idx < len(s) and s[idx] == '(':\n        right_tree, right_len = parse_tree(s[idx+1:])\n        idx += right_len + 2\n    else:\n        right_tree = None\n    return TreeNode(root_val, left_tree, right_tree), idx\n\ndef tree_to_string(node):\n    if not node:\n        return \"\"\n    left_str = f\"({tree_to_string(node.left)})\" if node.left else \"\"\n    right_str = f\"({tree_to_string(node.right)})\" if node.right else \"\"\n    return f\"{left_str}[{node.val}]{right_str}\"\n\ndef merge_trees(t1, t2):\n    if not t1 or not t2:\n        return None\n    new_root = TreeNode(t1.val + t2.val)\n    if t1.left and t2.left:\n        new_root.left = merge_trees(t1.left, t2.left)\n    if t1.right and t2.right:\n        new_root.right = merge_trees(t1.right, t2.right)\n    return new_root\n\ndef overlay_tree(t1_str, t2_str):\n    tree1, _ = parse_tree(t1_str)\n    tree2, _ = parse_tree(t2_str)\n    merged_tree = merge_trees(tree1, tree2)\n    return tree_to_string(merged_tree)\n\n# Read input for two trees\ntree1_string = input().strip()\ntree2_string = input().strip()\n\n# Process to generate the merged tree string\nresult_tree_string = overlay_tree(tree1_string, tree2_string)\nprint(result_tree_string)",
    "timestamp": "2025-08-13 08:10:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class OverlayBinaryTrees {\n    \n    public TreeNode parseTree(String s) {\n        if (s.isEmpty()) return null;\n        int bracketCount = 0, splitIndex = -1;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(') bracketCount++;\n            else if (c == ')') bracketCount--;\n            else if (bracketCount == 0 && c == '[') {\n                splitIndex = i;\n                break;\n            }\n        }\n        String leftStr = s.substring(0, splitIndex);\n        String rightStr = s.substring(s.indexOf(']') + 1);\n        int rootVal = Integer.parseInt(s.substring(splitIndex + 1, s.indexOf(']')));\n        TreeNode root = new TreeNode(rootVal);\n        root.left = parseTree(leftStr);\n        root.right = parseTree(rightStr);\n        return root;\n    }\n    \n    public TreeNode overlayTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null || t2 == null) return null;\n        TreeNode newRoot = new TreeNode(t1.val + t2.val);\n        newRoot.left = overlayTrees(t1.left, t2.left);\n        newRoot.right = overlayTrees(t1.right, t2.right);\n        return newRoot;\n    }\n    \n    public String serializeTree(TreeNode root) {\n        if (root == null) return \"\";\n        String left = serializeTree(root.left);\n        String right = serializeTree(root.right);\n        return \"(\" + left + \")[\" + root.val + \"]\" + \"(\" + right + \")\";\n    }\n    \n    public String overlayTrees(String tree1, String tree2) {\n        TreeNode t1 = parseTree(tree1);\n        TreeNode t2 = parseTree(tree2);\n        TreeNode resultTree = overlayTrees(t1, t2);\n        return serializeTree(resultTree);\n    }\n\n    public static void main(String[] args) {\n        OverlayBinaryTrees obt = new OverlayBinaryTrees();\n        String tree1 = \"([1]([3])[2]([7])[5])\";\n        String tree2 = \"([2]([5])[3]([5])[8])\";\n        System.out.println(obt.overlayTrees(tree1, tree2));\n        // Outputs the result of overlaying the trees.\n    }\n}",
    "timestamp": "2025-08-13 08:10:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Define the structure for a tree node\ntypedef struct TreeNode {\n    int value;\n    struct TreeNode *left;\n    struct TreeNode *right;\n} TreeNode;\n\n// Function to parse the tree from a string representation\nTreeNode* parseTree(const char *s, int *index) {\n    if (s[*index] == '\\0') return NULL;\n\n    // Handle left child\n    TreeNode *left = NULL;\n    if (s[*index] == '(') {\n        (*index)++;\n        left = parseTree(s, index);\n        if (s[*index] == ')') (*index)++;\n    }\n\n    // Parse the root value\n    int value = 0;\n    while (isdigit(s[*index])) {\n        value = value * 10 + (s[*index] - '0');\n        (*index)++;\n    }\n\n    // Handle right child\n    TreeNode *right = NULL;\n    if (s[*index] == '[') {\n        (*index)++;\n        right = parseTree(s, index);\n        if (s[*index] == ']') (*index)++;\n    }\n\n    TreeNode *node = (TreeNode*)malloc(sizeof(TreeNode));\n    node->value = value;\n    node->left = left;\n    node->right = right;\n    return node;\n}\n\n// Function to serialize a tree back to string\nvoid serializeTree(TreeNode *root, char *out, int *outIndex) {\n    if (!root) return;\n\n    if (root->left) {\n        out[(*outIndex)++] = '(';\n        serializeTree(root->left, out, outIndex);\n        out[(*outIndex)++] = ')';\n    }\n\n    (*outIndex) += sprintf(out + (*outIndex), \"%d\", root->value);\n\n    if (root->right) {\n        out[(*outIndex)++] = '[';\n        serializeTree(root->right, out, outIndex);\n        out[(*outIndex)++] = ']';\n    }\n}\n\n// Function to merge two trees\nTreeNode* mergeTrees(TreeNode *t1, TreeNode *t2) {\n    if (!t1 || !t2) return NULL;\n\n    TreeNode *newNode = (TreeNode*)malloc(sizeof(TreeNode));\n    newNode->value = t1->value + t2->value;\n    newNode->left = mergeTrees(t1->left, t2->left);\n    newNode->right = mergeTrees(t1->right, t2->right);\n    \n    return newNode;\n}\n\n// Function to free the tree\nvoid freeTree(TreeNode *root) {\n    if (!root) return;\n    freeTree(root->left);\n    freeTree(root->right);\n    free(root);\n}\n\nint main() {\n    char tree1Str[1001], tree2Str[1001];\n    scanf(\"%1000s %1000s\", tree1Str, tree2Str);\n\n    int index1 = 0, index2 = 0;\n    TreeNode *root1 = parseTree(tree1Str, &index1);\n    TreeNode *root2 = parseTree(tree2Str, &index2);\n\n    if (!root1 || !root2) {\n        printf(\"\\n\");\n        freeTree(root1);\n        freeTree(root2);\n        return 0;\n    }\n\n    TreeNode *mergedRoot = mergeTrees(root1, root2);\n\n    char output[2001] = {0}; // Assuming the output won't exceed 2000 characters\n    int outIndex = 0;\n    serializeTree(mergedRoot, output, &outIndex);\n\n    printf(\"%s\\n\", output);\n\n    freeTree(root1);\n    freeTree(root2);\n    freeTree(mergedRoot);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 08:11:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def parse_tree(s):\n    if not s:\n        return None\n    \n    # Find the root value\n    root_start = s.find('(')\n    root_end = s.rfind(')')\n    if root_start == -1:\n        return (int(s), None, None)\n    \n    root_val = int(s[root_start+1:root_end])\n    \n    # Find left and right subtree strings\n    left_start = 0\n    left_end = root_start\n    right_start = root_end + 1\n    right_end = len(s)\n    \n    left_subtree = s[left_start:left_start+root_start]\n    right_subtree = s[right_start:right_end]\n    \n    return (root_val, \n            parse_tree(left_subtree) if left_subtree else None, \n            parse_tree(right_subtree) if right_subtree else None)\n\ndef combine_trees(tree1, tree2):\n    if not tree1 and not tree2:\n        return None\n    \n    if not tree1:\n        return tree2\n    \n    if not tree2:\n        return tree1\n    \n    root_val = tree1[0] + tree2[0]\n    \n    left_child = combine_trees(tree1[1], tree2[1]) if tree1[1] and tree2[1] else None\n    right_child = combine_trees(tree1[2], tree2[2]) if tree1[2] and tree2[2] else None\n    \n    return (root_val, left_child, right_child)\n\ndef tree_to_string(tree):\n    if not tree:\n        return ''\n    \n    root_val, left, right = tree\n    \n    left_str = tree_to_string(left)\n    right_str = tree_to_string(right)\n    \n    return f'({left_str}){root_val}({right_str})'\n\ndef solve(tree1_str, tree2_str):\n    tree1 = parse_tree(tree1_str)\n    tree2 = parse_tree(tree2_str)\n    \n    combined_tree = combine_trees(tree1, tree2)\n    \n    return tree_to_string(combined_tree)\n\n# Example usage\ntree1 = input().strip()\ntree2 = input().strip()\nprint(solve(tree1, tree2))",
    "timestamp": "2025-08-13 08:11:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def parse_tree(s):\n    if not s:\n        return None\n    left_part = ''\n    right_part = ''\n    root_val = ''\n    stack = []\n    left_done = False\n    root_start = -1\n    root_end = -1\n    for i, c in enumerate(s):\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            if stack:\n                start = stack.pop()\n                if not stack:\n                    if not left_done:\n                        left_part = s[start+1:i]\n                        left_done = True\n                        root_start = i + 1\n                    else:\n                        right_part = s[start+1:i]\n                        root_end = start\n    if not left_done:\n        root_start = 0\n    root_end = len(s)\n    for i in range(root_start, root_end):\n        if s[i] == '(' or s[i] == ')':\n            continue\n        root_val += s[i]\n    root_val = int(root_val) if root_val else 0\n    left_node = parse_tree(left_part) if left_part else None\n    right_node = parse_tree(right_part) if right_part else None\n    return (root_val, left_node, right_node)\n\ndef build_tree_string(node):\n    if not node:\n        return \"\"\n    left_str = build_tree_string(node[1]) if node[1] is not None else \"\"\n    right_str = build_tree_string(node[2]) if node[2] is not None else \"\"\n    result = \"\"\n    if left_str:\n        result += f\"({left_str})\"\n    result += str(node[0])\n    if right_str:\n        result += f\"({right_str})\"\n    return result\n\ndef merge_trees(t1, t2):\n    if not t1 and not t2:\n        return None\n    val1 = t1[0] if t1 else 0\n    val2 = t2[0] if t2 else 0\n    new_val = val1 + val2\n    left1 = t1[1] if t1 and t1[1] is not None else None\n    left2 = t2[1] if t2 and t2[1] is not None else None\n    right1 = t1[2] if t1 and t1[2] is not None else None\n    right2 = t2[2] if t2 and t2[2] is not None else None\n    new_left = merge_trees(left1, left2) if (left1 is not None and left2 is not None) else None\n    new_right = merge_trees(right1, right2) if (right1 is not None and right2 is not None) else None\n    return (new_val, new_left, new_right)\n\ns1 = input().strip()\ns2 = input().strip()\ntree1 = parse_tree(s1)\ntree2 = parse_tree(s2)\nmerged = merge_trees(tree1, tree2)\noutput = build_tree_string(merged)\nprint(output)",
    "timestamp": "2025-08-13 08:11:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nTreeNode* parseTree(const std::string& s, int& pos) {\n    if (pos >= s.size() || s[pos] == ')') return nullptr;\n    \n    TreeNode* node = nullptr;\n\n    if (s[pos] == '(') {\n        pos++;\n        node = parseTree(s, pos);\n        if (pos < s.size() && s[pos] == ')') pos++;\n    }\n\n    std::stringstream ss;\n    while (pos < s.size() && isdigit(s[pos])) {\n        ss << s[pos++];\n    }\n\n    int value;\n    ss >> value;\n    TreeNode* root = new TreeNode(value);\n    root->left = node;\n\n    if (pos < s.size() && s[pos] == '(') {\n        pos++;\n        root->right = parseTree(s, pos);\n        if (pos < s.size() && s[pos] == ')') pos++;\n    }\n\n    return root;\n}\n\nstd::string buildTreeString(TreeNode* node) {\n    if (!node) return \"\";\n    return \"(\" + buildTreeString(node->left) + \")\" + std::to_string(node->val) + \"(\" + buildTreeString(node->right) + \")\";\n}\n\nTreeNode* combineTrees(TreeNode* t1, TreeNode* t2) {\n    if (!t1 || !t2) return nullptr;\n    TreeNode* newNode = new TreeNode(t1->val + t2->val);\n    newNode->left = combineTrees(t1->left, t2->left);\n    newNode->right = combineTrees(t1->right, t2->right);\n    return newNode;\n}\n\nint main() {\n    std::string s1, s2;\n    std::getline(std::cin, s1);\n    std::getline(std::cin, s2);\n\n    int pos1 = 0, pos2 = 0;\n    TreeNode* tree1 = parseTree(s1, pos1);\n    TreeNode* tree2 = parseTree(s2, pos2);\n\n    TreeNode* resultTree = combineTrees(tree1, tree2);\n    std::string result = buildTreeString(resultTree);\n\n    std::cout << result << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:43:47"
  }
]