[
  {
    "language": "Scala",
    "code": "\nobject Main extends App {\n\n  import scala.io.StdIn._\n  import scala.math._\n\n  val a = readLine.trim.toList\n  val b = readLine.trim.toList\n  val aTree = parseAll(a).get\n  val bTree = parseAll(b).get\n  println(\n    aTree.merge(bTree)\n  )\n  sealed trait BinaryTree {\n    def merge(that: BinaryTree): BinaryTree\n  }\n  case class Node(value: Int, left: BinaryTree, right: BinaryTree) extends BinaryTree {\n    override def toString: String = s\"($left)[$value]($right)\"\n\n    override def merge(that: BinaryTree): BinaryTree = {\n      that match {\n        case Leaf ⇒ Leaf\n        case Node(v, l, r) ⇒ Node(value + v, left.merge(l), right.merge(r))\n      }\n    }\n  }\n  case object Leaf extends BinaryTree {\n    override def toString: String = \"\"\n\n    override def merge(that: BinaryTree): BinaryTree = Leaf\n  }\n  def parseAll(arg: List[Char]): Option[BinaryTree] = {\n    parse(arg) match {\n      case (n, Nil) ⇒ Some(n)\n      case _ ⇒ None\n    }\n  }\n  def parse(arg: List[Char]): (BinaryTree, List[Char]) = {\n    def readValue(arg: List[Char], res: Int = 0): (Int, List[Char]) = {\n      arg match {\n        case h::t if h.isDigit ⇒ readValue(t, res * 10 + h.asDigit)\n        case _ ⇒ (res, arg)\n      }\n    }\n    arg match {\n      case '('::t ⇒ parse(t) match {\n        case (left, ')'::'['::t) ⇒ readValue(t) match {\n          case (value, ']'::'('::t) ⇒ parse(t) match {\n            case (right, ')'::t) ⇒ (Node(value, left, right), t)\n            case _ ⇒ ???\n          }\n          case _ ⇒ ???\n        }\n        case (left, ')'::Nil) ⇒ (left, Nil)\n        case _ ⇒ ???\n      }\n      case _ ⇒ (Leaf, arg)\n    }\n  }\n  implicit class Extension[T](val value :T){\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    def let[R](func: T ⇒ R): R = func(value)\n  }\n}\n/*\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring A,B;\n\nstring rec(string S1,string S2){\n    if(S1==\"\" || S2==\"\") return \"\";\n    if(S1==\"()\" || S2==\"()\") return \"\";\n    int c = 0;\n    int N1 = S1.size(),N2 = S2.size();\n    string left1,right1;\n    string num1;\n    for(int i=0;i<N1;i++){\n        if(S1[i]=='(') c++;\n        if(S1[i]==')') c--;\n        if(c==0){\n            left1 = S1.substr(1,i-1);\n            int id = i+2;\n            while(S1[id]!=']'){\n                num1 += S1[id];\n                id++;\n            }\n            break;\n        }\n    }\n    for(int i=N1-1;i>=0;i--){\n        if(S1[i]=='(') c++;\n        if(S1[i]==')') c--;\n        if(c==0){\n            right1 = S1.substr(i+1,N1-i-2);\n            break;\n        }\n    }\n    c = 0;\n    string left2,right2;\n    string num2;\n    for(int i=0;i<N2;i++){\n        if(S2[i]=='(') c++;\n        if(S2[i]==')') c--;\n        if(c==0){\n            left2 = S2.substr(1,i-1);\n            int id = i+2;\n            while(S2[id]!=']'){\n                num2 += S2[id];\n                id++;\n            }\n            break;\n        }\n    }\n    for(int i=N2-1;i>=0;i--){\n        if(S2[i]=='(') c++;\n        if(S2[i]==')') c--;\n        if(c==0){\n            right2 = S2.substr(i+1,N2-i-2);\n            break;\n        }\n    }\n//    cerr << num1 << \" \" << num2 << endl;\n    int n = stoi(num1)+stoi(num2);\n    string center = to_string(n);\n    return '(' + rec(left1,left2) + ')' + '[' + center + ']' + '(' + rec(right1,right2) + ')';\n}\n\nint main(){\n    cin >> A >> B;\n    cout << rec(A,B) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define rep(i,m,n) for(int i = (m);i < (n);i++)\n#define P pair< pair<ll,ll> ,ll>\n#define pb push_back\n#define mk make_pair\nusing namespace std;\n#define Vec(a) vector <int> a\nconst int INF = 1 << 20;\nconst int MOD = 1e9+7;\n\nstring s1,s2;\nvector <P> p1;\nvector <P> p2;\nvector <P> p3;\nbool f;\n\n\nvoid dfs(ll now, ll count, ll depth){\n  //cout << \"count : \" <<  count << endl;\n  if(count > ULLONG_MAX/2){\n    f = false;\n    return;\n  }\n  if(now >= s1.size()){\n    return;\n  }\n  if(s1[now] == '('){\n    dfs(now+1,(count)*2-1,depth+1);\n  }\n  else if(s1[now] == ')'){\n    dfs(now+1,(count+1)/2,depth-1);\n  }\n  else if(s1[now] == '['){\n    //cout << \"count : \" << count << endl;\n    ll n = 0;\n    now++;\n    while(s1[now] != ']'){\n      n = 10*n + (s1[now] - '0');\n      now++;\n    }\n    p1.pb(mk(mk(depth,count),n));\n    dfs(now+2,count*2,depth+1);\n  }\n  \n}\n\nvoid dfs2(ll now, ll count, ll depth){\n  //cout << \"count : \" <<  count << endl;\n\n   if(count > ULLONG_MAX/2){\n    f = false;\n    return;\n  }\n  \n  if(now >= s2.size()){\n    return;\n  }\n  if(s2[now] == '('){\n    dfs2(now+1,(count)*2-1,depth+1);\n  }\n  else if(s2[now] == ')'){\n    dfs2(now+1,(count+1)/2,depth-1);\n  }\n  else if(s2[now] == '['){\n    //cout << \"count : \" << count << endl;\n    ll n = 0;\n    now++;\n    while(s2[now] != ']'){\n      n = 10*n + (s2[now] - '0');\n      now++;\n    }\n    p2.pb(mk(mk(depth,count),n));\n    dfs2(now+2,count*2,depth+1);\n  }\n  \n}\n\nstring Stoi(ll s){\n  string n = \"\";\n  while(s > 0){\n    n += (s%10 + '0');\n    s /= 10;\n  }\n  reverse(n.begin(),n.end());\n  return n;\n}\n\nstring dfs3(pair <ll,ll> x){\n  ll num = -1;\n  REP(i,p3.size()){\n    if(p3[i].first == x){\n      num = i;\n      break;\n    }\n  }\n  \n  string r = \"\";\n  string l = \"\";\n  if(num == -1){\n    return r;\n  }\n  else{\n    x.first++;\n    x.second = x.second*2-1;\n    r = dfs3(x);\n    x.second++;\n    l = dfs3(x);\n  }\n  \n  string res = \"(\" + r + \")[\" + Stoi(p3[num].second) + \"](\" + l + \")\";\n  return res;\n\n}\n\n\nint main(){\n  cin >> s1;\n  cin >> s2;\n  f = true;\n  dfs(0,1,0);\n  dfs2(0,1,0);\n  \n  if(!f){\n    //cout << \"!\" << endl;\n    REP(i,s1.size()){\n      if(s1[i] >= '0' && s1[i] <= '9'){\n\tint u = i;\n\twhile(s1[u] != ']'){\n\t  \n\t  u++;\n\t}\n\treverse(s1.begin()+i,s1.begin()+u);\n\ti = u-1;\n      }\n      else if(s1[i] == '(')\n\ts1[i] = ')';\n      else if(s1[i] == ')')\n\ts1[i] = '(';\n      else if(s1[i] == '[')\n\ts1[i] = ']';\n      else if(s1[i] == ']')\n\ts1[i] = '[';\n    }\n    //cout << s1 << endl;\n    reverse(s1.begin(),s1.end());\n    //cout << s1 << endl;\n    REP(i,s2.size()){\n      if(s2[i] >= '0' && s2[i] <= '9'){\n\tint u = i;\n\twhile(s2[u] != ']'){\n\t  \n\t  u++;\n\t}\n\treverse(s2.begin()+i,s2.begin()+u);\n\ti = u-1;\n      }\n      else if(s2[i] == '(')\n\ts2[i] = ')';\n      else if(s2[i] == ')')\n\ts2[i] = '(';\n      else if(s2[i] == '[')\n\ts2[i] = ']';\n      else if(s2[i] == ']')\n\ts2[i] = '[';\n    }\n    reverse(s2.begin(),s2.end());\n    p1.clear();\n    p2.clear();\n    dfs(0,1,0);\n    dfs2(0,1,0);\n    //cout << s2 << endl;\n  }\n  sort(p1.begin(),p1.end());\n  sort(p2.begin(),p2.end());\n  /*\n  REP(i,p1.size()){\n     cout << p1[i].first.first << \"  \" << p1[i].first.second << \"  \" << p1[i].second << endl;\n  }\n   REP(i,p2.size()){\n     cout << p2[i].first.first << \"  \" << p2[i].first.second << \"  \" << p2[i].second << endl;\n     }*/\n   int x = 0;\n   REP(i,p1.size()){\n    rep(j,x,p2.size()){\n      if(p1[i].first == p2[j].first){\n\tp3.pb(mk(p1[i].first , p1[i].second + p2[j].second));\n\tx = j;\n\tbreak;\n      }\n      else if(p1[i].first < p2[j].first){\n\tx = j;\n\tbreak;\n      }\n    }\n   }\n   /*\n   REP(i,p3.size()){\n     cout << p3[i].first.first << \"  \" << p3[i].first.second << \"  \" << p3[i].second << endl;\n     }*/\n   pair <ll,ll> p;\n   p.first = 0;\n   p.second = 1;\n   /*\n   string t = dfs3(p);\n   string e = \"(()[6]())[8](((()[4]())[7]())[9]())\";\n   REP(i,t.size()){\n     if(t[i] != e[i]){\n       cout << i << endl;\n     }\n     }*/\n   string s3 = dfs3(p);\n   if(!f){\n     REP(i,s3.size()){\n      if(s3[i] >= '0' && s3[i] <= '9'){\n\tint u = i;\n\twhile(s3[u] != ']'){\n\t  \n\t  u++;\n\t}\n\treverse(s3.begin()+i,s3.begin()+u);\n\ti = u-1;\n      }\n      else if(s3[i] == '(')\n\ts3[i] = ')';\n      else if(s3[i] == ')')\n\ts3[i] = '(';\n      else if(s3[i] == '[')\n\ts3[i] = ']';\n      else if(s3[i] == ']')\n\ts3[i] = '[';\n    }\n     reverse(s3.begin(),s3.end());\n   }\n   cout << s3 << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1005,INF=1<<30;\nint lef[MAX][2],righ[MAX][2],score[MAX][2];\nint root[2],siz[2];\nint tu=0;\n\nint expr(string S,int &i,int &id);\nint number(string S,int &i,int &id);\n\nint expr(string S,int &i,int &id){\n    int lech=-1,rich=-1,par=-1,sco=-1;\n    if(i==S.size()) return par;\n    if(S[i]==')') return par;\n    \n    i++;\n    lech=expr(S,i,id);\n    i++;\n    i++;\n    sco=number(S,i,id);\n    par=id;\n    i++;\n    i++;\n    id++;\n    rich=expr(S,i,id);\n    i++;\n    \n    if(par>=0){\n        lef[par][tu]=lech;\n        righ[par][tu]=rich;\n        score[par][tu]=sco;\n    }\n    \n    return par;\n}\n\nint number(string S,int &i,int &id){\n    int res=0;\n    while('0'<=S[i]&&S[i]<='9'){\n        res*=10;\n        res+=(S[i]-'0');\n        i++;\n    }\n    return res;\n};\n\nstring DFS(int nowa,int nowb){\n    string res=\"\";\n    \n    res+='(';\n    \n    if(lef[nowa][0]>=0&&lef[nowb][1]>=0){\n        res+=DFS(lef[nowa][0],lef[nowb][1]);\n    }\n    \n    res+=')';\n    \n    res+='[';\n    \n    res+=to_string(score[nowa][0]+score[nowb][1]);\n    \n    res+=']';\n    \n    res+='(';\n    \n    if(righ[nowa][0]>=0&&righ[nowb][1]>=0){\n        res+=DFS(righ[nowa][0],righ[nowb][1]);\n    }\n    \n    res+=')';\n    \n    return res;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    string A,B;\n    cin>>A>>B;\n    memset(lef,-1,sizeof(lef));\n    memset(righ,-1,sizeof(righ));\n    memset(score,-1,sizeof(score));\n    int i=0,id=0;\n    expr(A,i,id);\n    siz[0]=id;\n    \n    i=0;id=0;\n    tu=1;\n    expr(B,i,id);\n    siz[1]=id;\n    \n    for(int j=0;j<2;j++){\n        set<int> SE;\n        for(int i=0;i<siz[j];i++) SE.insert(i);\n        \n        for(int i=0;i<siz[j];i++){\n            SE.erase(lef[i][j]);\n            SE.erase(righ[i][j]);\n        }\n        \n        root[j]=*(SE.begin());\n    }\n    \n    cout<<DFS(root[0],root[1])<<endl;\n    \n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nvoid solve(string s, int par, vector<int>& vec) {\n\tint cnt = 0;\n\tint l = 1, r = 0;\n\tfor (int i = 1; i < s.size() - 1; i++) {\n\t\tif (s[i] == '(')cnt++;\n\t\telse if (s[i] == ')')cnt--;\n\n\t\tif (cnt == 0) {\n\t\t\tr = i;\n\t\t\tstring next = s.substr(l, r - l + 1);\n\n\t\t\tif (l == 1) {\n\t\t\t\tsolve(next, par * 2 + 1, vec);\n\n\t\t\t\ti += 2;\n\n\t\t\t\tint l2 = i;\n\t\t\t\twhile (1) {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (s[i] == ']') {\n\t\t\t\t\t\tvec[par] = stoi(s.substr(l2, i - l2).data());\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tl = r = i;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsolve(next, par * 2 + 2, vec);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstring solve2(vector<int>&ans, int par) {\n\tstring s1, s2, s3;\n\n\tif (ans[par] != -1) {\n\t\ts2 = to_string(ans[par]);\n\t}\n\telse return \"\";\n\n\ts1 = solve2(ans, par * 2 + 1);\n\ts3 = solve2(ans, par * 2 + 2);\n\n\treturn \"(\" + s1 + \")\" + \"[\" + s2 + \"]\" + \"(\" + s3 + \")\";\n}\n\nint main()\n{\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tvector<int>a(100,-1), b(100,-1);\n\n\ts1.insert(s1.begin(), '(');\n\ts1.push_back(')');\n\ts2.insert(s2.begin(), '(');\n\ts2.push_back(')');\n\n\tsolve(s1, 0, a);\n\tsolve(s2, 0, b);\n\n\tvector<int>c(100, -1);\n\tfor (int i = 0; i < 100; i++) {\n\t\tif (a[i] != -1 && b[i] != -1) {\n\t\t\tc[i] = a[i] + b[i];\n\t\t}\n\t}\n\n\tcout << solve2(c, 0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cstddef>\n#include <memory>\n\nusing namespace std;\n\nclass Node\n{\npublic:\n    shared_ptr<Node> left;\n    shared_ptr<Node> right;\n    int  value;\n    Node()\n    {\n        left  = nullptr;\n        right = nullptr;\n        value = 0;\n    }\n};\n\nusing node_ptr = shared_ptr<Node>;\n\nvector<Node> Aar;\nvector<Node> Bar;\n\n\nvoid input(vector<Node> & ar,const string & str,int & i,node_ptr & ptr)\n{\n    if(str[i]==')')\n    {\n        ++i;\n        return;\n    }\n\n    ptr = make_shared<Node>();\n\n\n    if(str[i]=='(')\n    {\n        ++i;\n        input(ar,str,i,ptr->left);\n    }\n    if(str[i]=='[')\n    {\n        ++i;\n        while(str[i]!=']')\n        {\n            ptr->value*=10;\n            ptr->value+=(int)(str[i]-'0');\n            ++i;\n        }\n        ++i;\n    }\n    if(str[i]=='(')\n    {\n        ++i;\n        input(ar,str,i,ptr->right);\n    }\n    if(str[i]==')')\n    {\n        ++i;\n        return;\n    }\n}\n\nvoid output(node_ptr a, node_ptr b)\n{\n    if(a==nullptr || b==nullptr) return;\n\n    cout << \"(\" << flush;\n    output(a->left,b->left);\n    cout << \")\" << flush;\n\n    cout << \"[\" <<a->value + b->value << \"]\" << flush;\n\n    cout << \"(\" << flush;\n    output(a->right,b->right);\n    cout << \")\" << flush;\n}\n\nint main()\n{\n    string A,B;\n    cin >> A >> B;\n\n    int si=0;\n    node_ptr Aptr;\n    input(Aar,A,si,Aptr);\n\n    si = 0;\n    node_ptr Bptr;\n    input(Bar,B,si,Bptr);\n\n    output(Aptr,Bptr);\n\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cstddef>\n#include <memory>\n\nusing namespace std;\n\nclass Node\n{\npublic:\n    shared_ptr<Node> left;\n    shared_ptr<Node> right;\n    int  value;\n    Node()\n    {\n        left  = nullptr;\n        right = nullptr;\n        value = 0;\n    }\n};\n\nusing node_ptr = shared_ptr<Node>;\n\nvector<Node> Aar;\nvector<Node> Bar;\n\n\nvoid input(vector<Node> & ar,const string & str,int & i,node_ptr & ptr)\n{\n    if(str[i]==')')\n    {\n        ++i;\n        return;\n    }\n\n    ptr = make_shared<Node>();\n\n\n    if(str[i]=='(')\n    {\n        ++i;\n        input(ar,str,i,ptr->left);\n    }\n    if(str[i]=='[')\n    {\n        ++i;\n        while(str[i]!=']')\n        {\n            ptr->value*=10;\n            ptr->value+=(int)(str[i]-'0');\n            ++i;\n        }\n        ++i;\n    }\n    if(str[i]=='(')\n    {\n        ++i;\n        input(ar,str,i,ptr->right);\n    }\n    if(str[i]==')')\n    {\n        ++i;\n        return;\n    }\n}\n\nvoid output(node_ptr a, node_ptr b)\n{\n    if(a==nullptr || b==nullptr) return;\n\n    cout << \"(\" << flush;\n    output(a->left,b->left);\n    cout << \")\" << flush;\n\n    cout << \"[\" <<a->value + b->value << \"]\" << flush;\n\n    cout << \"(\" << flush;\n    output(a->right,b->right);\n    cout << \")\" << flush;\n}\n\nint main()\n{\n    string A,B;\n    cin >> A >> B;\n\n    int si=0;\n    node_ptr Aptr;\n    input(Aar,A,si,Aptr);\n\n    si = 0;\n    node_ptr Bptr;\n    input(Bar,B,si,Bptr);\n\n    output(Aptr,Bptr);\n\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct node_t {\n    node_t *child[2];\n    int val;\n};\n\nstring::iterator state;\nbool consume(char c) {\n    if(*state != c) return false;\n    ++state;\n    return true;\n}\n\nnode_t *parse() {\n    node_t *ret = new node_t();\n    assert(consume('('));\n    if(consume(')')) {\n        ret->child[0] = nullptr;\n    } else {\n        ret->child[0] = parse();\n        assert(consume(')'));\n    }\n\n    assert(consume('['));\n    while(isdigit(*state)) {\n        ret->val *= 10;\n        ret->val += *state - '0';\n        ++state;\n    }\n    assert(consume(']'));\n    \n    assert(consume('('));\n    if(consume(')')) {\n        ret->child[1] = nullptr;\n    } else {\n        ret->child[1] = parse();\n        assert(consume(')'));\n    }\n\n    return ret;\n}\n\nnode_t *merge(node_t *a, node_t *b) {\n    node_t *ret = new node_t;\n    if(a == nullptr || b == nullptr) {\n        ret = nullptr;\n    } else {\n        ret->val = a->val + b->val;\n        ret->child[0] = merge(a->child[0], b->child[0]);\n        ret->child[1] = merge(a->child[1], b->child[1]);\n    }\n    return ret;\n}\n\nvoid print(node_t *m) {\n    if(m == nullptr) return;\n\n    cout << '(';\n    print(m->child[0]);\n    cout << ')';\n\n    cout << '[' << m->val << ']';\n\n    cout << '(';\n    print(m->child[1]);\n    cout << ')';\n}\n\nint main() {\n    string A, B; cin >> A >> B;\n\n    state = begin(A);\n    node_t *a = parse();\n    state = begin(B);\n    node_t *b = parse();\n\n    node_t *m = merge(a, b);\n    print(m); cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin >= End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin;Begin!=End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      if (rb > End) {\n        rb = End;\n      }\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin(), be = b.end();\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\ttree t;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\ttree t;\n\tvt3.push_back(t);\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tif (vt.size() < no)\n\t\treturn \"\";\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\t//cout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin == End || Begin + 1 == End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin; Begin != End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end() - 1, bb = b.begin(), be = b.end() - 1;\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for (int i = (int)(s); i < (int)(n); i++)\nconst ll mod = ll(1e9) + 7;\nconst int INF = int(1e9);\n\nint idxa = 0, idxb = 0;\n\nint calc(string &A, string &B)\n{\n    string tmpa, tmpb;\n    idxa++;\n    idxb++;\n    while (A[idxa] != ']')\n    {\n        tmpa.push_back(A[idxa++]);\n    }\n    while (B[idxb] != ']')\n    {\n        tmpb.push_back(B[idxb++]);\n    }\n    //cout << tmpa << \" \" << tmpb << endl;\n    return stoi(tmpa) + stoi(tmpb);\n}\nint proceed(int idx, string &C)\n{\n    int cnt = 1;\n    while (1)\n    {\n        idx++;\n        if (C[idx] == ')')\n            cnt--;\n        if (C[idx] == '(')\n            cnt++;\n        if (cnt < 0)\n            break;\n    }\n    return idx;\n}\n\nint main()\n{\n    string A, B;\n    cin >> A >> B;\n    string ans;\n    while (idxa < A.size())\n    {\n        if (A[idxa] == B[idxb])\n        {\n            if (A[idxa] == '[')\n            {\n                ans.push_back('[');\n                int tmp = calc(A, B);\n                ans += to_string(tmp);\n                ans.push_back(']');\n            }\n            else\n                ans.push_back(A[idxa]);\n        }\n        else\n        {\n            if (A[idxa] == '(')\n                idxa = proceed(idxa, A);\n            else\n            {\n                idxb = proceed(idxb, B);\n            }\n            ans.push_back(A[idxa]);\n        }\n        idxa++;\n        idxb++;\n        //cout << ans << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for (int i = (int)(s); i < (int)(n); i++)\nconst ll mod = ll(1e9) + 7;\nconst int INF = int(1e9);\n\nint idxa = 0, idxb = 0;\n\nint calc(string &A, string &B)\n{\n    string tmpa, tmpb;\n    idxa++;\n    idxb++;\n    while (A[idxa] != ']')\n    {\n        tmpa.push_back(A[idxa++]);\n    }\n    while (B[idxb] != ']')\n    {\n        tmpb.push_back(B[idxb++]);\n    }\n    //cout << tmpa << \" \" << tmpb << endl;\n    return stoi(tmpa) + stoi(tmpb);\n}\nint proceed(int idx, string &C)\n{\n    int cnt = 1;\n    while (1)\n    {\n        idx++;\n        if (C[idx] == ')')\n            cnt--;\n        if (C[idx] == '(')\n            cnt++;\n        if (cnt < 0)\n            break;\n    }\n    return idx;\n}\n\nint main()\n{\n    string A, B;\n    cin >> A >> B;\n    string ans;\n    while (idxa < A.size())\n    {\n        if (A[idxa] == B[idxb])\n        {\n            if (A[idxa] == '[')\n            {\n                ans.push_back('[');\n                int tmp = calc(A, B);\n                ans += to_string(tmp);\n                ans.push_back(']');\n            }\n            else\n                ans.push_back(A[idxa]);\n        }\n        else\n        {\n            if (A[idxa] == '(')\n                idxa = proceed(idxa, A);\n            else\n            {\n                idxb = proceed(idxb, B);\n            }\n            ans.push_back(A[idxa]);\n        }\n        idxa++;\n        idxb++;\n        //cout << ans << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct data{int num,l,r;};\nvector<data> At,Bt;\n \nbool check(int s,int t, string &str){\n  stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')'&&st.empty())return 0;  \n    if(str[i]==')') st.pop();\n  }\n  return st.empty();\n}\n \nint get_num(string &str,int &idx){\n  int res=0;\n  while(isdigit(str[idx]))res=res*10+str[idx++]-'0';\n  return res;\n}\n \n \nint get_root(int s,int t,string &str){\n  stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(st.empty()&&isdigit(str[i])) return i;\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')') st.pop();\n  }\n  assert(0);\n}\n \n \nvoid make_tree(int s,int t,vector<data>&tree,string &str,int idx){\n    while(s<t&&check(s,t,str)) s++,t--;\n  if(s>=t)return;\n  s--,t++;\n \n  int root=get_root(s,t,str);\n  tree.push_back((data){-1,-1,-1});\n  tree[idx].l=tree.size()-1;\n  make_tree(s,root-2,tree,str,tree.size()-1);\n \n  tree[idx].num=get_num(str,root);\n \n  tree.push_back((data){-1,-1,-1});\n  tree[idx].r=tree.size()-1;\n  make_tree(root+1,t,tree,str,tree.size()-1);\n}\n \nstring make_str(int a,int b){\n  if(a==-1||b==-1||At[a].num<0||Bt[b].num<0) return \"\";\n  int num=At[a].num+Bt[b].num;\n  string str;\n  if(num==0)str=\"0\";\n  while(num) str=(char)((num%10)+'0')+str,num/=10;\n \n  return \"(\"+make_str(At[a].l,Bt[b].l)+\")\"+\"[\"+str+\"]\"+\"(\"+make_str(At[a].r,Bt[b].r)+\")\";\n \n}\nint main(){\n  string A,B;\n  cin>>A>>B;\n  At.push_back((data){-1,-1,-1});\n  Bt.push_back((data){-1,-1,-1});\n  make_tree(0,A.size()-1,At,A,0);\n  make_tree(0,B.size()-1,Bt,B,0);\n  cout <<make_str(0,0)<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Tree{\n  int num;\n  Tree* lhs;\n  Tree* rhs;\n};\n\nint get_val(string& s,int& i){\n  int res=0;\n  while(isdigit(s[i])){\n    res*=10;\n    res+=s[i]-'0';\n    i++;\n  }\n  return res;\n}\n\nTree* build_tree(string&s ,int &i){\n\n  assert(0<=i && i<s.size());\n  if(s[i]==')'){\n    return nullptr;\n  }\n  i++;\n  Tree* lef=build_tree(s,i);\n  assert(s[i]==')');\n  i++;\n  assert(s[i]=='[');\n  i++;\n  int val=get_val(s,i);\n\n  assert(s[i]==']');\n  i++;//]\n  assert(s[i]=='(');\n  i++;//(\n  Tree* rig=build_tree(s,i);\n  assert(s[i]==')');\n  i++;\n  Tree* res=new Tree();\n\n  res->num=val;\n\n  res->lhs=lef;\n  res->rhs=rig;\n  return res;\n}\n\nTree* sum(Tree* a_tree,Tree* b_tree){\n  if(a_tree==nullptr||b_tree==nullptr){\n    return nullptr;\n  }\n\n  Tree* res=new Tree();\n  res->num=(a_tree->num)+(b_tree->num);\n  res->lhs=sum(a_tree->lhs,b_tree->lhs);\n  res->rhs=sum(a_tree->rhs,b_tree->rhs);\n  return res;\n}\n\nstring code(Tree* tree){\n  if(tree==nullptr){\n    return \"\";\n  }\n  string res=\"(\";\n  res+=code(tree->lhs);\n  res+=\")\";\n  res+=\"[\";\n  res+=to_string((tree->num));\n  res+=\"]\";\n  res+=\"(\";\n  res+=code(tree->rhs);\n  res+=\")\";\n  return res;\n}\n\nint main(){\n  string a,b;\n  cin>>a>>b;\n  int i=0;\n  Tree* a_tree=build_tree(a,i);\n  i=0;\n  Tree* b_tree=build_tree(b,i);\n  Tree* c_tree=sum(a_tree,b_tree);\n  string res=code(c_tree);\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct node_t{\n    node_t *children[2];\n    int value;\n};\n\nstring::iterator state;\nbool consume(char c){\n    if(*state != c) return false;\n    ++state;\n    return true;\n}\nnode_t *node(){\n    node_t *ret = new node_t();\n    assert(consume('('));\n    if(consume(')')) ret->children[0] = nullptr;\n    else{\n        ret->children[0] = node();\n        assert(consume(')'));\n    }\n    assert(consume('['));\n    ret->value = 0;\n    while(isdigit(*state)){\n        ret->value *= 10;\n        ret->value += *state - '0';\n        ++state;\n    }\n    assert(consume(']'));\n    assert(consume('('));\n    if(consume(')')) ret->children[1] = nullptr;\n    else{\n        ret->children[1] = node();\n        assert(consume(')'));\n    }\n    return ret;\n}\n\nnode_t *merge(node_t *lhs, node_t *rhs){\n    if(lhs == nullptr || rhs == nullptr) return nullptr;\n    node_t *ret = new node_t();\n    ret->value = lhs->value + rhs->value;\n    ret->children[0] = merge(lhs->children[0], rhs->children[0]);\n    ret->children[1] = merge(lhs->children[1], rhs->children[1]);\n    return ret;\n}\n\nvoid print(node_t *n){\n    printf(\"(\");\n    if(n->children[0]) print(n->children[0]);\n    printf(\")[%d](\", n->value);\n    if(n->children[1]) print(n->children[1]);\n    printf(\")\");\n}\n\nint main(){\n    string a, b;\n    cin >> a >> b;\n    state = a.begin();\n    auto na = node();\n    assert(state == a.end());\n    state = b.begin();\n    auto nb = node();\n    assert(state == b.end());\n\n    print(merge(na, nb));\n    printf(\"\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r, int& idx){\n\tif(r - l == 0) return -1;\n\n\tint cur = idx;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tidx++;\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1, idx);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tidx++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1, idx);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x(10000), y(10000);\n\tint idx = 0;\n\tdfs(x, a, 0, a.size(), idx);\n\tidx = 0;\n\tdfs(y, b, 0, b.size(), idx);\n\n\n\tstring ans = merge(x,0,y,0);\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct no{\n  long int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nint n;\nstring s1[2];\nvector<long int>v[2];\nvoid v_make(int t){\n  v[t].push_back('(');\n  for(int i=0;i<s1[t].size();i++){\n    if(!isdigit(s1[t][i]))v[t].push_back(s1[t][i]);\n    else{\n      int p=s1[t][i]-'0';\n      while(isdigit(s1[t][i+1]))p*=10,p+=s1[t][++i]-'0';\n      v[t].push_back(p+100);\n    }\n  }\n  v[t].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1;\n  for(int i=l+1;i<r;i++)\n    if((char)v[n][i]=='(')p++;\n    else if((char)v[n][i]==')')p--;\n    else if(v[n][i]>=100&&!p){\n      c=i;\n      po->key=v[n][i]-100;\n      break;\n    }\n  if(l+1!=c)po->left=con(l+1,c-1);\n  if(r-1!=c)po->right=con(c+1,r-1);\n  return po;\n}\nstring make_num(long int p){\n  string t;\n  while(p){\n    t+=p%10+'0';\n    p/=10;\n  }\n  reverse(t.begin(),t.end());\n  return t;\n}\nstring init(node a,node b){\n  string l,r,x=make_num(a->key+b->key);\n  if(a->left!=NULL&&b->left!=NULL)\n    l=init(a->left,b->left);\n  if(a->right!=NULL&&b->right!=NULL)\n    r=init(a->right,b->right);\n  return \"(\"+l+\")[\"+x+\"](\"+r+\")\";\n}\nint main(){\n  cin>>s1[0]>>s1[1];\n  for(int j=0;j<2;j++)\n    for(int i=0;i<(int)s1[j].size()-1;i++)\n      if(s1[j][i]=='('&&s1[j][i+1]==')')s1[j].erase(s1[j].begin()+i),s1[j].erase(s1[j].begin()+i);\n  for(int j=0;j<2;j++)\n    for(int i=0;i<(int)s1[j].size()-1;i++)\n      if(s1[j][i]=='['||s1[j][i]==']')s1[j].erase(s1[j].begin()+i);\n  v_make(0);v_make(1);\n  n=0;node a=con(0,v[n].size()-1);\n  n=1;node b=con(0,v[n].size()-1);\n  cout<<init(a,b)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2);\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;\n  for(int i=l+1;i<r;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }if(p){cout<<1;exit(0);}\n  po->key=o;\n  if(l+1!=c){\n    //if(c-1>l+1)\n    po->left=con(l+1,c-1);\n  }\n  if(r-1!=c){\n   // if(r-1>c+1)\n    po->right=con(c+1,r-1);\n  }\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size()-1);\n  n=1;node p2=con(0,a[1].size()-1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring s1,s2;ll kasai[10000],isao[10000],jcreation[10000];\nbool visited[10000],visited2[10000];\n\nvoid dfs(int now,int cnt){\n  visited[cnt]=true;\n  if(now==s1.size()){\n    return;\n  }\n  if(s1[now]=='('){\n    if(visited[cnt*2+1])\n      dfs(now+1,(cnt*2)+2);\n    else\n      dfs(now+1,(cnt*2)+1);\n  }else if(s1[now]==')'){\n    dfs(now+1,(cnt-1)/2);\n  }else{\n    now++;\n    ll num=0;\n    while(s1[now]>='0'&&s1[now]<='9'){\n      num*=10;\n      num+=s1[now]-'0';\n      now++;\n    }\n    kasai[cnt]=num;\n    dfs(now+1,cnt);\n  }\n}\nvoid dfs2(int now,int cnt){\n  visited2[cnt]=true;\n  if(now==s2.size()){\n    return;\n  }\n  if(s2[now]=='('){\n    if(visited2[cnt*2+1])\n      dfs2(now+1,(cnt*2)+2);\n    else\n      dfs2(now+1,(cnt*2)+1);\n  }else if(s2[now]==')'){\n    dfs2(now+1,(cnt-1)/2);\n  }else{\n    now++;\n    ll num=0;\n    while(s2[now]>='0'&&s2[now]<='9'){\n      num*=10;\n      num+=s2[now]-'0';\n      now++;\n    }\n    isao[cnt]=num;\n    dfs2(now+1,cnt);\n  }\n}\nstring Stoi(int num){\n  string s=\"\";\n  while(num>0){\n    s+=(char)((num%10)+'0');\n    num/=10;\n  }\n  reverse(s.begin(),s.end());\n  return s;\n}\nstring dfs3(int now){\n  string ret=\"\";\n  if(jcreation[now]==-1)return ret;\n  ret=\"(\"+dfs3(2*now+1)+\")[\"+Stoi(jcreation[now])+\"](\"+dfs3(2*now+2)+\")\";\n  return ret;\n}\nint main(){\n  for(int i=0;i<10000;i++){\n    kasai[i]=-1;\n    isao[i]=-1;\n    jcreation[i]=-1;\n  }\n  cin>>s1>>s2;\n  dfs(0,0);\n  dfs2(0,0);\n  for(int i=0;i<10000;i++){\n    // cout<<i<<\" \"<<kasai[i]<<\" \"<<isao[i]<<endl;\n    if(isao[i]>=0&&kasai[i]>=0){\n      (jcreation[i]=isao[i]+kasai[i]);\n    }\n  }\n  cout<<dfs3(0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef string::const_iterator State;\n\nstruct node{\n    int item;\n    struct node *left;\n    struct node *right;\n};\n\nnode *make_node(){\n    node *d = new node;\n    d -> left = NULL;\n    d -> right = NULL;\n    return d;\n}\n\nint number(State &begin){\n    int ret = 0;\n    while (isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nnode *read(State &begin){\n    node *d = make_node();\n    begin++;\n    if (*begin != ')'){\n        d -> left = read(begin);\n    }\n    begin += 2;\n    d -> item = number(begin);\n    begin += 2;\n    if (*begin != ')'){\n        d -> right = read(begin);\n    }\n    begin++;\n    return d;\n}\n\nvoid out(node *d1, node *d2){\n    cout << \"(\";\n    if (d1 -> left != NULL && d2 -> left != NULL) out(d1 -> left, d2 -> left);\n    printf(\")[%d](\", d1 -> item + d2 -> item);\n    if (d1 -> right != NULL && d2 -> right != NULL) out(d1 -> right, d2 -> right);\n    cout << \")\";\n}\n\nint main() {\n    string s1, s2;\n    cin >> s1 >> s2;\n    node *r1, *r2;\n    State begin = s1.begin();\n    r1 = read(begin);\n    begin = s2.begin();\n    r2 = read(begin);\n\n    out(r1, r2);\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define llint long long\n\nusing namespace std;\ntypedef pair<llint, llint> P;\ntypedef pair<double, P> E;\n\nstruct Node{\n\tllint left, right, val;\n\tNode(){\n\t\tleft = -1, right = -1, val = 0;\n\t}\n};\n\nstring s, t;\nvector<Node> S, T, U;\n\nllint p;\n\nllint num(string &s, llint n)\n{\n\tllint ret = 0;\n\twhile(1){\n\t\tif(s[p] < '0' || s[p] > '9') break;\n\t\tret *= 10, ret += s[p]-'0';\n\t\tp++;\n\t}\n\treturn ret;\n}\n\nllint dec(string &s, vector<Node> &vec, llint &p)\n{\n\tif(s[p] != '(') return -1;\n\t\n\tvec.push_back(Node());\n\tllint root = (int)vec.size()-1;\n\t\n\tp++;\n\tllint l = dec(s, vec, p);\n\tp++;\n\t\n\tp++;\n\tllint res = num(s, p);\n\tp++;\n\tvec[root].val = res;\n\t\n\tp++;\n\tllint r = dec(s, vec, p);\n\tp++;\n\t\n\tvec[root].left = l, vec[root].right = r;\n\t\n\treturn root;\n}\n\nllint calc(llint u, llint v)\n{\n\tU.push_back(Node());\n\tllint root = (int)U.size()-1;\n\tU[root].val = S[u].val + T[v].val;\n\t\n\tif(S[u].left != -1 && T[v].left != -1){\n\t\tllint res = calc(S[u].left, T[v].left);\n\t\tU[root].left = res;\n\t}\n\tif(S[u].right != -1 && T[v].right != -1){\n\t\tllint res = calc(S[u].right, T[v].right);\n\t\tU[root].right = res;\n\t}\n\treturn root;\n}\n\nvoid enc(int v)\n{\n\tif(v == -1) return;\n\t\n\tcout << \"(\";\n\tenc(U[v].left);\n\tcout << \")\";\n\t\n\tcout << \"[\";\n\tcout << U[v].val;\n\tcout << \"]\";\n\t\n\tcout << \"(\";\n\tenc(U[v].right);\n\tcout << \")\";\n}\n\nint main(void)\n{\n\tcin >> s >> t;\n\ts += \"#\", t += \"#\";\n\t\n\tp = 0;\n\tllint rootS = dec(s, S, p);\n\t\n\tp = 0;\n\tllint rootT = dec(t, T, p);\n\t\n\tllint rootU = calc(rootS, rootT);\n\t\n\tenc(rootU);\n\tcout << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nstruct Tree {\n    Tree *l, *r;\n    int v;    \n};\n \nTree *tree[2], *ntree;\n \nTree* make_node(int v)\n{\n    Tree *t = new Tree;\n    t->l = t->r = NULL;\n    t->v = v;\n    return t;\n}\n \nvoid init(int ra, int rb)\n{    \n    tree[0] = make_node(ra);\n    tree[1] = make_node(rb);\n    ntree = make_node(-1);\n}\n \nint get_num(string &s, int L, int R)\n{\n    L++; R--;\n    string str;\n    for (int i = L; i <= R; i++) {\n        str += s[i];\n    }\n    stringstream ss(str);\n    int num;\n    ss >> num;\n    return num;\n}\n \nint get_node_left(int &L, int &R, string &s)\n{\n    int p = 0;\n    for (int i = R; i >= L; i--) {\n        if (s[i] == ')') {\n            p++;\n        } else if (s[i] == '(') {\n            p--;\n        }\n        if (p == 0) {\n            if (i - 1 >= 0 && s[i-1] == ']') {\n                int l = -1;\n                for (int j = i-1; j >= L; j--) {\n                    if (s[j] == '[') {\n                        l = j;\n                        break;\n                    }\n                }\n                L = l-1; R = i;\n                return get_num(s, l, i-1);\n            }\n            return -1;\n        }\n    }\n    return -1;\n}\n \nint get_node_right(int &L, int &R, string &s)\n{\n    int p = 0;\n    for (int i = L; i <= R; i++) {\n        if (s[i] == '(') {\n            p++;\n        } else if (s[i] == ')') {\n            p--;\n        }\n        if (p == 0) {\n            if (i + 1 <= R && s[i+1] == '[') {\n                int r = -1;\n                for (int j = i+1; j <= R; j++) {\n                    if (s[j] == ']') {\n                        r = j;\n                        break;\n                    }\n                }\n                L = i; R = r+1;\n                return get_num(s, i+1, r);\n            }\n            return -1;\n        }\n    }    \n    return -1;\n}\n \nvoid add_left(int v, Tree *t)\n{\n    t->l = make_node(v);\n}\n \nvoid add_right(int v, Tree *t)\n{\n    t->r = make_node(v);\n}\n \nvoid dfs(int L, int R, string &s, Tree *t)\n{\n    int l = 0, r = s.size()-1;\n    L = L - 1; R = R + 1;\n    int vl = get_node_left(l, L, s);\n    int vr = get_node_right(R, r, s);\n    if (vl != -1) {\n        add_left(vl, t);\n        dfs(l, L, s, t->l);        \n    }\n    if (vr != -1) {\n        add_right(vr, t);\n        dfs(R, r, s, t->r);\n    }\n}\n \nvoid make_sum_tree(Tree *t1, Tree *t2, Tree *t3)\n{\n    if (t1 != NULL && t2 != NULL) {\n        t3->v = t1->v + t2->v;\n        if (t1->l != NULL && t2->l != NULL) {\n            t3->l = make_node(-1);\n            make_sum_tree(t1->l, t2->l, t3->l);\n        }\n        if (t1->r != NULL && t2->r != NULL) {\n            t3->r = make_node(-1);\n            make_sum_tree(t1->r, t2->r, t3->r);\n        }\n    }\n}\n \nstring i2s(int v)\n{\n    stringstream ss;\n    ss << v;\n    string s;\n    ss >> s;\n    return s;\n}\n \nstring make_tree(Tree *t)\n{\n    string res, l = \"()\", r = \"()\";\n    if (t != NULL) {\n        res = \"[\" + i2s(t->v) + \"]\";\n    }\n    if (t->l != NULL) {\n        l = \"(\" + make_tree(t->l) + \")\";\n    } \n        \n    if (t->r != NULL) {\n        r = \"(\" + make_tree(t->r) + \")\";\n    }\n    return l + res + r;\n}\n \nvoid solve(string &a, string &b)\n{\n    int La = 0, Lb = 0;\n    int Ra = a.size()-1, Rb = b.size()-1;\n    int root_a = get_node_left(La, Ra, a);\n    int root_b = get_node_left(Lb, Rb, b);\n    init(root_a, root_b);\n    dfs(La, Ra, a, tree[0]);\n    dfs(Lb, Rb, b, tree[1]);    \n    make_sum_tree(tree[0], tree[1], ntree);\n    cout << make_tree(ntree) << endl;\n}\n \nint main()\n{\n    string a, b;\n    cin >> a >> b;\n    solve(a, b);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << \"}\" << endl;\n}\n\nclass node{\n\tpublic:\n\t\tint val;\n\t\tvector<node> l, r;\n\t\tstring to_s(){\n\t\t\tstring sl = \"\", sr = \"\";\n\t\t\tif(l.size() != 0) sl = l[0].to_s();\n\t\t\tif(r.size() != 0) sr = r[0].to_s();\n\t\t\treturn \"(\" + sl + \")[\" + to_string(val) + \"](\" + sr + \")\";\n\t\t}\n};\n\nint to_i(int &pos, string &s){// str[pos-1] = '['\n\tint n = 0;\n\twhile(s[pos] != ']'){\n\t\tn = n * 10 + s[pos] - '0';\n\t\tpos++;\n\t}\n\treturn n; //str[pos] = ']'\n}\n\nnode eval(int &pos, string &s){// str[pos] = '('\n\tpos++;\n\tnode n;\n\tif(s[pos] != ')'){\n\t\tn.l.pb(eval(pos, s));\n\t}\n\tpos+=2;\n\tint v = to_i(pos, s);\n\tn.val = v;\n\tpos+=2;\n\tif(s[pos] != ')'){\n\t\tn.r.pb(eval(pos, s));\n\t}\n\tpos++;\n\treturn n;\n}\n\nnode add(node t1, node t2){\n\tint n = t1.val + t2.val;\n\tnode v;\n\tv.val = n;\n\tif(!t1.l.empty() && !t2.l.empty()) v.l.pb(add(t1.l[0], t2.l[0]));\n\tif(!t1.r.empty() && !t2.r.empty()) v.r.pb(add(t1.r[0], t2.r[0]));\n\treturn v;\n}\n\nint main(){\n\tstring s;\n\tnode a[3];\n\tcin >> s;\n\tint n=0;\n\ta[0] = eval(n, s);\n\tn = 0;\n\tcin >> s;\n\ta[1] = eval(n, s);\n\tn = 0;\n\ta[2] = add(a[0], a[1]);\n\tcout << a[2].to_s() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<long>;\nstruct tree {\n  int node;\n  tree *left;\n  tree *right;\n};\n\nint p;\ntree *parse(string s) {\n  tree *t;\n  t = (tree*)malloc(sizeof(tree));\n  // left\n  assert(s[p] == '(');\n  if (s[p+1] == ')') {\n    p += 2;\n    return NULL;\n  } else {\n    p++;\n    t->left = parse(s);\n  }\n  // center\n  assert(s[p] == '[');\n  p++;\n  int l = 0;\n  while(s[p+l] != ']') {\n    l++;\n  }\n  t->node = stoi(s.substr(p, l));\n  p += l+1;\n  // right\n  assert(s[p] == '(');\n  t->right = parse(s);\n  p++;\n  return t;\n}\n\nstring t_to_str(tree *t) {\n  if (t == NULL) {\n    return \"\";\n  }\n  return \"(\" + t_to_str(t->left) + \")[\" + to_string(t->node) + \"](\" + t_to_str(t->right) + \")\";\n}\n\ntree *get_sum(tree *t1, tree *t2) {\n  tree *t;\n  if (t1 == NULL || t2 == NULL) {\n    return NULL;\n  } else {\n    t = (tree*)malloc(sizeof(tree));\n    t->node = t1->node + t2->node;\n    t->left = get_sum(t1->left, t2->left);\n    t->right = get_sum(t1->right, t2->right);\n    return t;\n  }\n}\n\nint main() {\n  string A, B;\n  cin >> A >> B;\n  if (A != \"()\") {\n    A = \"(\" + A + \")\";\n  }\n  if (B != \"()\") {\n    B = \"(\" + B + \")\";\n  }\n\n  tree *a, *b;\n  p = 0;\n  a = parse(A);\n  p = 0;\n  b = parse(B);\n  cout << t_to_str(get_sum(a, b)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing ll = long long;\nconst char newl = '\\n';\n#define var auto\n\nstring a, b;\n\nvector<int> getCore(int begin, int end, string& str){\n    vector<int> res{};\n    int depth = 0;\n    for (int i = begin; i <= end; i++){\n        if (str[i] == '(') depth++;\n        if (str[i] == ')') depth--;\n        if ((str[i] == '[' || str[i] == ']') && depth == 0) res.push_back(i);\n    }\n    return res;\n}\n\nstring dfs(int abegin, int aend, int bbegin, int bend){\n    var coreAPos = getCore(abegin, aend, a);\n    var coreBPos = getCore(bbegin, bend, b);\n    if (coreAPos.size() == 0 || coreBPos.size() == 0) {\n        return \"\";\n    }\n    var coreA = atoi(a.substr(coreAPos[0] + 1, coreAPos[1] - coreAPos[0] - 1).c_str());\n    var coreB = atoi(b.substr(coreBPos[0] + 1, coreBPos[1] - coreBPos[0] - 1).c_str());\n    var core = coreA + coreB;\n\n    var l = dfs(abegin + 1, coreAPos[0] - 2, bbegin + 1, coreBPos[0] - 2);\n    var r =  dfs(coreAPos[1] + 2, aend - 1, coreBPos[1] + 2, bend - 1);\n    return '(' + l + ')' + '[' + to_string(core) + ']' + '(' + r + ')';\n}\n\n\nsigned main(){\n    cin >> a >> b;\n    cout << dfs(0, a.size() - 1, 0, b.size() - 1) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\npair<int, int> num(const string &s, int i) {\n  int n = 0;\n  while (isdigit(s[i])) {\n    n *= 10;\n    n += s[i] - '0';\n    ++i;\n  }\n  return make_pair(n, i);\n}\n\nint skip(const string &s, int i) {\n  if (s[i] == '(') {\n    i = skip(s, i+1);\n    assert(s[i] == ')');\n    assert(s[i+1] == '[');\n    i = num(s, i+2).second;\n    assert(s[i] == ']');\n    assert(s[i+1] == '(');\n    i = skip(s, i+2);\n    return i+1;\n  } else {\n    return i;\n  }\n}\n\npair<int, int> parse(const string &a, const string &b, int i, int j) {\n  if (a[i] == '(' && b[j] == '(') {\n    cout << '(';\n    tie(i, j) = parse(a, b, i+1, j+1);\n    assert(a[i] == ')');\n    assert(b[j] == ')');\n    cout << ')';\n    assert(a[i+1] == '[');\n    assert(b[j+1] == '[');\n    cout << '[';\n    int n, m;\n    tie(n, i) = num(a, i+2);\n    tie(m, j) = num(b, j+2);\n    cout << (n+m);\n    assert(a[i] == ']');\n    assert(b[j] == ']');\n    cout << ']';\n    assert(a[i+1] == '(');\n    assert(b[j+1] == '(');\n    cout << '(';\n    tie(i, j) = parse(a, b, i+2, j+2);\n    assert(a[i] == ')');\n    assert(b[j] == ')');\n    cout << ')';\n    ++i; ++j;\n  } else {\n    if (a[i] == '(') {\n      i = skip(a, i);\n    } else if (b[j] == '(') {\n      j = skip(b, j);\n    }\n  }\n  return make_pair(i, j);\n}\n\nint main() {\n  string a, b;\n  cin>>a>>b;\n  parse(a, b, 0, 0);\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <functional>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct Node {\n    int value = 0;\n    Node* left = nullptr;\n    Node* right = nullptr;\n    Node(int v, Node* l, Node* r)\n        : value{v}\n        , left{l}\n        , right{r}\n    {\n    }\n};\n\nint main()\n{\n    string a;\n    cin >> a;\n    string b;\n    cin >> b;\n\n    auto parse = [](const string& str) {\n        int i = 0;\n        auto value = [&i, &str]() {\n            assert(str[i] == '[');\n            ++i;\n            auto begin = i;\n            while (static_cast<bool>(isdigit(str[i]))) {\n                ++i;\n            }\n            assert(str[i] == ']');\n            auto end = i - 1;\n            return stoi(str.substr(static_cast<size_t>(begin),\n                                   static_cast<size_t>(end - begin + 1)));\n        };\n\n        function<Node*()> p = [&p, &i, &str, &value]() {\n            if (str[i + 1] == ')') {\n                i += 2;\n                return static_cast<Node*>(nullptr);\n            }\n            assert(str[i] == '(');\n            ++i;\n            auto l = p();\n            auto v = value();\n            ++i;\n            auto r = p();\n            ++i;\n            return new Node{v, l, r};\n        };\n        auto ll = p();\n        auto vv = value();\n        ++i;\n        auto rr = p();\n        return new Node{vv, ll, rr};\n    };\n\n    function<void(Node*)> pp = [&pp](Node* n) {\n        if (n) {\n            cout << \"(\";\n            pp(n->left);\n            cout << \")\";\n            cout << '[' << n->value << ']';\n            cout << \"(\";\n            pp(n->right);\n            cout << \")\";\n        }\n    };\n\n    function<Node*(Node*, Node*)> f = [&f](Node* l, Node* r) {\n        auto ll = l->left && r->left ? f(l->left, r->left) : nullptr;\n        auto rr = l->right && r->right ? f(l->right, r->right) : nullptr;\n        return new Node{l->value + r->value, ll, rr};\n    };\n\n    auto t1 = parse(a);\n    //pp(t1);\n    //cout << endl;\n    auto t2 = parse(b);\n    //pp(t2);\n    //cout << endl;\n    auto r = f(t1, t2);\n    pp(r);\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//木を実装する\ntypedef struct _node{\n    int element;\n    struct _node *left;\n    struct _node *right;\n    struct _node *par;\n}node;\n\ntypedef struct _tree{\n    node *root;\n}tree;\n\n//リストを生成する関数\ntree *create(){\n    tree *T = (tree *)malloc(sizeof(tree));\n    T->root = (node *)malloc(sizeof(node));\n    T->root->left = NULL;\n    T->root->right = NULL;\n    T->root->par = NULL;\n    T->root->element = -1;\n    return T;\n}\n\nvoid make_tree(tree *T, string s){\n    node *ptr = T->root;\n\n    for(int i = 0; i < (int) s.size(); i++){\n\n        if(s[i] == '('){\n            //どっちかににノードを足す\n            node *add = (node *)malloc(sizeof(node));\n            add->element = -1;\n            add->left = NULL;\n            add->right = NULL;\n            add->par = ptr;\n\n            //左\n            if(ptr->left == NULL){\n                ptr->left = add;\n                ptr = add;\n            }else{\n                ptr->right = add;\n                ptr = add;\n            }\n        }else if(s[i] == ')'){\n            //戻る\n            ptr = ptr->par;\n        }else if(s[i] == '['){\n            string str;\n            int j;\n            for(j = i + 1; s[j] != ']'; j++) str.push_back(s[j]);\n            int num = stoi(str);\n            ptr->element = num;\n            i = j;\n        }\n    }\n}\n\nvoid print_tree(node *v){\n    if(v == NULL || v->element == -1){\n        cout << \")\";\n        return;\n    }\n\n    cout << \"(\";\n    print_tree(v->left);\n    cout << \"[\" << v->element << \"]\";\n    cout << \"(\";\n    print_tree(v->right);\n    if(v->par != NULL) cout << \")\";\n    return;\n}\n\nvoid sum_tree(node *v1, node *v2, node *v3){\n    v3->element = v1->element + v2->element;\n\n    if(v1->left != NULL && v2->left != NULL && v1->left->element != -1 && v2->left->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->left = add;\n        sum_tree(v1->left, v2->left, v3->left);\n    }\n    \n    if(v1->right != NULL && v2->right != NULL && v1->right->element != -1 && v2->right->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->right = add;        \n        sum_tree(v1->right, v2->right, v3->right);\n    }\n    \n    //if(v->par != NULL) cout << \")\";\n    return;\n    \n}\n\nint main(){\n\n    string s1, s2; cin >> s1 >> s2;\n    tree *T1 = create();\n    tree *T2 = create();\n    tree *T3 = create();    \n    make_tree(T1, s1);\n    make_tree(T2, s2);\n    sum_tree(T1->root, T2->root, T3->root);\n    print_tree(T1->root);\n    cout << endl;\n    print_tree(T2->root);\n    cout << endl;    \n    print_tree(T3->root);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r, int& idx){\n\tif(r - l == 0) return -1;\n\n\tint cur = idx;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tidx++;\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1, idx);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tidx++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1, idx);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x(200), y(200);\n\tint idx = 0;\n\tdfs(x, a, 0, a.size(), idx);\n\tidx = 0;\n\tdfs(y, b, 0, b.size(), idx);\n\n\n\tstring ans = merge(x,0,y,0);\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 40\n#define INF 1000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstring dfs(string s, string t){\n    if(s == \"()\" || t == \"()\") return \"()\";\n    s.erase(0,1); s.erase(s.size()-1,1);\n    t.erase(0,1); t.erase(t.size()-1,1);\n    int cnt = 0;\n    int i = 1;\n    for(; i < s.size(); i++){\n        if(s[i] == '(') cnt++;\n        if(s[i] == ')') cnt--;\n        if(cnt == -1) break;\n    }\n    string sl = s.substr(0,i+1);\n    i += 2;\n    int ns = 0;\n    for(; i < s.size(); i++){\n        if('0' > s[i] || s[i] > '9') break;\n        ns = ns*10+s[i]-'0';\n    }\n    string sr = s.substr(i+1);\n    cnt = 0;\n    i = 1;\n    for(; i < t.size(); i++){\n        if(t[i] == '(') cnt++;\n        if(t[i] == ')') cnt--;\n        if(cnt == -1) break;\n    }\n    string tl = t.substr(0,i+1);\n    i += 2;\n    int nt = 0;\n    for(; i < t.size(); i++){\n        if('0' > t[i] || t[i] > '9') break;\n        nt = nt*10+t[i]-'0';\n    }\n    string tr = t.substr(i+1);\n    sr = dfs(sr,tr);\n    sl = dfs(sl,tl);\n    ns += nt;\n    sl.push_back('[');\n    sl += to_string(ns);\n    sl.push_back(']');\n    sl += sr;\n    sl.insert(0,\"(\"); sl.insert(sl.size()-1,\")\");\n    return sl;\n}\n\nint main(){\n    string s,t;\n    cin >> s >> t;\n    s.insert(0,\"(\"); s.insert(s.size()-1,\")\");\n    t.insert(0,\"(\"); t.insert(t.size()-1,\")\");\n    s = dfs(s,t);\n    s.erase(0,1); s.erase(s.size()-1,1);\n    cout << s << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<string>\n#include<cmath>\n\n#define fin cin\n\nusing namespace std;\n\nbool isValue(char c){\n    return 48 <= (int)c && (int)c <=57;\n}\n\n\nint main(){\n    //ifstream fin(\"in.txt\");\n    \n    string one = \"\";\n    string two = \"\";\n\n    string ans = \"\";\n\n    fin >> one;\n    fin >> two;\n\n    //cout << one << endl;\n    //cout << two << endl;\n\n    auto one_kakko = 0;\n    auto two_kakko = 0;\n    auto one_sub = 0;\n    auto two_sub = 0;\n    auto s_size = max(one.size(), two.size());\n\n\n    while( max(one_sub, two_sub) < s_size)\n    {\n        //temporary\n        auto one_c = one[one_sub];\n        auto two_c = two[two_sub];\n\n        if(one_c == '(')one_kakko++;\n        else if(one_c == ')')one_kakko--;\n\n        if(two_c == '(')two_kakko++;\n        else if(two_c == ')')two_kakko--;\n\n        //???????????§i++?????????\n        //cout << one_c << \" \" << two_c << endl;\n\n        //??±????????????\n        if(one_kakko == two_kakko)\n        {\n            //??°???????????????ans?????????\n            if(isValue(one_c) && isValue(two_c))\n            {\n                int one_num = 0;\n                int two_num = 0;\n\n                one_num = (int)one_c - 48;\n                two_num = (int)two_c - 48;\n\n                while(isValue(one[one_sub + 1]))\n                {\n                    one_num *= 10;\n                    one_num += (int)one[one_sub + 1] - 48;\n                    one_sub++;\n                }\n\n                while(isValue(two[two_sub + 1]))\n                {\n                    two_num *= 10;\n                    two_num += (int)two[two_sub + 1] - 48;\n                    two_sub++;\n                }\n\n                ans += to_string(one_num + two_num);\n                //cout << \"add \" << to_string((int)one_c + (int)two_c - 96) << endl;\n            }\n            else if(one_c == two_c)//???????????????ans?????????\n            {\n                ans += one_c;\n                //cout << \"add \" << one_c << endl;\n            }\n        }\n        else//????????±???????????£??????????????¨???????????\\????????§++\n        {\n            int isSame = 1;\n            if(one_kakko > two_kakko)\n            {\n                one_sub++;\n                while(isSame < 2)\n                {\n                    //cout << one[one_sub] << \" \" << two[two_sub] << endl;\n                    if(one[one_sub] == '(')one_kakko++;\n                    else if(one[one_sub] == ')')one_kakko--;\n\n                    if(one_kakko == two_kakko)isSame++;\n                    one_sub++;\n                    //cout << \"come one \" << isSame << endl;\n                }\n                one_sub -= 2;\n                two_sub--;\n            }\n            else if(one_kakko < two_kakko)\n            {\n                two_sub++;\n                while(isSame < 2)\n                {\n                    //cout << one[one_sub] << \" \" << two[two_sub] << endl;\n                    if(two[two_sub] == '(')two_kakko++;\n                    else if(two[two_sub] == ')')two_kakko--;\n\n                    if(one_kakko == two_kakko)isSame++;\n                    two_sub++;\n                    //cout << \"come two \" << isSame << endl;\n                }\n                one_sub--;\n                two_sub -= 2;\n            }\n            \n        }\n\n        one_sub++;\n        two_sub++;\n    }\n\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n\n\n//((()[8]())[2]())[5](((()[2]())[6](()[3]()))[1](       ))\n//((       )[4]())[3](((()[2]())[1](       ))[8](()[3]()))\n\n//(()[1](       ))[2](()[3]())\n//(()[1](()[2]()))[3](       )"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct node{\n  LL num=-1;\n  struct node* r=NULL;\n  struct node* l=NULL;\n};\n\nvoid decode(string s,struct node* now){\n  int i=0;\n  int l=0,r=0;\n  for(;;i++){\n    if(s[i]=='(') l++;\n    else if(s[i]==')') r++;\n    if(l==r){\n      if(i>1){\n        now->l=new struct node;\n        decode(s.substr(1,i-1),now->l);\n        //cout << s.substr(1,i-1) <<endl;\n      }\n      break;\n    }\n  }\n  int tmp=i;\n  for(;;i++){\n    if(s[i]==']'){\n      now->num=stoi(s.substr(tmp+2,i-tmp-2));\n      break;\n    }\n  }\n  if(i<s.length()-3){\n    now->r=new struct node;\n    decode(s.substr(i+2,s.length()-3-i),now->r);\n    //cout << s.substr(i+2,s.length()-3-i) << endl;\n  }\n  return;\n}\n\nstring encode(struct node* now){\n  if(now!=NULL){\n    return \"(\"+encode(now->l)+\")[\"+to_string(now->num)+\"](\"+encode(now->r)+\")\";\n  }else{\n    return \"\";\n  }\n}\n\nvoid merge(struct node* now,struct node* anow,struct node* bnow){\n  now->num=anow->num+bnow->num;\n  if(anow->l!=NULL&&bnow->l!=NULL){\n    now->l=new struct node;\n    merge(now->l,anow->l,bnow->l);\n  }\n  if(anow->r!=NULL&&bnow->r!=NULL){\n    now->r=new struct node;\n    merge(now->r,anow->r,bnow->r);\n  }\n  return;\n}\n\nint main(){\n  string a,b;\n  cin >> a >> b;\n  struct node A,B,ans;\n  decode(a,&A);\n  decode(b,&B);\n  merge(&ans,&A,&B);\n  // for(int i=0;i<50;i++){\n  //   cout << A[i] << \" \";\n  // }\n  // cout << endl;\n  cout << encode(&ans) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct node{\n    int id;\n    node* left; node* right;\n    node() : id(-1),left(nullptr),right(nullptr){}\n};\n\nstring s;\n\nint num(int& pos){\n    string res;\n    while(isdigit(s[pos])){\n        res.pb(s[pos]);\n        pos++;\n    }\n    return stoi(res);\n}\n\nnode* expr(int& pos);\n\nnode* term(int& pos){\n    pos++;\n    node* res = expr(pos);\n    pos++;\n    return res;\n}\n\nnode* expr(int& pos){\n    if(s[pos] == ')'){\n        return nullptr;\n    }\n    node* mid = new node;\n    mid->left = term(pos);\n    pos++;\n    mid->id = num(pos);\n    pos++;\n    mid->right = term(pos);\n    return mid;\n}\n\nstring dfs(node* n1,node* n2)\n{\n    string res;\n    res.pb('(');\n    if(n1->left && n2->left){\n        res += dfs(n1->left,n2->left);\n    }\n    res.pb(')');\n    res.pb('[');\n    stringstream ss;\n    ss << (n1->id+n2->id);\n    res += ss.str();\n    res.pb(']');\n    res.pb('(');\n    if(n1->right && n2->right){\n        res += dfs(n1->right,n2->right);\n    }\n    res.pb(')');\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> s;\n    int pos = 0;\n    node* r1 = expr(pos);\n    cin >> s;\n    pos = 0;\n    node* r2 = expr(pos);\n    cout << dfs(r1,r2) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2740&lang=jp\ntypedef long long ll;\n#define INF 1<<30\nusing namespace std;\n\nvoid check(int& i,int k, vector<int>& str,string& S) {\n\t/* \"(\" ~ )[x]( ~ ) */\n\tif (S[i] == '(') i++;\n\n\t/* ( \"~\" )[x]( ~ ) */\n\tif (S[i] == '(') {\n\t\tcheck(i, 2 * k + 1, str, S);\n\t}\n\n\t/* ( ~ \")\"[x]( ~ )  */\n\tif (S[i] == ')') i++;\n\n\t/* ( ~ )\"[x]\"( ~ ) */\n\ti++; // \"[\"\n\tstr[k] = 0;\n\twhile (S[i] != ']') {\n\t\tstr[k] = str[k] * 10 + (S[i] - '0');\n\t\ti++;\n\t}\n\ti++; // \"]\"\n\n\t/* ( ~ )[x]\"(\" ~ ) */\n\tif (S[i] == '(') i++;\n\n\t/* ( ~ )[x]( \"~\" )*/\n\tif (S[i] == '(') {\n\t\tcheck(i, 2 * k + 2, str, S);\n\t}\n\n\t/* ( ~ )[x]( ~ \")\"*/\n\tif (S[i] == ')') i++;\n}\n\n/* print answer method */\nvoid out(int k,vector<int>& Sum){\n\tcout << \"(\";\n\tif (Sum[2 * k + 1] != -1) {\n\t\tout(2 * k + 1, Sum);\n\t}\n\tcout << \")[\" << Sum[k] << \"](\";\n\tif (Sum[2 * k + 2] != -1) {\n\t\tout(2 * k + 2, Sum);\n\t}\n\tcout << \")\";\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t/* input */\n\tstring A, B; cin >> A >> B;\n\n\t/* initialize */\n\tint k = max(A.length(), B.length());\n\tvector<int> A_tree(k*k, -1), B_tree(k*k, -1),Sum_tree(k*k,-1);\n\n\t/* calc */\n\tint x = 0;\n\tcheck(x, 0, A_tree, A);\n\tx = 0;\n\tcheck(x, 0, B_tree, B);\n\n\tfor (int i = 0; i < (int)A_tree.size();i++) {\n\t\tif (A_tree[i] == -1 || B_tree[i] == -1) continue;\n\t\tSum_tree[i] = A_tree[i] + B_tree[i];\n\t}\n\n\t/*for (auto v : Sum_tree) {\n\t\tcout << v << \" \";\n\t}\n\tcout << endl;*/\n\n\t/* solve */\n\tout(0, Sum_tree);\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n\nusing namespace std;\n\nenum TYPE{\n\tNONE,\n\tFIRST,\n\tSECOND,\n\tLEFT,\n\tRIGHT\n};\n\nint first[100000],second[100000],third[100000];\nchar buf[1010];\n\nTYPE toWrite;\n\n//left_or_right???LEFT????????????????????¢?????¬??????2*parent_address+1,RIGHT??????parent_address+2\nvoid recursive(int left,int right,int parent_address,TYPE left_or_right){\n\tint calcDepth,nextRight,nextLeft,tmp,nextParentAddress = -1;\n\tif(parent_address != -1){\n\t\tcalcDepth = 0; //??????????????±???\n\t\tfor(int i = left,k=0; i <= right; i++){\n\n\t\t\tif(calcDepth==0 && buf[i] == '['){ //???\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextRight = i-1;\n\t\t\t\tnextLeft = k+1;\n\t\t\t\tbreak; //???????????????????????????????????±???0???1??????????????¨???????????????????????§break;\n\t\t\t}else if(calcDepth==0 && buf[i] == '(' && buf[i+1] >= '0' && buf[i+1] <= '9'){ //???<?????????>\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ')';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\t}\n\t\t}\n\n\t\tif(nextParentAddress != -1){\n\t\t\tif(left+1 < nextRight-1){\n\t\t\t\trecursive(left+1,nextRight-1,nextParentAddress,LEFT);\n\t\t\t}\n\t\t\tif(nextLeft+1 < right-1){\n\t\t\t\trecursive(nextLeft+1,right-1,nextParentAddress,RIGHT);\n\t\t\t}\n\t\t}\n\n\t}else{ //???????????´???\n\t\tcalcDepth = 0; //??¶???????????±???\n\t\tfor(int i = 0,k=0; i <= right; i++){\n\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\telse{\n\t\t\t\tif(calcDepth==0 && buf[i] == '['){ //????????????????????????\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\t\tfirst[0] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[0] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tnextRight = i-1;\n\t\t\t\t\tnextLeft = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(left+1 < nextRight-1){\n\t\t\trecursive(left+1,nextRight-1,0,LEFT);\n\t\t}\n\t\tif(nextLeft+1 < right-1){\n\t\t\trecursive(nextLeft+1,right-1,0,RIGHT);\n\t\t}\n\t}\n}\n\nvoid outPut(int address){\n\n\tif(third[2*address+1] != -1 || third[2*address+2] != -1){//??????????????´???\n\t\tif(third[2*address+1] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+1);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t\tprintf(\"[%d]\",third[address]);\n\t\tif(third[2*address+2] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+2);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t}else{ //?????????????????´???\n\t\tprintf(\"()[%d]()\",third[address]);\n\t}\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 100000; i++){\n\t\tfirst[i] = -1;\n\t\tsecond[i] = -1;\n\t\tthird[i] = -1;\n\t}\n\n\tscanf(\"%s\",buf);\n\tint length;\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = FIRST;\n\trecursive(0,length-1,-1,NONE);\n\n\tscanf(\"%s\",buf);\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = SECOND;\n\trecursive(0,length-1,-1,NONE);\n\n\tfor(int i = 0; i < 100000; i++){\n\t\tif(first[i] != -1 && second[i] != -1){\n\t\t\tthird[i] = first[i]+second[i];\n\t\t}else{\n\t\t\tthird[i] = -1;\n\t\t}\n\t}\n\n\toutPut(0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\ttree t;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\ttree t;\n\tvt3.push_back(t);\n\t\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tif (vt.size() < no)\n\t\treturn \"\";\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\t//saiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct node{\n    node *l,*r;\n    int d;\n    node(){\n        l=r=NULL;\n        d=-1;\n    }\n};\n\nint number(string &S, int &i){\n    int ret=0;\n    while(isdigit(S[i])){\n        ret*=10;\n        ret+=S[i]-'0';\n        i++;\n    }\n    return ret;\n}\n\nnode* parse(string &S, int&i){\n    if(S[i]==')') return NULL;\n    node *p = new node();\n    i++;\n    p->l = parse(S,i);\n    i+=2;\n    p->d = number(S,i);\n    i+=2;\n    p->r = parse(S,i);\n    i++;\n    return p;\n}\n\nnode* unite(node* pA, node *pB){\n    if(pA==NULL||pB==NULL) return NULL;\n    node *p = new node();\n    p->d = pA->d + pB->d;\n    p->l = unite(pA->l,pB->l);\n    p->r = unite(pA->r,pB->r);\n    return p;\n}\n\nstring tree(node *p){\n    if(p==NULL) return \"\";\n    return \"(\"+tree(p->l)+\")[\"+to_string(p->d)+\"](\"+tree(p->r)+\")\";\n}\n\nint main(){\n    string A,B;\n    cin>>A>>B;\n    node *pA, *pB, *pC;\n    int i=0;\n    pA=parse(A,i);\n    i=0;\n    pB=parse(B,i);\n    pC=unite(pA,pB);\n    cout<<tree(pC)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\ntypedef string::const_iterator iter;\n \nstruct Node {\n  int value;\n  int left_index;\n  int right_index;\n  Node(int v, int l, int r) : value(v), left_index(l), right_index(r) {}\n};\n \ntypedef std::vector<Node> Tree;\n \nint expr(iter &p, Tree &tree);\nint term(iter &p, Tree &tree);\nint factor(iter &p, Tree &tree);\nint number(iter &p);\n \nint expr(iter &p, Tree &tree) {\n  // cerr << \"expr *p = \" << *p << endl;\n  int left_index = term(p, tree);\n  assert(*p == '[');\n  ++p;\n  int value = number(p);\n  assert(*p == ']');\n  ++p;\n  int right_index = term(p, tree);\n  tree.emplace_back(value, left_index, right_index);\n  return tree.size() - 1;\n}\n \nint term(iter &p, Tree &tree) {\n  // cerr << \"term *p = \" << *p << endl;\n  assert(*p == '(');\n  ++p;\n  if(*p == ')') {\n    ++p;\n    return -1;\n  }\n  else {\n    int ret = expr(p, tree);\n    assert(*p == ')');\n    ++p;\n    return ret;\n  }\n}\n \nint number(iter &p) {\n  int r = 0;\n  while(isdigit(*p)) {\n    r *= 10;\n    r += *p - '0';\n    ++p;\n  }\n  return r;\n}\n \nint dfs(Tree &AT, Tree &BT, int a, int b, Tree &CT) {\n  int left_index = -1;\n  if(AT[a].left_index != -1 && BT[b].left_index != -1) {\n    left_index = dfs(AT, BT, AT[a].left_index, BT[b].left_index, CT);\n  }\n \n  int right_index = -1;\n  if(AT[a].right_index != -1 && BT[b].right_index != -1) {\n    right_index = dfs(AT, BT, AT[a].right_index, BT[b].right_index, CT);\n  }\n \n  int value = AT[a].value + BT[b].value;\n  CT.emplace_back(value, left_index, right_index);\n  return CT.size() - 1;\n}\n \nvoid print(Tree &CT, int c, bool isTop) {\n  if(c == -1) cout << \"()\";\n  else {\n    if(!isTop) cout << \"(\";\n    print(CT, CT[c].left_index, false);\n    cout << \"[\" << CT[c].value << \"]\";\n    print(CT, CT[c].right_index, false);\n    if(!isTop) cout << \")\";\n  }\n}\n \nsigned main() {\n  ios::sync_with_stdio(false);\n  iter p;\n \n  string A; cin >> A;\n  Tree AT;\n  p = A.begin();\n  int topA = expr(p, AT);\n \n  string B; cin >> B;\n  Tree BT;\n  p = B.begin();\n  int topB = expr(p, BT);\n  // DEBUG(ret);\n  // for(int i = 0; i < (int)AT.size(); ++i) {\n  //   auto node = AT[i];\n  //   cout << i << \" = (\" << node.left_index << \" \" << node.value << \" \" << node.right_index << \")\" << endl;\n  // }\n  Tree CT;\n  int topC = dfs(AT, BT, topA, topB, CT);\n \n  // DEBUG(topC);\n  // for(int i = 0; i < (int)CT.size(); ++i) {\n  //   auto node = CT[i];\n  //   cout << i << \" = (\" << node.left_index << \" \" << node.value << \" \" << node.right_index << \")\" << endl;\n  // }\n  print(CT, topC, true);\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\ttree t;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\ttree t;\n\tvt3.push_back(t);\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  for(int N, M; ~scanf(\"%d%d\", &N, &M) && N;) {\n    int sum[N + 1]; sum[0] = 0;\n\n    int res = 0;\n    rep(i, N) {\n      int A; scanf(\"%d\", &A); A %= M;\n      sum[i + 1] = sum[i] + A;\n      sum[i + 1] %= M;\n      maximize(res, sum[i + 1]);\n    }\n\n    set<int> st;\n\n    REP(i, 1, N - 1) {\n      maximize(res, sum[i] + M - *st.upper_bound(sum[i]));\n      st.insert(sum[i]);\n    }\n\n    cout << res << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2);\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;\n  for(int i=l+1;i<r;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }//if(p){cout<<1;exit(0);}\n  po->key=o;\n  if(l+1!=c){\n    //if(c-1>l+1)\n    po->left=con(l+1,c-1);\n  }\n  if(r-1!=c){\n   // if(r-1>c+1)\n    po->right=con(c+1,r-1);\n  }\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size()-1);\n  n=1;node p2=con(0,a[1].size()-1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for (int i = (int)(s); i < (int)(n); i++)\nconst ll mod = ll(1e9) + 7;\nconst int INF = int(1e9);\n\nint idxa = 0, idxb = 0;\n\nint calc(string &A, string &B)\n{\n    string tmpa, tmpb;\n    idxa++;\n    idxb++;\n    while (A[idxa] != ']')\n    {\n        tmpa.push_back(A[idxa++]);\n    }\n    while (B[idxb] != ']')\n    {\n        tmpb.push_back(B[idxb++]);\n    }\n    //cout << tmpa << \" \" << tmpb << endl;\n    return stoi(tmpa) + stoi(tmpb);\n}\nint proceed(int idx, string &C)\n{\n    int cnt = 1;\n    while (1)\n    {\n        idx++;\n        if (C[idx] == ')')\n            cnt--;\n        if (C[idx] == '(')\n            cnt++;\n        if (cnt < 0)\n            break;\n    }\n    return idx;\n}\n\nint main()\n{\n    string A, B;\n    cin >> A >> B;\n    string ans;\n    while (idxa < A.size())\n    {\n        if (A[idxa] == B[idxb])\n        {\n            if (A[idxa] == '[')\n            {\n                ans.push_back('[');\n                int tmp = calc(A, B);\n                ans += to_string(tmp);\n                ans.push_back(']');\n            }\n            else\n                ans.push_back(A[idxa]);\n        }\n        else\n        {\n            if (A[idxa] == '(')\n                idxa = proceed(idxa, A);\n            else\n            {\n                idxb = proceed(idxb, B);\n            }\n            ans.push_back(A[idxa]);\n        }\n        idxa++;\n        idxb++;\n        //cout << ans << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct node{\n    int num; //ノードに書かれた数\n    int right,left;//子のindex\n};\n\nstruct node v[2][1000];\n\nvector<string> s(2);\nvi num(2);\nvoid f(int ind, int l, int r){\n    int st = 0;\n    int sum = 0;\n    int no = num[ind];\n\n    for(int i = l; i <= r; i++){\n        if(s[ind][i] == '('){\n            st++;\n        }\n        if(s[ind][i] == ')'){\n            st--;\n        }\n        if(s[ind][i] == '[' && st == 0){\n            num[ind]++;\n            v[ind][no].left = num[ind];\n            f(ind, l+1, i-2);\n        }\n        if(s[ind][i] == ']' && st == 0){\n            num[ind]++;\n            v[ind][no].right = num[ind];\n            v[ind][no].num = sum;\n            f(ind, i+2, r-1);\n        }\n        if(isdigit(s[ind][i]) && st == 0){\n            sum *= 10;\n            sum += s[ind][i] - '0';\n        }\n    }\n\n}\n\nstring g(int a, int b){\n    string ret = \"\";\n\n    ret += \"(\";\n    if(v[0][v[0][a].left].num >= 0 && v[1][v[1][b].left].num >= 0){\n        ret += g(v[0][a].left, v[1][b].left);\n    }\n    ret += \")\";\n\n    ret += \"[\";\n    ret += to_string(v[0][a].num + v[1][b].num);\n    ret += \"]\";\n\n    ret += \"(\";\n    if(v[0][v[0][a].right].num >= 0 && v[1][v[1][b].right].num >= 0){\n        ret += g(v[0][a].right, v[1][b].right);\n    }\n    ret += \")\";\n\n    return ret;\n}\n\nint main(void) {\n    int i,j;\n    cin >> s[0];\n    cin >> s[1];\n\n    rep(i,2)rep(j,1000) v[i][j].num = v[i][j].right = v[i][j].left = -1;\n\n    f(0,0,s[0].size()-1);\n    f(1,0,s[1].size()-1);\n\n\n    cout << g(0,0) << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstring A, B;\n\nstring merge(size_t la, size_t ra, size_t lb, size_t rb){\n  int s = -1, t = -1, k = 0;\n  if(ra-la <= 2 or rb-lb <= 2) return \"\";\n  int x = 0;\n  for(size_t i = la; i < ra; ++i){\n    if(A[i] == '(') ++k;\n    if(A[i] == ')') --k;\n    if(not k){\n      s = i+2;\n      break;\n    }\n  }\n  int s_ = s;\n  if(s < 0) x = -1;\n  else{\n    while(A[s] != ']'){\n      x *= 10;\n      x += A[s++] - '0';\n    }\n  }\n  k = 0;\n  int y = 0;\n  for(size_t i = lb; i < rb; ++i){\n    if(B[i] == '(') ++k;\n    if(B[i] == ')') --k;\n    if(not k){\n      t = i+2;\n      break;\n    }\n  }\n  int t_ = t;\n  if(t < 0) x = -1;\n  else{\n    while(B[t] != ']'){\n      y *= 10;\n      y += B[t++] - '0';\n    }\n  }\n  if(x < 0 or y < 0){\n    return \"()\";\n  }\n  int z = x+y;\n  return \"(\"+merge(la+1,s_-1,lb+1,t_-1)+\")[\"+to_string(z)+\"](\"+merge(s+2,ra-1,t+2,rb-1)+\")\";\n}\n\nint main(){\n  cin >> A >> B;\n  cout << merge(0,A.length(),0,B.length()) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n\ntypedef struct _tree {\n    struct _tree *left, *right;\n    int node;\n} tree;\n\nchar *p;\nbool analyze(tree *dst) {\n    dst->left = dst->right = NULL;\n    switch(*p) {\n        case ')':\n            p++;\n            return false;\n        case '(':\n            dst->left = (tree*)malloc(sizeof(tree));\n            p++;\n            if(!analyze(dst->left)) dst->left = NULL;\n            break;\n    }\n    p++;\n    dst->node = 0;\n    while('0' <= *p && *p <= '9')\n        dst->node*=10, dst->node+=(*p-'0'), p++;\n    p++;\n    p++;\n\n    dst->right = (tree*)malloc(sizeof(tree));\n    if(!analyze(dst->right)) dst->right = NULL;\n    p++;\n    return true;\n}\n\nvoid print_tree(tree *tr) {\n    printf(\"(\");\n    if(tr->left) print_tree(tr->left);\n    printf(\")\");\n\n    printf(\"[\");\n    printf(\"%d\", tr->node);\n    printf(\"]\");\n\n    printf(\"(\");\n    if(tr->right) print_tree(tr->right);\n    printf(\")\");\n}\n\nvoid unite(tree *tr1, tree *tr2) {\n    (tr1->left && tr2->left) ? unite(tr1->left, tr2->left),tr1->left : tr1->left = NULL;\n    (tr1->right && tr2->right) ? unite(tr1->right, tr2->right),tr1->left : tr1->right = NULL;\n    tr1->node += tr2->node;\n}\n\nint main(void) {\n    char s[2000], t[2000];\n    tree st, tt;\n\n    scanf(\"%s%s\",s,t);\n    p = s;\n    analyze(&st);\n    p = t;\n    analyze(&tt);\n\n    unite(&st, &tt);\n\n    print_tree(&st);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define endl \"\\n\"\n\nstring mul(string a)\n{\n  int n = (int)a.size();\n  string res = \"\";\n  bool up = false;\n  for (int i = n - 1; i >= 0; i--)\n  {\n    int tmp = (int)(a[i] - '0');\n    tmp *= 2;\n    if (up)\n      tmp++;\n    up = false;\n    string tmp2 = to_string(tmp);\n    res += tmp2[tmp2.size() - 1];\n    if (tmp2.size() > 1)\n      up = true;\n  }\n  if (up)\n    res += '1';\n  reverse(all(res));\n  return res;\n}\n\nstring add(string a) {\n  int n = (int)a.size();\n  string res = \"\";\n  bool up = true;\n  for (int i = n - 1; i >= 0; i--) {\n    if (!up) {\n      res += a[i];\n      continue;\n    }\n    int tmp = (int)(a[i] - '0');\n    tmp++;\n    string tmp2 = to_string(tmp);\n    res += tmp2[tmp2.size() - 1];\n    if (tmp2.size() > 1) up = true;\n    else up = false;\n  }\n  if (up) res += '1';\n  reverse(all(res));\n  return res;\n}\n\nmap<string, int> NumA, NumB;\n\nvoid parseA(string idx, string s)\n{\n  int n = (int)s.size();\n  stack<char> st;\n  int res = 0;\n  int left = -1, right = -1;\n  for (int i = 0; i < n; i++)\n  {\n    if (s[i] == '(')\n      st.push('(');\n    else if (s[i] == ')')\n      st.pop();\n    else if (isdigit(s[i]) && st.empty())\n    {\n      res *= 10;\n      res += (int)(s[i] - '0');\n    }\n    else if (s[i] == '[' && st.empty() && i - 2 > 0)\n    {\n      parseA(idx * 2, s.substr(1, i - 2));\n    }\n    else if (s[i] == ']' && st.empty() && i + 2 < n - 1)\n    {\n      parseA(idx * 2 + 1, s.substr(i + 2, n - i - 3));\n      break;\n    }\n  }\n  NumA[idx] = res;\n}\n\nvoid parseB(string idx, string s)\n{\n  int n = (int)s.size();\n  stack<char> st;\n  int res = 0;\n  for (int i = 0; i < n; i++)\n  {\n    if (s[i] == '(')\n      st.push('(');\n    else if (s[i] == ')')\n      st.pop();\n    else if (isdigit(s[i]) && st.empty())\n    {\n      res *= 10;\n      res += (int)(s[i] - '0');\n    }\n    else if (s[i] == '[' && st.empty() && i - 2 > 0)\n    {\n      parseB(mul(idx), s.substr(1, i - 2));\n    }\n    else if (s[i] == ']' && st.empty() && i + 2 < n - 1)\n    {\n      parseB(add(mul(idx)), s.substr(i + 2, n - i - 3));\n      break;\n    }\n  }\n  NumB[idx] = res;\n}\n\nstring a, b;\nmap<string, int> NumS;\n\nstring construct(string idx)\n{\n  if (NumS.count(idx) == 0)\n    return \"\";\n  return \"(\" + construct(mul(idx)) + \")[\" + to_string(NumS[idx]) + \"](\" + construct(add(mul(idx))) + \")\";\n}\n\nint main()\n{\n  cin >> a >> b;\n  parseA(\"1\", a);\n  parseB(\"1\", b);\n  for (auto ite = NumA.begin(); ite != NumA.end(); ite++) {\n    for (auto ite2 = NumB.begin(); ite2 != NumB.end(); ite2++) {\n      if (ite->fi == ite2->fi) {\n        NumS[ite->fi] = ite->se + ite2->se;\n      }\n    }\n  }\n  string ans = construct(\"1\");\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nint const MAX=10000000;\n\nint T[2][MAX];\nint A[MAX];\n\nvoid decode(string s,int num,int ab){\n  int i=0;\n  int l=0,r=0;\n  for(;;i++){\n    if(s[i]=='(') l++;\n    else if(s[i]==')') r++;\n    if(l==r){\n      if(i>1) decode(s.substr(1,i-1),num*2+1,ab);\n      break;\n    }\n  }\n  int tmp=i;\n  for(;;i++){\n    if(s[i]==']'){\n      T[ab][num]=stoi(s.substr(tmp+2,i-1));\n      break;\n    }\n  }\n  if(i<s.length()-3) decode(s.substr(i+2,s.length()-4-i),num*2+2,ab);\n  return;\n}\n\nstring encode(int num){\n  if(A[num]>=0){\n    return \"(\"+encode(num*2+1)+\")[\"+to_string(A[num])+\"](\"+encode(num*2+2)+\")\";\n  }else{\n    return \"\";\n  }\n}\n\nvoid merge(int num){\n  A[num]=T[0][num]+T[1][num];\n  if(T[0][num*2+1]>=0&&T[1][num*2+1]>=0) merge(num*2+1);\n  if(T[0][num*2+2]>=0&&T[1][num*2+2]>=0) merge(num*2+2);\n  return;\n}\n\nint main(){\n  string a,b;\n  cin >> a >> b;\n  for(int i=0;i<MAX;i++){\n    T[0][i]=T[1][i]=A[i]=-1;\n  }\n  decode(a,0,0);\n  decode(b,0,1);\n  merge(0);\n  // for(int i=0;i<50;i++){\n  //   cout << A[i] << \" \";\n  // }\n  // cout << endl;\n  cout << encode(0) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2);\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;\n  for(int i=l+1;i<r;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }if(p){cout<<1;exit(0);}\n  po->key=o;\n  if(l+1!=c){\n    if(c-1>l+1)\n    po->left=con(l+1,c-1);\n  }\n  if(r-1!=c){\n    if(r-1>c+1)\n    po->right=con(c+1,r-1);\n  }\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size()-1);\n  n=1;node p2=con(0,a[1].size()-1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;//if(l+1>=r+1){exit(0);}\n  for(int i=l+1;i<r-1;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c);\n  if(r-1!=c+1)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size());\n  n=1;node p2=con(0,a[1].size());\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2740&lang=jp\ntypedef long long ll;\n#define INF 1<<30\nusing namespace std;\n\nvoid check(int& i,int k, vector<int>& str,string& S) {\n\t/* \"(\" ~ )[x]( ~ ) */\n\tif (S[i] == '(') i++;\n\n\t/* ( \"~\" )[x]( ~ ) */\n\tif (S[i] == '(') {\n\t\tcheck(i, 2 * k + 1, str, S);\n\t}\n\n\t/* ( ~ \")\"[x]( ~ )  */\n\tif (S[i] == ')') i++;\n\n\t/* ( ~ )\"[x]\"( ~ ) */\n\ti++; // \"[\"\n\twhile (S[i] != ']') {\n\t\tstr[k] = str[k] * 10 + (S[i] - '0');\n\t\ti++;\n\t}\n\ti++; // \"]\"\n\n\t/* ( ~ )[x]\"(\" ~ ) */\n\tif (S[i] == '(') i++;\n\n\t/* ( ~ )[x]( \"~\" )*/\n\tif (S[i] == '(') {\n\t\tcheck(i, 2 * k + 2, str, S);\n\t}\n\n\t/* ( ~ )[x]( ~ \")\"*/\n\tif (S[i] == ')') i++;\n}\n\n/* print answer method */\nvoid out(int k,vector<int>& Sum){\n\tcout << \"(\";\n\tif (Sum[2 * k + 1] != 0) {\n\t\tout(2 * k + 1, Sum);\n\t}\n\tcout << \")[\" << Sum[k] << \"](\";\n\tif (Sum[2 * k + 2] != 0) {\n\t\tout(2 * k + 2, Sum);\n\t}\n\tcout << \")\";\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t/* input */\n\tstring A, B; cin >> A >> B;\n\n\t/* initialize */\n\tint k = max(A.length(), B.length());\n\tvector<int> A_tree(k + 10, 0), B_tree(k + 10, 0),Sum_tree(k+10,0);\n\n\t/* calc */\n\tint x = 0;\n\tcheck(x, 0, A_tree, A);\n\tx = 0;\n\tcheck(x, 0, B_tree, B);\n\n\tfor (int i = 0; i < (int)A_tree.size();i++) {\n\t\tif (A_tree[i] == 0 || B_tree[i] == 0) continue;\n\t\tSum_tree[i] = A_tree[i] + B_tree[i];\n\t}\n\n\t/*for (auto v : Sum_tree) {\n\t\tcout << v << \" \";\n\t}\n\tcout << endl;*/\n\n\t/* solve */\n\tout(0, Sum_tree);\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define repr(i, a, b) for (int i = (int)(a - 1); i >= b; i--)\n#define rep(i, n) repl(i, 0, n)\n#define each(itr, v) for (auto itr : v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(), (x).end()\n#define dbg(x) cout << #x \" = \" << x << endl\n#define dbgv(i, a, v) \\\n  rep(i, a) { cout << v[i] << ((i < a - 1) ? ' ' : '\\n'); }\n#define maxch(x, y) x = max(x, y)\n#define minch(x, y) x = min(x, y)\n#define uni(x) x.erase(unique(all(x)), x.end())\n#define exist(x, y) (find(all(x), y) != x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define INF INT_MAX / 3\n\nint rp, rq, rans;\nint p[1010][1010][2], q[1010][1010][2], ans[1010][2020][2];\n\nint toArray(string s, int h, bool f) {\n  if (s.size() == 0) return -1;\n  int l = 1, i = 1;\n  while (l > 0 && i < s.size()) {\n    if (s[i] == '(')\n      l++;\n    else if (s[i] == ')')\n      l--;\n    i++;\n  }\n  int j = i + 1, r = 0;\n  while ('0' <= s[j] && s[j] <= '9') {\n    r = r * 10 + (s[j] - '0');\n    j++;\n  }\n  if (f) {\n    p[h][r][0] = toArray(s.substr(1, i - 2), h + 1, true);\n    p[h][r][1] = toArray(s.substr(j + 2, s.size() - j - 3), h + 1, true);\n  } else {\n    q[h][r][0] = toArray(s.substr(1, i - 2), h + 1, false);\n    q[h][r][1] = toArray(s.substr(j + 2, s.size() - j - 3), h + 1, false);\n  }\n  return r;\n}\n\nint combine(int a, int b, int h) {\n  if (a != -1 && b != -1) {\n    int r = a + b;\n    ans[h][r][0] = combine(p[h][a][0], q[h][b][0], h + 1);\n    ans[h][r][1] = combine(p[h][a][1], q[h][b][1], h + 1);\n    return r;\n  } else {\n    return -1;\n  }\n}\n\nstring toString(int r, int h) {\n  if (r == -1) return \"\";\n  string ret = \"(\";\n  ret += toString(ans[h][r][0], h + 1);\n  ret += \")[\" + to_string(r) + \"](\";\n  ret += toString(ans[h][r][1], h + 1);\n  return ret + \")\";\n}\n\nint main() {\n  cin.sync_with_stdio(false);\n  memset(p, -1, sizeof(p));\n  memset(q, -1, sizeof(q));\n  memset(ans, -1, sizeof(ans));\n  string a, b;\n  cin >> a >> b;\n  rp = toArray(a, 0, true), rq = toArray(b, 0, false);\n  rans = combine(rp, rq, 0);\n  cout << toString(rans, 0) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\ttree t;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\ttree t;\n\tvt3.push_back(t);\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tif (vt.size() < no)\n\t\treturn \"\";\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\t//saiki(s1,tree1);\n\t//saiki(s2,tree2);\n\t//saiki2(0, 0,tree3);\n\t//cout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\nvoid yesno(bool ok, string yes = \"Yes\", string no = \"No\") {\n    if (ok) {\n        cout << yes << endl;\n    } else {\n        cout << no << endl;\n    }\n}\n\nll indexa = 0;\nvll numa(1000, -1);\nvll para(1000, -1);\nvll lefta(1000, -1);\nvll righta(1000, -1);\n\nll indexb = 0;\nvll numb(1000, -1);\nvll parb(1000, -1);\nvll leftb(1000, -1);\nvll rightb(1000, -1);\n\nll makeTree(string s, ll &index, vll &num, vll &par, vll &left, vll &right, ll dep) {\n    if (dep > 0) {\n        s = s.substr(1, s.size() - 2);\n    }\n    // cout << \"s \" << s << endl;\n    if (s == \"\") {\n        return -1;\n    }\n    ll p = 1;\n    ll tmp = 1;\n    while (p > 0) {\n        if(s[tmp] == '(') {\n            p++;\n        } else if (s[tmp] == ')') {\n            p--;\n        }\n        tmp++;\n    }\n    string leftstr = s.substr(0, tmp);\n    // cout << \"left \" << leftstr << endl;\n    ll leftnum = makeTree(leftstr, index, num, par, left, right, dep + 1);\n    tmp++;\n    ll lefti = tmp;\n    while (s[tmp] - '0' >= 0 && s[tmp] - '0' <= 9) {\n        tmp++;\n    }\n    ll parnum = stoll(s.substr(lefti, tmp - lefti));\n    num[index] = parnum;\n    ll parindex = index;\n    index++;\n    string rightstr = s.substr(tmp + 1, s.size() - (tmp + 1));\n    // cout << \"right \" << rightstr << endl;\n    ll rightnum = makeTree(rightstr, index, num, par, left, right, dep + 1);\n    if (leftnum != -1) {\n        par[leftnum] = parindex;\n    }\n    if (rightnum != -1) {\n        par[rightnum] = parindex;\n    }\n    left[parindex] = leftnum;\n    right[parindex] = rightnum;\n    return parindex;\n}\n\nstring solve(ll dep, ll ai, ll bi) {\n    if (ai == -1 || bi == -1) {\n        return \"()\";\n    }\n    ll num = numa[ai] + numb[bi];\n    string numstr = \"[\" + to_string(num) + \"]\";\n    string leftstr = solve(dep + 1, lefta[ai], leftb[bi]);\n    string rightstr = solve(dep + 1, righta[ai], rightb[bi]);\n    string ans = leftstr + numstr + rightstr;\n    if (dep > 0) {\n        ans = \"(\" + ans + \")\";\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string A, B;\n    cin >> A >> B;\n    makeTree(A, indexa, numa, para, lefta, righta, 0);\n    makeTree(B, indexb, numb, parb, leftb, rightb, 0);\n    // REP(i, 0, indexa) {\n    //     cout << numa[i] << \" \" << para[i] << \" \" << lefta[i] << \" \" << righta[i] << endl;\n    // }\n    // REP(i, 0, indexb) {\n    //     cout << numb[i] << \" \" << parb[i] << \" \" << leftb[i] << \" \" << rightb[i] << endl;\n    // }\n    ll art, brt;\n    REP(i, 0, indexa) {\n        if (para[i] == -1) {\n            art = i;\n            break;\n        }\n    }\n    REP(i, 0, indexb) {\n        if (parb[i] == -1) {\n            brt = i;\n            break;\n        }\n    }\n    string ans = solve(0, art, brt);\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstring a,b;\n\nstring dfs(int al,int ar,int bl,int br){\n  if(al==ar||bl==br)return \"\";\n  int level=0;\n  int an,bn,alr,blr,arl,brl;\n  repl(i,al,ar){\n    if(a[i]=='(')level++;\n    if(a[i]==')')level--;\n    if(level==0&&a[i]=='['){\n      int j=i;\n      while(a[j]!=']')j++;\n      an=stoi(a.substr(i+1,j-i-1));\n      alr=i-1; arl=j+2;\n      break;\n    }\n  }\n\n  level=0;\n  repl(i,bl,br){\n    if(b[i]=='(')level++;\n    if(b[i]==')')level--;\n    if(level==0&&b[i]=='['){\n      int j=i;\n      while(b[j]!=']')j++;\n      bn=stoi(b.substr(i+1,j-i-1));\n      blr=i-1; brl=j+2;\n      break;\n    }\n  }\n  string res=\"(\"+dfs(al+1,alr,bl+1,blr)+\")[\"+to_string(an+bn)+\"](\"+dfs(arl,ar-1,brl,br-1)+\")\";\n  return res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>a>>b;\n  cout<<dfs(0,a.length(),0,b.length())<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nstruct Node {\n  Node *left=nullptr, *right=nullptr;\n  int value;\n  Node() {}\n  Node(int value): value(value) {}\n};\n\nNode *parse(const std::string &s, size_t &i) {\n  assert(s[i] == '(');\n  Node *cur=new Node;\n  if (s[i+1] == ')') {\n    i += 2;\n  } else {\n    cur->left = parse(s, ++i);\n    assert(s[i] == ')');\n    ++i;\n  }\n  assert(s[i] == '[');\n  ++i;\n  assert(isdigit(s[i]));\n  int v=s[i]-'0';\n  while (++i < s.length() && isdigit(s[i]))\n    v = v*10+s[i]-'0';\n  cur->value = v;\n  assert(s[i] == ']');\n  ++i;\n  assert(s[i] == '(');\n  if (s[i+1] == ')') {\n    i += 2;\n  } else {\n    cur->right = parse(s, ++i);\n    assert(s[i] == ')');\n    ++i;\n  }\n  return cur;\n}\n\nvoid dfs(Node *a, Node *b) {\n  if (!a || !b) {\n    printf(\"()\");\n    return;\n  }\n  if (a->left && b->left) {\n    printf(\"(\");\n    dfs(a->left, b->left);\n    printf(\")\");\n  } else {\n    printf(\"()\");\n  }\n  printf(\"[%d]\", a->value+b->value);\n  if (a->right && b->right) {\n    printf(\"(\");\n    dfs(a->right, b->right);\n    printf(\")\");\n  } else {\n    printf(\"()\");\n  }\n}\n\nint main() {\n  char buf[1024];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  scanf(\"%s\", buf);\n  std::string t=buf;\n\n  size_t i=0;\n  Node *ts=parse(s, i);\n  assert(i == s.length());\n  i = 0;\n  Node *tt=parse(t, i);\n  assert(i == t.length());\n  dfs(ts, tt);\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;if(r-l-1==0){cout<<1;exit(0);}\n  for(int i=l+1;i<r;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c-1);\n  if(r-1!=c)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size()-1);\n  n=1;node p2=con(0,a[1].size()-1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n \nstruct node{\n    int val;\n    node *lch,*rch;\n    node(int val):val(val){}\n};\n \nnode *make(string s){\n    int stk=0;\n    rep(i,s.size()){\n        if(s[i]=='(')stk++;\n        else if(s[i]==')')stk--;\n        else if(s[i]=='['){\n            if(stk)continue;\n            string l=s.substr(1,i-2);\n            int cur=i+1,val=0;\n            while(s[cur]!=']'){\n                val=val*10+s[cur]-'0';\n                cur++;\n            }\n            cur++;\n            string r=s.substr(cur+1,s.size()-cur-1);\n            node *t=new node(val);\n            t->lch=make(l);\n            t->rch=make(r);\n            return t;\n        }\n    }\n    return NULL;\n}\n \nstring tostring(int a){\n    stringstream ss;\n    ss<<a;\n    return ss.str();\n}\n \nstring dfs(node *s,node *t){\n    if(s==NULL||t==NULL)return \"\";\n    return \"(\"+dfs(s->lch,t->lch)+\")[\"+tostring(s->val+t->val)+\"](\"+dfs(s->rch,t->rch)+\")\";\n}\n \nsigned main(){\n    string S,T;\n    cin>>S>>T;\n    node *s=make(S);\n    node *t=make(T);\n    cout<<dfs(s,t)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 10000000\nusing namespace std;\nint AT[N],BT[N];\n\nbool check(int s,int t, string &str){\n  stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')'&&st.empty())return 0;  \n    if(str[i]==')') st.pop();\n  }\n  return st.empty();\n}\n\nint get_num(string &str,int &idx){\n  int res=0;\n  while(isdigit(str[idx]))res=res*10+str[idx++]-'0';\n  return res;\n}\n\n\nint get_root(int s,int t,string &str){\n  stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(st.empty()&&isdigit(str[i])) return i;\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')') st.pop();\n  }\n  assert(0);\n}\n\n\nvoid make_tree(int s,int t,int tree[N],string &str,int idx){\n  while(s<t&&check(s,t,str)) s++,t--;\n  if(s>=t)return;\n  s--,t++;\n  int root=get_root(s,t,str);\n  if(root==-1)return;\n  make_tree(s,root-2,tree,str,idx*2+1);\n  tree[idx]=get_num(str,root);\n  make_tree(root+1,t,tree,str,idx*2+2);\n}\n\nstring make_str(int k){\n  if(AT[k]<0||BT[k]<0) return \"\";\n  int num=AT[k]+BT[k];\n  string str;\n  while(num) str=(char)((num%10)+'0')+str,num/=10;\n  return \"(\"+make_str(k*2+1)+\")\"+\"[\"+str+\"]\"+\"(\"+make_str(k*2+2)+\")\";\n}\n\nint main(){\n  string A,B;\n  cin>>A>>B;\n  memset(AT,-1,sizeof(AT));\n  memset(BT,-1,sizeof(BT));\n  make_tree(0,A.size()-1,AT,A,0);\n  make_tree(0,B.size()-1,BT,B,0);\n  cout <<make_str(0)<<endl;  \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n#define NUM 1000000\n\nusing namespace std;\n\nenum TYPE{\n\tNONE,\n\tFIRST,\n\tSECOND,\n\tLEFT,\n\tRIGHT\n};\n\nint* first,*second,*third;\nchar buf[1010];\n\nTYPE toWrite;\n\n//left_or_right???LEFT????????????????????¢?????¬??????2*parent_address+1,RIGHT??????parent_address+2\nvoid recursive(int left,int right,int parent_address,TYPE left_or_right){\n\tint calcDepth,nextRight,nextLeft,tmp,nextParentAddress = -1;\n\tif(parent_address != -1){\n\t\tcalcDepth = 0; //??????????????±???\n\t\tfor(int i = left,k=0; i <= right; i++){\n\n\t\t\tif(calcDepth==0 && buf[i] == '['){ //???\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextRight = i-1;\n\t\t\t\tnextLeft = k+1;\n\t\t\t\tbreak; //???????????????????????????????????±???0???1??????????????¨???????????????????????§break;\n\t\t\t}else if(calcDepth==0 && buf[i] == '(' && buf[i+1] >= '0' && buf[i+1] <= '9'){ //???<?????????>\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ')';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\t}\n\t\t}\n\n\t\tif(nextParentAddress != -1){\n\t\t\tif(left+1 < nextRight-1){\n\t\t\t\trecursive(left+1,nextRight-1,nextParentAddress,LEFT);\n\t\t\t}\n\t\t\tif(nextLeft+1 < right-1){\n\t\t\t\trecursive(nextLeft+1,right-1,nextParentAddress,RIGHT);\n\t\t\t}\n\t\t}\n\n\t}else{ //???????????´???\n\t\tcalcDepth = 0; //??¶???????????±???\n\t\tfor(int i = 0,k=0; i <= right; i++){\n\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\telse{\n\t\t\t\tif(calcDepth==0 && buf[i] == '['){ //????????????????????????\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\t\tfirst[0] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[0] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tnextRight = i-1;\n\t\t\t\t\tnextLeft = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(left+1 < nextRight-1){\n\t\t\trecursive(left+1,nextRight-1,0,LEFT);\n\t\t}\n\t\tif(nextLeft+1 < right-1){\n\t\t\trecursive(nextLeft+1,right-1,0,RIGHT);\n\t\t}\n\t}\n}\n\nvoid outPut(int address){\n\n\tif(third[2*address+1] != -1 || third[2*address+2] != -1){//??????????????´???\n\t\tif(third[2*address+1] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+1);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t\tprintf(\"[%d]\",third[address]);\n\t\tif(third[2*address+2] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+2);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t}else{ //?????????????????´???\n\t\tprintf(\"()[%d]()\",third[address]);\n\t}\n}\n\n\nint main(){\n\n\tfirst = new int[NUM];\n\tsecond = new int[NUM];\n\tthird = new int[NUM];\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tfirst[i] = -1;\n\t\tsecond[i] = -1;\n\t\tthird[i] = -1;\n\t}\n\n\tscanf(\"%s\",buf);\n\tint length;\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = FIRST;\n\trecursive(0,length-1,-1,NONE);\n\n\tscanf(\"%s\",buf);\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = SECOND;\n\trecursive(0,length-1,-1,NONE);\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(first[i] != -1 && second[i] != -1){\n\t\t\tthird[i] = first[i]+second[i];\n\t\t}else{\n\t\t\tthird[i] = -1;\n\t\t}\n\t}\n\n\toutPut(0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n  \nint const INF = 1<<29;\n  \nstruct tree; typedef tree* tree_ptr;\n  \nstruct tree {\n  tree_ptr lch, rch;\n  int num;\n  tree()\n    : lch(NULL), rch(NULL), num(-INF) { }\n};\n  \nvoid consume(string& S, char expected) {\n  if(S[0] == expected) {\n    S = S.substr(1);\n    return;\n  }\n  cout << S << \", \" << expected << endl;\n  assert(0);\n}\n  \nbool consume_if(string& S, char expected) {\n  if(S[0] == expected) {\n    consume(S, expected);\n    return true;\n  }\n  else {\n    return false;\n  }\n}\n  \nint read_num(string& S) {\n  stringstream ss(S);\n  int x; ss >> x;\n  ss >> S;\n  return x;\n}\n  \nvoid make_tree(string& S, tree_ptr curr) {\n  if(consume_if(S, '(')) {\n    tree_ptr lch = new(tree);\n    curr->lch = lch;\n    make_tree(S, lch);\n    consume(S, ')');\n     \n    consume(S, '[');\n    curr->num = read_num(S);\n    consume(S, ']');\n     \n    consume(S, '(');\n    tree_ptr rch = new(tree);\n    curr->rch = rch;\n    make_tree(S, rch);\n    consume(S, ')');\n    return;\n  }\n}\n  \nvoid dfs(tree* ptr1, tree* ptr2) {\n  if(ptr1->num == -INF || ptr2->num == -INF) { return; }\n   \n  if(ptr1->lch && ptr2->lch) {\n    cout << \"(\";\n    dfs(ptr1->lch, ptr2->lch);\n    cout << \")\";\n  }\n  cout << \"[\" << (ptr1->num + ptr2->num) << \"]\";\n  if(ptr1->rch && ptr2->rch) {\n    cout << \"(\";\n    dfs(ptr1->rch, ptr2->rch);\n    cout << \")\";\n  }\n}\n  \nint main() {\n  \n  string a; cin >> a;\n  string b; cin >> b;\n   \n  tree_ptr atree = new(tree);\n  tree_ptr btree = new(tree);\n   \n  make_tree(a, atree);\n  make_tree(b, btree);\n  \n  dfs(atree, btree);\n  cout << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n\nclass Parser {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tIter it2;\n\tParser(Iter it, Iter it2) :it(it), it2(it2) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\tEBNF\n\t??????=\"(\",[??????],\")[\",??°,\"](\",[??????],\")\"\n\t*/\n\tvoid a() {\n\t\tif (*it == '('&&*it2 == '(') {\n\t\t\tcmp('('); it++; it2++; cout << '(';\n\t\t\ta();\n\t\t\tcmp(')'); it++; it2++; cout << ')';\n\t\t\tcmp('['); it++; it2++; cout << '[';\n\t\t\tcout << (integer(it) + integer(it2));\n\t\t\tcmp(']'); it++; it2++; cout << ']';\n\t\t\tcmp('('); it++; it2++; cout << '(';\n\t\t\ta();\n\t\t\tcmp(')'); it++; it2++; cout << ')';\n\t\t}\n\t\telse {\n\t\t\tif (*it == '(') {\n\t\t\t\tit++;\n\t\t\t\ta();\n\t\t\t\tit++;\n\t\t\t\tit++;\n\t\t\t\tinteger(it);\n\t\t\t\tit++;\n\t\t\t\tit++;\n\t\t\t\ta();\n\t\t\t\tit++;\n\t\t\t}\n\t\t\tif (*it2 == '(') {\n\t\t\t\tit2++;\n\t\t\t\ta();\n\t\t\t\tit2++;\n\t\t\t\tit2++;\n\t\t\t\tinteger(it2);\n\t\t\t\tit2++;\n\t\t\t\tit2++;\n\t\t\t\ta();\n\t\t\t\tit2++;\n\t\t\t}\n\t\t}\n\t}\n\tint integer(Iter &it) {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nsigned main() {\n\tstring s1, s2; getline(cin, s1); getline(cin, s2);\n\ts1 += \"$\"; s2 += \"$\";\n\tParser P(s1.begin(), s2.begin());\n\tP.a();\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<iostream>\nusing namespace std;\nint yom;\n//AOJ2740??¨???(??´???????????????????????????????????£???????????¨?????????)\nclass tree{\npublic:\n\tint val,now;\n\ttree *left;\n\ttree *right;\n\ttree(){\n\t\tval=0;now=0;\n\t\tleft=NULL;;\n\t\tright=NULL;\n\t}\n\tvoid setval(int a){\n\t\tval=a;\n\t}\n\tvoid make_left(void){\n\t\tif(this->left!=NULL){cout<<\"??°???\"<<endl;throw(1);}\n\t\tthis->left=new tree;\n\t}\n\tvoid make_right(void){\n\t\tif(this->right!=NULL){cout<<\"??°???\"<<endl;throw(1);}\n\t\tthis->right=new tree;\n\t}\n\t~tree(){\n\t\t//cout<<\"??????????????????\"<<endl;\n\t\tdelete left;\n\t\tdelete right;\n\t}\n\tvoid confi_tree(string str){\n\t\twhile(-1){\n\t\t\tyom++;\n\t\t\tif(str[yom]==')'){return;}\n\t\t\telse if(str[yom]=='('&&now==0){make_left();left->confi_tree(str);}\n\t\t\telse if(str[yom]=='('&&now==1){make_right();right->confi_tree(str);}\n\t\t\telse if(str[yom]=='['){\n\t\t\t\tnow++;\n\t\t\t\twhile(-1){\n\t\t\t\t\tyom++;\n\t\t\t\t\tif(str[yom]==']'){break;}\n\t\t\t\t\tval*=10;\n\t\t\t\t\tval+=str[yom]-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid plus_tree(tree *Aki,tree *Bki){\n\t\tthis->val=Aki->val+Bki->val;\n\t\tif(Aki->left!=NULL&&Bki->left!=NULL){make_left();left->plus_tree(Aki->left,Bki->left);}\n\t\tif(Aki->right!=NULL&&Bki->right!=NULL){make_right();right->plus_tree(Aki->right,Bki->right);}\n\t}\n\tvoid show_tree(){\n\t\tif(this->left==NULL&&right==NULL){return;}\n\t\tprintf(\"(\");\n\t\tif(this->left!=NULL){this->left->show_tree();}\n\t\tprintf(\")\");\n\t\tprintf(\"[%d]\",this->val);\n\t\tprintf(\"(\");\n\t\tif(this->right!=NULL){this->right->show_tree();}\n\t\tprintf(\")\");\n\t}\n};\n\nint main(void){\n\tstring A,B,C;\n\ttree Aki;\n\ttree Bki;\n\ttree Cki;\n\tyom=-1;\n\tcin>>A>>B;\n\tA.push_back(')');\n\tB.push_back(')');\n\tyom=-1;\n\tAki.confi_tree(A);\n\tyom=-1;\n\tBki.confi_tree(B);\n\tCki.plus_tree(&Aki,&Bki);\n\tCki.show_tree();\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define repr(i, a, b) for (int i = (int)(a - 1); i >= b; i--)\n#define rep(i, n) repl(i, 0, n)\n#define each(itr, v) for (auto itr : v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(), (x).end()\n#define dbg(x) cout << #x \" = \" << x << endl\n#define dbgv(i, a, v) \\\n  rep(i, a) { cout << v[i] << ((i < a - 1) ? ' ' : '\\n'); }\n#define maxch(x, y) x = max(x, y)\n#define minch(x, y) x = min(x, y)\n#define uni(x) x.erase(unique(all(x)), x.end())\n#define exist(x, y) (find(all(x), y) != x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define INF INT_MAX / 3\n\nint p[1010000], q[1010000], ans[1010000];\n\nvoid toArray(string s, int *array, int rnum) {\n  if (s.size() == 0) return;\n  int l = 1, i = 1;\n  while (l > 0 && i < s.size()) {\n    if (s[i] == '(')\n      l++;\n    else if (s[i] == ')')\n      l--;\n    i++;\n  }\n  int j = i + 1, r = 0;\n  while ('0' <= s[j] && s[j] <= '9') {\n    r = r * 10 + (s[j] - '0');\n    j++;\n  }\n  array[rnum] = r;\n  toArray(s.substr(1, i - 2), array, rnum * 2 + 1);\n  toArray(s.substr(j + 2, s.size() - j - 3), array, rnum * 2 + 2);\n}\n\nstring toString(int *array, int rnum) {\n  if (array[rnum] == -1) return \"\";\n  string ret = \"(\";\n  ret += toString(array, rnum * 2 + 1);\n  ret += \")[\" + to_string(array[rnum]) + \"](\";\n  ret += toString(array, rnum * 2 + 2);\n  return ret + \")\";\n}\n\nint main() {\n  cin.sync_with_stdio(false);\n  memset(p, -1, sizeof(p));\n  memset(q, -1, sizeof(q));\n  memset(ans, -1, sizeof(ans));\n  string a, b;\n  cin >> a >> b;\n  toArray(a, p, 0), toArray(b, q, 0);\n  rep(i, 1010) {\n    if (p[i] > -1 && q[i] > -1) ans[i] = p[i] + q[i];\n  }\n  cout << toString(ans, 0) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n\ntuple<string,int,string> read(string s) {\n    assert(s.size());\n    int i = 0, n = s.size();\n    assert(s[i] == '(');\n    i++;\n    int dep = 1;\n    while (dep > 0) {\n        if (s[i] == '(') dep++;\n        if (s[i] == ')') dep--;\n        i++;\n    }\n    string L = s.substr(1,i-2);\n\n    assert(s[i] == '[');\n    i++;\n    int j = i;\n    while (isdigit(s[j])) j++;\n    assert(s[j] == ']');\n    int val = stoi(s.substr(i,j-i));\n    i = j+1;\n\n    assert(s[i] == '(');\n    i++;\n    j = i;\n    dep = 1;\n    while (dep > 0) {\n        if (s[i] == '(') dep++;\n        if (s[i] == ')') dep--;\n        i++;\n    }\n    assert(i == n);\n    string R = s.substr(j,i-1-j);\n    return make_tuple(L,val,R);\n}\n\n\nstring solve(string A, string B) {\n    if (A.empty() || B.empty()) return \"\";\n\n    string LA,RA,LB,RB;\n    int valA,valB;\n    tie(LA,valA,RA) = read(A);\n    tie(LB,valB,RB) = read(B);\n\n    auto L = solve(LA,LB);\n    int val = valA + valB;\n    auto R = solve(RA,RB);\n\n    stringstream ss;\n    ss << '(' << L << ')' << '[' << val << ']' << '(' << R << ')';\n    return ss.str();\n}\n\nint32_t main() {\n    string A,B; cin >> A >> B;\n    cout << solve(A,B) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator State;\n\nstruct node{\n    int item;\n    struct node *left, *right;\n};\n\nnode *make_node(){\n    node *d = new node;\n    d -> left = NULL;\n    d -> right = NULL;\n    return d;\n}\n\nint number(State &begin){\n    int ret = 0;\n    while (isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nnode *read(State &begin){\n    node *d = make_node();\n    begin++;\n    if (*begin != ')'){\n        d -> left = read(begin);\n    }\n    begin += 2;\n    d -> item = number(begin);\n    begin += 2;\n    if (*begin != ')'){\n        d -> right = read(begin);\n    }\n    begin++;\n    return d;\n}\n\nvoid out(node *d1, node *d2){\n    cout << \"(\";\n    if (d1 -> left != NULL && d2 -> left != NULL) out(d1 -> left, d2 -> left);\n    printf(\")[%d](\", d1 -> item + d2 -> item);\n    if (d1 -> right != NULL && d2 -> right != NULL) out(d1 -> right, d2 -> right);\n    cout << \")\";\n}\n\nint main() {\n    string s1, s2;\n    cin >> s1 >> s2;\n    node *r1, *r2;\n    State begin = s1.begin();\n    r1 = read(begin);\n    begin = s2.begin();\n    r2 = read(begin);\n    out(r1, r2);\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n \nstruct node{\n    int val;\n    node *lch,*rch;\n    node(int val):val(val){}\n};\n \nnode *make(string s){\n    int stk=0;\n    rep(i,s.size()){\n        if(s[i]=='(')stk++;\n        else if(s[i]==')')stk--;\n        else if(s[i]=='['){\n            if(stk)continue;\n            string l=s.substr(1,i-2);\n            int cur=i+1,val=0;\n            while(s[cur]!=']'){\n                val=val*10+s[cur]-'0';\n                cur++;\n            }\n            cur++;\n            string r=s.substr(cur+1,s.size()-cur-1);\n            node *t=new node(val);\n            t->lch=make(l);\n            t->rch=make(r);\n            return t;\n        }\n    }\n    return NULL;\n}\n \nstring tostring(int a){\n    stringstream ss;\n    ss<<a;\n    return ss.str();\n}\n \nstring dfs(node *s,node *t){\n    if(s==NULL||t==NULL)return \"\";\n    return \"(\"+dfs(s->lch,t->lch)+\")[\"+tostring(s->val+t->val)+\"](\"+dfs(s->rch,t->rch)+\")\";\n}\n \nsigned main(){\n    string S,T;\n    cin>>S>>T;\n    node *s=make(S);\n    node *t=make(T);\n    cout<<dfs(s,t)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define rep(i,m,n) for(int i = (m);i < (n);i++)\n#define P pair<int,int>\n#define pb push_back\n#define mk make_pair\nusing namespace std;\n#define Vec(a) vector <int> a\nconst int INF = 1 << 20;\nconst int MOD = 1e9+7;\n\n\n\nstring s1,s2;\nvector <P> p1;\nvector <P> p2;\nvector <P> p3;\n\nvoid dfs(int now, int count){\n  if(now >= s1.size()){\n    return;\n  }\n  if(s1[now] == '('){\n    dfs(now+1,count*2);\n  }\n  else if(s1[now] == ')'){\n    dfs(now+1,count/2);\n  }\n  else if(s1[now] == '['){\n    //cout << \"count : \" << count << endl;\n    int n = 0;\n    now++;\n    while(s1[now] != ']'){\n      n = 10*n + (s1[now] - '0');\n      now++;\n    }\n    p1.pb(mk(count,n));\n    dfs(now+2,count*2+1);\n  }\n  \n}\n\nvoid dfs2(int now, int count){\n  if(now >= s2.size()){\n    return;\n  }\n  if(s2[now] == '('){\n    dfs2(now+1,count*2);\n  }\n  else if(s2[now] == ')'){\n    dfs2(now+1,count/2);\n  }\n  else if(s2[now] == '['){\n    //cout << \"count : \" << count << endl;\n    int n = 0;\n    now++;\n    while(s2[now] != ']'){\n      n = 10*n + (s2[now] - '0');\n      now++;\n    }\n    p2.pb(mk(count,n));\n    dfs2(now+2,count*2+1);\n  }\n  \n}\n\nstring Stoi(int s){\n  string n = \"\";\n  while(s > 0){\n    n += (s%10 + '0');\n    s /= 10;\n  }\n  reverse(n.begin(),n.end());\n  return n;\n}\n\nstring dfs3(int x){\n  int num = -1;\n  REP(i,p3.size()){\n    if(p3[i].first == x){\n      num = i;\n      break;\n    }\n  }\n  \n  string r = \"\";\n  string l = \"\";\n  if(num == -1){\n    return r;\n  }\n  else{\n    r = dfs3(x*2);\n    l = dfs3(2*x+1);\n  }\n  \n  string res = \"(\" + r + \")[\" + Stoi(p3[num].second) + \"](\" + l + \")\";\n  return res;\n\n}\n\nint main(){\n  cin >> s1;\n  cin >> s2;\n  dfs(0,1);\n  dfs2(0,1);\n  \n  sort(p1.begin(),p1.end());\n  sort(p2.begin(),p2.end());\n  /*\n  REP(i,p1.size()){\n    cout << p1[i].first << \"  \" << p1[i].second << endl;\n  }\n  REP(i,p2.size()){\n    cout << p2[i].first << \"    \" << p2[i].second << endl; \n  }\n  \n  cout << \"!\" << endl;\n  */\n  int x = 0;\n  REP(i,p1.size()){\n    rep(j,x,p2.size()){\n      if(p1[i].first == p2[j].first){\n\tp3.pb(mk(p1[i].first , p1[i].second + p2[j].second));\n\tx = j;\n\tbreak;\n      }\n      else if(p1[i].first < p2[j].first){\n\tx = j;\n\tbreak;\n      }\n    }\n  }\n  /*\n  REP(i,p3.size()){\n    cout << p3[i].first << \"       \" << p3[i].second << endl;\n    }*/\n\n  \n\n  cout << dfs3(1) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nint number(string s, int &i) {\n    int res = 0;\n    while (isdigit(s[i])) {\n        res = 10 * res + (s[i] - '0');\n        ++i;\n    }\n    return res;\n}\n\nvoid dfs(string s, int &i, int lev, int idx, map<pii, int> &num) {\n    if (s[i] == ')') return;\n    ++i;\n    dfs(s, i, lev + 1, 2 * idx, num);\n    ++i;\n    ++i;\n    num[pii(lev, idx)] = number(s, i);\n    ++i;\n    ++i;\n    dfs(s, i, lev + 1, 2 * idx + 1, num);\n    ++i;\n}\n\nstring dfs2(int lev, int idx, map<pii, int> &num) {\n    if (!num.count(pii(lev, idx))) return \"\";\n    return \"(\" + dfs2(lev + 1, 2 * idx, num) + \")[\" + to_string(num[pii(lev, idx)]) + \"](\" + dfs2(lev + 1, 2 * idx + 1, num) + \")\";\n}\n\nvoid _main() {\n    string A, B;\n    cin >> A >> B;\n    map<pii, int> numA, numB, numC;\n    int i = 0;\n    dfs(A, i, 0, 0, numA);\n    i = 0;\n    dfs(B, i, 0, 0, numB);\n    for (auto p : numA) if (numB.count(p.first)) {\n        numC[p.first] = numA[p.first] + numB[p.first];\n    }\n    cout << dfs2(0, 0, numC) << endl;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\nusing State = string::const_iterator;\n\nint parseNumber(State& begin) {\n    int ret = 0;\n    while ('0' <= *begin and *begin <= '9') {\n        ret *= 10;\n        ret += *begin - '0';\n        ++begin;\n    }\n    return ret;\n}\n\nvoid parse(State& begin) {\n    if (*begin != '(') {\n        return;\n    }\n    assert(*begin == '(');\n    ++begin;\n    parse(begin);\n    assert(*begin == ')');\n    ++begin;\n    assert(*begin == '[');\n    ++begin;\n    parseNumber(begin);\n    assert(*begin == ']');\n    ++begin;\n    assert(*begin == '(');\n    ++begin;\n    parse(begin);\n    assert(*begin == ')');\n    ++begin;\n}\n\nstring parseTree(State& beginA, State& beginB) {\n    if (*beginA != '(' or *beginB != '(') {\n        parse(beginA);\n        parse(beginB);\n        return \"\";\n    }\n    string ret;\n    assert(*beginA == '(');\n    assert(*beginB == '(');\n    ++beginA, ++beginB;\n    ret += \"(\" + parseTree(beginA, beginB) + \")\";\n\n    assert(*beginA == ')');\n    assert(*beginB == ')');\n    ++beginA, ++beginB;\n    assert(*beginA == '[');\n    assert(*beginB == '[');\n    ++beginA, ++beginB;\n\n    int numA = parseNumber(beginA);\n    int numB = parseNumber(beginB);\n    ret += \"[\" + to_string(numA + numB) + \"]\";\n\n    assert(*beginA == ']');\n    assert(*beginB == ']');\n    ++beginA, ++beginB;\n    assert(*beginA == '(');\n    assert(*beginB == '(');\n    ++beginA, ++beginB;\n    ret += \"(\" + parseTree(beginA, beginB) + \")\";\n\n    assert(*beginA == ')');\n    assert(*beginB == ')');\n    ++beginA, ++beginB;\n\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    // ifstream in(\"in.txt\");\n    // cin.rdbuf(in.rdbuf());\n\n    string A, B; cin >> A >> B;\n\n    State beginA = A.begin();\n    State beginB = B.begin();\n\n    string ans = parseTree(beginA, beginB);\n    cout << ans << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//木を実装する\ntypedef struct _node{\n    int element;\n    struct _node *left;\n    struct _node *right;\n    struct _node *par;\n}node;\n\ntypedef struct _tree{\n    node *root;\n}tree;\n\n//リストを生成する関数\ntree *create(){\n    tree *T = (tree *)malloc(sizeof(tree));\n    T->root = (node *)malloc(sizeof(node));\n    T->root->left = NULL;\n    T->root->right = NULL;\n    T->root->par = NULL;\n    T->root->element = -1;\n    return T;\n}\n\nvoid make_tree(tree *T, string s){\n    node *ptr = T->root;\n\n    for(int i = 0; i < (int) s.size(); i++){\n\n        if(s[i] == '('){\n            //どっちかににノードを足す\n            node *add = (node *)malloc(sizeof(node));\n            add->element = -1;\n            add->left = NULL;\n            add->right = NULL;\n            add->par = ptr;\n\n            //左\n            if(ptr->left == NULL){\n                ptr->left = add;\n                ptr = add;\n            }else{\n                ptr->right = add;\n                ptr = add;\n            }\n        }else if(s[i] == ')'){\n            //戻る\n            ptr = ptr->par;\n        }else if(s[i] == '['){\n            string str;\n            int j;\n            for(j = i + 1; s[j] != ']'; j++) str.push_back(s[j]);\n            int num = stoi(str);\n            ptr->element = num;\n            i = j;\n        }\n    }\n}\n\nvoid print_tree(node *v){\n    if(v == NULL || v->element == -1){\n        cout << \")\";\n        return;\n    }\n\n    cout << \"(\";\n    print_tree(v->left);\n    cout << \"[\" << v->element << \"]\";\n    cout << \"(\";\n    print_tree(v->right);\n    if(v->par != NULL) cout << \")\";\n    return;\n}\n\nvoid sum_tree(node *v1, node *v2, node *v3){\n    v3->element = v1->element + v2->element;\n\n    if(v1->left != NULL && v2->left != NULL && v1->left->element != -1 && v2->left->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->left = add;\n        sum_tree(v1->left, v2->left, v3->left);\n    }\n    \n    if(v1->right != NULL && v2->right != NULL && v1->right->element != -1 && v2->right->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->right = add;        \n        sum_tree(v1->right, v2->right, v3->right);\n    }\n    \n    //if(v->par != NULL) cout << \")\";\n    return;\n    \n}\n\nint main(){\n\n    string s1, s2; cin >> s1 >> s2;\n    tree *T1 = create();\n    tree *T2 = create();\n    tree *T3 = create();    \n    make_tree(T1, s1);\n    make_tree(T2, s2);\n    sum_tree(T1->root, T2->root, T3->root); \n    print_tree(T3->root);\n    cout << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n\n    Node(int _x, Node* _left = NULL, Node* _right = NULL) :\n        val(_x), left(_left), right(_right){}\n\n    string to_str() {\n        string ret = \"[\"+to_string(this->val)+\"]\";\n\n        if (this->left != NULL)\n            ret = \"(\" + this->left->to_str() + \")\" + ret;\n        else\n            ret = \"()\" + ret;\n        if (this->right != NULL)\n            ret += \"(\" + this->right->to_str() + \")\";\n        else\n            ret += \"()\";\n\n        return ret;\n    }\n};\n\nNode* parse_tree(string s) {\n    if (s == \"\") return NULL;\n\n    int kakko = 1;\n    int left_idx = 1; // left: [0, left_idx]\n    while (kakko) {\n        if (s[left_idx] == '(') kakko++;\n        if (s[left_idx] == ')') kakko--;\n        left_idx++;\n    }\n    string left_s = s.substr(1, left_idx - 2);\n\n    int num_idx = left_idx + 2; // number: [left_idx + 1, num_idx];\n    while (s[num_idx] != ']') num_idx++;\n    int number = atoi(s.substr(left_idx + 1, num_idx - left_idx - 1).c_str());\n    string right_s = s.substr(num_idx + 2, s.size() - num_idx - 3);\n\n    auto left = parse_tree(left_s);\n    auto right = parse_tree(right_s);\n\n    Node* node = new Node(number, left, right);\n    return node;\n}\n\nNode* add_tree(Node* a, Node* b) {\n    Node* left = NULL;\n    Node* right = NULL;\n\n    if (a->left != NULL && b->left != NULL) {\n        left = add_tree(a->left, b->left);\n    }\n\n    int ans = b->val + a->val;\n\n    if (a->right != NULL && b->right != NULL) {\n        right = add_tree(a->right, b->right);\n    }\n\n    Node* node = new Node(ans, left, right);\n    return node;\n}\n\nint main() {\n    string a, b;\n    cin >> a >> b;\n    auto first = parse_tree(a);\n    auto second = parse_tree(b);\n\n    cout << add_tree(first, second)->to_str() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <memory>\nusing namespace std;\n\nclass tree {\npublic:\n    tree(int v) : val(v), l(nullptr), r(nullptr) {}\n    string print() {\n        return \"(\" + (l ? l->print() : \"\") + \")[\" + to_string(val) + \"](\" + (r ? r->print() : \"\") + \")\";\n    }\n    tree& operator+(tree const& other) {\n        val += other.val;\n        if(!l || !other.l) {\n            l = nullptr;\n        } else {\n            *l = *l + *other.l;\n        }\n        if(!r || !other.r) {\n            r = nullptr;\n        } else {\n            *r = *r + *other.r;\n        }\n        return *this;\n    }\n    int val;\n    shared_ptr<tree> l, r;\n};\n\nint number(string const& s, int& p) {\n    int res = 0;\n    while(isdigit(s[p])) {\n        res *= 10;\n        res += s[p] - '0';\n        p += 1;\n    }\n    return res;\n}\n\nshared_ptr<tree> parse(string const& s, int& p) {\n    shared_ptr<tree> res(new tree(0));\n    if(s[p+1] == ')') {\n        p += 1;\n    } else {\n        res->l = parse(s, ++p);\n    }\n    p += 2;\n    res->val = number(s, p);\n    p += 1;\n    if(s[p+1] != ')') {\n        res->r = parse(s, ++p);\n        p += 1;\n    } else {\n        p += 2;\n    }\n    return res;\n}\n\nint main() {\n    string s1, s2;\n    cin >> s1 >> s2;\n    int p = 0;\n    auto t1 = parse(s1, p);\n    p = 0;\n    auto t2 = parse(s2, p);\n    cout << (*t1 + *t2).print() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100000\nusing namespace std;\nint AT[N],BT[N];\n\nbool check(int s,int t, string &str){\n  stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')'&&st.empty())return 0;  \n    if(str[i]==')') st.pop();\n  }\n  return st.empty();\n}\n\nint get_num(string &str,int &idx){\n  int res=0;\n  while(isdigit(str[idx]))res=res*10+str[idx++]-'0';\n  return res;\n}\n\n\nint get_root(int s,int t,string &str){\n  \n   stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(st.empty()&&isdigit(str[i])) return i;\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')') st.pop();\n  }\n  return -1;\n  assert(0);\n}\n\n\nvoid make_tree(int s,int t,int tree[N],string &str,int idx){\n  while(s<t&&check(s,t,str)) s++,t--;\n  if(s>=t)return;\n  s--,t++;\n\t\t\t  \n\n  int root=get_root(s,t,str);\n  if(root==-1)return;\n  //  cout <<idx<<\" \"<<root<<endl;\n  //for(int i=s;i<=t;i++) cout <<str[i];cout<<endl;\n  make_tree(s,root-2,tree,str,idx*2+1);\n  tree[idx]=get_num(str,root);\n  make_tree(root+1,t,tree,str,idx*2+2);\n}\n\nstring make_str(int k){\n  if(AT[k]<0||BT[k]<0) return \"\";\n  int num=AT[k]+BT[k];\n  string str;\n  while(num) str=(char)((num%10)+'0')+str,num/=10;\n  return \"(\"+make_str(k*2+1)+\")\"+\"[\"+str+\"]\"+\"(\"+make_str(k*2+2)+\")\";\n}\n\nint main(){\n  string A,B;\n  cin>>A>>B;\n  memset(AT,-1,sizeof(AT));\n  memset(BT,-1,sizeof(BT));\n  make_tree(0,A.size()-1,AT,A,0);\n  make_tree(0,B.size()-1,BT,B,0);\n  cout <<make_str(0)<<endl;  \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst long double PI = acos(-1);\nconstexpr long double EPS = 1e-15;\nconstexpr int inf = 2e9;\nconstexpr ll INF = 2e18;\nconstexpr ll MOD = 1e9+7;\nconstexpr ll MOD1 = 998244353;\ntypedef pair<ll,ll> P;\n\n//#define all(v) (v).begin(), (v).end()\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) rep(i,0,n)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n//#define mp make_pair\n\nstruct Tree{\n  int num = 0;\n  Tree *left;\n  Tree *right;\n  Tree() {\n    num = 0;\n    left = NULL;\n    right = NULL;\n  }\n  Tree(Tree *l,int m,Tree *r) {\n    num = m;\n    left = l;\n    right = r;\n  }\n};\n\n// void findroot(string s, int &k) {\n//   int cnt = 1;\n//   for (int i = 1; i < sz(s); i++) {\n//     if (s[i] == '(') cnt++;\n//     else if (s[i] == ')') cnt--;\n\n//     if (cnt == 0) {\n//       i+=2;\n//       int num = 0;\n//       while ('0' <= s[i] && s[i] <= '9') {\n//         num *= 10;\n//         num += (s[i] - '0');\n//         i++;\n//       }\n//       k = num;\n//       return;\n//     }\n//   }\n// }\n\nint k;\nTree *maketree(Tree *t, string s) {\n  Tree *tmp = new Tree();\n\n  int middle = 0;\n  k++;\n  if (s[k] == ')') ;\n  else tmp->left = maketree(t, s);\n  k += 2;\n\n  while ('0' <= s[k] && s[k] <= '9') {\n    middle *= 10;\n    middle += (s[k] - '0');\n    k++;\n  }\n  \n  k+=2;\n  if (s[k] == ')') ;\n  else tmp->right = maketree(t, s);\n  k++;\n\n  tmp->num = middle;\n  return tmp;\n}\n\nvoid dfs(Tree *t1, Tree *t2) {\n  cout << '(';\n  if (t1->left != NULL && t2->left != NULL) {\n    dfs(t1->left, t2->left);\n  }\n  cout << ')';\n  cout << '[';\n  cout << t1->num + t2->num;\n  cout << ']';\n  cout << '(';\n  if (t1->right != NULL && t2->right != NULL) {\n    dfs(t1->right, t2->right);\n  }\n  cout << ')';\n}\n\nvoid solve() {\n  string a,b;\n  int r1,r2;\n  cin >> a >> b;\n  Tree *t1 = new Tree();\n  Tree *t2 = new Tree();\n  k = 0;\n  t1 = maketree(t1,a);\n  k = 0;\n  t2 = maketree(t2,b);\n  dfs(t1,t2);\n  cout << endl;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  REP(i,n) {\n    solve();\n  }\n//  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass node {\npublic:\n    int id = 0;\n    node *left = 0, *right = 0;\n};\nnode* str_to_nod(string s) {\n    node* ret = new node();\n    int dep = 0, i = 0;\n    for (; i < s.length(); ++i) {\n        if (s[i] == '(') ++dep;\n        if (s[i] == ')') --dep;\n        \n        if (!dep) {\n            if (s[i] == ')') ret->left = (i > 1) ? str_to_nod(s.substr(1, i - 1)) : 0;\n    \n            if (s[i] == ']') {\n                ret->right = (i + 3 < s.length()) ? str_to_nod(s.substr(i + 2, s.length() - i - 3)) : 0;\n                return ret;\n            }\n            if (s[i] >= '0' && s[i] <= '9') ret->id = ret->id * 10 + s[i] - '0';\n        }\n    }\n}\nstring nod_to_str(node* par) {\n    return par ? \"(\" + nod_to_str(par->left) + \")[\" + to_string(par->id) + \"](\" + nod_to_str(par->right) + \")\" : \"\";\n}\nnode* compo(node* a, node* b) {\n    if (!a || !b) return 0;\n    \n    node* ret = new node();\n    ret->id = a->id + b->id;\n    ret->left = compo(a->left, b->left);\n    ret->right = compo(a->right, b->right);\n    return ret;\n}\nint main(){\n    string a, b;\n    cin >> a;\n    cin >> b;\n    cout << nod_to_str(compo(str_to_nod(a), str_to_nod(b))) + \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nvoid findNum(string &s,int a,int b,int &A,int &B){\n  int cnt=0;\n  for(int i=a;i<b;i++){\n    if(s[i]=='(')cnt++;\n    if(s[i]==')')cnt--;\n    if(cnt==0&&s[i]=='[')A=i;\n    if(cnt==0&&s[i]==']')B=i+1;\n  }\n}\n \nint getNum(string &s,int a,int b){\n  int num=0;\n  for(int i=a+1;i<b-1;i++)\n    num=num*10+(s[i]-'0');\n  return num;\n}\n \nvoid solve(string &s,string &t,int a,int b,int l,int r){\n  if(a==b||l==r)return;\n  int A,B,L,R;\n  findNum(s,a,b,A,B);\n  findNum(t,l,r,L,R);\n  int snum=getNum(s,A,B);\n  int tnum=getNum(t,L,R);\n   \n  cout<<'(';\n  solve(s,t,a+1,A-1,l+1,L-1);\n  cout<<')';\n     \n  cout<<'['<<snum+tnum<<']';\n \n  cout<<'(';\n  solve(s,t,B+1,b-1,R+1,r-1);\n  cout<<')';\n}\n \nint main(){\n  string s,t;\n  cin>>s>>t;\n  solve(s,t,0,s.size(),0,t.size());\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)s; i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\n\n#define LINE cout << \"Line : \" << __LINE__  << endl\n#define dump(X) cout << \"Line : \" << __LINE__  << \", \" << #X << \" : \" << X\n#define dumpln(X) dump(X) << endl\n\nusing State = string::iterator;\nstruct Node {\n  int num = -1;\n  int idx = 0;\n  int l = -1;\n  int r = -1;\n};\nvector<Node> nodes0;\nvector<Node> nodes1;\n\nvector<Node> nodes2;\n\nint synNodes(int id0, int id1) {\n  int id2 = nodes2.size();\n  nodes2.push_back(Node());\n  nodes2[id2].idx= id2;\n  if(nodes0[id0].num == -1 || nodes1[id1].num == -1) return id2;\n  nodes2[id2].num = nodes0[id0].num + nodes1[id1].num;\n  if(nodes0[id0].l != -1 && nodes1[id1].l != -1) {\n    auto tmp = synNodes(nodes0[id0].l, nodes1[id1].l);\n    nodes2[id2].l = tmp;\n  }\n  if(nodes0[id0].r != -1 && nodes1[id1].r != -1) {\n    auto tmp = synNodes(nodes0[id0].r, nodes1[id1].r);\n    nodes2[id2].r = tmp;\n  }\n  return id2;\n}\n\nstring output(int id) {\n  if(nodes2[id].num == -1) return \"()\";\n  string s = \"(\";\n  if(nodes2[id].l != -1) {\n    auto tmp = output(nodes2[id].l);\n    s += tmp;\n  }\n  s += \")\";\n  s += '[';\n  s += to_string(nodes2[id].num);\n  s += ']';\n  s += '(';\n  if(nodes2[id].r != -1) {\n    auto tmp = output(nodes2[id].r);\n    s += tmp;\n  }\n  s += ')';\n  return s;\n}\n\nint getNum(State& s) {\n  int ret = 0;\n  while(*s >= '0' && *s <= '9') {\n    ret *= 10;\n    ret += *s - '0';\n    ++s;\n  }\n  return ret;\n}\nvector<Node> nodes;\nint calc(State& s) {\n  int id = nodes.size();\n  nodes.push_back(Node());\n  nodes[id].idx = id;\n  assert(*s == '(');\n  ++s;\n  if(*s != ')') {\n    int tmp = calc(s);\n    nodes[id].l = tmp;\n  }\n  ++s;\n  ++s;\n  nodes[id].num = getNum(s);\n  ++s;\n  ++s;\n  if(*s != ')') {\n    int tmp = calc(s);\n    nodes[id].r = tmp;\n  }\n  ++s;\n  return id;\n}\n\nint main() {\n  string s, t;\n  cin >> s >> t;\n  //  dumpln(s);\n  //  dumpln(t);\n  \n  auto it0 = s.begin();\n  auto it1 = t.begin();\n  int par0 = calc(it0);\n  nodes0 = nodes;\n  nodes.clear();\n\n  // dumpln(nodes0.size());\n  // rep(i, nodes0.size()) {\n  //   dumpln(nodes0[i].idx);\n  //   dumpln(nodes0[i].num);\n  //   dumpln(nodes0[i].l);\n  //   dumpln(nodes0[i].r);\n  // }\n\n  //dumpln(\"------------\");\n  \n  int par1 = calc(it1);\n  nodes1 = nodes;\n  nodes.clear();\n  \n  // dumpln(nodes1.size());\n  // rep(i, nodes1.size()) {\n  //   dumpln(nodes1[i].idx);\n  //   dumpln(nodes1[i].num);\n  //   dumpln(nodes1[i].l);\n  //   dumpln(nodes1[i].r);\n  // }\n\n  \n  int par2 = synNodes(par0, par1);\n  cout << output(par2) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define rep(i,m,n) for(int i = (m);i < (n);i++)\n#define P pair< pair<ll,ll> ,ll>\n#define pb push_back\n#define mk make_pair\nusing namespace std;\n#define Vec(a) vector <int> a\nconst int INF = 1 << 20;\nconst int MOD = 1e9+7;\n\nstring s1,s2;\nvector <P> p1;\nvector <P> p2;\nvector <P> p3;\n\nvoid dfs(ll now, ll count, ll depth){\n  //cout << \"count : \" <<  count << endl;\n  if(now >= s1.size()){\n    return;\n  }\n  if(s1[now] == '('){\n    dfs(now+1,(count)*2-1,depth+1);\n  }\n  else if(s1[now] == ')'){\n    dfs(now+1,(count+1)/2,depth-1);\n  }\n  else if(s1[now] == '['){\n    //cout << \"count : \" << count << endl;\n    ll n = 0;\n    now++;\n    while(s1[now] != ']'){\n      n = 10*n + (s1[now] - '0');\n      now++;\n    }\n    p1.pb(mk(mk(depth,count),n));\n    dfs(now+2,count*2,depth+1);\n  }\n  \n}\n\nvoid dfs2(ll now, ll count, ll depth){\n  //cout << \"count : \" <<  count << endl;\n  if(now >= s2.size()){\n    return;\n  }\n  if(s2[now] == '('){\n    dfs2(now+1,(count)*2-1,depth+1);\n  }\n  else if(s2[now] == ')'){\n    dfs2(now+1,(count+1)/2,depth-1);\n  }\n  else if(s2[now] == '['){\n    //cout << \"count : \" << count << endl;\n    ll n = 0;\n    now++;\n    while(s2[now] != ']'){\n      n = 10*n + (s2[now] - '0');\n      now++;\n    }\n    p2.pb(mk(mk(depth,count),n));\n    dfs2(now+2,count*2,depth+1);\n  }\n  \n}\n\nstring Stoi(ll s){\n  string n = \"\";\n  while(s > 0){\n    n += (s%10 + '0');\n    s /= 10;\n  }\n  reverse(n.begin(),n.end());\n  return n;\n}\n\nstring dfs3(pair <ll,ll> x){\n  ll num = -1;\n  REP(i,p3.size()){\n    if(p3[i].first == x){\n      num = i;\n      break;\n    }\n  }\n  \n  string r = \"\";\n  string l = \"\";\n  if(num == -1){\n    return r;\n  }\n  else{\n    x.first++;\n    x.second = x.second*2-1;\n    r = dfs3(x);\n    x.second++;\n    l = dfs3(x);\n  }\n  \n  string res = \"(\" + r + \")[\" + Stoi(p3[num].second) + \"](\" + l + \")\";\n  return res;\n\n}\n\n\nint main(){\n  cin >> s1;\n  cin >> s2;\n  dfs(0,1,0);\n  dfs2(0,1,0);\n  sort(p1.begin(),p1.end());\n  sort(p2.begin(),p2.end());\n  /*\n  REP(i,p1.size()){\n     cout << p1[i].first.first << \"  \" << p1[i].first.second << \"  \" << p1[i].second << endl;\n  }\n   REP(i,p2.size()){\n     cout << p2[i].first.first << \"  \" << p2[i].first.second << \"  \" << p2[i].second << endl;\n     }*/\n   int x = 0;\n   REP(i,p1.size()){\n    rep(j,x,p2.size()){\n      if(p1[i].first == p2[j].first){\n\tp3.pb(mk(p1[i].first , p1[i].second + p2[j].second));\n\tx = j;\n\tbreak;\n      }\n      else if(p1[i].first < p2[j].first){\n\tx = j;\n\tbreak;\n      }\n    }\n   }\n   /*\n   REP(i,p3.size()){\n     cout << p3[i].first.first << \"  \" << p3[i].first.second << \"  \" << p3[i].second << endl;\n     }*/\n   pair <ll,ll> p;\n   p.first = 0;\n   p.second = 1;\n   /*\n   string t = dfs3(p);\n   string e = \"(()[6]())[8](((()[4]())[7]())[9]())\";\n   REP(i,t.size()){\n     if(t[i] != e[i]){\n       cout << i << endl;\n     }\n     }*/\n   cout << dfs3(p) << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n\nusing namespace std;\n\nenum TYPE{\n\tNONE,\n\tFIRST,\n\tSECOND,\n\tLEFT,\n\tRIGHT\n};\n\nint first[10000],second[10000],third[10000];\nchar buf[1010];\n\nTYPE toWrite;\n\n//left_or_right???LEFT????????????????????¢?????¬??????2*parent_address+1,RIGHT??????parent_address+2\nvoid recursive(int left,int right,int parent_address,TYPE left_or_right){\n\tint calcDepth,nextRight,nextLeft,tmp,nextParentAddress = -1;\n\tif(parent_address != -1){\n\t\tcalcDepth = 0; //??????????????±???\n\t\tfor(int i = left,k=0; i <= right; i++){\n\n\t\t\tif(calcDepth==0 && buf[i] == '['){ //???\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextRight = i-1;\n\t\t\t\tnextLeft = k+1;\n\t\t\t\tbreak; //???????????????????????????????????±???0???1??????????????¨???????????????????????§break;\n\t\t\t}else if(calcDepth==0 && buf[i] == '(' && buf[i+1] >= '0' && buf[i+1] <= '9'){ //???<?????????>\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ')';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\t}\n\t\t}\n\n\t\tif(nextParentAddress != -1){\n\t\t\tif(left+1 < nextRight-1){\n\t\t\t\trecursive(left+1,nextRight-1,nextParentAddress,LEFT);\n\t\t\t}\n\t\t\tif(nextLeft+1 < right-1){\n\t\t\t\trecursive(nextLeft+1,right-1,nextParentAddress,RIGHT);\n\t\t\t}\n\t\t}\n\n\t}else{ //???????????´???\n\t\tcalcDepth = 0; //??¶???????????±???\n\t\tfor(int i = 0,k=0; i <= right; i++){\n\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\telse{\n\t\t\t\tif(calcDepth==0 && buf[i] == '['){ //????????????????????????\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\t\tfirst[0] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[0] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tnextRight = i-1;\n\t\t\t\t\tnextLeft = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(left+1 < nextRight-1){\n\t\t\trecursive(left+1,nextRight-1,0,LEFT);\n\t\t}\n\t\tif(nextLeft+1 < right-1){\n\t\t\trecursive(nextLeft+1,right-1,0,RIGHT);\n\t\t}\n\t}\n}\n\nvoid outPut(int address){\n\n\tif(third[2*address+1] != -1 || third[2*address+2] != -1){//??????????????´???\n\t\tif(third[2*address+1] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+1);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t\tprintf(\"[%d]\",third[address]);\n\t\tif(third[2*address+2] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+2);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t}else{ //?????????????????´???\n\t\tprintf(\"()[%d]()\",third[address]);\n\t}\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 10000; i++){\n\t\tfirst[i] = -1;\n\t\tsecond[i] = -1;\n\t\tthird[i] = -1;\n\t}\n\n\tscanf(\"%s\",buf);\n\tint length;\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = FIRST;\n\trecursive(0,length-1,-1,NONE);\n\n\tscanf(\"%s\",buf);\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = SECOND;\n\trecursive(0,length-1,-1,NONE);\n\n\tfor(int i = 0; i < 10000; i++){\n\t\tif(first[i] != -1 && second[i] != -1){\n\t\t\tthird[i] = first[i]+second[i];\n\t\t}else{\n\t\t\tthird[i] = -1;\n\t\t}\n\t}\n\n\toutPut(0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define repr(i, a, b) for (int i = (int)(a - 1); i >= b; i--)\n#define rep(i, n) repl(i, 0, n)\n#define each(itr, v) for (auto itr : v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(), (x).end()\n#define dbg(x) cout << #x \" = \" << x << endl\n#define dbgv(i, a, v) \\\n  rep(i, a) { cout << v[i] << ((i < a - 1) ? ' ' : '\\n'); }\n#define maxch(x, y) x = max(x, y)\n#define minch(x, y) x = min(x, y)\n#define uni(x) x.erase(unique(all(x)), x.end())\n#define exist(x, y) (find(all(x), y) != x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define INF INT_MAX / 3\n\nint rp, rq, rans;\nint p[1010][1010][2], q[1010][1010][2], ans[1010][2020][2];\n\nint toArray(string s, int h, bool f) {\n  if (s.size() == 0) return -1;\n  int l = 1, i = 1;\n  while (l > 0 && i < s.size()) {\n    if (s[i] == '(')\n      l++;\n    else if (s[i] == ')')\n      l--;\n    i++;\n  }\n  int j = i + 1, r = 0;\n  while ('0' <= s[j] && s[j] <= '9') {\n    r = r * 10 + (s[j] - '0');\n    j++;\n  }\n  if (f) {\n    p[h][r][0] = toArray(s.substr(1, i - 2), h + 1, true);\n    p[h][r][1] = toArray(s.substr(j + 2, s.size() - j - 3), h + 1, true);\n  } else {\n    q[h][r][0] = toArray(s.substr(1, i - 2), h + 1, false);\n    q[h][r][1] = toArray(s.substr(j + 2, s.size() - j - 3), h + 1, false);\n  }\n  return r;\n}\n\nint combine(int a, int b, int h) {\n  if (a != -1 && b != -1) {\n    int r = a + b;\n    ans[h][r][0] = combine(p[h][a][0], q[h][b][0], h + 1);\n    ans[h][r][1] = combine(p[h][a][1], q[h][b][1], h + 1);\n    return r;\n  } else {\n    return -1;\n  }\n}\n\nstring toString(int r, int h) {\n  if (r == -1) return \"\";\n  string ret = \"(\";\n  ret += toString(ans[h][r][0], h + 1);\n  ret += \")[\" + to_string(r) + \"](\";\n  ret += toString(ans[h][r][1], h + 1);\n  return ret + \")\";\n}\n\nint main() {\n  cin.sync_with_stdio(false);\n  memset(p, -1, sizeof(p));\n  memset(q, -1, sizeof(q));\n  memset(ans, -1, sizeof(ans));\n  string a, b;\n  cin >> a >> b;\n  rp = toArray(a, 0, true), rq = toArray(b, 0, false);\n  rans = combine(rp, rq, 0);\n  cout << toString(rans, 0) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nstruct Node {\n    Node *ch[2];\n    int num;\n};\n\nint number(char *&p) {\n    int res = 0;\n    while (isdigit(*p)) {\n        res *= 10;\n        res += *p - '0';\n        ++p;\n    }\n    return res;\n}\n\nNode *tree(char *&p) {\n    Node *res = new Node;\n    for (int i = 0; i < 2; i++) {\n        if (i) {\n            ++p;\n            res->num = number(p);\n            ++p;\n        }\n        if (p[1] == ')') {\n            ++p;\n            res->ch[i] = nullptr;\n            ++p;\n        } else {\n            ++p;\n            res->ch[i] = tree(p);\n            ++p;\n        }\n    }\n    return res;\n}\n\nvoid print(Node *s, Node *t) {\n    printf(\"(\");\n    for (int i = 0; i < 2; i++) {\n        if (i) {\n            printf(\")[%d](\", s->num + t->num);\n        }\n        if (s->ch[i] && t->ch[i]) {\n            print(s->ch[i], t->ch[i]);\n        }\n    }\n    printf(\")\");\n}\n\nint main() {\n    char s[1010], t[1010];\n    cin >> s >> t;\n    char *ss = s, *tt = t;\n    print(tree(ss), tree(tt));\n    cout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ALL(x) x.begin(), x.end()\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\nrandom_device rnd;\nmt19937 mt(rnd());\nusing ll = long long;\nusing lld = long double;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing PII = pair<int, int>;\nconst int IINF = 1 << 30;\nconst ll INF = 1ll << 60;\nconst ll MOD = 1000000007;\n\nint nodeNum(string &s)\n{\n    if (s == \"\")\n    {\n        return -1;\n    }\n\n    int cur = 1;\n    assert(s[0] == ('('));\n    for (int i = 1; i < s.size(); i++)\n    {\n        if (s[i] == '(')\n            cur++;\n        if (s[i] == ')')\n            cur--;\n        if (cur == 0 && isdigit(s[i]))\n        {\n            string ret = \"\";\n            while (isdigit(s[i]))\n            {\n                ret += s[i];\n                i++;\n            }\n            return stoi(ret);\n        }\n    }\n    return -1;\n}\n\nstring right(string &s)\n{\n    string ret = \"\";\n    int cur = -1;\n    rep(i, 1, s.size())\n    {\n        if (s[s.size() - 1 - i] == '(')\n            cur++;\n        if (s[s.size() - 1 - i] == ')')\n            cur--;\n\n        if (cur == 0)\n            break;\n        ret = s[s.size() - 1 - i] + ret;\n    }\n    return ret;\n}\nstring left(string &s)\n{\n    string ret = \"\";\n    int cur = 1;\n    rep(i, 1, s.size())\n    {\n        if (s[i] == '(')\n            cur++;\n        if (s[i] == ')')\n            cur--;\n\n        if (cur == 0)\n            break;\n        ret += s[i];\n    }\n    return ret;\n}\n\nstring calc(string a, string b)\n{\n    int x = nodeNum(a);\n    int y = nodeNum(b);\n    if (x == -1 || y == -1)\n    {\n        return \"\";\n    }\n    return \"(\" + calc(left(a), left(b)) + \")[\" + to_string(x + y) + \"](\" + calc(right(a), right(b)) + \")\";\n}\n\nint main()\n{\n\n    string a, b;\n    cin >> a >> b;\n    cout << calc(a, b) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define llong long long\n\nusing namespace std;\n\n// root ::= '(' node ')[' inum '](' node ')'\n// node ::= ep | '(' node ')[' inum '](' node ')'\n\nstruct node{\n\tint n;\n\tunique_ptr<node> left, right;\n\tnode() = default;\n\tnode(node&& c):n(c.n),left(move(c.left)),right(move(c.right)){}\n\tnode(int n_):n(n_){}\n\n\tbool operator==(const node &rhs)const {\n\t\treturn *left == *(rhs.left) && *right == *(rhs.right);\n\t}\n\tvoid print(){\n\t\tcout << \"(\";\n\t\tif(left)left->print();\n\t\tcout << \")[\" << n << \"](\";\n\t\tif(right)right->print();\n\t\tcout << \")\";\n\t}\n};\n\nstruct parser{\n\tstring str;\n\tparser(const string &str_):str(str_){}\n\tnode parse(){return root(); }\n\tnode root(){\n\t\tnode ret;\n\t\tsize_t idx = 0;\n\t\tassert(str[idx] == '(');\n\t\tret.left = child(++idx);\n\t\tassert(str[idx] == ')');\n\t\tidx += 2;\n\t\tassert(isdigit(str[idx]));\n\t\tret.n = inum(idx);\n\t\tassert(str[idx] == ']');\n\t\tidx += 2;\n\t\tret.right = child(idx);\n\t\tassert(str[idx] == ')');\n\t\treturn ret;\n\t}\n\n\tunique_ptr<node> child(size_t &idx){\n\t\tif(str[idx] == ')')return nullptr;\n\t\tassert(str[idx] == '(');\n\t\tunique_ptr<node> ret(new node());\n\t\tret->left = child(++idx);\n\t\tassert(str[idx] == ')');\n\t\tidx += 2;\n\t\tassert(isdigit(str[idx]));\n\t\tret->n = inum(idx);\n\t\tassert(str[idx] == ']');\n\t\tidx += 2;\n\t\tret->right = child(idx);\n\t\tassert(str[idx] == ')');\n\t\tidx++;\n\t\treturn ret;\n\t}\n\n\tint inum(size_t &idx){\n\t\tint i = idx;\n\t\twhile(isdigit(str[idx]))idx++;\n\t\treturn stoi(str.substr(i, idx-i));\n\t}\n};\n\nnode gattai(const node &left, const node &right){\n\tnode ret(left.n + right.n);\n\tif(left.left && right.left){\n\t\tret.left = unique_ptr<node>(new node(gattai(*left.left, *right.left)));\n\t}\n\tif(left.right && right.right){\n\t\tret.right = unique_ptr<node>(new node(gattai(*left.right, *right.right)));\n\t}\n\treturn ret;\n}\n\nsigned main(){\n\tstring s1,s2; cin >> s1 >> s2;\n\tparser p1(s1),p2(s2);\n\tnode l(p1.parse()), r(p2.parse());\n\tauto ans = gattai(l,r);\n\tans.print();\n\tcout << endl;\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_, *right;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator Begin, Iterator End) {\n  if (Begin == End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin; *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto *at = CreateTree(a.begin(), a.end()), *bt = CreateTree(b.begin(), b.end());\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y,h;\n                                        \tpas(int x=0,int y=0,int h=0):x(x),y(y),h(h) {}\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            /*\n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\ntypedef struct node{\nnode* left;\n\tnode* right;\n\tint val;\n}node;\n \nnode* new_node(){\n\tnode *n=new node;\n\tn->left=NULL;\n\tn->right =NULL;\n\tn->val=0;\n\treturn n;\n \n}\nvoid make_node(node* v,string s){\n//\tcout<<s<<endl;\n\tint l=s.length();\n\tint it,cn=0;\n\tfor( it=0;it<l;it++){\n\t\tif(s[it]=='(')cn++;\n\t\tif(s[it]==')')cn--;\n\t\t\n\t\tif(cn==0 && s[it]=='[') break;\n\t}\n\tif(it!=2){\n\tstring s2=s.substr(1,it-2);\n\t\tnode* h=new_node();\n\t\tmake_node(h,s2);\n\tv->left=h;\n\t//\tcout<<s2<<endl;\n\t\t\n\t}\n\tint r=0;\n\tit++;\n\twhile(s[it]<='9' && s[it]>='0'){\n\t\tr*=10;\n\t\tr+= s[it]-'0';\n\t\tit++;\n\t}\n\t//cout<<r<<endl;\n\tv->val=r;\n\t\n\tstring s22=s.substr(it+1);\n\t//cout<<s22<<endl;\n\tif(s22.length()>2){\n\t\tint l2=s22.length();\n\t\tnode* hh=new_node();\n\t\tmake_node(hh,s22.substr(1,l2-2));\n\t\tv->right=hh;\n\t\t\n\t\t\n\t}\n\t\n}\n\nvoid cul(node* v3,node* v1,node* v2){\n\tv3->val=v1->val + v2->val;\n\t\n\tif(v1->left !=NULL && v2->left !=NULL ){\n\t\tnode* vl=new_node();\n\t\tcul(vl,v1->left,v2->left);\n\t\tv3->left=vl;\n\t}\n\tif(v1->right !=NULL && v2->right !=NULL ){\n\t\tnode* vl=new_node();\n\t\tcul(vl,v1->right,v2->right);\n\t\tv3->right =vl;\n\t}\n}\nvoid saiki(node* v){\n\tcout<<\"(\";\n\t\tif(v->left!=NULL)saiki(v->left);\n\t\tcout<<\")[\";\n\tcout<<v->val;\n\tcout<<\"](\";\n\t\tif(v->right!=NULL)saiki(v->right);\n\t\tcout<<\")\";\n}\n   signed main(){\n   \t\n   string s1,s2;\n   \tcin>>s1>>s2;\n   \t\n   \tnode* v1=new_node();\n   \tnode* v2=new_node();\n   \t\n   \tmake_node(v1,s1);\n   \tmake_node(v2,s2);\n   \t\n   \tnode* v3=new_node();\n   \tcul(v3,v1,v2);\n   \tsaiki(v3);\n   \tcout<<endl;\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nclass ki{public:\n\tint num;\n\tki *hi,*mg;\n\tki(void){hi=nullptr;mg=nullptr;num=0;}\n\tvoid output(void){\n\t\tcout<<'(';\n\t\tif(hi!=nullptr){hi->output();}\n\t\tcout<<\")[\"<<num<<\"](\";\n\t\tif(mg!=nullptr){mg->output();}\n\t\tcout<<')';\n\t}\n};\nstring str;\nint ban;\nki* solve(void){\n\t\n\tif(str[ban]==')'){return nullptr;}\n\tki* ans=new ki();\n\tban++;\n\tans->hi=solve();\n\tban+=2;\n\t//数字\n\twhile(str[ban]!=']'){ans->num*=10;ans->num+=str[ban]-'0';ban++;}\n\tban+=2;\n\tans->mg=solve();\n\tban++;\n\treturn ans;\n}\nki* tasu(ki* a,ki* b){\n\tif(a==nullptr||b==nullptr){return nullptr;}\n\tki* ans=new ki();\n\tans->num=a->num+b->num;\n\tans->hi=tasu(a->hi,b->hi);\n\tans->mg=tasu(a->mg,b->mg);\n\treturn ans;\n}\n\nint main(void){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tstring S,T;cin>>S>>T;\n\tstr=S;ban=0;\n\tauto ss=solve();\n\t\n\tstr=T;ban=0;\n\tauto tt=solve();\n\ttasu(ss,tt)->output();cout<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\nusing namespace std;\n\nstruct Node{\n    Node* left;\n    Node* right;\n    int val;\n};\n\nNode* newNode(int x){\n    Node* cur = (Node*)malloc(sizeof(Node));\n    cur->val = x;\n    cur->left = NULL;\n    cur->right = NULL;\n    return cur;\n}\n\nvoid print(Node* x){\n    cout << \"(\";\n    if(x->left != NULL)     print(x->left);\n    cout << \")[\" << x->val << \"](\";\n    if(x->right != NULL)    print(x->right);\n    cout << \")\";\n}\n\nNode* dfs(int &pos, const string &s){\n    if(s[pos] != '('){\n        return NULL;\n    }\n    pos++;  // (\n    Node* root = newNode(-1);\n    root->left = dfs(pos, s);\n    pos++;  // )\n    pos++;  // [\n    int num = 0;\n    while(isdigit(s[pos])){\n        num = num*10 + s[pos++]-'0';\n    }\n    root->val = num;\n    pos++;  // ]\n    pos++;  // (\n    root->right = dfs(pos, s);\n    pos++;  // )\n    return root;\n}\n\nNode* unite(Node* l, Node* r){\n    if(l == NULL || r == NULL)  return NULL;\n    Node* root = newNode(l->val + r->val);\n    root->left = unite(l->left, r->left);\n    root->right = unite(l->right, r->right);\n    return root;\n}\n\nint main(){\n    string a, b;\n    cin >> a >> b;\n\n    int pos = 0;\n    Node* roota = dfs(pos, a);\n    pos = 0;\n    Node* rootb = dfs(pos, b);\n\n    Node* ret = unite(roota, rootb);\n\n    print(ret);\n    cout << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct no{\n  long int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nint n;\nstring s1[2];\nvector<long int>v[2];\nvoid v_make(int t){\n  v[t].push_back('(');\n  for(int i=0;i<s1[t].size();i++){\n    if(!isdigit(s1[t][i]))v[t].push_back(s1[t][i]);\n    else{\n      int p=s1[t][i]-'0';\n      while(isdigit(s1[t][i+1]))p*=10,p+=s1[t][++i]-'0';\n      v[t].push_back(p+100);\n    }\n  }\n  v[t].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1;\n  for(int i=l+1;i<r;i++)\n    if((char)v[n][i]=='(')p++;\n    else if((char)v[n][i]==')')p--;\n    else if(v[n][i]>=100&&!p){\n      c=i;\n      po->key=v[n][i]-100;\n      break;\n    }\n  if(l+1!=c)po->left=con(l+1,c-1);\n  if(r-1!=c)po->right=con(c+1,r-1);\n  return po;\n}\nstring make_num(long int p){\n  string t;\n  while(p){\n    t+=p%10+'0';\n    p/=10;\n  }\n  reverse(t.begin(),t.end());\n  return t;\n}\nstring init(node a,node b){\n  string l,r,x=make_num(a->key+b->key);\n  if(a->left!=NULL&&b->left!=NULL)\n    l=init(a->left,b->left);\n  if(a->right!=NULL&&b->right!=NULL)\n    r=init(a->right,b->right);\n  return \"(\"+l+\")[\"+x+\"](\"+r+\")\";\n}\nint main(){\n  cin>>s1[0]>>s1[1];\n  for(int j=0;j<2;j++)\n    for(int i=0;i<(int)s1[j].size()-1;i++)\n      if(s1[j][i]=='('&&s1[j][i+1]==')')s1[j].erase(s1[j].begin()+i),s1[j].erase(s1[j].begin()+i);\n  for(int j=0;j<2;j++)\n    for(int i=0;i<(int)s1[j].size();i++)\n      if(s1[j][i]=='['||s1[j][i]==']')s1[j].erase(s1[j].begin()+i);\n\n  v_make(0);v_make(1);\n  n=0;node a=con(0,v[n].size()-1);\n  n=1;node b=con(0,v[n].size()-1);\n  cout<<init(a,b)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n  int val;\n  Node* left;\n  Node* right;\n\n  Node(int v, Node* l, Node* r)\n    : val(v), left(l), right(r) {}\n\n  string toString() {\n    string ns = to_string(this->val);\n    string ls = (this->left != nullptr) ? this->left->toString() : \"\";\n    string rs = (this->right != nullptr) ? this->right->toString() : \"\";\n    return \"(\" + ls + \")[\" + ns + \"](\" + rs + \")\";\n  }\n};\n\nNode* parseTree(string s) {\n  if (s == \"\") return nullptr;\n\n  // left = [1, leftIdx - 2]\n  int depth = 1;\n  int leftIdx = 1;\n  while (depth) {\n    if (s[leftIdx] == '(') ++depth;\n    if (s[leftIdx] == ')') --depth;\n    ++leftIdx;\n  }\n  string leftVal = s.substr(1, leftIdx - 2);\n\n  // num = [leftIdx + 1, numIdx - 2]\n  int numIdx = leftIdx + 1;\n  while (s[numIdx] != '(') ++numIdx;\n  int numVal = stoi(s.substr(leftIdx + 1, numIdx - leftIdx - 2));\n\n  // right = [numIdx + 1, s.length() - 2]\n  string rightVal = s.substr(numIdx + 1, s.length() - numIdx - 2);\n\n  // s = \"(<left>)[num](<right>)\"\n  auto left = parseTree(leftVal);\n  auto right = parseTree(rightVal);\n  return new Node(numVal, left, right);\n}\n\nNode* composeTree(Node* a, Node* b) {\n  Node* left = nullptr;\n  Node* right = nullptr;\n\n  int sum = a->val + b->val;\n  if (a->left != nullptr && b->left != nullptr) {\n    left = composeTree(a->left, b->left);\n  }\n  if (a->right != nullptr && b->right != nullptr) {\n    right = composeTree(a->right, b->right);\n  }\n  return new Node(sum, left, right);\n}\n\nint main() {\n  string A; cin >> A;\n  string B; cin >> B;\n  auto TA = parseTree(A);\n  auto TB = parseTree(B);\n  cout << composeTree(TA, TB)->toString() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nclass Node{\n    public:\n        int n;\n        Node *l,*r;\n        Node(){}\n        Node(int n) : n(n){}\n};\n\n\nNode* parse(const string& str,int s,int e){\n    if(s+1 == e){\n        assert(str[s]=='(' and str[e]==')');\n        Node* ret = new Node(-1);\n        return ret;\n    }\n\n    int t=s+1;\n    int cnt = 0;\n    while(t<e){\n        if(str[t]=='(') cnt++;\n        else if(str[t]==')') cnt--;\n        t++;\n        if(cnt==0) break;\n    }\n    assert(str[t]=='[');\n    Node* left = parse(str,s+1,t-1); \n    int num = 0;\n    t++;\n    while(str[t]!=']'){\n        num = num * 10 + str[t]-'0';\n        t++;\n    }\n    assert(str[t]==']');\n    Node* right = parse(str,t+1,e-1);\n    Node* node = new Node(num);\n    node->l = left;\n    node->r = right;\n    return node;\n}\n\nNode* merge(Node *node1, Node *node2){\n    if(node1->n==-1 or node2->n==-1){\n        return new Node(-1);\n    }\n\n    Node *ret = new Node(node1->n + node2->n);\n    ret->l = merge(node1->l,node2->l);\n    ret->r = merge(node1->r,node2->r);\n    return ret;\n}\n\nvoid PrintNode(Node* node,int depth=0){\n    string d=\"\";\n    rep(i,depth) d+=\" \";\n    if(node->n == -1){\n        cout << d << \"Null\" << endl;\n        return;\n    }\n    PrintNode(node->l,depth+1);\n    cout << d << node->n << endl;\n    PrintNode(node->r,depth+1);\n}\n\nstring decode(Node* node){\n    if(node->n == -1) return \"()\";\n    string ret=\"(\";\n    ret += decode(node->l);\n    ret += \"[\" + to_string(node->n) + \"]\";\n    ret += decode(node->r);\n    ret += \")\";\n    return ret;\n}\n\nint main(){\n    string s[2];\n    rep(i,2) cin >> s[i];\n    rep(i,2){\n        s[i] = \"(\" + s[i] + \")\";\n    }\n\n    Node* tree[2];\n    rep(i,2) tree[i] = parse(s[i],0,s[i].size()-1);\n\n    Node* res = merge(tree[0],tree[1]);\n    string ans = decode(res);\n    ans = ans.substr(1,ans.size()-2);\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst long double PI = acos(-1);\nconstexpr long double EPS = 1e-15;\nconstexpr int inf = 2e9;\nconstexpr ll INF = 2e18;\nconstexpr ll MOD = 1e9+7;\nconstexpr ll MOD1 = 998244353;\ntypedef pair<ll,ll> P;\n\n//#define all(v) (v).begin(), (v).end()\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) rep(i,0,n)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n//#define mp make_pair\n\nstruct Tree{\n  int num = 0;\n  int left = -1;\n  int right = -1;\n  Tree() {\n    num = 0;\n    left = -1;\n    right = -1;\n  }\n  Tree(int l,int m,int r) {\n    num = m;\n    left = l;\n    right = r;\n  }\n};\n\n// void findroot(string s, int &k) {\n//   int cnt = 1;\n//   for (int i = 1; i < sz(s); i++) {\n//     if (s[i] == '(') cnt++;\n//     else if (s[i] == ')') cnt--;\n\n//     if (cnt == 0) {\n//       i+=2;\n//       int num = 0;\n//       while ('0' <= s[i] && s[i] <= '9') {\n//         num *= 10;\n//         num += (s[i] - '0');\n//         i++;\n//       }\n//       k = num;\n//       return;\n//     }\n//   }\n// }\n\nint k;\nint maketree(Tree *t, string s) {\n  int left = -1;\n  int right = -1;\n  int middle = 0;\n\n  k++;\n  if (s[k] == ')') ;\n  else left = maketree(t, s);\n  k += 2;\n\n  while ('0' <= s[k] && s[k] <= '9') {\n    middle *= 10;\n    middle += (s[k] - '0');\n    k++;\n  }\n  \n  k+=2;\n  if (s[k] == ')') ;\n  else right = maketree(t, s);\n  k++;\n\n  t[middle] = Tree(left,middle,right);\n  return middle;\n}\n\nvoid dfs(int r1, int r2, Tree *t1, Tree *t2) {\n  cout << '(';\n  if (t1[r1].left != -1 && t2[r2].left != -1) {\n    dfs(t1[r1].left, t2[r2].left, t1, t2);\n  }\n  cout << ')';\n  cout << '[';\n  cout << r1 + r2;\n  cout << ']';\n  cout << '(';\n  if (t1[r1].right != -1 && t2[r2].right != -1) {\n    dfs(t1[r1].right, t2[r2].right, t1, t2);\n  }\n  cout << ')';\n}\n\nvoid solve() {\n  string a,b;\n  int r1,r2;\n  cin >> a >> b;\n  Tree t1[2010], t2[2010];\n  k = 0;\n  r1 = maketree(t1,a);\n  k = 0;\n  r2 = maketree(t2,b);\n  dfs(r1,r2,t1,t2);\n  cout << endl;\n}\n\nint main(){\n  // int n;\n  // cin >> n;\n  // REP(i,n) {\n  //   solve();\n  // }\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct tree{\n  vector<shared_ptr<tree> >chs;\n  int num;\n  tree():chs(2,nullptr),num(0){\n  }\n};\n\nint getnum(string st,int &a){\n  int num=0;\n  assert(isdigit(st[a]));\n  while(a<st.size()&&isdigit(st[a])){\n    num*=10;\n    num+=st[a]-'0';\n    a++;\n  }\n  assert(st[a]==']');\n  a++;\n  return num;\n}\nshared_ptr < tree > input(string st,int &a){\n  cout<<a<<endl;\n  assert(a<=st.size());\n  if(a==st.size()){\n    a++;\n    return nullptr;\n  }else if(st[a]!='('){\n    assert(st[a]==')');\n    return nullptr;\n  }else{\n    shared_ptr<tree> t(make_shared<tree>());\n    assert(t->chs.size()==2);\n    assert(st[a]=='(');\n    a++;\n    cout<<\"moguru\"<<endl;\n    t->chs[0]=input(st,a);\n    assert(st[a]==')');\n    a++;\n    cout<<\"detekita\"<<endl;\n    assert(st[a]=='[');\n    a++;\n    cout<<\"Num is\"<<endl;\n    t->num=getnum(st,a);\n    cout<<t->num<<endl;\n    assert(st[a]=='(');\n    a++;\n    cout<<\"moguru2\"<<endl;\n    t->chs[1]=input(st,a);\n    assert(st[a]==')');\n    a++;\n    cout<<\"detekita2\"<<endl;\n    return t;\n  }\n}\n\nstring ans;\nvoid solve(shared_ptr<tree>&l,shared_ptr<tree>&r){\n  \n    ans.push_back('(');\n    if(l->chs[0]==nullptr||r->chs[0]==nullptr){\n  }else{\n    solve(l->chs[0],r->chs[0]);\n    \n  }\n  \n  ans.push_back(')');\n  ans.push_back('[');\n  ans+=(to_string(l->num+r->num));\n  ans.push_back(']');\n    ans.push_back('(');\n  if(l->chs[1]==nullptr||r->chs[1]==nullptr){\n\n  }else{\n    solve(l->chs[1],r->chs[1]);\n  }\n  \n    ans.push_back(')');\n}\n\nint main(){\n  string A,B;cin>>A>>B;\n  vector<shared_ptr<tree>>ts(2,(make_shared<tree>()));\n  int a=0;\n  ts[0]=input(A,a);\n  a=0;\n  ts[1]=input(B,a);\n  solve(ts[0],ts[1]);\n  cout<<ans<<endl;    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;\n  for(int i=l+1;i<r-1;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c);\n  if(r-1!=c+1)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size());\n  n=1;node p2=con(0,a[1].size());\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << \"}\" << endl;\n}\n\nclass node{\n\tpublic:\n\t\tint val;\n\t\tvector<node> l, r;\n\t\tstring to_s(){\n\t\t\tstring sl = \"\", sr = \"\";\n\t\t\tif(l.size() != 0) sl = l[0].to_s();\n\t\t\tif(r.size() != 0) sr = r[0].to_s();\n\t\t\treturn \"(\" + sl + \")[\" + to_string(val) + \"](\" + sr + \")\";\n\t\t}\n};\n\nint to_i(int &pos, string &s){// str[pos-1] = '['\n\tint n = 0;\n\twhile(s[pos] != ']'){\n\t\tn = n * 10 + s[pos] - '0';\n\t\tpos++;\n\t}\n\treturn n; //str[pos] = ']'\n}\n\nnode eval(int &pos, string &s){// str[pos] = '('\n\tpos++;\n\tnode n;\n\tif(s[pos] != ')'){\n\t\tn.l.pb(eval(pos, s));\n\t}\n\tpos+=2;\n\tint v = to_i(pos, s);\n\tn.val = v;\n\tpos+=2;\n\tif(s[pos] != ')'){\n\t\tn.r.pb(eval(pos, s));\n\t}\n\tpos++;\n\treturn n;\n}\n\nnode add(node t1, node t2){\n\tint n = t1.val + t2.val;\n\tnode v;\n\tv.val = n;\n\tif(!t1.l.empty() && !t2.l.empty()) v.l.pb(add(t1.l[0], t2.l[0]));\n\tif(!t1.r.empty() && !t2.r.empty()) v.r.pb(add(t1.r[0], t2.r[0]));\n\treturn v;\n}\n\nint main(){\n\tstring s;\n\tnode a[3];\n\tcin >> s;\n\tint n=0;\n\ta[0] = eval(n, s);\n\tn = 0;\n\tcin >> s;\n\ta[1] = eval(n, s);\n\tn = 0;\n\ta[2] = add(a[0], a[1]);\n\tcout << a[2].to_s() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint num(string&s, int&i) {\n\tint n = 0;\n\twhile (isdigit(s[i]))n = n * 10 + s[i++] - '0';\n\treturn n;\n}\nP E[2][10000];\nint v[2][10000];\nint cnt;\nint calc(string&s, int&i, int id) {\n\tint l = -1, r = -1;\n\ti++; if (s[i] == '(') { l = calc(s, i, id); i++; }\n\tint a = cnt++;\n\ti += 2; v[id][a] = num(s, i);\n\ti += 2; if (s[i] == '(') { r = calc(s, i, id); i++; }\n\tE[id][a].first = l; E[id][a].second = r;\n\treturn a;\n}\nstring dfs(int a, int b) {\n\tstring s = \")[\" + to_string(v[0][a] + v[1][b]) + \"](\";\n\tif (E[0][a].first != -1 && E[1][b].first != -1) {\n\t\ts = \"(\" + dfs(E[0][a].first, E[1][b].first) + s;\n\t}\n\telse s = \"(\" + s;\n\tif (E[0][a].second != -1 && E[1][b].second != -1) {\n\t\ts += dfs(E[0][a].second, E[1][b].second) + \")\";\n\t}\n\telse s += \")\";\n\treturn s;\n}\nint main() {\n\tstring a, b; cin >> a >> b;\n\tint r1, r2;\n\tint i = 0; r1 = calc(a, i, 0);\n\ti = 0; r2 = calc(b, i, 1);\n\tcout << dfs(r1, r2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct node{\n    int num; //ノードに書かれた数\n    int right,left;//子のindex\n};\n\nstruct node v[2][1000];\n\nvector<string> s(2);\nvi num(2);\nvoid f(int ind, int l, int r){\n    int st = 0;\n    int sum = 0;\n    int no = num[ind];\n\n    for(int i = l; i <= r; i++){\n        if(s[ind][i] == '('){\n            st++;\n        }\n        if(s[ind][i] == ')'){\n            st--;\n        }\n        if(s[ind][i] == '[' && st == 0){\n            num[ind]++;\n            v[ind][no].left = num[ind];\n            f(ind, l+1, i-2);\n        }\n        if(s[ind][i] == ']' && st == 0){\n            num[ind]++;\n            v[ind][no].right = num[ind];\n            v[ind][no].num = sum;\n            f(ind, i+2, r-1);\n        }\n        if(isdigit(s[ind][i]) && st == 0){\n            sum *= 10;\n            sum += s[ind][i] - '0';\n        }\n    }\n\n}\n\nstring g(int a, int b){\n    string ret = \"\";\n\n    ret += \"(\";\n    if(v[0][v[0][a].left].num >= 0 && v[1][v[1][b].left].num >= 0){\n        ret += g(v[0][a].left, v[1][b].left);\n    }\n    ret += \")\";\n\n    ret += \"[\";\n    ret += to_string(v[0][a].num + v[1][b].num);\n    ret += \"]\";\n\n    ret += \"(\";\n    if(v[0][v[0][a].right].num >= 0 && v[1][v[1][b].right].num >= 0){\n        ret += g(v[0][a].right, v[1][b].right);\n    }\n    ret += \")\";\n\n    return ret;\n}\n\nint main(void) {\n    int i,j;\n    cin >> s[0];\n    cin >> s[1];\n\n    rep(i,2)rep(j,1000) v[i][j].num = v[i][j].right = v[i][j].left = -1;\n\n    f(0,0,s[0].size()-1);\n    f(1,0,s[1].size()-1);\n\n\n    cout << g(0,0) << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef struct Treenode\n{\n\tbool left = false;\n\tbool right = false;\n\tpair<Treenode*, Treenode*> child;\n\tint num = INT_MAX / 6;\n};\n \nTreenode* saiki( string S ) {\n\t//cout << S << endl;\n\tint num = 0;\n\tint xx = 0;\n\tint parentnum = 0;\n\tint s = -1;\n\tint count = 0;\n\tTreenode *reta = new Treenode;\n\tfor( size_t i = 0; i < S.length(); i++ ) {\n\t\tif( S[i] == '(' ) {\n\t\t\tnum++;\n\t\t\tif( s == -1 ) {\n\t\t\t\ts = i;\n\t\t\t}\n\t\t} else if( S[i] == ')' ) {\n\t\t\tnum--;\n\t\t\tif( num == 0 ) {\n\t\t\t\tif( count == 0 ) {\n\t\t\t\t\tif( i - s > 1 ) {\n\t\t\t\t\t\t(*reta).child.first = saiki( S.substr( s + 1, i - s - 1 ) );\n\t\t\t\t\t\tif( (*(*reta).child.first).num != INT_MAX / 6 ) {\n\t\t\t\t\t\t\t(*reta).left = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t\t} else {\n\t\t\t\t\tif( i - s > 1 ) {\n\t\t\t\t\t\t(*reta).child.second = saiki( S.substr( s + 1, i - s - 1 ) );\n\t\t\t\t\t\tif( (*(*reta).child.second).num != INT_MAX / 6 ) {\n\t\t\t\t\t\t\t(*reta).right = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts = -1;\n\t\t\t}\n\t\t} else if( S[i] == '[' ) {\n\t\t\txx = 0;\n\t\t} else if( S[i] == ']' ) {\n\t\t\tif( num == 0 ) {\n\t\t\t\t(*reta).num = xx;\n\t\t\t}\n\t\t} else {\n\t\t\txx *= 10;\n\t\t\txx += S[i] - '0';\n\t\t}\n\t}\n\treturn reta;\n}\n \nTreenode* saiki2( Treenode* A, Treenode* B ) {\n\tTreenode* retc = new Treenode;\n\t(*retc).num = (*A).num + (*B).num;\n \n\tif( (*A).left && (*B).left ) {\n\t\t(*retc).left = true;\n\t\t(*retc).child.first = saiki2( (*A).child.first, (*B).child.first );\n\t}\n\tif( (*A).right && (*B).right ) {\n\t\t(*retc).right = true;\n\t\t(*retc).child.second = saiki2( (*A).child.second, (*B).child.second );\n\t}\n\treturn retc;\n \n}\n \nstring saiki3( Treenode* C ) {\n\tstring ret = \"\";\n\tif( (*C).left ) {\n\t\tret += '(' + saiki3( (*C).child.first ) + ')';\n\t} else {\n\t\tret += \"()\";\n\t}\n\tret += '[' + to_string( (*C).num ) + ']';\n\tif( (*C).right ) {\n\t\tret += '(' + saiki3( (*C).child.second ) + ')';\n\t} else {\n\t\tret += \"()\";\n\t}\n\treturn ret;\n \n}\n \nint main() {\n\tstring A, B;\n\tcin >> A >> B;\n\tTreenode* Atree = saiki( A );\n\tTreenode* Btree = saiki( B );\n\tTreenode* Ctree = saiki2( Atree, Btree );\n\tcout << saiki3( Ctree ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  long long value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin== End || Begin+1==End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin;Begin!=End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin(), be = b.end();\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\ttree t;\n\t\t\tt.num = 0;\n\t\t\tt.left = -1;\n\t\t\tt.right = -1;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\ttree t;\n\tt.num = 0;\n\tt.left = -1;\n\tt.right = -1;\n\tvt3.push_back(t);\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tif (vt.size() < no)\n\t\treturn \"\";\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstring a,b;\n\nstring dfs(int al,int ar,int bl,int br){\n  if(al==ar||bl==br)return \"\";\n  int level=0;\n  int an,bn,alr,blr,arl,brl;\n  repl(i,al,ar){\n    if(a[i]=='(')level++;\n    if(a[i]==')')level--;\n    if(level==0&&a[i]=='['){\n      int j=i;\n      while(a[j]!=']')j++;\n      an=stoi(a.substr(i+1,j-i-1));\n      alr=i-1; arl=j+2;\n      break;\n    }\n  }\n\n  level=0;\n  repl(i,bl,br){\n    if(b[i]=='(')level++;\n    if(b[i]==')')level--;\n    if(level==0&&b[i]=='['){\n      int j=i;\n      while(b[j]!=']')j++;\n      bn=stoi(b.substr(i+1,j-i-1));\n      blr=i-1; brl=j+2;\n      break;\n    }\n  }\n  string res=\"(\"+dfs(al+1,alr,bl+1,blr)+\")[\"+to_string(an+bn)+\"](\"+dfs(arl,ar-1,brl,br-1)+\")\";\n  return res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>a>>b;\n  cout<<dfs(0,a.length(),0,b.length())<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct no{\n  long int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nint n,p3,p4;\nstring s1[2];\nvector<long int>v[2];\nvoid v_make(int t){\n  v[t].push_back('(');\n  for(int i=0;i<s1[t].size();i++){\n    if(!isdigit(s1[t][i]))v[t].push_back(s1[t][i]);\n    else{\n      int p=s1[t][i]-'0';\n      while(isdigit(s1[t][i+1]))p*=10,p+=s1[t][++i]-'0';\n      v[t].push_back(p+100);\n    }\n  }\n  v[t].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=0;\n  for(int i=l+1;i<r;i++)\n    if((char)v[n][i]=='(')p++;\n    else if((char)v[n][i]==')')p--;\n    else if(v[n][i]>=100&&!p){\n      c=i;\n      po->key=v[n][i]-100;//if(n)cout<<i<<' ';\n      break;\n    }\n  if(l+1!=c&&c)po->left=con(l+1,c-1);\n  if(r-1!=c&&c)po->right=con(c+1,r-1);\n  return po;\n}\nstring make_num(long int p){\n  string t;\n  while(p){\n    t+=p%10+'0';\n    p/=10;\n  }\n  reverse(t.begin(),t.end());\n  return t;\n}\nstring init(node a,node b){\n  string l,r,x=make_num(a->key+b->key);//cout<<a->key<<' '<<b->key<<endl;\n  if(a->left!=NULL&&b->left!=NULL)\n    l=init(a->left,b->left);\n  if(a->right!=NULL&&b->right!=NULL)\n    r=init(a->right,b->right);\n  return \"(\"+l+\")[\"+x+\"](\"+r+\")\";\n}\nint main(){\n  cin>>s1[0]>>s1[1];\n  for(int j=0;j<2;j++)\n    for(int i=0;i<(int)s1[j].size();i++)\n      if(s1[j][i]=='('&&s1[j][i+1]==')')s1[j].erase(s1[j].begin()+i),s1[j].erase(s1[j].begin()+i);\n  for(int j=0;j<2;j++)\n    for(int i=0;i<(int)s1[j].size();i++)\n      if(s1[j][i]=='['||s1[j][i]==']')s1[j].erase(s1[j].begin()+i);\n  v_make(0);v_make(1);\n  \n  n=0;node a=con(0,v[n].size()-1);\n  n=1;node b=con(0,v[n].size()-1);\n  //cout<<a->key+b->key<<endl;\n  cout<<init(a,b)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n#define vec map<int,int>\n\nconst int SIZE=10000000;\n\nvec Aar;\nvec Bar;\nvec Xar;\n\n\nvoid input(vec & ar,const string & str,int & i,int k)\n{\n    if(str[i]=='(')\n    {\n        ++i;\n        input(ar,str,i,2*k+1);\n    }\n    if(str[i]==')')\n    {\n        ++i;\n        input(ar,str,i,(k-1)/2);\n        return;\n    }\n    if(str[i]=='[')\n    {\n        ++i;\n        int n=0;\n        while(str[i]!=']')\n        {\n            n*=10;\n            n+=(int)(str[i]-'0');\n            ++i;\n        }\n        ++i;\n        ar[k] = n;\n    }\n    if(str[i]=='(')\n    {\n        ++i;\n        input(ar,str,i,2*k+2);\n    }\n    if(str[i]==')')\n    {\n        ++i;\n        input(ar,str,i,(k-1)/2);\n        return;\n    }\n}\n\nvoid output(int k)\n{\n    if(!Xar.count(k))return;\n\n    cout << \"(\";\n    output(2*k+1);\n    cout << \")\";\n\n    cout << \"[\" << Xar[k] << \"]\";\n\n    cout << \"(\";\n    output(2*k+2);\n    cout << \")\";\n}\n\nint main()\n{\n    string A,B;\n    cin >> A >> B;\n    int si=0;\n    input(Aar,A,si,0);\n    si = 0;\n    input(Bar,B,si,0); \n\n    for(auto & a:Aar)\n    {\n        int i=a.first;\n        if(Aar.count(i) && Bar.count(i))\n        {\n            Xar[i]=Aar[i]+Bar[i];\n        }\n    }\n\n    output(0);\n\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nvoid solve(string s, int par, vector<int>& vec) {\n\tint cnt = 0;\n\tint l = 1, r = 0;\n\tfor (int i = 1; i < s.size() - 1; i++) {\n\t\tif (s[i] == '(')cnt++;\n\t\telse if (s[i] == ')')cnt--;\n\n\t\tif (cnt == 0) {\n\t\t\tr = i;\n\t\t\tstring next = s.substr(l, r - l + 1);\n\n\t\t\tif (l == 1) {\n\t\t\t\tsolve(next, par * 2 + 1, vec);\n\n\t\t\t\ti += 2;\n\n\t\t\t\tint l2 = i;\n\t\t\t\twhile (1) {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (s[i] == ']') {\n\t\t\t\t\t\tvec[par] = stoi(s.substr(l2, i - l2).data());\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tl = r = i;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsolve(next, par * 2 + 2, vec);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstring solve2(vector<int>&ans, int par) {\n\tstring s1, s2, s3;\n\n\tif (ans[par] != -1) {\n\t\ts2 = to_string(ans[par]);\n\t}\n\telse return \"\";\n\n\ts1 = solve2(ans, par * 2 + 1);\n\ts3 = solve2(ans, par * 2 + 2);\n\n\treturn \"(\" + s1 + \")\" + \"[\" + s2 + \"]\" + \"(\" + s3 + \")\";\n}\n\nint main()\n{\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tvector<int>a(10000,-1), b(10000,-1);\n\n\ts1.insert(s1.begin(), '(');\n\ts1.push_back(')');\n\ts2.insert(s2.begin(), '(');\n\ts2.push_back(')');\n\n\tsolve(s1, 0, a);\n\tsolve(s2, 0, b);\n\n\tvector<int>c(10000, -1);\n\tfor (int i = 0; i < 10000; i++) {\n\t\tif (a[i] != -1 && b[i] != -1) {\n\t\t\tc[i] = a[i] + b[i];\n\t\t}\n\t}\n\n\tcout << solve2(c, 0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_, *right;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin == End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin; *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin(), be = b.end();\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\nvoid init() {\n\n}\ntypedef struct V {\n\tint val;\n\tint left;\n\tint right;\n}V;\n\nint itr[2] = { 1,1 };\nV vertexs[2][2001] = {};\nint num(State& now) {\n\tint ans = 0;\n\twhile (*now >= '0' && *now <= '9') {\n\t\tans *= 10;\n\t\tans += *now - '0';\n\t\tnow++;\n\t}\n\treturn ans;\n}\n\nint make_tree(State& now,int check) {\n\tif (*now == ')') {\n\t\treturn 0;\n\t}\n\tassert(*now == '(');\n\tnow++;\n\tint hoge = itr[check];\n\titr[check]++;\n\tvertexs[check][hoge] = V{ 0,make_tree(now,check),0 };\n\tnow++;\n\tnow++;\n\tvertexs[check][hoge].val = num(now);\n\tnow++;\n\tnow++;\n\tvertexs[check][hoge].right = make_tree(now, check);\n\tnow++;\n\treturn hoge;\n}\n\nstring output(int L, int R) {\n\tstring ans;\n\tif (vertexs[0][L].left != 0 && vertexs[1][R].left != 0) {\n\t\t//goto left\n\t\tans += \"(\" + output(vertexs[0][L].left, vertexs[1][R].left) + \")\";\n\t}\n\telse {\n\t\tans += \"()\";\n\t}\n\tans += \"[\" + to_string(vertexs[0][L].val + vertexs[1][R].val) + \"]\";\n\tif (vertexs[0][L].right != 0 && vertexs[1][R].right != 0) {\n\t\t//goto right\n\t\tans += \"(\" + output(vertexs[0][L].right, vertexs[1][R].right) + \")\";\n\t}\n\telse {\n\t\tans += \"()\";\n\t}\n\treturn ans;\n}\n\n\nvoid solve() {\n\tint root[2];\n\tREP(i, 2) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tState start = s.begin();\n\t\troot[i] = make_tree(start, i);\n\t}\n\tcout << output(root[0], root[1]) << endl;\n}\n\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no=vt.size();\n\t\t\tvt.push_back({num,0,0});\n\t\t\tvt.at(no).left = saiki(s.substr(1, i - 2), vt);\n\t\t\tvt.at(no).right = saiki(s.substr(idx + 2, s.length() - idx - 1), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = vt3.size();\n\tvt3.push_back({tree1[a].num+tree2[b].num,0,0 });\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret;\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\t\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef string::const_iterator State;\n\nvoid assume(State &begin1, State &begin2, char expected, string &s) {\n    // cerr << \"assume: \" << *begin1 << \", \" << *begin2 << \", \" << expected << \", \" << s << endl;\n\n    assert(*begin1 == expected && *begin2 == expected);\n    s += *begin1;\n    begin1++;   begin2++;\n}\n\nstring number(State &begin1, State &begin2) {\n    // cerr << \"number: \" << *begin1 << \", \" << *begin2 << endl;\n\n    int val1 = 0;\n    while (isdigit(*begin1)) {\n        val1 *= 10;\n        val1 += *begin1 - '0';\n        begin1++;\n    }\n    int val2 = 0;\n    while (isdigit(*begin2)) {\n        val2 *= 10;\n        val2 += *begin2 - '0';\n        begin2++;\n    }\n    return to_string(val1 + val2);\n}\n\nstring node(State &begin1, State &begin2) {\n    // cerr << \"node: \" << *begin1 << \", \" << *begin2 << endl;\n\n    if (*begin1 == ')') {\n        int depth = 1;\n        for(;;) {\n            if (*begin2 == '(') {\n                depth++;\n            } else if (*begin2 == ')') {\n                depth--;\n            }\n            if (depth == 0) {\n                return \"\";\n            }\n            begin2++;\n        }\n    }\n    if (*begin2 == ')') {\n        int depth = 1;\n        for(;;) {\n            if (*begin1 == '(') {\n                depth++;\n            } else if (*begin1 == ')') {\n                depth--;\n            }\n            if (depth == 0) {\n                return \"\";\n            }\n            begin1++;\n        }\n    }\n\n    string ret = \"\";\n\n    assume(begin1, begin2, '(', ret);\n    ret += node(begin1, begin2);\n    assume(begin1, begin2, ')', ret);\n    assume(begin1, begin2, '[', ret);\n    ret += number(begin1, begin2);\n    assume(begin1, begin2, ']', ret);\n    assume(begin1, begin2, '(', ret);\n    ret += node(begin1, begin2);\n    assume(begin1, begin2, ')', ret);\n\n    return ret;\n\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string s1, s2;\n    while (cin >> s1 >> s2, s1 != \"#\") {\n        State begin1 = s1.begin();\n        State begin2 = s2.begin();\n        cout << node(begin1, begin2) << endl;\n        assert(begin1 == s1.end() && begin2 == s2.end());\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin == End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin; *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin(), be = b.end();\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 40\n#define INF 1000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstring dfs(string s, string t){\n    if(s == \"()\" || t == \"()\") return \"()\";\n    s.erase(0,1); s.erase(s.size()-1,1);\n    t.erase(0,1); t.erase(t.size()-1,1);\n    int cnt = 0;\n    int i = 1;\n    for(; i < s.size(); i++){\n        if(s[i] == '(') cnt++;\n        if(s[i] == ')') cnt--;\n        if(cnt == -1) break;\n    }\n    string sl = s.substr(0,i+1);\n    i += 2;\n    int ns = 0;\n    for(; i < s.size(); i++){\n        if('0' > s[i] || s[i] > '9') break;\n        ns = ns*10+s[i]-'0';\n    }\n    string sr = s.substr(i+1);\n    cnt = 0;\n    i = 1;\n    for(; i < t.size(); i++){\n        if(t[i] == '(') cnt++;\n        if(t[i] == ')') cnt--;\n        if(cnt == -1) break;\n    }\n    string tl = t.substr(0,i+1);\n    i += 2;\n    int nt = 0;\n    for(; i < t.size(); i++){\n        if('0' > t[i] || t[i] > '9') break;\n        nt = nt*10+t[i]-'0';\n    }\n    string tr = t.substr(i+1);\n    sr = dfs(sr,tr);\n    sl = dfs(sl,tl);\n    ns += nt;\n    sl.push_back('[');\n    sl += to_string(ns);\n    sl.push_back(']');\n    sl += sr;\n    sl.insert(0,\"(\"); sl.insert(sl.size()-1,\")\");\n    return sl;\n}\n\nint main(){\n    string s,t;\n    cin >> s >> t;\n    s.insert(0,\"(\"); s.insert(s.size()-1,\")\");\n    t.insert(0,\"(\"); t.insert(t.size()-1,\")\");\n    s = dfs(s,t);\n    s.erase(0,1); s.erase(s.size()-1,1);\n    cout << s << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin + 1 == End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin;Begin!=End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      if (rb > End) {\n        rb = End;\n      }\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin(), be = b.end();\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n\nusing namespace std;\n\nenum TYPE{\n\tNONE,\n\tFIRST,\n\tSECOND,\n\tLEFT,\n\tRIGHT\n};\n\nint first[1000],second[1000],third[1000];\nchar buf[1010];\n\nTYPE toWrite;\n\nvoid recursive(int left,int right,int parent_address,TYPE left_or_right){\n\tint calcDepth,nextRight,nextLeft,tmp,nextParentAddress = -1;\n\tif(parent_address != -1){\n\t\tcalcDepth = 0;\n\t\tfor(int i = left,k=0; i <= right; i++){\n\n\t\t\tif(calcDepth==0 && buf[i] == '['){ //???\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextRight = i-1;\n\t\t\t\tnextLeft = k+1;\n\t\t\t\tbreak;\n\t\t\t}else if(calcDepth==0 && buf[i] == '(' && buf[i+1] >= '0' && buf[i+1] <= '9'){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ')';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\t}\n\t\t}\n\n\t\tif(nextParentAddress != -1){\n\t\t\tif(left+1 < nextRight-1){\n\t\t\t\trecursive(left+1,nextRight-1,nextParentAddress,LEFT);\n\t\t\t}\n\t\t\tif(nextLeft+1 < right-1){\n\t\t\t\trecursive(nextLeft+1,right-1,nextParentAddress,RIGHT);\n\t\t\t}\n\t\t}\n\n\t}else{\n\t\tcalcDepth = 0;\n\t\tfor(int i = 0,k=0; i <= right; i++){\n\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\telse{\n\t\t\t\tif(calcDepth==0 && buf[i] == '['){\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\t\tfirst[0] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[0] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tnextRight = i-1;\n\t\t\t\t\tnextLeft = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(left+1 < nextRight-1){\n\t\t\trecursive(left+1,nextRight-1,0,LEFT);\n\t\t}\n\t\tif(nextLeft+1 < right-1){\n\t\t\trecursive(nextLeft+1,right-1,0,RIGHT);\n\t\t}\n\t}\n}\n\nvoid outPut(int address){\n\n\tif(third[2*address+1] != -1 || third[2*address+2] != -1){\n\t\tif(third[2*address+1] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+1);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t\tprintf(\"[%d]\",third[address]);\n\t\tif(third[2*address+2] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+2);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t}else{\n\t\tprintf(\"()[%d]()\",third[address]);\n\t}\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 1000; i++){\n\t\tfirst[i] = -1;\n\t\tsecond[i] = -1;\n\t\tthird[i] = -1;\n\t}\n\n\tscanf(\"%s\",buf);\n\tint length;\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = FIRST;\n\trecursive(0,length-1,-1,NONE);\n\n\tscanf(\"%s\",buf);\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = SECOND;\n\trecursive(0,length-1,-1,NONE);\n\n\tfor(int i = 0; i < 1000; i++){\n\t\tif(first[i] != -1 && second[i] != -1){\n\t\t\tthird[i] = first[i]+second[i];\n\t\t}else{\n\t\t\tthird[i] = -1;\n\t\t}\n\t}\n\n\toutPut(0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\tvt.push_back({num,0,0});\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\tvt3.push_back({tree1[a].num+tree2[b].num,0,0 });\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct node{\n  LL num=-1;\n  struct node* r=NULL;\n  struct node* l=NULL;\n};\n\nvoid decode(string s,struct node* now){\n  int i=0;\n  int l=0,r=0;\n  for(;;i++){\n    if(s[i]=='(') l++;\n    else if(s[i]==')') r++;\n    if(l==r){\n      if(i>1){\n        now->l=new struct node;\n        decode(s.substr(1,i-1),now->l);\n      }\n      break;\n    }\n  }\n  int tmp=i;\n  for(;;i++){\n    if(s[i]==']'){\n      now->num=stoi(s.substr(tmp+2,i-tmp-2));\n      break;\n    }\n  }\n  if(i<s.length()-3){\n    now->r=new struct node;\n    decode(s.substr(i+2,s.length()-4-i),now->r);\n  }\n  return;\n}\n\nstring encode(struct node* now){\n  if(now!=NULL){\n    return \"(\"+encode(now->l)+\")[\"+to_string(now->num)+\"](\"+encode(now->r)+\")\";\n  }else{\n    return \"\";\n  }\n}\n\nvoid merge(struct node* now,struct node* anow,struct node* bnow){\n  now->num=anow->num+bnow->num;\n  if(anow->l!=NULL&&bnow->l!=NULL){\n    now->l=new struct node;\n    merge(now->l,anow->l,bnow->l);\n  }\n  if(anow->r!=NULL&&bnow->r!=NULL){\n    now->r=new struct node;\n    merge(now->r,anow->r,bnow->r);\n  }\n  return;\n}\n\nint main(){\n  string a,b;\n  cin >> a >> b;\n  struct node A,B,ans;\n  decode(a,&A);\n  decode(b,&B);\n  merge(&ans,&A,&B);\n  // for(int i=0;i<50;i++){\n  //   cout << A[i] << \" \";\n  // }\n  // cout << endl;\n  cout << encode(&ans) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\n\tnode.emplace_back(Node());\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #include <bits/stdc++.h>\n// using namespace std;\n\n// #define rep(i,n) for(int i = 0; i < (n); i++)\n// #define FOR(i,d,n) for(int i = (d); i < (n); i++)\n// using ll = long long;\n// using vi = vector<int>;\n// using vs = vector<string>;\n\n// void dec(const string s,int& n,int d[1000]){\n//     int de=0;\n//     int left=1;\n//     int nn=0;\n//     FOR(i,0,n){\n//         if(s[i]=='('){\n//             de++;\n//         }else if(s[i]==')'){\n\n//         }else if(s[i]=='['){\n\n//         }else if(s[i]==']'){\n\n//         }else{\n\n//         }\n//     }\n// }\n\n// int main()\n// {\n//     string s[2]={};\n//     cin>>s[0]>>s[1];\n//     int n[2]={s[0].length(),s[1].length()};\n//     int num[2]={};\n//     int depth[2][1000]={};\n//     int \n//     dec(s[0],num[0],depth[0]);\n//     return 0;\n// }\n\n#include <bits/stdc++.h>\n\nstd::string A, B;\n\nvoid calcSum(int&, int&);\nvoid throughTree(int&, std::string&);\nint64_t calcNum(int&, std::string&);\n\nint main()\n{\n    std::cin >> A >> B;\n    int a_i{}, b_i{};\n    calcSum(a_i, b_i);\n    putchar('\\n');\n\n    return 0;\n}\n\nvoid calcSum(int& a_i, int& b_i)\n{\n    a_i++; b_i++;\n    putchar('(');\n    if (A[a_i] != ')' && B[b_i] != ')')\n        calcSum(a_i, b_i);\n    else if (A[a_i] != ')')\n        throughTree(a_i, A);\n    else if (B[b_i] != ')')\n        throughTree(b_i, B);\n    a_i++; b_i++;\n    putchar(')');\n\n    putchar('[');\n    std::cout << std::to_string(calcNum(a_i, A) + calcNum(b_i, B));\n    putchar(']');\n\n    a_i++; b_i++;\n    putchar('(');\n    if (A[a_i] != ')' && B[b_i] != ')')\n        calcSum(a_i, b_i);\n    else if (A[a_i] != ')')\n        throughTree(a_i, A);\n    else if (B[b_i] != ')')\n        throughTree(b_i, B);\n    a_i++; b_i++;\n    putchar(')');\n\n    return;\n}\n\nvoid throughTree(int& s_i, std::string& str)\n{\n    if (str[s_i] == ')') return;\n    s_i++;\n    throughTree(s_i, str);\n    s_i++;\n\n    calcNum(s_i, str);\n\n    s_i++;\n    throughTree(s_i, str);\n    s_i++;\n\n    return;\n}\n\nint64_t calcNum(int& s_i, std::string& str)\n{\n    s_i++;\n    int64_t ret{};\n    while (str[s_i] != ']')\n    {\n        ret = 10 * ret + str[s_i] - '0';\n        s_i++;\n    }\n    s_i++;\n    return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no=vt.size();\n\t\t\tvt.push_back({num,0,0});\n\t\t\tvt.at(no).left = saiki(s.substr(1, i - 2), vt);\n\t\t\tvt.at(no).right = saiki(s.substr(idx + 2, s.length() - idx - 1), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = vt3.size();\n\tvt3.push_back({tree1[a].num+tree2[b].num,0,0 });\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret;\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\t\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nstruct Node {\n    int Number;\n    Node *left, *right;\n};\n\nint getNumber(string::iterator &it);\nNode* getChildren(string::iterator &it);\nNode* parseNode(string::iterator &it);\n\nint getNumber(string::iterator &it) {\n    int ret = 0;\n    while(isdigit(*it)) {\n        ret *= 10;\n        ret += (*it - '0');\n        it++;\n    }\n    return ret;\n}\n\nNode* getChildren(string::iterator &it) {\n    if(*it == '(' && *(it+1) == ')') {\n        it += 2;\n        return NULL;\n    }\n    it++;\n    Node *ret = parseNode(it);\n    it++;\n    return ret;\n}\n\nNode* parseNode(string::iterator &it) {\n    // cerr << *it << endl;\n    assert(*it == '(');\n    Node *CurrentNode = new Node;\n    CurrentNode->left = getChildren(it);\n    it++; // '['\n    CurrentNode->Number = getNumber(it);\n    it++; // ']'\n    CurrentNode->right = getChildren(it);\n    return CurrentNode;\n}\n\nvoid dfs(Node *cur) {\n    if(cur == NULL) return;\n    cout << \"(\";\n    dfs(cur->left);\n    cout << \")\";\n    cout << \"[\";\n    cout << cur->Number;\n    cout << \"]\";\n    cout << \"(\";\n    dfs(cur->right);\n    cout << \")\";\n}\n\nNode *CreateTree(Node *ns, Node *nt) {\n    if(ns == NULL || nt == NULL) return NULL;\n    Node *ret = new Node;\n    ret->Number = ns->Number + nt->Number;\n    ret->left = CreateTree(ns->left, nt->left);\n    ret->right = CreateTree(ns->right, nt->right);\n    return ret;\n}\n\nsigned main() {\n    string s, t; cin >> s >> t;\n    string::iterator its = s.begin(), itt = t.begin();\n    Node *ns = parseNode(its), *nt = parseNode(itt);\n\n    Node *ans = CreateTree(ns, nt);\n    // dfs(ns); cout << endl;\n    // dfs(nt); cout << endl;\n\n    dfs(ans); cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define repr(i, a, b) for (int i = (int)(a - 1); i >= b; i--)\n#define rep(i, n) repl(i, 0, n)\n#define each(itr, v) for (auto itr : v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(), (x).end()\n#define dbg(x) cout << #x \" = \" << x << endl\n#define dbgv(i, a, v) \\\n  rep(i, a) { cout << v[i] << ((i < a - 1) ? ' ' : '\\n'); }\n#define maxch(x, y) x = max(x, y)\n#define minch(x, y) x = min(x, y)\n#define uni(x) x.erase(unique(all(x)), x.end())\n#define exist(x, y) (find(all(x), y) != x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define INF INT_MAX / 3\n\nint rp, rq, rans;\nint p[1010][1010][2], q[1010][1010][2], ans[2020][1010][2];\n\nint toArray(string s, int h, bool f) {\n  if (s.size() == 0) return -1;\n  int l = 1, i = 1;\n  while (l > 0 && i < s.size()) {\n    if (s[i] == '(')\n      l++;\n    else if (s[i] == ')')\n      l--;\n    i++;\n  }\n  int j = i + 1, r = 0;\n  while ('0' <= s[j] && s[j] <= '9') {\n    r = r * 10 + (s[j] - '0');\n    j++;\n  }\n  if (f) {\n    p[h][r][0] = toArray(s.substr(1, i - 2), h + 1, true);\n    p[h][r][1] = toArray(s.substr(j + 2, s.size() - j - 3), h + 1, true);\n  } else {\n    q[h][r][0] = toArray(s.substr(1, i - 2), h + 1, false);\n    q[h][r][1] = toArray(s.substr(j + 2, s.size() - j - 3), h + 1, false);\n  }\n  return r;\n}\n\nint combine(int a, int b, int h) {\n  if (a != -1 && b != -1) {\n    int r = a + b;\n    ans[h][r][0] = combine(p[h][a][0], q[h][b][0], h + 1);\n    ans[h][r][1] = combine(p[h][a][1], q[h][b][1], h + 1);\n    return r;\n  } else {\n    return -1;\n  }\n}\n\nstring toString(int r, int h) {\n  if (r == -1) return \"\";\n  string ret = \"(\";\n  ret += toString(ans[h][r][0], h + 1);\n  ret += \")[\" + to_string(r) + \"](\";\n  ret += toString(ans[h][r][1], h + 1);\n  return ret + \")\";\n}\n\nint main() {\n  cin.sync_with_stdio(false);\n  memset(p, -1, sizeof(p));\n  memset(q, -1, sizeof(q));\n  memset(ans, -1, sizeof(ans));\n  string a, b;\n  cin >> a >> b;\n  rp = toArray(a, 0, true), rq = toArray(b, 0, false);\n  rans = combine(rp, rq, 0);\n  cout << toString(rans, 0) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\nusing vi = vector<int>;\nusing Tree = vector<map<int,int>>;\n#define LEFT 0\n#define RIGHT 1\n\ntypedef string::const_iterator State;\n\nint number(State &begin){\n  int res = 0;\n  while(isdigit(*begin)){\n    res *= 10;\n    res += *begin - '0';\n    ++begin;\n  }\n  return res;\n}\n\nint parse(State &begin, Tree &t, vi &mp){\n  if(*begin == ')') return -1;\n\n  ++begin; // '('\n  int l = parse(begin, t, mp); // ノード番号\n  ++begin; // ')'\n  ++begin; // '[';\n  int p = number(begin); // ノードの数\n  ++begin; // ']';\n  ++begin; // '(';\n  int r = parse(begin, t, mp); // ノード番号\n  ++begin; // ')';\n\n  mp.push_back(p);\n  t.resize(t.size()+1);\n  if(l != -1) t.back()[LEFT] = l;\n  if(r != -1) t.back()[RIGHT] = r;\n\n  return t.size()-1;\n}\n\nstring syncDFS(int ap, Tree at, vi amp, int bp, Tree bt, vi bmp){\n  string res;\n\n  res += \"(\";\n  if(at[ap].count(LEFT) and bt[bp].count(LEFT))\n    res += syncDFS(at[ap][LEFT], at, amp, bt[bp][LEFT], bt, bmp);\n  res += \")[\";\n  res += to_string(amp[ap] + bmp[bp]);\n  res += \"](\";\n  if(at[ap].count(RIGHT) and bt[bp].count(RIGHT))\n    res += syncDFS(at[ap][RIGHT], at, amp, bt[bp][RIGHT], bt, bmp);\n  res += \")\";\n\n  return res;\n}\n\nint main(){\n  string a, b;\n  cin >> a >> b;\n\n  Tree at, bt;\n  vi amp, bmp;\n  State begin = a.begin();\n  int aroot = parse(begin, at, amp);\n  begin = b.begin();\n  int broot = parse(begin, bt, bmp);\n\n  cout << syncDFS(aroot, at, amp, broot, bt, bmp) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <stack>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = (int)1e9 + 7;\nconst int MAX_N = (int)1e5 + 5;\n#define debug(x) cout << #x << \": \" << x << endl\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) { for(int i = 0; i < (int) v.size(); i++) os << v[i] << (i + 1 != v.size() ? \" \" : \"\"); return os; }\nstruct Node\n{\n    int value;\n    Node *left, *right;\n};\nstruct Tree\n{\n    Node *root = nullptr;\n    string str = \"\";\n    Tree(string s) : str(s) {}\n    Node *getRoot(string target)\n    {\n        if(target.size() <= 2) return nullptr;\n        if(str != target and target.front() == '(' and target.back() == ')')\n        {\n            target = target.substr(1);\n            target.pop_back();\n        }\n        stack<char> st;\n        int num = 0, p, q;\n        for(int i = 0; i < (int)target.size(); i++)\n        {\n            if(st.empty() and target[i] == '[')\n            {\n                p = i;\n                int idx = i + 1;\n                while(isdigit(target[idx]))\n                {\n                    num *= 10;\n                    num += target[idx] - '0';\n                    idx++;\n                }\n                q = idx + 1;\n            }\n            else if(target[i] == ')')\n            {\n                char ch;\n                do { ch = st.top(); st.pop(); }\n                while(ch != '(');\n            }\n            else st.push(target[i]);\n        }\n        Node *res = new Node;\n        res->value = num;\n        res->left = getRoot(target.substr(0, p));\n        res->right = getRoot(target.substr(q));\n        return res;\n    }\n    void build() { root = getRoot(str); } ;\n};\nNode *make(Node *A, Node *B)\n{\n    if(A == nullptr or B == nullptr) return nullptr;\n    Node *res = new Node;\n    res->value = A->value + B->value;\n    res->left = make(A->left, B->left);\n    res->right = make(A->right, B->right);\n    return res;\n}\nstring create(Node *C)\n{\n    if(C == nullptr) return \"\";\n    string res = \"[\" + to_string(C->value) + \"]\";\n    res = \"(\" + create(C->left) + \")\" + res + \"(\" + create(C->right) + \")\";\n    return res;\n}\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s, t; cin >> s >> t;\n    Tree A(s), B(t);\n    A.build(); B.build();\n    Node *C = make(A.root, B.root);\n    cout << create(C) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\n\tnode.emplace_back(Node());\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tstring ans = merge(x,0,y,0);\n\tshow(\"test\")\n\tshow(ans)\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin == End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin; Begin != End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end() - 1, bb = b.begin(), be = b.end() - 1;\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nclass ki{public:\n\tint num;\n\tki *hi,*mg;\n\tki(void){hi=nullptr;mg=nullptr;num=0;}\n\tvoid output(void){\n\t\tcout<<'(';\n\t\tif(hi!=nullptr){hi->output();}\n\t\tcout<<\")[\"<<num<<\"](\";\n\t\tif(mg!=nullptr){mg->output();}\n\t\tcout<<')';\n\t}\n};\nstring str;\nint ban;\nki* solve(void){\n\t\n\tif(str[ban]==')'){return nullptr;}\n\tki* ans=new ki();\n\tban++;\n\tans->hi=solve();\n\tban+=2;\n\t//数字\n\twhile(str[ban]!=']'){ans->num*=10;ans->num+=str[ban]-'0';ban++;}\n\tban+=2;\n\tans->mg=solve();\n\tban++;\n\treturn ans;\n}\nki* tasu(ki* a,ki* b){\n\tif(a==nullptr||b==nullptr){return nullptr;}\n\tki* ans=new ki();\n\tans->num=a->num+b->num;\n\tans->hi=tasu(a->hi,b->hi);\n\tans->mg=tasu(a->mg,b->mg);\n\treturn ans;\n}\n\nint main(void){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tstring S,T;cin>>S>>T;\n\tstr=S;ban=0;\n\tauto ss=solve();\n\t\n\tstr=T;ban=0;\n\tauto tt=solve();\n\ttasu(ss,tt)->output();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define endl \"\\n\"\n\nstring mul(string a)\n{\n  int n = (int)a.size();\n  string res = \"\";\n  bool up = false;\n  for (int i = n - 1; i >= 0; i--)\n  {\n    int tmp = (int)(a[i] - '0');\n    tmp *= 2;\n    if (up)\n      tmp++;\n    up = false;\n    string tmp2 = to_string(tmp);\n    res += tmp2[tmp2.size() - 1];\n    if (tmp2.size() > 1)\n      up = true;\n  }\n  if (up)\n    res += '1';\n  reverse(all(res));\n  return res;\n}\n\nstring add(string a) {\n  int n = (int)a.size();\n  string res = \"\";\n  bool up = true;\n  for (int i = n - 1; i >= 0; i--) {\n    if (!up) {\n      res += a[i];\n      continue;\n    }\n    int tmp = (int)(a[i] - '0');\n    tmp++;\n    string tmp2 = to_string(tmp);\n    res += tmp2[tmp2.size() - 1];\n    if (tmp2.size() > 1) up = true;\n    else up = false;\n  }\n  if (up) res += '1';\n  reverse(all(res));\n  return res;\n}\n\nmap<string, int> NumA, NumB;\n\nvoid parseA(string idx, string s)\n{\n  int n = (int)s.size();\n  stack<char> st;\n  int res = 0;\n  int left = -1, right = -1;\n  for (int i = 0; i < n; i++)\n  {\n    if (s[i] == '(')\n      st.push('(');\n    else if (s[i] == ')')\n      st.pop();\n    else if (isdigit(s[i]) && st.empty())\n    {\n      res *= 10;\n      res += (int)(s[i] - '0');\n    }\n    else if (s[i] == '[' && st.empty() && i - 2 > 0)\n    {\n      parseA(mul(idx), s.substr(1, i - 2));\n    }\n    else if (s[i] == ']' && st.empty() && i + 2 < n - 1)\n    {\n      parseA(add(mul(idx)), s.substr(i + 2, n - i - 3));\n      break;\n    }\n  }\n  NumA[idx] = res;\n}\n\nvoid parseB(string idx, string s)\n{\n  int n = (int)s.size();\n  stack<char> st;\n  int res = 0;\n  for (int i = 0; i < n; i++)\n  {\n    if (s[i] == '(')\n      st.push('(');\n    else if (s[i] == ')')\n      st.pop();\n    else if (isdigit(s[i]) && st.empty())\n    {\n      res *= 10;\n      res += (int)(s[i] - '0');\n    }\n    else if (s[i] == '[' && st.empty() && i - 2 > 0)\n    {\n      parseB(mul(idx), s.substr(1, i - 2));\n    }\n    else if (s[i] == ']' && st.empty() && i + 2 < n - 1)\n    {\n      parseB(add(mul(idx)), s.substr(i + 2, n - i - 3));\n      break;\n    }\n  }\n  NumB[idx] = res;\n}\n\nstring a, b;\nmap<string, int> NumS;\n\nstring construct(string idx)\n{\n  if (NumS.count(idx) == 0)\n    return \"\";\n  return \"(\" + construct(mul(idx)) + \")[\" + to_string(NumS[idx]) + \"](\" + construct(add(mul(idx))) + \")\";\n}\n\nint main()\n{\n  cin >> a >> b;\n  parseA(\"1\", a);\n  parseB(\"1\", b);\n  for (auto ite = NumA.begin(); ite != NumA.end(); ite++) {\n    for (auto ite2 = NumB.begin(); ite2 != NumB.end(); ite2++) {\n      if (ite->fi == ite2->fi) {\n        NumS[ite->fi] = ite->se + ite2->se;\n      }\n    }\n  }\n  string ans = construct(\"1\");\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n#define NUM 50000000\n\nusing namespace std;\n\nenum TYPE{\n\tNONE,\n\tFIRST,\n\tSECOND,\n\tLEFT,\n\tRIGHT\n};\n\nint* first,*second,*third;\nchar buf[1010];\n\nTYPE toWrite;\n\n//left_or_right???LEFT????????????????????¢?????¬??????2*parent_address+1,RIGHT??????parent_address+2\nvoid recursive(int left,int right,int parent_address,TYPE left_or_right){\n\tint calcDepth,nextRight,nextLeft,tmp,nextParentAddress = -1;\n\tif(parent_address != -1){\n\t\tcalcDepth = 0; //??????????????±???\n\t\tfor(int i = left,k=0; i <= right; i++){\n\n\t\t\tif(calcDepth==0 && buf[i] == '['){ //???\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextRight = i-1;\n\t\t\t\tnextLeft = k+1;\n\t\t\t\tbreak; //???????????????????????????????????±???0???1??????????????¨???????????????????????§break;\n\t\t\t}else if(calcDepth==0 && buf[i] == '(' && buf[i+1] >= '0' && buf[i+1] <= '9'){ //???<?????????>\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ')';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\t}\n\t\t}\n\n\t\tif(nextParentAddress != -1){\n\t\t\tif(left+1 < nextRight-1){\n\t\t\t\trecursive(left+1,nextRight-1,nextParentAddress,LEFT);\n\t\t\t}\n\t\t\tif(nextLeft+1 < right-1){\n\t\t\t\trecursive(nextLeft+1,right-1,nextParentAddress,RIGHT);\n\t\t\t}\n\t\t}\n\n\t}else{ //???????????´???\n\t\tcalcDepth = 0; //??¶???????????±???\n\t\tfor(int i = 0,k=0; i <= right; i++){\n\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\telse{\n\t\t\t\tif(calcDepth==0 && buf[i] == '['){ //????????????????????????\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\t\tfirst[0] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[0] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tnextRight = i-1;\n\t\t\t\t\tnextLeft = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(left+1 < nextRight-1){\n\t\t\trecursive(left+1,nextRight-1,0,LEFT);\n\t\t}\n\t\tif(nextLeft+1 < right-1){\n\t\t\trecursive(nextLeft+1,right-1,0,RIGHT);\n\t\t}\n\t}\n}\n\nvoid outPut(int address){\n\n\tif(third[2*address+1] != -1 || third[2*address+2] != -1){//??????????????´???\n\t\tif(third[2*address+1] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+1);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t\tprintf(\"[%d]\",third[address]);\n\t\tif(third[2*address+2] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+2);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t}else{ //?????????????????´???\n\t\tprintf(\"()[%d]()\",third[address]);\n\t}\n}\n\n\nint main(){\n\n\tfirst = new int[NUM];\n\tsecond = new int[NUM];\n\tthird = new int[NUM];\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tfirst[i] = -1;\n\t\tsecond[i] = -1;\n\t\tthird[i] = -1;\n\t}\n\n\tscanf(\"%s\",buf);\n\tint length;\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = FIRST;\n\trecursive(0,length-1,-1,NONE);\n\n\tscanf(\"%s\",buf);\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = SECOND;\n\trecursive(0,length-1,-1,NONE);\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(first[i] != -1 && second[i] != -1){\n\t\t\tthird[i] = first[i]+second[i];\n\t\t}else{\n\t\t\tthird[i] = -1;\n\t\t}\n\t}\n\n\toutPut(0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\nstruct node{\n\tint v;\n\tvector<node> l;\n\tvector<node> r;\n\n\tvoid out(){\n\t\t//cout << \"out \" << (int)v << \" \" << (int)l.size() << endl;\n\t\tcout << \"(\";\n\t\tif( !l.empty() ) l.back().out();\n\t\tcout << \")[\" << v << \"](\";\n\t\tif( !r.empty() ) r.back().out();\n\t\tcout << \")\";\n\t}\n};\n\nnode parse(int &p, string &S){\n\tnode ret;\n\tp++;\n\tif( S[p] != ')' ){\n\t\tret.l.push_back( parse(p, S) );\n\t\t//while( S[p] != ')' ) p++;\n\t}\n\tp++;\n\tp++;\n\tint val=0;\n\twhile( S[p] != ']' ){\n\t\tval = val * 10 + (S[p]-'0');\n\t\tp++;\n\t}\n\tret.v = val;\n\tp++;\n\tp++;\n\tif( S[p] != ')' ){\n\t\tret.r.push_back( parse(p, S) );\n\t\t//while( S[p] != ')' ) p++;\n\t}\n\tp++;\n\treturn ret;\n}\n\nnode merge(node &n1, node &n2){\n\tnode ret;\n\tret.v = n1.v + n2.v;\n\tif( !n1.l.empty() && !n2.l.empty() ){\n\t\tret.l.push_back( merge(n1.l[0], n2.l[0]) );\n\t}\n\tif( !n1.r.empty() && !n2.r.empty() ){\n\t\tret.r.push_back( merge(n1.r[0], n2.r[0]) );\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint N, M, T, cur=0, ans=0;\n\tstring S1, S2;\n\n\tcin >> S1 >> S2;\n\tint p1=0, p2=0;\n\tnode n1 = parse(p1, S1);\n\tnode n2 = parse(p2, S2);\n\n\t//n1.out();\n\t//cout << endl;\n\t//n2.out();\n\t//cout << endl;\n\n\tmerge( n1, n2 ).out();\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll INF=2e18;\nstring A,B;\ntypedef string::const_iterator SC;\nll NumParse(SC& it){\n    it++;\n    ll ret=0;\n    while(isdigit(*it)){\n        ret*=10;\n        ret+=*it-'0';\n        it++;\n    }\n    return ret;\n}\nstring Func(ll al, ll ar,ll bl,ll br){\n    //cout<<\"ok\"<<endl;\n    ll rootA;\n    ll rootBeginA;\n    ll rootEndA;\n    ll lCount=0;\n    ll rCount=0;\n    for(ll i=al;i<=ar;i++){\n        if(A[i]=='('){\n            lCount++;\n        }else if(A[i]==')'){\n            rCount++;\n        }else if(A[i]=='['){\n            if(lCount==rCount){\n                SC sc=A.begin()+i;\n                rootBeginA=i;\n                rootA = NumParse(sc);\n                rootEndA=sc-A.begin();\n                break;\n            }\n        }\n    }\n    ll rootB;\n    ll rootBeginB;\n    ll rootEndB;\n    lCount=0;\n    rCount=0;\n    for(ll i=bl;i<=br;i++){\n        if(B[i]=='('){\n            lCount++;\n        }else if(B[i]==')'){\n            rCount++;\n        }else if(B[i]=='['){\n            if(lCount==rCount){\n                SC sc=B.begin()+i;\n                rootBeginB=i;\n                rootB = NumParse(sc);\n                rootEndB=sc-B.begin();\n                break;\n            }\n        }\n    }\n    string ret=\"\";\n    if((A[rootBeginA-2]=='(' && A[rootBeginA-1]==')') || (B[rootBeginB-2]=='(' && B[rootBeginB-1]==')')){\n        ret+=\"()\";\n    }else{\n        ret+='(';\n        ret+=Func(al+1,rootBeginA-2,bl+1,rootBeginB-2);\n        ret+=')';\n    }\n    ret+=\"[\"+to_string(rootA+rootB)+\"]\";\n    if((A[rootEndA+1]=='(' && A[rootEndA+2]==')') || (B[rootEndB+1]=='(' && B[rootEndB+2]==')')){\n        ret+=\"()\";\n    }else{\n        ret+='(';\n        ret+=Func(rootEndA+2,ar-1 ,rootEndB+2,br-1);\n        ret+=')';\n    }\n    return ret;\n}\n\nint main(){\n    cin>>A;\n    cin>>B;\n    cout<<Func(0,A.length()-1,0,B.length()-1)<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100000\nusing namespace std;\nint AT[N],BT[N];\n\nbool check(int s,int t, string &str){\n  stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')'&&st.empty())return 0;  \n    if(str[i]==')') st.pop();\n  }\n  return st.empty();\n}\n\nint get_num(string &str,int &idx){\n  int res=0;\n  while(isdigit(str[idx]))res=res*10+str[idx++]-'0';\n  return res;\n}\n\n\nint get_root(int s,int t,string &str){\n  \n   stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(st.empty()&&isdigit(str[i])) return i;\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')') st.pop();\n  }\n  assert(0);\n}\n\n\nvoid make_tree(int s,int t,int tree[N],string &str,int idx){\n  while(s<t&&check(s,t,str)) s++,t--;\n  if(s>=t)return;\n  s--,t++;\n\t\t\t  \n\n  int root=get_root(s,t,str);\n  //  cout <<idx<<\" \"<<root<<endl;\n  //for(int i=s;i<=t;i++) cout <<str[i];cout<<endl;\n  make_tree(s,root-2,tree,str,idx*2+1);\n  tree[idx]=get_num(str,root);\n  make_tree(root+1,t,tree,str,idx*2+2);\n}\n\nstring make_str(int k){\n  if(AT[k]<0||BT[k]<0) return \"\";\n  int num=AT[k]+BT[k];\n  string str;\n  while(num) str=(char)((num%10)+'0')+str,num/=10;\n  return \"(\"+make_str(k*2+1)+\")\"+\"[\"+str+\"]\"+\"(\"+make_str(k*2+2)+\")\";\n}\n\nint main(){\n  string A,B;\n  cin>>A>>B;\n  memset(AT,-1,sizeof(AT));\n  memset(BT,-1,sizeof(BT));\n  make_tree(0,A.size()-1,AT,A,0);\n  make_tree(0,B.size()-1,BT,B,0);\n  cout <<make_str(0)<<endl;  \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nstring a, b;\n\nstring dfs(int l, int r, int p, int q){\n    if(r-l == 0 || q-p == 0) return \"\";\n    int m1 = l, m2 = p, v1 = 0, v2 = 0;\n    int sum = 0;\n    while(true){\n        if(a[m1] == '(') ++sum;\n        else if(a[m1] == ')') --sum;\n        ++m1;\n        if(sum == 0) break;\n    }\n    while(true){\n        if(b[m2] == '(') ++sum;\n        else if(b[m2] == ')') --sum;\n        ++m2;\n        if(sum == 0) break;\n    }\n    string L = \"(\" + dfs(l+1, m1-1, p+1, m2-1) + \")\";\n\n    ++m1;\n    while(isdigit(a[m1])){\n        v1 = v1*10 + a[m1]-'0';\n        ++m1;\n    }\n    m1 += 2;\n    ++m2;\n    while(isdigit(b[m2])){\n        v2 = v2*10 + b[m2]-'0';\n        ++m2;\n    }\n    m2 += 2;\n    string M = \"[\" + to_string(v1+ v2) + \"]\";\n    string R = \"(\" + dfs(m1, r-1, m2, q-1) + \")\";\n\n    return L + M + R;\n}\n\nint main(){\n    cin >> a >> b;\n    cout << dfs(0, a.size(), 0, b.size()) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nstring s, t;\nstring solve(int sl, int sr, int tl, int tr) {\n\tif (sl == sr || tl == tr) return \"\";\n\tint d1 = 0, sp = -1;\n\tfor (int i = sl; i < sr; i++) {\n\t\tif (s[i] == '(') d1++;\n\t\tif (s[i] == ')') d1--;\n\t\tif (d1 == 0) {\n\t\t\tsp = i; break;\n\t\t}\n\t}\n\tint d2 = 0, tp = -1;\n\tfor (int i = tl; i < tr; i++) {\n\t\tif (t[i] == '(') d2++;\n\t\tif (t[i] == ')') d2--;\n\t\tif (d2 == 0) {\n\t\t\ttp = i; break;\n\t\t}\n\t}\n\tint sv = 0, se = -1; sp++;\n\tfor (se = sp + 1; s[se] >= '0' && s[se] <= '9'; se++) sv = sv * 10 + (s[se] - 48); se++;\n\tint tv = 0, te = -1; tp++;\n\tfor (te = tp + 1; t[te] >= '0' && t[te] <= '9'; te++) tv = tv * 10 + (t[te] - 48); te++;\n\tstring retl = solve(sl + 1, sp - 1, tl + 1, tp - 1);\n\tstring retr = solve(se + 1, sr - 1, te + 1, tr - 1);\n\treturn \"(\" + retl + \")[\" + to_string(sv + tv) + \"](\" + retr + \")\";\n}\nint main() {\n\tcin >> s >> t;\n\tcout << solve(0, s.size(), 0, t.size()) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin >= End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin;Begin!=End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      if (rb > End) {\n        rb = End;\n      }\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin(), be = b.end();\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int SIZE = 2001;\n\nint l2[SIZE], r2[SIZE], num[SIZE];\nint lrsize = 0;\n\nint dfs(char *l, char *r){\n  if(l >= r) return -1;\n  char *w = l;\n  int counter = 0;\n  \n  while(*w != '[' || counter){\n    if(w==r) assert(false);\n    if(*w == '(') counter++;\n    if(*w == ')') counter--;\n    w++;\n  }\n\n  *w = '\\0';\n  char *p = w;\n  while(*p != ']') p++;\n  *p = '\\0';\n  p++;\n\n  int t = lrsize++;\n\n  num[t] = atoi(w+1);\n  l2[t] = dfs(l+1, w-1);\n  r2[t] = dfs(p+1, r-1);\n\n  return t;\n}\n\nstring dfs2(int now1, int now2){\n  string L, R;\n  \n  if(l2[now1] != -1 && l2[now2] != -1){\n    L = dfs2(l2[now1], l2[now2]);\n  }else{\n    L = \"\";\n  }\n\n  if(r2[now1] != -1 && r2[now2] != -1){\n    R = dfs2(r2[now1], r2[now2]);\n  }else{\n    R = \"\";\n  }\n\n  return \"(\" + L + \")[\" + to_string(num[now1] + num[now2]) + \"](\" + R + \")\";\n\n}\n\n\nint main(){\n  char a[SIZE], b[SIZE];\n  scanf(\"%s%s\", a, b);\n  \n  int root1 = dfs(a, a + strlen(a));\n  int root2 = dfs(b, b + strlen(b));\n  \n  cout << dfs2(root1, root2) << endl;\n\n  return 0;  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint st[1000000], tt[1000000];\n\nchar *p;\nvoid analyze(int *dst, int i) {\n    switch(*p) {\n        case ')':\n            p++;\n            return;\n        case '(':\n            p++;\n            analyze(dst, i*2+1);\n            break;\n    }\n    p++;\n    dst[i] = 0;\n    while('0' <= *p && *p <= '9')\n        dst[i]*=10, dst[i]+=(*p-'0'), p++;\n    p++;\n    p++;\n\n    analyze(dst, i*2+2);\n    p++;\n}\n\nvoid print_tree(int *tr, int i) {\n    printf(\"(\");\n    if(tr[i*2+1] != -1) print_tree(tr, i*2+1);\n    printf(\")\");\n\n    printf(\"[\");\n    printf(\"%d\", tr[i]);\n    printf(\"]\");\n\n    printf(\"(\");\n    if(tr[i*2+2] != -1) print_tree(tr, i*2+2);\n    printf(\")\");\n}\n\nint main(void) {\n    memset(st, 0xFF, sizeof(st));\n    memset(tt, 0xFF, sizeof(tt));\n\n    char s[2000], t[2000];\n    scanf(\"%s%s\",s,t);\n    p = s;\n    analyze(st, 0);\n    p = t;\n    analyze(tt, 0);\n\n    for(int i=0; i<1000000; i++)\n        if(st[i] == -1 || tt[i] == -1) st[i] = -1;\n        else st[i] += tt[i];\n\n    print_tree(st, 0);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<unordered_map>\nusing namespace std;\nunordered_map<string, int> tree[2], ans;\n\nvoid dfs(string &s, int &i, string &pos, int id){\n  i++;\n  if(s[i] == '('){\n    pos += \"1\";\n    dfs(s, i, pos, id);\n    pos = pos.substr(0, pos.length() - 1);\n  }\n  i+=2;\n  int cnt = 0;\n  while(s[i] != ']')i++, cnt++;\n  string tmp = s.substr(i - cnt, cnt);\n  tree[id][pos] = atoi(tmp.c_str());\n  i+=2;\n  if(s[i] == '('){\n    pos += \"0\";\n    dfs(s, i, pos, id);\n    pos = pos.substr(0, pos.length() - 1);\n  }\n  i++;\n}\n\nvoid PrintAnswer(string &pos){\n  std::cout << \"(\";\n  if(ans.find(pos + \"1\") != ans.end()){\n    pos += \"1\";\n    PrintAnswer(pos);\n    pos = pos.substr(0, pos.length() - 1);\n  }\n  std::cout << \")[\" << ans[pos] << \"](\";\n  if(ans.find(pos + \"0\") != ans.end()){\n    pos += \"0\";\n    PrintAnswer(pos);\n    pos = pos.substr(0, pos.length() - 1);\n  }\n  std::cout << \")\";\n}\n\nint main(){\n  string a, b;\n  std::cin >> a >> b;\n  string p = \"\";\n  int i = 0;\n  dfs(a, i, p, 0);\n  p = \"\";\n  i = 0;\n  dfs(b, i, p, 1);\n  for (auto i:tree[0]){\n    if(tree[1].find(i.first) != tree[1].end()){\n      ans[i.first] = i.second + tree[1][i.first];\n    }\n  }\n  p = \"\";\n  PrintAnswer(p);\n  std::cout << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <functional>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct Node {\n    int value = 0;\n    Node* left = nullptr;\n    Node* right = nullptr;\n    Node(int v, Node* l, Node* r)\n        : value{v}\n        , left{l}\n        , right{r}\n    {\n    }\n};\n\nint main()\n{\n    string a;\n    cin >> a;\n    string b;\n    cin >> b;\n\n    auto parse = [](const string& str) {\n        int i = 0;\n        auto value = [&i, &str]() {\n            auto begin = i;\n            while (isdigit(str[i])) {\n                ++i;\n            }\n            auto end = i - 1;\n            return stoi(str.substr(begin, end - begin + 1));\n        };\n\n        function<Node*()> p = [&p, &i, &str, &value]() -> Node* {\n            if (str[i] == ')') {\n                return nullptr;\n            }\n            ++i; // (\n            auto l = p();\n            ++i; // )\n            ++i; // [\n            auto v = value();\n            ++i; // ]\n            ++i; // (\n            auto r = p();\n            ++i; // )\n            return new Node{v, l, r};\n        };\n        return p();\n    };\n\n    function<void(Node*)> pp = [&pp](Node* n) {\n        if (n) {\n            cout << \"(\";\n            pp(n->left);\n            cout << \")\";\n            cout << '[' << n->value << ']';\n            cout << \"(\";\n            pp(n->right);\n            cout << \")\";\n        }\n    };\n\n    function<Node*(Node*, Node*)> f = [&f](Node* l, Node* r) {\n        auto ll = l->left && r->left ? f(l->left, r->left) : nullptr;\n        auto rr = l->right && r->right ? f(l->right, r->right) : nullptr;\n        return new Node{l->value + r->value, ll, rr};\n    };\n\n    auto t1 = parse(a);\n    auto t2 = parse(b);\n    auto r = f(t1, t2);\n    pp(r);\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n// パースする文字列\nstring s;\n// 次に読み始める位置\nint pos;\n\n// 二分木ノード\nstruct Node\n{\n    int val;\n    Node *l, *r;\n};\n\n// tr := (tr)[num](tr)\n\n// 整数\nint number()\n{\n    int ret = 0;\n    while (isdigit(s[pos]))\n    {\n        ret *= 10;\n        ret += s[pos] - '0';\n        pos++;\n    }\n    return ret;\n}\n\n// パースして二分木のノードを返す\nNode *misawa()\n{\n    if (s[pos] == ')')\n    {\n        // 空ノード\n        return nullptr;\n    }\n    pos++;             // (\n    auto l = misawa(); // left child\n    pos++;             // )\n    pos++;             // [\n    auto v = number();\n    pos++;             // ]\n    pos++;             // (\n    auto r = misawa(); // right child\n    pos++;             // )\n    Node *node = new Node;\n    node->val = v;\n    node->l = l;\n    node->r = r;\n    return node;\n}\n\n// 二分木a, b を合成\nNode *rec(Node *a, Node *b)\n{\n    Node *ret = new Node;\n    ret->val = a->val + b->val;\n    ret->l = nullptr;\n    ret->r = nullptr;\n    if (a->l && b->l)\n    {\n        ret->l = rec(a->l, b->l);\n    }\n    if (a->r && b->r)\n    {\n        ret->r = rec(a->r, b->r);\n    }\n    return ret;\n}\n\n// 二分木を文字列に変換\nstring recstr(Node *node)\n{\n    if (node == nullptr)\n        return \"\";\n    string ret = \"\";\n    ret += \"(\" + recstr(node->l) + \")\";\n    ret += \"[\" + to_string(node->val) + \"]\";\n    ret += \"(\" + recstr(node->r) + \")\";\n    return ret;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    string a, b;\n    cin >> a >> b;\n    s = a;\n    pos = 0;\n    auto at = misawa();\n    s = b;\n    pos = 0;\n    auto bt = misawa();\n    auto ret = rec(at, bt);\n    cout << recstr(ret) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;if(r-l-1==0)exit(0);\n  for(int i=l+1;i<r;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c-1);\n  if(r-1!=c)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size()-1);\n  n=1;node p2=con(0,a[1].size()-1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nP t[1001][2]; int tra[1001][2];\nstring a, b;\nvoid init() {\n\trep(i, 1001) {\n\t\trep(j, 2) {\n\t\t\tt[i][j] = { -1,-1 };\n\t\t\ttra[i][j] = -1;\n\t\t}\n\t}\n}\nvoid maketree(string x,int y) {\n\tP root;\n\tint cnt = 0;\n\tint len = x.length();\n\trep(i, len) {\n\t\tif (x[i] == '(')cnt++;\n\t\tif (x[i] == ')')cnt--;\n\t\tif (x[i]=='['&&cnt==0) {\n\t\t\tstring u;\n\t\t\ti++;\n\t\t\twhile (x[i] != ']') {\n\t\t\t\tu += x[i]; i++;\n\t\t\t}\n\t\t\troot = { i,0 }; tra[0][y] = stoi(u);\n\t\t}\n\t}\n\tqueue<P> q;\n\tq.push(root);\n\tint whe = 1;\n\twhile (!q.empty()) {\n\t\tP now = q.front(); q.pop();\n\t\tint loc = now.first; int num = now.second;\n\t\tcnt = 0;\n\t\tfor (int i = loc - 1; i >= 0; i--) {\n\t\t\tif (i == loc - 1) {\n\t\t\t\twhile (x[i] != '[')i--;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tif (x[i] == ')')cnt++;\n\t\t\tif (x[i] == '(')cnt--;\n\t\t\tif (cnt == 0)break;\n\t\t\tif (x[i] == '['&&cnt == 1) {\n\t\t\t\tint j = i + 1;\n\t\t\t\tstring u;\n\t\t\t\twhile (x[j] != ']') {\n\t\t\t\t\tu += x[j]; j++;\n\t\t\t\t}\n\t\t\t\tt[num][y].first = whe;\n\t\t\t\ttra[whe][y] = stoi(u);\n\t\t\t\tq.push({ j,whe });\n\t\t\t\twhe++;\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tfor (int i = loc + 1; i < len; i++) {\n\t\t\tif (x[i] == '(')cnt++;\n\t\t\tif (x[i] == ')')cnt--;\n\t\t\tif (cnt == 0)break;\n\t\t\tif (x[i] == '['&&cnt == 1) {\n\t\t\t\tint j = i + 1;\n\t\t\t\tstring u;\n\t\t\t\twhile (x[j] != ']') {\n\t\t\t\t\tu += x[j]; j++;\n\t\t\t\t}\n\t\t\t\tt[num][y].second = whe;\n\t\t\t\ttra[whe][y] = stoi(u);\n\t\t\t\tq.push({ j,whe });\n\t\t\t\twhe++;\n\t\t\t}\n\t\t}\n\t}\n}\nstring uniontree(int aa,int ba) {\n\tstring res;\n\tif (aa==-1||ba==-1) {\n\t\tres = \"\";\n\t}\n\telse {\n\t\tint r = tra[aa][0] + tra[ba][1];\n\t\tres += \"(\";\n\t\tres += uniontree(t[aa][0].first, t[ba][1].first);\n\t\tres += \")[\";\n\t\tres += to_string(r);\n\t\tres += \"](\";\n\t\tres += uniontree(t[aa][0].second, t[ba][1].second);\n\t\tres += \")\";\n\t}\n\treturn res;\n}\nint main() {\n\tinit();\n\tcin >> a >> b;\n\tmaketree(a, 0); maketree(b, 1);\n\tcout << uniontree(0,0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nunordered_map<int, int> Left[3], Right[3], val[3];\nint num[3];\nint root[3];\nint f(string::iterator &itr, int index) {\n    /*\n    if(*itr == '[') {\n        itr++;\n        int now = 0;\n        while(*itr != ']') {\n            now *= 10;\n            now += (*itr - '0');\n            itr++;\n        }\n        itr++;\n        num[index]++;\n        val[index][num[index]] = now;\n        return num[index];\n    }\n    */\n    //cerr << *itr << endl;\n    if(*itr == '(') {\n        num[index]++;\n        int pos = num[index];\n        itr++;\n        if(*itr == ')') {\n            itr++;\n            Left[index][pos] = -1;\n        } else {\n            Left[index][pos] = f(itr, index);\n            itr++;\n        }\n        itr++;\n        int now = 0;\n        while(*itr != ']') {\n            now *= 10;\n            now += (int)((*itr) - '0');\n            //cerr << \"PLUS: \" << *itr << endl;\n            itr++;\n        }\n        val[index][pos] = now;\n        itr++;\n        itr++;\n        if(*itr == ')') {\n            itr++;\n            Right[index][pos] = -1;\n        } else {\n            Right[index][pos] = f(itr, index);\n            itr++;\n        }\n        return pos;\n    }\n}\n\nvoid dfs(int now, int index) {\n    cerr << \"pos: \" << now << \" val: \" << val[index][now] << \" left: \" << Left[index][now] << \" right: \" << Right[index][now] << endl;\n    if(Left[index][now] != -1) dfs(Left[index][now], index);\n    if(Right[index][now] != -1) dfs(Right[index][now], index);\n}\n\nvoid merge(int one, int two, int three) {\n    //cerr << one << \" \" << two << \" \" << three << endl;\n    if(Left[0][one] != -1 && Left[1][two] != -1) {\n        num[2]++;\n        Left[2][three] = num[2];\n        val[2][Left[2][three]] = val[0][Left[0][one]] + val[1][Left[1][two]];\n        merge(Left[0][one], Left[1][two], Left[2][three]);\n    } else Left[2][three] = -1;\n    if(Right[0][one] != -1 && Right[1][two] != -1) {\n        num[2]++;\n        Right[2][three] = num[2];\n        val[2][Right[2][three]] = val[0][Right[0][one]] + val[1][Right[1][two]];\n        merge(Right[0][one], Right[1][two], Right[2][three]);\n    } else Right[2][three] = -1;\n}\n\nvoid print(int now) {\n    if(now == -1) return;\n    cout << \"(\";\n    print(Left[2][now]);\n    cout << \")\";\n    cout << \"[\" << val[2][now] << \"]\";\n    cout << \"(\";\n    print(Right[2][now]);\n    cout << \")\";\n}\n\nint main() {\n    //cout.precision(10);\n    string A, B;\n    cin >> A >> B;\n    auto itr = A.begin();\n    root[0] = f(itr, 0);\n    itr = B.begin();\n    root[1] = f(itr, 1);\n    //dfs(root[0], 0);\n    //dfs(root[1], 1);\n    //cerr << root[0] << endl;\n    //cerr << num[0] << endl;\n    //cerr << val[0][1] << \" \" << Left[0][1] << \" \" << Right[0][1] << endl;\n    root[2] = 1;\n    num[2] = 1;\n    //cerr << root[0] << \" \" << root[1] << endl;\n    val[2][1] = val[0][1] + val[1][1];\n    merge(1, 1, 1);\n    //dfs(1, 2);\n    print(1);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Tree{\n  int num;\n  Tree* lhs;\n  Tree* rhs;\n};\n\nint get_val(string& s,int& i){\n  int res=0;\n  while(isdigit(s[i])){\n    res*=10;\n    res+=s[i]-'0';\n    i++;\n  }\n  return res;\n}\n\nTree* build_tree(string&s ,int &i){\n\n  assert(0<=i && i<s.size());\n  if(s[i]==')'){\n    return nullptr;\n  }\n  i++;\n  Tree* lef=build_tree(s,i);\n  assert(s[i]==')');\n  i++;\n  assert(s[i]=='[');\n  i++;\n  int val=get_val(s,i);\n\n  assert(s[i]==']');\n  i++;//]\n  assert(s[i]=='(');\n  i++;//(\n  Tree* rig=build_tree(s,i);\n  assert(s[i]==')');\n  i++;\n  Tree* res=new Tree();\n\n  res->num=val;\n\n  res->lhs=lef;\n  res->rhs=rig;\n  return res;\n}\n\nTree* sum(Tree* a_tree,Tree* b_tree){\n  if(a_tree==nullptr||b_tree==nullptr){\n    return nullptr;\n  }\n\n  Tree* res=new Tree();\n  res->num=(a_tree->num)+(b_tree->num);\n  res->lhs=sum(a_tree->lhs,b_tree->lhs);\n  res->rhs=sum(a_tree->rhs,b_tree->rhs);\n  return res;\n}\n\nstring code(Tree* tree){\n  if(tree==nullptr){\n    return \"\";\n  }\n  string res=\"(\";\n  res+=code(tree->lhs);\n  res+=\")\";\n  res+=\"[\";\n  res+=to_string((tree->num));\n  res+=\"]\";\n  res+=\"(\";\n  res+=code(tree->rhs);\n  res+=\")\";\n  return res;\n}\n\nint main(){\n  string a,b;\n  cin>>a>>b;\n  int i=0;\n  Tree* a_tree=build_tree(a,i);\n  i=0;\n  Tree* b_tree=build_tree(b,i);\n  Tree* c_tree=sum(a_tree,b_tree);\n  string res=code(c_tree);\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s==\"\")\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\ttree t;\n\t\t\tt.num = 0;\n\t\t\tt.left = -1;\n\t\t\tt.right = -1;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 3), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\ttree t;\n\tt.num = 0;\n\tt.left = -1;\n\tt.right = -1;\n\tvt3.push_back(t);\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin== End || Begin+1==End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin;Begin!=End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end()-1, bb = b.begin(), be = b.end()-1;\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstruct Treenode\n{\n\tbool left = false;\n\tbool right = false;\n\tpair<Treenode*, Treenode*> child;\n\tint num = INT_MAX / 6;\n};\n \nTreenode* saiki( string S ) {\n\t//cout << S << endl;\n\tint num = 0;\n\tint xx = 0;\n\tint parentnum = 0;\n\tint s = -1;\n\tint count = 0;\n\tTreenode *reta = new Treenode;\n\tfor( size_t i = 0; i < S.length(); i++ ) {\n\t\tif( S[i] == '(' ) {\n\t\t\tnum++;\n\t\t\tif( s == -1 ) {\n\t\t\t\ts = i;\n\t\t\t}\n\t\t} else if( S[i] == ')' ) {\n\t\t\tnum--;\n\t\t\tif( num == 0 ) {\n\t\t\t\tif( count == 0 ) {\n\t\t\t\t\tif( i - s > 1 ) {\n\t\t\t\t\t\t(*reta).child.first = saiki( S.substr( s + 1, i - s - 1 ) );\n\t\t\t\t\t\tif( (*(*reta).child.first).num != INT_MAX / 6 ) {\n\t\t\t\t\t\t\t(*reta).left = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t\t} else {\n\t\t\t\t\tif( i - s > 1 ) {\n\t\t\t\t\t\t(*reta).child.second = saiki( S.substr( s + 1, i - s - 1 ) );\n\t\t\t\t\t\tif( (*(*reta).child.second).num != INT_MAX / 6 ) {\n\t\t\t\t\t\t\t(*reta).right = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts = -1;\n\t\t\t}\n\t\t} else if( S[i] == '[' ) {\n\t\t\txx = 0;\n\t\t} else if( S[i] == ']' ) {\n\t\t\tif( num == 0 ) {\n\t\t\t\t(*reta).num = xx;\n\t\t\t}\n\t\t} else {\n\t\t\txx *= 10;\n\t\t\txx += S[i] - '0';\n\t\t}\n\t}\n\treturn reta;\n}\n \nTreenode* saiki2( Treenode* A, Treenode* B ) {\n\tTreenode* retc = new Treenode;\n\t(*retc).num = (*A).num + (*B).num;\n \n\tif( (*A).left && (*B).left ) {\n\t\t(*retc).left = true;\n\t\t(*retc).child.first = saiki2( (*A).child.first, (*B).child.first );\n\t}\n\tif( (*A).right && (*B).right ) {\n\t\t(*retc).right = true;\n\t\t(*retc).child.second = saiki2( (*A).child.second, (*B).child.second );\n\t}\n\treturn retc;\n \n}\n \nstring saiki3( Treenode* C ) {\n\tstring ret = \"\";\n\tif( (*C).left ) {\n\t\tret += '(' + saiki3( (*C).child.first ) + ')';\n\t} else {\n\t\tret += \"()\";\n\t}\n\tret += '[' + to_string( (*C).num ) + ']';\n\tif( (*C).right ) {\n\t\tret += '(' + saiki3( (*C).child.second ) + ')';\n\t} else {\n\t\tret += \"()\";\n\t}\n\treturn ret;\n \n}\n \nint main() {\n\tstring A, B;\n\tcin >> A >> B;\n\tTreenode* Atree = saiki( A );\n\tTreenode* Btree = saiki( B );\n\tTreenode* Ctree = saiki2( Atree, Btree );\n\tcout << saiki3( Ctree ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for (int i = (int)(s); i < (int)(n); i++)\nconst ll mod = ll(1e9) + 7;\nconst int INF = int(1e9);\n\nint idxa = 0, idxb = 0;\n\nint calc(string &A, string &B)\n{\n    string tmpa, tmpb;\n    idxa++;\n    idxb++;\n    while (A[idxa] != ']')\n    {\n        tmpa.push_back(A[idxa++]);\n    }\n    while (B[idxb] != ']')\n    {\n        tmpb.push_back(B[idxb++]);\n    }\n    //cout << tmpa << \" \" << tmpb << endl;\n    return stoi(tmpa) + stoi(tmpb);\n}\nint proceed(int idx, string &C)\n{\n    int cnt = 1;\n    while (1)\n    {\n        idx++;\n        if (C[idx] == ')')\n            cnt--;\n        if (C[idx] == '(')\n            cnt++;\n        if (cnt < 0)\n            break;\n    }\n    return idx;\n}\n\nint main()\n{\n    string A, B;\n    cin >> A >> B;\n    string ans;\n    while (idxa < A.size())\n    {\n        if (A[idxa] == B[idxb])\n        {\n            if (A[idxa] == '[')\n            {\n                ans.push_back('[');\n                int tmp = calc(A, B);\n                ans += to_string(tmp);\n                ans.push_back(']');\n            }\n            else\n                ans.push_back(A[idxa]);\n        }\n        else\n        {\n            if (A[idxa] == '(')\n                idxa = proceed(idxa, A);\n            else\n            {\n                idxb = proceed(idxb, B);\n            }\n            ans.push_back(A[idxa]);\n        }\n        idxa++;\n        idxb++;\n        //cout << ans << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint pos;\nstring S;\nstruct Node\n{\n    using Ptr = shared_ptr<Node>;\n    Node(const int v, const Ptr l, const Ptr r) : value{v}, l{l}, r{r} {}\n    int value;\n    Ptr l, r;\n};\nusing Ptr = Node::Ptr;\nPtr parse()\n{\n    if (S[pos] == ')') { return Ptr{}; }\n    pos++;\n    const Ptr l = parse();\n    pos += 2;\n    int num = 0;\n    for (; isdigit(S[pos]); pos++) { num = num * 10 + S[pos] - '0'; }\n    pos += 2;\n    const Ptr r = parse();\n    pos++;\n    return make_shared<Node>(num, l, r);\n}\nPtr merge(const Ptr t1, const Ptr t2)\n{\n    const int sum = t1->value + t2->value;\n    Ptr l;\n    if (t1->l and t2->l) { l = merge(t1->l, t2->l); }\n    Ptr r;\n    if (t1->r and t2->r) { r = merge(t1->r, t2->r); }\n    return make_shared<Node>(sum, l, r);\n}\nstring dump(const Ptr t) { return t == nullptr ? \"()\" : \"(\" + dump(t->l) + \"[\" + to_string(t->value) + \"]\" + dump(t->r) + \")\"; }\nint main()\n{\n    cin >> S;\n    const auto t1 = parse();\n    pos = 0;\n    cin >> S;\n    const auto t2 = parse();\n    const auto t = merge(t1, t2);\n    string ans = dump(t);\n    cout << ans.substr(1, ans.size() - 2) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr long double EPS = 1e-8;\n\nlong long int N, M, K, L, R, H, W;\n//int N, M, K, L, R, H, W;\n\nmap<string, int>mp;\nmap<string, int>n;\n\nvoid func(string s, string t) {\n\tint num = 0;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '(')num++;\n\t\tif (s[i] == ')')num--;\n\t\tif (s[i] == '[' && !num) {\n\t\t\tint st = i;\n\t\t\tint len = 1;\n\t\t\tfor (int j = i + 1; j < s.size(); j++) {\n\t\t\t\tif (s[j] == ']') {\n\t\t\t\t\tlen++;\n\t\t\t\t\tn[t]++;\n\t\t\t\t\tmp[t] += stoi(s.substr(i + 1, len - 2));\n\t\t\t\t\tfunc(s.substr(0+1, i-2), t + \"0\");\n\t\t\t\t\tfunc(s.substr(j + 2, s.size() - j - 3), t + \"1\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse len++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstring Ans(string s) {\n\tif (n[s] < 2)return \"\";\n\tauto t = s + \"0\";\n\tauto u = s + \"1\";\n\treturn \"(\" + Ans(t) + \")\" + \"[\" + to_string(mp[s]) + \"]\" + \"(\" + Ans(u) + \")\";\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tstring s, t;\n\tcin >> s >> t;\n\tvector<vector<int>>v;\n\tvector<vector<int>>w;\n\tfunc(s, \"\");\n\tfunc(t, \"\");\n\tcout << Ans(\"\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n\nstruct Tree {\n    struct Node {\n        int value;\n        Node *left, *right;\n    } *root;\n    Node *parse_tree(const char str[], size_t &i) {\n        assert(str[i] == '(');\n\n        Node *node=new Node;\n        node->left = parse_node(str, i);\n        assert(str[i] == '[');\n        node->value = parse_int(str, ++i);\n        assert(str[i] == ']');\n        ++i;\n        assert(str[i] == '(');\n        node->right = parse_node(str, i);\n\n        return node;\n    }\n    Node *parse_node(const char str[], size_t &i) {\n        assert(str[i] == '(');\n        Node *node=(str[++i]==')'? nullptr:parse_tree(str, i));\n        assert(str[i] == ')');\n        ++i;\n\n        return node;\n    }\n    int parse_int(const char str[], size_t &i) {\n        int res=0;\n        while (str[i] <= '9')\n            res = res*10 + str[i++]-'0';\n\n        return res;\n    }\n    void clear(Node *node) {\n        if (!node) return;\n\n        clear(node->left);\n        clear(node->right);\n        delete node;\n    }\n    Tree(const char str[], size_t &i): root(parse_tree(str, i)) {}\n    ~Tree() {\n        clear(root);\n    }\n};\n\nusing Node=Tree::Node;\n\nvoid dfs(const Node *s, const Node *t) {\n    if (s->left && t->left) {\n        printf(\"(\");\n        dfs(s->left, t->left);\n        printf(\")\");\n    } else {\n        printf(\"()\");\n    }\n\n    printf(\"[%d]\", s->value+t->value);\n\n    if (s->right && t->right) {\n        printf(\"(\");\n        dfs(s->right, t->right);\n        printf(\")\");\n    } else {\n        printf(\"()\");\n    }\n}\n\nint main() {\n    char A[1024], B[1024];\n    scanf(\"%s %s\", A, B);\n\n    size_t i=0, j=0;\n    Tree a(A, i), b(B, j);\n\n    dfs(a.root, b.root);\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int v;\n  int depth;\n  node *l,*r,*p;\n};\n\nstring s[3];\nint dpnum[1000]={0};\nnode *tree[3];\n\nstring encode(node *x,node *y);\nvoid decode(int num,int n,int dep,node *par);\n\nint main(){\n  cin >> s[0] >> s[1];\n  //s[0]=\"(()[6]())[8](((()[4]())[7]())[9]())\";\n  for(int i=0;i<3;i++){\n    tree[i]=new node;\n    tree[i]->p=NULL;\n    tree[i]->l=NULL;\n    tree[i]->r=NULL;\n    tree[i]->depth=0;\n    tree[i]->v=-1;\n  }\n  decode(0,0,0,tree[0]);\n  //cout << tree[0]->v <<\" \"<<tree[0]->l->v << \" \"<< tree[0]->r->v<<\" \"<<tree[0]->r->l->v <<\" \"<< tree[0]->r->l->l->v<<endl;\n  decode(1,0,0,tree[1]);\n  cout << encode(tree[0],tree[1]) << endl;\n  return 0;\n}\n\nvoid decode(int num,int n,int dep,node *par){\n  //cout << n << \" \" << s[num][n] << \" \"<<dep <<\" \" << par->v << endl;\n  if(n==s[num].size())return;\n  if(s[num][n]=='('){\n    node *newnode = new node;\n    newnode->r=NULL;\n    newnode->l=NULL;\n    newnode->p=par;\n    newnode->depth=dep+1;\n    newnode->v=-1;\n    if(n!=0&&s[num][n-1]==']'){\n      par->r=newnode;\n    }\n    else {\n      par->l=newnode;\n    }\n    decode(num,n+1,dep+1,newnode);\n  }\n  else if(s[num][n]==')')decode(num,n+1,dep-1,par->p);\n  else if(s[num][n]=='['){\n    int x=0;\n    while(s[num][n+1]>='0'&&s[num][n+1]<='9'){\n      n++;\n      x*=10;\n      x+=s[num][n]-'0';\n    }\n    par->v=x;\n    //cout <<\"in \"<<dep << par->v <<endl;\n    decode(num,n+2,dep,par);\n  }\n}\n\nstring encode(node *x,node *y){\n  string ansl,ansm,ansr;\n  if(x->l==NULL||y->l==NULL||x->l->v==-1||y->l->v==-1)ansl=\"()\";\n  else ansl = encode(x->l,y->l);\n  if(x->r==NULL||y->r==NULL||x->r->v==-1||y->r->v==-1)ansr=\"()\";\n  else ansr = encode(x->r,y->r);\n  ansm=\"[\"+to_string(x->v+y->v)+\"]\";\n  if(x==tree[0])return ansl+ansm+ansr;\n  else return \"(\"+ansl+ansm+ansr+\")\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;\n  for(int i=l+1;i<r-1;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c);\n  if(r-1!=c+1)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(-1,a[0].size()+1);\n  n=1;node p2=con(-1,a[1].size()+1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\tvt.push_back({num,0,0});\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\tvt3.push_back({tree1[a].num+tree2[b].num,0,0 });\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// T := (T)[V](T) | e\n\nvoid waste(string &s,int &i){\n    if(s[i] == ')') return; // e\n    i++; // (\n    waste(s,i);\n    i++; // )\n    i++; // [\n    while(isdigit(s[i])) i++;\n    i++; // ]\n    i++; // (\n    waste(s,i);\n    i++; // )\n}\n\nstring unite(string &s1,string &s2,int &a, int &b){\n    if(s1[a] == ')'){\n        waste(s2,b);\n        return \"\";\n    }\n    if(s2[b] == ')'){\n        waste(s1,a);\n        return \"\";\n    }\n\n    string res;\n    res += \"(\", a++, b++; // (\n    res += unite(s1,s2,a,b);\n    res += \")\", a++, b++; // )\n    res += \"[\", a++, b++; // [\n    int n1 = 0, n2 = 0;\n    while(isdigit(s1[a])){\n        n1 = n1*10 + s1[a]-'0';\n        a++;\n    }\n    while(isdigit(s2[b])){\n        n2 = n2*10 + s2[b]-'0';\n        b++;\n    }\n    res += to_string(n1+n2);\n    res += \"]\", a++, b++; // ]\n    res += \"(\", a++, b++; // (\n    res += unite(s1,s2,a,b);\n    res += \")\", a++, b++; // )\n    return res;\n}\n\nint main(void){\n    string s1,s2;\n    cin>>s1>>s2;\n    int a = 0, b = 0;\n    cout<<unite(s1,s2,a,b)<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Tree {\npublic:\n  Tree(Tree *parent) {\n    num = -1;\n    this->parent = parent;\n    child[0] = child[1] = NULL;\n    cnt = 0;\n  }\n\n  ~Tree() {\n    for (int i = 0; i < cnt; i++) {\n      delete child[i];\n    }\n  }\n  \n  // debug\n  void print() {\n    if (num != -1) {\n      if (cnt >= 1) {\n\tcout << '(';\n\tchild[0]->print();\n\tcout << ')';\n      }\n      cout << '[' << num << ']';\n      if (cnt >= 2) {\n\tcout << '(';\n\tchild[1]->print();\n\tcout << ')';\n      }\n    }\n  }\n\n  void merge(Tree *t) {\n    num += t->num;\n    for (int i = 0; i < cnt; i++) {\n      if (child[i]->num != -1 && t->child[i]->num != -1) {\n\tchild[i]->merge(t->child[i]);\n      } else {\n\tchild[i]->num = -1;\n      }\n    }\n  }\n  \n  int num;\n  Tree *parent;\n  Tree *child[2];\n  int cnt;\n};\n\nTree *readTree() {\n  char c = '\\0';\n\n  Tree *root = new Tree(NULL);\n  for (Tree *t = root; c != ')' || t != root || root->cnt != 2;) {\n    cin >> c;\n    if (c == '(') {\n      t->child[t->cnt] = new Tree(t);\n      t->cnt++;\n      t = t->child[t->cnt - 1];\n    }\n    if (c == ')') {\n      t = t->parent;\n    }\n    if (c == '[') {\n      int num;\n      cin >> num;\n      t->num = num;\n      cin >> c;\n    }\n  }\n\n  return root;\n}\n\nint main() {\n  Tree *t1 = readTree();\n  Tree *t2 = readTree();\n  t1->merge(t2);\n  t1->print();\n  cout << endl;\n\n  delete t1, t2;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\n\nstruct Node{\n    int val;\n    Node *lch, *rch;\n    Node(int x = 0) : val(x),lch(nullptr), rch(nullptr){}\n};\n\nNode* add(Node* l,Node* r){\n    Node* ret = new Node;\n    ret->val = l->val + r->val;\n    if(l->lch&&r->lch){\n        ret->lch = add(l->lch, r->lch);\n    }\n    if(l->rch&&r->rch){\n        ret->rch = add(l->rch, r->rch);\n    }\n    return ret;\n}\n\nNode* ston(string& s,int& idx){\n    if(s[idx]==')'){\n        idx++;\n        return nullptr;\n    }\n    ++idx;\n    auto lch = ston(s,idx);\n    ++idx;\n    int val=0;\n    while(s[idx]!=']'){\n        val=10*val+s[idx]-'0';\n        ++idx;\n    }\n    ++idx;\n    ++idx;\n    auto rch = ston(s,idx);\n    ++idx;\n    Node* ret = new Node(val);\n    if(lch)ret->lch = lch;\n    if(rch)ret->rch = rch;\n\n    return ret;\n}\nstring itos(int a){\n    if(a==0)return \"0\";\n    string res=\"\";\n    while(a){\n        res=char(a%10+'0')+res;\n        a/=10;\n    }\n    return res;\n}\nstring ntos(Node* t){\n    string ret;\n    ret+='(';\n    if(t->lch)ret+=ntos(t->lch);\n    ret+=\")[\";\n    ret+=itos(t->val);\n    ret+=\"](\";\n    if(t->rch)ret+=ntos(t->rch);\n    ret+=')';\n    return ret;\n}\nint main(){\n    string s,t;\n    cin>>s>>t;\n    int is=0,it=0;\n    auto ss = ston(s,is);\n    auto tt = ston(t,it);\n    auto uu = add(ss,tt);\n    auto ans = ntos(uu);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct node{\n  int num=-1;\n  struct node* r=NULL;\n  struct node* l=NULL;\n};\n\nvoid decode(string s,struct node* now){\n  int i=0;\n  int l=0,r=0;\n  for(;;i++){\n    if(s[i]=='(') l++;\n    else if(s[i]==')') r++;\n    if(l==r){\n      if(i>1){\n        now->l=new struct node;\n        decode(s.substr(1,i-1),now->l);\n      }\n      break;\n    }\n  }\n  int tmp=i;\n  for(;;i++){\n    if(s[i]==']'){\n      now->num=stoi(s.substr(tmp+2,i-1));\n      break;\n    }\n  }\n  if(i<s.length()-3){\n    now->r=new struct node;\n    decode(s.substr(i+2,s.length()-4-i),now->r);\n  }\n  return;\n}\n\nstring encode(struct node* now){\n  if(now!=NULL){\n    return \"(\"+encode(now->l)+\")[\"+to_string(now->num)+\"](\"+encode(now->r)+\")\";\n  }else{\n    return \"\";\n  }\n}\n\nvoid merge(struct node* now,struct node* anow,struct node* bnow){\n  now->num=anow->num+bnow->num;\n  if(anow->l!=NULL&&bnow->l!=NULL){\n    now->l=new struct node;\n    merge(now->l,anow->l,bnow->l);\n  }\n  if(anow->r!=NULL&&bnow->r!=NULL){\n    now->r=new struct node;\n    merge(now->r,anow->r,bnow->r);\n  }\n  return;\n}\n\nint main(){\n  string a,b;\n  cin >> a >> b;\n  struct node A,B,ans;\n  decode(a,&A);\n  decode(b,&B);\n  merge(&ans,&A,&B);\n  // for(int i=0;i<50;i++){\n  //   cout << A[i] << \" \";\n  // }\n  // cout << endl;\n  cout << encode(&ans) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef string::const_iterator State;\n\nvoid assume(State &begin1, State &begin2, char expected, string &s) {\n    // cerr << \"assume: \" << *begin1 << \", \" << *begin2 << \", \" << expected << \", \" << s << endl;\n\n    assert(*begin1 == expected && *begin2 == expected);\n    s += *begin1;\n    begin1++;   begin2++;\n}\n\nstring number(State &begin1, State &begin2) {\n    // cerr << \"number: \" << *begin1 << \", \" << *begin2 << endl;\n\n    int val1 = 0;\n    while (isdigit(*begin1)) {\n        val1 *= 10;\n        val1 += *begin1 - '0';\n        begin1++;\n    }\n    int val2 = 0;\n    while (isdigit(*begin2)) {\n        val2 *= 10;\n        val2 += *begin2 - '0';\n        begin2++;\n    }\n    return to_string(val1 + val2);\n}\n\nstring node(State &begin1, State &begin2) {\n    // cerr << \"node: \" << *begin1 << \", \" << *begin2 << endl;\n\n    if (*begin1 == ')') {\n        int depth = 1;\n        for(;;) {\n            if (*begin2 == '(') {\n                depth++;\n            } else if (*begin2 == ')') {\n                depth--;\n            }\n            if (depth == 0) {\n                return \"\";\n            }\n            begin2++;\n        }\n    }\n    if (*begin2 == ')') {\n        int depth = 1;\n        for(;;) {\n            if (*begin1 == '(') {\n                depth++;\n            } else if (*begin1 == ')') {\n                depth--;\n            }\n            if (depth == 0) {\n                return \"\";\n            }\n            begin1++;\n        }\n    }\n\n    string ret = \"\";\n\n    assume(begin1, begin2, '(', ret);\n    ret += node(begin1, begin2);\n    assume(begin1, begin2, ')', ret);\n    assume(begin1, begin2, '[', ret);\n    ret += number(begin1, begin2);\n    assume(begin1, begin2, ']', ret);\n    assume(begin1, begin2, '(', ret);\n    ret += node(begin1, begin2);\n    assume(begin1, begin2, ')', ret);\n\n    return ret;\n\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string s1, s2;\n    cin >> s1 >> s2;\n    State begin1 = s1.begin();\n    State begin2 = s2.begin();\n    cout << node(begin1, begin2) << endl;\n    assert(begin1 == s1.end() && begin2 == s2.end());\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid parse(string S, vector<pair<int, vector<int>>> &C){\n  int v = C.size();\n  C.push_back(make_pair(-1, vector<int>(2, -1)));\n  int N = S.size();\n  int cnt = 0;\n  int p = 0;\n  for (int i = 0; i < N; i++){\n    if (S[i] == '('){\n      cnt++;\n    }\n    if (S[i] == ')'){\n      cnt--;\n    }\n    if (S[i] == '[' && cnt == 0){\n      p = i;\n      break;\n    }\n  }\n  string T = S.substr(1, p - 2);\n  if (T != \"\"){\n    C[v].second[0] = C.size();\n    parse(T, C);\n  }\n  int q = p;\n  while (S[q] != ']'){\n    q++;\n  }\n  C[v].first = stoi(S.substr(p + 1, q - 1));\n  string T2 = S.substr(q + 2, N - q - 3);\n  if (T2 != \"\"){\n    C[v].second[1] = C.size();\n    parse(T2, C);\n  }\n  return;\n}\nvoid dfs1(vector<pair<int, vector<int>>> &T1, vector<pair<int, vector<int>>> &T2, vector<pair<int, vector<int>>> &T3, int u = 0, int v = 0){\n  int w = T3.size();\n  T3.push_back(make_pair(0, vector<int>(2, -1)));\n  if (u != -1){\n    T3[w].first += T1[u].first;\n  }\n  if (v != -1){\n    T3[w].first += T2[v].first;\n  }\n  for (int i = 0; i < 2; i++){\n    int c1 = -1;\n    if (u != -1){\n      c1 = T1[u].second[i];\n    }\n    int c2 = -1;\n    if (v != -1){\n      c2 = T2[v].second[i];\n    }\n    if (c1 != -1 && c2 != -1){\n      T3[w].second[i] = T3.size();\n      dfs1(T1, T2, T3, c1, c2);\n    }\n  }\n  \n  int cl1 = -1;\n  if (u != -1){\n    cl1 = T1[u].second[0];\n  }\n}\nstring dfs2(vector<pair<int, vector<int>>> &T3, int v = 0){\n  string ans = \"\";\n  ans += \"(\";\n  if (T3[v].second[0] != -1){\n    ans += dfs2(T3, T3[v].second[0]);\n  }\n  ans += \")\";\n  ans += \"[\";\n  ans += to_string(T3[v].first);\n  ans += \"]\";\n  ans += \"(\";\n  if (T3[v].second[1] != -1){\n    ans += dfs2(T3, T3[v].second[1]);\n  }\n  ans += \")\";\n  return ans;\n}\nint main(){\n  string A;\n  cin >> A;\n  string B;\n  cin >> B;\n  vector<pair<int, vector<int>>> T1;\n  parse(A, T1);\n  vector<pair<int, vector<int>>> T2;\n  parse(B, T2);\n  \n  int N = T1.size();\n  vector<pair<int, vector<int>>> T3;\n  dfs1(T1, T2, T3);\n  int M = T3.size();\n  cout << dfs2(T3) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;\n  for(int i=l+1;i<r;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c-1);\n  if(r-1!=c)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size()-1);\n  n=1;node p2=con(0,a[1].size()-1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s==\"\")\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = vt.size();\n\t\t\ttree t;\n\t\t\tt.num = 0;\n\t\t\tt.left = -1;\n\t\t\tt.right = -1;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 3), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = vt3.size();\n\ttree t;\n\tt.num = 0;\n\tt.left = -1;\n\tt.right = -1;\n\tvt3.push_back(t);\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nstring solve(string s1, string s2) {\n\tint cnt = 0;\n\tint l = 1, r = 0;\n\n\tint s1n=-1;\n\tstring ls1, rs1;\n\tfor (int i = 1; i < s1.size() - 1; i++) {\n\t\tif (s1[i] == '(')cnt++;\n\t\telse if (s1[i] == ')')cnt--;\n\n\t\tif (cnt == 0 && l == 1) {\n\t\t\tr = i;\n\t\t\tls1 = s1.substr(l, r - l + 1);\n\n\t\t\ti += 2;\n\n\t\t\tint l2 = i;\n\t\t\twhile (1) {\n\t\t\t\ti++;\n\t\t\t\tif (s1[i] == ']') {\n\t\t\t\t\ts1n = stoi(s1.substr(l2, i - l2).data());\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tl = r = i;\n\t\t\ti--;\n\t\t}\n\t\telse if (cnt == 0){\n\t\t\tr = i;\n\t\t\trs1 = s1.substr(l, r - l + 1);\n\t\t}\n\t}\n\n\n\tl = 1, r = 0;\n\n\tint s2n=-1;\n\tstring ls2, rs2;\n\tfor (int i = 1; i < s2.size() - 1; i++) {\n\t\tif (s2[i] == '(')cnt++;\n\t\telse if (s2[i] == ')')cnt--;\n\n\t\tif (cnt == 0 && l == 1) {\n\t\t\tr = i;\n\t\t\tls2 = s2.substr(l, r - l + 1);\n\n\t\t\ti += 2;\n\n\t\t\tint l2 = i;\n\t\t\twhile (1) {\n\t\t\t\ti++;\n\t\t\t\tif (s2[i] == ']') {\n\t\t\t\t\ts2n = stoi(s2.substr(l2, i - l2).data());\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tl = r = i;\n\t\t\ti--;\n\t\t}\n\t\telse if (cnt == 0) {\n\t\t\tr = i;\n\t\t\trs2 = s2.substr(l, r - l + 1);\n\t\t}\n\t}\n\n\tif (s1n == -1 || s2n == -1)return \"\";\n\n\treturn \"(\" + solve(ls1,ls2) + \")\" + \"[\" + to_string(s1n + s2n) + \"]\" + \"(\" + solve(rs1, rs2) + \")\";\n}\n\nint main()\n{\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\n\ts1.insert(s1.begin(), '(');\n\ts1.push_back(')');\n\ts2.insert(s2.begin(), '(');\n\ts2.push_back(')');\n\t\n\tcout << solve(s1, s2) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstring a,b;\nint placeA,placeB;\n\nvoid dfs(){\n\tcout << '(';\n\tint num = 0;\n\tint tmp;\n\tif(a[placeA+1] == '(' && b[placeB+1] == '('){\n\t\tplaceA++;\n\t\tplaceB++;\n\t\tdfs();\n\t}\n\telse{\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(a[placeA] == '(')tmp++;\n\t\t\tif(a[placeA] == ')')tmp--;\n\t\t\tplaceA++;\n\t\t}while(tmp != 0);\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(b[placeB] == '(')tmp++;\n\t\t\tif(b[placeB] == ')')tmp--;\n\t\t\tplaceB++;\n\t\t}while(tmp != 0);\n\t}\n\twhile(!isdigit(a[placeA]))placeA++;\n\twhile(!isdigit(b[placeB]))placeB++;\n\tcout << \")[\";\n\ttmp = 0;\n\n\twhile(isdigit(a[placeA])){\n\t\ttmp *= 10;\n\t\ttmp += a[placeA] - '0';\n\t\tplaceA++;\n\t}\n\tnum += tmp;\n\tDBG(cout << \"A is \" << tmp << endl;);\n\ttmp = 0;\n\twhile(isdigit(b[placeB])){\n\t\ttmp *= 10;\n\t\ttmp += b[placeB] - '0';\n\t\tplaceB++;\n\t}\n\tnum += tmp;\n\tplaceA++;\n\tplaceB++;\n\t\n\tif(a[placeA+1] == '(' && b[placeB+1] == '('){\n\t\tplaceA++;\n\t\tplaceB++;\n\t\tdfs();\n\t}\n\telse{\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(a[placeA] == '(')tmp++;\n\t\t\tif(a[placeA] == ')')tmp--;\n\t\t\tplaceA++;\n\t\t}while(tmp != 0);\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(b[placeB] == '(')tmp++;\n\t\t\tif(b[placeB] == ')')tmp--;\n\t\t\tplaceB++;\n\t\t}while(tmp != 0);\n\t}\n\tcout << \")\";\n}\n\nint main()\n{\n\tcin >> a >> b;\n\tdfs();\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//木を実装する\ntypedef struct _node{\n    int element;\n    struct _node *left;\n    struct _node *right;\n    struct _node *par;\n}node;\n\ntypedef struct _tree{\n    node *root;\n}tree;\n\n//リストを生成する関数\ntree *create(){\n    tree *T = (tree *)malloc(sizeof(tree));\n    T->root = (node *)malloc(sizeof(node));\n    T->root->left = NULL;\n    T->root->right = NULL;\n    T->root->par = NULL;\n    T->root->element = -1;\n    return T;\n}\n\nvoid make_tree(tree *T, string s){\n    node *ptr = T->root;\n\n    for(int i = 0; i < (int) s.size(); i++){\n\n        if(s[i] == '('){\n            //どっちかににノードを足す\n            node *add = (node *)malloc(sizeof(node));\n            add->element = -1;\n            add->left = NULL;\n            add->right = NULL;\n            add->par = ptr;\n\n            //左\n            if(ptr->left == NULL){\n                ptr->left = add;\n                ptr = add;\n            }else{\n                ptr->right = add;\n                ptr = add;\n            }\n        }else if(s[i] == ')'){\n            //戻る\n            ptr = ptr->par;\n        }else if(s[i] == '['){\n            string str;\n            int j;\n            for(j = i + 1; s[j] != ']'; j++) str.push_back(s[j]);\n            int num = stoi(str);\n            ptr->element = num;\n            i = j;\n        }\n    }\n}\n\nvoid print_tree(node *v){\n    if(v == NULL || v->element == -1){\n        cout << \")\";\n        return;\n    }\n\n    cout << \"(\";\n    print_tree(v->left);\n    cout << \"[\" << v->element << \"]\";\n    cout << \"(\";\n    print_tree(v->right);\n    if(v->par != NULL) cout << \")\";\n    return;\n}\n\nvoid sum_tree(node *v1, node *v2, node *v3){\n    v3->element = v1->element + v2->element;\n\n    if(v1->left != NULL && v2->left != NULL && v1->left->element != -1 && v2->left->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->left = add;\n        sum_tree(v1->left, v2->left, v3->left);\n    }\n    \n    if(v1->right != NULL && v2->right != NULL && v1->right->element != -1 && v2->right->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->right = add;        \n        sum_tree(v1->right, v2->right, v3->right);\n    }\n    \n    //if(v->par != NULL) cout << \")\";\n    return;\n    \n}\n\nint main(){\n\n    string s1, s2; cin >> s1 >> s2;\n    tree *T1 = create();\n    tree *T2 = create();\n    tree *T3 = create();    \n    make_tree(T1, s1);\n    make_tree(T2, s2);\n    sum_tree(T1->root, T2->root, T3->root); \n    print_tree(T3->root);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing lst = list<int>;\n\nstruct Node\n{\n    Node * right = nullptr;\n    Node * left  = nullptr;\n    int value;\n};\n\nint parseInt(string & str,int & i)\n{\n    int rtn=0;\n    while(str[i]>='0'&&str[i]<='9')\n    {\n        rtn *= 10;\n        rtn += (int)(str[i]-'0');\n        ++i;\n    }\n    return rtn;\n}\n\nNode * makeTree(string & str,int & i)\n{\n    if(str[i]==')')return nullptr;\n    Node * current = new Node;\n    ++i; // (\n    current->left = makeTree(str,i);\n    ++i; // )\n    ++i; // [\n    current->value = parseInt(str,i);\n    ++i; // ]\n    ++i; // (\n    current->right = makeTree(str,i);\n    ++i; // )\n    return current;\n}\n\nvoid output(Node * A,Node * B)\n{\n    cout << \"(\";\n    if(A->left && B->left)\n    {\n        output(A->left,B->left);\n    }\n    cout << \")[\";\n    cout << A->value + B->value;\n    cout << \"](\";\n    if(A->right && B->right)\n    {\n        output(A->right,B->right);\n    }\n    cout << \")\";\n}\n\n\nint main()\n{\n    string A,B;\n    cin >> A >> B;\n    int i=0;\n    Node * ATree = makeTree(A,i);\n    i=0;\n    Node * BTree = makeTree(B,i);\n\n    output(ATree,BTree);\n    cout << endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int NUM = 3000;\nclass tree{\n    public:\n    int value[NUM];\n    int left[NUM];\n    int right[NUM];\n    queue<int>iQ;\n    queue<int>lQ;\n    queue<int>rQ;\n    void push(int idx, int l, int r){\n        iQ.push(idx);\n        lQ.push(l);\n        rQ.push(r);\n    }\n    tree(string s){\n        for(int i = 0; i < NUM; i++){\n            value[i] = -1;\n            left[i] = -1;\n            right[i] = -1;\n        }\n        int cnt = 0;\n        push(0, 0, s.size() - 1); cnt++;\n        while(!iQ.empty()){\n            int idx = iQ.front(); iQ.pop();\n            int l = lQ.front(); lQ.pop();\n            int r = rQ.front(); rQ.pop();\n            if(l + 1 >= r)continue;\n            \n            int sum;\n            sum = 0;\n            int LR = l;\n            for(;LR==l || sum; LR++){\n                if(s[LR] == '(')sum++;\n                if(s[LR] == ')')sum--;\n            }\n            sum = 0;\n            int RL = r;\n            for(;RL == r || sum; RL--){\n                if(s[RL] == ')')sum++;\n                if(s[RL] == '(')sum--;\n            }\n            stringstream ss;\n            for(int i = LR + 1; i < RL; i++)ss << s[i];\n            // cout << ss.str() << endl;\n            ss >> value[idx];\n\n            left[idx] = cnt;\n            push(cnt, l + 1, LR - 2); cnt++;\n\n            right[idx] = cnt;\n            push(cnt, RL + 2, r - 1); cnt++;\n\n        }\n    }\n    tree(tree t1, tree t2){\n        for(int i = 0; i < NUM; i++){\n            value[i] = -1;\n            left[i] = -1;\n            right[i] = -1;\n        }\n        int cnt = 0;\n        queue<int>s, s1, s2;\n        s.push(cnt); cnt++;\n        s1.push(0);\n        s2.push(0);\n        while(!s1.empty()){\n            int idx = s.front(); s.pop();\n            int idx1 = s1.front(); s1.pop();\n            int idx2 = s2.front(); s2.pop();\n            value[idx] = t1.value[idx1] + t2.value[idx2];\n            // cout << value[idx] << endl;\n            if(t1.value[t1.left[idx1]] >= 0 && t2.value[t2.left[idx2]] >= 0){\n                left[idx] = cnt;\n                s.push(cnt); cnt++;\n                s1.push(t1.left[idx1]);\n                s2.push(t2.left[idx2]);\n            }\n            if(t1.value[t1.right[idx1]] >= 0 && t2.value[t2.right[idx2]] >= 0){\n                right[idx] = cnt;\n                s.push(cnt); cnt++;\n                s1.push(t1.right[idx1]);\n                s2.push(t2.right[idx2]);\n            }\n        }\n    }\n    string func(int idx){\n        if(value[idx] < 0)return \"\";\n        string res = \"\";\n        res += \"(\";\n        if(left[idx] >= 0)res += func(left[idx]);\n        res += \")\";\n        res += \"[\";\n        if(value[idx] >= 0){\n            stringstream ss;\n            ss << value[idx];\n            res += ss.str();\n            // res += to_string(value[idx]);\n        }\n        res += \"]\";\n        res += \"(\";\n        if(right[idx] >= 0)res += func(right[idx]);\n        res += \")\";\n        return res;\n    }\n};\n\nint main(){\n\n    for(string s1, s2;cin >> s1 >> s2;){\n        tree t1(s1);\n        tree t2(s2);\n        tree t3(t1, t2);\n        // cout << t1.func(0) << endl;\n        // cout << t2.func(0) << endl;\n        cout << t3.func(0) << endl;\n        // break;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n\nclass Parser {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tIter it2;\n\tParser(Iter it, Iter it2) :it(it), it2(it2) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\tEBNF\n\t??????=\"(\",[??????],\")[\",??°,\"](\",[??????],\")\"\n\t*/\n\tvoid a() {\n\t\tif (*it == '('&&*it2 == '(') {\n\t\t\tcmp('('); it++; it2++; cout << '(';\n\t\t\ta();\n\t\t\tcmp(')'); it++; it2++; cout << ')';\n\t\t\tcmp('['); it++; it2++; cout << '[';\n\t\t\tcout << (integer(it) + integer(it2));\n\t\t\tcmp(']'); it++; it2++; cout << ']';\n\t\t\tcmp('('); it++; it2++; cout << '(';\n\t\t\ta();\n\t\t\tcmp(')'); it++; it2++; cout << ')';\n\t\t}\n\t\telse {\n\t\t\tif (*it == '(') {\n\t\t\t\tit++;\n\t\t\t\ta();\n\t\t\t\tit++;\n\t\t\t\tit++;\n\t\t\t\tinteger(it);\n\t\t\t\tit++;\n\t\t\t\tit++;\n\t\t\t\ta();\n\t\t\t\tit++;\n\t\t\t}\n\t\t\tif (*it2 == '(') {\n\t\t\t\tit2++;\n\t\t\t\ta();\n\t\t\t\tit2++;\n\t\t\t\tit2++;\n\t\t\t\tinteger(it2);\n\t\t\t\tit2++;\n\t\t\t\tit2++;\n\t\t\t\ta();\n\t\t\t\tit2++;\n\t\t\t}\n\t\t}\n\t}\n\tint integer(Iter &it) {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nsigned main() {\n\tstring s1, s2; getline(cin, s1); getline(cin, s2);\n\ts1 += \"$\"; s2 += \"$\";\n\tParser P(s1.begin(), s2.begin());\n\tP.a();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef string::const_iterator State;\n\nvoid assume(State &begin1, State &begin2, char expected, string &s) {\n    // cerr << \"assume: \" << *begin1 << \", \" << *begin2 << \", \" << expected << \", \" << s << endl;\n\n    assert(*begin1 == expected && *begin2 == expected);\n    s += *begin1;\n    begin1++;   begin2++;\n}\n\nstring number(State &begin1, State &begin2) {\n    // cerr << \"number: \" << *begin1 << \", \" << *begin2 << endl;\n\n    int val1 = 0;\n    while (isdigit(*begin1)) {\n        val1 *= 10;\n        val1 += *begin1 - '0';\n        begin1++;\n    }\n    int val2 = 0;\n    while (isdigit(*begin2)) {\n        val2 *= 10;\n        val2 += *begin2 - '0';\n        begin2++;\n    }\n    return to_string(val1 + val2);\n}\n\nvoid pass(State &begin) {\n    int depth = 1;\n    for (;;) {\n        if (*begin == '(') {\n            depth++;\n        } else if (*begin == ')') {\n            depth--;\n        }\n\n        if (depth == 0) {\n            return;\n        }\n        begin++;\n    }\n}\n\nstring node(State &begin1, State &begin2) {\n    // cerr << \"node: \" << *begin1 << \", \" << *begin2 << endl;\n\n    if (*begin1 == ')') {\n        pass(begin2);\n        return \"\";\n    }\n    if (*begin2 == ')') {\n        pass(begin1);\n        return \"\";\n    }\n\n    string ret = \"\";\n\n    assume(begin1, begin2, '(', ret);\n    ret += node(begin1, begin2);\n    assume(begin1, begin2, ')', ret);\n    assume(begin1, begin2, '[', ret);\n    ret += number(begin1, begin2);\n    assume(begin1, begin2, ']', ret);\n    assume(begin1, begin2, '(', ret);\n    ret += node(begin1, begin2);\n    assume(begin1, begin2, ')', ret);\n\n    return ret;\n\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string s1, s2;\n    cin >> s1 >> s2;\n    State begin1 = s1.begin();\n    State begin2 = s2.begin();\n    cout << node(begin1, begin2) << endl;\n    assert(begin1 == s1.end() && begin2 == s2.end());\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nunordered_map<int, int> Left[3], Right[3], val[3];\nint num[3];\nint root[3];\nint f(string::iterator &itr, int index) {\n    /*\n    if(*itr == '[') {\n        itr++;\n        int now = 0;\n        while(*itr != ']') {\n            now *= 10;\n            now += (*itr - '0');\n            itr++;\n        }\n        itr++;\n        num[index]++;\n        val[index][num[index]] = now;\n        return num[index];\n    }\n    */\n    //cerr << *itr << endl;\n    if(*itr == '(') {\n        num[index]++;\n        int pos = num[index];\n        itr++;\n        if(*itr == ')') {\n            itr++;\n            Left[index][pos] = -1;\n        } else {\n            Left[index][pos] = f(itr, index);\n            itr++;\n        }\n        itr++;\n        int now = 0;\n        while(*itr != ']') {\n            now *= 10;\n            now += (int)((*itr) - '0');\n            //cerr << \"PLUS: \" << *itr << endl;\n            itr++;\n        }\n        val[index][pos] = now;\n        itr++;\n        itr++;\n        if(*itr == ')') {\n            itr++;\n            Right[index][pos] = -1;\n        } else {\n            Right[index][pos] = f(itr, index);\n            itr++;\n        }\n        return pos;\n    }\n}\n\nvoid dfs(int now, int index) {\n    cerr << \"pos: \" << now << \" val: \" << val[index][now] << \" left: \" << Left[index][now] << \" right: \" << Right[index][now] << endl;\n    if(Left[index][now] != -1) dfs(Left[index][now], index);\n    if(Right[index][now] != -1) dfs(Right[index][now], index);\n}\n\nvoid merge(int one, int two, int three) {\n    //cerr << one << \" \" << two << \" \" << three << endl;\n    if(Left[0][one] != -1 && Left[1][two] != -1) {\n        num[2]++;\n        Left[2][three] = num[2];\n        val[2][Left[2][three]] = val[0][Left[0][one]] + val[1][Left[1][two]];\n        merge(Left[0][one], Left[1][two], Left[2][three]);\n    } else Left[2][three] = -1;\n    if(Right[0][one] != -1 && Right[1][two] != -1) {\n        num[2]++;\n        Right[2][three] = num[2];\n        val[2][Right[2][three]] = val[0][Right[0][one]] + val[1][Right[1][two]];\n        merge(Right[0][one], Right[1][two], Right[2][three]);\n    } else Right[2][three] = -1;\n}\n\nvoid print(int now) {\n    if(now == -1) return;\n    cout << \"(\";\n    print(Left[2][now]);\n    cout << \")\";\n    cout << \"[\" << val[2][now] << \"]\";\n    cout << \"(\";\n    print(Right[2][now]);\n    cout << \")\";\n}\n\nint main() {\n    //cout.precision(10);\n    string A, B;\n    cin >> A >> B;\n    auto itr = A.begin();\n    root[0] = f(itr, 0);\n    itr = B.begin();\n    root[1] = f(itr, 1);\n    //dfs(root[0], 0);\n    //dfs(root[1], 1);\n    //cerr << root[0] << endl;\n    //cerr << num[0] << endl;\n    //cerr << val[0][1] << \" \" << Left[0][1] << \" \" << Right[0][1] << endl;\n    root[2] = 1;\n    num[2] = 1;\n    //cerr << root[0] << \" \" << root[1] << endl;\n    val[2][1] = val[0][1] + val[1][1];\n    merge(1, 1, 1);\n    //dfs(1, 2);\n    print(1);\n    cout << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nstring s[2];\nll t[3][1000000];\nbool f[1000000];\n\nstring solve(int k) {\n\tif (t[2][k] == -1)return \"\";\n\tstring res = \"(\" + solve(2 * k + 1) + \")\";\n\tres += (\"[\" + to_string(t[2][k]) + \"]\");\n\treturn res + \"(\" + solve(2 * k + 2) + \")\";\n}\n\nint main() {\n\trep(i, 3)fill(t[i], t[i] + 1000000, -1);\n\tcin >> s[0] >> s[1];\n\trep(i, 2) {\n\t\tll k = 0;\n\t\tll num = 0;\n\t\tfill(f, f + 1000000, 0);\n\t\trep(j, s[i].size()) {\n\t\t\tif (s[i][j] == '(')k = 2 * k + 1 + f[k];\n\t\t\telse if (s[i][j] == ')')k = (k - 1) / 2;\n\t\t\telse if (s[i][j] == ']') {\n\t\t\t\tf[k] = 1;\n\t\t\t\tt[i][k] = num;\n\t\t\t\tnum = 0;\n\t\t\t}\n\t\t\telse if (s[i][j] >= '0'&&s[i][j] <= '9') {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[i][j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 2) {\n\t\trep(j, 1000000) {\n\t\t\tif (t[0][j] != -1 && t[1][j] != -1) {\n\t\t\t\tt[2][j] = t[0][j] + t[1][j];\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, 20) {\n\t//\tcout << t[2][i] << \" \";\n\t//}\n\tcout << solve(0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2);\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;\n  for(int i=l+1;i<r;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c){\n    if(c-1>l+1)\n    po->left=con(l+1,c-1);\n  }\n  if(r-1!=c){\n    if(r-1>c+1)\n    po->right=con(c+1,r-1);\n  }\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size()-1);\n  n=1;node p2=con(0,a[1].size()-1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring merge(string tr1, string tr2){\n  string str=\"\";\n  int p1,p2;\n  int depth;\n  for(p1=1, depth=1; depth>0; p1++){\n    if(tr1[p1]=='(') depth++;\n    if(tr1[p1]==')') depth--;\n  }\n  for(p2=1, depth=1; depth>0; p2++){\n    if(tr2[p2]=='(') depth++;\n    if(tr2[p2]==')') depth--;\n  }\n  str += \"(\";\n  if(p1!=2 && p2!=2){\n    str +=  merge(tr1.substr(1,p1-2), tr2.substr(1,p2-2));\n  }\n  str += \")\";\n  \n  p1++; p2++;\n  int n1=1,n2=1;\n  while(tr1[p1+n1]!=']') n1++;\n  while(tr2[p2+n2]!=']') n2++;\n  str += \"[\" + to_string( stoi(tr1.substr(p1,n1)) +stoi(tr2.substr(p2,n2)))  + \"]\";\n  \n  p1+=n1+2; p2+=n2+2;\n  int size1 = tr1.length()-(p1+1);\n  int size2 = tr2.length()-(p2+1);\n  str += \"(\";\n  if(size1!=0 && size2!=0){\n    str += merge(tr1.substr(p1,size1), tr2.substr(p2,size2));\n  }\n  str += \")\";\n  return str;\n}\n\nint main(){\n  string tr1,tr2;\n  cin >> tr1 >> tr2;\n  string ans = merge(tr1, tr2);\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no=vt.size();\n\t\t\tvt.push_back({num,0,0});\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = vt3.size();\n\tvt3.push_back({tree1[a].num+tree2[b].num,0,0 });\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//木を実装する\ntypedef struct _node{\n    int element;\n    struct _node *left;\n    struct _node *right;\n    struct _node *par;\n}node;\n\ntypedef struct _tree{\n    node *root;\n}tree;\n\n//リストを生成する関数\ntree *create(){\n    tree *T = (tree *)malloc(sizeof(tree));\n    T->root = (node *)malloc(sizeof(node));\n    T->root->left = NULL;\n    T->root->right = NULL;\n    T->root->par = NULL;\n    T->root->element = -1;\n    return T;\n}\n\nvoid make_tree(tree *T, string s){\n    node *ptr = T->root;\n\n    for(int i = 0; i < (int) s.size(); i++){\n\n        if(s[i] == '('){\n            //どっちかににノードを足す\n            node *add = (node *)malloc(sizeof(node));\n            add->element = -1;\n            add->left = NULL;\n            add->right = NULL;\n            add->par = ptr;\n\n            //左\n            if(ptr->left == NULL){\n                ptr->left = add;\n                ptr = add;\n            }else{\n                ptr->right = add;\n                ptr = add;\n            }\n        }else if(s[i] == ')'){\n            //戻る\n            ptr = ptr->par;\n        }else if(s[i] == '['){\n            string str;\n            int j;\n            for(j = i + 1; s[j] != ']'; j++) str.push_back(s[j]);\n            int num = stoi(str);\n            ptr->element = num;\n            i = j;\n        }\n    }\n}\n\nvoid print_tree(node *v){\n    if(v == NULL || v->element == -1){\n        cout << \")\";\n        return;\n    }\n\n    cout << \"(\";\n    print_tree(v->left);\n    cout << \"[\" << v->element << \"]\";\n    cout << \"(\";\n    print_tree(v->right);\n    if(v->par != NULL) cout << \")\";\n    return;\n}\n\nvoid sum_tree(node *v1, node *v2, node *v3){\n    v3->element = v1->element + v2->element;\n\n    if(v1->left != NULL && v2->left != NULL && v1->left->element != -1 && v2->left->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->left = add;\n        sum_tree(v1->left, v2->left, v3->left);\n    }\n    \n    if(v1->right != NULL && v2->right != NULL && v1->right->element != -1 && v2->right->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->right = add;        \n        sum_tree(v1->right, v2->right, v3->right);\n    }\n    \n    //if(v->par != NULL) cout << \")\";\n    return;\n    \n}\n\nint main(){\n\n    string s1, s2; cin >> s1 >> s2;\n    tree *T1 = create();\n    tree *T2 = create();\n    tree *T3 = create();    \n    make_tree(T1, s1);\n    make_tree(T2, s2);\n    sum_tree(T1->root, T2->root, T3->root); \n    print_tree(T3->root);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\nconst i64 INF = i64(1e18) + 7;\n\nstruct Node{\n    Node* c1;\n    Node* c2;\n    int val, r;\n    Node(string& s, int i) : c1(nullptr), c2(nullptr), val(0){\n        // parse\n\n        assert(s[i] == '(');\n        if(s[i + 1] == '('){\n            c1 = new Node(s, i + 1);\n            i = c1->r;\n        }\n        else\n            ++i;\n        assert(s[i] == ')');\n        ++i;\n\n        assert(s[i] == '[');\n        ++i;\n\n        for(; s[i] != ']'; ++i){\n            val *= 10;\n            val += s[i] - '0';\n        }\n\n        assert(s[i] == ']');\n        ++i;\n\n        assert(s[i] == '(');\n        if(s[i + 1] == '('){\n            c2 = new Node(s, i + 1);\n            i = c2->r;\n        }\n        else\n            ++i;\n        assert(s[i] == ')');\n        ++i;\n        r = i;\n    }\n\n    Node(Node* x, Node* y) : c1(nullptr), c2(nullptr), val(0){\n        val = x->val + y->val;\n        if(x->c1 && y->c1)\n            c1 = new Node(x->c1, y->c1);\n        if(x->c2 && y->c2)\n            c2 = new Node(x->c2, y->c2);\n    }\n\n    void output(){\n        cout << '(';\n        if(c1)\n            c1->output();\n        cout << ')';\n        cout << '[' << val << ']';\n        cout << '(';\n        if(c2)\n            c2->output();\n        cout << ')';\n    }\n};\n\nint main()\n{\n\n    string a, b;\n    cin >> a >> b;\n\n    Node node_a = Node(a, 0);\n    Node node_b = Node(b, 0);\n\n    Node merge = Node(&node_a, &node_b);\n\n    merge.output();\n    cout << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nstring a, b;\n\nint read_num(int& p, string& s)\n{\n\tint res = 0;\n\twhile (p < s.size() && isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nstring solve(int la, int ra, int lb, int rb)\n{\n\tif (ra == la || rb == lb) return \"()\";\n\tint lla, lra, rla, rra;\n\tint cnt = 0, pa = la, pb = lb;\n\tfor(pa = la; pa < ra; pa++)\n\t{\n\t\tif (a[pa] == '(') cnt++;\n\t\tif (a[pa] == ')') cnt--;\n\t\tif (cnt == 0) break;\n\t}\n\tpa++;\n\tlla = la;\n\tlra = pa;\n\tassert(a[pa] == '[');\n\tpa++;\n\tint vala = read_num(pa, a);\n\tassert(a[pa] == ']');\n\tpa++;\n\trla = pa;\n\trra = ra;\n\n\tint llb, lrb, rlb, rrb;\n\tcnt = 0;\n\tfor (pb = lb; pb < rb; pb++)\n\t{\n\t\tif (b[pb] == '(') cnt++;\n\t\tif (b[pb] == ')') cnt--;\n\t\tif (cnt == 0) break;\n\t}\n\tpb++;\n\tllb = lb;\n\tlrb = pb;\n\tassert(b[pb] == '[');\n\tpb++;\n\tint valb = read_num(pb, b);\n\tassert(b[pb] == ']');\n\tpb++;\n\trlb = pb;\n\trrb = rb;\n\tstring res = \"(\" + solve(lla + 1, lra - 1, llb + 1, lrb - 1) + \"[\" + to_string(vala + valb) + \"]\" + solve(rla + 1, rra - 1, rlb + 1, rrb - 1) + \")\";\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tcin >> a >> b;\n\tstring res = solve(0, a.size(), 0, b.size());\n\tcout << res.substr(1, res.size() - 2) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    string s, t;\n    int l1, l2;\n    cin >> s >> t;\n\n    l1 = s.size();\n    l2 = t.size();\n\n    string ans;\n    int i = 0, j = 0;\n    while ( 1 ) {\n        if ( i >= l1 || j >= l2 ) break;\n        //cout << i << \" \" << j << endl;\n\n        if ( s[i] != t[j] ) {\n            if ( isdigit(s[i]) && isdigit(t[j]) ) {\n                int a = 0;\n                int b = 0;\n                while ( isdigit(s[i]) ) {\n                    a *= 10;\n                    a += s[i]-'0';\n                    i++;\n                }\n                while ( isdigit(t[j]) ) {\n                    b *= 10;\n                    b += t[j]-'0';\n                    j++;\n                }\n                ans += (to_string(a+b));\n            } else {\n                if ( s[i] == ')' ) {\n                    j++;\n                    int l = 1;\n                    while ( l >= 0 ) {\n                        if ( t[j] == '(' ) l++;\n                        if ( t[j] == ')' ) l--;\n                        j++;\n                    }\n                    i++;\n                } else {\n                    i++;\n                    int l = 1;\n                    while ( l >= 0 ) {\n                        if ( s[i] == '(' ) l++;\n                        if ( s[i] == ')' ) l--;\n                        i++;\n                    }\n                    j++;\n                }\n                ans.push_back(')');\n            }\n        } else{\n            ans.push_back(s[i]);\n            i++;\n            j++;\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\n\tnode.emplace_back(Node());\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tfor (auto i : x) {\n\t\tcerr << i.num << ' ' << i.r << ' ' << i.l << endl;\n\t}\n\n\tstring ans = merge(x,0,y,0);\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct node{\n\tint value;\n\tnode *left,*right;\n};\n\nnode* build(){\n\tif(getchar()==')')return NULL; //skip (\n\tnode *res = new node();\n\tif(res->left = build())getchar(); //skip )\n\tscanf(\"[%d](\",&res->value);\n\tif(res->right = build())getchar(); //skip )\n\treturn res;\n}\n\nnode* unite(node *a, node *b){\n\tif(a==NULL || b==NULL)return NULL;\n\tnode *res;\n\tres->value = a->value+b->value;\n\tres->left = unite(a->left, b->left);\n\tres->right = unite(a->right, b->right);\n\treturn res;\n}\n\nvoid output(node *n){\n\tif(n==NULL)return;\n\tprintf(\"(\");\n\toutput(n->left);\n\tprintf(\")[%d](\", n->value);\n\toutput(n->right);\n\tprintf(\")\");\n}\n\nint main(){\n\tnode *a = build();\n\tgetchar(); //skip \\n\n\tnode *b = build();\n\tgetchar(); //skip \\n\n\toutput(unite(a,b));\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\n\nstruct node { int n, left, right; };\n\nstring S[2];\nvector<node> V[2];\nvector<node> U;\nint p;\n\nint num(int s) {\n  int n = 0;\n  while('0' <= S[s][p] && S[s][p] <= '9') {\n    n = n * 10 + (S[s][p] - '0');\n    p++;\n  }\n  return n;\n}\n\nint tree(int s) {\n  if(S[s][p] == ')') return -1;\n  p++;\n  int left = tree(s);\n  p += 2;\n  int n = num(s);\n  p += 2;\n  int right = tree(s);\n  p++;\n  int ret = V[s].size();\n  V[s].push_back((node) { n, left, right });\n  return ret;\n}\n\nint dfs(int q1, int q2) {\n  int n = V[0][q1].n + V[1][q2].n;\n  int left = V[0][q1].left != -1 && V[1][q2].left != -1 ? dfs(V[0][q1].left, V[1][q2].left) : -1;\n  int right = V[0][q1].right != -1 && V[1][q2].right != -1 ? dfs(V[0][q1].right, V[1][q2].right) : -1;\n  int ret = U.size();\n  U.push_back((node) { n, left, right });\n  return ret;\n}\n\nvoid ans(int q) {\n  if(q == -1) return;\n  cout << \"(\";\n  ans(U[q].left);\n  cout << \")[\" << U[q].n << \"](\";\n  ans(U[q].right);\n  cout << \")\";\n}\n\nint main(void) {\n  REP(i, 0, 2) cin >> S[i];\n  int root[2];\n  REP(i, 0, 2) {\n    p = 0;\n    root[i] = tree(i);\n  }\n  int r = dfs(root[0], root[1]);\n  ans(r);\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint num(string&s, int&i) {\n\tint n = 0;\n\twhile (isdigit(s[i]))n = n * 10 + s[i++] - '0';\n\treturn n;\n}\nP E[2][10000];\nint calc(string&s, int&i, int id) {\n\tint l = -1, r = -1, ret;\n\ti++; if (s[i] == '(') { l = calc(s, i, id); i++; }\n\ti += 2; ret = num(s, i);\n\ti += 2; if (s[i] == '(') { r = calc(s, i, id); i++; }\n\tE[id][ret].first = l; E[id][ret].second = r;\n\treturn ret;\n}\nstring dfs(int a, int b) {\n\tstring s = \")[\" + to_string(a + b) + \"](\";\n\tif (E[0][a].first != -1 && E[1][b].first != -1)\n\t\ts = \"(\" + dfs(E[0][a].first, E[1][b].first) + s;\n\telse s = \"(\" + s;\n\tif (E[0][a].second != -1 && E[1][b].second != -1)\n\t\ts += dfs(E[0][a].second, E[1][b].second) + \")\";\n\telse s += \")\";\n\treturn s;\n}\nint main() {\n\tstring a, b; cin >> a >> b;\n\tint r1, r2;\n\tint i = 0; r1 = calc(a, i, 0);\n\ti = 0; r2 = calc(b, i, 1);\n\tcout << dfs(r1, r2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//木を実装する\ntypedef struct _node{\n    int element;\n    struct _node *left;\n    struct _node *right;\n    struct _node *par;\n}node;\n\ntypedef struct _tree{\n    node *root;\n}tree;\n\n//リストを生成する関数\ntree *create(){\n    tree *T = (tree *)malloc(sizeof(tree));\n    T->root = (node *)malloc(sizeof(node));\n    T->root->left = NULL;\n    T->root->right = NULL;\n    T->root->par = NULL;\n    T->root->element = -1;\n    return T;\n}\n\nvoid make_tree(tree *T, string s){\n    node *ptr = T->root;\n\n    for(int i = 0; i < (int) s.size(); i++){\n\n        if(s[i] == '('){\n            //どっちかににノードを足す\n            node *add = (node *)malloc(sizeof(node));\n            add->element = -1;\n            add->left = NULL;\n            add->right = NULL;\n            add->par = ptr;\n\n            //左\n            if(ptr->left == NULL){\n                ptr->left = add;\n                ptr = add;\n            }else{\n                ptr->right = add;\n                ptr = add;\n            }\n        }else if(s[i] == ')'){\n            //戻る\n            ptr = ptr->par;\n        }else if(s[i] == '['){\n            string str;\n            int j;\n            for(j = i + 1; s[j] != ']'; j++) str.push_back(s[j]);\n            int num = stoi(str);\n            ptr->element = num;\n            i = j;\n        }\n    }\n}\n\nvoid print_tree(node *v){\n    if(v == NULL || v->element == -1){\n        cout << \")\";\n        return;\n    }\n\n    cout << \"(\";\n    print_tree(v->left);\n    cout << \"[\" << v->element << \"]\";\n    cout << \"(\";\n    print_tree(v->right);\n    if(v->par != NULL) cout << \")\";\n    return;\n}\n\nvoid sum_tree(node *v1, node *v2, node *v3){\n    v3->element = v1->element + v2->element;\n\n    if(v1->left != NULL && v2->left != NULL && v1->left->element != -1 && v2->left->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->left = add;\n        sum_tree(v1->left, v2->left, v3->left);\n    }\n    \n    if(v1->right != NULL && v2->right != NULL && v1->right->element != -1 && v2->right->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->right = add;        \n        sum_tree(v1->right, v2->right, v3->right);\n    }\n    \n    //if(v->par != NULL) cout << \")\";\n    return;\n    \n}\n\nint main(){\n\n    string s1, s2; cin >> s1 >> s2;\n    tree *T1 = create();\n    tree *T2 = create();\n    tree *T3 = create();    \n    make_tree(T1, s1);\n    make_tree(T2, s2);\n    sum_tree(T1->root, T2->root, T3->root); \n    print_tree(T3->root);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define each(a,x) for(auto a : (x))\n#define all(a) (a).begin(),(a).end()\n#define chmin(a,b) ((a) = min((a),(b)))\n#define chmax(a,b) ((a) = max((a),(b)))\n#define in_range(x,l,r) ((l)<=(x) && (x)<(r))\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size() \n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n \nconst static int INF = 1e8;\nconst static D EPS = 1e-8;\n \nint integer(int &ia, const string &a){\n  int ans = 0;\n  while(isdigit(a[ia])){\n    ans = ans*10 + (a[ia++]-'0');\n  }\n  return ans;\n}\n \nvoid merge(int &ia, int &ib, const string &a, const string &b){\n  cout << \"[\";\n  ia++; ib++;\n \n  //cerr << a.substr(ia) << \" \" << b.substr(ib) << endl;\n  int A = integer(ia,a);\n  int B = integer(ib,b);\n  //cerr << A << \" \" << B << endl;\n  cout << A+B;\n \n  cout << \"]\";\n  ia++; ib++;\n}\n \nvoid inc(int &ia, const string &a){\n  int k = 1;\n  while(k){\n    if(a[ia] == '(') k++;\n    if(a[ia] == ')') k--;\n    ia++;\n  }\n}\n \nvoid rec(int &ia, int &ib, const string &a, const string &b){\n  cout << \"(\";\n  ia++; ib++;\n  if(a[ia] == '(' && b[ib] == '('){\n    rec(ia,ib,a,b);\n    ia++; ib++;\n  }else{\n    inc(ia,a); inc(ib,b);    \n  }\n  cout << \")\";\n \n  merge(ia,ib,a,b);\n \n  cout << \"(\";\n  ia++; ib++;\n  if(a[ia] == '(' && b[ib] == '('){\n    rec(ia,ib,a,b);\n    ia++; ib++;\n  }else{\n    inc(ia,a); inc(ib,b);    \n  }\n  cout << \")\";\n}\n \nint main(){\n  string a,b;\n  cin >> a >> b;\n  int ia = 0, ib = 0;\n  rec(ia,ib,a,b);\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;\n  for(int i=l+1;i<r-1;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c);\n  if(r-1!=c+1)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nint main(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(-1,a[0].size()+1);\n  n=1;node p2=con(-1,a[1].size()+1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin== End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin;Begin!=End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end()-1, bb = b.begin(), be = b.end()-1;\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define REP(i,n) for(int i = 0;i < n; i++)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e18;\n \n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n \ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>vector<T>\nmake_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n\tfor(auto &e:t) fill_v(e,v);\n}\n\nstring l,r,ans;\nint lnow = 0,rnow = 0;\nvoid dfs(){\n\tif(l[lnow]==')'&&r[rnow]==')')return;\n\telse if(l[lnow]==')'){\n\t\tint t = 2,cnt = 0;\n\t\twhile(1){\n\t\t\tif(r[rnow]=='(')cnt++;\n\t\t\telse if(r[rnow]==')'){\n\t\t\t\tcnt--;\n\t\t\t\tif(cnt==0)t--;\n\t\t\t\tif(t==0){\n\t\t\t\t\trnow++;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\trnow++;\n\t\t}\n\t\treturn;\n\t}\n\telse if(r[rnow]==')'){\n\t\tint t = 2,cnt = 0;\n\t\twhile(1){\n\t\t\tif(l[lnow]=='(')cnt++;\n\t\t\telse if(l[lnow]==')'){\n\t\t\t\tcnt--;\n\t\t\t\tif(cnt==0)t--;\n\t\t\t\tif(t==0){\n\t\t\t\t\tlnow++;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlnow++;\n\t\t}\n\t\treturn;\n\t}\n\tlnow++;\n\trnow++;\n\tans += '(';\n\tdfs();\n\tlnow++;\n\trnow++;\n\tans += ')';\n\tlnow++;\n\trnow++;\n\tans += '[';\n\tint lroot = 0;\n\twhile(isdigit(l[lnow])){\n\t\tlroot = lroot*10 + (l[lnow]-'0');\n\t\tlnow++;\n\t}\n\tint rroot = 0;\n\twhile(isdigit(r[rnow])){\n\t\trroot = rroot*10 + (r[rnow]-'0');\n\t\trnow++;\n\t}\n\tans += to_string(lroot+rroot);\n\tlnow++;\n\trnow++;\n\tans += ']';\n\tlnow++;\n\trnow++;\n\tans += '(';\n\tdfs();\n\tlnow++;\n\trnow++;\n\tans += ')';\n}\n \nsigned main(){\n\tIOS();\n\tcin>>l>>r;\n\tdfs();\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\tvt.size();\n\t\t\tvt.push_back({num,0,0});\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\tvt3.push_back({tree1[a].num+tree2[b].num,0,0 });\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n#define NUM 10000000\n\nusing namespace std;\n\nenum TYPE{\n\tNONE,\n\tFIRST,\n\tSECOND,\n\tLEFT,\n\tRIGHT\n};\n\nint* first,*second,*third;\nchar buf[1010];\n\nTYPE toWrite;\n\n//left_or_right???LEFT????????????????????¢?????¬??????2*parent_address+1,RIGHT??????parent_address+2\nvoid recursive(int left,int right,int parent_address,TYPE left_or_right){\n\tint calcDepth,nextRight,nextLeft,tmp,nextParentAddress = -1;\n\tif(parent_address != -1){\n\t\tcalcDepth = 0; //??????????????±???\n\t\tfor(int i = left,k=0; i <= right; i++){\n\n\t\t\tif(calcDepth==0 && buf[i] == '['){ //???\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextRight = i-1;\n\t\t\t\tnextLeft = k+1;\n\t\t\t\tbreak; //???????????????????????????????????±???0???1??????????????¨???????????????????????§break;\n\t\t\t}else if(calcDepth==0 && buf[i] == '(' && buf[i+1] >= '0' && buf[i+1] <= '9'){ //???<?????????>\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ')';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\t}\n\t\t}\n\n\t\tif(nextParentAddress != -1){\n\t\t\tif(left+1 < nextRight-1){\n\t\t\t\trecursive(left+1,nextRight-1,nextParentAddress,LEFT);\n\t\t\t}\n\t\t\tif(nextLeft+1 < right-1){\n\t\t\t\trecursive(nextLeft+1,right-1,nextParentAddress,RIGHT);\n\t\t\t}\n\t\t}\n\n\t}else{ //???????????´???\n\t\tcalcDepth = 0; //??¶???????????±???\n\t\tfor(int i = 0,k=0; i <= right; i++){\n\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\telse{\n\t\t\t\tif(calcDepth==0 && buf[i] == '['){ //????????????????????????\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\t\tfirst[0] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[0] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tnextRight = i-1;\n\t\t\t\t\tnextLeft = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(left+1 < nextRight-1){\n\t\t\trecursive(left+1,nextRight-1,0,LEFT);\n\t\t}\n\t\tif(nextLeft+1 < right-1){\n\t\t\trecursive(nextLeft+1,right-1,0,RIGHT);\n\t\t}\n\t}\n}\n\nvoid outPut(int address){\n\n\tif(third[2*address+1] != -1 || third[2*address+2] != -1){//??????????????´???\n\t\tif(third[2*address+1] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+1);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t\tprintf(\"[%d]\",third[address]);\n\t\tif(third[2*address+2] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+2);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t}else{ //?????????????????´???\n\t\tprintf(\"()[%d]()\",third[address]);\n\t}\n}\n\n\nint main(){\n\n\tfirst = new int[NUM];\n\tsecond = new int[NUM];\n\tthird = new int[NUM];\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tfirst[i] = -1;\n\t\tsecond[i] = -1;\n\t\tthird[i] = -1;\n\t}\n\n\tscanf(\"%s\",buf);\n\tint length;\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = FIRST;\n\trecursive(0,length-1,-1,NONE);\n\n\tscanf(\"%s\",buf);\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = SECOND;\n\trecursive(0,length-1,-1,NONE);\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(first[i] != -1 && second[i] != -1){\n\t\t\tthird[i] = first[i]+second[i];\n\t\t}else{\n\t\t\tthird[i] = -1;\n\t\t}\n\t}\n\n\toutPut(0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint st[10000000], tt[10000000];\n\nchar *p;\nvoid analyze(int *dst, int i) {\n    switch(*p) {\n        case ')':\n            p++;\n            return;\n        case '(':\n            p++;\n            analyze(dst, i*2+1);\n            break;\n    }\n    p++;\n    dst[i] = 0;\n    while('0' <= *p && *p <= '9')\n        dst[i]*=10, dst[i]+=(*p-'0'), p++;\n    p++;\n    p++;\n\n    analyze(dst, i*2+2);\n    p++;\n}\n\nvoid print_tree(int *tr, int i) {\n    printf(\"(\");\n    if(tr[i*2+1] != -1) print_tree(tr, i*2+1);\n    printf(\")\");\n\n    printf(\"[\");\n    printf(\"%d\", tr[i]);\n    printf(\"]\");\n\n    printf(\"(\");\n    if(tr[i*2+2] != -1) print_tree(tr, i*2+2);\n    printf(\")\");\n}\n\nint main(void) {\n    memset(st, 0xFF, sizeof(st));\n    memset(tt, 0xFF, sizeof(tt));\n\n    char s[2000], t[2000];\n    scanf(\"%s%s\",s,t);\n    p = s;\n    analyze(st, 0);\n    p = t;\n    analyze(tt, 0);\n\n    for(int i=0; i<100000; i++)\n        if(st[i] == -1 || tt[i] == -1) st[i] = -1;\n        else st[i] += tt[i];\n\n    print_tree(st, 0);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tstring s,t;\n\tcin>>s>>t;\n\tint c1=0,c2=0;\n\twhile(c1!=s.size()){\n\t\tif(isdigit(s[c1])){\n\t\t\tint a=0,b=0;\n\t\t\twhile(isdigit(s[c1])){\n\t\t\t\ta*=10;a+=s[c1]-'0';\n\t\t\t\tc1++;\n\t\t\t}\n\t\t\twhile(isdigit(t[c2])){\n\t\t\t\tb*=10;b+=t[c2]-'0';\n\t\t\t\tc2++;\n\t\t\t}\n\t\t\tcout<<a+b;\n\t\t}else if(s[c1]==t[c2]){\n\t\t\tcout<<s[c1];\n\t\t\tc1++;c2++;\n\t\t}else if(s[c1]=='('){\n\t\t\tint co=0;\n\t\t\tint cnt=0;\n\t\t\twhile(cnt!=5){\n\t\t\t\tif(s[c1]=='(')co++;\n\t\t\t\telse if(s[c1]==')')co--;\n\t\t\t\tif(co==0)cnt++;\n\t\t\t\tc1++;\n\t\t\t}\n\t\t}else{\n\t\t\tint co=0;\n\t\t\tint cnt=0;\n\t\t\twhile(cnt!=5){\n\t\t\t\tif(t[c2]=='(')co++;\n\t\t\t\telse if(t[c2]==')')co--;\n\t\t\t\tif(co==0)cnt++;\n\t\t\t\tc2++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct no{\n  long int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nint n,p3,p4;\nstring s1[2];\nvector<long int>v[2];\nvoid v_make(int t){\n  v[t].push_back('(');\n  for(int i=0;i<s1[t].size();i++){\n    if(!isdigit(s1[t][i]))v[t].push_back(s1[t][i]);\n    else{\n      int p=s1[t][i]-'0';\n      while(isdigit(s1[t][i+1]))p*=10,p+=s1[t][++i]-'0';\n      v[t].push_back(p+100);\n    }\n  }\n  v[t].push_back(')');\n}\nnode con(int l,int r){if(r<=l+1)return NULL;\n  node po=new no();\n  int p=0,c=-1;\n  for(int i=l+1;i<r;i++)\n    if((char)v[n][i]=='(')p++;\n    else if((char)v[n][i]==')')p--;\n    else if(v[n][i]>=100&&!p){\n      c=i;\n      po->key=v[n][i]-100;\n      break;\n    }\n  if(l+1!=c)po->left=con(l+1,c-1);\n  if(r-1!=c)po->right=con(c+1,r-1);\n  return po;\n}\nstring make_num(long int p){\n  string t;\n  while(p){\n    t+=p%10+'0';\n    p/=10;\n  }\n  reverse(t.begin(),t.end());\n  return t;\n}\nstring init(node a,node b){\n  string l,r,x=make_num(a->key+b->key);\n  if(a->left!=NULL&&b->left!=NULL)\n    l=init(a->left,b->left);\n  if(a->right!=NULL&&b->right!=NULL)\n    r=init(a->right,b->right);\n  return \"(\"+l+\")[\"+x+\"](\"+r+\")\";\n}\nint main(){\n  cin>>s1[0]>>s1[1];\n  for(int j=0;j<2;j++)\n    for(int i=0;i<(int)s1[j].size();i++)\n      if(s1[j][i]=='('&&s1[j][i+1]==')')s1[j].erase(s1[j].begin()+i),s1[j].erase(s1[j].begin()+i);\n  for(int j=0;j<2;j++)\n    for(int i=0;i<(int)s1[j].size();i++)\n      if(s1[j][i]=='['||s1[j][i]==']')s1[j].erase(s1[j].begin()+i);\n  v_make(0);v_make(1);\n\n  n=0;node a=con(0,v[n].size()-1);\n  n=1;node b=con(0,v[n].size()-1);\n  cout<<init(a,b)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n\nusing namespace std;\n\nenum TYPE{\n\tNONE,\n\tFIRST,\n\tSECOND,\n\tLEFT,\n\tRIGHT\n};\n\nstruct Node{\n\tNode(){\n\t\tvalue = 0;\n\t\tparent = first_index = address = left_child=right_child = -1;\n\t\troute_index = 0;\n\t}\n\tvoid addRoute(char dist){\n\t\troute[route_index++] = dist;\n\t\troute[route_index] = '\\0';\n\t}\n\n\tint value,left_child,right_child,address,route_index,first_index,parent;\n\tchar route[150];\n};\n\nbool strCmp(char* base, char* comp){\n\tint length1 = 0,length2 = 0;\n\tfor(int i=0;base[i] != '\\0'; i++)length1++;\n\tfor(int i=0;comp[i] != '\\0'; i++)length2++;\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nNode first[1000],second[1000],third[1000];\nint first_index = 0,second_index = 0;\nchar buf[1010];\n\nTYPE toWrite;\n\nvoid recursive(int left,int right,int parent_address,TYPE left_or_right){\n\tint calcDepth,nextRight,nextLeft,tmp,nextParentAddress = -1;\n\tif(parent_address != -1){\n\t\tcalcDepth = 0;\n\t\tfor(int i = left,k=0; i <= right; i++){\n\n\t\t\tif(calcDepth==0 && buf[i] == '['){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tfirst[first_index].value = tmp;\n\t\t\t\t\tfirst[first_index].address = first_index;\n\t\t\t\t\tfirst[first_index].parent = parent_address;\n\t\t\t\t\tstrcpy(first[first_index].route,first[parent_address].route);\n\t\t\t\t\tfirst[first_index].route_index = first[parent_address].route_index;\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[first_index].addRoute('L');\n\t\t\t\t\t\tfirst[parent_address].left_child = first_index;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[first_index].addRoute('R');\n\t\t\t\t\t\tfirst[parent_address].right_child = first_index;\n\t\t\t\t\t}\n\t\t\t\t\tnextParentAddress = first_index;\n\t\t\t\t\tfirst_index++;\n\t\t\t\t}else{\n\t\t\t\t\tsecond[second_index].value = tmp;\n\t\t\t\t\tsecond[second_index].address = second_index;\n\t\t\t\t\tsecond[second_index].parent = parent_address;\n\t\t\t\t\tstrcpy(second[second_index].route,second[parent_address].route);\n\t\t\t\t\tsecond[second_index].route_index = second[parent_address].route_index;\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[second_index].addRoute('L');\n\t\t\t\t\t\tsecond[parent_address].left_child = second_index;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[second_index].addRoute('R');\n\t\t\t\t\t\tsecond[parent_address].right_child = second_index;\n\t\t\t\t\t}\n\t\t\t\t\tnextParentAddress = second_index;\n\t\t\t\t\tsecond_index++;\n\t\t\t\t}\n\t\t\t\tnextRight = i-1;\n\t\t\t\tnextLeft = k+1;\n\t\t\t\tbreak;\n\t\t\t}else if(calcDepth==0 && buf[i] == '(' && buf[i+1] >= '0' && buf[i+1] <= '9'){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ')';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tfirst[first_index].value = tmp;\n\t\t\t\t\tfirst[first_index].address = first_index;\n\t\t\t\t\tfirst[first_index].parent = parent_address;\n\t\t\t\t\tstrcpy(first[first_index].route,first[parent_address].route);\n\t\t\t\t\tfirst[first_index].route_index = first[parent_address].route_index;\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[first_index].addRoute('L');\n\t\t\t\t\t\tfirst[parent_address].left_child = first_index;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[first_index].addRoute('R');\n\t\t\t\t\t\tfirst[parent_address].right_child = first_index;\n\t\t\t\t\t}\n\t\t\t\t\tfirst_index++;\n\t\t\t\t}else{\n\t\t\t\t\tsecond[second_index].value = tmp;\n\t\t\t\t\tsecond[second_index].address = second_index;\n\t\t\t\t\tsecond[second_index].parent = parent_address;\n\t\t\t\t\tstrcpy(second[second_index].route,second[parent_address].route);\n\t\t\t\t\tsecond[second_index].route_index = second[parent_address].route_index;\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[second_index].addRoute('L');\n\t\t\t\t\t\tsecond[parent_address].left_child = second_index;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[second_index].addRoute('R');\n\t\t\t\t\t\tsecond[parent_address].right_child = second_index;\n\t\t\t\t\t}\n\t\t\t\t\tsecond_index++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\t}\n\t\t}\n\n\t\tif(nextParentAddress != -1){\n\t\t\tif(left+1 < nextRight-1){\n\t\t\t\trecursive(left+1,nextRight-1,nextParentAddress,LEFT);\n\t\t\t}\n\t\t\tif(nextLeft+1 < right-1){\n\t\t\t\trecursive(nextLeft+1,right-1,nextParentAddress,RIGHT);\n\t\t\t}\n\t\t}\n\n\t}else{\n\t\tcalcDepth = 0;\n\t\tfor(int i = 0,k=0; i <= right; i++){\n\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\telse{\n\t\t\t\tif(calcDepth==0 && buf[i] == '['){\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\t\tfirst[0].value = tmp;\n\t\t\t\t\t\tfirst[0].address = 0;\n\t\t\t\t\t\tfirst[0].addRoute('X');\n\t\t\t\t\t\tfirst_index++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[0].value = tmp;\n\t\t\t\t\t\tsecond[0].address = 0;\n\t\t\t\t\t\tsecond[0].addRoute('X');\n\t\t\t\t\t\tsecond_index++;\n\t\t\t\t\t}\n\t\t\t\t\tnextRight = i-1;\n\t\t\t\t\tnextLeft = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(left+1 < nextRight-1){\n\t\t\trecursive(left+1,nextRight-1,0,LEFT);\n\t\t}\n\t\tif(nextLeft+1 < right-1){\n\t\t\trecursive(nextLeft+1,right-1,0,RIGHT);\n\t\t}\n\t}\n}\n\nvoid outPut(int address){\n\n\tif(third[address].left_child != -1 || third[address].right_child != -1){\n\t\tif(third[address].left_child != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(third[address].left_child);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t\tprintf(\"[%d]\",third[address].value);\n\t\tif(third[address].right_child != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(third[address].right_child);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t}else{\n\t\tprintf(\"()[%d]()\",third[address].value);\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%s\",buf);\n\tint length;\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = FIRST;\n\trecursive(0,length-1,-1,NONE);\n\n\tscanf(\"%s\",buf);\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = SECOND;\n\trecursive(0,length-1,-1,NONE);\n\n\tint indexTable[1000];\n\n\tthird[0].value = first[0].value + second[0].value;\n\tindexTable[0] = 0;\n\n\tint third_index = 1;\n\n\tfor(int i = 1; i < first_index; i++){\n\t\tfor(int k = 1; k < second_index; k++){\n\t\t\tif(strCmp(first[i].route,second[k].route)){\n\n\t\t\t\tthird[third_index].value = first[i].value + second[k].value;\n\t\t\t\tthird[third_index].first_index = i;\n\t\t\t\tstrcpy(third[third_index].route,first[i].route);\n\t\t\t\tthird[third_index].route_index = first[i].route_index;\n\t\t\t\tindexTable[i] = third_index;\n\t\t\t\tthird_index++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint p_tmp;\n\n\tfor(int i = 1; i < third_index; i++){\n\t\tp_tmp = indexTable[first[third[i].first_index].parent];\n\t\tif(third[i].route[third[i].route_index-1] == 'R'){\n\t\t\tthird[p_tmp].right_child = i;\n\t\t}else{\n\t\t\tthird[p_tmp].left_child = i;\n\t\t}\n\t}\n\n\toutPut(0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct Node{\n    int v;\n    Node *l, *r;\n};\n\nNode* new_node(){\n    Node *ret;\n    ret = (Node*)malloc(sizeof(Node));\n    ret->l = NULL;\n    ret->r = NULL;\n    return ret;\n}\n\nvoid dfs(string s, Node *root){\n    // dbg(s);\n    int n = s.size();\n\n    int d = 0;\n    int lidx,ridx;\n    rep(i,n){\n        if(s[i]=='(') ++d;\n        if(s[i]==')') --d;\n\n        if(s[i]=='['){\n            if(d==0){\n                lidx = i;\n                ridx = i;\n                while(s[ridx]!=']') ++ridx;\n                break;\n            }\n        }\n    }\n\n    int val = 0;\n    for(int i=lidx+1; i<ridx; ++i) val = val*10 + s[i]-'0';\n\n    string ls = \"\", rs = \"\";\n    for(int i=1; i<lidx-1; ++i) ls += s[i];\n    for(int i=ridx+2; i<n-1; ++i) rs += s[i];\n\n    root->v = val;\n\n    if(ls!=\"\"){\n        root->l = new_node();\n        dfs(ls,root->l);\n    }\n    if(rs!=\"\"){\n        root->r = new_node();\n        dfs(rs,root->r);\n    }\n}\n\nvoid merge(Node *a, Node *b, Node *c){\n    c->v = a->v + b->v;\n    if(a->l!=NULL && b->l!=NULL){\n        c->l = new_node();\n        merge(a->l,b->l,c->l);\n    }\n    if(a->r!=NULL && b->r!=NULL){\n        c->r = new_node();\n        merge(a->r,b->r,c->r);\n    }\n}\n\nstring recover(Node *root){\n    if(root == NULL) return \"\";\n\n    string ret = \"\";\n\n    ret += '(';\n    ret += recover(root->l);\n    ret += ')';\n\n    ret += '[';\n    ret += to_string(root->v);\n    ret += ']';\n\n    ret += '(';\n    ret += recover(root->r);\n    ret += ')';\n\n    return ret;\n}\n\nint main(){\n    string a,b;\n    cin >>a >>b;\n\n    Node *ra, *rb;\n\n    ra = new_node();\n    dfs(a,ra);\n\n    rb = new_node();\n    dfs(b,rb);\n\n    Node *rc;\n    rc = new_node();\n    merge(ra,rb,rc);\n\n    cout << recover(rc) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin >= End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin; Begin != End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      if (rb > End) {\n        rb = End;\n      }\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin()-1, be = b.end()-1;\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstring a,b;\nint placeA,placeB;\n\nvoid dfs(){\n\tDBG(cout << \"(START DFS \" << placeA << ' ' << placeB << \")\" << endl;);\n\tcout << '(';\n\tint num = 0;\n\tint tmp;\n\tif(a[placeA+1] == '(' && b[placeB+1] == '('){\n\t\tDBG(cout << \"IN DFS\" << endl;);\n\t\tplaceA++;\n\t\tplaceB++;\n\t\tdfs();\n\t}\n\telse{\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(a[placeA] == '(')tmp++;\n\t\t\tif(a[placeA] == ')')tmp--;\n\t\t\tplaceA++;\n\t\t}while(tmp != 0);\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(b[placeB] == '(')tmp++;\n\t\t\tif(b[placeB] == ')')tmp--;\n\t\t\tplaceB++;\n\t\t}while(tmp != 0);\n\t\tplaceA--;\n\t\tplaceB--;\n\t}\n\tDBG(cout << \"HOGE DFS \" << a[placeA] << ' ' << b[placeB] << endl;);\n\tplaceA += 2;\n\tplaceB += 2;\n\tcout << \")[\";\n\ttmp = 0;\n\tDBG(cout << \"NUM DFS \" << a[placeA] << ' ' << b[placeB] << endl;);\n\n\twhile(isdigit(a[placeA])){\n\t\ttmp *= 10;\n\t\ttmp += a[placeA] - '0';\n\t\tplaceA++;\n\t}\n\tnum += tmp;\n\tDBG(cout << \"A is \" << tmp << endl;);\n\ttmp = 0;\n\twhile(isdigit(b[placeB])){\n\t\ttmp *= 10;\n\t\ttmp += b[placeB] - '0';\n\t\tplaceB++;\n\t}\n\tnum += tmp;\n\tDBG(cout << \"B is \" << tmp << endl;);\n\tDBG(cout << \"num is \";)cout << num <<  \"](\";\n\tplaceA++;\n\tplaceB++;\n\t\n\tif(a[placeA+1] == '(' && b[placeB+1] == '('){\n\t\tplaceA++;\n\t\tplaceB++;\n\t\tdfs();\n\t}\n\telse{\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(a[placeA] == '(')tmp++;\n\t\t\tif(a[placeA] == ')')tmp--;\n\t\t\tplaceA++;\n\t\t}while(tmp != 0);\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(b[placeB] == '(')tmp++;\n\t\t\tif(b[placeB] == ')')tmp--;\n\t\t\tplaceB++;\n\t\t}while(tmp != 0);\n\t}\n\tDBG(cout << \"END DFS \" << a[placeA] << ' ' << b[placeB] << endl;);\n\tcout << \")\";\n}\n\nint main()\n{\n\tcin >> a >> b;\n\tdfs();\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Tree{\n  int num;\n  Tree* lhs;\n  Tree* rhs;\n};\n\nint get_val(string& s,int& i){\n  int res=0;\n  while(isdigit(s[i])){\n    res*=10;\n    res+=s[i]-'0';\n    i++;\n  }\n  return res;\n}\n\nTree* build_tree(string&s ,int &i){\n\n  assert(0<=i && i<s.size());\n  if(s[i]==')'){\n    return nullptr;\n  }\n  i++;\n  Tree* lef=build_tree(s,i);\n  assert(s[i]==')');\n  i++;\n  assert(s[i]=='[');\n  i++;\n  int val=get_val(s,i);\n\n  assert(s[i]==']');\n  i++;//]\n  assert(s[i]=='(');\n  i++;//(\n  Tree* rig=build_tree(s,i);\n  assert(s[i]==')');\n  i++;\n  Tree* res=new Tree();\n\n  res->num=val;\n\n  res->lhs=lef;\n  res->rhs=rig;\n  return res;\n}\n\nTree* sum(Tree* a_tree,Tree* b_tree){\n  if(a_tree==nullptr||b_tree==nullptr){\n    return nullptr;\n  }\n\n  Tree* res=new Tree();\n  res->num=(a_tree->num)+(b_tree->num);\n  res->lhs=sum(a_tree->lhs,b_tree->lhs);\n  res->rhs=sum(a_tree->rhs,b_tree->rhs);\n  return res;\n}\n\nstring code(Tree* tree){\n  if(tree==nullptr){\n    return \"\";\n  }\n  string res=\"(\";\n  res+=code(tree->lhs);\n  res+=\")\";\n  res+=\"[\";\n  res+=to_string((tree->num));\n  res+=\"]\";\n  res+=\"(\";\n  res+=code(tree->rhs);\n  res+=\")\";\n  return res;\n}\n\nint main(){\n  string a,b;\n  cin>>a>>b;\n  int i=0;\n  Tree* a_tree=build_tree(a,i);\n  i=0;\n  Tree* b_tree=build_tree(b,i);\n  Tree* c_tree=sum(a_tree,b_tree);\n  string res=code(c_tree);\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,s,e) for (int i=s;i<(e);i++)\n#define All(v) (v).begin(),(v).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst int MOD = (int)1e9 + 7;\nconst int INF = 1010101010;\nint A[2][1000],root;\nint G[2][1000][2];\nint f(string s,int flag)\n{\n    int nowroot=root++;\n    int cnt=0,i=0;\n    for(;i<(int)s.size();i++)\n    {\n        if(s[i]=='(')cnt++;\n        else if(s[i]==')')cnt--;\n        if(cnt==0)break;\n    }\n    if(i>1)G[flag][nowroot][0]=f(s.substr(1,i-1),flag);\n    else G[flag][nowroot][0]=-1;\n    int j=i+2;\n    for(;s[i]!=']';i++);\n    A[flag][nowroot]=stoi(s.substr(j,i-j));\n    if(i+3<s.size())G[flag][nowroot][1]=f(s.substr(i+2,s.size()-i-3),flag);\n    else G[flag][nowroot][1]=-1;\n    return nowroot;\n}\nstring solve(int a,int b)\n{\n    string ans=\"[\"+to_string(A[0][a]+A[1][b])+\"]\";\n    if(G[0][a][0]>=0&&G[1][b][0]>=0)ans=\"(\"+solve(G[0][a][0],G[1][b][0])+\")\"+ans;\n    else ans=\"()\"+ans;\n    if(G[0][a][1]>=0&&G[1][b][1]>=0)ans+=\"(\"+solve(G[0][a][1],G[1][b][1])+\")\";\n    else ans+=\"()\";\n    return ans;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    string s,t;\n    cin>>s>>t;\n    int aroot=f(s,0);\n    root=0;\n    int broot=f(t,1);\n    cout<<solve(aroot,broot)<<endl;   \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef struct Node {\n  int cost;\n  Node* left;\n  Node* right;\n  Node* parent;\n}node;\n\nnode nodes[1000];\nint nodenum=-1;\n\nint constructGraph(string s){\n  int i=0;\n  int left,right;\n  int par = 0;\n  if (s==\"\")return -1;\n  while(1){\n    char c=s[i];\n    if (c=='('){\n      par++;\n    } else if (c==')') {\n      par--;\n    }\n    i++;\n    if (par==0){left=i;i++;break;}\n  }\n  string num{s[i]};\n  i++;\n  while(1){\n    if (isdigit(s[i])){\n      num += s[i];\n      i++;\n    } else {\n      right = i+1;\n      break;\n    }\n  }\n  int cost=stoi(num);\n  node n={cost,NULL,NULL,NULL};\n  nodenum++;\n  nodes[nodenum] = n;\n  int ret = nodenum;\n  int ileft = constructGraph(s.substr(1,left-2));\n  int iright = constructGraph(s.substr(right+1,s.size()-right-2));\n  if (ileft>0){\n    nodes[ret].left = &nodes[ileft];\n  } else { \n    nodes[ret].left = NULL;\n  }\n  if (iright > 0) {\n    nodes[ret].right = &nodes[iright];\n  } else {\n    nodes[ret].right = NULL;\n  }\n  return ret;\n}\n\nstring inorder(pair<node*,node*> p){\n  int cost = p.first->cost+p.second->cost;\n  string ret = \"(\";\n  if (p.first->left != NULL && p.second->left != NULL){\n    ret += inorder(make_pair(p.first->left,p.second->left));\n  }\n  ret += \")[\"+to_string(cost)+\"](\";\n  if (p.first->right != NULL && p.second->right != NULL){\n    ret += inorder(make_pair(p.first->right,p.second->right));\n  }\n  ret += \")\";\n  return ret;\n}\n\nint main(){\n\n  string s1,s2;\n  cin >> s1 >> s2;\n  int ind1,ind2;\n  ind1 = constructGraph(s1);\n  ind2 = constructGraph(s2);\n  string ret = inorder(make_pair(&nodes[ind1],&nodes[ind2]));\n  cout << ret << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define rep(i,m,n) for(int i = (m);i < (n);i++)\n#define P pair<int,int>\n#define pb push_back\n#define mk make_pair\nusing namespace std;\n#define Vec(a) vector <int> a\nconst int INF = 1 << 20;\nconst int MOD = 1e9+7;\n\n\n\nstring s1,s2;\nvector <P> p1;\nvector <P> p2;\nvector <P> p3;\n\nvoid dfs(int now, int count){\n  if(now >= s1.size()){\n    return;\n  }\n  if(s1[now] == '('){\n    dfs(now+1,count*2);\n  }\n  else if(s1[now] == ')'){\n    dfs(now+1,count/2);\n  }\n  else if(s1[now] == '['){\n    //cout << \"count : \" << count << endl;\n    int n = 0;\n    now++;\n    while(s1[now] != ']'){\n      n = 10*n + (s1[now] - '0');\n      now++;\n    }\n    p1.pb(mk(count,n));\n    dfs(now+2,count*2+1);\n  }\n  \n}\n\nvoid dfs2(int now, int count){\n  if(now >= s2.size()){\n    return;\n  }\n  if(s2[now] == '('){\n    dfs2(now+1,count*2);\n  }\n  else if(s2[now] == ')'){\n    dfs2(now+1,count/2);\n  }\n  else if(s2[now] == '['){\n    //cout << \"count : \" << count << endl;\n    int n = 0;\n    now++;\n    while(s2[now] != ']'){\n      n = 10*n + (s2[now] - '0');\n      now++;\n    }\n    p2.pb(mk(count,n));\n    dfs2(now+2,count*2+1);\n  }\n  \n}\n\nstring Stoi(int s){\n  string n = \"\";\n  while(s > 0){\n    n += (s%10 + '0');\n    s /= 10;\n  }\n  reverse(n.begin(),n.end());\n  return n;\n}\n\nstring dfs3(int x){\n  int num = -1;\n  REP(i,p3.size()){\n    if(p3[i].first == x){\n      num = i;\n      break;\n    }\n  }\n  \n  string r = \"\";\n  string l = \"\";\n  if(num == -1){\n    return r;\n  }\n  else{\n    r = dfs3(x*2);\n    l = dfs3(2*x+1);\n  }\n  \n  string res = \"(\" + r + \")[\" + Stoi(p3[num].second) + \"](\" + l + \")\";\n  return res;\n\n}\n\nint main(){\n  cin >> s1;\n  cin >> s2;\n  dfs(0,1);\n  dfs2(0,1);\n  \n  sort(p1.begin(),p1.end());\n  sort(p2.begin(),p2.end());\n  /*\n  REP(i,p1.size()){\n    cout << p1[i].first << \"  \" << p1[i].second << endl;\n  }\n  REP(i,p2.size()){\n    cout << p2[i].first << \"    \" << p2[i].second << endl; \n  }\n  \n  cout << \"!\" << endl;\n  */\n  int x = 0;\n  REP(i,p1.size()){\n    rep(j,x,p2.size()){\n      if(p1[i].first == p2[j].first){\n\tp3.pb(mk(p1[i].first , p1[i].second + p2[j].second));\n\tx = j;\n\tbreak;\n      }\n      else if(p1[i].first < p2[j].first){\n\tx = j;\n\tbreak;\n      }\n    }\n  }\n  /*\n  REP(i,p3.size()){\n    cout << p3[i].first << \"       \" << p3[i].second << endl;\n    }*/d\n\n  \n\n  cout << dfs3(1) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstring parse(const string &A, const string &B, int la, int ra, int lb, int rb){\n  if(abs(ra-la) < 5 || abs(rb-lb) < 5) return \"\";\n  int t = 0, ra_ = -1, rb_ = -1;\n  for(int i = la; i < ra; ++i){\n    if(A[i] == '(') ++t;\n    if(A[i] == ')') --t;\n    if(!t){\n      ra_ = i;\n      break;\n    }\n  }\n  t = 0;\n  for(int i = lb; i < rb; ++i){\n    if(B[i] == '(') ++t;\n    if(B[i] == ')') --t;\n    if(!t){\n      rb_ = i;\n      break;\n    }\n  }\n\n  int va = -1, vb = -1, la_ = ra_+1, lb_ = rb_+1;\n  if(A.at(la_) == '['){\n    ++la_;\n    va = 0;\n    while(A.at(la_) >= '0' && A.at(la_) <= '9'){\n      va *= 10;\n      va += A.at(la_) - '0';\n      ++la_;\n    }\n    ++la_;\n  }\n  if(B.at(lb_) == '['){\n    ++lb_;\n    vb = 0;\n    while(B.at(lb_) >= '0' && B.at(lb_) <= '9'){\n      vb *= 10;\n      vb += B.at(lb_) - '0';\n      ++lb_;\n    }\n    ++lb_;\n  }\n  string ret = \"(\" + parse(A,B,la+1,ra_-1,lb+1,rb_-1) + \")\";\n  if(va >= 0 && vb >= 0) ret += \"[\" + to_string(va+vb) + \"]\";\n  ret += \"(\" + parse(A,B,la_+1,ra-1,lb_+1,rb-1) + \")\";\n  return ret;\n}\n\nint main(){\n  string A, B;\n  cin >> A >> B;\n  cout << parse(A,B,0,A.length(),0,B.length()) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nstruct node {\n  const node *left, *right;\n  const int val;\n  node(node *left, int val, node *right) : val(val), left(left), right(right) {}\n};\nnode *parse(const char*p)\n{\n  int i = 0;\n  function<node*()> rec = [&rec,&i,&p]() -> node* {\n    if(p[i] != '(') return NULL;\n    i++; // '('\n    node *left = rec();\n    i++; // ')'\n    i++; // '['\n    int k = 0;\n    while(p[i] != ']') {\n      k = k * 10 + p[i] - '0';\n      i++;\n    }\n    i++; // ']'\n    i++; // '('\n    node *right = rec();\n    i++; // ')'\n    return new node(left, k, right);\n  };\n  return rec();\n}\n\nostream &operator<<(ostream &os, const node*t)\n{\n  os << \"(\";\n  if(t->left != NULL) os << t->left;\n  os << \")\";\n  os << \"[\" << t->val << \"]\";\n  os << \"(\";\n  if(t->right != NULL) os << t->right;\n  os << \")\";\n}\n\nnode *merge(const node *ta, const node *tb)\n{\n  if(ta == NULL) return NULL;\n  if(tb == NULL) return NULL;\n  node *left = merge(ta->left, tb->left);\n  node *right = merge(ta->right, tb->right);\n  return new node(left, ta->val + tb->val, right);\n}\n\nint main(int argc, char *argv[])\n{\n  for(;;) {\n    string ta, tb;\n    getline(cin, ta);\n    getline(cin, tb);\n    \n    node *na = parse(ta.c_str());\n    node *nb = parse(tb.c_str());\n    node *nab = merge(na, nb);\n    cout << nab << endl;\n    break;\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//木を実装する\ntypedef struct _node{\n    int element;\n    struct _node *left;\n    struct _node *right;\n    struct _node *par;\n}node;\n\ntypedef struct _tree{\n    node *root;\n}tree;\n\n//リストを生成する関数\ntree *create(){\n    tree *T = (tree *)malloc(sizeof(tree));\n    T->root = (node *)malloc(sizeof(node));\n    T->root->left = NULL;\n    T->root->right = NULL;\n    T->root->par = NULL;\n    T->root->element = -1;\n    return T;\n}\n\nvoid make_tree(tree *T, string s){\n    node *ptr = T->root;\n\n    for(int i = 0; i < (int) s.size(); i++){\n\n        if(s[i] == '('){\n            //どっちかににノードを足す\n            node *add = (node *)malloc(sizeof(node));\n            add->element = -1;\n            add->left = NULL;\n            add->right = NULL;\n            add->par = ptr;\n\n            //左\n            if(ptr->left == NULL){\n                ptr->left = add;\n                ptr = add;\n            }else{\n                ptr->right = add;\n                ptr = add;\n            }\n        }else if(s[i] == ')'){\n            //戻る\n            ptr = ptr->par;\n        }else if(s[i] == '['){\n            string str;\n            int j;\n            for(j = i + 1; s[j] != ']'; j++) str.push_back(s[j]);\n            int num = stoi(str);\n            ptr->element = num;\n            i = j;\n        }\n    }\n}\n\nvoid print_tree(node *v){\n    if(v == NULL || v->element == -1){\n        cout << \")\";\n        return;\n    }\n\n    cout << \"(\";\n    print_tree(v->left);\n    cout << \"[\" << v->element << \"]\";\n    cout << \"(\";\n    print_tree(v->right);\n    if(v->par != NULL) cout << \")\";\n    return;\n}\n\nvoid sum_tree(node *v1, node *v2, node *v3){\n    v3->element = v1->element + v2->element;\n\n    if(v1->left != NULL && v2->left != NULL && v1->left->element != -1 && v2->left->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->left = add;\n        sum_tree(v1->left, v2->left, v3->left);\n    }\n    \n    if(v1->right != NULL && v2->right != NULL && v1->right->element != -1 && v2->right->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->right = add;        \n        sum_tree(v1->right, v2->right, v3->right);\n    }\n    \n    //if(v->par != NULL) cout << \")\";\n    return;\n    \n}\n\nint main(){\n\n    string s1, s2; cin >> s1 >> s2;\n    tree *T1 = create();\n    tree *T2 = create();\n    tree *T3 = create();    \n    make_tree(T1, s1);\n    make_tree(T2, s2);\n    sum_tree(T1->root, T2->root, T3->root); \n    print_tree(T3->root);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct Node {\n\tint v;\n\tNode* l;\n\tNode* r;\n\tNode() : v(0), l(nullptr), r(nullptr) {}\n};\n\nint N, c;\nstring s;\n\nNode* f() {\n\tNode* r = nullptr;\n\tif(c < N && s[c] == '(') {\n\t\tc++;\n\t\tr = new Node();\n\t\tr->l = f();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t}\n\tif(c < N && s[c] == '[') {\n\t\tif(r == nullptr) r = new Node();\n\t\tc++;\n\t\twhile(s[c] != ']') {\n\t\t\tr->v = r->v * 10 + s[c] - '0';\n\t\t\tc++;\n\t\t}\n\t\tc++;\n\t}\n\tif(c < N && s[c] == '(') {\n\t\tif(r == nullptr) r = new Node();\n\t\tc++;\n\t\tr->r = f();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t}\n\treturn r;\n}\n\nNode* r[2];\n\nvoid g(Node* n1, Node* n2) {\n\tif(n1 == nullptr || n2 == nullptr) return;\n\tcout << '(';\n\tg(n1->l, n2->l);\n\tcout << ')';\n\tcout << '[' << n1->v + n2->v << ']';\n\tcout << '(';\n\tg(n1->r, n2->r);\n\tcout << ')';\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int i = 0; i < 2; i++) {\n\t\tcin >> s;\n\t\tN = s.size();\n\t\tc = 0;\n\t\tr[i] = f();\n\t}\n\tg(r[0], r[1]);\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\ttree t;\n\t\t\tt.num = 0;\n\t\t\tt.left = -1;\n\t\t\tt.right = -1;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\ttree t;\n\tt.num = 0;\n\tt.left = -1;\n\tt.right = -1;\n\tvt3.push_back(t);\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tif (vt.size() < no)\n\t\treturn \"\";\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//木を実装する\ntypedef struct _node{\n    int element;\n    struct _node *left;\n    struct _node *right;\n    struct _node *par;\n}node;\n\ntypedef struct _tree{\n    node *root;\n}tree;\n\n//リストを生成する関数\ntree *create(){\n    tree *T = (tree *)malloc(sizeof(tree));\n    T->root = (node *)malloc(sizeof(node));\n    T->root->left = NULL;\n    T->root->right = NULL;\n    T->root->par = NULL;\n    T->root->element = -1;\n    return T;\n}\n\nvoid make_tree(tree *T, string s){\n    node *ptr = T->root;\n\n    for(int i = 0; i < (int) s.size(); i++){\n\n        if(s[i] == '('){\n            //どっちかににノードを足す\n            node *add = (node *)malloc(sizeof(node));\n            add->element = -1;\n            add->left = NULL;\n            add->right = NULL;\n            add->par = ptr;\n\n            //左\n            if(ptr->left == NULL){\n                ptr->left = add;\n                ptr = add;\n            }else{\n                ptr->right = add;\n                ptr = add;\n            }\n        }else if(s[i] == ')'){\n            //戻る\n            ptr = ptr->par;\n        }else if(s[i] == '['){\n            string str;\n            int j;\n            for(j = i + 1; s[j] != ']'; j++) str.push_back(s[j]);\n            int num = stoi(str);\n            ptr->element = num;\n            i = j;\n        }\n    }\n}\n\nvoid print_tree(node *v){\n    if(v == NULL || v->element == -1){\n        cout << \")\";\n        return;\n    }\n\n    cout << \"(\";\n    print_tree(v->left);\n    cout << \"[\" << v->element << \"]\";\n    cout << \"(\";\n    print_tree(v->right);\n    if(v->par != NULL) cout << \")\";\n    return;\n}\n\nvoid sum_tree(node *v1, node *v2, node *v3){\n    v3->element = v1->element + v2->element;\n\n    if(v1->left != NULL && v2->left != NULL && v1->left->element != -1 && v2->left->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->left = add;\n        sum_tree(v1->left, v2->left, v3->left);\n    }\n    \n    if(v1->right != NULL && v2->right != NULL && v1->right->element != -1 && v2->right->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->right = add;        \n        sum_tree(v1->right, v2->right, v3->right);\n    }\n    \n    //if(v->par != NULL) cout << \")\";\n    return;\n    \n}\n\nint main(){\n\n    string s1, s2; cin >> s1 >> s2;\n    tree *T1 = create();\n    tree *T2 = create();\n    tree *T3 = create();    \n    make_tree(T1, s1);\n    make_tree(T2, s2);\n    sum_tree(T1->root, T2->root, T3->root); \n    print_tree(T3->root);\n    cout << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n\nusing namespace std;\n\nenum TYPE{\n\tNONE,\n\tFIRST,\n\tSECOND,\n\tLEFT,\n\tRIGHT\n};\n\nstruct Node{\n\tNode(){\n\t\tvalue = address = -1;\n\t\tparent = left_child=right_child = -1;\n\t}\n\tll value,address,parent,left_child,right_child;\n};\n\nNode first[1000],second[1000],third[1000];\nint first_index = 0,second_index = 0;\nchar buf[1010];\n\nTYPE toWrite;\n\nvoid recursive(int left,int right,int parent_address,TYPE left_or_right){\n\tint calcDepth,nextRight,nextLeft,tmp,nextParentAddress = -1;\n\tif(parent_address != -1){\n\t\tcalcDepth = 0;\n\t\tfor(int i = left,k=0; i <= right; i++){\n\n\t\t\tif(calcDepth==0 && buf[i] == '['){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[first_index].value = tmp;\n\t\t\t\t\t\tfirst[first_index].address = 2*parent_address+1;\n\t\t\t\t\t\tfirst_index++;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[first_index].value = tmp;\n\t\t\t\t\t\tfirst[first_index].address = 2*parent_address+2;\n\t\t\t\t\t\tfirst_index++;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[second_index].value = tmp;\n\t\t\t\t\t\tsecond[second_index].address = 2*parent_address+1;\n\t\t\t\t\t\tsecond_index++;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[second_index].value = tmp;\n\t\t\t\t\t\tsecond[second_index].address = 2*parent_address+2;\n\t\t\t\t\t\tsecond_index++;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextRight = i-1;\n\t\t\t\tnextLeft = k+1;\n\t\t\t\tbreak;\n\t\t\t}else if(calcDepth==0 && buf[i] == '(' && buf[i+1] >= '0' && buf[i+1] <= '9'){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ')';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[first_index].value = tmp;\n\t\t\t\t\t\tfirst[first_index].address = 2*parent_address+1;\n\t\t\t\t\t\tfirst_index++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[first_index].value = tmp;\n\t\t\t\t\t\tfirst[first_index].address = 2*parent_address+2;\n\t\t\t\t\t\tfirst_index++;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[second_index].value = tmp;\n\t\t\t\t\t\tsecond[second_index].address = 2*parent_address+1;\n\t\t\t\t\t\tsecond_index++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[second_index].value = tmp;\n\t\t\t\t\t\tsecond[second_index].address = 2*parent_address+2;\n\t\t\t\t\t\tsecond_index++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\t}\n\t\t}\n\n\t\tif(nextParentAddress != -1){\n\t\t\tif(left+1 < nextRight-1){\n\t\t\t\trecursive(left+1,nextRight-1,nextParentAddress,LEFT);\n\t\t\t}\n\t\t\tif(nextLeft+1 < right-1){\n\t\t\t\trecursive(nextLeft+1,right-1,nextParentAddress,RIGHT);\n\t\t\t}\n\t\t}\n\n\t}else{\n\t\tcalcDepth = 0;\n\t\tfor(int i = 0,k=0; i <= right; i++){\n\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\telse{\n\t\t\t\tif(calcDepth==0 && buf[i] == '['){\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\t\tfirst[0].value = tmp;\n\t\t\t\t\t\tfirst[0].address = 0;\n\t\t\t\t\t\tfirst_index++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[0].value = tmp;\n\t\t\t\t\t\tsecond[0].address = 0;\n\t\t\t\t\t\tsecond_index++;\n\t\t\t\t\t}\n\t\t\t\t\tnextRight = i-1;\n\t\t\t\t\tnextLeft = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(left+1 < nextRight-1){\n\t\t\trecursive(left+1,nextRight-1,0,LEFT);\n\t\t}\n\t\tif(nextLeft+1 < right-1){\n\t\t\trecursive(nextLeft+1,right-1,0,RIGHT);\n\t\t}\n\t}\n}\n\nvoid outPut(int address){\n\n\tif(third[address].left_child != -1 || third[address].right_child != -1){\n\t\tif(third[address].left_child != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(third[address].left_child);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t\tprintf(\"[%lld]\",third[address].value);\n\t\tif(third[address].right_child != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(third[address].right_child);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t}else{\n\t\tprintf(\"()[%lld]()\",third[address].value);\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%s\",buf);\n\tint length;\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = FIRST;\n\trecursive(0,length-1,-1,NONE);\n\n\tscanf(\"%s\",buf);\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = SECOND;\n\trecursive(0,length-1,-1,NONE);\n\n\tint third_index = 0,indexTable[1000];\n\n\tfor(int i = 0; i < 1000; i++)indexTable[i] = -1;\n\n\tfor(int i = 0; i < first_index; i++){\n\t\tfor(int k = 0; k < second_index; k++){\n\t\t\tif(first[i].address == second[k].address){\n\t\t\t\tif(first[i].address == 0){\n\t\t\t\t\tthird[third_index].address = 0;\n\t\t\t\t\tthird[third_index].value = first[i].value + second[k].value;\n\t\t\t\t\tthird[third_index].parent = -1;\n\t\t\t\t\tindexTable[0] = 0;\n\t\t\t\t\tthird_index++;\n\t\t\t\t}else{\n\t\t\t\t\tthird[third_index].address = first[i].address;\n\t\t\t\t\tthird[third_index].value = first[i].value + second[k].value;\n\t\t\t\t\tindexTable[first[i].address] = third_index;\n\t\t\t\t\tthird_index++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint p_tmp;\n\n\tfor(int i = 0; i < third_index; i++){\n\t\tif(third[i].address != 0){\n\t\t\tp_tmp = indexTable[(third[i].address-1)/2];\n\t\t\tthird[i].parent = p_tmp;\n\t\t\tif(third[i].address%2 == 1){\n\t\t\t\tthird[p_tmp].left_child = i;\n\t\t\t}else{\n\t\t\t\tthird[p_tmp].right_child = i;\n\t\t\t}\n\t\t}\n\t}\n\n\toutPut(0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstring a,b;\nint placeA,placeB;\n\nvoid dfs(){\n\tDBG(cout << \"(START DFS \" << placeA << ' ' << placeB << \")\" << endl;);\n\tcout << '(';\n\tint num = 0;\n\tint tmp;\n\tif(a[placeA+1] == '(' && b[placeB+1] == '('){\n\t\tDBG(cout << \"IN DFS\" << endl;);\n\t\tplaceA++;\n\t\tplaceB++;\n\t\tdfs();\n\t}\n\telse{\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(a[placeA] == '(')tmp++;\n\t\t\tif(a[placeA] == ')')tmp--;\n\t\t\tplaceA++;\n\t\t}while(tmp != 0);\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(b[placeB] == '(')tmp++;\n\t\t\tif(b[placeB] == ')')tmp--;\n\t\t\tplaceB++;\n\t\t}while(tmp != 0);\n\t\tplaceA--;\n\t\tplaceB--;\n\t}\n\tDBG(cout << \"HOGE DFS \" << a[placeA] << ' ' << b[placeB] << endl;);\n\tplaceA += 2;\n\tplaceB += 2;\n\tcout << \")[\";\n\ttmp = 0;\n\tDBG(cout << \"NUM DFS \" << a[placeA] << ' ' << b[placeB] << endl;);\n\n\twhile(isdigit(a[placeA])){\n\t\ttmp *= 10;\n\t\ttmp += a[placeA] - '0';\n\t\tplaceA++;\n\t}\n\tnum += tmp;\n\tDBG(cout << \"A is \" << tmp << endl;);\n\ttmp = 0;\n\twhile(isdigit(b[placeB])){\n\t\ttmp *= 10;\n\t\ttmp += b[placeB] - '0';\n\t\tplaceB++;\n\t}\n\tnum += tmp;\n\tDBG(cout << \"B is \" << tmp << endl;);\n\tDBG(cout << \"num is \";)cout << num <<  \"](\";\n\tplaceA++;\n\tplaceB++;\n\t\n\tif(a[placeA+1] == '(' && b[placeB+1] == '('){\n\t\tplaceA++;\n\t\tplaceB++;\n\t\tdfs();\n\t}\n\telse{\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(a[placeA] == '(')tmp++;\n\t\t\tif(a[placeA] == ')')tmp--;\n\t\t\tplaceA++;\n\t\t}while(tmp != 0);\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(b[placeB] == '(')tmp++;\n\t\t\tif(b[placeB] == ')')tmp--;\n\t\t\tplaceB++;\n\t\t}while(tmp != 0);\n\t}\n\tDBG(cout << \"END DFS \" << a[placeA] << ' ' << b[placeB] << endl;);\n\tcout << \")\";\n}\n\nint main()\n{\n\tcin >> a >> b;\n\tdfs();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nstruct Node {\n  int x;\n  Node *l, *r;\n};\n\nint nm(string::iterator &it){\n  int x = 0;\n  while (isdigit(*it)){\n    x *= 10;\n    x += *it - '0';\n    ++it;\n  }\n  return x;\n}\n\nNode *dfs(string::iterator &it){\n  if (*it != '('){\n    ++it;\n    return nullptr;\n  }\n  ++it;\n  auto l = dfs(it);\n  ++it;\n  int x = nm(it);\n  ++it, ++it;\n  auto r = dfs(it);\n  ++it;\n  return new Node{x, l, r};\n}\n\nstring dfs2(Node *v, Node *u){\n  if (v == nullptr || u == nullptr) return \"\";\n  auto l = dfs2(v->l, u->l);\n  auto x = to_string(v->x + u->x);\n  auto r = dfs2(v->r, u->r);\n  return \"(\" + l + \")[\" + x + \"](\" + r + \")\";\n}\n\nint main(){\n  string s, t;\n  cin >> s >> t;\n  auto it1 = s.begin(), it2 = t.begin();\n  auto a = dfs(it1), b = dfs(it2);\n  cout << dfs2(a, b) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nint tree(State&);\nint number(State&);\n\nPII t[2][1010];\nint idx;\nint heap1[1010], heap2[1010], heap[1010];\nint val[2][1010];\nint cnt;\n\nint tree(State &begin) {\n  if(*begin != '(') return -1;\n  begin++;\n  int left = tree(begin);\n  begin++;\n  begin++;\n  int res = number(begin);\n  begin++;\n  begin++;\n  int right = tree(begin);\n  begin++;\n  val[idx][cnt] = res;\n  t[idx][cnt++] = {left, right};\n  // cout << left << \" \" << cnt-1 << \" \" << res << \" \" << right << endl;\n  return cnt-1;\n}\n\nint number(State &begin) {\n  int res = 0;\n  while(isdigit(*begin)) {\n    res *= 10;\n    res += *begin - '0';\n    ++begin;\n  }\n  return res;\n}\n\nstring dfs(int num) {\n  if(heap[num] == -1) return \"\";\n  string ret = \"(\";\n  ret += (dfs(num*2+1));\n  ret += (\")[\");\n  ret += (to_string(heap[num]));\n  ret += (\"](\");\n  ret += (dfs(num*2+2));\n  ret += (\")\");\n  return ret;\n}\n\nsigned main(void)\n{\n  string s, tt;\n  cin >> s >> tt;\n  memset(val, -1, sizeof(val));\n  memset(heap1, -1, sizeof(heap1));\n  memset(heap2, -1, sizeof(heap2));\n  memset(heap, -1, sizeof(heap));\n  idx = 0, cnt = 0;\n  State begin = s.begin();\n  int root1 = tree(begin);\n  idx = 1, cnt = 0;\n  begin = tt.begin();\n  int root2 = tree(begin);\n\n  queue<PII> que;\n  que.push({root1, 0});\n  heap1[0] = val[0][root1];\n  while(que.size()) {\n    PII p = que.front(); que.pop();\n    int v = p.first, index = p.second;\n    // cout << t[0][v].first << \",\" << v << \",\" << t[0][v].second << endl;\n    if(v == -1) continue;\n    heap1[index*2+1] = t[0][v].first==-1?-1:val[0][t[0][v].first];\n    que.push({t[0][v].first, index*2+1});\n    heap1[index*2+2] = t[0][v].second==-1?-1:val[0][t[0][v].second];\n    que.push({t[0][v].second, index*2+2});\n  }\n\n  while(que.size()) que.pop();\n  que.push({root2, 0});\n  heap2[0] = val[1][root2];\n  while(que.size()) {\n    PII p = que.front(); que.pop();\n    int v = p.first, index = p.second;\n    if(v == -1) continue;\n    heap2[index*2+1] = t[1][v].first==-1?-1:val[1][t[1][v].first];\n    que.push({t[1][v].first, index*2+1});\n    heap2[index*2+2] = t[1][v].second==-1?-1:val[1][t[1][v].second];\n    que.push({t[1][v].second, index*2+2});\n  }\n\n  REP(i, 1010) {\n    if(heap1[i] == -1 || heap2[i] == -1) {\n      heap[i] = -1;\n    } else {\n      heap[i] = heap1[i] + heap2[i];\n    }\n  }\n\n  cout << dfs(0) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring s1,s2;ll kasai[100000],isao[100000],jcreation[100000];\nbool visited[100000],visited2[100000];\n\nvoid dfs(int now,int cnt){\n  visited[cnt]=true;\n  if(now==s1.size()){\n    return;\n  }\n  if(s1[now]=='('){\n    if(visited[cnt*2+1])\n      dfs(now+1,(cnt*2)+2);\n    else\n      dfs(now+1,(cnt*2)+1);\n  }else if(s1[now]==')'){\n    dfs(now+1,(cnt-1)/2);\n  }else{\n    now++;\n    ll num=0;\n    while(s1[now]>='0'&&s1[now]<='9'){\n      num*=10;\n      num+=s1[now]-'0';\n      now++;\n    }\n    kasai[cnt]=num;\n    dfs(now+1,cnt);\n  }\n}\nvoid dfs2(int now,int cnt){\n  visited2[cnt]=true;\n  if(now==s2.size()){\n    return;\n  }\n  if(s2[now]=='('){\n    if(visited2[cnt*2+1])\n      dfs2(now+1,(cnt*2)+2);\n    else\n      dfs2(now+1,(cnt*2)+1);\n  }else if(s2[now]==')'){\n    dfs2(now+1,(cnt-1)/2);\n  }else{\n    now++;\n    ll num=0;\n    while(s2[now]>='0'&&s2[now]<='9'){\n      num*=10;\n      num+=s2[now]-'0';\n      now++;\n    }\n    isao[cnt]=num;\n    dfs2(now+1,cnt);\n  }\n}\nstring Stoi(int num){\n  string s=\"\";\n  while(num>0){\n    s+=(char)((num%10)+'0');\n    num/=10;\n  }\n  reverse(s.begin(),s.end());\n  return s;\n}\nstring dfs3(int now){\n  string ret=\"\";\n  if(jcreation[now]==-1)return ret;\n  ret=\"(\"+dfs3(2*now+1)+\")[\"+Stoi(jcreation[now])+\"](\"+dfs3(2*now+2)+\")\";\n  return ret;\n}\nint main(){\n  for(int i=0;i<100000;i++){\n    kasai[i]=-1;\n    isao[i]=-1;\n    jcreation[i]=-1;\n  }\n  cin>>s1>>s2;\n  dfs(0,0);\n  dfs2(0,0);\n  for(int i=0;i<100000;i++){\n    // cout<<i<<\" \"<<kasai[i]<<\" \"<<isao[i]<<endl;\n    if(isao[i]>=0&&kasai[i]>=0){\n      (jcreation[i]=isao[i]+kasai[i]);\n    }\n  }\n  cout<<dfs3(0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;//if(l+1>=r+1){return NULL;}\n  for(int i=l+1;i<r-1;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c);\n  if(r-1!=c+1)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size());\n  n=1;node p2=con(0,a[1].size());\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\n\tnode.emplace_back(Node());\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define CK(N, A, B) (A <= N && N < B)\n#define REP(i, a, b) for (ll i = a; i < b; i++)\n#define RREP(i, a, b) for (ll i = (b - 1); a <= i; i--)\n#define F first\n#define S second\ntypedef long long ll;\n\nconst int INF = 1e9 + 7;\nconst long long LLINF = 1e18;\n\nstring a, b;\nll idxa, idxb;\nll cnta, cntb;\nint main() {\n    cin>>a>>b;\n\n    a=a+\"A\";\n    b=b+\"B\";\n\n    while(idxa<a.size()-1 && idxb<b.size()-1){\n        while(a[idxa]==b[idxb] && (a[idxa]!='[' || b[idxb]!='[')){\n            cout<<a[idxa];\n\n            if(a[idxa]=='('){\n                cnta++;\n                cntb++;\n            }\n            else if(a[idxa]==')'){\n                cnta--;\n                cntb--;\n            }\n\n            idxa++; idxb++;\n        }\n        if(a[idxa]=='('){\n            cnta++;\n            cntb--;\n        }\n        else if(a[idxa]==')'){\n            cnta--;\n            cntb++;\n        }\n\n        // ignore no match sub string\n        if(cnta>cntb){\n            while(cnta!=cntb){\n                idxa++;\n                if(a[idxa]=='(') cnta++;\n                else if(a[idxa]==')') cnta--;\n            }\n        }\n        else if(cnta<cntb){\n            while(cnta!=cntb){\n                idxb++;\n                if(b[idxb]=='(') cntb++;\n                else if(b[idxb]==')') cntb--;\n            }\n        }\n\n        // add node value\n        if(a[idxa]=='[' && b[idxb]=='['){\n            idxa++; idxb++;\n\n            ll suma=0, sumb=0;\n            while(isdigit(a[idxa])){\n                suma=10*suma+(a[idxa]-'0');\n                idxa++;\n            }\n            while(isdigit(b[idxb])){\n                sumb=10*sumb+(b[idxb]-'0');\n                idxb++;\n            }\n            cout<<\"[\"<<suma+sumb<<\"]\";\n            idxa++; idxb++;\n        }\n    }\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Tree{\n    int val = -1;\n    Tree *L = NULL, *R = NULL;\n};\n\nTree* build(int &pos, string s){\n    Tree* tree = new Tree;\n    if(pos==s.npos || s[pos] == ')'){\n        pos++;\n        return tree;\n    }\n    else if(s[pos] == '('){\n        pos++;\n        tree->L = build(pos, s);\n    }\n    if(s[pos] == '['){\n        int val = 0;\n        while(s[++pos] != ']'){\n            val *= 10;\n            val += s[pos]-'0';\n        }\n        tree->val = val;\n        pos+=2;\n        tree->R = build(pos, s);\n    }\n    pos++;\n    return tree;\n}\n\nTree* merge(Tree *a, Tree *b){\n    Tree *tree = new Tree;\n    if(a->val != -1 && b->val != -1){\n        tree->val = a->val + b->val;\n        if(a->L != NULL && b->L != NULL){\n            tree->L = merge(a->L, b->L);\n        }\n        if(a->R != NULL && b->R != NULL){\n            tree->R = merge(a->R, b->R);\n        }\n    }\n    return tree;\n}\n\nstring dfs(Tree *tree){\n    string res = \"\";\n    if(tree->val != -1){\n        res.push_back('(');\n        if(tree->L != NULL){\n        res += dfs(tree->L);\n        }\n        res.push_back(')');\n    \n        res.push_back('[');\n        res += to_string(tree->val);\n        res.push_back(']');\n    \n        res.push_back('(');\n        if(tree->R != NULL){\n            res += dfs(tree->R);\n        }\n        res.push_back(')');\n    }\n    return res;\n}\n\nint main() {\n    string A, B;\n    cin >> A >> B;\n    Tree *a, *b, *c;\n    int pos = 0;\n    a = build(pos, A);\n    pos = 0;\n    b = build(pos, B);\n\n    c = merge(a, b);\n\n    string ans = dfs(c);\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n    int label;\n    Node* lhs;\n    Node* rhs;\n};\n\nNode *root_l, *root_r;\n\nNode* parse(string s, int l, int r) {\n    if(r - l == 0) return nullptr;\n    int sum = 0, i = l;\n    for(;; i++) {\n        if(s[i] == '(') sum++;\n        if(s[i] == ')') sum--;\n        if(sum == 0 && s[i] == ')') {\n            i++;\n            break;\n        }\n    }\n\n    Node* ret = new Node;\n    ret -> lhs = parse(s, l+1, i-1);\n\n    i++; // '['\n    int num = 0;\n    while(isdigit(s[i])) num = num * 10 + (s[i] - '0'), i++;\n    ret -> label = num;\n    i++; // ']'\n\n    ret -> rhs = parse(s, i+1, r-1);\n    return ret;\n}\n\nstring merge(Node* nl, Node* nr) {\n    int value = nl -> label + nr -> label;\n    string l = \"\", r = \"\";\n    if(nl -> lhs && nr -> lhs) l = merge(nl -> lhs, nr -> lhs);\n    if(nl -> rhs && nr -> rhs) r = merge(nl -> rhs, nr -> rhs);\n    return \"(\" + l + \")[\" + to_string(value) + \"](\" + r + \")\";\n}\n\nint main() {\n    string s, t; cin >> s >> t;\n    root_l = parse(s, 0, s.length());\n    root_r = parse(t, 0, t.length());\n\n    cout << merge(root_l, root_r) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\tshow(s.substr(l, r - l ))\n\n\tnode.emplace_back(Node());\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tstring ans = merge(x,0,y,0);\n\tshow(\"test\")\n\tshow(ans)\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \nusing namespace std;\n \ntypedef pair<string,string> pss;\ntypedef long long ll;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define pb push_back\n \n \nint find_cent(string s){\n    int count = 0;\n    for(int i=0; i< s.size(); i++){\n        if(s[i] == '(') count++;\n        else if(s[i] == ')') count--;\n        \n        if(count==0) return i;\n    }\n    return -1;\n}\n \npss dfs(string a, string b){\n    if(a.size()==0||b.size()==0)return pss(\"\",\"\");\n    \n    string ret = \"\";\n    string a_l=\"\",a_r=\"\",b_l=\"\",b_r=\"\";\n    \n    int a_cent, b_cent;\n    \n    a_cent = find_cent(a);  //get ) pos\n    b_cent = find_cent(b);  //get ) pos\n    \n    a_l = a.substr(1, a_cent-1);\n    b_l = b.substr(1, b_cent-1);\n    \n    int a_n = 0;\n    while(a[a_cent] != ']'){\n        if('0' <= a[a_cent] && a[a_cent] <= '9'){ a_n *= 10; a_n += (int)a[a_cent] - '0';}\n        a_cent++;\n    }\n    \n    a_r = a.substr(a_cent+2, a.size()-a_cent-3); //?\n    \n    a_cent = a_n;\n    \n    \n    int b_n = 0;\n    while(b[b_cent] != ']'){\n        if('0' <= b[b_cent] && b[b_cent] <= '9'){ b_n *= 10; b_n += (int)b[b_cent] - '0';}\n        b_cent++;\n    }\n    \n    b_r = b.substr(b_cent+2, b.size()-b_cent-3);\n    \n    b_cent = b_n;\n    \n    \n//    cout << a_l << \" [ \" << a_cent << \" ] \"<< a_r << endl;\n//    cout << b_l << \" [ \" << b_cent << \" ] \"<< b_r << endl;\n    \n    pss res_l = dfs(a_l,b_l);\n    pss res_r = dfs(a_r,b_r);\n    \n    string res_a = '('+res_l.first + \")[\"+to_string(a_cent)+\"](\" + res_r.first+')';\n    string res_b = '('+res_l.second + \")[\"+to_string(b_cent)+\"](\" + res_r.second+')';\n \n    return pss(res_a,res_b);\n}\n \nint main(){\n    string a, b;\n    cin >> a >> b;\n    pss res = dfs(a, b);\n    \n    a = res.first;\n    b=res.second;\n    \n    vector<int> numa,numb;\n    \n    for(int i=0;i<a.size();i++){\n        if(a[i]!='[')continue;\n        string tmp=\"\";\n        for(int j=i+1;;j++){\n            if(a[j]!=']')tmp+=a[j];\n            else {i=j;break;} //?\n        }\n        numa.pb(stoi(tmp));\n    }\n    \n    for(int i=0;i<b.size();i++){\n        if(b[i]!='[')continue;\n        string tmp=\"\";\n        for(int j=i+1;;j++){\n            if(b[j]!=']')tmp+=b[j];\n            else {i=j;break;} //?\n        }\n        numb.pb(stoi(tmp));\n    }\n    \n    rep(i,numa.size()){\n        numa[i]+=numb[i];\n    }\n    \n    \n    int cou=0;\n    rep(i,a.size()){\n        if(a[i]<'0'||'9'<a[i]){\n            cout<<a[i];\n        }\n        if(a[i]=='['){\n            cout<<numa[cou];\n            cou++;\n            while(a[i+1]!=']')i++;\n \n        }\n    }\n    cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n\nusing namespace std;\n\nenum TYPE{\n\tNONE,\n\tFIRST,\n\tSECOND,\n\tLEFT,\n\tRIGHT\n};\n\nstruct Node{\n\tNode(){\n\t\tvalue = address = -1;\n\t\tparent = left_child=right_child = -1;\n\t}\n\tint value,address,parent,left_child,right_child;\n};\n\nNode first[1000],second[1000],third[1000];\nint first_index = 0,second_index = 0;\nchar buf[1010];\n\nTYPE toWrite;\n\nvoid recursive(int left,int right,int parent_address,TYPE left_or_right){\n\tint calcDepth,nextRight,nextLeft,tmp,nextParentAddress = -1;\n\tif(parent_address != -1){\n\t\tcalcDepth = 0;\n\t\tfor(int i = left,k=0; i <= right; i++){\n\n\t\t\tif(calcDepth==0 && buf[i] == '['){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[first_index].value = tmp;\n\t\t\t\t\t\tfirst[first_index].address = 2*parent_address+1;\n\t\t\t\t\t\tfirst_index++;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[first_index].value = tmp;\n\t\t\t\t\t\tfirst[first_index].address = 2*parent_address+2;\n\t\t\t\t\t\tfirst_index++;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[second_index].value = tmp;\n\t\t\t\t\t\tsecond[second_index].address = 2*parent_address+1;\n\t\t\t\t\t\tsecond_index++;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[second_index].value = tmp;\n\t\t\t\t\t\tsecond[second_index].address = 2*parent_address+2;\n\t\t\t\t\t\tsecond_index++;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextRight = i-1;\n\t\t\t\tnextLeft = k+1;\n\t\t\t\tbreak;\n\t\t\t}else if(calcDepth==0 && buf[i] == '(' && buf[i+1] >= '0' && buf[i+1] <= '9'){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ')';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[first_index].value = tmp;\n\t\t\t\t\t\tfirst[first_index].address = 2*parent_address+1;\n\t\t\t\t\t\tfirst_index++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[first_index].value = tmp;\n\t\t\t\t\t\tfirst[first_index].address = 2*parent_address+2;\n\t\t\t\t\t\tfirst_index++;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[second_index].value = tmp;\n\t\t\t\t\t\tsecond[second_index].address = 2*parent_address+1;\n\t\t\t\t\t\tsecond_index++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[second_index].value = tmp;\n\t\t\t\t\t\tsecond[second_index].address = 2*parent_address+2;\n\t\t\t\t\t\tsecond_index++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\t}\n\t\t}\n\n\t\tif(nextParentAddress != -1){\n\t\t\tif(left+1 < nextRight-1){\n\t\t\t\trecursive(left+1,nextRight-1,nextParentAddress,LEFT);\n\t\t\t}\n\t\t\tif(nextLeft+1 < right-1){\n\t\t\t\trecursive(nextLeft+1,right-1,nextParentAddress,RIGHT);\n\t\t\t}\n\t\t}\n\n\t}else{\n\t\tcalcDepth = 0;\n\t\tfor(int i = 0,k=0; i <= right; i++){\n\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\telse{\n\t\t\t\tif(calcDepth==0 && buf[i] == '['){\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\t\tfirst[0].value = tmp;\n\t\t\t\t\t\tfirst[0].address = 0;\n\t\t\t\t\t\tfirst_index++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[0].value = tmp;\n\t\t\t\t\t\tsecond[0].address = 0;\n\t\t\t\t\t\tsecond_index++;\n\t\t\t\t\t}\n\t\t\t\t\tnextRight = i-1;\n\t\t\t\t\tnextLeft = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(left+1 < nextRight-1){\n\t\t\trecursive(left+1,nextRight-1,0,LEFT);\n\t\t}\n\t\tif(nextLeft+1 < right-1){\n\t\t\trecursive(nextLeft+1,right-1,0,RIGHT);\n\t\t}\n\t}\n}\n\nvoid outPut(int address){\n\n\tif(third[address].left_child != -1 || third[address].right_child != -1){\n\t\tif(third[address].left_child != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(third[address].left_child);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t\tprintf(\"[%d]\",third[address].value);\n\t\tif(third[address].right_child != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(third[address].right_child);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t}else{\n\t\tprintf(\"()[%d]()\",third[address].value);\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%s\",buf);\n\tint length;\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = FIRST;\n\trecursive(0,length-1,-1,NONE);\n\n\tscanf(\"%s\",buf);\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = SECOND;\n\trecursive(0,length-1,-1,NONE);\n\n\tint third_index = 0,indexTable[1000];\n\n\tfor(int i = 0; i < 1000; i++)indexTable[i] = -1;\n\n\tfor(int i = 0; i < first_index; i++){\n\t\tfor(int k = 0; k < second_index; k++){\n\t\t\tif(first[i].address == second[k].address){\n\t\t\t\tif(first[i].address == 0){\n\t\t\t\t\tthird[third_index].address = 0;\n\t\t\t\t\tthird[third_index].value = first[i].value + second[k].value;\n\t\t\t\t\tthird[third_index].parent = -1;\n\t\t\t\t\tindexTable[0] = 0;\n\t\t\t\t\tthird_index++;\n\t\t\t\t}else{\n\t\t\t\t\tthird[third_index].address = first[i].address;\n\t\t\t\t\tthird[third_index].value = first[i].value + second[k].value;\n\t\t\t\t\tindexTable[first[i].address] = third_index;\n\t\t\t\t\tthird_index++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint p_tmp;\n\n\tfor(int i = 0; i < third_index; i++){\n\t\tif(third[i].address != 0){\n\t\t\tp_tmp = indexTable[(third[i].address-1)/2];\n\t\t\tthird[i].parent = p_tmp;\n\t\t\tif(third[i].address%2 == 1){\n\t\t\t\tthird[p_tmp].left_child = i;\n\t\t\t}else{\n\t\t\t\tthird[p_tmp].right_child = i;\n\t\t\t}\n\t\t}\n\t}\n\n\toutPut(0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\ttree t;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\ttree t;\n\tvt3.push_back(t);\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tif (vt.size() < no)\n\t\treturn \"\";\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\t//saiki(s1,tree1);\n\t//saiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\nstring s, t;\n\nint f(int sc, string& s, char cl, char cr) {\n\tint cnt = 1;\n\tsc++;\n\twhile (cnt > 0) {\n\t\tif (s[sc] == cl) cnt++;\n\t\tif (s[sc] == cr) cnt--;\n\t\tsc++;\n\t}\n\treturn sc;\n}\n\nint num(int l, int r, string &s) {\n\tint res = 0;\n\tfor (int i = l; i < r; i++) {\n\t\tres = res * 10 + (s[i] - '0');\n\t}\n\treturn res;\n}\n\nstring dfs(int sl, int sr, int tl, int tr) {\n\tif (sl == sr or tl == tr) return \"\";\n\n\tint sc1 = f(sl, s, '(', ')');\n\tint tc1 = f(tl, t, '(', ')');\n\tstring L = '(' + dfs(sl + 1, sc1 - 1, tl + 1, tc1 - 1) + ')';\n\tint sc2 = f(sc1, s, '[', ']');\n\tint tc2 = f(tc1, t, '[', ']');\n\tint sn = num(sc1 + 1, sc2 - 1, s);\n\tint tn = num(tc1 + 1, tc2 - 1, t);\n\tstring M = '[' + to_string(sn + tn) + ']';\n\tint sc3 = f(sc2, s, '(', ')');\n\tint tc3 = f(tc2, t, '(', ')');\n\tstring R = '(' + dfs(sc2 + 1, sc3 - 1, tc2 + 1, tc3 - 1) + ')';\n\treturn L + M + R;\n\n}\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> s >> t;\n\tcout << dfs(0, s.size(), 0, t.size()) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nvoid solve(string s, int par, vector<int>& vec) {\n\tint cnt = 0;\n\tint l = 1, r = 0;\n\tfor (int i = 1; i < s.size() - 1; i++) {\n\t\tif (s[i] == '(')cnt++;\n\t\telse if (s[i] == ')')cnt--;\n\n\t\tif (cnt == 0) {\n\t\t\tr = i;\n\t\t\tstring next = s.substr(l, r - l + 1);\n\n\t\t\tif (l == 1) {\n\t\t\t\tsolve(next, par * 2 + 1, vec);\n\n\t\t\t\ti += 2;\n\n\t\t\t\tint l2 = i;\n\t\t\t\twhile (1) {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (s[i] == ']') {\n\t\t\t\t\t\tvec[par] = stoi(s.substr(l2, i - l2).data());\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tl = r = i;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsolve(next, par * 2 + 2, vec);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstring solve2(vector<int>&ans, int par) {\n\tstring s1, s2, s3;\n\n\tif (ans[par] != -1) {\n\t\ts2 = to_string(ans[par]);\n\t}\n\telse return \"\";\n\n\ts1 = solve2(ans, par * 2 + 1);\n\ts3 = solve2(ans, par * 2 + 2);\n\n\treturn \"(\" + s1 + \")\" + \"[\" + s2 + \"]\" + \"(\" + s3 + \")\";\n}\n\nint main()\n{\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tvector<int>a(1000,-1), b(1000,-1);\n\n\ts1.insert(s1.begin(), '(');\n\ts1.push_back(')');\n\ts2.insert(s2.begin(), '(');\n\ts2.push_back(')');\n\n\tsolve(s1, 0, a);\n\tsolve(s2, 0, b);\n\n\tvector<int>c(1000, -1);\n\tfor (int i = 0; i < 1000; i++) {\n\t\tif (a[i] != -1 && b[i] != -1) {\n\t\t\tc[i] = a[i] + b[i];\n\t\t}\n\t}\n\n\tcout << solve2(c, 0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nvoid solve(string s, int par, map<int,int>& m) {\n\tint cnt = 0;\n\tint l = 1, r = 0;\n\tfor (int i = 1; i < s.size() - 1; i++) {\n\t\tif (s[i] == '(')cnt++;\n\t\telse if (s[i] == ')')cnt--;\n\n\t\tif (cnt == 0) {\n\t\t\tr = i;\n\t\t\tstring next = s.substr(l, r - l + 1);\n\n\t\t\tif (l == 1) {\n\t\t\t\tsolve(next, par * 2 + 1, m);\n\n\t\t\t\ti += 2;\n\n\t\t\t\tint l2 = i;\n\t\t\t\twhile (1) {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (s[i] == ']') {\n\t\t\t\t\t\tm[par] = stoi(s.substr(l2, i - l2).data());\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tl = r = i;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsolve(next, par * 2 + 2,m);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstring solve2(map<int, int>& m ,int par) {\n\tstring s1, s2, s3;\n\n\tif (m.find(par) != m.end()) {\n\t\ts2 = to_string(m[par]);\n\t}\n\telse return \"\";\n\n\ts1 = solve2(m, par * 2 + 1);\n\ts3 = solve2(m, par * 2 + 2);\n\n\treturn \"(\" + s1 + \")\" + \"[\" + s2 + \"]\" + \"(\" + s3 + \")\";\n}\n\nint main()\n{\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\n\ts1.insert(s1.begin(), '(');\n\ts1.push_back(')');\n\ts2.insert(s2.begin(), '(');\n\ts2.push_back(')');\n\n\tmap<int, int>a, b;\n\n\n\tsolve(s1, 0, a);\n\tsolve(s2, 0, b);\n\t\n\tmap<int, int>c;\n\n\tfor (auto itr = a.begin(); itr != a.end(); itr++) {\n\t\tint p = itr->first;\n\t\tauto itr2 = b.find(p);\n\t\tif (itr2 != b.end()) {\n\t\t\tc[p] = itr->second + itr2->second;\n\t\t}\n\t}\n\n\tcout << solve2(c, 0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct no{\n  no *l,*r;\n  int key;\n  no(){l=r=NULL;key=-1;};\n};\ntypedef no* node;\nstring s[2];\nnode head[2];\nint x,p;\nint get_num(){\n  int res=0;\n  while(p<s[x].size()&&isdigit(s[x][p]))res=res*10+(s[x][p++]-'0');\n  return res;\n}\nnode make_tree(){\n  node po=new no();\n  if(s[x][p]=='(')++p,po->l=make_tree();\n  if(isdigit(s[x][p]))po->key=get_num();\n  if(p<s[x].size()&&s[x][p]=='(')++p,po->r=make_tree();\n  p++;\n  return po;\n}\nvoid ch(node n1,node n2,int p){\n  if(p)cout<<'(';\n  if(n1->l!=NULL&&n2->l!=NULL)ch(n1->l,n2->l,1);\n  if(n1->key>=0&&n2->key>=0)cout<<'['<<n1->key+n2->key<<']';\n  if(n1->r!=NULL&&n2->r!=NULL)ch(n1->r,n2->r,1);\n  if(p)cout<<')';\n}\nmain(){\n  r(i,2)cin>>s[i];\n  r(i,2)r(j,s[i].size())if(s[i][j]==']'||s[i][j]=='[')s[i].erase(s[i].begin()+j),j--;\n  r(i,2)p=0,x=i,head[i]=make_tree();\n  ch(head[0],head[1],0);\n  cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#ifdef DEBUG_MODE\n    #define DBG(n) n;\n#else\n    #define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n \n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nstring a,b;\nint placeA,placeB;\n \nvoid dfs(){\n    cout << '(';\n    int num = 0;\n    int tmp;\n    if(a[placeA+1] == '(' && b[placeB+1] == '('){\n        placeA++;\n        placeB++;\n        dfs();\n    }\n    else{\n        tmp = 0;\n        do{\n            if(a[placeA] == '(')tmp++;\n            if(a[placeA] == ')')tmp--;\n            placeA++;\n        }while(tmp != 0);\n        tmp = 0;\n        do{\n            if(b[placeB] == '(')tmp++;\n            if(b[placeB] == ')')tmp--;\n            placeB++;\n        }while(tmp != 0);\n    }\n    while(!isdigit(a[placeA]))placeA++;\n    while(!isdigit(b[placeB]))placeB++;\n    cout << \")[\";\n    tmp = 0;\n \n    while(isdigit(a[placeA])){\n        tmp *= 10;\n        tmp += a[placeA] - '0';\n        placeA++;\n    }\n    num += tmp;\n    tmp = 0;\n    while(isdigit(b[placeB])){\n        tmp *= 10;\n        tmp += b[placeB] - '0';\n        placeB++;\n    }\n    num += tmp;\n    cout << num <<  \"](\";\n    placeA++;\n    placeB++;\n     \n    if(a[placeA+1] == '(' && b[placeB+1] == '('){\n        placeA++;\n        placeB++;\n        dfs();\n    }\n    else{\n        tmp = 0;\n        do{\n            if(a[placeA] == '(')tmp++;\n            if(a[placeA] == ')')tmp--;\n            placeA++;\n        }while(tmp != 0);\n        tmp = 0;\n        do{\n            if(b[placeB] == '(')tmp++;\n            if(b[placeB] == ')')tmp--;\n            placeB++;\n        }while(tmp != 0);\n    }\n    cout << \")\";\n}\n \nint main()\n{\n    cin >> a >> b;\n    dfs();\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin== End || Begin+1==End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin;Begin!=End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      if (rb > End) {\n        rb = End;\n      }\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin(), be = b.end();\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nint s2tree(string &A, vector<int> &na, vector<pair<int,int>> &a, int b, int e){\n\t\n\tif(e - b <= 2) return -1;\n\t\n\tint inb = 0,ine = 0;\n\tfor(int i = b, depth = 0; i < e; i++){\n\t\tif(A[i] == '(') {\n\t\t\tdepth++;\n\t\t} else if(A[i] == ')'){\n\t\t\tdepth--;\n\t\t}\n\t\t\n\t\tif(A[i] == '[' && !depth) {\n\t\t\tinb = i+1;\n\t\t}\n\t\t\n\t\tif(A[i] == ']' && !depth) {\n\t\t\tine = i;\n\t\t}\n\t}\n\n  int number = 0;\n\n\tfor(int i = inb; i < ine; i++){\n\t\tnumber = number * 10 + A[i] - '0';\n\t}\n\n  int ca = a.size();\n\n\tna.push_back(number);\n\t\n\ta.emplace_back(-1,-1);\n\n  int ra = s2tree(A, na, a, b + 1, inb-2);\n  int rb = s2tree(A, na, a, ine + 2, e-1);\n  a[ca].first = ra;\n  a[ca].second = rb;\n\n\treturn ca;\n}\n\nint synthesis(\n              vector<pair<int,int>> &a, vector<pair<int,int>> &b, vector<pair<int,int>> &c, vector<int> &na, vector<int> &nb, vector<int> &nc, int ca = 0, int cb = 0){\n\t\n\tnc.push_back(na[ca] + nb[cb]);\n\tc.push_back({-1,-1});\n\t\n\tint cc = c.size()-1;\n\t\n\tif(a[ca].first != -1 && b[cb].first != -1) {\n    int d = synthesis(a, b, c, na, nb, nc, a[ca].first, b[cb].first);\n    c[cc].first = d;\n\t}\n\t\n\tif(a[ca].second != -1 && b[cb].second != -1) {\n    int d = synthesis(a, b, c, na, nb, nc, a[ca].second, b[cb].second);\n    c[cc].second = d;\n\t}\n\t\n\treturn cc;\n}\n\nstring tree2s(vector<int>& nc, vector<pair<int,int>> &c, int cc = 0){\n\tstring ra, rb, rc;\n\t\n\tif(cc == -1) return \"\";\n\t\n\tra = tree2s(nc, c, c[cc].first);\n\trc = tree2s(nc, c, c[cc].second);\n\t\n\treturn \"(\" + ra + \")\" + \"[\" + to_string(nc[cc]) + \"]\" + \"(\" + rc + \")\";\n}\nsigned main(){\n\tstring A, B, C;\n\tvector<int> na, nb, nc;\n\tvector<pair<int,int>> a, b, c;\n\t\n\tcin>>A>>B;\n\t\n\ts2tree(A, na, a, 0, A.size());\n\ts2tree(B, nb, b, 0, B.size());\n\tsynthesis(a, b, c, na, nb, nc);\n\t\n\tC = tree2s(nc, c);\n\t\n\tcout<<C<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\npair<int,int> get_mid(string t) {\n    int mid_s = t.size();\n    int mid_e = 0;\n\n    for (int i = 1, c = 1; i < t.size(); i++) {\n        if (t[i] == ')') c--;\n        else if (t[i] == '(') c++;\n        else if (!c) {\n            mid_s = min(mid_s, i);\n            mid_e = max(mid_e, i);\n        }\n    }\n\n    return make_pair(mid_s, mid_e);\n}\n\npair<string,string> get_subtree(string t, int mid_s, int mid_e) {\n    string a;\n    string b;\n\n    a = string(t.begin() + 1, t.begin() + mid_s -1);\n    b = string(t.begin() + mid_e + 2, t.end() - 1);\n\n    return make_pair(a,b);\n}\n\nstring get_tree(string a, string b) {\n    if (a.size() == 0 || b.size() == 0) {\n        return \"\";\n    }\n\n    auto ma = get_mid(a);\n    auto sta = get_subtree(a, ma.first, ma.second);\n\n    auto mb = get_mid(b);\n    auto stb = get_subtree(b, mb.first, mb.second);\n\n    stringstream ss, cc;\n    ss << string(a.begin() + ma.first + 1, a.begin() + ma.second)\n        + \" \"\n        + string(b.begin() + mb.first + 1, b.begin() + mb.second);\n\n    int A, B;\n    ss >> A >> B;\n    cc << (A+B);\n    string m;\n    cc >> m;\n\n    string ret = \"(\" + get_tree(sta.first, stb.first) + \")[\"\n        + m + \"](\" + get_tree(sta.second, stb.second) + \")\";\n\n    return ret;\n}\n\n\nint main() {\n    string a, b;\n    cin >> a >> b;\n\n    cout << get_tree(a, b) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Tree {\npublic:\n  Tree(Tree *parent) {\n    num = -1;\n    this->parent = parent;\n    child[0] = child[1] = NULL;\n    cnt = 0;\n  }\n\n  ~Tree() {\n    for (int i = 0; i < cnt; i++) {\n      delete child[i];\n    }\n  }\n  \n  // debug\n  void print() {\n    if (num != -1) {\n      if (cnt >= 1) {\n\tcout << '(';\n\tchild[0]->print();\n\tcout << ')';\n      }\n      cout << '[' << num << ']';\n      if (cnt >= 2) {\n\tcout << '(';\n\tchild[1]->print();\n\tcout << ')';\n      }\n    }\n  }\n\n  void merge(Tree *t) {\n    num += t->num;\n    for (int i = 0; i < cnt; i++) {\n      if (child[i]->num != -1 && t->child[i]->num != -1) {\n\tchild[i]->merge(t->child[i]);\n      } else {\n\tchild[i]->num = -1;\n      }\n    }\n  }\n  \n  int num;\n  Tree *parent;\n  Tree *child[2];\n  int cnt;\n};\n\nTree *readTree() {\n  char c = '\\0';\n\n  Tree *root = new Tree(NULL);\n  for (Tree *t = root; c != ')' || t != root || root->cnt != 2;) {\n    cin >> c;\n    if (c == '(') {\n      t->child[t->cnt] = new Tree(t);\n      t->cnt++;\n      t = t->child[t->cnt - 1];\n    }\n    if (c == ')') {\n      t = t->parent;\n    }\n    if (c == '[') {\n      int num;\n      cin >> num;\n      t->num = num;\n      cin >> c;\n    }\n  }\n\n  return root;\n}\n\nint main() {\n  Tree *t1 = readTree();\n  Tree *t2 = readTree();\n  t1->merge(t2);\n  t1->print();\n\n  delete t1, t2;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\n\tNode tmp;\n\tnode.emplace_back(tmp);\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tstring ans = merge(x,0,y,0);\n\tshow(\"test\")\n\tshow(ans)\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct node{\n    node *left;\n    node *right;\n    int cost;\n    node() : left(nullptr),right(nullptr),cost(-1){};\n};\n\nvoid treebuild(string &s,node* r,int x,int y){\n    if(y<=x+1)return ;\n    int cnt =0;\n    int tmp=0;\n    for(int i=x;i<=y;i++){\n        if(s[i]=='('){\n            cnt++;\n        }else if(s[i]==')'){\n            cnt--;\n        }\n        if(cnt==0){\n            tmp = i;\n            break;\n        }\n    }\n    int num = 0;\n    int tmp2;\n    for(int i = tmp+2;i<=y;i++){\n        if(s[i]>='0'&&s[i]<='9'){\n            num *= 10;\n            num += s[i]-'0';\n        }else{\n            tmp2 = i+1;\n            break;\n        }\n    }\n    r->cost = num;\n    if(x+1<=tmp-1){\n        node* ss = new node();\n        r->left = ss;\n        treebuild(s,ss,x+1,tmp-1);\n    \n    }\n    if(tmp2+1<=y-1){\n        node* tt = new node();\n        r->right = tt;\n        treebuild(s,tt,tmp2+1,y-1);\n    }\n    return ;\n}\n\nvoid treecreate(node* ra,node* rb,node* rc){\n    rc->cost = ra->cost+rb->cost;\n    if(ra->left!=nullptr&&rb->left!=nullptr){\n        node *ss = new node();\n        rc->left= ss;\n        treecreate(ra->left,rb->left,rc->left);\n    }\n    if(ra->right!=nullptr&&rb->right!=nullptr){\n        node *tt = new node();\n        rc->right= tt;\n        treecreate(ra->right,rb->right,rc->right);\n    }\n}\n\nstring answer(node* r){\n    string ans;\n    if(r->left!=nullptr){\n        ans = \"(\"+answer(r->left)+\")\";\n    }else{\n        ans =\"()\";\n    }\n    ans +=\"[\"+to_string(r->cost)+\"]\";\n    if(r->right!=nullptr){\n        ans += \"(\"+answer(r->right)+\")\";\n    }else{\n        ans +=\"()\";\n    }\n    return ans;\n}\nint main(){\n    string A,B;\n    cin >> A >> B;\n    node* ra = new node();\n    node* rb = new node();\n    node* rc = new node();\n    int n = A.size()-1;\n    int m = B.size()-1;\n    treebuild(A,ra,0,n);\n    treebuild(B,rb,0,m);\n    treecreate(ra,rb,rc);\n    cout << answer(rc) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\n\tnode.emplace_back(Node());\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tshow(xi)\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\tshow(  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\")\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tstring ans = merge(x,0,y,0);\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\ttree t;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\ttree t;\n\tvt3.push_back(t);\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\t//saiki(s1,tree1);\n\t//saiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int v;\n  int depth;\n  node *l,*r,*p;\n};\n\nstring s[3];\nint dpnum[1000]={0};\nnode *tree[3];\n\nstring encode(node *x,node *y);\nvoid decode(int num,int n,int dep,node *par);\n\nint main(){\n  cin >> s[0] >> s[1];\n  //s[0]=\"(()[6]())[8](((()[4]())[7]())[9]())\";\n  for(int i=0;i<3;i++){\n    tree[i]=new node;\n    tree[i]->p=NULL;\n    tree[i]->l=NULL;\n    tree[i]->r=NULL;\n    tree[i]->depth=0;\n    tree[i]->v=-1;\n  }\n  decode(0,0,0,tree[0]);\n  //cout << tree[0]->v <<\" \"<<tree[0]->l->v << \" \"<< tree[0]->r->v<<\" \"<<tree[0]->r->l->v <<\" \"<< tree[0]->r->l->l->v<<endl;\n  decode(1,0,0,tree[1]);\n  cout << encode(tree[0],tree[1]) << endl;\n  return 0;\n}\n\nvoid decode(int num,int n,int dep,node *par){\n  //cout << n << \" \" << s[num][n] << \" \"<<dep <<\" \" << par->v << endl;\n  if(n==s[num].size())return;\n  if(s[num][n]=='('){\n    node *newnode = new node;\n    newnode->r=NULL;\n    newnode->l=NULL;\n    newnode->p=par;\n    newnode->depth=dep+1;\n    newnode->v=-1;\n    if(n!=0&&s[num][n-1]==']'){\n      par->r=newnode;\n    }\n    else {\n      par->l=newnode;\n    }\n    decode(num,n+1,dep+1,newnode);\n  }\n  else if(s[num][n]==')')decode(num,n+1,dep-1,par->p);\n  else if(s[num][n]=='['){\n    int x=0;\n    while(s[num][n+1]>='0'&&s[num][n+1]<='9'){\n      n++;\n      x*=10;\n      x+=s[num][n]-'0';\n    }\n    par->v=x;\n    //cout <<\"in \"<<dep << par->v <<endl;\n    decode(num,n+2,dep,par);\n  }\n}\n\nstring encode(node *x,node *y){\n  string ansl,ansm,ansr;\n  if(x->l==NULL||y->l==NULL||x->l->v==-1||y->l->v==-1)ansl=\"()\";\n  else ansl = encode(x->l,y->l);\n  if(x->r==NULL||y->r==NULL||x->r->v==-1||y->r->v==-1)ansr=\"()\";\n  else ansr = encode(x->r,y->r);\n  ansm=\"[\"+to_string(x->v+y->v)+\"]\";\n  if(x==tree[0])return ansl+ansm+ansr;\n  else return \"(\"+ansl+ansm+ansr+\")\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=1000;\n\nvoid dfs(int &id,int &I,vip &a,string &s){\n\tint t=id;\n\tid++;\n\tI++;\n\tif(I<s.size()&&s[I]!=')'){\n\t\ta[t].second.first=id;\n\t\tdfs(id,I,a,s);\n\t}\n\tI+=2;\n\ta[t].first=0;\n\twhile(isdigit(s[I])){\n\t\ta[t].first=10*a[t].first+(s[I]-'0');\n\t\tI++;\n\t}\n\tI+=2;\n\tif(I<s.size()&&s[I]!=')'){\n\t\ta[t].second.second=id;\n\t\tdfs(id,I,a,s);\n\t}\n\tI++;\n}\n\nvip f(string s){\n\tvip a(M,{-1,{-1,-1}});\n\tint id=0,I=0;\n\tdfs(id,I,a,s);\n\treturn a;\n}\n\nvoid DFS(int u,int v,int &id,vip& a,vip& b,vip& c){\n\tc.push_back({a[u].first+b[v].first,{-1,-1}});\n\tint t=id;\n\tif(a[u].second.first>=0&&b[v].second.first>=0){\n\t\tc[t].second.first=id+1;\n\t\tid++;\n\t\tDFS(a[u].second.first,b[v].second.first,id,a,b,c);\n\t}\n\tif(a[u].second.second>=0&&b[v].second.second>=0){\n\t\tc[t].second.second=id+1;\n\t\tid++;\n\t\tDFS(a[u].second.second,b[v].second.second,id,a,b,c);\n\t}\n}\n\nvoid Dfs(int v,vip& a,string& s){\n\ts+='(';\n\tif(a[v].second.first>=0){\n\t\tDfs(a[v].second.first,a,s);\n\t}\n\ts+=')';\n\ts+='[';\n\ts+=to_string(a[v].first);\n\ts+=']';\n\ts+='(';\n\tif(a[v].second.second>=0){\n\t\tDfs(a[v].second.second,a,s);\n\t}\n\ts+=')';\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tstring s,t;\n\tcin>>s>>t;\n\tvip a=f(s),b=f(t);\n\tvip c;\n\tint id=0;\n\tDFS(0,0,id,a,b,c);\n\tstring res;\n\tDfs(0,c,res);\n\tcout<<res<<endl;\n/*\tfor(auto p:a) if(p.first>=0) cout<<p.first<<' '<<p.second.first<<' '<<p.second.second<<endl;\n\tcout<<endl;\n\tfor(auto p:b) if(p.first>=0) cout<<p.first<<' '<<p.second.first<<' '<<p.second.second<<endl;\n\tcout<<endl;\n\tfor(auto p:c) cout<<p.first<<' '<<p.second.first<<' '<<p.second.second<<endl;\n\tcout<<endl;*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstruct Node{\n    int i;\n    int num;\n    int li;\n    int ri;\n\n    Node() : i(-1), num(0), li(-1), ri(-1) {}\n    Node(int _i, int _num, int _li, int _ri) : i(_i), num(_num), li(_li), ri(_ri) {}\n    Node(const Node &rhs) : i(rhs.i), num(rhs.num), li(rhs.li), ri(rhs.ri) {}\n};\n\nint parse(vector<Node>& nodes, string in, int& idx){\n    nodes.push_back(Node());\n    Node node;\n    node.i = nodes.size() - 1;\n\n    // left child\n    if(in.substr(idx, 2) != \"()\"){\n        assert(in[idx++] == '(');\n        node.li = parse(nodes, in, idx);\n        assert(in[idx++] == ')');\n    }\n    else idx += 2;\n\n    // [ num ]\n    assert(in[idx++] == '[');\n    int& num = node.num = 0;\n    while(isdigit(in[idx])){\n        num = 10 * num + (in[idx] - '0');\n        idx++;\n    }\n    assert(in[idx++] == ']');\n\n    // right child\n    if(in.substr(idx, 2) != \"()\"){\n        assert(in[idx++] == '(');\n        node.ri = parse(nodes, in, idx);\n        assert(in[idx++] == ')');\n    }\n    else idx += 2;\n\n    nodes[node.i] = node;\n    return node.i;\n}\n\nstring merge(vector<Node>& a, vector<Node>& b, int va, int vb){\n    string ret;\n    if(a[va].li != -1 and b[vb].li != -1){\n        ret += \"(\" + merge(a, b, a[va].li, b[vb].li) + \")\";\n    }\n    else ret += \"()\";\n\n    stringstream ss; ss << a[va].num + b[vb].num;\n    ret += \"[\" + ss.str() + \"]\";\n    if(a[va].ri != -1 and b[vb].ri != -1){\n        ret += \"(\" + merge(a, b, a[va].ri, b[vb].ri) + \")\";\n    }\n    else ret += \"()\";\n\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    string A, B; cin >> A >> B;\n    vector<Node> a, b;\n    int idx;\n    idx = 0; parse(a, A, idx);\n    idx = 0; parse(b, B, idx);\n\n    cout << merge(a, b, 0, 0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nstruct Node {\n    int val;\n    Node *lch, *rch;\n};\n\nusing pNode = Node*;\n\nstring S;\nint itr;\n\nNode* parse() {\n    if (S[itr] != '(') return nullptr;\n\n    pNode node = new Node;\n\n    ++itr;\n    node->lch = parse();\n    assert(S[itr] == ')');\n\n    node->val = 0;\n    itr += 2;\n    while (S[itr] != ']') {\n        (node->val *= 10) += S[itr] - '0';\n        ++itr;\n    }\n\n    itr += 2;\n    node->rch = parse();\n    assert(S[itr] == ')');\n\n    ++itr;\n    return node;\n}\n\nstring tos(Node* node) {\n    if (node == nullptr) return \"\";\n    return \"(\" + tos(node->lch) + \")\" +\n           \"[\" + to_string(node->val) + \"]\" +\n           \"(\" + tos(node->rch) + \")\";\n}\n\nNode* merge(Node* s, Node* t) {\n    if (s == nullptr || t == nullptr) return nullptr;\n\n    pNode node = new Node;\n    node->lch = merge(s->lch, t->lch);\n    node->val = s->val + t->val;\n    node->rch = merge(s->rch, t->rch);\n\n    return node;\n}\n\nint main() {\n    string s, t;\n    cin >> s >> t;\n\n    S = s;\n    itr = 0;\n    auto str = parse();\n    assert(itr == S.length());\n\n    S = t;\n    itr = 0;\n    auto ttr = parse();\n    assert(itr == S.length());\n\n    auto mtr = merge(str, ttr);\n\n    cout << tos(mtr) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <functional>\n#include <iostream>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nstruct Node {\n    int value = 0;\n    Node* left = nullptr;\n    Node* right = nullptr;\n    Node(int v, Node* l, Node* r)\n        : value{v}\n        , left{l}\n        , right{r}\n    {\n    }\n};\n\nint main()\n{\n    string a;\n    cin >> a;\n    string b;\n    cin >> b;\n\n    auto parse = [](const string& str) {\n        int i = 0;\n        auto value = [&i, &str]() {\n            assert(str[i] == '[');\n            ++i;\n            auto begin = i;\n            while (isdigit(str[i])) {\n                ++i;\n            }\n            auto end = i - 1;\n            assert(str[i] == ']');\n            return stoi(str.substr(begin, end - begin + 1));\n        };\n\n        function<Node*()> p = [&p, &i, &str, &value]() -> Node* {\n            assert(str[i] == '(');\n            if (str[i + 1] == ')') {\n                i += 2;\n                return nullptr;\n            }\n            ++i;\n            auto l = p();\n            auto v = value();\n            ++i;\n            auto r = p();\n            ++i;\n            return new Node{v, l, r};\n        };\n        auto ll = p();\n        auto vv = value();\n        ++i;\n        auto rr = p();\n        return new Node{vv, ll, rr};\n    };\n\n    function<void(Node*)> pp = [&pp](Node* n) {\n        if (n) {\n            cout << \"(\";\n            pp(n->left);\n            cout << \")\";\n            cout << '[' << n->value << ']';\n            cout << \"(\";\n            pp(n->right);\n            cout << \")\";\n        }\n    };\n\n    function<Node*(Node*, Node*)> f = [&f](Node* l, Node* r) {\n        auto ll = l->left && r->left ? f(l->left, r->left) : nullptr;\n        auto rr = l->right && r->right ? f(l->right, r->right) : nullptr;\n        return new Node{l->value + r->value, ll, rr};\n    };\n\n    auto t1 = parse(a);\n    auto t2 = parse(b);\n    auto r = f(t1, t2);\n    pp(r);\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin== End || Begin+1==End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin;Begin!=End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin(), be = b.end();\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;\n  for(int i=l+1;i<r;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c){\n    if(c-1>l+1)\n    po->left=con(l+1,c-1);\n  }\n  if(r-1!=c){\n    if(r-1>c+1)\n    po->right=con(c+1,r-1);\n  }\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size()-1);\n  n=1;node p2=con(0,a[1].size()-1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cstddef>\n#include <memory>\n\nusing namespace std;\n\nclass Node\n{\npublic:\n    shared_ptr<Node> left;\n    shared_ptr<Node> right;\n    int  value;\n    Node()\n    {\n        left  = nullptr;\n        right = nullptr;\n        value = 0;\n    }\n};\n\nusing node_ptr = shared_ptr<Node>;\n\nvector<Node> Aar;\nvector<Node> Bar;\n\n\nvoid input(vector<Node> & ar,const string & str,int & i,node_ptr & ptr)\n{\n    if(str[i]==')')\n    {\n        ++i;\n        return;\n    }\n\n    ptr = make_shared<Node>();\n\n\n    if(str[i]=='(')\n    {\n        ++i;\n        input(ar,str,i,ptr->left);\n    }\n    if(str[i]=='[')\n    {\n        ++i;\n        while(str[i]!=']')\n        {\n            ptr->value*=10;\n            ptr->value+=(int)(str[i]-'0');\n            ++i;\n        }\n        ++i;\n    }\n    if(str[i]=='(')\n    {\n        ++i;\n        input(ar,str,i,ptr->right);\n    }\n    if(str[i]==')')\n    {\n        ++i;\n        return;\n    }\n}\n\nvoid output(node_ptr a, node_ptr b)\n{\n    if(a==nullptr || b==nullptr) return;\n\n    cout << \"(\" << flush;\n    output(a->left,b->left);\n    cout << \")\" << flush;\n\n    cout << \"[\" <<a->value + b->value << \"]\" << flush;\n\n    cout << \"(\" << flush;\n    output(a->right,b->right);\n    cout << \")\" << flush;\n}\n\nint main()\n{\n    string A,B;\n    cin >> A >> B;\n\n    int si=0;\n    node_ptr Aptr;\n    input(Aar,A,si,Aptr);\n\n    si = 0;\n    node_ptr Bptr;\n    input(Bar,B,si,Bptr);\n\n    output(Aptr,Bptr);\n\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no=vt.size();\n\t\t\tvt.push_back({num,0,0});\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = vt3.size();\n\tvt3.push_back({tree1[a].num+tree2[b].num,0,0 });\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2740&lang=jp\ntypedef long long ll;\n#define INF 1<<30\nusing namespace std;\n\nvoid check(int& i,int k, vector<int>& str,string& S) {\n\t/* \"(\" ~ )[x]( ~ ) */\n\tif (S[i] == '(') i++;\n\n\t/* ( \"~\" )[x]( ~ ) */\n\tif (S[i] == '(') {\n\t\tcheck(i, 2 * k + 1, str, S);\n\t}\n\n\t/* ( ~ \")\"[x]( ~ )  */\n\tif (S[i] == ')') i++;\n\n\t/* ( ~ )\"[x]\"( ~ ) */\n\ti++; // \"[\"\n\tstr[k] = 0;\n\twhile (S[i] != ']') {\n\t\tstr[k] = str[k] * 10 + (S[i] - '0');\n\t\ti++;\n\t}\n\ti++; // \"]\"\n\n\t/* ( ~ )[x]\"(\" ~ ) */\n\tif (S[i] == '(') i++;\n\n\t/* ( ~ )[x]( \"~\" )*/\n\tif (S[i] == '(') {\n\t\tcheck(i, 2 * k + 2, str, S);\n\t}\n\n\t/* ( ~ )[x]( ~ \")\"*/\n\tif (S[i] == ')') i++;\n}\n\n/* print answer method */\nvoid out(int k,vector<int>& Sum){\n\tcout << \"(\";\n\tif (Sum[2 * k + 1] != -1) {\n\t\tout(2 * k + 1, Sum);\n\t}\n\tcout << \")[\" << Sum[k] << \"](\";\n\tif (Sum[2 * k + 2] != -1) {\n\t\tout(2 * k + 2, Sum);\n\t}\n\tcout << \")\";\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t/* input */\n\tstring A, B; cin >> A >> B;\n\n\t/* initialize */\n\tint k = max(A.length(), B.length());\n\tvector<int> A_tree(k + 10, -1), B_tree(k + 10, -1),Sum_tree(k+10,-1);\n\n\t/* calc */\n\tint x = 0;\n\tcheck(x, 0, A_tree, A);\n\tx = 0;\n\tcheck(x, 0, B_tree, B);\n\n\tfor (int i = 0; i < (int)A_tree.size();i++) {\n\t\tif (A_tree[i] == -1 || B_tree[i] == -1) continue;\n\t\tSum_tree[i] = A_tree[i] + B_tree[i];\n\t}\n\n\t/*for (auto v : Sum_tree) {\n\t\tcout << v << \" \";\n\t}\n\tcout << endl;*/\n\n\t/* solve */\n\tout(0, Sum_tree);\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//木を実装する\ntypedef struct _node{\n    int element;\n    struct _node *left;\n    struct _node *right;\n    struct _node *par;\n}node;\n\ntypedef struct _tree{\n    node *root;\n}tree;\n\n//リストを生成する関数\ntree *create(){\n    tree *T = (tree *)malloc(sizeof(tree));\n    T->root = (node *)malloc(sizeof(node));\n    T->root->left = NULL;\n    T->root->right = NULL;\n    T->root->par = NULL;\n    T->root->element = -1;\n    return T;\n}\n\nvoid make_tree(tree *T, string s){\n    node *ptr = T->root;\n\n    for(int i = 0; i < (int) s.size(); i++){\n\n        if(s[i] == '('){\n            //どっちかににノードを足す\n            node *add = (node *)malloc(sizeof(node));\n            add->element = -1;\n            add->left = NULL;\n            add->right = NULL;\n            add->par = ptr;\n\n            //左\n            if(ptr->left == NULL){\n                ptr->left = add;\n                ptr = add;\n            }else{\n                ptr->right = add;\n                ptr = add;\n            }\n        }else if(s[i] == ')'){\n            //戻る\n            ptr = ptr->par;\n        }else if(s[i] == '['){\n            string str;\n            int j;\n            for(j = i + 1; s[j] != ']'; j++) str.push_back(s[j]);\n            int num = stoi(str);\n            ptr->element = num;\n            i = j;\n        }\n    }\n}\n\nvoid print_tree(node *v){\n    if(v == NULL || v->element == -1){\n        cout << \")\";\n        return;\n    }\n\n    cout << \"(\";\n    print_tree(v->left);\n    cout << \"[\" << v->element << \"]\";\n    cout << \"(\";\n    print_tree(v->right);\n    if(v->par != NULL) cout << \")\";\n    return;\n}\n\nvoid sum_tree(node *v1, node *v2, node *v3){\n    v3->element = v1->element + v2->element;\n\n    if(v1->left != NULL && v2->left != NULL && v1->left->element != -1 && v2->left->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->left = add;\n        sum_tree(v1->left, v2->left, v3->left);\n    }\n    \n    if(v1->right != NULL && v2->right != NULL && v1->right->element != -1 && v2->right->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->right = add;        \n        sum_tree(v1->right, v2->right, v3->right);\n    }\n    \n    //if(v->par != NULL) cout << \")\";\n    return;\n    \n}\n\nint main(){\n\n    string s1, s2; cin >> s1 >> s2;\n    tree *T1 = create();\n    tree *T2 = create();\n    tree *T3 = create();    \n    make_tree(T1, s1);\n    make_tree(T2, s2);\n    sum_tree(T1->root, T2->root, T3->root); \n    print_tree(T3->root);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n \nclass bitree;\nint ite;\nstring str;\n \nvoid error();\nbitree *kaiseki();\nbitree *add(bitree*,bitree*);\n \nclass bitree\n{\npublic:\n\tunsigned int data;\n\tbitree *left;\n\tbitree *right;\npublic:\n\tbitree():data(0),left(NULL),right(NULL){}\n\tbitree(unsigned int dt):data(dt),left(NULL),right(NULL){}\n\t~bitree()\n\t{\n\t\tif(left != NULL)\n\t\t\tdelete left;\n\t\tif(right != NULL)\n\t\t\tdelete right;\n\t}\n\tstring str()\n\t{\n\t\tstring ret;\n\t\tchar integer[5] = \"\";\n\t\tret += \"(\";\n\t\tif(left != NULL)\n\t\t\tret += left->str();\n\t\tret += \")\";\n\t\tret += \"[\";\n\t\tsprintf(integer,\"%u\",data);\n\t\tret += integer;\n\t\tret += \"]\";\n\t\tret += \"(\";\n\t\tif(right != NULL)\n\t\t\tret += right->str();\n\t\tret += \")\";\n\t\treturn ret;\n\t}\n\tbitree operator+(bitree a)\n\t{\n\t\tbitree ret;\n\t\tret = *add(this,&a);\n\t\treturn ret;\n\t}\n};\n \nvoid error()\n{\n\tcout << \"Error\" << endl;\n\texit(EXIT_FAILURE);\n}\n \nbitree *kaiseki()\n{\n\tbitree *ret = new bitree();\n\tif(str[ite] == ')'){\n\t\treturn NULL;\n\t}\n\tif(str[ite] != '(')\n\t\terror();\n\tite++;\n\tret->left = kaiseki();\n\tif(str[ite] != ')')\n\t\terror();\n\tite++;\n\tif(str[ite] != '[')\n\t\terror();\n\tite++;\n\tsscanf((str.substr(ite,4)).c_str(),\"%u\",&ret->data);\n\twhile(str[ite] >= '0' && str[ite] <= '9')\n\t\tite++;\n\tif(str[ite] != ']')\n\t\terror();\n\tite++;\n\tif(str[ite] != '(')\n\t\terror();\n\tite++;\n\tret->right = kaiseki();\n\tif(str[ite] != ')')\n\t\terror();\n\tite++;\n\treturn ret;\n}\n \nbitree *add(bitree *a,bitree *b)\n{\n\tif(a == NULL || b == NULL)\n\t\treturn NULL;\n\tbitree *ret = new bitree(a->data + b->data);\n\tret->left = add(a->left,b->left);\n\tret->right = add(a->right,b->right);\n\treturn ret;\n}\n \nint main()\n{\n\tstring sa,sb;\n\tcin >> sa;\n\tcin >> sb;\n\tite = 0;\n\tstr = sa;\n\tbitree *A = kaiseki();\n\tite = 0;\n\tstr = sb;\n\tbitree *B = kaiseki();\n\tcout << add(A,B)->str() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring a,b,c,d;\nint i=0,j=0,k=0,l=0,x,y;\nvoid reada(){\n  if(i>=a.size()) return;\n  c=\"\";\n  while(i<a.size()&&a[i]!='['){\n    if(a[i]=='(') k++;\n    if(a[i]==')') k--;\n    c+=a[i];\n    i++;\n  }\n  i++;x=0;\n  if(i>=a.size()) return;\n  while(a[i]!=']') x=x*10+a[i]-'0',i++;\n  i++;\n}\nvoid readb(){\n  if(j>=b.size()) return;\n  d=\"\";\n  while(j<b.size()&&b[j]!='['){\n    if(b[j]=='(') l++;\n    if(b[j]==')') l--;     \n    d+=b[j];\n    j++;\n  }\n  j++;y=0;\n  if(j>=b.size()) return;\n  while(b[j]!=']') y=y*10+b[j]-'0',j++;\n  j++;\n}\n\nint main(){\n  cin>>a>>b;\n  while(1){\n    reada();\n    if(i>=a.size()){\n      cout << c << endl;\n      break;\n    }\n    readb();\n    if(j>=b.size()){\n      cout << d << endl;\n      break;\n    }\n    if(k>l){\n      while(k>l) reada();\n      if(i>=a.size()){\n\tcout << d << endl;\n\tbreak;\n      }\n      cout << d << \"[\" << x+y << \"]\";\n    }else{\n      while(k<l) readb();\n      if(j>=b.size()){\n\tcout << c << endl;\n\tbreak;\n      }\n      cout << c << \"[\" << x+y << \"]\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;//if(l+1>=r+1){cout<<1<<endl;exit(0);}\n  for(int i=l+1;i<=r-1;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c);\n  if(r-1!=c+1)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size());\n  n=1;node p2=con(0,a[1].size());\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_, *right;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin == End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin; *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto *at = CreateTree(a.begin(), a.end()), *bt = CreateTree(b.begin(), b.end());\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n#define vec vector<int>\n\nconst int SIZE=10000000;\n\nvec Aar(SIZE,-1);\nvec Bar(SIZE,-1);\nvec Xar(SIZE,-1);\n\n\nvoid input(vec & ar,const string & str,int & i,int k)\n{\n    if(str[i]=='(')\n    {\n        ++i;\n        input(ar,str,i,2*k+1);\n    }\n    if(str[i]==')')\n    {\n        ++i;\n        input(ar,str,i,(k-1)/2);\n        return;\n    }\n    if(str[i]=='[')\n    {\n        ++i;\n        int n=0;\n        while(str[i]!=']')\n        {\n            n*=10;\n            n+=(int)(str[i]-'0');\n            ++i;\n        }\n        ++i;\n        ar[k] = n;\n    }\n    if(str[i]=='(')\n    {\n        ++i;\n        input(ar,str,i,2*k+2);\n    }\n    if(str[i]==')')\n    {\n        ++i;\n        input(ar,str,i,(k-1)/2);\n        return;\n    }\n}\n\nvoid output(int k)\n{\n    if(Xar[k]==-1)return;\n\n    cout << \"(\";\n    output(2*k+1);\n    cout << \")\";\n\n    cout << \"[\" << Xar[k] << \"]\";\n\n    cout << \"(\";\n    output(2*k+2);\n    cout << \")\";\n}\n\nint main()\n{\n    string A,B;\n    cin >> A >> B;\n    int si=0;\n    input(Aar,A,si,0);\n    si = 0;\n    input(Bar,B,si,0); \n\n    for(int i=0;i<SIZE;++i)\n    {\n        if(Aar[i]>=0 && Bar[i]>=0)\n        {\n            Xar[i]=Aar[i]+Bar[i];\n        }\n    }\n\n    output(0);\n\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\ttree t;\n\t\t\tt.num = 0;\n\t\t\tt.left = -1;\n\t\t\tt.right = -1;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 3), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\ttree t;\n\tt.num = 0;\n\tt.left = -1;\n\tt.right = -1;\n\tvt3.push_back(t);\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//木を実装する\ntypedef struct _node{\n    int element;\n    struct _node *left;\n    struct _node *right;\n    struct _node *par;\n}node;\n\ntypedef struct _tree{\n    node *root;\n}tree;\n\n//リストを生成する関数\ntree *create(){\n    tree *T = (tree *)malloc(sizeof(tree));\n    T->root = (node *)malloc(sizeof(node));\n    T->root->left = NULL;\n    T->root->right = NULL;\n    T->root->par = NULL;\n    T->root->element = -1;\n    return T;\n}\n\nvoid make_tree(tree *T, string s){\n    node *ptr = T->root;\n\n    for(int i = 0; i < (int) s.size(); i++){\n\n        if(s[i] == '('){\n            //どっちかににノードを足す\n            node *add = (node *)malloc(sizeof(node));\n            add->element = -1;\n            add->left = NULL;\n            add->right = NULL;\n            add->par = ptr;\n\n            //左\n            if(ptr->left == NULL){\n                ptr->left = add;\n                ptr = add;\n            }else{\n                ptr->right = add;\n                ptr = add;\n            }\n        }else if(s[i] == ')'){\n            //戻る\n            ptr = ptr->par;\n        }else if(s[i] == '['){\n            string str;\n            int j;\n            for(j = i + 1; s[j] != ']'; j++) str.push_back(s[j]);\n            int num = stoi(str);\n            ptr->element = num;\n            i = j;\n        }\n    }\n}\n\nvoid print_tree(node *v){\n    if(v == NULL || v->element == -1){\n        cout << \")\";\n        return;\n    }\n\n    cout << \"(\";\n    print_tree(v->left);\n    cout << \"[\" << v->element << \"]\";\n    cout << \"(\";\n    print_tree(v->right);\n    if(v->par != NULL) cout << \")\";\n    return;\n}\n\nvoid sum_tree(node *v1, node *v2, node *v3){\n    v3->element = v1->element + v2->element;\n\n    if(v1->left != NULL && v2->left != NULL && v1->left->element != -1 && v2->left->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->left = add;\n        sum_tree(v1->left, v2->left, v3->left);\n    }\n    \n    if(v1->right != NULL && v2->right != NULL && v1->right->element != -1 && v2->right->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->right = add;        \n        sum_tree(v1->right, v2->right, v3->right);\n    }\n    \n    //if(v->par != NULL) cout << \")\";\n    return;\n    \n}\n\nint main(){\n\n    string s1, s2; cin >> s1 >> s2;\n    tree *T1 = create();\n    tree *T2 = create();\n    tree *T3 = create();    \n    make_tree(T1, s1);\n    make_tree(T2, s2);\n    sum_tree(T1->root, T2->root, T3->root);\n    print_tree(T1->root);\n    cout << endl;\n    print_tree(T2->root);\n    cout << endl;    \n    print_tree(T3->root);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n \nusing namespace std;\n \nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \nint main() {\n \n  string a, b; cin >> a >> b;\n  int n = a.size(), m = b.size();\n  int da = 0, db = 0;\n  int ia = 0, ib = 0;\n  while(ia < n) {\n    da += (a[ia] == '(') - (a[ia] == ')');\n    db += (b[ib] == '(') - (b[ib] == ')');\n    while(da < db) {\n      ib ++;\n      db += (b[ib] == '(') - (b[ib] == ')');\n    }\n    while(da > db) {\n      ia ++;\n      da += (a[ia] == '(') - (a[ia] == ')');\n    }\n    cout << a[ia];\n    if(a[ia] == '[') {\n      assert(b[ib] == '[');\n      ia ++, ib ++;\n      int size_a = a.find(']', ia) - ia;\n      int size_b = b.find(']', ib) - ib;\n      cout << stoi(a.substr(ia, size_a)) + stoi(b.substr(ib, size_b));\n      ia += size_a, ib += size_b;\n      cout << ']';\n    }\n    ia ++, ib ++;\n  }\n  cout << endl;\n \n  assert(ia == n && ib == m);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;\n  for(int i=l+1;i<r-1;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c);\n  if(r-1!=c+1)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(-1,a[0].size()+1);\n  n=1;node p2=con(-1,a[1].size()+1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n \nint const INF = 1<<29;\n \nstruct tree; typedef tree* tree_ptr;\n \nstruct tree {\n  tree_ptr lch, rch;\n  int num;\n  tree()\n    : lch(NULL), rch(NULL), num(-INF) { }\n};\n \nvoid consume(string& S, char expected) {\n  if(S[0] == expected) {\n    S = S.substr(1);\n    return;\n  }\n  cout << S << \", \" << expected << endl;\n  assert(0);\n}\n \nbool consume_if(string& S, char expected) {\n  if(S[0] == expected) {\n    consume(S, expected);\n    return true;\n  }\n  else {\n    return false;\n  }\n}\n \nint read_num(string& S) {\n  stringstream ss(S);\n  int x; ss >> x;\n  ss >> S;\n  return x;\n}\n \nvoid make_tree(string& S, tree_ptr curr) {\n  if(consume_if(S, '(')) {\n    tree_ptr lch = new(tree);\n    curr->lch = lch;\n    make_tree(S, lch);\n    consume(S, ')');\n    \n    consume(S, '[');\n    curr->num = read_num(S);\n    consume(S, ']');\n    \n    consume(S, '(');\n    tree_ptr rch = new(tree);\n    curr->rch = rch;\n    make_tree(S, rch);\n    consume(S, ')');\n    return;\n  }\n}\n \nvoid dfs(tree* ptr1, tree* ptr2) {\n  if(ptr1->num == -INF || ptr2->num == -INF) { return; }\n  \n  if(ptr1->lch && ptr2->lch) {\n    cout << \"(\";\n    dfs(ptr1->lch, ptr2->lch);\n    cout << \")\";\n  }\n  cout << \"[\" << (ptr1->num + ptr2->num) << \"]\";\n  if(ptr1->rch && ptr2->rch) {\n    cout << \"(\";\n    dfs(ptr1->rch, ptr2->rch);\n    cout << \")\";\n  }\n}\n \nint main() {\n \n  string a; cin >> a;\n  string b; cin >> b;\n  \n  tree_ptr atree = new(tree);\n  tree_ptr btree = new(tree);\n  \n  make_tree(a, atree);\n  make_tree(b, btree);\n \n  dfs(atree, btree);\n  cout << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nstd::string A, B;\n \nvoid calcSum(int&, int&);\nvoid throughTree(int&, std::string&);\nint64_t calcNum(int&, std::string&);\n \nint main()\n{\n    std::cin >> A >> B;\n    int a_i{}, b_i{};\n    calcSum(a_i, b_i);\n    putchar('\\n');\n \n    return 0;\n}\n \nvoid calcSum(int& a_i, int& b_i)\n{\n    a_i++; b_i++;\n    putchar('(');\n    if (A[a_i] != ')' && B[b_i] != ')')\n        calcSum(a_i, b_i);\n    else if (A[a_i] != ')')\n        throughTree(a_i, A);\n    else if (B[b_i] != ')')\n        throughTree(b_i, B);\n    a_i++; b_i++;\n    putchar(')');\n \n    putchar('[');\n    std::cout << std::to_string(calcNum(a_i, A) + calcNum(b_i, B));\n    putchar(']');\n \n    a_i++; b_i++;\n    putchar('(');\n    if (A[a_i] != ')' && B[b_i] != ')')\n        calcSum(a_i, b_i);\n    else if (A[a_i] != ')')\n        throughTree(a_i, A);\n    else if (B[b_i] != ')')\n        throughTree(b_i, B);\n    a_i++; b_i++;\n    putchar(')');\n \n    return;\n}\n \nvoid throughTree(int& s_i, std::string& str)\n{\n    if (str[s_i] == ')') return;\n    s_i++;\n    throughTree(s_i, str);\n    s_i++;\n \n    calcNum(s_i, str);\n \n    s_i++;\n    throughTree(s_i, str);\n    s_i++;\n \n    return;\n}\n \nint64_t calcNum(int& s_i, std::string& str)\n{\n    s_i++;\n    int64_t ret{};\n    while (str[s_i] != ']')\n    {\n        ret = 10 * ret + str[s_i] - '0';\n        s_i++;\n    }\n    s_i++;\n    return ret;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstring a,b;\nint placeA,placeB;\n\nvoid dfs(){\n\tDBG(cout << \"START DFS \" << placeA << ' ' << placeB << endl;);\n\tcout << '(';\n\tint num = 0;\n\tint tmp;\n\tif(a[placeA+1] == '(' && b[placeB+1] == '('){\n\t\tDBG(cout << \"HIDARI DFS\" << endl;);\n\t\tplaceA++;\n\t\tplaceB++;\n\t\tdfs();\n\t}\n\telse{\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(a[placeA] == '(')tmp++;\n\t\t\tif(a[placeA] == ')')tmp--;\n\t\t\tplaceA++;\n\t\t}while(tmp != 0);\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(b[placeB] == '(')tmp++;\n\t\t\tif(b[placeB] == ')')tmp--;\n\t\t\tplaceB++;\n\t\t}while(tmp != 0);\n\t}\n\twhile(!isdigit(a[placeA]))placeA++;\n\twhile(!isdigit(b[placeB]))placeB++;\n\tcout << \")[\";\n\ttmp = 0;\n\n\twhile(isdigit(a[placeA])){\n\t\ttmp *= 10;\n\t\ttmp += a[placeA] - '0';\n\t\tplaceA++;\n\t}\n\tnum += tmp;\n\tDBG(cout << \"A is \" << tmp << endl;);\n\ttmp = 0;\n\twhile(isdigit(b[placeB])){\n\t\ttmp *= 10;\n\t\ttmp += b[placeB] - '0';\n\t\tplaceB++;\n\t}\n\tnum += tmp;\n\tDBG(cout << \"B is \" << tmp << endl;);\n\tDBG(cout << \"num is \";)cout << num <<  \"](\";\n\tplaceA++;\n\tplaceB++;\n\t\n\tif(a[placeA+1] == '(' && b[placeB+1] == '('){\n\t\tDBG(cout << \"MIGI DFS\" << endl;);\n\t\tplaceA++;\n\t\tplaceB++;\n\t\tdfs();\n\t}\n\telse{\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(a[placeA] == '(')tmp++;\n\t\t\tif(a[placeA] == ')')tmp--;\n\t\t\tplaceA++;\n\t\t}while(tmp != 0);\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(b[placeB] == '(')tmp++;\n\t\t\tif(b[placeB] == ')')tmp--;\n\t\t\tplaceB++;\n\t\t}while(tmp != 0);\n\t}\n\tDBG(cout << \"END DFS \" << a[placeA] << ' ' << b[placeB] << endl;);\n\tcout << \")\";\n}\n\nint main()\n{\n\tcin >> a >> b;\n\tdfs();\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nstruct node {\n    int val;\n    node *l, *r;\n    explicit node(int x) : val(x), l(nullptr), r(nullptr) {};\n};\nusing state = string::const_iterator;\n\nnode* getnode (state &cur){\n    node* ans = nullptr;\n    if(*cur == '('){\n        ans = new node(0);\n        cur++;\n        ans->l = getnode(cur);\n        cur++;\n        cur++;\n        while(isdigit(*cur)){\n            ans->val = (ans->val)*10 + *cur - '0';\n            cur++;\n        }\n        cur++;\n        cur++;\n        ans->r = getnode(cur);\n        cur++;\n    }\n    return ans;\n}\n\nvoid printnode(node* A, node* B){\n    printf(\"(\");\n    if(A->l != nullptr && B->l != nullptr){\n        printnode(A->l, B->l);\n    }\n    printf(\")[\");\n    printf(\"%d\", A->val+B->val);\n    printf(\"](\");\n    if(A->r != nullptr && B->r != nullptr){\n        printnode(A->r, B->r);\n    }\n    printf(\")\");\n}\n\nint main() {\n    string s, t;\n    cin >> s >> t;\n    state a = s.begin(), b = t.begin();\n    auto A = getnode(a), B = getnode(b);\n    printnode(A, B);\n    puts(\"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring s1,s2;ll kasai[2000000],isao[2000000],jcreation[2000000];\nbool visited[2000000],visited2[2000000];\n\nvoid dfs(int now,int cnt){\n  visited[cnt]=true;\n  if(now==s1.size()){\n    return;\n  }\n  if(s1[now]=='('){\n    if(visited[cnt*2+1])\n      dfs(now+1,(cnt*2)+2);\n    else\n      dfs(now+1,(cnt*2)+1);\n  }else if(s1[now]==')'){\n    dfs(now+1,(cnt-1)/2);\n  }else{\n    now++;\n    ll num=0;\n    while(s1[now]>='0'&&s1[now]<='9'){\n      num*=10;\n      num+=s1[now]-'0';\n      now++;\n    }\n    kasai[cnt]=num;\n    dfs(now+1,cnt);\n  }\n}\nvoid dfs2(int now,int cnt){\n  visited2[cnt]=true;\n  if(now==s2.size()){\n    return;\n  }\n  if(s2[now]=='('){\n    if(visited2[cnt*2+1])\n      dfs2(now+1,(cnt*2)+2);\n    else\n      dfs2(now+1,(cnt*2)+1);\n  }else if(s2[now]==')'){\n    dfs2(now+1,(cnt-1)/2);\n  }else{\n    now++;\n    ll num=0;\n    while(s2[now]>='0'&&s2[now]<='9'){\n      num*=10;\n      num+=s2[now]-'0';\n      now++;\n    }\n    isao[cnt]=num;\n    dfs2(now+1,cnt);\n  }\n}\nstring Stoi(int num){\n  string s=\"\";\n  while(num>0){\n    s+=(char)((num%10)+'0');\n    num/=10;\n  }\n  reverse(s.begin(),s.end());\n  return s;\n}\nstring dfs3(int now){\n  string ret=\"\";\n  if(jcreation[now]==-1)return ret;\n  ret=\"(\"+dfs3(2*now+1)+\")[\"+Stoi(jcreation[now])+\"](\"+dfs3(2*now+2)+\")\";\n  return ret;\n}\nint main(){\n  for(int i=0;i<2000000;i++){\n    kasai[i]=-1;\n    isao[i]=-1;\n    jcreation[i]=-1;\n  }\n  cin>>s1>>s2;\n  dfs(0,0);\n  dfs2(0,0);\n  for(int i=0;i<2000000;i++){\n    // cout<<i<<\" \"<<kasai[i]<<\" \"<<isao[i]<<endl;\n    if(isao[i]>=0&&kasai[i]>=0){\n      (jcreation[i]=isao[i]+kasai[i]);\n    }\n  }\n  cout<<dfs3(0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nclass node\n{\n\tpublic:\n\tint parent=-1;//親のindex\n\tint left=-1;\n\tint right=-1;//右側の子のindex\n\tint num;//書いてある数字\n\tint depth;\n\tnode(int n,int d)\n\t{\n\t\tdepth=d;\n\t\tnum=n;\n\t}\n};\n\nint aparentid;\nint bparentid;\n\nvector<node> decode(string s,int mode)\n{\n\tvector<node> ret;\n\tint predepth=-1;\n\tint now=1;//現在の深さ\n\t//それぞれのノードの深さと数字だけ求める\n\tfor(int i=0;i<s.size();i++)\n\t{\n\t\tif(s[i]=='(')\n\t\t\tnow++;\n\t\telse if(s[i]==')')\n\t\t\tnow--;\n\t\telse{\n\t\t\ti++;\n\t\t\tint num=0;\n\t\t\twhile(s[i]!=']')\n\t\t\t{\n\t\t\t\tnum*=10;\n\t\t\t\tnum+=(int)(s[i]-'0');\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tret.push_back(node(num,now));\n\t\t\tif(now==1)\n\t\t\t{\n\t\t\t\tif(mode==0)\n\t\t\t\t\taparentid=ret.size()-1;\n\t\t\t\telse\n\t\t\t\t\tbparentid=ret.size()-1;\n\t\t\t}\n\t\t}\n\t}\n\t//深さ情報から木を復元する\n\tfor(int i=0;i<ret.size();i++)\n\t{\n\t\tint dp=ret[i].depth;\n\t\tif(dp==1)\n\t\t\tcontinue;\n\t\t//親を探す\n\t\t//両向きに探して近いほうが答え\n\t\tint lind=i;\n\t\tint rind=i;\n\t\twhile(ret[lind].depth!=dp-1)\n\t\t{\n\t\t\tlind--;\n\t\t\tif(lind==-1 || ret[lind].depth<dp-1)\n\t\t\t{\n\t\t\t\tlind=-10000;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(ret[rind].depth!=dp-1)\n\t\t{\n\t\t\trind++;\n\t\t\tif(rind==ret.size() || ret[rind].depth<dp-1)\n\t\t\t{\n\t\t\t\trind=50000;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i-lind<rind-i)\n\t\t{\n\t\t\tret[lind].right=i;\n\t\t\tret[i].parent=lind;\n\t\t}else{\n\t\t\tret[rind].left=i;\n\t\t\tret[i].parent=rind;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<node> ans;\n//2つの木を結合する\nvoid ketu(vector<node> a,vector<node> b,int anow,int bnow,int oya)\n{\n\t//cerr<<a[anow].num<<\" \"<<b[bnow].num<<endl;\n\tbool f;\n\t//aの情報からどっち向きの子かを調べる\n\tif(oya!=-1)\n\t{\n\t\tif(anow==a[a[anow].parent].left)\n\t\t\tf=true;\n\t\telse\n\t\t\tf=false;\n\t}\n\t//aの現在地とbの現在地をマージする\n\tans.push_back(node(a[anow].num+b[bnow].num,a[anow].depth));\n\tint now=ans.size()-1;//現在のノード番号\n\tif(oya!=-1)\n\t{\n\t\tans[now].parent=oya;\n\t\t//左の子\n\t\tif(f)\n\t\t{\n\t\t\tans[oya].left=now;\n\t\t}else{//右の子\n\t\t\tans[oya].right=now;\n\t\t}\n\t}\n\t//継続判定\n\tif(a[anow].left!=-1 && b[bnow].left!=-1)\n\t\tketu(a,b,a[anow].left,b[bnow].left,now);\n\tif(a[anow].right!=-1 && b[bnow].right!=-1)\n\t\tketu(a,b,a[anow].right,b[bnow].right,now);\n\treturn;\n}\n\nstring encode(vector<node> a,int now)\n{\n\tstring ret;\n\tret+='(';\n\tif(a[now].left!=-1)\n\t\tret+=encode(a,a[now].left);//左側\n\tret+=\")[\";\n\tret+=to_string(a[now].num);//数字を文字列にして加える\n\tret+=\"](\";\n\tif(a[now].right!=-1)\n\t\tret+=encode(a,a[now].right);//右側\n\tret+=')';\n\treturn ret;\n}\n\nint main()\n{\n\tstring a,b;\n\tcin>>a;\n\tcin>>b;\n\tvector<node> atree;\n\tvector<node> btree;\n\tatree=decode(a,0);\n\tbtree=decode(b,1);\n\t//デコード結果を結合する\n\tketu(atree,btree,aparentid,bparentid,-1);\n\t//cerr<<atree.size()<<\" \"<<btree.size()<<\" \"<<ans.size()<<endl;\n\tcout<<encode(ans,0)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tstring s,t;\n\tcin>>s>>t;\n\tint c1=0,c2=0;\n\twhile(c1!=s.size()){\n\t\tif(isdigit(s[c1])){\n\t\t\tint a=0,b=0;\n\t\t\twhile(isdigit(s[c1])){\n\t\t\t\ta*=10;a+=s[c1]-'0';\n\t\t\t\tc1++;\n\t\t\t}\n\t\t\twhile(isdigit(t[c2])){\n\t\t\t\tb*=10;b+=t[c2]-'0';\n\t\t\t\tc2++;\n\t\t\t}\n\t\t\tcout<<a+b;\n\t\t}else if(s[c1]==t[c2]){\n\t\t\tcout<<s[c1];\n\t\t\tc1++;c2++;\n\t\t}else if(s[c1]=='('){\n\t\t\tint co=0;\n\t\t\tint cnt=0;\n\t\t\twhile(cnt!=4){\n\t\t\t\tif(isdigit(s[c1])){\n\t\t\t\t\tc1++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(s[c1]=='(')co++;\n\t\t\t\telse if(s[c1]==')')co--;\n\t\t\t\tif(co==0)cnt++;\n\t\t\t\tc1++;\n\t\t\t}\n\t\t}else{\n\t\t\tint co=0;\n\t\t\tint cnt=0;\n\t\t\twhile(cnt!=4){\n\t\t\t\tif(isdigit(t[c2])){\n\t\t\t\t\tc2++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(t[c2]=='(')co++;\n\t\t\t\telse if(t[c2]==')')co--;\n\t\t\t\tif(co==0)cnt++;\n\t\t\t\tc2++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nvoid solve(string s, long long par, map<long long,int>& m) {\n\tint cnt = 0;\n\tint l = 1, r = 0;\n\tfor (int i = 1; i < s.size() - 1; i++) {\n\t\tif (s[i] == '(')cnt++;\n\t\telse if (s[i] == ')')cnt--;\n\n\t\tif (cnt == 0) {\n\t\t\tr = i;\n\t\t\tstring next = s.substr(l, r - l + 1);\n\n\t\t\tif (l == 1) {\n\t\t\t\tsolve(next, par * 2 + 1, m);\n\n\t\t\t\ti += 2;\n\n\t\t\t\tint l2 = i;\n\t\t\t\twhile (1) {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (s[i] == ']') {\n\t\t\t\t\t\tm[par] = stoi(s.substr(l2, i - l2).data());\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tl = r = i;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsolve(next, par * 2 + 2,m);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstring solve2(map<long long, int>& m , long long par) {\n\tstring s1, s2, s3;\n\n\tif (m.find(par) != m.end()) {\n\t\ts2 = to_string(m[par]);\n\t}\n\telse return \"\";\n\n\ts1 = solve2(m, par * 2 + 1);\n\ts3 = solve2(m, par * 2 + 2);\n\n\treturn \"(\" + s1 + \")\" + \"[\" + s2 + \"]\" + \"(\" + s3 + \")\";\n}\n\nint main()\n{\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\n\ts1.insert(s1.begin(), '(');\n\ts1.push_back(')');\n\ts2.insert(s2.begin(), '(');\n\ts2.push_back(')');\n\n\tmap<long long, int>a, b;\n\n\n\tsolve(s1, 0, a);\n\tsolve(s2, 0, b);\n\t\n\tmap<long long, int>c;\n\n\tfor (auto itr = a.begin(); itr != a.end(); itr++) {\n\t\tlong long p = itr->first;\n\t\tauto itr2 = b.find(p);\n\t\tif (itr2 != b.end()) {\n\t\t\tc[p] = itr->second + itr2->second;\n\t\t}\n\t}\n\n\tcout << solve2(c, 0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst long double PI = acos(-1);\nconstexpr long double EPS = 1e-15;\nconstexpr int inf = 2e9;\nconstexpr ll INF = 2e18;\nconstexpr ll MOD = 1e9+7;\nconstexpr ll MOD1 = 998244353;\ntypedef pair<ll,ll> P;\n\n//#define all(v) (v).begin(), (v).end()\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) rep(i,0,n)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n//#define mp make_pair\n\nstruct Tree{\n  int num = 0;\n  Tree *left;\n  Tree *right;\n  Tree() {\n    num = 0;\n    left = NULL;\n    right = NULL;\n  }\n  Tree(Tree *l,int m,Tree *r) {\n    num = m;\n    left = l;\n    right = r;\n  }\n};\n\n// void findroot(string s, int &k) {\n//   int cnt = 1;\n//   for (int i = 1; i < sz(s); i++) {\n//     if (s[i] == '(') cnt++;\n//     else if (s[i] == ')') cnt--;\n\n//     if (cnt == 0) {\n//       i+=2;\n//       int num = 0;\n//       while ('0' <= s[i] && s[i] <= '9') {\n//         num *= 10;\n//         num += (s[i] - '0');\n//         i++;\n//       }\n//       k = num;\n//       return;\n//     }\n//   }\n// }\n\nint k;\nTree *maketree(Tree *t, string s) {\n  Tree *tmp = new Tree();\n\n  int middle = 0;\n  k++;\n  if (s[k] == ')') ;\n  else tmp->left = maketree(t, s);\n  k += 2;\n\n  while ('0' <= s[k] && s[k] <= '9') {\n    middle *= 10;\n    middle += (s[k] - '0');\n    k++;\n  }\n  \n  k+=2;\n  if (s[k] == ')') ;\n  else tmp->right = maketree(t, s);\n  k++;\n\n  tmp->num = middle;\n  return tmp;\n}\n\nvoid dfs(Tree *t1, Tree *t2) {\n  cout << '(';\n  if (t1->left != NULL && t2->left != NULL) {\n    dfs(t1->left, t2->left);\n  }\n  cout << ')';\n  cout << '[';\n  cout << t1->num + t2->num;\n  cout << ']';\n  cout << '(';\n  if (t1->right != NULL && t2->right != NULL) {\n    dfs(t1->right, t2->right);\n  }\n  cout << ')';\n}\n\nvoid solve() {\n  string a,b;\n  int r1,r2;\n  cin >> a >> b;\n  Tree *t1 = new Tree();\n  Tree *t2 = new Tree();\n  k = 0;\n  t1 = maketree(t1,a);\n  k = 0;\n  t2 = maketree(t2,b);\n  dfs(t1,t2);\n  cout << endl;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  REP(i,n) {\n    solve();\n  }\n//  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\n\tnode.emplace_back(Node());\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\n\tnode.emplace_back(Node());\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tstring ans = merge(x,0,y,0);\n\tshow(ans)\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef struct Treenode\n{\n\tbool left = false;\n\tbool right = false;\n\tpair<Treenode*, Treenode*> child;\n\tint num = INT_MAX / 6;\n};\n \nTreenode* saiki( string S ) {\n\t//cout << S << endl;\n\tint num = 0;\n\tint xx = 0;\n\tint parentnum = 0;\n\tint s = -1;\n\tint count = 0;\n\tTreenode *reta = new Treenode;\n\tfor( size_t i = 0; i < S.length(); i++ ) {\n\t\tif( S[i] == '(' ) {\n\t\t\tnum++;\n\t\t\tif( s == -1 ) {\n\t\t\t\ts = i;\n\t\t\t}\n\t\t} else if( S[i] == ')' ) {\n\t\t\tnum--;\n\t\t\tif( num == 0 ) {\n\t\t\t\tif( count == 0 ) {\n\t\t\t\t\tif( i - s > 1 ) {\n\t\t\t\t\t\t(*reta).child.first = saiki( S.substr( s + 1, i - s - 1 ) );\n\t\t\t\t\t\tif( (*(*reta).child.first).num != INT_MAX / 6 ) {\n\t\t\t\t\t\t\t(*reta).left = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t\t} else {\n\t\t\t\t\tif( i - s > 1 ) {\n\t\t\t\t\t\t(*reta).child.second = saiki( S.substr( s + 1, i - s - 1 ) );\n\t\t\t\t\t\tif( (*(*reta).child.second).num != INT_MAX / 6 ) {\n\t\t\t\t\t\t\t(*reta).right = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts = -1;\n\t\t\t}\n\t\t} else if( S[i] == '[' ) {\n\t\t\txx = 0;\n\t\t} else if( S[i] == ']' ) {\n\t\t\tif( num == 0 ) {\n\t\t\t\t(*reta).num = xx;\n\t\t\t}\n\t\t} else {\n\t\t\txx *= 10;\n\t\t\txx += S[i] - '0';\n\t\t}\n\t}\n\treturn reta;\n}\n \nTreenode* saiki2( Treenode* A, Treenode* B ) {\n\tTreenode* retc = new Treenode;\n\t(*retc).num = (*A).num + (*B).num;\n \n\tif( (*A).left && (*B).left ) {\n\t\t(*retc).left = true;\n\t\t(*retc).child.first = saiki2( (*A).child.first, (*B).child.first );\n\t}\n\tif( (*A).right && (*B).right ) {\n\t\t(*retc).right = true;\n\t\t(*retc).child.second = saiki2( (*A).child.second, (*B).child.second );\n\t}\n\treturn retc;\n \n}\n \nstring saiki3( Treenode* C ) {\n\tstring ret = \"\";\n\tif( (*C).left ) {\n\t\tret += '(' + saiki3( (*C).child.first ) + ')';\n\t} else {\n\t\tret += \"()\";\n\t}\n\tret += '[' + to_string( (*C).num ) + ']';\n\tif( (*C).right ) {\n\t\tret += '(' + saiki3( (*C).child.second ) + ')';\n\t} else {\n\t\tret += \"()\";\n\t}\n\treturn ret;\n \n}\n \nint main() {\n\tstring A, B;\n\tcin >> A >> B;\n\tTreenode* Atree = saiki( A );\n\tTreenode* Btree = saiki( B );\n\tTreenode* Ctree = saiki2( Atree, Btree );\n\tcout << saiki3( Ctree ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\nstruct Tree {\n\tTree* left, * right;\n\tint val;\n};\n\nint num(const string&, int&);\nTree* t(const string&, int&);\n\nTree* t(const string& s, int& i) {\n\tif (s[i] == ')')return NULL;\n\n\tTree* res = new Tree;\n\ti++;\n\tres->left = t(s, i);\n\ti++;\n\n\tassert(s[i] == '[');\n\ti++;\n\tres->val = num(s, i);\n\ti++;\n\n\ti++;\n\tres->right = t(s, i);\n\ti++;\n\treturn res;\n}\nint num(const string& s, int& i) {\n\tint res = 0;\n\twhile (s[i] != ']') {\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\t++i;\n\t}\n\treturn res;\n}\n\nTree* merge(Tree* a, Tree* b) {\n\tTree* res = new Tree;\n\tres->left = NULL;\n\tres->right = NULL;\n\tres->val = a->val + b->val;\n\tif (a->left != NULL && b->left != NULL)res->left = merge(a->left, b->left);\n\n\tif (a->right != NULL && b->right != NULL)res->right = merge(a->right, b->right);\n\treturn res;\n}\n\nstring to_string(Tree* a) {\n\tif (a == NULL)return \"\";\n\treturn \"(\" + to_string(a->left) + \")\" + \"[\" + to_string(a->val) + \"]\" + \"(\" + to_string(a->right) + \")\";\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring a, b;\n\tcin >> a >> b;\n\tint pos = 0;\n\tauto ta = t(a, pos);\n\tpos = 0;\n\tauto tb = t(b, pos);\n\tauto ans = merge(ta, tb);\n\tcout << to_string(ans) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Tree;\n\ntypedef shared_ptr<Tree> P;\n\nstruct Tree{\n  Tree(P l,P r,int n){\n    lef=l;\n    rig=r;\n    num=n;\n  }\n  P lef;\n  P rig;\n  int num=-1;\n};\n\nint get_num(int& i,string& s){\n  int prei=i;\n  while(isdigit(s[i])) i++;\n  int res=stoi(s.substr(prei,i-prei));\n  return res;\n}\n\nP build_tree(int& i,string &s){\n  if(s[i]==')'){\n\n    P _lef(nullptr);\n    P _rig(nullptr);\n    int _num=-1;\n    P res(new Tree(_lef,_rig,_num));\n\n    return res;\n  }\n  else{\n    i++;\n    P _lef(build_tree(i,s));\n    i+=2;\n    int _num=get_num(i,s);\n\n    i+=2;\n    P _rig(build_tree(i,s));\n    i++;\n    P res(new Tree(_lef,_rig,_num));\n    return res;\n  }\n}\n\nP sum_t(P a_t,P b_t){\n  if((a_t->num)==-1 || (b_t->num)==-1){\n    P _lef(nullptr);\n    P _rig(nullptr);\n    int _num=-1;\n    P res(new Tree(_lef,_rig,_num));\n    return res;\n  }\n  else{\n    P _lef=sum_t(a_t->lef,b_t->lef);\n    P _rig=sum_t(a_t->rig,b_t->rig);\n    int _num=(a_t->num)+(b_t->num);\n    P res(new Tree(_lef,_rig,_num));\n    return res;\n  }\n}\n\nstring coder(P t){\n  if((t->num)==-1){\n    return \"\";\n  }\n  string s=\"[\"+to_string(t->num)+\"]\";\n  string lef=coder(t->lef);\n  string rig=coder(t->rig);\n  return \"(\"+lef+\")\"+s+\"(\"+rig+\")\";\n}\n\nint main(){\n  string a;\n  string b;\n  cin>>a>>b;\n  int i=0;\n  P a_t=build_tree(i,a);\n\n  i=0;\n  P b_t=build_tree(i,b);\n\n  P res_t=sum_t(a_t,b_t);\n  string res=coder(res_t);\n\n\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n#define rrep(i, a, b) for (auto i = (a); i > (b); --i)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\n#ifdef LOCAL_DEFINE\nstruct InitInput\n{\n  InitInput()\n  {\n    FILE *stream1;\n    stream1 = freopen(\"in.txt\", \"r\", stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n} LOCAL_INPUT;\nstruct LOCAL_OUTPUT\n{\n  LOCAL_OUTPUT()\n  {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n} /*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showA(a, n)                                            \\\n  do                                                           \\\n  {                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)            \\\n      cerr << \"(\" << _i_t_e_ << \" = \" << (a)[_i_t_e_] << \") \"; \\\n    cerr << endl;                                              \\\n  } while (0)\n#define showA2(a, n, m)                                                                        \\\n  do                                                                                           \\\n  {                                                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)                                            \\\n    {                                                                                          \\\n      for (int _i_t_e_2 = 0; _i_t_e_2 < (m); _i_t_e_2++)                                       \\\n      {                                                                                        \\\n        cerr << \"(\" << _i_t_e_ << \", \" << _i_t_e_2 << \" = \" << (a)[_i_t_e_][_i_t_e_2] << \") \"; \\\n      }                                                                                        \\\n      cerr << endl;                                                                            \\\n    }                                                                                          \\\n    cerr << endl;                                                                              \\\n  } while (0)\n#else\n#define show(x)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim\n{\n  InitAim()\n  {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(12);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n} aim_cpo;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr const int INT_INF = 0x3f3f3f3f;       //1061109567\nconstexpr const ll LL_INF = 0x3f3f3f3f3f3f3f3f; //4557430888798830399\n\ntemplate <typename T>\nbool chmin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T>\nvoid ln(T i, T n) { cout << (i == n - 1 ? \"\\n\" : \" \"); }\ntemplate <typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1)\n{\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1)\n{\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++)\n  {\n    out << vector1[i];\n    if (i == vector1.size() - 1)\n      out << \"]\";\n    else\n      out << \", \";\n  }\n  return out;\n}\n\n// INT\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T>\nT LCM(T a, T b)\n{\n  return a / GCD(a, b) * b;\n}\ntemplate <typename T>\nT EXTGCD(T a, T b, T &x, T &y)\n{\n  T d = a;\n  if (b != 0)\n  {\n    d = EXTGCD(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n  else\n    x = 1, y = 0;\n  return d;\n}\ntemplate <typename T>\nbool is_prime(T a)\n{\n  for (int i = 2; i * i <= a; i++)\n    if (a % i == 0)\n      return true;\n  return false;\n}\ntemplate <typename T, typename S>\nT Pow(T a, S b)\n{\n  T res = 1, now = a;\n  while (b)\n  {\n    if (b & 1)\n      res *= now;\n    b >>= 1;\n    now *= now;\n  }\n  return res;\n}\n\n// MOD\nll MOD = 1000000000L + 7L;\n#define Madd(a, b) (((a) % MOD) + ((b) % MOD)) % MOD\n#define Mmul(a, b) (((a) % MOD) * ((b) % MOD)) % MOD\n#define Msub(a, b) (((a) % MOD) + MOD - ((b) % MOD)) % MOD\ntemplate <typename T, typename S>\nT ModPow(T a, S b)\n{\n  assert(b >= 0);\n  T res = 1, now = Msub(a, 0);\n  while (b)\n  {\n    if (b & 1)\n      res = Mmul(res, now);\n    b >>= 1;\n    now = Mmul(now, now);\n  }\n  return res;\n}\ntemplate <typename T>\nT ModInverse(T a, T mod, bool prime)\n{ // if mod is prime, \"prime\" is true.\n  if (prime)\n    return ModPow(a, mod - 2);\n  else\n  {\n    T x, y;\n    EXTGCD(a, mod, x, y);\n    return (mod + x % mod) % mod;\n  }\n}\ntemplate <typename T>\nT EulerTotient(T a)\n{\n  vector<pair<int, int>> v;\n  for (T i = 2; i * i <= a; i++)\n  {\n    int cnt = 0;\n    while (a % i == 0)\n    {\n      cnt++;\n      a /= i;\n    }\n    if (cnt != 0)\n      v.emplace_back(i, cnt);\n  }\n  if (a != 1)\n    v.emplace_back(a, 1);\n  //showV(v, (int) v.size());\n  T res = 1;\n  for (int i = 0; i < (int)v.size(); i++)\n  {\n    if (v[i].se == 1)\n    {\n      //res *= v[i].fi - 1;\n      res = Mmul(res, v[i].fi - 1);\n    }\n    else\n    {\n      //res *= Pow(v[i].fi, v[i].se) - Pow(v[i].fi, v[i].se - 1);\n      res = Mmul(res, Msub(ModPow(v[i].fi, v[i].se), ModPow(v[i].fi, v[i].se - 1)));\n    }\n  }\n  return res;\n}\n#define Mdivide(a, b) Mmul(((a) % MOD), (ModInverse((b), MOD, true))) % MOD\nll comb(ll a, ll b)\n{\n  chmin(b, a - b);\n  ll res = 1LL, now = a;\n  for (ll i = 1; i <= b; i++)\n  {\n    res = Mmul(res, now);  //res *= now;\n    res = Mdivide(res, i); // res /= i;\n    now--;\n  }\n  return res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\nclass BIT\n{\npublic:\n  BIT(int size)\n  {\n    BITTable.assign(++size, 0);\n  }\n  T sum(int k)\n  {\n    T res = 0;\n    for (++k; k > 0; k -= k & -k)\n    {\n      res += BITTable[k];\n    }\n    return res;\n  }\n  T sum(int l, int r)\n  {\n    if (l == 0)\n      return sum(r);\n    return sum(r) - sum(l - 1);\n  }\n  void update(int k, T x)\n  { // b[k] += x;\n    for (++k; k < (int)BITTable.size(); k += k & -k)\n      BITTable[k] += x;\n  }\n\nprivate:\n  vector<T> BITTable;\n};\n\ntemplate <typename T>\nclass IntervalTree\n{\n  using F = function<T(T, T)>;\n\npublic:\n  IntervalTree(int n, const F func, const T init) : func(func), init(init)\n  {\n    size = 1;\n    while ((int)size < n)\n      size <<= 1;\n    table.assign(2 * size, init);\n  }\n  void set(int k, T &x)\n  {\n    table[size + k] = x;\n  }\n  void build()\n  {\n    for (int i = size - 1; i >= 0; --i)\n    {\n      table[i] = func(table[i * 2], table[i * 2 + 1]);\n    }\n  }\n  void update(int k, const T &x)\n  {\n    k += size;\n    table[k] = x;\n    while (k >>= 1)\n    {\n      table[k] = func(table[k * 2], table[k * 2 + 1]);\n    }\n  }\n  T query(int a, int b)\n  {\n    T L = init, R = init;\n    for (a += size, b += size; a < b; a >>= 1, b >>= 1)\n    {\n      if (a & 1)\n        L = func(L, table[a++]);\n      if (b & 1)\n        R = func(table[--b], R);\n    }\n    return func(L, R);\n  }\n  T operator[](const int k) const\n  {\n    return table[k + size];\n  }\n\nprivate:\n  unsigned int size;\n  vector<T> table;\n  const F func;\n  const T init;\n};\n\nclass UnionFind\n{\npublic:\n  explicit UnionFind(int _n) : n(_n)\n  {\n    par.resize(static_cast<unsigned long>(_n));\n    rank.resize(static_cast<unsigned long>(_n));\n    sizes.resize(static_cast<unsigned long>(_n));\n    for (int i = 0; i < _n; i++)\n    {\n      par[i] = i;\n      rank[i] = 0;\n      sizes[i] = 1;\n    }\n  }\n  int find(int a)\n  {\n    if (par[a] == a)\n      return a;\n    return par[a] = find(par[a]);\n  }\n  bool same(int a, int b)\n  {\n    return find(a) == find(b);\n  }\n  void unite(int a, int b)\n  {\n    link(find(a), find(b));\n  }\n  int size(int a)\n  {\n    return sizes[find(a)];\n  }\n  void view()\n  {\n    for (int i = 0; i < n; i++)\n    {\n      cout << \" par\"\n           << \"[\" << i << \"]=\" << par[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    for (int i = 0; i < n; i++)\n    {\n      cout << \"size\"\n           << \"[\" << i << \"]=\" << sizes[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    cout << endl;\n  }\n\nprivate:\n  void link(int a, int b)\n  {\n    if (same(a, b))\n      return;\n    if (rank[a] > rank[b])\n    {\n      par[b] = a;\n      sizes[a] += sizes[b];\n      sizes[b] = 0;\n    }\n    else\n    {\n      par[a] = b;\n      if (rank[a] == rank[b])\n        rank[b]++;\n      sizes[b] += sizes[a];\n      sizes[a] = 0;\n    }\n  }\n  int n;\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sizes;\n};\n\nnamespace geo\n{\n#define IL inline\ntypedef double D;\ntypedef bool B;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\nostream &operator<<(ostream &out, const P &point1) // Pの出力\n{\n  out << '(' << point1.X << \", \" << point1.Y << ')';\n  return out;\n}\nB comp(const P &l, const P &r)\n{\n  return (l.X == r.X) ? l.Y < r.Y : l.X < r.X;\n}\ntypedef pair<P, P> L;  //line\ntypedef pair<P, P> LS; //line segment\ntypedef pair<P, D> C;  //circle\ntypedef vector<P> Poly;\nconst D EPS = 1e-8;\n//Decompotision Macro\n#define DCl(a, b, l) \\\n  P a, b;            \\\n  tie(a, b) = l\n#define DCc(a, b, c) \\\n  P a;               \\\n  D b;               \\\n  tie(a, b) = c\n\n//A dot B\nIL D dot(P a, P b) { return a.X * b.X + a.Y * b.Y; }\n//A cross B\nIL D cross(P a, P b) { return a.X * b.Y - a.Y * b.X; }\nIL D ccw(P a, P b, P c)\n{\n  return cross(b - a, c - a);\n}\n\nIL int sgn(P a, P b, P c)\n{\n  if (cross(b - a, c - a) > EPS)\n    return 1;\n  if (cross(b - a, c - a) < -EPS)\n    return -1;\n  if (dot(b - a, c - a) < -EPS)\n    return 2; // b-a-c\n  if (dot(a - b, c - b) < -EPS)\n    return -2; // a-b-c\n  return 0;\n}\nIL D signed_distance_P_L(P p, L l)\n{\n  DCl(a, b, l);\n  return ccw(a, b, p) / abs(b - a);\n}\n\nIL D distance_P_L(P p, L l) // 点と直線の距離\n{\n  return abs(signed_distance_P_L(p, l));\n}\n\nIL D distance_P_P(P p1, P p2) // 二点間距離\n{\n  return abs(p1 - p2);\n}\n\nIL D distance_P_LS(P p, LS ls) // 点と線分の距離\n{\n  DCl(a, b, ls);\n  if (dot(b - a, p - a) < EPS)\n    return abs(p - a);\n  if (dot(a - b, p - b) < EPS)\n    return abs(p - b);\n  return abs(cross(b - a, p - a)) / abs(b - a);\n}\n\nIL B is_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return abs(cross(a - b, c - d)) > EPS ||\n         abs(cross(a - b, d - b)) < EPS;\n}\nIL B is_L_LS(L l, LS ls)\n{\n  DCl(a, b, l);\n  DCl(c, d, ls);\n  return ccw(a, b, c) * ccw(a, b, d) < EPS;\n}\nIL B is_LS_LS(LS p, LS q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return sgn(a, b, c) * sgn(a, b, d) <= 0 && sgn(c, d, a) * sgn(c, d, b) <= 0;\n}\n\nIL D distance_LS_LS(LS p, LS q)\n{\n  if (is_LS_LS(p, q))\n    return 0;\n  return min({distance_P_LS(p.fi, q),\n              distance_P_LS(p.se, q),\n              distance_P_LS(q.fi, p),\n              distance_P_LS(q.se, p)});\n}\n\n//caution: have to use isintersected_L_L before this function\nIL P cross_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  D d1 = signed_distance_P_L(a, q);\n  D d2 = signed_distance_P_L(b, q);\n  return (a * d2 - b * d1) / (d2 - d1);\n}\n\nIL B is_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  return abs(rp - rq) - d < EPS &&\n         rp + rq - d > -EPS;\n}\nIL LS cross_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  D rc = (d * d + rp * rp - rq * rq) / (2 * d);\n  D rs = sqrt(rp * rp - rc * rc);\n  P diff = (cq - cp) / d;\n  return {cp + P(rc, rs) * diff, cp + P(rc, -rs) * diff};\n}\nIL Poly convex_hull(Poly p)\n{\n  int n = p.size();\n  Poly res(2 * n);\n  int k = 0, t;\n  sort(all(p), comp);\n  rep(i, 0, n)\n  {\n    while (k > 1 && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  t = k;\n  rep(j, 0, n - 1)\n  {\n    int i = n - 2 - j;\n    while (k > t && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  res.resize(k - 1);\n  return res;\n}\nIL B convex_in(Poly &l, P &p)\n{\n  int a = 0, b = l.size(), c;\n  D A, C;\n  P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n  while (b - a > 1)\n  {\n    c = (a + b) / 2;\n    A = cross(l[a] - g, p - l[a]);\n    C = cross(l[c] - g, p - l[c]);\n    if (cross(l[a] - g, l[c] - g) >= 0)\n    {\n      if (A > -EPS && C < -EPS)\n        b = c;\n      else\n        a = c;\n    }\n    else\n    {\n      if (C < -EPS || A > -EPS)\n        b = c;\n      else\n        a = c;\n    }\n  }\n  return (cross(l[b % l.size()] - l[a], p - l[b % l.size()]) > -EPS);\n}\n\n//not necessary?\nIL D convex_area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  rep(i, 2, n)\n      res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n  return res;\n}\nIL D area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  rep(i, 0, n)\n      res += cross(l[i], l[(i + 1) % n]);\n  return abs(res) / 2.0;\n}\ninline vector<L> tangent_line(C c, P p)\n{\n  vector<L> res;\n  DCc(cp, r, c);\n  P v = p - cp;\n  D dist = abs(v);\n  if (dist - r > -EPS)\n  {\n    double _cos = r / dist;\n    double _sin = sqrt(1.0 - _cos * _cos);\n    v = v * (r / dist);\n    {\n      P e = P(_cos * v.X - _sin * v.Y, _sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n    if (dist - r > EPS)\n    {\n      P e = P(_cos * v.X + _sin * v.Y, -_sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n  }\n  return res;\n}\nIL vector<L> inner_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  D dist = abs(Mp - Mq);\n  if (dist - (Rp + Rq) > -EPS)\n  {\n    P mid = (Mq * Rp + Mp * Rq) / (Rp + Rq);\n    res = tangent_line(p, mid);\n  }\n  return res;\n}\ninline vector<L> outer_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  P v = Mp - Mq;\n  D dist = abs(v);\n  if (dist - abs(Rp - Rq) > -EPS)\n  {\n    if (abs(Rp - Rq) < EPS)\n    {\n      P e = v * P(0, 1);\n      e = e / dist;\n      res.pb(L(Mp + e, Mq + e));\n      res.pb(L(Mp - e, Mq - e));\n    }\n    else\n    {\n      P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n      res = tangent_line(p, mid);\n    }\n  }\n  return res;\n}\n\nvector<Poly> decomposition(Poly p)\n{\n  int n = p.size();\n  vector<Poly> res;\n  while (n >= 3)\n  {\n    [&]() {\n      rep(i, 0, n)\n      {\n        P a = p[i];\n        P b = p[(i + 1) % n];\n        P c = p[(i + 2) % n];\n        if (ccw(a, b, c) < 0)\n          continue;\n        if ([&]() {\n              rep(j, 3, n)\n              {\n                P d = p[(i + j) % n];\n                if (ccw(a, b, d) > -EPS && ccw(b, c, d) > -EPS && ccw(c, a, d) > -EPS)\n                  return true;\n              }\n              return false;\n            }())\n          continue;\n        Poly nxt;\n        rep(j, 0, n) if ((i + j) % n != (i + 1) % n)\n            nxt.push_back(p[(i + j) % n]);\n        swap(p, nxt);\n        res.push_back({a, b, c});\n        n--;\n        return;\n      }\n    }();\n  }\n  return res;\n}\nint in_triangle(P p, Poly q)\n{\n  rep(i, 0, 3) if (abs(p - q[i]) < EPS) return 3; //on point\n  rep(i, 0, 3)\n  {\n    int s = sgn(q[i], q[(i + 1) % 3], p);\n    if (s != 1)\n    {\n      if (s == 0)\n        return 2; //on line\n      else\n        return 0; // not in\n    }\n  }\n  return 1; // inside triangle\n}\nint in_C(P q, C c) // 円での点の内外判定(円周上も判定)\n{\n  DCc(p, r, c);\n  if (abs(r - abs(p - q)) < EPS)\n    return 2; // 円周\n  return r - abs(p - q) > -EPS ? 1 : 0;\n}\nint is_triangle_C(Poly t, C c)\n{\n  t = convex_hull(t);\n  DCc(p, r, c);\n  int cnt = 0;\n  rep(i, 0, 3)\n      cnt += (in_C(t[i], c) > 0);\n  if (cnt == 3)\n    return 3; // t in c\n  if (cnt == 0)\n  {\n    double d = distance_P_LS(p, LS(t[2], t[0]));\n    rep(i, 0, 2)\n        d = min(d, distance_P_LS(p, LS(t[i], t[i + 1])));\n    if (r - d > EPS)\n      return 1; //intersect\n    if (in_triangle(p, t))\n      return 2; //c in t\n    else if (r - d < -EPS)\n      return 0; //not intersect\n  }\n  return 1; //intersect\n}\n\n//p must be convex and ccw\nLS diameter(Poly &p)\n{\n  int n = p.size();\n  int is = 0, js = 0;\n  rep(i, 0, n) if (p[i].Y > p[is].Y)\n      is = i;\n  rep(i, 0, n) if (p[i].Y < p[js].Y)\n      js = i;\n  LS res = {p[is], p[js]};\n  {\n    int i = is;\n    int j = js;\n    do\n    {\n      int ni = (i + 1) % n;\n      int nj = (j + 1) % n;\n      if (cross(p[ni] - p[i], p[nj] - p[j]) < EPS)\n        i = ni;\n      else\n        j = nj;\n      if (abs(res.fi - res.se) < abs(p[i] - p[j]))\n        res = LS(p[i], p[j]);\n    } while (i != is || j != js);\n  }\n  return res;\n}\n\nPoly cross_C_L(C c, L v)\n{\n  DCc(p, r, c);\n  DCl(a, b, v);\n  a -= p;\n  b -= p;\n  P u = a - b;\n  u = P(-u.Y, u.X);\n  P x = cross_L_L({a, b}, {P(0, 0), u});\n  D d = abs(x);\n  Poly res;\n  if (d - r > EPS)\n    return res;\n  D y = sqrt(r * r - d * d);\n  res.pb(p + x + (b - a) * y / abs(b - a));\n  //if(d-r>-EPS)return res;\n  res.pb(p + x + (a - b) * y / abs(b - a));\n  return res;\n}\n\npair<C, C> GetC_p_p_r(P p1, P p2, D r) // 二点と半径から２つの円を求める\n{\n  D d = distance_P_P(p1, p2);\n  assert(d <= 2. * r); // 二点間の距離は2 * r以内じゃないと同じ円周上に存在することはできない.\n  P mid = (p1 + p2) / 2.;\n  P NormalVector = (p1 - p2) / d * sqrt(r * r - d * d / 4.);\n  NormalVector = P(NormalVector.Y, -NormalVector.X);\n  P center1 = mid + NormalVector;\n  P center2 = mid - NormalVector;\n  return mp(C(center1, r), C(center2, r));\n}\n} // namespace geo\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n// 735134400 約数が1344個ある高度合成数(<= 1e9)\n// 897612484786617600 約数が103680個ある高度合成数(<= 1e18)\n// 苦手分野 重複順列\n// LLの数値をつかう時は最後にLLをつける癖をつけよう\n\nstring mul(string a)\n{\n  int n = (int)a.size();\n  string res = \"\";\n  bool up = false;\n  for (int i = n - 1; i >= 0; i--)\n  {\n    int tmp = (int)(a[i] - '0');\n    tmp *= 2;\n    if (up)\n      tmp++;\n    up = false;\n    string tmp2 = to_string(tmp);\n    res += tmp2[tmp2.size() - 1];\n    if (tmp2.size() > 1)\n      up = true;\n  }\n  if (up)\n    res += '1';\n  reverse(all(res));\n  return res;\n}\n\nstring add(string a) {\n  int n = (int)a.size();\n  string res = \"\";\n  bool up = true;\n  for (int i = n - 1; i >= 0; i--) {\n    if (!up) {\n      res += a[i];\n      continue;\n    }\n    int tmp = (int)(a[i] - '0');\n    tmp++;\n    string tmp2 = to_string(tmp);\n    res += tmp2[tmp2.size() - 1];\n    if (tmp2.size() > 1) up = true;\n    else up = false;\n  }\n  if (up) res += '1';\n  reverse(all(res));\n  return res;\n}\n\nmap<string, int> NumA, NumB;\n\nvoid parseA(string idx, string s)\n{\n  // show(s);\n  // show(idx);\n  int n = (int)s.size();\n  stack<char> st;\n  int res = 0;\n  int left = -1, right = -1;\n  for (int i = 0; i < n; i++)\n  {\n    if (s[i] == '(')\n      st.push('(');\n    else if (s[i] == ')')\n      st.pop();\n    else if (isdigit(s[i]) && st.empty())\n    {\n      res *= 10;\n      res += (int)(s[i] - '0');\n    }\n    else if (s[i] == '[' && st.empty() && i - 2 > 0)\n    {\n      left = i;\n      //parseA(idx * 2, s.substr(1, i - 2));\n    }\n    else if (s[i] == ']' && st.empty() && i + 2 < n - 1)\n    {\n      right = i;\n      //parseA(idx * 2 + 1, s.substr(i + 2, n - i - 3));\n      break;\n    }\n  }\n  // show(res);\n  if (left != -1)\n    parseA(mul(idx), s.substr(1, left - 2));\n  if (right != -1)\n    parseA(add(mul(idx)), s.substr(right + 2, n - right - 3));\n  NumA[idx] = res;\n}\n\nvoid parseB(string idx, string s)\n{\n  // show(s);\n  // show(idx);\n  int n = (int)s.size();\n  stack<char> st;\n  int res = 0;\n  for (int i = 0; i < n; i++)\n  {\n    if (s[i] == '(')\n      st.push('(');\n    else if (s[i] == ')')\n      st.pop();\n    else if (isdigit(s[i]) && st.empty())\n    {\n      res *= 10;\n      res += (int)(s[i] - '0');\n    }\n    else if (s[i] == '[' && st.empty() && i - 2 > 0)\n    {\n      parseB(mul(idx), s.substr(1, i - 2));\n    }\n    else if (s[i] == ']' && st.empty() && i + 2 < n - 1)\n    {\n      parseB(add(mul(idx)), s.substr(i + 2, n - i - 3));\n      break;\n    }\n  }\n  //show(idx);\n  NumB[idx] = res;\n}\n\nstring a, b;\nmap<string, int> NumS;\n\nstring construct(string idx)\n{\n  // show(idx);\n  if (NumS.count(idx) == 0)\n    return \"\";\n  return \"(\" + construct(mul(idx)) + \")[\" + to_string(NumS[idx]) + \"](\" + construct(add(mul(idx))) + \")\";\n}\n\nint main()\n{\n  cin >> a >> b;\n  parseA(\"1\", a);\n  //showA(NumA, 100);\n  parseB(\"1\", b);\n  //showA(NumA, 100);\n  //showA(NumB, 100);\n  for (auto ite = NumA.begin(); ite != NumA.end(); ite++) {\n    for (auto ite2 = NumB.begin(); ite2 != NumB.end(); ite2++) {\n      if (ite->fi == ite2->fi) {\n        NumS[ite->fi] = ite->se + ite2->se;\n      }\n    }\n  }\n  //showA(NumS, 100);\n  string ans = construct(\"1\");\n  cout << ans << endl;\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring A,B;\n\nstring rec(string S1,string S2){\n    if(S1==\"\" || S2==\"\") return \"\";\n    int c = 0;\n    int N1 = S1.size(),N2 = S2.size();\n    string left1,right1;\n    string num1;\n    for(int i=0;i<N1;i++){\n        if(S1[i]=='(') c++;\n        if(S1[i]==')') c--;\n        if(c==0){\n            left1 = S1.substr(1,i-1);\n            int id = i+2;\n            while(S1[id]!=']'){\n                num1 += S1[id];\n                id++;\n            }\n            break;\n        }\n    }\n    for(int i=N1-1;i>=0;i--){\n        if(S1[i]=='(') c++;\n        if(S1[i]==')') c--;\n        if(c==0){\n            right1 = S1.substr(i+1,N1-i-2);\n            break;\n        }\n    }\n    c = 0;\n    string left2,right2;\n    string num2;\n    for(int i=0;i<N2;i++){\n        if(S2[i]=='(') c++;\n        if(S2[i]==')') c--;\n        if(c==0){\n            left2 = S2.substr(1,i-1);\n            int id = i+2;\n            while(S2[id]!=']'){\n                num2 += S2[id];\n                id++;\n            }\n            break;\n        }\n    }\n    for(int i=N2-1;i>=0;i--){\n        if(S2[i]=='(') c++;\n        if(S2[i]==')') c--;\n        if(c==0){\n            right2 = S2.substr(i+1,N2-i-2);\n            break;\n        }\n    }\n    int n = stoi(num1)+stoi(num2);\n    string center = to_string(n);\n    return '(' + rec(left1,left2) + ')' + '[' + center + ']' + '(' + rec(right1,right2) + ')';\n}\n\nint main(){\n    cin >> A >> B;\n    cout << rec(A,B) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y,h;\n                                        \tpas(int x=0,int y=0,int h=0):x(x),y(y),h(h) {}\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            /*\n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\ntypedef struct node{\nnode* left;\n\tnode* right;\n\tint val;\n}node;\n \nnode* new_node(){\n\tnode *n=new node;\n\tn->left=NULL;\n\tn->right =NULL;\n\tn->val=0;\n\treturn n;\n \n}\nvoid make_node(node* v,string s){\n//\tcout<<s<<endl;\n\tint l=s.length();\n\tint it,cn=0;\n\tfor( it=0;it<l;it++){\n\t\tif(s[it]=='(')cn++;\n\t\tif(s[it]==')')cn--;\n\t\t\n\t\tif(cn==0 && s[it]=='[') break;\n\t}\n\tif(it!=2){\n\tstring s2=s.substr(1,it-2);\n\t\tnode* h=new_node();\n\t\tmake_node(h,s2);\n\tv->left=h;\n\t//\tcout<<s2<<endl;\n\t\t\n\t}\n\tint r=0;\n\tit++;\n\twhile(s[it]<='9' && s[it]>='0'){\n\t\tr*=10;\n\t\tr+= s[it]-'0';\n\t\tit++;\n\t}\n\t//cout<<r<<endl;\n\tv->val=r;\n\t\n\tstring s22=s.substr(it+1);\n\t//cout<<s22<<endl;\n\tif(s22.length()>2){\n\t\tint l2=s22.length();\n\t\tnode* hh=new_node();\n\t\tmake_node(hh,s22.substr(1,l2-2));\n\t\tv->right=hh;\n\t\t\n\t\t\n\t}\n\t\n}\n\nvoid cul(node* v3,node* v1,node* v2){\n\tv3->val=v1->val + v2->val;\n\t\n\tif(v1->left !=NULL && v2->left !=NULL ){\n\t\tnode* vl=new_node();\n\t\tcul(vl,v1->left,v2->left);\n\t\tv3->left=vl;\n\t}\n\tif(v1->right !=NULL && v2->right !=NULL ){\n\t\tnode* vl=new_node();\n\t\tcul(vl,v1->right,v2->right);\n\t\tv3->right =vl;\n\t}\n}\nsaiki(node* v){\n\tcout<<\"(\";\n\t\tif(v->left!=NULL)saiki(v->left);\n\t\tcout<<\")[\";\n\tcout<<v->val;\n\tcout<<\"](\";\n\t\tif(v->right!=NULL)saiki(v->right);\n\t\tcout<<\")\";\n}\n   signed main(){\n   \t\n   string s1,s2;\n   \tcin>>s1>>s2;\n   \t\n   \tnode* v1=new_node();\n   \tnode* v2=new_node();\n   \t\n   \tmake_node(v1,s1);\n   \tmake_node(v2,s2);\n   \t\n   \tnode* v3=new_node();\n   \tcul(v3,v1,v2);\n   \tsaiki(v3);\n   \tcout<<endl;\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\ttree t;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\ttree t;\n\tvt3.push_back(t);\n\t\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tif (vt.size() < no)\n\t\treturn \"\";\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\t//saiki2(0, 0,tree3);\n\t//cout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstring a,b;\nint placeA,placeB;\n\nvoid dfs(){\n\tDBG(cout << \"(START DFS \" << placeA << ' ' << placeB << \")\" << endl;);\n\tcout << '(';\n\tint num = 0;\n\tint tmp;\n\tif(a[placeA+1] == '(' && b[placeB+1] == '('){\n\t\tDBG(cout << \"IN DFS\" << endl;);\n\t\tplaceA++;\n\t\tplaceB++;\n\t\tdfs();\n\t}\n\telse{\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(a[placeA] == '(')tmp++;\n\t\t\tif(a[placeA] == ')')tmp--;\n\t\t\tplaceA++;\n\t\t}while(tmp > 0);\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(b[placeB] == '(')tmp++;\n\t\t\tif(b[placeB] == ')')tmp--;\n\t\t\tplaceB++;\n\t\t}while(tmp > 0);\n\t\tplaceA--;\n\t\tplaceB--;\n\t}\n\tDBG(cout << \"HOGE DFS \" << a[placeA] << ' ' << b[placeB] << endl;\n\tcout << \"place \" << placeA << ' ' << placeB << endl;);\n\tplaceA += 2;\n\tplaceB += 2;\n\tcout << \")[\";\n\ttmp = 0;\n\tDBG(cout << \"NUM DFS \" << a[placeA] << ' ' << b[placeB] << endl;);\n\n\twhile(isdigit(a[placeA])){\n\t\ttmp *= 10;\n\t\ttmp += a[placeA] - '0';\n\t\tplaceA++;\n\t}\n\tnum += tmp;\n\tDBG(cout << \"A is \" << tmp << endl;);\n\ttmp = 0;\n\twhile(isdigit(b[placeB])){\n\t\ttmp *= 10;\n\t\ttmp += b[placeB] - '0';\n\t\tplaceB++;\n\t}\n\tnum += tmp;\n\tDBG(cout << \"B is \" << tmp << endl;);\n\tDBG(cout << \"num is \";)cout << num <<  \"](\";\n\tplaceA++;\n\tplaceB++;\n\t\n\tif(a[placeA+1] == '(' && b[placeB+1] == '('){\n\t\tDBG(cout << \"IN DFS\" << endl;);\n\t\tplaceA++;\n\t\tplaceB++;\n\t\tdfs();\n\t}\n\telse{\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(a[placeA] == '(')tmp++;\n\t\t\tif(a[placeA] == ')')tmp--;\n\t\t\tplaceA++;\n\t\t}while(tmp > 0);\n\t\ttmp = 0;\n\t\tdo{\n\t\t\tif(b[placeB] == '(')tmp++;\n\t\t\tif(b[placeB] == ')')tmp--;\n\t\t\tplaceB++;\n\t\t}while(tmp > 0);\n\t}\n\tDBG(cout << \"END DFS \" << a[placeA] << ' ' << b[placeB] << endl;);\n\tcout << \")\";\n}\n\nint main()\n{\n\tcin >> a >> b;\n\tdfs();\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nstring A, B;\nint lIdx, rIdx;\n \nint get(string& s, int& idx)\n{\n  int num = 0;\n  while(isdigit(s[idx])) num = num * 10 + s[idx++] - '0';\n  return (num);\n}\n \nvoid dfs()\n{\n  bool left = A[lIdx] == '(';\n  bool right = B[rIdx] == '(';\n  bool mid = left & right;\n  if(!left & !right) return;\n  lIdx += left;\n  rIdx += right;\n  if(mid) cout << \"(\";\n  dfs();\n  if(mid) cout << \")\";\n  lIdx += left * 2;\n  rIdx += right * 2;\n  int value = get(A, lIdx) + get(B, rIdx);\n  if(mid) cout << \"[\" << value << \"]\";\n  lIdx += left * 2;\n  rIdx += right * 2;\n  if(mid) cout << \"(\";\n  dfs();\n  if(mid) cout << \")\";\n  lIdx += left;\n  rIdx += right;\n  if(lIdx == A.size() && rIdx == B.size()) cout << endl;\n}\n \nint main()\n{\n  cin >> A;\n  cin >> B;\n  dfs();\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin == End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End - 1;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin; Begin != End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end() , bb = b.begin(), be = b.end() ;\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\n\tnode.emplace_back(Node());\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tstring ans = merge(x,0,y,0);\n\tshow(ans)\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100000\nusing namespace std;\nint AT[N],BT[N];\n\nbool check(int s,int t, string &str){\n  stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')'&&st.empty())return 0;  \n    if(str[i]==')') st.pop();\n  }\n  return st.empty();\n}\n\nint get_num(string &str,int &idx){\n  int res=0;\n  while(isdigit(str[idx]))res=res*10+str[idx++]-'0';\n  return res;\n}\n\n\nint get_root(int s,int t,string &str){\n  \n   stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(st.empty()&&isdigit(str[i])) return i;\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')') st.pop();\n  }\n  assert(0);\n}\n\n\nvoid make_tree(int s,int t,int tree[N],string &str,int idx){\n  while(s<t&&check(s,t,str)) s++,t--;\n  if(s>=t)return;\n  s--,t++;\n\t\t\t  \n\n  int root=get_root(s,t,str);\n  if(root==-1)return;\n  //  cout <<idx<<\" \"<<root<<endl;\n  //for(int i=s;i<=t;i++) cout <<str[i];cout<<endl;\n  make_tree(s,root-2,tree,str,idx*2+1);\n  tree[idx]=get_num(str,root);\n  make_tree(root+1,t,tree,str,idx*2+2);\n}\n\nstring make_str(int k){\n  if(AT[k]<0||BT[k]<0) return \"\";\n  int num=AT[k]+BT[k];\n  string str;\n  while(num) str=(char)((num%10)+'0')+str,num/=10;\n  return \"(\"+make_str(k*2+1)+\")\"+\"[\"+str+\"]\"+\"(\"+make_str(k*2+2)+\")\";\n}\n\nint main(){\n  string A,B;\n  cin>>A>>B;\n  memset(AT,-1,sizeof(AT));\n  memset(BT,-1,sizeof(BT));\n  make_tree(0,A.size()-1,AT,A,0);\n  make_tree(0,B.size()-1,BT,B,0);\n  cout <<make_str(0)<<endl;  \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;if(r-l-1==1){cout<<1;exit(0);}\n  for(int i=l+1;i<r;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c-1);\n  if(r-1!=c)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size()-1);\n  n=1;node p2=con(0,a[1].size()-1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\n\nchar *p;\nusing pi = pair<int, int>;\nusing pn = pair<int, pi>;\n\n#define L second.first\n#define R second.second\n\nstring as, bs;\nvector<pn> A, B;\n\nint make(vector<pn>& G){\n    ++p;\n    int l,r;\n    if(*p == '('){\n        l = make(G);\n    } else{\n        l = -1;\n    }\n    ++p; ++p;\n    int v = 0;\n    for(; *p != ']';){\n        v = v*10+ *p - '0';\n        ++p;\n    }\n    ++p; ++p;\n    if(*p == '('){\n        r = make(G);\n    } else{\n        r = -1;\n    }\n    G.push_back(pn(v, pi(l,r)));\n    ++p;\n    return G.size()-1;\n}\n\nstring solve(int a, int b){\n    string r = \"(\";\n    if(A[a].L >= 0 && B[b].L >= 0){\n        r += solve(A[a].L, B[b].L);\n    }\n    r += \")[\"s + to_string(A[a].first + B[b].first) + \"](\";\n    if(A[a].R >= 0 && B[b].R >= 0){\n        r += solve(A[a].R, B[b].R);\n    }\n    r += \")\";\n    return r;\n}\n\nmain(){\n    cin >> as >> bs;\n    p = &as[0]; make(A);\n    p = &bs[0]; make(B);\n    auto ret = solve(A.size()-1, B.size()-1);\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n// #define USE_LLONG_AS_INT\n#ifdef USE_LLONG_AS_INT\n#define int long long\n#define inf (1ll<<60)\n#else\n#define inf (1<<30)\n#endif\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=(n)-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst string sp=\" \";\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nstruct node{\n    int n;\n    node *l,*r;\n};\n\nint i;\n\nnode *get_tree(string &s){\n    node *ret = new node();\n    ret->n=-1;\n    ret->l=NULL;\n    ret->r=NULL;\n    int l=-1;\n    while(i<s.length()){\n        if(s[i]=='('){\n            i++;\n            l++;\n            if(s[i]==')'){\n                i++;\n                continue;\n            }\n            (l?ret->r:ret->l)=get_tree(s);\n        }\n        else if(s[i]=='['){\n            i++;\n            ret->n=0;\n            while(s[i]!=']'){\n                ret->n*=10;\n                ret->n+=s[i]-'0';\n                i++;\n            }\n            i++;\n        }\n        else if(s[i]==')'){\n            i++;\n            return ret;\n        }\n    }\n    return ret;\n}\n\nnode *make_tree(node *t1,node *t2){\n    node *ret=new node();\n    ret->n=t1->n+t2->n;\n    if(t1->l!=NULL&&t2->l!=NULL)ret->l=make_tree(t1->l,t2->l);\n    if(t1->r!=NULL&&t2->r!=NULL)ret->r=make_tree(t1->r,t2->r);\n    return ret;\n}\n\nvoid print_tree(node *t){\n    cout<<'(';\n    if(t->l!=NULL)print_tree(t->l);\n    cout<<')';\n    cout<<'['<<t->n<<']';\n    cout<<'(';\n    if(t->r!=NULL)print_tree(t->r);\n    cout<<')';\n}\n    \nvoid run(){\n    string s1,s2;\n    cin>>s1>>s2;\n    node *t1=get_tree(s1);\n    i=0;\n    node *t2=get_tree(s2);\n    node *t3=make_tree(t1,t2);\n    print_tree(t3);\n    cout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\n\tnode.emplace_back(Node());\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n#define NUM 30000000\n\nusing namespace std;\n\nenum TYPE{\n\tNONE,\n\tFIRST,\n\tSECOND,\n\tLEFT,\n\tRIGHT\n};\n\nint* first,*second,*third;\nchar buf[1010];\n\nTYPE toWrite;\n\n//left_or_right???LEFT????????????????????¢?????¬??????2*parent_address+1,RIGHT??????parent_address+2\nvoid recursive(int left,int right,int parent_address,TYPE left_or_right){\n\tint calcDepth,nextRight,nextLeft,tmp,nextParentAddress = -1;\n\tif(parent_address != -1){\n\t\tcalcDepth = 0; //??????????????±???\n\t\tfor(int i = left,k=0; i <= right; i++){\n\n\t\t\tif(calcDepth==0 && buf[i] == '['){ //???\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextRight = i-1;\n\t\t\t\tnextLeft = k+1;\n\t\t\t\tbreak; //???????????????????????????????????±???0???1??????????????¨???????????????????????§break;\n\t\t\t}else if(calcDepth==0 && buf[i] == '(' && buf[i+1] >= '0' && buf[i+1] <= '9'){ //???<?????????>\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ')';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\t}\n\t\t}\n\n\t\tif(nextParentAddress != -1){\n\t\t\tif(left+1 < nextRight-1){\n\t\t\t\trecursive(left+1,nextRight-1,nextParentAddress,LEFT);\n\t\t\t}\n\t\t\tif(nextLeft+1 < right-1){\n\t\t\t\trecursive(nextLeft+1,right-1,nextParentAddress,RIGHT);\n\t\t\t}\n\t\t}\n\n\t}else{ //???????????´???\n\t\tcalcDepth = 0; //??¶???????????±???\n\t\tfor(int i = 0,k=0; i <= right; i++){\n\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\telse{\n\t\t\t\tif(calcDepth==0 && buf[i] == '['){ //????????????????????????\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\t\tfirst[0] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[0] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tnextRight = i-1;\n\t\t\t\t\tnextLeft = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(left+1 < nextRight-1){\n\t\t\trecursive(left+1,nextRight-1,0,LEFT);\n\t\t}\n\t\tif(nextLeft+1 < right-1){\n\t\t\trecursive(nextLeft+1,right-1,0,RIGHT);\n\t\t}\n\t}\n}\n\nvoid outPut(int address){\n\n\tif(third[2*address+1] != -1 || third[2*address+2] != -1){//??????????????´???\n\t\tif(third[2*address+1] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+1);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t\tprintf(\"[%d]\",third[address]);\n\t\tif(third[2*address+2] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+2);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t}else{ //?????????????????´???\n\t\tprintf(\"()[%d]()\",third[address]);\n\t}\n}\n\n\nint main(){\n\n\tfirst = new int[NUM];\n\tsecond = new int[NUM];\n\tthird = new int[NUM];\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tfirst[i] = -1;\n\t\tsecond[i] = -1;\n\t\tthird[i] = -1;\n\t}\n\n\tscanf(\"%s\",buf);\n\tint length;\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = FIRST;\n\trecursive(0,length-1,-1,NONE);\n\n\tscanf(\"%s\",buf);\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = SECOND;\n\trecursive(0,length-1,-1,NONE);\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(first[i] != -1 && second[i] != -1){\n\t\t\tthird[i] = first[i]+second[i];\n\t\t}else{\n\t\t\tthird[i] = -1;\n\t\t}\n\t}\n\n\toutPut(0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nvoid solve(string s, int par, vector<int>& vec) {\n\tint cnt = 0;\n\tint l = 1, r = 0;\n\tfor (int i = 1; i < s.size() - 1; i++) {\n\t\tif (s[i] == '(')cnt++;\n\t\telse if (s[i] == ')')cnt--;\n\n\t\tif (cnt == 0) {\n\t\t\tr = i;\n\t\t\tstring next = s.substr(l, r - l + 1);\n\n\t\t\tif (l == 1) {\n\t\t\t\tsolve(next, par * 2 + 1, vec);\n\n\t\t\t\ti += 2;\n\n\t\t\t\tint l2 = i;\n\t\t\t\twhile (1) {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (s[i] == ']') {\n\t\t\t\t\t\tvec[par] = stoi(s.substr(l2, i - l2).data());\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tl = r = i;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsolve(next, par * 2 + 2, vec);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstring solve2(vector<int>&ans, int par) {\n\tstring s1, s2, s3;\n\n\tif (ans[par] != -1) {\n\t\ts2 = to_string(ans[par]);\n\t}\n\telse return \"\";\n\n\ts1 = solve2(ans, par * 2 + 1);\n\ts3 = solve2(ans, par * 2 + 2);\n\n\treturn \"(\" + s1 + \")\" + \"[\" + s2 + \"]\" + \"(\" + s3 + \")\";\n}\n\nint main()\n{\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tvector<int>a(1000000,-1), b(1000000,-1);\n\n\ts1.insert(s1.begin(), '(');\n\ts1.push_back(')');\n\ts2.insert(s2.begin(), '(');\n\ts2.push_back(')');\n\n\tsolve(s1, 0, a);\n\tsolve(s2, 0, b);\n\n\tvector<int>c(1000000, -1);\n\tfor (int i = 0; i < 1000000; i++) {\n\t\tif (a[i] != -1 && b[i] != -1) {\n\t\t\tc[i] = a[i] + b[i];\n\t\t}\n\t}\n\n\tcout << solve2(c, 0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#ifdef _DEBUG_\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n#else\n#define dump(val)\n#endif\n\nusing namespace std;\n\ntypedef long long int ll;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nclass Node {\npublic:\n    Node *lf, *rt;\n    int num;\n    Node(Node *l, Node *r, int n)\n        : lf(l), rt(r), num(n) {}\n};\n\nint to_num(string &s, int &pos) {\n    int res = 0;\n    while (pos < s.size()) {\n        if (s[pos] < '0' || s[pos] > '9') break;\n        res = res * 10 + s[pos] - '0';\n        pos++;\n    }\n    return res;\n}\n\nNode *decode(string &s, int &pos) {\n    if (s.size() <= pos) {\n        return nullptr;\n    }\n    if (s[pos] == ')') {\n        pos++;\n        return nullptr;\n    }\n    if (s[pos] == '(') {\n        pos++;\n        auto lf = decode(s, pos);\n        pos++;\n        int num = to_num(s, pos);\n        pos++;\n        pos++;\n        auto rt = decode(s, pos);\n        pos++;\n        return new Node(lf, rt, num);\n    }\n    return nullptr;\n}\n\nNode *merge(Node *n1, Node *n2) {\n    if (n1 == nullptr or n2 == nullptr) {\n        return nullptr;\n    }\n    Node *lf = merge(n1->lf, n2->lf);\n    Node *rt = merge(n1->rt, n2->rt);\n    int num = n1->num + n2->num;\n    return new Node(lf, rt, num);\n}\n\n#include <sstream>\nstring to_str(int num) {\n    stringstream ss;\n    ss << num;\n    return ss.str();\n}\n\nstring encode(Node *node) {\n    if (node == nullptr) {\n        return \"\";\n    }\n    return \"(\" + encode(node->lf) + \")[\" + to_str(node->num) + \"](\" + encode(node->rt) + \")\";\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    string S, T;\n    cin >> S >> T;\n    Node *snode, *tnode;\n    {\n        int pos = 0;\n        snode = decode(S, pos);\n        pos = 0;\n        tnode = decode(T, pos);\n    }\n    Node *mer = merge(snode, tnode);\n    cout << encode(mer) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstring A, B;\nint lIdx, rIdx;\n\nint get(string& s, int& idx)\n{\n  int num = 0;\n  while(isdigit(s[idx])) num = num * 10 + s[idx++] - '0';\n  return (num);\n}\n\nvoid dfs()\n{\n  bool left = A[lIdx] == '(';\n  bool right = B[rIdx] == '(';\n  bool mid = left & right;\n  if(!left & !right) return;\n  lIdx += left;\n  rIdx += right;\n  if(mid) cout << \"(\";\n  dfs();\n  if(mid) cout << \")\";\n  lIdx += left * 2;\n  rIdx += right * 2;\n  int value = get(A, lIdx) + get(B, rIdx);\n  if(mid) cout << \"[\" << value << \"]\";\n  lIdx += left * 2;\n  rIdx += right * 2;\n  if(mid) cout << \"(\";\n  dfs();\n  if(mid) cout << \")\";\n  lIdx += left;\n  rIdx += right;\n  if(lIdx == A.size() && rIdx == B.size()) cout << endl;\n}\n\nint main()\n{\n  cin >> A;\n  cin >> B;\n  dfs();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nstring s[2];\nll t[3][10000000];\nbool f[10000000];\n\nstring solve(int k) {\n\tif (t[2][k] == -1)return \"\";\n\tstring res = \"(\" + solve(2 * k + 1) + \")\";\n\tres += (\"[\" + to_string(t[2][k]) + \"]\");\n\treturn res + \"(\" + solve(2 * k + 2) + \")\";\n}\n\nint main() {\n\trep(i, 3)fill(t[i], t[i] + 10000000, -1);\n\tcin >> s[0] >> s[1];\n\trep(i, 2) {\n\t\tll k = 0;\n\t\tll num = 0;\n\t\tfill(f, f + 10000000, 0);\n\t\trep(j, s[i].size()) {\n\t\t\tif (s[i][j] == '(')k = 2 * k + 1 + f[k];\n\t\t\telse if (s[i][j] == ')')k = (k - 1) / 2;\n\t\t\telse if (s[i][j] == ']') {\n\t\t\t\tf[k] = 1;\n\t\t\t\tt[i][k] = num;\n\t\t\t\tnum = 0;\n\t\t\t}\n\t\t\telse if (s[i][j] >= '0'&&s[i][j] <= '9') {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[i][j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 2) {\n\t\trep(j, 10000000) {\n\t\t\tif (t[0][j] != -1 && t[1][j] != -1) {\n\t\t\t\tt[2][j] = t[0][j] + t[1][j];\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, 20) {\n\t//\tcout << t[2][i] << \" \";\n\t//}\n\tcout << solve(0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n#define NUM 1000000\n\nusing namespace std;\n\nenum TYPE{\n\tNONE,\n\tFIRST,\n\tSECOND,\n\tLEFT,\n\tRIGHT\n};\n\nint* first,*second,*third;\nchar buf[1010];\n\nTYPE toWrite;\n\n//left_or_right???LEFT????????????????????¢?????¬??????2*parent_address+1,RIGHT??????parent_address+2\nvoid recursive(int left,int right,int parent_address,TYPE left_or_right){\n\tint calcDepth,nextRight,nextLeft,tmp,nextParentAddress = -1;\n\tif(parent_address != -1){\n\t\tcalcDepth = 0; //??????????????±???\n\t\tfor(int i = left,k=0; i <= right; i++){\n\n\t\t\tif(calcDepth==0 && buf[i] == '['){ //???\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextRight = i-1;\n\t\t\t\tnextLeft = k+1;\n\t\t\t\tbreak; //???????????????????????????????????±???0???1??????????????¨???????????????????????§break;\n\t\t\t}else if(calcDepth==0 && buf[i] == '(' && buf[i+1] >= '0' && buf[i+1] <= '9'){ //???<?????????>\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ')';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\t}\n\t\t}\n\n\t\tif(nextParentAddress != -1){\n\t\t\tif(left+1 < nextRight-1){\n\t\t\t\trecursive(left+1,nextRight-1,nextParentAddress,LEFT);\n\t\t\t}\n\t\t\tif(nextLeft+1 < right-1){\n\t\t\t\trecursive(nextLeft+1,right-1,nextParentAddress,RIGHT);\n\t\t\t}\n\t\t}\n\n\t}else{ //???????????´???\n\t\tcalcDepth = 0; //??¶???????????±???\n\t\tfor(int i = 0,k=0; i <= right; i++){\n\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\telse{\n\t\t\t\tif(calcDepth==0 && buf[i] == '['){ //????????????????????????\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\t\tfirst[0] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[0] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tnextRight = i-1;\n\t\t\t\t\tnextLeft = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(left+1 < nextRight-1){\n\t\t\trecursive(left+1,nextRight-1,0,LEFT);\n\t\t}\n\t\tif(nextLeft+1 < right-1){\n\t\t\trecursive(nextLeft+1,right-1,0,RIGHT);\n\t\t}\n\t}\n}\n\nvoid outPut(int address){\n\n\tif(third[2*address+1] != -1 || third[2*address+2] != -1){//??????????????´???\n\t\tif(third[2*address+1] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+1);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t\tprintf(\"[%d]\",third[address]);\n\t\tif(third[2*address+2] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+2);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t}else{ //?????????????????´???\n\t\tprintf(\"()[%d]()\",third[address]);\n\t}\n}\n\n\nint main(){\n\n\tfirst = new int[NUM];\n\tsecond = new int[NUM];\n\tthird = new int[NUM];\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tfirst[i] = -1;\n\t\tsecond[i] = -1;\n\t\tthird[i] = -1;\n\t}\n\n\tscanf(\"%s\",buf);\n\tint length;\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = FIRST;\n\trecursive(0,length-1,-1,NONE);\n\n\tscanf(\"%s\",buf);\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = SECOND;\n\trecursive(0,length-1,-1,NONE);\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(first[i] != -1 && second[i] != -1){\n\t\t\tthird[i] = first[i]+second[i];\n\t\t}else{\n\t\t\tthird[i] = -1;\n\t\t}\n\t}\n\n\toutPut(0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;if(r-l-1<=0){cout<<1;exit(0);}\n  for(int i=l+1;i<r;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c-1);\n  if(r-1!=c)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size()-1);\n  n=1;node p2=con(0,a[1].size()-1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstring A, B;\nint ai, bi;\n\nint nodeval(bool isA)\n{\n  int ret = 0;\n  if(isA) while(ai < A.size() && isdigit(A[ai])) ret = ret*10 + A[ai]-'0', ai++;\n  else while(bi < B.size() && isdigit(B[bi])) ret = ret*10 + B[bi]-'0', bi++;\n  return ret;\n}\n\nvoid parse()\n{\n  bool advA = (ai < A.size() && A[ai] == '(');\n  bool advB = (bi < B.size() && B[bi] == '(');\n  if(!advA && !advB) return;\n  if(advA) ai++; // (\n  if(advB) bi++; // (\n  if(advA && advB) cout << \"(\";\n  parse(); // left child\n  if(advA && advB) cout << \")\";\n  if(advA) ai+=2; // )[\n  if(advB) bi+=2; // )[\n  int aval = nodeval(true);\n  int bval = nodeval(false);\n  if(advA && advB) cout << \"[\" << aval+bval << \"]\";\n  if(advA) ai+=2; // ](\n  if(advB) bi+=2; // ](\n  if(advA && advB) cout << \"(\";\n  parse(); // right child\n  if(advA && advB) cout << \")\";\n  if(advA) ai++; // )\n  if(advB) bi++; // )\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> A >> B;\n  parse();\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct node{\n\tint val;\n\tnode *l,*r;\n};\nnode* parse(string S){\n\t// cout << S << endl;\n\tint nest = 0;\n\tint val = 0;\n\tint st = -1;\n\tint end = -1;\n\tfor(int i=0;i<S.size();i++){\n\t\tif(S[i]=='('){\n\t\t\tnest++;\n\t\t}else if(S[i]==')'){\n\t\t\tnest--;\n\t\t}\n\t\tif(nest==0&&S[i]=='['){\n\t\t\tst = i;\n\t\t}\n\t\tif(st!=-1&&'0'<=S[i]&&S[i]<='9'){\n\t\t\tval = val*10+(int)(S[i]-'0');\n\t\t}\n\t\tif(st!=-1&&S[i]==']'){\n\t\t\tend = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(st==-1){\n\t\treturn NULL;\n\t}\n\t//cout << st << ' ' << end << endl;\n\tnode* v = (node*)malloc(sizeof(node));\n\tv->val = val;\n\tv->l = parse(S.substr(1,st-2));\n\tv->r = parse(S.substr(end+2,S.size()-end-3));\n\treturn v; \n}\nnode* conv(node* a,node* b){\n\tnode* v = (node*)malloc(sizeof(node));\n\tv->val = (a->val)+(b->val);\n\tif((a->l)==NULL||(b->l)==NULL)v->l = NULL;\n\telse v->l = conv(a->l,b->l);\n\tif((a->r)==NULL||(b->r)==NULL)v->r = NULL;\n\telse v->r = conv(a->r,b->r);\n\treturn v;\n}\nvoid print(node* v){\n\tif(v==NULL){\n\t\tcout << \"\";\n\t\treturn;\n\t}\n\tcout << '(';\n\tprint(v->l);\n\tcout << ')';\n\tcout << '[' <<  v->val << ']';\n\tcout << '(';\n\tprint(v->r);\n\tcout << ')';\n\treturn;\n}\nstring s,t;\nint main(){\n\tcin >> s >> t;\n\tnode *a = parse(s);\n\tnode *b = parse(t);\n\tnode *c = conv(a,b);\n\tprint(c);\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <cmath>\n \nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned int;\n#define REP(i,n) for(ll i=0;i<(n); ++i)\n#define FOR(i,b,n) for(ll i=(b); i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define TEN(x) ((ll)1e##x)\n \nstruct node{\n\tnode * left = nullptr;\n\tnode * right = nullptr;\n\tint v;\n};\n \nll parse_int(int & index, string & s){\n\tstring si;\n\twhile ('0' <= s[index] && '9' >= s[index] ){\n\t\tsi.push_back(s[index]);\n\t\tindex++;\n\t}\n \n\treturn stoi(si);\n}\n \nnode * parse(int & index, string & s){\n\tif (s[index] == ')') return nullptr;\n\tauto current = new node;\n\tindex++; // (\n\tcurrent->left = parse(index, s);\n\tindex++; // )\n\tindex++; // [\n\tcurrent->v = parse_int(index, s);\n\tindex++; // ]\n\tindex++; // (\n\tcurrent->right = parse(index, s);\n\tindex++; // )\n \n\treturn current;\n}\n \nnode * bfs(node * a, node * b){\n\tnode * current = new node;\n\tif (a->left && b->left){\n\t\tcurrent->left = bfs(a->left, b->left);\n\t}\n\tif (a->right && b->right){\n\t\tcurrent->right = bfs(a->right, b->right);\n\t}\n\tcurrent->v = a->v + b->v;\n\treturn current;\n}\n \nstring output(node * current){\n\tif (!current) return \"\";\n\tstring s = \"(\";\n\ts += output(current->left);\n\ts += \")[\";\n\ts += to_string(current->v);\n\ts += \"](\";\n\ts += output(current->right);\n\ts += \")\";\n\treturn s;\n}\n \nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tstring A, B;\n\tcin >> A >> B;\n\tint indexa = 0, indexb = 0;\n\tauto a = parse(indexa, A);\n\tauto b = parse(indexb, B);\n\tauto c = bfs(a,b);\n\tcout << output(c) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct no{\n  no *l,*r;\n  int key;\n  no(){l=r=NULL;key=-1;};\n};\ntypedef no* node;\nstring s[2];\nnode h[2];\nint x,p;\nint get_num(){\n  int res=0;\n  while(p<s[x].size()&&isdigit(s[x][p]))res=res*10+(s[x][p++]-'0');\n  return res;\n}\nnode make_tree(){\n  node po=new no();\n  if(s[x][p]=='(')++p,po->l=make_tree();\n  if(s[x][p]=='[')p++;\n  if(isdigit(s[x][p]))po->key=get_num();\n  if(s[x][p]==']')p++;\n  if(p<s[x].size()&&s[x][p]=='(')++p,po->r=make_tree();\n  p++;\n  return po;\n}\nvoid ch(node n1,node n2,int p){\n  if(p)cout<<'(';\n  if(n1->l!=NULL&&n2->l!=NULL)ch(n1->l,n2->l,1);\n  if(n1->key>=0&&n2->key>=0)cout<<'['<<n1->key+n2->key<<']';\n  if(n1->r!=NULL&&n2->r!=NULL)ch(n1->r,n2->r,1);\n  if(p)cout<<')';\n}\nmain(){\n  r(i,2)cin>>s[i];\n  r(i,2)p=0,x=i,h[i]=make_tree();\n  ch(h[0],h[1],0);\n  cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct data{int num,l,r;};\nvector<data> At,Bt;\n\nbool check(int s,int t, string &str){\n  stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')'&&st.empty())return 0;  \n    if(str[i]==')') st.pop();\n  }\n  return st.empty();\n}\n\nint get_num(string &str,int &idx){\n  int res=0;\n  while(isdigit(str[idx]))res=res*10+str[idx++]-'0';\n  return res;\n}\n\n\nint get_root(int s,int t,string &str){\n  stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(st.empty()&&isdigit(str[i])) return i;\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')') st.pop();\n  }\n  assert(0);\n}\n\n\nvoid make_tree(int s,int t,vector<data>&tree,string &str,int idx){\n    while(s<t&&check(s,t,str)) s++,t--;\n  if(s>=t)return;\n  s--,t++;\n\n  int root=get_root(s,t,str);\n  tree.push_back((data){-1,-1,-1});\n  tree[idx].l=tree.size()-1;\n  make_tree(s,root-2,tree,str,tree.size()-1);\n\n  tree[idx].num=get_num(str,root);\n\n  tree.push_back((data){-1,-1,-1});\n  tree[idx].r=tree.size()-1;\n  make_tree(root+1,t,tree,str,tree.size()-1);\n}\n\nstring make_str(int a,int b){\n  if(a==-1||b==-1||At[a].num<0||Bt[b].num<0) return \"\";\n  int num=At[a].num+Bt[b].num;\n  string str;\n  if(num==0)str=\"0\";\n  while(num) str=(char)((num%10)+'0')+str,num/=10;\n\n  return \"(\"+make_str(At[a].l,Bt[b].l)+\")\"+\"[\"+str+\"]\"+\"(\"+make_str(At[a].r,Bt[b].r)+\")\";\n\n}\nint main(){\n  string A,B;\n  cin>>A>>B;\n  At.push_back((data){-1,-1,-1});\n  Bt.push_back((data){-1,-1,-1});\n  make_tree(0,A.size()-1,At,A,0);\n  make_tree(0,B.size()-1,Bt,B,0);\n  cout <<make_str(0,0)<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct node{\n\tint value;\n\tnode *left,*right;\n};\n\nnode* build(){\n\tif(getchar()==')')return NULL; //skip (\n\tnode *res = new node();\n\tif(res->left = build())getchar(); //skip )\n\tscanf(\"[%d](\",&res->value);\n\tif(res->right = build())getchar(); //skip )\n\treturn res;\n}\n\nnode* unite(node *a, node *b){\n\tif(a==NULL || b==NULL)return NULL;\n\tnode *res;\n\tres->value = a->value+b->value;\n\tres->left = unite(a->left, b->left);\n\tres->right = unite(a->right, b->right);\n\treturn res;\n}\n\nvoid output(node *n){\n\tif(n==NULL)return;\n\tprintf(\"(\");\n\toutput(n->left);\n\tprintf(\")[%d](\", n->value);\n\toutput(n->right);\n\tprintf(\")\");\n}\n\nint main(){\n\tnode *a = build();\n\tgetchar(); //skip \\n\n\tnode *b = build();\n\tgetchar(); //skip \\n\n\toutput(unite(a,b));\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid findNum(string &s,int a,int b,int &A,int &B){\n  int cnt=0;\n  for(int i=a;i<b;i++){\n    if(s[i]=='(')cnt++;\n    if(s[i]==')')cnt--;\n    if(cnt==0&&s[i]=='[')A=i;\n    if(cnt==0&&s[i]==']')B=i+1;\n  }\n}\n\nint getNum(string &s,int a,int b){\n  int num=0;\n  for(int i=a+1;i<b-1;i++)\n    num=num*10+(s[i]-'0');\n  return num;\n}\n\nvoid solve(string &s,string &t,int a,int b,int l,int r){\n  if(a==b||l==r)return;\n  int A,B,L,R;\n  findNum(s,a,b,A,B);\n  findNum(t,l,r,L,R);\n  int snum=getNum(s,A,B);\n  int tnum=getNum(t,L,R);\n  \n  cout<<'(';\n  solve(s,t,a+1,A-1,l+1,L-1);\n  cout<<')';\n    \n  cout<<'['<<snum+tnum<<']';\n\n  cout<<'(';\n  solve(s,t,B+1,b-1,R+1,r-1);\n  cout<<')';\n}\n\nint main(){\n  string s,t;\n  cin>>s>>t;\n  solve(s,t,0,s.size(),0,t.size());\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n#define NUM 5000000\n\nusing namespace std;\n\nenum TYPE{\n\tNONE,\n\tFIRST,\n\tSECOND,\n\tLEFT,\n\tRIGHT\n};\n\nint* first,*second,*third;\nchar buf[1010];\n\nTYPE toWrite;\n\n//left_or_right???LEFT????????????????????¢?????¬??????2*parent_address+1,RIGHT??????parent_address+2\nvoid recursive(int left,int right,int parent_address,TYPE left_or_right){\n\tint calcDepth,nextRight,nextLeft,tmp,nextParentAddress = -1;\n\tif(parent_address != -1){\n\t\tcalcDepth = 0; //??????????????±???\n\t\tfor(int i = left,k=0; i <= right; i++){\n\n\t\t\tif(calcDepth==0 && buf[i] == '['){ //???\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t\tnextParentAddress = 2*parent_address+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextRight = i-1;\n\t\t\t\tnextLeft = k+1;\n\t\t\t\tbreak; //???????????????????????????????????±???0???1??????????????¨???????????????????????§break;\n\t\t\t}else if(calcDepth==0 && buf[i] == '(' && buf[i+1] >= '0' && buf[i+1] <= '9'){ //???<?????????>\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(k = i+1; buf[k] != ')';k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[2*parent_address+1] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[2*parent_address+2] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\t}\n\t\t}\n\n\t\tif(nextParentAddress != -1){\n\t\t\tif(left+1 < nextRight-1){\n\t\t\t\trecursive(left+1,nextRight-1,nextParentAddress,LEFT);\n\t\t\t}\n\t\t\tif(nextLeft+1 < right-1){\n\t\t\t\trecursive(nextLeft+1,right-1,nextParentAddress,RIGHT);\n\t\t\t}\n\t\t}\n\n\t}else{ //???????????´???\n\t\tcalcDepth = 0; //??¶???????????±???\n\t\tfor(int i = 0,k=0; i <= right; i++){\n\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\telse{\n\t\t\t\tif(calcDepth==0 && buf[i] == '['){ //????????????????????????\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(k = i+1; buf[k] != ']';k++){\n\t\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\t\tfirst[0] = tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[0] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tnextRight = i-1;\n\t\t\t\t\tnextLeft = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(left+1 < nextRight-1){\n\t\t\trecursive(left+1,nextRight-1,0,LEFT);\n\t\t}\n\t\tif(nextLeft+1 < right-1){\n\t\t\trecursive(nextLeft+1,right-1,0,RIGHT);\n\t\t}\n\t}\n}\n\nvoid outPut(int address){\n\n\tif(third[2*address+1] != -1 || third[2*address+2] != -1){//??????????????´???\n\t\tif(third[2*address+1] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+1);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t\tprintf(\"[%d]\",third[address]);\n\t\tif(third[2*address+2] != -1){\n\t\t\tprintf(\"(\");\n\t\t\toutPut(2*address+2);\n\t\t\tprintf(\")\");\n\t\t}else{\n\t\t\tprintf(\"()\");\n\t\t}\n\t}else{ //?????????????????´???\n\t\tprintf(\"()[%d]()\",third[address]);\n\t}\n}\n\n\nint main(){\n\n\tfirst = new int[NUM];\n\tsecond = new int[NUM];\n\tthird = new int[NUM];\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tfirst[i] = -1;\n\t\tsecond[i] = -1;\n\t\tthird[i] = -1;\n\t}\n\n\tscanf(\"%s\",buf);\n\tint length;\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = FIRST;\n\trecursive(0,length-1,-1,NONE);\n\n\tscanf(\"%s\",buf);\n\tfor(length = 0; buf[length] != '\\0';length++);\n\ttoWrite = SECOND;\n\trecursive(0,length-1,-1,NONE);\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(first[i] != -1 && second[i] != -1){\n\t\t\tthird[i] = first[i]+second[i];\n\t\t}else{\n\t\t\tthird[i] = -1;\n\t\t}\n\t}\n\n\toutPut(0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define rep(i,m,n) for(int i = (m);i < (n);i++)\n#define P pair< pair<ll,ll> ,ll>\n#define pb push_back\n#define mk make_pair\nusing namespace std;\n#define Vec(a) vector <int> a\nconst int INF = 1 << 20;\nconst int MOD = 1e9+7;\n\nstring s1,s2;\nvector <P> p1;\nvector <P> p2;\nvector <P> p3;\n\nvoid dfs(ll now, ll count, ll depth){\n  //cout << \"count : \" <<  count << endl;\n  if(now >= s1.size()){\n    return;\n  }\n  if(s1[now] == '('){\n    dfs(now+1,(count)*2-1,depth+1);\n  }\n  else if(s1[now] == ')'){\n    dfs(now+1,(count+1)/2,depth-1);\n  }\n  else if(s1[now] == '['){\n    //cout << \"count : \" << count << endl;\n    ll n = 0;\n    now++;\n    while(s1[now] != ']'){\n      n = 10*n + (s1[now] - '0');\n      now++;\n    }\n    p1.pb(mk(mk(depth,count),n));\n    dfs(now+2,count*2,depth+1);\n  }\n  \n}\n\nvoid dfs2(ll now, ll count, ll depth){\n  //cout << \"count : \" <<  count << endl;\n  if(now >= s2.size()){\n    return;\n  }\n  if(s2[now] == '('){\n    dfs2(now+1,(count)*2-1,depth+1);\n  }\n  else if(s2[now] == ')'){\n    dfs2(now+1,(count+1)/2,depth-1);\n  }\n  else if(s2[now] == '['){\n    //cout << \"count : \" << count << endl;\n    ll n = 0;\n    now++;\n    while(s2[now] != ']'){\n      n = 10*n + (s2[now] - '0');\n      now++;\n    }\n    p2.pb(mk(mk(depth,count),n));\n    dfs2(now+2,count*2,depth+1);\n  }\n  \n}\n\nstring Stoi(ll s){\n  string n = \"\";\n  while(s > 0){\n    n += (s%10 + '0');\n    s /= 10;\n  }\n  reverse(n.begin(),n.end());\n  return n;\n}\n\nstring dfs3(pair <ll,ll> x){\n  ll num = -1;\n  REP(i,p3.size()){\n    if(p3[i].first == x){\n      num = i;\n      break;\n    }\n  }\n  \n  string r = \"\";\n  string l = \"\";\n  if(num == -1){\n    return r;\n  }\n  else{\n    x.first++;\n    x.second = x.second*2-1;\n    r = dfs3(x);\n    x.second++;\n    l = dfs3(x);\n  }\n  \n  string res = \"(\" + r + \")[\" + Stoi(p3[num].second) + \"](\" + l + \")\";\n  return res;\n\n}\n\n\nint main(){\n  cin >> s1;\n  cin >> s2;\n  dfs(0,1,0);\n  dfs2(0,1,0);\n  sort(p1.begin(),p1.end());\n  sort(p2.begin(),p2.end());\n  REP(i,p1.size()){\n     cout << p1[i].first.first << \"  \" << p1[i].first.second << \"  \" << p1[i].second << endl;\n  }\n   REP(i,p2.size()){\n     cout << p2[i].first.first << \"  \" << p2[i].first.second << \"  \" << p2[i].second << endl;\n  }\n   int x = 0;\n   REP(i,p1.size()){\n    rep(j,x,p2.size()){\n      if(p1[i].first == p2[j].first){\n\tp3.pb(mk(p1[i].first , p1[i].second + p2[j].second));\n\tx = j;\n\tbreak;\n      }\n      else if(p1[i].first < p2[j].first){\n\tx = j;\n\tbreak;\n      }\n    }\n   }\n   REP(i,p3.size()){\n     cout << p3[i].first.first << \"  \" << p3[i].first.second << \"  \" << p3[i].second << endl;\n   }\n   pair <ll,ll> p;\n   p.first = 0;\n   p.second = 1;\n   cout << dfs3(p) << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin >= End || Begin +1>=End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin; Begin != End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin()-1, be = b.end()-1;\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\ttree t;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\ttree t;\n\tvt3.push_back(t);\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tif (vt.size() < no)\n\t\treturn \"\";\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\t//saiki(s1,tree1);\n\t//saiki(s2,tree2);\n\t//saiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\n\n#define int long long\n\nint s2tree(string &A, vector<int> &na, vector<pair<int,int>> &a, int b, int e){\n\tint inb = 0, ine = 0, number = 0;\n\tint ca = 0;\n\t\n\tif(e - b <= 1) return -1;\n\t\n\tfor(int i = b, depth = 0; i < e; i++){\n\t\tif(A[i] == '(') {\n\t\t\tdepth++;\n\t\t} else if(A[i] == ')'){\n\t\t\tdepth--;\n\t\t}\n\t\t\n\t\tif(A[i] == '[' && !depth) {\n\t\t\tinb = i+1;\n\t\t}\n\t\t\n\t\tif(A[i] == ']' && !depth) {\n\t\t\tine = i;\n\t\t}\n\t}\n\t\n\tfor(int i = inb; i < ine; i++){\n\t\tnumber = number * 10 + A[i] - '0';\n\t}\n\t\n\tna.push_back(number);\n\ta.push_back(make_pair(-1,-1));\n\t\n\tca = (int)a.size()-1;\n\tint fa = s2tree(A, na, a, b + 1, inb-2);\n\t\n\tint sa = s2tree(A, na, a, ine + 2, e-1);\n\t\n\ta[ca].first  = fa;\n\ta[ca].second = sa;\n\t\n\treturn ca;\n}\n\nint synthesis(\nvector<pair<int,int> > &a, vector<pair<int,int> > &b, vector<pair<int,int> > &c, vector<int> &na, vector<int> &nb, vector<int> &nc, int ca = 0, int cb = 0){\n\tint cc;\n\t\n\tnc.push_back(na[ca] + nb[cb]);\n\tc.push_back(make_pair(-1,-1));\n\t\n\tcc = c.size()-1;\n\t\n\t\n\tif(a[ca].first != -1 && b[cb].first != -1) {\n\tint temp = synthesis(a, b, c, na, nb, nc, a[ca].first, b[cb].first);\n\t\tc[cc].first = temp;\n\t}\n\t\n\tif(a[ca].second != -1 && b[cb].second != -1) {\n\t\tint temp = synthesis(a, b, c, na, nb, nc, a[ca].second, b[cb].second);\n\t\tc[cc].second = temp;\n\t}\n\t\n\treturn cc;\n}\n\nstring tree2s(vector<int>& nc, vector<pair<int,int> > &c, int cc = 0){\n\tstring ra, rb, rc;\n\t\n\tif(cc == -1) return \"\";\n\t\n\tra = tree2s(nc, c, c[cc].first);\n\trc = tree2s(nc, c, c[cc].second);\n\t\n\treturn \"(\" + ra + \")\" + \"[\" + to_string(nc[cc]) + \"]\" + \"(\" + rc + \")\";\n}\nsigned main(){\n\tstring A, B, C;\n\tvector<int> na, nb, nc;\n\tvector<pair<int,int> > a, b, c;\n\t\n\tcin>>A>>B;\n\ts2tree(A, na, a, 0, A.size());\n\ts2tree(B, nb, b, 0, B.size());\n\tsynthesis(a, b, c, na, nb, nc);\n\tC = tree2s(nc, c);\n\t\n\tcout<<C<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nint tree(State&);\nint number(State&);\n\nPII t[2][100010], ans[100010];\nint idx;\nint heap1[100010], heap2[100010], heap[100010];\nint val[2][100010], val2[100010];\nint cnt;\n\nint tree(State &begin) {\n  if(*begin != '(') return -1;\n  begin++;\n  int left = tree(begin);\n  begin++;\n  begin++;\n  int res = number(begin);\n  begin++;\n  begin++;\n  int right = tree(begin);\n  begin++;\n  val[idx][cnt] = res;\n  t[idx][cnt++] = {left, right};\n  // cout << left << \" \" << cnt-1 << \" \" << res << \" \" << right << endl;\n  return cnt-1;\n}\n\nint number(State &begin) {\n  int res = 0;\n  while(isdigit(*begin)) {\n    res *= 10;\n    res += *begin - '0';\n    ++begin;\n  }\n  return res;\n}\n\nstring dfs(int num) {\n  if(num == -1) return \"\";\n  string ret = \"(\";\n  ret += (dfs(ans[num].first));\n  ret += (\")[\");\n  ret += (to_string(val2[num]));\n  ret += (\"](\");\n  ret += (dfs(ans[num].second));\n  ret += (\")\");\n  return ret;\n}\n\nint func(int a, int b) {\n  if(a == -1 || b == -1) return -1;\n  int left = func(t[0][a].first, t[1][b].first);\n  int right = func(t[0][a].second, t[1][b].second);\n  val2[cnt] = val[0][a] + val[1][b];\n  // cout << left << \" val2[\" << cnt << \"] = \" << val2[cnt] << \" \" << right << endl;\n  ans[cnt++] = {left, right};\n  return cnt-1;\n}\n\nsigned main(void)\n{\n  string s, tt;\n  cin >> s >> tt;\n  memset(val, -1, sizeof(val));\n  memset(heap1, -1, sizeof(heap1));\n  memset(heap2, -1, sizeof(heap2));\n  memset(heap, -1, sizeof(heap));\n  idx = 0, cnt = 0;\n  State begin = s.begin();\n  int root1 = tree(begin);\n  idx = 1, cnt = 0;\n  begin = tt.begin();\n  int root2 = tree(begin);\n\n  memset(val2, -1, sizeof(val2));\n  cnt = 0;\n  int tmp = func(root1, root2);\n\n  cout << dfs(tmp) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring a,b,c,d;\nint i=0,j=0,k=0,l=0,x,y;\nvoid reada(){\n  if(i>=a.size()) return;\n  c=\"\";\n  while(i<a.size()&&a[i]!='['){\n    if(a[i]=='(') k++;\n    if(a[i]==')') k--;\n    c+=a[i];\n    i++;\n  }\n  i++;x=0;\n  if(i>=a.size()) return;\n  while(a[i]!=']') x=x*10+a[i]-'0',i++;\n  i++;\n}\nvoid readb(){\n  if(j>=b.size()) return;\n  d=\"\";\n  while(j<b.size()&&b[j]!='['){\n    if(b[j]=='(') l++;\n    if(b[j]==')') l--;     \n    d+=b[j];\n    j++;\n  }\n  j++;y=0;\n  if(j>=b.size()) return;\n  while(b[j]!=']') y=y*10+b[j]-'0',j++;\n  j++;\n}\n\nint main(){\n  cin>>a>>b;\n  while(1){\n    reada();\n    if(i>=a.size()){\n      cout << d << endl;\n      break;\n    }\n    readb();\n    if(j>=b.size()){\n      cout << c << endl;\n      break;\n    }\n    if(k>l){\n      while(k>l) reada();\n      if(i>=a.size()){\n\tcout << d << endl;\n\tbreak;\n      }\n      cout << d << \"[\" << x+y << \"]\";\n    }else{\n      while(k<l) readb();\n      if(j>=b.size()){\n\tcout << c << endl;\n\tbreak;\n      }\n      cout << c << \"[\" << x+y << \"]\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    string s, t;\n    int l1, l2;\n    cin >> s >> t;\n\n    l1 = s.size();\n    l2 = t.size();\n\n    string ans;\n    int i = 0, j = 0;\n    while ( 1 ) {\n        if ( i >= l1 || j >= l2 ) break;\n        //cout << i << \" \" << j << endl;\n\n        if ( s[i] != t[j] || (isdigit(s[i]) && isdigit(t[j])) )  {\n            if ( isdigit(s[i]) && isdigit(t[j]) ) {\n                int a = 0;\n                int b = 0;\n                while ( isdigit(s[i]) ) {\n                    a *= 10;\n                    a += s[i]-'0';\n                    i++;\n                }\n                while ( isdigit(t[j]) ) {\n                    b *= 10;\n                    b += t[j]-'0';\n                    j++;\n                }\n                ans += (to_string(a+b));\n            } else {\n                if ( s[i] == ')' ) {\n                    j++;\n                    int l = 1;\n                    while ( l >= 0 ) {\n                        if ( t[j] == '(' ) l++;\n                        if ( t[j] == ')' ) l--;\n                        j++;\n                    }\n                    i++;\n                } else {\n                    i++;\n                    int l = 1;\n                    while ( l >= 0 ) {\n                        if ( s[i] == '(' ) l++;\n                        if ( s[i] == ')' ) l--;\n                        i++;\n                    }\n                    j++;\n                }\n                ans.push_back(')');\n            }\n        } else{\n            ans.push_back(s[i]);\n            i++;\n            j++;\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nstruct Node {\n\tint val;\n\tNode *l;\n\tNode *r;\n};\nconst Node Ni= { 0,NULL,NULL };\n\nvoid dfs(Node* a,string s) {\n\tint cnt = 0;\n\t*a = Ni;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t}\n\t\tif (s[i] == '['&&cnt == 0) {\n\t\t\tint llastidx = i-1;\n\t\t\ti++;\n\t\t\twhile (isdigit(s[i])) {\n\t\t\t\ta->val *= 10;\n\t\t\t\ta->val += s[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tstring s2;\n\t\t\ts2 = s.substr(1, llastidx - 1);\n\t\t\tif (s2!=\"\"){\n\t\t\t\ta->l = (Node*)malloc(sizeof(Node));\n\t\t\t\tdfs(a->l, s.substr(1, llastidx - 1));\n\t\t\t}\n\t\t\ts2 = s.substr(i + 2, s.length() - (i + 2) - 1);\n\t\t\tif (s2 != \"\") {\n\t\t\t\ta->r = (Node*)malloc(sizeof(Node));\n\t\t\t\tdfs(a->r, s.substr(i + 2, s.length() - (i + 2) - 1));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\n}\nstring add(Node *a, Node *b) {\n\tstring ret = \"\";\n\tint val = a->val + b->val;\n\tret += \"(\";\n\tif ((a->l != NULL)&&(b->l != NULL))\n\t\tret += add(a->l, b->l);\n\tret += \")[\" + to_string(val) + \"](\";\n\tif ((a->r != NULL)&&(b->r != NULL))\n\t\tret += add(a->r, b->r);\n\tret += \")\";\n\treturn ret;\n}\nvoid nd(Node* a) {\n\tif (a->l != NULL)\n\t\tnd(a->l);\n\tif (a->r != NULL)\n\t\tnd(a->r);\n\tfree(a);\n}\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tNode *a;\n\ta = (Node*)malloc(sizeof(Node));\n\tdfs(a,s1);\n\tNode *b; \n\tb = (Node*)malloc(sizeof(Node));\n\tdfs(b,s2);\n\tcout << add(a, b) << endl;\n\tnd(a);\n\tnd(b);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n//木を実装する\ntypedef struct _node{\n    int element;\n    struct _node *left;\n    struct _node *right;\n    struct _node *par;\n}node;\n \ntypedef struct _tree{\n    node *root;\n}tree;\n \n//リストを生成する関数\ntree *create(){\n    tree *T = (tree *)malloc(sizeof(tree));\n    T->root = (node *)malloc(sizeof(node));\n    T->root->left = NULL;\n    T->root->right = NULL;\n    T->root->par = NULL;\n    T->root->element = -1;\n    return T;\n}\n \nvoid make_tree(tree *T, string s){\n    node *ptr = T->root;\n \n    for(int i = 0; i < (int) s.size(); i++){\n \n        if(s[i] == '('){\n            //どっちかににノードを足す\n            node *add = (node *)malloc(sizeof(node));\n            add->element = -1;\n            add->left = NULL;\n            add->right = NULL;\n            add->par = ptr;\n \n            //左\n            if(ptr->left == NULL){\n                ptr->left = add;\n                ptr = add;\n            }else{\n                ptr->right = add;\n                ptr = add;\n            }\n        }else if(s[i] == ')'){\n            //戻る\n            ptr = ptr->par;\n        }else if(s[i] == '['){\n            string str;\n            int j;\n            for(j = i + 1; s[j] != ']'; j++) str.push_back(s[j]);\n            int num = stoi(str);\n            ptr->element = num;\n            i = j;\n        }\n    }\n}\n \nvoid print_tree(node *v){\n    if(v == NULL || v->element == -1){\n        cout << \")\";\n        return;\n    }\n \n    cout << \"(\";\n    print_tree(v->left);\n    cout << \"[\" << v->element << \"]\";\n    cout << \"(\";\n    print_tree(v->right);\n    if(v->par != NULL) cout << \")\";\n    return;\n}\n \nvoid sum_tree(node *v1, node *v2, node *v3){\n    v3->element = v1->element + v2->element;\n \n    if(v1->left != NULL && v2->left != NULL && v1->left->element != -1 && v2->left->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->left = add;\n        sum_tree(v1->left, v2->left, v3->left);\n    }\n     \n    if(v1->right != NULL && v2->right != NULL && v1->right->element != -1 && v2->right->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->right = add;        \n        sum_tree(v1->right, v2->right, v3->right);\n    }\n     \n    //if(v->par != NULL) cout << \")\";\n    return;\n     \n}\n \nint main(){\n \n    string s1, s2; cin >> s1 >> s2;\n    tree *T1 = create();\n    tree *T2 = create();\n    tree *T3 = create();    \n    make_tree(T1, s1);\n    make_tree(T2, s2);\n    sum_tree(T1->root, T2->root, T3->root); \n    print_tree(T3->root);\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin + 1 == End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin;Begin!=End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin(), be = b.end();\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n#define rrep(i, a, b) for (auto i = (a); i > (b); --i)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\n#ifdef LOCAL_DEFINE\nstruct InitInput\n{\n  InitInput()\n  {\n    FILE *stream1;\n    stream1 = freopen(\"in.txt\", \"r\", stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n} LOCAL_INPUT;\nstruct LOCAL_OUTPUT\n{\n  LOCAL_OUTPUT()\n  {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n} /*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showA(a, n)                                            \\\n  do                                                           \\\n  {                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)            \\\n      cerr << \"(\" << _i_t_e_ << \" = \" << (a)[_i_t_e_] << \") \"; \\\n    cerr << endl;                                              \\\n  } while (0)\n#define showA2(a, n, m)                                                                        \\\n  do                                                                                           \\\n  {                                                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)                                            \\\n    {                                                                                          \\\n      for (int _i_t_e_2 = 0; _i_t_e_2 < (m); _i_t_e_2++)                                       \\\n      {                                                                                        \\\n        cerr << \"(\" << _i_t_e_ << \", \" << _i_t_e_2 << \" = \" << (a)[_i_t_e_][_i_t_e_2] << \") \"; \\\n      }                                                                                        \\\n      cerr << endl;                                                                            \\\n    }                                                                                          \\\n    cerr << endl;                                                                              \\\n  } while (0)\n#else\n#define show(x)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim\n{\n  InitAim()\n  {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(12);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n} aim_cpo;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr const int INT_INF = 0x3f3f3f3f;       //1061109567\nconstexpr const ll LL_INF = 0x3f3f3f3f3f3f3f3f; //4557430888798830399\n\ntemplate <typename T>\nbool chmin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T>\nvoid ln(T i, T n) { cout << (i == n - 1 ? \"\\n\" : \" \"); }\ntemplate <typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1)\n{\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1)\n{\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++)\n  {\n    out << vector1[i];\n    if (i == vector1.size() - 1)\n      out << \"]\";\n    else\n      out << \", \";\n  }\n  return out;\n}\n\n// INT\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T>\nT LCM(T a, T b)\n{\n  return a / GCD(a, b) * b;\n}\ntemplate <typename T>\nT EXTGCD(T a, T b, T &x, T &y)\n{\n  T d = a;\n  if (b != 0)\n  {\n    d = EXTGCD(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n  else\n    x = 1, y = 0;\n  return d;\n}\ntemplate <typename T>\nbool is_prime(T a)\n{\n  for (int i = 2; i * i <= a; i++)\n    if (a % i == 0)\n      return true;\n  return false;\n}\ntemplate <typename T, typename S>\nT Pow(T a, S b)\n{\n  T res = 1, now = a;\n  while (b)\n  {\n    if (b & 1)\n      res *= now;\n    b >>= 1;\n    now *= now;\n  }\n  return res;\n}\n\n// MOD\nll MOD = 1000000000L + 7L;\n#define Madd(a, b) (((a) % MOD) + ((b) % MOD)) % MOD\n#define Mmul(a, b) (((a) % MOD) * ((b) % MOD)) % MOD\n#define Msub(a, b) (((a) % MOD) + MOD - ((b) % MOD)) % MOD\ntemplate <typename T, typename S>\nT ModPow(T a, S b)\n{\n  assert(b >= 0);\n  T res = 1, now = Msub(a, 0);\n  while (b)\n  {\n    if (b & 1)\n      res = Mmul(res, now);\n    b >>= 1;\n    now = Mmul(now, now);\n  }\n  return res;\n}\ntemplate <typename T>\nT ModInverse(T a, T mod, bool prime)\n{ // if mod is prime, \"prime\" is true.\n  if (prime)\n    return ModPow(a, mod - 2);\n  else\n  {\n    T x, y;\n    EXTGCD(a, mod, x, y);\n    return (mod + x % mod) % mod;\n  }\n}\ntemplate <typename T>\nT EulerTotient(T a)\n{\n  vector<pair<int, int>> v;\n  for (T i = 2; i * i <= a; i++)\n  {\n    int cnt = 0;\n    while (a % i == 0)\n    {\n      cnt++;\n      a /= i;\n    }\n    if (cnt != 0)\n      v.emplace_back(i, cnt);\n  }\n  if (a != 1)\n    v.emplace_back(a, 1);\n  //showV(v, (int) v.size());\n  T res = 1;\n  for (int i = 0; i < (int)v.size(); i++)\n  {\n    if (v[i].se == 1)\n    {\n      //res *= v[i].fi - 1;\n      res = Mmul(res, v[i].fi - 1);\n    }\n    else\n    {\n      //res *= Pow(v[i].fi, v[i].se) - Pow(v[i].fi, v[i].se - 1);\n      res = Mmul(res, Msub(ModPow(v[i].fi, v[i].se), ModPow(v[i].fi, v[i].se - 1)));\n    }\n  }\n  return res;\n}\n#define Mdivide(a, b) Mmul(((a) % MOD), (ModInverse((b), MOD, true))) % MOD\nll comb(ll a, ll b)\n{\n  chmin(b, a - b);\n  ll res = 1LL, now = a;\n  for (ll i = 1; i <= b; i++)\n  {\n    res = Mmul(res, now);  //res *= now;\n    res = Mdivide(res, i); // res /= i;\n    now--;\n  }\n  return res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\nclass BIT\n{\npublic:\n  BIT(int size)\n  {\n    BITTable.assign(++size, 0);\n  }\n  T sum(int k)\n  {\n    T res = 0;\n    for (++k; k > 0; k -= k & -k)\n    {\n      res += BITTable[k];\n    }\n    return res;\n  }\n  T sum(int l, int r)\n  {\n    if (l == 0)\n      return sum(r);\n    return sum(r) - sum(l - 1);\n  }\n  void update(int k, T x)\n  { // b[k] += x;\n    for (++k; k < (int)BITTable.size(); k += k & -k)\n      BITTable[k] += x;\n  }\n\nprivate:\n  vector<T> BITTable;\n};\n\ntemplate <typename T>\nclass IntervalTree\n{\n  using F = function<T(T, T)>;\n\npublic:\n  IntervalTree(int n, const F func, const T init) : func(func), init(init)\n  {\n    size = 1;\n    while ((int)size < n)\n      size <<= 1;\n    table.assign(2 * size, init);\n  }\n  void set(int k, T &x)\n  {\n    table[size + k] = x;\n  }\n  void build()\n  {\n    for (int i = size - 1; i >= 0; --i)\n    {\n      table[i] = func(table[i * 2], table[i * 2 + 1]);\n    }\n  }\n  void update(int k, const T &x)\n  {\n    k += size;\n    table[k] = x;\n    while (k >>= 1)\n    {\n      table[k] = func(table[k * 2], table[k * 2 + 1]);\n    }\n  }\n  T query(int a, int b)\n  {\n    T L = init, R = init;\n    for (a += size, b += size; a < b; a >>= 1, b >>= 1)\n    {\n      if (a & 1)\n        L = func(L, table[a++]);\n      if (b & 1)\n        R = func(table[--b], R);\n    }\n    return func(L, R);\n  }\n  T operator[](const int k) const\n  {\n    return table[k + size];\n  }\n\nprivate:\n  unsigned int size;\n  vector<T> table;\n  const F func;\n  const T init;\n};\n\nclass UnionFind\n{\npublic:\n  explicit UnionFind(int _n) : n(_n)\n  {\n    par.resize(static_cast<unsigned long>(_n));\n    rank.resize(static_cast<unsigned long>(_n));\n    sizes.resize(static_cast<unsigned long>(_n));\n    for (int i = 0; i < _n; i++)\n    {\n      par[i] = i;\n      rank[i] = 0;\n      sizes[i] = 1;\n    }\n  }\n  int find(int a)\n  {\n    if (par[a] == a)\n      return a;\n    return par[a] = find(par[a]);\n  }\n  bool same(int a, int b)\n  {\n    return find(a) == find(b);\n  }\n  void unite(int a, int b)\n  {\n    link(find(a), find(b));\n  }\n  int size(int a)\n  {\n    return sizes[find(a)];\n  }\n  void view()\n  {\n    for (int i = 0; i < n; i++)\n    {\n      cout << \" par\"\n           << \"[\" << i << \"]=\" << par[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    for (int i = 0; i < n; i++)\n    {\n      cout << \"size\"\n           << \"[\" << i << \"]=\" << sizes[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    cout << endl;\n  }\n\nprivate:\n  void link(int a, int b)\n  {\n    if (same(a, b))\n      return;\n    if (rank[a] > rank[b])\n    {\n      par[b] = a;\n      sizes[a] += sizes[b];\n      sizes[b] = 0;\n    }\n    else\n    {\n      par[a] = b;\n      if (rank[a] == rank[b])\n        rank[b]++;\n      sizes[b] += sizes[a];\n      sizes[a] = 0;\n    }\n  }\n  int n;\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sizes;\n};\n\nnamespace geo\n{\n#define IL inline\ntypedef double D;\ntypedef bool B;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\nostream &operator<<(ostream &out, const P &point1) // Pの出力\n{\n  out << '(' << point1.X << \", \" << point1.Y << ')';\n  return out;\n}\nB comp(const P &l, const P &r)\n{\n  return (l.X == r.X) ? l.Y < r.Y : l.X < r.X;\n}\ntypedef pair<P, P> L;  //line\ntypedef pair<P, P> LS; //line segment\ntypedef pair<P, D> C;  //circle\ntypedef vector<P> Poly;\nconst D EPS = 1e-8;\n//Decompotision Macro\n#define DCl(a, b, l) \\\n  P a, b;            \\\n  tie(a, b) = l\n#define DCc(a, b, c) \\\n  P a;               \\\n  D b;               \\\n  tie(a, b) = c\n\n//A dot B\nIL D dot(P a, P b) { return a.X * b.X + a.Y * b.Y; }\n//A cross B\nIL D cross(P a, P b) { return a.X * b.Y - a.Y * b.X; }\nIL D ccw(P a, P b, P c)\n{\n  return cross(b - a, c - a);\n}\n\nIL int sgn(P a, P b, P c)\n{\n  if (cross(b - a, c - a) > EPS)\n    return 1;\n  if (cross(b - a, c - a) < -EPS)\n    return -1;\n  if (dot(b - a, c - a) < -EPS)\n    return 2; // b-a-c\n  if (dot(a - b, c - b) < -EPS)\n    return -2; // a-b-c\n  return 0;\n}\nIL D signed_distance_P_L(P p, L l)\n{\n  DCl(a, b, l);\n  return ccw(a, b, p) / abs(b - a);\n}\n\nIL D distance_P_L(P p, L l) // 点と直線の距離\n{\n  return abs(signed_distance_P_L(p, l));\n}\n\nIL D distance_P_P(P p1, P p2) // 二点間距離\n{\n  return abs(p1 - p2);\n}\n\nIL D distance_P_LS(P p, LS ls) // 点と線分の距離\n{\n  DCl(a, b, ls);\n  if (dot(b - a, p - a) < EPS)\n    return abs(p - a);\n  if (dot(a - b, p - b) < EPS)\n    return abs(p - b);\n  return abs(cross(b - a, p - a)) / abs(b - a);\n}\n\nIL B is_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return abs(cross(a - b, c - d)) > EPS ||\n         abs(cross(a - b, d - b)) < EPS;\n}\nIL B is_L_LS(L l, LS ls)\n{\n  DCl(a, b, l);\n  DCl(c, d, ls);\n  return ccw(a, b, c) * ccw(a, b, d) < EPS;\n}\nIL B is_LS_LS(LS p, LS q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return sgn(a, b, c) * sgn(a, b, d) <= 0 && sgn(c, d, a) * sgn(c, d, b) <= 0;\n}\n\nIL D distance_LS_LS(LS p, LS q)\n{\n  if (is_LS_LS(p, q))\n    return 0;\n  return min({distance_P_LS(p.fi, q),\n              distance_P_LS(p.se, q),\n              distance_P_LS(q.fi, p),\n              distance_P_LS(q.se, p)});\n}\n\n//caution: have to use isintersected_L_L before this function\nIL P cross_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  D d1 = signed_distance_P_L(a, q);\n  D d2 = signed_distance_P_L(b, q);\n  return (a * d2 - b * d1) / (d2 - d1);\n}\n\nIL B is_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  return abs(rp - rq) - d < EPS &&\n         rp + rq - d > -EPS;\n}\nIL LS cross_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  D rc = (d * d + rp * rp - rq * rq) / (2 * d);\n  D rs = sqrt(rp * rp - rc * rc);\n  P diff = (cq - cp) / d;\n  return {cp + P(rc, rs) * diff, cp + P(rc, -rs) * diff};\n}\nIL Poly convex_hull(Poly p)\n{\n  int n = p.size();\n  Poly res(2 * n);\n  int k = 0, t;\n  sort(all(p), comp);\n  rep(i, 0, n)\n  {\n    while (k > 1 && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  t = k;\n  rep(j, 0, n - 1)\n  {\n    int i = n - 2 - j;\n    while (k > t && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  res.resize(k - 1);\n  return res;\n}\nIL B convex_in(Poly &l, P &p)\n{\n  int a = 0, b = l.size(), c;\n  D A, C;\n  P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n  while (b - a > 1)\n  {\n    c = (a + b) / 2;\n    A = cross(l[a] - g, p - l[a]);\n    C = cross(l[c] - g, p - l[c]);\n    if (cross(l[a] - g, l[c] - g) >= 0)\n    {\n      if (A > -EPS && C < -EPS)\n        b = c;\n      else\n        a = c;\n    }\n    else\n    {\n      if (C < -EPS || A > -EPS)\n        b = c;\n      else\n        a = c;\n    }\n  }\n  return (cross(l[b % l.size()] - l[a], p - l[b % l.size()]) > -EPS);\n}\n\n//not necessary?\nIL D convex_area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  rep(i, 2, n)\n      res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n  return res;\n}\nIL D area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  rep(i, 0, n)\n      res += cross(l[i], l[(i + 1) % n]);\n  return abs(res) / 2.0;\n}\ninline vector<L> tangent_line(C c, P p)\n{\n  vector<L> res;\n  DCc(cp, r, c);\n  P v = p - cp;\n  D dist = abs(v);\n  if (dist - r > -EPS)\n  {\n    double _cos = r / dist;\n    double _sin = sqrt(1.0 - _cos * _cos);\n    v = v * (r / dist);\n    {\n      P e = P(_cos * v.X - _sin * v.Y, _sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n    if (dist - r > EPS)\n    {\n      P e = P(_cos * v.X + _sin * v.Y, -_sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n  }\n  return res;\n}\nIL vector<L> inner_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  D dist = abs(Mp - Mq);\n  if (dist - (Rp + Rq) > -EPS)\n  {\n    P mid = (Mq * Rp + Mp * Rq) / (Rp + Rq);\n    res = tangent_line(p, mid);\n  }\n  return res;\n}\ninline vector<L> outer_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  P v = Mp - Mq;\n  D dist = abs(v);\n  if (dist - abs(Rp - Rq) > -EPS)\n  {\n    if (abs(Rp - Rq) < EPS)\n    {\n      P e = v * P(0, 1);\n      e = e / dist;\n      res.pb(L(Mp + e, Mq + e));\n      res.pb(L(Mp - e, Mq - e));\n    }\n    else\n    {\n      P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n      res = tangent_line(p, mid);\n    }\n  }\n  return res;\n}\n\nvector<Poly> decomposition(Poly p)\n{\n  int n = p.size();\n  vector<Poly> res;\n  while (n >= 3)\n  {\n    [&]() {\n      rep(i, 0, n)\n      {\n        P a = p[i];\n        P b = p[(i + 1) % n];\n        P c = p[(i + 2) % n];\n        if (ccw(a, b, c) < 0)\n          continue;\n        if ([&]() {\n              rep(j, 3, n)\n              {\n                P d = p[(i + j) % n];\n                if (ccw(a, b, d) > -EPS && ccw(b, c, d) > -EPS && ccw(c, a, d) > -EPS)\n                  return true;\n              }\n              return false;\n            }())\n          continue;\n        Poly nxt;\n        rep(j, 0, n) if ((i + j) % n != (i + 1) % n)\n            nxt.push_back(p[(i + j) % n]);\n        swap(p, nxt);\n        res.push_back({a, b, c});\n        n--;\n        return;\n      }\n    }();\n  }\n  return res;\n}\nint in_triangle(P p, Poly q)\n{\n  rep(i, 0, 3) if (abs(p - q[i]) < EPS) return 3; //on point\n  rep(i, 0, 3)\n  {\n    int s = sgn(q[i], q[(i + 1) % 3], p);\n    if (s != 1)\n    {\n      if (s == 0)\n        return 2; //on line\n      else\n        return 0; // not in\n    }\n  }\n  return 1; // inside triangle\n}\nint in_C(P q, C c) // 円での点の内外判定(円周上も判定)\n{\n  DCc(p, r, c);\n  if (abs(r - abs(p - q)) < EPS)\n    return 2; // 円周\n  return r - abs(p - q) > -EPS ? 1 : 0;\n}\nint is_triangle_C(Poly t, C c)\n{\n  t = convex_hull(t);\n  DCc(p, r, c);\n  int cnt = 0;\n  rep(i, 0, 3)\n      cnt += (in_C(t[i], c) > 0);\n  if (cnt == 3)\n    return 3; // t in c\n  if (cnt == 0)\n  {\n    double d = distance_P_LS(p, LS(t[2], t[0]));\n    rep(i, 0, 2)\n        d = min(d, distance_P_LS(p, LS(t[i], t[i + 1])));\n    if (r - d > EPS)\n      return 1; //intersect\n    if (in_triangle(p, t))\n      return 2; //c in t\n    else if (r - d < -EPS)\n      return 0; //not intersect\n  }\n  return 1; //intersect\n}\n\n//p must be convex and ccw\nLS diameter(Poly &p)\n{\n  int n = p.size();\n  int is = 0, js = 0;\n  rep(i, 0, n) if (p[i].Y > p[is].Y)\n      is = i;\n  rep(i, 0, n) if (p[i].Y < p[js].Y)\n      js = i;\n  LS res = {p[is], p[js]};\n  {\n    int i = is;\n    int j = js;\n    do\n    {\n      int ni = (i + 1) % n;\n      int nj = (j + 1) % n;\n      if (cross(p[ni] - p[i], p[nj] - p[j]) < EPS)\n        i = ni;\n      else\n        j = nj;\n      if (abs(res.fi - res.se) < abs(p[i] - p[j]))\n        res = LS(p[i], p[j]);\n    } while (i != is || j != js);\n  }\n  return res;\n}\n\nPoly cross_C_L(C c, L v)\n{\n  DCc(p, r, c);\n  DCl(a, b, v);\n  a -= p;\n  b -= p;\n  P u = a - b;\n  u = P(-u.Y, u.X);\n  P x = cross_L_L({a, b}, {P(0, 0), u});\n  D d = abs(x);\n  Poly res;\n  if (d - r > EPS)\n    return res;\n  D y = sqrt(r * r - d * d);\n  res.pb(p + x + (b - a) * y / abs(b - a));\n  //if(d-r>-EPS)return res;\n  res.pb(p + x + (a - b) * y / abs(b - a));\n  return res;\n}\n\npair<C, C> GetC_p_p_r(P p1, P p2, D r) // 二点と半径から２つの円を求める\n{\n  D d = distance_P_P(p1, p2);\n  assert(d <= 2. * r); // 二点間の距離は2 * r以内じゃないと同じ円周上に存在することはできない.\n  P mid = (p1 + p2) / 2.;\n  P NormalVector = (p1 - p2) / d * sqrt(r * r - d * d / 4.);\n  NormalVector = P(NormalVector.Y, -NormalVector.X);\n  P center1 = mid + NormalVector;\n  P center2 = mid - NormalVector;\n  return mp(C(center1, r), C(center2, r));\n}\n} // namespace geo\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n// 735134400 約数が1344個ある高度合成数(<= 1e9)\n// 897612484786617600 約数が103680個ある高度合成数(<= 1e18)\n// 苦手分野 重複順列\n// LLの数値をつかう時は最後にLLをつける癖をつけよう\n\nint NumA[1000], NumB[1000];\n\nvoid parseA(int idx, string s)\n{\n  // show(s);\n  int n = (int)s.size();\n  stack<char> st;\n  int res = 0;\n  for (int i = 0; i < n; i++)\n  {\n    if (s[i] == '(')\n      st.push('(');\n    else if (s[i] == ')')\n      st.pop();\n    else if (s[i] >= '0' && s[i] <= '9' && st.empty())\n    {\n      res *= 10;\n      res += (int)(s[i] - '0');\n    }\n    else if (s[i] == '[' && st.empty() && i - 2 > 0)\n    {\n      parseA(idx * 2, s.substr(1, i - 2));\n    }\n    else if (s[i] == ']' && st.empty() && i + 2 < n - 1)\n    {\n      parseA(idx * 2 + 1, s.substr(i + 2, n - i - 3));\n    }\n  }\n  NumA[idx] = res;\n}\n\nvoid parseB(int idx, string s)\n{\n  // show(s);\n  int n = (int)s.size();\n  stack<char> st;\n  int res = 0;\n  for (int i = 0; i < n; i++)\n  {\n    if (s[i] == '(')\n      st.push('(');\n    else if (s[i] == ')')\n      st.pop();\n    else if (s[i] >= '0' && s[i] <= '9' && st.empty())\n    {\n      res *= 10;\n      res += (int)(s[i] - '0');\n    }\n    else if (s[i] == '[' && st.empty() && i - 2 > 0)\n    {\n      parseB(idx * 2, s.substr(1, i - 2));\n    }\n    else if (s[i] == ']' && st.empty() && i + 2 < n - 1)\n    {\n      parseB(idx * 2 + 1, s.substr(i + 2, n - i - 3));\n    }\n  }\n  NumB[idx] = res;\n}\n\nstring a, b;\nint NumS[1000];\n\nstring construct(int idx)\n{\n  // show(idx);\n  if (NumS[idx] == -1)\n    return \"\";\n  return \"(\" + construct(idx * 2) + \")[\" + to_string(NumS[idx]) + \"](\" + construct(idx * 2 + 1) + \")\";\n}\n\nint main()\n{\n  cin >> a >> b;\n  fill(NumA, NumA + 1000, -1);\n  fill(NumB, NumB + 1000, -1);\n  parseA(1, a);\n  parseB(1, b);\n  // showA(NumA, 20);\n  // showA(NumB, 20);\n  for (int i = 0; i < 1000; i++)\n  {\n    if (NumA[i] == -1 || NumB[i] == -1)\n    {\n      NumS[i] = -1;\n      continue;\n    }\n    NumS[i] = NumA[i] + NumB[i];\n  }\n  string ans = construct(1);\n  cout << ans << endl;\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\n\tnode.emplace_back(Node());\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;if(r-l-1<0){exit(0);}\n  for(int i=l+1;i<r;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c-1);\n  if(r-1!=c)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size()-1);\n  n=1;node p2=con(0,a[1].size()-1);\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntuple<string, int, string> d(const string& s) {\n  int c = 0, n = s.size();\n  for (int i = 0; i < n; ++i) {\n    c += s[i] == '(';\n    c -= s[i] == ')';\n    if (!c) {\n      int j = i;\n      while (s[j] != ']') ++j;\n\n      return make_tuple(s.substr(1, i - 1), stoi(s.substr(i + 2, j - i - 2)), s.substr(j + 2, n - j - 3));\n    }\n  }\n}\nstring fn(const string& s, const string& t) {\n  if (s.empty() or t.empty()) return \"\";\n  string sl, sr, tl, tr;\n  int sm, tm;\n  tie(sl, sm, sr) = d(s);\n  tie(tl, tm, tr) = d(t);\n  return '(' + fn(sl, tl) + \")[\" + to_string(sm + tm) + \"](\" + fn(sr, tr) + ')';\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  string s, t; cin >> s >> t;\n  cout << fn(s, t) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  unsigned long long value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(unsigned long long Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin== End || Begin+1==End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin;Begin!=End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin(), be = b.end();\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef struct Treenode\n{\n\tbool left = false;\n\tbool right = false;\n\tpair<Treenode*, Treenode*> child;\n\tint num = INT_MAX / 6;\n};\n \nTreenode* saiki( string S ) {\n\t//cout << S << endl;\n\tint num = 0;\n\tint xx = 0;\n\tint parentnum = 0;\n\tint s = -1;\n\tint count = 0;\n\tTreenode *reta = new Treenode;\n\tfor( size_t i = 0; i < S.length(); i++ ) {\n\t\tif( S[i] == '(' ) {\n\t\t\tnum++;\n\t\t\tif( s == -1 ) {\n\t\t\t\ts = i;\n\t\t\t}\n\t\t} else if( S[i] == ')' ) {\n\t\t\tnum--;\n\t\t\tif( num == 0 ) {\n\t\t\t\tif( count == 0 ) {\n\t\t\t\t\tif( i - s > 1 ) {\n\t\t\t\t\t\t(*reta).child.first = saiki( S.substr( s + 1, i - s - 1 ) );\n\t\t\t\t\t\tif( (*(*reta).child.first).num != INT_MAX / 6 ) {\n\t\t\t\t\t\t\t(*reta).left = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t\t} else {\n\t\t\t\t\tif( i - s > 1 ) {\n\t\t\t\t\t\t(*reta).child.second = saiki( S.substr( s + 1, i - s - 1 ) );\n\t\t\t\t\t\tif( (*(*reta).child.second).num != INT_MAX / 6 ) {\n\t\t\t\t\t\t\t(*reta).right = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts = -1;\n\t\t\t}\n\t\t} else if( S[i] == '[' ) {\n\t\t\txx = 0;\n\t\t} else if( S[i] == ']' ) {\n\t\t\tif( num == 0 ) {\n\t\t\t\t(*reta).num = xx;\n\t\t\t}\n\t\t} else {\n\t\t\txx *= 10;\n\t\t\txx += S[i] - '0';\n\t\t}\n\t}\n\treturn reta;\n}\n \nTreenode* saiki2( Treenode* A, Treenode* B ) {\n\tTreenode* retc = new Treenode;\n\t(*retc).num = (*A).num + (*B).num;\n \n\tif( (*A).left && (*B).left ) {\n\t\t(*retc).left = true;\n\t\t(*retc).child.first = saiki2( (*A).child.first, (*B).child.first );\n\t}\n\tif( (*A).right && (*B).right ) {\n\t\t(*retc).right = true;\n\t\t(*retc).child.second = saiki2( (*A).child.second, (*B).child.second );\n\t}\n\treturn retc;\n \n}\n \nstring saiki3( Treenode* C ) {\n\tstring ret = \"\";\n\tif( (*C).left ) {\n\t\tret += '(' + saiki3( (*C).child.first ) + ')';\n\t} else {\n\t\tret += \"()\";\n\t}\n\tret += '[' + to_string( (*C).num ) + ']';\n\tif( (*C).right ) {\n\t\tret += '(' + saiki3( (*C).child.second ) + ')';\n\t} else {\n\t\tret += \"()\";\n\t}\n\treturn ret;\n \n}\n \nint main() {\n\tstring A, B;\n\tcin >> A >> B;\n\tTreenode* Atree = saiki( A );\n\tTreenode* Btree = saiki( B );\n\tTreenode* Ctree = saiki2( Atree, Btree );\n\tcout << saiki3( Ctree ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct node{\n\tint value;\n\tnode *left,*right;\n};\n\nnode* build(){\n\tif(getchar()==')')return NULL; //skip (\n\tnode *res = new node();\n\tif(res->left = build())getchar(); //skip )\n\tscanf(\"[%d](\",&res->value);\n\tif(res->right = build())getchar(); //skip )\n\treturn res;\n}\n\nnode* unite(node *a, node *b){\n\tif(a==NULL || b==NULL)return NULL;\n\tnode *res = new node();\n\tres->value = a->value+b->value;\n\tres->left = unite(a->left, b->left);\n\tres->right = unite(a->right, b->right);\n\treturn res;\n}\n\nvoid output(node *n){\n\tif(n==NULL)return;\n\tprintf(\"(\");\n\toutput(n->left);\n\tprintf(\")[%d](\", n->value);\n\toutput(n->right);\n\tprintf(\")\");\n}\n\nint main(){\n\tnode *a = build();\n\tgetchar(); //skip \\n\n\tnode *b = build();\n\tgetchar(); //skip \\n\n\toutput(unite(a,b));\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\tvt.push_back({num,0,0});\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 2), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\tvt3.push_back({tree1[a].num+tree2[b].num,0,0 });\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\telse\n\t\tvt3[no].left = -1;\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\telse\n\t\tvt3[no].right = -1;\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint A[2][1000],G[2][1000][2];\nstring s,t;\nint root;\nint f(string s,int flag)\n{\n\tint nowroot=root++;\n\tint i=0,cnt=0;\n\tfor(;i<s.size();i++)\n\t{\n\t\tif(s[i]=='(')cnt++;\n\t\telse if(s[i]==')')cnt--;\n\t\tif(!cnt)break;\n\t}\n\tG[flag][nowroot][0]=i>1?f(s.substr(1,i-1),flag):-1;\n\tint j=i+2;\n\tfor(;s[i]!=']';i++);\n\tA[flag][nowroot]=stoi(s.substr(j,i-j));\n\tG[flag][nowroot][1]=i+4<s.size()?f(s.substr(i+2,s.size()-i-3),flag):-1;\n\treturn nowroot;\n}\nstring solve(int a,int b)\n{\n\tstring ans=\"[\"+to_string(A[0][a]+A[1][b])+\"]\";\n\tans=\"(\"+(G[0][a][0]>=0&&G[1][b][0]>=0?solve(G[0][a][0],G[1][b][0]):\"\")+\")\"+ans;\n\tans+=\"(\"+(G[0][a][1]>=0&&G[1][b][1]>=0?solve(G[0][a][1],G[1][b][1]):\"\")+\")\";\n\treturn ans;\n}\nmain()\n{\n\tcin>>s>>t;\n\tint aroot=f(s,0);\n\troot=0;\n\tint broot=f(t,1);\n\tcout<<solve(aroot,broot)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>{\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//テゥツ?淌・ツコツヲテ」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ?湘」ツδ。テ」ツδ「テ」ツδェテ・ツ環ケテァツ篠?」ツつ津ィツ?ε」ツ?暗」ツつ凝」ツ?ェテ」ツつ詠ankテ」ツ?ョテ」ツ?凝」ツつ湘」ツつ甘」ツ?ォsizeテ」ツつ津、ツスツソテ」ツ??\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b,QF &&qf) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1,qf);\n\t}*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//テ・ツ、ツ堙ヲツャツ。テ・ツ?ィITテ」ツ?ッテ」ツδォテ」ツδシテ」ツδ療」ツつ津」ツδ催」ツつケテ」ツδ暗」ツ?凖」ツつ古」ツ?ーテ」ツ??」ツ??」ツつ嘉」ツ?療」ツ??」ツ??\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l,int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nusing t = tuple<int,void*,void*>;\nt *a, *b;\nstring f(t& a, t& b) {\n\treturn \"(\" + (get<1>(a) && get<1>(b) ? f(*(t*)get<1>(a), *(t*)get<1>(b)) : string()) + \")[\" + to_string(get<0>(a) + get<0>(b)) + \"](\" + (get<2>(a) && get<2>(b) ? f(*(t*)get<2>(a), *(t*)get<2>(b)) : string()) + \")\";\n}\nt* g(string& s, int &p) {\n\tp++;\n\tt &x = *new t();\n\tif (s[p] == '(')get<1>(x) = g(s, p);\n\tp+=2;\n\tget<0>(x) = atoi(s.c_str() + p);\n\twhile (s[p] != ']')p++;\n\tp += 2;\n\tif (s[p] == '(')get<2>(x) = g(s, p);\n\tp++;\n\treturn &x;\n}\nint main() {\n\tstring a, b;\n\tcin >> a >> b;\n\tint c = 0, d = 0;\n\tcout << f(*g(a, c), *g(b, d)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define repr(i, a, b) for (int i = (int)(a - 1); i >= b; i--)\n#define rep(i, n) repl(i, 0, n)\n#define each(itr, v) for (auto itr : v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(), (x).end()\n#define dbg(x) cout << #x \" = \" << x << endl\n#define dbgv(i, a, v) \\\n  rep(i, a) { cout << v[i] << ((i < a - 1) ? ' ' : '\\n'); }\n#define maxch(x, y) x = max(x, y)\n#define minch(x, y) x = min(x, y)\n#define uni(x) x.erase(unique(all(x)), x.end())\n#define exist(x, y) (find(all(x), y) != x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define INF INT_MAX / 3\n\nint p[1010], q[1010], ans[1010];\n\nvoid toArray(string s, int *array, int rnum) {\n  if (s.size() == 0) return;\n  int l = 1, i = 1;\n  while (l > 0 && i < s.size()) {\n    if (s[i] == '(')\n      l++;\n    else if (s[i] == ')')\n      l--;\n    i++;\n  }\n  int j = i + 1, r = 0;\n  while ('0' <= s[j] && s[j] <= '9') {\n    r = r * 10 + (s[j] - '0');\n    j++;\n  }\n  array[rnum] = r;\n  toArray(s.substr(1, i - 2), array, rnum * 2 + 1);\n  toArray(s.substr(j + 2, s.size() - j - 3), array, rnum * 2 + 2);\n}\n\nstring toString(int *array, int rnum) {\n  if (array[rnum] == -1) return \"\";\n  string ret = \"(\";\n  ret += toString(array, rnum * 2 + 1);\n  ret += \")[\" + to_string(array[rnum]) + \"](\";\n  ret += toString(array, rnum * 2 + 2);\n  return ret + \")\";\n}\n\nint main() {\n  cin.sync_with_stdio(false);\n  memset(p, -1, sizeof(p));\n  memset(q, -1, sizeof(q));\n  memset(ans, -1, sizeof(ans));\n  string a, b;\n  cin >> a >> b;\n  toArray(a, p, 0), toArray(b, q, 0);\n  rep(i, 1010) {\n    if (p[i] > -1 && q[i] > -1) ans[i] = p[i] + q[i];\n  }\n  cout << toString(ans, 0) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nint tree(State&);\nint number(State&);\n\nPII t[2][100010];\nint idx;\nint heap1[100010], heap2[100010], heap[100010];\nint val[2][100010];\nint cnt;\n\nint tree(State &begin) {\n  if(*begin != '(') return -1;\n  begin++;\n  int left = tree(begin);\n  begin++;\n  begin++;\n  int res = number(begin);\n  begin++;\n  begin++;\n  int right = tree(begin);\n  begin++;\n  val[idx][cnt] = res;\n  t[idx][cnt++] = {left, right};\n  // cout << left << \" \" << cnt-1 << \" \" << res << \" \" << right << endl;\n  return cnt-1;\n}\n\nint number(State &begin) {\n  int res = 0;\n  while(isdigit(*begin)) {\n    res *= 10;\n    res += *begin - '0';\n    ++begin;\n  }\n  return res;\n}\n\nstring dfs(int num) {\n  if(heap[num] == -1) return \"\";\n  string ret = \"(\";\n  ret += (dfs(num*2+1));\n  ret += (\")[\");\n  ret += (to_string(heap[num]));\n  ret += (\"](\");\n  ret += (dfs(num*2+2));\n  ret += (\")\");\n  return ret;\n}\n\nsigned main(void)\n{\n  string s, tt;\n  cin >> s >> tt;\n  memset(val, -1, sizeof(val));\n  memset(heap1, -1, sizeof(heap1));\n  memset(heap2, -1, sizeof(heap2));\n  memset(heap, -1, sizeof(heap));\n  idx = 0, cnt = 0;\n  State begin = s.begin();\n  int root1 = tree(begin);\n  idx = 1, cnt = 0;\n  begin = tt.begin();\n  int root2 = tree(begin);\n\n  queue<PII> que;\n  que.push({root1, 0});\n  heap1[0] = val[0][root1];\n  while(que.size()) {\n    PII p = que.front(); que.pop();\n    int v = p.first, index = p.second;\n    // cout << t[0][v].first << \",\" << v << \",\" << t[0][v].second << endl;\n    if(v == -1) continue;\n    heap1[index*2+1] = t[0][v].first==-1?-1:val[0][t[0][v].first];\n    que.push({t[0][v].first, index*2+1});\n    heap1[index*2+2] = t[0][v].second==-1?-1:val[0][t[0][v].second];\n    que.push({t[0][v].second, index*2+2});\n  }\n\n  while(que.size()) que.pop();\n  que.push({root2, 0});\n  heap2[0] = val[1][root2];\n  while(que.size()) {\n    PII p = que.front(); que.pop();\n    int v = p.first, index = p.second;\n    if(v == -1) continue;\n    heap2[index*2+1] = t[1][v].first==-1?-1:val[1][t[1][v].first];\n    que.push({t[1][v].first, index*2+1});\n    heap2[index*2+2] = t[1][v].second==-1?-1:val[1][t[1][v].second];\n    que.push({t[1][v].second, index*2+2});\n  }\n\n  REP(i, 100010) {\n    if(heap1[i] == -1 || heap2[i] == -1) {\n      heap[i] = -1;\n    } else {\n      heap[i] = heap1[i] + heap2[i];\n    }\n  }\n\n  cout << dfs(0) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n#define INF 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t\tstatic void print(std::ostream &os, const Tuple &t) {\n\t\t\t__TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t\t\tos << \", \" << std::get<N - 1>(t);\n\t\t}\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t\tstatic void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t\tos << '(';\n\t\t__TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t\tos << ')';\n\t\treturn os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t\treturn os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\tos << '[';                                \\\n\tfor (auto it = begin(c); it != end(c);) { \\\n\t\tos << *it;                            \\\n\t\tos << (++it != end(c) ? \", \" : \"\");   \\\n\t}                                         \\\n\treturn os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t\t__INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\t__INNER__                                               \\\n\t}\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t\t__INNER__                                                  \\\n\t}\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\tstd::deque<T> v;                                        \\\n\t\tfor (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t\t\treturn os << v;                                         \\\n\t}\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n\tconstexpr static signed MODULO = M;\n\tconstexpr static unsigned TABLE_SIZE = T;\n\n\tsigned x;\n\n\tmod_int() : x(0) {}\n\n\tmod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n\tmod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n\tmod_int &operator+=(const mod_int &rhs) {\n\t\tif ((x += rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator-=(const mod_int &rhs) {\n\t\tif ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator*=(const mod_int &rhs) {\n\t\tx = static_cast<signed>(1LL * x * rhs.x % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int &operator/=(const mod_int &rhs) {\n\t\tx = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int operator-() const { return mod_int(-x); }\n\n\tmod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n\tmod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n\tmod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n\tmod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n\tbool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n\tmod_int inv() const {\n\t\tassert(x != 0);\n\t\tif (x <= static_cast<signed>(TABLE_SIZE)) {\n\t\t\tif (_inv[1].x == 0) prepare();\n\t\t\treturn _inv[x];\n\t\t} else {\n\t\t\tsigned a = x, b = MODULO, u = 1, v = 0, t;\n\t\t\twhile (b) {\n\t\t\t\tt = a / b;\n\t\t\t\ta -= t * b;\n\t\t\t\tstd::swap(a, b);\n\t\t\t\tu -= t * v;\n\t\t\t\tstd::swap(u, v);\n\t\t\t}\n\t\t\treturn mod_int(u);\n\t\t}\n\t}\n\n\tmod_int pow(long long t) const {\n\t\tassert(!(x == 0 && t == 0));\n\t\tmod_int e = *this, res = mod_int(1);\n\t\tfor (; t; e *= e, t >>= 1)\n\t\t\tif (t & 1) res *= e;\n\t\treturn res;\n\t}\n\n\tmod_int fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _fact[x];\n\t}\n\n\tmod_int inv_fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _inv_fact[x];\n\t}\n\n\tmod_int choose(mod_int y) {\n\t\tassert(y.x <= x);\n\t\treturn this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n\t}\n\n\tstatic mod_int _inv[TABLE_SIZE + 1];\n\n\tstatic mod_int _fact[TABLE_SIZE + 1];\n\n\tstatic mod_int _inv_fact[TABLE_SIZE + 1];\n\n\tstatic void prepare() {\n\t\t_inv[1] = 1;\n\t\tfor (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n\t\t\t_inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n\t\t}\n\t\t_fact[0] = 1;\n\t\tfor (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n\t\t\t_fact[i] = _fact[i - 1] * int(i);\n\t\t}\n\t\t_inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n\t\tfor (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n\t\t\t_inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n\t\t}\n\t}\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n\treturn os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n\tlong long s;\n\tis >> s;\n\trhs = mod_int<M, F>(s);\n\treturn is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\nconst ll mod = 1000000007;\nconst int MAX_N = 10000;  // 400MB\n// const int MAX_N = 1024; // 4MB\n// nCr % mod\n\n#define int long long\n#define double long double \n\ninline ll gcds(ll a, ll b) { return b ? gcds(b, a % b) : a; }\n\n#define RK 200000000000\n#define LK 300000000000\n#define PL 400000000000\n#define MI 500000000000\n#define KA 600000000000\n\nint findc(string s){\n\tint n=0;\n\tlp(i,s.size()){\n\t\tif(s[i]=='(')n++;\n\t\telse if(s[i]==')')n--;\n\t\tif(n==0){\n\t\t\tint num=0;\n\t\t\tif(s[i+1]!='[')return -1;\n\t\t\tfor(int j=i+2;1;j++){\n\t\t\t\tif(s[j]==']')return num;\n\t\t\t\tnum*=10;\n\t\t\t\tnum+=s[j]-'0';\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nstring findl(string s){\n\tint n=0;\n\tlp(i,s.size()){\n\t\tif(s[i]=='(')n++;\n\t\telse if(s[i]==')')n--;\n\t\tif(n==0){\n\t\t\treturn s.substr(1,i-1);\n\n\t\t}\n\t}\n}\n\nstring findr(string s){\n\tint n=0;\n\tlp(i,s.size()){\n\t\tif(s[i]=='(')n++;\n\t\telse if(s[i]==')')n--;\n\t\tif(n==0&&s[i]==']'){\n\t\t\treturn s.substr(i+2,s.size()-3-i);\n\t\t}\n\t}\n}\n\nstring solve(string s,string t){\n\tint x=findc(s);\n\tint y=findc(t);\n\t//cout<<s<<\" \"<<t<<\" \"<<x<<\" \"<<y<<endl;\n\tif(x==-1||y==-1){\n\t\treturn \"\";\n\t}\n\tstring ans=\"[\"+to_string(x+y)+\"]\";\n\tstring l=solve(findl(s),findl(t));\n\tstring r=solve(findr(s),findr(t));\n\treturn \"(\"+l+\")\"+ans+\"(\"+r+\")\";\n}\n\nsigned main(){\n\tstring s,t;\n\tcin>>s>>t;\n\tcout<<solve(s,t)<<endl;;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint num(string&s, int&i) {\n\tint n = 0;\n\twhile (isdigit(s[i]))n = n * 10 + s[i++] - '0';\n\treturn n;\n}\nP E[2][10000];\nint calc(string&s, int&i, int id) {\n\tint l = -1, r = -1, ret;\n\ti++; if (s[i] == '(') { l = calc(s, i, id); i++; }\n\ti += 2; ret = num(s, i);\n\ti += 2; if (s[i] == '(') { r = calc(s, i, id); i++; }\n\tE[id][ret].first = l; E[id][ret].second = r;\n\treturn ret;\n}\nstring dfs(int a, int b) {\n\tstring s = \")[\" + to_string(a + b) + \"](\";\n\tif (E[0][a].first != -1 && E[1][b].first != -1)\n\t\ts = \"(\" + dfs(E[0][a].first, E[1][b].first) + \")\" + s;\n\telse s = \"(\" + s;\n\tif (E[0][a].second != -1 && E[1][b].second != -1)\n\t\ts = s += dfs(E[0][a].second, E[1][b].second) + \")\";\n\telse s += \")\";\n\treturn s;\n}\nint main() {\n\tstring a, b; cin >> a >> b;\n\tint r1, r2;\n\tint i = 0; r1 = calc(a, i, 0);\n\ti = 0; r2 = calc(b, i, 1);\n\tcout << dfs(r1, r2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <string>\n\nint parse_int(std::string const& s, size_t& i) {\n  assert(isdigit(s[i]));\n  int res = s[i]-'0';\n  while (isdigit(s[++i]))\n    res = res*10 + s[i]-'0';\n  return res;\n}\n\nvoid skip(std::string const& s, size_t& i) {\n  assert(s[i] == '(');\n  int opens = 0;\n  do {\n    if (s[i] == '(') ++opens;\n    if (s[i] == ')') --opens;\n    ++i;\n  } while (opens);\n}\n\nvoid nya(std::string const& s, size_t& i, std::string const& t, size_t& j) {\n  assert(s[i] == '(');\n  assert(t[j] == '(');\n  ++i;\n  ++j;\n\n  putchar('(');\n  if (s[i] == ')') {\n    ++i;\n    skip(t, --j);\n  } else if (t[j] == ')') {\n    ++j;\n    skip(s, --i);\n  } else {\n    nya(s, i, t, j);\n  }\n  putchar(')');\n\n  assert(s[i] == '[');\n  assert(t[j] == '[');\n  int x = parse_int(s, ++i);\n  int y = parse_int(t, ++j);\n  assert(s[i] == ']');\n  assert(t[j] == ']');\n  ++i;\n  ++j;\n  printf(\"[%d]\", x+y);\n\n  assert(s[i] == '(');\n  assert(t[j] == '(');\n  ++i;\n  ++j;\n\n  putchar('(');\n  if (s[i] == ')') {\n    ++i;\n    skip(t, --j);\n  } else if (t[j] == ')') {\n    ++j;\n    skip(s, --i);\n  } else {\n    nya(s, i, t, j);\n  }\n  putchar(')');\n\n  assert(s[i] == 0 || s[i] == ')');\n  assert(t[j] == 0 || t[j] == ')');\n  ++i;\n  ++j;\n}\n\nint main() {\n  char buf[1024];\n  scanf(\"%s\", buf);\n  std::string s = buf;\n  scanf(\"%s\", buf);\n  std::string t = buf;\n\n  size_t i = 0;\n  size_t j = 0;\n  nya(s, i, t, j);\n  putchar('\\n');\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_, *right;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator Begin, Iterator End) {\n  if (Begin == End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin; *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto *at = CreateTree(a.begin(), a.end()), *bt = CreateTree(b.begin(), b.end());\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;if(l+1>=r+1){cout<<1<<endl;exit(0);}\n  for(int i=l+1;i<r-1;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c);\n  if(r-1!=c+1)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size());\n  n=1;node p2=con(0,a[1].size());\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2005\nusing namespace std;\nint p=0,num=0,idx;\nstring s[2];\n\nstruct Graph{\n  int l,r,v;\n};\n\nGraph G[2][N];\n\nint make_G(){\n  int node=num++;\n  G[idx][node].l=-1;\n  G[idx][node].r=-1;\n  G[idx][node].v=-1;\n  if(s[idx][p++]==')')return node;\n  G[idx][node].l=make_G();\n  p++;\n  int Num=0;\n  while('0'<=s[idx][p]&&s[idx][p]<='9')\n    Num=Num*10+s[idx][p]-'0',p++;\n  p++;\n  G[idx][node].v=Num;\n  p++;\n  G[idx][node].r=make_G();\n  p++;\n  return node;\n}\n\nvoid output(int x,int y){\n  cout<<'(';\n  if(G[0][G[0][x].l].v>=0&&G[1][G[1][y].l].v>=0)\n    output(G[0][x].l,G[1][y].l);\n  cout<<')';\n  cout<<'['<<G[0][x].v+G[1][y].v<<']';\n  cout<<'(';\n  if(G[0][G[0][x].r].v>=0&&G[1][G[1][y].r].v>=0)\n    output(G[0][x].r,G[1][y].r);\n  cout<<')';\n}\n\nint main(){\n  cin>>s[0]>>s[1];\n  make_G();\n  idx=1;\n  p=0;\n  int num2=num;\n  make_G();\n  output(0,num2);\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r, int& idx){\n\tif(r - l == 0) return -1;\n\n\tint cur = idx;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tidx++;\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1, idx);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tidx++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1, idx);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x(200), y(200);\n\tint idx = 0;\n\tdfs(x, a, 0, a.size(), idx);\n\tidx = 0;\n\tdfs(y, b, 0, b.size(), idx);\n\n\n\tstring ans = merge(x,0,y,0);\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <tuple>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\ntuple<string, int, string> parse(string S) {\n    string L;\n    int itr, depth = 1;\n    for (itr = 1; depth > 0; ++itr) {\n        L.push_back(S[itr]);\n        if (S[itr] == '(') {\n            ++depth;\n        } else if (S[itr] == ')') {\n            --depth;\n        }\n    }\n    L.pop_back();\n\n    string V;\n    for (++itr; S[itr] != ']'; ++itr) {\n        V.push_back(S[itr]);\n    }\n\n    string R;\n    depth = 1;\n    for (itr += 2; depth > 0; ++itr) {\n        R.push_back(S[itr]);\n        if (S[itr] == '(') {\n            ++depth;\n        } else if (S[itr] == ')') {\n            --depth;\n        }\n    }\n    R.pop_back();\n    return make_tuple(L, stoi(V), R);\n}\n\nstring compose(string L, int v, string R) {\n    return \"(\" + L + \")[\" + to_string(v) + \"](\" + R + \")\";\n}\n\nstring merge(string S, string T) {\n    if (S.empty() || T.empty()) return \"\";\n\n    string sl, sr, tl, tr;\n    int sv, tv;\n    tie(sl, sv, sr) = parse(S);\n    tie(tl, tv, tr) = parse(T);\n\n    return compose(merge(sl, tl), sv + tv, merge(sr, tr));\n}\n\nint main() {\n    string S, T;\n    cin >> S >> T;\n    cout << merge(S, T) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstruct Tree {\n  std::string s;\n  struct Node {\n    Node *left, *right;\n    int value;\n  } *root;\n  \n  Tree(const std::string &s): s(s) {\n    size_t i=0;\n    root = new Node;\n    root->left = root->right = nullptr;\n    root->value = 114514;\n    parse(root, i);\n  }\n\n  void parse(Node *root, size_t &i) {\n    root->left = parse_node(i);\n    root->value = parse_value(i);\n    root->right = parse_node(i);\n  }\n\n  Node *parse_node(size_t &i) {\n    assert(s[i] == '(');\n    ++i;\n\n    Node *node;\n    if (s[i] == '(') {\n      node = new Node;\n      parse(node, i);\n    } else {\n      assert(s[i] == ')');\n      node = nullptr;\n    }\n    ++i;\n    return node;\n  }\n\n  int parse_value(size_t &i) {\n    assert(s[i] == '[');\n    ++i;\n\n    int res=0;\n    while (s[i] != ']') {\n      res = res*10 + s[i]-'0';\n      ++i;\n    }\n    ++i;\n\n    return res;\n  }\n};\n\nvoid print_sum(Tree::Node *ra, Tree::Node *rb) {\n  if (ra == nullptr || rb == nullptr) {\n    return;\n  }\n\n  printf(\"(\");\n  print_sum(ra->left, rb->left);\n  printf(\")\");\n\n  printf(\"[%d]\", ra->value+rb->value);\n\n  printf(\"(\");\n  print_sum(ra->right, rb->right);\n  printf(\")\");\n}\n\nint main() {\n  char buf[1024];\n  scanf(\"%s\", buf);\n  std::string A=buf;\n  scanf(\"%s\", buf);\n  std::string B=buf;\n\n  Tree ta(A), tb(B);\n  print_sum(ta.root, tb.root);\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Tree {\npublic:\n    int num = -1;\n    Tree* left;\n    Tree* right;\n\n    Tree(int _num, Tree* _left=nullptr, Tree* _right=nullptr) :\n        num(_num), left(_left), right(_right){}\n\n    string to_str() {\n        string ret = \"[\" + to_string(num) + \"]\";\n\n        if (left != nullptr) {\n            ret = \"(\" + left->to_str() + \")\" + ret;\n        } else {\n            ret = \"()\" + ret;\n        }\n\n        if (right != nullptr) {\n            ret += \"(\" + right->to_str() + \")\";\n        } else {\n            ret += \"()\";\n        }\n        return ret;\n    }\n};\n\nTree* parse(string s) {\n    if (s == \"\") return nullptr;\n\n    int paren= 1;\n    int left_idx = 1;\n    while (paren) {\n        if (s[left_idx] == '(') paren++;\n        else if (s[left_idx] == ')') paren--;\n        left_idx++;\n    }\n    string left_str = s.substr(1, left_idx-2);\n\n    int num_idx = left_idx + 1;\n    while (s[num_idx] != ']') num_idx++;\n    int num = atoi(s.substr(left_idx + 1, num_idx - left_idx - 1).c_str());\n\n    string right_str = s.substr(num_idx + 2, s.size() - num_idx - 3);\n\n    Tree *left = parse(left_str);\n    Tree *right = parse(right_str);\n    Tree *ret = new Tree(num, left, right);\n    return ret;\n}\n\nTree* add(Tree* a, Tree* b){\n    Tree* left = nullptr;\n    if (a->left != nullptr && b->left != nullptr) {\n        left = add(a->left, b->left);\n    }\n\n    int num = a->num + b->num;\n\n    Tree* right = nullptr;\n    if (a->right != nullptr && b->right != nullptr) {\n        right = add(a->right, b->right);\n    }\n\n    Tree *ret = new Tree(num, left, right);\n    return ret;\n}\n\nint main() {\n    string a, b;\n    cin >> a >> b;\n\n    auto tree_a = parse(a);\n    auto tree_b = parse(b);\n    auto add_tree = add(tree_a, tree_b);\n    cout << add_tree->to_str() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SP << \" \" <<\n\nLL mod = 1000000007;\n\nstruct node\n{\n  int num;\n  node *left = NULL;\n  node *right = NULL;\n  node(int value) : num(value){}\n};\n\nnode* parse(string& str,int& idx){\n  node* now = new node(0);\n  // (\n  idx++;\n  if(str[idx]=='('){\n    now->left = parse(str, idx);\n    idx++;\n  }\n  else if (str[idx] == ')')\n  {\n    now->left = NULL;\n    idx++;\n  }\n\n  //[\n  idx++;\n  //read num\n  while(str[idx]!=']'){\n    int val = str[idx] - '0';\n    now->num *= 10;\n    now->num += val;\n    idx++;\n  }\n  //]\n  idx++;\n  \n  // (\n  idx++;\n  if(str[idx]=='('){\n    now->right = parse(str, idx);\n    idx++;\n  }\n  else if (str[idx] == ')')\n  {\n    now->right = NULL;\n    idx++;\n  }\n  \n  return now;\n}\n\nstring output(node* node){\n  string str = \"\";\n  str += \"(\";\n\n  \n  if (node->left != NULL)\n  {\n    str += output(node->left);\n  }\n  str += \")\";\n\n  str += \"[\";\n  str += to_string(node->num);\n  str += \"]\";\n\n  \n  str += \"(\";\n  if (node->right != NULL)\n  {\n    str += output(node->right);\n  }\n  str += \")\";\n\n\n  return str;\n}\n\nnode* f(node* A,node* B){\n  node *now = new node(0);\n\n  now->num = A->num + B->num;\n  \n  if(A->left!=NULL&&B->left!=NULL){\n    now->left = f(A->left, B->left);\n  }\n  if(A->right!=NULL&&B->right!=NULL){\n    now->right = f(A->right, B->right);\n  }\n  return now;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string A, B;\n  cin >> A >> B;\n\n  int Ai = 0;\n  node* nodeA = parse(A, Ai);\n  int Bi = 0;\n  node* nodeB = parse(B, Bi);\n\n  cout << output(f(nodeA,nodeB)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin== End || Begin+1==End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin;Begin!=End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin(), be = b.end();\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct tree {\n\tint num;\n\tint left;\n\tint right;\n};\n\nvector<tree> tree1;\nvector<tree> tree2;\nvector<tree> tree3;\n\nint saiki(string s,vector<tree> &vt) {\n\tif (s.empty())\n\t\treturn -1;\n\tint cnt=0;\n\tREP(i, s.length()) {\n\t\tif (s[i] == '(') {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')') {\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cnt == 0 && isdigit(s[i])) {\n\t\t\tint idx = i;\n\t\t\tint num=0;\n\t\t\twhile (idx<s.length()&&isdigit(s[idx])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tint no = 0;\n\t\t\tif (!vt.empty())\n\t\t\t\tno = vt.size();\n\t\t\ttree t;\n\t\t\tt.num = 0;\n\t\t\tt.left = -1;\n\t\t\tt.right = -1;\n\t\t\tvt.push_back(t);\n\t\t\tvt[no].num = num;\n\t\t\tvt[no].left = saiki(s.substr(1, i - 3), vt);\n\t\t\tvt[no].right = saiki(s.substr(idx + 2, s.length() - idx - 3), vt);\n\t\t\treturn no;\n\t\t}\n\t}\n\treturn -1;\n}\nint saiki2(int a, int b, vector<tree> &vt3) {\n\tint no = 0;\n\tif(!vt3.empty())\n\tno=vt3.size();\n\ttree t;\n\tt.num = 0;\n\tt.left = -1;\n\tt.right = -1;\n\tvt3.push_back(t);\n\tvt3[no].num =tree1[a].num + tree2[b].num;\n\tif (tree1[a].left != -1 && tree2[b].left != -1)\n\t\tvt3[no].left = saiki2(tree1[a].left, tree2[b].left, vt3);\n\tif (tree1[a].right != -1 && tree2[b].right != -1)\n\t\tvt3[no].right = saiki2(tree1[a].right, tree2[b].right, vt3);\n\treturn no;\n}\n\nstring saiki3(vector<tree> vt,int no) {\n\tif (vt.size() < no)\n\t\treturn \"\";\n\tstring s = \"[\" + to_string(vt[no].num) + \"]\";\n\tstring ret=\"\";\n\tif (vt[no].left == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].left) + \")\";\n\tret += s;\n\tif (vt[no].right == -1)\n\t\tret += \"()\";\n\telse\n\t\tret += \"(\" + saiki3(vt, vt[no].right) + \")\";\n\treturn ret;\n}\n\nint main() {\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tsaiki(s1,tree1);\n\tsaiki(s2,tree2);\n\tsaiki2(0, 0,tree3);\n\tcout<<saiki3(tree3,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct no{\n  int key;\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s,t;\nint n,x;\nvector<int>a[2];\nvoid mae(string q){\n  a[n].push_back('(');\n  for(int i=0;i<(int)q.size();i++)\n    if(q[i]=='('&&q[i+1]==')')\n      q.erase(q.begin()+i,q.begin()+i+2),i--;\n  for(int i=0;i<q.size();i++){\n    if(q[i]=='['){\n      int p=0;i++;\n      while(isdigit(q[i]))p*=10,p+=q[i++]-'0';\n      a[n].push_back(p+100);\n    }\n    else a[n].push_back(q[i]);\n  }\n  a[n].push_back(')');\n}\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1,o;if(l+1>=r+1){cout<<1<<endl;exit(0);}\n  for(int i=l+1;i<=r-1;i++){\n    if((char)a[n][i]=='(')p++;\n    else if((char)a[n][i]==')')p--;\n    else if(a[n][i]>=100&&!p){\n      o=a[n][i]-100;\n      c=i;\n      break;\n    }\n  }\n  po->key=o;\n  if(l+1!=c)po->left=con(l+1,c);\n  if(r-1!=c+1)po->right=con(c+1,r-1);\n  return po;\n}\nstring df(int q){\n  if(!q)return \"0\";\n  string y;\n  while(q){\n    y+=q%10+'0';\n    q/=10;\n  }\n  reverse(y.begin(),y.end());\n  return y;\n}\nstring init(node aa,node b){\n  int t1=0,t2=0;\n  string l,r,xx=df(aa->key+b->key);\n  if(aa->left!=NULL&&b->left!=NULL)\n    l=init(aa->left,b->left),t1++;\n  if(aa->right!=NULL&&b->right!=NULL)\n    r=init(aa->right,b->right),t2++;\n  if(!t1&&!t2)return \"()[\"+xx+\"]()\";\n  else if(t2&&!t1)return \"()[\"+xx+\"](\"+r+\")\";\n  else if(t1&&!t2)return \"(\"+l+\")[\"+xx+\"]()\";\n  else return \"(\"+l+\")[\"+xx+\"](\"+r+\")\";\n}\nmain(){\n  string s1;\n  cin>>s>>t;\n  n=0;mae(s);\n  n=1;mae(t);\n  n=0;node p1=con(0,a[0].size());\n  n=1;node p2=con(0,a[1].size());\n  cout<<init(p1,p2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define repr(i, a, b) for (int i = (int)(a - 1); i >= b; i--)\n#define rep(i, n) repl(i, 0, n)\n#define each(itr, v) for (auto itr : v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(), (x).end()\n#define dbg(x) cout << #x \" = \" << x << endl\n#define dbgv(i, a, v) \\\n  rep(i, a) { cout << v[i] << ((i < a - 1) ? ' ' : '\\n'); }\n#define maxch(x, y) x = max(x, y)\n#define minch(x, y) x = min(x, y)\n#define uni(x) x.erase(unique(all(x)), x.end())\n#define exist(x, y) (find(all(x), y) != x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define INF INT_MAX / 3\n\nstring toArray(string a, string b) {\n  if (a.size() == 0 || b.size() == 0) return \"\";\n  int pr, qr, pi, pj, qi, qj;\n  {\n    int l = 1, i = 1;\n    string s = a;\n    while (l > 0 && i < s.size()) {\n      if (s[i] == '(')\n        l++;\n      else if (s[i] == ')')\n        l--;\n      i++;\n    }\n    int j = i + 1, r = 0;\n    while ('0' <= s[j] && s[j] <= '9') {\n      r = r * 10 + (s[j] - '0');\n      j++;\n    }\n    pr = r, pi = i, pj = j;\n  }\n  {\n    int l = 1, i = 1;\n    string s = b;\n    while (l > 0 && i < s.size()) {\n      if (s[i] == '(')\n        l++;\n      else if (s[i] == ')')\n        l--;\n      i++;\n    }\n    int j = i + 1, r = 0;\n    while ('0' <= s[j] && s[j] <= '9') {\n      r = r * 10 + (s[j] - '0');\n      j++;\n    }\n    qr = r, qi = i, qj = j;\n  }\n  string ret = \"(\";\n  ret += toArray(a.substr(1, pi - 2), b.substr(1, qi - 2));\n  ret += \")[\" + to_string(pr + qr) + \"](\";\n  ret += toArray(a.substr(pj + 2, a.size() - pj - 3),b.substr(qj + 2, b.size() - qj - 3));\n  return ret + \")\";\n}\n\nint main() {\n  cin.sync_with_stdio(false);\n  string a, b;\n  cin >> a >> b;\n  cout << toArray(a, b) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\n\tnode.emplace_back(Node());\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tfor (auto i : x) {\n\t\tcerr << i.num << ' ' << i.r << ' ' << i.l << endl;\n\t}\n\n\tstring ans = merge(x,0,y,0);\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Node{\n\tint l, r;\n\tint num;\n\tNode(){\n\t\tl = r = -1;\n\t}\n};\n\nint number(string& s, int& i){\n\tint res = 0;\n\twhile(isdigit(s[i])){\n\t\tres *= 10;\n\t\tres += s[i] - '0';\n\t\ti++;\n\t}\n\treturn res;\n}\n\nint dfs(vector<Node>& node, string& s, int l, int r){\n\tif(r - l == 0) return -1;\n\n\tnode.emplace_back(Node());\n\tint cur = node.size() - 1;\n\n\tint cnt = 0, i = l;\n\twhile(true){\n\t\tassert(i < s.size());\n\t\tif(s[i] == '(') cnt++;\n\t\telse if(s[i] == ')') cnt--;\n\t\telse if(cnt == 0){\n\t\t\tassert(cur < node.size());\n\t\t\tnode[cur].l = dfs(node, s, l + 1, i - 1);\n\t\t\ti++;\n\t\t\tnode[cur].num = number(s, i);\n\t\t\ti++;\n\t\t\tnode[cur].r = dfs(node, s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn cur;\n}\n\nstring merge(vector<Node>& x, int xi, vector<Node>& y, int yi){\n\tif(xi == -1 or yi == -1) return \"\";\n\n\tstring left = merge(x, x[xi].l, y, y[yi].l);\n\tstring num = to_string(x[xi].num + y[yi].num);\n\tstring right = merge(x, x[xi].r, y, y[yi].r);\n\tshow(  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\")\n\n\treturn  \"(\" + left + \")\" + \"[\" + num + \"]\" + \"(\" + right + \")\";\n}\n\nint main(){\n    string a,b;\n    cin >> a >> b;\n\n\tvector<Node> x, y;\n\tdfs(x, a, 0, a.size());\n\tdfs(y, b, 0, b.size());\n\n\tstring ans = merge(x,0,y,0);\n\tcout << merge(x, 0, y, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n \nusing namespace std;\n \n#define Node Tree\n \nstruct Node {\n  bool root;\n  bool child[2];\n  Node *next[2];\n  string id;\n  Node() {\n    child[0] = child[1] = false;\n    root = false;\n    id = \"\";\n  }\n};\n \nvoid rec1(Tree *t);\n \nstring context;\nint pos;\nvoid rec2(Tree *t) {\n  //cout << \"pos = \" << pos << \" \" << context[pos] << endl;\n  if( pos < (int)context.size() ) {\n    if( context[pos] == ')' ) {\n      //++pos;/////\n      t->child[0] = t->child[1] = false;\n      t->id = \"leaf\";\n    } else {\n      //++pos;\n      rec1(t);\n      //++pos;\n    }\n  } else {\n    t->child[0] = t->child[1] = false;\n    t->id = \"leaf\";\n  }\n}\n \nstring getID() {\n  string id = \"\";\n  while( pos < (int)context.size() && context[pos] != ']' ) {\n    id += context[pos];\n    ++pos;\n  }\n  return id;\n}\n \nvoid rec1(Tree *t) {\n  //cout << \"pos2 = \" << pos << \" \" << context[pos] << endl;\n  if( pos < (int)context.size() ) {\n    assert( context[pos] == '(' );\n    ++pos; // (\n    t->child[0] = true;\n    t->next[0] = new Tree;\n    rec2(t->next[0]);\n    assert( pos < (int)context.size() );\n    assert( context[pos] == ')');\n    ++pos; // )\n    assert( context[pos] == '[' );\n    ++pos; // [\n    string id = getID();\n    //cout << \"[[\" << id << \"]]\" << endl;\n    t->id = id;\n    assert( context[pos] == ']' );\n    ++pos; // ]\n    ++pos; // (\n    t->child[1] = true;\n    t->next[1] = new Tree;\n    rec2(t->next[1]);\n    ++pos; // )\n \n  } else {\n    t->child[0] = t->child[1] = false;\n    t->id = \"leaf\";\n  }\n}\n \n \nstring tree_walk(Tree *t,int depth) {\n  string ret = \"\";\n  //cout << '(';\n  ret += \"(\";\n  if(t->child[0]) ret += tree_walk(t->next[0],depth+1);\n  else {\n    //cout << \"()\";\n    ret += \"()\";\n  }\n  //cout << \"[\" << (t->id) << \"]\";\n  ret += ( \"[\" + (t->id) + \"]\" );\n  if(t->child[1]) ret += tree_walk(t->next[1],depth+1);\n  else ret += \"()\";//cout << \"()\";\n  //cout << ')';\n  ret += \")\";\n  return ret;\n}\n \nvoid getTree(string s,Tree *t) {\n  pos = 0;\n  context = s;\n  rec1(t);\n}\n \nstring itos(int i) {\n  stringstream ss;\n  ss << i;\n  return ss.str();\n}\n \nvoid dfs(Tree *t1,Tree *t2,Tree *t) {\n  int v1 = (atoi)(t1->id.c_str());\n  int v2 = (atoi)(t2->id.c_str());\n  t->id = itos(v1+v2);\n  \n  if( t1->next[0]->id != \"leaf\" && \n      t2->next[0]->id != \"leaf\" ) {\n    t->child[0] = true;\n    t->next[0] = new Tree;\n    dfs(t1->next[0],t2->next[0],t->next[0]);\n  } else {\n    t->child[0] = false;\n  }\n \n  \n  if( t1->next[1]->id != \"leaf\" && \n      t2->next[1]->id != \"leaf\" ) {\n    t->child[1] = true;\n    t->next[1] = new Tree;\n    dfs(t1->next[1],t2->next[1],t->next[1]);\n  } else {\n    t->child[1] = false;\n  }\n  \n}\n \nint main() {\n  string s;\n  cin >> s;\n  Tree t1,t2;\n  getTree(s,&t1);\n  //tree_walk(&t1,0); cout << endl;\n  cin >> s;\n  getTree(s,&t2);\n  //tree_walk(&t2,0);cout << endl;\n  Tree answer;\n  dfs(&t1,&t2,&answer);\n \n  string ans = tree_walk(&answer,0);\n  cout << ans.substr(1,(int)ans.size()-2) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nstruct Node {\n    Node *ch[2];\n    int num;\n};\n\nint number(char *&p) {\n    int res = 0;\n    while (isdigit(*p)) {\n        res = res * 10 + *p - '0';\n        ++p;\n    }\n    return res;\n}\n\nNode *tree(char *&p) {\n    Node *res = new Node;\n    for (int i = 0; i < 2; i++) {\n        if (i) {\n            ++p;\n            res->num = number(p);\n            ++p;\n        }\n        if (p[1] == ')') {\n            p += 2;\n            res->ch[i] = nullptr;\n        } else {\n            ++p;\n            res->ch[i] = tree(p);\n            ++p;\n        }\n    }\n    return res;\n}\n\nvoid print(Node *s, Node *t) {\n    printf(\"(\");\n    for (int i = 0; i < 2; i++) {\n        if (i) printf(\")[%d](\", s->num + t->num);\n        if (s->ch[i] && t->ch[i]) print(s->ch[i], t->ch[i]);\n    }\n    printf(\")\");\n}\n\nint main() {\n    char s[1010], t[1010];\n    cin >> s >> t;\n    char *ss = s, *tt = t;\n    print(tree(ss), tree(tt));\n    cout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\n#include <array>\n#include <float.h>\n#include <memory>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <random>\n#include <map>\n#include <set>\n\n#pragma warning(disable:4996)\n\nusing namespace std;\nusing Iterator = std::string::iterator;\n\nstruct Tree {\n  int value_;\n  Tree* left_ = nullptr, *right = nullptr;\n  Tree(int Value, Tree* l, Tree* r) {\n    value_ = Value;\n    left_ = l;\n    right = r;\n  }\n};\n\nTree * CreateTree(Iterator& Begin, Iterator &End) {\n  if (Begin == End) {\n    return nullptr;\n  }\n  int idx = 0;\n  Iterator lb = Begin + 1, le, rb, re = End;\n  for (; Begin != End; ++Begin) {\n    if (*Begin == '(')++idx;\n    else if (*Begin == ')')--idx;\n    if (idx == 0) {\n      le = Begin;\n      string num;\n      for (++++Begin;Begin!=End&& *Begin != ']'; ++Begin) {\n        num += *Begin;\n      }\n      rb = Begin + 2;\n      if (rb > End) {\n        rb = End;\n      }\n      return new Tree(stoi(num), CreateTree(lb, le), CreateTree(rb, re));\n    }\n  }\n}\n\nTree* AddTree(Tree* a, Tree* b) {\n  Tree* ret = new Tree(a->value_ + b->value_, nullptr, nullptr);\n  if (a->left_ != nullptr&&b->left_ != nullptr) {\n    ret->left_ = AddTree(a->left_, b->left_);\n  }\n  if (a->right != nullptr&&b->right != nullptr) {\n    ret->right = AddTree(a->right, b->right);\n  }\n  return ret;\n}\n\nstring ToString(Tree* t) {\n  return \"(\" + (t->left_ == nullptr ? \"\" : ToString(t->left_)) + \")[\" + to_string(t->value_) + \"](\" + (t->right == nullptr ? \"\" : ToString(t->right)) + \")\";\n}\n\nint main() {\n  string a, b;\n  cin >> a >> b;\n  auto ab = a.begin(), ae = a.end(), bb = b.begin(), be = b.end();\n  auto *at = CreateTree(ab, ae), *bt = CreateTree(bb, be);\n  auto *ans = AddTree(at, bt);\n  cout << ToString(ans) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nstruct BinGraph;\nstruct BinGraph {\n    ll val;\n    BinGraph *lch, *rch;\n    BinGraph(ll val, BinGraph* lch, BinGraph* rch) : val(val), lch(lch), rch(rch) {}\n    void out() {\n        cout << \"(\";\n        if (lch != NULL) lch->out();\n        cout << \")\";\n        cout << \"[\";\n        cout << val;\n        cout << \"]\";\n        cout << \"(\";\n        if (rch != NULL) rch->out();\n        cout << \")\";\n    }\n};\n\nBinGraph* merge(BinGraph* g1, BinGraph* g2) {\n    if (g1 == NULL) return NULL;\n    if (g2 == NULL) return NULL;\n    return new BinGraph(g1->val+g2->val, merge(g1->lch, g2->lch), merge(g1->rch, g2->rch));\n}\n\nclass Perser {\n    const string s;\n    ll pos;\npublic:\n    Perser(const string& s) : s(s), pos(0) {}\n    BinGraph* perse() {\n        return G();\n    }\n    BinGraph* G() {\n        assert(pos < s.size());\n        if (s[pos] == ')') {\n            return NULL;\n        }\n        else {\n            read_char('(');\n            BinGraph* lch = G();\n            read_char(')');\n            read_char('[');\n            ll val = number();\n            read_char(']');\n            read_char('(');\n            BinGraph* rch = G();\n            read_char(')');\n            return new BinGraph(val, lch, rch);\n        }\n    }\n    ll number() {\n        string res = \"\";\n        while (pos < s.size() && isdigit(s[pos])) {\n            res += s[pos];\n            ++pos;\n        }\n        return stoll(res);\n    }\n    void read_char(char c) {\n        assert(pos < s.size() && s[pos] == c);\n        ++pos;\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    string s1, s2; cin >> s1 >> s2;\n    BinGraph* G1 = Perser(s1).perse();\n    BinGraph* G2 = Perser(s2).perse();\n    merge(G1, G2)->out();\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 10000000\nusing namespace std;\nstruct data{\n  int num,l,r;\n};\nvector<data> At,Bt;\n\nbool check(int s,int t, string &str){\n  stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')'&&st.empty())return 0;  \n    if(str[i]==')') st.pop();\n  }\n  return st.empty();\n}\n\nint get_num(string &str,int &idx){\n  int res=0;\n  while(isdigit(str[idx]))res=res*10+str[idx++]-'0';\n  return res;\n}\n\n\nint get_root(int s,int t,string &str){\n  stack <char> st;\n  for(int i=s;i<=t;i++){\n    if(st.empty()&&isdigit(str[i])) return i;\n    if(str[i]=='(') st.push(str[i]);\n    if(str[i]==')') st.pop();\n  }\n  assert(0);\n}\n\n\nvoid make_tree(int s,int t,vector<data>&tree,string &str,int idx){\n  while(s<t&&check(s,t,str)) s++,t--;\n  if(s>=t)return;\n  s--,t++;\n  int root=get_root(s,t,str);\n\n  tree.push_back((data){-1,-1,-1});\n  tree[idx].l=tree.size()-1;\n  make_tree(s,root-2,tree,str,tree.size()-1);\n\n  tree[idx].num=get_num(str,root);\n\n  tree.push_back((data){-1,-1,-1});\n  tree[idx].r=tree.size()-1;\n  make_tree(root+1,t,tree,str,tree.size()-1);\n}\n\nstring make_str(int a,int b){\n  if(a==-1||b==-1||At[a].num<0||Bt[b].num<0) return \"\";\n  int num=At[a].num+Bt[b].num;\n  string str;\n  while(num) str=(char)((num%10)+'0')+str,num/=10;\n  return \"(\"+make_str(At[a].l,Bt[b].l)+\")\"+\"[\"+str+\"]\"+\"(\"+make_str(At[a].r,Bt[b].r)+\")\";\n}\n\nint main(){\n  string A,B;\n  cin>>A>>B;\n  At.clear();\n  Bt.clear();\n  At.push_back((data){-1,-1,-1});\n  Bt.push_back((data){-1,-1,-1});\n  make_tree(0,A.size()-1,At,A,0);\n  make_tree(0,B.size()-1,Bt,B,0);\n  cout <<make_str(0,0)<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \nstruct Tree {\n    Tree *l, *r;\n    int v;    \n};\n  \nTree *tree[2], *ntree;\n  \nTree* make_node(int v)\n{\n    Tree *t = new Tree;\n    t->l = t->r = NULL;\n    t->v = v;\n    return t;\n}\n  \nvoid init(int ra, int rb)\n{    \n    tree[0] = make_node(ra);\n    tree[1] = make_node(rb);\n    ntree = make_node(-1);\n}\n  \nint get_num(string &s, int L, int R)\n{\n    L++; R--;\n    string str;\n    for (int i = L; i <= R; i++) {\n        str += s[i];\n    }\n    stringstream ss(str);\n    int num;\n    ss >> num;\n    return num;\n}\n  \nint get_node_left(int &L, int &R, string &s)\n{\n    int p = 0;\n    for (int i = R; i >= L; i--) {\n        if (s[i] == ')') {\n            p++;\n        } else if (s[i] == '(') {\n            p--;\n        }\n        if (p == 0) {\n            if (i - 1 >= 0 && s[i-1] == ']') {\n                int l = -1;\n                for (int j = i-1; j >= L; j--) {\n                    if (s[j] == '[') {\n                        l = j;\n                        break;\n                    }\n                }\n                L = l-1; R = i;\n                return get_num(s, l, i-1);\n            }\n            return -1;\n        }\n    }\n    return -1;\n}\n  \nint get_node_right(int &L, int &R, string &s)\n{\n    int p = 0;\n    for (int i = L; i <= R; i++) {\n        if (s[i] == '(') {\n            p++;\n        } else if (s[i] == ')') {\n            p--;\n        }\n        if (p == 0) {\n            if (i + 1 <= R && s[i+1] == '[') {\n                int r = -1;\n                for (int j = i+1; j <= R; j++) {\n                    if (s[j] == ']') {\n                        r = j;\n                        break;\n                    }\n                }\n                L = i; R = r+1;\n                return get_num(s, i+1, r);\n            }\n            return -1;\n        }\n    }    \n    return -1;\n}\n  \nvoid add_left(int v, Tree *t)\n{\n    t->l = make_node(v);\n}\n  \nvoid add_right(int v, Tree *t)\n{\n    t->r = make_node(v);\n}\n  \nvoid dfs(int L, int R, string &s, Tree *t)\n{\n    int l = 0, r = s.size()-1;\n    L = L - 1; R = R + 1;\n    int vl = get_node_left(l, L, s);\n    int vr = get_node_right(R, r, s);\n    if (vl != -1) {\n        add_left(vl, t);\n        dfs(l, L, s, t->l);        \n    }\n    if (vr != -1) {\n        add_right(vr, t);\n        dfs(R, r, s, t->r);\n    }\n}\n  \nvoid make_sum_tree(Tree *t1, Tree *t2, Tree *t3)\n{\n    if (t1 != NULL && t2 != NULL) {\n        t3->v = t1->v + t2->v;\n        if (t1->l != NULL && t2->l != NULL) {\n            t3->l = make_node(-1);\n            make_sum_tree(t1->l, t2->l, t3->l);\n        }\n        if (t1->r != NULL && t2->r != NULL) {\n            t3->r = make_node(-1);\n            make_sum_tree(t1->r, t2->r, t3->r);\n        }\n    }\n}\n  \nstring i2s(int v)\n{\n    stringstream ss;\n    ss << v;\n    string s;\n    ss >> s;\n    return s;\n}\n  \nstring make_tree(Tree *t)\n{\n    string res, l = \"()\", r = \"()\";\n    if (t != NULL) {\n        res = \"[\" + i2s(t->v) + \"]\";\n    }\n    if (t->l != NULL) {\n        l = \"(\" + make_tree(t->l) + \")\";\n    } \n         \n    if (t->r != NULL) {\n        r = \"(\" + make_tree(t->r) + \")\";\n    }\n    return l + res + r;\n}\n  \nvoid solve(string &a, string &b)\n{\n    int La = 0, Lb = 0;\n    int Ra = a.size()-1, Rb = b.size()-1;\n    int root_a = get_node_left(La, Ra, a);\n    int root_b = get_node_left(Lb, Rb, b);\n    init(root_a, root_b);\n    dfs(La, Ra, a, tree[0]);\n    dfs(Lb, Rb, b, tree[1]);    \n    make_sum_tree(tree[0], tree[1], ntree);\n    cout << make_tree(ntree) << endl;\n}\n  \nint main()\n{\n    string a, b;\n    cin >> a >> b;\n    solve(a, b);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstring A, B;\n\nint get(string& s, int& idx)\n{\n  int num = 0;\n  while(isdigit(s[idx])) num = num * 10 + s[idx++] - '0';\n  return (num);\n}\n\nvoid dfs(int& lIdx, int& rIdx)\n{\n  bool left = A[lIdx] == '(';\n  bool right = B[rIdx] == '(';\n  bool mid = left & right;\n  if(!left & !right) return;\n  lIdx += left;\n  rIdx += right;\n  if(mid) cout << \"(\";\n  dfs(lIdx, rIdx);\n  if(mid) cout << \")\";\n  lIdx += left * 2;\n  rIdx += right * 2;\n  int value = get(A, lIdx) + get(B, rIdx);\n  if(mid) cout << \"[\" << value << \"]\";\n  lIdx += left * 2;\n  rIdx += right * 2;\n  if(mid) cout << \"(\";\n  dfs(lIdx, rIdx);\n  if(mid) cout << \")\";\n  lIdx += left;\n  rIdx += right;\n}\n\nint main()\n{\n  cin >> A;\n  cin >> B;\n  int leftIdx = 0, rightIdx = 0;\n  dfs(leftIdx, rightIdx);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint st[100000], tt[100000];\n\nchar *p;\nvoid analyze(int *dst, int i) {\n    switch(*p) {\n        case ')':\n            p++;\n            return;\n        case '(':\n            p++;\n            analyze(dst, i*2+1);\n            break;\n    }\n    p++;\n    dst[i] = 0;\n    while('0' <= *p && *p <= '9')\n        dst[i]*=10, dst[i]+=(*p-'0'), p++;\n    p++;\n    p++;\n\n    analyze(dst, i*2+2);\n    p++;\n}\n\nvoid print_tree(int *tr, int i) {\n    printf(\"(\");\n    if(tr[i*2+1] != -1) print_tree(tr, i*2+1);\n    printf(\")\");\n\n    printf(\"[\");\n    printf(\"%d\", tr[i]);\n    printf(\"]\");\n\n    printf(\"(\");\n    if(tr[i*2+2] != -1) print_tree(tr, i*2+2);\n    printf(\")\");\n}\n\nint main(void) {\n    memset(st, 0xFF, sizeof(st));\n    memset(tt, 0xFF, sizeof(tt));\n\n    char s[2000], t[2000];\n    scanf(\"%s%s\",s,t);\n    p = s;\n    analyze(st, 0);\n    p = t;\n    analyze(tt, 0);\n\n    for(int i=0; i<100000; i++)\n        if(st[i] == -1 || tt[i] == -1) st[i] = -1;\n        else st[i] += tt[i];\n\n    print_tree(st, 0);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nstruct BinGraph;\nstruct BinGraph {\n    ll val;\n    BinGraph *lch, *rch;\n    BinGraph(ll val, BinGraph* lch, BinGraph* rch) : val(val), lch(lch), rch(rch) {}\n    void out() {\n        cout << \"(\";\n        if (lch != NULL) lch->out();\n        cout << \")\";\n        cout << \"[\";\n        cout << val;\n        cout << \"]\";\n        cout << \"(\";\n        if (rch != NULL) rch->out();\n        cout << \")\";\n    }\n};\n\nBinGraph* merge(BinGraph* g1, BinGraph* g2) {\n    if (g1 == NULL) return NULL;\n    if (g2 == NULL) return NULL;\n    return new BinGraph(g1->val+g2->val, merge(g1->lch, g2->lch), merge(g1->rch, g2->rch));\n}\n\nclass Perser {\n    const string s;\n    ll pos;\npublic:\n    Perser(const string& s) : s(s), pos(0) {}\n    BinGraph* perse() {\n        return G();\n    }\n    BinGraph* G() {\n        assert(pos < s.size());\n        if (s[pos] == ')') {\n            return NULL;\n        }\n        else {\n            read_char('(');\n            BinGraph* lch = G();\n            read_char(')');\n            read_char('[');\n            ll val = number();\n            read_char(']');\n            read_char('(');\n            BinGraph* rch = G();\n            read_char(')');\n            return new BinGraph(val, lch, rch);\n        }\n    }\n    ll number() {\n        string res = \"\";\n        while (pos < s.size() && isdigit(s[pos])) {\n            res += s[pos];\n            ++pos;\n        }\n        return stoll(res);\n    }\n    void read_char(char c) {\n        assert(pos < s.size() && s[pos] == c);\n        ++pos;\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    string s1, s2; cin >> s1 >> s2;\n    BinGraph* G1 = Perser(s1).perse();\n    BinGraph* G2 = Perser(s2).perse();\n    merge(G1, G2)->out();\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator State;\n\nstruct node{\n    int item;\n    struct node *left, *right;\n};\n\nnode *make_node(){\n    node *d = new node;\n    d -> left = NULL;\n    d -> right = NULL;\n    return d;\n}\n\nint number(State &begin){\n    int ret = 0;\n    while (isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nnode *read(State &begin){\n    node *d = make_node();\n    begin++;\n    if (*begin != ')') d -> left = read(begin);\n    begin += 2;\n    d -> item = number(begin);\n    begin += 2;\n    if (*begin != ')') d -> right = read(begin);\n    begin++;\n    return d;\n}\n\nvoid out(node *d1, node *d2){\n    cout << \"(\";\n    if (d1 -> left != NULL && d2 -> left != NULL) out(d1 -> left, d2 -> left);\n    printf(\")[%d](\", d1 -> item + d2 -> item);\n    if (d1 -> right != NULL && d2 -> right != NULL) out(d1 -> right, d2 -> right);\n    cout << \")\";\n}\n\nint main() {\n    string s1, s2;\n    cin >> s1 >> s2;\n    node *r1, *r2;\n    r1 = read(s1.begin());\n    r2 = read(s2.begin());\n    out(r1, r2);\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst long double PI = acos(-1);\nconstexpr long double EPS = 1e-15;\nconstexpr int inf = 2e9;\nconstexpr ll INF = 2e18;\nconstexpr ll MOD = 1e9+7;\nconstexpr ll MOD1 = 998244353;\ntypedef pair<ll,ll> P;\n\n//#define all(v) (v).begin(), (v).end()\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) rep(i,0,n)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n//#define mp make_pair\n\nstruct Tree{\n  int num = 0;\n  Tree *left;\n  Tree *right;\n  Tree() {\n    num = 0;\n    left = NULL;\n    right = NULL;\n  }\n  Tree(Tree *l,int m,Tree *r) {\n    num = m;\n    left = l;\n    right = r;\n  }\n};\n\n// void findroot(string s, int &k) {\n//   int cnt = 1;\n//   for (int i = 1; i < sz(s); i++) {\n//     if (s[i] == '(') cnt++;\n//     else if (s[i] == ')') cnt--;\n\n//     if (cnt == 0) {\n//       i+=2;\n//       int num = 0;\n//       while ('0' <= s[i] && s[i] <= '9') {\n//         num *= 10;\n//         num += (s[i] - '0');\n//         i++;\n//       }\n//       k = num;\n//       return;\n//     }\n//   }\n// }\n\nint k;\nTree *maketree(Tree *t, string s) {\n  Tree *tmp = new Tree();\n\n  int middle = 0;\n  k++;\n  if (s[k] == ')') ;\n  else tmp->left = maketree(t, s);\n  k += 2;\n\n  while ('0' <= s[k] && s[k] <= '9') {\n    middle *= 10;\n    middle += (s[k] - '0');\n    k++;\n  }\n  \n  k+=2;\n  if (s[k] == ')') ;\n  else tmp->right = maketree(t, s);\n  k++;\n\n  tmp->num = middle;\n  return tmp;\n}\n\nvoid dfs(Tree *t1, Tree *t2) {\n  cout << '(';\n  if (t1->left != NULL && t2->left != NULL) {\n    dfs(t1->left, t2->left);\n  }\n  cout << ')';\n  cout << '[';\n  cout << t1->num + t2->num;\n  cout << ']';\n  cout << '(';\n  if (t1->right != NULL && t2->right != NULL) {\n    dfs(t1->right, t2->right);\n  }\n  cout << ')';\n}\n\nvoid solve() {\n  string a,b;\n  int r1,r2;\n  cin >> a >> b;\n  Tree *t1 = new Tree();\n  Tree *t2 = new Tree();\n  k = 0;\n  t1 = maketree(t1,a);\n  k = 0;\n  t2 = maketree(t2,b);\n  dfs(t1,t2);\n  cout << endl;\n}\n\nint main(){\n  // int n;\n  // cin >> n;\n  // REP(i,n) {\n  //   solve();\n  // }\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct tree{\n  vector<shared_ptr<tree> >chs;\n  int num;\n  tree():chs(2,nullptr),num(0){\n  }\n};\n\nint getnum(string st,int &a){\n  int num=0;\n  assert(isdigit(st[a]));\n  while(a<st.size()&&isdigit(st[a])){\n    num*=10;\n    num+=st[a]-'0';\n    a++;\n  }\n  assert(st[a]==']');\n  a++;\n  return num;\n}\nshared_ptr < tree > input(string st,int &a){\n  //cout<<a<<endl;\n  assert(a<=st.size());\n  if(a==st.size()){\n    a++;\n    return nullptr;\n  }else if(st[a]!='('){\n    assert(st[a]==')');\n    return nullptr;\n  }else{\n    shared_ptr<tree> t(make_shared<tree>());\n    assert(t->chs.size()==2);\n    assert(st[a]=='(');\n    a++;\n    //cout<<\"moguru\"<<endl;\n    t->chs[0]=input(st,a);\n    assert(st[a]==')');\n    a++;\n    //cout<<\"detekita\"<<endl;\n    assert(st[a]=='[');\n    a++;\n    //cout<<\"Num is\"<<endl;\n    t->num=getnum(st,a);\n    //cout<<t->num<<endl;\n    assert(st[a]=='(');\n    a++;\n    //cout<<\"moguru2\"<<endl;\n    t->chs[1]=input(st,a);\n    assert(st[a]==')');\n    a++;\n    //cout<<\"detekita2\"<<endl;\n    return t;\n  }\n}\n\nstring ans;\nvoid solve(shared_ptr<tree>&l,shared_ptr<tree>&r){\n  \n    ans.push_back('(');\n    if(l->chs[0]==nullptr||r->chs[0]==nullptr){\n  }else{\n    solve(l->chs[0],r->chs[0]);\n    \n  }\n  \n  ans.push_back(')');\n  ans.push_back('[');\n  ans+=(to_string(l->num+r->num));\n  ans.push_back(']');\n    ans.push_back('(');\n  if(l->chs[1]==nullptr||r->chs[1]==nullptr){\n\n  }else{\n    solve(l->chs[1],r->chs[1]);\n  }\n  \n    ans.push_back(')');\n}\n\nint main(){\n  string A,B;cin>>A>>B;\n  vector<shared_ptr<tree>>ts(2,(make_shared<tree>()));\n  int a=0;\n  ts[0]=input(A,a);\n  a=0;\n  ts[1]=input(B,a);\n  solve(ts[0],ts[1]);\n  cout<<ans<<endl;    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for (int i = (int)(s); i < (int)(n); i++)\nconst ll mod = ll(1e9) + 7;\nconst int INF = int(1e9);\n\nint idxa = 0, idxb = 0;\n\nint calc(string &A, string &B)\n{\n    string tmpa, tmpb;\n    idxa++;\n    idxb++;\n    while (A[idxa] != ']')\n    {\n        tmpa.push_back(A[idxa++]);\n    }\n    while (B[idxb] != ']')\n    {\n        tmpb.push_back(B[idxb++]);\n    }\n    //cout << tmpa << \" \" << tmpb << endl;\n    return stoi(tmpa) + stoi(tmpb);\n}\nint proceed(int idx, string &C)\n{\n    int cnt = 1;\n    while (1)\n    {\n        idx++;\n        if (C[idx] == ')')\n            cnt--;\n        if (C[idx] == '(')\n            cnt++;\n        if (cnt < 0)\n            break;\n    }\n    return idx;\n}\n\nint main()\n{\n    string A, B;\n    cin >> A >> B;\n    string ans;\n    while (idxa < A.size())\n    {\n        if (A[idxa] == B[idxb])\n        {\n            if (A[idxa] == '[')\n            {\n                ans.push_back('[');\n                int tmp = calc(A, B);\n                ans += to_string(tmp);\n                ans.push_back(']');\n            }\n            else\n                ans.push_back(A[idxa]);\n        }\n        else\n        {\n            if (A[idxa] == '(')\n                idxa = proceed(idxa, A);\n            else\n            {\n                idxb = proceed(idxb, B);\n            }\n            ans.push_back(A[idxa]);\n        }\n        idxa++;\n        idxb++;\n        //cout << ans << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for (int i = (int)(s); i < (int)(n); i++)\nconst ll mod = ll(1e9) + 7;\nconst int INF = int(1e9);\n\nint idxa = 0, idxb = 0;\n\nint calc(string &A, string &B)\n{\n    string tmpa, tmpb;\n    idxa++;\n    idxb++;\n    while (A[idxa] != ']')\n    {\n        tmpa.push_back(A[idxa++]);\n    }\n    while (B[idxb] != ']')\n    {\n        tmpb.push_back(B[idxb++]);\n    }\n    //cout << tmpa << \" \" << tmpb << endl;\n    return stoi(tmpa) + stoi(tmpb);\n}\nint proceed(int idx, string &C)\n{\n    int cnt = 1;\n    while (1)\n    {\n        idx++;\n        if (C[idx] == ')')\n            cnt--;\n        if (C[idx] == '(')\n            cnt++;\n        if (cnt < 0)\n            break;\n    }\n    return idx;\n}\n\nint main()\n{\n    string A, B;\n    cin >> A >> B;\n    string ans;\n    while (idxa < A.size())\n    {\n        if (A[idxa] == B[idxb])\n        {\n            if (A[idxa] == '[')\n            {\n                ans.push_back('[');\n                int tmp = calc(A, B);\n                ans += to_string(tmp);\n                ans.push_back(']');\n            }\n            else\n                ans.push_back(A[idxa]);\n        }\n        else\n        {\n            if (A[idxa] == '(')\n                idxa = proceed(idxa, A);\n            else\n            {\n                idxb = proceed(idxb, B);\n            }\n            ans.push_back(A[idxa]);\n        }\n        idxa++;\n        idxb++;\n        //cout << ans << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2740&lang=jp\ntypedef long long ll;\n#define INF 1<<30\nusing namespace std;\n\nvoid solve(int& i1, int& i2, string& S1, string& S2, bool f1 = true, bool f2 = true) {\n\t/* \"(\" ~ )[x]( ~ ) */\n\tif (f1 && S1[i1] == '(') i1++;\n\tif (f2 && S2[i2] == '(') i2++;\n\tif (f1 && f2)cout << '(';\n\n\t/* ( \"~\" )[x]( ~ ) */\n\tif (S1[i1] == '(' || S2[i2] == '(') {\n\t\tsolve(i1, i2, S1, S2, S1[i1] == '(', S2[i2] == '(');\n\t}\n\n\t/* ( ~ \")\"[x]( ~ )  */\n\tif (f1 && S1[i1] == ')') i1++;\n\tif (f2 && S2[i2] == ')') i2++;\n\tif (f1&&f2) cout << ')';\n\n\t/* ( ~ )\"[x]\"( ~ ) */\n\t// \"[\"\n\tif (f1)i1++;\n\tif (f2)i2++;\n\t// \"x\"\n\tint x1 = 0;\n\twhile (f1 && S1[i1] != ']') {\n\t\tx1 = x1 * 10 + (S1[i1] - '0');\n\t\ti1++;\n\t}\n\tint x2 = 0;\n\twhile (f2&& S2[i2] != ']') {\n\t\tx2 = x2 * 10 + (S2[i2] - '0');\n\t\ti2++;\n\t}\n\t// \"]\"\n\tif (f1)i1++;\n\tif (f2)i2++;\n\n\tif (f1&&f2) { cout << '[' << x1 + x2 << ']'; }\n\n\t/* ( ~ )[x]\"(\" ~ ) */\n\tif (f1&&S1[i1] == '(') i1++;\n\tif (f2&&S2[i2] == '(') i2++;\n\tif (f1&&f2)cout << '(';\n\n\t/* ( ~ )[x]( \"~\" )*/\n\tif (S1[i1] == '(' || S2[i2] == '(') {\n\t\tsolve(i1, i2, S1, S2, S1[i1] == '(', S2[i2] == '(');\n\t}\n\n\t/* ( ~ )[x]( ~ \")\"*/\n\tif (f1&&S1[i1] == ')') i1++;\n\tif (f2&&S2[i2] == ')') i2++;\n\tif (f1&&f2)cout << ')';\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t/* input */\n\tstring A, B; cin >> A >> B;\n\n\t/* solve */\n\tint i1 = 0, i2 = 0;\n\tsolve(i1, i2, A, B);\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct node{\n    int value;\n    struct node *left,*right;\n};\n\ntypedef struct node node;\n\nnode *build(){\n    if(getchar()==')')return NULL; //skip (\n    node *res = (node *)malloc(sizeof(node));\n    if(res->left = build())getchar(); //skip )\n    scanf(\"[%d](\",&res->value);\n    if(res->right = build())getchar(); //skip )\n    return res;\n}\n\nnode *unite(node *a, node *b){\n    if(a==NULL || b==NULL)return NULL;\n    node *res = (node *)malloc(sizeof(node));\n    res->value = a->value+b->value;\n    res->left = unite(a->left, b->left);\n    res->right = unite(a->right, b->right);\n    return res;\n}\n\nvoid output(node *n){\n    if(n==NULL)return;\n    printf(\"(\");\n    output(n->left);\n    printf(\")[%d](\", n->value);\n    output(n->right);\n    printf(\")\");\n}\n\nint main(){\n    node *a = build();\n    getchar(); //skip \\n\n    node *b = build();\n    getchar(); //skip \\n\n    output(unite(a,b));\n    printf(\"\\n\");\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct node{\n    int value;\n    struct node *left,*right;\n};\n\ntypedef struct node node;\n\nnode *build(){\n    if(getchar()==')')return NULL; //skip (\n    node *res = (node *)malloc(sizeof(node));\n    if(res->left = build())getchar(); //skip )\n    scanf(\"[%d](\",&res->value);\n    if(res->right = build())getchar(); //skip )\n    return res;\n}\n\nnode *unite(node *a, node *b){\n    if(a==NULL || b==NULL)return NULL;\n    node *res = (node *)malloc(sizeof(node));\n    res->value = a->value+b->value;\n    res->left = unite(a->left, b->left);\n    res->right = unite(a->right, b->right);\n    return res;\n}\n\nvoid output(node *n){\n    if(n==NULL)return;\n    printf(\"(\");\n    output(n->left);\n    printf(\")[%d](\", n->value);\n    output(n->right);\n    printf(\")\");\n}\n\nint main(){\n    node *a = build();\n    getchar(); //skip \\n\n    node *b = build();\n    getchar(); //skip \\n\n    output(unite(a,b));\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2740: Rooted Tree for Misawa-san\n// 2018.1.7 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\ntypedef struct { int n; int l, r; } T;\nT node[2000]; int sz;\n\nchar a[1005], b[1005];\nchar ans[1500];\n\nvoid tree(char *p, int k, int update)\n{\n\tint f;\n\n\tif (*p++ != '(') return;\n\tif (*p == '(') {\n\t\tif (!update) node[k].l = sz++, tree(p, sz-1, update);\n\t\telse if (node[k].l > 0) tree(p, node[k].l, update);\n\t} else if (update) node[k].l = 0;\n\tf = 1; while (1) {\n\t\tif (*p == '(') f++;\n\t\telse if (*p == ')') { if (--f == 0) break; }\n\t\tp++;\n\t}\n\tp += 2;\t\t\t\t\t\t\t\t// skip \")[\"\n\tnode[k].n += atoi(p);\t\t\t\n\twhile (isdigit(*p)) p++;\n\tp += 2;\t\t\t\t\t\t\t\t// skip \"](\"\n\tif (*p == '(') {\n\t\tif (!update) node[k].r = sz++, tree(p, sz-1, update);\n\t\telse if (node[k].r > 0) tree(p, node[k].r, update);\n\t\telse node[k].r = 0;\n\t} else if (update) node[k].r = 0;\n}\n\nchar *cout(char *p, int k)\n{\n\t*p++ = '(';\n\tif (node[k].l > 0) p = cout(p, node[k].l);\n\tsprintf(p, \")[%d](\", node[k].n);\n\twhile (*p) p++;\n\tif (node[k].r > 0) p = cout(p, node[k].r);\n\t*p++ = ')';\n\t*p = 0;\n\treturn p;\n}\n\nint main()\n{\n\tfgets(a, 1005, stdin);\n\tfgets(b, 1005, stdin);\n\tsz = 2;\n\ttree(a, 1, 0), tree(b, 1, 1);\n\tcout(ans, 1);\n\tputs(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\nA2740\ntitle:Rooted Tree for Misawa-san\n@kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\nchar input_tree[2][100000];\nchar ans[100000];\nchar *ap;\nchar zeros[1]=\"\\0\";\n\ntypedef struct  {\n  char *sptr;\n  int  len;\n} mystr_;\n\nvoid display(mystr_ *str)\n{\n  int i;\n  for(i=0;i<str->len;i++)\n    printf(\"%c\",str->sptr[i]);\n#ifdef DEBUG\n  printf(\"{%d}\",str->len);\n#endif\n  printf(\"\\n\");\n}\n\nvoid analyze_tree(mystr_ *in,mystr_ *left,mystr_ *right,int *val)\n{\n  char *p;\n  int lv,i;\n\n  left->sptr = p = in->sptr;\n\n  for(i=0,lv=0;i<in->len;i++)\n    {\n      if(p[i]=='[')\n\t{\n\tif(lv==0)\n\t  {\n\t    left->len=i;\n\t    *val = atoi(p+i+1);\n\t  }\n\t\n\t\n\t  lv++;\n\t}\n      else if(p[i]==']')\n\t{\n\t  if(lv==1)\n\t    {\n\t      right->sptr=&p[i+1];\n\t      right->len =in->len-i-1;\n\t    }\n\t  lv--;\n\t}\n      else if(p[i]=='(')\n\tlv++;\n      else if(p[i]==')')\n\tlv--;\n    }\n}\n\nint is_empty_tree(mystr_ *in)\n{\n  if(in->len==2)\n    return(1);\n  else\n    return(0);\n}\n\nvoid remove_paren(mystr_ *in)\n{\n  in->len  -= 2;\n  in->sptr ++;\n}\n\n\nvoid add_tree(mystr_ *in1,mystr_ *in2,mystr_ *out)\n{\n  mystr_ stree[2][2],sstree[2];\n  int v[2],val,le,i;\n\n  analyze_tree(in1,&stree[0][0],&stree[0][1],&v[0]);\n  analyze_tree(in2,&stree[1][0],&stree[1][1],&v[1]);\n  val = v[0]+v[1];\n\n  if(is_empty_tree(&stree[0][0]) || is_empty_tree(&stree[1][0]))\n    {\n      sstree[0].sptr=zeros;\n      sstree[0].len =0;\n    }\n  else\n    {\n      remove_paren(&stree[0][0]);\n      remove_paren(&stree[1][0]);\n      add_tree(&stree[0][0],&stree[1][0],&sstree[0]);\n    }\n  if(is_empty_tree(&stree[0][1]) || is_empty_tree(&stree[1][1]))\n    {\n      sstree[1].sptr=zeros;\n      sstree[1].len =0;\n    }\n  else\n    {\n      remove_paren(&stree[0][1]);\n      remove_paren(&stree[1][1]);\n      add_tree(&stree[0][1],&stree[1][1],&sstree[1]);\n    }\n\n  out->sptr=ap;\n\n  sprintf(ap,\"(%.*s)[%d](%.*s)\",sstree[0].len,sstree[0].sptr,val,\n\t  sstree[1].len,sstree[1].sptr);\n\n  while(*ap)\n    ap++;\n  out->len=ap - out->sptr;\n\n}\n\nint main()\n{\n  char *l,*r;\n  int llen,rlen,val;\n  mystr_ tree[3],ltree,rtree;\n  \n  scanf(\"%s\",&(input_tree[0][0]));\n  tree[0].sptr=&(input_tree[0][0]);\n  tree[0].len =strlen(&(input_tree[0][0]));\n  scanf(\"%s\",&(input_tree[1][0]));\n  tree[1].sptr=&(input_tree[1][0]);\n  tree[1].len =strlen(&(input_tree[1][0]));\n  ap=&ans[0];\n\n  add_tree(&tree[0],&tree[1],&tree[2]);\n  display(&tree[2]);\n\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct node{\n    int value;\n    struct node *left,*right;\n};\n\ntypedef struct node node;\n\nnode *build(){\n    if(getchar()==')')return NULL; //skip (\n    node *res = (node *)malloc(sizeof(node));\n    if((res->left = build()))getchar(); //skip )\n    scanf(\"[%d](\",&res->value);\n    if((res->right = build()))getchar(); //skip )\n    return res;\n}\n\nnode *unite(node *a, node *b){\n    if(a==NULL || b==NULL)return NULL;\n    node *res = (node *)malloc(sizeof(node));\n    res->value = a->value+b->value;\n    res->left = unite(a->left, b->left);\n    res->right = unite(a->right, b->right);\n    return res;\n}\n\nvoid output(node *n){\n    if(n==NULL)return;\n    printf(\"(\");\n    output(n->left);\n    printf(\")[%d](\", n->value);\n    output(n->right);\n    printf(\")\");\n}\n\nint main(){\n    node *a = build();\n    getchar(); //skip \\n\n    node *b = build();\n    getchar(); //skip \\n\n    output(unite(a,b));\n    printf(\"\\n\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "    #include <stdio.h>\n    #include <stdlib.h>\n    #include <string.h>\n     \n    struct node {\n        int num;\n        struct node *hidari, *migi;\n    };\n     \n    char input_a[1001];\n    char input_b[1001];\n    int length, pos;\n     \n    struct node *make_tree(char data[], int len);\n    void print_tree(struct node *tree);\n    void make_next(struct node *a, struct node *b);\n     \n    struct node *top_a, *top_b, *top_c;\n     \n    int main(void)\n    {\n        int i, j;\n        scanf(\"%s\",input_a);\n        length = strlen(input_a);\n        pos = 0;\n        top_a = make_tree(input_a, length);\n        //print_tree(top_a);\n     \n        scanf(\"%s\",input_b);\n        length = strlen(input_b);\n        pos = 0;\n        top_b = make_tree(input_b, length);\n        //print_tree(top_b);\n     \n        make_next(top_a, top_b);\n        puts(\"\");\n     \n        return 0;\n     \n    }\n    struct node *make_tree(char data[], int len) \n    {\n        struct node *now;\n        now = (struct node*)malloc(sizeof(struct node));\n        now->num = -1;\n        now->hidari = NULL;\n        now->migi = NULL;\n        int fl = 0;\n        while (pos < len) {\n            if (data[pos] == '(') {\n                if (fl == 0) {\n                    pos++;\n                    now->hidari = make_tree(data, len);\n                } else {\n                    pos++;\n                    now->migi = make_tree(data, len);\n                }\n            } else if (data[pos] == '[') {\n                pos++;\n                now->num = 0;\n                while (1) {\n                    if (data[pos] != ']') {\n                        now->num *= 10;\n                        now->num += data[pos] - '0';\n                        pos++;\n                    } else {\n                        break;\n                    }\n                }\n                pos += 1;\n                fl = 1;\n            } else if (data[pos] == ')') {\n                pos++;\n                return now;\n            }\n        }\n        return now;\n    }\n     \n    void print_tree(struct node *tree) \n    {\n        if (tree->hidari != NULL) {\n            if (tree->hidari->num == -1) {\n                printf(\"()\");\n            } else {\n                printf(\"(\");\n                print_tree(tree->hidari);\n                printf(\")\");\n            }\n        }\n        printf(\"[%d]\",tree->num);\n        if (tree->migi != NULL) {\n            if (tree->migi->num == -1) {\n                printf(\"()\");\n            } else {\n                printf(\"(\");\n                print_tree(tree->migi);\n                printf(\")\");\n            }\n        }\n        return ;\n    }\n     \n    void make_next(struct node *a, struct node *b) \n    {\n        if (a->hidari != NULL && b->hidari != NULL) {\n            if (a->hidari->num == -1 || b->hidari->num == -1) {\n                printf(\"()\");\n            } else {\n                printf(\"(\");\n                make_next(a->hidari, b->hidari);\n                printf(\")\");\n            }\n        }\n        printf(\"[%d]\",a->num+b->num);\n        if (a->migi != NULL && b->migi != NULL) {\n            if (a->migi->num == -1 || b->migi->num == -1) {\n                printf(\"()\");\n            } else {\n                printf(\"(\");\n                make_next(a->migi, b->migi);\n                printf(\")\");\n            }\n        }\n    }\n     "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\ntypedef struct asumisu_tag {\n\tint ayaneru;\n\tstruct asumisu_tag *hanazawakana;\n\tstruct asumisu_tag *tamurayukari;\n} asumisu;\n\nasumisu* kitaeri(void) {\n\tasumisu* kugyu = malloc(sizeof(asumisu));\n\tint hayaminn;\n\tif (kugyu == NULL) exit(1);\n\twhile ((hayaminn = getchar()) != '(') {\n\t\tif (hayaminn == EOF) exit(1);\n\t}\n\thayaminn = getchar();\n\tif (hayaminn == '(') {\n\t\tungetc('(', stdin);\n\t\tkugyu->hanazawakana = kitaeri();\n\t\thayaminn = getchar(); assert(hayaminn == ')');\n\t} else {\n\t\tassert(hayaminn == ')');\n\t\tkugyu->hanazawakana = NULL;\n\t}\n\thayaminn = getchar(); assert(hayaminn == '[');\n\tif (scanf(\"%d\", &kugyu->ayaneru) != 1) exit(1);\n\thayaminn = getchar(); assert(hayaminn == ']');\n\thayaminn = getchar(); assert(hayaminn == '(');\n\thayaminn = getchar();\n\tif (hayaminn == '(') {\n\t\tungetc('(', stdin);\n\t\tkugyu->tamurayukari = kitaeri();\n\t\thayaminn = getchar(); assert(hayaminn == ')');\n\t} else {\n\t\tassert(hayaminn == ')');\n\t\tkugyu->tamurayukari = NULL;\n\t}\n\treturn kugyu;\n}\n\nasumisu* miyukiti(const asumisu* sumipe, const asumisu* ayappe) {\n\tif (sumipe == NULL || ayappe == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tasumisu* yukati = malloc(sizeof(asumisu));\n\t\tif (yukati == NULL) exit(1);\n\t\tyukati->ayaneru = sumipe->ayaneru + ayappe->ayaneru;\n\t\tyukati->hanazawakana = miyukiti(sumipe->hanazawakana, ayappe->hanazawakana);\n\t\tyukati->tamurayukari = miyukiti(sumipe->tamurayukari, ayappe->tamurayukari);\n\t\treturn yukati;\n\t}\n}\n\nvoid mizuhasu(const asumisu* mimorin) {\n\tif (mimorin != NULL) {\n\t\tputchar('(');\n\t\tmizuhasu(mimorin->hanazawakana);\n\t\tprintf(\")[%d](\", mimorin->ayaneru);\n\t\tmizuhasu(mimorin->tamurayukari);\n\t\tputchar(')');\n\t}\n}\n\nvoid yukinnko(asumisu* ayati) {\n\tif (ayati != NULL) {\n\t\tyukinnko(ayati->hanazawakana);\n\t\tyukinnko(ayati->tamurayukari);\n\t\tfree(ayati);\n\t}\n}\n\nint main(void) {\n\tasumisu *nakamurayuuiti, *sakagutidaisuke, *riesyonn;\n\tnakamurayuuiti = kitaeri();\n\tsakagutidaisuke = kitaeri();\n\triesyonn = miyukiti(nakamurayuuiti, sakagutidaisuke);\n\tmizuhasu(riesyonn); putchar('\\n');\n\tyukinnko(nakamurayuuiti);\n\tyukinnko(sakagutidaisuke);\n\tyukinnko(riesyonn); /* itigomamire dayo~ */\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        RootedTreeForMisawaSan solver = new RootedTreeForMisawaSan();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class RootedTreeForMisawaSan {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            String x = in.nextLine(), y = in.nextLine();\n            RootedTreeForMisawaSan.Node a = parse(x), b = parse(y);\n            if (a == null || b == null || !a.toString().equals(x) || !b.toString().equals(y)) {\n                throw new RuntimeException(\"Parse failed\");\n            }\n            a.merge(b);\n            out.println(a.toString());\n        }\n\n        private static RootedTreeForMisawaSan.Node parse(String expr) {\n            if (expr.equals(\"\")) {\n                return null;\n            }\n            assert expr.charAt(0) == '(';\n            int depth = 1;\n            int i = 1;\n            for (; i < expr.length(); i++) {\n                if (expr.charAt(i) == '(') depth++;\n                else if (expr.charAt(i) == ')') depth--;\n                if (depth == 0) break;\n            }\n            RootedTreeForMisawaSan.Node left = parse(expr.substring(1, i));\n            i++;\n            assert expr.charAt(i) == '[';\n            i++;\n            long v = 0;\n            while (Character.isDigit(expr.charAt(i))) {\n                v *= 10;\n                v += expr.charAt(i) - '0';\n                i++;\n            }\n            assert expr.charAt(i) == ']';\n            i++;\n            assert expr.charAt(i) == '(';\n            i++;\n            RootedTreeForMisawaSan.Node right = parse(expr.substring(i, expr.length() - 1));\n            return new RootedTreeForMisawaSan.Node(v, left, right);\n        }\n\n        private static class Node {\n            private long value;\n            private RootedTreeForMisawaSan.Node left;\n            private RootedTreeForMisawaSan.Node right;\n\n            public Node(long value, RootedTreeForMisawaSan.Node left, RootedTreeForMisawaSan.Node right) {\n                this.value = value;\n                this.left = left;\n                this.right = right;\n            }\n\n            public void merge(RootedTreeForMisawaSan.Node node) {\n                this.value += node.value;\n                if (this.left != null && node.left != null) {\n                    this.left.merge(node.left);\n                } else {\n                    this.left = null;\n                }\n                if (this.right != null && node.right != null) {\n                    this.right.merge(node.right);\n                } else {\n                    this.right = null;\n                }\n            }\n\n            public String toString() {\n                StringBuilder sb = new StringBuilder();\n                sb.append('(');\n                if (left != null) {\n                    sb.append(left.toString());\n                }\n                sb.append(\")[\").append(value).append(\"](\");\n                if (right != null) {\n                    sb.append(right.toString());\n                }\n                sb.append(')');\n                return sb.toString();\n            }\n\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString A = sc.next();\n\t\tString B = sc.next();\n\t\t\n\t\tNode a = toNode(A);\n\t\tNode b = toNode(B);\n\t\t\n\t\tNode c = merge(a,b);\n\t\t\n\t\tSystem.out.println(toString(c));\n\t\t\n\t}\n\tstatic char[] S;\n\tstatic int id;\n\tpublic static Node toNode(String a) {\n\t\tS = a.toCharArray();\n\t\tid = 0;\n\t\treturn N();\n\t}\n\tpublic static Node N() {\n\t\tNode node = new Node();\n\t\tif(S[id+1] != ')') {\n\t\t\tid++;\n\t\t\tnode.l = N();\n\t\t}\n\t\tid += 3;\n\t\tString num = \"\";\n\t\twhile(S[id] != ']') {\n\t\t\tnum += S[id++];\n\t\t}\n\t\tnode.number = Integer.parseInt(num);\n\t\tid++;\n\t\tif(S[id+1] != ')') {\n\t\t\tid++;\n\t\t\tnode.r = N();\n\t\t}\n\t\tid++;\n\t\treturn node;\n\t\t\t\n\t}\n\tpublic static Node merge(Node a, Node b) {\n\t\tNode next = new Node();\n\t\tnext.number = a.number + b.number;\n\t\tif(a.l != null && b.l != null) {\n\t\t\tnext.l = merge(a.l,b.l);\n\t\t}\n\t\tif(a.r != null && b.r != null) {\n\t\t\tnext.r = merge(a.r,b.r);\n\t\t}\n\t\treturn next;\n\t}\n\tpublic static String toString(Node a) {\n\t\tString ret = \"(\";\n\t\tif(a.l != null) {\n\t\t\tret += toString(a.l);\n\t\t}\n\t\tret += \")[\" + a.number + \"](\";\n\t\tif(a.r != null) {\n\t\t\tret += toString(a.r);\n\t\t}\n\t\tret += \")\";\n\t\treturn ret;\n\t}\n\tstatic class Node {\n\t\tint number;\n\t\tNode l;\n\t\tNode r;\n\t}\n}\n\t\n\t\n\t\t"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node implements Comparable<Node> {\n    Node left = null;\n    int value;\n    Node right = null;\n\n    @Override\n    public int compareTo(Node node) {\n      return 0;\n    }\n\n    @Override\n    public String toString() {\n      StringBuilder sb = new StringBuilder();\n      sb.append('(');\n      if (this.left != null)\n        sb.append(this.left);\n      sb.append(')');\n      sb.append('[');\n      sb.append(this.value);\n      sb.append(']');\n      sb.append('(');\n      if (this.right != null)\n        sb.append(this.right);\n      sb.append(')');\n      return sb.toString();\n    }\n  }\n\n  Pair<Node, Integer> parse(String str, int index) {\n    char next = str.charAt(index);\n    if (next == ')') {\n      return new Pair<>(null, index + 1);\n    }\n    Node node = new Node();\n    assert (next == '(');\n    ++index;\n    Pair<Node, Integer> ret = parse(str, index);\n    index = ret.s;\n    if (ret.f != null) {\n      node.left = ret.f;\n    }\n    next = str.charAt(index);\n//    for (int i = 0; i < index; ++i) {\n//      System.err.print(\" \");\n//    }\n//    System.err.println(\"* : \" + next);\n    assert (next == '[');\n    ++index;\n    StringBuilder sb = new StringBuilder();\n    while (str.charAt(index) != ']') {\n      next = str.charAt(index);\n      sb.append(next);\n      ++index;\n    }\n    node.value = Integer.parseInt(sb.toString());\n    ++index;\n    next = str.charAt(index);\n    assert (next == '(');\n    ++index;\n    ret = parse(str, index);\n    index = ret.s;\n    if (ret.f != null) {\n      node.right = ret.f;\n    }\n    return new Pair<>(node, index + 1);\n  }\n\n  Node merge(Node a, Node b) {\n    if (a == null || b == null) {\n      return null;\n    }\n    Node node = new Node();\n    node.value = a.value + b.value;\n    node.left = merge(a.left, b.left);\n    node.right = merge(a.right, b.right);\n    return node;\n  }\n\n  void run() {\n    String A = sc.next();\n    Node a = parse(A, 0).f;\n    String B = sc.next();\n    Node b = parse(B, 0).f;\n    Node c = merge(a, b);\n    System.out.println(c);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\n/**\n * Rooted Tree for Misawa-san\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tNode tree1, tree2, tree;\n\t\ttree1 = Node.parseNode(br.readLine());\n\t\ttree2 = Node.parseNode(br.readLine());\n\t\ttree = Node.merge(tree1, tree2);\n\n\t\tSystem.out.println(tree.toString());\n\n\t} //end main\n}\n\nclass Node {\n\tNode parent, left, right;\n\tint value = -1;\n\n\tpublic static Node parseNode(String str) {\n\n\t\tif (str.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tNode node = new Node();\n\n\t\tDeque<Character> stack = new ArrayDeque<>();\n\n\t\tint i, j, v = 0;\n\t\tfor (i = 0; i < str.length(); i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tswitch (c) {\n\t\t\t\tcase '(':\n\t\t\t\t\tstack.push(c);\n\t\t\t\t\tfor (j = i + 1; j < str.length(); j++) {\n\t\t\t\t\t\tchar _c = str.charAt(j);\n\t\t\t\t\t\tif (_c == '(') {\n\t\t\t\t\t\t\tstack.push(_c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_c == ')') {\n\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (stack.isEmpty()) {\n\t\t\t\t\t\t\tif (node.value < 0) {\n\t\t\t\t\t\t\t\tnode.left = Node.parseNode(str.substring(i + 1, j));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnode.right = Node.parseNode(str.substring(i + 1, j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '[':\n\t\t\t\t\tbreak;\n\t\t\t\tcase ']':\n\t\t\t\t\tnode.value = v;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tv *= 10;\n\t\t\t\t\tv += c - '0';\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tpublic static Node merge(Node t1, Node t2) {\n\n\t\tif (t1 == null || t2 == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tNode node = new Node();\n\n\t\tnode.value = t1.value + t2.value;\n\t\tnode.left = Node.merge(t1.left, t2.left);\n\t\tnode.right = Node.merge(t1.right, t2.right);\n\n\t\treturn node;\n\t}\n\n\tpublic String toString() {\n\n\t\tString ls = \"\";\n\t\tString rs = \"\";\n\n\t\tif (left != null) ls = left.toString();\n\t\tif (right != null) rs = right.toString();\n\n\t\treturn String.format(\"(%s)[%d](%s)\", ls, value, rs);\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "def conv(str)\n    eval(?[ + str.gsub(?[, '').gsub(?], ?,).gsub(?(, ?[).gsub(?), '],') + ?])\nend\n\ndef merge(a, b)\n    return [] if a.empty? or b.empty?\n    [merge(a[0], b[0]), a[1] + b[1], merge(a[2], b[2])]\nend\n\ndef inv(a)\n    return '()' if a.empty?\n    \"(#{inv(a[0])}[#{a[1]}]#{inv(a[2])})\"\nend\n\na = conv(gets.chomp)\nb = conv(gets.chomp)\n\nputs inv(merge(a, b))[1..-2]"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.string;\nimport std.conv;\n\nclass T {\n    int value;\n    T left, right;\n    this(int value, T left, T right) {\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n    override string toString() const {\n        string l = (left ? left.toString : \"\");\n        string r = (right ? right.toString : \"\");\n        return \"(\" ~ l ~ \")\" ~ \"[\" ~ value.to!string ~ \"]\" ~ \"(\" ~ r ~ \")\";\n    }\n}\n\nint size(string s) {\n    return cast(int)(s.length);\n}\n\nint parse_int(string s, ref int n) {\n    assert(isDigit(s[n]));\n    int r = 0;\n    while (n < s.size && isDigit(s[n])) {\n        r = r * 10 + cast(int)(s[n] - '0');\n        n++;\n    }\n    return r;\n}\n\nT parse(string s, ref int n) {\n    assert(s[n] == '(');\n    n++;\n    if (s[n] == ')') {\n        return null;\n    }\n    T l = parse(s, n);\n    //stderr.writeln(s, \" \", n, \" \", s[n]);\n    assert(s[n] == ')');\n    n++;\n    assert(s[n] == '[');\n    n++;\n    int value = parse_int(s, n);\n    assert(s[n] == ']');\n    n++;\n    T r = parse(s, n);\n    assert(s[n] == ')');\n    n++;\n    return new T(value, l, r);\n}\n\nvoid main() {\n    auto A = \"(\" ~ stdin.readln.chomp ~ \")\";\n    auto B = \"(\" ~ stdin.readln.chomp ~ \")\";\n\n    T dfs(T a, T b) {\n        if (a is null || b is null) return null;\n        return new T(a.value + b.value, dfs(a.left, b.left), dfs(a.right, b.right));\n    }\n\n    int n = 0, m = 0;\n    writeln(dfs(parse(A, n), parse(B, m)));\n}"
  },
  {
    "language": "Python",
    "code": "def convert(S):\n    return eval(S.replace(\")[\",\"),[\").replace(\"](\",\"],(\"))\ndef dfs(A, B):\n    if not A or not B:\n        return ()\n    return (dfs(A[0], B[0]), [A[1][0] + B[1][0]], dfs(A[2], B[2]))\nprint(str(dfs(convert(input()), convert(input()))).replace(\", \",\"\")[1:-1])"
  },
  {
    "language": "Python",
    "code": "in1 = input()\nin2 = input()\n\nnodes = [[-1,-1,-1] for _ in range(800)]\nnodes2 = [[-1,-1,-1] for _ in range(800)]\nnodes3 = [[-1,-1,-1] for _ in range(800)]\n\n\ndef create_node(s, cnt):\n    \n    #print('s: ' + s)\n    cnt_l = 0\n    cnt_r = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            cnt_l += 1\n        elif s[i] == ')':\n            cnt_r += 1\n        if cnt_l == cnt_r and cnt_l != 0:\n            s1 = s[1:i]\n            j = 0\n            while s[i+j] != ']':\n                j += 1\n            #print('val:'+ s[i+2:i+j])\n            s2 = s[i+j+2:len(s)-1]\n            if len(s2) == 1:\n                s2 = ''\n            #print(s1)\n            #print(s2)\n            #print(cnt, 's1:'+s1, 's2:'+ s2, 's[i+2]:' + s[i+2])\n            nodes[cnt][2] = int(s[i+2:i+j])\n            \n            if len(s1) != 0:\n                create_node(s1, 2*cnt+1)\n                nodes[cnt][0] = 2*cnt+1\n            if len(s2) != 0:\n                create_node(s2, 2*cnt+2)\n                nodes[cnt][1] = 2*cnt+2\n            break\n\ndef create_node2(s, cnt):\n    \n    #print('s: ' + s)\n    cnt_l = 0\n    cnt_r = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            cnt_l += 1\n        elif s[i] == ')':\n            cnt_r += 1\n        if cnt_l == cnt_r and cnt_l != 0:\n            s1 = s[1:i]\n            j = 0\n            while s[i+j] != ']':\n                j += 1\n            #print(s[i+2:i+j])\n            s2 = s[i+j+2:len(s)-1]\n            if len(s2) == 1:\n                s2 = ''\n            #print(cnt, 's1:'+s1, 's2:'+ s2, 's[i+2]:' + s[i+2])\n            nodes2[cnt][2] = int(s[i+2:i+j])\n            \n            if len(s1) != 0:\n                create_node2(s1, 2*cnt+1)\n                nodes2[cnt][0] = 2*cnt+1\n            if len(s2) != 0:\n                create_node2(s2, 2*cnt+2)\n                nodes2[cnt][1] = 2*cnt+2\n            break\n\ndef print_nodes(i):\n    #print(nodes3[i])\n    #if nodes3[i][0] == -1 and nodes3[i][1] == -1:\n    if nodes3[i][2] == -1:\n        return '()'\n    return '(' + print_nodes(nodes3[i][0]) + '[' + str(nodes3[i][2]) + ']' + print_nodes(nodes3[i][1]) + ')'\n\ncreate_node(in1, 0)\ncreate_node2(in2, 0)\n\nfor i in range(len(nodes)):\n    if nodes[i][2] == -1 or nodes2[i][2] == -1:\n        pass\n    else:\n        nodes3[i][2] = nodes[i][2] + nodes2[i][2]\n        nodes3[i][0] = nodes[i][0]\n        nodes3[i][1] = nodes[i][1]\n\n# print(nodes[0:12])\n# print(nodes2[0:12])\n# print(nodes3[0:12])\nres = print_nodes(0)\nprint(res[1:len(res)-1])\n"
  },
  {
    "language": "Python",
    "code": "in1 = input()\nin2 = input()\n\nnodes = [[-1,-1,-1] for _ in range(1000)]\nnodes2 = [[-1,-1,-1] for _ in range(1000)]\nnodes3 = [[-1,-1,-1] for _ in range(1000)]\ndef create_node(s, cnt):\n    \n    #print('s: ' + s)\n    cnt_l = 0\n    cnt_r = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            cnt_l += 1\n        elif s[i] == ')':\n            cnt_r += 1\n        if cnt_l == cnt_r and cnt_l != 0:\n            s1 = s[1:i]\n            s2 = s[i+5:len(s)-1]\n            \n            #print(cnt, 's1:'+s1, 's2:'+ s2, 's[i+2]:' + s[i+2])\n            nodes[cnt][2] = int(s[i+2])\n            \n            if len(s1) != 0:\n                create_node(s1, 2*cnt+1)\n                nodes[cnt][0] = 2*cnt+1\n            if len(s2) != 0:\n                create_node(s2, 2*cnt+2)\n                nodes[cnt][1] = 2*cnt+2\n            break\n            \ndef create_node2(s, cnt):\n    \n    #print('s: ' + s)\n    cnt_l = 0\n    cnt_r = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            cnt_l += 1\n        elif s[i] == ')':\n            cnt_r += 1\n        if cnt_l == cnt_r and cnt_l != 0:\n            s1 = s[1:i]\n            s2 = s[i+5:len(s)-1]\n            \n            #print(cnt, 's1:'+s1, 's2:'+ s2, 's[i+2]:' + s[i+2])\n            nodes2[cnt][2] = int(s[i+2])\n            \n            if len(s1) != 0:\n                create_node2(s1, 2*cnt+1)\n                nodes2[cnt][0] = 2*cnt+1\n            if len(s2) != 0:\n                create_node2(s2, 2*cnt+2)\n                nodes2[cnt][1] = 2*cnt+2\n            break\n\ndef print_nodes(i):\n    #print(nodes3[i])\n    #if nodes3[i][0] == -1 and nodes3[i][1] == -1:\n    if nodes3[i][2] == -1:\n        return '()'\n    return '(' + print_nodes(nodes3[i][0]) + '[' +str(nodes3[i][2])+ ']' + print_nodes(nodes3[i][1]) + ')'\n\ncreate_node(in1, 0)\ncreate_node2(in2, 0)\n\nfor i in range(len(nodes)):\n    if nodes[i][2] == -1 or nodes2[i][2] == -1:\n        pass\n    else:\n        nodes3[i][2] = nodes[i][2] + nodes2[i][2]\n        nodes3[i][0] = nodes[i][0]\n        nodes3[i][1] = nodes[i][1]\n\n#print(nodes3[0:12])\nres = print_nodes(0)\nprint(res[1:len(res)-1])\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    a = S()\n    b = S()\n\n    def f(s):\n        if not s:\n            return None\n        if s[0] != '(':\n            return int(s)\n        c = 1\n        mi = -1\n        for i in range(1, len(s)):\n            if s[i] == '(':\n                c += 1\n            elif s[i] == ')':\n                c -= 1\n                if c == 0:\n                    mi = i\n                    break\n\n        c = 1\n        ki = -1\n        for i in range(mi+2, len(s)):\n            if s[i] == '[':\n                c += 1\n            elif s[i] == ']':\n                c -= 1\n                if c == 0:\n                    ki = i\n                    break\n\n        return [f(s[mi+2:ki]), f(s[1:mi]), f(s[ki+2:-1])]\n\n    fa = f(a)\n    fb = f(b)\n    def g(a, b):\n        if a is None or b is None:\n            return None\n        if isinstance(a, int) or isinstance(b, int):\n            ai = a\n            while not isinstance(ai, int):\n                ai = ai[0]\n\n            bi = b\n            while not isinstance(bi, int):\n                bi = bi[0]\n\n            return ai + bi\n\n        return [g(a[i],b[i]) for i in range(3)]\n\n    def h(a):\n        if a is None:\n            return ''\n        if isinstance(a, int):\n            return str(a)\n        return '({})[{}]({})'.format(h(a[1]),h(a[0]),h(a[2]))\n\n\n    return h(g(fa, fb))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\nA = input()\nB = input()\n\nA_root = [[-1] * 3 for i in range(1000)]\nB_root = [[-1] * 3 for i in range(1000)]\n\nclass Source():\n  def __init__(self, S):\n    self.S = S\n    self.pos = 0\n   \n  \ndef peek(S):\n  return S.S[S.pos] if S.pos < len(S.S) else -1\n\ndef next(S):\n  S.pos += 1\n\ndef tree(S, A, i):\n  next(S)\n  if peek(S) == ')':\n    next(S)\n    return -1\n  c = i[0]\n  i[0] += 1\n  l = i[0] \n  left = tree(S, A, i)\n  center = root(S, A)\n  i[0] += 1\n  r = i[0]\n  right = tree(S, A, i)\n  \n  A[c] = [center, l, r]\n  next(S)\n  \ndef root(S, A):\n  res = 0\n  next(S)\n  while peek(S) != ']':\n    res = res * 10 + int(peek(S))\n    next(S)\n  next(S)\n  \n  return res\n  \ntree(Source('(' + A + ')'), A_root, [0])\ntree(Source('(' + B + ')'), B_root, [0])\n\ndef f(i, j):\n  if A_root[i][0] == -1 or B_root[j][0] == -1:\n    return '()'\n  center = '[' + str(A_root[i][0] + B_root[j][0]) + ']'\n  return '(' + f(A_root[i][1], B_root[j][1]) + center + f(A_root[i][2], B_root[j][2]) + ')'\n\nprint(f(0, 0)[1:-1])\n"
  },
  {
    "language": "Python",
    "code": "def parse_node(l, r, S):\n    left, right = 0, 0\n    cnt = 0\n    for i in range(l, r + 1):\n        if S[i] == '(':\n            cnt += 1\n        elif S[i] == ')':\n            cnt -= 1\n        elif cnt == 0 and S[i] == \"[\":\n            left = i\n        elif cnt == 0 and S[i] == \"]\":\n            right = i\n    return left, right\n\n\ndef parser(l1, r1, l2, r2):\n    n1_l, n1_r = parse_node(l1, r1, S1)\n    n2_l, n2_r = parse_node(l2, r2, S2)\n    # print(n1_l, n1_r, n2_l, n2_r)\n    node = \"[{}]\".format(int(S1[n1_l + 1:n1_r]) + int(S2[n2_l + 1:n2_r]))\n    left_node = \"({})\".format(\"\" if min(n1_l - l1, n2_l - l2) <= 2 else parser(l1 + 1, n1_l - 2, l2 + 1, n2_l - 2))\n    right_node = \"({})\".format(\"\" if min(r1 - n1_r, r2 - n2_r) <= 2 else parser(n1_r + 2, r1 - 1, n2_r + 2, r2 - 1))\n    return left_node + node + right_node\n\n\n\nS1, S2 = input(), input()\nprint(parser(0, len(S1) - 1, 0, len(S2) - 1))"
  },
  {
    "language": "Python",
    "code": "in1 = input()\nin2 = input()\n\nnodes = [[-1,-1,-1] for _ in range(100000)]\nnodes2 = [[-1,-1,-1] for _ in range(100000)]\nnodes3 = [[-1,-1,-1] for _ in range(100000)]\n\n\ndef create_node(s, cnt):\n    \n    #print('s: ' + s)\n    cnt_l = 0\n    cnt_r = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            cnt_l += 1\n        elif s[i] == ')':\n            cnt_r += 1\n        if cnt_l == cnt_r and cnt_l != 0:\n            s1 = s[1:i]\n            j = 0\n            while s[i+j] != ']':\n                j += 1\n            #print('val:'+ s[i+2:i+j])\n            s2 = s[i+j+2:len(s)-1]\n            if len(s2) == 1:\n                s2 = ''\n            #print(s1)\n            #print(s2)\n            #print(cnt, 's1:'+s1, 's2:'+ s2, 's[i+2]:' + s[i+2])\n            nodes[cnt][2] = int(s[i+2:i+j])\n            \n            if len(s1) != 0:\n                create_node(s1, 2*cnt+1)\n                nodes[cnt][0] = 2*cnt+1\n            if len(s2) != 0:\n                create_node(s2, 2*cnt+2)\n                nodes[cnt][1] = 2*cnt+2\n            break\n\ndef create_node2(s, cnt):\n    \n    #print('s: ' + s)\n    cnt_l = 0\n    cnt_r = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            cnt_l += 1\n        elif s[i] == ')':\n            cnt_r += 1\n        if cnt_l == cnt_r and cnt_l != 0:\n            s1 = s[1:i]\n            j = 0\n            while s[i+j] != ']':\n                j += 1\n            #print(s[i+2:i+j])\n            s2 = s[i+j+2:len(s)-1]\n            if len(s2) == 1:\n                s2 = ''\n            #print(cnt, 's1:'+s1, 's2:'+ s2, 's[i+2]:' + s[i+2])\n            nodes2[cnt][2] = int(s[i+2:i+j])\n            \n            if len(s1) != 0:\n                create_node2(s1, 2*cnt+1)\n                nodes2[cnt][0] = 2*cnt+1\n            if len(s2) != 0:\n                create_node2(s2, 2*cnt+2)\n                nodes2[cnt][1] = 2*cnt+2\n            break\n\ndef print_nodes(i):\n    #print(nodes3[i])\n    #if nodes3[i][0] == -1 and nodes3[i][1] == -1:\n    if nodes3[i][2] == -1:\n        return '()'\n    return '(' + print_nodes(nodes3[i][0]) + '[' + str(nodes3[i][2]) + ']' + print_nodes(nodes3[i][1]) + ')'\n\ncreate_node(in1, 0)\ncreate_node2(in2, 0)\n\nfor i in range(len(nodes)):\n    if nodes[i][2] == -1 or nodes2[i][2] == -1:\n        pass\n    else:\n        nodes3[i][2] = nodes[i][2] + nodes2[i][2]\n        nodes3[i][0] = nodes[i][0]\n        nodes3[i][1] = nodes[i][1]\n\n# print(nodes[0:12])\n# print(nodes2[0:12])\n# print(nodes3[0:12])\nres = print_nodes(0)\nprint(res[1:len(res)-1])\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nimport sys\nimport math\nimport itertools as it\nfrom collections import deque\n\nsys.setrecursionlimit(10000000)\n\ndef make_tree(pos, id, S, V, E):\n    if S[pos] == ')':\n        V[id] = -1\n        return pos + 1, id + 1\n    par = id\n    id += 1\n    E[par][0] = id\n    pos, id = make_tree(pos + 1, id, S, V, E)\n    val = ''\n    pos += 1\n    while S[pos] != ']':\n        val += S[pos]\n        pos += 1\n    V[par] = int(val)\n    pos += 1\n    E[par][1] = id\n    pos, id = make_tree(pos + 1, id, S, V, E)\n    return pos + 1, id\n\ndef and_tree(id1, id2, V1, V2, E1, E2):\n    if V1[id1] == -1 or V2[id2] == -1:\n        return \"\"\n    S = \"\"\n    S += \"(\" + and_tree(E1[id1][0], E2[id2][0], V1, V2, E1, E2) + \")\"\n    S += \"[\" + str(V1[id1] + V2[id2]) + \"]\"\n    S += \"(\" + and_tree(E1[id1][1], E2[id2][1], V1, V2, E1, E2) + \")\"\n    return S\n\nS1 = raw_input()\nV1 = [-1] * 1000\nE1 = [[-1, -1] for i in range(1000)]\nmake_tree(0, 0, S1, V1, E1)\n\nS2 = raw_input()\nV2 = [-1] * 1000\nE2 = [[-1, -1] for i in range(1000)]\nmake_tree(0, 0, S2, V2, E2)\n\nprint and_tree(0, 0, V1, V2, E1, E2)\n"
  },
  {
    "language": "Python",
    "code": "def sep(S):\n    l=r=0\n    for i,s in enumerate(S):\n        l+=s=='('\n        r+=s==')'\n        if l==r:\n            j=S.find(']',i)\n            s_l=S[1:i]\n            s_r=S[j+2:-1]\n            s_c=int(S[i+2:j])\n            break\n    return s_l,s_c,s_r\ndef solve(A,B):\n    if A=='' or B=='':\n        return ''\n    a_l,a_c,a_r=sep(A)\n    b_l,b_c,b_r=sep(B)\n    return '(%s)[%d](%s)'%(solve(a_l,b_l),a_c+b_c,solve(a_r,b_r))\nprint(solve(input(),input()))\n"
  },
  {
    "language": "Python",
    "code": "def sToTree(S):\n#    print(S)\n    if len(S)==0:\n        return 'N'\n    c = 0\n    left=0\n    right=0\n    #print(S)\n    for i in range(len(S)):\n        if S[i] =='(':\n            c+=1\n        elif S[i] ==')':\n            c-=1\n        elif c==0 and S[i]=='[':\n            left=i\n        elif c==0 and S[i] ==']':\n            right=i\n            break\n#    print(S[right+1:len(S)-1],right,left)   \n    return[sToTree(S[1:left-1]),int(S[left+1:right]),sToTree(S[right+2:len(S)-1])]\n    \ndef dfs(S1,S2):\n    if S1=='N' or S2=='N':\n        return 'N'\n\n    ret = [dfs(S1[0],S2[0]),S1[1]+S2[1],dfs(S1[2],S2[2])]\n    return ret\n\ndef my_print(ans):\n    if ans == 'N':\n        return\n    print('(',end='')\n    my_print(ans[0])\n    print(\")[{0}](\".format(ans[1]),end = '')\n    my_print(ans[2])\n    print(')',end='')\n\nS1 = input()\nS2 = input()\n\n\nS1 = sToTree(S1)\nS2 = sToTree(S2)\n\nans = dfs(S1,S2)\nmy_print(ans)\nprint()\n\n"
  },
  {
    "language": "Python",
    "code": "class binary_tree():\n    def __init__(self,value,left=None,right=None):\n        self.value=value\n        self.left=left\n        self.right=right\n\ndef find_corres_bra(s,fr,to):\n    count=0 \n    x=-1\n    for i in range(len(s)):\n        if s[i]==fr:\n            count += 1\n        elif s[i]==to:\n            if count==1:\n                x=i\n                break\n            else:\n                count-=1\n    return x\n    \n\ndef make_tree(s):\n    if s=='':\n        return None\n    x0=0\n    x1=find_corres_bra(s,'(',')')+1\n    x2=x1+find_corres_bra(s[x1:],'[',']')+1\n    tree=binary_tree(int(s[x1+1:x2-1]),make_tree(s[x0+1:x1-1]),make_tree(s[x2+1:-1]))\n    return tree\n\ndef synthe_trees(t1,t2):\n    tree=binary_tree(value=t1.value+t2.value)\n    if t1.left!=None and t2.left !=None:\n        tree.left=synthe_trees(t1.left,t2.left)\n    if t1.right!=None and t2.right !=None:\n        tree.right=synthe_trees(t1.right,t2.right)\n    return tree\n\ndef tree_to_str(tree):\n    if tree==None:\n        return ''\n    ans='('+ tree_to_str(tree.left)+')'+'['+str(tree.value)+']'+'('+ tree_to_str(tree.right)+')'\n    return ans\n\nt1=make_tree(input())\nt2=make_tree(input())\ntree=synthe_trees(t1,t2)\nprint(tree_to_str(tree))\n        \n"
  },
  {
    "language": "Python",
    "code": "def convert(S):\n    cur = 0\n    def parse():\n        nonlocal cur\n        if S[cur] == ')':\n            return ()\n        cur += 1 # '('\n        left = parse()\n        cur += 2 # ')['\n        num = 0\n        while S[cur] != ']':\n            num = 10*num + int(S[cur])\n            cur += 1\n        cur += 2 # ']('\n        right = parse()\n        cur += 1 # ')'\n        return left, num, right\n    return parse()\ndef dfs(A, B):\n    if not A or not B:\n        return ()\n    return (dfs(A[0], B[0]), [A[1] + B[1]], dfs(A[2], B[2]))\nprint(str(dfs(convert(input()), convert(input()))).replace(\", \",\"\")[1:-1])"
  },
  {
    "language": "Python",
    "code": "in1 = input()\nin2 = input()\n\nnodes = [[-1,-1,-1] for _ in range(1000)]\nnodes2 = [[-1,-1,-1] for _ in range(1000)]\nnodes3 = [[-1,-1,-1] for _ in range(1000)]\n\n\ndef create_node(s, cnt):\n    \n    #print('s: ' + s)\n    cnt_l = 0\n    cnt_r = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            cnt_l += 1\n        elif s[i] == ')':\n            cnt_r += 1\n        if cnt_l == cnt_r and cnt_l != 0:\n            s1 = s[1:i]\n            s2 = s[i+5:len(s)-1]\n            \n            #print(cnt, 's1:'+s1, 's2:'+ s2, 's[i+2]:' + s[i+2])\n            nodes[cnt][2] = int(s[i+2])\n            \n            if len(s1) != 0:\n                create_node(s1, 2*cnt+1)\n                nodes[cnt][0] = 2*cnt+1\n            if len(s2) != 0:\n                create_node(s2, 2*cnt+2)\n                nodes[cnt][1] = 2*cnt+2\n            break\n            \ndef create_node2(s, cnt):\n    \n    #print('s: ' + s)\n    cnt_l = 0\n    cnt_r = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            cnt_l += 1\n        elif s[i] == ')':\n            cnt_r += 1\n        if cnt_l == cnt_r and cnt_l != 0:\n            s1 = s[1:i]\n            num = ''\n            j = 0\n            while s[i+j] != '[':\n                j += 1\n            #print(s[i+2:i+j+4])\n            s2 = s[i+j+5:len(s)-1]\n            \n            #print(cnt, 's1:'+s1, 's2:'+ s2, 's[i+2]:' + s[i+2])\n            nodes2[cnt][2] = int(s[i+2:i+j+4])\n            \n            if len(s1) != 0:\n                create_node2(s1, 2*cnt+1)\n                nodes2[cnt][0] = 2*cnt+1\n            if len(s2) != 0:\n                create_node2(s2, 2*cnt+2)\n                nodes2[cnt][1] = 2*cnt+2\n            break\n\ndef print_nodes(i):\n    #print(nodes3[i])\n    #if nodes3[i][0] == -1 and nodes3[i][1] == -1:\n    if nodes3[i][2] == -1:\n        return '()'\n    return '(' + print_nodes(nodes3[i][0]) + '[' + str(nodes3[i][2]) + ']' + print_nodes(nodes3[i][1]) + ')'\n\ncreate_node(in1, 0)\ncreate_node2(in2, 0)\n\nfor i in range(len(nodes)):\n    if nodes[i][2] == -1 or nodes2[i][2] == -1:\n        pass\n    else:\n        nodes3[i][2] = nodes[i][2] + nodes2[i][2]\n        nodes3[i][0] = nodes[i][0]\n        nodes3[i][1] = nodes[i][1]\n\n# print(nodes[0:12])\n# print(nodes2[0:12])\n# print(nodes3[0:12])\nres = print_nodes(0)\nprint(res[1:len(res)-1])\n\n"
  }
]