[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nvoid generate_primes(int max_num, int primes[], int *count) {\n    *count = 0;\n    for (int i = 2; i <= max_num; ++i) {\n        if (is_prime(i)) {\n            primes[(*count)++] = i;\n        }\n    }\n}\n\nint count_consecutive_prime_sums(int n, int primes[], int prime_count) {\n    int count = 0;\n    for (int i = 0; i < prime_count; ++i) {\n        int sum = 0;\n        for (int j = i; j < prime_count; ++j) {\n            sum += primes[j];\n            if (sum == n) {\n                count++;\n                break;\n            } else if (sum > n) {\n                break;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        \n        int primes[10000];\n        int prime_count;\n        generate_primes(n, primes, &prime_count);\n        \n        int result = count_consecutive_prime_sums(n, primes, prime_count);\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:16:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ConsecutivePrimeSums {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            \n            System.out.println(countConsecutivePrimeSums(n));\n        }\n        \n        scanner.close();\n    }\n    \n    static int countConsecutivePrimeSums(int target) {\n        List<Integer> primes = generatePrimes(target);\n        int count = 0;\n        \n        for (int start = 0; start < primes.size(); start++) {\n            int sum = 0;\n            for (int end = start; end < primes.size(); end++) {\n                sum += primes.get(end);\n                if (sum == target) {\n                    count++;\n                    break;\n                }\n                if (sum > target) break;\n            }\n        }\n        \n        return count;\n    }\n    \n    static List<Integer> generatePrimes(int limit) {\n        List<Integer> primes = new ArrayList<>();\n        boolean[] isPrime = new boolean[limit + 1];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i <= limit; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n                for (int j = i * i; j <= limit; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        return primes;\n    }\n}",
    "timestamp": "2025-08-05 19:16:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> generatePrimes(int limit) {\n    vector<bool> sieve(limit + 1, true);\n    sieve[0] = sieve[1] = false;\n    for (int p = 2; p * p <= limit; ++p) {\n        if (sieve[p]) {\n            for (int i = p * p; i <= limit; i += p) {\n                sieve[i] = false;\n            }\n        }\n    }\n    vector<int> primes;\n    for (int i = 2; i <= limit; ++i) {\n        if (sieve[i]) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\nint countConsecutivePrimeSums(int n, const vector<int>& primes) {\n    int count = 0;\n    int sum;\n    for (int i = 0; i < primes.size(); ++i) {\n        sum = 0;\n        for (int j = i; j < primes.size(); ++j) {\n            sum += primes[j];\n            if (sum == n) {\n                count++;\n                break;\n            }\n            if (sum > n) {\n                break;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    vector<int> primes = generatePrimes(10000);\n    int n;\n    while (cin >> n && n != 0) {\n        cout << countConsecutivePrimeSums(n, primes) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:17:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 10000\n\nbool isPrime(int n) {\n    if (n < 2) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint countConsecutivePrimeSums(int target) {\n    int primes[MAX_N];\n    int primeCount = 0;\n    \n    // Generate primes up to target\n    for (int i = 2; i <= target; i++) {\n        if (isPrime(i)) {\n            primes[primeCount++] = i;\n        }\n    }\n    \n    int ways = 0;\n    \n    for (int start = 0; start < primeCount; start++) {\n        int sum = 0;\n        for (int j = start; j < primeCount; j++) {\n            sum += primes[j];\n            if (sum == target) {\n                ways++;\n                break;\n            }\n            if (sum > target) {\n                break;\n            }\n        }\n    }\n    \n    return ways;\n}\n\nint main() {\n    int n;\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        printf(\"%d\\n\", countConsecutivePrimeSums(n));\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:17:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint consecutivePrimeSums(int n) {\n    std::vector<int> primes;\n    for (int i = 2; i <= n; i++) {\n        if (isPrime(i)) primes.push_back(i);\n    }\n    \n    int count = 0;\n    for (int start = 0; start < primes.size(); start++) {\n        int sum = 0;\n        for (int end = start; end < primes.size(); end++) {\n            sum += primes[end];\n            if (sum == n) count++;\n            if (sum > n) break;\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    int n;\n    while (true) {\n        std::cin >> n;\n        if (n == 0) break;\n        std::cout << consecutivePrimeSums(n) << std::endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:17:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ConsecutivePrimeSum {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<Integer> primes = generatePrimes(10000);\n        List<Integer> cumulativeSums = new ArrayList<>();\n        cumulativeSums.add(0);\n        int sum = 0;\n        for (int prime : primes) {\n            sum += prime;\n            cumulativeSums.add(sum);\n        }\n\n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            int count = 0;\n            for (int i = 0; i < cumulativeSums.size(); i++) {\n                for (int j = i + 1; j < cumulativeSums.size(); j++) {\n                    int diff = cumulativeSums.get(j) - cumulativeSums.get(i);\n                    if (diff == n) {\n                        count++;\n                    } else if (diff > n) {\n                        break;\n                    }\n                }\n            }\n            System.out.println(count);\n        }\n    }\n\n    private static List<Integer> generatePrimes(int limit) {\n        boolean[] sieve = new boolean[limit + 1];\n        Arrays.fill(sieve, true);\n        sieve[0] = sieve[1] = false;\n        for (int i = 2; i * i <= limit; i++) {\n            if (sieve[i]) {\n                for (int j = i * i; j <= limit; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i <= limit; i++) {\n            if (sieve[i]) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n}",
    "timestamp": "2025-08-05 19:17:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def sieve(max_number):\n    is_prime = [True] * (max_number + 1)\n    p = 2\n    while (p * p <= max_number):\n        if (is_prime[p] == True):\n            for i in range(p * p, max_number + 1, p):\n                is_prime[i] = False\n        p += 1\n    prime_numbers = [p for p in range(2, max_number + 1) if is_prime[p]]\n    return prime_numbers\n\ndef count_prime_sum_representations(n, primes):\n    count = 0\n    for start in range(len(primes)):\n        sum_primes = 0\n        for end in range(start, len(primes)):\n            sum_primes += primes[end]\n            if sum_primes > n:\n                break\n            if sum_primes == n:\n                count += 1\n                break\n    return count\n\ndef main():\n    max_input = 0\n    inputs = []\n    \n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        inputs.append(n)\n        if n > max_input:\n            max_input = n\n    \n    if max_input > 0:\n        primes = sieve(max_input)\n        for n in inputs:\n            print(count_prime_sum_representations(n, primes))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:24:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class ConsecutivePrimeSums {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        ArrayList<Integer> primes = generatePrimes(10000); // Arbitrarily large upper limit\n        int input;\n\n        while ((input = scanner.nextInt()) != 0) {\n            System.out.println(countConsecutivePrimeSumWays(input, primes));\n        }\n    }\n\n    private static int countConsecutivePrimeSumWays(int n, ArrayList<Integer> primes) {\n        int count = 0;\n        for (int start = 0; start < primes.size(); start++) {\n            int sum = 0;\n            for (int end = start; end < primes.size(); end++) {\n                sum += primes.get(end);\n                if (sum == n) {\n                    count++;\n                }\n                if (sum >= n) {\n                    break;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static ArrayList<Integer> generatePrimes(int upperLimit) {\n        boolean[] isPrime = new boolean[upperLimit + 1];\n        ArrayList<Integer> primes = new ArrayList<>();\n        for (int i = 2; i <= upperLimit; i++) {\n            isPrime[i] = true;\n        }\n        for (int p = 2; p * p <= upperLimit; p++) {\n            if (isPrime[p]) {\n                for (int j = p * p; j <= upperLimit; j += p) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        for (int i = 2; i <= upperLimit; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n}",
    "timestamp": "2025-08-13 03:24:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX 10000\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n\n    if (num % 2 == 0 || num % 3 == 0) return false;\n\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\nvoid generate_primes(int primes[], int *size) {\n    *size = 0;\n    for (int i = 2; i < MAX; i++) {\n        if (is_prime(i)) {\n            primes[(*size)++] = i;\n        }\n    }\n}\n\nint count_consecutive_prime_sums(int target, int primes[], int size) {\n    int count = 0;\n    \n    for (int start = 0; start < size; start++) {\n        int sum = 0;\n        for (int end = start; end < size; end++) {\n            sum += primes[end];\n            if (sum == target) {\n                count++;\n                break;\n            }\n            if (sum > target) break;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int primes[MAX], size;\n    generate_primes(primes, &size);\n    \n    int n;\n    while (scanf(\"%d\", &n) && n != 0) {\n        int result = count_consecutive_prime_sums(n, primes, size);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 03:24:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef count_prime_sum_representations(n):\n    primes = [p for p in range(2, n+1) if is_prime(p)]\n    count = 0\n    \n    for start in range(len(primes)):\n        curr_sum = 0\n        for j in range(start, len(primes)):\n            curr_sum += primes[j]\n            if curr_sum == n:\n                count += 1\n                break\n            if curr_sum > n:\n                break\n    \n    return count\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        print(count_prime_sum_representations(n))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:24:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def sieve(limit):\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False\n    for num in range(2, int(limit ** 0.5) + 1):\n        if sieve[num]:\n            sieve[num*num : limit+1 : num] = [False] * len(sieve[num*num : limit+1 : num])\n    primes = [i for i, is_prime in enumerate(sieve) if is_prime]\n    return primes\n\ndef count_consecutive_prime_sums(n, primes):\n    count = 0\n    for i in range(len(primes)):\n        sum_p = 0\n        for j in range(i, len(primes)):\n            sum_p += primes[j]\n            if sum_p == n:\n                count += 1\n                break\n            elif sum_p > n:\n                break\n    return count\n\ndef main():\n    max_n = 10000\n    primes = sieve(max_n)\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        print(count_consecutive_prime_sums(n, primes))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:25:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\n// Function to generate all primes less than a given number\nvector<int> generatePrimes(int maxNum) {\n    vector<int> primes;\n    for (int i = 2; i <= maxNum; ++i) {\n        if (isPrime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to find consecutive prime sum representations\nint countConsecutivePrimeSums(int n) {\n    vector<int> primes = generatePrimes(n);\n    int count = 0;\n\n    for (size_t i = 0; i < primes.size(); ++i) {\n        int sum = 0;\n        for (size_t j = i; j < primes.size(); ++j) {\n            sum += primes[j];\n            if (sum == n) {\n                ++count;\n                break;\n            } else if (sum > n) {\n                break;\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n != 0) {\n        cout << countConsecutivePrimeSums(n) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:11:40"
  }
]