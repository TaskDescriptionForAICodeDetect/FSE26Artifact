[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "int maxBlackStoneCapture(char* S) {\n    int L = strlen(S);\n    int maxCapture = 0;\n\n    for (int i = 0; i < L; i++) {\n        if (S[i] == '.') {\n            int currentCapture = 0;\n            int validMove = 1;\n\n            // Check left side captures\n            for (int left = i - 1; left >= 0; left--) {\n                if (S[left] == 'B') currentCapture++;\n                else if (S[left] == 'W') break;\n                else break;\n            }\n\n            // Check right side captures\n            for (int right = i + 1; right < L; right++) {\n                if (S[right] == 'B') currentCapture++;\n                else if (S[right] == 'W') break;\n                else break;\n            }\n\n            // Check if placing white stone creates a valid configuration\n            int leftWhite = 0, rightWhite = 0;\n            for (int left = i - 1; left >= 0; left--) {\n                if (S[left] == 'W') { leftWhite = 1; break; }\n                if (S[left] == '.') break;\n            }\n\n            for (int right = i + 1; right < L; right++) {\n                if (S[right] == 'W') { rightWhite = 1; break; }\n                if (S[right] == '.') break;\n            }\n\n            if (leftWhite && rightWhite) validMove = 0;\n\n            if (validMove) {\n                maxCapture = fmax(maxCapture, currentCapture);\n            }\n        }\n    }\n\n    return maxCapture;\n}",
    "timestamp": "2025-08-05 22:05:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint max_captures(char* S) {\n    int L = strlen(S);\n    int max = 0;\n    \n    for (int i = 0; i < L; i++) {\n        if (S[i] == '.') {\n            int left = i - 1;\n            int right = i + 1;\n            int count_left = 0;\n            int count_right = 0;\n            int valid_left = 0;\n            int valid_right = 0;\n            \n            // Check left side\n            if (left >= 0 && S[left] == 'B') {\n                valid_left = 1;\n                for (int j = left; j >= 0; j--) {\n                    if (S[j] == 'B') {\n                        count_left++;\n                    } else if (S[j] == 'W' || S[j] == '.') {\n                        if (S[j] == '.') {\n                            valid_left = 0;\n                        }\n                        break;\n                    }\n                }\n            }\n            \n            // Check right side\n            if (right < L && S[right] == 'B') {\n                valid_right = 1;\n                for (int j = right; j < L; j++) {\n                    if (S[j] == 'B') {\n                        count_right++;\n                    } else if (S[j] == 'W' || S[j] == '.') {\n                        if (S[j] == '.') {\n                            valid_right = 0;\n                        }\n                        break;\n                    }\n                }\n            }\n            \n            int total = 0;\n            if (valid_left) {\n                total += count_left;\n            }\n            if (valid_right) {\n                total += count_right;\n            }\n            \n            if (total > max) {\n                max = total;\n            }\n        }\n    }\n    \n    return max;\n}\n\nint main() {\n    char S[1001];\n    scanf(\"%s\", S);\n    printf(\"%d\\n\", max_captures(S));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:05:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint maxBlackStonesCaptured(string S) {\n    int max_captured = 0;\n    int L = S.length();\n    \n    for (int i = 0; i < L; ++i) {\n        if (S[i] == '.') {\n            int left = i - 1;\n            int right = i + 1;\n            bool left_blocked = false;\n            bool right_blocked = false;\n            int captured_left = 0;\n            int captured_right = 0;\n            \n            // Check left side\n            while (left >= 0 && S[left] == 'B') {\n                captured_left++;\n                left--;\n            }\n            if (left >= 0 && S[left] == 'W') {\n                left_blocked = true;\n            }\n            \n            // Check right side\n            while (right < L && S[right] == 'B') {\n                captured_right++;\n                right++;\n            }\n            if (right < L && S[right] == 'W') {\n                right_blocked = true;\n            }\n            \n            // Update max_captured\n            if (left_blocked && captured_left > 0) {\n                max_captured = max(max_captured, captured_left);\n            }\n            if (right_blocked && captured_right > 0) {\n                max_captured = max(max_captured, captured_right);\n            }\n        }\n    }\n    \n    return max_captured;\n}",
    "timestamp": "2025-08-05 22:05:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "public class Solution {\n    public static int maxBlackStonesCaptured(String S) {\n        int maxCapture = 0;\n        int L = S.length();\n        \n        for (int i = 0; i < L; i++) {\n            if (S.charAt(i) == '.') {\n                int left = i - 1;\n                int right = i + 1;\n                int captureLeft = 0;\n                int captureRight = 0;\n                boolean leftValid = false;\n                boolean rightValid = false;\n                \n                // Check left side\n                if (left >= 0 && S.charAt(left) == 'B') {\n                    int j = left;\n                    while (j >= 0 && S.charAt(j) == 'B') {\n                        captureLeft++;\n                        j--;\n                    }\n                    if (j >= 0 && S.charAt(j) == 'W') {\n                        leftValid = true;\n                    }\n                }\n                \n                // Check right side\n                if (right < L && S.charAt(right) == 'B') {\n                    int j = right;\n                    while (j < L && S.charAt(j) == 'B') {\n                        captureRight++;\n                        j++;\n                    }\n                    if (j < L && S.charAt(j) == 'W') {\n                        rightValid = true;\n                    }\n                }\n                \n                if (leftValid && rightValid) {\n                    maxCapture = Math.max(maxCapture, captureLeft + captureRight);\n                } else if (leftValid) {\n                    maxCapture = Math.max(maxCapture, captureLeft);\n                } else if (rightValid) {\n                    maxCapture = Math.max(maxCapture, captureRight);\n                }\n            }\n        }\n        \n        return maxCapture;\n    }\n}",
    "timestamp": "2025-08-05 22:06:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "public class Solution {\n    public static int maxBlackStoneCapture(String board) {\n        int maxCapture = 0;\n        int L = board.length();\n        \n        for (int i = 0; i < L; i++) {\n            if (board.charAt(i) == '.') {\n                String newBoard = board.substring(0, i) + 'W' + board.substring(i + 1);\n                int captured = countCapturedStones(newBoard);\n                maxCapture = Math.max(maxCapture, captured);\n            }\n        }\n        \n        return maxCapture;\n    }\n    \n    private static int countCapturedStones(String board) {\n        int captured = 0;\n        boolean[] visited = new boolean[board.length()];\n        \n        for (int i = 0; i < board.length(); i++) {\n            if (board.charAt(i) == 'B' && !visited[i]) {\n                int group = checkBlackGroup(board, i, visited);\n                if (group == -1) {\n                    captured += countGroupStones(board, i, visited);\n                }\n            }\n        }\n        \n        return captured;\n    }\n    \n    private static int checkBlackGroup(String board, int start, boolean[] visited) {\n        int groupStatus = 1;\n        visited[start] = true;\n        \n        for (int i = start - 1; i >= 0; i--) {\n            if (board.charAt(i) == 'B') {\n                if (!visited[i]) {\n                    int status = checkBlackGroup(board, i, visited);\n                    groupStatus = Math.min(groupStatus, status);\n                }\n            } else if (board.charAt(i) == 'W') {\n                groupStatus = 0;\n                break;\n            } else {\n                groupStatus = -1;\n                break;\n            }\n        }\n        \n        for (int i = start + 1; i < board.length(); i++) {\n            if (board.charAt(i) == 'B') {\n                if (!visited[i]) {\n                    int status = checkBlackGroup(board, i, visited);\n                    groupStatus = Math.min(groupStatus, status);\n                }\n            } else if (board.charAt(i) == 'W') {\n                groupStatus = 0;\n                break;\n            } else {\n                groupStatus = -1;\n                break;\n            }\n        }\n        \n        return groupStatus;\n    }\n    \n    private static int countGroupStones(String board, int start, boolean[] visited) {\n        int count = 1;\n        \n        for (int i = start - 1; i >= 0; i--) {\n            if (board.charAt(i) == 'B' && !visited[i]) {\n                visited[i] = true;\n                count++;\n            } else {\n                break;\n            }\n        }\n        \n        for (int i = start + 1; i < board.length(); i++) {\n            if (board.charAt(i) == 'B' && !visited[i]) {\n                visited[i] = true;\n                count++;\n            } else {\n                break;\n            }\n        }\n        \n        return count;\n    }\n}",
    "timestamp": "2025-08-05 22:06:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "class Solution {\npublic:\n    int maxCapturedStones(string S) {\n        int L = S.length();\n        int maxCapture = 0;\n        \n        for (int i = 0; i < L; i++) {\n            if (S[i] == '.') {\n                string newBoard = S;\n                newBoard[i] = 'W';\n                int captured = countCapturedStones(newBoard);\n                maxCapture = max(maxCapture, captured);\n            }\n        }\n        \n        return maxCapture;\n    }\n    \nprivate:\n    int countCapturedStones(string& board) {\n        int L = board.length();\n        int captured = 0;\n        \n        for (int i = 0; i < L; i++) {\n            if (board[i] == 'B') {\n                if (isBlackChainCaptured(board, i)) {\n                    captured++;\n                }\n            }\n        }\n        \n        return captured;\n    }\n    \n    bool isBlackChainCaptured(string& board, int start) {\n        int L = board.length();\n        vector<bool> visited(L, false);\n        queue<int> q;\n        q.push(start);\n        visited[start] = true;\n        bool captured = true;\n        \n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n            \n            // Check left\n            if (curr > 0) {\n                if (board[curr-1] == '.') {\n                    captured = false;\n                    break;\n                }\n                if (board[curr-1] == 'B' && !visited[curr-1]) {\n                    q.push(curr-1);\n                    visited[curr-1] = true;\n                }\n            }\n            \n            // Check right\n            if (curr < L-1) {\n                if (board[curr+1] == '.') {\n                    captured = false;\n                    break;\n                }\n                if (board[curr+1] == 'B' && !visited[curr+1]) {\n                    q.push(curr+1);\n                    visited[curr+1] = true;\n                }\n            }\n        }\n        \n        return captured;\n    }\n};",
    "timestamp": "2025-08-05 22:06:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_captured_black_stones(S: str) -> int:\n    max_captures = 0\n    L = len(S)\n    \n    def capture_count(start: int, end: int) -> int:\n        return S[start:end].count('B')\n    \n    for i in range(L):\n        if S[i] == '.':\n            left, right = i, i\n            while left > 0 and S[left - 1] == 'B':\n                left -= 1\n            while right < L - 1 and S[right + 1] == 'B':\n                right += 1\n            \n            if left > 0 and right < L - 1 and S[left - 1] == 'W' and S[right + 1] == 'W':\n                max_captures = max(max_captures, capture_count(left, right + 1))\n    \n    return max_captures\n\n# Example test\nprint(max_captured_black_stones(\"B.W.BB\"))  # Output depends on the specific board configuration",
    "timestamp": "2025-08-13 08:57:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "public class OneDGo {\n    public static int maxCapturedStones(String S) {\n        int maxCapture = 0;\n        int n = S.length();\n\n        for (int i = 0; i < n; i++) {\n            if (S.charAt(i) == '.') {\n                // Try placing a white stone at the empty position\n                String newConfiguration = S.substring(0, i) + 'W' + S.substring(i + 1);\n\n                // Count captured black stones from left to right\n                int captureLeft = countCapture(newConfiguration, i, -1);\n                // Count captured black stones from right to left\n                int captureRight = countCapture(newConfiguration, i, 1);\n\n                // Update maxCapture if this placement captured more stones\n                maxCapture = Math.max(maxCapture, captureLeft + captureRight);\n            }\n        }\n\n        return maxCapture;\n    }\n\n    private static int countCapture(String S, int position, int direction) {\n        int count = 0;\n        int n = S.length();\n        char current = 'W';\n\n        int i = position + direction;\n        while (i >= 0 && i < n) {\n            char stone = S.charAt(i);\n            if (stone == current) return 0;\n            if (stone == 'B') {\n                count++;\n            } else if (stone == 'W') {\n                break;\n            }\n            i += direction;\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        String testBoard = \".BWB.B.\";\n        System.out.println(maxCapturedStones(testBoard)); // Example usage\n    }\n}",
    "timestamp": "2025-08-13 08:57:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint maxBlackCaptures(char* S) {\n    int maxCaptures = 0, L = strlen(S);\n    \n    for (int i = 0; i < L; i++) {\n        if (S[i] == '.') {\n            // Simulate placing a white stone at position i\n            int left = i - 1, right = i + 1;\n            int capturedLeft = 0, capturedRight = 0;\n            \n            // Check left side\n            while (left >= 0 && S[left] == 'B') {\n                capturedLeft++;\n                left--;\n            }\n            if (left < 0 || S[left] != 'W') {\n                capturedLeft = 0;\n            }\n            \n            // Check right side\n            while (right < L && S[right] == 'B') {\n                capturedRight++;\n                right++;\n            }\n            if (right >= L || S[right] != 'W') {\n                capturedRight = 0;\n            }\n            \n            int totalCaptured = capturedLeft + capturedRight;\n            if (totalCaptured > maxCaptures) {\n                maxCaptures = totalCaptured;\n            }\n        }\n    }\n    \n    return maxCaptures;\n}\n\nint main() {\n    char S[] = \"B.BWB.BB\";\n    printf(\"%d\\n\", maxBlackCaptures(S));\n    return 0;\n}",
    "timestamp": "2025-08-13 08:57:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_black_stones_capture(S):\n    L = len(S)\n    max_capture = 0\n    \n    for i in range(L):\n        if S[i] == '.':\n            new_board = list(S)\n            new_board[i] = 'W'\n            captured = count_captured_stones(new_board)\n            max_capture = max(max_capture, captured)\n    \n    return max_capture\n\ndef count_captured_stones(board):\n    L = len(board)\n    captured = 0\n    visited = [False] * L\n    \n    for i in range(L):\n        if board[i] == 'B' and not visited[i]:\n            group = find_group(board, i)\n            if is_group_captured(board, group):\n                captured += len(group)\n                for pos in group:\n                    visited[pos] = True\n    \n    return captured\n\ndef find_group(board, start):\n    group = [start]\n    color = board[start]\n    \n    for i in range(start-1, -1, -1):\n        if board[i] == color:\n            group.insert(0, i)\n        else:\n            break\n    \n    for i in range(start+1, len(board)):\n        if board[i] == color:\n            group.append(i)\n        else:\n            break\n    \n    return group\n\ndef is_group_captured(board, group):\n    for pos in group:\n        left = pos - 1\n        right = pos + 1\n        \n        if (left < 0 or board[left] == 'W') and \\\n           (right >= len(board) or board[right] == 'W'):\n            return False\n    \n    return True",
    "timestamp": "2025-08-13 08:57:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_black_stones_captured(S):\n    max_captured = 0\n    L = len(S)\n    \n    for i in range(L):\n        if S[i] == '.':\n            left = i - 1\n            right = i + 1\n            captured_left = 0\n            captured_right = 0\n            \n            # Check left side\n            if left >= 0 and S[left] == 'B':\n                temp_left = left\n                while temp_left >= 0 and S[temp_left] == 'B':\n                    temp_left -= 1\n                if temp_left >= 0 and S[temp_left] == 'W':\n                    captured_left = left - temp_left\n            \n            # Check right side\n            if right < L and S[right] == 'B':\n                temp_right = right\n                while temp_right < L and S[temp_right] == 'B':\n                    temp_right += 1\n                if temp_right < L and S[temp_right] == 'W':\n                    captured_right = temp_right - right\n            \n            total_captured = captured_left + captured_right\n            if total_captured > max_captured:\n                max_captured = total_captured\n    \n    return max_captured",
    "timestamp": "2025-08-13 08:57:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nint maxBlackCaptures(const std::string &S) {\n    int maxCapture = 0;\n    int n = S.length();\n    \n    for (int i = 0; i < n; ++i) {\n        if (S[i] == '.') {\n            int left = i - 1;\n            int right = i + 1;\n            int countLeft = 0;\n            int countRight = 0;\n            \n            // Count black stones to the left\n            while (left >= 0 && S[left] == 'B') {\n                countLeft++;\n                left--;\n            }\n            // Check if they are surrounded by a white stone\n            if (left < 0 || S[left] != 'W') countLeft = 0;\n            \n            // Count black stones to the right\n            while (right < n && S[right] == 'B') {\n                countRight++;\n                right++;\n            }\n            // Check if they are surrounded by a white stone\n            if (right >= n || S[right] != 'W') countRight = 0;\n            \n            // Ensure we do not create a chain of white stones\n            if ((i > 0 && S[i - 1] != 'W') || (i < n - 1 && S[i + 1] != 'W')) {\n                int totalCapture = countLeft + countRight;\n                maxCapture = std::max(maxCapture, totalCapture);\n            }\n        }\n    }\n    \n    return maxCapture;\n}\n\nint main() {\n    std::string board = \"BWBBW.B.B.W\";\n    std::cout << maxBlackCaptures(board) << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:48:41"
  }
]