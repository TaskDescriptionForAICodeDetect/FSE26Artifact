[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n// #include <ctime>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nint main(){\n\tull v = 0;\n\tconst int MAX_N = 50;\n\tint X1[MAX_N], Y1[MAX_N], D1[MAX_N], X2[MAX_N], Y2[MAX_N], D2[MAX_N];\n\tint N, K;\n\n\tcin >> N >> K;\n\n\tvector<int> X(2 * N), Y(2 * N), D(2 * N);\n\n\tfor (int i = 0; i<N; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t\tX[i]     = X1[i];\n\t\tX[i + N] = X2[i];\n\t\tY[i]     = Y1[i];\n\t\tY[i + N] = Y2[i];\n\t\tD[i]     = D1[i];\n\t\tD[i + N] = D2[i];\n\t}\n//\tclock_t st = clock();\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\tX.erase(unique(X.begin(), X.end()), X.end());\n\tY.erase(unique(Y.begin(), Y.end()), Y.end());\n\tD.erase(unique(D.begin(), D.end()), D.end());\n\n\tfor (int i = 0, nx = X.size() - 1; i<nx; i++){\n\tfor (int j = 0, ny = Y.size() - 1; j<ny; j++){\n\tfor (int k = 0, nd = D.size() - 1; k<nd; k++){\n\t\tint kind = 0;\n\t\tfor (int l = 0; l < N; l++){\n\t\t\tif (X1[l] <= X[i] && X[i+1] <= X2[l] && \n\t\t\t\tY1[l] <= Y[j] && Y[j+1] <= Y2[l] && \n\t\t\t\tD1[l] <= D[k] && D[k+1] <= D2[l]) kind++;\n\t\t}\n\t\tif (kind >= K) v += (ull)(X[i+1] - X[i]) * (Y[j+1] - Y[j]) * (D[k+1] - D[k]);\n\t}\n\t}\n\t}\n\n\tcout << v << endl;\n//\tclock_t ed = clock();\n//\tcout << (double)(ed - st) / CLOCKS_PER_SEC << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nint main()\n{\n\tint N, K;\n\tcin >> N >> K;\n\n\tvector<long long int> X1(N), Y1(N), D1(N), X2(N), Y2(N), D2(N);\n\tvector<long long int> xs, ys, ds;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t\txs.push_back(X1[i]); xs.push_back(X2[i]);\n\t\tys.push_back(Y1[i]); ys.push_back(Y2[i]);\n\t\tds.push_back(D1[i]); ds.push_back(D2[i]);\n\t}\n\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\tsort(ds.begin(), ds.end());\n\n\tlong long int volume = 0;\n\n\tfor(int x = 0; x < xs.size()-1; x++) {\n\t\tfor(int y = 0; y < ys.size()-1; y++) {\n\t\t\tfor(int d = 0; d < ds.size()-1; d++) {\n\t\t\t\tint k = 0;\n\n\t\t\t\tfor(int n = 0; n < N; n++) {\n\t\t\t\t\tk += (xs[x] >= X1[n] && X2[n] >= xs[x+1]) &&\n\t\t\t\t\t     (ys[y] >= Y1[n] && Y2[n] >= ys[y+1]) &&\n\t\t\t\t\t     (ds[d] >= D1[n] && D2[n] >= ds[d+1]);\n\t\t\t\t}\n\n\t\t\t\tif(K <= k) {\n\t\t\t\t\tvolume += (xs[x+1] - xs[x]) * (ys[y+1] - ys[y]) * (ds[d+1] - ds[d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << volume << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tint N,K;\n\tscanf(\"%d%d\",&N,&K);\n\tint x[2][50],y[2][50],z[2][50];\n\tvector<int> dx,dy,dz;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d%d%d\",&x[0][i],&y[0][i],&z[0][i],&x[1][i],&y[1][i],&z[1][i]);\n\t\tdx.push_back(x[0][i]); dx.push_back(x[1][i]);\n\t\tdy.push_back(y[0][i]); dy.push_back(y[1][i]);\n\t\tdz.push_back(z[0][i]); dz.push_back(z[1][i]);\n\t}\n\tsort(dx.begin(),dx.end());sort(dy.begin(),dy.end());sort(dz.begin(),dz.end());\n\tdx.erase(unique(dx.begin(),dx.end()),dx.end());\n\tdy.erase(unique(dy.begin(),dy.end()),dy.end());\n\tdz.erase(unique(dz.begin(),dz.end()),dz.end());\n\tint d[dx.size()-1][dy.size()-1][dz.size()-1];\n\tfor(int i=0;i<dx.size();i++) for(int j=0;j<dy.size();j++) for(int k=0;k<dz.size();k++) d[i][j][k]=0;\n\tfor(int s=0;s<N;s++) for(int i=0;i<dx.size()-1;i++) for(int j=0;j<dy.size()-1;j++) for(int k=0;k<dz.size()-1;k++)\n\t\tif(x[0][s]<=dx[i]&&dx[i+1]<=x[1][s]) if(y[0][s]<=dy[j]&&dy[j+1]<=y[1][s]) if(z[0][s]<=dz[k]&&dz[k+1]<=z[1][s])\n\t\t\td[i][j][k]++;\n\tll res=0;\n\tfor(int i=0;i<dx.size()-1;i++) for(int j=0;j<dy.size()-1;j++) for(int k=0;k<dz.size()-1;k++)\n\t\tif(d[i][j][k]>=K) res+=(ll)(dx[i+1]-dx[i])*(dy[j+1]-dy[j])*(dz[k+1]-dz[k]);\n\tprintf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n,K;\nint X1[55],X2[55],Y1[55],Y2[55],D1[55],D2[55];\nint sx1[55],sx2[55],sy1[55],sy2[55],sd1[55],sd2[55];\nvector<int> xs,ys,ds;\nint m[111][111][111];\nint main(void){\n  cin >> n >> K;\n  for(int i = 0; i < n; i++){\n    cin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n    xs.push_back(X1[i]);\n    xs.push_back(X2[i]);\n    ys.push_back(Y1[i]);\n    ys.push_back(Y2[i]);\n    ds.push_back(D1[i]);\n    ds.push_back(D2[i]);\n  }\n\n  sort(xs.begin(),xs.end());\n  sort(ys.begin(),ys.end());\n  sort(ds.begin(),ds.end());\n\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  ys.erase(unique(ys.begin(),ys.end()),ys.end());\n  ds.erase(unique(ds.begin(),ds.end()),ds.end());\n\n  for(int i = 0; i < n; i++){\n    sx1[i] = find(xs.begin(),xs.end(),X1[i]) - xs.begin();\n    sx2[i] = find(xs.begin(),xs.end(),X2[i]) - xs.begin();\n    sy1[i] = find(ys.begin(),ys.end(),Y1[i]) - ys.begin();\n    sy2[i] = find(ys.begin(),ys.end(),Y2[i]) - ys.begin();\n    sd1[i] = find(ds.begin(),ds.end(),D1[i]) - ds.begin();\n    sd2[i] = find(ds.begin(),ds.end(),D2[i]) - ds.begin();\n\n    m[sx1[i]][sy1[i]][sd1[i]]++; m[sx2[i]][sy2[i]][sd1[i]]++; m[sx1[i]][sy2[i]][sd2[i]]++; m[sx2[i]][sy1[i]][sd2[i]]++;\n    m[sx1[i]][sy2[i]][sd1[i]]--; m[sx2[i]][sy1[i]][sd1[i]]--; m[sx1[i]][sy1[i]][sd2[i]]--; m[sx2[i]][sy2[i]][sd2[i]]--;\n  }\n\n  for(int i = 0; i <= 105; i++){\n    for(int j = 0; j <= 105; j++){\n      for(int k = 0; k <= 105; k++){\n\tm[i+1][j][k] += m[i][j][k];\n      }\n    }\n  }  \n  for(int i = 0; i <= 105; i++){\n    for(int j = 0; j <= 105; j++){\n      for(int k = 0; k <= 105; k++){\n\tm[i][j+1][k] += m[i][j][k];\n      }\n    }\n  }\n  for(int i = 0; i <= 105; i++){\n    for(int j = 0; j <= 105; j++){\n      for(int k = 0; k <= 105; k++){\n\tm[i][j][k+1] += m[i][j][k];\n      }\n    }\n  }\n\n  long long int res = 0;\n  for(int i = 0; i <= 105; i++){\n    for(int j = 0; j <= 105; j++){\n      for(int k = 0; k <= 105; k++){\n\tif(m[i][j][k] < K) continue;\n\tres += (long long int)(xs[i+1]-xs[i]) * (ys[j+1]-ys[j]) * (ds[k+1]-ds[k]);\n      }\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <string>\nconst int INF = 1 << 30;\nusing namespace std;\n\nint n, k;\n\nint pt[300][300][300];\nint X1[50], X2[50], Y1[50], Y2[50], D1[50], D2[50];\nunsigned long long int uX[150], uY[150], uD[150];\n\nint compress(int *x1, int *x2, unsigned long long int *unzip){\n\tvector<int> vec;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = -1; j <= 1; j++){\n\t\t\tint a = x1[i] + j, b = x2[i] + j;\n\t\t\tif (0 <= a) vec.push_back(a);\n\t\t\tif (0 <= b) vec.push_back(b);\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tfor (int i = 0; i < n; i++){\n\t\tx1[i] = find(vec.begin(), vec.end(), x1[i]) - vec.begin();\n\t\tx2[i] = find(vec.begin(), vec.end(), x2[i]) - vec.begin();\n\t}\n\tfor (int i = 0; i < vec.size(); i++)\n\t\tunzip[i] = vec[i];\n\treturn vec.size();\n}\n\nint main(){\n\tint W, H, D;\n\tunsigned long long int ans = 0;\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i];\n\t\tcin >> X2[i] >> Y2[i] >> D2[i];\n\t}\n\tW = compress(X1, X2, uX);\n\tH = compress(Y1, Y2, uY);\n\tD = compress(D1, D2, uD);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = X1[i]; j < X2[i]; j++){\n\t\t\tfor (int m = Y1[i]; m < Y2[i]; m++){\n\t\t\t\tfor (int l = D1[i]; l < D2[i]; l++){\n\t\t\t\t\tpt[j][m][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int m = 0; m <D; m++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tfor (int i = 0; i < W;i++){\n\t\t\t\tif (pt[i][j][m] >= k&&uX[i + 1] && uY[j + 1] && uD[m + 1]){\n\t\t\t\t\t\tans += (uX[i+1] - uX[i]) * (uY[j+1] - uY[j]) * (uD[m+1] - uD[m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <assert.h>\n#include <string.h>\n\nusing namespace std;\n\nnamespace\n{\n\tint n, k;\n\tint x1[50], yy[50], d1[50], x2[50], y2[50], d2[50];\n\tint cx1[50], cy1[50], cd1[50], cx2[50], cy2[50], cd2[50];\n\n\tint compd[123][123][123];\n}\n\n//w1,w2???????????????????????§???????????§???????????????\nvector<int> compress(int *w1, int *w2)\n{\n\tvector<int>ws;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tws.push_back(w1[i]);\n\t\tws.push_back(w2[i]);\n\t}\n\tsort(ws.begin(), ws.end());\n\tws.erase(unique(ws.begin(), ws.end()), ws.end());\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tw1[i] = find(ws.begin(), ws.end(), w1[i]) - ws.begin();\n\t\tw2[i] = find(ws.begin(), ws.end(), w2[i]) - ws.begin();\n\t}\n\treturn ws;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &k);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d %d %d %d %d %d\", x1 + i, yy + i, d1 + i, x2 + i, y2 + i, d2 + i);\n\t}\n\t\n\tauto xsv = compress(x1, x2);\n\tauto ysv = compress(yy, y2);\n\tauto dsv = compress(d1, d2);\n\tint xs = xsv.size();\n\tint ys = ysv.size();\n\tint ds = dsv.size();\n\n\tmemset(compd, 0, sizeof(compd));\n\n\t//??????????¨????\n\tfor (int i = 0;i < n;++i)\n\t{\n\t\tconst int hash[8][3] = { {0,0,0},{0,0,1},{0,1,0},{0,1,1},{1,0,0},{1,0,1},{1,1,0},{1,1,1}, };\n\t\tfor (int p = 0; p < 8; ++p)\n\t\t{\n\t\t\tcompd\n\t\t\t\t[hash[p][0] ? x1[i] : x2[i]]\n\t\t\t\t[hash[p][1] ? yy[i] : y2[i]]\n\t\t\t\t[hash[p][2] ? d1[i] : d2[i]] =\n\t\t\t\t\t(hash[p][0]^hash[p][1]^hash[p][2]) ? 1 : -1;\n\t\t}\n\t}\n\t\n\t//?´????????????¨???\n\tfor (int x = 0; x < xs; ++x)\n\t{\n\t\tfor (int y = 0; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 1; d < ds; ++d)\n\t\t\t{\n\t\t\t\tcompd[x][y][d] += compd[x][y][d - 1];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 0; x < xs; ++x)\n\t{\n\t\tfor (int y = 1; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < ds; ++d)\n\t\t\t{\n\t\t\t\tcompd[x][y][d] += compd[x][y - 1][d];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 1; x < xs; ++x)\n\t{\n\t\tfor (int y = 0; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < ds; ++d)\n\t\t\t{\n\t\t\t\tcompd[x][y][d] += compd[x - 1][y][d];\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor (int x = 0; x < xs; ++x)\n\t{\n\t\tfor (int y = 0; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < ds; ++d)\n\t\t\t{\n\t\t\t\tassert(compd[x][y][d] >= 0);\n\t\t\t\tif (compd[x][y][d] >= k)\n\t\t\t\t{\n\t\t\t\t\tans += (xsv[x + 1] - xsv[x]) * (ysv[y + 1] - ysv[y]) * (dsv[d + 1] - dsv[d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#define all(c) (c).begin(),(c).end()\n#define f first\n#define s second\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct point{ll x,y,z;};\n\ntypedef pair<point,point> P;\n\nint main(void){\n  ll n,k,x1,x2,y1,y2,z1,z2;\n  vector<ll>x,y,z;\n\n  cin >> n >> k;\n  vector<P> p(n);\n\n  for(int i=0;i<n;i++){\n    cin >> p[i].f.x >> p[i].f.y >> p[i].f.z;\n    cin >> p[i].s.x >> p[i].s.y >> p[i].s.z;\n\n    x.push_back(p[i].f.x);\n    x.push_back(p[i].s.x);\n    y.push_back(p[i].f.y);\n    y.push_back(p[i].s.y);\n    z.push_back(p[i].f.z);\n    z.push_back(p[i].s.z);\n  }\n  \n  sort(all(x));\n  sort(all(y));\n  sort(all(z));\n\n  map<ll,int>X,Y,Z;\n  \n  for(int i=0;i<x.size();i++)X[x[i]]=i;\n  for(int i=0;i<y.size();i++)Y[y[i]]=i;\n  for(int i=0;i<z.size();i++)Z[z[i]]=i;\n  \n  int grid[101][101][101];\n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)\n      for(int l=0;l<101;l++)grid[i][j][l]=0;\n\n  for(int i=0;i<n;i++)\n    for(int xi=X[p[i].f.x];xi<X[p[i].s.x];xi++)\n      for(int yi=Y[p[i].f.y];yi<Y[p[i].s.y];yi++)\n\tfor(int zi=Z[p[i].f.z];zi<Z[p[i].s.z];zi++)\n\t  grid[xi][yi][zi]++;\n\n  ll ans=0;\n  for(int i=0;i<x.size()-1;i++)\n    for(int j=0;j<y.size()-1;j++)\n      for(int l=0;l<z.size()-1;l++)\n\tif(grid[i][j][l]>=k)\n\t  ans+=(x[i+1]-x[i])*(y[j+1]-y[j])*(z[l+1]-z[l]);\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint num[200][200][200]; //x,y,z\nint main(void){\n\tint n, k; cin >> n >> k;\n\trep(x, 200)rep(y, 200)rep(z, 200) num[x][y][z] = 0;\n\tint x1, y1, z1, x2, y2, z2;\n\tfor (int i = 0; i < n; ++i){\n\t\tcin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n\t\tfor (int x = x1; x < x2; ++x){\n\t\t\tfor (int y = y1; y < y2; ++y){\n\t\t\t\tfor (int z = z1; z < z2; ++z){\n\t\t\t\t\tnum[x][y][z]++;z\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(x, 200)rep(y, 200)rep(z, 200){\n\t\tif(num[x][y][z] == k) ans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <climits>\n#include <string>\n#include <vector>\n#include <map>\n#include <cmath>\nusing namespace std;\n\nint N, K;\nint X1[110], Y1[110], D1[110];\nint X2[110], Y2[110], D2[110];\nint field[110][110][110];\n\nmap<int, int> zip_x, zip_y, zip_z;\nint unzip_x[110], unzip_y[110], unzip_z[110];\n\nvoid compress(vector<int> &x, map<int, int> &zip, int unzip[]) {\n  sort(x.begin(), x.end());\n  x.erase(unique(x.begin(), x.end()), x.end());\n  for (int i=0; i<x.size(); i++) {\n    zip[x[i]] = i;\n    unzip[i] = x[i];\n  }\n}\n\nint main() {\n  cin >> N >> K;\n  vector<int> xs, ys, zs;\n  for (int i=0; i<N; i++) {\n    cin >> X1[i] >> Y1[i] >> D1[i];\n    cin >> X2[i] >> Y2[i] >> D2[i];\n    xs.push_back(X1[i]); xs.push_back(X2[i]);\n    ys.push_back(Y1[i]); ys.push_back(Y2[i]);\n    zs.push_back(D1[i]); zs.push_back(D2[i]);\n  }\n\n  compress(xs, zip_x, unzip_x);\n  compress(ys, zip_y, unzip_y);\n  compress(zs, zip_z, unzip_z);\n\n  for (int i=0; i<N; i++) {\n    for (int x=zip_x[X1[i]]; x<zip_x[X2[i]]; x++) {\n      for (int y=zip_y[Y1[i]]; y<zip_y[Y2[i]]; y++) {\n        for (int z=zip_z[D1[i]]; z<zip_z[D2[i]]; z++) {\n          field[x][y][z]++;\n        }\n      }\n    }\n  }\n\n  long long ans = 0;\n  for (int x=0; x<110; x++) {\n    for (int y=0; y<110; y++) {\n      for (int z=0; z<110; z++) {\n        if (field[x][y][z] >= K) {\n          ans += (long)(unzip_x[x+1]-unzip_x[x])\n                *(long)(unzip_y[y+1]-unzip_y[y])\n                *(long)(unzip_z[z+1]-unzip_z[z]);\n        }\n      }\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n\nll H[6][60];//x1,y1,z1,x2,y2,z2\nvector<ll>V[3];\n\nint main() {\n\tint n, k;\n\tll ans = 0;\n\tscanf(\"%d%d\", &n, &k);\n\trep(i, n) {\n\t\trep(j, 6) {\n\t\t\tscanf(\"%lld\", &H[j][i]);\n\t\t\tV[j % 3].push_back(H[j][i]);\n\t\t}\n\t}\n\trep(i, 3)\n\t\tsort(V[i].begin(), V[i].end());\n\trep(i, V[0].size()-1) {\n\t\trep(j, V[1].size()-1) {\n\t\t\trep(t, V[2].size()-1) {\n\t\t\t\tll cnt = 0;\n\t\t\t\trep(k, n) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tV[0][i] >= H[0][k] && H[3][k] >= V[0][i + 1] &&\n\t\t\t\t\t\tV[1][j] >= H[1][k] && H[4][k] >= V[1][j + 1] &&\n\t\t\t\t\t\tV[2][t] >= H[2][k] && H[5][k] >= V[2][t + 1]\n\t\t\t\t\t\t)\n\t\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif (cnt >= k) \n\t\t\t\t\tans += (V[0][i + 1] - V[0][i])*(V[1][j + 1] - V[1][j])*(V[2][t + 1] - V[2][t]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n \nint main(){\n    vector<int>x,y,d;\n    static int zx[1000000+2],zy[1000000+2],zd[1000000+2],p[50][6],n,k,sea[102][102][102];\n    long long int ans=0,a;\n    scanf(\"%d%d\",&n,&k);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<6;j++){\n            scanf(\"%d\",&p[i][j]);\n        }\n        x.push_back(p[i][0]);\n        x.push_back(p[i][3]);\n        y.push_back(p[i][1]);\n        y.push_back(p[i][4]);\n        d.push_back(p[i][2]);\n        d.push_back(p[i][5]);\n    }\n    sort(x.begin(),x.end());\n    sort(y.begin(),y.end());\n    sort(d.begin(),d.end());\n    int N=2*n+1;\n    for(int i=0;i<N-1;i++){\n        zx[x[i]]=i;\n        zy[y[i]]=i;\n        zd[d[i]]=i;\n    }\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            for(int l=0;l<N;l++){\n                sea[i][j][l]=0;\n            }\n        }\n    }\n     \n    for(int i=0;i<n;i++){\n        sea[zx[p[i][0]]][zy[p[i][1]]][zd[p[i][2]]]++;\n        sea[zx[p[i][0]]][zy[p[i][1]]][zd[p[i][5]]]--;\n        sea[zx[p[i][0]]][zy[p[i][4]]][zd[p[i][2]]]--;\n        sea[zx[p[i][0]]][zy[p[i][4]]][zd[p[i][5]]]++;\n        sea[zx[p[i][3]]][zy[p[i][1]]][zd[p[i][2]]]--;\n        sea[zx[p[i][3]]][zy[p[i][1]]][zd[p[i][5]]]++;\n        sea[zx[p[i][3]]][zy[p[i][4]]][zd[p[i][2]]]++;\n        sea[zx[p[i][3]]][zy[p[i][4]]][zd[p[i][5]]]--;\n    }\n    for(int i=1;i<N;i++){\n        for(int j=0;j<N;j++){\n            for(int l=0;l<N;l++){\n                sea[i][j][l]+=sea[i-1][j][l];\n            }\n        }\n    }\n    for(int i=0;i<N;i++){\n        for(int j=1;j<N;j++){\n            for(int l=0;l<N;l++){\n                sea[i][j][l]+=sea[i][j-1][l];\n            }\n        }\n    }\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            for(int l=0;l<N;l++){\n                if(l!=0)sea[i][j][l]+=sea[i][j][l-1];\n                if(sea[i][j][l]>=k){\n                    a=1;\n                    a=x[i+1]-x[i];\n                    a*=y[j+1]-y[j];\n                    a*=d[l+1]-d[l];\n                    ans+=a;\n                }\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n// #include <ctime>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nint main(){\n\tull v = 0;\n\tconst int MAX_N = 50;\n\tint X1[MAX_N], Y1[MAX_N], D1[MAX_N], X2[MAX_N], Y2[MAX_N], D2[MAX_N];\n\tint N, K;\n\n\tcin >> N >> K;\n\n\tvector<int> X(2 * N), Y(2 * N), D(2 * N);\n\n\tfor (int i = 0; i<N; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t\tX[i]     = X1[i];\n\t\tX[i + N] = X2[i];\n\t\tY[i]     = Y1[i];\n\t\tY[i + N] = Y2[i];\n\t\tD[i]     = D1[i];\n\t\tD[i + N] = D2[i];\n\t}\n//\tclock_t st = clock();\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\tfor (int i = 0, n = 2*N - 1; i<n; i++){\n\tfor (int j = 0; j<n; j++){\n\tfor (int k = 0; k<n; k++){\n\t\tint kind = 0;\n\t\tfor (int l = 0; l < N; l++){\n\t\t\tif (X1[l] <= X[i] && X[i+1] <= X2[l] && \n\t\t\t\tY1[l] <= Y[j] && Y[j+1] <= Y2[l] && \n\t\t\t\tD1[l] <= D[k] && D[k+1] <= D2[l]) kind++;\n\t\t}\n\t\tif (kind >= K) v += (ull)(X[i+1] - X[i]) * (Y[j+1] - Y[j]) * (D[k+1] - D[k]);\n\t}\n\t}\n\t}\n\n\tcout << v << endl;\n//\tclock_t ed = clock();\n//\tcout << (double)(ed - st) / CLOCKS_PER_SEC << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long Int;\n\nint main(){\n\tconst int MAX_N = 50;\n\tint N, K;\n\tint X1[MAX_N], Y1[MAX_N], D1[MAX_N], X2[MAX_N], Y2[MAX_N], D2[MAX_N];\n\tvector<int> X, Y, D;\n\tInt ans = 0;\n\tint k;\n\t\n\tscanf(\"%d%d\", &N, &K);\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d%d%d%d%d%d\", &X1[i], &Y1[i], &D1[i], &X2[i], &Y2[i], &D2[i]);\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tX.push_back(X1[i] - 1); X.push_back(X1[i]);\n\t\tX.push_back(X2[i]); X.push_back(X2[i] + 1);\n\t\tY.push_back(Y1[i] - 1); Y.push_back(Y1[i]);\n\t\tY.push_back(Y2[i]); Y.push_back(Y2[i] + 1);\n\t\tD.push_back(D1[i] - 1); D.push_back(D1[i]);\n\t\tD.push_back(D2[i]); D.push_back(D2[i] + 1);\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\tX.erase(unique(X.begin(), X.end()), X.end());\n\tY.erase(unique(Y.begin(), Y.end()), Y.end());\n\tD.erase(unique(D.begin(), D.end()), D.end());\n\t\n\tfor(int d = 0; d < D.size() - 1; d++){\n\t\tfor(int y = 0; y < Y.size() - 1; y++){\n\t\t\tfor(int x = 0; x < X.size() - 1; x++){\n\t\t\t\tk = 0;\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tif(X1[i] <= X[x] && Y1[i] <= Y[y] && D1[i] <= D[d]\n\t\t\t\t\t && X2[i] >= X[x + 1] && Y2[i] >= Y[y + 1] && D2[i] >= D[d + 1]){\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(k >= K){\n\t\t\t\t\tans += (Int)(X[x + 1] - X[x]) * (Y[y + 1] - Y[y]) * (D[d + 1] - D[d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<long long>X, Y, Z;\nlong long ax[100], ay[100], az[100], bx[100], by[100], bz[100], n, q, r[100][100][100], sum;\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> ax[i] >> ay[i] >> az[i] >> bx[i] >> by[i] >> bz[i];\n\t\tX.push_back(ax[i]); X.push_back(bx[i]);\n\t\tY.push_back(ay[i]); Y.push_back(by[i]);\n\t\tZ.push_back(az[i]); Z.push_back(bz[i]);\n\t}\n\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end()); sort(Z.begin(), Z.end());\n\tfor (int i = 0; i < n; i++) { for (int j = 0; j < X.size(); j++) { if (ax[i] == X[j])ax[i] = j; if (bx[i] == X[j])bx[i] = j; } }\n\tfor (int i = 0; i < n; i++) { for (int j = 0; j < Y.size(); j++) { if (ay[i] == Y[j])ay[i] = j; if (by[i] == Y[j])by[i] = j; } }\n\tfor (int i = 0; i < n; i++) { for (int j = 0; j < Z.size(); j++) { if (az[i] == Z[j])az[i] = j; if (bz[i] == Z[j])bz[i] = j; } }\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = ax[i]; j < bx[i]; j++) { for (int k = ay[i]; k < by[i]; k++) { for (int l = az[i]; l < bz[i]; l++)r[j][k][l]++; } }\n\t}\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = 0; j < Y.size(); j++) {\n\t\t\tfor (int k = 0; k < Z.size(); k++) {\n\t\t\t\tif (r[i][j][k] >= q) {\n\t\t\t\t\tsum += (X[i + 1] - X[i])*(Y[j + 1] - Y[j])*(Z[k + 1] - Z[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,-1,0,1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n      \n\nint a[120][120][120]={0};\nmap<int,int>mx,my,mz;\nset<int> sx,sy,sz;\n\n\n\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nint x1[60];\nint x2[60];\nint y1[60];\nint y2[60];\nint z1[60];\nint z2[60];\nint gx[120],gy[120],gz[120];\n  \tint n,e;\n  \tcin>>n>>e;\n\n  \tfor(int i=0;i<n;i++)cin>>x1[i]>>y1[i]>>z1[i]>>x2[i]>>y2[i]>>z2[i];\n  \tfor(int i=0;i<n;i++){\n  \t\tsx.insert(x1[i]);\n  \t\tsx.insert(x2[i]);\n  \t\tsy.insert(y1[i]);\n  \t\tsy.insert(y2[i]);\n  \t\tsz.insert(z1[i]);\n  \t\tsz.insert(z2[i]);\n  \t}\n  \tint cnt;\n  \tcnt=0;\n  \tfor(auto it=sx.begin();it!=sx.end();it++){\n  \t\tmx[*it]=cnt;\n  \t\tgx[cnt]=*it;\n  \t\tcnt++;\n  \t}\n  \t\n  \tcnt=0;\n  \tfor(auto it=sy.begin();it!=sy.end();it++){\n  \t\tmy[*it]=cnt;\n  \t\tgy[cnt]=*it;\n  \t\tcnt++;\n  \t}\n  \t\n  \t\n  \tcnt=0;\n  \tfor(auto it=sz.begin();it!=sz.end();it++){\n  \t\tmz[*it]=cnt;\n  \t\tgz[cnt]=*it;\n  \t\tcnt++;\n  \t}\n  \tfor(int i=0;i<n;i++){\n  \t\tx1[i]=mx[x1[i]];\n  \t\tx2[i]=mx[x2[i]];\n  \t\ty1[i]=my[y1[i]];\n  \t\ty2[i]=my[y2[i]];\n  \t\tz1[i]=mz[z1[i]];\n  \t\tz2[i]=mz[z2[i]];\n  \t}\n  \t\n  \tfor(int r=0;r<n;r++){\n  \t\tfor(int i=x1[r];i<x2[r];i++)for(int j=y1[r];j<y2[r];j++)for(int k=z1[r];k<z2[r];k++)a[i][j][k]++;\n  \t}\n  \tint ans=0;\n  \tfor(int i=0;i<120;i++)for(int j=0;j<120;j++)for(int k=0;k<120;k++)if(a[i][j][k]>=e){\n  \t\tans+=(gx[i+1]-gx[i])*(gy[j+1]-gy[j])*(gz[k+1]-gz[k]);\n  \t}\n  \tcout<<ans<<endl;\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nvector<int> xx,yy,zz;\n#undef int\nint main(){\n\t#define int long long\n\tint N,K;\tcin>>N>>K;\n\tvector<int> sx(N),tx(N),sy(N),ty(N),sz(N),tz(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>sx[i]>>sy[i]>>sz[i]>>tx[i]>>ty[i]>>tz[i];\n\t\txx.push_back(sx[i]);\txx.push_back(tx[i]);\n\t\tyy.push_back(sy[i]);\tyy.push_back(ty[i]);\n\t\tzz.push_back(sz[i]);\tzz.push_back(tz[i]);\n\t}\n\tsort(xx.begin(),xx.end());\txx.erase(unique(xx.begin(),xx.end()),xx.end());\n\tsort(yy.begin(),yy.end());\tyy.erase(unique(yy.begin(),yy.end()),yy.end());\n\tsort(zz.begin(),zz.end());\tzz.erase(unique(zz.begin(),zz.end()),zz.end());\n\tfor(int i=0;i<(int)xx.size();i++)\tcout<<xx[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<(int)yy.size();i++)\tcout<<yy[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<(int)zz.size();i++)\tcout<<zz[i]<<\" \";\n\tcout<<endl;\n\tint ans=0;\n\tfor(int i=1;i<(int)xx.size();i++){\n\t\tfor(int j=1;j<(int)yy.size();j++){\n\t\t\tfor(int k=1;k<(int)zz.size();k++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int l=0;l<N;l++){\n\t\t\t\t\tif(sx[l]<=xx[i-1]&&xx[i]<=tx[l]&&sy[l]<=yy[j-1]&&yy[j]<=ty[l]&&sz[l]<=zz[k-1]&&zz[k]<=tz[l]){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt>=K){\n\t\t\t\t\tans+=(xx[i]-xx[i-1])*(yy[j]-yy[j-1])*(zz[k]-zz[k-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint n, k;\nvector<ll> xs, ys, zs;//?????¨????????§?¨?\nmap<ll, ll> zipx, zipy, zipz;//<???, ??§??????>\nmap<ll, ll> unzipx, unzipy, unzipz;//<??§??????, ???>\nint num[100][100][100];//???????¨?????????\\??????\n\nint main(void){\n\tcin >> n >> k;\n\tll x1[51], x2[51], y1[51], y2[51], z1[51], z2[51];//?????????????????§?¨?\n\trep(i, n){\n\t\tcin >> x1[i] >> y1[i] >> z1[i];\n\t\tcin >> x2[i] >> y2[i] >> z2[i];\n\t\txs.push_back(x1[i]); xs.push_back(x2[i]);\n\t\tys.push_back(y1[i]); ys.push_back(y2[i]);\n\t\tzs.push_back(z1[i]); zs.push_back(z2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(),xs.end()), xs.end());//???????¶????\n\tsort(ys.begin(), ys.end());\n\tys.erase(unique(ys.begin(), ys.end()), ys.end());\n\tsort(zs.begin(), zs.end());\n\tzs.erase(unique(zs.begin(), zs.end()), zs.end());\n\n\trep(i, xs.size()){\n\t\tzipx[i] = xs[i];\n\t\tunzipx[xs[i]] = i;\n\t}\n\trep(i, ys.size()){\n\t\tzipy[i] = ys[i];\n\t\tunzipy[ys[i]] = i;\n\t}\n\trep(i, zs.size()){\n\t\tzipz[i] = zs[i];\n\t\tunzipz[zs[i]] = i;\n\t}\n\n\tmemset(num, 0, sizeof(num));\n\tfor (int i = 0; i < n; ++i){\n\t\tfor (int x = unzipx[x1[i]]; x < unzipx[x2[i]]; ++x){\n\t\t\tfor (int y = unzipy[y1[i]]; y < unzipy[y2[i]]; ++y){\n\t\t\t\tfor (int z = unzipz[z1[i]]; z < unzipz[z2[i]]; ++z){\n\t\t\t\t\tnum[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\trep(x, 100)rep(y, 100)rep(z, 100){\n\t\tif(num[x][y][z] >= k){\n\t\t\tans += ((zipx[x + 1] - zipx[x]) * (zipy[y + 1] - zipy[y]) * (zipz[z + 1] - zipz[z]));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 10001\n#define B 100\n#define dmp make_pair\n#define dpb push_back\n#define fi first\n#define se second\n#define P pair<int,int>\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\n/*chrono::system_clock::time_point  start;\nvoid timerstart(){start = chrono::system_clock::now();}\nvoid timerend(){\n\tauto end = chrono::system_clock::now();\n\tint elapsed = chrono::duration_cast<chrono::milliseconds>(end-start).count();\n\tprintf(\"%d[ms]\\n\", elapsed);\n}*/\n\nint n, k, fld[110][110][110];\nint cx[102][2], cy[102][2], cz[102][2];\nint dx[102], dy[102], dz[102];\nint compress1(int x1[52], int x2[52]){\n\tvector<int> xs;\n\tfor(int i = 0;i < n;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tfor(int i = 0;i < xs.size();i++)dx[i] = xs[i];\n\tfor(int i = 0;i < n;i++){\n\t\tcx[i][0] = find(xs.begin(), xs.end(), x1[i])-xs.begin();\n\t\tcx[i][1] = find(xs.begin(), xs.end(), x2[i])-xs.begin();\n\t}\n\treturn xs.size();\n}\n\nint compress2(int x1[52], int x2[52]){\n\tvector<int> xs;\n\tfor(int i = 0;i < n;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tfor(int i = 0;i < xs.size();i++)dy[i] = xs[i];\n\tfor(int i = 0;i < n;i++){\n\t\tcy[i][0] = find(xs.begin(), xs.end(), x1[i])-xs.begin();\n\t\tcy[i][1] = find(xs.begin(), xs.end(), x2[i])-xs.begin();\n\t}\n\treturn xs.size();\n}\n\nint compress3(int x1[52], int x2[52]){\n\tvector<int> xs;\n\tfor(int i = 0;i < n;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tfor(int i = 0;i < xs.size();i++)dz[i] = xs[i];\n\tfor(int i = 0;i < n;i++){\n\t\tcz[i][0] = find(xs.begin(), xs.end(), x1[i])-xs.begin();\n\t\tcz[i][1] = find(xs.begin(), xs.end(), x2[i])-xs.begin();\n\t}\n\treturn xs.size();\n}\n\nvoid paint(int w, int h, int d){\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int x = cx[i][0]+1;x <= cx[i][1];x++){\n\t\t\tfor(int y = cy[i][0]+1;y <= cy[i][1];y++){\n\t\t\t\tfor(int z = cz[i][0]+1;z <= cz[i][1];z++){\n\t\t\t\t\tfld[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint X1[52], X2[52], Y1[52];\n\tint Y2[52], Z1[52], Z2[52];\n\tscanf(\"%d%d\", &n, &k);\n\trep(i,n){\n\t\tscanf(\"%d%d%d\", &X1[i], &Y1[i], &Z1[i]);\n\t\tscanf(\"%d%d%d\", &X2[i], &Y2[i], &Z2[i]);\n\t}\n\tint w = compress1(X1, X2);\n\tint h = compress2(Y1, Y2);\n\tint d = compress3(Z1, Z2);\n\tpaint(w, h, d);\n\t\n\tll ans = 0, t1, t2, t3;\n\tfor(int x = 1;x < w;x++){\n\t\tfor(int y = 1;y < h;y++){\n\t\t\tfor(int z = 1;z < d;z++){\n\t\t\t\tif(fld[x][y][z] >= k){\n\t\t\t\t\tt1 = dx[x]-dx[x-1];\n\t\t\t\t\tt2 = dy[y]-dy[y-1];\n\t\t\t\t\tt3 = dz[z]-dz[z-1];\n\t\t\t\t\tans += (ll)t1*t2*t3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n#define N 50\nint n,k;\nint field[2*N][2*N][2*N];\nvector<int> compress(int *x1,int *x2){\n    vector<int>xs;\n    for(int i=0;i<n;i++){\n        xs.push_back(x1[i]);\n        xs.push_back(x2[i]);\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n\n    for(int i=0;i<n;i++){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    vector<int>len;\n    for(int i=0;i<xs.size()-1;i++){\n        len.push_back(xs[i+1]-xs[i]);\n    }\n    return len;\n}\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    int x1[N],x2[N],y1[N],y2[N],z1[N],z2[N];\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d%d\",&x1[i],&y1[i],&z1[i]);\n        scanf(\"%d%d%d\",&x2[i],&y2[i],&z2[i]);\n    }\n    vector<int>X,Y,Z;\n    X=compress(x1,x2);\n    Y=compress(y1,y2);\n    Z=compress(z1,z2);\n    fill(field[0][0],field[0][0]+8*N*N*N,0);\n    for(int i=0;i<n;i++){\n        for(int z=z1[i];z<z2[i];z++){\n            for(int y=y1[i];y<y2[i];y++){\n                for(int x=x1[i];x<x2[i];x++){\n                    field[z][y][x]++;\n                }\n            }\n        }\n    }\n    ll sum=0;\n    for(int z=0;z<Z.size();z++){\n        for(int y=0;y<Y.size();y++){\n            for(int x=0;x<X.size();x++){\n                if(field[z][y][x]>=k)sum+=(ll)X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n    printf(\"%lld\\n\",sum);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\ntemplate <class T>\nstd::map<T, int> compress(std::vector<T>& v) {\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    std::map<T, int> rev;\n    for (int i = 0; i < (int)v.size(); ++i) rev[v[i]] = i;\n    return rev;\n}\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\nusing lint = long long;\n\nstruct Point {\n    lint x, y, z;\n};\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n\n    std::vector<lint> xs, ys, zs;\n    std::vector<Point> lps(n), rps(n);\n    for (int i = 0; i < n; ++i) {\n        auto& lp = lps[i];\n        auto& rp = rps[i];\n        std::cin >>\n            lp.x >> lp.y >> lp.z >>\n            rp.x >> rp.y >> rp.z;\n\n        xs.push_back(lp.x);\n        xs.push_back(rp.x);\n        ys.push_back(lp.y);\n        ys.push_back(rp.y);\n        zs.push_back(lp.z);\n        zs.push_back(rp.z);\n    }\n\n    auto revx = compress(xs);\n    auto revy = compress(ys);\n    auto revz = compress(zs);\n    int xn = xs.size(), yn = ys.size(), zn = zs.size();\n\n    auto grid = vec(xn, vec(yn, vec(zn, 0)));\n    for (int i = 0; i < n; ++i) {\n        auto l = lps[i], r = rps[i];\n\n        l.x = revx[l.x], r.x = revx[r.x];\n        l.y = revy[l.y], r.y = revy[r.y];\n        l.z = revz[l.z], r.z = revz[r.z];\n\n        ++grid[l.x][l.y][l.z];\n\n        --grid[r.x][l.y][l.z];\n        --grid[l.x][r.y][l.z];\n        --grid[l.x][l.y][r.z];\n\n        ++grid[l.x][r.y][r.z];\n        ++grid[r.x][l.y][r.z];\n        ++grid[r.x][r.y][l.z];\n\n        --grid[r.x][r.y][r.z];\n    }\n\n    for (int i = 0; i < xn; ++i) {\n        for (int j = 0; j < yn; ++j) {\n            for (int k = 0; k + 1 < zn; ++k) {\n                grid[i][j][k + 1] += grid[i][j][k];\n            }\n        }\n    }\n    for (int i = 0; i < xn; ++i) {\n        for (int j = 0; j + 1 < yn; ++j) {\n            for (int k = 0; k < zn; ++k) {\n                grid[i][j + 1][k] += grid[i][j][k];\n            }\n        }\n    }\n    for (int i = 0; i + 1 < xn; ++i) {\n        for (int j = 0; j < yn; ++j) {\n            for (int k = 0; k < zn; ++k) {\n                grid[i + 1][j][k] += grid[i][j][k];\n            }\n        }\n    }\n\n    lint ans = 0;\n    for (int i = 0; i < xn; ++i) {\n        for (int j = 0; j < yn; ++j) {\n            for (int k = 0; k < zn; ++k) {\n                if (grid[i][j][k] < m) continue;\n                ans += (xs[i + 1] - xs[i]) * (ys[j + 1] - ys[j]) * (zs[k + 1] - zs[k]);\n            }\n        }\n    }\n\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n#define MAX(x,y) ((x>y)?x:y)\n\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nint x[105],y[105],d[105];\nint sx[105],sy[105],sd[105];\nint c[105][105][105];\nint main(){\n\tint i,j,k,l,n,K;\n\tint xn,yn,dn;\n\tlong long ans;\n\t\n\tscanf(\"%d%d\",&n,&K);\n\tfor(i=0;i<n;i++)scanf(\"%d%d%d%d%d%d\",&x[i*2],&y[i*2],&d[i*2],&x[i*2+1],&y[i*2+1],&d[i*2+1]);\n\tmemcpy(sx,x,sizeof(int)*n*2);\n\tmemcpy(sy,y,sizeof(int)*n*2);\n\tmemcpy(sd,d,sizeof(int)*n*2);\n\t\n\tqsort(sx,n*2,sizeof(int),comp);\n\tqsort(sy,n*2,sizeof(int),comp);\n\tqsort(sd,n*2,sizeof(int),comp);\n\t\n\txn=yn=dn=1;\n\tfor(i=1;i<n*2;i++)if(sx[i]!=sx[i-1])sx[xn++]=sx[i];\n\tfor(i=1;i<n*2;i++)if(sy[i]!=sy[i-1])sy[yn++]=sy[i];\n\tfor(i=1;i<n*2;i++)if(sd[i]!=sd[i-1])sd[dn++]=sd[i];\n\t/*\n\tfor(i=0;i<xn;i++)printf(\"%3d \",sx[i]);printf(\"\\n\");\n\tfor(i=0;i<yn;i++)printf(\"%3d \",sy[i]);printf(\"\\n\");\n\tfor(i=0;i<dn;i++)printf(\"%3d \",sd[i]);printf(\"\\n\");\n\t*/\n\tmemset(c,0,sizeof(c));\n\tfor(i=0;i<n*2;i++){\n\t\tx[i]=lower_bound(sx,sx+xn,x[i])-sx;\n\t\ty[i]=lower_bound(sy,sy+yn,y[i])-sy;\n\t\td[i]=lower_bound(sd,sd+dn,d[i])-sd;\n\t\t//printf(\"%d %d %d\\n\",x[i],y[i],d[i]);\n\t\tif(i%2==1){\n\t\t\tfor(j=x[i-1];j<x[i];j++)\n\t\t\t\tfor(k=y[i-1];k<y[i];k++)\n\t\t\t\t\tfor(l=d[i-1];l<d[i];l++)c[j][k][l]++;\n\t\t}\n\t}\n\tans=0;\n\tfor(i=0;i<xn-1;i++)for(j=0;j<yn-1;j++)for(k=0;k<dn-1;k++){\n\t\tif(c[i][j][k]>=K)ans+=(long long)(sx[i+1]-sx[i])*\n\t\t\t\t\t\t\t  (long long)(sy[j+1]-sy[j])*\n\t\t\t\t\t\t\t  (long long)(sd[k+1]-sd[k]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\n\nint N,K;\nint W,H,D;\nint X1[55],Y1[55],Z1[55],X2[55],Y2[55],Z2[55];\nint cx1[55],cy1[55],cz1[55],cx2[55],cy2[55],cz2[55];\nvector<long long int> X,Y,Z;\nchar fld[51*6][51*6][51*6];\n\nlong long int ans;\nvector<int> xs;\n\nvoid compress(vector<long long int> &X,int* x1,int* x2,int* vx1,int* vx2,int w,int* P){\n    xs.clear();\n    for(int i=0;i<N;++i){\n        x1[i]=vx1[i];\n        x2[i]=vx2[i];\n    }\n    for(int i=0;i<N;++i){\n        for(int d=-1;d<=1;++d){\n            int tx1=x1[i]+d;\n            int tx2=x2[i]+d;\n            if(0<=tx1&&tx1<=w)xs.PB(tx1);\n            if(0<=tx2&&tx2<=w)xs.PB(tx2);\n        }\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    //for(int i=0;i<xs.size();++i)cout<<xs[i]<<endl;\n    for(int i=0;i<xs.size();++i){\n        X.PB(xs[i+1]-xs[i]);\n    }\n    *P = xs.size();\n}\n\nint main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    compress(X,cx1,cx2,X1,X2,1000000,&W);\n    compress(Y,cy1,cy2,Y1,Y2,1000000,&H);\n    compress(Z,cz1,cz2,Z1,Z2,1000000,&D);\n    for(int i=0;i<N;++i){\n        for(int z=cz1[i];z<cz2[i];++z){\n            for(int y=cy1[i];y<cy2[i];++y){\n                for(int x=cx1[i];x<cx2[i];++x){\n                    fld[z][y][x]++;\n                }\n            }\n        }\n    }\n    for(int z=0;z<=D;++z){\n        for(int y=0;y<=H;++y){\n            for(int x=0;x<=W;++x){\n                if(fld[z][y][x]>=K)ans+=X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, m;\nint main() {\n\tcin >> n >> m;\n\tvector<int> xl(n), yl(n), zl(n), xr(n), yr(n), zr(n), xc, yc, zc;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> xl[i] >> yl[i] >> zl[i] >> xr[i] >> yr[i] >> zr[i];\n\t\txc.push_back(xl[i]);\n\t\tyc.push_back(yl[i]);\n\t\tzc.push_back(zl[i]);\n\t\txc.push_back(xr[i]);\n\t\tyc.push_back(yr[i]);\n\t\tzc.push_back(zr[i]);\n\t}\n\tsort(xc.begin(), xc.end());\n\txc.erase(unique(xc.begin(), xc.end()), xc.end());\n\tsort(yc.begin(), yc.end());\n\tyc.erase(unique(yc.begin(), yc.end()), yc.end());\n\tsort(zc.begin(), zc.end());\n\tzc.erase(unique(zc.begin(), zc.end()), zc.end());\n\tfor (int i = 0; i < n; i++) {\n\t\txl[i] = lower_bound(xc.begin(), xc.end(), xl[i]) - xc.begin();\n\t\tyl[i] = lower_bound(yc.begin(), yc.end(), yl[i]) - yc.begin();\n\t\tzl[i] = lower_bound(zc.begin(), zc.end(), zl[i]) - zc.begin();\n\t\txr[i] = lower_bound(xc.begin(), xc.end(), xr[i]) - xc.begin();\n\t\tyr[i] = lower_bound(yc.begin(), yc.end(), yr[i]) - yc.begin();\n\t\tzr[i] = lower_bound(zc.begin(), zc.end(), zr[i]) - zc.begin();\n\t}\n\tvector<vector<vector<int> > > sum(xc.size(), vector<vector<int> >(yc.size(), vector<int>(zc.size())));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = xl[i]; j < xr[i]; j++) {\n\t\t\tfor (int k = yl[i]; k < yr[i]; k++) {\n\t\t\t\tfor (int l = zl[i]; l < zr[i]; l++) {\n\t\t\t\t\tsum[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret = 0;\n\tfor (int i = 0; i < xc.size(); i++) {\n\t\tfor (int j = 0; j < yc.size(); j++) {\n\t\t\tfor (int k = 0; k < zc.size(); k++) {\n\t\t\t\tif (sum[i][j][k] >= m) ret += 1LL * (xc[i + 1] - xc[i]) * (yc[j + 1] - yc[j]) * (zc[k + 1] - zc[k]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\ntypedef long LONG;\n\nLONG zip[3][200];\nint M[3];\n\nint a[50][6];\nint N, K;\n\nint O[200][200][200];\n\nint main()\n{\n\tscanf(\"%d %d\", &N, &K);\t\n\tmemset(zip, -1, sizeof(zip));\n\tmemset(M, 0, sizeof(M));\n\tmemset(a, 0, sizeof(a));\n\tmemset(O, 0, sizeof(O));\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = 0; j < 6; j++){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\t\n\t\t\tbool f = true;\n\t\t\tfor (int k = 0; k < M[j % 3]; k++){\n\t\t\t\tif (zip[j % 3][k] == a[i][j]){\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (f){\n\t\t\t\tzip[j % 3][M[j % 3]] = a[i][j];\n\t\t\t\tM[j % 3]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < 3; i++){\n\t\tsort(zip[i], zip[i] + M[i]);\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = 0; j < 6; j++){\n\t\t\tint l = 0;\n\t\t\tint r = M[j % 3] - 1;\n\t\t\tint m = (l + r) / 2;\n\t\t\t\n\t\t\twhile (zip[j % 3][m] != a[i][j]){\n\t\t\t\tif (zip[j % 3][m] < a[i][j]){\n\t\t\t\t\tl = m + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tr = m - 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tm = (l + r) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta[i][j] = m;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int x = a[i][0]; x < a[i][3]; x++){\n\t\t\tfor (int y = a[i][1]; y < a[i][4]; y++){\n\t\t\t\tfor (int z = a[i][2]; z < a[i][5]; z++){\n\t\t\t\t\tO[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tLONG sum = 0;\n\t\n\tfor (int x = 0; x < 200; x++){\n\t\tfor (int y = 0; y < 200; y++){\n\t\t\tfor (int z = 0; z < 200; z++){\n\t\t\t\tif (O[x][y][z] >= K){\n\t\t\t\t\tsum += (zip[0][x + 1] - zip[0][x]) * \n\t\t\t\t\t       (zip[1][y + 1] - zip[1][y]) *\n\t\t\t\t\t       (zip[2][z + 1] - zip[2][z]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%ld\\n\", sum);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\n\nint main() {\n    int n, r;\n    cin >> n >> r;\n    vector<int> xs{0, 1000010}, ys{0, 1000010}, zs{0, 1000010};\n    using P = array<int, 6>;\n    vector<array<int, 6>> v;\n\n    for (int i = 0; i < n; ++i) {\n        int a, b, c, d, e, f;\n        scanf(\"%d %d %d %d %d %d\", &a, &b, &c, &d, &e, &f);\n        v.emplace_back(P{a, b, c, d, e, f});\n        xs.emplace_back(a); ys.emplace_back(b); zs.emplace_back(c);\n        xs.emplace_back(d); ys.emplace_back(e); zs.emplace_back(f);\n    }\n    sort(xs.begin(), xs.end());\n    xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    sort(ys.begin(), ys.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    sort(zs.begin(), zs.end());\n    zs.erase(unique(zs.begin(), zs.end()), zs.end());\n    auto zx = [&xs](int i){ return lower_bound(xs.begin(),xs.end(), i) - xs.begin(); };\n    auto zy = [&ys](int i){ return lower_bound(ys.begin(),ys.end(), i) - ys.begin(); };\n    auto zz = [&zs](int i){ return lower_bound(zs.begin(),zs.end(), i) - zs.begin(); };\n    auto G = make_v(xs.size(), ys.size(), zs.size(), 0);\n    for (int i = 0; i < n; ++i) {\n        auto A = v[i];\n        A[0] = zx(A[0]); A[1] = zy(A[1]); A[2] = zz(A[2]);\n        A[3] = zx(A[3]); A[4] = zy(A[4]); A[5] = zz(A[5]);\n        for (int j = 0; j < 2; ++j) {\n            for (int k = 0; k < 2; ++k) {\n                for (int l = 0; l < 2; ++l) {\n                    if((j+k+l)&1) G[A[3*j]][A[3*k+1]][A[3*l+2]]--;\n                    else G[A[3*j]][A[3*k+1]][A[3*l+2]]++;\n                }\n            }\n        }\n    }\n    for (int i = 1; i < xs.size(); ++i) {\n        for (int j = 0; j < ys.size(); ++j) {\n            for (int k = 0; k < zs.size(); ++k) {\n                G[i][j][k] += G[i-1][j][k];\n            }\n        }\n    }\n    for (int i = 0; i < xs.size(); ++i) {\n        for (int j = 1; j < ys.size(); ++j) {\n            for (int k = 0; k < zs.size(); ++k) {\n                G[i][j][k] += G[i][j-1][k];\n            }\n        }\n    }\n    for (int i = 0; i < xs.size(); ++i) {\n        for (int j = 0; j < ys.size(); ++j) {\n            for (int k = 1; k < zs.size(); ++k) {\n                G[i][j][k] += G[i][j][k-1];\n            }\n        }\n    }\n    ll ans = 0;\n    for (int i = 0; i+1 < xs.size(); ++i) {\n        for (int j = 0; j+1 < ys.size(); ++j) {\n            for (int k = 0; k+1 < zs.size(); ++k) {\n                if(G[i][j][k] >= r){\n                    ans += (ll)(xs[i+1]-xs[i])*(ys[j+1]-ys[j])*(zs[k+1]-zs[k]);\n                }\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct POS{\n\tint num;\n\tint coord[3];\n\tbool begin;\n};\n\nlong long scan_d(vector<bool> &vec_x,vector<bool> &vec_y,vector<POS> &vec_d,int N,int K)\n{\n\tvector<bool> vec(N);\n\tfill(vec.begin(),vec.end(),false);\n\t\n\tint count=0;\n\tint begin;\n\tlong long total = 0;\n\tfor(POS &p : vec_d ){\n\t\tif( !vec_x[p.num] ) continue;\n\t\tif( !vec_y[p.num] ) continue;\n\n\t\tif( p.begin ){\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[2]-begin);\n//\t\t\t\tcout << \"D:\" << begin << \"-\" << p.coord[2] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=true;\n\t\t\tcount++;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[2];\n\t\t\t}\n\t\t}else{\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[2]-begin);\n//\t\t\t\tcout << \"D:\" << begin << \"-\" << p.coord[2] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=false;\n\t\t\tcount--;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[2];\n\t\t\t}\n\t\t}\n\t}\n\treturn total;\n}\n\nlong long scan_y(vector<bool> &vec_x,vector<POS> &vec_y,vector<POS> &vec_d,int N,int K)\n{\n\tvector<bool> vec(N);\n\tfill(vec.begin(),vec.end(),false);\n\t\n\tint count=0;\n\tint begin;\n\tlong long size;\n\tlong long total = 0;\n\tfor(POS &p : vec_y ){\n\t\tif( !vec_x[p.num] ) continue;\n\n\t\tif( p.begin ){\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[1]-begin) * size;\n//\t\t\t\tcout << \"Y:\" << begin << \"-\" << p.coord[1] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=true;\n\t\t\tcount++;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[1];\n\t\t\t\tsize = scan_d(vec_x, vec,vec_d,N,K);\n\t\t\t}\n\t\t}else{\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[1]-begin) * size;\n//\t\t\t\tcout << \"Y:\" << begin << \"-\" << p.coord[1] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=false;\n\t\t\tcount--;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[1];\n\t\t\t\tsize = scan_d(vec_x, vec,vec_d,N,K);\n\t\t\t}\n\t\t}\n\t}\n\treturn total;\n}\n\nlong long scan_x(vector<POS> &vec_x,vector<POS> &vec_y,vector<POS> &vec_d,int N,int K)\n{\n\tvector<bool> vec(N);\n\tfill(vec.begin(),vec.end(),false);\n\t\n\tint count=0;\n\tint begin;\n\tlong long size;\n\tlong long total = 0;\n\tfor(POS &p : vec_x ){\n\t\tif( p.begin ){\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[0]-begin) * size;\n//\t\t\t\tcout << \"X:\" << begin << \"-\" << p.coord[0] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=true;\n\t\t\tcount++;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[0];\n\t\t\t\tsize = scan_y(vec, vec_y,vec_d,N,K);\n\t\t\t}\n\t\t}else{\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[0]-begin) * size;\n//\t\t\t\tcout << \"X:\" << begin << \"-\" << p.coord[0] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=false;\n\t\t\tcount--;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[0];\n\t\t\t\tsize = scan_y(vec, vec_y,vec_d,N,K);\n\t\t\t}\n\t\t}\n\t}\n\treturn total;\n}\n\nint main() {\n\tint N,K;\n\tcin >> N >> K;\n\t\n\tvector<POS> vec;\n\n\tfor(int i=0;i<N;i++){\n\t\tPOS p0,p1;\n\t\tcin >> p0.coord[0] >> p0.coord[1] >> p0.coord[2];\n\t\tcin >> p1.coord[0] >> p1.coord[1] >> p1.coord[2];\n\t\tp0.num=i;\n\t\tp0.begin=true;\n\t\tp1.num=i;\n\t\tp1.begin=false;\n\t\tvec.push_back(p0);\n\t\tvec.push_back(p1);\n\t}\n\n\tvector<POS> vec_x(vec);\n\tvector<POS> vec_y(vec);\n\tvector<POS> vec_d(vec);\n\n\tsort(vec_x.begin(),vec_x.end(),[](POS &p0,POS &p1){ return p0.coord[0]<p1.coord[0];});\n\tsort(vec_y.begin(),vec_y.end(),[](POS &p0,POS &p1){ return p0.coord[1]<p1.coord[1];});\n\tsort(vec_d.begin(),vec_d.end(),[](POS &p0,POS &p1){ return p0.coord[2]<p1.coord[2];});\n\n\t// for( POS p : vec_x ){\n\t// \tcout << p.coord[0] << \" \";\n\t// }\n\t// cout << endl;\n\n\tlong long ans = scan_x(vec_x,vec_y,vec_d,N,K);\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\n\n\nusing namespace std;\ntypedef long long ll;\n\n#define In_(x) scanf(\"%lld\",&x)\n\nll n, k;\nvector<ll>xtag, ytag, dtag;\nll x1[50], y1__[50], d1[50];\nll x2[50], y2[50], d2[50];\nll area[123][123][123];\n\nll compress(ll t1[],ll t2[],vector<ll>&tmp)\n{\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\ttmp.push_back(t1[i]);\n\t\ttmp.push_back(t2[i]);\n\t}\n\tsort(tmp.begin(), tmp.end());\n\ttmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tt1[i] = find(tmp.begin(), tmp.end(), t1[i]) - tmp.begin();\n\t\tt2[i] = find(tmp.begin(), tmp.end(), t2[i]) - tmp.begin();\n\t}\n\treturn tmp.size();\n}\n\nint main()\n{\n\tIn_(n);\n\tIn_(k);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tIn_(x1[i]);\n\t\tIn_(y1__[i]);\n\t\tIn_(d1[i]);\n\t\tIn_(x2[i]);\n\t\tIn_(y2[i]);\n\t\tIn_(d2[i]);\n\t}\n\tll xlen = compress(x1, x2, xtag);\n\tll ylen = compress(y1__, y2, ytag);\n\tll dlen = compress(d1, d2, dtag);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tarea[x1[i]][y1__[i]][d1[i]] += 1;\n\t\tarea[x1[i]][y1__[i]][d2[i]] -= 1;\n\t\tarea[x1[i]][y2[i]][d1[i]] -= 1;\n\t\tarea[x1[i]][y2[i]][d2[i]] += 1;\n\t\tarea[x2[i]][y1__[i]][d1[i]] -= 1;\n\t\tarea[x2[i]][y1__[i]][d2[i]] += 1;\n\t\tarea[x2[i]][y2[i]][d1[i]] += 1;\n\t\tarea[x2[i]][y2[i]][d2[i]] -= 1;\n\t}\n\tfor (int x = 0; x < xlen; ++x)\n\t{\n\t\tfor (int y = 0; y < ylen; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < dlen; ++d)\n\t\t\t{\n\t\t\t\tarea[x][y][d + 1] += area[x][y][d];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 0; x < xlen; ++x)\n\t{\n\t\tfor (int y = 0; y < ylen; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < dlen; ++d)\n\t\t\t{\n\t\t\t\tarea[x][y + 1][d] += area[x][y][d];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 0; x < xlen; ++x)\n\t{\n\t\tfor (int y = 0; y < ylen; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < dlen; ++d)\n\t\t\t{\n\t\t\t\tarea[x + 1][y][d] += area[x][y][d];\n\t\t\t}\n\t\t}\n\t}\n\tll answer = 0;\n\tfor (int x = 0; x < xlen; ++x)\n\t{\n\t\tfor (int y = 0; y < ylen; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < dlen; ++d)\n\t\t\t{\n\t\t\t\tif (area[x][y][d] >= k)\n\t\t\t\t{\n\t\t\t\t\tanswer += (xtag[x + 1] - xtag[x]) * (ytag[y + 1] - ytag[y]) * (dtag[d + 1] - dtag[d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",answer);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\nusing namespace std;\n\nstruct Fish {int left, front, top, right, back, bottom;};\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<Fish> fish(N);\n    for(auto& f: fish) cin >> f.left >> f.front >> f.top >> f.right >> f.back >> f.bottom;\n\n    set<long long int > tx, ty, tz;\n    for(const auto& f: fish) {\n        tx.insert(f.left);\n        tx.insert(f.right);\n        ty.insert(f.front);\n        ty.insert(f.back);\n        tz.insert(f.top);\n        tz.insert(f.bottom);\n    }\n    vector<long long int> x(tx.begin(), tx.end()), y(ty.begin(), ty.end()), z(tz.begin(), tz.end());\n\n    long long int answer = 0;\n    for(int i = 1; i < x.size(); ++i) for(int j = 1; j < y.size(); ++j) for(int k = 1; k < z.size(); ++k) {\n        int count = 0;\n        for(const auto& f: fish)\n            if((f.left < x[i] && x[i] <= f.right) && (f.front < y[j] && y[j] <= f.back) && (f.top < z[k] && z[k] <= f.bottom))\n                ++count;\n        if(count >= K) answer += (x[i] - x[i - 1]) * (y[j] - y[j - 1]) * (z[k] - z[k - 1]);\n    }\n    cout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef long long lli;\nconst int MAX = 300;\nint a[MAX][MAX][MAX];\n\nint main(){\n  int n,m;\n  while(cin >> n >> m){\n    lli v[50][6], ans = 0;\n    vector<lli> v2[3];\n    set<lli> s[3];\n    map<lli,int> v3[3];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<6;j++){\n        cin >> v[i][j];\n        s[j%3].insert(v[i][j]);\n      }\n    }\n\n    for(int i=0;i<MAX;i++) for(int j=0;j<MAX;j++) for(int k=0;k<MAX;k++) a[i][j][k] = 0;\n    for(int i=0;i<3;i++){\n      for(set<lli>::iterator it = s[i].begin(); it != s[i].end(); it++){\n        v2[i].push_back(*it);\n        v3[i][*it] = v2[i].size()-1;\n      }\n    }\n\n    for(int i=0;i<n;i++)\n      for(int j=v3[0][v[i][0]];j<v3[0][v[i][3]];j++)\n        for(int k=v3[1][v[i][1]];k<v3[1][v[i][4]];k++)\n          for(int l=v3[2][v[i][2]];l<v3[2][v[i][5]];l++)\n            a[j][k][l]++;\n\n    for(int i=0;i<MAX-1;i++)\n      for(int j=0;j<MAX-1;j++)\n        for(int k=0;k<MAX-1;k++)\n          if(a[i][j][k] >= m)\n            ans += (v2[0][i+1]-v2[0][i]) * (v2[1][j+1]-v2[1][j]) * (v2[2][k+1]-v2[2][k]);\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <ctime>\nusing namespace std;\n\nint main(){\n\tcin.tie(0);\n    ios::sync_with_stdio(false);\n\n\tint N, K;\n\tcin >> N >> K;\n\n\tvector<int> X1(N);\n\tvector<int> Y1(N);\n\tvector<int> D1(N);\n\tvector<int> X2(N);\n\tvector<int> Y2(N);\n\tvector<int> D2(N);\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t}\n\t\n\t//ソート用vector\n\tvector<int> X(2*N);\n\tvector<int> Y(2*N);\n\tvector<int> D(2*N);\n\n\tcopy(X1.begin(), X1.end(), X.begin());\n\tcopy(X2.begin(), X2.end(), X.begin()+N);\n\tcopy(Y1.begin(), Y1.end(), Y.begin());\n\tcopy(Y2.begin(), Y2.end(), Y.begin()+N);\n\tcopy(D1.begin(), D1.end(), D.begin());\n\tcopy(D2.begin(), D2.end(), D.begin()+N);\n\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\t\n\tlong long int ans = 0;\n\tint kasanari;\n\tfor (int i = 0; i < 2*N-1; i++){ //X\n\t\tfor (int j = 0; j < 2*N-1; j++){ //Y\n\t\t\tfor (int k = 0; k < 2*N-1; k++){ //D\n\t\t\t\tkasanari = 0;\n\t\t\t\tfor (int l = 0; l < N; l++){ //実際の直方体\n\t\t\t\t\tif ((X1[l]<=X[i] && X[i+1] <= X2[l]) &&\n\t\t\t\t\t\t(Y1[l]<=Y[j] && Y[j+1] <= Y2[l]) &&\n\t\t\t\t\t\t(D1[l]<=D[k] && D[k+1] <= D2[l]))\n\t\t\t\t\t\tkasanari++;\n\t\t\t\t}\n\t\t\t\tif (kasanari >= K){\n\t\t\t\t\tans += (long long int)(X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) * (D[k + 1] - D[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 51;\n\nint n,K;\nvector<int> X,Y,Z,X1,Y1,Z1,X2,Y2,Z2;\nint flag[MAX_N*2][MAX_N*2][MAX_N*2];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\trep(i,n){\n\t\tint ax,ay,az,bx,by,bz;\n\t\tscanf(\"%d%d%d%d%d%d\",&ax,&ay,&az,&bx,&by,&bz);\n\t\tX.push_back(ax),X.push_back(bx);\n\t\tX1.push_back(ax),X2.push_back(bx);\n\t\tY.push_back(ay),Y.push_back(by);\n\t\tY1.push_back(ay),Y2.push_back(by);\n\t\tZ.push_back(az),Z.push_back(bz);\n\t\tZ1.push_back(az),Z2.push_back(bz);\n\t}\n\tsort(X.begin(),X.end());\n\tsort(Y.begin(),Y.end());\n\tsort(Z.begin(),Z.end());\n\tX.erase(unique(X.begin(),X.end()),X.end());\n\tY.erase(unique(Y.begin(),Y.end()),Y.end());\n\tZ.erase(unique(Z.begin(),Z.end()),Z.end());\n\trep(i,n){\n\t\tX1[i] = lower_bound(X.begin(),X.end(),X1[i])-X.begin();\n\t\tX2[i] = lower_bound(X.begin(),X.end(),X2[i])-X.begin();\n\t\tY1[i] = lower_bound(Y.begin(),Y.end(),Y1[i])-Y.begin();\n\t\tY2[i] = lower_bound(Y.begin(),Y.end(),Y2[i])-Y.begin();\n\t\tZ1[i] = lower_bound(Z.begin(),Z.end(),Z1[i])-Z.begin();\n\t\tZ2[i] = lower_bound(Z.begin(),Z.end(),Z2[i])-Z.begin();\n\t\tflag[X1[i]][Y1[i]][Z1[i]]++,flag[X1[i]][Y2[i]][Z1[i]]--;\n\t\tflag[X2[i]][Y1[i]][Z1[i]]--,flag[X2[i]][Y2[i]][Z1[i]]++;\n\t\tflag[X1[i]][Y1[i]][Z2[i]]--,flag[X1[i]][Y2[i]][Z2[i]]++;\n\t\tflag[X2[i]][Y1[i]][Z2[i]]++,flag[X2[i]][Y2[i]][Z2[i]]--;\n\t}\n\trep(i,101){\n\t\trep(j,101){\n\t\t\trep(k,101){\n\t\t\t\tflag[i+1][j][k] += flag[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\trep(i,101){\n\t\trep(j,101){\n\t\t\trep(k,101){\n\t\t\t\tflag[i][j+1][k] += flag[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\trep(i,101){\n\t\trep(j,101){\n\t\t\trep(k,101){\n\t\t\t\tflag[i][j][k+1] += flag[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\trep(i,X.size()-1){\n\t\trep(j,Y.size()-1){\n\t\t\trep(k,Z.size()-1){\n\t\t\t\tif(flag[i][j][k]>=K){\n\t\t\t\t\tans += (ll)(X[i+1]-X[i])*(Y[j+1]-Y[j])*(Z[k+1]-Z[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\n\nint N,K;\nint W,H,D;\nint X1[55],Y1[55],Z1[55],X2[55],Y2[55],Z2[55];\nint cx1[55],cy1[55],cz1[55],cx2[55],cy2[55],cz2[55];\nvector<int> X,Y,Z;\nunsigned short fld[55*5][55*5][55*5];\n\nint ans;\nvector<int> xs;\n\nvoid compress(vector<int> &X,int* x1,int* x2,int* vx1,int* vx2,int w,int* P){\n    xs.clear();\n    for(int i=0;i<N;++i){\n        x1[i]=vx1[i];\n        x2[i]=vx2[i];\n    }\n    for(int i=0;i<N;++i){\n        for(int d=-1;d<=1;++d){\n            int tx1=x1[i]+d;\n            int tx2=x2[i]+d;\n            if(0<=tx1&&tx1<=w)xs.PB(tx1);\n            if(0<=tx2&&tx2<=w)xs.PB(tx2);\n        }\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    //for(int i=0;i<xs.size();++i)cout<<xs[i]<<endl;\n    for(int i=0;i<xs.size();++i){\n        X.PB(xs[i+1]-xs[i]);\n    }\n    *P = xs.size();\n}\n\nint main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    compress(X,cx1,cx2,X1,X2,1000000,&W);\n    compress(Y,cy1,cy2,Y1,Y2,1000000,&H);\n    compress(Z,cz1,cz2,Z1,Z2,1000000,&D);\n    for(int i=0;i<N;++i){\n        for(int z=cz1[i];z<cz2[i];++z){\n            for(int y=cy1[i];y<cy2[i];++y){\n                for(int x=cx1[i];x<cx2[i];++x){\n                    fld[z][y][x]++;\n                }\n            }\n        }\n    }\n    for(int z=0;z<=D;++z){\n        for(int y=0;y<=H;++y){\n            for(int x=0;x<=W;++x){\n                if(fld[z][y][x]>=K)ans+=X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n\n    //cout<<W<<\" \"<<H<<\" \"<<D<<endl;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n \ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n\n#define F first\n#define S second\n\n\n\nint index(const vector<int>& v, int x)\n{\n    return lower_bound(all(v), x) - v.begin();\n}\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n\n    const int inf = ten(8);\n\n    vector<int> cx, cy, cz;\n    int x1[55], y1[55], z1[55], x2[55], y2[55], z2[55];\n    rep(i, n)\n    {\n        cin >> x1[i] >> y1[i] >> z1[i] >> x2[i] >> y2[i] >> z2[i];\n        cx.pb(x1[i]), cx.pb(x2[i]);\n        cy.pb(y1[i]), cy.pb(y2[i]);\n        cz.pb(z1[i]), cz.pb(z2[i]);\n    }\n    uniq(cx);\n    uniq(cy);\n    uniq(cz);\n\n    static int imos[111][111][111];\n    rep(i, n)\n    {\n        int cx1 = index(cx, x1[i]);\n        int cx2 = index(cx, x2[i]);\n        int cy1 = index(cy, y1[i]);\n        int cy2 = index(cy, y2[i]);\n        int cz1 = index(cz, z1[i]);\n        int cz2 = index(cz, z2[i]);\n\n        // xy, z1\n        ++imos[cz1][cy1][cx1], --imos[cz1][cy1][cx2];\n        --imos[cz1][cy2][cx1], ++imos[cz1][cy2][cx2];\n\n        // xy, z2\n        --imos[cz2][cy1][cx1], ++imos[cz2][cy1][cx2];\n        ++imos[cz2][cy2][cx1], --imos[cz2][cy2][cx2];\n    }\n\n    // imos x\n    rep(z, cz.size()) rep(y, cy.size()) rep(x, cx.size())\n        imos[z][y][x + 1] += imos[z][y][x];\n    // imos y\n    rep(z, cz.size()) rep(x, cx.size()) rep(y, cy.size())\n        imos[z][y + 1][x] += imos[z][y][x];\n    // imos z\n    rep(y, cy.size()) rep(x, cx.size()) rep(z, cz.size())\n        imos[z + 1][y][x] += imos[z][y][x];\n\n    ll res = 0;\n    rep(z, cz.size()) rep(y, cy.size()) rep(x, cx.size())\n        if (imos[z][y][x] >= k)\n            res += (cz[z + 1] - cz[z]) * (cy[y + 1] - cy[y]) * (cx[x + 1] - cx[x]);\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<string>\n#include<vector>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\ntypedef unsigned long long ullong;\n\nstatic const int MAX = 50;\nstatic const int GMAX = 102;\n\nstruct Point{ int x, y, z; };\nint G[GMAX][GMAX][GMAX];\n\nmain(){\n  int N, K, x, y, z, nx, ny, nz;\n  cin >> N >> K;\n  pair<Point, Point> C[MAX];\n  set<int> X, Y, Z;\n  vector<int> VX, VY, VZ;\n  map<int, int> MX, MY, MZ;\n\n  rep(i, N){\n    cin >> C[i].first.x >> C[i].first.y >> C[i].first.z;\n    cin >> C[i].second.x >> C[i].second.y >> C[i].second.z;\n    X.insert(C[i].first.x);\n    X.insert(C[i].second.x);\n    Y.insert(C[i].first.y);\n    Y.insert(C[i].second.y);\n    Z.insert(C[i].first.z);\n    Z.insert(C[i].second.z);\n  }\n\n  nx = ny = nz = 0;\n  for ( set<int>::iterator it = X.begin(); it != X.end(); it++){\n    VX.push_back(*it);\n    MX[*it] = nx++;\n  }\n  for ( set<int>::iterator it = Y.begin(); it != Y.end(); it++){\n    VY.push_back(*it);\n    MY[*it] = ny++;\n  }\n  for ( set<int>::iterator it = Z.begin(); it != Z.end(); it++){\n    VZ.push_back(*it);\n    MZ[*it] = nz++;\n  }\n\n  rep(i, nx) rep(j, ny) rep(k, nz) G[i][j][k] = 0;\n\n  rep(i, N){\n    int sx = MX[C[i].first.x];\n    int tx = MX[C[i].second.x];\n    int sy = MY[C[i].first.y];\n    int ty = MY[C[i].second.y];\n    int sz = MZ[C[i].first.z];\n    int tz = MZ[C[i].second.z];\n    REP(x, sx, tx) REP(y, sy, ty) REP(z, sz, tz) G[x][y][z]++;\n  }\n\n  ullong sum = 0;\n  rep(x, nx){\n    rep(y, ny){\n      rep(z, nz){\n\tif ( G[x][y][z] >= K ){\n\t  sum += (VX[x+1] - VX[x])*(VY[y+1] - VY[y])*(VZ[z+1] - VZ[z]);\n\t}\n      }\n    }\n  }\n\n  cout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\ntypedef unsigned long long ull;\nconst int MAX_N = 50;\nint N, K;\n\nint x1[MAX_N], y1[MAX_N], d1[MAX_N], x2[MAX_N], y2[MAX_N], d2[MAX_N];\n\nint countKind(int x, int y, int d){\n\tint ans = 0;\n\tx++; y++; d++;\n\tfor(int i=0; i<N; i++){\n\t\tif(x1[i]<=x && x<=x2[i] && y1[i]<=y && y<=y2[i] && d1[i]<=d && d<=d2[i]) ans ++;\n\t}\n\treturn ans;\n}\n\nusing namespace std;\n\nint main(){\n\tull v = 0;\n\tcin >> N >> K;\n\n\tvector<int> X(2*N), Y(2*N), D(2*N);\n\n\tfor(int i=0; i<N; i++){\n\t\tcin >> x1[i] >> y1[i] >> d1[i] >> x2[i] >> y2[i] >> d2[i];\n\t\tX[i]   = x1[i];\n\t\tX[i+N] = x2[i];\n\t\tY[i]   = y1[i];\n\t\tY[i+N] = y2[i];\n\t\tD[i]   = d1[i];\n\t\tD[i+N] = d2[i];\n\t}\n\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\tfor(int i=0; i<2*N-1; i++){\n\tfor(int j=0; j<2*N-1; j++){\n\tfor(int k=0; k<2*N-1; k++){\n\t\tv += (countKind(X[i], Y[j], D[k]) >= K ? (X[i+1]-X[i]) * (Y[j+1]-Y[j]) * (D[k+1]-D[k]) : 0);\n\t}}}\n\n\tprintf(\"%llu\\n\", v);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\ntypedef vector<vvi> vvvi;\nint main(){\n\tint n,K;\n\tcin>>n>>K;\n\tvi x,y,d;\n\tvi x1(n),y1(n),d1(n);\n\tvi x2(n),y2(n),d2(n);\n\tREP(i,n){\n\t\tcin>>x1[i]>>y1[i]>>d1[i];\n\t\tcin>>x2[i]>>y2[i]>>d2[i];\n\t\tx.push_back(x1[i]);\n\t\tx.push_back(x2[i]);\n\t\ty.push_back(y1[i]);\n\t\ty.push_back(y2[i]);\n\t\td.push_back(d1[i]);\n\t\td.push_back(d2[i]);\n\t}\n\tsort(ALL(x));\n\tsort(ALL(y));\n\tsort(ALL(d));\n\tx.erase(unique(ALL(x)),x.end());\n\ty.erase(unique(ALL(y)),y.end());\n\td.erase(unique(ALL(d)),d.end());\n\t\n\tvvvi f(x.size(),vvi(y.size(),vi(d.size())));\n\tREP(i,n){\n\t\tREP(j,x.size()-1){\n\t\tREP(k,y.size()-1){\n\t\tREP(l,d.size()-1){\n\t\t\tif(x1[i]<=x[j]&&x[j+1]<=x2[i]&&\n\t\t\ty1[i]<=y[k]&&y[k+1]<=y2[i]&&\n\t\t\td1[i]<=d[l]&&d[l+1]<=d2[i]){\n\t\t\t\tf[j][k][l]++;\n\t\t\t}\n\t\t}\n\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\tREP(j,x.size()-1){\n\tREP(k,y.size()-1){\n\tREP(l,d.size()-1){\n\t\tif(f[j][k][l]>=K){\n\t\t\tans+=(ll)(x[j+1]-x[j])*(y[k+1]-y[k])*(d[l+1]-d[l]);\n\t\t\t//cerr<<\"x\"<<x[j]<<\"-\"<<x[j+1]<<endl;\n\t\t\t//cerr<<\"y\"<<y[k]<<\"-\"<<y[k+1]<<endl;\n\t\t\t//cerr<<\"d\"<<d[l]<<\"-\"<<d[l+1]<<endl;\n\t\t}\n\t}\n\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n#define FI first\n#define SE second\n#define PB push_back\n#define MT make_tuple\n#define int long long\nusing namespace std;\n\nint N,K;\nint fld[105][105][105];\nint X1[55],X2[55],Y1[55],Y2[55],Z1[55],Z2[55];\nvector<int> X,Y,Z;\n\nvector<int> compress(int *x1,int *x2){\n    vector<int> xs;\n    for(int i=0;i<N;++i){\n        xs.PB(x1[i]);\n        xs.PB(x2[i]);\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    vector<int> length;\n    for(int i=0;i<xs.size()-1;++i){\n        length.PB(xs[i+1]-xs[i]);\n    }\n    return length;\n}\n\n\nsigned main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    X=compress(X1,X2);\n    Y=compress(Y1,Y2);\n    Z=compress(Z1,Z2);\n    for(int i=0;i<N;++i){\n        for(int x=X1[i];x<X2[i];++x){\n            for(int y=Y1[i];y<Y2[i];++y){\n                for(int z=Z1[i];z<Z2[i];++z){\n                    fld[x][y][z]++;\n                }\n            }\n        }\n    }\n    int ans=0;\n    for(int x=0;x<X.size();++x){\n        for(int y=0;y<Y.size();++y){\n            for(int z=0;z<Z.size();++z){\n                if(fld[x][y][z]>=K)ans+=X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <cstdint>\n\nconstexpr uint32_t N_MAX = 50;\nuint32_t N, K,X,Y,Z;\nuint32_t p1x[N_MAX];\nuint32_t p2x[N_MAX];\nuint32_t p1y[N_MAX];\nuint32_t p2y[N_MAX];\nuint32_t p1z[N_MAX];\nuint32_t p2z[N_MAX];\nuint8_t graph[N_MAX*2][N_MAX*2][N_MAX*2];//z,y,x\nuint32_t width_x[N_MAX*2];\nuint32_t width_y[N_MAX*2];\nuint32_t width_z[N_MAX*2];\n\nuint32_t com(uint32_t a1[],uint32_t a2[], uint32_t length,uint32_t width_out[])\n{\n\tstatic uint32_t tmp_arr[N_MAX*2];\n\tauto iter = tmp_arr;\n\tfor(uint32_t i = 0;i < length;++i){\n\t\t*iter++ = a1[i];\n\t\t*iter++ = a2[i];\n\t}\n\tstd::sort(tmp_arr, iter);\n\titer = std::unique(tmp_arr, iter);\n\tfor(uint32_t i = 0;i < length;++i){\n\t\ta1[i] = std::lower_bound(tmp_arr, iter, a1[i]) - tmp_arr;\n\t}\n\tfor(uint32_t i = 0;i < length;++i){\n\t\ta2[i] = std::lower_bound(tmp_arr, iter, a2[i]) - tmp_arr;\n\t}\n\tlength = iter - tmp_arr;\n\tfor(uint32_t i = 0;i < length-1;++i){\n\t\twidth_out[i] = tmp_arr[i+1] - tmp_arr[i];\n\t}\n\treturn length;\n}\n\nint main()\n{\n\tstd::cin >> N>>K;\n\tfor(uint32_t i = 0;i < N;++i){\n\t\tstd::cin >> p1x[i]>>p1y[i]>>p1z[i]>>p2x[i]>>p2y[i]>>p2z[i];\n\t}\n\tX = com(p1x,p2x,N, width_x);\n\tY = com(p1y,p2y,N, width_y);\n\tZ = com(p1z,p2z,N, width_z);\n\t\n\t//いもす\n\tfor(uint32_t i = 0;i < N;++i){\n\t\t++graph[p1x[i]][p1y[i]][p1z[i]];\n\t\t--graph[p2x[i]][p1y[i]][p1z[i]];\n\t\t--graph[p1x[i]][p2y[i]][p1z[i]];\n\t\t++graph[p2x[i]][p2y[i]][p1z[i]];\n\t\t--graph[p1x[i]][p1y[i]][p2z[i]];\n\t\t++graph[p2x[i]][p1y[i]][p2z[i]];\n\t\t++graph[p1x[i]][p2y[i]][p2z[i]];\n\t\t--graph[p2x[i]][p2y[i]][p2z[i]];\n\t}\n\tfor(uint32_t z = 0;z < Z;++z)\n\tfor(uint32_t y = 0;y < Y;++y)for(uint32_t x = 1;x < X;++x){\n\t\tgraph[z][y][x] += graph[z][y][x-1];\n\t}\n\tfor(uint32_t z = 0;z < Z;++z)\n\tfor(uint32_t y = 1;y < Y;++y)for(uint32_t x = 0;x < X;++x){\n\t\tgraph[z][y][x] += graph[z][y-1][x];\n\t}\n\tfor(uint32_t z = 1;z < Z;++z)\n\tfor(uint32_t y = 0;y < Y;++y)for(uint32_t x = 0;x < X;++x){\n\t\tgraph[z][y][x] += graph[z-1][y][x];\n\t}\n\t#if 0\n\tstd::cout<<\"(\"<<X<<','<<Y<<','<<X<<')' <<\"------------------------\\n\";\n\tfor(uint32_t z = 0;z < Z;++z){\n\tfor(uint32_t y = 0;y < Y;++y){for(uint32_t x = 0;x < X;++x){\n\t\tstd::cout << graph[z][y][x] << ' ';\n\t}std::cout <<'\\n';}std::cout <<\"------------------------\\n\";}\n\t#endif\n\t//K以上をカウント\n\tuint64_t count = 0;\n\tfor(uint32_t z = 0;z < Z;++z)\n\tfor(uint32_t y = 0;y < Y;++y)for(uint32_t x = 0;x < X;++x){\n\t\tif(K <= graph[z][y][x]){\n\t\t\tcount += (uint64_t)(width_x[x])*(uint64_t)(width_y[y])\n\t\t\t\t*(uint64_t)(width_z[z]);\n\t\t}\n\t}\n\tstd::cout << count << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<string>\n#include<vector>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\ntypedef unsigned long long ullong;\n\nstatic const int MAX = 50;\nstatic const int GMAX = 55;\n\nstruct Point{ int x, y, z; };\n\nmain(){\n  int N, K, x, y, z, nx, ny, nz;\n  cin >> N >> K;\n  pair<Point, Point> C[MAX];\n  set<int> X, Y, Z;\n  vector<int> VX, VY, VZ;\n  map<int, int> MX, MY, MZ;\n\n  rep(i, N){\n    cin >> C[i].first.x >> C[i].first.y >> C[i].first.z;\n    cin >> C[i].second.x >> C[i].second.y >> C[i].second.z;\n    X.insert(C[i].first.x);\n    X.insert(C[i].second.x);\n    Y.insert(C[i].first.y);\n    Y.insert(C[i].second.y);\n    Z.insert(C[i].first.z);\n    Z.insert(C[i].second.z);\n  }\n\n  nx = ny = nz = 0;\n  for ( set<int>::iterator it = X.begin(); it != X.end(); it++){\n    VX.push_back(*it);\n    MX[*it] = nx++;\n  }\n  for ( set<int>::iterator it = Y.begin(); it != Y.end(); it++){\n    VY.push_back(*it);\n    MY[*it] = ny++;\n  }\n  for ( set<int>::iterator it = Z.begin(); it != Z.end(); it++){\n    VZ.push_back(*it);\n    MZ[*it] = nz++;\n  }\n\n  int G[GMAX][GMAX][GMAX];\n  rep(i, nx) rep(j, ny) rep(k, nz) G[i][j][k] = 0;\n\n  rep(i, N){\n    int sx = MX[C[i].first.x];\n    int tx = MX[C[i].second.x];\n    int sy = MY[C[i].first.y];\n    int ty = MY[C[i].second.y];\n    int sz = MZ[C[i].first.z];\n    int tz = MZ[C[i].second.z];\n    REP(x, sx, tx) REP(y, sy, ty) REP(z, sz, tz) G[x][y][z]++;\n  }\n\n  ullong sum = 0;\n  rep(x, nx){\n    rep(y, ny){\n      rep(z, nz){\n\tif ( G[x][y][z] >= K ){\n\t  sum += (VX[x+1] - VX[x])*(VY[y+1] - VY[y])*(VZ[z+1] - VZ[z]);\n\t}\n      }\n    }\n  }\n\n  cout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n\tvector<int>x,y,d;\n\tstatic int zx[1000000+2],zy[1000000+2],zd[1000000+2],p[50][6],n,k,sea[102][102][102];\n\tlong long int ans=0,a;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<6;j++){\n\t\t\tscanf(\"%d\",&p[i][j]);\n\t\t}\n\t\tx.push_back(p[i][0]);\n\t\tx.push_back(p[i][3]);\n\t\ty.push_back(p[i][1]);\n\t\ty.push_back(p[i][4]);\n\t\td.push_back(p[i][2]);\n\t\td.push_back(p[i][5]);\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tsort(d.begin(),d.end());\n\tint N=2*n;\n\tfor(int i=0;i<N;i++){\n\t\tzx[x[i]]=i;\n\t\tzy[y[i]]=i;\n\t\tzd[d[i]]=i;\n\t}\n\tfor(int i=0;i<N+1;i++){\n\t\tfor(int j=0;j<N+1;j++){\n\t\t\tfor(int l=0;l<N+1;l++){\n\t\t\t\tsea[i][j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tsea[zx[p[i][0]]][zy[p[i][1]]][zd[p[i][2]]]++;\n\t\tsea[zx[p[i][0]]][zy[p[i][1]]][zd[p[i][5]]]--;\n\t\tsea[zx[p[i][0]]][zy[p[i][4]]][zd[p[i][2]]]--;\n\t\tsea[zx[p[i][0]]][zy[p[i][4]]][zd[p[i][5]]]++;\n\t\tsea[zx[p[i][3]]][zy[p[i][1]]][zd[p[i][2]]]--;\n\t\tsea[zx[p[i][3]]][zy[p[i][1]]][zd[p[i][5]]]++;\n\t\tsea[zx[p[i][3]]][zy[p[i][4]]][zd[p[i][2]]]++;\n\t\tsea[zx[p[i][3]]][zy[p[i][4]]][zd[p[i][5]]]--;\n\t}\n\tfor(int i=0;i<N+1;i++){\n\t\tfor(int j=0;j<N+1;j++){\n\t\t\tfor(int l=0;l<N+1;l++){\n\t\t\t\tif(i!=0)sea[i][j][l]+=sea[i-1][j][l];\n\t\t\t\tif(j!=0)sea[i][j][l]+=sea[i][j-1][l];\n\t\t\t\tif(l!=0)sea[i][j][l]+=sea[i][j][l-1];\n\t\t\t\tif(sea[i][j][l]>=k){\n\t\t\t\t\ta=1;\n\t\t\t\t\ta*=x[i+1]-x[i];\n\t\t\t\t\ta*=y[j+1]-y[j];\n\t\t\t\t\ta*=d[l+1]-d[l];\n\t\t\t\t\tans+=a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint x[100];\nint y[100];\nint z[100];\nint x1[50];\nint x2[50];\nint y1[50];\nint y2[50];\nint z1[50];\nint z2[50];\nint table[100][100][100];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d%d%d%d%d\",x1+i,y1+i,z1+i,x2+i,y2+i,z2+i);\n\t\tx[i*2]=x1[i];x[i*2+1]=x2[i];\n\t\ty[i*2]=y1[i];y[i*2+1]=y2[i];\n\t\tz[i*2]=z1[i];z[i*2+1]=z2[i];\n\t}\n\tstd::sort(x,x+a*2);std::sort(y,y+a*2);std::sort(z,z+a*2);\n\tfor(int i=0;i<a;i++){\n\t\tint X1=lower_bound(x,x+a*2,x1[i])-x;\n\t\tint Y1=lower_bound(y,y+a*2,y1[i])-y;\n\t\tint Z1=lower_bound(z,z+a*2,z1[i])-z;\n\t\tint X2=lower_bound(x,x+a*2,x2[i])-x;\n\t\tint Y2=lower_bound(y,y+a*2,y2[i])-y;\n\t\tint Z2=lower_bound(z,z+a*2,z2[i])-z;\n\t\ttable[X1][Y1][Z1]++;\n\t\ttable[X1][Y1][Z2]--;\n\t\ttable[X1][Y2][Z1]--;\n\t\ttable[X2][Y1][Z1]--;\n\t\ttable[X1][Y2][Z2]++;\n\t\ttable[X2][Y1][Z2]++;\n\t\ttable[X2][Y2][Z1]++;\n\t\ttable[X2][Y2][Z2]--;\n\t}\n\tfor(int i=0;i<a*2;i++)\n\t\tfor(int j=0;j<a*2;j++)\n\t\t\tfor(int k=1;k<a*2;k++){\n\t\t\t\ttable[i][j][k]=table[i][j][k]+table[i][j][k-1];\n\t\t\t}\n\tfor(int k=0;k<a*2;k++)\n\t\tfor(int j=0;j<a*2;j++)\n\t\t\tfor(int i=1;i<a*2;i++){\n\t\t\t\ttable[i][j][k]=table[i][j][k]+table[i-1][j][k];\n\t\t\t}\n\tfor(int k=0;k<a*2;k++)\n\t\tfor(int i=0;i<a*2;i++)\n\t\t\tfor(int j=1;j<a*2;j++){\n\t\t\t\ttable[i][j][k]=table[i][j][k]+table[i][j-1][k];\n\t\t\t}\n\tlong long ret=0;\n\tfor(int i=0;i<a*2;i++)\n\t\tfor(int j=0;j<a*2;j++)\n\t\t\tfor(int k=0;k<a*2;k++)\n\t\t\t\tif(table[i][j][k]>=b)ret+=(long long)(x[i+1]-x[i])*(y[j+1]-y[j])*(z[k+1]-z[k]);\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<string>\n#include<string.h>\n\nusing namespace std;\nstruct AREA {\n\tlong long int x, y, d;\n};\nstruct ANS {\n\tint X, Y, D, X1, Y1, D1;\n};\nint N, K;\nlong long int tmp;\nAREA box[101], del;\nANS Box[51];\nint main() {\n\tdel.x = 0;\n\tdel.y = 0;\n\tdel.d = 0;\n\tcin >> N >> K;\n\tfor (int i = 0; i < 2 * N; i++) {\n\t\tcin >> box[i].x >> box[i].y >> box[i].d;\n\t\tif (i % 2 == 0){\n\t\t\tBox[i / 2].X = box[i].x;\n\t\t\tBox[i / 2].Y = box[i].y;\n\t\t\tBox[i / 2].D = box[i].d;\n\t\t}\n\t\telse {\n\t\t\tBox[i / 2].X1 = box[i].x;\n\t\t\tBox[i / 2].Y1 = box[i].y;\n\t\t\tBox[i / 2].D1 = box[i].d;\n\t\t}\n\t}\n\tfor (int i = 0; i < 2*N; i++) {\n\t\tfor (int j = 2*N - 1; j > i; j--) {\n\t\t\tif (box[j - 1].x > box[j].x) {\n\t\t\t\ttmp = box[j - 1].x;\n\t\t\t\tbox[j - 1].x = box[j].x;\n\t\t\t\tbox[j].x = tmp;\n\t\t\t}\n\t\t\tif (box[j - 1].x == box[j].x&&box[j - 1].x != 1000000000) {\n\t\t\t\tbox[j].x = 1000000000;\n\t\t\t\tdel.x++;\n\t\t\t}\n\t\t\tif (box[j - 1].y > box[j].y) {\n\t\t\t\ttmp = box[j - 1].y;\n\t\t\t\tbox[j - 1].y = box[j].y;\n\t\t\t\tbox[j].y = tmp;\n\t\t\t}\n\t\t\tif (box[j - 1].y == box[j].y&&box[j - 1].x != 1000000000) {\n\t\t\t\tbox[j].y = 1000000000;\n\t\t\t\tdel.y++;\n\t\t\t}\n\t\t\tif (box[j - 1].d > box[j].d){\n\t\t\t\ttmp = box[j - 1].d;\n\t\t\t\tbox[j - 1].d = box[j].d;\n\t\t\t\tbox[j].d = tmp;\n\t\t\t\t}\n\t\t\tif (box[j - 1].d == box[j].d&&box[j - 1].d != 1000000000) {\n\t\t\t\tbox[j].d = 1000000000;\n\t\t\t\tdel.d++;\n\t\t\t}\n\t\t}\n\t}\n\tint CNT=0;\n\tlong long int ANS=0;\n\tfor (int i = 0; i < 2 * N - del.x - 1; i++) {\n\t\tfor (int j = 0; j < 2 * N - del.y - 1; j++) {\n\t\t\tfor (int k = 0; k < 2 * N - del.d - 1; k++) {\n\t\t\t\tfor (int l = 0; l < N; l++) {\n\t\t\t\t\tif (Box[l].X <= box[i].x&&box[i + 1].x <= Box[l].X1&&Box[l].Y <= box[j].y&&box[j + 1].y <= Box[l].Y1&&Box[l].D <= box[k].d&&box[k + 1].d <= Box[l].D1)\n\t\t\t\t\t\tCNT++;\n\t\t\t\t}\n\t\t\t\tif (CNT >= K)\n\t\t\t\t\tANS += (box[i + 1].x - box[i].x)*(box[j + 1].y - box[j].y)*(box[k + 1].d - box[k].d);\n\t\t\t\tCNT = 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ANS << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX_DIS = 1000000;\nint n, k;\nint x[2][51], y[2][51], z[2][51];\nint ocean[301][301][301];\nlong long int lx[301], ly[301], lz[301];\nlong long int ans;\n\nint compress(int *start, int *end, long long int *lx){\n    vector<int> v;\n\n    for(int i = 0; i < n; i++){\n        for(int j = -1; j <= 1; j++){\n            int x1 = start[i] + j, x2 = end[i] + j;\n            if(0 <= x1 && x1 <= MAX_DIS)\n                v.push_back(x1);\n            if(0 <= x2 && x2 <= MAX_DIS)\n                v.push_back(x2);\n        }\n    }\n\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n\n    for(int i = 0; i < n; i++){\n        start[i] = find(v.begin(), v.end(), start[i]) - v.begin();\n        end[i] = find(v.begin(), v.end(), end[i]) - v.begin();\n    }\n\n    for(int i = 0; i < v.size(); i++)\n        lx[i] = v[i];\n\n    return v.size();\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &k);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d%d%d%d%d%d\", &x[0][i], &y[0][i], &z[0][i], &x[1][i], &y[1][i], &z[1][i]);\n    }\n\n    int w = compress(x[0], x[1], lx);\n    int h = compress(y[0], y[1], ly);\n    int d = compress(z[0], z[1], lz);\n\n    for(int i = 0; i < n; i++){\n        for(int j = x[0][i]; j < x[1][i]; j++){\n            for(int l = y[0][i]; l < y[1][i]; l++){\n                for(int m = z[0][i]; m < z[1][i]; m++){\n                    ocean[j][l][m]++;\n                }\n            }\n        }\n    }\n\n    for(int i = 0; i < w - 1; i++){\n        for(int j = 0; j < h - 1; j++){\n            for(int l = 0; l < d - 1; l++){\n                if(ocean[i][j][l] >= k)\n                    ans += (lx[i + 1] - lx[i]) * (ly[j + 1] - ly[j]) * (lz[l + 1] - lz[l]);\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\ntypedef __int64 LONG;\n\nLONG zip[3][200];\nint M[3];\n\nint a[50][6];\nint N, K;\n\nint O[200][200][200];\n\nint main()\n{\n\tscanf(\"%d %d\", &N, &K);\t\n\tmemset(zip, -1, sizeof(zip));\n\tmemset(M, 0, sizeof(M));\n\tmemset(a, 0, sizeof(a));\n\tmemset(O, 0, sizeof(O));\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = 0; j < 6; j++){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\t\n\t\t\tbool f = true;\n\t\t\tfor (int k = 0; k < M[j % 3]; k++){\n\t\t\t\tif (zip[j % 3][k] == a[i][j]){\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (f){\n\t\t\t\tzip[j % 3][M[j % 3]] = a[i][j];\n\t\t\t\tM[j % 3]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < 3; i++){\n\t\tsort(zip[i], zip[i] + M[i]);\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = 0; j < 6; j++){\n\t\t\tint l = 0;\n\t\t\tint r = M[j % 3] - 1;\n\t\t\tint m = (l + r) / 2;\n\t\t\t\n\t\t\twhile (zip[j % 3][m] != a[i][j]){\n\t\t\t\tif (zip[j % 3][m] < a[i][j]){\n\t\t\t\t\tl = m + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tr = m - 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tm = (l + r) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta[i][j] = m;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int x = a[i][0]; x < a[i][3]; x++){\n\t\t\tfor (int y = a[i][1]; y < a[i][4]; y++){\n\t\t\t\tfor (int z = a[i][2]; z < a[i][5]; z++){\n\t\t\t\t\tO[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tLONG sum = 0;\n\t\n\tfor (int x = 0; x < 200; x++){\n\t\tfor (int y = 0; y < 200; y++){\n\t\t\tfor (int z = 0; z < 200; z++){\n\t\t\t\tif (O[x][y][z] >= K){\n\t\t\t\t\tsum += (zip[0][x + 1] - zip[0][x]) * \n\t\t\t\t\t       (zip[1][y + 1] - zip[1][y]) *\n\t\t\t\t\t       (zip[2][z + 1] - zip[2][z]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%I64d\\n\", sum);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#define all(c) (c).begin(),(c).end()\n#define f first\n#define s second\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct point{ll x,y,z;};\n\ntypedef pair<point,point> P;\n\nint main(){\n  ll n,k,x1,x2,y1,y2,z1,z2;\n  vector<ll>x,y,z;\n\n  cin >> n >> k;\n  vector<P> p(n);\n\n  for(int i=0;i<n;i++){\n    cin >> p[i].f.x >> p[i].f.y >> p[i].f.z;\n    cin >> p[i].s.x >> p[i].s.y >> p[i].s.z;\n\n    x.push_back(p[i].f.x);\n    x.push_back(p[i].s.x);\n    y.push_back(p[i].f.y);\n    y.push_back(p[i].s.y);\n    z.push_back(p[i].f.z);\n    z.push_back(p[i].s.z);\n  }\n  \n  sort(all(x));\n  sort(all(y));\n  sort(all(z));\n\n  map<ll,int>X,Y,Z;\n  \n  for(int i=0;i<x.size();i++)X[x[i]]=i;\n  for(int i=0;i<y.size();i++)Y[y[i]]=i;\n  for(int i=0;i<z.size();i++)Z[z[i]]=i;\n  \n  int board[101][101][101];\n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)\n      for(int l=0;l<101;l++)board[i][j][l]=0;\n\n  for(int i=0;i<n;i++)\n    for(int xi=X[p[i].f.x];xi<X[p[i].s.x];xi++)\n      for(int yi=Y[p[i].f.y];yi<Y[p[i].s.y];yi++)\n\tfor(int zi=Z[p[i].f.z];zi<Z[p[i].s.z];zi++)\n\t  board[xi][yi][zi]++;\n\n  ll ans=0;\n  for(int i=0;i<x.size()-1;i++)\n    for(int j=0;j<y.size()-1;j++)\n      for(int l=0;l<z.size()-1;l++)\n\tif(board[i][j][l]>=k)\n\t  ans+=(x[i+1]-x[i])*(y[j+1]-y[j])*(z[l+1]-z[l]);\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef long long ll;\n\nll n, K;\nvector<ll> unzipx, unzipy, unzipz;\nint x, y, z;\nvector<ll>  bx, by, bz, ex, ey, ez;\nint sum[105][105][105];\n\nint press(vector<ll>& v1, vector<ll>& v2,vector<ll>& unzip) {\n\tauto t1 = v1, t2 = v2;\n\tt1.insert(t1.end(), t2.begin(), t2.end());\n\tsort(t1.begin(), t1.end());\n\tt1.erase(unique(t1.begin(), t1.end()), t1.end());\n\tfor (int i = 0; i < v1.size(); i++) {\n\t\tll tmp = lower_bound(t1.begin(), t1.end(), v1[i]) - t1.begin();\n\t\tunzip[tmp] = v1[i];\n\t\tv1[i] = tmp;\n\t}\n\n\tfor (int i = 0; i < v2.size(); i++) {\n\t\tll tmp = lower_bound(t1.begin(), t1.end(), v2[i]) - t1.begin();\n\t\tunzip[tmp] = v2[i];\n\t\tv2[i] = tmp;\n\t}\n\t\n\treturn t1.size();\n}\n\nint main() {\n\tunzipx.resize(55 * 3), unzipy.resize(55 * 3), unzipz.resize(55 * 3);\n\tcin >> n >> K;\n\tfor (int i = 0; i < n; i++) {\n\t\tll a, b, c, d, e, f;\n\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\tbx.push_back(a), by.push_back(b), bz.push_back(c);\n\t\tex.push_back(d), ey.push_back(e), ez.push_back(f);\n\t}\n\tx = press(bx, ex, unzipx), y = press(by, ey, unzipy), z = press(bz, ez, unzipz);\n\t// ?´?????????????\n\tll ans = 0;\n\tfor (int i = 0; i < bx.size(); i++) {\n\t\tfor (int j = bx[i]; j < ex[i]; j++) {\n\t\t\tfor (int k = by[i]; k < ey[i]; k++) {\n\t\t\t\tfor (int l = bz[i]; l < ez[i]; l++) {\n\t\t\t\t\tsum[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < x - 1; i++) {\n\t\tfor (int j = 0; j < y - 1; j++) {\n\t\t\tfor (int k = 0; k < z - 1; k++) {\n\t\t\t\tif (sum[i][j][k] >= K) {\n\t\t\t\t\tans += ((unzipx[i + 1] - unzipx[i]) * (unzipy[j + 1] - unzipy[j]) * (unzipz[k + 1] - unzipz[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\n\nint N,K;\nint W,H,D;\nint X1[55],Y1[55],Z1[55],X2[55],Y2[55],Z2[55];\nint cx1[55],cy1[55],cz1[55],cx2[55],cy2[55],cz2[55];\nvector<int> X,Y,Z;\nunsigned short fld[51*6][51*6][51*6];\n\nint ans;\nvector<int> xs;\n\nvoid compress(vector<int> &X,int* x1,int* x2,int* vx1,int* vx2,int w,int* P){\n    xs.clear();\n    for(int i=0;i<N;++i){\n        x1[i]=vx1[i];\n        x2[i]=vx2[i];\n    }\n    for(int i=0;i<N;++i){\n        for(int d=-1;d<=1;++d){\n            int tx1=x1[i]+d;\n            int tx2=x2[i]+d;\n            if(0<=tx1&&tx1<=w)xs.PB(tx1);\n            if(0<=tx2&&tx2<=w)xs.PB(tx2);\n        }\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    //for(int i=0;i<xs.size();++i)cout<<xs[i]<<endl;\n    for(int i=0;i<xs.size();++i){\n        X.PB(xs[i+1]-xs[i]);\n    }\n    *P = xs.size();\n}\n\nint main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    compress(X,cx1,cx2,X1,X2,1000000,&W);\n    compress(Y,cy1,cy2,Y1,Y2,1000000,&H);\n    compress(Z,cz1,cz2,Z1,Z2,1000000,&D);\n    for(int i=0;i<N;++i){\n        for(int z=cz1[i];z<cz2[i];++z){\n            for(int y=cy1[i];y<cy2[i];++y){\n                for(int x=cx1[i];x<cx2[i];++x){\n                    fld[z][y][x]++;\n                }\n            }\n        }\n    }\n    for(int z=0;z<=D;++z){\n        for(int y=0;y<=H;++y){\n            for(int x=0;x<=W;++x){\n                if(fld[z][y][x]>=K)ans+=X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n\n    //cout<<W<<\" \"<<H<<\" \"<<D<<endl;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nint main(void) {\n  int i, j, k, l, m, n;\n  long long ans = 0;\n  std::vector<int> vx, vy, vd;\n  scanf(\"%d%d\", &n, &k);\n  int x1[n], y1[n], d1[n], x2[n], y2[n], d2[n];\n  for(i = 0; i < n; ++i) {\n    scanf(\"%d%d%d%d%d%d\", &x1[i], &y1[i], &d1[i], &x2[i], &y2[i], &d2[i]);\n    vx.push_back(x1[i]);\n    vx.push_back(x2[i]);\n    vy.push_back(y1[i]);\n    vy.push_back(y2[i]);\n    vd.push_back(d1[i]);\n    vd.push_back(d2[i]);\n  }\n  std::sort(vx.begin(), vx.end());\n  std::sort(vy.begin(), vy.end());\n  std::sort(vd.begin(), vd.end());\n  vx.erase(std::unique(vx.begin(), vx.end()), vx.end());\n  vy.erase(std::unique(vy.begin(), vy.end()), vy.end());\n  vd.erase(std::unique(vd.begin(), vd.end()), vd.end());\n  for(i = 1; i < vx.size(); ++i) {\n    for(j = 1; j < vy.size(); ++j) {\n      for(l = 1; l < vd.size(); ++l) {\n        int t = 0;\n        for(m = 0; m < n; ++m) {\n          if(x1[m] <= vx[i - 1] && vx[i] <= x2[m] && y1[m] <= vy[j - 1] && vy[j] <= y2[m] && d1[m] <= vd[l - 1] && vd[l] <= d2[m]) ++t;\n        }\n        if(t >= k) ans += (long long)(vx[i] - vx[i - 1]) * (long long)(vy[j] - vy[j - 1]) * (long long)(vd[l] - vd[l - 1]);\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx\")\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;i<(n);i++)\n#define rrep(i,n) for(int (i)=1;i<=(n);i++)\n#define REP(i,m,n) for(int (i)=(m);(i)<(n);(i)++)\n#define MOD 1000000007\n#define INF 1e18\n#define int long long\n#define endl \"\\n\"\n#define yorn(f) puts((f)?\"Yes\":\"No\")\n#define YORN(f) puts((f)?\"YES\":\"NO\")\ntypedef long long ll;\ntypedef pair<int, int> P;\nint gcd(int a,int b){return b?gcd(b,a%b):a;};\nint lcm(int a,int b){return a/gcd(a,b)*b;};\nint mod(int a,int b){return (a+b-1)/b;};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N],const T &val){std::fill((T*)array,(T*)(array+N),val);}\ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;};\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;};\n\nint x[2][55], y[2][55], z[2][55];\nvector<int> X, Y, Z;\n\nsigned main() {\n\tcin.tie(0);\n\tcout.tie(0);\n\tios::sync_with_stdio(false);\n\t//cout << fixed << setprecision(15);\n\t\n\tint N, K;\n\tcin >> N >> K;\n\trep(i, N) {\n\t\trep(j, 2) {\n\t\t\tcin >> x[j][i] >> y[j][i] >> z[j][i];\n\t\t\tX.push_back(x[j][i]);\n\t\t\tY.push_back(y[j][i]);\n\t\t\tZ.push_back(z[j][i]);\n\t\t}\n\t}\n\tsort(all(X));\n\tsort(all(Y));\n\tsort(all(Z));\n\n\tint ans = 0;\n\trep(i, 2 * N - 1) {\n\t\trep(j, 2 * N - 1) {\n\t\t\trep(k, 2 * N - 1) {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(l, N) {\n\t\t\t\t\tif(x[0][l] <= X[i] && X[i] < x[1][l] && y[0][l] <= Y[j] && Y[j] < y[1][l] && z[0][l] <= Z[k] && Z[k] < z[1][l]) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(K <= cnt) {\n\t\t\t\t\tint dx = X[i+1] - X[i];\n\t\t\t\t\tint dy = Y[j+1] - Y[j];\n\t\t\t\t\tint dz = Z[k+1] - Z[k];\n\t\t\t\t\tans += dx * dy * dz;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct square{\n    long long x1,y1,z1,x2,y2,z2;\n};\n\nvector<square> rippous;\nset<long long> xs, ys, zs;\nmap<long long, long long>transx, transy, transz;\nlong long field[150][150][150];\nlong long xx[150], yy[150], zz[150], K, n;\nlong long res;\nint main(){\n    cin >> n >> K;\n    for(long long i = 0;i < n;i++){\n\tsquare tmp;\n\tcin >> tmp.x1 >> tmp.y1 >> tmp.z1 >> tmp.x2 >> tmp.y2 >> tmp.z2;\n\trippous.push_back(tmp);\n\txs.insert(tmp.x1);xs.insert(tmp.x2);\n\tys.insert(tmp.y1);ys.insert(tmp.y2);\n\tzs.insert(tmp.z1);zs.insert(tmp.z2);\n    }\n    long long tttt;\n    set<long long>::iterator it = xs.begin();\n    long long ii = 0;\n    while(it != xs.end()){\n\txx[ii] = *it;\n\ttransx[*it] = ii;\n\tit++;\n\tii++;\n    }\n    ii = 0;\n    it = ys.begin();\n    while(it != ys.end()){\n\tyy[ii] = *it;\n\ttransy[*it] = ii;\n\tit++;\n\tii++;\n    }\n    ii = 0;\n    it = zs.begin();\n    while(it != zs.end()){\n\tzz[ii] = *it;\n\ttransz[*it] = ii;\n\tit++;\n\tii++;\n    }\n    for(long long i = 0;i < rippous.size();i++){\n\tsquare tmp = rippous[i];\n\ttmp.x1 = transx[tmp.x1];\n\ttmp.x2 = transx[tmp.x2];\n\ttmp.y1 = transy[tmp.y1];\n\ttmp.y2 = transy[tmp.y2];\n\ttmp.z1 = transz[tmp.z1];\n\ttmp.z2 = transz[tmp.z2];\n\tfield[tmp.x1][tmp.y1][tmp.z1] ++;\n\tfield[tmp.x2][tmp.y1][tmp.z1] --;\n\tfield[tmp.x1][tmp.y2][tmp.z1] --;\n\tfield[tmp.x2][tmp.y2][tmp.z1] ++;\n\tfield[tmp.x1][tmp.y1][tmp.z2] --;\n\tfield[tmp.x2][tmp.y1][tmp.z2] ++;\n\tfield[tmp.x1][tmp.y2][tmp.z2] ++;\n\tfield[tmp.x2][tmp.y2][tmp.z2] --;\n    }\n    for(long long i = 1;i < xs.size();i++){\n\tfor(long long j = 0;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tfield[i][j][k] += field[i - 1][j][k];\n\t    }\n\t}\n    }\n    for(long long i = 0;i < xs.size();i++){\n\tfor(long long j = 1;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tfield[i][j][k] += field[i][j - 1][k];\n\t    }\n\t}\n    }\n    for(long long i = 0;i < xs.size();i++){\n\tfor(long long j = 1;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tfield[i][j][k] += field[i][j][k - 1];\n\t    }\n\t}\n    }\n    for(long long i = 0;i < xs.size();i++){\n\tfor(long long j = 0;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tif(field[i][j][k] >= K) \n\t\t    res += (xx[i + 1] - xx[i]) * (yy[j + 1] - yy[j]) * (zz[k + 1] - zz[k]);\n\t    }\n\t}\n    } \n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 10001\n#define B 100\n#define dmp make_pair\n#define dpb push_back\n#define fi first\n#define se second\n#define P pair<int,int>\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\n/*chrono::system_clock::time_point  start;\nvoid timerstart(){start = chrono::system_clock::now();}\nvoid timerend(){\n\tauto end = chrono::system_clock::now();\n\tint elapsed = chrono::duration_cast<chrono::milliseconds>(end-start).count();\n\tprintf(\"%d[ms]\\n\", elapsed);\n}*/\n\nint n, k, fld[110][110][110];\nll cx[52][2], cy[52][2], cz[52][2];\nll dx[52], dy[52], dz[52];\nint compress1(int x1[52], int x2[52]){\n\tvector<int> xs;\n\tfor(int i = 0;i < n;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tfor(int i = 0;i < xs.size();i++)dx[i] = xs[i];\n\tfor(int i = 0;i < n;i++){\n\t\tcx[i][0] = find(xs.begin(), xs.end(), x1[i])-xs.begin();\n\t\tcx[i][1] = find(xs.begin(), xs.end(), x2[i])-xs.begin();\n\t}\n\treturn xs.size();\n}\n\nint compress2(int x1[52], int x2[52]){\n\tvector<int> xs;\n\tfor(int i = 0;i < n;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tfor(int i = 0;i < xs.size();i++)dy[i] = xs[i];\n\tfor(int i = 0;i < n;i++){\n\t\tcy[i][0] = find(xs.begin(), xs.end(), x1[i])-xs.begin();\n\t\tcy[i][1] = find(xs.begin(), xs.end(), x2[i])-xs.begin();\n\t}\n\treturn xs.size();\n}\n\nint compress3(int x1[52], int x2[52]){\n\tvector<int> xs;\n\tfor(int i = 0;i < n;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tfor(int i = 0;i < xs.size();i++)dz[i] = xs[i];\n\tfor(int i = 0;i < n;i++){\n\t\tcz[i][0] = find(xs.begin(), xs.end(), x1[i])-xs.begin();\n\t\tcz[i][1] = find(xs.begin(), xs.end(), x2[i])-xs.begin();\n\t}\n\treturn xs.size();\n}\n\nvoid paint(int w, int h, int d){\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int x = cx[i][0]+1;x <= cx[i][1];x++){\n\t\t\tfor(int y = cy[i][0]+1;y <= cy[i][1];y++){\n\t\t\t\tfor(int z = cz[i][0]+1;z <= cz[i][1];z++){\n\t\t\t\t\tfld[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint X1[52], X2[52], Y1[52];\n\tint Y2[52], Z1[52], Z2[52];\n\tscanf(\"%d%d\", &n, &k);\n\trep(i,n){\n\t\tscanf(\"%d%d%d\", &X1[i], &Y1[i], &Z1[i]);\n\t\tscanf(\"%d%d%d\", &X2[i], &Y2[i], &Z2[i]);\n\t}\n\tint w = compress1(X1, X2);\n\tint h = compress2(Y1, Y2);\n\tint d = compress3(Z1, Z2);\n\tpaint(w, h, d);\n\t\n\tll ans = 0, t1, t2, t3;\n\tfor(int x = 1;x < w;x++){\n\t\tfor(int y = 1;y < h;y++){\n\t\t\tfor(int z = 1;z < d;z++){\n\t\t\t\tif(fld[x][y][z] >= k){\n\t\t\t\t\tt1 = dx[x]-dx[x-1];\n\t\t\t\t\tt2 = dy[y]-dy[y-1];\n\t\t\t\t\tt3 = dz[z]-dz[z-1];\n\t\t\t\t\tans += (ll)t1*t2*t3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t/*printf(\"\\n\");\n\tfor(int i = 0;i < n;i++){\n\t\tprintf(\"%d %d\\n\", cy[i][0], cy[i][1]);\n\t}*/\n\t/*for(int i = 0;i < h;i++){\n\t\tprintf(\"%d \", dy[i]);\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nint N, K;\nint X1[55], X2[55];\nint Y1[55], Y2[55];\nint Z1[55], Z2[55];\n\nvector<int> X, Y, Z;\n\nint cnt[110][110][110];\n\nint compress(int *x1, int *x2, vector<int> &res)\n{\n    rep(i, N) {\n        res.push_back(x1[i]);\n        res.push_back(x2[i]);\n    }\n\n    sort(all(res));\n    res.erase(unique(all(res)), end(res));\n\n    return res.size();\n}\n\nint get_index(vector<int> &a, int v)\n{\n    return lower_bound(all(a), v) - begin(a);\n}\n\nint main()\n{\n    cin >> N >> K;\n\n    rep(i, N) {\n        cin >> X1[i] >> Y1[i] >> Z1[i];\n        cin >> X2[i] >> Y2[i] >> Z2[i];\n    }\n\n    int x = compress(X1, X2, X);\n    int y = compress(Y1, Y2, Y);\n    int z = compress(Z1, Z2, Z);\n\n    rep(i, N) {\n        for (int j = get_index(Z, Z1[i]), j_len = get_index(Z, Z2[i]); j < j_len; ++j) {\n            for (int k = get_index(Y, Y1[i]), k_len = get_index(Y, Y2[i]); k < k_len; ++k) {\n                for (int l = get_index(X, X1[i]), l_len = get_index(X, X2[i]); l < l_len; ++l) {\n                    cnt[j][k][l]++;\n                }\n            }\n        }\n    }\n\n    long long ans = 0;\n\n    rep(i, z - 1) rep(j, y - 1) rep(k, x - 1) {\n        if (cnt[i][j][k] >= K) {\n            ans += 1ll * (Z[i + 1] - Z[i]) * (Y[j + 1] - Y[j]) * (X[k + 1] - X[k]);\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n, k;\nvector<int> z[3];\nvector<int> comp[3];\n \nint s[100][100][100];\n\nint main(){\n\tvector<int>& x = z[0];\n\tvector<int>& y = z[1];\n\tvector<int>& d = z[2];\n\n\tscanf(\"%d%d\", &n, &k);\n\trep(i, 3){\n\t\tz[i].resize(2 * n);\n\t}\n\trep(i, n){\n\t\tscanf(\"%d%d%d\", &x[i], &y[i], &d[i]);\n\t\tscanf(\"%d%d%d\", &x[i + n], &y[i + n], &d[i + n]);\n\t}\n\n\trep(i, 3){\n\t\tcomp[i] = z[i];\n\t\tsort(comp[i].begin(), comp[i].end());\n\t\tcomp[i].erase(unique(comp[i].begin(), comp[i].end()), comp[i].end());\n\t\trep(j, 2 * n){\n\t\t\tz[i][j] = lower_bound(comp[i].begin(), comp[i].end(), z[i][j]) - comp[i].begin();\n\t\t}\n\t}\n\n\trep(i, n){\n\t\tint sx = x[i];\n\t\tint ex = x[i + n];\n\t\tint sy = y[i];\n\t\tint ey = y[i + n];\n\t\tint sd = d[i];\n\t\tint ed = d[i + n];\n\t\ts[sx][sy][sd] += 1;\n\t\ts[ex][sy][sd] -= 1;\n\t\ts[sx][ey][sd] -= 1;\n\t\ts[sx][sy][ed] -= 1;\n\t\ts[sx][ey][ed] += 1;\n\t\ts[ex][sy][ed] += 1;\n\t\ts[ex][ey][sd] += 1;\n\t\ts[ex][ey][ed] -= 1;\n\t}\n\n\trep(a, 3){\n\t\tint dz[3] = {0, 0, 0};\n\t\tdz[a] = 1;\n\t\tfor(int p = dz[0]; p < 2 * n; ++p){\n\t\t\tfor(int q = dz[1]; q < 2 * n; ++q){\n\t\t\t\tfor(int r = dz[2]; r < 2 * n; ++r){\n\t\t\t\t\ts[p][q][r] += s[p - dz[0]][q - dz[1]][r - dz[2]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\trep(r, 2 * n){\n\t\trep(p, 2 * n){\n\t\t\trep(q, 2 * n){\n\t\t\t\tprintf(\"%d\", s[p][q][r]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\n\tll ans = 0;\n\trep(p, 2 * n){\n\t\trep(q, 2 * n){\n\t\t\trep(r, 2 * n){\n\t\t\t\tif(s[p][q][r] >= k){\n\t\t\t\t\tll dx = comp[0][p + 1] - comp[0][p];\n\t\t\t\t\tll dy = comp[1][q + 1] - comp[1][q];\n\t\t\t\t\tll dd = comp[2][r + 1] - comp[2][r];\n\t\t\t\t\tans += (dx * dy * dd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\n\nint N, K;\n\n\n\nconst int MAX_N = 110;\nlong long con[MAX_N][MAX_N][MAX_N];\nvector<long long> xpl, ypl, zpl;\n\nlong long merge(vector<pair<vector<long long>, vector<long long> > > rec) {\n    map<long long,int> xma, yma, zma;\n    xpl.clear(); ypl.clear(); zpl.clear();\n    for (int i = 0; i < rec.size(); ++i) {\n        long long x1 = rec[i].first[0], x2 = rec[i].second[0];\n        long long y1 = rec[i].first[1], y2 = rec[i].second[1];\n        long long z1 = rec[i].first[2], z2 = rec[i].second[2];\n        xma[x1]++; xma[x2]++; yma[y1]++; yma[y2]++; zma[z1]++; zma[z2]++;\n    }\n    int nx = 0;\n    for(map<long long,int>::iterator it = xma.begin(); it != xma.end(); ++it) {\n        it->second = nx++; xpl.push_back(it->first);\n    }\n    int ny = 0;\n    for(map<long long,int>::iterator it = yma.begin(); it != yma.end(); ++it) { \n        it->second = ny++; ypl.push_back(it->first);\n    }\n    int nz = 0;\n    for(map<long long,int>::iterator it = zma.begin(); it != zma.end(); ++it) { \n        it->second = nz++; zpl.push_back(it->first);\n    }\n    \n    memset(con, 0, sizeof(con));\n    for (int i = 0; i < rec.size(); ++i) {\n        int x1 = xma[rec[i].first[0]], x2 = xma[rec[i].second[0]];\n        int y1 = yma[rec[i].first[1]], y2 = yma[rec[i].second[1]];\n        int z1 = zma[rec[i].first[2]], z2 = zma[rec[i].second[2]];\n        con[x1][y1][z1]++; con[x1][y2][z1]--; con[x2][y1][z1]--; con[x2][y2][z1]++;\n        con[x1][y1][z2]--; con[x1][y2][z2]++; con[x2][y1][z2]++; con[x2][y2][z2]--;\n    }\n    for (int i = 0; i < nx; ++i) for (int j = 0; j < ny; ++j) for (int k = 0; k < nz; ++k)\n        con[i+1][j][k] += con[i][j][k];\n    for (int i = 0; i < nx; ++i) for (int j = 0; j < ny; ++j) for (int k = 0; k < nz; ++k) \n        con[i][j+1][k] += con[i][j][k];\n    for (int i = 0; i < nx; ++i) for (int j = 0; j < ny; ++j) for (int k = 0; k < nz; ++k) \n        con[i][j][k+1] += con[i][j][k];\n    \n    long long res = 0;\n    for (int i = 0; i < nx; ++i) for (int j = 0; j < ny; ++j) for (int k = 0; k < nz; ++k) if (con[i][j][k] >= K) \n        res += (xpl[i+1]-xpl[i]) * (ypl[j+1]-ypl[j]) * (zpl[k+1]-zpl[k]);\n    \n    return res;\n}\n\n\n\n\n\nint main() {\n    while (cin >> N >> K) {\n        vector<pair<vector<long long>, vector<long long> > > rec(N);\n        for (int i = 0; i < N; ++i) {\n            vector<long long> lo(3), hi(3);\n            cin >> lo[0] >> lo[1] >> lo[2] >> hi[0] >> hi[1] >> hi[2];\n            rec[i] = MP(lo, hi);\n        }\n        long long res = merge(rec);\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\n\nint N,K;\nint W,H,D;\nint X1[55],Y1[55],Z1[55],X2[55],Y2[55],Z2[55];\nint cx1[55],cy1[55],cz1[55],cx2[55],cy2[55],cz2[55];\nvector<int> X,Y,Z;\nint fld[55*6][55*6][55*6];\n\nint ans;\nvector<int> xs;\n\nvoid compress(vector<int> &X,int* x1,int* x2,int* vx1,int* vx2,int w,int* P){\n    xs.clear();\n    for(int i=0;i<N;++i){\n        x1[i]=vx1[i];\n        x2[i]=vx2[i];\n    }\n    for(int i=0;i<N;++i){\n        for(int d=-1;d<=1;++d){\n            int tx1=x1[i]+d;\n            int tx2=x2[i]+d;\n            if(0<=tx1&&tx1<=w)xs.PB(tx1);\n            if(0<=tx2&&tx2<=w)xs.PB(tx2);\n        }\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    //for(int i=0;i<xs.size();++i)cout<<xs[i]<<endl;\n    for(int i=0;i<xs.size();++i){\n        X.PB(xs[i+1]-xs[i]);\n    }\n    *P = xs.size();\n}\n\nsigned main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    compress(X,cx1,cx2,X1,X2,1000000,&W);\n    compress(Y,cy1,cy2,Y1,Y2,1000000,&H);\n    compress(Z,cz1,cz2,Z1,Z2,1000000,&D);\n    for(int i=0;i<N;++i){\n        for(int z=cz1[i];z<cz2[i];++z){\n            for(int y=cy1[i];y<cy2[i];++y){\n                for(int x=cx1[i];x<cx2[i];++x){\n                    fld[z][y][x]++;\n                }\n            }\n        }\n    }\n    for(int z=0;z<=D;++z){\n        for(int y=0;y<=H;++y){\n            for(int x=0;x<=W;++x){\n                if(fld[z][y][x]>=K)ans+=X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n\n    //cout<<W<<\" \"<<H<<\" \"<<D<<endl;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#define INF 10000000\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define all(n) n.begin(),n.end()\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> PII;\n\nconst int MAX_N = 51;\n\nint X1[MAX_N], X2[MAX_N], Y1[MAX_N], Y2[MAX_N], Z1[MAX_N], Z2[MAX_N];\nint fld[2*MAX_N][2*MAX_N][2*MAX_N];\nint n, k;\nll res = 0;\nvector<int> xs, ys, zs;\n\nint main(void){\n\tcin >> n >> k;\n\n\tREP(i, 2*MAX_N) REP(j, 2*MAX_N) REP(k, 2*MAX_N) fld[i][j][k] = 0;\n\n\tREP(i, n){\n\t\tcin >> X1[i] >> Y1[i] >> Z1[i] >> X2[i] >> Y2[i] >> Z2[i];\n\t\txs.push_back(X1[i]);\n\t\txs.push_back(X2[i]);\n\t\tys.push_back(Y1[i]);\n\t\tys.push_back(Y2[i]);\n\t\tzs.push_back(Z1[i]);\n\t\tzs.push_back(Z2[i]);\n\t}\n\tsort(all(xs));\n\tsort(all(ys));\n\tsort(all(zs));\n\txs.erase(unique(all(xs)), xs.end());\n\tys.erase(unique(all(ys)), ys.end());\n\tzs.erase(unique(all(zs)), zs.end());\n\tREP(i, n){\n\t\tX1[i] = find(all(xs), X1[i])-xs.begin();\n\t\tX2[i] = find(all(xs), X2[i])-xs.begin();\n\t\tY1[i] = find(all(ys), Y1[i])-ys.begin();\n\t\tY2[i] = find(all(ys), Y2[i])-ys.begin();\n\t\tZ1[i] = find(all(zs), Z1[i])-zs.begin();\n\t\tZ2[i] = find(all(zs), Z2[i])-zs.begin();\n\t}\n\n\tREP(i, n){\n\t\tfor(int x = X1[i];x < X2[i];x++){\n\t\t\tfor(int y = Y1[i];y < Y2[i];y++){\n\t\t\t\tfor(int z = Z1[i];z < Z2[i];z++){\n\t\t\t\t\tfld[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(x, xs.size()){\n\t\tREP(y, ys.size()){\n\t\t\tREP(z, zs.size()){\n\t\t\t\tif(fld[x][y][z] >= k){\n\t\t\t\t\tres += ll(xs[x+1]-xs[x])*ll(ys[y+1]-ys[y])*ll(zs[z+1]-zs[z]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n// #include <ctime>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(){\n\tull v = 0;\n\tconst int MAX_N = 50;\n\tint N, K;\n\tint X1[MAX_N], Y1[MAX_N], D1[MAX_N], X2[MAX_N], Y2[MAX_N], D2[MAX_N];\n\n\tcin >> N >> K;\n\n\tvector<int> X(2 * N), Y(2 * N), D(2 * N);\n\n\tfor (int i = 0; i<N; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t\tX[i]     = X1[i];\n\t\tX[i + N] = X2[i];\n\t\tY[i]     = Y1[i];\n\t\tY[i + N] = Y2[i];\n\t\tD[i]     = Y1[i];\n\t\tD[i + N] = Y2[i];\n\t}\n//\tclock_t st = clock();\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\tfor (int i = 0, n = 2*N - 1; i<n; i++){\n\tfor (int j = 0; j<n; j++){\n\tfor (int k = 0; k<n; k++){\n\t\tint kind = 0;\n\t\tfor (int l = 0; l < N; l++){\n\t\t\tif (X1[l] <= X[i] && X[i+1] <= X2[l] && Y1[l] <= Y[j] && Y[j+1] <= Y2[l] && D1[l] <= D[k] && D[k+1] <= D2[l]) kind++;\n\t\t}\n\t\tif (kind >= K) v += (ull)(X[i+1] - X[i]) * (Y[j+1] - Y[j]) * (D[k+1] - D[k]);\n\t}\n\t}\n\t}\n\n\tcout << v << endl;\n//\tclock_t ed = clock();\n//\tcout << (double)(ed - st) / CLOCKS_PER_SEC << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nVL xx, x, unzipx(100010), yy, y, unzipy(100010), zz, z, unzipz(100010);\nunordered_map<int, int> zipx, zipy, zipz;\nvoid compress() {\n  x = xx;\n  sort(ALL(xx));\n  xx.erase(unique(ALL(xx)), xx.end());\n  REP(i, xx.size()) {zipx[xx[i]] = i; unzipx[i] = xx[i];}\n  REP(i, x.size()) x[i] = zipx[x[i]];\n  y = yy;\n  sort(ALL(yy));\n  yy.erase(unique(ALL(yy)), yy.end());\n  REP(i, yy.size()) {zipy[yy[i]] = i; unzipy[i] = yy[i];}\n  REP(i, y.size()) y[i] = zipy[y[i]];\n  z = zz;\n  sort(ALL(zz));\n  zz.erase(unique(ALL(zz)), zz.end());\n  REP(i, zz.size()) {zipz[zz[i]] = i; unzipz[i] = zz[i];}\n  REP(i, z.size()) z[i] = zipz[z[i]];\n}\n\nint dp[105][105][105];\nint sx[55], sy[55], sd[55], gx[55], gy[55], gd[55];\nsigned main(void)\n{\n  int n, K;\n  cin >> n >> K;\n  REP(i, n) {\n    cin >> sx[i] >> sy[i] >> sd[i] >> gx[i] >> gy[i] >> gd[i];\n    xx.PB(sx[i]); xx.PB(gx[i]);\n    yy.PB(sy[i]); yy.PB(gy[i]);\n    zz.PB(sd[i]); zz.PB(gd[i]);\n  }\n  compress();\n\n  // cout << \"a\" << endl;\n  // REP(i, n) {\n  //   cout << zipx[sx[i]] << \" \" << zipy[sy[i]] << \" \" << zipz[sd[i]] << \" \" << zipx[gx[i]] << \" \" << zipy[gy[i]] << \" \" << zipz[gd[i]] << endl;\n  // }\n\n  REP(i, n) {\n    // cout << i << endl;\n    // cout << zipx[sx[i]] << \" \" << zipy[sy[i]] << \" \" << zipz[sd[i]] << \" \" << zipx[gx[i]] << \" \" << zipy[gy[i]] << \" \" << zipz[gd[i]] << endl;\n    FOR(z, zipz[sd[i]], zipz[gd[i]]) FOR(y, zipy[sy[i]], zipy[gy[i]]) FOR(x, zipx[sx[i]], zipx[gx[i]]) {\n      dp[z][y][x]++;\n    }\n    // REP(ii, z.size()) {\n    //   cout << \"z:\" << ii << endl;\n    //   REP(j, y.size()) {\n    //     REP(k, x.size()) {\n    //       cout << dp[ii][j][k] << \" \";\n    //     }\n    //     cout << endl;\n    //   }\n    // }\n    // cout << endl;\n  }\n\n  // cout << \"b\" << endl;\n\n  ll ret = 0;\n  REP(i, z.size()) REP(j, y.size()) REP(k, x.size()) {\n    if(dp[i][j][k] >= K) {\n      ret += (unzipz[i+1]-unzipz[i])*(unzipy[j+1]-unzipy[j])*(unzipx[k+1]-unzipx[k]);\n    }\n  }\n\n  cout << ret << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\ntypedef long LONG;\n\nLONG zip[3][200];\nint M[3];\n\nLONG a[50][6];\nint N, K;\n\nint O[200][200][200];\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &N, &K), N + K){\t\n\t\tmemset(zip, -1, sizeof(zip));\n\t\tmemset(M, 0, sizeof(M));\n\t\tmemset(a, 0, sizeof(a));\n\t\tmemset(O, 0, sizeof(O));\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < 6; j++){\n\t\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\t\t\n\t\t\t\tbool f = true;\n\t\t\t\tfor (int k = 0; k < M[j % 3]; k++){\n\t\t\t\t\tif (zip[j % 3][k] == a[i][j]){\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (f){\n\t\t\t\t\tzip[j % 3][M[j % 3]] = a[i][j];\n\t\t\t\t\tM[j % 3]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tsort(zip[i], zip[i] + M[i]);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < 6; j++){\n\t\t\t\tint l = 0;\n\t\t\t\tint r = M[j % 3] - 1;\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\t\n\t\t\t\twhile (zip[j % 3][m] != a[i][j]){\n\t\t\t\t\tif (zip[j % 3][m] < a[i][j]){\n\t\t\t\t\t\tl = m + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tr = m - 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tm = (l + r) / 2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ta[i][j] = m;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int x = a[i][0]; x < a[i][3]; x++){\n\t\t\t\tfor (int y = a[i][1]; y < a[i][4]; y++){\n\t\t\t\t\tfor (int z = a[i][2]; z < a[i][5]; z++){\n\t\t\t\t\t\tO[x][y][z]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLONG sum = 0;\n\t\t\n\t\tfor (int x = 0; x < 200; x++){\n\t\t\tfor (int y = 0; y < 200; y++){\n\t\t\t\tfor (int z = 0; z < 200; z++){\n\t\t\t\t\tif (O[x][y][z] >= K){\n\t\t\t\t\t\tsum = sum + (zip[0][x + 1] - zip[0][x]) * \n\t\t\t\t\t\t            (zip[1][y + 1] - zip[1][y])\t*\n\t\t\t\t\t\t\t\t\t(zip[2][z + 1] - zip[2][z]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%ld\\n\", sum);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint coun[105][105][105];\nvector<int>x,y,z;\nint rx[52][2], ry[52][2], rz[52][2];\nint a[52],b[52],c[52],d[52],e[52],f[52];\nint n,m;\n\nint compress1(){\n\tfor(int i = 0;i < n;i++){\n\t\tx.push_back(a[i]);\n\t\tx.push_back(d[i]);\n\t}\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tfor(int i = 0;i < n;i++){\n\t\trx[i][0] = find(x.begin(),x.end(),a[i])-x.begin();\n\t\trx[i][1] = find(x.begin(),x.end(),d[i])-x.begin();\n\t}\n\treturn x.size();\n}\n\nint compress2(){\n\tfor(int i = 0;i < n;i++){\n\t\ty.push_back(b[i]);\n\t\ty.push_back(e[i]);\n\t}\n\tsort(y.begin(), y.end());\n\ty.erase(unique(y.begin(), y.end()), y.end());\n\tfor(int i = 0;i < n;i++){\n\t\try[i][0] = find(y.begin(),y.end(),b[i])-y.begin();\n\t\try[i][1] = find(y.begin(),y.end(),e[i])-y.begin();\n\t}\n\treturn y.size();\n}\n\nint compress3(){\n\tfor(int i = 0;i < n;i++){\n\t\tz.push_back(c[i]);\n\t\tz.push_back(f[i]);\n\t}\n\tsort(z.begin(), z.end());\n\tz.erase(unique(z.begin(), z.end()), z.end());\n\tfor(int i = 0;i < n;i++){\n\t\trz[i][0] = find(z.begin(),z.end(),c[i])-z.begin();\n\t\trz[i][1] = find(z.begin(),z.end(),f[i])-z.begin();\n\t}\n\treturn z.size();\n}\n\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d %d %d %d %d\",&a[i],&b[i],&c[i],&d[i],&e[i],&f[i]);\n\t}\n\tint w = compress1();\n\tint h = compress2();\n\tint d = compress3();\n\tfor(int i = 0;i < n;i++){\n\tfor(int tx=rx[i][0];tx<rx[i][1];tx++)\n    {\n      for(int ty=ry[i][0];ty<ry[i][1];ty++)\n        {\n          for(int tz=rz[i][0];tz<rz[i][1];tz++)\n        {\n          coun[tx][ty][tz]++;\n        }\n        }\n    }\n\t}\n  long long ans=0;\n  for(int i=0;i<=w;i++)\n    {\n      for(int j=0;j<=h;j++)\n    {\n      for(int k=0;k<=d;k++)\n        {\n          if(coun[i][j][k]>=m)\n        {\n          long long s1=(x[i+1]-x[i]),s2=(y[j+1]-y[j]),s3=(z[k+1]-z[k]);\n          ans+=s1*s2*s3;\n        }\n        }\n    }\n    }\n\t//long long ans = 0;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Fish\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct Point {\n    int x, y, d;\n    Point() {}\n    Point(int x, int y, int d): x(x), y(y), d(d) {}\n};\n\nstruct Rectangle {\n    Point p1, p2;\n    Rectangle() {}\n    Rectangle(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\nint main() {\n    int N, K;\n    vector<ll> X, Y, D;\n    cin >> N >> K;\n    Rectangle R[N];\n    int x1, y1, d1, x2, y2, d2;\n    for(int i = 0; i < N; i++) {\n        cin >> x1 >> y1 >> d1 >> x2 >> y2 >> d2;\n        R[i] = Rectangle(Point(x1, y1, d1), Point(x2, y2, d2));\n        X.push_back(x1); X.push_back(x2);\n        Y.push_back(y1); Y.push_back(y2);\n        D.push_back(d1); D.push_back(d2);\n    }\n\n    sort(X.begin(), X.end());\n    sort(Y.begin(), Y.end());\n    sort(D.begin(), D.end());\n    X.erase(unique(X.begin(), X.end()), X.end());\n    Y.erase(unique(Y.begin(), Y.end()), Y.end());\n    D.erase(unique(D.begin(), D.end()), D.end());\n    int G[X.size() - 1][Y.size() - 1][D.size() - 1];\n    if(X.size() == 1 || Y.size() == 1 || D.size() == 1) {\n        cout << 0 << endl;\n    } else {\n        for(int i = 0; i < X.size() - 1; i++) {\n            for(int j = 0; j < Y.size() - 1; j++) {\n                for(int k = 0; k < D.size() - 1; k++) {\n                    G[i][j][k] = 0;\n                }\n            }\n        }\n        for(int n = 0; n < N; n++) {\n            for(int i = int(distance(X.begin(), lower_bound(X.begin(), X.end(), R[n].p1.x))); i < int(distance(X.begin(), upper_bound(X.begin(), X.end(), R[n].p2.x))) - 1; i++) {\n                for(int j = int(distance(Y.begin(), lower_bound(Y.begin(), Y.end(), R[n].p1.y))); j < int(distance(Y.begin(), upper_bound(Y.begin(), Y.end(), R[n].p2.y))) - 1; j++) {\n                    for(int k = int(distance(D.begin(), lower_bound(D.begin(), D.end(), R[n].p1.d))); k < int(distance(D.begin(), upper_bound(D.begin(), D.end(), R[n].p2.d))) - 1; k++) {\n                        G[i][j][k]++;\n                    }\n                }\n            }\n        }\n        ll v = 0;\n        for(int i = 0; i < X.size() - 1; i++) {\n            for(int j = 0; j < Y.size() - 1; j++) {\n                for(int k = 0; k < D.size() - 1; k++) {\n                    if(G[i][j][k] >= K) {\n                        v += (X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) * (D[k + 1] - D[k]);\n                    }\n                }\n            }\n        }\n        cout << v << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef long long ll;\n\nll n, K;\nvector<ll> unzipx, unzipy, unzipz;\nint x, y, z;\nvector<ll>  bx, by, bz, ex, ey, ez;\nint sum[55][55][55];\n\nint press(vector<ll>& v1, vector<ll>& v2,vector<ll>& unzip) {\n\tauto t1 = v1, t2 = v2;\n\tt1.insert(t1.end(), t2.begin(), t2.end());\n\tsort(t1.begin(), t1.end());\n\tt1.erase(unique(t1.begin(), t1.end()), t1.end());\n\tfor (int i = 0; i < v1.size(); i++) {\n\t\tll tmp = lower_bound(t1.begin(), t1.end(), v1[i]) - t1.begin();\n\t\tunzip[tmp] = v1[i];\n\t\tv1[i] = tmp;\n\t}\n\tfor (int i = 0; i < v2.size(); i++) {\n\t\tll tmp = lower_bound(t1.begin(), t1.end(), v2[i]) - t1.begin();\n\t\tunzip[tmp] = v2[i];\n\t\tv2[i] = tmp;\n\t}\n\t\n\treturn t1.size();\n}\n\nint main() {\n\tunzipx.resize(55), unzipy.resize(55), unzipz.resize(55);\n\tcin >> n >> K;\n\tfor (int i = 0; i < n; i++) {\n\t\tll a, b, c, d, e, f;\n\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\tbx.push_back(a), by.push_back(b), bz.push_back(c);\n\t\tex.push_back(d), ey.push_back(e), ez.push_back(f);\n\t}\n\tx = press(bx, ex, unzipx), y = press(by, ey, unzipy), z = press(bz, ez, unzipz);\n\t// ?´?????????????\n\tll ans = 0;\n\tfor (int i = 0; i < bx.size(); i++) {\n\t\tfor (int j = bx[i]; j < ex[i]; j++) {\n\t\t\tfor (int k = by[i]; k < ey[i]; k++) {\n\t\t\t\tfor (int l = bz[i]; l < ez[i]; l++) {\n\t\t\t\t\tsum[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < x - 1; i++) {\n\t\tfor (int j = 0; j < y - 1; j++) {\n\t\t\tfor (int k = 0; k < z - 1; k++) {\n\t\t\t\tif (sum[i][j][k] >= K) {\n\t\t\t\t\tans += ((unzipx[i + 1] - unzipx[i]) * (unzipy[j + 1] - unzipy[j]) * (unzipz[k + 1] - unzipz[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nvector<long long> sp[3];\nint N, K;\nint input[50][6];\n\nint cnt[100][100][100];\n\nint main()\n{\n  cin >> N >> K;\n  for(int i = 0; i < N; i++)\n  {\n    int x1, y1, z1, x2, y2, z2;\n    cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n    sp[0].push_back(x1);\n    sp[0].push_back(x2);\n    sp[1].push_back(y1);\n    sp[1].push_back(y2);\n    sp[2].push_back(z1);\n    sp[2].push_back(z2);\n    input[i][0] = x1;\n    input[i][1] = y1;\n    input[i][2] = z1;\n    input[i][3] = x2;\n    input[i][4] = y2;\n    input[i][5] = z2;\n  }\n  for(int i = 0; i < 3; i++)\n  {\n    sort(sp[i].begin(), sp[i].end());\n    unique(sp[i].begin(), sp[i].end());\n  }\n  for(int i = 0; i < N; i++)\n  {\n    auto x1 = distance(sp[0].begin(), lower_bound(sp[0].begin(), sp[0].end(), input[i][0]));\n    auto y1 = distance(sp[1].begin(), lower_bound(sp[1].begin(), sp[1].end(), input[i][1]));\n    auto z1 = distance(sp[2].begin(), lower_bound(sp[2].begin(), sp[2].end(), input[i][2]));\n    auto x2 = distance(sp[0].begin(), lower_bound(sp[0].begin(), sp[0].end(), input[i][3]));\n    auto y2 = distance(sp[1].begin(), lower_bound(sp[1].begin(), sp[1].end(), input[i][4]));\n    auto z2 = distance(sp[2].begin(), lower_bound(sp[2].begin(), sp[2].end(), input[i][5]));\n    for(int x = x1; x < x2; x++)\n      for(int y = y1; y < y2; y++)\n        for(int z = z1; z < z2; z++)\n          cnt[x][y][z]++;\n  }\n  long long area = 0;\n  for(int x = 0; x < 100; x++)\n    for(int y = 0; y < 100; y++)\n      for(int z = 0; z < 100; z++)\n        if(cnt[x][y][z] >= K)\n          area += (sp[0][x + 1] - sp[0][x]) * (sp[1][y + 1] - sp[1][y]) * (sp[2][z + 1] - sp[2][z]);\n  cout << area << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef long long lli;\nconst int MAX = 300;\nint a[MAX][MAX][MAX];\n\nint main(){\n  int n,m;\n  while(cin >> n >> m){\n    lli v[50][6], ans = 0;\n    vector<lli> v2;\n    set<lli> s;\n    map<lli,int> v3;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<6;j++){\n        cin >> v[i][j];\n        s.insert(v[i][j]);\n      }\n    }\n\n    for(int i=0;i<MAX;i++) for(int j=0;j<MAX;j++) for(int k=0;k<MAX;k++) a[i][j][k] = 0;\n    for(set<lli>::iterator it = s.begin(); it != s.end(); it++){\n      v2.push_back(*it);\n      v3[*it] = v2.size()-1;\n    }\n\n    for(int i=0;i<n;i++)\n      for(int j=v3[v[i][0]];j<v3[v[i][3]];j++)\n        for(int k=v3[v[i][1]];k<v3[v[i][4]];k++)\n          for(int l=v3[v[i][2]];l<v3[v[i][5]];l++)\n            a[j][k][l]++;\n\n    for(int i=0;i<MAX-1;i++)\n      for(int j=0;j<MAX-1;j++)\n        for(int k=0;k<MAX-1;k++)\n          if(a[i][j][k] >= m)\n            ans += (v2[i+1]-v2[i]) * (v2[j+1]-v2[j]) * (v2[k+1]-v2[k]);\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v)) os<<*i<<(i==end(v)-1?\"\":\"\\n\"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n    is>>p.first>>p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b) {if(a<b) {a=b;return 1;} return 0;}\ntemplate<class T>bool chmin(T &a,const T &b) {if(b<a) {a=b;return 1;} return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nint sum[105][105][105];\nsigned main() {\n    int n,K;\n    cin>>n>>K;\n    vector<vector<int>> p(n);\n    map<int,int> idx_x,idx_y,idx_z;\n    map<int,int> xdi_x,xdi_y,xdi_z;\n    REP(i,n) {\n        int x1,y1,z1,x2,y2,z2;\n        cin>>x1>>y1>>z1>>x2>>y2>>z2;\n        p[i]={x1,y1,z1,x2,y2,z2};\n        idx_x[x1]=idx_x[x2]=idx_y[y1]=idx_y[y2]=idx_z[z1]=idx_z[z2]=0;\n    }\n    int cnt=0;\n    FORE(x,idx_x) x.second=cnt++, xdi_x[x.second]=x.first;\n    cnt=0;\n    FORE(y,idx_y) y.second=cnt++, xdi_y[y.second]=y.first;\n    cnt=0;\n    FORE(z,idx_z) z.second=cnt++, xdi_z[z.second]=z.first;\n\n    REP(i,n) {\n        int x1=idx_x[p[i][0]];\n        int y1=idx_y[p[i][1]];\n        int z1=idx_z[p[i][2]];\n        int x2=idx_x[p[i][3]];\n        int y2=idx_y[p[i][4]];\n        int z2=idx_z[p[i][5]];\n        sum[x1][y1][z1]++;\n        sum[x2+1][y1][z1]--;\n        sum[x1][y2+1][z1]--;\n        sum[x2+1][y2+1][z1]++;\n        sum[x1][y1][z2+1]--;\n        sum[x2+1][y1][z2+1]++;\n        sum[x1][y2+1][z2+1]++;\n        sum[x2+1][y2+1][z2+1]--;\n    }\n    REP(j,105) REP(k,105) REP(i,104) sum[i+1][j][k]+=sum[i][j][k];\n    REP(i,105) REP(k,105) REP(j,104) sum[i][j+1][k]+=sum[i][j][k];\n    REP(i,105) REP(j,105) REP(k,104) sum[i][j][k+1]+=sum[i][j][k];\n\n    int ans=0;\n    REP(i,104) {\n        REP(j,104) {\n            REP(k,104) {\n                if(sum[i][j][k]>=K &&\n                  sum[i+1][j][k]>=K &&\n                  sum[i][j+1][k]>=K &&\n                  sum[i][j][k+1]>=K &&\n                  sum[i+1][j+1][k]>=K &&\n                  sum[i+1][j][k+1]>=K &&\n                  sum[i][j+1][k+1]>=K &&\n                  sum[i+1][j+1][k+1]>=K) {\n                    if(!CONTAIN(xdi_x,i+1) || !CONTAIN(xdi_y,j+1) || !CONTAIN(xdi_z,k+1)) continue;\n                    ans+=(xdi_x[i+1]-xdi_x[i])*(xdi_y[j+1]-xdi_y[j])*(xdi_z[k+1]-xdi_z[k]);\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint q[20000][7],p[6],qtop;\nbool ICV(int c[],int d[]){\n\tbool ret=true;\n\tfor(int i=0;i<3;i++){\n\t\tif(d[i]<c[i+3]&&d[i+3]>c[i])p[i]=max(c[i],d[i]),p[i+3]=min(c[i+3],d[i+3]);\n\t\telse ret=false;\n\t}\n\treturn ret;\n}\nint main(){\n\tint n,e;\n\tcin>>n>>e;\n\tqtop=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<6;j++)cin>>q[qtop][j];\n\t\tq[qtop][6]=1;\n\t\tint keep=qtop;\n\t\tqtop++;\n\t\tfor(int j=0;j<keep;j++){\n\t\t\tif(ICV(q[keep],q[j])){\n\t\t\t\tfor(int k=0;k<6;k++)q[qtop][k]=p[k];\n\t\t\t\tq[qtop][6]=q[j][6]+1;\n\t\t\t\tqtop++;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans[60]={0};\n\tfor(int i=55;i>0;i--){\n\tfor(int j=0;j<qtop;j++){\n\t\tif(q[j][6]==i){\n\t\tlong long v[3]={q[j][3]-q[j][0],q[j][4]-q[j][1],q[j][5]-q[j][2]};\n\t\tans[q[j][6]]+=v[0]*v[1]*v[2];\n\t\t}\n\t}\n\tans[i-1]-=ans[i]*(i-1);\n\t}\n\tcout<<ans[e]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n\tint N, K;\n\tcin >> N >> K;\n\tvector<int> xs, ys, zs;\n\tmap<int, int> xp, yp, zp;\n\tint x1[60], x2[60], y1[60], y2[60], z1[60], z2[60], xm[110], ym[110], zm[110];\n\tll ans = 0;\n\tfor(int i = 0; i < N; ++i){\n\t\tscanf(\"%d%d%d%d%d%d\", &x1[i], &y1[i], &z1[i], &x2[i], &y2[i], &z2[i]);\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t\tys.push_back(y1[i]);\n\t\tys.push_back(y2[i]);\n\t\tzs.push_back(z1[i]);\n\t\tzs.push_back(z2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\tsort(zs.begin(), zs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tys.erase(unique(ys.begin(), ys.end()), ys.end());\n\tzs.erase(unique(zs.begin(), zs.end()), zs.end());\n\t\n\tfor(int i = 0; i < 2 * N; ++i){\n\t\tif(xs.size() > i){\n\t\t\txm[i] = xs[i];\n\t\t\txp[xs[i]] = i;\n\t\t}\n\t\tif(ys.size() > i){\n\t\t\tym[i] = ys[i];\n\t\t\typ[ys[i]] = i;\n\t\t}\n\t\tif(zs.size() > i){\n\t\t\tzm[i] = zs[i];\n\t\t\tzp[zs[i]] = i;\n\t\t}\n\t}\n\tint cnt[110][110][110] = {0};\n\tfor(int i = 0; i < N; ++i)\n\t\tfor(int j = xp[x1[i]]; j < xp[x2[i]]; ++j)\n\t\t\tfor(int k = yp[y1[i]]; k < yp[y2[i]]; ++k)\n\t\t\t\tfor(int l = zp[z1[i]]; l < zp[z2[i]]; ++l)\n\t\t\t\t\tcnt[j][k][l]++;\n\t\t\t\t\t\n\tfor(int i = 0; i < xs.size() - 1; ++i)\n\t\tfor(int j = 0; j < ys.size() - 1; ++j)\n\t\t\tfor(int k = 0; k < zs.size() - 1; ++k)\n\t\t\t\tif(cnt[i][j][k] >= K)\n\t\t\t\t\tans += ((ll)(xm[i + 1] - xm[i]) * (ll)(ym[j + 1] - ym[j]) * (zm[k + 1] - zm[k]));\n\t\n\tcout << ans << endl;\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <complex>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FORE(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\nusing namespace std;\ntypedef long long ll;\ntypedef map<ll,ll> mi;\ntypedef vector<ll> vi;\nmi open[3],close[3];\nll fish[50][2][3];\nbool search(int x,int y,int z,int l){\n\tint num[3]={x,y,z};\n\tnum[0]=x;\n\tnum[1]=y;\n\tnum[2]=z;\n\tREP(i,3){\n\t\tif(fish[l][0][i]<=num[i] && fish[l][1][i]>=num[i]+1)\n\t\tcontinue;\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n\tll N,K;\n\tvi points[3];\n\tcin >> N >> K;\n\tREP(i,N)\n\t\tREP(j,2)\n\t\t\tREP(k,3){\n\t\t\t\tcin >> fish[i][j][k];\n\t\t\t\tpoints[k].push_back(fish[i][j][k]);\n\t\t\t}\n\tREP(i,3){\n\tpoints[i].push_back(0);\n\tsort(points[i].begin(),points[i].end());\n\tint count =0;\n\tREP(j,(int)points[i].size())\n\t\tif(j==1 || points[i][j]!=points[i][j-1]){\n\t\t\topen[i].insert(mi::value_type(count,points[i][j]));\n\t\t\tclose[i].insert(mi::value_type(points[i][j],count));\n\t\t\tcount++;\n\t\t}\n\t}\n\tREP(i,N)\n\t\tREP(j,2)\n\t\t\tREP(k,3){\n\t\t\t\tfish[i][j][k]=close[k][fish[i][j][k]];\n\t\t\t\t\n\t\t}\n\tll sum=0;\n\tREP(i,open[0].size()-1)\n\t\tREP(j,open[1].size()-1)\n\t\t\tREP(k,open[2].size()-1){\n\t\t\t\tint count=0;\n\t\t\t\tREP(l,N)\n\t\t\t\tcount+=search(i,j,k,l);\n\t\t\t\tif(count>=K)\n\t\t\t\tsum+=(open[0][i+1]-open[0][i])*(open[1][j+1]-open[1][j])*(open[2][k+1]-open[2][k]);\n\t\t\t}\n\tcout << sum << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint coun[105][105][105];\nvector<int>x,y,z;\nint main()\n{\n  int n,m;\n  scanf(\"%d %d\",&n,&m);\n  int a[52],b[52],c[52],d[52],e[52],f[52];\n  for(int i=0;i<n;i++)\n    {\n      scanf(\"%d %d %d %d %d %d\",&a[i],&b[i],&c[i],&d[i],&e[i],&f[i]);\n       x.push_back(a[i]);\n       x.push_back(d[i]);\n       y.push_back(b[i]);\n       y.push_back(e[i]);\n       z.push_back(c[i]);\n       z.push_back(f[i]);\n    }\n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  sort(z.begin(),z.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n  z.erase(unique(z.begin(),z.end()),z.end());\n  for(int i=0;i<n;i++)\n    {\n      int r1=find(x.begin(),x.end(),a[i])-x.begin();\n      int r2=find(x.begin(),x.end(),d[i])-x.begin();\n      int r3=find(y.begin(),y.end(),b[i])-y.begin();\n      int r4=find(y.begin(),y.end(),e[i])-y.begin();\n      int r5=find(z.begin(),z.end(),c[i])-z.begin();\n      int r6=find(z.begin(),z.end(),f[i])-z.begin();\n      for(int i=r1;i<r2;i++)\n    {\n      for(int j=r3;j<r4;j++)\n        {\n          for(int k=r5;k<r6;k++)\n        {\n          coun[i][j][k]++;\n        }\n        }\n    }\n    }\n  long long ans=0;\n  for(int i=0;i<=100;i++)\n    {\n      for(int j=0;j<=100;j++)\n    {\n      for(int k=0;k<=100;k++)\n        {\n          if(coun[i][j][k]>=m)\n        {\n          long long s1=(x[i+1]-x[i]),s2=(y[j+1]-y[j]),s3=(z[k+1]-z[k]);\n          ans+=s1*s2*s3;\n        }\n        }\n    }\n    }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N, K;\n  cin>>N>>K;\n  int x1[50], y1[50], z1[50], x2[50], y2[50], z2[50];\n  vector<int> ax, ay, az;\n  REP(i, N){\n    cin>>x1[i]>>y1[i]>>z1[i]>>x2[i]>>y2[i]>>z2[i];\n    ax.push_back(x1[i]); ax.push_back(x2[i]);\n    ay.push_back(y1[i]); ay.push_back(y2[i]);\n    az.push_back(z1[i]); az.push_back(z2[i]);\n  }\n  sort(ax.begin(), ax.end());\n  ax.erase(unique(ax.begin(), ax.end()), ax.end());\n  sort(ay.begin(), ay.end());\n  ay.erase(unique(ay.begin(), ay.end()), ay.end());\n  sort(az.begin(), az.end());\n  az.erase(unique(az.begin(), az.end()), az.end());\n  ll ans = 0;\n  REP(i, ax.size() - 1)REP(j, ay.size() - 1)REP(k, az.size() - 1){\n    int cnt = 0;\n    REP(l, N){\n      if(ax[i] >= x1[l] && x2[l] >= ax[i + 1] &&\n         ay[j] >= y1[l] && y2[l] >= ay[j + 1] &&\n         az[k] >= z1[l] && z2[l] >= az[k + 1] ){\n        cnt++;\n      }\n    }\n    if(cnt >= K){\n      ans += (ll)(ax[i + 1] - ax[i]) * (ay[j + 1] - ay[j]) * (az[k + 1] - az[k]);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) Rep(i, 0, n)\n\ntemplate<class T> T read() {\n\tT t;\n\tcin >> t;\n\treturn t;\n}\n\nint main(){\n\tint n = read<int>(), k = read<int>();\n\tint x1[n], y1[n], z1[n], x2[n], y2[n], z2[n];\n\tset<int> xSet, ySet, zSet;\n\trep(i,n){\n\t\tx1[i]=read<int>();\n\t\ty1[i]=read<int>();\n\t\tz1[i]=read<int>();\n\t\tx2[i]=read<int>();\n\t\ty2[i]=read<int>();\n\t\tz2[i]=read<int>();\n\t\txSet.insert(x1[i]);\n\t\txSet.insert(x2[i]);\n\t\tySet.insert(y1[i]);\n\t\tySet.insert(y2[i]);\n\t\tzSet.insert(z1[i]);\n\t\tzSet.insert(z2[i]);\n\t}\n\tint xList[xSet.size()], yList[ySet.size()], zList[zSet.size()];\n\t// map<int, int> xMap, yMap, zMap;\n\tint i;\n\ti=0;\n\tfor(set<int>::iterator it = xSet.begin();it!=xSet.end();it++){\n\t\txList[i]=*it;\n\t\t// xMap[*it]=i;\n\t\ti++;\n\t}\n\ti=0;\n\tfor(set<int>::iterator it = ySet.begin();it!=ySet.end();it++){\n\t\tyList[i]=*it;\n\t\t// yMap[*it]=i;\n\t\ti++;\n\t}\n\ti=0;\n\tfor(set<int>::iterator it = zSet.begin();it!=zSet.end();it++){\n\t\tzList[i]=*it;\n\t\t// zMap[*it]=i;\n\t\ti++;\n\t}\n\tlong long ans = 0;\n\trep(x,xSet.size()-1){\n\t\trep(y,ySet.size()-1){\n\t\t\trep(z,zSet.size()-1){\n\t\t\t\t// printf(\"(%d, %d, %d)->(%d, %d, %d)\\n\",xList[x],yList[y],\n\t\t\t\t// \t\tzList[z],xList[x+1],yList[y+1],zList[z+1]);\n\t\t\t\tint count = 0;\n\t\t\t\trep(j,n){\n\t\t\t\t\t// printf(\"\\t%d (%d, %d, %d)->(%d, %d, %d)\",j,x1[j],y1[j],z1[j],x2[j],y2[j],z2[j]);\n\t\t\t\t\tif(x1[j] <= xList[x] && xList[x+1] <= x2[j] && \n\t\t\t\t\t\t\ty1[j] <= yList[y] && yList[y+1] <= y2[j] && \n\t\t\t\t\t\t\tz1[j] <= zList[z] && zList[z+1] <= z2[j]){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t// cout << \"\\to\";\n\t\t\t\t\t}\n\t\t\t\t\t// cout << endl;\n\t\t\t\t}\n\t\t\t\tif(count>=k){\n\t\t\t\t\tans += ((long long)xList[x+1]-xList[x])*(yList[y+1]-yList[y])*(zList[z+1]-zList[z]);\n\t\t\t\t}\n\t\t\t\t// cout << endl;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\n\nint N,K;\nint MAXW,MAXH,MAXD;\nint W=1e6,H=1e6,D=1e6;\nint X1[55],Y1[55],Z1[55],X2[55],Y2[55],Z2[55];\nint fld[55*6][55*6][55*6];\nint dx[] = {0,0,0,0,1,-1};\nint dy[] = {1,-1,0,0,0,0,};\nint dz[] = {0,0,0,0,1,-1};\nint ans;\nvector<int> xs;\n\n\nstruct P{\n    int x;\n    int y;\n    int z;\n    P(){}\n    P(int p1,int p2,int p3){\n        x=p1;\n        y=p2;\n        z=p3;\n    }\n};\n\n\nint compress(int* x1,int* x2,int w){\n    xs.clear();\n    for(int i=0;i<N;++i){\n        for(int d=-1;d<=1;++d){\n            int tx1=x1[i]+d;\n            int tx2=x2[i]+d;\n            if(0<=tx1&&tx1<w)xs.PB(tx1);\n            if(0<=tx2&&tx2<w)xs.PB(tx2);\n        }\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    return xs.size();\n}\n\nvoid bfs(int sx,int sy,int sz){\n    queue<P> que;\n    que.push(P(sx,sy,sz));\n    if(fld[sz][sy][sx]>=K)ans+=fld[sz][sy][sx];\n    fld[sz][sy][sx]=0;\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        int x = p.x;\n        int y = p.y;\n        int z = p.z;\n        for(int i=0;i<6;++i){\n            int nx=x+dx[i];\n            int ny=y+dy[i];\n            int nz=z+dz[i];\n            if(nx<0||nx>=W||ny<0||ny>=H||nz<0||nz>=D)continue;\n            if(fld[nz][ny][nx]==-1)continue;\n            que.push(P(nx,ny,nz));\n            if(fld[nz][ny][nx]>=K)ans+=fld[nz][ny][nx];\n            fld[nz][ny][nx]=-1;\n        }\n    }\n}\n\n\nsigned main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i){\n        cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n        MAXW=max(MAXW,X2[i]-X1[i]);\n        MAXH=max(MAXH,Y2[i]-Y1[i]);\n        MAXD=max(MAXD,Z2[i]-Z1[i]);\n    }\n    W = compress(X1,X2,W);\n    H = compress(Y1,Y2,H);\n    D = compress(Z1,Z2,D);\n    //cout<<W<<\" \"<<H<<\" \"<<D<<endl;\n    for(int i=0;i<N;++i){\n        for(int z=Z1[i];z<Z2[i];++z){\n            for(int y=Y1[i];y<Y2[i];++y){\n                for(int x=X1[i];x<X2[i];++x){\n                    fld[z][y][x]++;\n                }\n            }\n        }\n    }\n    for(int z=0;z<D;++z){\n        for(int y=0;y<H;++y){\n            for(int x=0;x<W;++x){\n                bfs(x,y,z);\n            }\n        }\n    }\n    //cout<<ans<<endl;\n    cout<<ans*MAXW/W*MAXH/H*MAXD/D<<endl;\n    memset(fld,0,sizeof(fld));\n    ans=0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\n\nint N,K;\nint W,H,D;\nint X1[55],Y1[55],Z1[55],X2[55],Y2[55],Z2[55];\nint cx1[55],cy1[55],cz1[55],cx2[55],cy2[55],cz2[55];\nvector<int> X,Y,Z;\nunsigned short fld[50*6][50*6][50*6];\n\nint ans;\nvector<int> xs;\n\nvoid compress(vector<int> &X,int* x1,int* x2,int* vx1,int* vx2,int w,int* P){\n    xs.clear();\n    for(int i=0;i<N;++i){\n        x1[i]=vx1[i];\n        x2[i]=vx2[i];\n    }\n    for(int i=0;i<N;++i){\n        for(int d=-1;d<=1;++d){\n            int tx1=x1[i]+d;\n            int tx2=x2[i]+d;\n            if(0<=tx1&&tx1<=w)xs.PB(tx1);\n            if(0<=tx2&&tx2<=w)xs.PB(tx2);\n        }\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    //for(int i=0;i<xs.size();++i)cout<<xs[i]<<endl;\n    for(int i=0;i<xs.size();++i){\n        X.PB(xs[i+1]-xs[i]);\n    }\n    *P = xs.size();\n}\n\nint main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    compress(X,cx1,cx2,X1,X2,1000000,&W);\n    compress(Y,cy1,cy2,Y1,Y2,1000000,&H);\n    compress(Z,cz1,cz2,Z1,Z2,1000000,&D);\n    for(int i=0;i<N;++i){\n        for(int z=cz1[i];z<cz2[i];++z){\n            for(int y=cy1[i];y<cy2[i];++y){\n                for(int x=cx1[i];x<cx2[i];++x){\n                    fld[z][y][x]++;\n                }\n            }\n        }\n    }\n    for(int z=0;z<=D;++z){\n        for(int y=0;y<=H;++y){\n            for(int x=0;x<=W;++x){\n                if(fld[z][y][x]>=K)ans+=X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n\n    //cout<<W<<\" \"<<H<<\" \"<<D<<endl;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nstruct fish {\n\tint lx, ly, lz;\n\tint rx, ry, rz;\n};\nstruct Compress {\n\tmap<int, int>mp;\n\tmap<int, int>revmp;\n\n\tCompress(vector<int>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < vs.size(); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\tCompress(const set<int>&vs) {\n\t\tint num = 0;\n\t\tfor (auto v : vs) {\n\t\t\tmp[v] = num;\n\t\t\trevmp[num] = v;\n\t\t\tnum++;\n\t\t}\n\t}\n};\nint pluss[101][101][101];\nint num[102][102][102];\nint main() {\n\tint N, K; cin >> N >> K;\n\tvector<fish>fs;\n\tvector<int>xs, ys, zs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint lx, ly, ld, rx, ry, rd; cin >> lx >> ly >> ld >> rx >> ry >> rd;\n\t\tfs.push_back(fish{lx, ly, ld, rx, ry, rd});\n\t\txs.push_back(lx); xs.push_back(rx);\n\t\tys.push_back(ly); ys.push_back(ry);\n\t\tzs.push_back(ld); zs.push_back(rd);\n\t}\n\tCompress cx(xs), cy(ys), cz(zs);\n\tfor (auto &f : fs) {\n\t\tf.lx = cx.mp[f.lx];\n\t\tf.rx = cx.mp[f.rx];\n\t\tf.ly = cy.mp[f.ly];\n\t\tf.ry = cy.mp[f.ry];\n\t\tf.lz = cz.mp[f.lz];\n\t\tf.rz = cz.mp[f.rz];\n\t}\n\tmemset(pluss, 0, sizeof(pluss));\n\tfor (auto f : fs) {\n\t\tpluss[f.lx][f.ly][f.lz]++;\n\t\tpluss[f.rx][f.ly][f.lz]--;\n\t\tpluss[f.lx][f.ry][f.lz]--;\n\t\tpluss[f.lx][f.lx][f.rz]--;\n\t\tpluss[f.rx][f.ry][f.lz]++;\n\t\tpluss[f.lx][f.ry][f.rz]++;\n\t\tpluss[f.rx][f.ly][f.rz]++;\n\t\tpluss[f.rx][f.ry][f.rz]--;\n\t}\n\tmemset(num, 0, sizeof(num));\n\tlong long int ans = 0;\n\tfor (int x = 1; x < 102; ++x) {\n\t\tfor (int y = 1; y < 102; ++y) {\n\t\t\tfor (int z = 1; z < 102; ++z) {\n\t\t\t\tnum[x][y][z] = pluss[x - 1][y - 1][z - 1]+ num[x][y][z - 1] + num[x][y - 1][z] +num[x - 1][y][z] - num[x - 1][y - 1][z] - num[x - 1][y][z - 1]- num[x][y - 1][z - 1] +num[x - 1][y - 1][z - 1];\n\t\t\t\tif (num[x][y][z] >= K) {\n\t\t\t\t\tif (cx.revmp.find(x) == cx.revmp.end())assert(false);\n\t\t\t\t\tif (cy.revmp.find(y) == cy.revmp.end())assert(false);\n\n\t\t\t\t\tif (cz.revmp.find(z) == cz.revmp.end())assert(false);\n\n\t\t\t\t\tlong long int dx = cx.revmp[x] - cx.revmp[x - 1];\n\t\t\t\t\tlong long int dy = cy.revmp[y] - cy. revmp[y - 1];\n\t\t\t\t\tlong long int dz = cz.revmp[z] - cz.revmp[z - 1];\n\t\t\t\t\tans += dx*dy*dz;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define MAX_N 55\n#define ll long long\n\nll N, K;\n\nint compress(vector<ll>& x1, vector<ll>& x2,vector<ll>& xs) {\n\tfor (int i = 0; i < N;i++) {\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor (int i = 0; i < N;i++) {\n\t\tx1[i] = find(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = find(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\treturn xs.size();\n}\n\nint main() {\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tcin >> N >> K;\n\tvector<ll> X1(N), X2(N), Y1(N), Y2(N), D1(N), D2(N);\n\tvector<ll> xs, ys, ds;\n\tfor (int i = 0; i < N;i++) {\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t}\n\tll X = compress(X1, X2, xs);\n\tll Y = compress(Y1, Y2, ys);\n\tll D = compress(D1, D2, ds);\n\n\tll ans = 0;\n\n\tvector<vector<vector<ll>>> m(X, vector<vector<ll>>(Y, vector<ll>(D, 0)));\n\tfor (int i = 0; i < N;i++) {\n\t\tfor (int x = X1[i] + 1; x <= X2[i]; x++) {\n\t\t\tfor (int y = Y1[i] + 1; y <= Y2[i]; y++) {\n\t\t\t\tfor (int d = D1[i] + 1; d <= D2[i]; d++) {\n\t\t\t\t\tm[x][y][d]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = 1; x < X; x++) {\n\t\tfor (int y = 1; y < Y;y++) {\n\t\t\tfor (int d = 1; d < D;d++) {\n\t\t\t\tif (m[x][y][d] >= K) {\n\t\t\t\t\tll a_x, a_y, a_d;\n\t\t\t\t\ta_x = xs[x] - xs[x - 1];\n\t\t\t\t\ta_y = ys[y] - ys[y - 1];\n\t\t\t\t\ta_d = ds[d] - ds[d - 1];\n\n\t\t\t\t\tans += a_x * a_y * a_d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nenum {X=0, Y=1, Z=2 };\n\nvoid main(){\n\tint K,N;\n\tint *data1[3], *data2[3];\t\n\t\n\n\tcin >> N >> K;\n\tfor(int x=0; x<3; x++){\n\t\tdata1[x] = new int[N];\n\t\tdata2[x] = new int[N];\n\t}\n\tfor(int n=0; n<N; n++){\n\t\tcin >> data1[X][n] >> data1[Y][n] >> data1[Z][n] >> data2[X][n] >> data2[Y][n] >> data2[Z][n];\n\t}\n\t\n\n\tmap<int, char> gridmap[3];\t\n\tint *gridstep[3];\t\n\tchar *grid;\t\n\tfor(int x=0; x<3; x++){\n\t\tfor(int n=0; n<N; n++){\n\t\t\tgridmap[x].insert(make_pair(data1[x][n], -1));\n\t\t\tgridmap[x].insert(make_pair(data2[x][n], -1));\n\t\t}\n\t}\n\tchar gridnum[3] = {0,0,0};\n\tfor(int x=0; x<3; x++){\n\t\tgridstep[x] = new int[gridmap[x].size()];\n\t\tfor(auto it = gridmap[x].begin(); it!=gridmap[x].end(); it++, gridnum[x]++){\n\t\t\tgridstep[x][gridnum[x]] = it->first;\n\t\t\tit->second = gridnum[x];\n\t\t}\n\t}\n\tint griddim = (gridnum[X]-1)*(gridnum[Y]-1)*(gridnum[Z]-1);\n\tgrid = new char[griddim];\n\tfor(int a=0; a<griddim; a++)grid[a] = 0;\n\n\n\tfor(int n=0; n<N; n++){\n\t\tint xyz1[3], xyz2[3];\n\t\tfor(int x=0; x< 3; x++){\n\t\t\txyz1[x] = gridmap[x].find(data1[x][n])->second;\n\t\t\txyz2[x] = gridmap[x].find(data2[x][n])->second;\n\t\t}\n\t\tfor(int xn=xyz1[X]; xn<xyz2[X]; xn++){\n\t\t\tfor(int yn=xyz1[Y]; yn<xyz2[Y]; yn++){\n\t\t\t\tfor(int zn=xyz1[Z]; zn<xyz2[Z]; zn++){\n\t\t\t\t\tgrid[zn + (gridnum[2]-1)*(yn + (gridnum[1]-1)*xn)]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tlong long value=0;\n\tfor(int xn=0; xn< gridnum[X]-1; xn++){\n\t\tfor(int yn=0; yn< gridnum[Y]-1; yn++){\n\t\t\tfor(int zn=0; zn< gridnum[Z]-1; zn++){\n\t\t\t\tif(grid[zn + (gridnum[2]-1)*(yn + (gridnum[1]-1)*xn)] >= K){\n\t\t\t\t\tvalue += (long long)(gridstep[X][xn+1] -gridstep[X][xn])*\n\t\t\t\t\t\t\t\t\t\t(gridstep[Y][yn+1] -gridstep[Y][yn])*\n\t\t\t\t\t\t\t\t\t\t(gridstep[Z][zn+1] -gridstep[Z][zn]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << value << endl;\n\n\n\tfor(int x=0; x<3; x++){\n\t\tdelete[] data1[x];\n\t\tdelete[] data2[x];\n\t\tdelete[] gridstep[x];\n\t}\n\tdelete[] grid;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct Box{\n\tint x1,y1,z1,x2,y2,z2;\n};\n\nvector<long long>X;\nvector<long long>Y;\nvector<long long>Z;\nvector<Box>data;\n\nbool che(Box B1,Box B2){\n\tbool re=true;\n\treturn (B1.x1<=B2.x1 && B1.x2>=B2.x2 \n\t\t && B1.y1<=B2.y1 && B1.y2>=B2.y2\n\t\t && B1.z1<=B2.z1 && B1.z2>=B2.z2);\n}\n\nint cou(int x,int y,int z){\n\tint x1=X[x],x2=X[x+1];\n\tint y1=Y[y],y2=Y[y+1];\n\tint z1=Z[z],z2=Z[z+1];\n\tBox B2=(Box){x1,y1,z1,x2,y2,z2};\n\tint re=0;\n\tfor(int i=0;i<data.size();i++){\n\t\tBox B1=data[i];\n\t\tif(che(B1,B2))re++;\n\t}\n\treturn re;\n}\nint main(){\n\tint n,k;\n\tcin>>n>>k;\n\tfor(int i=0;i<n;i++){\n\t\tBox tmp;\n\t\tcin>>tmp.x1>>tmp.y1>>tmp.z1>>tmp.x2>>tmp.y2>>tmp.z2;\n\t\t\n\t\tdata.push_back(tmp);\n\t\tX.push_back(tmp.x1);X.push_back(tmp.x2);\n\t\tY.push_back(tmp.y1);Y.push_back(tmp.y2);\n\t\tZ.push_back(tmp.z1);Z.push_back(tmp.z2);\n\t}\n\tsort(X.begin(),X.end());\n\tsort(Y.begin(),Y.end());\n\tsort(Z.begin(),Z.end());\n\tlong long ans=0;\n\tfor(int x=0;x<X.size()-1;x++){\n\t\tfor(int y=0;y<Y.size()-1;y++){\n\t\t\tfor(int z=0;z<Z.size()-1;z++){\n\t\t\t\tif(cou(x,y,z)>=k)ans+=(long long)((X[x+1]-X[x])*(Y[y+1]-Y[y])*(Z[z+1]-Z[z]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct square{\n  long long x1,y1,z1,x2,y2,z2;\n};\n\nvector<square> rippous;\nset<long long> xs, ys, zs;\nmap<long long, long long>transx, transy, transz;\nlong long field[300][300][300];\nlong long xx[300], yy[300], zz[300], K, n;\nlong long res;\nint main(){\n  cin >> n >> K;\n  for(long long i = 0;i < n;i++){\n    square tmp;\n    cin >> tmp.x1 >> tmp.y1 >> tmp.z1 >> tmp.x2 >> tmp.y2 >> tmp.z2;\n    rippous.push_back(tmp);\n    xs.insert(tmp.x1);xs.insert(tmp.x2);\n    ys.insert(tmp.y1);ys.insert(tmp.y2);\n    zs.insert(tmp.z1);zs.insert(tmp.z2);\n  }\n  long long tttt;\n  set<long long>::iterator it = xs.begin();\n  long long ii = 0;\n  while(it != xs.end()){\n    xx[ii] = *it;\n    transx[*it] = ii;\n    it++;\n    ii++;\n  }\n  ii = 0;\n  it = ys.begin();\n  while(it != ys.end()){\n    yy[ii] = *it;\n    transy[*it] = ii;\n    it++;\n    ii++;\n  }\n  ii = 0;\n  it = zs.begin();\n  while(it != zs.end()){\n    zz[ii] = *it;\n    transz[*it] = ii;\n    it++;\n    ii++;\n  }\n  for(long long i = 0;i < rippous.size();i++){\n    square tmp = rippous[i];\n    tmp.x1 = transx[tmp.x1];\n    tmp.x2 = transx[tmp.x2];\n    tmp.y1 = transy[tmp.y1];\n    tmp.y2 = transy[tmp.y2];\n    tmp.z1 = transz[tmp.z1];\n    tmp.z2 = transz[tmp.z2];\n    field[tmp.x1][tmp.y1][tmp.z1] ++;\n    field[tmp.x2][tmp.y1][tmp.z1] --;\n    field[tmp.x1][tmp.y2][tmp.z1] --;\n    field[tmp.x2][tmp.y2][tmp.z1] ++;\n    field[tmp.x1][tmp.y1][tmp.z2] --;\n    field[tmp.x2][tmp.y1][tmp.z2] ++;\n    field[tmp.x1][tmp.y2][tmp.z2] ++;\n    field[tmp.x2][tmp.y2][tmp.z2] --;\n  }\n  for(long long i = 1;i < xs.size();i++){\n    for(long long j = 0;j < ys.size();j++){\n      for(long long k = 0;k < zs.size();k++){\n\tfield[i][j][k] += field[i - 1][j][k];\n      }\n    }\n  }\n  for(long long i = 0;i < xs.size();i++){\n    for(long long j = 1;j < ys.size();j++){\n      for(long long k = 0;k < zs.size();k++){\n\tfield[i][j][k] += field[i][j - 1][k];\n      }\n    }\n  }\n  for(long long i = 0;i < xs.size();i++){\n    for(long long j = 1;j < ys.size();j++){\n      for(long long k = 0;k < zs.size();k++){\n\tfield[i][j][k] += field[i][j][k - 1];\n      }\n    }\n  }\n  for(long long i = 0;i < xs.size();i++){\n    for(long long j = 0;j < ys.size();j++){\n      for(long long k = 0;k < zs.size();k++){\n\tif(field[i][j][k] >= K) \n\t  res += (xx[i + 1] - xx[i]) * (yy[j + 1] - yy[j]) * (zz[k + 1] - zz[k]);\n      }\n    }\n  } \n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\n#define all(x) x.begin(),x.end()\nusing namespace std;\n\ntypedef long long ll;\n\nint N,K;\nll x1[110],y1[110],d1[110],x2[110],y2[110],d2[110];\nvector<ll> x,y,z;\nint num[110][110][110];\nint xl,xr,yl,yr,zl,zr;\n\nint main(){\n  cin >> N >> K;\n  rep(i,N){\n    cin >> x1[i] >> y1[i] >> d1[i] >> x2[i] >> y2[i] >> d2[i];\n    x.pb(x1[i]); x.pb(x2[i]);\n    y.pb(y1[i]); y.pb(y2[i]);\n    z.pb(d1[i]); z.pb(d2[i]);\n  }\n\n  sort(all(x)); sort(all(y)); sort(all(z));\n  x.erase(unique(all(x)),x.end());\n  y.erase(unique(all(y)),y.end());\n  z.erase(unique(all(z)),z.end());\n\n  rep(i,x.size())rep(j,y.size())rep(k,z.size())num[i][j][k] = 0;\n\n  rep(a,N){\n    xl = lower_bound(all(x),x1[a]) - x.begin();\n    xr = lower_bound(all(x),x2[a]) - x.begin();\n    yl = lower_bound(all(y),y1[a]) - y.begin();\n    yr = lower_bound(all(y),y2[a]) - y.begin();\n    zl = lower_bound(all(z),d1[a]) - z.begin();\n    zr = lower_bound(all(z),d2[a]) - z.begin();\n   \n    for(int i=xl;i<xr;i++)\n      for(int j=yl;j<yr;j++)\n\tfor(int k=zl;k<zr;k++)num[i][j][k]++;\n  }\n\n  ll ans = 0;\n  rep(i,x.size())rep(j,y.size())rep(k,z.size()){\n    if(num[i][j][k]>=K){\n      ans += (x[i+1]-x[i])*(y[j+1]-y[j])*(z[k+1]-z[k]);\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n \ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n\n#define F first\n#define S second\n\n\n\nint index(const vector<int>& v, int x)\n{\n    return lower_bound(all(v), x) - v.begin();\n}\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n\n    const int inf = ten(8);\n\n    vector<int> cx, cy, cz;\n    int x1[55], y1[55], z1[55], x2[55], y2[55], z2[55];\n    rep(i, n)\n    {\n        cin >> x1[i] >> y1[i] >> z1[i] >> x2[i] >> y2[i] >> z2[i];\n        cx.pb(x1[i]), cx.pb(x2[i]);\n        cy.pb(y1[i]), cy.pb(y2[i]);\n        cz.pb(z1[i]), cz.pb(z2[i]);\n    }\n    uniq(cx);\n    uniq(cy);\n    uniq(cz);\n\n    static int imos[111][111][111];\n    rep(i, n)\n    {\n        int cx1 = index(cx, x1[i]);\n        int cx2 = index(cx, x2[i]);\n        int cy1 = index(cy, y1[i]);\n        int cy2 = index(cy, y2[i]);\n        int cz1 = index(cz, z1[i]);\n        int cz2 = index(cz, z2[i]);\n\n        // xy, z1\n        ++imos[cz1][cy1][cx1], --imos[cz1][cy1][cx2];\n        --imos[cz1][cy2][cx1], ++imos[cz1][cy2][cx2];\n\n        // xy, z2\n        --imos[cz2][cy1][cx1], ++imos[cz2][cy1][cx2];\n        ++imos[cz2][cy2][cx1], --imos[cz2][cy2][cx2];\n    }\n\n    // imos x\n    rep(z, cz.size()) rep(y, cy.size()) rep(x, cx.size())\n        imos[z][y][x + 1] += imos[z][y][x];\n    // imos y\n    rep(z, cz.size()) rep(x, cx.size()) rep(y, cy.size())\n        imos[z][y + 1][x] += imos[z][y][x];\n    // imos z\n    rep(y, cy.size()) rep(x, cx.size()) rep(z, cz.size())\n        imos[z + 1][y][x] += imos[z][y][x];\n\n    ll res = 0;\n    rep(z, cz.size()) rep(y, cy.size()) rep(x, cx.size())\n        if (imos[z][y][x] >= k)\n            res += (ll)(cz[z + 1] - cz[z]) * (cy[y + 1] - cy[y]) * (cx[x + 1] - cx[x]);\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\n// 座標圧縮\ntemplate <typename T> struct Compress {\n    map<T, int> zip;\n    vector<int> unzip;\n\n    Compress(vector<T> v) {\n        sort(v.begin(), v.end());\n        v.erase(unique(v.begin(), v.end()), v.end());\n        for (int i = 0; i < v.size(); ++i) {\n            zip[v[i]] = i;\n            unzip.push_back(v[i]);\n        }\n    }\n\n    int size() { return unzip.size(); }\n};\n\nint N, K;\nint X[50][2], Y[50][2], Z[50][2];\nint cum[200][200][200];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N >> K;\n    vector<int> vx, vy, vz;\n    REP(i, N) REP(j, 2) {\n        cin >> X[i][j] >> Y[i][j] >> Z[i][j];\n        vx.push_back(X[i][j]);\n        vy.push_back(Y[i][j]);\n        vz.push_back(Z[i][j]);\n    }\n    Compress<int> cx(vx), cy(vy), cz(vz);\n    REP(i, N) {\n        FOR(z, cz.zip[Z[i][0]], cz.zip[Z[i][1]]) {\n            ++cum[cx.zip[X[i][0]]][cy.zip[Y[i][0]]][z];\n            --cum[cx.zip[X[i][0]]][cy.zip[Y[i][1]]][z];\n            --cum[cx.zip[X[i][1]]][cy.zip[Y[i][0]]][z];\n            ++cum[cx.zip[X[i][1]]][cy.zip[Y[i][1]]][z];\n        }\n    }\n    REP(z, 200) REP(y, 200) FOR(x, 1, 200) cum[x][y][z] += cum[x - 1][y][z];\n    REP(z, 200) REP(x, 200) FOR(y, 1, 200) cum[x][y][z] += cum[x][y - 1][z];\n    int ans = 0;\n    REP(x, cx.size() - 1) REP(y, cy.size() - 1) REP(z, cz.size() - 1) {\n        if (cum[x][y][z] >= K) {\n            ans += (cx.unzip[x + 1] - cx.unzip[x]) * (cy.unzip[y + 1] - cy.unzip[y]) * (cz.unzip[z + 1] - cz.unzip[z]);\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nint N, K;\nint X1[55], X2[55];\nint Y1[55], Y2[55];\nint Z1[55], Z2[55];\n\nvector<int> X, Y, Z;\n\nint cnt[110][110][110];\n\nint compress(int *x1, int *x2, vector<int> &res)\n{\n    rep(i, N) {\n        res.push_back(x1[i]);\n        res.push_back(x2[i]);\n    }\n\n    sort(all(res));\n\n    return res.size();\n}\n\nint get_index(vector<int> &a, int v)\n{\n    return lower_bound(all(a), v) - begin(a);\n}\n\nbool ok(int z, int y, int x)\n{\n    bool res = true;\n\n    res &= cnt[z][y][x] >= K;\n    res &= cnt[z][y][x+1] >= K;\n    res &= cnt[z][y+1][x] >= K;\n    res &= cnt[z][y+1][x+1] >= K;\n    res &= cnt[z+1][y][x] >= K;\n    res &= cnt[z+1][y][x+1] >= K;\n    res &= cnt[z+1][y+1][x] >= K;\n    res &= cnt[z+1][y+1][x+1] >= K;\n\n    return res;\n}\n\nint main()\n{\n    cin >> N >> K;\n\n    rep(i, N) {\n        cin >> X1[i] >> Y1[i] >> Z1[i];\n        cin >> X2[i] >> Y2[i] >> Z2[i];\n    }\n\n    int x = compress(X1, X2, X);\n    int y = compress(Y1, Y2, Y);\n    int z = compress(Z1, Z2, Z);\n\n    rep(i, N) {\n        for (int j = get_index(Z, Z1[i]), j_len = get_index(Z, Z2[i]); j <= j_len; ++j) {\n            for (int k = get_index(Y, Y1[i]), k_len = get_index(Y, Y2[i]); k <= k_len; ++k) {\n                for (int l = get_index(X, X1[i]), l_len = get_index(X, X2[i]); l <= l_len; ++l) {\n                    cnt[j][k][l]++;\n                }\n            }\n        }\n    }\n\n    long long ans = 0;\n\n    rep(i, z - 1) rep(j, y - 1) rep(k, x - 1) {\n        if (ok(i, j, k)) {\n            ans += 1ll * (Z[i + 1] - Z[i]) * (Y[j + 1] - Y[j]) * (X[k + 1] - X[k]);\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmap<ll,int>zipX,zipY,zipD;\nll unzipX[64],unzipY[64],unzipD[64];\nint W,H,Z,N,K;\nvector<int>X,Y,D;\nint sea[64][64][64];\n\nint compress(vector<int> crd, map<ll,int> &zip, ll unzip[64]){\n  sort(crd.begin(), crd.end());\n  crd.erase(unique(crd.begin(), crd.end()), crd.end());\n  for(int i=0;i<crd.size();i++){\n    zip[crd[i]] = i;\n    unzip[i] = crd[i];\n  }\n  return crd.size();\n}\n\nint main(){\n  scanf(\"%d%d\",&N,&K);\n  for(int i=0;i<N;i++){\n    int x,y,d;\n    scanf(\"%d%d%d\", &x,&y,&d);\n    X.push_back(x); Y.push_back(y); D.push_back(d);\n    scanf(\"%d%d%d\", &x,&y,&d);\n    X.push_back(x); Y.push_back(y); D.push_back(d);\n  }\n  \n  H = compress(Y, zipY, unzipY);\n  W = compress(X, zipX, unzipX);\n  Z = compress(D, zipD, unzipD);\n\n  for(int i=0;i<2*N;i+=2){\n    for(int y=zipY[Y[i]];y<zipY[Y[i+1]];y++)\n      for(int x=zipX[X[i]];x<zipX[X[i+1]];x++)\n\tfor(int d=zipD[D[i]];d<zipD[D[i+1]];d++)\n\t  sea[y][x][d]++;\n  }\n  ll res = 0;\n  for(int y=0;y<64;y++) \n    for(int x=0;x<64;x++) \n      for(int d=0;d<64;d++)\n\tif(sea[y][x][d] >= K) \n\t  res += abs(unzipY[y]-unzipY[y+1])*abs(unzipX[x]-unzipX[x+1])*abs(unzipD[d]-unzipD[d+1]);\n  \n  printf(\"%lld\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define e(i,n) for(int i=0;i<n;i++)\nusing namespace std;int n,q,p;long long x[110],y[110],z[110],a[110][2],b[110][2],c[110][2],s;int main(){cin>>n>>q;e(i,2*n){cin>>x[i]>>y[i]>>z[i];a[i/2][i%2]=x[i],b[i/2][i%2]=y[i],c[i/2][i%2]=z[i];}sort(x,x+n*2);sort(y,y+n*2);sort(z,z+n*2);s=0;e(i,n*2-1)e(j,n*2-1)e(k,n*2-1){p=0;e(t,n){bool o=1;e(r,2){if(a[t][0]>x[i+r]||x[i+r]>a[t][1])o=0;if(b[t][0]>y[j+r]||y[j+r]>b[t][1])o=0;if(c[t][0]>z[k+r]||z[k+r]>c[t][1])o=0;}if(o)p++;}if(p>=q)s+=(x[i+1]-x[i])*(y[j+1]-y[j])*(z[k+1]-z[k]);}cout<<s<<endl;return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX_N = 60;\n\nint n, k;\n\nint X1[60], Y1[60], Z1[60];\nint X2[60], Y2[60], Z2[60];\n\nvector<ll> x, y, z;\n\nint main()\n{\n  cin >> n >> k;\n  for (int i = 0; i < n; i++){\n    cin >> X1[i] >> Y1[i] >> Z1[i] >> X2[i] >> Y2[i] >> Z2[i];\n    x.push_back(X1[i]);\n    x.push_back(X2[i]);\n    y.push_back(Y1[i]);\n    y.push_back(Y2[i]);\n    z.push_back(Z1[i]);\n    z.push_back(Z2[i]);\n  }\n\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  sort(z.begin(), z.end());\n\n  ll ans = 0;\n  for (int X = 0; X < x.size() - 1; X++){\n    for (int Y = 0; Y < y.size() - 1; Y++){\n      for (int Z = 0; Z < z.size() - 1; Z++){\n        int cnt = 0;\n        for (int i = 0; i < n; i++){\n          if (X1[i] <= x[X] && x[X + 1] <= X2[i] &&\n              Y1[i] <= y[Y] && y[Y + 1] <= Y2[i] &&\n              Z1[i] <= z[Z] && z[Z + 1] <= Z2[i]) cnt++;\n        }\n\n        if (cnt >= k){\n          ans += (x[X + 1] - x[X]) * (y[Y + 1] - y[Y]) * (z[Z + 1] - z[Z]);\n        }\n      }\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nconst int LIMIT = 1e9 + 7;\n#define rep(i, n) for(int i=0; i<(int)n; i++)\n#define all(v) (v).begin(), (v).end()\n\n\nnamespace /* ZahyoComp.cpp */ {\n\n\n  template<class T>\n  vector<T> compress(vector<T> &V1, vector<T> &V2){\n    //2つのVを一緒くたにして各々圧縮する 重複削除ソート列Sを返す\n    vector<T> S;\n    int N = V1.size();\n    copy(V1.begin(), V1.end(), back_inserter(S));\n    copy(V2.begin(), V2.end(), back_inserter(S));\n\n    sort(S.begin(), S.end());\n    S.erase( unique(S.begin(), S.end()), S.end() );\n    for(int i=0; i<N; i++){\n      V1[i] = lower_bound(S.begin(), S.end(), V1[i]) - S.begin();\n      V2[i] = lower_bound(S.begin(), S.end(), V2[i]) - S.begin();\n    }\n    return S;\n  }\n}\n\nint main(){\n\tint N,K;cin>>N>>K;\n  vi X1(N), X2(N), Y1(N), Y2(N), D1(N), D2(N);\n  rep(i,N){\n    cin>>X1[i]>>Y1[i]>>D1[i]>>X2[i]>>Y2[i]>>D2[i];\n  }\n\n  //座標圧縮\n  vi X = compress(X1, X2);\n  vi Y = compress(Y1, Y2);\n  vi D = compress(D1, D2);\n\n  int XX = X.size();\n  int YY = Y.size();\n  int DD = D.size();\n\n  //DEBUG(XX,YY,DD);\n  //DEBUG(X1);DEBUG(X2);DEBUG(Y1);DEBUG(Y2);DEBUG(D1);DEBUG(D2);\n\n  vector<vector<vi>> sea(XX, vector<vi>(YY, vi(DD, 0)));\n\n  rep(i,N){\n    //いもす法3D\n    //上面\n    sea[X1[i]][Y1[i]][D1[i]]++;\n    sea[X1[i]][Y2[i]][D1[i]]--;\n    sea[X2[i]][Y1[i]][D1[i]]--;\n    sea[X2[i]][Y2[i]][D1[i]]++;\n    //下面\n    sea[X1[i]][Y1[i]][D2[i]]--;\n    sea[X1[i]][Y2[i]][D2[i]]++;\n    sea[X2[i]][Y1[i]][D2[i]]++;\n    sea[X2[i]][Y2[i]][D2[i]]--;\n  }\n\n  //累積和\n  for(int i=1; i<XX; i++){\n    for(int j=0; j<YY; j++){\n      for(int k=0; k<DD; k++){\n        sea[i][j][k] += sea[i-1][j][k];\n      }\n    }\n  }\n  for(int i=0; i<XX; i++){\n    for(int j=1; j<YY; j++){\n      for(int k=0; k<DD; k++){\n        sea[i][j][k] += sea[i][j-1][k];\n      }\n    }\n  }\n  for(int i=0; i<XX; i++){\n    for(int j=0; j<YY; j++){\n      for(int k=1; k<DD; k++){\n        sea[i][j][k] += sea[i][j][k-1];\n      }\n    }\n  }\n\n  /*\n  rep(k,DD){\n    rep(i,XX){\n      rep(j,YY){\n        cout<<sea[i][j][k];\n      }\n      cout<<endl;\n    }\n    cout<<\"-----\"<<endl;\n  }\n  //*/\n\n  //実体積計算\n  ll ans = 0;\n  rep(i,XX)rep(j,YY)rep(k,DD){\n    if(sea[i][j][k] >= K){\n      ll lx = X[i+1] - X[i];\n      ll ly = Y[j+1] - Y[j];\n      ll ld = D[k+1] - D[k];\n      ans += lx * ly * ld;\n      //DEBUG(lx,ly,ld,ans);\n    }\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint n, K;\nint xl[50], yl[50], zl[50], xr[50], yr[50], zr[50];\nint sortedX[100];\nint sortedY[100];\nint sortedZ[100];\n\nbool bet(double a, double b, double c) {\n\treturn (a <= b && b <= c);\n}\n\n//leader point(x, y, z)\nbool check(double x, double y, double z) {\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (bet(xl[i], x, xr[i]) && bet(yl[i], y, yr[i]) && bet(zl[i], z, zr[i])) {\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn (cnt >= K);\n}\n\nsigned main() {\n\tint i, j, k;\n\t\n\tcin >> n >> K;\n\tfor (i = 0; i < n; i++) cin >> xl[i] >> yl[i] >> zl[i] >> xr[i] >> yr[i] >> zr[i];\n\tfor (i = 0; i < n; i++) {\n\t\tsortedX[2 * i] = xl[i]; sortedX[2 * i + 1] = xr[i];\n\t\tsortedY[2 * i] = yl[i]; sortedY[2 * i + 1] = yr[i];\n\t\tsortedZ[2 * i] = zl[i]; sortedZ[2 * i + 1] = zr[i];\n\t}\n\tsort(sortedX, sortedX + 2 * n);\n\tsort(sortedY, sortedY + 2 * n);\n\tsort(sortedZ, sortedZ + 2 * n);\n\t\n\tint ans = 0;\n\tfor (i = 0; i < 2 * n - 1; i++) {\n\t\tfor (j = 0; j < 2 * n - 1; j++) {\n\t\t\tfor (k = 0; k < 2 * n - 1; k++) {\n\t\t\t\tif (check(sortedX[i] + 0.5, sortedY[j] + 0.5, sortedZ[k] + 0.5)) {\n\t\t\t\t\tint szX = sortedX[i+1] - sortedX[i];\n\t\t\t\t\tint szY = sortedY[j+1] - sortedY[j];\n\t\t\t\t\tint szZ = sortedZ[k+1] - sortedZ[k];\n\t\t\t\t\tans += szX * szY * szZ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<string>\n#include<string.h>\n\nusing namespace std;\nstruct AREA {\n\tlong long int x, y, d;\n};\nstruct ANS {\n\tint X, Y, D, X1, Y1, D1;\n};\nint N, K;\nlong long int tmp;\nAREA box[101], del;\nANS Box[51];\nint main() {\n\tdel.x = 0;\n\tdel.y = 0;\n\tdel.d = 0;\n\tcin >> N >> K;\n\tfor (int i = 0; i < 2 * N; i++) {\n\t\tcin >> box[i].x >> box[i].y >> box[i].d;\n\t\tif (i % 2 == 0){\n\t\t\tBox[i / 2].X = box[i].x;\n\t\t\tBox[i / 2].Y = box[i].y;\n\t\t\tBox[i / 2].D = box[i].d;\n\t\t}\n\t\telse {\n\t\t\tBox[i / 2].X1 = box[i].x;\n\t\t\tBox[i / 2].Y1 = box[i].y;\n\t\t\tBox[i / 2].D1 = box[i].d;\n\t\t}\n\t}\n\tfor (int i = 0; i < 2*N; i++) {\n\t\tfor (int j = 2*N - 1; j > i; j--) {\n\t\t\tif (box[j - 1].x > box[j].x) {\n\t\t\t\ttmp = box[j - 1].x;\n\t\t\t\tbox[j - 1].x = box[j].x;\n\t\t\t\tbox[j].x = tmp;\n\t\t\t}\n\t\t\tif (box[j - 1].x == box[j].x) {\n\t\t\t\t\tbox[j].x = 1000000000;\n\t\t\t\t\tdel.x++;\n\t\t\t\t}\n\t\t\tif (box[j - 1].y > box[j].y) {\n\t\t\t\ttmp = box[j - 1].y;\n\t\t\t\tbox[j - 1].y = box[j].y;\n\t\t\t\tbox[j].y = tmp;\n\t\t\t}\n\t\t\tif (box[j - 1].y == box[j].y) {\n\t\t\t\t\tbox[j].y = 1000000000;\n\t\t\t\t\tdel.y++;\n\t\t\t\t}\n\t\t\tif (box[j - 1].d > box[j].d){\n\t\t\t\ttmp = box[j - 1].d;\n\t\t\t\tbox[j - 1].d = box[j].d;\n\t\t\t\tbox[j].d = tmp;\n\t\t\t\t}\n\t\t\tif (box[j - 1].d == box[j].d) {\n\t\t\t\t\tbox[j].d = 1000000000;\n\t\t\t\t\tdel.d++;\n\t\t\t}\n\t\t}\n\t}\n\tint CNT=0;\n\tlong long int ANS=0;\n\tfor (int i = 0; i < 2 * N - del.x - 1; i++) {\n\t\tfor (int j = 0; j < 2 * N - del.y - 1; j++) {\n\t\t\tfor (int k = 0; k < 2 * N - del.d - 1; k++) {\n\t\t\t\tfor (int l = 0; l < N; l++) {\n\t\t\t\t\tif (Box[l].X <= box[i].x&&box[i + 1].x <= Box[l].X1&&Box[l].Y <= box[j].y&&box[j + 1].y <= Box[l].Y1&&Box[l].D <= box[k].d&&box[k + 1].d <= Box[l].D1)\n\t\t\t\t\t\tCNT++;\n\t\t\t\t}\n\t\t\t\tif (CNT >= K)\n\t\t\t\t\tANS += (box[i + 1].x - box[i].x)*(box[j + 1].y - box[j].y)*(box[k + 1].d - box[k].d);\n\t\t\t\tCNT = 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ANS << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n\nusing namespace std;\n\ntypedef struct{\n\tint n;\n\tint species;\n} coord_t;\n\ntypedef struct{\n\tint xl;\n\tint xr;\n\tint yl;\n\tint yr;\n\tint zl;\n\tint zr;\n} fish_t;\n\nint comp(const void *c1, const void *c2);\n\nint main(){\n\tint N;\n\tint K;\n\n\t//魚の種類数と数える種類数を入力\n\tcin >> N >> K;\n\n\tcoord_t *X = new coord_t[2*N];\n\tcoord_t *Y = new coord_t[2*N];\n\tcoord_t *Z = new coord_t[2*N];\n\n\t//座標を入力\n\tfor(int i=0; i<N; i++){\n\t\tcin >> X[2*i].n >> Y[2*i].n >> Z[2*i].n >> X[2*i+1].n >> Y[2*i+1].n >> Z[2*i+1].n;\n\t\tX[2*i].species = 0;\n\t\tX[2*i+1].species = 0;\n\t\tY[2*i].species = 0;\n\t\tY[2*i+1].species = 0;\n\t\tZ[2*i].species = 0;\n\t\tZ[2*i+1].species = 0;\n\t}\n\n\tfish_t *fish = new fish_t[N];\n\t\n\t//各魚の生息領域を代入\n\tfor(int i=0; i<N; i++){\n\t\tint L = 2*i;\n\t\tint R = 2*i+1;\n\n\t\tfish[i].xl = X[L].n;\n\t\tfish[i].xr = X[R].n;\n\t\tfish[i].yl = Y[L].n;\n\t\tfish[i].yr = Y[R].n;\n\t\tfish[i].zl = Z[L].n;\n\t\tfish[i].zr = Z[R].n;\n\t}\n\n\t//座標を小さい順に並べ替える\n\tqsort(X, 2*N, sizeof(coord_t), comp);\n\tqsort(Y, 2*N, sizeof(coord_t), comp);\n\tqsort(Z, 2*N, sizeof(coord_t), comp);\n\n\tint dim = 2*N - 1;\n\n\t//各ブロックの魚の種類を数え、K種類以上の体積を求める\n\tunsigned long long V = 0;\n\tfor(int z=0; z<dim; z++){\n\t\tfor(int y=0; y<dim; y++){\n\t\t\tfor(int x=0; x<dim; x++){\n\t\t\t\tint k = 0;\n\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tif( (fish[i].xl > X[x].n) || (fish[i].xr < X[x+1].n) || (fish[i].yl > Y[y].n) || (fish[i].yr < Y[y+1].n) || (fish[i].zl > Z[z].n) || (fish[i].zr < Z[z+1].n) ){ continue; }\n\t\t\t\t\telse{ k++; }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(k < K){ continue; }\n\t\t\t\telse{\n\t\t\t\t\tV += (unsigned long long) (X[x+1].n - X[x].n) * (Y[y+1].n - Y[y].n) * (Z[z+1].n - Z[z].n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << V << endl;\n\t\n\tdelete[] X;\n\tdelete[] Y;\n\tdelete[] Z;\n\tdelete[] fish;\n\n\treturn 0;\n}\n\nint comp(const void *c1, const void *c2){\n\tcoord_t coord1 = *(coord_t*)c1;\n\tcoord_t coord2 = *(coord_t*)c2;\n\n\tint tmp_n1 = coord1.n;\n\tint tmp_n2 = coord2.n;\n\n\tint tmp_s1 = coord1.species;\n\tint tmp_s2 = coord2.species;\n\n\tint c = tmp_n1 - tmp_n2;\n\n\tif(c == 0){ c = tmp_s1 - tmp_s2; }\n\n\treturn c;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nLL imos[128][128][128];\nint main(void)\n{\n  LL n,k;\n  cin >> n >> k;\n  map<LL,int> compmap[3];\n  vector<LL> comp[3];\n  vector<LL> habitat[6];\n  REP(j,6) habitat[j].resize(n);\n  REP(i,n) REP(j,6) cin >> habitat[j][i];\n  REP(i,n) REP(j,6) comp[j%3].push_back(habitat[j][i]);\n  REP(j,3) SORT(comp[j]);\n  REP(j,3) REP(i,comp[j].size()) compmap[j][comp[j][i]]=i;\n  REP(x,128) REP(y,128) REP(z,128) imos[x][y][z]=0LL;\n  REP(i,n){\n    REP(state,8){\n      int a,b,c;\n      a=(state&1);\n      b=((state&2)>>1);\n      c=((state&4)>>2);\n      imos[compmap[0][habitat[0+a*3][i]]][compmap[1][habitat[1+b*3][i]]][compmap[2][habitat[2+c*3][i]]]+=((a^b^c)?-1:1);\n    }\n  }\n  REP(x,127) REP(y,127) REP(z,127) imos[x+1][y][z]+=imos[x][y][z];\n  REP(x,127) REP(y,127) REP(z,127) imos[x][y+1][z]+=imos[x][y][z];\n  REP(x,127) REP(y,127) REP(z,127) imos[x][y][z+1]+=imos[x][y][z];\n  LL answer=0LL;\n  REP(x,127) REP(y,127) REP(z,127) if(imos[x][y][z]>=k) answer+=(comp[0][x+1]-comp[0][x])*(comp[1][y+1]-comp[1][y])*(comp[2][z+1]-comp[2][z]);\n  cout << answer << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint q[1500][7],p[6],qtop;\nbool ICV(int c[],int d[]){\n\tbool ret=true;\n\tfor(int i=0;i<3;i++){\n\t\tif(d[i]<c[i+3]&&d[i+3]>c[i])p[i]=max(c[i],d[i]),p[i+3]=min(c[i+3],d[i+3]);\n\t\telse ret=false;\n\t}\n\treturn ret;\n}\nint main(){\n\tint n,e;\n\tcin>>n>>e;\n\tqtop=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<6;j++)cin>>q[qtop][j];\n\t\tq[qtop][6]=1;\n\t\tint keep=qtop;\n\t\tqtop++;\n\t\tfor(int j=0;j<keep;j++){\n\t\t\tif(ICV(q[keep],q[j])){\n\t\t\t\tfor(int k=0;k<6;k++)q[qtop][k]=p[k];\n\t\t\t\tq[qtop][6]=q[j][6]+1;\n\t\t\t\tqtop++;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans[60]={0};\n\tfor(int i=0;i<qtop;i++){\n\t\tlong long v[3]={q[i][3]-q[i][0],q[i][4]-q[i][1],q[i][5]-q[i][2]};\n\t\tans[q[i][6]]+=v[0]*v[1]*v[2];\n\t}\n\tfor(int i=55;i>0;i--)ans[i-1]-=ans[i]*(i-1);\n\tcout<<ans[e]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define UNQ(a) a.erase(unique(a.begin(),a.end()),a.end())\nint main(){\n  ll FX[60],FY[60],FZ[60],EX[60],EY[60],EZ[60];\n  vector< ll > x, y, z;\n  int n, K;\n  cin >> n >> K;\n  for(int i = 0 ; i < n ; i++ ){\n    cin >> FX[i] >> FY[i] >> FZ[i];\n    cin >> EX[i] >> EY[i] >> EZ[i];\n  }\n  for(int i = 0 ; i < n ; i++ ){\n    x.pb(FX[i]),y.pb(FY[i]),z.pb(FZ[i]),x.pb(EX[i]),y.pb(EY[i]),z.pb(EZ[i]);\n  }\n  sort(ALL(x)), sort(ALL(y)), sort(ALL(z));\n  UNQ(x),UNQ(y),UNQ(z);\n  ll ans = 0ll;\n  for(int i = 0 ; i < x.size() - 1 ; i++ ){\n    for(int j = 0 ; j < y.size() - 1 ; j++ ){\n      for(int k = 0 ; k < z.size() - 1 ; k++ ){\n\tint cnt = 0;\n\tfor(int l = 0 ; l < n ; l++ ){\n\t  if(FX[l] <= x[i] && x[i+1] <= EX[l] &&\n\t     FY[l] <= y[j] && y[j+1] <= EY[l] &&\n\t     FZ[l] <= z[k] && z[k+1] <= EZ[l]) cnt++;\n\t}\n\tif(cnt >= K) ans += (x[i+1] - x[i]) * (y[j+1] - y[j]) * (z[k+1] - z[k]);\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define e(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,q,p;long long x[110],y[110],z[110],a[110][2],b[110][2],c[110][2],s;\nint main(){\n\tcin>>n>>q;\n\te(i,2*n){cin>>x[i]>>y[i]>>z[i];\n\t\ta[i/2][i%2]=x[i],b[i/2][i%2]=y[i],c[i/2][i%2]=z[i];\n\t}sort(x,x+n*2);sort(y,y+n*2);sort(z,z+n*2);s=0;\n\te(i,n*2-1)e(j,n*2-1)e(k,n*2-1){p=0;\n\te(t,n){bool o=1;e(r,2){\n\t\tif(a[t][0]>x[i+r]||x[i+r]>a[t][1])o=0;\n\t\tif(b[t][0]>y[j+r]||y[j+r]>b[t][1])o=0;\n\t\tif(c[t][0]>z[k+r]||z[k+r]>c[t][1])o=0;\n\t}if(o)p++;\n\t}if(p>=q)s+=(x[i+1]-x[i])*(y[j+1]-y[j])*(z[k+1]-z[k]);\n}cout<<s<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int INF = 1e7;\ntypedef long long ll;\n\nint main(){\n    int n, K;\n    cin >> n >> K;\n    vector<int> ax(n), ay(n), az(n), bx(n), by(n), bz(n), x, y, z;\n    for(int i = 0; i < n; i++){\n        cin >> ax[i] >> ay[i] >> az[i] >> bx[i] >> by[i] >> bz[i];\n        x.push_back(ax[i]), x.push_back(bx[i]);\n        y.push_back(ay[i]), y.push_back(by[i]);\n        z.push_back(az[i]), z.push_back(bz[i]);\n    }\n    x.push_back(-INF), x.push_back(INF);\n    y.push_back(-INF), y.push_back(INF);\n    z.push_back(-INF), z.push_back(INF);\n    sort(x.begin(), x.end());\n    sort(y.begin(), y.end());\n    sort(z.begin(), z.end());\n    x.erase(unique(x.begin(),x.end()),x.end());\n    y.erase(unique(y.begin(),y.end()),y.end());\n    z.erase(unique(z.begin(),z.end()),z.end());\n    int xn = x.size(), yn = y.size(), zn = z.size();\n    int imos[xn][yn][zn];\n    memset(imos, 0, sizeof(imos));\n    for(int i = 0; i < n; i++){\n        int ix = lower_bound(x.begin(),x.end(),ax[i])-x.begin();\n        int iy = lower_bound(y.begin(),y.end(),ay[i])-y.begin();\n        int iz = lower_bound(z.begin(),z.end(),az[i])-z.begin();\n        int jx = lower_bound(x.begin(),x.end(),bx[i])-x.begin();\n        int jy = lower_bound(y.begin(),y.end(),by[i])-y.begin();\n        int jz = lower_bound(z.begin(),z.end(),bz[i])-z.begin();\n        imos[ix][iy][iz]++;\n        imos[ix][jy][iz]--;\n        imos[jx][iy][iz]--;\n        imos[jx][jy][iz]++;\n        imos[ix][iy][jz]--;\n        imos[ix][jy][jz]++;\n        imos[jx][iy][jz]++;\n        imos[jx][jy][jz]--;\n    }\n\n    for(int k = 0; k < zn; k++){\n        for(int j = 0; j < yn; j++){\n            for(int i = 1; i < xn; i++){\n                imos[i][j][k] += imos[i-1][j][k];\n            }\n        }\n    }\n    for(int k = 0; k < zn; k++){\n        for(int i = 0; i < xn; i++){\n            for(int j = 1; j < yn; j++){\n                imos[i][j][k] += imos[i][j-1][k];\n            }\n        }\n    }\n    for(int i = 0; i < xn; i++){\n        for(int j = 0; j < yn; j++){\n            for(int k = 1; k < zn; k++){\n                imos[i][j][k] += imos[i][j][k-1];\n            }\n        }\n    }\n\n    ll ans = 0;\n    for(int i = 0; i < xn; i++){\n        for(int j = 0; j < yn; j++){\n            for(int k = 0; k < zn; k++){\n                if(imos[i][j][k] < K)   continue;\n                ans += (ll)(x[i+1]-x[i])*(y[j+1]-y[j])*(z[k+1]-z[k]);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct CUBE {\n    long long x1;\n    long long y1;\n    long long d1;\n    long long x2;\n    long long y2;\n    long long d2;\n    CUBE() {}\n    CUBE(long long a,long long b,long long c,long long d,long long e,long long f) {\n        this->x1=a; this->y1=b; this->d1=c;\n        this->x2=d; this->y2=e; this->d2=f;\n    }\n};\n\ntypedef pair<long long, int> P; // cordinate, index\n\nint main() {\n    int N,K;\n    cin >> N >> K;\n\n    vector<CUBE> fish;\n    vector<P> x,y,z;\n\n    for(int i=0 ;i<N; ++i) {\n        long long a,b,c,d,e,f;\n        cin >> a >> b >> c >> d >> e >> f;\n        fish.push_back(CUBE(a,b,c,d,e,f));\n        x.push_back(P(a,i));\n        y.push_back(P(b,i));\n        z.push_back(P(c,i));\n        x.push_back(P(d,i));\n        y.push_back(P(e,i));\n        z.push_back(P(f,i));\n    }\n\n    sort(x.begin(),x.end());\n    sort(y.begin(),y.end());\n    sort(z.begin(),z.end());\n\n    vector<int> rnkx[N];\n    vector<int> rnky[N];\n    vector<int> rnkz[N];\n\n    long long valx[2*N],valy[2*N],valz[2*N];\n\n    for(int i=0; i<(int)x.size(); ++i) {\n        P px=x[i];\n        P py=y[i];\n        P pz=z[i];\n        rnkx[px.second].push_back(i);\n        rnky[py.second].push_back(i);\n        rnkz[pz.second].push_back(i);\n        valx[i]=(i<2*N-1?x[i+1].first-x[i].first:0);\n        valy[i]=(i<2*N-1?y[i+1].first-y[i].first:0);\n        valz[i]=(i<2*N-1?z[i+1].first-z[i].first:0);\n    }\n\n    int mp[2*N][2*N][2*N];\n\n    for(int i=0; i<2*N; ++i) {\n        for(int j=0; j<2*N; ++j) {\n            fill(mp[i][j],mp[i][j]+2*N,0);\n        }\n    }\n\n    for(int i=0; i<N; ++i) {\n        for(int mpx=rnkx[i][0]; mpx<rnkx[i][1]; ++mpx) {\n            for(int mpy=rnky[i][0]; mpy<rnky[i][1]; ++mpy) {\n                for(int mpz=rnkz[i][0]; mpz<rnkz[i][1]; ++mpz) ++mp[mpx][mpy][mpz];\n            }\n        }\n    }\n\n    long long ans=0;\n    for(int i=0; i<2*N; ++i) {\n        for(int j=0; j<2*N; ++j) {\n            for(int k=0; k<2*N; ++k) {\n                if(mp[i][j][k]>=K) ans+=valx[i]*valy[j]*valz[k];\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\ntypedef pair<int, int> P;\n\nint n, K;\n\nint compress(vector<int>& v1, vector<int>& v2, vector<int>& ret)\n{\n\tvector<int> vs;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tvs.push_back(v1[i]);\n\t\tvs.push_back(v2[i]);\n\t}\n\tsort(vs.begin(), vs.end());\n\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tv1[i] = find(vs.begin(), vs.end(), v1[i]) - vs.begin();\n\t\tv2[i] = find(vs.begin(), vs.end(), v2[i]) - vs.begin();\n \t}\n\tret = vs;\n\treturn vs.size();\n}\n\nint main(void)\n{\n\twhile(cin >> n >> K && n && K)\n\t{\n\t\tvector<int> x1(n), y1(n), d1(n), x2(n), y2(n), d2(n);\n\t\tvector<int> rx, ry, rd;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> x1[i] >> y1[i] >> d1[i] >> x2[i] >> y2[i] >> d2[i];\n\t\t}\n\n\t\tint xc = compress(x1, x2, rx);\n\t\tint yc = compress(y1, y2, ry);\n\t\tint dc = compress(d1, d2, rd);\n\n\t\tlong long ans = 0;\n\t\tfor (int d = 0; d + 1 < dc; d++)\n\t\t{\n\t\t\tfor (int y = 0; y + 1 < yc; y++)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x + 1 < xc; x++)\n\t\t\t\t{\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(x1[i] <= x && x < x2[i]\n\t\t\t\t\t\t\t&& y1[i] <= y && y < y2[i]\n\t\t\t\t\t\t\t&& d1[i] <= d && d < d2[i])\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tif(count >= K)\n\t\t\t\t\t\tans += (long long)(rx[x+1] - rx[x]) * (long long)(ry[y+1] - ry[y]) * (long long)(rd[d+1] - rd[d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define ll long long int\n\nstruct ST\n{\n\tll x1, x2;\n\tll y1, y2;\n\tll z1, z2;\n};\n\nll x[100 + 10] = { 0 };\nll y[100 + 10] = { 0 };\nll z[100 + 10] = { 0 };\n\nll area = 0;\n\nint main()\n{\n\tST fish[50 + 10];\n\n\tint n,k;\n\n\tint i, j;\n\tint xi, yi, zi;\n\n\tint cnt = 0;\n\n\n\t\n\tcin >> n >> k;\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tcin >> fish[i].x1 >> fish[i].y1 >> fish[i].z1 >> fish[i].x2 >> fish[i].y2 >> fish[i].z2;\n\n\t\tx[i * 2] = fish[i].x1;\n\t\tx[(i * 2) + 1] = fish[i].x2;\n\t\ty[i * 2] = fish[i].y1;\n\t\ty[(i * 2) + 1] = fish[i].y2;\n\t\tz[i * 2] = fish[i].z1;\n\t\tz[(i * 2) + 1] = fish[i].z2;\n\t}\n\n\tsort(x, x + (n * 2));\n\tsort(y, y + (n * 2));\n\tsort(z, z + (n * 2));\n\n\tfor (xi = 0; xi < n * 2 -1; xi++)\n\t{\n\t\tfor (yi = 0; yi < n * 2 -1; yi++)\n\t\t{\n\t\t\tfor (zi = 0; zi < n * 2 -1; zi++)\n\t\t\t{\n\t\t\t\tcnt = 0;\n\t\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\t{\n\t\t\t\t\tif (fish[i].x1 > x[xi] || x[xi + 1] > fish[i].x2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (fish[i].y1 > y[yi] || y[yi + 1] > fish[i].y2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (fish[i].z1 > z[zi] || z[zi + 1] > fish[i].z2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\n\t\t\t\tif (cnt >= k)\n\t\t\t\t{\n\t\t\t\t\tarea += (x[xi + 1] - x[xi]) * (y[yi + 1] - y[yi]) * (z[zi + 1] - z[zi]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << area << endl;\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX_DIS = 1000000;\nint n, k;\nint x[2][51], y[2][51], z[2][51];\nint lx[301], ly[301], lz[301];\nint ocean[301][301][301];\nlong long int ans;\n\nint compress(int *start, int *end, int *lx){\n    vector<int> v;\n\n    for(int i = 0; i < n; i++){\n        for(int j = -1; j <= 1; j++){\n            int x1 = start[i] + j, x2 = end[i] + j;\n            if(0 <= x1 && x1 <= MAX_DIS)\n                v.push_back(x1);\n            if(0 <= x2 && x2 <= MAX_DIS)\n                v.push_back(x2);\n        }\n    }\n\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n\n    for(int i = 0; i < n; i++){\n        start[i] = find(v.begin(), v.end(), start[i]) - v.begin();\n        end[i] = find(v.begin(), v.end(), end[i]) - v.begin();\n    }\n\n    for(int i = 0; i < v.size(); i++)\n        lx[i] = v[i];\n\n    return v.size();\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &k);\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 2; j++){\n            scanf(\"%d%d%d\", &x[j][i], &y[j][i], &z[j][i]);\n        }\n    }\n\n    int w = compress(x[0], x[1], lx);\n    int h = compress(y[0], y[1], ly);\n    int d = compress(z[0], z[1], lz);\n\n    for(int i = 0; i < n; i++){\n        for(int j = x[0][i]; j < x[1][i]; j++){\n            for(int l = y[0][i]; l < y[1][i]; l++){\n                for(int m = z[0][i]; m < z[1][i]; m++){\n                    ocean[j][l][m]++;\n                }\n            }\n        }\n    }\n\n    for(int i = 0; i < w - 1; i++){\n        for(int j = 0; j < h - 1; j++){\n            for(int l = 0; l < d - 1; l++){\n                if(ocean[i][j][l] >= k)\n                    ans += (lx[i + 1] - lx[i]) * (ly[j + 1] - ly[j]) * (lz[l + 1] - lz[l]);\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#define all(c) (c).begin(),(c).end()\n#define f first\n#define s second\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct point{ll x,y,z;};\n\ntypedef pair<point,point> P;\n\nint main(void){\n  ll n,k,x1,x2,y1,y2,z1,z2;\n  vector<ll>x,y,z;\n\n  cin >> n >> k;\n  vector<P> p(n);\n\n  for(int i=0;i<n;i++){\n    cin >> p[i].f.x >> p[i].f.y >> p[i].f.z;\n    cin >> p[i].s.x >> p[i].s.y >> p[i].s.z;\n\n    x.push_back(p[i].f.x);\n    x.push_back(p[i].s.x);\n    y.push_back(p[i].f.y);\n    y.push_back(p[i].s.y);\n    z.push_back(p[i].f.z);\n    z.push_back(p[i].s.z);\n  }\n  \n  sort(all(x));\n  sort(all(y));\n  sort(all(z));\n\n  map<ll,int>X,Y,Z;\n  \n  for(int i=0;i<x.size();i++)X[x[i]]=i;\n  for(int i=0;i<y.size();i++)Y[y[i]]=i;\n  for(int i=0;i<z.size();i++)Z[z[i]]=i;\n  \n  int grid[101][101][101];\n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)\n      for(int l=0;l<101;l++)\n\tgrid[i][j][l]=0;\n\n  for(int i=0;i<n;i++){\n    for(int xi=X[p[i].f.x];xi<X[p[i].s.x];xi++){\n      for(int yi=Y[p[i].f.y];yi<Y[p[i].s.y];yi++){\n\tfor(int zi=Z[p[i].f.z];zi<Z[p[i].s.z];zi++){\n\t  grid[xi][yi][zi]++;\n\t}\n      }\n    }\n  }\n  \n  ll ans=0;\n  for(int i=0;i<x.size()-1;i++){\n    for(int j=0;j<y.size()-1;j++){\n      for(int l=0;l<z.size()-1;l++){\n\tif(grid[i][j][l]>=k){\n\t  ans+=(x[i+1]-x[i])*(y[j+1]-y[j])*(z[l+1]-z[l]);\n\t}\n      }\n    }\n  }\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n \n    int N, K;\n    cin >> N >> K;\n \n    vector<int> X1(N);\n    vector<int> Y1(N);\n    vector<int> D1(N);\n    vector<int> X2(N);\n    vector<int> Y2(N);\n    vector<int> D2(N);\n \n    for (int i = 0; i < N; i++){\n        cin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n    }\n     \n    //ソート用vector\n    vector<int> X(2*N);\n    vector<int> Y(2*N);\n    vector<int> D(2*N);\n    for (int i = 0; i < N; i++){\n        X[2 * i]     = X1[i];\n        X[2 * i + 1] = X2[i];\n        Y[2 * i]     = Y1[i];\n        Y[2 * i + 1] = Y2[i];\n        D[2 * i]     = D1[i];\n        D[2 * i + 1] = D2[i];\n    }\n    sort(X.begin(), X.end());\n    sort(Y.begin(), Y.end());\n    sort(D.begin(), D.end());\n \n    long long ans = 0;\n    int kasanari;\n    for (int i = 0; i < 2*N-1; i++){ //X\n        for (int j = 0; j < 2*N-1; j++){ //Y\n            for (int k = 0; k < 2*N-1; k++){ //D\n                kasanari = 0;\n                for (int l = 0; l < N; l++){ //実際の直方体\n                    if ((X1[l]<=X[i] && X[i+1] <= X2[l]) &&\n                        (Y1[l]<=Y[j] && Y[j+1] <= Y2[l]) &&\n                        (D1[l]<=D[k] && D[k+1] <= D2[l]))\n                        kasanari++;\n                }\n                if (kasanari >= K){\n                    ans += (long long)(X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) * (D[k + 1] - D[k]);\n                }\n            }\n        }\n    }\n \n    cout << ans << \"\\n\";\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint dp[100][100][100];\nvint zip(vint v,vint w){\n\tv.insert(v.end(),ALL(w));\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)),v.end());\n\treturn v;\n}\nint pos(vint &v,int val){\n\treturn lower_bound(ALL(v),val)-v.begin();\n}\nvoid mainmain(){\n\tint N,K;\n\tcin>>N>>K;\n\tvint x1(N);\n\tvint x2(N);\n\tvint y1(N);\n\tvint y2(N);\n\tvint z1(N);\n\tvint z2(N);\n\trep(i,N){\n\t\tcin>>x1[i]>>y1[i]>>z1[i]>>x2[i]>>y2[i]>>z2[i];\n\t}\n\tvint xx=zip(x1,x2);\n\tvint yy=zip(y1,y2);\n\tvint zz=zip(z1,z2);\n\trep(i,N){\n\t\tint xs,ys,zs;\n\t\tint xe,ye,ze;\n\t\txs=pos(xx,x1[i]);\n\t\tys=pos(yy,y1[i]);\n\t\tzs=pos(zz,z1[i]);\n\t\txe=pos(xx,x2[i]);\n\t\tye=pos(yy,y2[i]);\n\t\tze=pos(zz,z2[i]);\n\t\tdp[xs][ys][zs]=dp[xe][ye][zs]=1;\n\t\tdp[xs][ye][zs]=dp[xe][ys][zs]=-1;\n\t\tdp[xs][ys][ze]=dp[xe][ye][ze]=-1;\n\t\tdp[xs][ye][ze]=dp[xe][ys][ze]=1;\n\t}\n\treep(i,1,100){\n\t\trep(j,100){\n\t\t\trep(k,100){\n\t\t\t\tdp[i][j][k]+=dp[i-1][j][k];\n\t\t\t}\n\t\t}\n\t}\n\trep(i,100){\n\t\treep(j,1,100){\n\t\t\trep(k,100){\n\t\t\t\tdp[i][j][k]+=dp[i][j-1][k];\n\t\t\t}\n\t\t}\n\t}\n\trep(i,100){\n\t\trep(j,100){\n\t\t\treep(k,1,100){\n\t\t\t\tdp[i][j][k]+=dp[i][j][k-1];\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\trep(i,100){\n\t\trep(j,100){\n\t\t\trep(k,100){\n\t\t\t\tif(dp[i][j][k]>=K){\n\t\t\t\t\tans+=(ll)(xx[i+1]-xx[i])*(yy[j+1]-yy[j])*(zz[k+1]-zz[k]);\n\t\t\t\t\t// cout<<i<<\" \"<<j<<\" \"<<k<<endl;\n\t\t\t\t\t// cout<<xx[i]<<\" \"<<xx[i+1]<<\" \"<<yy[j]<<\" \"<<yy[j+1]<<\" \"<<zz[k]<<\" \"<<zz[k+1]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n  \tcout<<fixed<<setprecision(0);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Event {\n  int kind, depth, x1, x2, y1, y2;\n};\nbool operator<(const Event &e, const Event &f) {\n  if (e.depth != f.depth) return e.depth < f.depth;\n  if (e.kind != f.kind) return e.kind < f.kind;\n  return e.x1 < f.x1;\n}\n\nint cnt[51][51];\n\nint main() {\n  int N,K;\n  cin>>N>>K;\n  set<int> x,y;\n  int x1,x2,y1,y2,d1,d2;\n  vector<Event> evs;\n  for (int i=0; i<N; ++i) {\n    cin>>x1>>y1>>d1>>x2>>y2>>d2;\n    x.insert(x1); x.insert(x2);\n    y.insert(y1); y.insert(y2);\n    evs.push_back((Event){0,d1,x1,x2,y1,y2});\n    evs.push_back((Event){1,d2,x1,x2,y1,y2});\n  }\n\n  map<int,int> ix, iy, rx, ry;\n  for (set<int>::iterator it = x.begin(); it != x.end(); ++it) {\n    if (ix.find(*it) == ix.end()) {\n      int p = ix.size(); ix[*it] = p;\n      rx[p] = *it;\n      //cout<<*it<<\" = \"<<p<<endl;\n    }\n  }\n  for (set<int>::iterator it = y.begin(); it != y.end(); ++it) {\n    if (iy.find(*it) == iy.end()) {\n      int p = iy.size(); iy[*it] = p;\n      ry[p] = *it;\n    }\n  }\n\n  for (int i=0; i<evs.size(); ++i) {\n    evs[i].x1 = ix[evs[i].x1];\n    evs[i].x2 = ix[evs[i].x2];\n    evs[i].y1 = iy[evs[i].y1];\n    evs[i].y2 = iy[evs[i].y2];\n  }\n\n  sort(evs.begin(), evs.end());\n  memset(cnt, 0, sizeof(cnt));\n\n  int idx = 0, pd = 0;\n  ll ca = 0, ans = 0;\n  while(idx < evs.size()) {\n    int cd = evs[idx].depth;\n    if (ca > 0) {\n      ans += ca*(cd-pd);\n      ca = 0;\n    }\n    pd = cd;\n    while(idx < evs.size()) {\n      if (evs[idx].depth != cd) break;\n      if (evs[idx].kind == 0) {\n        for (int i=evs[idx].x1; i<evs[idx].x2; ++i) {\n          for (int j=evs[idx].y1; j<evs[idx].y2; ++j)\n            cnt[j][i]++;\n        }\n      } else {\n        for (int i=evs[idx].x1; i<evs[idx].x2; ++i) {\n          for (int j=evs[idx].y1; j<evs[idx].y2; ++j)\n            cnt[j][i]--;\n        }\n      }\n      idx++;\n    }\n\n    // calc\n    //cout<<idx<<endl;\n    for (int i=0; i<51; ++i) {\n      for (int j=0; j<51; ++j) {\n        //cout<<cnt[i][j]<<\" \";\n        if (cnt[i][j] >= K) {\n          ca += (ll)(rx[j+1]-rx[j])*(ry[i+1]-ry[i]);\n        }\n      }\n      //cout<<endl;\n    }\n\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct POS{\n\tint num;\n\tint coord[3];\n\tbool begin;\n};\n\nlong long scan_d(vector<bool> &vec_x,vector<bool> &vec_y,vector<POS> &vec_d,int N,int K)\n{\n\tvector<bool> vec(N);\n\tfill(vec.begin(),vec.end(),false);\n\t\n\tint count=0;\n\tint begin;\n\tlong long total = 0;\n\tfor(POS &p : vec_d ){\n\t\tif( !vec_x[p.num] ) continue;\n\t\tif( !vec_y[p.num] ) continue;\n\n\t\tif( p.begin ){\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[2]-begin);\n//\t\t\t\tcout << \"D:\" << begin << \"-\" << p.coord[2] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=true;\n\t\t\tcount++;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[2];\n\t\t\t}\n\t\t}else{\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[2]-begin);\n//\t\t\t\tcout << \"D:\" << begin << \"-\" << p.coord[2] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=false;\n\t\t\tcount--;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[2];\n\t\t\t}\n\t\t}\n\t}\n\treturn total;\n}\n\nlong long scan_y(vector<bool> &vec_x,vector<POS> &vec_y,vector<POS> &vec_d,int N,int K)\n{\n\tvector<bool> vec(N);\n\tfill(vec.begin(),vec.end(),false);\n\t\n\tint count=0;\n\tint begin;\n\tlong long size;\n\tlong long total = 0;\n\tfor(POS &p : vec_y ){\n\t\tif( !vec_x[p.num] ) continue;\n\n\t\tif( p.begin ){\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[1]-begin) * size;\n//\t\t\t\tcout << \"Y:\" << begin << \"-\" << p.coord[1] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=true;\n\t\t\tcount++;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[1];\n\t\t\t\tsize = scan_d(vec_x, vec,vec_d,N,K);\n\t\t\t}\n\t\t}else{\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[1]-begin) * size;\n//\t\t\t\tcout << \"Y:\" << begin << \"-\" << p.coord[1] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=false;\n\t\t\tcount--;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[1];\n\t\t\t\tsize = scan_d(vec_x, vec,vec_d,N,K);\n\t\t\t}\n\t\t}\n\t}\n\treturn total;\n}\n\nlong long scan_x(vector<POS> &vec_x,vector<POS> &vec_y,vector<POS> &vec_d,int N,int K)\n{\n\tvector<bool> vec(N);\n\tfill(vec.begin(),vec.end(),false);\n\t\n\tint count=0;\n\tint begin;\n\tlong long size;\n\tlong long total = 0;\n\tfor(POS &p : vec_x ){\n\t\tif( p.begin ){\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[0]-begin) * size;\n//\t\t\t\tcout << \"X:\" << begin << \"-\" << p.coord[0] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=true;\n\t\t\tcount++;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[0];\n\t\t\t\tsize = scan_y(vec, vec_y,vec_d,N,K);\n\t\t\t}\n\t\t}else{\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[0]-begin) * size;\n//\t\t\t\tcout << \"X:\" << begin << \"-\" << p.coord[0] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=false;\n\t\t\tcount--;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[0];\n\t\t\t\tsize = scan_y(vec, vec_y,vec_d,N,K);\n\t\t\t}\n\t\t}\n\t}\n\treturn total;\n}\n\nint main() {\n\tint N,K;\n\tcin >> N >> K;\n\t\n\tvector<POS> vec;\n\n\tfor(int i=0;i<N;i++){\n\t\tPOS p0,p1;\n\t\tcin >> p0.coord[0] >> p0.coord[1] >> p0.coord[2];\n\t\tcin >> p1.coord[0] >> p1.coord[1] >> p1.coord[2];\n\t\tp0.num=i;\n\t\tp0.begin=true;\n\t\tp1.num=i;\n\t\tp1.begin=false;\n\t\tvec.push_back(p0);\n\t\tvec.push_back(p1);\n\t}\n\n\tvector<POS> vec_x(vec);\n\tvector<POS> vec_y(vec);\n\tvector<POS> vec_d(vec);\n\n\tsort(vec_x.begin(),vec_x.end(),[](POS &p0,POS &p1){ return p0.coord[0]<p1.coord[0];});\n\tsort(vec_y.begin(),vec_y.end(),[](POS &p0,POS &p1){ return p0.coord[1]<p1.coord[1];});\n\tsort(vec_d.begin(),vec_d.end(),[](POS &p0,POS &p1){ return p0.coord[2]<p1.coord[2];});\n\n\t// for( POS p : vec_x ){\n\t// \tcout << p.coord[0] << \" \";\n\t// }\n\t// cout << endl;\n\n\tlong long ans = scan_x(vec_x,vec_y,vec_d,N,K);\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define ll long long\nusing namespace std;\n\nint n;\n\nvoid compress(int *x1,int *x2){\n\tvector<int> pos;\n\tfor(int i = 0;i < n;i++){\n\t\tpos.push_back(x1[i]);\n\t\tpos.push_back(x2[i]);\n\t}\n\tsort(pos.begin(),pos.end());\n\tpos.erase(unique(pos.begin(),pos.end()),pos.end());\n\tfor(int i = 0;i < n;i++){\n\t\tx1[i] = find(pos.begin(),pos.end(),x1[i]) - pos.begin();\n\t\tx2[i] = find(pos.begin(),pos.end(),x2[i]) - pos.begin();\n\t}\n}\n\nint main(){\n\tint kk;\n\tint x1[50],x2[50],y1[50],y2[50],d1[50],d2[50];\n\tint x1p[50],x2p[50],y1p[50],y2p[50],d1p[50],d2p[50];\n\tint fill[100][100][100] = {},coor[3][100];\n\tcin >> n >> kk;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x1[i] >> y1[i] >> d1[i] >> x2[i] >> y2[i] >> d2[i];\n\t\tx1p[i] = x1[i];\n\t\tx2p[i] = x2[i];\n\t\ty1p[i] = y1[i];\n\t\ty2p[i] = y2[i];\n\t\td1p[i] = d1[i];\n\t\td2p[i] = d2[i];\n\t}\n\tcompress(x1,x2);\n\tcompress(y1,y2);\n\tcompress(d1,d2);\n\tfor(int i = 0;i < n;i++) coor[0][x1[i]] = x1p[i];\n\tfor(int i = 0;i < n;i++) coor[0][x2[i]] = x2p[i];\n\tfor(int i = 0;i < n;i++) coor[1][y1[i]] = y1p[i];\n\tfor(int i = 0;i < n;i++) coor[1][y2[i]] = y2p[i];\n\tfor(int i = 0;i < n;i++) coor[2][d1[i]] = d1p[i];\n\tfor(int i = 0;i < n;i++) coor[2][d2[i]] = d2p[i];\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = x1[i];j < x2[i];j++){\n\t\t\tfor(int k = y1[i];k < y2[i];k++){\n\t\t\t\tfor(int l = d1[i];l < d2[i];l++){\n\t\t\t\t\tfill[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long int res = 0;\n\tfor(int i = 0;i < 100;i++){\n\t\tfor(int j = 0;j < 100;j++){\n\t\t\tfor(int k = 0;k < 100;k++){\n\t\t\t\tif(fill[i][j][k] >= kk){\n\t\t\t\t\tres += (ll)(coor[0][i + 1] - coor[0][i]) * (ll)(coor[1][j + 1] - coor[1][j]) * (ll)(coor[2][k + 1] - coor[2][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nvector<int> compress(vector<int> &x) {\n  vector<int> v(x);\n  sort(ALL(v));\n  v.erase(unique(ALL(v)), v.end());\n  FOR(it, x) {\n    *it = find(ALL(v), *it) - v.begin();\n  }\n  return v;\n}\n\nint x1[50],y1[50],z1[50];\nint x2[50],y2[50],z2[50];\nint imos[100][100][100];\n\nint main() {\n  int n,k;\n  while(cin>>n>>k) {\n    vector<int> xs,ys,zs;\n    REP(i,n) {\n      cin >> x1[i] >> y1[i] >> z1[i];\n      cin >> x2[i] >> y2[i] >> z2[i];\n      xs.push_back(x1[i]); xs.push_back(x2[i]);\n      ys.push_back(y1[i]); ys.push_back(y2[i]);\n      zs.push_back(z1[i]); zs.push_back(z2[i]);\n    }\n    vector<int> cxs = compress(xs);\n    vector<int> cys = compress(ys);\n    vector<int> czs = compress(zs);\n    memset(imos,0,sizeof(imos));\n    REP(i,n) {\n      int p1 = i*2;\n      int p2 = i*2+1;\n      for (int x=xs[p1]; x<xs[p2]; ++x) {\n        for (int y=ys[p1]; y<ys[p2]; ++y) {\n          imos[x][y][zs[p1]]++;\n          imos[x][y][zs[p2]]--;\n        }\n      }\n    }\n    ll ans = 0;\n    REP(x,cxs.size()) {\n      REP(y,cys.size()) {\n        int c = 0;\n        REP(z,czs.size()) {\n          c += imos[x][y][z];\n          if (c >= k) {\n            ans += (ll)(cxs[x+1]-cxs[x])*(cys[y+1]-cys[y])*(czs[z+1]-czs[z]);\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\ntypedef long long ll;\nint n,m;\nint x[N],y[N],z[N];\nint X[N],Y[N],Z[N];\nint s[N],t[N],u[N];\nint S[N],T[N],U[N];\nint xd[201],yd[201],zd[201];\n\nvoid compress(int a[51],int A[51],int b[51],int B[51],int c[201]){\n  vector <int> v;\n  for(int i=0;i<n;i++)v.push_back(a[i]),v.push_back(A[i]);\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  for(int i=0;i<v.size();i++) c[i]=v[i];\n  for(int i=0;i<n;i++){\n    b[i]=lower_bound(v.begin(),v.end(),a[i])-v.begin();\n    B[i]=lower_bound(v.begin(),v.end(),A[i])-v.begin();\n  }\n}\n\nll calc(){\n  ll res=0;\n  for(int i=0;i<101;i++) //x\n    for(int j=0;j<101;j++)//y\n      for(int k=0;k<101;k++){//z\n\tint cnt=0;\n\tfor(int l=0;l<n;l++)cnt+=((s[l]<=i&&i<S[l])&&(t[l]<=j&&j<T[l])&&(u[l]<=k&&k<U[l]));\n\tif(cnt<m)continue;\n\tll a=xd[i+1]-xd[i],b=yd[j+1]-yd[j],c=zd[k+1]-zd[k];\n\tres+=a*b*c;\n      }\n  return res;\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>z[i]>>X[i]>>Y[i]>>Z[i];\n  compress(x,X,s,S,xd),compress(y,Y,t,T,yd),compress(z,Z,u,U,zd);\n  cout << calc()<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, K;\nint X1[50], Y1[50], D1[50], X2[50], Y2[50], D2[50];\nvector<int> x, y, d;\nlong long ans;\n\nint main() {\n\tcin >> N >> K;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t\tx.push_back(X1[i]), x.push_back(X2[i]);\n\t\ty.push_back(Y1[i]), y.push_back(Y2[i]);\n\t\td.push_back(D1[i]), d.push_back(D2[i]);\n\t}\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tsort(d.begin(), d.end());\n\tfor (int i = 0; i < 2 * N - 1; i++) {\n\t\tfor (int j = 0; j < 2 * N - 1; j++) {\n\t\t\tfor (int k = 0; k < 2 * N - 1; k++) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int l = 0; l < N; l++) {\n\t\t\t\t\tif (X1[l] <= x[i] && x[i + 1] <= X2[l]\n\t\t\t\t\t\t&& Y1[l] <= y[j] && y[j + 1] <= Y2[l]\n\t\t\t\t\t\t&& D1[l] <= d[k] && d[k + 1] <= D2[l]) cnt++;\n\t\t\t\t}\n\t\t\t\tif (cnt >= K) ans += (long long)(x[i + 1] - x[i]) * (y[j + 1] - y[j]) * (d[k + 1] - d[k]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n, k;\nint loc[6][50];\nint sloc[3][100];\nint sea[99][99][99];\nlong long int ans = 0;\n\nbool judge(int i, int x, int y, int d)\n{\n  if(loc[0][i] <= sloc[0][x]&&\n     sloc[0][x + 1] <= loc[3][i]&&\n     loc[1][i] <= sloc[1][y]&&\n     sloc[1][y + 1] <= loc[4][i]&&\n     loc[2][i] <= sloc[2][d]&&\n     sloc[2][d + 1] <= loc[5][i])\n    return true;\n  return false;\n}\n\nint main()\n{\n  cin >> n >> k;\n  \n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < 6; j++){\n      cin >> loc[j][i];\n    }\n  }\n\n  for(int i = 0; i < 6; i++){\n    for(int j = 0; j < n; j++){\n      sloc[i % 3][2 * j + i % 2] = loc[i][j];\n    }\n  }\n\n  for(int i = 0; i < 3; i++)\n    sort(sloc[i], sloc[i] + n * 2);\n  \n  for(int i = 0; i < n; i++){\n    for(int x = 0; x < n * 2 - 1; x++){\n      for(int y = 0; y < n * 2 - 1; y++){\n\tfor(int d = 0; d < n * 2 - 1; d++){\n\t  if(judge(i, x, y, d))\n\t    sea[x][y][d]++;\n\t}\n      }\n    }\n  }\n  \n  for(int x = 0; x < n * 2 - 1; x++){\n    for(int y = 0; y < n * 2 - 1; y++){\n      for(int d = 0; d < n * 2 - 1; d++){\n\tif(sea[x][y][d] >= k)\n\t  ans += (long long int) (sloc[0][x + 1] - sloc[0][x]) * (sloc[1][y + 1] - sloc[1][y]) * (sloc[2][d + 1] - sloc[2][d]);\n      }\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0580\n#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\n#define REP(i,n) for(integer i=0;i<(int)(n);i++)\nusing namespace std;\n\ntypedef long long int integer;\n\nconst integer NNMAX = 200, NMAX = 50;\nconst integer INF = 1e6 + 10;\ninteger N, K;\ninteger X1[NMAX], X2[NMAX], Y1[NMAX], Y2[NMAX], Z1[NMAX], Z2[NMAX];\n\nvector<int> CX, CY, CZ;\ninteger volume[NNMAX][NNMAX][NNMAX];\ninteger kinds[NNMAX][NNMAX][NNMAX];\n\ninteger solve() {\n  set<integer> xs, ys, zs;\n  for (integer i = 0; i < N; i++) { xs.insert(X1[i]); xs.insert(X2[i]); }\n  for (integer x : xs) CX.push_back(x);\n  \n  for (integer i = 0; i < N; i++) { ys.insert(Y1[i]); ys.insert(Y2[i]); }\n  for (integer y : ys) CY.push_back(y);\n\n  for (integer i = 0; i < N; i++) { zs.insert(Z1[i]); zs.insert(Z2[i]); }\n  for (integer z : zs) CZ.push_back(z);\n\n  sort(CX.begin(), CX.end());\n  sort(CY.begin(), CY.end());\n  sort(CZ.begin(), CZ.end());\n\n  CX.push_back(INF);\n  CY.push_back(INF);\n  CZ.push_back(INF);\n\n  REP(i, N) {\n    auto xl = lower_bound(CX.begin(), CX.end(), X1[i]) - CX.begin(),\n         xu = upper_bound(CX.begin(), CX.end(), X2[i]) - CX.begin(),\n         yl = lower_bound(CY.begin(), CY.end(), Y1[i]) - CY.begin(),\n         yu = upper_bound(CY.begin(), CY.end(), Y2[i]) - CY.begin(),\n         zl = lower_bound(CZ.begin(), CZ.end(), Z1[i]) - CZ.begin(),\n         zu = upper_bound(CZ.begin(), CZ.end(), Z2[i]) - CZ.begin();\n    \n    kinds[xl][yl][zl]++;\n    kinds[xu][yl][zl]--;\n    kinds[xl][yu][zl]--;\n    kinds[xl][yl][zu]--;\n    kinds[xu][yu][zl]++;\n    kinds[xu][yl][zu]++;\n    kinds[xl][yu][zu]++;\n    kinds[xu][yu][zu]--;\n  }\n\n  integer xm = CX.size(), ym = CY.size(), zm = CZ.size();\n  \n  for (integer x : xs) { cout << x << \",\"; } cout << endl;\n  for (integer y : ys) { cout << y << \",\"; } cout << endl;\n  for (integer z : zs) { cout << z << \",\"; } cout << endl;\n\n  REP(x,xm-1) REP(y,ym-1) REP(z,zm-1) {\n    volume[x][y][z] = \n      (CX[x+1]-CX[x])*(CY[y+1]-CY[y])*(CZ[z+1]-CZ[z]);\n  }\n\n  REP(x,xm-1) REP(y,ym) REP(z,zm) { \n    kinds[x+1][y][z] += kinds[x][y][z];\n  }\n  REP(x,xm) REP(y,ym-1) REP(z,zm) { \n    kinds[x][y+1][z] += kinds[x][y][z];\n  }\n  REP(x,xm) REP(y,ym) REP(z,zm-1) { \n    kinds[x][y][z+1] += kinds[x][y][z];\n  }\n\n  integer sum = 0;\n  REP(x,xm-1) REP(y,ym-1) REP(z,zm-1) {\n    if (kinds[x][y][z] >= K) {\n      cout << \"(\" << x << \",\" << y << \",\" << z << \")\" <<\n        volume[x][y][z] << endl;\n      sum += volume[x][y][z];\n    }\n  }\n\n  return sum;\n}\n\nint main() {\n  cin >> N >> K;\n  for (integer i = 0; i < N; i++) {\n    cin >> X1[i] >> Y1[i] >> Z1[i]\n      >> X2[i] >> Y2[i] >> Z2[i];\n  }\n\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nint q[55][2][3];\n\nlong long int xx[111];\nlong long int yy[111];\nlong long int zz[111];\n\nint w[111][111][111];\n\nint main()\n{\n\tint n,k;\n\tscanf(\"%d %d\",&n,&k);\n\t\n\tpriority_queue<int,vector<int>,greater<int> > x,y,z;\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d %d %d %d %d %d\",&q[i][0][0],&q[i][0][1],&q[i][0][2],&q[i][1][0],&q[i][1][1],&q[i][1][2]);\n\t\tx.push(q[i][0][0]);\n\t\tx.push(q[i][1][0]);\n\t\ty.push(q[i][0][1]);\n\t\ty.push(q[i][1][1]);\n\t\tz.push(q[i][0][2]);\n\t\tz.push(q[i][1][2]);\n\t}\n\t\n\tint xw = 0;\n\tint yw = 0;\n\tint zw = 0;\n\tint mae;\n\tmae = -1;\n\twhile(x.empty() == false)\n\t{\n\t\tif(mae != x.top())\n\t\t{\n\t\t\txx[xw] = x.top();\n\t\t\tmae = x.top();\n\t\t\txw++;\n\t\t}\n\t\tx.pop();\n\t}\n\tmae = -1;\n\twhile(y.empty() == false)\n\t{\n\t\tif(mae != y.top())\n\t\t{\n\t\t\tyy[yw] = y.top();\n\t\t\tmae = y.top();\n\t\t\tyw++;\n\t\t}\n\t\ty.pop();\n\t}\n\tmae = -1;\n\twhile(z.empty() == false)\n\t{\n\t\tif(mae != z.top())\n\t\t{\n\t\t\tzz[zw] = z.top();\n\t\t\tmae = z.top();\n\t\t\tzw++;\n\t\t}\n\t\tz.pop();\n\t}\n\t\n\tfor(int i = 0; i < xw; i++)\n\t{\n\t\tfor(int ii = 0; ii < yw; ii++)\n\t\t{\n\t\t\tfor(int iii = 0; iii < zw; iii++)\n\t\t\t{\n\t\t\t\tw[i][ii][iii] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int j = 0; j < n; j++)\n\t{\n\t\tfor(int i = 0; i < xw; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < yw; ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii < zw; iii++)\n\t\t\t\t{\n\t\t\t\t\tif(q[j][0][0] <= xx[i] && xx[i] < q[j][1][0] && q[j][0][1] <= yy[ii] && yy[ii] < q[j][1][1] && q[j][0][2] <= zz[iii] && zz[iii] < q[j][1][2])\n\t\t\t\t\t{\n\t\t\t\t\t\tw[i][ii][iii]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long int all = 0;\n\tfor(int i = 0; i < xw; i++)\n\t{\n\t\tfor(int ii = 0; ii < yw; ii++)\n\t\t{\n\t\t\tfor(int iii = 0; iii < zw; iii++)\n\t\t\t{\n\t\t\t\tif(w[i][ii][iii] >= k)\n\t\t\t\t{\n\t\t\t\t\tall += (xx[i + 1] - xx[i]) * (yy[ii + 1] - yy[ii]) * (zz[iii + 1] - zz[iii]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\",all);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint N,K;\nint pos[50][2][3];\nvector<int> v[3];\nint table[100][100][100];\nint main() {\n\tcin >> N >> K;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tcin >> pos[i][j][k];\n\t\t\t\tv[k].push_back(pos[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<3;i++){\n\t\tsort(v[i].begin(),v[i].end());\n\t\tv[i].resize(unique(v[i].begin(),v[i].end())-v[i].begin());\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tint p2[2][3];\n\t\tfor(int j=0;j<2;j++){\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tp2[j][k]=lower_bound(v[k].begin(),v[k].end(),pos[i][j][k])-v[k].begin();\n\t\t\t}\n\t\t}\n\t\tfor(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<2;b++){\n\t\t\t\tfor(int c=0;c<2;c++){\n\t\t\t\t\tint d=(a+b+c)%2==0?1:-1;\n\t\t\t\t\ttable[p2[a][0]][p2[b][1]][p2[c][2]]+=d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<v[0].size();i++){\n\t\tfor(int j=0;j<v[1].size();j++){\n\t\t\tfor(int k=1;k<v[2].size();k++){\n\t\t\t\ttable[i][j][k]+=table[i][j][k-1];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<v[0].size();i++){\n\t\tfor(int j=1;j<v[1].size();j++){\n\t\t\tfor(int k=0;k<v[2].size();k++){\n\t\t\t\ttable[i][j][k]+=table[i][j-1][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<v[0].size();i++){\n\t\tfor(int j=0;j<v[1].size();j++){\n\t\t\tfor(int k=0;k<v[2].size();k++){\n\t\t\t\ttable[i][j][k]+=table[i-1][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tLL ret=0;\n\tfor(int i=0;i+1<v[0].size();i++){\n\t\tLL x=v[0][i+1]-v[0][i];\n\t\tfor(int j=0;j+1<v[1].size();j++){\n\t\t\tLL y=v[1][j+1]-v[1][j];\n\t\t\tfor(int k=0;k+1<v[2].size();k++){\n\t\t\t\tif(table[i][j][k]>=K){\n\t\t\t\t\tLL z=v[2][k+1]-v[2][k];\n\t\t\t\t\tret+=x*y*z;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct AREA\n{\n\tint x1, y1, z1, x2, y2, z2;\n};\nint main(void)\n{\n\tint N, K,i,j,x[101],y[101],z[101],xx,yy,zz,m,h,cnt=0;\n\tAREA barea[51];\n\tlong long sum = 0;\n\tscanf(\"%d%d\", &N, &K);\n\tfor (i = 0; i <2*N; i++)\n\t{\n\t\tscanf(\"%d %d %d\", &x[i], &y[i], &z[i]);\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\tbarea[i / 2].x1 = x[i];\n\t\t\tbarea[i / 2].y1 = y[i];\n\t\t\tbarea[i / 2].z1 = z[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbarea[i / 2].x2 = x[i];\n\t\t\tbarea[i / 2].y2 = y[i];\n\t\t\tbarea[i / 2].z2 = z[i];\n\t\t}\n\t}\n\n\tfor (i = 0; i < 2*N-1; i++)\n\t{\n\t\tfor (j = i + 1; j < 2*N; j++)\n\t\t{\n\t\t\tif (x[i] > x[j])\n\t\t\t{\n\t\t\t\txx = x[i];\n\t\t\t\tx[i] = x[j];\n\t\t\t\tx[j] = xx;\n\t\t\t}\n\t\t\tif (y[i] > y[j])\n\t\t\t{\n\t\t\t\tyy = y[i];\n\t\t\t\ty[i] = y[j];\n\t\t\t\ty[j] = yy;\n\t\t\t}\n\t\t\tif (z[i] > z[j])\n\t\t\t{\n\t\t\t\tzz = z[i];\n\t\t\t\tz[i] = z[j];\n\t\t\t\tz[j] = zz;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < 2 * N-1; i++)\n\t{\n\t\tfor (j = 0; j < 2 * N-1; j++)\n\t\t{\n\t\t\tfor (m = 0; m < 2 * N-1; m++)\n\t\t\t{\n\t\t\t\tfor (h = 0; h < N; h++)\n\t\t\t\t{\n\t\t\t\t\tif(barea[h].x1<=x[i]&&x[i+1]<=barea[h].x2&&barea[h].y1 <= y[j] && y[j + 1] <= barea[h].y2&&barea[h].z1 <= z[m] && z[m + 1] <= barea[h].z2)\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif (K <= cnt)\n\t\t\t\t{\n\t\t\t\n\t\t\t\t\tsum = sum + (x[i + 1] - x[i])*(y[j + 1] - y[j])*(z[m + 1] - z[m]);\n\t\t\t\t}\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n// #include <ctime>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nint main(){\n\tull v = 0;\n\tconst int MAX_N = 50;\n\tint X1[MAX_N], Y1[MAX_N], D1[MAX_N], X2[MAX_N], Y2[MAX_N], D2[MAX_N];\n\tint N, K;\n\n\tcin >> N >> K;\n\n\tvector<int> X(2 * N), Y(2 * N), D(2 * N);\n\n\tfor (int i = 0; i<N; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t\tX[i]     = X1[i];\n\t\tX[i + N] = X2[i];\n\t\tY[i]     = Y1[i];\n\t\tY[i + N] = Y2[i];\n\t\tD[i]     = D1[i];\n\t\tD[i + N] = D2[i];\n\t}\n//\tclock_t st = clock();\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\tfor (size_t i = 0, n = X.size()-1; i<n; i++){\n\tfor (size_t j = 0; j<n; j++){\n\tfor (size_t k = 0; k<n; k++){\n\t\tint kind = 0;\n\t\tfor (int l = 0; l < N; l++){\n\t\t\tif (X1[l] <= X[i] && X[i+1] <= X2[l] && \n\t\t\t\tY1[l] <= Y[j] && Y[j+1] <= Y2[l] && \n\t\t\t\tD1[l] <= D[k] && D[k+1] <= D2[l]) kind++;\n\t\t}\n\t\tif (kind >= K) v += (ull)(X[i+1] - X[i]) * (Y[j+1] - Y[j]) * (D[k+1] - D[k]);\n\t}\n\t}\n\t}\n\n\tcout << v << endl;\n//\tclock_t ed = clock();\n//\tcout << (double)(ed - st) / CLOCKS_PER_SEC << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tcin.tie(0);\n    ios::sync_with_stdio(false);\n\n\tint N, K;\n\tcin >> N >> K;\n\n\tvector<int> X1(N);\n\tvector<int> Y1(N);\n\tvector<int> D1(N);\n\tvector<int> X2(N);\n\tvector<int> Y2(N);\n\tvector<int> D2(N);\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t}\n\t\n\t//ソート用vector\n\tvector<int> X(2*N);\n\tvector<int> Y(2*N);\n\tvector<int> D(2*N);\n\tfor (int i = 0; i < N; i++){\n\t\tX[2 * i]     = X1[i];\n\t\tX[2 * i + 1] = X2[i];\n\t\tY[2 * i]     = Y1[i];\n\t\tY[2 * i + 1] = Y2[i];\n\t\tD[2 * i]     = D1[i];\n\t\tD[2 * i + 1] = D2[i];\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\tlong long int ans = 0;\n\tint kasanari;\n\tfor (int i = 0; i < 2*N-1; i++){ //X\n\t\tfor (int j = 0; j < 2*N-1; j++){ //Y\n\t\t\tfor (int k = 0; k < 2*N-1; k++){ //D\n\t\t\t\tkasanari = 0;\n\t\t\t\tfor (int l = 0; l < N; l++){ //実際の直方体\n\t\t\t\t\tif ((X1[l]<=X[i] && X[i+1] <= X2[l]) &&\n\t\t\t\t\t\t(Y1[l]<=Y[j] && Y[j+1] <= Y2[l]) &&\n\t\t\t\t\t\t(D1[l]<=D[k] && D[k+1] <= D2[l]))\n\t\t\t\t\t\tkasanari++;\n\t\t\t\t}\n\t\t\t\tif (kasanari >= K){\n\t\t\t\t\tans += (long long int)(X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) * (D[k + 1] - D[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX_DIS = 1000000;\nint n, k;\nint x[2][51], y[2][51], z[2][51];\nint ocean[301][301][301];\nlong long int lx[301], ly[301], lz[301];\nlong long int ans;\n\nint compress(int *start, int *end, int *lx){\n    vector<int> v;\n\n    for(int i = 0; i < n; i++){\n        for(int j = -1; j <= 1; j++){\n            int x1 = start[i] + j, x2 = end[i] + j;\n            if(0 <= x1 && x1 <= MAX_DIS)\n                v.push_back(x1);\n            if(0 <= x2 && x2 <= MAX_DIS)\n                v.push_back(x2);\n        }\n    }\n\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n\n    for(int i = 0; i < n; i++){\n        start[i] = find(v.begin(), v.end(), start[i]) - v.begin();\n        end[i] = find(v.begin(), v.end(), end[i]) - v.begin();\n    }\n\n    for(int i = 0; i < v.size(); i++)\n        lx[i] = v[i];\n\n    return v.size();\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &k);\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 2; j++){\n            scanf(\"%d%d%d\", &x[j][i], &y[j][i], &z[j][i]);\n        }\n    }\n\n    int w = compress(x[0], x[1], lx);\n    int h = compress(y[0], y[1], ly);\n    int d = compress(z[0], z[1], lz);\n\n    for(int i = 0; i < n; i++){\n        for(int j = x[0][i]; j < x[1][i]; j++){\n            for(int l = y[0][i]; l < y[1][i]; l++){\n                for(int m = z[0][i]; m < z[1][i]; m++){\n                    ocean[j][l][m]++;\n                }\n            }\n        }\n    }\n\n    for(int i = 0; i < w - 1; i++){\n        for(int j = 0; j < h - 1; j++){\n            for(int l = 0; l < d - 1; l++){\n                if(ocean[i][j][l] >= k)\n                    ans += (lx[i + 1] - lx[i]) * (ly[j + 1] - ly[j]) * (lz[l + 1] - lz[l]);\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nlong long int INF = 1000000000000000000LL; // 10^18\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint cnt[110][110][110] = {};\n\nint main(){\n\t\n\tint N, K;\n\tcin >> N >> K;\n\t\n\tlong long int x[200], y[200], z[200];\n\tlong long int x1[200], y1[200], z1[200];\n\tfor(int i = 0; i < N * 2; i += 2){\n\t\tcin >> x[i] >> y[i] >> z[i];\n\t\tcin >> x[i + 1] >> y[i + 1] >> z[i + 1];\n\t}\n\t\n\tvector<P> v;\n\tfor(int i = 0; i < N * 2; i++){\n\t\tP p;\n\t\tp.first = x[i];\n\t\tp.second = i;\n\t\tv.push_back(p);\n\t}\n\t\n\tsort(v.begin(), v.end());\n\t\n\tfor(int i = 0; i < N * 2; i++){\n\t\tP p = v[i];\n\t\tx1[p.second] = i;\n\t}\n\t\n\tv.erase(v.begin(), v.end());\n\tfor(int i = 0; i < N * 2; i++){\n\t\tP p;\n\t\tp.first = y[i];\n\t\tp.second = i;\n\t\tv.push_back(p);\n\t}\n\t\n\tsort(v.begin(), v.end());\n\t\n\tfor(int i = 0; i < N * 2; i++){\n\t\tP p = v[i];\n\t\ty1[p.second] = i;\n\t}\n\t\n\tv.erase(v.begin(), v.end());\n\tfor(int i = 0; i < N * 2; i++){\n\t\tP p;\n\t\tp.first = z[i];\n\t\tp.second = i;\n\t\tv.push_back(p);\n\t}\n\t\n\tsort(v.begin(), v.end());\n\t\n\tfor(int i = 0; i < N * 2; i++){\n\t\tP p = v[i];\n\t\tz1[p.second] = i;\n\t}\n\t\n\tv.erase(v.begin(), v.end());\n\t\n\tfor(int i = 0; i < 2 * N; i += 2){\n\t\tfor(int j = x1[i]; j < x1[i + 1]; j++){\n\t\t\tfor(int k = y1[i]; k < y1[i + 1]; k++){\n\t\t\t\tcnt[j][k][z1[i]]++;\n\t\t\t\tcnt[j][k][z1[i + 1]]--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsort(x, x + 2 * N);\n\tsort(y, y + 2 * N);\n\tsort(z, z + 2 * N);\n\t\n\tlong long ans = 0;\n\tfor(int i = 0; i < 2 * N + 1; i++){\n\t\tfor(int j = 0; j < 2 * N + 1; j++){\n\t\t\tint num = 0;\n\t\t\tfor(int k = 0; k < 2 * N + 1; k++){\n\t\t\t\tnum += cnt[i][j][k];\n\t\t\t\tif(num >= K){\n\t\t\t\t\tans += (x[i + 1] - x[i]) * (y[j + 1] - y[j]) * (z[k + 1] - z[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N, K;\n\tcin >> N >> K;\n\n\tvector<int> X1(N);\n\tvector<int> Y1(N);\n\tvector<int> D1(N);\n\tvector<int> X2(N);\n\tvector<int> Y2(N);\n\tvector<int> D2(N);\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> X1[i] >> Y1[i]>> D1[i]>> X2[i]>> Y2[i]>> D2[i];\n\t}\n\t\n\t//ソート用vector\n\tvector<int> X(2*N);\n\tvector<int> Y(2*N);\n\tvector<int> D(2*N);\n\tfor (int i = 0; i < N; i++){\n\t\tX[2 * i]     = X1[i];\n\t\tX[2 * i + 1] = X2[i];\n\t\tY[2 * i]     = Y1[i];\n\t\tY[2 * i + 1] = Y2[i];\n\t\tD[2 * i]     = D1[i];\n\t\tD[2 * i + 1] = D2[i];\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\tlong long int ans = 0;\n\tint kasanari;\n\tfor (int i = 0; i < 2*N-1; i++){ //X\n\t\tfor (int j = 0; j < 2*N-1; j++){ //Y\n\t\t\tfor (int k = 0; k < 2*N-1; k++){ //D\n\t\t\t\tkasanari = 0;\n\t\t\t\tfor (int l = 0; l < N; l++){ //実際の直方体\n\t\t\t\t\tif ((X1[l]<=X[i] && X[i+1] <= X2[l]) &&\n\t\t\t\t\t\t(Y1[l]<=Y[j] && Y[j+1] <= Y2[l]) &&\n\t\t\t\t\t\t(D1[l]<=D[k] && D[k+1] <= D2[l]))\n\t\t\t\t\t\tkasanari++;\n\t\t\t\t}\n\t\t\t\tif (kasanari >= K){\n\t\t\t\t\tans += (X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) * (D[k + 1] - D[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmap<ll,int>zipX,zipY,zipD;\nll unzipX[128],unzipY[128],unzipD[128];\nint W,H,Z,N,K;\nvector<int>X,Y,D;\nint sea[128][128][128];\n\nint compress(vector<int> crd, map<ll,int> &zip, ll unzip[128]){\n  sort(crd.begin(), crd.end());\n  crd.erase(unique(crd.begin(), crd.end()), crd.end());\n  for(int i=0;i<crd.size();i++){\n    zip[crd[i]] = i;\n    unzip[i] = crd[i];\n  }\n  return crd.size();\n}\n\nint main(){\n  scanf(\"%d%d\",&N,&K);\n  for(int i=0;i<N;i++){\n    int x,y,d;\n    scanf(\"%d%d%d\", &x,&y,&d);\n    X.push_back(x); Y.push_back(y); D.push_back(d);\n    scanf(\"%d%d%d\", &x,&y,&d);\n    X.push_back(x); Y.push_back(y); D.push_back(d);\n  }\n  \n  H = compress(Y, zipY, unzipY);\n  W = compress(X, zipX, unzipX);\n  Z = compress(D, zipD, unzipD);\n\n  for(int i=0;i<2*N;i+=2){\n    for(int y=zipY[Y[i]];y<zipY[Y[i+1]];y++)\n      for(int x=zipX[X[i]];x<zipX[X[i+1]];x++)\n\tfor(int d=zipD[D[i]];d<zipD[D[i+1]];d++)\n\t  sea[y][x][d]++;\n  }\n  ll res = 0;\n  for(int y=0;y<128;y++) \n    for(int x=0;x<128;x++) \n      for(int d=0;d<128;d++)\n\tif(sea[y][x][d] >= K) \n\t  res += abs(unzipY[y]-unzipY[y+1])*abs(unzipX[x]-unzipX[x+1])*abs(unzipD[d]-unzipD[d+1]);\n  \n  printf(\"%lld\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<long long> x1(n), y1(n), z1(n), x2(n), y2(n), z2(n);\n  for (int i : range(n)) cin >> x1[i] >> y1[i] >> z1[i] >> x2[i] >> y2[i] >> z2[i];\n  long long res = 0;\n  vector<long long> x = x1, y = y1, z = z1;\n  copy(x2.begin(), x2.end(), back_inserter(x));\n  copy(y2.begin(), y2.end(), back_inserter(y));\n  copy(z2.begin(), z2.end(), back_inserter(z));\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  sort(z.begin(), z.end());\n  for (int xi : range(x.size() - 1)) {\n    for (int yi : range(y.size() - 1)) {\n      for (int zi : range(z.size() - 1)) {\n        int xx = x[xi], yy = y[yi], zz = z[zi], c = 0;\n        for (int i : range(n)) {\n          if (xx < x1[i] || x2[i] <= xx) continue;\n          if (yy < y1[i] || y2[i] <= yy) continue;\n          if (zz < z1[i] || z2[i] <= zz) continue;\n          ++c;\n        }\n        if (c >= k) res += (x[xi + 1] - xx) * (y[yi + 1] - yy) * (z[zi + 1] - zz);\n      }\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX_X 1000500\n#define MAX_Y 1000500\n#define MAX_Z 1000500\n#define MAX_N 52\n#define MAX_C MAX_N * 2\n\nint N, K;\n\nint X[MAX_X], Y[MAX_X], D[MAX_X];\n\nint SX[MAX_C], SY[MAX_C], SD[MAX_C];\nint LX[MAX_C], LY[MAX_C], LD[MAX_C];\nint KX[MAX_C], KY[MAX_C], KD[MAX_C];\n\nint X1[MAX_N], Y1[MAX_N], D1[MAX_N], X2[MAX_N], Y2[MAX_N], D2[MAX_N];\n\nint main()\n{\n\tmemset(X, 0, sizeof(X));\n\tmemset(Y, 0, sizeof(Y));\n\tmemset(D, 0, sizeof(D));\n\n\tcin >> N >> K;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\n\t\tfor (int j = X1[i]; j < X2[i]; j++)\n\t\t{\n\t\t\tX[j] += 1;\n\t\t}\n\n\t\tfor (int j = Y1[i]; j < Y2[i]; j++)\n\t\t{\n\t\t\tY[j] += 1;\n\t\t}\n\n\t\tfor (int j = D1[i]; j < D2[i]; j++)\n\t\t{\n\t\t\tD[j] += 1;\n\t\t}\n\t}\n\n\n\tint start;\n\tint countx = 0, county = 0, countd = 0;\n\n\tstart = 0;\n\n\tfor (int i = 1; i < MAX_X; i++)\n\t{\n\t\tif (X[i - 1] != X[i])\n\t\t{\n\t\t\tSX[countx] = start;\n\t\t\tLX[countx] = i - start;\n\t\t\tKX[countx] = X[i - 1];\n\n\t\t\tstart = i;\n\t\t\tcountx += 1;\n\t\t}\n\t}\n\n\tstart = 0;\n\n\tfor (int i = 1; i < MAX_X; i++)\n\t{\n\t\tif (Y[i - 1] != Y[i])\n\t\t{\n\t\t\tSY[county] = start;\n\t\t\tLY[county] = i - start;\n\t\t\tKY[county] = Y[i - 1];\n\n\t\t\tstart = i;\n\t\t\tcounty += 1;\n\t\t}\n\t}\n\n\tstart = 0;\n\n\tfor (int i = 1; i < MAX_X; i++)\n\t{\n\t\tif (D[i - 1] != D[i])\n\t\t{\n\t\t\tSD[countd] = start;\n\t\t\tLD[countd] = i - start;\n\t\t\tKD[countd] = D[i - 1];\n\n\t\t\tstart = i;\n\t\t\tcountd += 1;\n\t\t}\n\t}\n\n\tlong long Ans = 0;\n\n\tfor (int x = 0; x <= countx; x++)\n\t{\n\t\tfor (int y = 0; y <= county; y++)\n\t\t{\n\t\t\tfor (int d = 0; d <= countd; d++)\n\t\t\t{\n\t\t\t\tint cnt = 0;\n\n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t{\n\t\t\t\t\tif (X1[i] <= SX[x] && SX[x] < X2[i] && Y1[i] <= SY[y] && SY[y] < Y2[i] && D1[i] <= SD[d] && SD[d] < D2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (cnt >= K)\n\t\t\t\t{\n\t\t\t\t\tAns += 1LL * LX[x] * LY[y] * LD[d];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << Ans << endl;\n\n\treturn 0;\n}\n\n// Time : O ( 3 * MAX_X + 8 * MAX_N ^ 4 )"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n#define MAX_N 50\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint W,H,D,N,K;\nint X1[MAX_N],X2[MAX_N],Y1[MAX_N],Y2[MAX_N],D1[MAX_N],D2[MAX_N];\nvector<int> xl,yl,dl;\n\nint fld[MAX_N * 2][MAX_N*2][MAX_N*2];\n\nint compress(int *x1,int *x2, int w,vector<int> *xs){\n\t\n\trep(i,N){\n\t\t\tint tx1=x1[i], tx2=x2[i];\n\t\t\txs->push_back(tx1);\n\t\t\txs->push_back(tx2);\n\t}\n\tsort(xs->begin(),xs->end());\n\txs->erase(unique(xs->begin(),xs->end()),xs->end());\n\t\n\trep(i,N){\n\t\tx1[i] = find(xs->begin(),xs->end(),x1[i] )- xs->begin();\n\t\tx2[i] = find(xs->begin(),xs->end(),x2[i] )- xs->begin();\n\t}\n\treturn xs->size();\n\t\n}\n\nvoid solve(){\n\tW=compress(X1,X2,W,&xl);\n\tH=compress(Y1,Y2,H,&yl);\n\tD=compress(D1,D2,D,&dl);\n\n\tmemset(fld, 0, sizeof(fld));\n\trep(i,N){\n\t\tfor(int d=D1[i]; d<D2[i]; d++){\n\t\t\tfor(int y = Y1[i]; y<Y2[i];y++){\n\t\t\t\tfor(int x = X1[i]; x<X2[i];x++){\n\t\t\t\t\tfld[d][y][x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long int ans=0;\n\trep(d,D){\n\t\trep(y,H){\n\t\t\trep(x,W){\n\t\t\t\tif(fld[d][y][x]<K)continue;\n\t\t\t\tans+=(xl[x+1]-xl[x])*(yl[y+1]-yl[y])*(dl[d+1]-dl[d]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tscanf(\"%d %d\",&N,&K);\n\tW=H=D=1000000;\n\trep(i,N){\n\t\t//int x1,x2,y1,y2,d1,d2;\n\t\tscanf(\"%d %d %d %d %d %d\",&X1[i],&Y1[i],&D1[i],&X2[i],&Y2[i],&D2[i]);\n\t}\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n \ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n\n#define F first\n#define S second\n\n\n\nstruct Rect\n{\n    int v[3][2];\n    ll calc_area() const\n    {\n        ll res = 1;\n        rep(d, 3)\n        {\n            res *= v[d][1] - v[d][0];\n            assert(v[d][1] > v[d][0]);\n        }\n        return res;\n    }\n};\ntypedef pair<Rect, int> Area; // (rect, num of fishes)\n\nbool intersect(const Rect& a, const Rect& b, Rect& r)\n{\n    rep(d, 3)\n    {\n        r.v[d][0] = max(a.v[d][0], b.v[d][0]);\n        r.v[d][1] = min(a.v[d][1], b.v[d][1]);\n        if (r.v[d][0] >= r.v[d][1])\n            return false;\n    }\n    return true;\n}\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n\n    const int inf = ten(8);\n    Rect inf_rect;\n    rep(d, 3)\n    {\n        inf_rect.v[d][0] = -inf;\n        inf_rect.v[d][1] = inf;\n    }\n\n    vector<Area> area;\n    area.pb(make_pair(inf_rect, 0));\n    rep(fi, n)\n    {\n        Rect fish;\n        rep(i, 2) rep(d, 3)\n            cin >> fish.v[d][i];\n\n        vector<Area> narea;\n        foreach (it, area)\n        {\n            Rect and_rect;\n            if (intersect(fish, it->first, and_rect))\n            {\n                narea.pb(make_pair(and_rect, it->second + 1));\n\n                int bound[3][4];\n                rep(d, 3)\n                {\n                    bound[d][0] = -inf;\n                    bound[d][1] = and_rect.v[d][0];\n                    bound[d][2] = and_rect.v[d][1];\n                    bound[d][3] = inf;\n                }\n\n                rep(i, 3) rep(j, 3) rep(k, 3)\n                {\n                    if (i == 1 && j == 1 && k == 1)\n                    {\n                        // excluding: temp_rect == and_rect\n                        continue;\n                    }\n\n                    Rect temp_rect;\n                    temp_rect.v[0][0] = bound[0][i];\n                    temp_rect.v[0][1] = bound[0][i + 1];\n\n                    temp_rect.v[1][0] = bound[1][j];\n                    temp_rect.v[1][1] = bound[1][j + 1];\n\n                    temp_rect.v[2][0] = bound[2][k];\n                    temp_rect.v[2][1] = bound[2][k + 1];\n\n                    Rect and_r;\n                    if (intersect(temp_rect, it->first, and_r))\n                        narea.pb(make_pair(and_r, it->second));\n                }\n            }\n        }\n\n        area = narea;\n    }\n\n    ll res = 0;\n    foreach (it, area)\n        if (it->second >= k)\n            res += it->first.calc_area();\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint conv(int n, vector<int> &a){\n    vector<int>::iterator it = lower_bound(a.begin(), a.end(), n);\n    if(*it == n){\n        return 2*(it -a.begin()) +1;\n    }\n    return 2*(it -a.begin());\n}\n\nint main(){\n    int n,k;\n    cin >> n >> k;\n    vector<vector<int> > x(n, vector<int>(2)), y(n, vector<int>(2)), d(n, vector<int>(2));\n    vector<int> xr(2*n), yr(2*n), dr(2*n);\n    for(int i=0; i<n; i++){\n        cin >> x[i][0] >> y[i][0] >> d[i][0];\n        cin >> x[i][1] >> y[i][1] >> d[i][1];\n        xr[2*i] = x[i][0];\n        xr[2*i+1] = x[i][1];\n        yr[2*i] = y[i][0];\n        yr[2*i+1] = y[i][1];\n        dr[2*i] = d[i][0];\n        dr[2*i+1] = d[i][1];\n    }\n    sort(xr.begin(), xr.end());\n    xr.erase(unique(xr.begin(), xr.end()), xr.end());\n    sort(yr.begin(), yr.end());\n    yr.erase(unique(yr.begin(), yr.end()), yr.end());\n    sort(dr.begin(), dr.end());\n    dr.erase(unique(dr.begin(), dr.end()), dr.end());\n\n    vector<vector<vector<int> > > field(2*xr.size()+1, vector<vector<int> >(2*yr.size()+1, vector<int>(2*dr.size()+1, 0)));\n    for(int i=0; i<n; i++){\n        for(int j=conv(x[i][0], xr); j<=conv(x[i][1], xr); j++){\n            for(int k=conv(y[i][0], yr); k<=conv(y[i][1], yr); k++){\n                for(int l=conv(d[i][0], dr); l<=conv(d[i][1], dr); l++){\n                    field[j][k][l]++;\n                }\n            }\n        }\n    }\n\n    lli ans = 0;\n    for(int i=2; i<(int)field.size()-2; i+=2){\n        for(int j=2; j<(int)field[0].size()-2; j+=2){\n            for(int l=2; l<(int)field[0][0].size()-2; l+=2){\n                if(field[i][j][l] >= k){\n                    ans += (lli)(xr[i/2] -xr[i/2-1]) *(yr[j/2] -yr[j/2-1]) *(dr[l/2] -dr[l/2-1]);\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint n, k;\n// vector<int> xs, ys, zs;\nmap<int, int> zipx, zipy, zipz;//<???, ??§??????>\nmap<int, int> unzipx, unzipy, unzipz;//<??§??????, ???>\nint num[100][100][100];//???????¨?????????\\??????\n\nint main(void){\n\tcin >> n >> k;\n\tint x1[51], x2[51], y1[51], y2[51], z1[51], z2[51];//?????????????????§?¨?\n\tvector<int> xs, ys, zs;\n\trep(i, n){\n\t\tcin >> x1[i] >> y1[i] >> z1[i];\n\t\tcin >> x2[i] >> y2[i] >> z2[i];\n\t\txs.push_back(x1[i]); xs.push_back(x2[i]);\n\t\tys.push_back(y1[i]); ys.push_back(y2[i]);\n\t\tzs.push_back(z1[i]); zs.push_back(z2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end(), xs.end()));//???????¶????\n\tsort(ys.begin(), ys.end());\n\tys.erase(unique(ys.begin(), ys.end(), ys.end()));\n\tsort(zs.begin(), zs.end());\n\tzs.erase(unique(zs.begin(), zs.end(), zs.end()));\n\n\trep(i, xs.size()){\n\t\tzipx[i] = xs[i];\n\t\tunzipx[xs[i]] = i;\n\t}\n\trep(i, ys.size()){\n\t\tzipy[i] = ys[i];\n\t\tunzipy[ys[i]] = i;\n\t}\n\trep(i, zs.size()){\n\t\tzipz[i] = zs[i];\n\t\tunzipz[zs[i]] = i;\n\t}\n\n\tmemset(num, 0, sizeof(num));\n\tfor (int i = 0; i < n; ++i){\n\t\tfor (int x = unzipx[x1[i]]; x < unzipx[x2[i]]; ++x){\n\t\t\tfor (int y = unzipy[y1[i]]; y < unzipy[x2[i]]; ++y){\n\t\t\t\tfor (int z = unzipz[z1[i]]; z < unzipz[z2[i]]; ++z){\n\t\t\t\t\tnum[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(x, 100)rep(y, 100)rep(z, 100){\n\t\tif(num[x][y][z] >= k) ans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nlong long s=0,n,m,i,j,k,d[3][110],r[3][110],rr[3][110],c[110][110][110],b;\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tscanf(\"%d\",&d[j][i]);\n\t\t\tfor(k=i;k&&d[j][r[j][k-1]]>d[j][i];k--)r[j][k]=r[j][k-1];\n\t\t\tr[j][k]=i;\n\t\t}\n\t}\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<3;j++)rr[j][r[j][i]]=i;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<8;j++){\n\t\t\tb=0;\n\t\t\tfor(k=j;k;k/=2)b+=k%2;\n\t\t\tc[rr[0][i*2+(j/1%2)]][rr[1][i*2+(j/2%2)]][rr[2][i*2+(j/4%2)]]=1-(b%2*2);\n\t\t}\n\t}\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<n*2;j++){\n\t\t\tfor(k=0;k<n*2;k++)c[i][j][k+1]+=c[i][j][k];\n\t\t}\n\t}\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<n*2;j++){\n\t\t\tfor(k=0;k<n*2;k++)c[i][k+1][j]+=c[i][k][j];\n\t\t}\n\t}\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<n*2;j++){\n\t\t\tfor(k=0;k<n*2;k++)c[k+1][i][j]+=c[k][i][j];\n\t\t}\n\t}\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<n*2;j++){\n\t\t\tfor(k=0;k<n*2;k++){\n\t\t\t\tif(c[i][j][k]>=m)s+=(d[0][r[0][i+1]]-d[0][r[0][i]])\n\t\t\t\t\t\t   *(d[1][r[1][j+1]]-d[1][r[1][j]])\n\t\t\t\t\t\t   *(d[2][r[2][k+1]]-d[2][r[2][k]]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n\nll x1[60], x2[60];\nll ya1[60], y2[60];\nll z1[60], z2[60];\nvector<ll>xs, ys, zs;\nll zaatu(int n,int k) {\n\tll ans = 0;\n\tfor (int x = 0; x < xs.size() - 1; x++) {\n\t\tfor (int y = 0; y < ys.size() - 1; y++) {\n\t\t\tfor (int z = 0; z < zs.size() - 1; z++) {\n\t\t\t\tll c = 0;\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (x1[i] <= xs[x] && xs[x + 1] <= x2[i] &&\n\t\t\t\t\t\tya1[i] <= ys[y] && ys[y + 1] <= y2[i] &&\n\t\t\t\t\t\tz1[i] <= zs[z] && zs[z + 1] <= z2[i]) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (c >= k) {\n\t\t\t\t\tans += (xs[x + 1] - xs[x])*(ys[y + 1] - ys[y])*(zs[z + 1] - zs[z]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x1[i] >> ya1[i] >> z1[i] >> x2[i] >> y2[i] >> z2[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t\tys.push_back(ya1[i]);\n\t\tys.push_back(y2[i]);\n\t\tzs.push_back(z1[i]);\n\t\tzs.push_back(z2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\tsort(zs.begin(), zs.end());\n\tcout << zaatu(n, k) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint N,K;\nint ax[100],ay[100],az[100];\nint bx[100],by[100],bz[100];\nvector<long long> cx,cy,cz;\n\nint t[100][100][100];\nbool visited[100][100][100];\n\nvoid add(int ax,int ay,int az,int bx,int by,int bz){\n  for(int x=ax;x<bx;x++)\n    for(int y=ay;y<by;y++)\n      for(int z=az;z<bz;z++)\n\tt[x][y][z]++;\n}\n\nlong long solve(){\n  long long ans=0;\n  for(int i=0;i<N;i++)\n    add(ax[i],ay[i],az[i],bx[i],by[i],bz[i]);\n  for(int x=0;x<(int)cx.size();x++)\n    for(int y=0;y<(int)cy.size();y++)\n      for(int z=0;z<(int)cz.size();z++)\n\tif(t[x][y][z]>=K)\n\t  ans+=(cx[x+1]-cx[x])*(cy[y+1]-cy[y])*(cz[z+1]-cz[z]);\n\n  return ans;\n}\n\nvoid func(int* A,int* B,vector<long long> &C){\n  C.clear();\n  map<int,int> m;\n  vector<int> v;\n  for(int i=0;i<N;i++)v.push_back(A[i]),v.push_back(B[i]);\n  sort(v.begin(),v.end());\n  for(int i=0;i<2*N;i++){\n    if(i&&v[i]==v[i-1])continue;\n    m[v[i]]=C.size();\n    C.push_back(v[i]);\n  }\n  for(int i=0;i<N;i++)A[i]=m[A[i]],B[i]=m[B[i]];\n}\n\nint main(){\n  cin>>N>>K;\n  for(int i=0;i<N;i++)\n    cin>>ax[i]>>ay[i]>>az[i]>>bx[i]>>by[i]>>bz[i];\n  func(ax,bx,cx),func(ay,by,cy),func(az,bz,cz);\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\tstatic ll n,t;\n\tstatic ll x[52][2],y[52][2],z[52][2];\n\t\n\tscanf(\"%lld%lld\",&n,&t);\n\trep(i,n){\n\t\tscanf(\"%lld\",&x[i][0]);\n\t\tscanf(\"%lld\",&y[i][0]);\n\t\tscanf(\"%lld\",&z[i][0]);\n\t\tscanf(\"%lld\",&x[i][1]);\n\t\tscanf(\"%lld\",&y[i][1]);\n\t\tscanf(\"%lld\",&z[i][1]);\n\t}\n\t\n\tstatic vector<ll> Zx,Zy,Zz;\n\trep(i,n){\n\t\tZx.pb( x[i][0] );\n\t\tZx.pb( x[i][1] );\n\t\tZy.pb( y[i][0] );\n\t\tZy.pb( y[i][1] );\n\t\tZz.pb( z[i][0] );\n\t\tZz.pb( z[i][1] );\n\t}\n\tsor(Zx); uniq(Zx);\n\tsor(Zy); uniq(Zy);\n\tsor(Zz); uniq(Zz);\n\t\n\tstatic ll imos[102][102][102] = {};\n\t\n\trep(i,n){\n\t\tll x1 = lb(Zx,x[i][0]) - Zx.begin();\n\t\tll x2 = lb(Zx,x[i][1]) - Zx.begin();\n\t\tll y1 = lb(Zy,y[i][0]) - Zy.begin();\n\t\tll y2 = lb(Zy,y[i][1]) - Zy.begin();\n\t\tll z1 = lb(Zz,z[i][0]) - Zz.begin();\n\t\tll z2 = lb(Zz,z[i][1]) - Zz.begin();\n\t\timos[x1][y1][z1] ++;\n\t\timos[x1][y1][z2] --;\n\t\timos[x1][y2][z1] --;\n\t\timos[x2][y1][z1] --;\n\t\timos[x1][y2][z2] ++;\n\t\timos[x2][y1][z2] ++;\n\t\timos[x2][y2][z1] ++;\n\t\timos[x2][y2][z2] --;\n\t}\n\t\n\trep1(i,101)rep(j,102)rep(k,102)imos[i][j][k] += imos[i-1][j][k];\n\trep(i,102)rep1(j,101)rep(k,102)imos[i][j][k] += imos[i][j-1][k];\n\trep(i,102)rep(j,102)rep1(k,101)imos[i][j][k] += imos[i][j][k-1];\n\t\n\tstatic ll ret = 0;\n\t\n\trep(i,Zx.size()){\n\t\trep(j,Zy.size()){\n\t\t\trep(k,Zz.size()){\n\t\t\t\tif(imos[i][j][k] >= t){\n\t\t\t\t\tret += (Zx[i+1]-Zx[i]) * (Zy[j+1]-Zy[j]) * (Zz[k+1]-Zz[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=599078\n\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define all(c) (c).begin(),(c).end()\nint n,k;\nvector<int> x1,x2,y1_,y2,z1,z2;\nvector<int> fx,fy,fz;\nint grid[101][101][101];\n\nint main(){\n    cin>>n>>k;\n    x1.resize(n);\n    x2.resize(n);\n    y1_.resize(n);\n    y2.resize(n);\n    z1.resize(n);\n    z2.resize(n);\n    fx.resize(n*2);\n    fy.resize(n*2);\n    fz.resize(n*2);\n    rep(i,n){\n        cin>>x1[i]>>y1_[i]>>z1[i]>>x2[i]>>y2[i]>>z2[i];\n        fx[i*2]=x1[i];\n        fx[i*2+1]=x2[i];\n        fy[i*2]=y1_[i];\n        fy[i*2+1]=y2[i];\n        fz[i*2]=z1[i];\n        fz[i*2+1]=z2[i];\n    }\n    sort(all(fx)); fx.erase(unique(all(fx)),fx.end());\n    sort(all(fy)); fy.erase(unique(all(fy)),fy.end());\n    sort(all(fz)); fz.erase(unique(all(fz)),fz.end());\n    memset(grid,0,sizeof(grid));\n    rep(i,n){\n        int clx=lower_bound(all(fx),x1[i])-fx.begin();\n        int crx=lower_bound(all(fx),x2[i])-fx.begin();\n        int cly=lower_bound(all(fy),y1_[i])-fy.begin();\n        int cry=lower_bound(all(fy),y2[i])-fy.begin();\n        int clz=lower_bound(all(fz),z1[i])-fz.begin();\n        int crz=lower_bound(all(fz),z2[i])-fz.begin();\n        loop(iz,clz,crz)loop(iy,cly,cry)loop(ix,clx,crx){\n            grid[iz][iy][ix]++;\n        }\n    }\n    unsigned long long ans=0;\n    rep(ix,fx.size())rep(iy,fy.size())rep(iz,fz.size()){\n        if(grid[iz][iy][ix]>=k){\n            ans+=(unsigned long long)(fx[ix+1]-fx[ix])*(fy[iy+1]-fy[iy])*(fz[iz+1]-fz[iz]);\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint coun[105][105][105];\nvector<int>x,y,z;\nint rx[52][2], ry[52][2], rz[52][2];\nint a[52],b[52],c[52],d[52],e[52],f[52];\nint n,m;\n\nint compress1(){\n\tfor(int i = 0;i < n;i++){\n\t\tx.push_back(a[0]);\n\t\tx.push_back(d[0]);\n\t}\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tfor(int i = 0;i < n;i++){\n\t\trx[i][0] = find(x.begin(),x.end(),a[i])-x.begin();\n\t\trx[i][1] = find(x.begin(),x.end(),d[i])-x.begin();\n\t}\n\treturn 0;\n}\n\nint compress2(){\n\tfor(int i = 0;i < n;i++){\n\t\ty.push_back(b[0]);\n\t\ty.push_back(e[0]);\n\t}\n\tsort(y.begin(), y.end());\n\ty.erase(unique(y.begin(), y.end()), y.end());\n\tfor(int i = 0;i < n;i++){\n\t\try[i][0] = find(y.begin(),y.end(),b[i])-y.begin();\n\t\try[i][1] = find(y.begin(),y.end(),e[i])-y.begin();\n\t}\n\treturn 0;\n}\n\nint compress3(){\n\tfor(int i = 0;i < n;i++){\n\t\tz.push_back(c[0]);\n\t\tz.push_back(f[0]);\n\t}\n\tsort(z.begin(), z.end());\n\tz.erase(unique(z.begin(), z.end()), z.end());\n\tfor(int i = 0;i < n;i++){\n\t\trz[i][0] = find(z.begin(),z.end(),c[i])-z.begin();\n\t\trz[i][1] = find(z.begin(),z.end(),f[i])-z.begin();\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d %d %d %d %d\",&a[i],&b[i],&c[i],&d[i],&e[i],&f[i]);\n\t}\n\tcompress1();\n\tcompress2();\n\tcompress3();\n\tfor(int i = 0;i < n;i++){\n\tfor(int tx=rx[i][0];tx<rx[i][1];tx++)\n    {\n      for(int ty=ry[i][0];ty<ry[i][1];ty++)\n        {\n          for(int tz=rz[i][0];tz<rz[i][1];tz++)\n        {\n          coun[tx][ty][tz]++;\n        }\n        }\n    }\n\t}\n  long long ans=0;\n  for(int i=0;i<=100;i++)\n    {\n      for(int j=0;j<=100;j++)\n    {\n      for(int k=0;k<=100;k++)\n        {\n          if(coun[i][j][k]>=m)\n        {\n          long long s1=(x[i+1]-x[i]),s2=(y[j+1]-y[j]),s3=(z[k+1]-z[k]);\n          ans+=s1*s2*s3;\n        }\n        }\n    }\n    }\n\t//long long ans = 0;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define sc second\n#define pb push_back\ntypedef long long int ll;\ntypedef pair<ll,ll> P;\nint K,N;\nll X1[50],X2[50],Y1[50],Y2[50],Z1[50],Z2[50];\nvector<ll>X,Y,Z;\nint cou[300][300][300];\nint main()\n{\n\tscanf(\"%d%d\",&N,&K);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%lld%lld%lld%lld%lld%lld\",&X1[i],&Y1[i],&Z1[i],&X2[i],&Y2[i],&Z2[i]);\n\t\tX.pb(X1[i]);X.pb(X2[i]);\n\t\tY.pb(Y1[i]);Y.pb(Y2[i]);\n\t\tZ.pb(Z1[i]);Z.pb(Z2[i]);\n\t}\n\tsort(X.begin(),X.end());sort(Y.begin(),Y.end());sort(Z.begin(),Z.end());\n\tX.erase(unique(X.begin(),X.end()),X.end());\n\tY.erase(unique(Y.begin(),Y.end()),Y.end());\n\tZ.erase(unique(Z.begin(),Z.end()),Z.end());\n\tfor(int i=0;i<N;i++){\n\t\tint x1,x2,y1,y2,z1,z2;\n\t\tfor(int j=0;j<(int)X.size();j++){\n\t\t\tif(X[j]==X1[i])x1=j;\n\t\t\tif(X[j]==X2[i])x2=j;\n\t\t}\n\t\tfor(int j=0;j<(int)Y.size();j++){\n\t\t\tif(Y[j]==Y1[i])y1=j;\n\t\t\tif(Y[j]==Y2[i])y2=j;\n\t\t}\n\t\tfor(int j=0;j<(int)Z.size();j++){\n\t\t\tif(Z[j]==Z1[i])z1=j;\n\t\t\tif(Z[j]==Z2[i])z2=j;\n\t\t}\n\t\t//printf(\"%d %d %d %d %d %d\\n\",x1,y1,z1,x2,y2,z2);\n\t\tfor(int x=x1;x<x2;x++){\n\t\t\tfor(int y=y1;y<y2;y++){\n\t\t\t\tfor(int z=z1;z<z2;z++){\n\t\t\t\t\tcou[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=0;i<(int)X.size()-1;i++){\n\t\tfor(int j=0;j<(int)Y.size()-1;j++){\n\t\t\tfor(int k=0;k<(int)Z.size()-1;k++){\n\t\t\t\tif(cou[i][j][k]>=K){\n\t\t\t\t\t//printf(\"%d:%lld %d:%lld %d:%lld\\n\",i,X[i+1]-X[i],j,Y[j+1]-Y[j],k,Z[k+1]-Z[k]);\n\t\t\t\t\tans+=(X[i+1]-X[i])*(Y[j+1]-Y[j])*(Z[k+1]-Z[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nconst int INF = (1e9);\n\nint main(){\n  int N, K;\n  cin >> N >> K;\n  vector<int> X(2*N), Y(2*N), Z(2*N), X2, Y2, Z2;\n  map<int,int> X_, Y_, Z_;\n  for(int i = 0; i < N; ++i){\n    cin >> X[2*i] >> Y[2*i] >> Z[2*i] >> X[2*i+1] >> Y[2*i+1] >> Z[2*i+1];\n    X_[X[2*i]] = 1;\n    X_[X[2*i+1]] = 1;\n    Y_[Y[2*i]] = 1;\n    Y_[Y[2*i+1]] = 1;\n    Z_[Z[2*i]] = 1;\n    Z_[Z[2*i+1]] = 1;\n  }\n  int t = 0;\n  for(auto &x : X_) x.second = t,++t,X2.push_back(x.first);\n  t = 0;\n  for(auto &y : Y_) y.second = t,++t,Y2.push_back(y.first);\n  t = 0;\n  for(auto &z : Z_) z.second = t,++t,Z2.push_back(z.first);\n  int n = X_.size(), m = Y_.size(), o = Z_.size();\n  vector< vector< vector<int> > > S(n+1,vector< vector<int> >(m+1,vector<int>(o+1,0)));\n  \n  for(int i = 0; i < N; ++i){\n    int x = X_[X[2*i]], x2 = X_[X[2*i+1]], y = Y_[Y[2*i]], y2 = Y_[Y[2*i+1]], z = Z_[Z[2*i]], z2 = Z_[Z[2*i+1]];\n    ++S[x][y][z];\n    --S[x2][y][z];\n    --S[x][y2][z];\n    --S[x][y][z2];\n    ++S[x2][y2][z];\n    ++S[x][y2][z2];\n    ++S[x2][y][z2];\n    --S[x2][y2][z2];\n  }\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < m; ++j){\n      for(int k = 0; k < o; ++k){\n        S[i][j][k+1] += S[i][j][k];\n      }\n    }\n  }\n  for(int i = 0; i < n; ++i){\n    for(int k = 0; k < o; ++k){\n      for(int j = 0; j < m; ++j){\n        S[i][j+1][k] += S[i][j][k];\n      }\n    }\n  }\n  for(int k = 0; k < o; ++k){\n    for(int j = 0; j < m; ++j){\n      for(int i = 0; i < n; ++i){\n        S[i+1][j][k] += S[i][j][k];\n      }\n    }\n  }\n  long long ans = 0;\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < m; ++j){\n      for(int k = 0; k < o; ++k){\n        if(S[i][j][k] < K) continue;\n        ans += (long long)(X2[i+1]-X2[i])*(Y2[j+1]-Y2[j])*(Z2[k+1]-Z2[k]);\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MOD 1000000007\n#define MAX_N 64\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nvector<int>X1,X2,Y1,Y2,Z1,Z2,xunzip,yunzip,zunzip;\nmap<int,int>xzip,yzip,zzip;\nint X,Y,Z, N, K;\nint sea[128][128][128];\n\nint compress(vector<int> &x1, vector<int>&x2, map<int,int> &zip, vector<int> &unzip){\n  vector<int>xs;\n  /*  for(int i=0;i<N;i++){\n    for(int d=-1;d<=1;d++){\n      int tx1 = x1[i]+d, tx2 = x2[i]+d;\n      if(0<=tx1 && tx1 <= 1000000) xs.push_back(tx1);\n      if(0<=tx2 && tx2 <= 1000000) xs.push_back(tx2);\n    }\n    }*/\n  rep(i, N) xs.push_back(x1[i]), xs.push_back(x2[i]);\n\n\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.end());\n  for(int i=0;i<xs.size();i++){\n    zip[xs[i]] = i;\n    unzip[i] = xs[i];\n  }\n  return xs.size();\n}\n\nint main(){\n  scanf(\"%d%d\", &N, &K);\n  X1.resize(N); X2.resize(N); Y1.resize(N); Y2.resize(N); Z1.resize(N); Z2.resize(N);\n  xunzip.resize(128); yunzip.resize(128), zunzip.resize(128);\n  rep(i, N){\n    scanf(\"%d%d%d%d%d%d\", &X1[i], &Y1[i], &Z1[i], &X2[i], &Y2[i], &Z2[i]);\n  }\n\n  X = compress(X1, X2, xzip, xunzip);\n  Y = compress(Y1, Y2, yzip, yunzip);\n  Z = compress(Z1, Z2, zzip, zunzip);\n\n\n\n  memset(sea, 0, sizeof(sea));\n  int x,y,z;\n  rep(i, N){\n    REP(x, xzip[X1[i]], xzip[X2[i]]){\n      REP(y, yzip[Y1[i]], yzip[Y2[i]]){\n\tREP(z, zzip[Z1[i]], zzip[Z2[i]]){\n\t  sea[z][y][x]++;\n\t}\n      }\n    }\n  }\n\n  /*  rep(z, Z-1){\n    rep(y, Y-1){\n      rep(x, X-1) printf(\"%d\", sea[z][y][x]);\n      puts(\"\");\n    }\n    puts(\"\");\n    }*/\n\n  ll res = 0;\n  rep(z, Z-1) rep(y, Y-1) rep(x, X-1){\n    if(sea[z][y][x]<K) continue;\n    res += (ll)(zunzip[z+1]-zunzip[z]) * (ll)(yunzip[y+1]-yunzip[y]) * (ll)(xunzip[x+1]-xunzip[x]);\n  }\n  printf(\"%lld\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// JOI 2012-2013 予選5\n#include<algorithm>\n#include<iostream>\n\ntypedef long long ll;\n\nint N, K;\nll X1[50], Y1[50], D1[50];\nll X2[50], Y2[50], D2[50];\nll xs[100], ys[100], ds[100];\nint xl, yl, dl;\n\nint main()\n{\n\tstd::cin >> N >> K;\n\tfor( int i = 0; i != N; ++i )\n\t{\n\t\tstd::cin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t\t\n\t\txs[xl++] = X1[i]; ys[yl++] = Y1[i]; ds[dl++] = D1[i];\n\t\txs[xl++] = X2[i]; ys[yl++] = Y2[i]; ds[dl++] = D2[i];\n\t}\n\n\tstd::sort( xs, xs + xl ); std::sort( ys, ys + yl ); std::sort( ds, ds + dl );\n\n\tll ans = 0;\n\tfor( int a = 0; a != xl - 1; ++a )\n\t{\n\t\tfor( int b = 0; b != yl - 1; ++b )\n\t\t{\n\t\t\tfor( int c = 0; c != dl - 1; ++c )\n\t\t\t{\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor( int i = 0; i != N; ++i )\n\t\t\t\t{\n\t\t\t\t\tif( X1[i] <= xs[a] && xs[a + 1] <= X2[i] \n\t\t\t\t\t && Y1[i] <= ys[b] && ys[b + 1] <= Y2[i] \n\t\t\t\t\t && D1[i] <= ds[c] && ds[c + 1] <= D2[i] )\n\t\t\t\t\t\t++cnt;\n\t\t\t\t}\n\n\t\t\t\tif( cnt >= K )\n\t\t\t\t\tans += ( xs[a + 1] - xs[a] ) * ( ys[b + 1] - ys[b] ) * ( ds[c + 1] - ds[c] );\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n\n    vector<map<int, int> > index(3);\n    vector<vector<int> > x, y, z;\n    x = y = z = vector<vector<int> >(n, vector<int>(2));\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<2; ++j){\n            cin >> x[i][j] >> y[i][j] >> z[i][j];\n            index[0][x[i][j]];\n            index[1][y[i][j]];\n            index[2][z[i][j]];\n        }\n    }\n\n    vector<vector<int> > p(3);\n    for(int i=0; i<3; ++i){\n        int j = 0;\n        for(map<int, int>::iterator it=index[i].begin(); it!=index[i].end(); ++it){\n            p[i].push_back(it->first);\n            it->second = j;\n            ++ j;\n        }\n    }\n\n    int nx = index[0].size() - 1;\n    int ny = index[1].size() - 1;\n    int nz = index[2].size() - 1;\n    vector<vector<vector<int> > > s(nx, vector<vector<int> >(ny, vector<int>(nz, 0)));\n    for(int i=0; i<n; ++i){\n        for(int a=index[0][x[i][0]]; a<index[0][x[i][1]]; ++a){\n            for(int b=index[1][y[i][0]]; b<index[1][y[i][1]]; ++b){\n                for(int c=index[2][z[i][0]]; c<index[2][z[i][1]]; ++c){\n                    ++ s[a][b][c];\n                }\n            }\n        }\n    }\n\n    long long ret = 0;\n    for(int a=0; a<nx; ++a){\n        for(int b=0; b<ny; ++b){\n            for(int c=0; c<nz; ++c){\n                if(s[a][b][c] >= k){\n                    ret += (long long)(p[0][a+1] - p[0][a]) * (p[1][b+1] - p[1][b]) * (p[2][c+1] - p[2][c]);\n                }\n            }\n        }\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n#define FI first\n#define SE second\n#define PB push_back\n#define MT make_tuple\n#defineint long long\nusing namespace std;\n\nint N,K;\nint fld[105][105][105];\nint X1[55],X2[55],Y1[55],Y2[55],Z1[55],Z2[55];\nvector<int> X,Y,Z;\n\nvector<int> compress(int *x1,int *x2){\n    vector<int> xs;\n    for(int i=0;i<N;++i){\n        xs.PB(x1[i]);\n        xs.PB(x2[i]);\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    vector<int> length;\n    for(int i=0;i<xs.size()-1;++i){\n        length.PB(xs[i+1]-xs[i]);\n    }\n    return length;\n}\n\n\nsigned main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    X=compress(X1,X2);\n    Y=compress(Y1,Y2);\n    Z=compress(Z1,Z2);\n    for(int i=0;i<N;++i){\n        for(int x=X1[i];x<X2[i];++x){\n            for(int y=Y1[i];y<Y2[i];++y){\n                for(int z=Z1[i];z<Z2[i];++z){\n                    fld[x][y][z]++;\n                }\n            }\n        }\n    }\n    int ans=0;\n    for(int x=0;x<X.size();++x){\n        for(int y=0;y<Y.size();++y){\n            for(int z=0;z<Z.size();++z){\n                if(fld[x][y][z]>=K)ans+=X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct square{\n    long long x1,y1,z1,x2,y2,z2;\n};\n\nvector<square> rippous;\nset<long long> xs, ys, zs;\nmap<long long, long long>transx, transy, transz;\nlong long field[100][100][100];\nlong long xx[100], yy[100], zz[100], K, n;\nlong long res;\nint main(){\n    cin >> n >> K;\n    for(long long i = 0;i < n;i++){\n\tsquare tmp;\n\tcin >> tmp.x1 >> tmp.y1 >> tmp.z1 >> tmp.x2 >> tmp.y2 >> tmp.z2;\n\trippous.push_back(tmp);\n\txs.insert(tmp.x1);xs.insert(tmp.x2);\n\tys.insert(tmp.y1);ys.insert(tmp.y2);\n\tzs.insert(tmp.z1);zs.insert(tmp.z2);\n    }\n    long long tttt;\n    set<long long>::iterator it = xs.begin();\n    long long ii = 0;\n    while(it != xs.end()){\n\txx[ii] = *it;\n\ttransx[*it] = ii;\n\tit++;\n\tii++;\n    }\n    ii = 0;\n    it = ys.begin();\n    while(it != ys.end()){\n\tyy[ii] = *it;\n\ttransy[*it] = ii;\n\tit++;\n\tii++;\n    }\n    ii = 0;\n    it = zs.begin();\n    while(it != zs.end()){\n\tzz[ii] = *it;\n\ttransz[*it] = ii;\n\tit++;\n\tii++;\n    }\n    for(long long i = 0;i < rippous.size();i++){\n\tsquare tmp = rippous[i];\n\ttmp.x1 = transx[tmp.x1];\n\ttmp.x2 = transx[tmp.x2];\n\ttmp.y1 = transy[tmp.y1];\n\ttmp.y2 = transy[tmp.y2];\n\ttmp.z1 = transz[tmp.z1];\n\ttmp.z2 = transz[tmp.z2];\n\tfield[tmp.x1][tmp.y1][tmp.z1] ++;\n\tfield[tmp.x2][tmp.y1][tmp.z1] --;\n\tfield[tmp.x1][tmp.y2][tmp.z1] --;\n\tfield[tmp.x2][tmp.y2][tmp.z1] ++;\n\tfield[tmp.x1][tmp.y1][tmp.z2] --;\n\tfield[tmp.x2][tmp.y1][tmp.z2] ++;\n\tfield[tmp.x1][tmp.y2][tmp.z2] ++;\n\tfield[tmp.x2][tmp.y2][tmp.z2] --;\n    }\n    for(long long i = 1;i < xs.size();i++){\n\tfor(long long j = 0;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tfield[i][j][k] += field[i - 1][j][k];\n\t    }\n\t}\n    }\n    for(long long i = 0;i < xs.size();i++){\n\tfor(long long j = 1;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tfield[i][j][k] += field[i][j - 1][k];\n\t    }\n\t}\n    }\n    for(long long i = 0;i < xs.size();i++){\n\tfor(long long j = 1;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tfield[i][j][k] += field[i][j][k - 1];\n\t    }\n\t}\n    }\n    for(long long i = 0;i < xs.size();i++){\n\tfor(long long j = 0;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tif(field[i][j][k] >= K) \n\t\t    res += (xx[i + 1] - xx[i]) * (yy[j + 1] - yy[j]) * (zz[k + 1] - zz[k]);\n\t    }\n\t}\n    } \n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, kk;\nint sea[110][110][110];\nint xx1[55], yy1[55], dd1[55], xx2[55], yy2[55], dd2[55];\nint x[110], y[110], d[110];\nlong long int ans = 0;\n\nint main()\n{\n  cin >> n >> kk;\n\n  for(int i = 0; i < n; i++)\n    cin >> xx1[i] >> yy1[i] >> dd1[i] >> xx2[i] >> yy2[i] >> dd2[i];\n\n  for(int i = 0; i < n; i++){\n    x[2 * i] = xx1[i];\n    x[2 * i + 1] = xx2[i];\n  }\n  for(int i = 0; i < n; i++){\n    y[2 * i] = yy1[i];\n    y[2 * i + 1] = yy2[i];\n  }\n  for(int i = 0; i < n; i++){\n    d[2 * i] = dd1[i];\n    d[2 * i + 1] = dd2[i];\n  }\n\n  sort(x, x + 2 * n);\n  sort(y, y + 2 * n);\n  sort(d, d + 2 * n);\n\n  for(int i = 0; i < 2 * n - 1; i++)\n    for(int j = 0; j < 2 * n - 1; j++)\n      for(int k = 0; k < 2 * n - 1; k++){\n\tint many = 0;\n\tfor(int l = 0; l < n; l++)\n\t  if(xx1[l] <= x[i] && x[i + 1] <= xx2[l] && yy1[l] <= y[j] && y[j + 1] <= yy2[l] && dd1[l] <= d[k] && d[k + 1] <= dd2[l])\n\t    many++;\n\t\n\tif(many >= kk)\n\t  ans += (long long int)(x[i + 1] - x[i]) * (long long int)(y[j + 1] - y[j]) * (long long int)(d[k + 1] - d[k]);\n\t\n      }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,a;\n  vector<long long> grx,gry,grz;\n  long long x1[50],y1[50],z1[50],x2[50],y2[50],z2[50];\n  int used[100][100][100] = {};\n  cin >> n >> a;\n  for(int i=0;i<n;i++){\n    cin >> x1[i] >> y1[i] >> z1[i] >> x2[i] >> y2[i] >> z2[i];\n    grx.push_back(x1[i]);\n    grx.push_back(x2[i]);\n    gry.push_back(y1[i]);\n    gry.push_back(y2[i]);\n    grz.push_back(z1[i]);\n    grz.push_back(z2[i]);\n  }\n  sort(grx.begin(),grx.end());\n  grx.erase(unique(grx.begin(),grx.end()),grx.end());\n  sort(gry.begin(),gry.end());\n  gry.erase(unique(gry.begin(),gry.end()),gry.end());\n  sort(grz.begin(),grz.end());\n  grz.erase(unique(grz.begin(),grz.end()),grz.end());\n\n  long long sum = 0;\n\n  for(int i=0;i<grx.size()-1;i++)\n    for(int j=0;j<gry.size()-1;j++) \n      for(int k=0;k<grz.size()-1;k++){\n\t\n\tfor(int l=0;l<n;l++){\n\t  if(grx[i] >= x1[l] && grx[i+1] <= x2[l] && gry[j] >= y1[l] && gry[j+1] <= y2[l] && grz[k] >= z1[l] && grz[k+1] <= z2[l]){\n\t    used[i][j][k]++;\n\t    if(used[i][j][k] == a) sum += (grx[i+1]-grx[i]) * (gry[j+1]-gry[j]) * (grz[k+1]-grz[k]); \n\t  }\n\t}\n\t\n      }\n\n  cout << sum << endl;\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <string>\nconst int INF = 1 << 30;\nusing namespace std;\n\nint n, k;\n\nint pt[300][300][300];\nint X1[50], X2[50], Y1[50], Y2[50], D1[50], D2[50];\nlong long int uX[300], uY[300], uD[300];\n\nint compress(int *x1, int *x2, long long int *unzip){\n\tvector<int> vec;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = -1; j <= 1; j++){\n\t\t\tint a = x1[i] + j, b = x2[i] + j;\n\t\t\tif (0 <= a) vec.push_back(a);\n\t\t\tif (0 <= b) vec.push_back(b);\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tfor (int i = 0; i < n; i++){\n\t\tx1[i] = find(vec.begin(), vec.end(), x1[i]) - vec.begin();\n\t\tx2[i] = find(vec.begin(), vec.end(), x2[i]) - vec.begin();\n\t}\n\tfor (int i = 0; i < vec.size(); i++)\n\t\tunzip[i] = vec[i];\n\treturn vec.size();\n}\n\nint main(){\n\tint W, H, D;\n\tlong long int ans = 0;\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i];\n\t\tcin >> X2[i] >> Y2[i] >> D2[i];\n\t}\n\tW = compress(X1, X2, uX);\n\tH = compress(Y1, Y2, uY);\n\tD = compress(D1, D2, uD);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = X1[i]; j < X2[i]; j++){\n\t\t\tfor (int m = Y1[i]; m < Y2[i]; m++){\n\t\t\t\tfor (int l = D1[i]; l < D2[i]; l++){\n\t\t\t\t\tpt[j][m][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int m = 0; m <D; m++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tfor (int i = 0; i < W;i++){\n\t\t\t\tif (pt[i][j][m] >= k&&uX[i + 1] && uY[j + 1] && uD[m + 1]){\n\t\t\t\t\t\tans += (uX[i+1] - uX[i]) * (uY[j+1] - uY[j]) * (uD[m+1] - uD[m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0580\n#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\n#define REP(i,n) for(integer i=0;i<(int)(n);i++)\nusing namespace std;\n\ntypedef long long int integer;\n\nconst integer NNMAX = 200, NMAX = 50;\nconst integer INF = 1e6 + 10;\ninteger N, K;\ninteger X1[NMAX], X2[NMAX], Y1[NMAX], Y2[NMAX], Z1[NMAX], Z2[NMAX];\n\nvector<int> CX, CY, CZ;\ninteger volume[NNMAX][NNMAX][NNMAX];\ninteger kinds[NNMAX][NNMAX][NNMAX];\n\ninteger solve() {\n  set<integer> xs, ys, zs;\n  for (integer i = 0; i < N; i++) { xs.insert(X1[i]); xs.insert(X2[i]); }\n  for (integer x : xs) CX.push_back(x);\n  \n  for (integer i = 0; i < N; i++) { ys.insert(Y1[i]); ys.insert(Y2[i]); }\n  for (integer y : ys) CY.push_back(y);\n\n  for (integer i = 0; i < N; i++) { zs.insert(Z1[i]); zs.insert(Z2[i]); }\n  for (integer z : zs) CZ.push_back(z);\n\n  sort(CX.begin(), CX.end());\n  sort(CY.begin(), CY.end());\n  sort(CZ.begin(), CZ.end());\n\n  CX.push_back(INF);\n  CY.push_back(INF);\n  CZ.push_back(INF);\n\n  REP(i, N) {\n    auto xl = lower_bound(CX.begin(), CX.end(), X1[i]) - CX.begin(),\n         xu = upper_bound(CX.begin(), CX.end(), X2[i]) - CX.begin(),\n         yl = lower_bound(CY.begin(), CY.end(), Y1[i]) - CY.begin(),\n         yu = upper_bound(CY.begin(), CY.end(), Y2[i]) - CY.begin(),\n         zl = lower_bound(CZ.begin(), CZ.end(), Z1[i]) - CZ.begin(),\n         zu = upper_bound(CZ.begin(), CZ.end(), Z2[i]) - CZ.begin();\n    \n    kinds[xl][yl][zl]++;\n    kinds[xu][yl][zl]--;\n    kinds[xl][yu][zl]--;\n    kinds[xl][yl][zu]--;\n    kinds[xu][yu][zl]++;\n    kinds[xu][yl][zu]++;\n    kinds[xl][yu][zu]++;\n    kinds[xu][yu][zu]--;\n  }\n\n  integer xm = CX.size(), ym = CY.size(), zm = CZ.size();\n  \n  for (integer x : xs) { cout << x << \",\"; } cout << endl;\n  for (integer y : ys) { cout << y << \",\"; } cout << endl;\n  for (integer z : zs) { cout << z << \",\"; } cout << endl;\n\n  REP(x,xm-1) REP(y,ym-1) REP(z,zm-1) {\n    volume[x][y][z] = \n      (CX[x+1]-CX[x])*(CY[y+1]-CY[y])*(CZ[z+1]-CZ[z]);\n  }\n\n  REP(x,xm-1) REP(y,ym) REP(z,zm) { \n    kinds[x+1][y][z] += kinds[x][y][z];\n  }\n  REP(x,xm) REP(y,ym-1) REP(z,zm) { \n    kinds[x][y+1][z] += kinds[x][y][z];\n  }\n  REP(x,xm) REP(y,ym) REP(z,zm-1) { \n    kinds[x][y][z+1] += kinds[x][y][z];\n  }\n\n  integer sum = 0;\n  REP(x,xm-1) REP(y,ym-1) REP(z,zm-1) {\n    if (kinds[x][y][z] >= K) {\n      cout << \"(\" << x << \",\" << y << \",\" << z << \")\" <<\n        volume[x][y][z] << endl;\n      sum += volume[x][y][z];\n    }\n  }\n\n  return sum;\n}\n\nint main() {\n  cin >> N >> K;\n  for (integer i = 0; i < N; i++) {\n    cin >> X1[i] >> Y1[i] >> Z1[i]\n      >> X2[i] >> Y2[i] >> Z2[i];\n  }\n\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n\n#define N\t60\n\nusing namespace std;\n\n\nint main()\n{\n\tint n , K;\n\tint x1[N] , x2[N] , d1[N] , y1[N] , y2[N] , d2[N];\n\tint x_copy[N * 2] , y_copy[N * 2] , d_copy[N * 2];\n\tlong long int ans = 0;\n\n\tcin >> n >> K;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> x1[i] >> y1[i] >> d1[i] >> x2[i] >> y2[i] >> d2[i];\n\t}\n\n\tint a = 0;\n\t//ソートのために１つの配列にまとめる\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tx_copy[a] = x1[i];\n\t\tx_copy[a + 1] = x2[i];\n\n\t\ty_copy[a] = y1[i];\n\t\ty_copy[a + 1] = y2[i];\n\n\t\td_copy[a] = d1[i];\n\t\td_copy[a + 1] = d2[i];\n\n\t\ta += 2;\n\t}\n\n\t//ソート\n\tsort(x_copy , x_copy + a);\n\tsort(y_copy , y_copy + a);\n\tsort(d_copy , d_copy + a);\n\n\t//コピー配列は小さい体積でできており、その中にいる魚の数を数える\n\tfor (int i = 0; i < a - 1; i++)\n\t{\n\t\tfor (int j = 0; j < a - 1; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < a - 1; k++)\n\t\t\t{\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int l = 0; l < n; l++)\n\t\t\t\t{\n\t\t\t\t\t//lは大元の配列を表していて、i,j,kほ各容積の縦・横・高さを表す\n\t\t\t\t\tif (x1[l] <= x_copy[i] && x_copy[i + 1] <= x2[l] &&\n\t\t\t\t\t\ty1[l] <= y_copy[j] && y_copy[j + 1] <= y2[l] &&\n\t\t\t\t\t\td1[l] <= d_copy[k] && d_copy[k + 1] <= d2[l])\n\t\t\t\t\t{\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//カウント変数が最低限の魚の数より多い\n\t\t\t\tif (cnt >= K)\n\t\t\t\t{\n\t\t\t\t\tans += (long long)(x_copy[i + 1] - x_copy[i]) * (y_copy[j + 1] - y_copy[j]) * (d_copy[k + 1] - d_copy[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\ntypedef struct data\n{\n\tlong long int x1;\n\tlong long int y1;\n\tlong long int d1;\n\tlong long int x2;\n\tlong long int y2;\n\tlong long int d2;\n} data;\n\nint main()\n{\n\tlong long int n, K;\n\tcin >> n >> K;\n\tvector<data> v;\n\tlong long int x[101], y[101], d[101];\n\tfor(int i = 0; i < 2 * n; i += 2){\n\t\tcin >> x[i] >> y[i] >> d[i];\n\t\tcin >> x[i + 1] >> y[i + 1] >> d[i + 1];\n\t\tdata tmp;\n\t\ttmp.x1 = x[i];\n\t\ttmp.x2 = x[i + 1];\n\t\ttmp.y1 = y[i];\n\t\ttmp.y2 = y[i + 1];\n\t\ttmp.d1 = d[i];\n\t\ttmp.d2 = d[i + 1];\n\t\tv.push_back(tmp);\n\t}\n\tsort(x, x + 2 * n);\n\tsort(y, y + 2 * n);\n\tsort(d, d + 2 * n);\n\tint result[110][110][110] = {};\n\tfor(int i = 0; i < n; i++){\n\t\tdata tmp = v[i];\n\t\tlong long int x1 = lower_bound(x, x + 2 * n, tmp.x1) - x;\n\t\tlong long int x2 = lower_bound(x, x + 2 * n, tmp.x2) - x;\n\t\tlong long int y1 = lower_bound(y, y + 2 * n, tmp.y1) - y;\n\t\tlong long int y2 = lower_bound(y, y + 2 * n, tmp.y2) - y;\n\t\tlong long int d1 = lower_bound(d, d + 2 * n, tmp.d1) - d;\n\t\tlong long int d2 = lower_bound(d, d + 2 * n, tmp.d2) - d;\n\t\tresult[x1][y1][d1]++;\n\t\tresult[x1][y2][d1]--;\n\t\tresult[x2][y1][d1]--;\n\t\tresult[x2][y2][d1]++;\n\t\tresult[x1][y1][d2]--;\n\t\tresult[x1][y2][d2]++;\n\t\tresult[x2][y1][d2]++;\n\t\tresult[x2][y2][d2]--;\n\t}\n\tfor(int i = 0; i < 110; i++){\n\t\tfor(int j = 0; j < 110; j++){\n\t\t\tfor(int k = 1; k < 110; k++){\n\t\t\t\tresult[k][i][j] += result[k - 1][i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < 110; i++){\n\t\tfor(int j = 0; j < 110; j++){\n\t\t\tfor(int k = 1; k < 110; k++){\n\t\t\t\tresult[i][k][j] += result[i][k - 1][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < 110; i++){\n\t\tfor(int j = 0; j < 110; j++){\n\t\t\tfor(int k = 1; k < 110; k++){\n\t\t\t\tresult[i][j][k] += result[i][j][k - 1];\n\t\t\t}\n\t\t}\n\t}\n\t// for(int i = 0; i < 10; i++){\n\t// \tfor(int j = 0; j < 10; j++){\n\t// \t\tfor(int k = 0; k < 10; k++){\n\t// \t\t\tcout << x[i] << \" \" << y[j] << \" \" << d[k] << \" \" << result[i][j][k] << endl;\n\t// \t\t}\n\t// \t}\n\t// }\n\tlong long int ans = 0;\n\tfor(int i = 0; i < 110; i++){\n\t\tfor(int j = 0; j < 110; j++){\n\t\t\tfor(int k = 0; k < 110; k++){\n\t\t\t\tif(result[i][j][k] >= K){\n\t\t\t\t\tans += (x[i + 1] - x[i]) * (y[j + 1] - y[j]) * (d[k + 1] - d[k]);\n\t\t\t\t\t// cout << i << \" \" << j << \" \" << k << result[i][j][k] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n\nll x1[60], x2[60];\nll ya1[60], y2[60];\nll z1[60], z2[60];\nvector<ll>xs, ys, zs;\nll zaatu(int n,int k) {\n\tll ans = 0;\n\tfor (int x = 0; x < xs.size() - 1; x++) {\n\t\tfor (int y = 0; y < ys.size() - 1; y++) {\n\t\t\tfor (int z = 0; z < zs.size() - 1; z++) {\n\t\t\t\tll c = 0;\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (x1[i] <= xs[x] && xs[x + 1] <= x2[i] &&\n\t\t\t\t\t\tya1[i] <= ys[y] && ys[y + 1] <= y2[i] &&\n\t\t\t\t\t\tz1[i] <= zs[z] && zs[z + 1] <= z2[i]) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (c >= k) {\n\t\t\t\t\tans += (xs[x + 1] - xs[x])*(ys[y + 1] - ys[y])*(zs[z + 1] - zs[z]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x1[i] >> x2[i] >> ya1[i] >> y2[i] >> z1[i] >> z2[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t\tys.push_back(ya1[i]);\n\t\tys.push_back(y2[i]);\n\t\tzs.push_back(z1[i]);\n\t\tzs.push_back(z2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\tsort(zs.begin(), zs.end());\n\tcout << zaatu(n, k) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_N = 55;\n\nclass C{\n  public:\n    int x1, x2, y1, y2, d1, d2;\n    C(int _x1, int _x2, int _y1, int _y2, int _d1, int _d2){\n      x1 = _x1; x2 = _x1;\n      y1 = _y1; y2 = _y1;\n      d1 = _d1; d2 = _d1;\n    }\n    C(){}\n};\n\nvector<int> X, Y, D;\nint f[MAX_N * 2][MAX_N * 2][MAX_N * 2];\n\nint main() {\n  int N, K; cin >>N >>K;\n  vector<C> v(N);\n  set<int> xs, ys, ds;\n  REP(i, N){\n    cin >>v[i].x1 >>v[i].y1 >>v[i].d1 >>v[i].x2 >>v[i].y2 >>v[i].d2;\n    xs.insert(v[i].x1); xs.insert(v[i].x2);\n    ys.insert(v[i].y1); ys.insert(v[i].y2);\n    ds.insert(v[i].d1); ds.insert(v[i].d2);\n    //X[i * 2] = v[i].x1;\n    //X[i * 2 + 1] = v[i].x2;\n    //Y[i * 2] = v[i].y1;\n    //Y[i * 2 + 1] = v[i].y2;\n    //D[i * 2] = v[i].d1;\n    //D[i * 2 + 1] = v[i].d2;\n  }\n  X = vector<int>(xs.begin(), xs.end());\n  Y = vector<int>(ys.begin(), ys.end());\n  D = vector<int>(ds.begin(), ds.end());\n\n  map<int, int> dex, dey, ded;\n  REP(i, X.size()) dex[X[i]] = i;\n  REP(i, Y.size()) dey[Y[i]] = i;\n  REP(i, D.size()) ded[D[i]] = i;\n\n  //for(map<int, int>::iterator it = dex.begin(); it != dex.end(); ++it) cout <<it->first <<\", \" <<it->second <<endl;\n\n  REP(i, v.size()){\n    int nowx1 = dex[v[i].x1]; int nowx2 = dex[v[i].x2];\n    int nowy1 = dey[v[i].y1]; int nowy2 = dey[v[i].y2];\n    int nowd1 = ded[v[i].d1]; int nowd2 = ded[v[i].d2];\n    FOR(x, nowx1, nowx2)\n      FOR(y, nowy1, nowy2)\n        FOR(d, nowd1, nowd2) f[x][y][d] += 1;\n  }\n\n  long long int ans = 0;\n  REP(x, X.size()){\n    REP(y, Y.size()){\n      REP(d, D.size()){\n        if (f[x][y][d] < K) continue;\n        //cout <<\"========\" <<endl;\n        //cout <<x <<\", \" <<y <<\", \" <<d <<endl;\n        long long int dx = X[x + 1] - X[x];\n        long long int dy = Y[y + 1] - Y[y];\n        long long int dd = D[d + 1] - D[d];\n        //cout <<dx <<\", \" <<dy <<\", \" <<dd <<endl;\n        ans += dx * dy * dd;\n      }\n    }\n  }\n  cout <<ans <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <string>\nconst int INF = 1 << 30;\nusing namespace std;\n\nint n, k;\n\nint pt[150][150][150];\nint X1[50], X2[50], Y1[50], Y2[50], D1[50], D2[50];\nunsigned long long int uX[150], uY[150], uD[150];\n\nint compress(int *x1, int *x2, unsigned long long int *unzip){\n\tvector<int> vec;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = -1; j <= 1; j++){\n\t\t\tint a = x1[i] + j, b = x2[i] + j;\n\t\t\tif (0 <= a) vec.push_back(a);\n\t\t\tif (0 <= b) vec.push_back(b);\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tfor (int i = 0; i < n; i++){\n\t\tx1[i] = find(vec.begin(), vec.end(), x1[i]) - vec.begin();\n\t\tx2[i] = find(vec.begin(), vec.end(), x2[i]) - vec.begin();\n\t}\n\tfor (int i = 0; i < vec.size(); i++)\n\t\tunzip[i] = vec[i];\n\treturn vec.size();\n}\n\nint main(){\n\tint W, H, D;\n\tunsigned long long int ans = 0;\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i];\n\t\tcin >> X2[i] >> Y2[i] >> D2[i];\n\t}\n\tW = compress(X1, X2, uX);\n\tH = compress(Y1, Y2, uY);\n\tD = compress(D1, D2, uD);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = X1[i]; j < X2[i]; j++){\n\t\t\tfor (int m = Y1[i]; m < Y2[i]; m++){\n\t\t\t\tfor (int l = D1[i]; l < D2[i]; l++){\n\t\t\t\t\tpt[j][m][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int m = 0; m <D; m++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tfor (int i = 0; i < W;i++){\n\t\t\t\tif (pt[i][j][m] >= k&&uX[i + 1] && uY[j + 1] && uD[m + 1]){\n\t\t\t\t\t\tans += (uX[i+1] - uX[i]) * (uY[j+1] - uY[j]) * (uD[m+1] - uD[m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\n\n\nint N,K;\nint X1[51],Y1[51],D1[51],X2[51],Y2[51],D2[51];\n\nset<int> xset,yset,dset;\ntypedef pair<int,pii>  point;\ntypedef pair<point,point> tpl;\nset<tpl> ps;\n\nint main(){\n  \n\n  cin>>N>>K;\n  for(int i=0;i<N;i++){\n    cin>>X1[i]>>Y1[i]>>D1[i]>>X2[i]>>Y2[i]>>D2[i];\n    xset.insert(X1[i]);\n    yset.insert(Y1[i]);\n    dset.insert(D1[i]);\n    xset.insert(X2[i]);\n    yset.insert(Y2[i]);\n    dset.insert(D2[i]);\n  }\n  for(int i=0;i<N;i++){\n    vector<int> xs,ys,ds;\n    xs.push_back(X1[i]),xs.push_back(X2[i]);\n    ys.push_back(Y1[i]),ys.push_back(Y2[i]);\n    ds.push_back(D1[i]),ds.push_back(D2[i]);\n    for(set<int>::iterator it1=xset.begin();it1!=xset.end();it1++){\n      int x=*it1;\n      if(X1[i]<x&&X2[i]>x){\n        xs.push_back(x);\n      }\n    }\n    for(set<int>::iterator it2=yset.begin();it2!=yset.end();it2++){\n      int y=*it2;\n      if(Y1[i]<y&&Y2[i]>y){\n        ys.push_back(y);\n      }\n    }\n    for(set<int>::iterator it3=dset.begin();it3!=dset.end();it3++){\n      int d=*it3;\n      if(D1[i]<d&&D2[i]>d){\n        ds.push_back(d);\n      }\n    }\n    sort(xs.begin(),xs.end());\n    sort(ys.begin(),ys.end());\n    sort(ds.begin(),ds.end());\n    for(int k=1;k<(int)ds.size();k++){\n      for(int j=1;j<(int)ys.size();j++){\n        for(int i=1;i<(int)xs.size();i++){\n          int minx=xs[i-1];\n          int miny=ys[j-1];\n          int mind=ds[k-1];\n          int maxx=xs[i];\n          int maxy=ys[j];\n          int maxd=ds[k];\n          ps.insert(make_pair(make_pair(minx,pii(miny,mind))\n                              ,make_pair(maxx,pii(maxy,maxd))));\n        }\n      }\n    }\n  }\n  ll ans=0;\n  for(set<tpl>::iterator it=ps.begin();it!=ps.end();it++){\n    point p1=it->first;\n    point p2=it->second;\n    int cnt=0;\n    ll minx=p1.first;\n    ll miny=p1.second.first;\n    ll mind=p1.second.second;\n    ll maxx=p2.first;\n    ll maxy=p2.second.first;\n    ll maxd=p2.second.second;\n    for(int i=0;i<N;i++){\n      if(X1[i]<=minx&&maxx<=X2[i]\n         &&Y1[i]<=miny&&maxy<=Y2[i]\n         &&D1[i]<=mind&&maxd<=D2[i]){\n        cnt++;\n      }\n    }\n    if(cnt>=K)ans+=(maxx-minx)*(maxy-miny)*(maxd-mind);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nint map[100][100][100];\nstd::vector<ull> X1, X2, Y1, Y2, D1, D2, X, Y, D;\n\nint compress(std::vector<ull> &v1, std::vector<ull> &v2, std::vector<ull> &v, int w){\n    REP(i, w){\n        int s = v1[i], t = v2[i];\n\n        v.push_back(s);\n        v.push_back(t);\n    }\n\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    REP(i, w){\n        v1[i] = std::find(v.begin(), v.end(), v1[i]) - v.begin();\n        v2[i] = std::find(v.begin(), v.end(), v2[i]) - v.begin();\n    }\n\n    return v.size();\n}\n\nint main(){\n    int N, K;\n    std::cin >> N >> K;\n\n    REP(i, N){\n        int x1, y1, d1, x2, y2, d2;\n        std::cin >> x1 >> y1 >> d1 >> x2 >> y2 >> d2;\n\n        X1.push_back(x1);\n        Y1.push_back(y1);\n        D1.push_back(d1);\n        X2.push_back(x2);\n        Y2.push_back(y2);\n        D2.push_back(d2);\n    }\n\n    int w_x, w_y, w_d;\n    w_x = compress(X1, X2, X, N);\n    w_y = compress(Y1, Y2, Y, N);\n    w_d = compress(D1, D2, D, N);\n\n    REP(i, N){\n        int x1 = X1[i], y1 = Y1[i], d1 = D1[i],\n            x2 = X2[i], y2 = Y2[i], d2 = D2[i];\n\n        map[d1][y1][x1] += 1;\n        map[d1][y2][x1] += -1;\n        map[d1][y1][x2] += -1;\n        map[d1][y2][x2] += 1;\n        map[d2][y1][x1] += -1;\n        map[d2][y2][x1] += 1;\n        map[d2][y1][x2] += 1;\n        map[d2][y2][x2] += -1;\n    }\n\n    REP(k, w_d){\n        REP(i, w_y){\n            FOR(j, 1, w_x){\n                map[k][i][j] += map[k][i][j-1];\n            }\n        }\n    }\n\n    REP(k, w_d){\n        REP(i, w_x){\n            FOR(j, 1, w_y){\n                map[k][j][i] += map[k][j-1][i];\n            }\n        }\n    }\n\n    REP(i, w_y){\n        REP(j, w_x){\n            FOR(k, 1, w_d){\n                map[k][i][j] += map[k-1][i][j];\n            }\n        }\n    }\n\n    ull res = 0;\n    REP(i, w_d-1){\n        REP(j, w_y-1){\n            REP(k, w_x-1){\n                if(map[i][j][k] >= K){\n                    res += (D[i+1]-D[i]) * (Y[j+1]-Y[j]) * (X[k+1]-X[k]);\n                }\n            }\n        }\n    }\n\n    std::cout << res << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n#define MAX_N 50\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint W,H,D,N,K;\nint X1[MAX_N],X2[MAX_N],Y1[MAX_N],Y2[MAX_N],D1[MAX_N],D2[MAX_N];\nvector<int> xl,yl,dl;\n\nint fld[MAX_N * 2][MAX_N*2][MAX_N*2];\n\nint compress(int *x1,int *x2, int w,vector<int> *xs){\n\t\n\trep(i,N){\n\t\t\tint tx1=x1[i], tx2=x2[i];\n\t\t\txs->push_back(tx1);\n\t\t\txs->push_back(tx2);\n\t}\n\tsort(xs->begin(),xs->end());\n\txs->erase(unique(xs->begin(),xs->end()),xs->end());\n\t\n\trep(i,N){\n\t\tx1[i] = find(xs->begin(),xs->end(),x1[i] )- xs->begin();\n\t\tx2[i] = find(xs->begin(),xs->end(),x2[i] )- xs->begin();\n\t}\n\treturn xs->size();\n\t\n}\n\nvoid solve(){\n\tW=compress(X1,X2,W,&xl);\n\tH=compress(Y1,Y2,H,&yl);\n\tD=compress(D1,D2,D,&dl);\n\n\tmemset(fld, 0, sizeof(fld));\n\trep(i,N){\n\t\tfor(int d=D1[i]; d<D2[i]; d++){\n\t\t\tfor(int y = Y1[i]; y<Y2[i];y++){\n\t\t\t\tfor(int x = X1[i]; x<X2[i];x++){\n\t\t\t\t\tfld[d][y][x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long int ans=0;\n\trep(d,D){\n\t\trep(y,H){\n\t\t\trep(x,W){\n\t\t\t\tif(fld[d][y][x]<K)continue;\n\t\t\t\tans+=(xl[x+1]-xl[x])*(yl[y+1]-yl[y])*(dl[d+1]-dl[d]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tscanf(\"%d %d\",&N,&K);\n\tW=H=D=1000000;\n\trep(i,N){\n\t\t//int x1,x2,y1,y2,d1,d2;\n\t\tscanf(\"%d %d %d %d %d %d\",&X1[i],&Y1[i],&D1[i],&X2[i],&Y2[i],&D2[i]);\n\t}\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint q[20000][7],p[6],qtop;\nbool ICV(int c[],int d[]){\n\tbool ret=true;\n\tfor(int i=0;i<3;i++){\n\t\tif(d[i]<c[i+3]&&d[i+3]>c[i])p[i]=max(c[i],d[i]),p[i+3]=min(c[i+3],d[i+3]);\n\t\telse ret=false;\n\t}\n\treturn ret;\n}\nint main(){\n\tint n,e;\n\tcin>>n>>e;\n\tqtop=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<6;j++)cin>>q[qtop][j];\n\t\tq[qtop][6]=1;\n\t\tint keep=qtop;\n\t\tqtop++;\n\t\tfor(int j=0;j<keep;j++){\n\t\t\tif(ICV(q[keep],q[j])){\n\t\t\t\tfor(int k=0;k<6;k++)q[qtop][k]=p[k];\n\t\t\t\tq[qtop][6]=q[j][6]+1;\n\t\t\t\tqtop++;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans[60]={0};\n\tfor(int i=55;i>0;i--){\n\tfor(int j=0;j<qtop;j++){\n\t\tif(q[j][6]==i){\n\t\tlong long v[3]={q[j][3]-q[j][0],q[j][4]-q[j][1],q[j][5]-q[j][2]};\n\t\tans[i]+=v[0]*v[1]*v[2];\n\t\t}\n\t}\n\tans[i-1]-=ans[i];\n\t}\n\tcout<<ans[e]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n \n \nlong long X[ 100 ][ 2 ] ,x[ 100 ] ;\nlong long Y[ 100 ][ 2 ] ,y[ 100 ] ;\nlong long Z[ 100 ][ 2 ] ,z[ 100 ] ;\n \nint i ,j ,k ,l ;\n \ninline void sort( long long *a ,int size )\n{\n    qsort( a ,size ,sizeof( long long ) ,[]( const void *a ,const void *b ){ return *( int* )a - *( int* )b ; } ) ;\n}\n \nint check()\n{\n    if(\n            X[ l ][ 0 ] > x[ i ] || X[ l ][ 1 ] < x[ i + 1 ] ||\n            Y[ l ][ 0 ] > y[ j ] || Y[ l ][ 1 ] < y[ j + 1 ] ||\n            Z[ l ][ 0 ] > z[ k ] || Z[ l ][ 1 ] < z[ k + 1 ]\n    )\n    {\n        return 1 ;\n    }\n \n    return 0 ;\n}\n \nint main( void )\n{\n    int N ,K ;\n    scanf( \"%d %d\" ,&N ,&K ) ;\n \n    N *= 2 ;\n \n    --K ;\n \n    int n = N - 1 ;\n \n    for( i = 0 ; i < N ; ++i )\n    {\n        scanf( \"%lld %lld %lld\" ,x + i ,y + i ,z + i ) ;\n \n        X[ i / 2 ][ i % 2 ] = x[ i ] ;\n        Y[ i / 2 ][ i % 2 ] = y[ i ] ;\n        Z[ i / 2 ][ i % 2 ] = z[ i ] ;\n    }\n \n    sort( x ,N ) ;\n    sort( y ,N ) ;\n    sort( z ,N ) ;\n\n\tN /= 2 ;\n \n    long long ans = 0 ;\n    for( i = 0 ; i < n ; ++i )\n    {\n        for( j = 0 ; j < n ; ++j )\n        {\n            for( k = 0 ; k < n ; ++k )\n            {\n                int cnt = 0 ;\n \n                for( l = 0 ; l < N ; ++l )\n                {\n                    if( check() == 0 )\n                    {\n                        ++cnt ;\n                    }\n                }\n \n                if( cnt > K )\n                {\n                    ans += ( x[ i + 1 ] - x[ i ] ) * ( y[ j + 1 ] - y[ j ] ) * ( z[ k + 1 ] - z[ k ] ) ;\n                }\n            }\n        }\n    }\n \n \n    printf( \"%lld\\n\" ,ans ) ;\n \n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define int long long int\n#define rep(a,b,c) for(int a=b;a<c;a++)\n#define repm(a,b,c) for(int a=(b-1);a>=c;a--)\n#define pb push_back\n#define str string\n#define sf(a) scanfs(\"%d\",&a)\n#define pb push_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n\nusing namespace std;\n\nconst int INF = 1e18 + 9;\nconst int Mod = 1e9 + 7;\ninline int replac(str s){double ans=0;rep(i,0,s.length()){ans+=(s[i]-'0')*pow(10,s.length()-i-1);}return (int)ans;}\ninline string numstr(int m){str s=\"\";while(m>0){char c;int a=m/10;if(a>0)a=m%(a*10);else a=m;c=(char)('0'+a);s+=c;m/=10;}str st=\"\";for(int i=s.size()-1;i>=0;i--){st+=s[i];}return st;}\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;cin >> n >> m;\n    vi x,y,z;\n    int X[101],Y[101],Z[101];\n    int xu[51],yu[51],zu[51];\n    rep(i,0,n){\n        cin >> X[n+i] >> Y[n+i] >> Z[n+i];\n        cin >> X[i] >> Y[i] >> Z[i];\n        x.pb(X[n+i]);x.pb(X[i]);y.pb(Y[i]);y.pb(Y[i+n]);z.pb(Z[i]);z.pb(Z[i+n]);\n    }\n    sort(ALL(x));\n    sort(ALL(y));\n    sort(ALL(z));\n    int ans=0;\n    rep(i,1,n*2){\n        rep(j,1,n*2){\n            rep(k,1,n*2){\n                int len=0;\n                //cout << X[i] << \" \" << Y[j] << \" \" << Z[k] << endl;\n                rep(l,0,n){\n                  //  cout << X[l] << \" | \" << X[l+n] << endl;\n                        if(x[i]<=X[l]&&X[l+n]<=x[i-1]){\n                        if(y[j]<=Y[l]&&Y[l+n]<=y[j-1]){\n                        if(z[k]<=Z[l]&&Z[l+n]<=z[k-1]){len++;}}}\n                }\n                //cout << len << \"  \";\n                if(len>=m){\n                    //cout << \"a\" << endl;\n                    ans+=(x[i]-x[i-1])*(y[j]-y[j-1])*(z[k]-z[k-1]);\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nll X_1[100],X_2[100],Y_1[100],Y_2[100],D_1[100],D_2[100];\nll table[110][110][110];\nmap<ll,int> index_X,index_Y,index_D;\nvector<ll> X,Y,D;\n\nint main(){\n\n\tint N,K;\n\tscanf(\"%d %d\",&N,&K);\n\n\tX.push_back(-10);\n\tX.push_back(BIG_NUM);\n\n\tY.push_back(-10);\n\tY.push_back(BIG_NUM);\n\n\tD.push_back(-10);\n\tD.push_back(BIG_NUM);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld %lld %lld %lld %lld %lld\",&X_1[i],&Y_1[i],&D_1[i],&X_2[i],&Y_2[i],&D_2[i]);\n\t\tX.push_back(X_1[i]);\n\t\tX.push_back(X_2[i]);\n\t\tY.push_back(Y_1[i]);\n\t\tY.push_back(Y_2[i]);\n\t\tD.push_back(D_1[i]);\n\t\tD.push_back(D_2[i]);\n\t}\n\n\tsort(X.begin(),X.end());\n\tsort(Y.begin(),Y.end());\n\tsort(D.begin(),D.end());\n\n\tX.erase(unique(X.begin(),X.end()),X.end());\n\tY.erase(unique(Y.begin(),Y.end()),Y.end());\n\tD.erase(unique(D.begin(),D.end()),D.end());\n\n\tll size_X = X.size(),size_Y = Y.size(),size_D = D.size();\n\n\tfor(int i = 0; i < size_X; i++){\n\t\tindex_X[X[i]] = i;\n\t}\n\tfor(int i = 0; i < size_Y; i++){\n\t\tindex_Y[Y[i]] = i;\n\t}\n\tfor(int i = 0; i < size_D; i++){\n\t\tindex_D[D[i]] = i;\n\t}\n\n\tfor(int x = 0; x <= size_X; x++){\n\t\tfor(int y = 0; y <= size_Y; y++){\n\t\t\tfor(int d = 0; d <= size_D; d++)table[x][y][d] = 0;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int x = index_X[X_1[i]]; x < index_X[X_2[i]]; x++){\n\t\t\tfor(int y = index_Y[Y_1[i]]; y < index_Y[Y_2[i]]; y++){\n\t\t\t\tfor(int d = index_D[D_1[i]]; d < index_D[D_2[i]]; d++)table[x][y][d]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\tfor(int x = 0; x < size_X; x++){\n\t\tfor(int y = 0; y < size_Y; y++){\n\t\t\tfor(int d = 0; d < size_D; d++){\n\t\t\t\tif(table[x][y][d] >= K){\n\t\t\t\t\tans += (X[x+1]-X[x])*(Y[y+1]-Y[y])*(D[d+1]-D[d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\ntypedef struct{\n\tint n;\n\tint species;\n} coord_t;\n\ntypedef struct{\n\tint xl;\n\tint xr;\n\tint yl;\n\tint yr;\n\tint zl;\n\tint zr;\n} fish_t;\n\nint comp(const void *c1, const void *c2);\n\nint main(){\n\tint N;\n\tint K;\n\n\t//魚の種類数と数える種類数を入力\n\tcin >> N >> K;\n\n\tcoord_t *X = new coord_t[2*N];\n\tcoord_t *Y = new coord_t[2*N];\n\tcoord_t *Z = new coord_t[2*N];\n\n\t//座標を入力\n\tfor(int i=0; i<N; i++){\n\t\tcin >> X[2*i].n >> Y[2*i].n >> Z[2*i].n >> X[2*i+1].n >> Y[2*i+1].n >> Z[2*i+1].n;\n\t\tX[2*i].species = i;\n\t\tX[2*i+1].species = i;\n\t\tY[2*i].species = i;\n\t\tY[2*i+1].species = i;\n\t\tZ[2*i].species = i;\n\t\tZ[2*i+1].species = i;\n\t}\n\n\tfish_t *fish = new fish_t[N];\n\t\n\t//各魚の生息領域を代入\n\tfor(int i=0; i<N; i++){\n\t\tint L = 2*i;\n\t\tint R = 2*i+1;\n\n\t\tfish[i].xl = X[L].n;\n\t\tfish[i].xr = X[R].n;\n\t\tfish[i].yl = Y[L].n;\n\t\tfish[i].yr = Y[R].n;\n\t\tfish[i].zl = Z[L].n;\n\t\tfish[i].zr = Z[R].n;\n\t}\n\n\t//座標を小さい順に並べ替える\n\tqsort(X, 2*N, sizeof(coord_t), comp);\n\tqsort(Y, 2*N, sizeof(coord_t), comp);\n\tqsort(Z, 2*N, sizeof(coord_t), comp);\n\n\tint dim = 2*N - 1;\n\n\t//各ブロックの魚の種類を数え、K種類以上の体積を求める\n\tunsigned long long V = 0;\n\tfor(int z=0; z<dim; z++){\n\t\tfor(int y=0; y<dim; y++){\n\t\t\tfor(int x=0; x<dim; x++){\n\t\t\t\tint k = 0;\n\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tif( (fish[i].xl > X[x].n) || (fish[i].xr < X[x+1].n) || (fish[i].yl > Y[y].n) || (fish[i].yr < Y[y+1].n) || (fish[i].zl > Z[z].n) || (fish[i].zr < Z[z+1].n) ){ continue; }\n\t\t\t\t\telse{ k++; }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(k < K){ continue; }\n\t\t\t\telse{\n\t\t\t\t\tV += (unsigned long long) (X[x+1].n - X[x].n) * (Y[y+1].n - Y[y].n) * (Z[z+1].n - Z[z].n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << V << endl;\n\t\n\tdelete[] X;\n\tdelete[] Y;\n\tdelete[] Z;\n\tdelete[] fish;\n\n\treturn 0;\n}\n\nint comp(const void *c1, const void *c2){\n\tcoord_t coord1 = *(coord_t*)c1;\n\tcoord_t coord2 = *(coord_t*)c2;\n\n\tint tmp_n1 = coord1.n;\n\tint tmp_n2 = coord2.n;\n\n\tint tmp_s1 = coord1.species;\n\tint tmp_s2 = coord2.species;\n\n\tint c = tmp_n1 - tmp_n2;\n\n\tif(c == 0){ c = tmp_s1 - tmp_s2; }\n\n\treturn c;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define MAX_M 120\n#define MAX_N 60\n\nint x[MAX_N][6];\nint y[MAX_N][6];\nint z[MAX_M][3];\nlong long int a[MAX_M][MAX_M][MAX_M];\nbool b[MAX_M][MAX_M][MAX_M];\n\nint main() {\n\tmemset(b, false, sizeof(b));\n\tint n, m;\n\tint MAXX[3] = { 0,0,0 };\n\tint SUMX[3] = { 0,0,0 };\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tcin >> x[i][j];\n\t\t\tMAXX[j % 3] = max(MAXX[j % 3], x[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j <= MAXX[i]; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (x[k][i] == j) {\n\t\t\t\t\ty[k][i] = SUMX[i];\n\t\t\t\t\tz[SUMX[i]][i] = j;\n\t\t\t\t\tSUMX[i] += 1;\n\t\t\t\t}\n\t\t\t\tif (x[k][i + 3] == j) {\n\t\t\t\t\ty[k][i + 3] = SUMX[i];\n\t\t\t\t\tz[SUMX[i]][i] = j;\n\t\t\t\t\tSUMX[i] += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < SUMX[0]; i++) {\n\t\tfor (int j = 0; j < SUMX[1]; j++) {\n\t\t\tfor (int k = 0; k < SUMX[2]; k++){\n\t\t\t\ta[i][j][k] = z[i + 1][0] - z[i][0];\n\t\t\t\ta[i][j][k] *= z[j + 1][1] - z[j][1];\n\t\t\t\ta[i][j][k] *= z[k + 1][2] - z[k][2];\n\t\t\t}\n\t\t}\n\t}\n\n\tint p;\n\tlong long int sum = 0;\n\n\tfor (int i = 0; i < SUMX[0]; i++) {\n\t\tfor (int j = 0; j < SUMX[1]; j++) {\n\t\t\tfor (int k = 0; k < SUMX[2]; k++) {\n\t\t\t\tp = 0;\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tif (((y[l][0] <= i && y[l][3]>i) && (y[l][1] <= j && y[l][4]>j)) && (y[l][2] <= k && y[l][5]>k)) {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p >= m) {\n\t\t\t\t\tsum += a[i][j][k];\n\t\t\t\t\tb[i][j][k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << sum << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nvector<int> xx,yy,zz;\n#undef int\nint main(){\n\t#define int long long\n\tint N,K;\tcin>>N>>K;\n\tvector<int> sx(N),tx(N),sy(N),ty(N),sz(N),tz(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>sx[i]>>sy[i]>>sz[i]>>tx[i]>>ty[i]>>tz[i];\n\t\txx.push_back(sx[i]);\txx.push_back(tx[i]);\n\t\tyy.push_back(sy[i]);\tyy.push_back(ty[i]);\n\t\tzz.push_back(sz[i]);\tzz.push_back(tz[i]);\n\t}\n\tsort(xx.begin(),xx.end());\txx.erase(unique(xx.begin(),xx.end()),xx.end());\n\tsort(yy.begin(),yy.end());\tyy.erase(unique(yy.begin(),yy.end()),yy.end());\n\tsort(zz.begin(),zz.end());\tzz.erase(unique(zz.begin(),zz.end()),zz.end());\n\tint ans=0;\n\tfor(int i=1;i<(int)xx.size();i++){\n\t\tfor(int j=1;j<(int)yy.size();j++){\n\t\t\tfor(int k=1;k<(int)zz.size();k++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int l=0;l<N;l++){\n\t\t\t\t\tif(sx[l]<=xx[i-1]&&xx[i]<=tx[l]&&sy[l]<=yy[j-1]&&yy[j]<=ty[l]&&sz[l]<=zz[k-1]&&zz[k]<=tz[l]){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt>=K){\n\t\t\t\t\tans+=(xx[i]-xx[i-1])*(yy[j]-yy[j-1])*(zz[k]-zz[k-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\n\nint N,K;\nint W,H,D;\nint X1[55],Y1[55],Z1[55],X2[55],Y2[55],Z2[55];\nint cx1[55],cy1[55],cz1[55],cx2[55],cy2[55],cz2[55];\nvector<int> X,Y,Z;\nint fld[55*6][55*6][55*6];\n\nint ans;\nvector<int> xs;\n\nvoid compress(vector<int> &X,int* x1,int* x2,int* vx1,int* vx2,int w,int* P){\n    xs.clear();\n    for(int i=0;i<N;++i){\n        x1[i]=vx1[i];\n        x2[i]=vx2[i];\n    }\n    for(int i=0;i<N;++i){\n        for(int d=-1;d<=1;++d){\n            int tx1=x1[i]+d;\n            int tx2=x2[i]+d;\n            if(0<=tx1&&tx1<=w)xs.PB(tx1);\n            if(0<=tx2&&tx2<=w)xs.PB(tx2);\n        }\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    //for(int i=0;i<xs.size();++i)cout<<xs[i]<<endl;\n    for(int i=0;i<xs.size();++i){\n        X.PB(xs[i+1]-xs[i]);\n    }\n    *P = xs.size();\n}\n\nint main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    compress(X,cx1,cx2,X1,X2,1000000,&W);\n    compress(Y,cy1,cy2,Y1,Y2,1000000,&H);\n    compress(Z,cz1,cz2,Z1,Z2,1000000,&D);\n    for(int i=0;i<N;++i){\n        for(int z=cz1[i];z<cz2[i];++z){\n            for(int y=cy1[i];y<cy2[i];++y){\n                for(int x=cx1[i];x<cx2[i];++x){\n                    fld[z][y][x]++;\n                }\n            }\n        }\n    }\n    for(int z=0;z<=D;++z){\n        for(int y=0;y<=H;++y){\n            for(int x=0;x<=W;++x){\n                if(fld[z][y][x]>=K)ans+=X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n\n    //cout<<W<<\" \"<<H<<\" \"<<D<<endl;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint q[10000][7],p[6],qtop;\nbool ICV(int c[],int d[]){\n\tbool ret=true;\n\tfor(int i=0;i<3;i++){\n\t\tif(d[i]<c[i+3]&&d[i+3]>c[i])p[i]=max(c[i],d[i]),p[i+3]=min(c[i+3],d[i+3]);\n\t\telse ret=false;\n\t}\n\treturn ret;\n}\nint main(){\n\tint n,e;\n\tcin>>n>>e;\n\tqtop=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<6;j++)cin>>q[qtop][j];\n\t\tq[qtop][6]=1;\n\t\tint keep=qtop;\n\t\tqtop++;\n\t\tfor(int j=0;j<keep;j++){\n\t\t\tif(ICV(q[keep],q[j])){\n\t\t\t\tfor(int k=0;k<6;k++)q[qtop][k]=p[k];\n\t\t\t\tq[qtop][6]=q[j][6]+1;\n\t\t\t\tqtop++;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans[60]={0};\n\tfor(int i=0;i<qtop;i++){\n\t\tlong long v[3]={q[i][3]-q[i][0],q[i][4]-q[i][1],q[i][5]-q[i][2]};\n\t\tans[q[i][6]]+=v[0]*v[1]*v[2];\n\t}\n\tfor(int i=55;i>0;i--)ans[i-1]-=ans[i]*(i-1);\n\tcout<<ans[e]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\nstruct Point{\n  int64 x1, y1, z1;\n  int64 x2, y2, z2;\n  Point(){}\n  Point(int64 x1, int64 y1, int64 z1, int64 x2, int64 y2, int64 z2):\n    x1(x1), y1(y1), z1(z1), x2(x2), y2(y2), z2(z2){};\n};\n\n\nint main(){\n  int64 N, K;\n  cin >> N >> K;\n  vector< int64 > X, Y, Z;\n  vector< Point > p(N);\n  for(int i = 0; i < N; i++){\n    int x1, y1, z1, x2, y2, z2;\n    cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n    p[i] = Point( x1, y1, z1, x2, y2, z2);\n\n    X.push_back(x1), X.push_back(x2);\n    Y.push_back(y1), Y.push_back(y2);\n    Z.push_back(z1), Z.push_back(z2);\n  }\n\n  sort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end());\n  sort(Y.begin(), Y.end()); Y.erase(unique(Y.begin(), Y.end()), Y.end());\n  sort(Z.begin(), Z.end()); Z.erase(unique(Z.begin(), Z.end()), Z.end());\n\n\n  int64 ret = 0;\n  for(int i = 0; i < X.size() - 1; i++){\n    for(int j = 0; j < Y.size() - 1; j++){\n      for(int k = 0; k < Z.size() - 1; k++){\n        int cnt = 0;\n        for(int l = 0; l < N; l++){\n          if(p[l].x1 <= X[i] && X[i + 1] <= p[l].x2 &&\n             p[l].y1 <= Y[j] && Y[j + 1] <= p[l].y2 &&\n             p[l].z1 <= Z[k] && Z[k + 1] <= p[l].z2) cnt++;\n        }\n        if(cnt >= K){\n          ret += (X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) * (Z[k + 1] - Z[k]);\n        }\n      }\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef long long lli;\nconst int MAX = 100;\nint a[MAX][MAX][MAX];\n\nint main(){\n  int n,m;\n  while(cin >> n >> m){\n    lli v[50][6], ans = 0;\n    vector<lli> v2[3];\n    set<lli> s[3];\n    map<lli,int> v3[3];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<6;j++){\n        cin >> v[i][j];\n        s[j%3].insert(v[i][j]);\n      }\n    }\n\n    for(int i=0;i<MAX;i++) for(int j=0;j<MAX;j++) for(int k=0;k<MAX;k++) a[i][j][k] = 0;\n    for(int i=0;i<3;i++){\n      for(set<lli>::iterator it = s[i].begin(); it != s[i].end(); it++){\n        v2[i].push_back(*it);\n        v3[i][*it] = v2[i].size()-1;\n      }\n    }\n\n    for(int i=0;i<n;i++)\n      for(int j=v3[0][v[i][0]];j<v3[0][v[i][3]];j++)\n        for(int k=v3[1][v[i][1]];k<v3[1][v[i][4]];k++)\n          for(int l=v3[2][v[i][2]];l<v3[2][v[i][5]];l++)\n            a[j][k][l]++;\n\n    for(int i=0;i<MAX-1;i++)\n      for(int j=0;j<MAX-1;j++)\n        for(int k=0;k<MAX-1;k++)\n          if(a[i][j][k] >= m)\n            ans += (v2[0][i+1]-v2[0][i]) * (v2[1][j+1]-v2[1][j]) * (v2[2][k+1]-v2[2][k]);\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\ntypedef long long int ll;\nint N, K;\nint X1[50], Y1[50], Z1[50], X2[50], Y2[50], Z2[50];\nint XX[100], YY[100], ZZ[100];\nint X_X[100], Y_Y[100], Z_Z[100];\nint COU[100][100][100];\nll ans;\nint main()\n{\n\tscanf(\"%d%d\", &N, &K);\n\tfor (int i = 0; i < N; i++){\n\t\tscanf(\"%d%d%d\", &X1[i], &Y1[i], &Z1[i]);\n\t\tscanf(\"%d%d%d\", &X2[i], &Y2[i], &Z2[i]);\n\t}\n\t\n\tfor (int i = 0; i < 2 * N; i++){\n\t\tfor (int j = i + 1; j < 2 * N; j++){\n\t\t\tif (i < N&&j < N){\n\t\t\t\tif (X1[i] < X1[j])XX[j]++;\n\t\t\t\telse XX[i]++;\n\t\t\t}\n\t\t\telse if (i < N){\n\t\t\t\tif (X1[i] < X2[j - N])XX[j]++;\n\t\t\t\telse XX[i]++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (X2[i - N] < X2[j - N])XX[j]++;\n\t\t\t\telse XX[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 2 * N; i++){\n\t\tfor (int j = i + 1; j < 2 * N; j++){\n\t\t\tif (i < N&&j < N){\n\t\t\t\tif (Y1[i] < Y1[j])YY[j]++;\n\t\t\t\telse YY[i]++;\n\t\t\t}\n\t\t\telse if (i < N){\n\t\t\t\tif (Y1[i] < Y2[j - N])YY[j]++;\n\t\t\t\telse YY[i]++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (Y2[i - N] < Y2[j - N])YY[j]++;\n\t\t\t\telse YY[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 2 * N; i++){\n\t\tfor (int j = i + 1; j < 2 * N; j++){\n\t\t\tif (i < N&&j < N){\n\t\t\t\tif (Z1[i] < Z1[j])ZZ[j]++;\n\t\t\t\telse ZZ[i]++;\n\t\t\t}\n\t\t\telse if (i < N){\n\t\t\t\tif (Z1[i] < Z2[j - N])ZZ[j]++;\n\t\t\t\telse ZZ[i]++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (Z2[i - N] < Z2[j - N])ZZ[j]++;\n\t\t\t\telse ZZ[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 2 * N; i++){\n\t\tif (i < N)X_X[XX[i]] = X1[i];\n\t\telse X_X[XX[i]] = X2[i-N];\n\t\tif (i < N)Y_Y[YY[i]] = Y1[i];\n\t\telse Y_Y[YY[i]] = Y2[i - N];\n\t\tif (i < N)Z_Z[ZZ[i]] = Z1[i];\n\t\telse Z_Z[ZZ[i]] = Z2[i - N];\n\t}\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = XX[i]; j < XX[i + N]; j++){\n\t\t\tfor (int k = YY[i]; k < YY[i + N]; k++){\n\t\t\t\tfor (int l = ZZ[i]; l < ZZ[i + N]; l++){\n\t\t\t\t\tCOU[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 2 * N; i++){\n\t\tfor (int j = 0; j < 2 * N; j++){\n\t\t\tfor (int k = 0; k < 2 * N; k++){\n\t\t\t\tif (COU[i][j][k] >= K){\n\t\t\t\t\tans += (ll)(X_X[i+1] - X_X[i])*(ll)(Y_Y[j + 1] - Y_Y[j])*(ll)(Z_Z[k + 1] - Z_Z[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nVL xx, x, unzipx(100010), yy, y, unzipy(100010), zz, z, unzipz(100010);\nunordered_map<int, int> zipx, zipy, zipz;\nvoid compress() {\n  x = xx;\n  sort(ALL(xx));\n  xx.erase(unique(ALL(xx)), xx.end());\n  REP(i, xx.size()) {zipx[xx[i]] = i; unzipx[i] = xx[i];}\n  REP(i, x.size()) x[i] = zipx[x[i]];\n  y = yy;\n  sort(ALL(yy));\n  yy.erase(unique(ALL(yy)), yy.end());\n  REP(i, yy.size()) {zipy[yy[i]] = i; unzipy[i] = yy[i];}\n  REP(i, y.size()) y[i] = zipy[y[i]];\n  z = zz;\n  sort(ALL(zz));\n  zz.erase(unique(ALL(zz)), zz.end());\n  REP(i, zz.size()) {zipz[zz[i]] = i; unzipz[i] = zz[i];}\n  REP(i, z.size()) z[i] = zipz[z[i]];\n}\n\nint dp[55][55][55];\nint sx[55], sy[55], sd[55], gx[55], gy[55], gd[55];\nsigned main(void)\n{\n  int n, K;\n  cin >> n >> K;\n  REP(i, n) {\n    cin >> sx[i] >> sy[i] >> sd[i] >> gx[i] >> gy[i] >> gd[i];\n    xx.PB(sx[i]); xx.PB(gx[i]);\n    yy.PB(sy[i]); yy.PB(gy[i]);\n    zz.PB(sd[i]); zz.PB(gd[i]);\n  }\n  compress();\n\n  // REP(i, n) {\n  //   cout << zipx[sx[i]] << \" \" << zipy[sy[i]] << \" \" << zipz[sd[i]] << \" \" << zipx[gx[i]] << \" \" << zipy[gy[i]] << \" \" << zipz[gd[i]] << endl;\n  // }\n\n  REP(i, n) {\n    FOR(z, zipz[sd[i]], zipz[gd[i]]) FOR(y, zipy[sy[i]], zipy[gy[i]]) FOR(x, zipx[sx[i]], zipx[gx[i]]) {\n      dp[z][y][x]++;\n    }\n    // REP(ii, z.size()) {\n    //   cout << \"z:\" << ii << endl;\n    //   REP(j, y.size()) {\n    //     REP(k, x.size()) {\n    //       cout << dp[ii][j][k] << \" \";\n    //     }\n    //     cout << endl;\n    //   }\n    // }\n    // cout << endl;\n  }\n\n  ll ret = 0;\n  REP(i, z.size()) REP(j, y.size()) REP(k, x.size()) {\n    if(dp[i][j][k] >= K) {\n      ret += (unzipz[i+1]-unzipz[i])*(unzipy[j+1]-unzipy[j])*(unzipx[k+1]-unzipx[k]);\n    }\n  }\n\n  cout << ret << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint map[160][160][160];\n\nint main(){\n\t\n\tint N, K;\n\t\n\tcin >> N >> K;\n\t\n\tint x1[100], x2[100], y1[100], y2[100], d1[100], d2[100];\n\tvector<long long int> x_v, y_v, d_v;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> x1[i] >> y1[i] >> d1[i] >> x2[i] >> y2[i] >> d2[i];\n\t\tx_v.push_back(x1[i]);\n\t\tx_v.push_back(x2[i]);\n\t\ty_v.push_back(y1[i]);\n\t\ty_v.push_back(y2[i]);\n\t\td_v.push_back(d1[i]);\n\t\td_v.push_back(d2[i]);\n\t}\n\t\n\tfor(int i = 0; i < 160; i++){\n\t\tfor(int j = 0; j < 160; j++){\n\t\t\tfor(int k = 0; k < 160; k++){\n\t\t\t\tmap[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsort(x_v.begin(), x_v.end());\n\tsort(y_v.begin(), y_v.end());\n\tsort(d_v.begin(), d_v.end());\n\t\n\tfor(int q = 0; q < N; q++){\n\t\tfor(int i = 0; i < N * 2; i++){\n\t\t\tif(x1[q] > x_v[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(x2[q] <= x_v[i]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int j = 0; j < N * 2; j++){\n\t\t\t\tif(y1[q] > y_v[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(y2[q] <= y_v[j]){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < N * 2; k++){\n\t\t\t\t\tif(d1[q] > d_v[k]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(d2[q] <= d_v[k]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmap[i][j][k]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long int ans = 0;\n\t\n\tfor(int i = 0; i < N * 2; i++){\n\t\tfor(int j = 0; j < N * 2; j++){\n\t\t\tfor(int k = 0; k < N * 2; k++){\n\t\t\t\tif(map[i][j][k] >= K){\n\t\t\t\t\tans += (x_v[i + 1] - x_v[i]) * (y_v[j + 1] - y_v[j]) * (d_v[k + 1] - d_v[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\n\n\nint N,K;\nint X1[51],Y1[51],D1[51],X2[51],Y2[51],D2[51];\n\nset<int> xset,yset,dset;\ntypedef pair<int,pii>  point;\ntypedef pair<point,point> tpl;\nset<tpl> ps;\n\nint main(){\n  \n\n  cin>>N>>K;\n  for(int i=0;i<N;i++){\n    cin>>X1[i]>>Y1[i]>>D1[i]>>X2[i]>>Y2[i]>>D2[i];\n    xset.insert(X1[i]);\n    yset.insert(Y1[i]);\n    dset.insert(D1[i]);\n    xset.insert(X2[i]);\n    yset.insert(Y2[i]);\n    dset.insert(D2[i]);\n  }\n  vector<int> xs(xset.begin(),xset.end());\n  vector<int> ys(yset.begin(),yset.end());\n  vector<int> ds(dset.begin(),dset.end());\n  for(int k=1;k<(int)ds.size();k++){\n    for(int j=1;j<(int)ys.size();j++){\n      for(int i=1;i<(int)xs.size();i++){\n        int minx=xs[i-1];\n        int miny=ys[j-1];\n        int mind=ds[k-1];\n        int maxx=xs[i];\n        int maxy=ys[j];\n        int maxd=ds[k];\n        ps.insert(make_pair(make_pair(minx,pii(miny,mind))\n                            ,make_pair(maxx,pii(maxy,maxd))));\n      }\n    }\n  }\n  ll ans=0;\n  for(set<tpl>::iterator it=ps.begin();it!=ps.end();it++){\n    point p1=it->first;\n    point p2=it->second;\n    int cnt=0;\n    ll minx=p1.first;\n    ll miny=p1.second.first;\n    ll mind=p1.second.second;\n    ll maxx=p2.first;\n    ll maxy=p2.second.first;\n    ll maxd=p2.second.second;\n    for(int i=0;i<N;i++){\n      if(X1[i]<=minx&&maxx<=X2[i]\n         &&Y1[i]<=miny&&maxy<=Y2[i]\n         &&D1[i]<=mind&&maxd<=D2[i]){\n        cnt++;\n      }\n    }\n    if(cnt>=K)ans+=(maxx-minx)*(maxy-miny)*(maxd-mind);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\ntypedef long long ll;\nint n,m;\nint x[N],y[N],z[N];\nint X[N],Y[N],Z[N];\nint s[N],t[N],u[N];\nint S[N],T[N],U[N];\nint xd[N][501],yd[N][501],zd[N][501];\n\n\nvoid compress(int a[51],int A[51],int b[51],int B[51],int c[51][501]){\n  vector <int> v;\n  for(int i=0;i<n;i++)v.push_back(a[i]),v.push_back(A[i]);\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  \n  for(int i=0;i<n;i++){\n    vector <int>::iterator it=lower_bound(v.begin(),v.end(),a[i]);\n    b[i]=it-v.begin();\n    c[i][b[i]]=*it;\n    for(int j=b[i];*it!=A[i];j++,it++)c[i][j]=*it;\n    B[i]=it-v.begin();\n    c[i][B[i]]=*it;\n  }\n}\n\nll calc(){\n  double res=0;\n  for(int i=0;i<101;i++) //x\n    for(int j=0;j<101;j++)//y\n      for(int k=0;k<101;k++){//z\n\tvector <ll> v;\n\tfor(int l=0;l<n;l++){\n\t  if(s[l]>i||t[l]>j||u[l]>k||S[l]<=i||T[l]<=j||U[l]<=k)continue;\n\t  ll a=xd[l][i+1]-xd[l][i];\n\t  ll b=yd[l][j+1]-yd[l][j];\n\t  ll c=zd[l][k+1]-zd[l][k];\n\t  v.push_back(a*b*c);\n\t}\n\tsort(v.begin(),v.end(),greater<int>());\n\tif(v.size()>=m) res+=v[m-1];\n      }\n  return res;\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>z[i]>>X[i]>>Y[i]>>Z[i];\n  compress(x,X,s,S,xd),compress(y,Y,t,T,yd),compress(z,Z,u,U,zd);\n  cout << calc()<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nstruct pos { int x, y, z; };\nvector<int> x, y, z;\nvector<pair<pos, pos>> fish;\nint num[100][100][100];\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++) {\n\t\tpos a,b;\n\t\tcin >> a.x >> a.y >> a.z >> b.x >> b.y >> b.z;\n\t\tfish.push_back(make_pair(a, b));\n\t\tfor (int i = 0; i < 1; i++) {\n\t\t\tx.push_back(a.x+i);\n\t\t\ty.push_back(a.y+i);\n\t\t\tz.push_back(a.z+i);\n\t\t\tx.push_back(b.x+i);\n\t\t\ty.push_back(b.y+i);\n\t\t\tz.push_back(b.z+i);\n\t\t}\n\t}\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tsort(z.begin(), z.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\ty.erase(unique(y.begin(), y.end()), y.end());\n\tz.erase(unique(z.begin(), z.end()), z.end());\n\tfor (auto f : fish) {\n\t\tint up = lower_bound(x.begin(), x.end(), f.second.x) - x.begin();\n\t\tfor (int i = lower_bound(x.begin(), x.end(), f.first.x) - x.begin(); i < up; i++) {\n\t\t\tint up = lower_bound(y.begin(), y.end(), f.second.y) - y.begin();\n\t\t\tfor (int j = lower_bound(y.begin(), y.end(), f.first.y) - y.begin(); j < up; j++) {\n\t\t\t\tint up = lower_bound(z.begin(), z.end(), f.second.z) - z.begin();\n\t\t\t\tfor (int k = lower_bound(z.begin(), z.end(), f.first.z) - z.begin(); k < up; k++) {\n\t\t\t\t\tnum[i][j][k]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < x.size()-1; i++) {\n\t\tfor (int j = 0; j < y.size()-1; j++) {\n\t\t\tfor (int l = 0; l < z.size()-1; l++) {\n\t\t\t\tif (num[i][j][l] >= k) {\n\t\t\t\t\tans += (ll)(x[i + 1] - x[i])*(y[j + 1] - y[j])*(z[l + 1] - z[l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nint N,K;\nlong long int x[100];\nlong long int y[100];\nlong long int z[100];\nlong long int xbox[100];\nlong long int ybox[100];\nlong long int zbox[100];\nint sum[100][100][100];\nlong long int ans;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> K;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i * 2] >> y[i * 2] >> z[i * 2] >> x[i * 2 + 1] >> y[i * 2 + 1] >> z[i * 2 + 1];\n\t\txbox[i * 2] = x[i * 2];\n\t\txbox[i * 2 + 1] = x[i * 2 + 1];\n\t\tybox[i * 2] = y[i * 2];\n\t\tybox[i * 2 + 1] = y[i * 2 + 1];\n\t\tzbox[i * 2] = z[i * 2];\n\t\tzbox[i * 2 + 1] = z[i * 2 + 1];\n\t}\n\tstable_sort(x, x + N * 2);\n\tstable_sort(y, y + N * 2);\n\tstable_sort(z, z + N * 2);\n\t//for (int i = 0; i < N * 2; i++) {\n\t//\tcout << x[i] << \" \";\n\t//}\n\t//cout << endl;\n\t//for (int i = 0; i < N * 2; i++) {\n\t//\tcout << y[i] << \" \";\n\t//}\n\t//cout << endl;\n\t//for (int i = 0; i < N * 2; i++) {\n\t//\tcout << z[i] << \" \";\n\t//}\n\t//cout << endl;\n\tfor (int i = 0; i < N; i++) {\n\t\tint sx = 0, sy = 0, sz = 0, gx = 0, gy = 0, gz = 0;\n\t\tfor (int j = 0; j < N * 2; j++) {\n\t\t\tif (xbox[i * 2] == x[j])sx = j;\n\t\t\tif (xbox[i * 2 + 1] == x[j])gx = j;\n\t\t\tif (ybox[i * 2] == y[j])sy = j;\n\t\t\tif (ybox[i * 2 + 1] == y[j])gy = j;\n\t\t\tif (zbox[i * 2] == z[j])sz = j;\n\t\t\tif (zbox[i * 2 + 1] == z[j])gz = j;\n\t\t}\n\t//\tcout << sx << \" \" << gx << \" \" << sy << \" \" << gy << \" \" << sz << \" \" << gz << endl;\n\t\tfor (int j = sx; j < gx; j++) {\n\t\t\tfor (int k = sy; k < gy; k++) {\n\t\t\t\tfor (int l = sz; l < gz; l++) {\n\t\t\t\t\tsum[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N * 2 - 1; i++) {\n\t\tfor (int j = 0; j < N * 2 - 1; j++) {\n\t\t\tfor (int k = 0; k < N * 2 - 1; k++) {\n\t\t\t\tif (sum[i][j][k]>=K){\n\t\t\t\t\tans += (x[i + 1] - x[i])*(y[j + 1] - y[j])*(z[k + 1] - z[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\tstatic ll n,t;\n\tstatic ll x[52][2],y[52][2],z[52][2];\n\t\n\tscanf(\"%lld%lld\",&n,&t);\n\trep(i,n){\n\t\tscanf(\"%lld\",&x[i][0]);\n\t\tscanf(\"%lld\",&y[i][0]);\n\t\tscanf(\"%lld\",&z[i][0]);\n\t\tscanf(\"%lld\",&x[i][1]);\n\t\tscanf(\"%lld\",&y[i][1]);\n\t\tscanf(\"%lld\",&z[i][1]);\n\t}\n\t\n\tstatic vector<ll> Zx,Zy,Zz;\n\trep(i,n){\n\t\tZx.pb( x[i][0] );\n\t\tZx.pb( x[i][1] );\n\t\tZy.pb( y[i][0] );\n\t\tZy.pb( y[i][1] );\n\t\tZz.pb( z[i][0] );\n\t\tZz.pb( z[i][1] );\n\t}\n\tsor(Zx); uniq(Zx);\n\tsor(Zy); uniq(Zy);\n\tsor(Zz); uniq(Zz);\n\t\n\tstatic ll imos[102][102][102] = {};\n\t\n\trep(i,n){\n\t\tll x1 = lb(Zx,x[i][0]) - Zx.begin();\n\t\tll x2 = lb(Zx,x[i][1]) - Zx.begin();\n\t\tll y1 = lb(Zy,y[i][0]) - Zy.begin();\n\t\tll y2 = lb(Zy,y[i][1]) - Zy.begin();\n\t\tll z1 = lb(Zz,z[i][0]) - Zz.begin();\n\t\tll z2 = lb(Zz,z[i][1]) - Zz.begin();\n\t\timos[x1][y1][z1] ++;\n\t\timos[x1][y1][z2] --;\n\t\timos[x1][y2][z1] --;\n\t\timos[x2][y1][z1] --;\n\t\timos[x1][y2][z2] ++;\n\t\timos[x2][y1][z2] ++;\n\t\timos[x2][y2][z1] ++;\n\t\timos[x2][y2][z2] --;\n\t}\n\t\n\trep1(i,101)rep(j,102)rep(k,102)imos[i][j][k] += imos[i-1][j][k];\n\trep(i,102)rep1(j,101)rep(k,102)imos[i][j][k] += imos[i][j-1][k];\n\trep(i,102)rep(j,102)rep1(k,101)imos[i][j][k] += imos[i][j][k-1];\n\t\n\tstatic ll ret = 0;\n\t\n\trep(i,Zx.size()){\n\t\trep(j,Zy.size()){\n\t\t\trep(k,Zz.size()){\n\t\t\t\tif(imos[i][j][k] >= t){\n\t\t\t\t\tret += (Zx[i+1]-Zx[i]) * (Zy[j+1]-Zy[j]) * (Zz[k+1]-Zz[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\nstruct Point{\n  int64 x1, y1, z1;\n  int64 x2, y2, z2;\n  Point(){}\n  Point(int64 x1, int64 y1, int64 z1, int64 x2, int64 y2, int64 z2):\n    x1(x1), y1(y1), z1(z1), x2(x2), y2(y2), z2(z2){};\n};\n\n\nint main(){\n  int64 N, K;\n  cin >> N >> K;\n  vector< int64 > X, Y, Z;\n  static int nums[101][101][101];\n  vector< Point > p(N);\n  for(int i = 0; i < N; i++){\n    int x1, y1, z1, x2, y2, z2;\n    cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n    p[i] = Point( x1, y1, z1, x2, y2, z2);\n\n    X.push_back(x1), X.push_back(x2);\n    Y.push_back(y1), Y.push_back(y2);\n    Z.push_back(z1), Z.push_back(z2);\n  }\n\n  sort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end());\n  sort(Y.begin(), Y.end()); Y.erase(unique(Y.begin(), Y.end()), Y.end());\n  sort(Z.begin(), Z.end()); Z.erase(unique(Z.begin(), Z.end()), Z.end());\n                                \n  for(int i = 0; i < N; i++){\n    int x1 = lower_bound(X.begin(), X.end(), p[i].x1) - X.begin();\n    int y1 = lower_bound(Y.begin(), Y.end(), p[i].y1) - Y.begin();\n    int z1 = lower_bound(Z.begin(), Z.end(), p[i].z1) - Z.begin();\n    int x2 = lower_bound(X.begin(), X.end(), p[i].x2) - X.begin();\n    int y2 = lower_bound(Y.begin(), Y.end(), p[i].y2) - Y.begin();\n    int z2 = lower_bound(Z.begin(), Z.end(), p[i].z2) - Z.begin();\n\n    for(int i = x1; i < x2; i++){\n      for(int j = y1; j < y2; j++){\n        for(int k = z1; k < z2; k++){\n          nums[i][j][k]++;\n        }\n      }\n    }\n  }\n\n\n  int64 ret = 0;\n  for(int i = 0; i < 101; i++){\n    for(int j = 0; j < 101; j++){\n      for(int k = 0; k < 101; k++){\n        if(nums[i][j][k] >= K){\n          ret += (X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) * (Z[k + 1] - Z[k]);\n        }\n      }\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Event {\n  ll kind, depth, x1, x2, y1, y2;\n};\nbool operator<(const Event &e, const Event &f) {\n  if (e.depth != f.depth) return e.depth < f.depth;\n  if (e.kind != f.kind) return e.kind < f.kind;\n  return e.x1 < f.x1;\n}\n\nint cnt[101][101];\n\nint main() {\n  int N,K;\n  cin>>N>>K;\n  set<ll> x,y;\n  int x1,x2,y1,y2,d1,d2;\n  vector<Event> evs;\n  for (int i=0; i<N; ++i) {\n    cin>>x1>>y1>>d1>>x2>>y2>>d2;\n    x.insert(x1); x.insert(x2);\n    y.insert(y1); y.insert(y2);\n    evs.push_back((Event){0,d1,x1,x2,y1,y2});\n    evs.push_back((Event){1,d2,x1,x2,y1,y2});\n  }\n\n  map<ll,ll> ix, iy, rx, ry;\n  for (set<ll>::iterator it = x.begin(); it != x.end(); ++it) {\n    if (ix.find(*it) == ix.end()) {\n      ll p = ix.size(); ix[*it] = p;\n      rx[p] = *it;\n    }\n  }\n  for (set<ll>::iterator it = y.begin(); it != y.end(); ++it) {\n    if (iy.find(*it) == iy.end()) {\n      ll p = iy.size(); iy[*it] = p;\n      ry[p] = *it;\n    }\n  }\n\n  for (int i=0; i<evs.size(); ++i) {\n    evs[i].x1 = ix[evs[i].x1];\n    evs[i].x2 = ix[evs[i].x2];\n    evs[i].y1 = iy[evs[i].y1];\n    evs[i].y2 = iy[evs[i].y2];\n  }\n\n  sort(evs.begin(), evs.end());\n  memset(cnt, 0, sizeof(cnt));\n\n  ll idx = 0, pd = 0;\n  ll ca = 0, ans = 0;\n  while(idx < evs.size()) {\n    ll cd = evs[idx].depth;\n    if (ca > 0) {\n      ans += ca*(cd-pd);\n      ca = 0;\n    }\n    pd = cd;\n    while(idx < evs.size()) {\n      if (evs[idx].depth != cd) break;\n      if (evs[idx].kind == 0) {\n        for (int i=evs[idx].x1; i<evs[idx].x2; ++i) {\n          for (int j=evs[idx].y1; j<evs[idx].y2; ++j)\n            cnt[j][i]++;\n        }\n      } else {\n        for (int i=evs[idx].x1; i<evs[idx].x2; ++i) {\n          for (int j=evs[idx].y1; j<evs[idx].y2; ++j)\n            cnt[j][i]--;\n        }\n      }\n      idx++;\n    }\n\n    // calc\n    //cout<<idx<<endl;\n    for (int i=0; i<101; ++i) {\n      for (int j=0; j<101; ++j) {\n        //cout<<cnt[i][j]<<\" \";\n        if (cnt[i][j] >= K) {\n          ca += (ll)(rx[j+1]-rx[j])*(ry[i+1]-ry[i]);\n        }\n      }\n      //cout<<endl;\n    }\n\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long Int;\n\nint main(){\n\tconst int MAX_N = 50;\n\tint N, K;\n\tint X1[MAX_N], Y1[MAX_N], D1[MAX_N], X2[MAX_N], Y2[MAX_N], D2[MAX_N];\n\tvector<int> X, Y, D;\n\tInt ans = 0;\n\tint k;\n\t\n\tscanf(\"%d%d\", &N, &K);\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d%d%d%d%d%d\", &X1[i], &Y1[i], &D1[i], &X2[i], &Y2[i], &D2[i]);\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tX.push_back(X1[i] - 1); X.push_back(X1[i]);\n\t\tX.push_back(X2[i]); X.push_back(X2[i] + 1);\n\t\tY.push_back(Y1[i] - 1); Y.push_back(Y1[i]);\n\t\tY.push_back(Y2[i]); Y.push_back(Y2[i] + 1);\n\t\tD.push_back(D1[i] - 1); D.push_back(D1[i]);\n\t\tD.push_back(D2[i]); D.push_back(D2[i] + 1);\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\tX.erase(unique(X.begin(), X.end()), X.end());\n\tY.erase(unique(Y.begin(), Y.end()), Y.end());\n\tD.erase(unique(D.begin(), D.end()), D.end());\n\t\n\tfor(int d = 0; d < D.size() - 1; d++){\n\t\tfor(int y = 0; y < Y.size() - 1; y++){\n\t\t\tfor(int x = 0; x < X.size() - 1; x++){\n\t\t\t\tk = 0;\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tif(X1[i] <= X[x] && Y1[i] <= Y[y] && D1[i] <= D[d]\n\t\t\t\t\t && X2[i] >= X[x + 1] && Y2[i] >= Y[y + 1] && D2[i] >= D[d + 1]){\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(k >= K){\n\t\t\t\t\tans += (Int)(X[x + 1] - X[x]) * (Y[y + 1] - Y[y]) * (D[d + 1] - D[d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint coun[105][105][105];\nvector<int>x,y,z;\nint rx[52][2], ry[52][2], rz[52][2];\nint n,m;\n\nint compress1(int x1[52], int x2[52]){\n\tfor(int i = 0;i < n;i++){\n\t\tx.push_back(x1[i]);\n\t\tx.push_back(x2[i]);\n\t}\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tfor(int i = 0;i < n;i++){\n\t\trx[i][0] = find(x.begin(),x.end(),x1[i])-x.begin();\n\t\trx[i][1] = find(x.begin(),x.end(),x2[i])-x.begin();\n\t}\n\treturn x.size();\n}\n\nint compress2(int x1[52], int x2[52]){\n\tfor(int i = 0;i < n;i++){\n\t\ty.push_back(x1[i]);\n\t\ty.push_back(x2[i]);\n\t}\n\tsort(y.begin(), y.end());\n\ty.erase(unique(y.begin(), y.end()), y.end());\n\tfor(int i = 0;i < n;i++){\n\t\try[i][0] = find(y.begin(),y.end(),x1[i])-y.begin();\n\t\try[i][1] = find(y.begin(),y.end(),x2[i])-y.begin();\n\t}\n\treturn y.size();\n}\n\nint compress3(int x1[52], int x2[52]){\n\tfor(int i = 0;i < n;i++){\n\t\tz.push_back(x1[i]);\n\t\tz.push_back(x2[i]);\n\t}\n\tsort(z.begin(), z.end());\n\tz.erase(unique(z.begin(), z.end()), z.end());\n\tfor(int i = 0;i < n;i++){\n\t\trz[i][0] = find(z.begin(),z.end(),x1[i])-z.begin();\n\t\trz[i][1] = find(z.begin(),z.end(),x2[i])-z.begin();\n\t}\n\treturn z.size();\n}\n\nvoid paint(){\n\tfor(int i = 0;i < n;i++){\n\tfor(int tx=rx[i][0];tx<rx[i][1];tx++)\n    {\n      for(int ty=ry[i][0];ty<ry[i][1];ty++)\n        {\n          for(int tz=rz[i][0];tz<rz[i][1];tz++)\n        {\n          coun[tx][ty][tz]++;\n        }\n        }\n    }\n\t}\n}\n\nint main()\n{\n\tint a[52],b[52],c[52],d[52],e[52],f[52];\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d %d %d %d %d\",&a[i],&b[i],&c[i],&d[i],&e[i],&f[i]);\n\t}\n\tint w = compress1(a, d);\n\tint h = compress2(b, d);\n\tint p = compress3(c, f);\n\tpaint();\n\t\n  long long ans=0;\n  for(int i=0;i<=w;i++)\n    {\n      for(int j=0;j<=h;j++)\n    {\n      for(int k=0;k<=p;k++)\n        {\n          if(coun[i][j][k]>=m)\n        {\n          long long s1=(x[i+1]-x[i]),s2=(y[j+1]-y[j]),s3=(z[k+1]-z[k]);\n          ans+=s1*s2*s3;\n        }\n        }\n    }\n    }\n\t//long long ans = 0;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint n, K;\nvector<int> v[6];\nvector<int> w[3];\nvector<int> u[3];\nvector<long long int> d[3];\nlong long int ans;\n\nint main(){\n\tscanf(\"%d %d\", &n, &K);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<6; j++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tv[j].push_back(t);\n\t\t\tw[j%3].push_back(t);\n\t\t}\n\t}\n\tfor(int i=0; i<3; i++){\n\t\tsort(w[i].begin(), w[i].end());\n\t\tw[i].erase(unique(w[i].begin(), w[i].end()), w[i].end());\n\t}\n/*\n\tfor(int i=0; i<3; i++){\n\t\tfor(int j=0; j<w[i].size(); j++){\n\t\t\tprintf(\"%d\\t\", w[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<6; j++){\n\t\t\tv[j][i] = find(w[j%3].begin(), w[j%3].end(), v[j][i]) - w[j%3].begin();\n\t\t}\n\t}\n/*\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<6; j++){\n\t\t\tprintf(\"%d\\t\", v[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\n\tfor(int i=0; i<3; i++){\n\t\tfor(int j=0; j<w[i].size()-1; j++){\n\t\t\td[i].push_back(w[i][j+1]-w[i][j]);\n\t\t}\n\t}\n/*\n\tfor(int i=0; i<3; i++){\n\t\tfor(int j=0; j<d[i].size(); j++){\n\t\t\tprintf(\"%d\\t\", d[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\n\tint u[w[0].size()][w[1].size()][w[2].size()];\n\tmemset(u, 0, sizeof(u));\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=v[0][i]; j<v[3][i]; j++){\n\t\t\tfor(int k=v[1][i]; k<v[4][i]; k++){\n\t\t\t\tfor(int l=v[2][i]; l<v[5][i]; l++){\n\t\t\t\t\tu[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0; i<w[0].size(); i++){\n\t\tfor(int j=0; j<w[1].size(); j++){\n\t\t\tfor(int k=0; k<w[2].size(); k++){\n\t\t\t\tif(u[i][j][k] >= K) ans += d[0][i] * d[1][j] * d[2][k];\n\t\t\t}\n\t\t}\n\t}\n/*\n\tfor(int i=0; i<3; i++)\n\t\tfor(int j=0; j<w[i].size(); j++)\n\t\t\tu[i].push_back(0);\n\n\tfor(int i=0; i<3; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int k=v[i][j]; k<v[i+3][j]; k++){\n\t\t\t\tu[i][k]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0; i<3; i++){\n\t\tfor(int j=0; j<u[i].size(); j++){\n\t\t\tprintf(\"%d\\t\", u[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor(int i=0; i<u[0].size()-1; i++){\n\t\tfor(int j=0; j<u[1].size()-1; j++){\n\t\t\tfor(int k=0; k<u[2].size()-1; k++){\n\t\t\t\tif(u[0][i] >= K && u[1][j] >= K && u[2][k] >= K){\n\t\t\t\t\tans += d[0][i] * d[1][j] * d[2][k];\n\t\t\t\t\tprintf(\"%d %d %d\\n\", i, j, k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n*/\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nint main(){\n\tconst int MAX_N = 50;\n\tull v = 0;\n\tint X1[MAX_N], Y1[MAX_N], D1[MAX_N], X2[MAX_N], Y2[MAX_N], D2[MAX_N];\n\tint N, K;\n\n\tcin >> N >> K;\n\n\tvector<int> X(2 * N), Y(2 * N), D(2 * N);\n\n\tfor (int i = 0; i<N; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t\tX[i]     = X1[i];\n\t\tX[i + N] = X2[i];\n\t\tY[i]     = Y1[i];\n\t\tY[i + N] = Y2[i];\n\t\tD[i]     = D1[i];\n\t\tD[i + N] = D2[i];\n\t}\n\n\t// 並び替え\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\t// 重複する値を消去\n\tX.erase(unique(X.begin(), X.end()), X.end());\n\tY.erase(unique(Y.begin(), Y.end()), Y.end());\n\tD.erase(unique(D.begin(), D.end()), D.end());\n\n\t// 3次元配列\n\tvector<vector<vector<int> > > num(X.size()-1, vector<vector<int> >(Y.size()-1, vector<int>(D.size()-1, 0)));\n\n\tfor (int n = 0; n < N; n++){\n\n\t\t// n番目の種類の生息範囲を取り出す\n\t\t// iterator同士の引き算によってiterator -> intに変換できる\n\t\t// lower_boundは二分木探索（要ソート）、findは線形探索（ソート不要）\n\t\tint xl = lower_bound(X.begin(), X.end(), X1[n]) - X.begin();\n\t\tint xr = lower_bound(X.begin(), X.end(), X2[n]) - X.begin();\n\t\tint yl = lower_bound(Y.begin(), Y.end(), Y1[n]) - Y.begin();\n\t\tint yr = lower_bound(Y.begin(), Y.end(), Y2[n]) - Y.begin();\n\n\t\t//std::distanceでもできる\n\t\tint dl = distance(D.begin(), lower_bound(D.begin(), D.end(), D1[n]));\n\t\tint dr = distance(D.begin(), lower_bound(D.begin(), D.end(), D2[n]));\n\n\t\tfor (int i = xl; i < xr; i++){\n\t\tfor (int j = yl; j < yr; j++){\n\t\tfor (int k = dl; k < dr; k++){\n\t\t\tnum[i][j][k] ++;\n\t\t}}}\n\n\t}\n\n\tfor (int i = 0, nx = X.size() - 1; i<nx; i++){\n\tfor (int j = 0, ny = Y.size() - 1; j<ny; j++){\n\tfor (int k = 0, nd = D.size() - 1; k<nd; k++){\n\t\tif (num[i][j][k] >= K) v += (ull)(X[i+1] - X[i]) * (Y[j+1] - Y[j]) * (D[k+1] - D[k]);\n\t}\n\t}\n\t}\n\n\tcout << v << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint compress(vector<int>& v, map<int, int>& zip, map<int, int>& unzip) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());\n\n\trep(i, v.size()) {\n\t\tzip[v[i]] = i;\n\t\tunzip[i] = v[i];\n\t}\n\n\treturn v.size();\n}\n\nint d[55 * 3][55 * 3][55 * 5];\n\nint main() {\n\tint n, K;\n\tcin >> n >> K;\n\n\tvector<int> x, y, z;\n\tvector<int> x1(n), y1(n), z1(n), x2(n), y2(n), z2(n);\n\n\trep(i, n) {\n\t\tcin >> x1[i] >> y1[i] >> z1[i] >> x2[i] >> y2[i] >> z2[i];\n\t\tx.push_back(x1[i]);\n\t\tx.push_back(x2[i]);\n\n\t\ty.push_back(y1[i]);\n\t\ty.push_back(y2[i]);\n\n\t\tz.push_back(z1[i]);\n\t\tz.push_back(z2[i]);\n\t}\n\n\tmap<int, int> xzip, yzip, zzip;\n\tmap<int, int> xunzip, yunzip, zunzip;\n\n\tint X = compress(x, xzip, xunzip);\n\tint Y = compress(y, yzip, yunzip);\n\tint Z = compress(z, zzip, zunzip);\n\n\tmemset(d, 0, sizeof(d));\n\n\trep(i, n) {\n\t\tREP(j, xzip[x1[i]], xzip[x2[i]]) {\n\t\t\tREP(k, yzip[y1[i]], yzip[y2[i]]) {\n\t\t\t\tREP(l, zzip[z1[i]], zzip[z2[i]]) {\n\t\t\t\t\td[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\trep(i, X) {\n\t\trep(j, Y) {\n\t\t\trep(k, Z) {\n\t\t\t\tif(d[i][j][k] >= K) {\n\t\t\t\t\tans += ll(xunzip[i+1] - xunzip[i]) * ll(yunzip[j+1] - yunzip[j]) * ll(zunzip[k+1] - zunzip[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <complex>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FORE(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\nusing namespace std;\ntypedef long long ll;\ntypedef map<ll,ll> mi;\ntypedef vector<ll> vi;\nmi open[3],closed[3];\nll fish[50][2][3];\nbool search(int x,int y,int z,int l){\n\tint num[3]={x,y,z};\n\tnum[0]=x;\n\tnum[1]=y;\n\tnum[2]=z;\n\tREP(i,3){\n\t\tif(fish[l][0][i]<=num[i] && fish[l][1][i]>=num[i]+1)\n\t\tcontinue;\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n\tll N,K;\n\tvi points[3];\n\tcin >> N >> K;\n\tREP(i,N)\n\t\tREP(j,2)\n\t\t\tREP(k,3){\n\t\t\t\tcin >> fish[i][j][k];\n\t\t\t\tpoints[k].push_back(fish[i][j][k]);\n\t\t\t}\n\tREP(i,3){\n\tpoints[i].push_back(0);\n\tsort(points[i].begin(),points[i].end());\n\tint count =0;\n\tREP(j,(int)points[i].size())\n\t\tif(j==1 || points[i][j]!=points[i][j-1]){\n\t\t\topen[i].insert(mi::value_type(count,points[i][j]));\n\t\t\tclosed[i].insert(mi::value_type(points[i][j],count));\n\t\t\tcount++;\n\t\t}\n\t}\n\tREP(i,N)\n\t\tREP(j,2)\n\t\t\tREP(k,3){\n\t\t\t\tfish[i][j][k]=closed[k][fish[i][j][k]];\n\t\t\t\t\n\t\t}\n\tll sum=0;\n\tREP(i,open[0].size()-1)\n\t\tREP(j,open[1].size()-1)\n\t\t\tREP(k,open[2].size()-1){\n\t\t\t\tint count=0;\n\t\t\t\tREP(l,N)\n\t\t\t\tcount+=search(i,j,k,l);\n\t\t\t\tif(count>=K)\n\t\t\t\tsum+=(open[0][i+1]-open[0][i])*(open[1][j+1]-open[1][j])*(open[2][k+1]-open[2][k]);\n\t\t\t}\n\tcout << sum << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint coun[105][105][105]={};\nvector<int>x,y,z;\nint main()\n{\n  int n,m;\n  scanf(\"%d %d\",&n,&m);\n  int a[55],b[55],c[55],d[55],e[55],f[55];\n  for(int i=0;i<n;i++)\n    {\n      scanf(\"%d %d %d %d %d %d\",&a[i],&b[i],&c[i],&d[i],&e[i],&f[i]);\n       x.push_back(a[i]);\n       x.push_back(d[i]);\n       y.push_back(b[i]);\n       y.push_back(e[i]);\n       z.push_back(c[i]);\n       z.push_back(f[i]);\n    }\n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  sort(z.begin(),z.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n  z.erase(unique(z.begin(),z.end()),z.end());\n  for(int i=0;i<n;i++)\n    {\n      int r1=lower_bound(x.begin(),x.end(),a[i])-x.begin();\n      int r2=lower_bound(x.begin(),x.end(),d[i])-x.begin();\n      int r3=lower_bound(y.begin(),y.end(),b[i])-y.begin();\n      int r4=lower_bound(y.begin(),y.end(),e[i])-y.begin();\n      int r5=lower_bound(z.begin(),z.end(),c[i])-z.begin();\n      int r6=lower_bound(z.begin(),z.end(),f[i])-z.begin();\n      for(int i=r1;i<r2;i++)\n\t{\n\t  for(int j=r3;j<r4;j++)\n\t    {\n\t      for(int k=r5;k<r6;k++)\n\t\t{\n\t\t  coun[i][j][k]++;\n\t\t}\n\t    }\n\t}\n    }\n  long long ans=0;\n  for(int i=0;i<=100;i++)\n    {\n      for(int j=0;j<=100;j++)\n\t{\n\t  for(int k=0;k<=100;k++)\n\t    {\n\t      if(coun[i][j][k]>=m)\n\t\t{\n\t\t  ans+=(x[i+1]-x[i])*(y[j+1]-y[j])*(z[k+1]-z[k]);\n\t\t}\n\t    }\n\t}\n    }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\n\nstruct POINT {\n\tll x1,y1,z1;\n\tll x2,y2,z2;\n\tPOINT(){}\n\tPOINT(ll x1, ll y1, ll z1, ll x2, ll y2, ll z2):\n\t  x1(x1), y1(y1), z1(z1), x2(x2), y2(y2), z2(z2){};\n};\n\nint main(){\n\tll n,k;\n\tcin >> n >> k;\n\tvector< ll > X,Y,Z;\n\tint memo[101][101][101];\n\tvector<POINT> p(n);\n\tfor(int i=0;i<n;i++){\n\t\tint x1,y1,z1,x2,y2,z2;\n\t\tcin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n\t\tp[i] = POINT (x1,y1,z1,x2,y2,z2);\n\t\tX.push_back(x1); X.push_back(x2);\n\t\tY.push_back(y1); Y.push_back(y2);\n\t\tZ.push_back(z1); Z.push_back(z2);\n\t}\n\tsort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end());\n\tsort(Y.begin(), Y.end()); Y.erase(unique(Y.begin(), Y.end()), Y.end());\n\tsort(Z.begin(), Z.end()); Z.erase(unique(Z.begin(), Z.end()), Z.end());\n\tfor(int i = 0; i < n; i++){\n\t   int x1 = lower_bound(X.begin(), X.end(), p[i].x1) - X.begin();\n\t   int y1 = lower_bound(Y.begin(), Y.end(), p[i].y1) - Y.begin();\n\t   int z1 = lower_bound(Z.begin(), Z.end(), p[i].z1) - Z.begin();\n\t   int x2 = lower_bound(X.begin(), X.end(), p[i].x2) - X.begin();\n\t   int y2 = lower_bound(Y.begin(), Y.end(), p[i].y2) - Y.begin();\n\t   int z2 = lower_bound(Z.begin(), Z.end(), p[i].z2) - Z.begin();\n\n\t   for(int i = x1; i < x2; i++){\n\t     for(int j = y1; j < y2; j++){\n\t       for(int z = z1; z < z2; z++){\n\t         memo[i][j][z]++;\n\t       }\n\t     }\n\t   }\n\t }\n\t ll ret = 0;\n\t for(int i = 0; i < 101; i++){\n\t   for(int j = 0; j < 101; j++){\n\t     for(int z = 0; z < 101; z++){\n\t       if(memo[i][j][z] >= k){\n\t         ret += (X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) * (Z[z + 1] - Z[z]);\n\t       }\n\t     }\n\t   }\n\t }\n\t cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define pint pair<int, int>\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nconst int INF = 1e7;\n\nstruct xyd\n{\n\tint x, y, d;\n\txyd(int x, int y, int d):x(x), y(y), d(d){}\n};\n\nint N, K;\nvector<int> x, y, d;\nvector<xyd> xyd1, xyd2;\nint imos[105][105][105] = {};\n\nint main() {\n\tcin >> N >> K;\n\trep(i, N) {\n\t\tint x1, y1, d1, x2, y2, d2;\n\t\tcin >> x1 >> y1 >> d1 >> x2 >> y2 >> d2;\n\n\t\txyd1.push_back(xyd(x1, y1, d1));\n\t\txyd2.push_back(xyd(x2, y2, d2));\n\n\t\tx.push_back(x1); x.push_back(x2);\n\t\ty.push_back(y1); y.push_back(y2);\n\t\td.push_back(d1); d.push_back(d2);\n\t}\n\n\tsort(x.begin(), x.end()); sort(y.begin(), y.end()); sort(d.begin(), d.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\ty.erase(unique(y.begin(), y.end()), y.end());\n\td.erase(unique(d.begin(), d.end()), d.end());\n\n\tint xn = x.size(), yn = y.size(), dn = d.size();\n\n\tfor (int i = 0; i < N; i++) {\n\t\tint x1 = lower_bound(x.begin(), x.end(), xyd1[i].x) - x.begin();\n\t\tint y1 = lower_bound(y.begin(), y.end(), xyd1[i].y) - y.begin();\n\t\tint d1 = lower_bound(d.begin(), d.end(), xyd1[i].d) - d.begin();\n\t\tint x2 = lower_bound(x.begin(), x.end(), xyd2[i].x) - x.begin();\n\t\tint y2 = lower_bound(y.begin(), y.end(), xyd2[i].y) - y.begin();\n\t\tint d2 = lower_bound(d.begin(), d.end(), xyd2[i].d) - d.begin();\n\n\t\timos[x1][y1][d1]++;\n\n\t\timos[x2][y1][d1]--;\n\t\timos[x1][y2][d1]--;\n\t\timos[x1][y1][d2]--;\n\n\t\timos[x1][y2][d2]++;\n\t\timos[x2][y1][d2]++;\n\t\timos[x2][y2][d1]++;\n\n\t\timos[x2][y2][d2]--;\n\t}\n\t\n\tfor (int i = 0; i < xn; i++) {\n\t\tfor (int j = 0; j < yn; j++) {\n\t\t\tfor (int k = 1; k < dn; k++) {\n\t\t\t\timos[i][j][k] += imos[i][j][k-1];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < xn; i++) {\n\t\tfor (int j = 1; j < yn; j++) {\n\t\t\tfor (int k = 0; k < dn; k++) {\n\t\t\t\timos[i][j][k] += imos[i][j-1][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < xn; i++) {\n\t\tfor (int j = 0; j < yn; j++) {\n\t\t\tfor (int k = 0; k < dn; k++) {\n\t\t\t\timos[i][j][k] += imos[i-1][j][k];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tll ans = 0;\n\tfor (int i = 0; i < xn-1; i++) {\n\t\tfor (int j = 0; j < yn-1; j++) {\n\t\t\tfor (int k = 0; k < dn-1; k++) {\n\t\t\t\tif (imos[i][j][k] >= K) {\n\t\t\t\t\tans += (ll)(x[i + 1] - x[i])*(y[j + 1] - y[j])*(d[k + 1] - d[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nint n,m;\nll ans;\nll d[52][7];\nll sx[110],sy[110],sd[110];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < 6;j++){\n\t\t\tscanf(\"%lld\",&d[i][j]);\n\t\t\tswitch(j%3){\n\t\t\t\tcase 0:\n\t\t\t\t\tsx[i*2+(j/3)] = d[i][j];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tsy[i*2+(j/3)] = d[i][j];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsd[i*2+(j/3)] = d[i][j];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsort(sx,sx + 2*n);\n\tsort(sy,sy + 2*n);\n\tsort(sd,sd + 2*n);\n\n\tint six=2*n,siy=2*n,sid=2*n;\n\tint cnt = 0;\n\tint pre = sx[cnt++];\n\tfor(int i = 1;i < 2*n;i++){\n\t\tif(pre != sx[i]){\n\t\t\tsx[cnt++] = sx[i];\n\t\t\tpre = sx[i];\n\t\t}\n\t}\n\tsix = cnt; cnt = 0; pre = sy[cnt++]; \n\tfor(int i = 1;i < 2*n;i++){\n\t\tif(pre != sy[i]){\n\t\t\tsy[cnt++] = sy[i];\n\t\t\tpre = sy[i];\n\t\t}\n\t}\n\tsiy = cnt; cnt = 0; pre = sd[cnt++];\n\tfor(int i = 1;i < 2*n;i++){\n\t\tif(pre != sd[i]){\n\t\t\tsd[cnt++] = sd[i];\n\t\t\tpre = sd[i];\n\t\t}\n\t}\n\tsid = cnt;\n\tn = 2*n;\n\tfor(int i = 0;i < six-1;i++){\n\t\tfor(int j = 0;j < siy-1;j++){\n\t\t\tfor(int k = 0;k < sid-1;k++){\n\t\t\t\tint co = 0;\n\t\t\t\tfor(int l = 0;l < n/2;l++){\n\t\t\t\t\tif(sx[i] < d[l][0] || sx[i+1] > d[l][3] || sy[j] < d[l][1] || sy[j+1] > d[l][4] || sd[k] < d[l][2] || sd[k+1] > d[l][5])continue;\n\t\t\t\t\tco++;\n\t\t\t\t}\n\t\t\t\tif(co >= m)ans += (sx[i+1]-sx[i])*(sy[j+1]-sy[j])*(sd[k+1]-sd[k]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t//cout << \"six:\" << six << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<sstream>\n#include<iterator>\n#include<ctime>\n#include<iomanip>\n#define pb push_back\n#define F first\n#define S second \n#define all(n) n.begin(),n.end()\nusing namespace std;\n\nint graph[110][110][100];\n\nvoid draw(int x1,int y1,int z1,int x2,int y2,int z2)\n{\n\n  for(int i=x1;i<x2;i++)\n    for(int j=y1;j<y2;j++)\n      for(int k=z1;k<z2;k++)\n\tgraph[i][j][k]++;\n}\n\nint main()\n{\n  int N,K;  \n  \n  cin >> N >> K;\n  vector<int> X,Y,Z,X_1,Y_1,Z_1,X_2,Y_2,Z_2;\n  for(int i=0;i<110;i++)\n    for(int j=0;j<110;j++)\n      for(int k=0;k<110;k++)\n\tgraph[i][j][k] = 0;\n\n  for(int i=0;i<N;i++)\n    {\n      int x1,x2,y1,y2,z1,z2;\n      cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n      X_1.pb(x1),Y_1.pb(y1),Z_1.pb(z1),X_2.pb(x2),Y_2.pb(y2),Z_2.pb(z2);\n      X.pb(x1),X.pb(x2),Y.pb(y1),Y.pb(y2),Z.pb(z1),Z.pb(z2);\n    }\n  \n  sort(all(X)),sort(all(Y)),sort(all(Z));\n  X.erase(unique(all(X)),X.end());\n  Y.erase(unique(all(Y)),Y.end());\n  Z.erase(unique(all(Z)),Z.end());\n  \n  for(int i=0;i<X_1.size();i++)\n    {\n      \n      X_1[i] = find(all(X),X_1[i])-X.begin();\n      Y_1[i] = find(all(Y),Y_1[i])-Y.begin();\n      Z_1[i] = find(all(Z),Z_1[i])-Z.begin();\n    \n      X_2[i] = find(all(X),X_2[i])-X.begin();\n      Y_2[i] = find(all(Y),Y_2[i])-Y.begin();\n      Z_2[i] = find(all(Z),Z_2[i])-Z.begin();\n    \n    }\n  \n  for(int i=0;i<N;i++)\n    draw(X_1[i],Y_1[i],Z_1[i],X_2[i],Y_2[i],Z_2[i]);\n\n  long long ans = 0;\n  for(int i=0;i<X.size()-1;i++)//x\n    for(int j=0;j<Y.size()-1;j++)//y\n      for(int k=0;k<Z.size()-1;k++)//z\n\tif(graph[i][j][k] < K)\n\t  continue;\n\telse\n\t  ans += (long long)(X[i+1]-X[i])*(long long)(Y[j+1]-Y[j])*(long long)(Z[k+1]-Z[k]);\n\t    \t  \n\t \t \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\n\nint N,K;\nint W,H,D;\ndouble X1[55],Y1[55],Z1[55],X2[55],Y2[55],Z2[55];\ndouble cx1[55],cy1[55],cz1[55],cx2[55],cy2[55],cz2[55];\ndouble X[55],Y[55],Z[55];\nint fld[55*6][55*6][55*6];\n\nint ans;\nvector<double> xs;\n\nvoid compress(double* X,double* x1,double* x2,double* vx1,double* vx2,int w,int* P){\n    xs.clear();\n    for(int i=0;i<N;++i){\n        x1[i]=vx1[i];\n        x2[i]=vx2[i];\n    }\n    for(int i=0;i<N;++i){\n        for(int d=-1;d<=1;++d){\n            double tx1=(double)x1[i]+d;\n            double tx2=(double)x2[i]+d;\n            if(0<=tx1&&tx1<w)xs.PB(tx1);\n            if(0<=tx2&&tx2<w)xs.PB(tx2);\n        }\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    for(int i=0;i<N;++i){\n        double t =(double)vx2[i]-(double)vx1[i];\n        double s =(double)x2[i]-(double)x1[i];\n        X[i]=t/s;\n        cout<<X[i]<<endl;\n    }\n    *P=xs.size();\n}\n\nsigned main(){\n    //cout<<(double)10000/(double)3<<endl;\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    compress(X,cx1,cx2,X1,X2,1000000,&W);\n    compress(Y,cy1,cy2,Y1,Y2,1000000,&H);\n    compress(Z,cz1,cz2,Z1,Z2,1000000,&D);\n    for(int i=0;i<N;++i){\n        for(int z=cz1[i];z<cz2[i];++z){\n            for(int y=cy1[i];y<cy2[i];++y){\n                for(int x=cx1[i];x<cx2[i];++x){\n                    fld[z][y][x]++;\n                }\n            }\n        }\n    }\n    cout<<W<<\" \"<<H<<\" \"<<D<<endl;\n    for(int i=0;i<N;++i){\n        for(int z=cz1[i];z<cz2[i];++z){\n            for(int y=cy1[i];y<cy2[i];++y){\n                for(int x=cx1[i];x<cx2[i];++x){\n                    if(fld[z][y][x]>=K){\n                        //cout<<X[i]<<\" \"<<Y[i]<<\" \"<<Z[i]<<endl;\n                        ans+=X[i]*Y[i]*Z[i];\n                        fld[z][y][x]=0;\n                    }\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\nint n, k;\nvector<ll> xs, ys, zs;\nmap<ll, ll> zipx, zipy, zipz;//<???, ??§??????>\nmap<ll, ll> unzipx, unzipy, unzipz;//<??§??????, ???>\nint num[100][100][100];//???????¨?????????\\??????\n\nint main(void){\n\tcin >> n >> k;\n\tll x1[51], x2[51], y1[51], y2[51], z1[51], z2[51];//?????????????????§?¨?\n\trep(i, n){\n\t\tcin >> x1[i] >> y1[i] >> z1[i];\n\t\tcin >> x2[i] >> y2[i] >> z2[i];\n\t\txs.push_back(x1[i]); xs.push_back(x2[i]);\n\t\tys.push_back(y1[i]); ys.push_back(y2[i]);\n\t\tzs.push_back(z1[i]); zs.push_back(z2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(),xs.end()), xs.end());//???????¶????\n\tsort(ys.begin(), ys.end());\n\tys.erase(unique(ys.begin(), ys.end()), ys.end());\n\tsort(zs.begin(), zs.end());\n\tzs.erase(unique(zs.begin(), zs.end()), zs.end());\n\n\trep(i, xs.size()){\n\t\tzipx[i] = xs[i];\n\t\tunzipx[xs[i]] = i;\n\t\t// printf(\"unzip[%d] = %d\\n\", xs[i], i);\n\t\t// printf(\"zip[%d] = %d\\n\", i, xs[i]);\n\t}\n\trep(i, ys.size()){\n\t\tzipy[i] = ys[i];\n\t\tunzipy[ys[i]] = i;\n\t\t// printf(\"unzip[%d] = %d\\n\", ys[i], i);\n\t\t// printf(\"zip[%d] = %d\\n\", i, ys[i]);\n\t}\n\trep(i, zs.size()){\n\t\tzipz[i] = zs[i];\n\t\tunzipz[zs[i]] = i;\n\t\t// printf(\"unzip[%d] = %d\\n\", zs[i], i);\n\t\t// printf(\"zip[%d] = %d\\n\", i, zs[i]);\n\t}\n\n\tmemset(num, 0, sizeof(num));\n\tfor (int i = 0; i < n; ++i){\n\t\t// printf(\"%d %d %d %d %d %d\\n\", unzipx[x1[i]], unzipy[y1[i]], unzipz[z1[i]], unzipx[x2[i]], unzipy[y2[i]], unzipz[z2[i]]);\n\t\tfor (int x = unzipx[x1[i]]; x < unzipx[x2[i]]; ++x){\n\t\t\tfor (int y = unzipy[y1[i]]; y < unzipy[y2[i]]; ++y){\n\t\t\t\tfor (int z = unzipz[z1[i]]; z < unzipz[z2[i]]; ++z){\n\t\t\t\t\t// printf(\"%d %d %d \\n\", x, y, z);\n\t\t\t\t\tnum[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\trep(x, 100)rep(y, 100)rep(z, 100){\n\t\tif(num[x][y][z] >= k){\n\t\t\t// printf(\"%lld\\n\", zipx[x + 1] - zipx[x]);\n\t\t\t// printf(\"%lld\\n\", zipy[x + 1] - zipy[y]);\n\t\t\t// printf(\"%lld\\n\", zipz[x + 1] - zipz[z]);\n\t\t\tans += ((zipx[x + 1] - zipx[x]) * (zipy[y + 1] - zipy[y]) * (zipz[z + 1] - zipz[z]));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = {\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\ntypedef pair<pair<pii, int>, pair<pii, int>> Block;\n\nsigned main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tvector<Block> rg(n);\n\tvector<int> ax(2 * n), ay(2 * n), az(2 * n);\n\tauto fair = [](Block& block) {\n\t\tif (block.first.first.first > block.second.first.first) {\n\t\t\tswap(block.first.first.first, block.second.first.first);\n\t\t}\n\t\tif (block.first.first.second > block.second.first.second) {\n\t\t\tswap(block.first.first.second, block.second.first.second);\n\t\t}\n\t\tif (block.first.second > block.second.second) {\n\t\t\tswap(block.first.second, block.second.second);\n\t\t}\n\t};\n\tREP(i, n) {\n\t\tint x, y, z;\n\t\tscanf(\"%d %d %d\", &x, &y, &z);\n\t\trg[i].first = { {x,y},z };\n\t\tax[i * 2] = x;\n\t\tay[i * 2] = y;\n\t\taz[i * 2] = z;\n\t\tscanf(\"%d %d %d\", &x, &y, &z);\n\t\trg[i].second = { {x,y}, z };\n\t\tfair(rg[i]);\n\t\tax[i * 2 + 1] = x;\n\t\tay[i * 2 + 1] = y;\n\t\taz[i * 2 + 1] = z;\n\t}\n\tsort(ALL(ax));\n\tsort(ALL(ay));\n\tsort(ALL(az));\n\tax.erase(unique(ALL(ax)),ax.end());\n\tay.erase(unique(ALL(ay)), ay.end());\n\taz.erase(unique(ALL(az)), az.end());\n\tauto incl = [](int k, int n, Block b1, Block b2) {\n\t\tbool f = 1;\n\t\tif (b1.first.first.first > b2.first.first.first)\n\t\t\tf = 0;\n\t\tif (b1.first.first.second > b2.first.first.second)\n\t\t\tf = 0;\n\t\tif (b1.first.second > b2.first.second)\n\t\t\tf = 0;\n\t\tif (b1.second.first.first < b2.second.first.first)\n\t\t\tf = 0;\n\t\tif (b1.second.first.second < b2.second.first.second)\n\t\t\tf = 0;\n\t\tif (b1.second.second < b2.second.second)\n\t\t\tf = 0;\n\t\treturn f;\n\t};\n\n\tll res = 0;\n\tREP(i1, ax.size() - 1) {\n\t\tREP(i2, ay.size() - 1) {\n\t\t\tREP(i3, az.size() - 1) {\n\t\t\t\tBlock nb = { {{ax[i1],ay[i2]},az[i3]},{ { ax[i1 + 1],ay[i2 + 1] },az[i3 + 1] } };\n\t\t\t\tfair(nb);\n\t\t\t\tint cou = 0;\n\t\t\t\tREP(i4, n) {\n\t\t\t\t\tcou += incl(k, n, rg[i4], nb);\n\t\t\t\t}\n\t\t\t\tif(cou >= k)\n\t\t\t\t\tres += (ll)(nb.second.first.first - nb.first.first.first) * (nb.second.first.second - nb.first.first.second) * (nb.second.second - nb.first.second);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 10001\n#define B 100\n#define dmp make_pair\n#define dpb push_back\n#define fi first\n#define se second\n#define P pair<int,int>\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\n\n/*chrono::system_clock::time_point  start;\nvoid timerstart(){start = chrono::system_clock::now();}\nvoid timerend(){\n\tauto end = chrono::system_clock::now();\n\tint elapsed = chrono::duration_cast<chrono::milliseconds>(end-start).count();\n\tprintf(\"%d[ms]\\n\", elapsed);\n}*/\n\nint n, k, fld[100][100][100];\nint cx[52][2], cy[52][2], cz[52][2];\nint dx[52], dy[52], dz[52];\nint compress1(int *x1, int *x2){\n\tvector<int> xs;\n\tfor(int i = 0;i < n;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tfor(int i = 0;i < xs.size();i++)dx[i] = xs[i];\n\tfor(int i = 0;i < n;i++){\n\t\tcx[i][0] = find(xs.begin(), xs.end(), x1[i])-xs.begin();\n\t\tcx[i][1] = find(xs.begin(), xs.end(), x2[i])-xs.begin();\n\t}\n\treturn xs.size();\n}\n\nint compress2(int *x1, int *x2){\n\tvector<int> xs;\n\tfor(int i = 0;i < n;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tfor(int i = 0;i < xs.size();i++)dy[i] = xs[i];\n\tfor(int i = 0;i < n;i++){\n\t\tcy[i][0] = find(xs.begin(), xs.end(), x1[i])-xs.begin();\n\t\tcy[i][1] = find(xs.begin(), xs.end(), x2[i])-xs.begin();\n\t}\n\treturn xs.size();\n}\n\nint compress3(int *x1, int *x2){\n\tvector<int> xs;\n\tfor(int i = 0;i < n;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tfor(int i = 0;i < xs.size();i++)dz[i] = xs[i];\n\tfor(int i = 0;i < n;i++){\n\t\tcz[i][0] = find(xs.begin(), xs.end(), x1[i])-xs.begin();\n\t\tcz[i][1] = find(xs.begin(), xs.end(), x2[i])-xs.begin();\n\t}\n\treturn xs.size();\n}\n\nvoid paint(int w, int h, int d){\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int x = cx[i][0]+1;x <= cx[i][1];x++){\n\t\t\tfor(int y = cy[i][0]+1;y <= cy[i][1];y++){\n\t\t\t\tfor(int z = cz[i][0]+1;z <= cz[i][1];z++){\n\t\t\t\t\tfld[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint X1[52], X2[52], Y1[52], Y2[52], Z1[52], Z2[52];\n\tscanf(\"%d%d\", &n, &k);\n\trep(i,n){\n\t\tscanf(\"%d%d%d\", &X1[i], &Y1[i], &Z1[i]);\n\t\tscanf(\"%d%d%d\", &X2[i], &Y2[i], &Z2[i]);\n\t}\n\tint w = compress1(X1, X2);\n\tint h = compress2(Y1, Y2);\n\tint d = compress3(Z1, Z2);\n\tpaint(w, h, d);\n\t\n\tll ans = 0, t1, t2, t3;\n\tfor(int x = 1;x < w;x++){\n\t\tfor(int y = 1;y < h;y++){\n\t\t\tfor(int z = 1;z < d;z++){\n\t\t\t\tif(fld[x][y][z] >= k){\n\t\t\t\t\tt1 = dx[x]-dx[x-1];\n\t\t\t\t\tt2 = dy[y]-dy[y-1];\n\t\t\t\t\tt3 = dz[z]-dz[z-1];\n\t\t\t\t\tans += t1*t2*t3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t/*for(int i = 0;i < n;i++){\n\t\tprintf(\"%d %d\\n\", cy[i][0], cy[i][1]);\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tprintf(\"%d \", dy[i]);\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nstruct vec3{\npublic:\n  int x,y,z;\n  vec3():x(0),y(0),z(0) {}\n  vec3(int x,int y,int z):x(x),y(y),z(z) {}\n};\n\nint dp[100][100][100];\n\nint main(){\n  // ??´?????????K?????\\???????????£???????????¨????????°????????????\n  // 1<=K<=N<=50\n  // ??§?¨???§??????\n  // ?????????????????????\n  // ?????????N^3 <= 125000\n  // ????¬????imos??§????????°???????????¨???????????????\n  int n,k;\n  cin>>n>>k;\n  vec3 A[n],B[n];\n  set<int> Xs,Ys,Zs;\n  REP(i,n){\n    int x,y,z;\n    cin>>x>>y>>z;\n    A[i] = vec3(x,y,z);\n    Xs.insert(x);\n    Ys.insert(y);\n    Zs.insert(z);\n    cin>>x>>y>>z;\n    B[i] = vec3(x,y,z);\n    Xs.insert(x);\n    Ys.insert(y);\n    Zs.insert(z);\n  }\n  int Xc = Xs.size(), Yc = Ys.size(), Zc = Zs.size();\n  vi Xa, Ya, Za;\n  map<int,int> Xm,Ym,Zm;\n  set<int>::iterator iter;\n  iter = Xs.begin();\n  while(iter!=Xs.end()){\n    Xm[*iter] = Xa.size();\n    Xa.push_back(*iter);\n    ++iter;\n  }\n  iter = Ys.begin();\n  while(iter!=Ys.end()){\n    Ym[*iter] = Ya.size();\n    Ya.push_back(*iter);\n    ++iter;\n  }\n  iter = Zs.begin();\n  while(iter!=Zs.end()){\n    Zm[*iter] = Za.size();\n    Za.push_back(*iter);\n    ++iter;\n  }\n  // imos\n  REP(i,n){\n    vec3 a = A[i], b = B[i];\n    int ax = Xm[a.x],\n        ay = Ym[a.y],\n        az = Zm[a.z],\n        bx = Xm[b.x],\n        by = Ym[b.y],\n        bz = Zm[b.z];\n    dp[ax][ay][az] += 1;\n    dp[ax][ay][bz] -= 1;\n    dp[ax][by][az] -= 1;\n    dp[bx][ay][az] -= 1;\n    dp[ax][by][bz] += 1;\n    dp[bx][ay][bz] += 1;\n    dp[bx][by][az] += 1;\n    dp[bx][by][bz] -= 1;\n  }\n  REPR(x,77)REP(y,77)REP(z,77){\n    dp[x][y][z] += dp[x-1][y][z];\n  }\n  REP(x,77)REPR(y,77)REP(z,77){\n    dp[x][y][z] += dp[x][y-1][z];\n  }\n  REP(x,77)REP(y,77)REPR(z,77){\n    dp[x][y][z] += dp[x][y][z-1];\n  }\n  ll result = 0;\n  REP(x,Xc-1)REP(y,Yc-1)REP(z,Zc-1){\n    if(dp[x][y][z] >= k){\n      result += (ll)(Xa[x+1]-Xa[x])*(ll)(Ya[y+1]-Ya[y])*(ll)(Za[z+1]-Za[z]);\n    }\n  }\n  cout<<result<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\ntypedef long long ll;\n\n#include <algorithm>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ninline bool contain(const int x1, const int y1, const int z1,\n                    const int x2, const int y2, const int z2,\n                    const int x,  const int y,  const int z){\n  return x1 <= x && x <= x2 &&\n    y1 <= y && y <= y2 &&\n    z1 <= z && z <= z2;\n}\n\nint main(){\n  const int n = getInt();\n  const int k = getInt();\n\n  vector<int> xl(n), xh(n);\n  vector<int> yl(n), yh(n);\n  vector<int> zl(n), zh(n);\n\n  vector<int> xc, yc, zc;\n\n  REP(i,n){\n    xc.push_back(xl[i] = getInt());\n    yc.push_back(yl[i] = getInt());\n    zc.push_back(zl[i] = getInt());\n    xc.push_back(xh[i] = getInt());\n    yc.push_back(yh[i] = getInt());\n    zc.push_back(zh[i] = getInt());\n  }\n\n  sort(xc.begin(), xc.end());\n  sort(yc.begin(), yc.end());\n  sort(zc.begin(), zc.end());\n\n  xc.erase(unique(xc.begin(), xc.end()), xc.end());\n  yc.erase(unique(yc.begin(), yc.end()), yc.end());\n  zc.erase(unique(zc.begin(), zc.end()), zc.end());\n\n  ll ans = 0;\n  REP(ii,xc.size() - 1) REP(jj,yc.size() - 1) REP(kk,zc.size() - 1){\n    const int x1 = xc[ii];\n    const int x2 = xc[ii + 1];\n    const int y1 = yc[jj];\n    const int y2 = yc[jj + 1];\n    const int z1 = zc[kk];\n    const int z2 = zc[kk + 1];\n\n    int cnt = 0;\n    REP(a, n){\n      if(contain(xl[a], yl[a], zl[a],\n                 xh[a], yh[a], zh[a],\n                 x1, y1, z1) &&\n         contain(xl[a], yl[a], zl[a],\n                 xh[a], yh[a], zh[a],\n                 x2, y2, z2))\n        cnt++;\n    }\n\n    if(cnt >= k){\n      ans += (ll)(x2 - x1) * (ll)(y2 - y1) * (ll)(z2 - z1);\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint coun[105][105][105];\nvector<int>x,y,z;\nint rx[52][2], ry[52][2], rz[52][2];\nint a[52],b[52],c[52],d[52],e[52],f[52];\nint n,m;\n\nint compress1(){\n\tfor(int i = 0;i < n;i++){\n\t\tx.push_back(a[i]);\n\t\tx.push_back(d[i]);\n\t}\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tfor(int i = 0;i < n;i++){\n\t\trx[i][0] = find(x.begin(),x.end(),a[i])-x.begin();\n\t\trx[i][1] = find(x.begin(),x.end(),d[i])-x.begin();\n\t}\n\treturn 0;\n}\n\nint compress2(){\n\tfor(int i = 0;i < n;i++){\n\t\ty.push_back(b[i]);\n       y.push_back(e[i]);\n\t}\n\tsort(y.begin(), y.end());\n\ty.erase(unique(y.begin(), y.end()), y.end());\n\tfor(int i = 0;i < n;i++){\n\t\try[i][0] = find(y.begin(),y.end(),b[i])-y.begin();\n\t\try[i][1] = find(y.begin(),y.end(),e[i])-y.begin();\n\t}\n\treturn 0;\n}\n\nint compress3(){\n\tfor(int i = 0;i < n;i++){\n\t\tz.push_back(c[i]);\n       z.push_back(f[i]);\n\t}\n\tsort(z.begin(), z.end());\n\tz.erase(unique(z.begin(), z.end()), z.end());\n\tfor(int i = 0;i < n;i++){\n\t\trz[i][0] = find(z.begin(),z.end(),c[i])-z.begin();\n\t\trz[i][1] = find(z.begin(),z.end(),f[i])-z.begin();\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d %d %d %d %d\",&a[i],&b[i],&c[i],&d[i],&e[i],&f[i]);\n\t}\n\tcompress1();\n\tcompress2();\n\tcompress3();\n\tfor(int i = 0;i < n;i++){\n\tfor(int tx=rx[i][0];tx<rx[i][1];tx++)\n    {\n      for(int ty=ry[i][0];ty<ry[i][1];ty++)\n        {\n          for(int tz=rz[i][0];tz<rz[i][1];tz++)\n        {\n          coun[tx][ty][tz]++;\n        }\n        }\n    }\n\t}\n  long long ans=0;\n  for(int i=0;i<=100;i++)\n    {\n      for(int j=0;j<=100;j++)\n    {\n      for(int k=0;k<=100;k++)\n        {\n          if(coun[i][j][k]>=m)\n        {\n          long long s1=(x[i+1]-x[i]),s2=(y[j+1]-y[j]),s3=(z[k+1]-z[k]);\n          ans+=s1*s2*s3;\n        }\n        }\n    }\n    }\n\t//long long ans = 0;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<string>\n#include<vector>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\ntypedef unsigned long long ullong;\n\nstatic const int MAX = 50;\nstatic const int GMAX = 102;\n\nstruct Point{ ullong x, y, z; };\nint G[GMAX][GMAX][GMAX];\n\nmain(){\n  int N, K, nx, ny, nz;\n  cin >> N >> K;\n  pair<Point, Point> C[MAX];\n  set<ullong> X, Y, Z;\n  vector<ullong> VX, VY, VZ;\n  map<ullong, int> MX, MY, MZ;\n\n  rep(i, N){\n    cin >> C[i].first.x >> C[i].first.y >> C[i].first.z;\n    cin >> C[i].second.x >> C[i].second.y >> C[i].second.z;\n    X.insert(C[i].first.x);\n    X.insert(C[i].second.x);\n    Y.insert(C[i].first.y);\n    Y.insert(C[i].second.y);\n    Z.insert(C[i].first.z);\n    Z.insert(C[i].second.z);\n  }\n\n  nx = ny = nz = 0;\n  for ( set<ullong>::iterator it = X.begin(); it != X.end(); it++){\n    VX.push_back(*it);\n    MX[*it] = nx++;\n  }\n  for ( set<ullong>::iterator it = Y.begin(); it != Y.end(); it++){\n    VY.push_back(*it);\n    MY[*it] = ny++;\n  }\n  for ( set<ullong>::iterator it = Z.begin(); it != Z.end(); it++){\n    VZ.push_back(*it);\n    MZ[*it] = nz++;\n  }\n\n  rep(i, nx) rep(j, ny) rep(k, nz) G[i][j][k] = 0;\n\n  rep(i, N){\n    int sx = MX[C[i].first.x];\n    int tx = MX[C[i].second.x];\n    int sy = MY[C[i].first.y];\n    int ty = MY[C[i].second.y];\n    int sz = MZ[C[i].first.z];\n    int tz = MZ[C[i].second.z];\n    REP(x, sx, tx) REP(y, sy, ty) REP(z, sz, tz) G[x][y][z]++;\n  }\n\n  ullong sum = 0;\n  rep(x, nx){\n    rep(y, ny){\n      rep(z, nz){\n\tif ( G[x][y][z] >= K ){\n\t  sum += (VX[x+1] - VX[x])*(VY[y+1] - VY[y])*(VZ[z+1] - VZ[z]);\n\t}\n      }\n    }\n  }\n\n  cout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n\tint N, K;\n\tcin >> N >> K;\n\tvector<int> xs, ys, zs;\n\tmap<ll, int> xp, yp, zp;\n\tll x1[60], x2[60], y1[60], y2[60], z1[60], z2[60], xm[60], ym[60], zm[60], ans = 0;\n\tfor(int i = 0; i < N; ++i){\n\t\tscanf(\"%lld%lld%lld%lld%lld%lld\", &x1[i], &y1[i], &z1[i], &x2[i], &y2[i], &z2[i]);\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t\tys.push_back(y1[i]);\n\t\tys.push_back(y2[i]);\n\t\tzs.push_back(z1[i]);\n\t\tzs.push_back(z2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\tsort(zs.begin(), zs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tys.erase(unique(ys.begin(), ys.end()), ys.end());\n\tzs.erase(unique(zs.begin(), zs.end()), zs.end());\n\t\n\tfor(int i = 0; i < 2 * N; ++i){\n\t\tif(xs.size() > i){\n\t\t\txm[i] = xs[i];\n\t\t\txp[xs[i]] = i;\n\t\t}\n\t\tif(ys.size() > i){\n\t\t\tym[i] = ys[i];\n\t\t\typ[ys[i]] = i;\n\t\t}\n\t\tif(zs.size() > i){\n\t\t\tzm[i] = zs[i];\n\t\t\tzp[zs[i]] = i;\n\t\t}\n\t}\n\tint cnt[60][60][60] = {0};\n\tfor(int i = 0; i < N; ++i)\n\t\tfor(int j = xp[x1[i]]; j < xp[x2[i]]; ++j)\n\t\t\tfor(int k = yp[y1[i]]; k < yp[y2[i]]; ++k)\n\t\t\t\tfor(int l = zp[z1[i]]; l < zp[z2[i]]; ++l)\n\t\t\t\t\tcnt[j][k][l]++;\n\t\t\t\t\t\n\tfor(int i = 0; i < xs.size() - 1; ++i)\n\t\tfor(int j = 0; j < ys.size() - 1; ++j)\n\t\t\tfor(int k = 0; k < zs.size() - 1; ++k)\n\t\t\t\tif(cnt[i][j][k] >= K)\n\t\t\t\t\tans += ((ll)(xm[i + 1] - xm[i]) * (ym[j + 1] - ym[j]) * (zm[k + 1] - zm[k]));\n\t\n\tcout << ans << endl;\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nint xh[100],yh[100],zh[100];\nint bmx[50][2],xc;\nint bmy[50][2],yc;\nint bmz[50][2],zc;\nint n,p;\nint main(void){\n  scanf(\"%d%d\",&n,&p);\n  int i,j,k,m;\n  xc=0;yc=0;zc=0;\n  for(i=0;i<n;i++){\n    scanf(\"%d%d%d\",&(bmx[i][0]),&(bmy[i][0]),&(bmz[i][0]));\n    scanf(\"%d%d%d\",&(bmx[i][1]),&(bmy[i][1]),&(bmz[i][1]));\n    xh[xc]=bmx[i][0];xc++;\n    yh[yc]=bmy[i][0];yc++;\n    zh[zc]=bmz[i][0];zc++;\n    xh[xc]=bmx[i][1];xc++;\n    yh[yc]=bmy[i][1];yc++;\n    zh[zc]=bmz[i][1];zc++;\n  }\n  sort(xh,xh+xc);\n  sort(yh,yh+yc);\n  sort(zh,zh+zc);\n  int mc;\n  int ms;\n  mc=xc;\n  ms=xh[0];\n  xc=0;\n  for(i=1;i<mc;i++){\n    if(ms!=xh[i]){\n      xc++;\n      ms=xh[i];\n      xh[xc]=xh[i];\n    }\n  }\n  mc=yc;\n  ms=yh[0];\n  yc=0;\n  for(i=1;i<mc;i++){\n    if(ms!=yh[i]){\n      yc++;\n      ms=yh[i];\n      yh[yc]=yh[i];\n    }\n  }\n  mc=zc;\n  ms=zh[0];\n  zc=0;\n  for(i=1;i<mc;i++){\n    if(ms!=zh[i]){\n      zc++;\n      ms=zh[i];\n      zh[zc]=zh[i];\n    }\n  }\n  lli ans=0;\n  int co=0;\n  for(i=0;i<xc;i++){\n    for(j=0;j<yc;j++){\n      for(k=0;k<zc;k++){\n\tco=0;\n\tfor(m=0;m<n;m++){\n\t  if(xh[i]>=bmx[m][0] && xh[i+1]<=bmx[m][1] &&\n\t     yh[j]>=bmy[m][0] && yh[j+1]<=bmy[m][1] &&\n\t     zh[k]>=bmz[m][0] && zh[k+1]<=bmz[m][1]){\n\t    co++;\n\t  }\n\t}\n\tif(co>=p){\n\t  ans+=(lli)(xh[i+1]-xh[i])*(lli)(yh[j+1]-yh[j])*(lli)(zh[k+1]-zh[k]);\n\t  //printf(\"%d %d %d\\n\",i,j,k);\n\t}\n      }\n    }\n  }\n  /*printf(\"%d %d %d\\n\",xh[0],xh[1],xc);\n  printf(\"%d %d %d\\n\",yh[0],yh[1],yc);\n  printf(\"%d %d %d\\n\",zh[0],zh[1],zc);*/\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define ll long long int\n\nstruct ST\n{\n\tll x1, x2;\n\tll y1, y2;\n\tll z1, z2;\n};\n\nll x[100 + 10] = { 0 };\nll y[100 + 10] = { 0 };\nll z[100 + 10] = { 0 };\n\nll area = 0;\n\nint main()\n{\n\tST fish[50 + 10];\n\n\tint n,k;\n\n\tint i, j;\n\tint xi, yi, zi;\n\n\tint cnt = 0;\n\n\t\n\n\t/*\n\tcin >> n;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tcin >> x[i];\n\t}\n\tsort(x, x + n);\n\tfor (i = 0; i < n + 5; i++)\n\t{\n\t\tcout << x[i] << \" \";\n\t}\n\t*/\n\n\t\n\tcin >> n >> k;\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tcin >> fish[i].x1 >> fish[i].y1 >> fish[i].z1 >> fish[i].x2 >> fish[i].y2 >> fish[i].z2;\n\n\t\tx[i * 2] = fish[i].x1;\n\t\tx[(i * 2) + 1] = fish[i].x2;\n\t\ty[i * 2] = fish[i].y1;\n\t\ty[(i * 2) + 1] = fish[i].y2;\n\t\tz[i * 2] = fish[i].z1;\n\t\tz[(i * 2) + 1] = fish[i].z2;\n\t}\n\n\tsort(x, x + (n * 2));\n\tsort(y, y + (n * 2));\n\tsort(z, z + (n * 2));\n\n\tfor (xi = 0; xi < n * 2 -1; xi++)\n\t{\n\t\tfor (yi = 0; yi < n * 2 -1; yi++)\n\t\t{\n\t\t\tfor (zi = 0; zi < n * 2 -1; zi++)\n\t\t\t{\n\t\t\t\tcnt = 0;\n\t\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\t{\n\t\t\t\t\tif (fish[i].x1 > x[xi] || x[xi + 1] > fish[i].x2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (fish[i].y1 > y[yi] || y[yi + 1] > fish[i].y2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (fish[i].z1 > z[zi] || x[zi + 1] > fish[i].z2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\n\t\t\t\tif (cnt >= k)\n\t\t\t\t{\n\t\t\t\t\tarea += (x[xi + 1] - x[xi]) * (y[yi + 1] - y[yi]) * (z[zi + 1] - z[zi]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << area << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nint q[55][2][3];\n\nint xx[111];\nint yy[111];\nint zz[111];\n\nint w[111][111][111];\n\nint main()\n{\n\tint n,k;\n\tscanf(\"%d %d\",&n,&k);\n\t\n\tpriority_queue<int,vector<int>,greater<int> > x,y,z;\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d %d %d %d %d %d\",&q[i][0][0],&q[i][0][1],&q[i][0][2],&q[i][1][0],&q[i][1][1],&q[i][1][2]);\n\t\tx.push(q[i][0][0]);\n\t\tx.push(q[i][1][0]);\n\t\ty.push(q[i][0][1]);\n\t\ty.push(q[i][1][1]);\n\t\tz.push(q[i][0][2]);\n\t\tz.push(q[i][1][2]);\n\t}\n\t\n\tint xw = 0;\n\tint yw = 0;\n\tint zw = 0;\n\tint mae;\n\tmae = -1;\n\twhile(x.empty() == false)\n\t{\n\t\tif(mae != x.top())\n\t\t{\n\t\t\txx[xw] = x.top();\n\t\t\tmae = x.top();\n\t\t\txw++;\n\t\t}\n\t\tx.pop();\n\t}\n\tmae = -1;\n\twhile(y.empty() == false)\n\t{\n\t\tif(mae != y.top())\n\t\t{\n\t\t\tyy[yw] = y.top();\n\t\t\tmae = y.top();\n\t\t\tyw++;\n\t\t}\n\t\ty.pop();\n\t}\n\tmae = -1;\n\twhile(z.empty() == false)\n\t{\n\t\tif(mae != z.top())\n\t\t{\n\t\t\tzz[zw] = z.top();\n\t\t\tmae = z.top();\n\t\t\tzw++;\n\t\t}\n\t\tz.pop();\n\t}\n\t\n\tfor(int i = 0; i < xw; i++)\n\t{\n\t\tfor(int ii = 0; ii < yw; ii++)\n\t\t{\n\t\t\tfor(int iii = 0; iii < zw; iii++)\n\t\t\t{\n\t\t\t\tw[i][ii][iii] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int j = 0; j < n; j++)\n\t{\n\t\tfor(int i = 0; i < xw; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < yw; ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii < zw; iii++)\n\t\t\t\t{\n\t\t\t\t\tif(q[j][0][0] <= xx[i] && xx[i] < q[j][1][0] && q[j][0][1] <= yy[ii] && yy[ii] < q[j][1][1] && q[j][0][2] <= zz[iii] && zz[iii] < q[j][1][2])\n\t\t\t\t\t{\n\t\t\t\t\t\tw[i][ii][iii]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long int all = 0;\n\tfor(int i = 0; i < xw; i++)\n\t{\n\t\tfor(int ii = 0; ii < yw; ii++)\n\t\t{\n\t\t\tfor(int iii = 0; iii < zw; iii++)\n\t\t\t{\n\t\t\t\tif(w[i][ii][iii] >= k)\n\t\t\t\t{\n\t\t\t\t\tall += (xx[i + 1] - xx[i]) * (yy[ii + 1] - yy[ii]) * (zz[iii + 1] - zz[iii]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\",all);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Event {\n  ll kind, depth, x1, x2, y1, y2;\n};\nbool operator<(const Event &e, const Event &f) {\n  if (e.depth != f.depth) return e.depth < f.depth;\n  if (e.kind != f.kind) return e.kind < f.kind;\n  return e.x1 < f.x1;\n}\n\nint cnt[101][101];\n\nint main() {\n  int N,K;\n  cin>>N>>K;\n  set<ll> x,y;\n  int x1,x2,y1,y2,d1,d2;\n  vector<Event> evs;\n  for (int i=0; i<N; ++i) {\n    cin>>x1>>y1>>d1>>x2>>y2>>d2;\n    x.insert(x1); x.insert(x2);\n    y.insert(y1); y.insert(y2);\n    evs.push_back((Event){0,d1,x1,x2,y1,y2});\n    evs.push_back((Event){1,d2,x1,x2,y1,y2});\n  }\n\n  map<ll,ll> ix, iy, rx, ry;\n  for (set<ll>::iterator it = x.begin(); it != x.end(); ++it) {\n    if (ix.find(*it) == ix.end()) {\n      ll p = ix.size(); ix[*it] = p;\n      rx[p] = *it;\n    }\n  }\n  for (set<ll>::iterator it = y.begin(); it != y.end(); ++it) {\n    if (iy.find(*it) == iy.end()) {\n      ll p = iy.size(); iy[*it] = p;\n      ry[p] = *it;\n    }\n  }\n\n  for (int i=0; i<evs.size(); ++i) {\n    evs[i].x1 = ix[evs[i].x1];\n    evs[i].x2 = ix[evs[i].x2];\n    evs[i].y1 = iy[evs[i].y1];\n    evs[i].y2 = iy[evs[i].y2];\n  }\n\n  sort(evs.begin(), evs.end());\n  memset(cnt, 0, sizeof(cnt));\n\n  ll idx = 0, pd = 0;\n  ll ca = 0, ans = 0;\n  while(idx < evs.size()) {\n    ll cd = evs[idx].depth;\n    if (ca > 0) {\n      ans += ca*(cd-pd);\n      ca = 0;\n    }\n    pd = cd;\n    while(idx < evs.size()) {\n      if (evs[idx].depth != cd) break;\n      if (evs[idx].kind == 0) {\n        for (int i=evs[idx].x1; i<evs[idx].x2; ++i) {\n          for (int j=evs[idx].y1; j<evs[idx].y2; ++j)\n            cnt[j][i]++;\n        }\n      } else {\n        for (int i=evs[idx].x1; i<evs[idx].x2; ++i) {\n          for (int j=evs[idx].y1; j<evs[idx].y2; ++j)\n            cnt[j][i]--;\n        }\n      }\n      idx++;\n    }\n\n    // calc\n    //cout<<idx<<endl;\n    for (int i=0; i<51; ++i) {\n      for (int j=0; j<51; ++j) {\n        //cout<<cnt[i][j]<<\" \";\n        if (cnt[i][j] >= K) {\n          ca += (ll)(rx[j+1]-rx[j])*(ry[i+1]-ry[i]);\n        }\n      }\n      //cout<<endl;\n    }\n\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n#define FI first\n#define SE second\n#define PB push_back\n#define MT make_tuple\nusing namespace std;\n\nint N,K;\nint fld[105][105][105];\nint X1[55],X2[55],Y1[55],Y2[55],Z1[55],Z2[55];\nvector<int> X,Y,Z;\n\nvector<int> compress(int *x1,int *x2){\n    vector<int> xs;\n    for(int i=0;i<N;++i){\n        xs.PB(x1[i]);\n        xs.PB(x2[i]);\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    vector<int> length;\n    for(int i=0;i<xs.size()-1;++i){\n        length.PB(xs[i+1]-xs[i]);\n    }\n    return length;\n}\n\n\nint main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    X=compress(X1,X2);\n    Y=compress(Y1,Y2);\n    Z=compress(Z1,Z2);\n    for(int i=0;i<N;++i){\n        for(int x=X1[i];x<X2[i];++x){\n            for(int y=Y1[i];y<Y2[i];++y){\n                for(int z=Z1[i];z<Z2[i];++z){\n                    fld[x][y][z]++;\n                }\n            }\n        }\n    }\n    int ans=0;\n    for(int x=0;x<X.size();++x){\n        for(int y=0;y<Y.size();++y){\n            for(int z=0;z<Z.size();++z){\n                if(fld[x][y][z]>=K)ans+=X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define ll long long int\n\nstruct ST\n{\n\tll x1, x2;\n\tll y1, y2;\n\tll z1, z2;\n};\n\nll x[100 + 10] = { 0 };\nll y[100 + 10] = { 0 };\nll z[100 + 10] = { 0 };\n\nll area = 0;\n\nint main()\n{\n\tST fish[50 + 10];\n\n\tint n,k;\n\n\tint i, j;\n\tint xi, yi, zi;\n\n\tint cnt = 0;\n\n\n\t\n\tcin >> n >> k;\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tcin >> fish[i].x1 >> fish[i].y1 >> fish[i].z1 >> fish[i].x2 >> fish[i].y2 >> fish[i].z2;\n\n\t\tx[i * 2] = fish[i].x1;\n\t\tx[(i * 2) + 1] = fish[i].x2;\n\t\ty[i * 2] = fish[i].y1;\n\t\ty[(i * 2) + 1] = fish[i].y2;\n\t\tz[i * 2] = fish[i].z1;\n\t\tz[(i * 2) + 1] = fish[i].z2;\n\t}\n\n\tsort(x, x + (n * 2));\n\tsort(y, y + (n * 2));\n\tsort(z, z + (n * 2));\n\n\tfor (xi = 0; xi < n * 2 -1; xi++)\n\t{\n\t\tfor (yi = 0; yi < n * 2 -1; yi++)\n\t\t{\n\t\t\tfor (zi = 0; zi < n * 2 -1; zi++)\n\t\t\t{\n\t\t\t\tcnt = 0;\n\t\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\t{\n\t\t\t\t\tif (fish[i].x1 > x[xi] || x[xi + 1] > fish[i].x2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (fish[i].y1 > y[yi] || y[yi + 1] > fish[i].y2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (fish[i].z1 > z[zi] || z[zi + 1] > fish[i].z2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\n\t\t\t\tif (cnt >= k)\n\t\t\t\t{\n\t\t\t\t\tarea += (x[xi + 1] - x[xi]) * (y[yi + 1] - y[yi]) * (z[zi + 1] - z[zi]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << area << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\ntypedef unsigned long long ull;\nconst int MAX_N = 50;\nint N, K;\n\nint x1[MAX_N], y1[MAX_N], d1[MAX_N], x2[MAX_N], y2[MAX_N], d2[MAX_N];\n\nint countKind(int x, int y, int d){\n\tint ans = 0;\n\tx++; y++; d++;\n\tfor(int i=0; i<N; i++){\n\t\tif(x1[i]<=x && x<=x2[i] && y1[i]<=y && y<=y2[i] && d1[i]<=d && d<=d2[i]) ans ++;\n\t}\n\treturn ans;\n}\n\nusing namespace std;\n\nint main(){\n\tull v = 0;\n\tcin >> N >> K;\n\n\tvector<int> X(2*N), Y(2*N), D(2*N);\n\n\tfor(int i=0; i<N; i++){\n\t\tcin >> x1[i] >> y1[i] >> d1[i] >> x2[i] >> y2[i] >> d2[i];\n\t\tX[i]   = x1[i];\n\t\tX[i+N] = x2[i];\n\t\tY[i]   = y1[i];\n\t\tY[i+N] = y2[i];\n\t\tD[i]   = d1[i];\n\t\tD[i+N] = d2[i];\n\t}\n\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\tfor(int i=0; i<2*N-1; i++){\n\tfor(int j=0; j<2*N-1; j++){\n\tfor(int k=0; k<2*N-1; k++){\n\t\tv += (countKind(X[i], Y[j], D[k]) >= K ? (ull)(X[i+1]-X[i]) * (ull)(Y[j+1]-Y[j]) * (ull)(D[k+1]-D[k]) : 0);\n\t}}}\n\n\tprintf(\"%llu\\n\", v);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N, K;\n\tcin >> N >> K;\n\n\tvector<int> X1(N);\n\tvector<int> Y1(N);\n\tvector<int> D1(N);\n\tvector<int> X2(N);\n\tvector<int> Y2(N);\n\tvector<int> D2(N);\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> X1[i] >> Y1[i]>> D1[i]>> X2[i]>> Y2[i]>> D2[i];\n\t}\n\t\n\t//ソート用vector\n\tvector<int> X(2*N);\n\tvector<int> Y(2*N);\n\tvector<int> D(2*N);\n\tfor (int i = 0; i < N; i++){\n\t\tX[2 * i]     = X1[i];\n\t\tX[2 * i + 1] = X2[i];\n\t\tY[2 * i]     = Y1[i];\n\t\tY[2 * i + 1] = Y2[i];\n\t\tD[2 * i]     = D1[i];\n\t\tD[2 * i + 1] = D2[i];\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\tlong long int ans = 0;\n\tint kasanari;\n\tfor (int i = 0; i < 2*N-1; i++){ //X\n\t\tfor (int j = 0; j < 2*N-1; j++){ //Y\n\t\t\tfor (int k = 0; k < 2*N-1; k++){ //D\n\t\t\t\tkasanari = 0;\n\t\t\t\tfor (int l = 0; l < N; l++){ //実際の直方体\n\t\t\t\t\tif ((X1[l]<=X[i] && X[i+1] <= X2[l]) &&\n\t\t\t\t\t\t(Y1[l]<=Y[j] && Y[j+1] <= Y2[l]) &&\n\t\t\t\t\t\t(D1[l]<=D[k] && D[k+1] <= D2[l]))\n\t\t\t\t\t\t++kasanari;\n\t\t\t\t}\n\t\t\t\tif (kasanari >= K){\n\t\t\t\t\tans += (X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) * (D[k + 1] - D[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n\nll x1[60], x2[60];\nll y1[60], y2[60];\nll z1[60], z2[60];\nvector<ll>xs, ys, zs;\nll zaatu(int n,int k) {\n\tll ans = 0;\n\tfor (int x = 0; x < xs.size() - 1; x++) {\n\t\tfor (int y = 0; y < ys.size() - 1; y++) {\n\t\t\tfor (int z = 0; z < zs.size() - 1; z++) {\n\t\t\t\tll c = 0;\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (x1[i] <= xs[x] && xs[x + 1] <= x2[i] &&\n\t\t\t\t\t\ty1[i] <= ys[y] && ys[y + 1] <= y2[i] &&\n\t\t\t\t\t\tz1[i] <= zs[z] && zs[z + 1] <= z2[i]) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (c >= k) {\n\t\t\t\t\tans += (xs[x + 1] - xs[x])*(ys[y + 1] - ys[y])*(zs[z + 1] - zs[z]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x1[i] >> x2[i] >> y1[i] >> y2[i] >> z1[i] >> z2[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t\tys.push_back(y1[i]);\n\t\tys.push_back(y2[i]);\n\t\tzs.push_back(z1[i]);\n\t\tzs.push_back(z2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\tsort(zs.begin(), zs.end());\n\tcout << zaatu(n, k) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nint n, k, s;\nll xmin[60], ymin[60], zmin[60], xmax[60], ymax[60], zmax[60];\nll x[114], y[114], z[114];\nll ans;\n\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%lld%lld%lld%lld%lld%lld\", &xmin[i], &ymin[i], &zmin[i], &xmax[i], &ymax[i], &zmax[i]);\n\t\t//xmin[i]++; ymin[i]++; zmin[i]++;\n\t\tx[s] = xmin[i]; y[s] = ymin[i]; z[s] = zmin[i];\n\t\ts++;\n\t\tx[s] = xmax[i]; y[s] = ymax[i]; z[s] = zmax[i];\n\t\ts++;\n\t}\n\tsort(x,x+s); sort(y,y+s); sort(z,z+s);\n\tfor(int i = 1; i < s; i++){\n\t\tfor(int j = 1; j < s; j++){\n\t\t\tfor(int u = 1; u < s; u++){\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int v = 0; v < n; v++){\n\t\t\t\t\tif(xmin[v] <= x[i-1] && x[i] <= xmax[v] && ymin[v] <= y[j-1] && y[j] <= ymax[v] && zmin[v] <= z[u-1] && z[u] <= zmax[v]){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt >= k){\n\t\t\t\t\tans += (x[i]-x[i-1])*(y[j]-y[j-1])*(z[u]-z[u-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nstruct vec3{\npublic:\n  int x,y,z;\n  vec3():x(0),y(0),z(0) {}\n  vec3(int x,int y,int z):x(x),y(y),z(z) {}\n};\n\nint dp[200][200][200];\n\nint main(){\n  // ??´?????????K?????\\???????????£???????????¨????????°????????????\n  // 1<=K<=N<=50\n  // ??§?¨???§??????\n  // ?????????????????????\n  // ?????????N^3 <= 125000\n  // ????¬????imos??§????????°???????????¨???????????????\n  int n,k;\n  cin>>n>>k;\n  vec3 A[n],B[n];\n  set<int> Xs,Ys,Zs;\n  REP(i,n){\n    int x,y,z;\n    cin>>x>>y>>z;\n    A[i] = vec3(x,y,z);\n    Xs.insert(x);\n    Ys.insert(y);\n    Zs.insert(z);\n    cin>>x>>y>>z;\n    B[i] = vec3(x,y,z);\n    Xs.insert(x);\n    Ys.insert(y);\n    Zs.insert(z);\n  }\n  int Xc = Xs.size(), Yc = Ys.size(), Zc = Zs.size();\n  vi Xa, Ya, Za;\n  map<int,int> Xm,Ym,Zm;\n  set<int>::iterator iter;\n  iter = Xs.begin();\n  while(iter!=Xs.end()){\n    Xm[*iter] = Xa.size();\n    Xa.push_back(*iter);\n    ++iter;\n  }\n  iter = Ys.begin();\n  while(iter!=Ys.end()){\n    Ym[*iter] = Ya.size();\n    Ya.push_back(*iter);\n    ++iter;\n  }\n  iter = Zs.begin();\n  while(iter!=Zs.end()){\n    Zm[*iter] = Za.size();\n    Za.push_back(*iter);\n    ++iter;\n  }\n  // imos\n  REP(i,n){\n    vec3 a = A[i], b = B[i];\n    int ax = Xm[a.x],\n        ay = Ym[a.y],\n        az = Zm[a.z],\n        bx = Xm[b.x],\n        by = Ym[b.y],\n        bz = Zm[b.z];\n    dp[ax][ay][az] += 1;\n    dp[ax][ay][bz] -= 1;\n    dp[ax][by][az] -= 1;\n    dp[bx][ay][az] -= 1;\n    dp[ax][by][bz] += 1;\n    dp[bx][ay][bz] += 1;\n    dp[bx][by][az] += 1;\n    dp[bx][by][bz] -= 1;\n  }\n  REPR(x,200)REP(y,200)REP(z,200){\n    dp[x][y][z] += dp[x-1][y][z];\n  }\n  REP(x,200)REPR(y,200)REP(z,200){\n    dp[x][y][z] += dp[x][y-1][z];\n  }\n  REP(x,200)REP(y,200)REPR(z,200){\n    dp[x][y][z] += dp[x][y][z-1];\n  }\n  ll result = 0;\n  REP(x,Xc-1)REP(y,Yc-1)REP(z,Zc-1){\n    if(dp[x][y][z] >= k){\n      result += (ll)(Xa[x+1]-Xa[x])*(ll)(Ya[y+1]-Ya[y])*(ll)(Za[z+1]-Za[z]);\n    }\n  }\n  cout<<result<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// JOI2013予選５　魚の生息範囲\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0580\n// ｘ座標ｙ座標ｄ座標で出てくるそれぞれの座標値で空間を区切る\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(void){\n    int N,K;\n    int X1[51],Y1[51],D1[51],X2[51],Y2[51],D2[51];\n    vector<unsigned long long> x,y,d;\n    cin >> N >> K;\n    for(int i=1;i<=N;i++){\n        cin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n        x.push_back(X1[i]);\n        x.push_back(X2[i]);\n        y.push_back(Y1[i]);\n        y.push_back(Y2[i]);\n        d.push_back(D1[i]);\n        d.push_back(D2[i]);\n    }\n    sort(x.begin(),x.end());\n    sort(y.begin(),y.end());\n    sort(d.begin(),d.end());\n    x.erase(unique(x.begin(), x.end()), x.end());\n    y.erase(unique(y.begin(), y.end()), y.end());\n    d.erase(unique(d.begin(), d.end()), d.end());\n    unsigned long long vol=0;\n    for(int i=0;i<x.size()-1;i++){\n        for(int j=0;j<y.size()-1;j++){\n            for(int k=0;k<d.size()-1;k++){\n                int count=0;\n                    for(int l=1;l<=N;l++){\n                        if(X1[l]<=x[i] && x[i+1]<=X2[l] && Y1[l]<=y[j] && y[j+1]<=Y2[l] && D1[l]<=d[k] && d[k+1]<=D2[l]){\n                            count++;\n                        }\n                    }\n                if(count>=K){\n                    vol=vol+(x[i+1]-x[i])*(y[j+1]-y[j])*(d[k+1]-d[k]);\n                }\n            }\n        }\n    }\n    cout << vol << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct XYZ{\nlong long xxx,yyy,ddd,xx,yy,dd;\n};\nlong long x[101],y[101],d[101];\nXYZ m[50];\nint main(){\nint i,j,n,k,delx=0,dely=0,deld=0,r,u,cnt=0,l;\nint t;\nlong long ans=0;\ncin>>n>>k;\nfor(i=0;i<n;i++){\ncin>>x[i*2]>>y[i*2]>>d[i*2]>>x[i*2+1]>>y[i*2+1]>>d[i*2+1];\nm[i].xxx=x[i*2];\nm[i].yyy=y[i*2];\nm[i].ddd=d[i*2];\nm[i].xx=x[i*2+1];\nm[i].yy=y[i*2+1];\nm[i].dd=d[i*2+1];\n}\nfor(i=0;i<n*2;i++){\nfor(j=i+1;j<n*2;j++){\nif(x[i]==x[j]&&x[j]<10000000){\nx[j]=10000010;\ndelx++;\n}\nif(x[i]>x[j]){\nt=x[i];\nx[i]=x[j];\nx[j]=t;\n}\nif(y[i]==y[j]&&y[j]<10000000){\ny[j]=10000010;\ndely++;\n}\nif(y[i]>y[j]){\nt=y[i];\ny[i]=y[j];\ny[j]=t;\n}\nif(d[i]==d[j]&&d[j]<10000000){\nd[j]=10000001;\ndeld++;\n}\nif(d[i]>d[j]){\nt=d[i];\nd[i]=d[j];\nd[j]=t;\n}\n}\n}\nfor(i=0;i<n*2-delx-1;i++){\nfor(j=0;j<n*2-dely-1;j++){\nfor(r=0;r<n*2-deld-1;r++){\ncnt=0;\nfor(u=0;u<n;u++){\n//cout<<\"bx=\"<<m[u].xxx<<\" x=\"<<x[i]<<\" x+1=\"<<x[i+1]<<\" ax=\"<<m[u].xx<<\" by=\"<<m[u].yyy<<\" y=\"<<y[j]<<\" y+1=\"<<y[j+1]<<\" ay=\"<<m[u].yy<<\" bd=\"<<m[u].ddd<<\" d=\"<<d[r]<<\" d+1=\"<<d[r+1]<<\" ad=\"<<m[u].dd; \nif(m[u].xxx<=x[i]&&m[u].xx>=x[i+1]&&m[u].yy>=y[j+1]&&m[u].yyy<=y[j]&&m[u].ddd<=d[r]&&m[u].dd>=d[r+1])cnt++;\n//cout<<\"   cnt=\"<<cnt<<endl;\n}\nif(cnt>=k)ans=ans+(x[i+1]-x[i])*(y[j+1]-y[j])*(d[r+1]-d[r]);\n}\n}\n}\ncout<<ans<<endl;\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios_base::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\nstruct Cube {\n  int sx, sy, sd;\n  int ex, ey, ed;\n  Cube(int sx, int sy, int sd, int ex, int ey, int ed) :\n    sx(sx), sy(sy), sd(sd), ex(ex), ey(ey), ed(ed) {}\n};\n\nint imos[128][128][128];\n\nint main()\n{\n  int N, K;\n  cin >> N >> K;\n\n  vector<Cube> cs;\n  vector<int> X, Y, D;\n  for (int i = 0; i < N; i++){\n    int sx, sy, sd, ex, ey, ed;\n    cin >> sx >> sy >> sd >> ex >> ey >> ed;\n    cs.emplace_back(sx, sy, sd, ex, ey, ed);\n    X.push_back(sx);\n    X.push_back(ex);\n    Y.push_back(sy);\n    Y.push_back(ey);\n    D.push_back(sd);\n    D.push_back(ed);\n  }\n  sort(X), sort(Y), sort(D);\n  map<int, int> CX, CY, CD;\n  N *= 2;\n  for (int i = 0; i < N; i++){\n    CD[D[i]] = CY[Y[i]]= CX[X[i]] = i;\n  }\n  for (auto& c : cs){\n    int csx = CX[c.sx], csy = CY[c.sy], csd = CD[c.sd];\n    int cex = CX[c.ex], cey = CY[c.ey], ced = CD[c.ed];\n    // x -> y -> d\n    imos[csy][csx][csd]++;\n    imos[csy][cex][csd]--;\n    imos[cey][csx][csd]--;\n    imos[cey][cex][csd]++;\n    imos[csy][csx][ced]--;\n    imos[csy][cex][ced]++;\n    imos[cey][csx][ced]++;\n    imos[cey][cex][ced]--;\n  }\n  for (int d = 0; d < N; d++){\n    for (int y = 0; y < N; y++){\n      for (int x = 1; x < N; x++){\n        imos[y][x][d] += imos[y][x - 1][d];\n      }\n    }\n    for (int y = 1; y < N; y++){\n      for (int x = 0; x < N; x++){\n        imos[y][x][d] += imos[y - 1][x][d];\n      }\n    }\n  }\n  for (int d = 1; d < N; d++){\n    for (int y = 0; y < N; y++){\n      for (int x = 0; x < N; x++){\n        imos[y][x][d] += imos[y][x][d - 1];\n      }\n    }\n  }\n  ll ans = 0;\n  for (int d = 0; d < N; d++){\n    for (int y = 0; y < N; y++){\n      for (int x = 0; x < N; x++){\n        if (imos[y][x][d] >= K){\n          ans += (ll)(X[x + 1] - X[x]) * (Y[y + 1] - Y[y]) * (D[d + 1] - D[d]);\n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <string>\nconst int INF = 1 << 30;\nusing namespace std;\n\nint n, k;\n\nint pt[200][200][200];\nint X1[50], X2[50], Y1[50], Y2[50], D1[50], D2[50];\nlong long int uX[200], uY[200], uD[200];\n\nint compress(int *x1, int *x2, long long int *unzip){\n\tvector<int> vec;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = -1; j <= 1; j++){\n\t\t\tint a = x1[i] + j, b = x2[i] + j;\n\t\t\tif (0 <= a) vec.push_back(a);\n\t\t\tif (0 <= b) vec.push_back(b);\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tfor (int i = 0; i < n; i++){\n\t\tx1[i] = find(vec.begin(), vec.end(), x1[i]) - vec.begin();\n\t\tx2[i] = find(vec.begin(), vec.end(), x2[i]) - vec.begin();\n\t}\n\tfor (int i = 0; i < vec.size(); i++)\n\t\tunzip[i] = vec[i];\n\treturn vec.size();\n}\n\nint main(){\n\tint W, H, D;\n\tlong long int ans = 0;\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i];\n\t\tcin >> X2[i] >> Y2[i] >> D2[i];\n\t}\n\tW = compress(X1, X2, uX);\n\tH = compress(Y1, Y2, uY);\n\tD = compress(D1, D2, uD);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = X1[i]; j < X2[i]; j++){\n\t\t\tfor (int m = Y1[i]; m < Y2[i]; m++){\n\t\t\t\tfor (int l = D1[i]; l < D2[i]; l++){\n\t\t\t\t\tpt[j][m][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int m = 0; m <D; m++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tfor (int i = 0; i < W;i++){\n\t\t\t\tif (pt[i][j][m] >= k&&uX[i + 1] && uY[j + 1] && uD[m + 1]){\n\t\t\t\t\t\tans += (uX[i+1] - uX[i]) * (uY[j+1] - uY[j]) * (uD[m+1] - uD[m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint n, k;\nvector<ll> xs, ys, zs;\nmap<ll, ll> zipx, zipy, zipz;//<???, ??§??????>\nmap<ll, ll> unzipx, unzipy, unzipz;//<??§??????, ???>\nint num[100][100][100];//???????¨?????????\\??????\n\nint main(void){\n\tcin >> n >> k;\n\tll x1[51], x2[51], y1[51], y2[51], z1[51], z2[51];//?????????????????§?¨?\n\trep(i, n){\n\t\tcin >> x1[i] >> y1[i] >> z1[i];\n\t\tcin >> x2[i] >> y2[i] >> z2[i];\n\t\txs.push_back(x1[i]); xs.push_back(x2[i]);\n\t\tys.push_back(y1[i]); ys.push_back(y2[i]);\n\t\tzs.push_back(z1[i]); zs.push_back(z2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(),xs.end()), xs.end());//???????¶????\n\tsort(ys.begin(), ys.end());\n\tys.erase(unique(ys.begin(), ys.end()), ys.end());\n\tsort(zs.begin(), zs.end());\n\tzs.erase(unique(zs.begin(), zs.end()), zs.end());\n\n\trep(i, xs.size()){\n\t\tzipx[i] = xs[i];\n\t\tunzipx[xs[i]] = i;\n\t\t// printf(\"unzip[%d] = %d\\n\", xs[i], i);\n\t\t// printf(\"zip[%d] = %d\\n\", i, xs[i]);\n\t}\n\trep(i, ys.size()){\n\t\tzipy[i] = ys[i];\n\t\tunzipy[ys[i]] = i;\n\t\t// printf(\"unzip[%d] = %d\\n\", ys[i], i);\n\t\t// printf(\"zip[%d] = %d\\n\", i, ys[i]);\n\t}\n\trep(i, zs.size()){\n\t\tzipz[i] = zs[i];\n\t\tunzipz[zs[i]] = i;\n\t\t// printf(\"unzip[%d] = %d\\n\", zs[i], i);\n\t\t// printf(\"zip[%d] = %d\\n\", i, zs[i]);\n\t}\n\n\tmemset(num, 0, sizeof(num));\n\tfor (int i = 0; i < n; ++i){\n\t\t// printf(\"%d %d %d %d %d %d\\n\", unzipx[x1[i]], unzipy[y1[i]], unzipz[z1[i]], unzipx[x2[i]], unzipy[y2[i]], unzipz[z2[i]]);\n\t\tfor (int x = unzipx[x1[i]]; x < unzipx[x2[i]]; ++x){\n\t\t\tfor (int y = unzipy[y1[i]]; y < unzipy[y2[i]]; ++y){\n\t\t\t\tfor (int z = unzipz[z1[i]]; z < unzipz[z2[i]]; ++z){\n\t\t\t\t\t// printf(\"%d %d %d \\n\", x, y, z);\n\t\t\t\t\tnum[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\trep(x, 100)rep(y, 100)rep(z, 100){\n\t\tif(num[x][y][z] >= k){\n\t\t\t// printf(\"%lld\\n\", zipx[x + 1] - zipx[x]);\n\t\t\t// printf(\"%lld\\n\", zipy[x + 1] - zipy[y]);\n\t\t\t// printf(\"%lld\\n\", zipz[x + 1] - zipz[z]);\n\t\t\tans += ((zipx[x + 1] - zipx[x]) * (zipy[y + 1] - zipy[y]) * (zipz[z + 1] - zipz[z]));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define e(i,n) for(int i=0;i<n;i++)\nusing namespace std;int n,q,p;long long x[110],y[110],z[110],a[110][2],b[110][2],c[110][2],s;int main(){cin>>n>>q;e(i,2*n){cin>>x[i]>>y[i]>>z[i];a[i/2][i%2]=x[i],b[i/2][i%2]=y[i],c[i/2][i%2]=z[i];}sort(x,x+n*2);sort(y,y+n*2);sort(z,z+n*2);s=0;e(i,n*2-1)e(j,n*2-1)e(k,n*2-1){p=0;e(t,n){bool o=1;e(r,2){if(a[t][0]>x[i+r]||x[i+r]>a[t][1])o=0;if(b[t][0]>y[j+r]||y[j+r]>b[t][1])o=0;if(c[t][0]>z[k+r]||z[k+r]>c[t][1])o=0;}if(o)p++;}if(p>=q)s+=(x[i+1]-x[i])*(y[j+1]-y[j])*(z[k+1]-z[k]);}cout<<s<<endl;return 0;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n\tvector<int>x,y,d;\n\tstatic int zx[1000000+2],zy[1000000+2],zd[1000000+2],p[50][6],n,k,sea[102][102][102];\n\tlong long int ans=0,a;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<6;j++){\n\t\t\tscanf(\"%d\",&p[i][j]);\n\t\t}\n\t\tx.push_back(p[i][0]);\n\t\tx.push_back(p[i][3]);\n\t\ty.push_back(p[i][1]);\n\t\ty.push_back(p[i][4]);\n\t\td.push_back(p[i][2]);\n\t\td.push_back(p[i][5]);\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tsort(d.begin(),d.end());\n\tint N=2*n;\n\tfor(int i=0;i<N;i++){\n\t\tzx[x[i]]=i;\n\t\tzy[y[i]]=i;\n\t\tzd[d[i]]=i;\n\t}\n\tfor(int i=0;i<N+1;i++){\n\t\tfor(int j=0;j<N+1;j++){\n\t\t\tfor(int l=0;l<N+1;l++){\n\t\t\t\tsea[i][j][l]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tsea[zx[p[i][0]]][zy[p[i][1]]][zd[p[i][2]]]++;\n\t\tsea[zx[p[i][0]]][zy[p[i][1]]][zd[p[i][5]]]--;\n\t\tsea[zx[p[i][0]]][zy[p[i][4]]][zd[p[i][2]]]--;\n\t\tsea[zx[p[i][0]]][zy[p[i][4]]][zd[p[i][5]]]++;\n\t\tsea[zx[p[i][3]]][zy[p[i][1]]][zd[p[i][2]]]--;\n\t\tsea[zx[p[i][3]]][zy[p[i][1]]][zd[p[i][5]]]++;\n\t\tsea[zx[p[i][3]]][zy[p[i][4]]][zd[p[i][2]]]++;\n\t\tsea[zx[p[i][3]]][zy[p[i][4]]][zd[p[i][5]]]--;\n\t}\n\tfor(int i=1;i<N+1;i++){\n\t\tfor(int j=0;j<N+1;j++){\n\t\t\tfor(int l=0;l<N+1;l++){\n\t\t\t\tsea[i][j][l]+=sea[i-1][j][l];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<N+1;i++){\n\t\tfor(int j=1;j<N+1;j++){\n\t\t\tfor(int l=0;l<N+1;l++){\n\t\t\t\tsea[i][j][l]+=sea[i][j-1][l];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<N+1;i++){\n\t\tfor(int j=0;j<N+1;j++){\n\t\t\tfor(int l=0;l<N+1;l++){\n\t\t\t\tif(l!=0)sea[i][j][l]+=sea[i][j][l-1];\n\t\t\t\tif(sea[i][j][l]>=k){\n\t\t\t\t\ta=1;\n\t\t\t\t\ta*=x[i+1]-x[i];\n\t\t\t\t\ta*=y[j+1]-y[j];\n\t\t\t\t\ta*=d[l+1]-d[l];\n\t\t\t\t\tans+=a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <string>\nconst int INF = 1 << 30;\nusing namespace std;\n\nint n, k;\n\nshort int pt[300][300][300];\nint X1[50], X2[50], Y1[50], Y2[50], D1[50], D2[50];\nunsigned long long int uX[300], uY[300], uD[300];\n\nint compress(int *x1, int *x2, unsigned long long int *unzip){\n\tvector<int> vec;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = -1; j <= 1; j++){\n\t\t\tint a = x1[i] + j, b = x2[i] + j;\n\t\t\tif (0 <= a) vec.push_back(a);\n\t\t\tif (0 <= b) vec.push_back(b);\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tfor (int i = 0; i < n; i++){\n\t\tx1[i] = find(vec.begin(), vec.end(), x1[i]) - vec.begin();\n\t\tx2[i] = find(vec.begin(), vec.end(), x2[i]) - vec.begin();\n\t}\n\tfor (int i = 0; i < vec.size(); i++)\n\t\tunzip[i] = vec[i];\n\treturn vec.size();\n}\n\nint main(){\n\tint W, H, D;\n\tunsigned long long int ans = 0;\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i];\n\t\tcin >> X2[i] >> Y2[i] >> D2[i];\n\t}\n\tW = compress(X1, X2, uX);\n\tH = compress(Y1, Y2, uY);\n\tD = compress(D1, D2, uD);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = X1[i]; j < X2[i]; j++){\n\t\t\tfor (int m = Y1[i]; m < Y2[i]; m++){\n\t\t\t\tfor (int l = D1[i]; l < D2[i]; l++){\n\t\t\t\t\tpt[j][m][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int m = 0; m <D; m++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tfor (int i = 0; i < W;i++){\n\t\t\t\tif (pt[i][j][m] >= k&&uX[i + 1] && uY[j + 1] && uD[m + 1]){\n\t\t\t\t\t\tans += (uX[i+1] - uX[i]) * (uY[j+1] - uY[j]) * (uD[m+1] - uD[m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nlong long int n,k,x[52][2],y[52][2],d[52][2],ans=0;\nvector<long long int> zx,zy,zd;\n\nvector<long long int> f(vector<long long int> a){\n\tsort(a.begin(),a.end());\n\tint s=a.size();\n\tvector<long long int> ret;\n\tret.push_back(a[0]);\n\tfor(int i=1;i<s;i++){\n\t\tif(a[i]!=a[i-1])ret.push_back(a[i]);\n\t}\n\treturn ret;\n}\n\nlong long int find_x(int a){\n\t//cout<<\"f(x)\"<<a<<endl;\n\tlong long int l=0,r=zx.size()-1;\n\twhile(l<=r){\n\t\t//cout<<\"l=\"<<l<<\"r=\"<<r<<endl;\n\t\tint s=(l+r)/2;\n\t\tif(zx[s]==a)return s;\n\t\tif(zx[s]<a)l=s+1;\n\t\telse r=s-1;\n\t}\n\treturn -1;\n}\n\nlong long int find_y(int a){\n\tlong long int l=0,r=zy.size()-1;\n\twhile(l<=r){\n\t\tint s=(l+r)/2;\n\t\tif(zy[s]==a)return s;\n\t\tif(zy[s]<a)l=s+1;\n\t\telse r=s-1;\n\t}\n\treturn -1;\n}\n\nlong long int find_d(int a){\n\tlong long int l=0,r=zd.size()-1;\n\twhile(l<=r){\n\t\tint s=(l+r)/2;\n\t\tif(zd[s]==a)return s;\n\t\tif(zd[s]<a)l=s+1;\n\t\telse r=s-1;\n\t}\n\treturn -1;\n}\n\n\nint main(){\n\tzx.push_back(0);\n\tzx.push_back(1000000+2);\n\tzy.push_back(0);\n\tzy.push_back(1000000+2);\n\tzd.push_back(0);\n\tzd.push_back(1000000+2);\n\tscanf(\"%lld%lld\",&n,&k);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lld%lld%lld%lld%lld%lld\",&x[i][0],&y[i][0],&d[i][0],&x[i][1],&y[i][1],&d[i][1]);\n\t\tzx.push_back(x[i][0]);\n\t\tzx.push_back(x[i][1]);\n\t\tzy.push_back(y[i][0]);\n\t\tzy.push_back(y[i][1]);\n\t\tzd.push_back(d[i][0]);\n\t\tzd.push_back(d[i][1]);\n\t}\n\tzx=f(zx); zy=f(zy); zd=f(zd);\n\t/*sort(zx.begin(),zx.end());\n\tsort(zy.begin(),zy.end());\n\tsort(zd.begin(),zd.end());*/\n\tstatic long long int imos[105][105][105]={0};\n\tint siz=zx.size();\n\t//for(int i=0;i<siz;i++)cout<<zx[i]<<endl;\n\tfor(int i=0;i<n;i++){\n\t\t//cout<<i<<endl;\n\t\tlong long int fx[2]={find_x(x[i][0]),find_x(x[i][1])},fy[2]={find_y(y[i][0]),find_y(y[i][1])},fd[2]={find_d(d[i][0]),find_d(d[i][1])};\n\t\t//cout<<fx[0]<<\" \"<<fx[1]<<\" \"<<fy[0]<<\" \"<<fy[1]<<\" \"<<fd[0]<<\" \"<<fd[1]<<endl;\n\t\timos[fx[0]][fy[0]][fd[0]]++;\n\t\timos[fx[0]][fy[0]][fd[1]]--;\n\t\timos[fx[0]][fy[1]][fd[0]]--;\n\t\timos[fx[1]][fy[0]][fd[0]]--;\n\t\timos[fx[0]][fy[1]][fd[1]]++;\n\t\timos[fx[1]][fy[0]][fd[1]]++;\n\t\timos[fx[1]][fy[1]][fd[0]]++;\n\t\timos[fx[1]][fy[1]][fd[1]]--;\n\t}\n\t//for(int i=0;i<8;i++){for(int j=0;j<8;j++){for(int m=0;m<8;m++)cout<<imos[i][j][m]; cout<<endl;} cout<<endl;}\n\tfor(int i=1;i<105;i++)for(int j=0;j<105;j++)for(int m=0;m<105;m++)imos[i][j][m]+=imos[i-1][j][m];\n\tfor(int i=0;i<105;i++)for(int j=1;j<105;j++)for(int m=0;m<105;m++)imos[i][j][m]+=imos[i][j-1][m];\n\tfor(int i=0;i<105;i++)for(int j=0;j<105;j++)for(int m=1;m<105;m++)imos[i][j][m]+=imos[i][j][m-1];\n\t//for(int i=0;i<8;i++){for(int j=0;j<8;j++){for(int m=0;m<8;m++)cout<<imos[i][j][m]; cout<<endl;} cout<<endl;}\n\tfor(int i=0;i<105;i++)for(int j=0;j<105;j++)for(int m=0;m<105;m++){\n\t\tif(imos[i][j][m]>=k){\n\t\t\t//cout<<\"_________________________\"<<i<<\" \"<<j<<\" \"<<m<<\" \"<<imos[i][j][m]<<endl;\n\t\t\t//cout<<zx[i]<<\" \"<<zx[i+1]<<\" \"<<zy[j]<<\" \"<<zy[j+1]<<\" \"<<zd[m]<<\" \"<<zd[m+1]<<endl;\n\t\t\tans+=(zx[i+1]-zx[i])*(zy[j+1]-zy[j])*(zd[m+1]-zd[m]);\n\t\t\t//cout<<ans<<endl;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nstruct P{\n    int x,y,d;\n};\n\nint main(){\n    int N,K;\n    cin >> N >> K;\n    vector<pair<P,P>> box(N);\n    vector<ll> X,Y,D;\n    for(int i=0;i<N;i++){\n        cin >> box[i].first.x >> box[i].first.y >> box[i].first.d >> box[i].second.x >> box[i].second.y >> box[i].second.d;\n        X.pb(box[i].first.x);\n        X.pb(box[i].second.x);\n        Y.pb(box[i].first.y);\n        Y.pb(box[i].second.y);\n        D.pb(box[i].first.d);\n        D.pb(box[i].second.d);\n    }\n    sort(all(X));\n    sort(all(Y));\n    sort(all(D));\n    X.erase(unique(all(X)),X.end());\n    Y.erase(unique(all(Y)),Y.end());\n    D.erase(unique(all(D)),D.end());\n\n\n    vector<pair<P,P>> box2(N);      //??§???????????§?¨?\n    for(int i=0;i<N;i++){\n        box2[i].first.x = find(all(X),box[i].first.x) - X.begin();\n        box2[i].first.y = find(all(Y),box[i].first.y) - Y.begin();\n        box2[i].first.d = find(all(D),box[i].first.d) - D.begin();\n        box2[i].second.x = find(all(X),box[i].second.x) - X.begin();\n        box2[i].second.y = find(all(Y),box[i].second.y) - Y.begin();\n        box2[i].second.d = find(all(D),box[i].second.d) - D.begin();\n    }\n\n    int table[110][110][110];\n    for(int i=0;i<110;i++) for(int j=0;j<110;j++) for(int k=0;k<110;k++) table[i][j][k] = 0;\n\n    for(int i=0;i<N;i++){\n        for(int j=box2[i].first.x;j<box2[i].second.x;j++){\n            for(int k=box2[i].first.y;k<box2[i].second.y;k++){\n                for(int l=box2[i].first.d;l<box2[i].second.d;l++){\n                    table[j][k][l]++;\n                }\n            }\n        }\n    }\n\n    ll ans = 0;\n    for(int i=0;i<X.size();i++){\n        for(int j=0;j<Y.size();j++){\n            for(int k=0;k<D.size();k++){\n                if(table[i][j][k]>=K){\n                    ll V = (X[i+1]-X[i])*(Y[j+1]-Y[j])*(D[k+1]-D[k]);\n                    ans += V;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <complex>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FORE(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\nusing namespace std;\ntypedef long long ll;\ntypedef map<ll,ll> mi;\ntypedef vector<ll> vi;\nmi open[3],close[3];\nll fish[50][2][3];\nbool search(int x,int y,int z,int l){\n\tint num[3]={x,y,z};\n\tnum[0]=x;\n\tnum[1]=y;\n\tnum[2]=z;\n\tREP(i,3){\n\t\tif(fish[l][0][i]<=num[i] && fish[l][1][i]>=num[i]+1)\n\t\tcontinue;\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n\tll N,K;\n\tvi points[3];\n\tcin >> N >> K;\n\tREP(i,N)\n\t\tREP(j,2)\n\t\t\tREP(k,3){\n\t\t\t\tcin >> fish[i][j][k];\n\t\t\t\tpoints[k].push_back(fish[i][j][k]);\n\t\t\t}\n\tREP(i,3){\n\tpoints[i].push_back(0);\n\tsort(points[i].begin(),points[i].end());\n\tint count =0;\n\tREP(j,(int)points[i].size())\n\t\tif(j==1 || points[i][j]!=points[i][j-1]){\n\t\t\topen[i].insert(mi::value_type(count,points[i][j]));\n\t\t\tclose[i].insert(mi::value_type(points[i][j],count));\n\t\t\tcount++;\n\t\t}\n\t}\n\tREP(i,N)\n\t\tREP(j,2)\n\t\t\tREP(k,3){\n\t\t\t\tfish[i][j][k]=close[k][fish[i][j][k]];\n\t\t\t\t\n\t\t}\n\tll sum=0;\n\tREP(i,open[0].size()-1)\n\t\tREP(j,open[1].size()-1)\n\t\t\tREP(k,open[2].size()-1){\n\t\t\t\tint count=0;\n\t\t\t\tREP(l,N)\n\t\t\t\tcount+=search(i,j,k,l);\n\t\t\t\tif(count>=K)\n\t\t\t\tsum+=(open[0][i+1]-open[0][i])*(open[1][j+1]-open[1][j])*(open[2][k+1]-open[2][k]);\n\t\t\t}\n\tcout << sum << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint ary[110][110][110]={};\nint x1[60],x2[60],yy1[60],y2[60],d1[60],d2[60];\nset<int> X,Y,D;\nmap<int,int> mx,nmx,my,nmy,md,nmd;\nint main(){\n\tset<int>::iterator it;\n\tint N,K,xc,yc,dc,ax1,ax2,ayy1,ay2,ad1,ad2;\n\tcin>>N>>K;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>x1[i]>>yy1[i]>>d1[i]>>x2[i]>>y2[i]>>d2[i];\n\t\tX.insert(x1[i]);X.insert(x2[i]);\n\t\tY.insert(yy1[i]);Y.insert(y2[i]);\n\t\tD.insert(d1[i]);D.insert(d2[i]);\n\t}\n\txc=X.size();\n\tyc=Y.size();\n\tdc=D.size();\n\tit=X.begin();\n\tfor(int i=0;i<xc;i++){\n\t\tmx.insert(make_pair(*it,i));\n\t\tnmx.insert(make_pair(i,*it));\n\t\tit++;\n\t}\n\tit=Y.begin();\n\tfor(int i=0;i<yc;i++){\n\t\tmy.insert(make_pair(*it,i));\n\t\tnmy.insert(make_pair(i,*it));\n\t\tit++;\n\t}\n\tit=D.begin();\n\tfor(int i=0;i<dc;i++){\n\t\tmd.insert(make_pair(*it,i));\n\t\tnmd.insert(make_pair(i,*it));\n\t\tit++;\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tax1=mx[x1[i]];\n\t\tax2=mx[x2[i]];\n\t\tayy1=my[yy1[i]];\n\t\tay2=my[y2[i]];\n\t\tad1=md[d1[i]];\n\t\tad2=md[d2[i]];\n\t\tfor(int j=ax1;j<ax2;j++){\n\t\t\tfor(int k=ayy1;k<ay2;k++){\n\t\t\t\tfor(int l=ad1;l<ad2;l++){\n\t\t\t\t\tary[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int i=0;i<xc-1;i++){\n\t\tcout<<i<<\"??????\"<<endl;\n\t\tfor(int j=0;j<yc-1;j++){\n\t\t\tfor(int k=0;k<dc-1;k++){\n\t\t\t\tcout<<ary[i][j][k]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}*/\n\tlong long int cnt=0;\n\tfor(int i=0;i<xc-1;i++){\n\t\tfor(int j=0;j<yc-1;j++){\n\t\t\tfor(int k=0;k<dc-1;k++){\n\t\t\t\tif(ary[i][j][k]>=K){\n\t\t\t\t\t/*cout<<\"(\"<<nmx[i]<<\",\"<<nmy[j]<<\",\"<<nmd[k]<<\"),(\"<<nmx[i+1]<<\",\"<<nmy[j+1]<<\",\"<<nmd[k+1]<<\")????????? cnt+=\"<<(long long)(nmx[i+1]-nmx[i])*(long long)(nmy[j+1]-nmy[j])*(long long)(nmd[k+1]-nmd[k])<<endl;*/\n\t\t\t\t\tcnt+=(long long)(nmx[i+1]-nmx[i])*(long long)(nmy[j+1]-nmy[j])*(long long)(nmd[k+1]-nmd[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tint N,K;\n\tscanf(\"%d%d\",&N,&K);\n\tint x[2][50],y[2][50],z[2][50];\n\tvector<int> dx,dy,dz;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d%d%d\",&x[0][i],&y[0][i],&z[0][i],&x[1][i],&y[1][i],&z[1][i]);\n\t\tdx.push_back(x[0][i]); dx.push_back(x[1][i]);\n\t\tdy.push_back(y[0][i]); dy.push_back(y[1][i]);\n\t\tdz.push_back(z[0][i]); dz.push_back(z[1][i]);\n\t}\n\tsort(dx.begin(),dx.end());sort(dy.begin(),dy.end());sort(dz.begin(),dz.end());\n\tdx.erase(unique(dx.begin(),dx.end()),dx.end());\n\tdy.erase(unique(dy.begin(),dy.end()),dy.end());\n\tdz.erase(unique(dz.begin(),dz.end()),dz.end());\n\tint d[dx.size()-1][dy.size()-1][dz.size()-1];\n\tfor(int i=0;i<dx.size()-1;i++) for(int j=0;j<dy.size()-1;j++) for(int k=0;k<dz.size()-1;k++) d[i][j][k]=0;\n\tfor(int s=0;s<N;s++) for(int i=0;i<dx.size()-1;i++) for(int j=0;j<dy.size()-1;j++) for(int k=0;k<dz.size()-1;k++)\n\t\tif(x[0][s]<=dx[i]&&dx[i+1]<=x[1][s]) if(y[0][s]<=dy[j]&&dy[j+1]<=y[1][s]) if(z[0][s]<=dz[k]&&dz[k+1]<=z[1][s])\n\t\t\td[i][j][k]++;\n\tll res=0;\n\tfor(int i=0;i<dx.size()-1;i++) for(int j=0;j<dy.size()-1;j++) for(int k=0;k<dz.size()-1;k++)\n\t\tif(d[i][j][k]>=K) res+=(ll)(dx[i+1]-dx[i])*(dy[j+1]-dy[j])*(dz[k+1]-dz[k]);\n\tprintf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint n,K;\nint f[100][100][100];\nstruct area{ll x1,x2,y1,y2,d1,d2;};\nvector<area> all;\nset<ll> x,y,d;\nmap<int,ll> tx,ty,td;\nint main()\n{\n\tcin >> n >> K;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tarea in;\n\t\tcin >> in.x1 >> in.y1 >> in.d1 >> in.x2 >> in.y2 >> in.d2;\n\t\tall.pb(in);\n\t\tx.insert(in.x1);\n\t\tx.insert(in.x2);\n\t\ty.insert(in.y1);\n\t\ty.insert(in.y2);\n\t\td.insert(in.d1);\n\t\td.insert(in.d2);\n\t}\n\tint nx=x.size(),ny=y.size(),nd=d.size();\n\tset<ll>::iterator it;\n\tint p=0;\n\tfor(it=x.begin();it!=x.end();it++){tx[p++]=*it;}\n\tp=0;\n\tfor(it=y.begin();it!=y.end();it++){ty[p++]=*it;}\n\tp=0;\n\tfor(it=d.begin();it!=d.end();it++){td[p++]=*it;}\n\tfor(int i=0;i<all.size();i++)\n\t{\n\t\tfor(int j=0;j<nx-1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<ny-1;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<nd-1;l++)\n\t\t\t\t{\n\t\t\t\t\tif(all[i].x1<=tx[j]&&all[i].x2>tx[j]&&all[i].y1<=ty[k]&&all[i].y2>ty[k]&&all[i].d1<=td[l]&&all[i].d2>td[l]){f[j][k][l]++;/*cout << \"・∴'、-=≡ ≡ (っ'ヮ'c)ウッヒョ アアアアアアｗｗｗｗｗ\" << endl;*/}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0ll;\n\tfor(int i=0;i<nx-1;i++)\n\t{\n\t\tfor(int j=0;j<ny-1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<nd-1;k++)\n\t\t\t{\n\t\t\t\tif(f[i][j][k]>=K)\n\t\t\t\t{\n\t\t\t\t\tans+=(tx[i+1]-tx[i])*(ty[j+1]-ty[j])*(td[k+1]-td[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint coun[105][105][105]={};\nvector<int>x,y,z;\nint main()\n{\n  int n,m;\n  scanf(\"%d %d\",&n,&m);\n  int a[55],b[55],c[55],d[55],e[55],f[55];\n  for(int i=0;i<n;i++)\n    {\n      scanf(\"%d %d %d %d %d %d\",&a[i],&b[i],&c[i],&d[i],&e[i],&f[i]);\n       x.push_back(a[i]);\n       x.push_back(d[i]);\n       y.push_back(b[i]);\n       y.push_back(e[i]);\n       z.push_back(c[i]);\n       z.push_back(f[i]);\n    }\n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  sort(z.begin(),z.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n  z.erase(unique(z.begin(),z.end()),z.end());\n  for(int i=0;i<n;i++)\n    {\n      int r1=lower_bound(x.begin(),x.end(),a[i])-x.begin();\n      int r2=lower_bound(x.begin(),x.end(),d[i])-x.begin();\n      int r3=lower_bound(y.begin(),y.end(),b[i])-y.begin();\n      int r4=lower_bound(y.begin(),y.end(),e[i])-y.begin();\n      int r5=lower_bound(z.begin(),z.end(),c[i])-z.begin();\n      int r6=lower_bound(z.begin(),z.end(),f[i])-z.begin();\n      for(int i=r1;i<r2;i++)\n    {\n      for(int j=r3;j<r4;j++)\n        {\n          for(int k=r5;k<r6;k++)\n        {\n          coun[i][j][k]++;\n        }\n        }\n    }\n    }\n  long long ans=0;\n  for(int i=0;i<=100;i++)\n    {\n      for(int j=0;j<=100;j++)\n    {\n      for(int k=0;k<=100;k++)\n        {\n          if(coun[i][j][k]>=m)\n        {\n          long long s1=(x[i+1]-x[i]),s2=(y[j+1]-y[j]),s3=(z[k+1]-z[k]);\n          ans+=s1*s2*s3;\n        }\n        }\n    }\n    }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> mp;\ntypedef pair<mp ,int> mypair;\ntypedef pair<mp,pair<mp,mp> > tri;\ntypedef long long int ll;\nvoid print(vector<int> a){\n\tfor(int i=0;i<a.size();i++)cout<<a[i]<<' ';\n\tcout<<endl;\n}\nvoid print(vector<mp> a){\n\tfor(int i=0;i<a.size();i++)cout<<\" (\"<<a[i].first<<\" ,\"<<a[i].second<<\")\" ;\n\tcout<<endl;\n}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvector<int> x,y,d;\n\tvector<mp> mx(n),my(n),md(n);\n\tfor(int i=0;i<n;i++){\n\t\tint x1,x2,y1,y2,d1,d2;\n\t\tcin>>x1>>y1>>d1>>x2>>y2>>d2;\n\t\tx.push_back(x1);\n\t\tx.push_back(x2);\n\t\ty.push_back(y1);\n\t\ty.push_back(y2);\n\t\td.push_back(d1);\n\t\td.push_back(d2);\n\t\tmx[i]=mp(x1,x2);\n\t\tmy[i]=mp(y1,y2);\n\t\tmd[i] =mp(d1,d2);\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tsort(d.begin(),d.end() );\n\t//cout<<endl;\n\t//print(x);\n\t//print(y);\n\t//print(d);\n\t//cout<<endl;\n\t//print(mx);\n\t//print(my);\n\t//print(md);\n\t//cout<<endl;\n\t//sort(map.begin(),map.end() );\n\tll  ans = 0;\n\tfor(int i=0;i<x.size()-1;i++){\n\t\t\tif(x[i]==x[i+1])continue;\n\t\tfor(int j=0;j<y.size()-1;j++){\n\t\t\t\tif(y[j]==y[j+1])continue;\n\t\t\tfor(int k=0;k<d.size()-1;k++){\n\t\t\t\tif(d[k]==d[k+1])continue;\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int t=0;t<n;t++){\n\t\t\t\t\tmp nx = mx[t];\n\t\t\t\t\tmp ny = my[t];\n\t\t\t\t\tmp nd = md[t];\n\t\t\t\t\t\n\t\t\t\t\tif(nx.first<=x[i]&&x[i+1]<=nx.second&&\n\t\t\t\t\t\t\tny.first<=y[j]&&y[j+1]<=ny.second&&\n\t\t\t\t\t\t\tnd.first<=d[k]&&d[k+1]<=nd.second){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt>=m){\n\t\t\t\t\tll tmp=(ll( x[i+1]-x[i]))*(ll(y[j+1]-y[j]) )*(ll(d[k+1]-d[k]) );\n\t\t\t\t\t//cout<<x[i]<<' '<<y[j]<<' '<<d[k]<<\" \"<<tmp<<endl;\n\t\t\t\t\tans+=tmp;\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\ntypedef unsigned long long ull;\nconst int MAX_N = 50;\nint N, K;\n\nint x1[MAX_N], y1[MAX_N], d1[MAX_N], x2[MAX_N], y2[MAX_N], d2[MAX_N];\n\nint countKind(int x, int y, int d){\n\tint ans = 0;\n\tx++; y++; d++;\n\tfor(int i=0; i<N; i++){\n\t\tif(x1[i]<=x && x<=x2[i] && y1[i]<=y && y<=y2[i] && d1[i]<=d && d<=d2[i]) ans ++;\n\t}\n\treturn ans;\n}\n\nusing namespace std;\n\nint main(){\n\tull v = 0;\n\tcin >> N >> K;\n\n\tvector<int> X(2*N), Y(2*N), D(2*N);\n\n\tfor(int i=0; i<N; i++){\n\t\tcin >> x1[i] >> y1[i] >> d1[i] >> x2[i] >> y2[i] >> d2[i];\n\t\tX[i]   = x1[i];\n\t\tX[i+N] = x2[i];\n\t\tY[i]   = y1[i];\n\t\tY[i+N] = y2[i];\n\t\tD[i]   = d1[i];\n\t\tD[i+N] = d2[i];\n\t}\n\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\tfor(int i=0; i<2*N-1; i++){\n\tfor(int j=0; j<2*N-1; j++){\n\tfor(int k=0; k<2*N-1; k++){\n\t\tv += (countKind(X[i], Y[j], D[k]) >= K ? (ull)(X[i+1]-X[i]) * (Y[j+1]-Y[j]) * (D[k+1]-D[k]) : 0);\n\t}}}\n\n\tprintf(\"%llu\\n\", v);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct square{\n    long long x1,y1,z1,x2,y2,z2;\n};\n\nvector<square> rippous;\nset<long long> xs, ys, zs;\nmap<long long, long long>transx, transy, transz;\nlong long field[200][200][200];\nlong long xx[200], yy[200], zz[200], K, n;\nlong long res;\nint main(){\n    cin >> n >> K;\n    for(long long i = 0;i < n;i++){\n\tsquare tmp;\n\tcin >> tmp.x1 >> tmp.y1 >> tmp.z1 >> tmp.x2 >> tmp.y2 >> tmp.z2;\n\trippous.push_back(tmp);\n\txs.insert(tmp.x1);xs.insert(tmp.x2);\n\tys.insert(tmp.y1);ys.insert(tmp.y2);\n\tzs.insert(tmp.z1);zs.insert(tmp.z2);\n    }\n    set<long long>::iterator it = xs.begin();\n    long long ii = 0;\n    while(it != xs.end()){\n\txx[ii] = *it;\n\ttransx[*it] = ii;\n\tit++;\n\tii++;\n    }\n    ii = 0;\n    it = ys.begin();\n    while(it != ys.end()){\n\tyy[ii] = *it;\n\ttransy[*it] = ii;\n\tit++;\n\tii++;\n    }\n    ii = 0;\n    it = zs.begin();\n    while(it != zs.end()){\n\tzz[ii] = *it;\n\ttransz[*it] = ii;\n\tit++;\n\tii++;\n    }\n    for(long long i = 0;i < rippous.size();i++){\n\tsquare tmp = rippous[i];\n\ttmp.x1 = transx[tmp.x1];\n\ttmp.x2 = transx[tmp.x2];\n\ttmp.y1 = transy[tmp.y1];\n\ttmp.y2 = transy[tmp.y2];\n\ttmp.z1 = transz[tmp.z1];\n\ttmp.z2 = transz[tmp.z2];\n\tfield[tmp.x1][tmp.y1][tmp.z1] ++;\n\tfield[tmp.x2][tmp.y1][tmp.z1] --;\n\tfield[tmp.x1][tmp.y2][tmp.z1] --;\n\tfield[tmp.x2][tmp.y2][tmp.z1] ++;\n\tfield[tmp.x1][tmp.y1][tmp.z2] --;\n\tfield[tmp.x2][tmp.y1][tmp.z2] ++;\n\tfield[tmp.x1][tmp.y2][tmp.z2] ++;\n\tfield[tmp.x2][tmp.y2][tmp.z2] --;\n    }\n    for(long long i = 1;i < xs.size();i++){\n\tfor(long long j = 0;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tfield[i][j][k] += field[i - 1][j][k];\n\t    }\n\t}\n    }\n    for(long long i = 0;i < xs.size();i++){\n\tfor(long long j = 1;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tfield[i][j][k] += field[i][j - 1][k];\n\t    }\n\t}\n    }\n    for(long long i = 0;i < xs.size();i++){\n\tfor(long long j = 0;j < ys.size();j++){\n\t    for(long long k = 1;k < zs.size();k++){\n\t\tfield[i][j][k] += field[i][j][k - 1];\n\t    }\n\t}\n    }\n    for(long long i = 0;i < xs.size();i++){\n\tfor(long long j = 0;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tif(field[i][j][k] >= K) \n\t\t    res += (xx[i + 1] - xx[i]) * (yy[j + 1] - yy[j]) * (zz[k + 1] - zz[k]);\n\t    }\n\t}\n    } \n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint q[5000][7],p[6],qtop;\nbool ICV(int c[],int d[]){\n\tbool ret=true;\n\tfor(int i=0;i<3;i++){\n\t\tif(d[i]<c[i+3]&&d[i+3]>c[i])p[i]=max(c[i],d[i]),p[i+3]=min(c[i+3],d[i+3]);\n\t\telse ret=false;\n\t}\n\treturn ret;\n}\nint main(){\n\tint n,e;\n\tcin>>n>>e;\n\tqtop=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<6;j++)cin>>q[qtop][j];\n\t\tq[qtop][6]=1;\n\t\tint keep=qtop;\n\t\tqtop++;\n\t\tfor(int j=0;j<keep;j++){\n\t\t\tif(ICV(q[keep],q[j])){\n\t\t\t\tfor(int k=0;k<6;k++)q[qtop][k]=p[k];\n\t\t\t\tq[qtop][6]=q[j][6]+1;\n\t\t\t\tqtop++;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans[60]={0};\n\tfor(int i=0;i<qtop;i++){\n\t\tlong long v[3]={q[i][3]-q[i][0],q[i][4]-q[i][1],q[i][5]-q[i][2]};\n\t\tans[q[i][6]]+=v[0]*v[1]*v[2];\n\t}\n\tfor(int i=55;i>0;i--)ans[i-1]-=ans[i]*(i-1);\n\tcout<<ans[e]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint num[200][200][200]; //x,y,z\nint main(void){\n\tint n, k; cin >> n >> k;\n\trep(x, 200)rep(y, 200)rep(z, 200) num[x][y][z] = 0;\n\tint x1, y1, z1, x2, y2, z2;\n\tfor (int i = 0; i < n; ++i){\n\t\tcin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n\t\tfor (int x = x1; x < x2; ++x){\n\t\t\tfor (int y = y1; y < y2; ++y){\n\t\t\t\tfor (int z = z1; z < z2; ++z){\n\t\t\t\t\tnum[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(x, 200)rep(y, 200)rep(z, 200){\n\t\tif(num[x][y][z] == k) ans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nint ary[110][110][110],X[2][60],Y[2][60],D[2][60];\nint main(){\n\tll N,K;\n\tvector<ll> sx,sy,sd;\n\tcin>>N>>K;\n\tfor(int i=1;i<=N;i++){\n\t\tcin>>X[0][i]>>Y[0][i]>>D[0][i]>>X[1][i]>>Y[1][i]>>D[1][i];\n\t\tif(X[0][i]>X[1][i]) swap(X[0][i],X[1][i]);\n\t\tif(Y[0][i]>Y[1][i]) swap(Y[0][i],Y[1][i]);\n\t\tif(D[0][i]>D[1][i]) swap(D[0][i],D[1][i]);\n\t\tsx.push_back(X[0][i]);\n\t\tsx.push_back(X[1][i]);\n\t\tsy.push_back(Y[0][i]);\n\t\tsy.push_back(Y[1][i]);\n\t\tsd.push_back(D[0][i]);\n\t\tsd.push_back(D[1][i]);\n\t}\n\tsort(sx.begin(),sx.end());\n\tsort(sy.begin(),sy.end());\n\tsort(sd.begin(),sd.end());\n\n\tll nx[2],ny[2],nd[2];\n\tfor(int i=1;i<=N;i++){\n\t\tnx[0]=(lower_bound(sx.begin(),sx.end(),X[0][i])-sx.begin());\n\t\tnx[1]=(lower_bound(sx.begin(),sx.end(),X[1][i])-sx.begin());\n\t\tny[0]=(lower_bound(sy.begin(),sy.end(),Y[0][i])-sy.begin());\n\t\tny[1]=(lower_bound(sy.begin(),sy.end(),Y[1][i])-sy.begin());\n\t\tnd[0]=(lower_bound(sd.begin(),sd.end(),D[0][i])-sd.begin());\n\t\tnd[1]=(lower_bound(sd.begin(),sd.end(),D[1][i])-sd.begin());\n\t\tfor(int j=nx[0];j<nx[1];j++){\n\t\t\tfor(int k=ny[0];k<ny[1];k++){\n\t\t\t\tfor(int l=nd[0];l<nd[1];l++){\n\t\t\t\t\tary[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll res=0;\n\tfor(int i=0;i<sx.size()-1;i++){\n\t\tfor(int j=0;j<sy.size()-1;j++){\n\t\t\tfor(int k=0;k<sd.size()-1;k++){\n\t\t\t\tif(ary[i][j][k]>=K){\n\t\t\t\t\tres+=(sx[i+1]-sx[i])*(sy[j+1]-sy[j])*(sd[k+1]-sd[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<long long, int> P; // cordinate, index\n\nint main() {\n    int N,K;\n    cin >> N >> K;\n\n    vector<P> x,y,z;\n\n    for(int i=0 ;i<N; ++i) {\n        long long a,b,c,d,e,f;\n        cin >> a >> b >> c >> d >> e >> f;\n        x.push_back(P(a,i));\n        y.push_back(P(b,i));\n        z.push_back(P(c,i));\n        x.push_back(P(d,i));\n        y.push_back(P(e,i));\n        z.push_back(P(f,i));\n    }\n\n    sort(x.begin(),x.end());\n    sort(y.begin(),y.end());\n    sort(z.begin(),z.end());\n\n    vector<int> rnkx[N];\n    vector<int> rnky[N];\n    vector<int> rnkz[N];\n\n    long long valx[2*N],valy[2*N],valz[2*N];\n\n    for(int i=0; i<(int)x.size(); ++i) {\n        P px=x[i];\n        P py=y[i];\n        P pz=z[i];\n        rnkx[px.second].push_back(i);\n        rnky[py.second].push_back(i);\n        rnkz[pz.second].push_back(i);\n        valx[i]=(i<2*N-1?x[i+1].first-x[i].first:0);\n        valy[i]=(i<2*N-1?y[i+1].first-y[i].first:0);\n        valz[i]=(i<2*N-1?z[i+1].first-z[i].first:0);\n    }\n\n    int mp[2*N][2*N][2*N];\n\n    for(int i=0; i<2*N; ++i) {\n        for(int j=0; j<2*N; ++j) {\n            fill(mp[i][j],mp[i][j]+2*N,0);\n        }\n    }\n\n    for(int i=0; i<N; ++i) {\n        for(int mpx=rnkx[i][0]; mpx<rnkx[i][1]; ++mpx) {\n            for(int mpy=rnky[i][0]; mpy<rnky[i][1]; ++mpy) {\n                for(int mpz=rnkz[i][0]; mpz<rnkz[i][1]; ++mpz) ++mp[mpx][mpy][mpz];\n            }\n        }\n    }\n\n    long long ans=0;\n    for(int i=0; i<2*N; ++i) {\n        for(int j=0; j<2*N; ++j) {\n            for(int k=0; k<2*N; ++k) {\n                if(mp[i][j][k]>=K) ans+=valx[i]*valy[j]*valz[k];\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lint;\n\nint main()\n{\n\tint N, K;\n\tstatic int cube[128][128][128];\n\tint x1[64], x2[64], y1[64], y2[64], z1[64], z2[64];\n\tvector<int> xs, ys, zs;\n\tmap<int, int> convx, convy, convz;\n\tmap<int, int> motox, motoy, motoz;\n\t\n\tscanf(\"%d %d\", &N, &K);\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d %d %d %d\", x1 + i, y1 + i, z1 + i, x2 + i, y2 + i, z2 + i);\n\t\txs.push_back(x1[i]); xs.push_back(x2[i]);\n\t\tys.push_back(y1[i]); ys.push_back(y2[i]);\n\t\tzs.push_back(z1[i]); zs.push_back(z2[i]);\n\t}\n\t\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\tsort(zs.begin(), zs.end());\n\t\n\tint idx = 0;\n\tconvx[xs[0]] = idx;\n\tmotox[idx++] = xs[0];\n\tfor (int i = 1; i < 2 * N; i++){\n\t\tif (xs[i] != xs[i - 1]){\n\t\t\tconvx[xs[i]] = idx;\n\t\t\tmotox[idx++] = xs[i];\n\t\t}\n\t}\n\t\n\tidx = 0;\n\tconvy[ys[0]] = idx;\n\tmotoy[idx++] = ys[0];\n\tfor (int i = 1; i < 2 * N; i++){\n\t\tif (ys[i] != ys[i - 1]){\n\t\t\tconvy[ys[i]] = idx;\n\t\t\tmotoy[idx++] = ys[i];\n\t\t}\n\t}\n\t\n\tidx = 0;\n\tconvz[zs[0]] = idx;\n\tmotoz[idx++] = zs[0];\n\tfor (int i = 1; i < 2 * N; i++){\n\t\tif (zs[i] != zs[i - 1]){\n\t\t\tconvz[zs[i]] = idx;\n\t\t\tmotoz[idx++] = zs[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\t//printf(\"%d %d %d %d %d %d\\n\", convx[x1[i]], convy[y1[i]], convz[z1[i]], convx[x2[i]], convy[y2[i]], convz[z2[i]]);\n\t\tfor (int x = convx[x1[i]]; x < convx[x2[i]]; x++){\n\t\t\tfor (int y = convy[y1[i]]; y < convy[y2[i]]; y++){\n\t\t\t\tfor (int z = convz[z1[i]]; z < convz[z2[i]]; z++){\n\t\t\t\t\tcube[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlint ans = 0;\n\tfor (int i = 0; i < 128; i++){\n\t\tfor (int j = 0; j < 128; j++){\n\t\t\tfor (int k = 0; k < 128; k++){\n\t\t\t\t/*if (cube[i][j][k] >= K){\n\t\t\t\t\tprintf(\"!!\\n\");\n\t\t\t\t\tprintf(\"motox[i + 1] = %d motox[i] = %d motoy[j + 1] = %d motoy[j] = %d motoz[k + 1] = %d motoz[k] = %d\\n\", motox[i + 1], motox[i], motoy[j + 1], motoy[j], motoz[k + 1], motoz[k]);\n\t\t\t\t}*/\n\t\t\t\tans += (cube[i][j][k] >= K ? (lint)(motox[i + 1] - motox[i]) * (motoy[j + 1] - motoy[j]) * (motoz[k + 1] - motoz[k]) : 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\n\nint N,K;\nint W,H,D;\nint X1[55],Y1[55],Z1[55],X2[55],Y2[55],Z2[55];\nint cx1[55],cy1[55],cz1[55],cx2[55],cy2[55],cz2[55];\nvector<int> X,Y,Z;\nint fld[55*3][55*3][55*3];\n\nint ans;\nvector<int> xs;\n\nvoid compress(vector<int> &X,int* x1,int* x2,int* vx1,int* vx2,int w,int* P){\n    xs.clear();\n    for(int i=0;i<N;++i){\n        x1[i]=vx1[i];\n        x2[i]=vx2[i];\n    }\n    for(int i=0;i<N;++i){\n        for(int d=-1;d<=1;++d){\n            int tx1=x1[i]+d;\n            int tx2=x2[i]+d;\n            if(0<=tx1&&tx1<=w)xs.PB(tx1);\n            if(0<=tx2&&tx2<=w)xs.PB(tx2);\n        }\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    //for(int i=0;i<xs.size();++i)cout<<xs[i]<<endl;\n    for(int i=0;i<xs.size();++i){\n        X.PB(xs[i+1]-xs[i]);\n    }\n    *P = xs.size();\n}\n\nsigned main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    compress(X,cx1,cx2,X1,X2,1000000,&W);\n    compress(Y,cy1,cy2,Y1,Y2,1000000,&H);\n    compress(Z,cz1,cz2,Z1,Z2,1000000,&D);\n    for(int i=0;i<N;++i){\n        for(int z=cz1[i];z<cz2[i];++z){\n            for(int y=cy1[i];y<cy2[i];++y){\n                for(int x=cx1[i];x<cx2[i];++x){\n                    fld[z][y][x]++;\n                }\n            }\n        }\n    }\n    for(int z=0;z<=D;++z){\n        for(int y=0;y<=H;++y){\n            for(int x=0;x<=W;++x){\n                if(fld[z][y][x]>=K)ans+=X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n\n    //cout<<W<<\" \"<<H<<\" \"<<D<<endl;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\nconst int MAX=100;\n\nstruct S{\n\tll x1,x2,y1,y2,z1,z2;\n\tbool isIn(ll x,ll y, ll z){\n\t\tif(x1<=x&&x<x2&&y1<=y&&y<y2&&z1<=z&&z<z2) return true;\n\t\treturn false;\n\t}\n};\n\nint N,K;\nvector<S> vec;\nvector<ll> X;\nvector<ll> Y;\nvector<ll> Z;\nint grid[MAX][MAX][MAX]={};\n\nvoid input(){\n\tcin >> N >> K;\n\tfor(int i=0; i<N; ++i){\n\t\tS s;\n\t\tcin >> s.x1 >> s.y1 >> s.z1 >> s.x2 >> s.y2 >> s.z2;\n\t\tvec.push_back(s);\n\t\tX.push_back(s.x1);\n\t\tX.push_back(s.x2);\n\t\tY.push_back(s.y1);\n\t\tY.push_back(s.y2);\n\t\tZ.push_back(s.z1);\n\t\tZ.push_back(s.z2);\n\t}\n}\n\nint main(){\n\tinput();\n\tsort(X.begin(),X.end());\n\tsort(Y.begin(),Y.end());\n\tsort(Z.begin(),Z.end());\n\tX.erase(unique(X.begin(),X.end()),X.end());\n\tY.erase(unique(Y.begin(),Y.end()),Y.end());\n\tZ.erase(unique(Z.begin(),Z.end()),Z.end());\n\tfor(int i=0; i<vec.size(); ++i){\n\t\tfor(int xin=0; xin<X.size()-1; ++xin){\n\t\t\tfor(int yin=0; yin<Y.size()-1; ++yin){\n\t\t\t\tfor(int zin=0; zin<Z.size()-1; ++zin){\n\t\t\t\t\tif(vec[i].isIn(X[xin],Y[yin],Z[zin])) ++grid[xin][yin][zin];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int xin=0; xin<X.size()-1; ++xin){\n\t\tfor(int yin=0; yin<Y.size()-1; ++yin){\n\t\t\tfor(int zin=0; zin<Z.size()-1; ++zin){\n\t\t\t\tif(grid[xin][yin][zin]>=K) ans+=((X[xin+1]-X[xin])*(Y[yin+1]-Y[yin])*(Z[zin+1]-Z[zin]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tlong[] xS = new long[N];\n\t\tlong[] yS = new long[N];\n\t\tlong[] zS = new long[N];\n\t\tlong[] xT = new long[N];\n\t\tlong[] yT = new long[N];\n\t\tlong[] zT = new long[N];\n\t\tArrayList<Long> X = new ArrayList<Long>();\n\t\tArrayList<Long> Y = new ArrayList<Long>();\n\t\tArrayList<Long> Z = new ArrayList<Long>();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\txS[i] = sc.nextLong();\n\t\t\tyS[i] = sc.nextLong();\n\t\t\tzS[i] = sc.nextLong();\n\t\t\txT[i] = sc.nextLong();\n\t\t\tyT[i] = sc.nextLong();\n\t\t\tzT[i] = sc.nextLong();\n\t\t\tX.add(xS[i]);\n\t\t\tX.add(xT[i]);\n\t\t\tY.add(yS[i]);\n\t\t\tY.add(yT[i]);\n\t\t\tZ.add(zS[i]);\n\t\t\tZ.add(zT[i]);\n\t\t}\n\n\t\tCollections.sort(X);\n\t\tCollections.sort(Y);\n\t\tCollections.sort(Z);\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < N * 2 - 1; i++) {\n\t\t\tfor (int j = 0; j < N * 2 - 1; j++) {\n\t\t\t\tfor (int k = 0; k < N * 2 - 1; k++) {\n\t\t\t\t\tint overlap = 0;\n\t\t\t\t\t// x,y,z???????????????????????¨????????????????????????\n\t\t\t\t\t// ????????????????¢?????????????????????¬??????????????????\n\t\t\t\t\tfor (int l = 0; l < N; l++) {\n\t\t\t\t\t\tif (xS[l] <= X.get(i) && X.get(i + 1) <= xT[l]\n\t\t\t\t\t\t\t\t&& yS[l] <= Y.get(j) && Y.get(j + 1) <= yT[l]\n\t\t\t\t\t\t\t\t&& zS[l] <= Z.get(k) && Z.get(k + 1) <= zT[l]) {\n\t\t\t\t\t\t\toverlap++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (overlap >= K) {\n\t\t\t\t\t\tans += (X.get(i + 1) - X.get(i)) * (Y.get(j + 1) - Y.get(j)) * (Z.get(k + 1) - Z.get(k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint comp( const void *c1, const void *c2 )\n{\n  int tmp1 = *(int *)c1;\n  int tmp2 = *(int *)c2;\n\n  if( tmp1 < tmp2 )  return -1;\n  if( tmp1 == tmp2 ) return  0;\n  if( tmp1 > tmp2 )  return  1;\n}\n\ntypedef struct{\n\tint position;\n\tint label;\n} grid_index;\n\nint main(void){\n\tFILE *fp;\n\tfp = fopen(\"input.txt\",\"r\");\n\tint N, K;\n\tint ret;\n\tint i,p[3]={0},j=0,k=0,l=0;\n\tlong int x1,x2,y1,y2,d1,d2;\n\tlong int x1_index,x2_index,y1_index,y2_index,d1_index,d2_index;\n\tlong long int V=0;\n\tlong int x_begin,y_begin,d_begin,x_end,y_end,d_end;\n\tscanf(\"%d %d\", &N, &K);\n\tint data[6][N];\n\tfor(i=0; i<N; i++){\n\t\tscanf(\"%ld %ld %ld %ld %ld %ld\", &x1,&y1,&d1,&x2,&y2,&d2);\n\t\tdata[0][i] = x1;\n\t\tdata[1][i] = y1;\n\t\tdata[2][i] = d1;\n\t\tdata[3][i] = x2;\n\t\tdata[4][i] = y2;\n\t\tdata[5][i] = d2;\n\t}\n\tint tmp[2*N];\n\n\tfor(i=0; i<N; i++){\n\t\ttmp[i] = data[0][i];\n\t\ttmp[i+N] = data[3][i];\n\t}\n\tqsort(tmp,2*N,sizeof(int),comp);\n\tfor(i=0; i<N; i++){\n\t\tif(tmp[i] == tmp[i+1]){\n\t\t\tp[0]++;\n\t\t}\n\t}\n\tint gridx[2*N-p[0]];\n\tfor(i=0; i<2*N; i++){\n\t\tif(tmp[i] != tmp[i+1]){\n\t\t\tgridx[j] = tmp[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tj=0;\n\tfor(i=0; i<N; i++){\n\t\ttmp[i] = data[1][i];\n\t\ttmp[i+N] = data[4][i];\n\t}\n\tqsort(tmp,2*N,sizeof(int),comp);\n\tfor(i=0; i<2*N; i++){\n\t\tif(tmp[i] == tmp[i+1]){\n\t\t\tp[1]++;\n\t\t}\n\t}\n\tint gridy[2*N-p[1]];\n\tfor(i=0; i<2*N; i++){\n\t\tif(tmp[i] != tmp[i+1]){\n\t\t\tgridy[j] = tmp[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tj=0;\n\tfor(i=0; i<N; i++){\n\t\ttmp[i] = data[2][i];\n\t\ttmp[i+N] = data[5][i];\n\t}\n\tqsort(tmp,2*N,sizeof(int),comp);\n\tfor(i=0; i<N; i++){\n\t\tif(tmp[i] == tmp[i+1]){\n\t\t\tp[2]++;\n\t\t}\n\t}\n\tint gridd[2*N-p[2]];\n\tfor(i=0; i<2*N; i++){\n\t\tif(tmp[i] != tmp[i+1]){\n\t\t\tgridd[j] = tmp[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tgrid_index gx[2*N-p[0]];\n\tgrid_index gy[2*N-p[1]];\n\tgrid_index gd[2*N-p[2]];\n\tfor(i=0; i<2*N-p[0];i++){\n\t\tgx[i].label = i;\n\t\tgx[i].position = gridx[i];\n\t}\n\tfor(i=0; i<2*N-p[1];i++){\n\t\tgy[i].label = i;\n\t\tgy[i].position = gridy[i];\n\t}\n\tfor(i=0; i<2*N-p[2];i++){\n\t\tgd[i].label = i;\n\t\tgd[i].position = gridd[i];\n\t}\n\n\tint fish_dist[2*N-p[0]][2*N-p[1]][2*N-p[2]];\n\tfor(i=0; i<2*N-p[0];i++){\n\t\tfor(j=0; j<2*N-p[1];j++){\n\t\t\tfor(k=0; k<2*N-p[2];k++){\n\t\t\t\tfish_dist[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(i=0; i<N; i++){\n\t\tfor(j=0; j<2*N-p[0]; j++){\n\t\t\tif(data[0][i] == gx[j].position) {\n\t\t\t\tx1_index = gx[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[0];j++){\n\t\t\tif(data[3][i] == gx[j].position) {\n\t\t\t\tx2_index = gx[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[1];j++){\n\t\t\tif(data[1][i] == gy[j].position) {\n\t\t\t\ty1_index = gy[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[1];j++){\n\t\t\tif(data[4][i] == gy[j].position) {\n\t\t\t\ty2_index = gy[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[2];j++){\n\t\t\tif(data[2][i] == gd[j].position) {\n\t\t\t\td1_index = gd[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[2];j++){\n\t\t\tif(data[5][i] == gd[j].position) {\n\t\t\t\td2_index = gd[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(l=x1_index; l<x2_index; l++){\n\t\t\tfor(j=y1_index; j<y2_index; j++){\n\t\t\t\tfor(k=d1_index; k<d2_index; k++){\n\t\t\t\t\tfish_dist[l][j][k] += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=0; i<2*N-p[0]; i++){\n\t\tfor(j=0; j<2*N-p[1]; j++){\n\t\t\tfor(k=0; k<2*N-p[2]; k++){\n\t\t\t\tif(fish_dist[i][j][k] >= K){\n\t\t\t\t\tx_begin = gridx[i];\n\t\t\t\t\ty_begin = gridy[j];\n\t\t\t\t\td_begin = gridd[k];\n\t\t\t\t\tx_end = gridx[i+1];\n\t\t\t\t\ty_end = gridy[j+1];\n\t\t\t\t\td_end = gridd[k+1];\n\t\t\t\t\tV += (x_end - x_begin) * (y_end - y_begin) * (d_end - d_begin);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",V);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n \ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n\n#define F first\n#define S second\n\n\n\nstruct Rect\n{\n    int v[3][2];\n    ll calc_area() const\n    {\n        ll res = 1;\n        rep(d, 3)\n            res *= v[d][1] - v[d][0];\n        return res;\n    }\n};\ntypedef pair<Rect, int> Area; // (rect, num of fishes)\n\nbool intersect(const Rect& a, const Rect& b, Rect& r)\n{\n    rep(d, 3)\n    {\n        r.v[d][0] = max(a.v[d][0], b.v[d][0]);\n        r.v[d][1] = min(a.v[d][1], b.v[d][1]);\n        if (r.v[d][0] >= r.v[d][1])\n            return false;\n    }\n    return true;\n}\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n\n    const int inf = ten(8);\n    Rect inf_rect;\n    rep(d, 3)\n    {\n        inf_rect.v[d][0] = -inf;\n        inf_rect.v[d][1] = inf;\n    }\n\n    vector<Area> area;\n    area.pb(make_pair(inf_rect, 0));\n    rep(fi, n)\n    {\n        Rect fish;\n        rep(i, 2) rep(d, 3)\n            cin >> fish.v[d][i];\n\n        vector<Area> narea;\n        foreach (it, area)\n        {\n            Rect and_rect;\n            if (intersect(fish, it->first, and_rect))\n            {\n                narea.pb(make_pair(and_rect, it->second + 1));\n\n                int bound[3][4];\n                rep(d, 3)\n                {\n                    bound[d][0] = -inf;\n                    bound[d][1] = and_rect.v[d][0];\n                    bound[d][2] = and_rect.v[d][1];\n                    bound[d][3] = inf;\n                }\n\n                rep(i, 3) rep(j, 3) rep(k, 3)\n                {\n                    if (i == 1 && j == 1 && k == 1)\n                    {\n                        // excluding: temp_rect == and_rect\n                        continue;\n                    }\n\n                    Rect temp_rect;\n                    temp_rect.v[0][0] = bound[0][i];\n                    temp_rect.v[0][1] = bound[0][i + 1];\n\n                    temp_rect.v[1][0] = bound[1][j];\n                    temp_rect.v[1][1] = bound[1][j + 1];\n\n                    temp_rect.v[2][0] = bound[2][k];\n                    temp_rect.v[2][1] = bound[2][k + 1];\n\n                    Rect and_r;\n                    if (intersect(temp_rect, it->first, and_r))\n                        narea.pb(make_pair(and_r, it->second));\n                }\n            }\n            else\n                narea.pb(*it);\n        }\n\n        area = narea;\n    }\n\n    ll res = 0;\n    foreach (it, area)\n        if (it->second >= k)\n            res += it->first.calc_area();\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint X1[210], Y1[210], Z1[210], X2[210], Y2[210], Z2[210];\nint rX[210], rY[210], rZ[210];\nint sum[210][210][210];\nsigned main() {\n    int N, K; cin >> N >> K;\n    map<int, int> cmpx, cmpy, cmpz;\n\n    // int acc[210][210][210];\n    for(int i=0; i<N; i++) {\n        int x1, y1, z1, x2, y2, z2;\n        cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n        cmpx[x1]++; cmpx[x2]++; // cmpx[x2+1]++;\n        cmpy[y1]++; cmpy[y2]++; // cmpy[y2+1]++;\n        cmpz[z1]++; cmpz[z2]++; // cmpz[z2+1]++;\n\n        X1[i] = x1, Y1[i] = y1, Z1[i] = z1;\n        X2[i] = x2, Y2[i] = y2, Z2[i] = z2;\n    }\n\n    int idx = 0, idy = 0, idz = 0;\n    for(auto &e : cmpx) rX[idx] = e.first, e.second = idx++;\n    for(auto &e : cmpy) rY[idy] = e.first, e.second = idy++;\n    for(auto &e : cmpz) rZ[idz] = e.first, e.second = idz++;\n\n    for(int i=0; i<N; i++) {\n        int lb = cmpz[ Z1[i] ], ub = cmpz[ Z2[i] ];\n        for(int z=lb; z<ub; z++) {\n            int lx = cmpx[ X1[i] ], rx = cmpx[ X2[i] ];\n            int ly = cmpy[ Y1[i] ], ry = cmpy[ Y2[i] ];\n            for(int x=lx; x<rx; x++) {\n                for(int y=ly; y<ry; y++) {\n                    sum[x][y][z]++;\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<idx; i++) {\n        for(int j=0; j<idy; j++) {\n            for(int k=0; k<idz; k++) {\n                if(sum[i][j][k] >= K) {\n                    int diff_x = rX[i+1] - rX[i];\n                    int diff_y = rY[j+1] - rY[j];\n                    int diff_z = rZ[k+1] - rZ[k];\n                    ans += diff_x * diff_y * diff_z;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v)) os<<*i<<(i==end(v)-1?\"\":\"\\n\"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n    is>>p.first>>p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b) {if(a<b) {a=b;return 1;} return 0;}\ntemplate<class T>bool chmin(T &a,const T &b) {if(b<a) {a=b;return 1;} return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nint sum[105][105][105];\nsigned main() {\n    int n,K;\n    cin>>n>>K;\n    vector<vector<int>> p(n);\n    map<int,int> idx_x,idx_y,idx_z;\n    map<int,int> xdi_x,xdi_y,xdi_z;\n    REP(i,n) {\n        int x1,y1,z1,x2,y2,z2;\n        cin>>x1>>y1>>z1>>x2>>y2>>z2;\n        p[i]={x1,y1,z1,x2,y2,z2};\n        idx_x[x1]=idx_x[x2]=idx_y[y1]=idx_y[y2]=idx_z[z1]=idx_z[z2]=0;\n    }\n    int cnt=0;\n    FORE(x,idx_x) x.second=cnt++, xdi_x[x.second]=x.first;\n    cnt=0;\n    FORE(y,idx_y) y.second=cnt++, xdi_y[y.second]=y.first;\n    cnt=0;\n    FORE(z,idx_z) z.second=cnt++, xdi_z[z.second]=z.first;\n\n    REP(i,n) {\n        int x1=idx_x[p[i][0]];\n        int y1=idx_y[p[i][1]];\n        int z1=idx_z[p[i][2]];\n        int x2=idx_x[p[i][3]];\n        int y2=idx_y[p[i][4]];\n        int z2=idx_z[p[i][5]];\n        REPF(x,x1,x2) {\n            REPF(y,y1,y2) {\n                REPF(z,z1,z2) {\n                    sum[x][y][z]++;\n                }\n            }\n        }\n    }\n\n    int ans=0;\n    REP(i,104) {\n        REP(j,104) {\n            REP(k,104) {\n                if(sum[i][j][k]>=K) {\n                    ans+=(xdi_x[i+1]-xdi_x[i])*(xdi_y[j+1]-xdi_y[j])*(xdi_z[k+1]-xdi_z[k]);\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define MAX_N 55\n#define ll long long\n\nll N, K;\n\nint compress(vector<ll>& x1, vector<ll>& x2,vector<ll>& xs) {\n\tfor (int i = 0; i < N;i++) {\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor (int i = 0; i < N;i++) {\n\t\tx1[i] = find(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = find(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\treturn xs.size();\n}\n\nint main() {\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tcin >> N >> K;\n\tvector<ll> X1(N), X2(N), Y1(N), Y2(N), D1(N), D2(N);\n\tvector<ll> xs, ys, ds;\n\tfor (int i = 0; i < N;i++) {\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t}\n\tll X = compress(X1, X2, xs);\n\tll Y = compress(Y1, Y2, ys);\n\tll D = compress(D1, D2, ds);\n\n\tll ans = 0;\n\n\tvector<vector<vector<ll>>> m(X, vector<vector<ll>>(Y, vector<ll>(D, 0)));\n\tfor (int i = 0; i < N;i++) {\n\t\tfor (int x = X1[i] + 1; x <= X2[i]; x++) {\n\t\t\tfor (int y = Y1[i] + 1; y <= Y2[i]; y++) {\n\t\t\t\tfor (int d = D1[i] + 1; d <= D2[i]; d++) {\n\t\t\t\t\tm[x][y][d]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = 1; x < X; x++) {\n\t\tfor (int y = 1; y < Y;y++) {\n\t\t\tfor (int d = 1; d < D;d++) {\n\t\t\t\tif (m[x][y][d] >= K) {\n\t\t\t\t\tll a_x, a_y, a_d;\n\t\t\t\t\ta_x = xs[x] - xs[x - 1];\n\t\t\t\t\ta_y = ys[y] - ys[y - 1];\n\t\t\t\t\ta_d = ds[d] - ds[d - 1];\n\n\t\t\t\t\tans += a_x * a_y * a_d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, K;\nvector<int> v[6];\nvector<int> w[3];\nvector<int> u[3];\nvector<long long int> d[3];\nlong long int ans;\n\nint main(){\n\tscanf(\"%d %d\", &n, &K);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<6; j++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tv[j].push_back(t);\n\t\t\tw[j%3].push_back(t);\n\t\t}\n\t}\n\tfor(int i=0; i<3; i++){\n\t\tsort(w[i].begin(), w[i].end());\n\t\tw[i].erase(unique(w[i].begin(), w[i].end()), w[i].end());\n\t}\n/*\n\tfor(int i=0; i<3; i++){\n\t\tfor(int j=0; j<w[i].size(); j++){\n\t\t\tprintf(\"%d\\t\", w[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<6; j++){\n\t\t\tv[j][i] = find(w[j%3].begin(), w[j%3].end(), v[j][i]) - w[j%3].begin();\n\t\t}\n\t}\n/*\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<6; j++){\n\t\t\tprintf(\"%d\\t\", v[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\n\tfor(int i=0; i<3; i++){\n\t\tfor(int j=0; j<w[i].size()-1; j++){\n\t\t\td[i].push_back(w[i][j+1]-w[i][j]);\n\t\t}\n\t}\n/*\n\tfor(int i=0; i<3; i++){\n\t\tfor(int j=0; j<d[i].size(); j++){\n\t\t\tprintf(\"%d\\t\", d[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\n\tint u[w[0].size()][w[1].size()][w[2].size()];\n\tmemset(u, 0, sizeof(u));\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=v[0][i]; j<v[3][i]; j++){\n\t\t\tfor(int k=v[1][i]; k<v[4][i]; k++){\n\t\t\t\tfor(int l=v[2][i]; l<v[5][i]; l++){\n\t\t\t\t\tu[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0; i<w[0].size(); i++){\n\t\tfor(int j=0; j<w[1].size(); j++){\n\t\t\tfor(int k=0; k<w[2].size(); k++){\n\t\t\t\tif(u[i][j][k] >= K) ans += d[0][i] * d[1][j] * d[2][k];\n\t\t\t}\n\t\t}\n\t}\n/*\n\tfor(int i=0; i<3; i++)\n\t\tfor(int j=0; j<w[i].size(); j++)\n\t\t\tu[i].push_back(0);\n\n\tfor(int i=0; i<3; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int k=v[i][j]; k<v[i+3][j]; k++){\n\t\t\t\tu[i][k]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0; i<3; i++){\n\t\tfor(int j=0; j<u[i].size(); j++){\n\t\t\tprintf(\"%d\\t\", u[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor(int i=0; i<u[0].size()-1; i++){\n\t\tfor(int j=0; j<u[1].size()-1; j++){\n\t\t\tfor(int k=0; k<u[2].size()-1; k++){\n\t\t\t\tif(u[0][i] >= K && u[1][j] >= K && u[2][k] >= K){\n\t\t\t\t\tans += d[0][i] * d[1][j] * d[2][k];\n\t\t\t\t\tprintf(\"%d %d %d\\n\", i, j, k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n*/\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(void) {\n\n\tint N, K; cin >> N >> K;\n\tvector<vector<unsigned long long> > fishrange;\n\tvector<unsigned long long> x, y, d;\n\n\tunsigned long long volume = 0;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tvector<unsigned long long> range;\n\t\tint x1, y1, d1, x2, y2, d2; cin >> x1 >> y1 >> d1 >> x2 >> y2 >> d2;\n\n\t\trange.push_back(x1); range.push_back(y1); range.push_back(d1);\n\t\trange.push_back(x2); range.push_back(y2); range.push_back(d2);\n\n\t\tx.push_back(x1); x.push_back(x2);\n\t\ty.push_back(y1); y.push_back(y2);\n\t\td.push_back(d1); d.push_back(d2);\n\n\t\tfishrange.push_back(range);\n\t}\n\n\tsort(x.begin(), x.end()); x.erase(unique(x.begin(), x.end()), x.end());\n\tsort(y.begin(), y.end()); y.erase(unique(y.begin(), y.end()), y.end());\n\tsort(d.begin(), d.end()); d.erase(unique(d.begin(), d.end()), d.end());\n\n\tfor (int i = 0; i < (x.size() - 1); i++) {\n\t\tfor (int j = 0; j < (y.size() - 1); j++) {\n\n\t\t\tfor (int t = 0; t < (d.size() - 1); t++) {\n\n\t\t\t\tint count = 0;\n\n\t\t\t\tfor (int s = 0; s < N; s++) {\n\t\t\t\t\tif (x[i] >= fishrange[s][0] && x[i + 1] <= fishrange[s][3] &&\n\t\t\t\t\t\ty[j] >= fishrange[s][1] && y[j + 1] <= fishrange[s][4] &&\n\t\t\t\t\t\td[t] >= fishrange[s][2] && d[t + 1] <= fishrange[s][5])\n\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\n\t\t\t\tif (count >= K) volume += (x[i + 1] - x[i])*(y[j + 1] - y[j])*(d[t + 1] - d[t]);\n\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << volume << endl;\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef long long ll;\n\nll n, K;\nvector<ll> unzipx, unzipy, unzipz;\nint x, y, z;\nvector<ll>  bx, by, bz, ex, ey, ez;\nint sum[55][55][55];\n\nint press(vector<ll>& v1, vector<ll>& v2,vector<ll>& unzip) {\n\tauto t1 = v1, t2 = v2;\n\tt1.insert(t1.end(), t2.begin(), t2.end());\n\tsort(t1.begin(), t1.end());\n\tt1.erase(unique(t1.begin(), t1.end()), t1.end());\n\tfor (int i = 0; i < v1.size(); i++) {\n\t\tll tmp = lower_bound(t1.begin(), t1.end(), v1[i]) - t1.begin();\n\t\tunzip[tmp] = v1[i];\n\t\tv1[i] = tmp;\n\t}\n\n\tfor (int i = 0; i < v2.size(); i++) {\n\t\tll tmp = lower_bound(t1.begin(), t1.end(), v2[i]) - t1.begin();\n\t\tunzip[tmp] = v2[i];\n\t\tv2[i] = tmp;\n\t}\n\t\n\treturn t1.size();\n}\n\nint main() {\n\tunzipx.resize(55 * 3), unzipy.resize(55 * 3), unzipz.resize(55 * 3);\n\tcin >> n >> K;\n\tfor (int i = 0; i < n; i++) {\n\t\tll a, b, c, d, e, f;\n\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\tbx.push_back(a), by.push_back(b), bz.push_back(c);\n\t\tex.push_back(d), ey.push_back(e), ez.push_back(f);\n\t}\n\tx = press(bx, ex, unzipx), y = press(by, ey, unzipy), z = press(bz, ez, unzipz);\n\t// ?´?????????????\n\tll ans = 0;\n\tfor (int i = 0; i < bx.size(); i++) {\n\t\tfor (int j = bx[i]; j < ex[i]; j++) {\n\t\t\tfor (int k = by[i]; k < ey[i]; k++) {\n\t\t\t\tfor (int l = bz[i]; l < ez[i]; l++) {\n\t\t\t\t\tsum[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < x - 1; i++) {\n\t\tfor (int j = 0; j < y - 1; j++) {\n\t\t\tfor (int k = 0; k < z - 1; k++) {\n\t\t\t\tif (sum[i][j][k] >= K) {\n\t\t\t\t\tans += ((unzipx[i + 1] - unzipx[i]) * (unzipy[j + 1] - unzipy[j]) * (unzipz[k + 1] - unzipz[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct AREA\n{\n\tint x1, y1, z1, x2, y2, z2;\n};\nint main(void)\n{\n\tint N, K,i,j,x[101],y[101],z[101],xx,yy,zz,m,h,cnt=0;\n\tAREA barea[51];\n\tlong long sum = 0;\n\tscanf(\"%d%d\", &N, &K);\n\tfor (i = 0; i <2*N; i++)\n\t{\n\t\tscanf(\"%d %d %d\", &x[i], &y[i], &z[i]);\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\tbarea[i / 2].x1 = x[i];\n\t\t\tbarea[i / 2].y1 = y[i];\n\t\t\tbarea[i / 2].z1 = z[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbarea[i / 2].x2 = x[i];\n\t\t\tbarea[i / 2].y2 = y[i];\n\t\t\tbarea[i / 2].z2 = z[i];\n\t\t}\n\t}\n\n\tfor (i = 0; i < 2*N-1; i++)\n\t{\n\t\tfor (j = i + 1; j < 2*N; j++)\n\t\t{\n\t\t\tif (x[i] > x[j])\n\t\t\t{\n\t\t\t\txx = x[i];\n\t\t\t\tx[i] = x[j];\n\t\t\t\tx[j] = xx;\n\t\t\t}\n\t\t\tif (y[i] > y[j])\n\t\t\t{\n\t\t\t\tyy = y[i];\n\t\t\t\ty[i] = y[j];\n\t\t\t\ty[j] = yy;\n\t\t\t}\n\t\t\tif (z[i] > z[j])\n\t\t\t{\n\t\t\t\tzz = z[i];\n\t\t\t\tz[i] = z[j];\n\t\t\t\tz[j] = zz;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < 2 * N-1; i++)\n\t{\n\t\tfor (j = 0; j < 2 * N-1; j++)\n\t\t{\n\t\t\tfor (m = 0; m < 2 * N-1; m++)\n\t\t\t{\n\t\t\t\tfor (h = 0; h < N; h++)\n\t\t\t\t{\n\t\t\t\t\tif(barea[h].x1<=x[i]&&x[i+1]<=barea[h].x2&&barea[h].y1 <= y[j] && y[j + 1] <= barea[h].y2&&barea[h].z1 <= z[m] && z[m + 1] <= barea[h].z2)\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif (K <= cnt)\n\t\t\t\t{\n\t\t\t\n\t\t\t\t\tsum = sum + (x[i + 1] - x[i])*(y[j + 1] - y[j])*(z[m + 1] - z[m]);\n\t\t\t\t}\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n\nint n, k;\nint x1[60], x2[60], y334[60], y2[60], d1[60], d2[60];\n\nvector<LL>x, y, d;\n\nint main() {\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x1[i] >> y334[i] >> d1[i] >> x2[i] >> y2[i] >> d2[i];\n\t\tx.emplace_back(x1[i]);\n\t\tx.emplace_back(x2[i]);\n\t\ty.emplace_back(y334[i]);\n\t\ty.emplace_back(y2[i]);\n\t\td.emplace_back(d1[i]);\n\t\td.emplace_back(d2[i]);\n\t}\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tsort(d.begin(), d.end());\n\n\tLL ans = 0;\n\tfor (int X = 0; X < x.size() - 1; X++) {\n\t\tfor (int Y = 0; Y < y.size() - 1; Y++) {\n\t\t\tfor (int D = 0; D < d.size() - 1; D++) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (x1[i] <= x[X] && x[X + 1] <= x2[i] && y334[i] <= y[Y] && y[Y + 1] <= y2[i] && d1[i] <= d[D] && d[D + 1] <= d2[i]) count++;\n\t\t\t\t}\n\t\t\t\tif (count >= k)ans += (x[X + 1] - x[X]) * (y[Y + 1] - y[Y]) * (d[D + 1] - d[D]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n,K;\nint X1[55],X2[55],Y1[55],Y2[55],D1[55],D2[55];\nint sx1[55],sx2[55],sy1[55],sy2[55],sd1[55],sd2[55];\nvector<int> xs,ys,ds;\nint m[111][111][111];\nint main(void){\n  cin >> n >> K;\n  for(int i = 0; i < n; i++){\n    cin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n    xs.push_back(X1[i]);\n    xs.push_back(X2[i]);\n    ys.push_back(Y1[i]);\n    ys.push_back(Y2[i]);\n    ds.push_back(D1[i]);\n    ds.push_back(D2[i]);\n  }\n\n  sort(xs.begin(),xs.end());\n  sort(ys.begin(),ys.end());\n  sort(ds.begin(),ds.end());\n\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  ys.erase(unique(ys.begin(),ys.end()),ys.end());\n  ds.erase(unique(ds.begin(),ds.end()),ds.end());\n\n  for(int i = 0; i < n; i++){\n    sx1[i] = find(xs.begin(),xs.end(),X1[i]) - xs.begin();\n    sx2[i] = find(xs.begin(),xs.end(),X2[i]) - xs.begin();\n    sy1[i] = find(ys.begin(),ys.end(),Y1[i]) - ys.begin();\n    sy2[i] = find(ys.begin(),ys.end(),Y2[i]) - ys.begin();\n    sd1[i] = find(ds.begin(),ds.end(),D1[i]) - ds.begin();\n    sd2[i] = find(ds.begin(),ds.end(),D2[i]) - ds.begin();\n\n    m[sx1[i]][sy1[i]][sd1[i]] = m[sx2[i]][sy2[i]][sd1[i]] = m[sx1[i]][sy2[i]][sd2[i]] = m[sx2[i]][sy1[i]][sd2[i]] = 1;\n    m[sx1[i]][sy2[i]][sd1[i]] = m[sx2[i]][sy1[i]][sd1[i]] = m[sx1[i]][sy1[i]][sd2[i]] = m[sx2[i]][sy2[i]][sd2[i]] = -1;\n  }\n\n  for(int i = 1; i <= 100; i++){\n    for(int j = 1; j <= 100; j++){\n      for(int k = 1; k <= 100; k++){\n\tm[i][j][k] = m[i-1][j][k];\n      }\n    }\n  }  \n  for(int i = 1; i <= 100; i++){\n    for(int j = 1; j <= 100; j++){\n      for(int k = 1; k <= 100; k++){\n\tm[i][j][k] = m[i][j-1][k];\n      }\n    }\n  }\n  for(int i = 1; i <= 100; i++){\n    for(int j = 1; j <= 100; j++){\n      for(int k = 1; k <= 100; k++){\n\tm[i][j][k] = m[i][j][k-1];\n      }\n    }\n  }\n\n  long long int res = 0;\n  for(int i = 0; i <= 100; i++){\n    for(int j = 0; j <= 100; j++){\n      for(int k = 0; k <= 100; k++){\n\tif(m[i][j][k] < K) continue;\n\tres += (long long int)(xs[i+1]-xs[i]) * (ys[j+1]-ys[j]) * (ds[k+1]-ds[k]);\n      }\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(ll i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(ll i=0;i<(n);i++)\n#define RREP(i,n) for(ll i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint main(){\n    ll n,K;\n    vector<ll> vx;\n    vector<ll> vy;\n    vector<ll> vd;\n    cin >> n >> K;\n    vector<ll> x1(n),x2(n),y1(n),y2(n),d1(n),d2(n);\n    REP(i,n){\n\tcin >> x1[i] >> y1[i] >> d1[i] >> x2[i] >> y2[i] >> d2[i];\n\tvx.PB(x1[i]);\n\tvx.PB(x2[i]);\n\tvy.PB(y1[i]);\n\tvy.PB(y2[i]);\n\tvd.PB(d1[i]);\n\tvd.PB(d2[i]);\n    }\n    sort(ALL(vx));\n    sort(ALL(vy));\n    sort(ALL(vd));\n    int num[101][101][101] = {0};\n    REP(i,n){\n\tint xl = lower_bound(ALL(vx),x1[i])-vx.begin();\n\tint xr = lower_bound(ALL(vx),x2[i])-vx.begin();\n\tint yl = lower_bound(ALL(vy),y1[i])-vy.begin();\n\tint yr = lower_bound(ALL(vy),y2[i])-vy.begin();\n\tint dl = lower_bound(ALL(vd),d1[i])-vd.begin();\n\tint dr = lower_bound(ALL(vd),d2[i])-vd.begin();\n\tFOR(j,xl,xr)FOR(k,yl,yr)FOR(l,dl,dr){\n\t    num[j][k][l]++;\n\t}\n    }\n\n    ll ans = 0;\n    REP(i,vx.size())REP(j,vy.size())REP(k,vd.size()){\n\tif(num[i][j][k] >= K){\n\t    ans += abs( (vx[i]-vx[i+1])*(vy[j]-vy[j+1])*(vd[k]-vd[k+1]));\n\t}\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define vvvel vector<vvel>\nvoid mmin(int &a, int b) {\n\ta = min(a, b);\n}\nvoid mmax(int &a, int b) {\n\ta = max(a, b);\n}\nvoid sor(vel &v) {\n\tsort(v.begin(), v.end());\n}\nint ser(vel &v, int tan) {\n\tint si = v.size() - 1;\n\tif (tan == v[si]) {\n\t\treturn si;\n\t}\n\tint lo = 0;\n\tint up = si;\n\twhile (up - lo > 1) {\n\t\tint mi = (lo + up) / 2;\n\t\tif (v[mi] <= tan) {\n\t\t\tlo = mi;\n\t\t}\n\t\telse {\n\t\t\tup = mi;\n\t\t}\n\t}\n\treturn lo;\n}\nsigned main() {\n\tint n, li;\n\tcin >> n >> li;\n\tvel x(2 * n);\n\tvel y(2 * n);\n\tvel d(2 * n);\n\tfor (int i = 0; i < 2*n; i++) {\n\t\tcin >> x[i] >> y[i] >> d[i];\n\t}\n\tvel mhx = x;\n\tvel mhy = y;\n\tvel mhd = d;\n\tsor(mhx);\n\tsor(mhy);\n\tsor(mhd);\n\tint kox=1;\n\tint koy=1;\n\tint kod=1;\n\tfor (int i = 1; i < 2*n; i++) {\n\t\tif (mhx[i] != mhx[kox - 1]) {\n\t\t\tmhx[kox] = mhx[i];\n\t\t\tkox++;\n\t\t}\n\t\tif (mhy[i] != mhy[koy - 1]) {\n\t\t\tmhy[koy] = mhy[i];\n\t\t\tkoy++;\n\t\t}\n\t\tif (mhd[i] != mhd[kod - 1]) {\n\t\t\tmhd[kod] = mhd[i];\n\t\t\tkod++;\n\t\t}\n\t}\n\tvel hx(kox);\n\tvel hy(koy);\n\tvel hd(kod);\n\tfor (int i = 0; i < kox; i++) hx[i] = mhx[i];\n\tfor (int i = 0; i < koy; i++) hy[i] = mhy[i];\n\tfor (int i = 0; i < kod; i++) hd[i] = mhd[i];\n\tvvvel di(kox, vvel(koy, vel(kod, 0)));\n\tfor (int i = 0; i < n; i++) {\n\t\tint sx = ser(hx, x[2 * i]);\n\t\tint sy = ser(hy, y[2 * i]);\n\t\tint sd = ser(hd, d[2 * i]);\n\t\tint tx = ser(hx, x[2 * i+1]);\n\t\tint ty = ser(hy, y[2 * i+1]);\n\t\tint td = ser(hd, d[2 * i+1]);\n\t\tdi[sx][sy][sd]++;\n\t\tdi[tx][ty][sd]++;\n\t\tdi[sx][ty][td]++;\n\t\tdi[tx][sy][td]++;\n\t\tdi[tx][sy][sd]--;\n\t\tdi[sx][ty][sd]--;\n\t\tdi[sx][sy][td]--;\n\t\tdi[tx][ty][td]--;\n\t}\n\tvvvel su(kox, vvel(koy, vel(kod, 0)));\n\tint ans = 0;\n\tfor (int i = 1; i < kox; i++) {\n\t\tfor (int j = 1; j < koy; j++) {\n\t\t\tfor (int k = 1; k < kod; k++) {\n\t\t\t\tint xx = di[i - 1][j - 1][k - 1];\n\t\t\t\txx += su[i - 1][j][k] + su[i][j - 1][k] + su[i][j][k - 1];\n\t\t\t\txx -= su[i - 1][j - 1][k] + su[i][j - 1][k - 1] + su[i - 1][j][k - 1];\n\t\t\t\txx += su[i - 1][j - 1][k - 1];\n\t\t\t\tsu[i][j][k] = xx;\n\t\t\t\tif (xx >=li) {\n\t\t\t\t\tans += (hx[i] - hx[i - 1])*(hy[j] - hy[j - 1])*(hd[k] - hd[k - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T>\nvector<vector<T> > make_v(size_t a,size_t b){\n  return vector<vector<T> >(a,make_v<T>(b));\n}\ntemplate<typename T>\nvector<vector<vector<T> > > make_v(size_t a,size_t b,size_t c){\n  return vector<vector<vector<T> > > (a,make_v<T>(b,c));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\nusing Int = __int128_t;\nInt abs128(Int val){return val<0?-val:val;}\n\nostream &operator<<(ostream &os,Int val){\n  if(ostream::sentry(os)){\n    __uint128_t tmp=abs128(val);\n    char buf[64];\n    char *d=end(buf);\n    do{\n      --d;\n      *d=char(tmp%10+'0');\n      tmp/=10;\n    }while(tmp);\n    if(val<0) *--d='-';\n    int len=end(buf)-d;\n    if(os.rdbuf()->sputn(d,len)!=len){\n      os.setstate(ios_base::badbit);\n    }\n  }\n  return os;\n}\n\nistream &operator>>(istream &is,Int &val){\n  string s;\n  is>>s;\n  val=0;\n  for(int i=0;i<(int)s.size();i++)\n    if(isdigit(s[i])) val=val*10+s[i]-'0';\n  if(s[0]=='-') val*=-1;\n  return is;\n}\n\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,b;\n  cin>>n>>b;\n  vector<Int> x1(n),y1(n),d1(n);\n  vector<Int> x2(n),y2(n),d2(n);\n  for(Int i=0;i<n;i++)\n    cin>>x1[i]>>y1[i]>>d1[i]>>x2[i]>>y2[i]>>d2[i];\n\n  auto comp=[](auto &a,auto &b){\n    vector<Int> res;\n    res.emplace_back(0);\n    res.emplace_back(1e8);\n    for(Int i=0;i<(Int)a.size();i++)\n      res.emplace_back(a[i]);\n    for(Int i=0;i<(Int)b.size();i++)\n      res.emplace_back(b[i]);\n    sort(res.begin(),res.end());\n    res.erase(unique(res.begin(),res.end()),res.end());\n    return res;\n  };\n\n  auto vx=comp(x1,x2);\n  auto vy=comp(y1,y2);\n  auto vd=comp(d1,d2);\n\n  auto get=[&](auto &v,Int x){\n    return lower_bound(v.begin(),v.end(),x)-v.begin();\n  };\n\n  auto s=make_v<Int>(vx.size()+1,vy.size()+1,vd.size()+1);\n  fill_v(s,0);\n\n  for(Int l=0;l<n;l++)\n    for(Int i=get(vx,x1[l]);i<get(vx,x2[l]);i++)\n      for(Int j=get(vy,y1[l]);j<get(vy,y2[l]);j++)\n\tfor(Int k=get(vd,d1[l]);k<get(vd,d2[l]);k++)\n\t  s[i][j][k]++;\n\n  if(0){\n    for(Int i=0;i<(Int)vx.size()-1;i++)\n      for(Int j=0;j<(Int)vy.size()-1;j++)\n\tfor(Int k=0;k<(Int)vd.size()-1;k++)\n\t  cout<<(s[i][j][k]>=b)<<\":\"<<(vx[i+1]-vx[i])*(vy[j+1]-vy[j])*(vd[k+1]-vd[k])<<endl;\n  }\n\t    \n  Int ans=0;\n  for(Int i=0;i<(Int)vx.size()-1;i++)\n    for(Int j=0;j<(Int)vy.size()-1;j++)\n      for(Int k=0;k<(Int)vd.size()-1;k++)\n\tans+=(s[i][j][k]>=b)*(vx[i+1]-vx[i])\n\t  *(vy[j+1]-vy[j])*(vd[k+1]-vd[k]);\n \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\ntypedef pair<int, int> P;\n\nint n, k;\n\nint compress(vector<int>& vec1, vector<int>& vec2, vector<int>& tmp)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\ttmp.push_back(vec1[i]);\n\t\ttmp.push_back(vec2[i]);\n\t}\n\n\tsort(tmp.begin(), tmp.end());\n\ttmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tvec1[i] = find(tmp.begin(), tmp.end(), vec1[i]) - tmp.begin();\n\t\tvec2[i] = find(tmp.begin(), tmp.end(), vec2[i]) - tmp.begin();\n\t}\n\n\treturn tmp.size();\n}\n\nint main(void)\n{\n\twhile(cin >> n >> k && n && k)\n\t{\n\t\tvector<int> x1, y1, d1, x2, y2, d2;\n\t\tx1.resize(n); y1.resize(n); d1.resize(n); x2.resize(n); y2.resize(n); d2.resize(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> x1[i] >> y1[i] >> d1[i] >> x2[i] >> y2[i] >> d2[i];\n\t\t}\n\t\tvector<int> cx; int w = compress(x1, x2, cx);\n\t\tvector<int> cy; int h = compress(y1, y2, cy);\n\t\tvector<int> cd; int d = compress(d1, d2, cd);\n\n\t\tlong long ans = 0;\n\t\tfor (int x = 0; x < w - 1; x++)\n\t\t{\n\t\t\tfor (int y = 0; y < h - 1; y++)\n\t\t\t{\n\t\t\t\tfor (int z = 0; z < d - 1; z++)\n\t\t\t\t{\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(x1[i] <= x && x + 1 <= x2[i] && y1[i] <= y && y + 1 <= y2[i] && d1[i] <= z && z + 1 <= d2[i])\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tif(count >= k)\n\t\t\t\t\t\tans += (long long)(cx[x + 1] - cx[x]) * (long long)(cy[y + 1] - cy[y]) * (long long)(cd[z + 1] - cd[z]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(50 + 5);\nconst double EPS = 1e-10;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nll n, k, h, w, d;\nll X1[MAX_N], X2[MAX_N], Y1[MAX_N], Y2[MAX_N], D1[MAX_N], D2[MAX_N];\nll field[MAX_N*2][MAX_N*2][MAX_N*2];\nvector<ll> xs, ys, ds, xunzip, yunzip, dunzip;\nmap<ll,ll> xzip, yzip, dzip;\n\nvoid compress(vector<ll> &x, map<ll, ll> &zip, vector<ll> &unzip) {\n    sort(x.begin(), x.end());\n    x.erase(unique(x.begin(), x.end()), x.end());\n    unzip.resize(x.size());\n    for (int i = 0; i < x.size(); i++) {\n        zip[x[i]] = i;\n        unzip[i] = x[i];\n    }\n}\n\nint main() {\n    cin >> n >> k;\n    REP(i,n){\n        cin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n        xs.push_back(X1[i]);\n        xs.push_back(X2[i]);\n        ys.push_back(Y1[i]);\n        ys.push_back(Y2[i]);\n        ds.push_back(D1[i]);\n        ds.push_back(D2[i]);\n    }\n\n    compress(xs, xzip, xunzip);\n    compress(ys, yzip, yunzip);\n    compress(ds, dzip, dunzip);\n\n    w = xzip.size();\n    h = yzip.size();\n    d = dzip.size();\n\n    REP(i,n){\n        field[yzip[Y1[i]]][xzip[X1[i]]][dzip[D1[i]]]++;\n        field[yzip[Y1[i]]][xzip[X2[i]]][dzip[D1[i]]]--;\n        field[yzip[Y2[i]]][xzip[X1[i]]][dzip[D1[i]]]--;\n        field[yzip[Y2[i]]][xzip[X2[i]]][dzip[D1[i]]]++;\n        field[yzip[Y1[i]]][xzip[X1[i]]][dzip[D2[i]]]--;\n        field[yzip[Y1[i]]][xzip[X2[i]]][dzip[D2[i]]]++;\n        field[yzip[Y2[i]]][xzip[X1[i]]][dzip[D2[i]]]++;\n        field[yzip[Y2[i]]][xzip[X2[i]]][dzip[D2[i]]]--;\n    }\n    REP(i,h+1)REP(j,w)REP(m,d){\n        field[i][j+1][m] += field[i][j][m];\n    }\n    REP(j,w+1)REP(i,h)REP(m,d){\n        field[i+1][j][m] += field[i][j][m];\n    }\n    REP(m,d+1)REP(i,h)REP(j,w){\n        field[i][j][m+1] += field[i][j][m]; \n    }\n    ll ans = 0;\n    REP(i,h)REP(j,w)REP(m,d){\n        if(field[i][j][m]>=k) \n            ans += (yunzip[i+1]-yunzip[i])*(xunzip[j+1]-xunzip[j])*(dunzip[m+1]-dunzip[m]);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cstdio>\n#include<string>\n#include<vector>\nusing namespace std;\nint main() {\n\tint n, kkk;\n\tcin >> n >> kkk;\n\tlong long int b[51][9][4] = { 0 };\n\tlong long int x[105] = { 0 }, y[105] = { 0 }, z[105] = { 0 };\n\tfor (int i = 0; i < n; i++) {\n\t\tint x1, y1, d1, x2, y2, d2;\n\t\tcin >> x1 >> y1 >> d1 >> x2 >> y2 >> d2;\n\t\tx[i * 2] = x1;\n\t\tx[i * 2 + 1] = x2;\n\t\ty[i * 2] = y1;\n\t\ty[i * 2 + 1] = y2;\n\t\tz[i * 2] = d1;\n\t\tz[i * 2 + 1] = d2;\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif (j == 0 || j == 2 || j == 3 || j == 6) {\n\t\t\t\tb[i][j][0] = x1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[i][j][0] = x2;\n\t\t\t}\n\t\t\tif (j == 0 || j == 1 || j == 3 || j == 5) {\n\t\t\t\tb[i][j][1] = y1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[i][j][1] = y2;\n\t\t\t}\n\t\t\tif (j == 0 || j == 1 || j == 2 || j == 4) {\n\t\t\t\tb[i][j][2] = d1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[i][j][2] = d2;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tfor (int j = 2*n - 1; j > i; j--) {\n\t\t\tif (x[j] < x[j - 1]) {\n\t\t\t\tswap(x[j], x[j - 1]);\n\t\t\t}\n\t\t\tif (y[j] < y[j - 1]) {\n\t\t\t\tswap(y[j], y[j - 1]);\n\t\t\t}\n\t\t\tif (z[j] < z[j - 1]) {\n\t\t\t\tswap(z[j], z[j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long int ts = 0;\n\tfor (int i = 0; i < 2*n -1; i++) {\n\t\tfor (int j = 0; j < 2 * n -1; j++) {\n\t\t\tfor (int k = 0; k < 2 * n-1 ; k++) {\n\t\t\t\tint ae = 0;\n\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\tif (b[l][0][0] <= x[i] && b[l][7][0] >= x[i + 1]) {\n\t\t\t\t\t\tif (b[l][0][1] <= y[j] && b[l][7][1] >= y[j + 1]) {\n\t\t\t\t\t\t\tif (b[l][0][2] <= z[k] && b[l][7][2] >= z[k + 1]) {\n\t\t\t\t\t\t\t\tae++;\n\t\t\t\t\t\t\t\tif (ae == kkk) {\n\t\t\t\t\t\t\t\t\tts += (x[i + 1] - x[i])*(y[j + 1] - y[j])*(z[k + 1] - z[k]);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ts << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define int long long\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n\nint n, k;\nvector<int> x_1(55), x_2(55), y_1(55), y_2(55), z_1(55), z_2(55);\nmap<int, int> mpx, mpy, mpz;\n\nint compress(int n, int xyz, vector<int>& v1, vector<int>& v2) {\n    vector<int> sx;\n    for (int i = 0; i < n; i++) {\n        int cmpx1 = v1[i];\n        int cmpx2 = v2[i];\n        sx.push_back(cmpx1);\n        sx.push_back(cmpx2);\n    }\n    sort(sx.begin(), sx.end());\n    sx.erase(unique(sx.begin(), sx.end()), sx.end());\n    for (int i = 0; i < n; i++) {\n        int idx1 = lower_bound(sx.begin(), sx.end(), v1[i]) - sx.begin();\n        int idx2 = lower_bound(sx.begin(), sx.end(), v2[i]) - sx.begin();\n        if (xyz == 0) {\n            mpx[idx1] = v1[i];\n            mpx[idx2] = v2[i];\n        }\n        else if (xyz == 1) {\n            mpy[idx1] = v1[i];\n            mpy[idx2] = v2[i];\n        }\n        else {\n            mpz[idx1] = v1[i];\n            mpz[idx2] = v2[i];\n        }\n    }\n    return sx.size();\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> k;\n    rep(i, n) {\n        cin >> x_1[i] >> y_1[i] >> z_1[i];\n        cin >> x_2[i] >> y_2[i] >> z_2[i];\n    }\n    int X = compress(n, 0, x_1, x_2);\n    int Y = compress(n, 1, y_1, y_2);\n    int Z = compress(n, 2, z_1, z_2);\n\n    ll ans = 0;\n    rep(x, X - 1) {\n        rep(y, Y - 1) {\n            rep(z, Z - 1) {\n                int cnt = 0;\n                rep(i, n) {\n                    if (x_1[i] <= mpx[x] && mpx[x + 1] <= x_2[i]) {\n                        if (y_1[i] <= mpy[y] && mpy[y + 1] <= y_2[i]) {\n                            if (z_1[i] <= mpz[z] && mpz[z + 1] <= z_2[i]) cnt++;\n                        }\n                    }\n                }\n                if (cnt >= k) ans += (mpx[x + 1] - mpx[x]) * (mpy[y + 1] - mpy[y]) * (mpz[z + 1] - mpz[z]);\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint coun[105][105][105]={};\nvector<int>x,y,z;\nint main()\n{\n  int n,m;\n  scanf(\"%d %d\",&n,&m);\n  int a[55],b[55],c[55],d[55],e[55],f[55];\n  for(int i=0;i<n;i++)\n    {\n      scanf(\"%d %d %d %d %d %d\",&a[i],&b[i],&c[i],&d[i],&e[i],&f[i]);\n       x.push_back(a[i]);\n       x.push_back(d[i]);\n       y.push_back(b[i]);\n       y.push_back(e[i]);\n       z.push_back(c[i]);\n       z.push_back(f[i]);\n    }\n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  sort(z.begin(),z.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n  z.erase(unique(z.begin(),z.end()),z.end());\n  for(int i=0;i<n;i++)\n    {\n      int r1=lower_bound(x.begin(),x.end(),a[i])-x.begin();\n      int r2=lower_bound(x.begin(),x.end(),d[i])-x.begin();\n      int r3=lower_bound(y.begin(),y.end(),b[i])-y.begin();\n      int r4=lower_bound(y.begin(),y.end(),e[i])-y.begin();\n      int r5=lower_bound(z.begin(),z.end(),c[i])-z.begin();\n      int r6=lower_bound(z.begin(),z.end(),f[i])-z.begin();\n      for(int i=r1;i<r2;i++)\n\t{\n\t  for(int j=r3;j<r4;j++)\n\t    {\n\t      for(int k=r5;k<r6;k++)\n\t\t{\n\t\t  coun[i][j][k]++;\n\t\t}\n\t    }\n\t}\n    }\n  long long ans=0;\n  for(int i=0;i<=100;i++)\n    {\n      for(int j=0;j<=100;j++)\n\t{\n\t  for(int k=0;k<=100;k++)\n\t    {\n\t      if(coun[i][j][k]>=m)\n\t\t{\n\t\t  long long s1=(x[i+1]-x[i]),s2=(y[j+1]-y[j]),s3=(z[k+1]-z[k]);\n\t\t  ans+=s1*s2*s3;\n\t\t}\n\t    }\n\t}\n    }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX_DIS = 1000000;\nint n, k;\nint x[2][51], y[2][51], z[2][51];\nint ocean[301][301][301];\nlong long int lx[301], ly[301], lz[301];\nlong long int ans;\n\nint compress(int *start, int *end, long long int *lx){\n    vector<int> v;\n\n    for(int i = 0; i < n; i++){\n        for(int j = -1; j <= 1; j++){\n            int x1 = start[i] + j, x2 = end[i] + j;\n            if(0 <= x1 && x1 <= MAX_DIS)\n                v.push_back(x1);\n            if(0 <= x2 && x2 <= MAX_DIS)\n                v.push_back(x2);\n        }\n    }\n\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n\n    for(int i = 0; i < n; i++){\n        start[i] = find(v.begin(), v.end(), start[i]) - v.begin();\n        end[i] = find(v.begin(), v.end(), end[i]) - v.begin();\n    }\n\n    for(int i = 0; i < v.size(); i++)\n        lx[i] = v[i];\n\n    return v.size();\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &k);\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 2; j++){\n            scanf(\"%d%d%d\", &x[j][i], &y[j][i], &z[j][i]);\n        }\n    }\n\n    int w = compress(x[0], x[1], lx);\n    int h = compress(y[0], y[1], ly);\n    int d = compress(z[0], z[1], lz);\n\n    for(int i = 0; i < n; i++){\n        for(int j = x[0][i]; j < x[1][i]; j++){\n            for(int l = y[0][i]; l < y[1][i]; l++){\n                for(int m = z[0][i]; m < z[1][i]; m++){\n                    ocean[j][l][m]++;\n                }\n            }\n        }\n    }\n\n    for(int i = 0; i < w - 1; i++){\n        for(int j = 0; j < h - 1; j++){\n            for(int l = 0; l < d - 1; l++){\n                if(ocean[i][j][l] >= k)\n                    ans += (lx[i + 1] - lx[i]) * (ly[j + 1] - ly[j]) * (lz[l + 1] - lz[l]);\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\tstatic ll n,t;\n\tstatic ll x[52][2],y[52][2],z[52][2];\n\t\n\tscanf(\"%I64d%I64d\",&n,&t);\n\trep(i,n){\n\t\tscanf(\"%I64d\",&x[i][0]);\n\t\tscanf(\"%I64d\",&y[i][0]);\n\t\tscanf(\"%I64d\",&z[i][0]);\n\t\tscanf(\"%I64d\",&x[i][1]);\n\t\tscanf(\"%I64d\",&y[i][1]);\n\t\tscanf(\"%I64d\",&z[i][1]);\n\t}\n\t\n\tstatic vector<ll> Zx,Zy,Zz;\n\trep(i,n){\n\t\tZx.pb( x[i][0] );\n\t\tZx.pb( x[i][1] );\n\t\tZy.pb( y[i][0] );\n\t\tZy.pb( y[i][1] );\n\t\tZz.pb( z[i][0] );\n\t\tZz.pb( z[i][1] );\n\t}\n\tsor(Zx); uniq(Zx);\n\tsor(Zy); uniq(Zy);\n\tsor(Zz); uniq(Zz);\n\t\n\tstatic ll imos[102][102][102] = {};\n\t\n\trep(i,n){\n\t\tll x1 = lb(Zx,x[i][0]) - Zx.begin();\n\t\tll x2 = lb(Zx,x[i][1]) - Zx.begin();\n\t\tll y1 = lb(Zy,y[i][0]) - Zy.begin();\n\t\tll y2 = lb(Zy,y[i][1]) - Zy.begin();\n\t\tll z1 = lb(Zz,z[i][0]) - Zz.begin();\n\t\tll z2 = lb(Zz,z[i][1]) - Zz.begin();\n\t\timos[x1][y1][z1] ++;\n\t\timos[x1][y1][z2] --;\n\t\timos[x1][y2][z1] --;\n\t\timos[x2][y1][z1] --;\n\t\timos[x1][y2][z2] ++;\n\t\timos[x2][y1][z2] ++;\n\t\timos[x2][y2][z1] ++;\n\t\timos[x2][y2][z2] --;\n\t}\n\t\n\trep1(i,101)rep(j,102)rep(k,102)imos[i][j][k] += imos[i-1][j][k];\n\trep(i,102)rep1(j,101)rep(k,102)imos[i][j][k] += imos[i][j-1][k];\n\trep(i,102)rep(j,102)rep1(k,101)imos[i][j][k] += imos[i][j][k-1];\n\t\n\tstatic ll ret = 0;\n\t\n\trep(i,Zx.size()){\n\t\trep(j,Zy.size()){\n\t\t\trep(k,Zz.size()){\n\t\t\t\tif(imos[i][j][k] >= t){\n\t\t\t\t\tret += (Zx[i+1]-Zx[i]) * (Zy[j+1]-Zy[j]) * (Zz[k+1]-Zz[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%I64d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef long long lli;\nconst int MAX = 100;\nint a[MAX][MAX][MAX];\n\nint main(){\n  int n,m;\n  while(cin >> n >> m){\n    lli v[50][6], ans = 0;\n    vector<lli> v2[3];\n    set<lli> s[3];\n    map<lli,int> v3[3];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<6;j++){\n        cin >> v[i][j];\n        s[j%3].insert(v[i][j]);\n      }\n    }\n\n    for(int i=0;i<MAX;i++) for(int j=0;j<MAX;j++) for(int k=0;k<MAX;k++) a[i][j][k] = 0;\n    for(int i=0;i<3;i++){\n      for(set<lli>::iterator it = s[i].begin(); it != s[i].end(); it++){\n        v2[i].push_back(*it);\n        v3[i][*it] = v2[i].size()-1;\n      }\n    }\n\n    for(int i=0;i<n;i++)\n      for(int j=v3[0][v[i][0]];j<v3[0][v[i][3]];j++)\n        for(int k=v3[1][v[i][1]];k<v3[1][v[i][4]];k++)\n          for(int l=v3[2][v[i][2]];l<v3[2][v[i][5]];l++)\n            a[j][k][l]++;\n\n    for(int i=0;i<MAX-1;i++)\n      for(int j=0;j<MAX-1;j++)\n        for(int k=0;k<MAX-1;k++)\n          if(a[i][j][k] >= m)\n            ans += (v2[0][i+1]-v2[0][i]) * (v2[1][j+1]-v2[1][j]) * (v2[2][k+1]-v2[2][k]);\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nvoid compress(vector<int>& x1, vector<int>& x2, map<int, int>& unzip) {\n  vector<int> xs;\n  rep(i, x1.size()) {\n    xs.push_back(x1[i]);\n    xs.push_back(x2[i]);\n  }\n\n  sort(all(xs));\n  xs.erase(unique(all(xs)), xs.end());\n\n  vector<int> nx1, nx2;\n\n  rep(i, x1.size()) {\n    nx1.push_back(lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin());\n    nx2.push_back(lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin());\n    unzip[nx1.back()] = x1[i];\n    unzip[nx2.back()] = x2[i];\n  }\n  x1 = nx1, x2 = nx2;\n}\n\nint a[333][333][333];\n\nint main() {\n\n  int N, K; cin >> N >> K;\n  vector<int> x1(N), y1(N), z1(N), x2(N), y2(N), z2(N);\n  rep(i, N) {\n    cin >> x1[i] >> y1[i] >> z1[i]\n        >> x2[i] >> y2[i] >> z2[i];\n  }\n\n  map<int, int> ux, uy, uz;\n  compress(x1, x2, ux);\n  compress(y1, y2, uy);\n  compress(z1, z2, uz);\n\n  rep(i, N) {\n    REP(x, x1[i], x2[i])\n    REP(y, y1[i], y2[i])\n    REP(z, z1[i], z2[i])\n      a[x][y][z] ++;\n  }\n\n  ll ans = 0;\n  rep(x, ux.size()-1) rep(y, uy.size()-1) rep(z, uz.size()-1) {\n    if(a[x][y][z] >= K) {\n      ans += (ll)(ux[x+1] - ux[x]) * (uy[y+1] - uy[y]) * (uz[z+1] - uz[z]);\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void){\n    // Your code here!\n    vector<vector<long> > fishrange;\n    vector<long> xi;\n    vector<long> yi;\n    vector<long> di;\n    unsigned long long n,k,p,checker;\n    unsigned long long volume = 0;\n    cin>>n>>k;\n    for(int i=0;i<n;i++)\n    {\n        vector<long> v;\n        for(int j=0;j<6;j++)\n        {\n            int h;\n            cin>>h;\n            v.push_back(h);\n        }\n        fishrange.push_back(v);\n        p = fishrange[i][0];\n        xi.push_back(p);\n        p = fishrange[i][3];\n        xi.push_back(p);\n        p = fishrange[i][1];\n        yi.push_back(p);\n        p = fishrange[i][4];\n        yi.push_back(p);\n        p = fishrange[i][2];\n        di.push_back(p); \n        p = fishrange[i][5];\n        di.push_back(p);\n        \n    }\n    sort(xi.begin(),xi.end());\n    xi.erase(unique(xi.begin(),xi.end()),xi.end());\n    sort(yi.begin(),yi.end());\n    yi.erase(unique(yi.begin(),yi.end()),yi.end());\n    sort(di.begin(),di.end());\n    di.erase(unique(di.begin(),di.end()),di.end());\n    \n    for(int i=0;i<n*2-1;i++)\n    {\n        for(int j=0;j<n*2-1;j++)\n        {\n            for(int l=0;l<n*2-1;l++)\n            {\n                checker = 0;\n                for(int c=0;c<n;c++)\n                {\n                    if(xi[i]>=fishrange[c][0]&&xi[i+1]<=fishrange[c][3]&&yi[j]>=fishrange[c][1]&&yi[j+1]<=fishrange[c][4]&&di[l]>=fishrange[c][2]&&di[l+1]<=fishrange[c][5])\n                    checker++;\n                }\n                if(checker>=k)\n                 volume += (xi[i+1]-xi[i])*(yi[j+1]-yi[j])*(di[l+1]-di[l]);\n            }\n        }\n    }\n    \n  \n    cout<<volume<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint fil[110][110][110]={0};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvi x(2*n),y(2*n),z(2*n);\n\trep(i,2*n)cin>>x[i]>>y[i]>>z[i];\n\tvi X=x,Y=y,Z=z;\n\tsort(all(X));sort(all(Y));sort(all(Z));\n\trep(i,2*n){\n\t\tx[i]=lower_bound(all(X),x[i])-X.begin();\n\t\ty[i]=lower_bound(all(Y),y[i])-Y.begin();\n\t\tz[i]=lower_bound(all(Z),z[i])-Z.begin();\n\t}\n\trep(q,2*n){\n\t\tloop(i,x[q],x[q+1])loop(j,y[q],y[q+1])loop(k,z[q],z[q+1])\n\t\t\tfil[i][j][k]++;\n\t\tq++;\n\t}\n\tll out=0;\n\trep(i,109)rep(j,109)rep(k,109)if(fil[i][j][k]>=m){\n\t\tout+=(ll)(X[i+1]-X[i])*(Y[j+1]-Y[j])*(Z[k+1]-Z[k]);\n\t}\n\tcout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Cuboid{\npublic:\n  ll ox[8]; //original x\n  ll oy[8];\n  ll od[8];\n\n  int mx[8]; // mapped x\n  int my[8];\n  int md[8];\n\n  Cuboid(int x1,int y1,int d1,\n         int x2,int y2,int d2){\n    ox[0] = x1;\n    oy[0] = y1;\n    od[0] = d1;\n\n    ox[1] = x1;\n    oy[1] = y2;\n    od[1] = d1;\n\n    ox[2] = x2;\n    oy[2] = y2;\n    od[2] = d1;\n\n    ox[3] = x2;\n    oy[3] = y1;\n    od[3] = d1;\n\n    ox[4] = x1;\n    oy[4] = y1;\n    od[4] = d2;\n\n    ox[5] = x1;\n    oy[5] = y2;\n    od[5] = d2;\n\n    ox[6] = x2;\n    oy[6] = y2;\n    od[6] = d2;\n\n    ox[7] = x2;\n    oy[7] = y1;\n    od[7] = d2;\n  }    \n\n  void mapping(const vector<ll>& xs,\n               const vector<ll>& ys,\n               const vector<ll>& ds){\n    for(int i=0;i<8;i++){\n      mx[i] = lower_bound(xs.begin(),xs.end(),ox[i]) - xs.begin();\n      my[i] = lower_bound(ys.begin(),ys.end(),oy[i]) - ys.begin();\n      md[i] = lower_bound(ds.begin(),ds.end(),od[i]) - ds.begin();\n    }\n  }\n};\n\nint dp[101][101][101];\n\nint main(){\n  int total_fish;\n  int lower;\n  while(~scanf(\"%d %d\",&total_fish,&lower)){\n\n    vector<ll> xs;\n    vector<ll> ys;\n    vector<ll> ds;\n\n    vector<Cuboid> cuboids;\n    for(int fish_idx = 0; fish_idx < total_fish; fish_idx++){\n      ll x1,y1,d1;\n      ll x2,y2,d2;\n      scanf(\"%lld %lld %lld\",&x1,&y1,&d1);\n      scanf(\"%lld %lld %lld\",&x2,&y2,&d2);\n      \n      cuboids.push_back(Cuboid(x1,y1,d1,x2,y2,d2));\n      xs.push_back(x1);       \n      xs.push_back(x2);\n\n      ys.push_back(y1);       \n      ys.push_back(y2);\n\n      ds.push_back(d1);       \n      ds.push_back(d2);\n    }\n\n    sort(xs.begin(),xs.end());\n    sort(ys.begin(),ys.end());\n    sort(ds.begin(),ds.end());\n\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    ys.erase(unique(ys.begin(),ys.end()),ys.end());\n    ds.erase(unique(ds.begin(),ds.end()),ds.end());\n\n    memset(dp,0,sizeof(dp));\n    for(int i=0;i<cuboids.size();i++){\n      cuboids[i].mapping(xs,ys,ds);\n\n      for(int x = cuboids[i].mx[0]; x < cuboids[i].mx[2]; x++){\n        for(int y = cuboids[i].my[0]; y < cuboids[i].my[1]; y++){\n          for(int d = cuboids[i].md[0]; d < cuboids[i].md[4]; d++){\n            dp[x][y][d]++;\n          }\n        }\n      }\n    }\n\n    ll res = 0;\n    for(int x = 0; x < xs.size(); x++){\n      for(int y = 0; y < ys.size(); y++){\n        for(int d = 0; d < ds.size(); d++){\n          if(dp[x][y][d] >= lower){\n            res += (xs[x + 1] - xs[x])\n              * (ys[y + 1] - ys[y])\n              * (ds[d + 1] - ds[d]);\n          }\n        }\n      }\n    }\n\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef vector<int> vi;\n\nvi x[2], y[2], d[2];\nvi cx, cy, cd;\nint maps[101][101][101];\n\nint getRev(vi &xs, int i) {\n\tif (i == -1) return 0;\n\treturn *(xs.begin() + i);\n}\n\nvoid compress(vi &x1, vi &x2, vi &xs) {\n\tREP(i, x1.size()) {\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\t\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\t\n\tREP(i, x1.size()) x1[i] = find(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\tREP(i, x2.size()) x2[i] = find(xs.begin(), xs.end(), x2[i]) - xs.begin();\n}\n\nint main() {\n\tint n, K;\n\tcin >> n >> K;\n\t\n\tREP(i, n) {\n\t\tint a1, b1, c1, a2, b2, c2;\n\t\tscanf(\"%d %d %d %d %d %d\", &a1, &b1, &c1, &a2, &b2, &c2);\n\t\tx[0].push_back(a1);\n\t\ty[0].push_back(b1);\n\t\td[0].push_back(c1);\n\t\tx[1].push_back(a2);\n\t\ty[1].push_back(b2);\n\t\td[1].push_back(c2);\n\t}\n\tcompress(x[0], x[1], cx);\n\tcompress(y[0], y[1], cy);\n\tcompress(d[0], d[1], cd);\n\t\n\n\t\n\tREP(i, n) {\n\t\tint x1 = x[0][i] + 1, y1 = y[0][i] + 1, d1 = d[0][i] + 1;\n\t\tint x2 = x[1][i], y2 = y[1][i], d2 = d[1][i];\n\t\t\n\t\tFOR(j, d1, d2 + 1) {\n\t\t\tmaps[j][y1][x1]++;\n\t\t\tmaps[j][y1][x2 + 1]--;\n\t\t\tmaps[j][y2 + 1][x1]--;\n\t\t\tmaps[j][y2 + 1][x2 + 1]++;\n\t\t}\n\t}\n\t\n\tREP(i, n * 2 + 1) {\n\t\tREP(j, n * 2 + 1) FOR(k, 1, n * 2 + 1) maps[i][j][k] += maps[i][j][k - 1];\n\t\tFOR(j, 1, n * 2 + 1) REP(k, n * 2 + 1) maps[i][j][k] += maps[i][j - 1][k];\n\t}\n\t\n\tlong long ans = 0;\n\t\n\tREP(i, n * 2 + 1) REP(j, n * 2 + 1) REP(k, n * 2 + 1) {\n\t\tif (maps[i][j][k] >= K) {\n\t\t\tlong long  dx = getRev(cx, k) - getRev(cx, k - 1);\n\t\t\tlong long  dy = getRev(cy, j) - getRev(cy, j - 1);\n\t\t\tlong long  dd = getRev(cd, i) - getRev(cd, i - 1);\n\t\t\t\n\t\t\tans += dx * dy * dd;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n//#include<fstream>\n#include<map>\nusing namespace std;\n\nenum {X=0, Y=1, Z=2 };\n\nint main(){\n\tint K,N;\n\tint *data1[3], *data2[3];\t//ファイルの中身の座標をを保存\n\t\n\t// データ読み込み\n\t/*\n\tifstream fin(\"input.txt\", ios::in);\n\tfin >> N >> K;\n\tfor(int x=0; x<3; x++){\n\t\tdata1[x] = new int[N];\n\t\tdata2[x] = new int[N];\n\t}\n\tfor(int n=0; n<N; n++){\n\t\tfin >> data1[X][n] >> data1[Y][n] >> data1[Z][n] >> data2[X][n] >> data2[Y][n] >> data2[Z][n];\n\t}\n\tfin.close();\n\t*/\n\tcin >> N >> K;\n\tfor(int x=0; x<3; x++){\n\t\tdata1[x] = new int[N];\n\t\tdata2[x] = new int[N];\n\t}\n\tfor(int n=0; n<N; n++){\n\t\tcin >> data1[X][n] >> data1[Y][n] >> data1[Z][n] >> data2[X][n] >> data2[Y][n] >> data2[Z][n];\n\t}\n\t\n\n\t//グリットの作成\n\tmap<int, char> gridmap[3];\t//重複座標を除去するためにmapを使用\n\tint *gridstep[3];\t\t\t//mapは添字でアクセスできないから、普通の配列も併用\n\tchar *grid;\t\t\t\t\t//直方体に分割した領域内の生息範囲を記憶\n\tfor(int x=0; x<3; x++){\n\t\tfor(int n=0; n<N; n++){\n\t\t\tgridmap[x].insert(make_pair(data1[x][n], -1));\n\t\t\tgridmap[x].insert(make_pair(data2[x][n], -1));\n\t\t}\n\t}\n\tchar gridnum[3] = {0,0,0};\n\tfor(int x=0; x<3; x++){\n\t\tgridstep[x] = new int[gridmap[x].size()];\n\t\tfor(map<int, char>::iterator it = gridmap[x].begin(); it!=gridmap[x].end(); it++, gridnum[x]++){\n\t\t\tgridstep[x][gridnum[x]] = it->first;\n\t\t\tit->second = gridnum[x];\n\t\t}\n\t}\n\tint griddim = (gridnum[X]-1)*(gridnum[Y]-1)*(gridnum[Z]-1);\n\tgrid = new char[griddim];\n\tfor(int a=0; a<griddim; a++)grid[a] = 0;\n\n\t//生息範囲の登録\n\tfor(int n=0; n<N; n++){\n\t\tint xyz1[3], xyz2[3];\n\t\tfor(int x=0; x< 3; x++){\n\t\t\txyz1[x] = gridmap[x].find(data1[x][n])->second;\n\t\t\txyz2[x] = gridmap[x].find(data2[x][n])->second;\n\t\t}\n\t\tfor(int xn=xyz1[X]; xn<xyz2[X]; xn++){\n\t\t\tfor(int yn=xyz1[Y]; yn<xyz2[Y]; yn++){\n\t\t\t\tfor(int zn=xyz1[Z]; zn<xyz2[Z]; zn++){\n\t\t\t\t\tgrid[zn + (gridnum[2]-1)*(yn + (gridnum[1]-1)*xn)]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//体積計算\n\tlong long value=0;\n\tfor(int xn=0; xn< gridnum[X]-1; xn++){\n\t\tfor(int yn=0; yn< gridnum[Y]-1; yn++){\n\t\t\tfor(int zn=0; zn< gridnum[Z]-1; zn++){\n\t\t\t\tif(grid[zn + (gridnum[2]-1)*(yn + (gridnum[1]-1)*xn)] >= K){\n\t\t\t\t\tvalue += (long long)(gridstep[X][xn+1] -gridstep[X][xn])*\n\t\t\t\t\t\t\t\t\t\t(gridstep[Y][yn+1] -gridstep[Y][yn])*\n\t\t\t\t\t\t\t\t\t\t(gridstep[Z][zn+1] -gridstep[Z][zn]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << value << endl;\n\n\n\tfor(int x=0; x<3; x++){\n\t\tdelete[] data1[x];\n\t\tdelete[] data2[x];\n\t\tdelete[] gridstep[x];\n\t}\n\tdelete[] grid;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 10001\n#define B 100\n#define dmp make_pair\n#define dpb push_back\n#define fi first\n#define se second\n#define P pair<int,int>\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\n\nchrono::system_clock::time_point  start;\nvoid timerstart(){start = chrono::system_clock::now();}\nvoid timerend(){\n\tauto end = chrono::system_clock::now();\n\tint elapsed = chrono::duration_cast<chrono::milliseconds>(end-start).count();\n\tprintf(\"%d[ms]\\n\", elapsed);\n}\n\nint n, k, fld[100][100][100];\nint cx[52][2], cy[52][2], cz[52][2];\nint dx[52], dy[52], dz[52];\nint compress1(int *x1, int *x2){\n\tvector<int> xs;\n\tfor(int i = 0;i < n;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tfor(int i = 0;i < xs.size();i++)dx[i] = xs[i];\n\tfor(int i = 0;i < n;i++){\n\t\tcx[i][0] = find(xs.begin(), xs.end(), x1[i])-xs.begin();\n\t\tcx[i][1] = find(xs.begin(), xs.end(), x2[i])-xs.begin();\n\t}\n\treturn xs.size();\n}\n\nint compress2(int *x1, int *x2){\n\tvector<int> xs;\n\tfor(int i = 0;i < n;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tfor(int i = 0;i < xs.size();i++)dy[i] = xs[i];\n\tfor(int i = 0;i < n;i++){\n\t\tcy[i][0] = find(xs.begin(), xs.end(), x1[i])-xs.begin();\n\t\tcy[i][1] = find(xs.begin(), xs.end(), x2[i])-xs.begin();\n\t}\n\treturn xs.size();\n}\n\nint compress3(int *x1, int *x2){\n\tvector<int> xs;\n\tfor(int i = 0;i < n;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tfor(int i = 0;i < xs.size();i++)dz[i] = xs[i];\n\tfor(int i = 0;i < n;i++){\n\t\tcz[i][0] = find(xs.begin(), xs.end(), x1[i])-xs.begin();\n\t\tcz[i][1] = find(xs.begin(), xs.end(), x2[i])-xs.begin();\n\t}\n\treturn xs.size();\n}\n\nvoid paint(int w, int h, int d){\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int x = cx[i][0]+1;x <= cx[i][1];x++){\n\t\t\tfor(int y = cy[i][0]+1;y <= cy[i][1];y++){\n\t\t\t\tfor(int z = cz[i][0]+1;z <= cz[i][1];z++){\n\t\t\t\t\tfld[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint X1[52], X2[52], Y1[52], Y2[52], Z1[52], Z2[52];\n\tscanf(\"%d%d\", &n, &k);\n\trep(i,n){\n\t\tscanf(\"%d%d%d\", &X1[i], &Y1[i], &Z1[i]);\n\t\tscanf(\"%d%d%d\", &X2[i], &Y2[i], &Z2[i]);\n\t}\n\tint w = compress1(X1, X2);\n\tint h = compress2(Y1, Y2);\n\tint d = compress3(Z1, Z2);\n\tpaint(w, h, d);\n\t\n\tll ans = 0, t1, t2, t3;\n\tfor(int x = 1;x < w;x++){\n\t\tfor(int y = 1;y < h;y++){\n\t\t\tfor(int z = 1;z < d;z++){\n\t\t\t\tif(fld[x][y][z] >= k){\n\t\t\t\t\tt1 = dx[x]-dx[x-1];\n\t\t\t\t\tt2 = dy[y]-dy[y-1];\n\t\t\t\t\tt3 = dz[z]-dz[z-1];\n\t\t\t\t\tans += t1*t2*t3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//printf(\"%d\\n\", ans);\n\t//printf(\"%d\\n\", h);\n\tprintf(\"%lld\\n\", ans);\n\t/*for(int i = 0;i < n;i++){\n\t\tprintf(\"%d %d\\n\", cy[i][0], cy[i][1]);\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tprintf(\"%d \", dy[i]);\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\n\nmap<ll,ll> Dic(vector<ll>& v){\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tmap<ll,ll> res;\n\tfor(int i = 0;i < v.size();i++){\n\t\tres[v[i]] = i;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tll N,K;\n\tcin >> N >> K;\n\tvector<ll> X1(N),Y1(N),D1(N),X2(N),Y2(N),D2(N),SX,SY,SD;\n\tSX.push_back(0), SX.push_back(INF);\n\tSY.push_back(0), SY.push_back(INF);\n\tSD.push_back(0), SD.push_back(INF);\n\tfor(int i = 0;i < N;i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t\tSX.push_back(X1[i]), SX.push_back(X2[i]);\n\t\tSY.push_back(Y1[i]), SY.push_back(Y2[i]);\n\t\tSD.push_back(D1[i]), SD.push_back(D2[i]);\n\t}\n\tmap<ll,ll> DX = Dic(SX),DY = Dic(SY),DD = Dic(SD);\n\tvector<vector<vector<ll>>> C(SX.size(), vector<vector<ll>>(SY.size(), vector<ll>(SD.size(), 0)));\n\tfor(int i = 0;i < N;i++){\n\t\tfor(int x = DX[X1[i]];x < DX[X2[i]];x++){\n\t\t\tfor(int y = DY[Y1[i]];y < DY[Y2[i]];y++){\n\t\t\t\tfor(int d = DD[D1[i]];d < DD[D2[i]];d++){\n\t\t\t\t\tC[x][y][d]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll res = 0;\n\tfor(int x = 0;x < SX.size();x++){\n\t\tfor(int y = 0;y < SY.size();y++){\n\t\t\tfor(int d = 0;d < SD.size();d++){\n\t\t\t\tif(C[x][y][d] >= K){\n\t\t\t\t\tres += (SX[x + 1] - SX[x]) * (SY[y + 1] - SY[y]) * (SD[d + 1] - SD[d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n//y13-5 魚の生息範囲 (解説見た後解き直し)\n#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define segment_size 65536\n#define ROOP() while(true)\n\n//classは初期値がprivate、structはpublic\nstruct CUBE{\n    int x1;\n    int x2;\n    int y1;\n    int y2;\n    int d1;\n    int d2;\n    LL volume(){\n        LL x = x2 - x1;\n        LL y = y2 - y1;\n        LL dd = d2 - d1;\n        return x * y * dd;\n    }\n};\n\nint N,K;\nvector<CUBE> li;\nvector<int> x;\nvector<int> y;\nvector<int> d;\n\nbool check(CUBE a, CUBE b){\n    if(a.x1 <= b.x1 && a.x2 <= b.x1) return false;\n    if(b.x1 <= a.x1 && b.x2 <= a.x1) return false;\n    if(a.y1 <= b.y1 && a.y2 <= b.y1) return false;\n    if(b.y1 <= a.y1 && b.y2 <= a.y1) return false;\n    if(a.d1 <= b.d1 && a.d2 <= b.d1) return false;\n    if(b.d1 <= a.d1 && b.d2 <= a.d1) return false;\n    return true;\n}\n\nint main(){\n    cin >> N >> K;\n    for(int i=0; i<N; i++){\n        CUBE tmp;\n        cin >> tmp.x1 >> tmp.y1 >> tmp.d1 >> tmp.x2 >> tmp.y2 >> tmp.d2;\n        li.push_back(tmp);\n        x.push_back(tmp.x1);\n        x.push_back(tmp.x2);\n        y.push_back(tmp.y1);\n        y.push_back(tmp.y2);\n        d.push_back(tmp.d1);\n        d.push_back(tmp.d2);\n    }\n    sort(x.begin(), x.end());\n    sort(y.begin(), y.end());\n    sort(d.begin(), d.end());\n\n    LL ans = 0;\n    for(int i=0; i+1<x.size(); i++){\n        for(int j=0; j+1<y.size(); j++){\n            for(int k=0; k+1<d.size(); k++){\n                CUBE tmp;\n                tmp.x1 = x[i];\n                tmp.x2 = x[i+1];\n                tmp.y1 = y[j];\n                tmp.y2 = y[j+1];\n                tmp.d1 = d[k];\n                tmp.d2 = d[k+1];\n                int c = 0;\n                for(int l=0; l<li.size(); l++){\n                    if(check(li[l], tmp)) c++;\n                }\n                if(c >= K){\n                    //cout << tmp.x1 << \" \" <<  tmp.x2 << \" \" <<  tmp.y1 << \" \" <<  tmp.y2 << \" \" <<  tmp.d1 << \" \" <<  tmp.d2 << \" \" << tmp.volume() << endl;\n                    ans += tmp.volume();\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <assert.h>\n#include <string.h>\n\nusing namespace std;\n\nnamespace\n{\n\tint n, k;\n\tint x1[50], yy[50], d1[50], x2[50], y2[50], d2[50];\n\tint cx1[50], cy1[50], cd1[50], cx2[50], cy2[50], cd2[50];\n\n\tint compd[123][123][123];\n}\n\n//w1,w2???????????????????????§???????????§???????????????\nvector<int> compress(int *w1, int *w2)\n{\n\tvector<int>ws;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tws.push_back(w1[i]);\n\t\tws.push_back(w2[i]);\n\t}\n\tsort(ws.begin(), ws.end());\n\tws.erase(unique(ws.begin(), ws.end()), ws.end());\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tw1[i] = find(ws.begin(), ws.end(), w1[i]) - ws.begin();\n\t\tw2[i] = find(ws.begin(), ws.end(), w2[i]) - ws.begin();\n\t}\n\treturn ws;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &k);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d %d %d %d %d %d\", x1 + i, yy + i, d1 + i, x2 + i, y2 + i, d2 + i);\n\t}\n\t\n\tauto xsv = compress(x1, x2);\n\tauto ysv = compress(yy, y2);\n\tauto dsv = compress(d1, d2);\n\tint xs = xsv.size();\n\tint ys = ysv.size();\n\tint ds = dsv.size();\n\n\tmemset(compd, 0, sizeof(compd));\n\n\t//??????????¨????\n\tfor (int i = 0;i < n;++i)\n\t{\n\t\tconst int hash[8][3] = { {0,0,0},{0,0,1},{0,1,0},{0,1,1},{1,0,0},{1,0,1},{1,1,0},{1,1,1}, };\n\t\tfor (int p = 0; p < 8; ++p)\n\t\t{\n\t\t\tcompd\n\t\t\t\t[hash[p][0] ? x1[i] : x2[i]]\n\t\t\t\t[hash[p][1] ? yy[i] : y2[i]]\n\t\t\t\t[hash[p][2] ? d1[i] : d2[i]] =\n\t\t\t\t\t(hash[p][0]^hash[p][1]^hash[p][2]) ? 1 : -1;\n\t\t}\n\t}\n\t\n\t//?´????????????¨???\n\tfor (int x = 0; x < xs; ++x)\n\t{\n\t\tfor (int y = 0; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 1; d < ds; ++d)\n\t\t\t{\n\t\t\t\tcompd[x][y][d] += compd[x][y][d - 1];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 0; x < xs; ++x)\n\t{\n\t\tfor (int y = 1; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < ds; ++d)\n\t\t\t{\n\t\t\t\tcompd[x][y][d] += compd[x][y - 1][d];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 1; x < xs; ++x)\n\t{\n\t\tfor (int y = 0; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < ds; ++d)\n\t\t\t{\n\t\t\t\tcompd[x][y][d] += compd[x - 1][y][d];\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor (int x = 0; x < xs; ++x)\n\t{\n\t\tfor (int y = 0; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < ds; ++d)\n\t\t\t{\n\t\t\t\tassert(compd[x][y][d] >= 0);\n\t\t\t\tif (compd[x][y][d] >= k)\n\t\t\t\t{\n\t\t\t\t\tans += (xsv[x + 1] - xsv[x]) * (ysv[y + 1] - ysv[y]) * (dsv[d + 1] - dsv[d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>\nusing namespace std;\n \nsigned main(){\n  int a,b;cin>>a>>b;\n   set<int>c,d,e;\n   int f[50][6];\n   for(int g=0;g<a;g++){\n       for(int h=0;h<6;h++)scanf(\"%lld\",&f[g][h]);\n       c.insert(f[g][0]);\n       c.insert(f[g][3]);\n       d.insert(f[g][1]);\n       d.insert(f[g][4]);\n       e.insert(f[g][2]);\n       e.insert(f[g][5]);\n       }\n       int taiou[3][100];\n       memset(taiou,-1,sizeof(taiou));\n       auto r=c.begin();\n       for(int l=0;l<c.size();l++,r++){taiou[0][l]=*r;}\n       r=d.begin();\n       for(int l=0;l<d.size();l++,r++){taiou[1][l]=*r;}\n       r=e.begin();\n       for(int l=0;l<e.size();l++,r++){taiou[2][l]=*r;}\n       int S[99][99][99]{};\n       for(int p=0;p<a;p++){\n\t   for(int x=0;x<99;x++){\n\t       if(taiou[0][x+1]!=-1&&taiou[0][x]>=f[p][0]&&taiou[0][x+1]<=f[p][3]){\n\t\t   for(int y=0;y<99;y++){\n\t\t       if(taiou[1][y+1]!=-1&&taiou[1][y]>=f[p][1]&&taiou[1][y+1]<=f[p][4]){\n\t\t\t   for(int z=0;z<99;z++){\n\t\t\t       if(taiou[2][z+1]!=-1&&taiou[2][z]>=f[p][2]&&taiou[2][z+1]<=f[p][5]){\n\t\t\t\t   S[x][y][z]++;\n\t\t\t\t   }\n\t\t\t       }\n\t\t\t   }\n\t\t       }\n\t\t   }\n\t       }\n\t   }\n\t   int ans=0;\n\tfor(int x=0;x<99;x++){\n\t    for(int y=0;y<99;y++){\n\t\tfor(int z=0;z<99;z++){\n\t       if(S[x][y][z]>=b){\n\t\t   ans+=(taiou[0][x+1]-taiou[0][x])*(taiou[1][y+1]-taiou[1][y])*(taiou[2][z+1]-taiou[2][z]);\n\t\t   }\n\t           }\n\t\t}\n\t    }\n\t    cout<<ans<<endl;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\n\nunsigned long long int a[50][6];\nvector<unsigned long long int>x,y,d;\n\nint main(){\n\n\tint N,K;\n\tunsigned long long int x1,y1,d1,x2,y2,d2;\n\tcin >> N >> K;\n\trep(i,N){\n\t\tcin >> x1 >> y1 >> d1 >> x2 >> y2 >> d2;\n\t\ta[i][0]=x1; a[i][1]=y1; a[i][2]=d1; a[i][3]=x2; a[i][4]=y2; a[i][5]=d2;\n\t\tx.push_back(x1); x.push_back(x2);\n\t\ty.push_back(y1); y.push_back(y2);\n\t\td.push_back(d1); d.push_back(d2);\n\t}\n\n\tsort(x.begin(),x.end());\n\tvector<unsigned long long int>:: iterator itx=unique(x.begin(),x.end());\n\tx.erase(itx,x.end());\n\n\tsort(y.begin(),y.end());\n\tvector<unsigned long long int>:: iterator ity=unique(y.begin(),y.end());\n\ty.erase(ity,y.end());\n\n\tsort(d.begin(),d.end());\n\tvector<unsigned long long int>:: iterator itd=unique(d.begin(),d.end());\n\td.erase(itd,d.end());\n\n\tunsigned long long int V=0;\n\trep(i,x.size()-1){\n\t\trep(j,y.size()-1){\n\t\t\trep(k,d.size()-1){\n\t\t\t\tint t=0;\n\t\t\t\tdouble x0=(x[i]+x[i+1])/2.0,y0=(y[j]+y[j+1])/2.0,d0=(d[k]+d[k+1])/2.0;\n\n\t\t\t\trep(l,N){\n\t\t\t\tif(a[l][0]<=x0 && x0<=a[l][3] && a[l][1]<=y0 && y0<=a[l][4] && a[l][2]<=d0 && d0<=a[l][5])\n\t\t\t\t\tt++;\n\t\t\t\tif(t>=K){ V+=(x[i+1]-x[i])*(y[j+1]-y[j])*(d[k+1]-d[k]); break;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << V << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint compress(vector<ll>& v, vector<ll>& vs) {\n    sort(vs.begin(), vs.end());\n    vs.erase(unique(vs.begin(), vs.end()), vs.end());\n    for(int i=0; i<v.size(); ++i) {\n        v[i] = lower_bound(vs.begin(), vs.end(), v[i]) - vs.begin();\n    }\n    return vs.size();\n}\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<ll> x(2*N), y(2*N), z(2*N), xs(2*N), ys(2*N), zs(2*N);\n    for(int i=0; i<N; ++i) {\n        ll x1, y1, z1, x2, y2, z2;\n        cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n        x[2*i] = xs[2*i] = x1, x[2*i+1] = xs[2*i+1] = x2;\n        y[2*i] = ys[2*i] = y1, y[2*i+1] = ys[2*i+1] = y2;\n        z[2*i] = zs[2*i] = z1, z[2*i+1] = zs[2*i+1] = z2;\n    }\n    int xsize = compress(x, xs);\n    int ysize = compress(y, ys);\n    int zsize = compress(z, zs);\n    vector<vector<vector<int>>> sum(xsize, vector<vector<int>>(ysize, vector<int>(zsize)));\n    for(int i=0; i<N; ++i) {\n        for(int j=x[2*i]; j<x[2*i+1]; ++j) {\n            for(int k=y[2*i]; k<y[2*i+1]; ++k) {\n                for(int l=z[2*i]; l<z[2*i+1]; ++l) {\n                    ++sum[j][k][l];\n                }\n            }\n        }\n    }\n    ll res = 0;\n    for(int i=0; i<xsize-1; ++i) {\n        for(int j=0; j<ysize-1; ++j) {\n            for(int k=0; k<zsize-1; ++k) {\n                if(sum[i][j][k] >= K) {\n                    res += (xs[i+1] - xs[i]) * (ys[j+1] - ys[j]) * (zs[k+1] - zs[k]);\n                }\n            }\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main()\n{\n    int N, K;\n    cin >> N >> K;\n    vector<ll> X1(N), Y1(N), Z1(N);\n    vector<ll> X2(N), Y2(N), Z2(N);\n    vector<ll> xs, ys, zs;\n    for (int i = 0; i < N; i++) {\n        cin >> X1[i] >> Y1[i] >> Z1[i];\n        cin >> X2[i] >> Y2[i] >> Z2[i];\n        xs.push_back(X1[i]); xs.push_back(X2[i]);\n        ys.push_back(Y1[i]); ys.push_back(Y2[i]);\n        zs.push_back(Z1[i]); zs.push_back(Z2[i]);\n    }\n\n    sort(xs.begin(), xs.end());\n    xs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n    sort(ys.begin(), ys.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n    sort(zs.begin(), zs.end());\n    zs.erase(unique(zs.begin(), zs.end()), zs.end());\n    \n    ll res = 0;\n    for (int i = 0; i < (int)xs.size()-1; i++) {\n        for (int j = 0; j < (int)ys.size()-1; j++) {\n            for (int k = 0; k < (int)zs.size()-1; k++) {\n                int cnt = 0;\n                for (int l = 0; l < N; l++) {\n                    if (X1[l] <= xs[i] && xs[i+1] <= X2[l] &&\n                        Y1[l] <= ys[j] && ys[j+1] <= Y2[l] &&\n                        Z1[l] <= zs[k] && zs[k+1] <= Z2[l]) {\n                        cnt++;\n                    }\n                }\n                if (cnt >= K) {\n                    res += (xs[i+1] - xs[i]) * (ys[j+1] - ys[j]) * (zs[k+1] - zs[k]);\n                }\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokann ga bokka--nn!!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint main(){\n\tint n,kk;\n\tvector<int>xx,yy,zz;\n\tint x[55][2],y[55][2],z[55][2];\n\n\tcin >> n >> kk;\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin >> x[i][0] >> y[i][0] >> z[i][0]\n\t\t>> x[i][1] >> y[i][1] >> z[i][1];\n\t\txx.pb(x[i][0]);\n\t\txx.pb(x[i][1]);\n\t\tyy.pb(y[i][0]);\n\t\tyy.pb(y[i][1]);\n\t\tzz.pb(z[i][0]);\n\t\tzz.pb(z[i][1]);\n\t}\n\n\tsort(xx.begin(),xx.end());\n\tsort(yy.begin(),yy.end());\n\tsort(zz.begin(),zz.end());\n\txx.erase(unique(xx.begin(),xx.end()),xx.end());\n\tyy.erase(unique(yy.begin(),yy.end()),yy.end());\n\tzz.erase(unique(zz.begin(),zz.end()),zz.end());\n\n\tlong long val=0;\n\n\tfor(int i=0;i<xx.size()-1;i++)\n\t{\n\t\tfor(int j=0;j<yy.size()-1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<zz.size()-1;k++)\n\t\t\t{\n\t\t\t\tint check=0;\n\n\t\t\t\tfor(int a=0;a<n;a++)\n\t\t\t\t{\n\t\t\t\t\tif( (x[a][0]<=xx[i] && xx[i+1]<=x[a][1]) && (y[a][0]<=yy[j] && yy[j+1]<=y[a][1]) && (z[a][0]<=zz[k] && zz[k+1]<=z[a][1]))\n\t\t\t\t\t{\n\t\t\t\t\t\tcheck++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(check>=kk) val+=1LL*(xx[i+1]-xx[i])*(yy[j+1]-yy[j])*(zz[k+1]-zz[k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << val << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n    int n,k,xb,yb,zb,xe,ye,ze;\n    long long x1[51],x2[51],xs[101],y1[51],y2[51],ys[101],z1[51],z2[51],zs[101];\n    cin>>n>>k;\n    for(int i=0;i<n;++i){\n        cin>>xb>>yb>>zb>>xe>>ye>>ze;\n        x1[i]=xs[i*2]=xb;x2[i]=xs[i*2+1]=xe;\n        y1[i]=ys[i*2]=yb;y2[i]=ys[i*2+1]=ye;\n        z1[i]=zs[i*2]=zb;z2[i]=zs[i*2+1]=ze;\n    }\n    sort(xs,xs+2*n);sort(ys,ys+2*n);sort(zs,zs+2*n);\n    long long ans=0;\n    for(int i=0;i<2*n-1;++i){\n        for(int j=0;j<2*n-1;++j){\n            for(int p=0;p<2*n-1;++p){\n                int cnt=0;\n                for(int l=0;l<n;++l){\n                    if(xs[i+1]<=x2[l]&&xs[i]>=x1[l]&&ys[j+1]<=y2[l]&&ys[j]>=y1[l]&&zs[p+1]<=z2[l]&&zs[p]>=z1[l]) ++cnt;\n                }\n                if(cnt>=k) ans +=(xs[i+1]-xs[i])*(ys[j+1]-ys[j])*(zs[p+1]-zs[p]);\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint coun[105][105][105];\nvector<int>x,y,z;\nint rx[52][2], ry[52][2], rz[52][2];\nint n,m;\n\nint compress1(int x1[52], int x2[52]){\n\tfor(int i = 0;i < n;i++){\n\t\tx.push_back(x1[i]);\n\t\tx.push_back(x2[i]);\n\t}\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tfor(int i = 0;i < n;i++){\n\t\trx[i][0] = find(x.begin(),x.end(),x1[i])-x.begin();\n\t\trx[i][1] = find(x.begin(),x.end(),x2[i])-x.begin();\n\t}\n\treturn x.size();\n}\n\nint compress2(int x1[52], int x2[52]){\n\tfor(int i = 0;i < n;i++){\n\t\ty.push_back(x1[i]);\n\t\ty.push_back(x2[i]);\n\t}\n\tsort(y.begin(), y.end());\n\ty.erase(unique(y.begin(), y.end()), y.end());\n\tfor(int i = 0;i < n;i++){\n\t\try[i][0] = find(y.begin(),y.end(),x1[i])-y.begin();\n\t\try[i][1] = find(y.begin(),y.end(),x2[i])-y.begin();\n\t}\n\treturn y.size();\n}\n\nint compress3(int x1[52], int x2[52]){\n\tfor(int i = 0;i < n;i++){\n\t\tz.push_back(x1[i]);\n\t\tz.push_back(x2[i]);\n\t}\n\tsort(z.begin(), z.end());\n\tz.erase(unique(z.begin(), z.end()), z.end());\n\tfor(int i = 0;i < n;i++){\n\t\trz[i][0] = find(z.begin(),z.end(),x1[i])-z.begin();\n\t\trz[i][1] = find(z.begin(),z.end(),x2[i])-z.begin();\n\t}\n\treturn z.size();\n}\n\nvoid paint(){\n\tfor(int i = 0;i < n;i++){\n\tfor(int tx=rx[i][0];tx<rx[i][1];tx++)\n    {\n      for(int ty=ry[i][0];ty<ry[i][1];ty++)\n        {\n          for(int tz=rz[i][0];tz<rz[i][1];tz++)\n        {\n          coun[tx][ty][tz]++;\n        }\n        }\n    }\n\t}\n}\n\nint main()\n{\n\tint a[52],b[52],c[52],d[52],e[52],f[52];\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d %d %d %d %d\",&a[i],&b[i],&c[i],&d[i],&e[i],&f[i]);\n\t}\n\tint w = compress1(a, d);\n\tint h = compress2(b, e);\n\tint p = compress3(c, f);\n\tpaint();\n\t\n  long long ans=0;\n  for(int i=0;i<=w;i++)\n    {\n      for(int j=0;j<=h;j++)\n    {\n      for(int k=0;k<=p;k++)\n        {\n          if(coun[i][j][k]>=m)\n        {\n          long long s1=(x[i+1]-x[i]),s2=(y[j+1]-y[j]),s3=(z[k+1]-z[k]);\n          ans+=s1*s2*s3;\n        }\n        }\n    }\n    }\n\t//long long ans = 0;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cctype>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<queue>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 1000000007\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\ntypedef long long int ll;\nll dx[4] = {1,0,0,-1};\nll dy[4] = {0,1,-1,0};\n\n#define ARRAY_MAX 55\nll n,k,h,w,d;\nll X1[ARRAY_MAX],X2[ARRAY_MAX],Y1[ARRAY_MAX],Y2[ARRAY_MAX],D1[ARRAY_MAX],D2[ARRAY_MAX];\nll field[ARRAY_MAX*4][ARRAY_MAX*4][ARRAY_MAX*4];\nvector<ll> xs,ys,ds,xunzip,yunzip,dunzip;\nmap<ll,ll> xzip,yzip,dzip;\n\nvoid compress(vector<ll>& x,map<ll,ll>& zip,vector<ll>& unzip){\n\n    VSORT(x);\n    x.erase(unique(x.begin(),x.end()),x.end());\n    unzip.resize(x.size());\n    REP(i,x.size()){\n        zip[x[i]] = i;\n        unzip[i] = x[i];\n    }\n}\n\n\nint main(){\n\n\n    cin >> n >> k;\n    \n    REP(i,n){\n        cin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n        xs.push_back(X1[i]);\n        xs.push_back(X2[i]);\n        ys.push_back(Y1[i]);\n        ys.push_back(Y2[i]);\n        ds.push_back(D1[i]);\n        ds.push_back(D2[i]);\n    }\n\n    compress(xs,xzip,xunzip);\n    compress(ys,yzip,yunzip);\n    compress(ds,dzip,dunzip);\n\n    w = xzip.size();\n    h = yzip.size();\n    d = dzip.size();\n\n    REP(i,n){\n        field[yzip[Y1[i]]][xzip[X1[i]]][dzip[D1[i]]]++;\n        field[yzip[Y1[i]]][xzip[X2[i]]][dzip[D1[i]]]--;\n        field[yzip[Y2[i]]][xzip[X1[i]]][dzip[D1[i]]]--;\n        field[yzip[Y2[i]]][xzip[X2[i]]][dzip[D1[i]]]++;\n        field[yzip[Y1[i]]][xzip[X1[i]]][dzip[D2[i]]]--;\n        field[yzip[Y1[i]]][xzip[X2[i]]][dzip[D2[i]]]++;\n        field[yzip[Y2[i]]][xzip[X1[i]]][dzip[D2[i]]]++;\n        field[yzip[Y2[i]]][xzip[X2[i]]][dzip[D2[i]]]--;\n    }\n        \n    REP(i,h+1)REP(j,w)REP(m,d){//横\n        field[i][j+1][m] += field[i][j][m];\n    }\n\n\n    REP(j,w+1)REP(i,h)REP(m,d){//縦\n        field[i+1][j][m] += field[i][j][m];\n    }\n\n    REP(m,d+1)REP(i,h)REP(j,w){\n        field[i][j][m+1] += field[i][j][m];\n    }\n\n    ll ans = 0;\n    REP(i,h)REP(j,w)REP(m,d){\n        if(field[i][j][m] >= k){\n            ans += (yunzip[i+1] - yunzip[i])*(xunzip[j+1] - xunzip[j])*(dunzip[m+1] - dunzip[m]);\n\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nconst int MAX_N = 60;\nusing namespace std;\n\ntypedef long long ll;\nstruct point {\n  ll x, y, z;\n};\ntypedef pair<point, point> P;\n\nint main(void) {\n  int N, K;\n  vector<ll> x, y, z;\n  cin >> N >> K;\n\n  point p1, p2;\n  vector<P> pair_points;\n  for (int i = 0; i < N; i++) {\n    cin >> p1.x >> p1.y >> p1.z\n        >> p2.x >> p2.y >> p2.z;\n    pair_points.push_back(P(p1, p2));\n\n    x.push_back(p1.x);\n    x.push_back(p2.x);\n    y.push_back(p1.y);\n    y.push_back(p2.y);\n    z.push_back(p1.z);\n    z.push_back(p2.z);\n  }\n\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  sort(z.begin(), z.end());\n  map<ll, int> zipped_x, zipped_y, zipped_z;\n  for (int i = 0; i < x.size(); i++) {\n    zipped_x[x[i]] = i;\n  }\n  for (int i = 0; i < y.size(); i++) {\n    zipped_y[y[i]] = i;\n  }\n  for (int i = 0; i < z.size(); i++) {\n    zipped_z[z[i]] = i;\n  }\n\n\n  int ocean[MAX_N*2][MAX_N*2][MAX_N*2];\n  for (int i = 0; i < MAX_N*2; i++) {\n    for (int j = 0; j < MAX_N*2; j++) {\n      for (int k = 0; k < MAX_N*2; k++) {\n        ocean[i][j][k] = 0;\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = zipped_x[pair_points[i].first.x]; j < zipped_x[pair_points[i].second.x]; j++) {\n      for (int k = zipped_y[pair_points[i].first.y]; k < zipped_y[pair_points[i].second.y]; k++) {\n        for (int l = zipped_z[pair_points[i].first.z]; l < zipped_z[pair_points[i].second.z]; l++) {\n          ocean[j][k][l]++;\n        }\n      }\n    }\n  }\n\n  ll ans = 0;\n  for (int i = 0; i < x.size()-1; i++) {\n    for (int j = 0; j < y.size()-1; j++) {\n      for (int k = 0; k < z.size()-1; k++) {\n        if (ocean[i][j][k] >= K) {\n          ans += (x[i+1]-x[i])*(y[j+1]-y[j])*(z[k+1]-z[k]);\n        }\n      }\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\n\ntypedef unsigned long long ll;\nint n,K;\nint xf[100],xt[100];\nint yf[100],yt[100];\nint zf[100],zt[100];\nvector<int> vx;\nvector<int> vy;\nvector<int> vz;\nint cnt[501][501][501];\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tvx.push_back(xf[i]);\n\t\tvx.push_back(xt[i]);\n\t\tvy.push_back(yf[i]);\n\t\tvy.push_back(yt[i]);\n\t\tvz.push_back(zf[i]);\n\t\tvz.push_back(zt[i]);\n\t}\n\tsort(vx.begin(),vx.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tsort(vz.begin(),vz.end());\n\tvz.erase(unique(vz.begin(),vz.end()),vz.end());\t\n\tfor(int i=0;i<n;i++){\n\t\t//printf(\"%d %d %d %d %d %d\\n\",xf[i],xt[i],yf[i],yt[i],zf[i],zt[i]);\n\t\txf[i]=find(vx.begin(),vx.end(),xf[i])-vx.begin();\n\t\txt[i]=find(vx.begin(),vx.end(),xt[i])-vx.begin();\n\t\tyf[i]=find(vy.begin(),vy.end(),yf[i])-vy.begin();\n\t\tyt[i]=find(vy.begin(),vy.end(),yt[i])-vy.begin();\n\t\tzf[i]=find(vz.begin(),vz.end(),zf[i])-vz.begin();\n\t\tzt[i]=find(vz.begin(),vz.end(),zt[i])-vz.begin();\n\t\t//printf(\"%d %d %d %d %d %d\\n\",xf[i],xt[i],yf[i],yt[i],zf[i],zt[i]);\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&K);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d%d%d%d%d\",&xf[i],&yf[i],&zf[i],&xt[i],&yt[i],&zt[i]);\n\t}\n\tzatu();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=xf[i];j<xt[i];j++){\n\t\t\tfor(int k=yf[i];k<yt[i];k++){\n\t\t\t\tfor(int l=zf[i];l<zt[i];l++){\n\t\t\t\t\tcnt[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll res=0;\n\tfor(int i=0;i<vx.size()-1;i++){\n\t\tfor(int j=0;j<vy.size()-1;j++){\n\t\t\tfor(int k=0;k<vz.size()-1;k++){\n\t\t\t\tif(cnt[i][j][k]>=K){\n\t\t\t\t\tres+=(ll)(vx[i+1]-vx[i])*(vy[j+1]-vy[j])*(vz[k+1]-vz[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <assert.h>\n\nusing namespace std;\n\nnamespace\n{\n\tint n, k;\n\tint x1[50], yy[50], d1[50], x2[50], y2[50], d2[50];\n\tint cx1[50], cy1[50], cd1[50], cx2[50], cy2[50], cd2[50];\n\n\tint compd[123][123][123];\n}\n\n//w1,w2???????????????????????§???????????§???????????????\nvector<int> compress(int *w1, int *w2)\n{\n\tvector<int>ws;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tws.push_back(w1[i]);\n\t\tws.push_back(w2[i]);\n\t}\n\tsort(ws.begin(), ws.end());\n\tws.erase(unique(ws.begin(), ws.end()), ws.end());\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tw1[i] = find(ws.begin(), ws.end(), w1[i]) - ws.begin();\n\t\tw2[i] = find(ws.begin(), ws.end(), w2[i]) - ws.begin();\n\t}\n\treturn ws;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &k);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d %d %d %d %d %d\", x1 + i, yy + i, d1 + i, x2 + i, y2 + i, d2 + i);\n\t}\n\t\n\tauto xsv = compress(x1, x2);\n\tauto ysv = compress(yy, y2);\n\tauto dsv = compress(d1, d2);\n\tint xs = xsv.size();\n\tint ys = ysv.size();\n\tint ds = dsv.size();\n\n\tmemset(compd, 0, sizeof(compd));\n\n\t//??????????¨????\n\tfor (int i = 0;i < n;++i)\n\t{\n\t\tconst int hash[8][3] = { {0,0,0},{0,0,1},{0,1,0},{0,1,1},{1,0,0},{1,0,1},{1,1,0},{1,1,1}, };\n\t\tfor (int p = 0; p < 8; ++p)\n\t\t{\n\t\t\tcompd\n\t\t\t\t[hash[p][0] ? x1[i] : x2[i]]\n\t\t\t\t[hash[p][1] ? yy[i] : y2[i]]\n\t\t\t\t[hash[p][2] ? d1[i] : d2[i]] =\n\t\t\t\t\t(hash[p][0]^hash[p][1]^hash[p][2]) ? 1 : -1;\n\t\t}\n\t}\n\t\n\t//?´????????????¨???\n\tfor (int x = 0; x < xs; ++x)\n\t{\n\t\tfor (int y = 0; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 1; d < ds; ++d)\n\t\t\t{\n\t\t\t\tcompd[x][y][d] += compd[x][y][d - 1];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 0; x < xs; ++x)\n\t{\n\t\tfor (int y = 1; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < ds; ++d)\n\t\t\t{\n\t\t\t\tcompd[x][y][d] += compd[x][y - 1][d];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 1; x < xs; ++x)\n\t{\n\t\tfor (int y = 0; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < ds; ++d)\n\t\t\t{\n\t\t\t\tcompd[x][y][d] += compd[x - 1][y][d];\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor (int x = 0; x < xs; ++x)\n\t{\n\t\tfor (int y = 0; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < ds; ++d)\n\t\t\t{\n\t\t\t\tassert(compd[x][y][d] >= 0);\n\t\t\t\tif (compd[x][y][d] >= k)\n\t\t\t\t{\n\t\t\t\t\tans += (xsv[x + 1] - xsv[x]) * (ysv[y + 1] - ysv[y]) * (dsv[d + 1] - dsv[d]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\n    int N,K;\n    scanf(\"%d%d\",&N,&K);\n    int pos[2][3][60];\n    vector<int> crs[3];\n    for(int i=0;i<N;i++){\n        for(int j=0;j<2;j++){\n            for(int k=0;k<3;k++){\n                scanf(\"%d\",&pos[j][k][i]);\n                crs[k].push_back(pos[j][k][i]);\n            }\n        }\n    }\n    for(auto &x:crs){\n        sort(x.begin(),x.end());\n        x.erase(unique(x.begin(),x.end()),x.end());\n    }\n    long long ans=0;\n    for(int i=0;i<crs[0].size()-1;i++){\n        for(int j=0;j<crs[1].size()-1;j++){\n            for(int k=0;k<crs[2].size()-1;k++){\n                int cnt=0;\n                for(int l=0;l<N;l++){\n                    if(pos[0][0][l]<=crs[0][i]&&crs[0][i]<pos[1][0][l]\n                            && pos[0][1][l]<=crs[1][j]&&crs[1][j]<pos[1][1][l]\n                            && pos[0][2][l]<=crs[2][k]&&crs[2][k]<pos[1][2][l]) cnt++;\n                }\n                if(cnt>=K) ans+=(long long)(crs[0][i+1]-crs[0][i])*(crs[1][j+1]-crs[1][j])*(crs[2][k+1]-crs[2][k]);\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nint N, K;\nint X1[55], X2[55];\nint Y1[55], Y2[55];\nint Z1[55], Z2[55];\n\nvector<int> X, Y, Z;\n\nint cnt[110][110][110];\n\nint compress(int *x1, int *x2, vector<int> &res)\n{\n    rep(i, N) {\n        res.push_back(x1[i]);\n        res.push_back(x2[i]);\n    }\n\n    sort(all(res));\n\n    return res.size();\n}\n\nint get_index(vector<int> &a, int v)\n{\n    return lower_bound(all(a), v) - begin(a);\n}\n\nbool ok(int z, int y, int x)\n{\n    bool res = true;\n\n    res &= cnt[z][y][x] >= K;\n    res &= cnt[z][y][x+1] >= K;\n    res &= cnt[z][y+1][x] >= K;\n    res &= cnt[z][y+1][x+1] >= K;\n    res &= cnt[z+1][y][x] >= K;\n    res &= cnt[z+1][y][x+1] >= K;\n    res &= cnt[z+1][y+1][x] >= K;\n    res &= cnt[z+1][y+1][x+1] >= K;\n\n    return res;\n}\n\nint main()\n{\n    cin >> N >> K;\n\n    rep(i, N) {\n        cin >> X1[i] >> Y1[i] >> Z1[i];\n        cin >> X2[i] >> Y2[i] >> Z2[i];\n    }\n\n    int x = compress(X1, X2, X);\n    int y = compress(Y1, Y2, Y);\n    int z = compress(Z1, Z2, Z);\n\n    rep(i, N) {\n        for (int j = get_index(Z, Z1[i]), j_len = get_index(Z, Z2[i]); j <= j_len; ++j) {\n            for (int k = get_index(Y, Y1[i]), k_len = get_index(Y, Y2[i]); k <= k_len; ++k) {\n                for (int l = get_index(X, X1[i]), l_len = get_index(X, X2[i]); l <= l_len; ++l) {\n                    cnt[j][k][l]++;\n                }\n            }\n        }\n    }\n\n    long long ans = 0;\n\n    rep(i, z - 1) rep(j, y - 1) rep(k, x - 1) {\n        if (ok(i, j, k)) {\n            ans += 1ll * (Z[i + 1] - Z[i]) * (Y[j + 1] - Y[j]) * (X[k + 1] - X[k]);\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nstruct fish {\n\tint lx, ly, lz;\n\tint rx, ry, rz;\n};\nstruct Compress {\n\tmap<int, int>mp;\n\tmap<int, int>revmp;\n\n\tCompress(vector<int>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < vs.size(); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\tCompress(const set<int>&vs) {\n\t\tint num = 0;\n\t\tfor (auto v : vs) {\n\t\t\tmp[v] = num;\n\t\t\trevmp[num] = v;\n\t\t\tnum++;\n\t\t}\n\t}\n};\nint pluss[101][101][101];\nint num[102][102][102];\nint main() {\n\tint N, K; cin >> N >> K;\n\tvector<fish>fs;\n\tvector<int>xs, ys, zs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint lx, ly, ld, rx, ry, rd; cin >> lx >> ly >> ld >> rx >> ry >> rd;\n\t\tfs.push_back(fish{lx, ly, ld, rx, ry, rd});\n\t\txs.push_back(lx); xs.push_back(rx);\n\t\tys.push_back(ly); ys.push_back(ry);\n\t\tzs.push_back(ld); zs.push_back(rd);\n\t}\n\tCompress cx(xs), cy(ys), cz(zs);\n\tfor (auto &f : fs) {\n\t\tf.lx = cx.mp[f.lx];\n\t\tf.rx = cx.mp[f.rx];\n\t\tf.ly = cy.mp[f.ly];\n\t\tf.ry = cy.mp[f.ry];\n\t\tf.lz = cz.mp[f.lz];\n\t\tf.rz = cz.mp[f.rz];\n\t}\n\tmemset(pluss, 0, sizeof(pluss));\n\tfor (auto f : fs) {\n\t\tpluss[f.lx][f.ly][f.lz]++;\n\t\tpluss[f.rx][f.ly][f.lz]--;\n\t\tpluss[f.lx][f.ry][f.lz]--;\n\t\tpluss[f.lx][f.lx][f.rz]--;\n\t\tpluss[f.rx][f.ry][f.lz]++;\n\t\tpluss[f.lx][f.ry][f.rz]++;\n\t\tpluss[f.rx][f.ly][f.rz]++;\n\t\tpluss[f.rx][f.ry][f.rz]--;\n\t}\n\tmemset(num, 0, sizeof(num));\n\tlong long int ans = 0;\n\tfor (int x = 1; x < 102; ++x) {\n\t\tfor (int y = 1; y < 102; ++y) {\n\t\t\tfor (int z = 1; z < 102; ++z) {\n\t\t\t\tnum[x][y][z] = pluss[x - 1][y - 1][z - 1]+ num[x][y][z - 1] + num[x][y - 1][z] +num[x - 1][y][z] - num[x - 1][y - 1][z] - num[x - 1][y][z - 1]- num[x][y - 1][z - 1] +num[x - 1][y - 1][z - 1];\n\t\t\t\tif (num[x][y][z] >= K) {\n\t\t\t\t\tlong long int dx = cx.revmp[x] - cx.revmp[x - 1];\n\t\t\t\t\tlong long int dy = cy.revmp[y] - cy. revmp[y - 1];\n\t\t\t\t\tlong long int dz = cz.revmp[z] - cz.revmp[z - 1];\n\t\t\t\t\tans += dx*dy*dz;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n#define F first\n#define S second\n#define P_MAX (10000010)\nint px[51*6];\nint py[51*6];\nint pz[51*6];\nint W,H,D;\nint N,K;\nP sx[51];\nP sy[51];\nP sz[51];\nint ash(P *ps,int *pp,int &p){\n  vector<int> pv;\n  for(int i=0;i<N;i++){\n    for(int j=-1;j<2;j++){\n      if(ps[i].F+j >= 0)\n\tpv.push_back(ps[i].F+j);\n      if(ps[i].S+j >= 0)\n\tpv.push_back(ps[i].S+j);\n    }\n  }\n  sort(pv.begin(),pv.end());\n  pv.erase(unique(pv.begin(),pv.end()),pv.end());\n  for(int i=0;i<N;i++){\n    ps[i].F = find(pv.begin(),pv.end(),ps[i].F)-pv.begin();\n    ps[i].S = find(pv.begin(),pv.end(),ps[i].S)-pv.begin();\n  }\n  for(int i=0;i<(int)pv.size()-1;i++){\n    pp[i] = pv[i+1]-pv[i];\n    //    printf(\"%d %d %d\\n\",pv[i+1],pv[i],pv[i+1]-pv[i]);\n  }\n  pp[(int)pv.size()-1] = P_MAX-pv[(int)pv.size()-1];\n  //  printf(\"Last: %d\\n\",P_MAX-pv[(int)pv.size()-1]);\n  p = (int)pv.size();\n}\n\nbool ok(int x,int y,int z,int id){\n  if( sx[id].F <= x && x < sx[id].S ){\n    if( sy[id].F <= y && y < sy[id].S ){\n      if( sz[id].F <= z && z < sz[id].S ){\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nvoid printN(){\n  printf(\"%d %d %d\\n\",W,H,D);\n  for(int id=0;id<N;id++){\n    printf(\"%d %d %d %d %d %d\\n\",\n\t   sx[id].F,sy[id].F,sz[id].F,\n\t   sx[id].S,sy[id].S,sz[id].S);\n  }\n}\n\nll solve(){\n  ll res = 0;\n  ash(sx,px,W);\n  ash(sy,py,H);\n  ash(sz,pz,D);\n  printN();\n  for(int x=0;x<W;x++){\n    for(int y=0;y<H;y++){\n      for(int z=0;z<D;z++){\n\tint co = 0;\n\t//\tprintf(\"%d %d %d\\n\",px[x],py[y],pz[z]);\n\tfor(int i=0;i<N;i++){\n\t  if(ok(x,y,z,i)){\n\t    co++;\n\t  }\n\t}\n\t//printf(\"%d\\n\",co);\n\tif(K<=co){\n\t  //\t  printf(\"%d:%d %d:%d %d:%d\\n\",x,px[x],y,py[y],z,pz[z]);\n\t  res+=(ll)px[x]*(ll)py[y]*(ll)pz[z];\n\t  // printf(\"%lld\\n\",res);\n\t}\n      }\n    }\n  }\n  return res;\n}\nint main(){\n  scanf(\"%d %d\",&N,&K);\n  for(int i=0;i<N;i++){\n    scanf(\"%d %d %d %d %d %d\",\n\t  &sx[i].F,&sy[i].F,&sz[i].F,\n\t  &sx[i].S,&sy[i].S,&sz[i].S);\t  \n  }\n  printf(\"%lld\\n\",solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <string>\nconst int INF = 1 << 30;\nusing namespace std;\n\nint n, k;\n\nint pt[150][150][150];\nint X1[50], X2[50], Y1[50], Y2[50], D1[50], D2[50];\nlong long int uX[150], uY[150], uD[150];\n\nint compress(int *x1, int *x2, long long int *unzip){\n\tvector<int> vec;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = -1; j <= 1; j++){\n\t\t\tint a = x1[i] + j, b = x2[i] + j;\n\t\t\tif (0 <= a) vec.push_back(a);\n\t\t\tif (0 <= b) vec.push_back(b);\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tfor (int i = 0; i < n; i++){\n\t\tx1[i] = find(vec.begin(), vec.end(), x1[i]) - vec.begin();\n\t\tx2[i] = find(vec.begin(), vec.end(), x2[i]) - vec.begin();\n\t}\n\tfor (int i = 0; i < vec.size(); i++)\n\t\tunzip[i] = vec[i];\n\treturn vec.size();\n}\n\nint main(){\n\tint W, H, D;\n\tlong long int ans = 0;\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i];\n\t\tcin >> X2[i] >> Y2[i] >> D2[i];\n\t}\n\tW = compress(X1, X2, uX);\n\tH = compress(Y1, Y2, uY);\n\tD = compress(D1, D2, uD);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = X1[i]; j < X2[i]; j++){\n\t\t\tfor (int m = Y1[i]; m < Y2[i]; m++){\n\t\t\t\tfor (int l = D1[i]; l < D2[i]; l++){\n\t\t\t\t\tpt[j][m][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int m = 0; m <D; m++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tfor (int i = 0; i < W;i++){\n\t\t\t\tif (pt[i][j][m] >= k&&uX[i + 1] && uY[j + 1] && uD[m + 1]){\n\t\t\t\t\t\tans += (uX[i+1] - uX[i]) * (uY[j+1] - uY[j]) * (uD[m+1] - uD[m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nint q[55][2][3];\n\nint xx[55];\nint yy[55];\nint zz[55];\n\nint w[55][55][55];\n\nint main()\n{\n\tint n,k;\n\tscanf(\"%d %d\",&n,&k);\n\t\n\tpriority_queue<int,vector<int>,greater<int> > x,y,z;\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d %d %d %d %d %d\",&q[i][0][0],&q[i][0][1],&q[i][0][2],&q[i][1][0],&q[i][1][1],&q[i][1][2]);\n\t\tx.push(q[i][0][0]);\n\t\tx.push(q[i][1][0]);\n\t\ty.push(q[i][0][1]);\n\t\ty.push(q[i][1][1]);\n\t\tz.push(q[i][0][2]);\n\t\tz.push(q[i][1][2]);\n\t}\n\t\n\tint xw = 0;\n\tint yw = 0;\n\tint zw = 0;\n\tint mae;\n\tmae = -1;\n\twhile(x.empty() == false)\n\t{\n\t\tif(mae != x.top())\n\t\t{\n\t\t\txx[xw] = x.top();\n\t\t\tmae = x.top();\n\t\t\txw++;\n\t\t}\n\t\tx.pop();\n\t}\n\tmae = -1;\n\twhile(y.empty() == false)\n\t{\n\t\tif(mae != y.top())\n\t\t{\n\t\t\tyy[yw] = y.top();\n\t\t\tmae = y.top();\n\t\t\tyw++;\n\t\t}\n\t\ty.pop();\n\t}\n\tmae = -1;\n\twhile(z.empty() == false)\n\t{\n\t\tif(mae != z.top())\n\t\t{\n\t\t\tzz[zw] = z.top();\n\t\t\tmae = z.top();\n\t\t\tzw++;\n\t\t}\n\t\tz.pop();\n\t}\n\t\n\tfor(int i = 0; i < xw; i++)\n\t{\n\t\tfor(int ii = 0; ii < yw; ii++)\n\t\t{\n\t\t\tfor(int iii = 0; iii < zw; iii++)\n\t\t\t{\n\t\t\t\tw[i][ii][iii] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int j = 0; j < n; j++)\n\t{\n\t\tfor(int i = 0; i < xw; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < yw; ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii < zw; iii++)\n\t\t\t\t{\n\t\t\t\t\tif(q[j][0][0] <= xx[i] && xx[i] < q[j][1][0] && q[j][0][1] <= yy[ii] && yy[ii] < q[j][1][1] && q[j][0][2] <= zz[iii] && zz[iii] < q[j][1][2])\n\t\t\t\t\t{\n\t\t\t\t\t\tw[i][ii][iii]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long int all = 0;\n\tfor(int i = 0; i < xw; i++)\n\t{\n\t\tfor(int ii = 0; ii < yw; ii++)\n\t\t{\n\t\t\tfor(int iii = 0; iii < zw; iii++)\n\t\t\t{\n\t\t\t\tif(w[i][ii][iii] >= k)\n\t\t\t\t{\n\t\t\t\t\tall += (xx[i + 1] - xx[i]) * (yy[ii + 1] - yy[ii]) * (zz[iii + 1] - zz[iii]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\",all);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\n\nint N,K;\nint W,H,D;\nint X1[55],Y1[55],Z1[55],X2[55],Y2[55],Z2[55];\nint cx1[55],cy1[55],cz1[55],cx2[55],cy2[55],cz2[55];\nvector<int> X,Y,Z;\nint8_t fld[55*6][55*6][55*6];\n\nint ans;\nvector<int> xs;\n\nvoid compress(vector<int> &X,int* x1,int* x2,int* vx1,int* vx2,int w,int* P){\n    xs.clear();\n    for(int i=0;i<N;++i){\n        x1[i]=vx1[i];\n        x2[i]=vx2[i];\n    }\n    for(int i=0;i<N;++i){\n        for(int d=-1;d<=1;++d){\n            int tx1=x1[i]+d;\n            int tx2=x2[i]+d;\n            if(0<=tx1&&tx1<=w)xs.PB(tx1);\n            if(0<=tx2&&tx2<=w)xs.PB(tx2);\n        }\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    //for(int i=0;i<xs.size();++i)cout<<xs[i]<<endl;\n    for(int i=0;i<xs.size();++i){\n        X.PB(xs[i+1]-xs[i]);\n    }\n    *P = xs.size();\n}\n\nint main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    compress(X,cx1,cx2,X1,X2,1000000,&W);\n    compress(Y,cy1,cy2,Y1,Y2,1000000,&H);\n    compress(Z,cz1,cz2,Z1,Z2,1000000,&D);\n    for(int i=0;i<N;++i){\n        for(int z=cz1[i];z<cz2[i];++z){\n            for(int y=cy1[i];y<cy2[i];++y){\n                for(int x=cx1[i];x<cx2[i];++x){\n                    fld[z][y][x]++;\n                }\n            }\n        }\n    }\n    for(int z=0;z<=D;++z){\n        for(int y=0;y<=H;++y){\n            for(int x=0;x<=W;++x){\n                if(fld[z][y][x]>=K)ans+=X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n\n    //cout<<W<<\" \"<<H<<\" \"<<D<<endl;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n#define F first\n#define S second\n#define P_MAX (10000010)\nint px[51*6];\nint py[51*6];\nint pz[51*6];\nint W,H,D;\nint N,K;\nP sx[51];\nP sy[51];\nP sz[51];\nint ash(P *ps,int *pp,int &p){\n  vector<int> pv;\n  for(int i=0;i<N;i++){\n    for(int j=-1;j<2;j++){\n      if(ps[i].F+j >= 0)\n\tpv.push_back(ps[i].F+j);\n      if(ps[i].S+j >= 0)\n\tpv.push_back(ps[i].S+j);\n    }\n  }\n  sort(pv.begin(),pv.end());\n  pv.erase(unique(pv.begin(),pv.end()),pv.end());\n  for(int i=0;i<N;i++){\n    ps[i].F = find(pv.begin(),pv.end(),ps[i].F)-pv.begin();\n    ps[i].S = find(pv.begin(),pv.end(),ps[i].S)-pv.begin();\n  }\n  for(int i=0;i<(int)pv.size()-1;i++){\n    pp[i] = pv[i+1]-pv[i];\n    //    printf(\"%d %d %d\\n\",pv[i+1],pv[i],pv[i+1]-pv[i]);\n  }\n  pp[(int)pv.size()-1] = P_MAX-pv[(int)pv.size()-1];\n  //  printf(\"Last: %d\\n\",P_MAX-pv[(int)pv.size()-1]);\n  p = (int)pv.size();\n}\n\nbool ok(int x,int y,int z,int id){\n  if( sx[id].F <= x && x < sx[id].S ){\n    if( sy[id].F <= y && y < sy[id].S ){\n      if( sz[id].F <= z && z < sz[id].S ){\n\treturn true;\n      }\n    }\n  }\n  return false;\n}\n\nvoid printN(){\n  printf(\"%d %d %d\\n\",W,H,D);\n  for(int id=0;id<N;id++){\n    printf(\"%d %d %d %d %d %d\\n\",\n\t   sx[id].F,sy[id].F,sz[id].F,\n\t   sx[id].S,sy[id].S,sz[id].S);\n  }\n}\n\nll solve(){\n  ll res = 0;\n  ash(sx,px,W);\n  ash(sy,py,H);\n  ash(sz,pz,D);\n  //  printN();\n  for(int x=0;x<W;x++){\n    for(int y=0;y<H;y++){\n      for(int z=0;z<D;z++){\n\tint co = 0;\n\t//\tprintf(\"%d %d %d\\n\",px[x],py[y],pz[z]);\n\tfor(int i=0;i<N;i++){\n\t  if(ok(x,y,z,i)){\n\t    co++;\n\t  }\n\t}\n\t//printf(\"%d\\n\",co);\n\tif(K<=co){\n\t  //\t  printf(\"%d:%d %d:%d %d:%d\\n\",x,px[x],y,py[y],z,pz[z]);\n\t  res+=(ll)px[x]*(ll)py[y]*(ll)pz[z];\n\t  // printf(\"%lld\\n\",res);\n\t}\n      }\n    }\n  }\n  return res;\n}\nint main(){\n  scanf(\"%d %d\",&N,&K);\n  for(int i=0;i<N;i++){\n    scanf(\"%d %d %d %d %d %d\",\n\t  &sx[i].F,&sy[i].F,&sz[i].F,\n\t  &sx[i].S,&sy[i].S,&sz[i].S);\t  \n  }\n  printf(\"%lld\\n\",solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n\nusing namespace std;\n\ntypedef struct{\n\tint xl;\n\tint xr;\n\tint yl;\n\tint yr;\n\tint zl;\n\tint zr;\n} fish_t;\n\nint comp(const void *c1, const void *c2);\n\nint main(){\n\tint N;\n\tint K;\n\n\t//魚の種類数と数える種類数を入力\n\tcin >> N >> K;\n\n\tint *X = new int[2*N];\n\tint *Y = new int[2*N];\n\tint *Z = new int[2*N];\n\n\t//座標を入力\n\tfor(int i=0; i<N; i++){ cin >> X[2*i] >> Y[2*i] >> Z[2*i] >> X[2*i+1] >> Y[2*i+1] >> Z[2*i+1]; }\n\n\n\tfish_t *fish = new fish_t[N];\n\t\n\t//各魚の生息領域を代入\n\tfor(int i=0; i<N; i++){\n\t\tint L = 2*i;\n\t\tint R = 2*i+1;\n\n\t\tfish[i].xl = X[L];\n\t\tfish[i].xr = X[R];\n\t\tfish[i].yl = Y[L];\n\t\tfish[i].yr = Y[R];\n\t\tfish[i].zl = Z[L];\n\t\tfish[i].zr = Z[R];\n\t}\n\n\t//座標を小さい順に並べ替える\n\tqsort(X, 2*N, sizeof(int), comp);\n\tqsort(Y, 2*N, sizeof(int), comp);\n\tqsort(Z, 2*N, sizeof(int), comp);\n\n\tint dim = 2*N - 1;\n\n\t//各ブロックの魚の種類を数え、K種類以上の体積を求める\n\tunsigned long long V = 0;\n\n\tfor(int z=0; z<dim; z++){\n\t\tfor(int y=0; y<dim; y++){\n\t\t\tfor(int x=0; x<dim; x++){\n\t\t\t\tint k = 0;\n\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tif( (fish[i].xl > X[x]) || (fish[i].xr < X[x+1]) || (fish[i].yl > Y[y]) || (fish[i].yr < Y[y+1]) || (fish[i].zl > Z[z]) || (fish[i].zr < Z[z+1]) ){ continue; }\n\t\t\t\t\telse{ k++; }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(k < K){ continue; }\n\t\t\t\telse{\n\t\t\t\t\tV += (unsigned long long) (X[x+1] - X[x]) * (Y[y+1] - Y[y]) * (Z[z+1] - Z[z]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << V << endl;\n\t\n\tdelete[] X;\n\tdelete[] Y;\n\tdelete[] Z;\n\tdelete[] fish;\n\n\treturn 0;\n}\n\nint comp(const void *c1, const void *c2){\n\tint tmp1 = *(int*)c1;\n\tint tmp2 = *(int*)c2;\n\n\treturn tmp1 - tmp2;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Fish\n//Level: 3\n//Category: 座標圧縮\n//Note:\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Rect {\n    int x1, y1, z1, x2, y2, z2;\n\n    bool operator <(const Rect &other) const {\n        return z1 < other.z1;\n    }\n};\n\nenum EventType {\n    EVENT_CLOSE,\n    EVENT_OPEN,\n};\n\nstruct Event {\n    int x1, y1, x2, y2;\n    int z;\n    EventType event;\n\n    Event(int x1, int y1, int x2, int y2, int z, EventType ev) : x1(x1), y1(y1), x2(x2), y2(y2), z(z), event(ev) {}\n\n    bool operator <(const Event &other) const {\n        if(z != other.z) return z < other.z;\n        return event < other.event;\n    }\n};\n\nvector<Rect> rects;\nvector<int> event_x, event_y;\nvector<Event> event_z;\nint K;\n\nvoid sort_and_uniq(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n}\n\ninline bool in_range(int a, int x, int b) {\n    return a <= x && x < b;\n}\n\nlong long sweep_z(const int x, const int y) {\n    const int N = event_z.size();\n    long long ans = 0;\n    int cnt = 0;\n    int prev_z = 0;\n    for(int i = 0; i < N; ) {\n        const int z = event_z[i].z;\n        if(cnt >= K) {\n            ans += z - prev_z;\n        }\n        while(i < N && z == event_z[i].z) {\n            const Event &ev = event_z[i];\n            if(in_range(ev.x1, x, ev.x2) && in_range(ev.y1, y, ev.y2)) {\n                if(ev.event == EVENT_CLOSE) --cnt;\n                else ++cnt;\n            }\n            ++i;\n        }\n        prev_z = z;\n    }\n    return ans;\n}\n\nlong long sweep_y(const int x) {\n    const int N = event_y.size();\n    long long ans = 0;\n    for(int i = 0; i < N-1; ++i) {\n        const int y = event_y[i];\n        long long length = sweep_z(x, y);\n        ans += length * (event_y[i+1] - y);\n    }\n    return ans;\n}\n\nlong long sweep() {\n    const int N = event_x.size();\n    long long ans = 0;\n    for(int i = 0; i < N-1; ++i) {\n        const int x = event_x[i];\n        long long area = sweep_y(x);\n        ans += area * (event_x[i+1] - x);\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int N;\n    cin >> N >> K;\n    rects.resize(N);\n    for(int i = 0; i < N; ++i) {\n        Rect &r = rects[i];\n        cin >> r.x1 >> r.y1 >> r.z1 >> r.x2 >> r.y2 >> r.z2;\n        event_x.push_back(r.x1);\n        event_x.push_back(r.x2);\n        event_y.push_back(r.y1);\n        event_y.push_back(r.y2);\n        event_z.push_back(Event(r.x1, r.y1, r.x2, r.y2, r.z1, EVENT_OPEN));\n        event_z.push_back(Event(r.x1, r.y1, r.x2, r.y2, r.z2, EVENT_CLOSE));\n    }\n    sort_and_uniq(event_x);\n    sort_and_uniq(event_y);\n    sort(event_z.begin(), event_z.end());\n\n    cout << sweep() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  int n,K;\n  cin>>n>>K;\n  vector<vector<tuple<int,int,int>>> p(n);\n  vector<int> sx,sy,sz;\n  REP(i,n){\n    REP(j,2){\n      int x,y,z;\n      cin>>x>>y>>z;\n      p[i].emplace_back(x,y,z);\n      sx.push_back(x);\n      sy.push_back(y);\n      sz.push_back(z);\n    }\n  }\n  sort(begin(sx),end(sx));\n  sort(begin(sy),end(sy));\n  sort(begin(sz),end(sz));\n  sx.erase(unique(begin(sx),end(sx)),end(sx));\n  sy.erase(unique(begin(sy),end(sy)),end(sy));\n  sz.erase(unique(begin(sz),end(sz)),end(sz));\n  int h=sx.size(),w=sy.size(),d=sz.size();\n  int bx[h][w][d];\n  REP(i,h)REP(j,w)REP(k,d)bx[i][j][k] = 0;\n  REP(i,n){\n    vector<tuple<int,int,int>> p2;\n    REP(j,2){\n      int x,y,z;\n      tie(x,y,z)=p[i][j];\n      int xc=lower_bound(begin(sx),end(sx),x)-begin(sx);\n      int yc=lower_bound(begin(sy),end(sy),y)-begin(sy);\n      int zc=lower_bound(begin(sz),end(sz),z)-begin(sz);\n      p2.emplace_back(xc,yc,zc);\n    }\n    REP(j,2)REP(k,2)REP(l,2){\n      int x,y,z;\n      x=get<0>(p2[j]);\n      y=get<1>(p2[k]);\n      z=get<2>(p2[l]);\n      int sg=1;\n      if((j+k+l)%2)sg*=-1;\n      bx[x][y][z] += sg;\n    }\n  }\n  REP(i,h)REP(j,w)REP(k,d-1) bx[i][j][k+1] += bx[i][j][k];\n  REP(i,h)REP(j,w-1)REP(k,d) bx[i][j+1][k] += bx[i][j][k];\n  REP(i,h-1)REP(j,w)REP(k,d) bx[i+1][j][k] += bx[i][j][k];\n  int64_t cnt = 0;\n  REP(i,h)REP(j,w)REP(k,d) {\n    if(bx[i][j][k] >= K) {\n      int64_t v = 1;\n      v *= sx[i+1]-sx[i];\n      v *= sy[j+1]-sy[j];\n      v *= sz[k+1]-sz[k];\n      cnt += v;\n    }\n  }\n  cout << cnt << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <assert.h>\n#include <string.h>\n\nusing namespace std;\n\nnamespace\n{\n\tint n, k;\n\tint x1[50], yy[50], d1[50], x2[50], y2[50], d2[50];\n\tint cx1[50], cy1[50], cd1[50], cx2[50], cy2[50], cd2[50];\n\n\tint compd[123][123][123];\n}\n\n//w1,w2???????????????????????§???????????§???????????????\nvector<int> compress(int *w1, int *w2)\n{\n\tvector<int>ws;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tws.push_back(w1[i]);\n\t\tws.push_back(w2[i]);\n\t}\n\tsort(ws.begin(), ws.end());\n\tws.erase(unique(ws.begin(), ws.end()), ws.end());\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tw1[i] = find(ws.begin(), ws.end(), w1[i]) - ws.begin();\n\t\tw2[i] = find(ws.begin(), ws.end(), w2[i]) - ws.begin();\n\t}\n\treturn ws;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &k);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d %d %d %d %d %d\", x1 + i, yy + i, d1 + i, x2 + i, y2 + i, d2 + i);\n\t}\n\t\n\tauto xsv = compress(x1, x2);\n\tauto ysv = compress(yy, y2);\n\tauto dsv = compress(d1, d2);\n\tint xs = xsv.size();\n\tint ys = ysv.size();\n\tint ds = dsv.size();\n\n\tmemset(compd, 0, sizeof(compd));\n\n\t//??????????¨????\n\tfor (int i = 0;i < n;++i)\n\t{\n\t\tconst int hash[8][3] = { {0,0,0},{0,0,1},{0,1,0},{0,1,1},{1,0,0},{1,0,1},{1,1,0},{1,1,1}, };\n\t\tfor (int p = 0; p < 8; ++p)\n\t\t{\n\t\t\tcompd\n\t\t\t\t[hash[p][0] ? x1[i] : x2[i]]\n\t\t\t\t[hash[p][1] ? yy[i] : y2[i]]\n\t\t\t\t[hash[p][2] ? d1[i] : d2[i]] =\n\t\t\t\t\t(hash[p][0]^hash[p][1]^hash[p][2]) ? 1 : -1;\n\t\t}\n\t}\n\t\n\t//?´????????????¨???\n\tfor (int x = 0; x < xs; ++x)\n\t{\n\t\tfor (int y = 0; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 1; d < ds; ++d)\n\t\t\t{\n\t\t\t\tcompd[x][y][d] += compd[x][y][d - 1];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 0; x < xs; ++x)\n\t{\n\t\tfor (int y = 1; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < ds; ++d)\n\t\t\t{\n\t\t\t\tcompd[x][y][d] += compd[x][y - 1][d];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 1; x < xs; ++x)\n\t{\n\t\tfor (int y = 0; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < ds; ++d)\n\t\t\t{\n\t\t\t\tcompd[x][y][d] += compd[x - 1][y][d];\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor (int x = 0; x < xs; ++x)\n\t{\n\t\tfor (int y = 0; y < ys; ++y)\n\t\t{\n\t\t\tfor (int d = 0; d < ds; ++d)\n\t\t\t{\n\t\t\t\tassert(compd[x][y][d] >= 0);\n\t\t\t\tif (compd[x][y][d] >= k)\n\t\t\t\t{\n\t\t\t\t\tlong long tmp = (long long)(xsv[x + 1] - xsv[x]) * (long long)(ysv[y + 1] - ysv[y]) * (long long)(dsv[d + 1] - dsv[d]);\n\t\t\t\t\tans += tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\ntypedef long long ll;\nint n,m;\nint x[N],y[N],z[N];\nint X[N],Y[N],Z[N];\nint s[N],t[N],u[N];\nint S[N],T[N],U[N];\nint xd[201],yd[201],zd[201];\n\n\nvoid compress(int a[51],int A[51],int b[51],int B[51],int c[201]){\n  vector <int> v;\n  for(int i=0;i<n;i++)v.push_back(a[i]),v.push_back(A[i]);\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  for(int i=0;i<v.size();i++) c[i]=v[i];\n  for(int i=0;i<n;i++){\n    b[i]=lower_bound(v.begin(),v.end(),a[i])-v.begin();\n    B[i]=lower_bound(v.begin(),v.end(),A[i])-v.begin();\n  }\n}\n\nll calc(){\n  ll res=0;\n  for(int i=0;i<101;i++) //x\n    for(int j=0;j<101;j++)//y\n      for(int k=0;k<101;k++){//z\n\tint cnt=0;\n\tfor(int l=0;l<n;l++)cnt+=((s[l]<=i&&i<S[l])&&(t[l]<=j&&j<T[l])&&(u[l]<=k&&k<U[l]));\n\tif(cnt<m)continue;\n\tll a=xd[i+1]-xd[i],b=yd[j+1]-yd[j],c=zd[k+1]-zd[k];\n\tres+=a*b*c;\n      }\n  return res;\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>z[i]>>X[i]>>Y[i]>>Z[i];\n  compress(x,X,s,S,xd),compress(y,Y,t,T,yd),compress(z,Z,u,U,zd);\n  cout << calc()<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nvector<long long> sp[3];\nint N, K;\nint input[50][6];\n\nint cnt[100][100][100];\n\nint main()\n{\n  cin >> N >> K;\n  for(int i = 0; i < N; i++)\n  {\n    int x1, y1, z1, x2, y2, z2;\n    cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n    sp[0].push_back(x1);\n    sp[0].push_back(x2);\n    sp[1].push_back(y1);\n    sp[1].push_back(y2);\n    sp[2].push_back(z1);\n    sp[2].push_back(z2);\n    input[i][0] = x1;\n    input[i][1] = y1;\n    input[i][2] = z1;\n    input[i][3] = x2;\n    input[i][4] = y2;\n    input[i][5] = z2;\n  }\n  for(int i = 0; i < 3; i++)\n  {\n    sort(sp[i].begin(), sp[i].end());\n    unique(sp[i].begin(), sp[i].end());\n  }\n  for(int i = 0; i < N; i++)\n  {\n    auto x1 = distance(sp[0].begin(), lower_bound(sp[0].begin(), sp[0].end(), input[i][0]));\n    auto y1 = distance(sp[1].begin(), lower_bound(sp[1].begin(), sp[1].end(), input[i][1]));\n    auto z1 = distance(sp[2].begin(), lower_bound(sp[2].begin(), sp[2].end(), input[i][2]));\n    auto x2 = distance(sp[0].begin(), lower_bound(sp[0].begin(), sp[0].end(), input[i][3]));\n    auto y2 = distance(sp[1].begin(), lower_bound(sp[1].begin(), sp[1].end(), input[i][4]));\n    auto z2 = distance(sp[2].begin(), lower_bound(sp[2].begin(), sp[2].end(), input[i][5]));\n    for(int x = x1; x < x2; x++)\n      for(int y = y1; y < y2; y++)\n        for(int z = z1; z < z2; z++)\n          cnt[x][y][z]++;\n  }\n  long long area = 0;\n  for(int x = 0; x < 100; x++)\n    for(int y = 0; y < 100; y++)\n      for(int z = 0; z < 100; z++)\n        if(cnt[x][y][z] >= K)\n          area += (sp[0][x + 1] - sp[0][x]) * (sp[1][y + 1] - sp[1][y]) * (sp[2][z + 1] - sp[2][z]);\n  cout << area << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n#define MAX_N 50\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint W,H,D,N,K;\nint X1[MAX_N],X2[MAX_N],Y1[MAX_N],Y2[MAX_N],D1[MAX_N],D2[MAX_N];\nvector<int> xl,yl,dl;\n\nint fld[MAX_N * 2][MAX_N*2][MAX_N*2];\n\nint compress(int *x1,int *x2, int w,vector<int> *xs){\n\t\n\trep(i,N){\n\t\t\tint tx1=x1[i], tx2=x2[i];\n\t\t\txs->push_back(tx1);\n\t\t\txs->push_back(tx2);\n\t}\n\tsort(xs->begin(),xs->end());\n\txs->erase(unique(xs->begin(),xs->end()),xs->end());\n\t\n\trep(i,N){\n\t\tx1[i] = find(xs->begin(),xs->end(),x1[i] )- xs->begin();\n\t\tx2[i] = find(xs->begin(),xs->end(),x2[i] )- xs->begin();\n\t}\n\treturn xs->size();\n\t\n}\n\nvoid solve(){\n\tW=compress(X1,X2,W,&xl);\n\tH=compress(Y1,Y2,H,&yl);\n\tD=compress(D1,D2,D,&dl);\n\n\tmemset(fld, 0, sizeof(fld));\n\trep(i,N){\n\t\tfor(int d=D1[i]; d<D2[i]; d++){\n\t\t\tfor(int y = Y1[i]; y<Y2[i];y++){\n\t\t\t\tfor(int x = X1[i]; x<X2[i];x++){\n\t\t\t\t\tfld[d][y][x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long int ans=0;\n\trep(d,D-1){\n\t\trep(y,H-1){\n\t\t\trep(x,W-1){\n\t\t\t\tif(fld[d][y][x]<K)continue;\n\t\t\t\tans+=(long long int)(xl[x+1]-xl[x])*(long long int)(yl[y+1]-yl[y])*(long long int)(dl[d+1]-dl[d]);\n\t\t\t\tans=ans;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tscanf(\"%d %d\",&N,&K);\n\tW=H=D=1000000;\n\trep(i,N){\n\t\t//int x1,x2,y1,y2,d1,d2;\n\t\tscanf(\"%d %d %d %d %d %d\",&X1[i],&Y1[i],&D1[i],&X2[i],&Y2[i],&D2[i]);\n\t}\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <cstdint>\n\nconstexpr uint32_t N_MAX = 50;\nuint32_t N,X,Y,Z;\nint32_t K;\nuint32_t p1x[N_MAX];\nuint32_t p2x[N_MAX];\nuint32_t p1y[N_MAX];\nuint32_t p2y[N_MAX];\nuint32_t p1z[N_MAX];\nuint32_t p2z[N_MAX];\nint8_t graph[N_MAX*2][N_MAX*2][N_MAX*2];//z,y,x\nuint32_t width_x[N_MAX*2];\nuint32_t width_y[N_MAX*2];\nuint32_t width_z[N_MAX*2];\n\nuint32_t com(uint32_t a1[],uint32_t a2[], uint32_t length,uint32_t width_out[])\n{\n\tstatic uint32_t tmp_arr[N_MAX*2];\n\tauto iter = tmp_arr;\n\tfor(uint32_t i = 0;i < length;++i){\n\t\t*iter++ = a1[i];\n\t\t*iter++ = a2[i];\n\t}\n\tstd::sort(tmp_arr, iter);\n\titer = std::unique(tmp_arr, iter);\n\tfor(uint32_t i = 0;i < length;++i){\n\t\ta1[i] = std::lower_bound(tmp_arr, iter, a1[i]) - tmp_arr;\n\t}\n\tfor(uint32_t i = 0;i < length;++i){\n\t\ta2[i] = std::lower_bound(tmp_arr, iter, a2[i]) - tmp_arr;\n\t}\n\tlength = iter - tmp_arr;\n\tfor(uint32_t i = 0;i < length-1;++i){\n\t\twidth_out[i] = tmp_arr[i+1] - tmp_arr[i];\n\t}\n\treturn length;\n}\n\nint main()\n{\n\tstd::cin >> N>>K;\n\tfor(uint32_t i = 0;i < N;++i){\n\t\tstd::cin >> p1x[i]>>p1y[i]>>p1z[i]>>p2x[i]>>p2y[i]>>p2z[i];\n\t}\n\tX = com(p1x,p2x,N, width_x);\n\t#if 0\n\tstd::cout <<\"------------------------\\n\";\n\tfor(uint32_t x = 0;x < N;++x){\n\t\tstd::cout<<'(' << (int)(p1x[x]) <<','<<(int)(p2x[x])<< ')';\n\t}\n\t#endif\n\tY = com(p1y,p2y,N, width_y);\n\tZ = com(p1z,p2z,N, width_z);\n\t\n\t//いもす\n\tfor(uint32_t i = 0;i < N;++i){\n\t\t++graph[p1z[i]][p1y[i]][p1x[i]];\n\t\t--graph[p1z[i]][p1y[i]][p2x[i]];\n\t\t--graph[p1z[i]][p2y[i]][p1x[i]];\n\t\t++graph[p1z[i]][p2y[i]][p2x[i]];\n\t\t--graph[p2z[i]][p1y[i]][p1x[i]];\n\t\t++graph[p2z[i]][p1y[i]][p2x[i]];\n\t\t++graph[p2z[i]][p2y[i]][p1x[i]];\n\t\t--graph[p2z[i]][p2y[i]][p2x[i]];\n\t}\n\t#if 0\n\tstd::cout<<\"(\"<<X<<','<<Y<<','<<Z<<')' <<\"------------------------\\n\";\n\tfor(uint32_t z = 0;z < Z;++z){\n\tfor(uint32_t y = 0;y < Y;++y){for(uint32_t x = 0;x < X;++x){\n\t\tstd::cout << (int)graph[z][y][x] << ' ';\n\t}std::cout <<'\\n';}std::cout <<\"------------------------\\n\";}\n\t#endif\n\tfor(uint32_t z = 0;z < Z;++z)\n\tfor(uint32_t y = 0;y < Y;++y)for(uint32_t x = 1;x < X;++x){\n\t\tgraph[z][y][x] += graph[z][y][x-1];\n\t}\n\tfor(uint32_t z = 0;z < Z;++z)\n\tfor(uint32_t y = 1;y < Y;++y)for(uint32_t x = 0;x < X;++x){\n\t\tgraph[z][y][x] += graph[z][y-1][x];\n\t}\n\t#if 0\n\tstd::cout<<\"(\"<<X<<','<<Y<<','<<Z<<')' <<\"------------------------\\n\";\n\tfor(uint32_t z = 0;z < Z;++z){\n\tfor(uint32_t y = 0;y < Y;++y){for(uint32_t x = 0;x < X;++x){\n\t\tstd::cout << (int)graph[z][y][x] << ' ';\n\t}std::cout <<'\\n';}std::cout <<\"------------------------\\n\";}\n\t#endif\n\tfor(uint32_t z = 1;z < Z;++z)\n\tfor(uint32_t y = 0;y < Y;++y)for(uint32_t x = 0;x < X;++x){\n\t\tgraph[z][y][x] += graph[z-1][y][x];\n\t}\n\t#if 0\n\tstd::cout<<\"(\"<<X<<','<<Y<<','<<Z<<')' <<\"------------------------\\n\";\n\tfor(uint32_t z = 0;z < Z;++z){\n\tfor(uint32_t y = 0;y < Y;++y){for(uint32_t x = 0;x < X;++x){\n\t\tstd::cout << (int)graph[z][y][x] << ' ';\n\t}std::cout <<'\\n';}std::cout <<\"------------------------\\n\";}\n\t#endif\n\t//K以上をカウント\n\tuint64_t count = 0;\n\tfor(uint32_t z = 0;z < Z;++z)\n\tfor(uint32_t y = 0;y < Y;++y)for(uint32_t x = 0;x < X;++x){\n\t\tif(K <= graph[z][y][x]){\n\t\t\tcount += (uint64_t)(width_x[x])*(uint64_t)(width_y[y])\n\t\t\t\t*(uint64_t)(width_z[z]);\n\t\t}\n\t}\n\tstd::cout << count << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n\tint n,K; scanf(\"%d%d\",&n,&K);\n\tint x1[50],y1[50],z1[50],x2[50],y2[50],z2[50];\n\trep(i,n) scanf(\"%d%d%d%d%d%d\",x1+i,y1+i,z1+i,x2+i,y2+i,z2+i);\n\n\tvector<int> X,Y,Z;\n\trep(i,n){\n\t\tX.push_back(x1[i]); X.push_back(x2[i]);\n\t\tY.push_back(y1[i]); Y.push_back(y2[i]);\n\t\tZ.push_back(z1[i]); Z.push_back(z2[i]);\n\t}\n\tsort(X.begin(),X.end()); X.erase(unique(X.begin(),X.end()),X.end());\n\tsort(Y.begin(),Y.end()); Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\tsort(Z.begin(),Z.end()); Z.erase(unique(Z.begin(),Z.end()),Z.end());\n\n\tll ans=0;\n\trep(i,(int)X.size()-1) rep(j,(int)Y.size()-1) rep(k,(int)Z.size()-1) {\n\t\tint cnt=0;\n\t\trep(l,n){\n\t\t\tif(x1[l]<=X[i] && X[i+1]<=x2[l]\n\t\t\t&& y1[l]<=Y[j] && Y[j+1]<=y2[l]\n\t\t\t&& z1[l]<=Z[k] && Z[k+1]<=z2[l]) cnt++;\n\t\t}\n\t\tif(cnt>=K) ans+=(ll)(X[i+1]-X[i])*(Y[j+1]-Y[j])*(Z[k+1]-Z[k]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tcin.tie(0);\n    ios::sync_with_stdio(false);\n\n\tint N, K;\n\tcin >> N >> K;\n\n\tint* X1 = new int[N];\n\tint* Y1 = new int[N];\n\tint* D1 = new int[N];\n\tint* X2 = new int[N];\n\tint* Y2 = new int[N];\n\tint* D2 = new int[N];\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t}\n\t\n\t//ソート用vector\n\tvector<int> X(2*N);\n\tvector<int> Y(2*N);\n\tvector<int> D(2*N);\n\tfor (int i = 0; i < N; i++){\n\t\tX[2 * i]     = X1[i];\n\t\tX[2 * i + 1] = X2[i];\n\t\tY[2 * i]     = Y1[i];\n\t\tY[2 * i + 1] = Y2[i];\n\t\tD[2 * i]     = D1[i];\n\t\tD[2 * i + 1] = D2[i];\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\tlong long int ans = 0;\n\tint kasanari;\n\tfor (int i = 0; i < 2*N-1; i++){ //X\n\t\tfor (int j = 0; j < 2*N-1; j++){ //Y\n\t\t\tfor (int k = 0; k < 2*N-1; k++){ //D\n\t\t\t\tkasanari = 0;\n\t\t\t\tfor (int l = 0; l < N; l++){ //実際の直方体\n\t\t\t\t\tif ((X1[l]<=X[i] && X[i+1] <= X2[l]) &&\n\t\t\t\t\t\t(Y1[l]<=Y[j] && Y[j+1] <= Y2[l]) &&\n\t\t\t\t\t\t(D1[l]<=D[k] && D[k+1] <= D2[l]))\n\t\t\t\t\t\tkasanari++;\n\t\t\t\t}\n\t\t\t\tif (kasanari >= K){\n\t\t\t\t\tans += (long long int)(X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) * (D[k + 1] - D[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n\n\tdelete[] X1;\n\tdelete[] Y1;\n\tdelete[] D1;\n\tdelete[] X2;\n\tdelete[] Y2;\n\tdelete[] D2;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n\nlong long X[ 100 ][ 2 ] ,x[ 100 ] ;\nlong long Y[ 100 ][ 2 ] ,y[ 100 ] ;\nlong long Z[ 100 ][ 2 ] ,z[ 100 ] ;\n\nint i ,j ,k ,l ;\n\ninline void sort( long long *a ,int size )\n{\n\tqsort( a ,size ,sizeof( long long ) ,[]( const void *a ,const void *b ){ return *( int* )a - *( int* )b ; } ) ;\n}\n\nint check()\n{\n\tif(\n\t\t\tX[ l ][ 0 ] > x[ i ] || X[ l ][ 1 ] < x[ i + 1 ] ||\n\t\t\tY[ l ][ 0 ] > y[ j ] || Y[ l ][ 1 ] < y[ j + 1 ] ||\n\t\t\tZ[ l ][ 0 ] > z[ k ] || Z[ l ][ 1 ] < z[ k + 1 ]\n\t)\n\t{\n\t\treturn 1 ;\n\t}\n\n\treturn 0 ;\n}\n\nint main( void )\n{\n\tint N ,K ;\n\tscanf( \"%d %d\" ,&N ,&K ) ;\n\n\tN *= 2 ;\n\n\t--K ;\n\n\tint n = N - 1 ;\n\n\tfor( i = 0 ; i < N ; ++i )\n\t{\n\t\tscanf( \"%lld %lld %lld\" ,x + i ,y + i ,z + i ) ;\n\n\t\tX[ i / 2 ][ i % 2 ] = x[ i ] ;\n\t\tY[ i / 2 ][ i % 2 ] = y[ i ] ;\n\t\tZ[ i / 2 ][ i % 2 ] = z[ i ] ;\n\t}\n\n\tsort( x ,N ) ;\n\tsort( y ,N ) ;\n\tsort( z ,N ) ;\n\n\tlong long ans = 0 ;\n\tfor( i = 0 ; i < n ; ++i )\n\t{\n\t\tfor( j = 0 ; j < n ; ++j )\n\t\t{\n\t\t\tfor( k = 0 ; k < n ; ++k )\n\t\t\t{\n\t\t\t\tint cnt = 0 ;\n\n\t\t\t\tfor( l = 0 ; l < N ; ++l )\n\t\t\t\t{\n\t\t\t\t\tif( check() == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\t++cnt ;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( cnt > K )\n\t\t\t\t{\n\t\t\t\t\tans += ( x[ i + 1 ] - x[ i ] ) * ( y[ j + 1 ] - y[ j ] ) * ( z[ k + 1 ] - z[ k ] ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprintf( \"%lld\\n\" ,ans ) ;\n\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#include <iomanip>\n#include <sstream>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define sym cout<<\"-----------\"<<endl;\n#define ll long long\n#define P pair<int,int>\n#define mk make_pair\n#define en endl\n#define RE return 0\n#define int ll\n\n// 魚の生息範囲\n\n\nint x[100];\nint y[100];\nint z[100];\nint x1[50];\nint x2[50];\nint y_1[50];\nint y2[50];\nint z1[50];\nint z2[50];\nint table[100][100][100];\nsigned main(){\n  int a,b;\n  cin>>a>>b;\n  for(int i=0;i<a;i++){\n    cin>>x1[i]>>y_1[i]>>z1[i]>>x2[i]>>y2[i]>>z2[i];\n    x[i*2]=x1[i];x[i*2+1]=x2[i];\n    y[i*2]=y_1[i];y[i*2+1]=y2[i];\n    z[i*2]=z1[i];z[i*2+1]=z2[i];\n  }\n  sort(x,x+a*2);\n  sort(y,y+a*2);\n  sort(z,z+a*2);\n  for(int i=0;i<a;i++){\n    int X1=lower_bound(x,x+a*2,x1[i])-x;\n    int Y1=lower_bound(y,y+a*2,y_1[i])-y;\n    int Z1=lower_bound(z,z+a*2,z1[i])-z;\n    int X2=lower_bound(x,x+a*2,x2[i])-x;\n    int Y2=lower_bound(y,y+a*2,y2[i])-y;\n    int Z2=lower_bound(z,z+a*2,z2[i])-z;\n    \n    for(int i=X1; i<X2; i++){\n      for(int j=Y1; j<Y2; j++)\n        for(int k=Z1; k<Z2; k++){\n          table[i][j][k]++;\n        }\n    }\n  }\n  \n  int ret=0;\n  for(int i=0; i<a*2; i++){\n    for(int j=0; j<a*2; j++){\n      for(int k=0; k<a*2; k++){\n        if(table[i][j][k]>=b) ret+=(x[i+1]-x[i])*(y[j+1]-y[j])*(z[k+1]-z[k]);\n      }\n    }\n  }\n  \n  \n  cout<<ret<<en;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\n\nint N,K;\nint W,H,D;\nint X1[55],Y1[55],Z1[55],X2[55],Y2[55],Z2[55];\nint cx1[55],cy1[55],cz1[55],cx2[55],cy2[55],cz2[55];\nvector<int> X,Y,Z;\nchar fld[55*6][55*6][55*6];\n\nint ans;\nvector<int> xs;\n\nvoid compress(vector<int> &X,int* x1,int* x2,int* vx1,int* vx2,int w,int* P){\n    xs.clear();\n    for(int i=0;i<N;++i){\n        x1[i]=vx1[i];\n        x2[i]=vx2[i];\n    }\n    for(int i=0;i<N;++i){\n        for(int d=-1;d<=1;++d){\n            int tx1=x1[i]+d;\n            int tx2=x2[i]+d;\n            if(0<=tx1&&tx1<=w)xs.PB(tx1);\n            if(0<=tx2&&tx2<=w)xs.PB(tx2);\n        }\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    //for(int i=0;i<xs.size();++i)cout<<xs[i]<<endl;\n    for(int i=0;i<xs.size();++i){\n        X.PB(xs[i+1]-xs[i]);\n    }\n    *P = xs.size();\n}\n\nint main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    compress(X,cx1,cx2,X1,X2,1000000,&W);\n    compress(Y,cy1,cy2,Y1,Y2,1000000,&H);\n    compress(Z,cz1,cz2,Z1,Z2,1000000,&D);\n    for(int i=0;i<N;++i){\n        for(int z=cz1[i];z<cz2[i];++z){\n            for(int y=cy1[i];y<cy2[i];++y){\n                for(int x=cx1[i];x<cx2[i];++x){\n                    fld[z][y][x]++;\n                }\n            }\n        }\n    }\n    for(int z=0;z<=D;++z){\n        for(int y=0;y<=H;++y){\n            for(int x=0;x<=W;++x){\n                if(fld[z][y][x]>=K)ans+=X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n\n    //cout<<W<<\" \"<<H<<\" \"<<D<<endl;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<int> vint;\n\nint imos[100][100][100];\n\nvint compress2(vint v1, const vint &v2){\n\tv1.insert(v1.end(), v2.begin(), v2.end());\n\tsort(v1.begin(), v1.end());\n\tv1.erase(unique(v1.begin(), v1.end()), v1.end());\n\treturn v1;\n}\n\nint index(const vint &v, int x){\n\treturn lower_bound(v.begin(), v.end(), x) - v.begin();\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvint x1(n), x2(n), y1(n), y2(n), z1(n), z2(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> x1[i] >> y1[i] >> z1[i] >> x2[i] >> y2[i] >> z2[i];\n\t}\n\n\tvint xs = compress2(x1, x2);\n\tvint ys = compress2(y1, y2);\n\tvint zs = compress2(z1, z2);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint xi1, yi1, zi1, xi2, yi2, zi2;\n\t\txi1 = index(xs, x1[i]);\n\t\tyi1 = index(ys, y1[i]);\n\t\tzi1 = index(zs, z1[i]);\n\t\txi2 = index(xs, x2[i]);\n\t\tyi2 = index(ys, y2[i]);\n\t\tzi2 = index(zs, z2[i]);\n\n\t\t++imos[xi1][yi1][zi1];\n\t\t--imos[xi1][yi2][zi1];\n\t\t--imos[xi2][yi1][zi1];\n\t\t++imos[xi2][yi2][zi1];\n\t\t--imos[xi1][yi1][zi2];\n\t\t++imos[xi1][yi2][zi2];\n\t\t++imos[xi2][yi1][zi2];\n\t\t--imos[xi2][yi2][zi2];\n\t}\n\n\tfor(int i = 1; i < xs.size(); ++i)\n\tfor(int j = 0; j < ys.size(); ++j)\n\tfor(int k = 0; k < zs.size(); ++k){\n\t\timos[i][j][k] += imos[i-1][j][k];\n\t}\n\n\tfor(int i = 0; i < xs.size(); ++i)\n\tfor(int j = 1; j < ys.size(); ++j)\n\tfor(int k = 0; k < zs.size(); ++k){\n\t\timos[i][j][k] += imos[i][j-1][k];\n\t}\n\n\tfor(int i = 0; i < xs.size(); ++i)\n\tfor(int j = 0; j < ys.size(); ++j)\n\tfor(int k = 1; k < zs.size(); ++k){\n\t\timos[i][j][k] += imos[i][j][k-1];\n\t}\n\n\tlong long ans = 0;\n\tfor(int i = 0; i < xs.size(); ++i)\n\tfor(int j = 0; j < ys.size(); ++j)\n\tfor(int k = 0; k < zs.size(); ++k){\n\t\tif(imos[i][j][k] >= m){\n\t\t\tans += (long long)(xs[i+1] - xs[i]) * (ys[j+1] - ys[j]) * (zs[k+1] - zs[k]);\n\t\t}\n\t}\n\t\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll h, w, d, n, k;\nvector<ll>x, y, z;\nstruct A {\n\tll x1, y1, d1, x2, y2, d2;\n};\nstruct P {\n\tll i, j;\n};\nvector<A>v;\nint a[200][200][200];\nint main() {\n\twhile (cin >> n >> k) {\n\t\tx.clear();\n\t\ty.clear();\n\t\tz.clear();\n\t\tv.clear();\n\t\tx.push_back(0);\n\t\ty.push_back(0);\n\t\tz.push_back(0);\n\t\tx.push_back(1000000);\n\t\ty.push_back(1000000);\n\t\tz.push_back(1000000);\n\t\tfor (ll i = 0; i < n; i++) {\n\t\t\tll x1, y1, d1, x2, y2, d2;\n\t\t\tcin >> x1 >> y1 >> d1 >> x2 >> y2 >> d2;\n\t\t\tx.push_back(x1);\n\t\t\tx.push_back(x2);\n\t\t\ty.push_back(y1);\n\t\t\ty.push_back(y2);\n\t\t\tz.push_back(d1);\n\t\t\tz.push_back(d2);\n\t\t\tv.push_back(A{ x1,y1,d1,x2,y2,d2 });\n\t\t}\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tfor (int j = 0; j < y.size(); j++) {\n\t\t\t\tfor (int w = 0; w < z.size(); w++)\n\t\t\t\t\ta[i][j][w] = 0;\n\t\t\t}\n\t\t}\n\t\tsort(x.begin(), x.end());\n\t\tsort(y.begin(), y.end());\n\t\tsort(z.begin(), z.end());\n\t\tfor (ll l = 0; l < n; l++) {\n\t\t\tll o, p, q, r, s, u;\n\t\t\to = lower_bound(x.begin(), x.end(), v[l].x1) - x.begin();\n\t\t\tp = lower_bound(y.begin(), y.end(), v[l].y1) - y.begin();\n\t\t\tq = lower_bound(z.begin(), z.end(), v[l].d1) - z.begin();\n\t\t\tr = upper_bound(x.begin(), x.end(), v[l].x2) - x.begin() - 1;\n\t\t\ts = upper_bound(y.begin(), y.end(), v[l].y2) - y.begin() - 1;\n\t\t\tu = upper_bound(z.begin(), z.end(), v[l].d2) - z.begin() - 1;\n\t\t\tfor (int i = o; i < r; i++) {\n\t\t\t\tfor (int j = p; j < s; j++) {\n\t\t\t\t\tfor (int w = q; w < u; w++)\n\t\t\t\t\t\ta[i][j][w]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll sum = 0;\n\t\tfor (int i = 0; i < x.size() - 1; i++) {\n\t\t\tfor (int j = 0; j < y.size() - 1; j++) {\n\t\t\t\tfor (int w = 0; w < z.size() - 1; w++) {\n\t\t\t\t\tif (a[i][j][w] >= k) {\n\t\t\t\t\t\tsum += ((x[i + 1] - x[i])*(y[j + 1] - y[j])*(z[w + 1] - z[w]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nll n,k;\nll xs[50],ys[50],ds[50],xe[50],ye[50],de[50];\nll X1[50],Y1[50],D1[50],X2[50],Y2[50],D2[50];\nbool ok[100][100][100];\nvector<ll> X,Y,D;\n/*\nbool judge(ll x,ll y,ll d){\n\tll cnt=0;\n\tfor(ll i=0;i<2*n;i++){\n\t\tif(X1[i]<=x&&x<X2[i]&&Y1[i]<=y&&y<Y2[i]&&D1[i]<=d&&d<D2[i]) cnt++;\n\t}\n\tif(cnt>=k) ok[x][y][z]=0;\n}\n*/\nint main()\n{\n\tll ans=0;\n\tscanf(\"%lld%lld\",&n,&k);\n\tfor(ll i=0;i<n;i++){\n\t\tscanf(\"%lld%lld%lld%lld%lld%lld\",&xs[i],&ys[i],&ds[i],&xe[i],&ye[i],&de[i]);\n\t\tX.push_back(xs[i]);\n\t\tX.push_back(xe[i]);\n\t\tY.push_back(ys[i]);\n\t\tY.push_back(ye[i]);\n\t\tD.push_back(ds[i]);\n\t\tD.push_back(de[i]);\n\t}\n\tsort(X.begin(),X.end());\n\tsort(Y.begin(),Y.end());\n\tsort(D.begin(),D.end());\n\t//for(ll i=0;i<n;i++){\n\t\t/*X1[i]=lower_bound(X.begin(),X.end(),xs[i])-X.begin();\n\t\tX2[i]=lower_bound(X.begin(),X.end(),xe[i])-X.begin();\n\t\tY1[i]=lower_bound(Y.begin(),Y.end(),ys[i])-Y.begin();\n\t\tY2[i]=lower_bound(Y.begin(),Y.end(),ye[i])-Y.begin();\n\t\tD1[i]=lower_bound(D.begin(),D.end(),ds[i])-D.begin();\n\t\tD2[i]=lower_bound(D.begin(),D.end(),de[i])-D.//*/\n\tfor(ll i=0;i<2*n-1;i++){\n\t\tfor(ll j=0;j<2*n-1;j++){\n\t\t\tfor(ll d=0;d<2*n-1;d++){\n\t\t\t\tll cnt=0;\n\t\t\t\tfor(ll p=0;p<n;p++){\n\t\t\t\t\tif(xs[p]<=X[i]&&X[i]<xe[p]&&ys[p]<=Y[j]&&Y[j]<ye[p]&&ds[p]<=D[d]&&D[d]<de[p]) cnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt>=k) ans+=(X[i+1]-X[i])*(Y[j+1]-Y[j])*(D[d+1]-D[d]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\nint n, k;\nvector<int> xs, ys, zs;\nmap<int, int> zipx, zipy, zipz;//<???, ??§??????>\nmap<int, int> unzipx, unzipy, unzipz;//<??§??????, ???>\nlong long num[100][100][100];//???????¨?????????\\??????\n\nint main(void){\n\tcin >> n >> k;\n\tint x1[51], x2[51], y1[51], y2[51], z1[51], z2[51];//?????????????????§?¨?\n\trep(i, n){\n\t\tcin >> x1[i] >> y1[i] >> z1[i];\n\t\tcin >> x2[i] >> y2[i] >> z2[i];\n\t\txs.push_back(x1[i]); xs.push_back(x2[i]);\n\t\tys.push_back(y1[i]); ys.push_back(y2[i]);\n\t\tzs.push_back(z1[i]); zs.push_back(z2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(),xs.end()), xs.end());//???????¶????\n\tsort(ys.begin(), ys.end());\n\tys.erase(unique(ys.begin(), ys.end()), ys.end());\n\tsort(zs.begin(), zs.end());\n\tzs.erase(unique(zs.begin(), zs.end()), zs.end());\n\n\trep(i, xs.size()){\n\t\tzipx[i] = xs[i];\n\t\tunzipx[xs[i]] = i;\n\t\t// printf(\"unzip[%d] = %d\\n\", xs[i], i);\n\t\t// printf(\"zip[%d] = %d\\n\", i, xs[i]);\n\t}\n\trep(i, ys.size()){\n\t\tzipy[i] = ys[i];\n\t\tunzipy[ys[i]] = i;\n\t\t// printf(\"unzip[%d] = %d\\n\", ys[i], i);\n\t\t// printf(\"zip[%d] = %d\\n\", i, ys[i]);\n\t}\n\trep(i, zs.size()){\n\t\tzipz[i] = zs[i];\n\t\tunzipz[zs[i]] = i;\n\t\t// printf(\"unzip[%d] = %d\\n\", zs[i], i);\n\t\t// printf(\"zip[%d] = %d\\n\", i, zs[i]);\n\t}\n\n\tmemset(num, 0, sizeof(num));\n\tfor (int i = 0; i < n; ++i){\n\t\t// printf(\"%d %d %d %d %d %d\\n\", unzipx[x1[i]], unzipy[y1[i]], unzipz[z1[i]], unzipx[x2[i]], unzipy[y2[i]], unzipz[z2[i]]);\n\t\tfor (int x = unzipx[x1[i]]; x < unzipx[x2[i]]; ++x){\n\t\t\tfor (int y = unzipy[y1[i]]; y < unzipy[y2[i]]; ++y){\n\t\t\t\tfor (int z = unzipz[z1[i]]; z < unzipz[z2[i]]; ++z){\n\t\t\t\t\t// printf(\"%d %d %d \\n\", x, y, z);\n\t\t\t\t\tnum[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = 0;\n\trep(x, 100)rep(y, 100)rep(z, 100){\n\t\tif(num[x][y][z] >= k){\n\t\t\tans += (zipx[x + 1] - zipx[x]) * (zipy[y + 1] - zipy[y]) * (zipz[z + 1] - zipz[z]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint compress(vector<long long> &v){\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  return v.size();\n}\n\nint main(){\n  int n,K;\n  long long x1[50],y1[50],z1[50],x2[50],y2[50],z2[50];\n  vector<long long> vx,vy,vz;\n  scanf(\"%d %d\",&n,&K);\n  for(int i=0;i<n;i++){\n    scanf(\"%lld %lld %lld %lld %lld %lld\",x1+i,y1+i,z1+i,x2+i,y2+i,z2+i);\n    vx.push_back(x1[i]);\n    vy.push_back(y1[i]);\n    vz.push_back(z1[i]);\n    vx.push_back(x2[i]);\n    vy.push_back(y2[i]);\n    vz.push_back(z2[i]);\n  }\n  int size_x = compress(vx);\n  int size_y = compress(vy);\n  int size_z = compress(vz);\n  int area[99][99][99];\n  fill(area[0][0],area[0][0]+99*99*99,0);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<size_x-1;j++){\n      for(int k=0;k<size_y-1;k++){\n        for(int l=0;l<size_z-1;l++){\n          if(x1[i]<=vx[j]&&vx[j+1]<=x2[i]&&y1[i]<=vy[k]&&vy[k+1]<=y2[i]&&z1[i]<=vz[l]&&vz[l+1]<=z2[i]) area[j][k][l]++;\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for(int i=0;i<size_x-1;i++){\n    for(int j=0;j<size_y-1;j++){\n      for(int k=0;k<size_z-1;k++){\n        if(area[i][j][k]>=K) ans+=(vx[i+1]-vx[i])*(vy[j+1]-vy[j])*(vz[k+1]-vz[k]);\n      }\n    }\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<iomanip>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef std::pair<int, int> ipair;\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint N;\n\nvector<ll> compress(ll *x1, ll *x2) {\n   vector<ll> xs(0);\n\n   for (int i = 0; i < N; i++) {\n      xs.push_back(x1[i]);\n      xs.push_back(x2[i]);\n   }\n   \n   sort(xs.begin(), xs.end());\n   xs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n   return xs;\n}\n\nint main() {\n   int K;\n   cin >> N >> K;\n   ll X1[N], Y1[N], Z1[N], X2[N], Y2[N], Z2[N];\n\n   for (int i = 0; i < N; i++) {\n      cin >> X1[i] >> Y1[i] >> Z1[i] >> X2[i] >> Y2[i] >> Z2[i];\n   }\n\n   vector<ll> XS = compress(X1, X2);\n   vector<ll> YS = compress(Y1, Y2);\n   vector<ll> ZS = compress(Z1, Z2);\n   int XL = XS.size();\n   int YL = YS.size();\n   int ZL = ZS.size();\n\n   ll ans = 0;\n   for (int x = 0; x < XL - 1; x++) {\n      for (int y = 0; y < YL - 1; y++) {\n         for (int z = 0; z < ZL - 1; z++) {\n            int cnt = 0;\n            for (int i = 0; i < N; i++) {\n               if (X1[i] > XS[x]) continue;\n               if (X2[i] < XS[x + 1]) continue;\n               if (Y1[i] > YS[y]) continue;\n               if (Y2[i] < YS[y + 1]) continue;\n               if (Z1[i] > ZS[z]) continue;\n               if (Z2[i] < ZS[z + 1]) continue;\n               cnt++;\n            }\n            if (cnt >= K) {\n               ans += (XS[x + 1] - XS[x]) * (YS[y + 1] - YS[y]) * (ZS[z + 1] - ZS[z]);\n            }\n         }\n      }\n   }\n   cout << ans << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define Rep(i, N) for(int i = 0; i < N; i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define alluniq(x) (x).erase(unique((x).begin(), (x).end()), (x).end())\n\nsigned main()\n{\n  vector<int> x, y, d;\n  \n  int N, K;\n  int X1[55], Y1[55], D1[55], X2[55], Y2[55], D2[55];\n  int ans = 0;\n  \n  cin >> N >> K;\n  Rep(i, N) {\n    cin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n    x.pb(X1[i]); x.pb(X2[i]);\n    y.pb(Y1[i]); y.pb(Y2[i]);\n    d.pb(D1[i]); d.pb(D2[i]);\n  }\n\n  sort(all(x)); sort(all(y)); sort(all(d));\n  alluniq(x); alluniq(y); alluniq(d);\n\n  Rep(i, x.size() - 1) {\n    Rep(j, y.size() - 1) {\n      Rep(k, d.size() - 1) {\n\tint cnt = 0;\n\tRep(l, N) {\n\t  if(X1[l] <= x[i] && x[i + 1] <= X2[l] && Y1[l] <= y[j] && y[j + 1] <= Y2[l] && D1[l] <= d[k] && d[k + 1] <= D2[l]) cnt++;\n\t}\n\tif(cnt >= K) ans += (x[i + 1] - x[i]) * (y[j + 1] - y[j]) * (d[k + 1] - d[k]);\n      }\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nusing namespace std;\ntypedef long long ll;\n\nint N, K;\nint X1[50], Y1[50], D1[50], X2[50], Y2[50], D2[50];\nvector<int> x, y, d;\nmap<int, int> zipx, zipy, zipd;\nint unzipx[100], unzipy[100], unzipd[100];\nint grid[100][100][100];\n\nsigned main()\n{\n\tcin >> N >> K;\n\trep(i,N) {\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t\tx.push_back(X1[i]); x.push_back(X2[i]);\n\t\ty.push_back(Y1[i]); y.push_back(Y2[i]);\n\t\td.push_back(D1[i]); d.push_back(D2[i]);\n\t}\n\n\t//??§?¨???§???\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tsort(d.begin(), d.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\ty.erase(unique(y.begin(), y.end()), y.end());\n\td.erase(unique(d.begin(), d.end()), d.end());\n\trep(i,x.size()) {\n\t\tzipx[x[i]] = i;\n\t\tunzipx[i] = x[i];\n\t}\n\trep(i,y.size()) {\n\t\tzipy[y[i]] = i;\n\t\tunzipy[i] = y[i];\n\t}\n\trep(i,d.size()) {\n\t\tzipd[d[i]] = i;\n\t\tunzipd[i] = d[i];\n\t}\n\n\trep(i,N) {\n\t\tfor (int xx=zipx[X1[i]]; xx<zipx[X2[i]]; xx++) {\n\t\t\tfor (int yy=zipy[Y1[i]]; yy<zipy[Y2[i]]; yy++) {\n\t\t\t\tfor (int dd=zipd[D1[i]]; dd<zipd[D2[i]]; dd++) {\n\t\t\t\t\tgrid[xx][yy][dd]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\trep(i,x.size()-1) {\n\t\trep(j,y.size()-1) {\n\t\t\trep(k,d.size()-1) {\n\t\t\t\tif (grid[i][j][k] >= K) {\n\t\t\t\t\tans += (unzipx[i+1]-unzipx[i]) * (unzipy[j+1]-unzipy[j]) * (unzipd[k+1]-unzipd[k]);\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct square{\n    long long x1,y1,z1,x2,y2,z2;\n};\n\nvector<square> rippous;\nset<long long> xs, ys, zs;\nmap<long long, long long>transx, transy, transz;\nlong long field[200][200][200];\nlong long xx[200], yy[200], zz[200], K, n;\nlong long res;\nint main(){\n    cin >> n >> K;\n    for(long long i = 0;i < n;i++){\n\tsquare tmp;\n\tcin >> tmp.x1 >> tmp.y1 >> tmp.z1 >> tmp.x2 >> tmp.y2 >> tmp.z2;\n\trippous.push_back(tmp);\n\txs.insert(tmp.x1);xs.insert(tmp.x2);\n\tys.insert(tmp.y1);ys.insert(tmp.y2);\n\tzs.insert(tmp.z1);zs.insert(tmp.z2);\n    }\n    long long tttt;\n    set<long long>::iterator it = xs.begin();\n    long long ii = 0;\n    while(it != xs.end()){\n\txx[ii] = *it;\n\ttransx[*it] = ii;\n\tit++;\n\tii++;\n    }\n    ii = 0;\n    it = ys.begin();\n    while(it != ys.end()){\n\tyy[ii] = *it;\n\ttransy[*it] = ii;\n\tit++;\n\tii++;\n    }\n    ii = 0;\n    it = zs.begin();\n    while(it != zs.end()){\n\tzz[ii] = *it;\n\ttransz[*it] = ii;\n\tit++;\n\tii++;\n    }\n    for(long long i = 0;i < rippous.size();i++){\n\tsquare tmp = rippous[i];\n\ttmp.x1 = transx[tmp.x1];\n\ttmp.x2 = transx[tmp.x2];\n\ttmp.y1 = transy[tmp.y1];\n\ttmp.y2 = transy[tmp.y2];\n\ttmp.z1 = transz[tmp.z1];\n\ttmp.z2 = transz[tmp.z2];\n\tfield[tmp.x1][tmp.y1][tmp.z1] ++;\n\tfield[tmp.x2][tmp.y1][tmp.z1] --;\n\tfield[tmp.x1][tmp.y2][tmp.z1] --;\n\tfield[tmp.x2][tmp.y2][tmp.z1] ++;\n\tfield[tmp.x1][tmp.y1][tmp.z2] --;\n\tfield[tmp.x2][tmp.y1][tmp.z2] ++;\n\tfield[tmp.x1][tmp.y2][tmp.z2] ++;\n\tfield[tmp.x2][tmp.y2][tmp.z2] --;\n    }\n    for(long long i = 1;i < xs.size();i++){\n\tfor(long long j = 0;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tfield[i][j][k] += field[i - 1][j][k];\n\t    }\n\t}\n    }\n    for(long long i = 0;i < xs.size();i++){\n\tfor(long long j = 1;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tfield[i][j][k] += field[i][j - 1][k];\n\t    }\n\t}\n    }\n    for(long long i = 0;i < xs.size();i++){\n\tfor(long long j = 1;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tfield[i][j][k] += field[i][j][k - 1];\n\t    }\n\t}\n    }\n    for(long long i = 0;i < xs.size();i++){\n\tfor(long long j = 0;j < ys.size();j++){\n\t    for(long long k = 0;k < zs.size();k++){\n\t\tif(field[i][j][k] >= K) \n\t\t    res += (xx[i + 1] - xx[i]) * (yy[j + 1] - yy[j]) * (zz[k + 1] - zz[k]);\n\t    }\n\t}\n    } \n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 50;\nconst int MAX_DIS = 1000000;\nint n, k;\nint x[2][MAX_N], y[2][MAX_N], z[2][MAX_N];\nint lx[MAX_N * 6], ly[MAX_N * 6], lz[MAX_N * 6];\nint ocean[MAX_N * 6][MAX_N * 6][MAX_N * 6];\nlong long int ans;\n\nint compress(int *start, int *end, int *lx){\n    vector<int> v;\n\n    for(int i = 0; i < n; i++){\n        for(int j = -1; j <= 1; j++){\n            int x1 = start[i] + j, x2 = end[i] + j;\n            if(0 <= x1 && x1 <= MAX_DIS)\n                v.push_back(x1);\n            if(0 <= x2 && x2 <= MAX_DIS)\n                v.push_back(x2);\n        }\n    }\n\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n\n    for(int i = 0; i < n; i++){\n        start[i] = find(v.begin(), v.end(), start[i]) - v.begin();\n        end[i] = find(v.begin(), v.end(), end[i]) - v.begin();\n    }\n\n    for(int i = 0; i < v.size(); i++)\n        lx[i] = v[i];\n\n    return v.size();\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &k);\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 2; j++){\n            scanf(\"%d%d%d\", &x[j][i], &y[j][i], &z[j][i]);\n        }\n    }\n\n    int w = compress(x[0], x[1], lx);\n    int h = compress(y[0], y[1], ly);\n    int d = compress(z[0], z[1], lz);\n\n    for(int i = 0; i < n; i++){\n        for(int j = x[0][i]; j < x[1][i]; j++){\n            for(int l = y[0][i]; l < y[1][i]; l++){\n                for(int m = z[0][i]; m < z[1][i]; m++){\n                    ocean[j][l][m]++;\n                }\n            }\n        }\n    }\n\n    for(int i = 0; i < w - 1; i++){\n        for(int j = 0; j < h - 1; j++){\n            for(int l = 0; l < d - 1; l++){\n                if(ocean[i][j][l] >= k)\n                    ans += (long long)(lx[i + 1] - lx[i]) * (long long)(ly[j + 1] - ly[j]) * (long long)(lz[l + 1] - lz[l]);\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint n,K;\nint f[100][100][100];\nstruct area{ll x1,x2,y1,y2,d1,d2;};\nvector<area> all;\nset<ll> x,y,d;\nmap<int,ll> tx,ty,td;\nint main()\n{\n\tcin >> n >> K;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tarea in;\n\t\tcin >> in.x1 >> in.y1 >> in.d1 >> in.x2 >> in.y2 >> in.d2;\n\t\tall.pb(in);\n\t\tx.insert(in.x1);\n\t\tx.insert(in.x2);\n\t\ty.insert(in.y1);\n\t\ty.insert(in.y2);\n\t\td.insert(in.d1);\n\t\td.insert(in.d2);\n\t}\n\tint nx=x.size(),ny=y.size(),nd=d.size();\n\tset<ll>::iterator it;\n\tint p=0;\n\tfor(it=x.begin();it!=x.end();it++){tx[p++]=*it;}\n\tp=0;\n\tfor(it=y.begin();it!=y.end();it++){ty[p++]=*it;}\n\tp=0;\n\tfor(it=d.begin();it!=d.end();it++){td[p++]=*it;}\n\tfor(int i=0;i<all.size();i++)\n\t{\n\t\tfor(int j=0;j<nx-1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<ny-1;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<nd-1;l++)\n\t\t\t\t{\n\t\t\t\t\tif(all[i].x1<=tx[j]&&all[i].x2>tx[j]&&all[i].y1<=ty[k]&&all[i].y2>ty[k]&&all[i].d1<=td[l]&&all[i].d2>td[l]){f[j][k][l]++;/*cout << \"・∴'、-=≡ ≡ (っ'ヮ'c)ウッヒョ アアアアアアｗｗｗｗｗ\" << endl;*/}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0ll;\n\tfor(int i=0;i<nx-1;i++)\n\t{\n\t\tfor(int j=0;j<ny-1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<nd-1;k++)\n\t\t\t{\n\t\t\t\tif(f[i][j][k]>=K)\n\t\t\t\t{\n\t\t\t\t\tans+=(tx[i+1]-tx[i])*(ty[j+1]-ty[j])*(td[k+1]-td[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nstruct area\n{\n    ll x1,y1,z1,x2,y2,z2;\n\n    bool inside(ll a1, ll a2, ll b1, ll b2, ll c1, ll c2)\n    {\n        return (x1<=a1 && a2<=x2 && y1<=b1 && b2<=y2 && z1<=c1 && c2<=z2);\n    }\n};\n\nint main()\n{\n    int n,m;\n    scanf(\" %d %d\", &n, &m);\n\n    vector<area> f(n);\n    vector<ll> X,Y,Z;\n    rep(i,n)\n    {\n        scanf(\" %lld %lld %lld %lld %lld %lld\", &f[i].x1, &f[i].y1, &f[i].z1, &f[i].x2, &f[i].y2, &f[i].z2);\n\n        X.pb(f[i].x1);\n        X.pb(f[i].x2);\n        Y.pb(f[i].y1);\n        Y.pb(f[i].y2);\n        Z.pb(f[i].z1);\n        Z.pb(f[i].z2);\n    }\n\n    sort(all(X));\n    X.erase(unique(all(X)),X.end());\n    sort(all(Y));\n    Y.erase(unique(all(Y)),Y.end());\n    sort(all(Z));\n    Z.erase(unique(all(Z)),Z.end());\n\n    ll ans=0;\n\n    rep(i,X.size()-1)rep(j,Y.size()-1)rep(k,Z.size()-1)\n    {\n        int ct=0;\n        rep(l,n) if(f[l].inside(X[i],X[i+1],Y[j],Y[j+1],Z[k],Z[k+1])) ++ct;\n        if(ct>=m) ans+=(X[i+1]-X[i])*(Y[j+1]-Y[j])*(Z[k+1]-Z[k]);\n    }\n\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nclass imos3 {\n\tint n, m, l;\n\tvector<vector<vector<T>>> v;\npublic:\n\timos3(int n, int m, int l) : n(n), m(m), l(l), v(n + 1, vector<vector<T>>(m + 1, vector<T>(l + 1))) {}\n\tT& val(int i, int j, int k) { assert(0 <= i && i < n && 0 <= j && j < m && 0 <= k && k < l); return v[i + 1][j + 1][k + 1]; }\n\tvoid add(int li, int lj, int lk, int ri, int rj, int rk, T x) {\n\t\tassert(0 <= li && li <= ri && ri <= n);\n\t\tassert(0 <= lj && lj <= rj && rj <= m);\n\t\tassert(0 <= lk && lk <= rk && rk <= l);\n\t\tval(li, lj, lk) += x;\n\t\tif (ri < n) val(ri, lj, lk) -= x;\n\t\tif (rj < m) val(li, rj, lk) -= x;\n\t\tif (rk < l) val(li, lj, rk) -= x;\n\t\tif (rj < m && rk < l) val(li, rj, rk) += x;\n\t\tif (ri < n && rk < l) val(ri, lj, rk) += x;\n\t\tif (ri < n && rj < m) val(ri, rj, lk) += x;\n\t\tif (ri < n && rj < m && rk < l) val(ri, rj, rk) -= x;\n\t}\n\tvoid build() {\n\t\tfor (int i = 1; i <= n; i++) for (int j = 0; j <= m; j++)  for (int k = 0; k <= l; k++) v[i][j][k] += v[i - 1][j][k];\n\t\tfor (int i = 0; i <= n; i++) for (int j = 1; j <= m; j++)  for (int k = 0; k <= l; k++) v[i][j][k] += v[i][j - 1][k];\n\t\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= m; j++)  for (int k = 1; k <= l; k++) v[i][j][k] += v[i][j][k - 1];\n\t}\n\tT sum(int li, int lj, int lk, int ri, int rj, int rk) {\n\t\tassert(0 <= li && li <= ri && ri <= n);\n\t\tassert(0 <= lj && lj <= rj && rj <= m);\n\t\tassert(0 <= lk && lk <= rk && rk <= l);\n\t\treturn v[ri][rj][rk] - v[li][rj][rk] - v[ri][lj][rk] - v[ri][rj][lk]\n\t\t\t+ v[ri][lj][lk] + v[li][rj][lk] + v[li][lj][rk] - v[li][lj][lk];\n\t}\n};\n\nvoid press(vector<ll>& v, int& size, vector<ll>& vs) {\n\tvs = v;\n\tsort(vs.begin(), vs.end());\n\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n\tsize = vs.size();\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint N, K, h, w, d;\n\tcin >> N >> K;\n\tvector<ll> x(N * 2), y(N * 2), z(N * 2);\n\tfor (int i = 0; i < N * 2; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i];\n\t}\n\tvector<ll> xs, ys, zs;\n\tpress(x, h, xs), press(y, w, ys), press(z, d, zs);\n\timos3<int> im(h, w, d);\n\tfor (int i = 0; i < N; i++) {\n\t\tim.add(x[i * 2], y[i * 2], z[i * 2], x[i * 2 + 1], y[i * 2 + 1], z[i * 2 + 1], 1);\n\t}\n\tim.build();\n\tll res = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tfor (int k = 0; k < d; k++) {\n\t\t\t\tif (im.val(i, j, k) >= K) {\n\t\t\t\t\tres += (xs[i + 1] - xs[i]) * (ys[j + 1] - ys[j]) * (zs[k + 1] - zs[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\n\ntypedef unsigned long long ll;\nint n,K;\nint xf[100],xt[100];\nint yf[100],yt[100];\nint zf[100],zt[100];\nvector<int> vx;\nvector<int> vy;\nvector<int> vz;\nint cnt[201][201][201];\n\nvoid zatu(){\n\tfor(int i=0;i<n;i++){\n\t\tvx.push_back(xf[i]);\n\t\tvx.push_back(xt[i]);\n\t\tvy.push_back(yf[i]);\n\t\tvy.push_back(yt[i]);\n\t\tvz.push_back(zf[i]);\n\t\tvz.push_back(zt[i]);\n\t}\n\tsort(vx.begin(),vx.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tsort(vy.begin(),vy.end());\n\tvy.erase(unique(vy.begin(),vy.end()),vy.end());\n\tsort(vz.begin(),vz.end());\n\tvz.erase(unique(vz.begin(),vz.end()),vz.end());\t\n\tfor(int i=0;i<n;i++){\n\t\t//printf(\"%d %d %d %d %d %d\\n\",xf[i],xt[i],yf[i],yt[i],zf[i],zt[i]);\n\t\txf[i]=find(vx.begin(),vx.end(),xf[i])-vx.begin();\n\t\txt[i]=find(vx.begin(),vx.end(),xt[i])-vx.begin();\n\t\tyf[i]=find(vy.begin(),vy.end(),yf[i])-vy.begin();\n\t\tyt[i]=find(vy.begin(),vy.end(),yt[i])-vy.begin();\n\t\tzf[i]=find(vz.begin(),vz.end(),zf[i])-vz.begin();\n\t\tzt[i]=find(vz.begin(),vz.end(),zt[i])-vz.begin();\n\t\t//printf(\"%d %d %d %d %d %d\\n\",xf[i],xt[i],yf[i],yt[i],zf[i],zt[i]);\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&K);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d%d%d%d%d\",&xf[i],&yf[i],&zf[i],&xt[i],&yt[i],&zt[i]);\n\t}\n\tzatu();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=xf[i];j<xt[i];j++){\n\t\t\tfor(int k=yf[i];k<yt[i];k++){\n\t\t\t\tfor(int l=zf[i];l<zt[i];l++){\n\t\t\t\t\tcnt[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll res=0;\n\tfor(int i=0;i<vx.size()-1;i++){\n\t\tfor(int j=0;j<vy.size()-1;j++){\n\t\t\tfor(int k=0;k<vz.size()-1;k++){\n\t\t\t\tif(cnt[i][j][k]>=K){\n\t\t\t\t\tres+=(ll)(vx[i+1]-vx[i])*(vy[j+1]-vy[j])*(vz[k+1]-vz[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//55\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n\nusing namespace std;\n\nint main(){\n  int N,K;\n  cin>>N>>K;\n  int X[50][2],Y[50][2],D[50][2];\n  int px[100],py[100],pd[100];\n  for(int i=0;i<N;i++){\n    for(int j=0;j<2;j++){\n      cin>>X[i][j]>>Y[i][j]>>D[i][j];\n      px[i*2+j]=X[i][j];\n      py[i*2+j]=Y[i][j];\n      pd[i*2+j]=D[i][j];\n    }\n  }\n  sort(px,px+N*2);\n  sort(py,py+N*2);\n  sort(pd,pd+N*2);\n  static int m[100][100][100]={};\n  long long v=0;\n  for(int i=0;i<N;i++){\n    for(int j=lower_bound(px,px+N*2,X[i][0])-px;j<lower_bound(px,px+N*2,X[i][1])-px;j++){\n      for(int k=lower_bound(py,py+N*2,Y[i][0])-py;k<lower_bound(py,py+N*2,Y[i][1])-py;k++){\n\tfor(int l=lower_bound(pd,pd+N*2,D[i][0])-pd;l<lower_bound(pd,pd+N*2,D[i][1])-pd;l++){\n\t  m[j][k][l]++;\n\t  if(m[j][k][l]==K){\n\t    v+=(long long)(px[j+1]-px[j])*(py[k+1]-py[k])*(pd[l+1]-pd[l]);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<v<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N, K;\n\tcin >> N >> K;\n\n\tvector<int> X1(N);\n\tvector<int> Y1(N);\n\tvector<int> D1(N);\n\tvector<int> X2(N);\n\tvector<int> Y2(N);\n\tvector<int> D2(N);\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> X1[i] >> Y1[i]>> D1[i]>> X2[i]>> Y2[i]>> D2[i];\n\t}\n\t\n\t//ソート用vector\n\tvector<int> X(2*N);\n\tvector<int> Y(2*N);\n\tvector<int> D(2*N);\n\tfor (int i = 0; i < N; i++){\n\t\tX[2 * i]     = X1[i];\n\t\tX[2 * i + 1] = X2[i];\n\t\tY[2 * i]     = Y1[i];\n\t\tY[2 * i + 1] = Y2[i];\n\t\tD[2 * i]     = D1[i];\n\t\tD[2 * i + 1] = D2[i];\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\tlong long int ans = 0;\n\tint kasanari;\n\tfor (int i = 0; i < 2*N-1; i++){ //X\n\t\tfor (int j = 0; j < 2*N-1; j++){ //Y\n\t\t\tfor (int k = 0; k < 2*N-1; k++){ //D\n\t\t\t\tkasanari = 0;\n\t\t\t\tfor (int l = 0; l < N; l++){ //実際の直方体\n\t\t\t\t\tif ((X1[l]<=X[i] && X[i+1] <= X2[l]) &&\n\t\t\t\t\t\t(Y1[l]<=Y[j] && Y[j+1] <= Y2[l]) &&\n\t\t\t\t\t\t(D1[l]<=D[k] && D[k+1] <= D2[l]))\n\t\t\t\t\t\tkasanari++;\n\t\t\t\t}\n\t\t\t\tif (kasanari >= K){\n\t\t\t\t\tans += (long long int)(X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) * (D[k + 1] - D[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX_DIS = 1000000;\nint n, k;\nint x[2][51], y[2][51], z[2][51];\nint lx[301], ly[301], lz[301];\nint ocean[301][301][301];\nlong long int ans;\n\nint compress(int *start, int *end, int *lx){\n    vector<int> v;\n\n    for(int i = 0; i < n; i++){\n        for(int j = -1; j <= 1; j++){\n            int x1 = start[i] + j, x2 = end[i] + j;\n            if(0 <= x1 && x1 <= MAX_DIS)\n                v.push_back(x1);\n            if(0 <= x2 && x2 <= MAX_DIS)\n                v.push_back(x2);\n        }\n    }\n\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n\n    for(int i = 0; i < n; i++){\n        start[i] = find(v.begin(), v.end(), start[i]) - v.begin();\n        end[i] = find(v.begin(), v.end(), end[i]) - v.begin();\n    }\n\n    for(int i = 0; i < v.size(); i++)\n        lx[i] = v[i];\n\n    return v.size();\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &k);\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 2; j++){\n            scanf(\"%d%d%d\", &x[j][i], &y[j][i], &z[j][i]);\n        }\n    }\n\n    int w = compress(x[0], x[1], lx);\n    int h = compress(y[0], y[1], ly);\n    int d = compress(z[0], z[1], lz);\n\n    for(int i = 0; i < n; i++){\n        for(int j = x[0][i]; j < x[1][i]; j++){\n            for(int l = y[0][i]; l < y[1][i]; l++){\n                for(int m = z[0][i]; m < z[1][i]; m++){\n                    ocean[j][l][m]++;\n                }\n            }\n        }\n    }\n\n    for(int i = 0; i < w - 1; i++){\n        for(int j = 0; j < h - 1; j++){\n            for(int l = 0; l < d - 1; l++){\n                if(ocean[i][j][l] >= k)\n                    ans += (lx[i + 1] - lx[i]) * g(ly[j + 1] - ly[j]) * (lz[l + 1] - lz[l]);\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef long long lli;\n\nconst int MAXN = 51;\nconst int NUM = MAXN*2;\nint N, K;\nlli x1[MAXN], y1[MAXN], z1[MAXN], x2[MAXN], y2[MAXN], z2[MAXN];\nset<lli> sx, sy, sz;\nmap<lli, lli> mx, my, mz;\nlli X[NUM], Y[NUM], Z[NUM];\nlli S[NUM][NUM][NUM];\n\nint main() {\n  while(cin >> N >> K) {\n    sx.clear();\n    sy.clear();\n    sz.clear();\n    mx.clear();\n    my.clear();\n    mz.clear();\n    for(int i = 0; i < N; ++i) {\n      cin >> x1[i] >> y1[i] >> z1[i] >> x2[i] >> y2[i] >> z2[i];\n      sx.insert(x1[i]);\n      sx.insert(x2[i]);\n      sy.insert(y1[i]);\n      sy.insert(y2[i]);\n      sz.insert(z1[i]);\n      sz.insert(z2[i]);\n    }\n\n    {\n      int cnt;\n      cnt = 0;\n      for(set<lli>::iterator it = sx.begin(); it != sx.end(); ++it) {\n        mx[*it] = cnt;\n        X[cnt++] = *it;\n      }\n      cnt = 0;\n      for(set<lli>::iterator it = sy.begin(); it != sy.end(); ++it) {\n        my[*it] = cnt;\n        Y[cnt++] = *it;\n      }\n      cnt = 0;\n      for(set<lli>::iterator it = sz.begin(); it != sz.end(); ++it) {\n        mz[*it] = cnt;\n        Z[cnt++] = *it;\n      }\n    }\n\n    for(int i = 0; i < N; ++i) {\n      x1[i] = mx[x1[i]];\n      x2[i] = mx[x2[i]];\n      y1[i] = my[y1[i]];\n      y2[i] = my[y2[i]];\n      z1[i] = mz[z1[i]];\n      z2[i] = mz[z2[i]];\n      /*\n      cout << x1[i] << \", \" << y1[i] << \", \" << z1[i] << \", \"\n           << x2[i] << \", \" << y2[i] << \", \" << z2[i] << endl;\n      */\n    }\n\n    fill(S[0][0], S[NUM][0], 0);\n    for(int m = 0; m < N; ++m) {\n      for(int k = z1[m]; k < z2[m]; ++k) {\n        for(int i = y1[m]; i < y2[m]; ++i) {\n          for(int j = x1[m]; j < x2[m]; ++j) {\n            S[k][i][j] += 1;\n          }\n        }\n      }\n    }\n    lli res = 0;\n    for(int k = 0; k < sz.size(); ++k) {\n      for(int i = 0; i < sy.size(); ++i) {\n        for(int j = 0; j < sx.size(); ++j) {\n          if(S[k][i][j] >= K) {\n            res += ( X[j+1] - X[j] ) * ( Y[i+1] - Y[i] ) * ( Z[k+1] - Z[k] );\n          }\n        }\n      }\n    }\n    cout << res << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nint N,K;\nlong long int x[100];\nlong long int y[100];\nlong long int z[100];\nlong long int xbox[100];\nlong long int ybox[100];\nlong long int zbox[100];\nint sum[100][100][100];\nlong long int ans;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> K;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i * 2] >> y[i * 2] >> z[i * 2] >> x[i * 2 + 1] >> y[i * 2 + 1] >> z[i * 2 + 1];\n\t\txbox[i * 2] = x[i * 2];\n\t\txbox[i * 2 + 1] = x[i * 2 + 1];\n\t\tybox[i * 2] = y[i * 2];\n\t\tybox[i * 2 + 1] = y[i * 2 + 1];\n\t\tzbox[i * 2] = z[i * 2];\n\t\tzbox[i * 2 + 1] = z[i * 2 + 1];\n\t}\n\tstable_sort(x, x + N * 2);\n\tstable_sort(y, y + N * 2);\n\tstable_sort(z, z + N * 2);\n\t//for (int i = 0; i < N * 2; i++) {\n\t//\tcout << x[i] << \" \";\n\t//}\n\t//cout << endl;\n\t//for (int i = 0; i < N * 2; i++) {\n\t//\tcout << y[i] << \" \";\n\t//}\n\t//cout << endl;\n\t//for (int i = 0; i < N * 2; i++) {\n\t//\tcout << z[i] << \" \";\n\t//}\n\t//cout << endl;\n\tfor (int i = 0; i < N; i++) {\n\t\tint sx = 0, sy = 0, sz = 0, gx = 0, gy = 0, gz = 0;\n\t\tfor (int j = 0; j < N * 2; j++) {\n\t\t\tif (xbox[i * 2] == x[j])sx = j;\n\t\t\tif (xbox[i * 2 + 1] == x[j])gx = j;\n\t\t\tif (ybox[i * 2] == y[j])sy = j;\n\t\t\tif (ybox[i * 2 + 1] == y[j])gy = j;\n\t\t\tif (zbox[i * 2] == z[j])sz = j;\n\t\t\tif (zbox[i * 2 + 1] == z[j])gz = j;\n\t\t}\n\t//\tcout << sx << \" \" << gx << \" \" << sy << \" \" << gy << \" \" << sz << \" \" << gz << endl;\n\t\tfor (int j = sx; j <= gx; j++) {\n\t\t\tfor (int k = sy; k <= gy; k++) {\n\t\t\t\tfor (int l = sz; l <= gz; l++) {\n\t\t\t\t\tsum[j][k][l]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N * 2 - 1; i++) {\n\t\tfor (int j = 0; j < N * 2 - 1; j++) {\n\t\t\tfor (int k = 0; k < N * 2 - 1; k++) {\n\t\t\t\tif (sum[i][j][k] >= K&&sum[i + 1][j][k] >= K&&sum[i][j + 1][k] >= K&&sum[i][j][k + 1] >= K&&sum[i + 1][j + 1][k] >= K&&sum[i + 1][j][k + 1] >= K&&sum[i][j + 1][k + 1] >= K&&sum[i + 1][j + 1][k + 1] >= K) {\n\t\t\t\t\tans += (x[i + 1] - x[i])*(y[j + 1] - y[j])*(z[k + 1] - z[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Cuboid{\npublic:\n  ll ox[8]; //original x\n  ll oy[8];\n  ll od[8];\n\n  int mx[8]; // mapped x\n  int my[8];\n  int md[8];\n\n  Cuboid(int x1,int y1,int d1,\n         int x2,int y2,int d2){\n    ox[0] = x1;\n    oy[0] = y1;\n    od[0] = d1;\n\n    ox[1] = x1;\n    oy[1] = y2;\n    od[1] = d1;\n\n    ox[2] = x2;\n    oy[2] = y2;\n    od[2] = d1;\n\n    ox[3] = x2;\n    oy[3] = y1;\n    od[3] = d1;\n\n    ox[4] = x1;\n    oy[4] = y1;\n    od[4] = d2;\n\n    ox[5] = x1;\n    oy[5] = y2;\n    od[5] = d2;\n\n    ox[6] = x2;\n    oy[6] = y2;\n    od[6] = d2;\n\n    ox[7] = x2;\n    oy[7] = y1;\n    od[7] = d2;\n  }    \n\n  void mapping(const vector<int>& xs,\n               const vector<int>& ys,\n               const vector<int>& ds){\n    for(int i=0;i<6;i++){\n      mx[i] = lower_bound(xs.begin(),xs.end(),ox[i]) - xs.begin();\n      my[i] = lower_bound(ys.begin(),ys.end(),oy[i]) - ys.begin();\n      md[i] = lower_bound(ds.begin(),ds.end(),od[i]) - ds.begin();\n    }\n  }\n};\n\nint dp[101][101][101];\n\nint main(){\n  int total_fish;\n  int lower;\n  while(~scanf(\"%d %d\",&total_fish,&lower)){\n\n    vector<int> xs;\n    vector<int> ys;\n    vector<int> ds;\n\n    vector<Cuboid> cuboids;\n    for(int fish_idx = 0; fish_idx < total_fish; fish_idx++){\n      int x1,y1,d1;\n      int x2,y2,d2;\n      scanf(\"%d %d %d\",&x1,&y1,&d1);\n      scanf(\"%d %d %d\",&x2,&y2,&d2);\n      \n      cuboids.push_back(Cuboid(x1,y1,d1,x2,y2,d2));\n      xs.push_back(x1);       \n      xs.push_back(x2);\n\n      ys.push_back(y1);       \n      ys.push_back(y2);\n\n      ds.push_back(d1);       \n      ds.push_back(d2);\n    }\n\n    sort(xs.begin(),xs.end());\n    sort(ys.begin(),ys.end());\n    sort(ds.begin(),ds.end());\n\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    ys.erase(unique(ys.begin(),ys.end()),ys.end());\n    ds.erase(unique(ds.begin(),ds.end()),ds.end());\n\n    memset(dp,0,sizeof(dp));\n    for(int i=0;i<cuboids.size();i++){\n      cuboids[i].mapping(xs,ys,ds);\n\n      for(int x = cuboids[i].mx[0]; x < cuboids[i].mx[2]; x++){\n        for(int y = cuboids[i].my[0]; y < cuboids[i].my[1]; y++){\n          for(int d = cuboids[i].md[0]; d < cuboids[i].md[4]; d++){\n            dp[x][y][d]++;\n          }\n        }\n      }\n    }\n\n    ll res = 0;\n    for(int x = 0; x < xs.size(); x++){\n      for(int y = 0; y < ys.size(); y++){\n        for(int d = 0; d < ds.size(); d++){\n          if(dp[x][y][d] >= lower){\n            res += (xs[x + 1] - xs[x])\n              * (ys[y + 1] - ys[y])\n              * (ds[d + 1] - ds[d]);\n          }\n        }\n      }\n    }\n\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n  int x1, y1, z1;\n  int x2, y2, z2;\n  Point(){}\n  Point(int x1, int y1, int z1, int x2, int y2, int z2):\n    x1(x1), y1(y1), z1(z1), x2(x2), y2(y2), z2(z2){};\n};\n\n\nint main(){\n  int N, K;\n  cin >> N >> K;\n  vector< int > X, Y, Z;\n  vector< Point > p(N);\n  for(int i = 0; i < N; i++){\n    int x1, y1, z1, x2, y2, z2;\n    cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n    p[i] = Point( x1, y1, z1, x2, y2, z2);\n\n    X.push_back(x1), X.push_back(x2);\n    Y.push_back(y1), Y.push_back(y2);\n    Z.push_back(z1), Z.push_back(z2);\n  }\n\n  sort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end());\n  sort(Y.begin(), Y.end()); Y.erase(unique(Y.begin(), Y.end()), Y.end());\n  sort(Z.begin(), Z.end()); Z.erase(unique(Z.begin(), Z.end()), Z.end());\n\n\n  long long ret = 0;\n  for(int i = 0; i < X.size() - 1; i++){\n    for(int j = 0; j < Y.size() - 1; j++){\n      for(int k = 0; k < Z.size() - 1; k++){\n        int cnt = 0;\n        for(int l = 0; l < N; l++){\n          cnt += (p[l].x1 <= X[i] && X[i + 1] <= p[l].x2 &&\n                  p[l].y1 <= Y[j] && Y[j + 1] <= p[l].y2 &&\n                  p[l].z1 <= Z[k] && Y[k + 1] <= p[l].z2);\n        }\n        if(cnt >= K){\n          ret += (long long)(X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) * (Z[k + 1] - Z[k]);\n        }\n      }\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct POS{\n\tint num;\n\tint coord[3];\n\tbool begin;\n};\n\nlong long scan_d(vector<bool> &vec_x,vector<bool> &vec_y,vector<POS> &vec_d,int N,int K)\n{\n\tvector<bool> vec(N);\n\tfill(vec.begin(),vec.end(),false);\n\t\n\tint count=0;\n\tint begin;\n\tlong long total = 0;\n\tfor(POS &p : vec_d ){\n\t\tif( !vec_x[p.num] ) continue;\n\t\tif( !vec_y[p.num] ) continue;\n\n\t\tif( p.begin ){\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[2]-begin);\n//\t\t\t\tcout << \"D:\" << begin << \"-\" << p.coord[2] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=true;\n\t\t\tcount++;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[2];\n\t\t\t}\n\t\t}else{\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[2]-begin);\n//\t\t\t\tcout << \"D:\" << begin << \"-\" << p.coord[2] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=false;\n\t\t\tcount--;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[2];\n\t\t\t}\n\t\t}\n\t}\n\treturn total;\n}\n\nlong long scan_y(vector<bool> &vec_x,vector<POS> &vec_y,vector<POS> &vec_d,int N,int K)\n{\n\tvector<bool> vec(N);\n\tfill(vec.begin(),vec.end(),false);\n\t\n\tint count=0;\n\tint begin;\n\tlong long size;\n\tlong long total = 0;\n\tfor(POS &p : vec_y ){\n\t\tif( !vec_x[p.num] ) continue;\n\n\t\tif( p.begin ){\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[1]-begin) * size;\n//\t\t\t\tcout << \"Y:\" << begin << \"-\" << p.coord[1] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=true;\n\t\t\tcount++;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[1];\n\t\t\t\tsize = scan_d(vec_x, vec,vec_d,N,K);\n\t\t\t}\n\t\t}else{\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[1]-begin) * size;\n//\t\t\t\tcout << \"Y:\" << begin << \"-\" << p.coord[1] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=false;\n\t\t\tcount--;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[1];\n\t\t\t\tsize = scan_d(vec_x, vec,vec_d,N,K);\n\t\t\t}\n\t\t}\n\t}\n\treturn total;\n}\n\nlong long scan_x(vector<POS> &vec_x,vector<POS> &vec_y,vector<POS> &vec_d,int N,int K)\n{\n\tvector<bool> vec(N);\n\tfill(vec.begin(),vec.end(),false);\n\t\n\tint count=0;\n\tint begin;\n\tlong long size;\n\tlong long total = 0;\n\tfor(POS &p : vec_x ){\n\t\tif( p.begin ){\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[0]-begin) * size;\n//\t\t\t\tcout << \"X:\" << begin << \"-\" << p.coord[0] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=true;\n\t\t\tcount++;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[0];\n\t\t\t\tsize = scan_y(vec, vec_y,vec_d,N,K);\n\t\t\t}\n\t\t}else{\n\t\t\tif(count>=K){\n\t\t\t\ttotal += (p.coord[0]-begin) * size;\n//\t\t\t\tcout << \"X:\" << begin << \"-\" << p.coord[0] << endl;\n\t\t\t}\n\t\t\tvec[p.num]=false;\n\t\t\tcount--;\n\t\t\tif( count>=K ){\n\t\t\t\tbegin = p.coord[0];\n\t\t\t\tsize = scan_y(vec, vec_y,vec_d,N,K);\n\t\t\t}\n\t\t}\n\t}\n\treturn total;\n}\n\nint main() {\n\tint N,K;\n\tcin >> N >> K;\n\t\n\tvector<POS> vec;\n\n\tfor(int i=0;i<N;i++){\n\t\tPOS p0,p1;\n\t\tcin >> p0.coord[0] >> p0.coord[1] >> p0.coord[2];\n\t\tcin >> p1.coord[0] >> p1.coord[1] >> p1.coord[2];\n\t\tp0.num=i;\n\t\tp0.begin=true;\n\t\tp1.num=i;\n\t\tp1.begin=false;\n\t\tvec.push_back(p0);\n\t\tvec.push_back(p1);\n\t}\n\n\tvector<POS> vec_x(vec);\n\tvector<POS> vec_y(vec);\n\tvector<POS> vec_d(vec);\n\n\tsort(vec_x.begin(),vec_x.end(),[](const POS &p0,const POS &p1){ return p0.coord[0]<p1.coord[0];});\n\tsort(vec_y.begin(),vec_y.end(),[](const POS &p0,const POS &p1){ return p0.coord[1]<p1.coord[1];});\n\tsort(vec_d.begin(),vec_d.end(),[](const POS &p0,const POS &p1){ return p0.coord[2]<p1.coord[2];});\n\n\t// for( POS p : vec_x ){\n\t// \tcout << p.coord[0] << \" \";\n\t// }\n\t// cout << endl;\n\n\tlong long ans = scan_x(vec_x,vec_y,vec_d,N,K);\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n \nint main(){\n    vector<int>x,y,d;\n    static int zx[1000000+2],zy[1000000+2],zd[1000000+2],p[50][6],n,k,sea[102][102][102];\n    long long int ans=0,a;\n    scanf(\"%d%d\",&n,&k);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<6;j++){\n            scanf(\"%d\",&p[i][j]);\n        }\n        x.push_back(p[i][0]);\n        x.push_back(p[i][3]);\n        y.push_back(p[i][1]);\n        y.push_back(p[i][4]);\n        d.push_back(p[i][2]);\n        d.push_back(p[i][5]);\n    }\n    sort(x.begin(),x.end());\n    sort(y.begin(),y.end());\n    sort(d.begin(),d.end());\n    int N=2*n+1;\n    for(int i=0;i<N-1;i++){\n        zx[x[i]]=i;\n        zy[y[i]]=i;\n        zd[d[i]]=i;\n    }\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            for(int l=0;l<N;l++){\n                sea[i][j][l]=0;\n            }\n        }\n    }\n     \n    for(int i=0;i<n;i++){\n        sea[zx[p[i][0]]][zy[p[i][1]]][zd[p[i][2]]]++;\n        sea[zx[p[i][0]]][zy[p[i][1]]][zd[p[i][5]]]--;\n        sea[zx[p[i][0]]][zy[p[i][4]]][zd[p[i][2]]]--;\n        sea[zx[p[i][0]]][zy[p[i][4]]][zd[p[i][5]]]++;\n        sea[zx[p[i][3]]][zy[p[i][1]]][zd[p[i][2]]]--;\n        sea[zx[p[i][3]]][zy[p[i][1]]][zd[p[i][5]]]++;\n        sea[zx[p[i][3]]][zy[p[i][4]]][zd[p[i][2]]]++;\n        sea[zx[p[i][3]]][zy[p[i][4]]][zd[p[i][5]]]--;\n    }\n    for(int i=1;i<N;i++){\n        for(int j=0;j<N;j++){\n            for(int l=0;l<N;l++){\n                sea[i][j][l]+=sea[i-1][j][l];\n            }\n        }\n    }\n    for(int i=0;i<N;i++){\n        for(int j=1;j<N;j++){\n            for(int l=0;l<N;l++){\n                sea[i][j][l]+=sea[i][j-1][l];\n            }\n        }\n    }\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            for(int l=0;l<N;l++){\n                if(l!=0)sea[i][j][l]+=sea[i][j][l-1];\n                if(sea[i][j][l]>=k){\n                    a=1;\n                    a*=x[i+1]-x[i];\n                    a*=y[j+1]-y[j];\n                    a*=d[l+1]-d[l];\n                    ans+=a;\n                }\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n// #include <ctime>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(){\n\tull v = 0;\n\tconst int MAX_N = 50;\n\tint N, K;\n\tint X1[MAX_N], Y1[MAX_N], D1[MAX_N], X2[MAX_N], Y2[MAX_N], D2[MAX_N];\n\n\tcin >> N >> K;\n\n\tvector<int> X(2 * N), Y(2 * N), D(2 * N);\n\n\tfor (int i = 0; i<N; i++){\n\t\tcin >> X1[i] >> Y1[i] >> D1[i] >> X2[i] >> Y2[i] >> D2[i];\n\t\tX[i]     = X1[i];\n\t\tX[i + N] = X2[i];\n\t\tY[i]     = Y1[i];\n\t\tY[i + N] = Y2[i];\n\t\tD[i]     = Y1[i];\n\t\tD[i + N] = Y2[i];\n\t}\n//\tclock_t st = clock();\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\tfor (int i = 0, n = 2*N - 1; i<n; i++){\n\tfor (int j = 0; j<n; j++){\n\tfor (int k = 0; k<n; k++){\n\t\tint kind = 0;\n\t\tfor (int l = 0; l < N; l++){\n\t\t\tif (X1[l] <= X[i] && X[i+1] <= X2[l] && \n\t\t\t\tY1[l] <= Y[j] && Y[j+1] <= Y2[l] && \n\t\t\t\tD1[l] <= D[k] && D[k+1] <= D2[l]) kind++;\n\t\t}\n\t\tif (kind >= K) v += (ull)(X[i+1] - X[i]) * (Y[j+1] - Y[j]) * (D[k+1] - D[k]);\n\t}\n\t}\n\t}\n\n\tcout << v << endl;\n//\tclock_t ed = clock();\n//\tcout << (double)(ed - st) / CLOCKS_PER_SEC << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint n, k;\nvector<int> xs, ys, zs;\nmap<int, int> zipx, zipy, zipz;//<???, ??§??????>\nmap<int, int> unzipx, unzipy, unzipz;//<??§??????, ???>\nint num[100][100][100];//???????¨?????????\\??????\n\nint main(void){\n\tcin >> n >> k;\n\tint x1[51], x2[51], y1[51], y2[51], z1[51], z2[51];//?????????????????§?¨?\n\trep(i, n){\n\t\tcin >> x1[i] >> y1[i] >> z1[i];\n\t\tcin >> x2[i] >> y2[i] >> z2[i];\n\t\txs.push_back(x1[i]); xs.push_back(x2[i]);\n\t\tys.push_back(y1[i]); ys.push_back(y2[i]);\n\t\tzs.push_back(z1[i]); zs.push_back(z2[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end(), xs.end()));//???????¶????\n\tsort(ys.begin(), ys.end());\n\tys.erase(unique(ys.begin(), ys.end(), ys.end()));\n\tsort(zs.begin(), zs.end());\n\tzs.erase(unique(zs.begin(), zs.end(), zs.end()));\n\n\trep(i, xs.size()){\n\t\tzipx[i] = xs[i];\n\t\tunzipx[xs[i]] = i;\n\t}\n\trep(i, ys.size()){\n\t\tzipy[i] = ys[i];\n\t\tunzipy[ys[i]] = i;\n\t}\n\trep(i, zs.size()){\n\t\tzipz[i] = zs[i];\n\t\tunzipz[zs[i]] = i;\n\t}\n\n\tmemset(num, 0, sizeof(num));\n\tfor (int i = 0; i < n; ++i){\n\t\tfor (int x = unzipx[x1[i]]; x < unzipx[x2[i]]; ++x){\n\t\t\tfor (int y = unzipy[y1[i]]; y < unzipy[x2[i]]; ++y){\n\t\t\t\tfor (int z = unzipz[z1[i]]; z < unzipz[z2[i]]; ++z){\n\t\t\t\t\tnum[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(x, 100)rep(y, 100)rep(z, 100){\n\t\tif(num[x][y][z] >= k) ans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    一般に3次元imosはバグの元なんじゃ\n  */\n\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<pair<int, int>, int> Coor;\n#define make_coor(x, y, z) make_pair(make_pair((x), (y)), (z))\n#define get_coor(c, x, y, z)\\\n    do {\\\n        x = (c).first.first;\\\n        y = (c).first.second;\\\n        z = (c).second;\\\n    } while(0)\n\nint area[401][401][401];\nint n;\nint g;\nvector<int> newx;\nvector<int> newy;\nvector<int> newz;\nvector<pair<Coor, Coor> > points;\nmap<int, int> revx;\nmap<int, int> revy;\nmap<int, int> revz;\nlong long int xval;\nlong long int yval;\nlong long int zval;\nlong long int ans;\n\nint main() {\n    scanf(\"%d %d\", &n, &g);\n    for (int i=0; i<n; i++) {\n        int x1, x2;\n        int y1, y2;\n        int z1, z2;\n        Coor c, c2;\n\n        scanf(\"%d %d %d %d %d %d\", &x1, &y1, &z1, &x2, &y2, &z2);\n        newx.push_back(x1);\n        newx.push_back(x2);\n        newy.push_back(y1);\n        newy.push_back(y2);\n        newz.push_back(z1);\n        newz.push_back(z2);\n\n        c = make_coor(x1, y1, z1);\n        c2 = make_coor(x2, y2, z2);\n        points.push_back(make_pair(c, c2));\n    }\n\n    sort(newx.begin(), newx.end());\n    sort(newy.begin(), newy.end());\n    sort(newz.begin(), newz.end());\n    newx.erase(unique(newx.begin(), newx.end()), newx.end());\n    newy.erase(unique(newy.begin(), newy.end()), newy.end());\n    newz.erase(unique(newz.begin(), newz.end()), newz.end());\n    for (int i=0; i<newx.size(); i++) {\n        revx[newx[i]] = i;\n    }\n\n    for (int i=0; i<newy.size(); i++) {\n        revy[newy[i]] = i;\n    }\n\n    for (int i=0; i<newz.size(); i++) {\n        revz[newz[i]] = i;\n    }\n\n    for (int uni=0; uni<points.size(); uni++) {\n        pair<Coor, Coor> p = points[uni];\n        Coor c = p.first;\n        Coor c2 = p.second;\n        int x, y, z;\n        int x2, y2, z2;\n\n        get_coor(c, x, y, z);\n        get_coor(c2, x2, y2, z2);\n        x = revx[x];\n        x2 = revx[x2];\n        y = revy[y];\n        y2 = revy[y2];\n        z = revz[z];\n        z2 = revz[z2];\n\n        for (int i=x; i<x2; i++) {\n            for (int j=y; j<y2; j++) {\n                for (int k=z; k<z2; k++) {\n                    ++area[i][j][k];\n                }\n            }\n        }\n    }\n\n    for (int i=0; i<newx.size()-1; i++) {\n        for (int j=0; j<newy.size()-1; j++){\n            for (int k=0; k<newz.size()-1; k++) {\n                if (area[i][j][k] >= g) {\n                    xval = newx[i+1] - newx[i];\n                    yval = newy[j+1] - newy[j];\n                    zval = newz[k+1] - newz[k];\n                    ans += xval * yval * zval;\n                }\n            }\n        }  \n    }\n\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,q;\nlong long x[110],y[110],z[110],ans;\nlong long a[110][2],b[110][2],c[110][2];\nint main(){\n\tcin>>n>>q;\n\trep(i,2*n){\n\t\tcin>>x[i]>>y[i]>>z[i];\n\t\ta[i/2][i%2]=x[i];\n\t\tb[i/2][i%2]=y[i];\n\t\tc[i/2][i%2]=z[i];\n\t}\n\tsort(x,x+n*2);sort(y,y+n*2);sort(z,z+n*2);\n\tans=0;\n\trep(i,n*2-1)rep(j,n*2-1)rep(k,n*2-1){\n\t\tint cnt=0;\n\t\trep(t,n){\n\t\t\tbool ok=true;\n\t\t\trep(r,2){\n\t\t\t\tif(a[t][0]>x[i+r]||x[i+r]>a[t][1])ok=false;\n\t\t\t\tif(b[t][0]>y[j+r]||y[j+r]>b[t][1])ok=false;\n\t\t\t\tif(c[t][0]>z[k+r]||z[k+r]>c[t][1])ok=false;\n\t\t\t}\n\t\t\tif(ok)cnt++;\n\t\t}\n\t\tif(cnt>=q)ans+=(x[i+1]-x[i])*(y[j+1]-y[j])*(z[k+1]-z[k]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N, K;\n\tcin >> N >> K;\n\n\tvector<int> X1(N);\n\tvector<int> Y1(N);\n\tvector<int> D1(N);\n\tvector<int> X2(N);\n\tvector<int> Y2(N);\n\tvector<int> D2(N);\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> X1[i] >> Y1[i]>> D1[i]>> X2[i]>> Y2[i]>> D2[i];\n\t}\n\t\n\t//ソート用vector\n\tvector<int> X(2*N);\n\tvector<int> Y(2*N);\n\tvector<int> D(2*N);\n\tfor (int i = 0; i < N; i++){\n\t\tX[2 * i]     = X1[i];\n\t\tX[2 * i + 1] = X2[i];\n\t\tY[2 * i]     = Y1[i];\n\t\tY[2 * i + 1] = Y2[i];\n\t\tD[2 * i]     = D1[i];\n\t\tD[2 * i + 1] = D2[i];\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tsort(D.begin(), D.end());\n\n\tlong long int ans = 0;\n\tint kasanari;\n\tfor (int i = 0; i < 2*N-1; i++){ //X\n\t\tfor (int j = 0; j < 2*N-1; j++){ //Y\n\t\t\tfor (int k = 0; k < 2*N-1; k++){ //D\n\t\t\t\tkasanari = 0;\n\t\t\t\tfor (int l = 0; l < N; l++){ //実際の直方体\n\t\t\t\t\tif ((X1[l]<=X[i] && X[i+1] <= X2[l]) &&\n\t\t\t\t\t\t(Y1[l]<=Y[j] && Y[j+1] <= Y2[l]) &&\n\t\t\t\t\t\t(D1[l]<=D[k] && D[k+1] <= D2[l]))\n\t\t\t\t\t\tkasanari++;\n\t\t\t\t}\n\t\t\t\tif (kasanari >= K){\n\t\t\t\t\tans += (X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) * (D[k + 1] - D[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\nlong long in(){\n\tlong long n;\n\tscanf(\"%lld\",&n);\n\treturn n;\n}\n/*\n\tza atu + iroiro\n*/\n\nint st[50][3];\nint en[50][3];\n\nvector<int> u[3];\n\nint sim[120][120][120];\n\nint main(){\n\tint N,K;\n\tcin >> N >> K;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tfor(int j = 0 ; j < 3 ; j++){\n\t\t\tcin >> st[i][j];\n\t\t\tu[j].push_back(st[i][j]);\n\t\t}\n\t\tfor(int j = 0 ; j < 3 ; j++){\n\t\t\tcin >> en[i][j];\n\t\t\tu[j].push_back(en[i][j]);\n\t\t}\n\t}\n\tfor(int i = 0 ; i < 3 ; i++){\n\t\tsort(u[i].begin(),u[i].end());\n\t\tu[i].erase( unique(u[i].begin(),u[i].end()) , u[i].end() );\n\t}\n\tfor(int i = 0 ; i < N ; i++){\n\t\tfor(int j = 0 ; j < 3 ; j++){\n\t\t\tst[i][j] = lower_bound( u[j].begin() , u[j].end() , st[i][j] ) - u[j].begin();\n\t\t}\n\t\tfor(int j = 0 ; j < 3 ; j++){\n\t\t\ten[i][j] = lower_bound( u[j].begin() , u[j].end() , en[i][j] ) - u[j].begin();\n\t\t}\n\t\tfor(int x = st[i][0] ; x < en[i][0] ; x++)\n\t\t\tfor(int y = st[i][1] ; y < en[i][1] ; y++)\n\t\t\t\tfor(int z = st[i][2] ; z < en[i][2] ; z++)\n\t\t\t\t\tsim[x][y][z]++;\n\t}\n\tlong long ans = 0;\n\tfor(int x = 0 ; x < u[0].size()-1 ; x++)\n\t\tfor(int y = 0 ; y < u[1].size()-1 ; y++)\n\t\t\tfor(int z = 0 ; z < u[2].size()-1 ; z++)\n\t\t\t\tif( sim[x][y][z] >= K ){\n\t\t\t\t\tlong long dx = (u[0][x+1]-u[0][x]);\n\t\t\t\t\tlong long dy = (u[1][y+1]-u[1][y]);\n\t\t\t\t\tlong long dz = (u[2][z+1]-u[2][z]);\n\t\t\t\t\tlong long vol = dx * dy * dz;\n\t\t\t\t\tans += vol;\n\t\t\t\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef __int64 lint;\n\nint main()\n{\n\tint N, K;\n\tstatic int cube[128][128][128];\n\tint x1[64], x2[64], y1[64], y2[64], z1[64], z2[64];\n\tvector<int> xs, ys, zs;\n\tmap<int, int> convx, convy, convz;\n\tmap<int, int> motox, motoy, motoz;\n\t\n\tscanf(\"%d %d\", &N, &K);\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d %d %d %d\", x1 + i, y1 + i, z1 + i, x2 + i, y2 + i, z2 + i);\n\t\txs.push_back(x1[i]); xs.push_back(x2[i]);\n\t\tys.push_back(y1[i]); ys.push_back(y2[i]);\n\t\tzs.push_back(z1[i]); zs.push_back(z2[i]);\n\t}\n\t\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\tsort(zs.begin(), zs.end());\n\t\n\t/*\n\tint idx = 0;\n\tconvx[xs[0]] = idx;\n\tmotox[idx++] = xs[0];\n\t*/\n\tfor (int i = 1; i < 2 * N; i++){\n\t\tif (xs[i] != xs[i - 1]){\n\t\t\tconvx[xs[i]] = idx;\n\t\t\tmotox[idx++] = xs[i];\n\t\t}\n\t}\n\t\n\t/*\n\tidx = 0;\n\tconvy[ys[0]] = idx;\n\tmotoy[idx++] = ys[0];\n\t*/\n\tfor (int i = 1; i < 2 * N; i++){\n\t\tif (ys[i] != ys[i - 1]){\n\t\t\tconvy[ys[i]] = idx;\n\t\t\tmotoy[idx++] = ys[i];\n\t\t}\n\t}\n\t\n\t/*\n\tidx = 0;\n\tconvz[zs[0]] = idx;\n\tmotoz[idx++] = zs[0];\n\t*/\n\tfor (int i = 1; i < 2 * N; i++){\n\t\tif (zs[i] != zs[i - 1]){\n\t\t\tconvz[zs[i]] = idx;\n\t\t\tmotoz[idx++] = zs[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\t//printf(\"%d %d %d %d %d %d\\n\", convx[x1[i]], convy[y1[i]], convz[z1[i]], convx[x2[i]], convy[y2[i]], convz[z2[i]]);\n\t\tfor (int x = convx[x1[i]]; x < convx[x2[i]]; x++){\n\t\t\tfor (int y = convy[y1[i]]; y < convy[y2[i]]; y++){\n\t\t\t\tfor (int z = convz[z1[i]]; z < convz[z2[i]]; z++){\n\t\t\t\t\tcube[x][y][z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlint ans = 0;\n\tfor (int i = 0; i < 128; i++){\n\t\tfor (int j = 0; j < 128; j++){\n\t\t\tfor (int k = 0; k < 128; k++){\n\t\t\t\t/*if (cube[i][j][k] >= K){\n\t\t\t\t\tprintf(\"!!\\n\");\n\t\t\t\t\tprintf(\"motox[i + 1] = %d motox[i] = %d motoy[j + 1] = %d motoy[j] = %d motoz[k + 1] = %d motoz[k] = %d\\n\", motox[i + 1], motox[i], motoy[j + 1], motoy[j], motoz[k + 1], motoz[k]);\n\t\t\t\t}*/\n\t\t\t\tans += (cube[i][j][k] >= K ? (lint)(motox[i + 1] - motox[i]) * (motoy[j + 1] - motoy[j]) * (motoz[k + 1] - motoz[k]) : 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%I64d\\n\", ans);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nstruct fish {\n\tint lx, ly, lz;\n\tint rx, ry, rz;\n};\nstruct Compress {\n\tmap<int, int>mp;\n\tmap<int, int>revmp;\n\n\tCompress(vector<int>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < vs.size(); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\tCompress(const set<int>&vs) {\n\t\tint num = 0;\n\t\tfor (auto v : vs) {\n\t\t\tmp[v] = num;\n\t\t\trevmp[num] = v;\n\t\t\tnum++;\n\t\t}\n\t}\n};\nint pluss[101][101][101];\nint num[102][102][102];\nint main() {\n\tint N, K; cin >> N >> K;\n\tvector<fish>fs;\n\tvector<int>xs, ys, zs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint lx, ly, ld, rx, ry, rd; cin >> lx >> ly >> ld >> rx >> ry >> rd;\n\t\tfs.push_back(fish{lx, ly, ld, rx, ry, rd});\n\t\txs.push_back(lx); xs.push_back(rx);\n\t\tys.push_back(ly); ys.push_back(ry);\n\t\tzs.push_back(ld); zs.push_back(rd);\n\t}\n\tCompress cx(xs), cy(ys), cz(zs);\n\tfor (auto &f : fs) {\n\t\tf.lx = cx.mp[f.lx];\n\t\tf.rx = cx.mp[f.rx];\n\t\tf.ly = cy.mp[f.ly];\n\t\tf.ry = cy.mp[f.ry];\n\t\tf.lz = cz.mp[f.lz];\n\t\tf.rz = cz.mp[f.rz];\n\t}\n\tmemset(pluss, 0, sizeof(pluss));\n\tfor (auto f : fs) {\n\t\tpluss[f.lx][f.ly][f.lz]++;\n\t\tpluss[f.rx][f.ly][f.lz]--;\n\t\tpluss[f.lx][f.ry][f.lz]--;\n\t\tpluss[f.lx][f.ly][f.rz]--;\n\t\tpluss[f.rx][f.ry][f.lz]++;\n\t\tpluss[f.lx][f.ry][f.rz]++;\n\t\tpluss[f.rx][f.ly][f.rz]++;\n\t\tpluss[f.rx][f.ry][f.rz]--;\n\t}\n\tmemset(num, 0, sizeof(num));\n\tlong long int ans = 0;\n\tfor (int x = 1; x < 102; ++x) {\n\t\tfor (int y = 1; y < 102; ++y) {\n\t\t\tfor (int z = 1; z < 102; ++z) {\n\t\t\t\tnum[x][y][z] = pluss[x - 1][y - 1][z - 1]+ num[x][y][z - 1] + num[x][y - 1][z] +num[x - 1][y][z] - num[x - 1][y - 1][z] - num[x - 1][y][z - 1]- num[x][y - 1][z - 1] +num[x - 1][y - 1][z - 1];\n\t\t\t\tif (num[x][y][z] >= K) {\n\t\t\t\t\tif (cx.revmp.find(x) == cx.revmp.end())assert(false);\n\t\t\t\t\tif (cy.revmp.find(y) == cy.revmp.end())assert(false);\n\n\t\t\t\t\tif (cz.revmp.find(z) == cz.revmp.end())assert(false);\n\n\t\t\t\t\tlong long int dx = cx.revmp[x] - cx.revmp[x - 1];\n\t\t\t\t\tlong long int dy = cy.revmp[y] - cy. revmp[y - 1];\n\t\t\t\t\tlong long int dz = cz.revmp[z] - cz.revmp[z - 1];\n\t\t\t\t\tans += dx*dy*dz;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint coun[105][105][105];\nvector<int>x,y,z;\nint rx[52][2], ry[52][2], rz[52][2];\nint a[52],b[52],c[52],d[52],e[52],f[52];\nint n,m;\n\nint compress1(){\n\tfor(int i = 0;i < n;i++){\n\t\tx.push_back(a[0]);\n\t\tx.push_back(d[0]);\n\t}\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tfor(int i = 0;i < n;i++){\n\t\trx[i][0] = find(x.begin(),x.end(),a[i])-x.begin();\n\t\trx[i][1] = find(x.begin(),x.end(),d[i])-x.begin();\n\t}\n\treturn 0;\n}\n\nint main()\n{\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<n;i++)\n    {\n      scanf(\"%d %d %d %d %d %d\",&a[i],&b[i],&c[i],&d[i],&e[i],&f[i]);\n       x.push_back(a[i]);\n       x.push_back(d[i]);\n       y.push_back(b[i]);\n       y.push_back(e[i]);\n       z.push_back(c[i]);\n       z.push_back(f[i]);\n    }\n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  sort(z.begin(),z.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n  z.erase(unique(z.begin(),z.end()),z.end());\n  for(int i=0;i<n;i++)\n    {\n      int r1=find(x.begin(),x.end(),a[i])-x.begin();\n      int r2=find(x.begin(),x.end(),d[i])-x.begin();\n      int r3=find(y.begin(),y.end(),b[i])-y.begin();\n      int r4=find(y.begin(),y.end(),e[i])-y.begin();\n      int r5=find(z.begin(),z.end(),c[i])-z.begin();\n      int r6=find(z.begin(),z.end(),f[i])-z.begin();\n      for(int i=r1;i<r2;i++)\n    {\n      for(int j=r3;j<r4;j++)\n        {\n          for(int k=r5;k<r6;k++)\n        {\n          coun[i][j][k]++;\n        }\n        }\n    }\n    }\n  long long ans=0;\n  for(int i=0;i<=100;i++)\n    {\n      for(int j=0;j<=100;j++)\n    {\n      for(int k=0;k<=100;k++)\n        {\n          if(coun[i][j][k]>=m)\n        {\n          long long s1=(x[i+1]-x[i]),s2=(y[j+1]-y[j]),s3=(z[k+1]-z[k]);\n          ans+=s1*s2*s3;\n        }\n        }\n    }\n    }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint coun[105][105][105];\nvector<int>x,y,z;\nint rx[52][2], ry[52][2], rz[52][2];\nint a[52],b[52],c[52],d[52],e[52],f[52];\nint n,m;\n\nint compress1(){\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tfor(int i = 0;i < n;i++){\n\t\trx[i][0] = find(x.begin(),x.end(),a[i])-x.begin();\n\t\trx[i][1] = find(x.begin(),x.end(),d[i])-x.begin();\n\t}\n\treturn 0;\n}\n\nint compress2(){\n\tsort(y.begin(), y.end());\n\ty.erase(unique(y.begin(), y.end()), y.end());\n\tfor(int i = 0;i < n;i++){\n\t\try[i][0] = find(y.begin(),y.end(),b[i])-y.begin();\n\t\try[i][1] = find(y.begin(),y.end(),e[i])-y.begin();\n\t}\n\treturn 0;\n}\n\nint compress3(){\n\tsort(z.begin(), z.end());\n\tz.erase(unique(z.begin(), z.end()), z.end());\n\tfor(int i = 0;i < n;i++){\n\t\trz[i][0] = find(z.begin(),z.end(),c[i])-z.begin();\n\t\trz[i][1] = find(z.begin(),z.end(),f[i])-z.begin();\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d %d %d %d %d\",&a[i],&b[i],&c[i],&d[i],&e[i],&f[i]);\n\t\tx.push_back(a[i]);\n       x.push_back(d[i]);\n       y.push_back(b[i]);\n       y.push_back(e[i]);\n       z.push_back(c[i]);\n       z.push_back(f[i]);\n\t}\n\tcompress1();\n\tcompress2();\n\tcompress3();\n\tfor(int i = 0;i < n;i++){\n\tfor(int tx=rx[i][0];tx<rx[i][1];tx++)\n    {\n      for(int ty=ry[i][0];ty<ry[i][1];ty++)\n        {\n          for(int tz=rz[i][0];tz<rz[i][1];tz++)\n        {\n          coun[tx][ty][tz]++;\n        }\n        }\n    }\n\t}\n  long long ans=0;\n  for(int i=0;i<=100;i++)\n    {\n      for(int j=0;j<=100;j++)\n    {\n      for(int k=0;k<=100;k++)\n        {\n          if(coun[i][j][k]>=m)\n        {\n          long long s1=(x[i+1]-x[i]),s2=(y[j+1]-y[j]),s3=(z[k+1]-z[k]);\n          ans+=s1*s2*s3;\n        }\n        }\n    }\n    }\n\t//long long ans = 0;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\nint N,K;\nint MAXW,MAXH,MAXD;\nint W=1e6,H=1e6,D=1e6;\nint X1[55],Y1[55],Z1[55],X2[55],Y2[55],Z2[55];\nshort fld[55*6][55*6][55*6];\nint dx[] = {0,0,0,0,1,-1};\nint dy[] = {1,-1,0,0,0,0,};\nint dz[] = {0,0,0,0,1,-1};\nint ans;\nvector<int> xs;\n\n\nstruct P{\n    int x;\n    int y;\n    int z;\n    P(){}\n    P(int p1,int p2,int p3){\n        x=p1;\n        y=p2;\n        z=p3;\n    }\n};\n\n\nint compress(int* x1,int* x2,int w){\n    xs.clear();\n    for(int i=0;i<N;++i){\n        for(int d=-1;d<=1;++d){\n            int tx1=x1[i]+d;\n            int tx2=x2[i]+d;\n            if(0<=tx1&&tx1<w)xs.PB(tx1);\n            if(0<=tx2&&tx2<w)xs.PB(tx2);\n        }\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    return xs.size();\n}\n\nvoid bfs(int sx,int sy,int sz){\n    queue<P> que;\n    que.push(P(sx,sy,sz));\n    if(fld[sz][sy][sx]>=K)ans+=fld[sz][sy][sx];\n    fld[sz][sy][sx]=0;\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        int x = p.x;\n        int y = p.y;\n        int z = p.z;\n        for(int i=0;i<6;++i){\n            int nx=x+dx[i];\n            int ny=y+dy[i];\n            int nz=z+dz[i];\n            if(nx<0||nx>=W||ny<0||ny>=H||nz<0||nz>=D)continue;\n            if(fld[nz][ny][nx]==-1)continue;\n            que.push(P(nx,ny,nz));\n            if(fld[nz][ny][nx]>=K)ans+=fld[nz][ny][nx];\n            fld[nz][ny][nx]=-1;\n        }\n    }\n}\n\n\nsigned main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i){\n        cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n        MAXW=max(MAXW,X2[i]-X1[i]);\n        MAXH=max(MAXH,Y2[i]-Y1[i]);\n        MAXD=max(MAXD,Z2[i]-Z1[i]);\n    }\n    W = compress(X1,X2,W);\n    H = compress(Y1,Y2,H);\n    D = compress(Z1,Z2,D);\n    //cout<<W<<\" \"<<H<<\" \"<<D<<endl;\n    for(int i=0;i<N;++i){\n        for(int z=Z1[i];z<Z2[i];++z){\n            for(int y=Y1[i];y<Y2[i];++y){\n                for(int x=X1[i];x<X2[i];++x){\n                    fld[z][y][x]++;\n                }\n            }\n        }\n    }\n    for(int z=0;z<D;++z){\n        for(int y=0;y<H;++y){\n            for(int x=0;x<W;++x){\n                bfs(x,y,z);\n            }\n        }\n    }\n    //cout<<ans<<endl;\n    cout<<ans*MAXW/W*MAXH/H*MAXD/D<<endl;\n    memset(fld,0,sizeof(fld));\n    ans=0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long Int;\n#define MAX_N 60\n\nint N, K;\nInt X1[MAX_N], Y1[MAX_N], Z1[MAX_N];\nInt X2[MAX_N], Y2[MAX_N], Z2[MAX_N];\n\nint xsLen, ysLen, zsLen;\nInt xs[MAX_N * 2], ys[MAX_N * 2], zs[MAX_N * 2];\n\nint main() {\n\tint i;\n\tint a, b, c;\n\n\tscanf(\"%d%d\", &N, &K);\n\tfor (i = 0; i < N; ++i) {\n\t\tscanf(\"%lld%lld%lld\", &X1[i], &Y1[i], &Z1[i]);\n\t\tscanf(\"%lld%lld%lld\", &X2[i], &Y2[i], &Z2[i]);\n\t}\n\n\txsLen = ysLen = zsLen = 0;\n\tfor (i = 0; i < N; ++i) {\n\t\txs[xsLen++] = X1[i]; ys[ysLen++] = Y1[i]; zs[zsLen++] = Z1[i];\n\t\txs[xsLen++] = X2[i]; ys[ysLen++] = Y2[i]; zs[zsLen++] = Z2[i];\n\t}\n\tsort(xs, xs + xsLen); sort(ys, ys + ysLen); sort(zs, zs + zsLen);\n\n\tInt ans = 0;\n\tfor (a = 0; a < xsLen - 1; ++a)\n\t\tfor (b = 0; b < ysLen - 1; ++b)\n\t\t\tfor (c = 0; c < zsLen - 1; ++c)\n\t\t\t{\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (i = 0; i < N; ++i) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tX1[i] <= xs[a] && xs[a + 1] <= X2[i] &&\n\t\t\t\t\t\tY1[i] <= ys[b] && ys[b + 1] <= Y2[i] &&\n\t\t\t\t\t\tZ1[i] <= zs[c] && zs[c + 1] <= Z2[i]\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt >= K) {\n\t\t\t\t\tans += (xs[a + 1] - xs[a]) * (ys[b + 1] - ys[b]) * (zs[c + 1] - zs[c]);\n\t\t\t\t}\n\t\t\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint fld[101][101][101];\nint N,K;\n\nvoid unq(vector<int> &px,int vx[]){\n    for(int i=0;i<px.size();){\n        if(i+1<px.size() && px[i]==px[i+1]){\n            px.erase(px.begin()+i);\n        }\n        else{\n            vx[i]=px[i+1]-px[i];\n            i++;\n        }\n    }\n    return;\n}\n\nint compress(int x[][2],int vx[]){\n    vector<int> px;\n    for(int i=0;i<N;i++)for(int j=0;j<2;j++) px.push_back(x[i][j]);\n    sort(px.begin(),px.end());\n    unq(px,vx);\n    for(int i=0;i<N;i++){\n        for(int j=0;j<2;j++){\n            x[i][j] = find(px.begin(),px.end(),x[i][j])-px.begin();\n        }\n    }\n    //for(int i=0;i<px.size()-1;i++) printf(\"%d \",vx[i]); puts(\"\");\n    return px.size()-1;\n}\n\nint main(){\n    int X[50][2],Y[50][2],Z[50][2],vX[101]={},vY[101]={},vZ[101]={};\n    cin>>N>>K;\n    for(int i=0;i<N;i++){\n        for(int j=0;j<2;j++){\n            cin>>X[i][j]>>Y[i][j]>>Z[i][j];\n        }\n        //X[i][1]--; Y[i][1]--; Z[i][1]--;\n    }\n\n    int maxX=0,maxY=0,maxZ=0;\n    maxX=compress(X,vX); maxY=compress(Y,vY); maxZ=compress(Z,vZ);\n    //printf(\"%d,%d,%d\\n\",maxX,maxY,maxZ);\n    for(int i=0;i<N;i++){\n        for(int j=X[i][0];j<X[i][1];j++){\n            for(int k=Y[i][0];k<Y[i][1];k++){\n                for(int l=Z[i][0];l<Z[i][1];l++){\n                    fld[j][k][l]++;\n                }\n            }\n        }\n    }\n\n    long long ans=0;\n    for(int i=0;i<maxX;i++){\n        for(int j=0;j<maxY;j++){\n            for(int k=0;k<maxZ;k++){\n                if(fld[i][j][k]>=K){\n                    //printf(\"%d\\n\",ans);\n                    //printf(\"%d: %d,%d,%d\\n\",fld[i][j][k],vX[i],vY[j],vZ[k]);\n                    ans += ((long long)vX[i]*(long long)vY[j]*(long long)vZ[k]);\n                }\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n\n    /*int vx[10]={},in;\n    vector<int> px;\n    for(int i=0;i<10;i++) cin>>in,px.push_back(in);\n    unq(px,vx);\n    for(int i=0;i<px.size();i++) printf(\"%d \",px[i]); puts(\"\");\n    for(int i=0;i<10;i++) printf(\"%d \",vx[i]); puts(\"\");*/\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct AREA\n{\n\tint x1, y1, z1, x2, y2, z2;\n};\nint main(void)\n{\n\tlong long N, K,i,j,x[101],y[101],z[101],xx,yy,zz,m,h,cnt=0;\n\tAREA barea[51];\n\tlong long sum = 0;\n\tscanf(\"%lld%lld\", &N, &K);\n\tfor (i = 0; i <2*N; i++)\n\t{\n\t\tscanf(\"%lld %lld %lld\", &x[i], &y[i], &z[i]);\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\tbarea[i / 2].x1 = x[i];\n\t\t\tbarea[i / 2].y1 = y[i];\n\t\t\tbarea[i / 2].z1 = z[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbarea[i / 2].x2 = x[i];\n\t\t\tbarea[i / 2].y2 = y[i];\n\t\t\tbarea[i / 2].z2 = z[i];\n\t\t}\n\t}\n\n\tfor (i = 0; i < 2*N-1; i++)\n\t{\n\t\tfor (j = i + 1; j < 2*N; j++)\n\t\t{\n\t\t\tif (x[i] > x[j])\n\t\t\t{\n\t\t\t\txx = x[i];\n\t\t\t\tx[i] = x[j];\n\t\t\t\tx[j] = xx;\n\t\t\t}\n\t\t\tif (y[i] > y[j])\n\t\t\t{\n\t\t\t\tyy = y[i];\n\t\t\t\ty[i] = y[j];\n\t\t\t\ty[j] = yy;\n\t\t\t}\n\t\t\tif (z[i] > z[j])\n\t\t\t{\n\t\t\t\tzz = z[i];\n\t\t\t\tz[i] = z[j];\n\t\t\t\tz[j] = zz;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < 2 * N-1; i++)\n\t{\n\t\tfor (j = 0; j < 2 * N-1; j++)\n\t\t{\n\t\t\tfor (m = 0; m < 2 * N-1; m++)\n\t\t\t{\n\t\t\t\tfor (h = 0; h < N; h++)\n\t\t\t\t{\n\t\t\t\t\tif(barea[h].x1<=x[i]&&x[i+1]<=barea[h].x2&&barea[h].y1 <= y[j] && y[j + 1] <= barea[h].y2&&barea[h].z1 <= z[m] && z[m + 1] <= barea[h].z2)\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif (K <= cnt)\n\t\t\t\t{\n\t\t\t\n\t\t\t\t\tsum = sum + (x[i + 1] - x[i])*(y[j + 1] - y[j])*(z[m + 1] - z[m]);\n\t\t\t\t}\n\t\t\t\t//printf(\"%d*%d*%d=%lld\\n\", x[i + 1] - x[i], y[j + 1] - y[j], z[m + 1] - z[m], sum);\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\ntypedef long long ll;\n\nusing namespace std;\n\n\nint main(){\n    ll z[3][100],n,K,in[50][6],c;\n    ll ans=0;\n    \n    scanf(\"%lld%lld\",&n,&K);\n    \n    for(int i=0;i<n;i++){\n        for(int j=0;j<6;j++){\n            scanf(\"%lld\",&in[i][j]);\n            z[j%3][i*2+(j/3)]=in[i][j];\n        }\n    }\n    \n    for(int i=0;i<3;i++)\n        sort(z[i],z[i]+n*2);\n    \n    for(int i=0;i<n*2-1;i++)\n        for(int j=0;j<n*2-1;j++)\n            for(int k=0;k<2*n-1;k++){\n                c=0;\n                for(int l=0;l<n;l++){\n                        c+=(in[l][0]<=z[0][i] && z[0][i+1]<=in[l][3] &&\n                            in[l][1]<=z[1][j] && z[1][j+1]<=in[l][4] &&\n                            in[l][2]<=z[2][k] && z[2][k+1]<=in[l][5]\n                            );\n                }\n                if(c>=K){\n                    ans+=(z[0][i+1]-z[0][i])*(z[1][j+1]-z[1][j])*(z[2][k+1]-z[2][k]);\n                }\n            }\n    \n    printf(\"%lld\\n\",ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\n\nint N,K;\nint W,H,D;\nint X1[55],Y1[55],Z1[55],X2[55],Y2[55],Z2[55];\nint cx1[55],cy1[55],cz1[55],cx2[55],cy2[55],cz2[55];\nvector<int> X,Y,Z;\nsigned fld[55*6][55*6][55*6];\n\nint ans;\nvector<int> xs;\n\nvoid compress(vector<int> &X,int* x1,int* x2,int* vx1,int* vx2,int w,int* P){\n    xs.clear();\n    for(int i=0;i<N;++i){\n        x1[i]=vx1[i];\n        x2[i]=vx2[i];\n    }\n    for(int i=0;i<N;++i){\n        for(int d=-1;d<=1;++d){\n            int tx1=x1[i]+d;\n            int tx2=x2[i]+d;\n            if(0<=tx1&&tx1<=w)xs.PB(tx1);\n            if(0<=tx2&&tx2<=w)xs.PB(tx2);\n        }\n    }\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    for(int i=0;i<N;++i){\n        x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n    }\n    //for(int i=0;i<xs.size();++i)cout<<xs[i]<<endl;\n    for(int i=0;i<xs.size();++i){\n        X.PB(xs[i+1]-xs[i]);\n    }\n    *P = xs.size();\n}\n\nint main(){\n    cin>>N>>K;\n    for(int i=0;i<N;++i)cin>>X1[i]>>Y1[i]>>Z1[i]>>X2[i]>>Y2[i]>>Z2[i];\n    compress(X,cx1,cx2,X1,X2,1000000,&W);\n    compress(Y,cy1,cy2,Y1,Y2,1000000,&H);\n    compress(Z,cz1,cz2,Z1,Z2,1000000,&D);\n    for(int i=0;i<N;++i){\n        for(int z=cz1[i];z<cz2[i];++z){\n            for(int y=cy1[i];y<cy2[i];++y){\n                for(int x=cx1[i];x<cx2[i];++x){\n                    fld[z][y][x]++;\n                }\n            }\n        }\n    }\n    for(int z=0;z<=D;++z){\n        for(int y=0;y<=H;++y){\n            for(int x=0;x<=W;++x){\n                if(fld[z][y][x]>=K)ans+=X[x]*Y[y]*Z[z];\n            }\n        }\n    }\n\n    //cout<<W<<\" \"<<H<<\" \"<<D<<endl;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\ntypedef long long ll;\n\nusing namespace std;\n\n\nint main(){\n    ll z[3][100],n,K,in[50][6],c;\n    ll ans=0;\n    \n    scanf(\"%lld%lld\",&n,&K);\n    \n    for(int i=0;i<n;i++){\n        for(int j=0;j<6;j++){\n            scanf(\"%lld\",&in[i][j]);\n            z[j%3][i*2+(j/3)]=in[i][j];\n        }\n    }\n    \n    for(int i=0;i<3;i++)\n        sort(z[i],z[i]+n*2);\n    \n    for(int i=0;i<n*2-1;i++)\n        for(int j=0;j<n*2-1;j++)\n            for(int k=0;k<2*n-1;k++){\n                c=0;\n                for(int l=0;l<n;l++){\n                        c+=(in[l][0]<=z[0][i] && z[0][i+1]<=in[l][3] &&\n                            in[l][1]<=z[1][j] && z[1][j+1]<=in[l][4] &&\n                            in[l][2]<=z[2][k] && z[2][k+1]<=in[l][5]\n                            );\n                }\n                if(c>=K){\n                    ans+=(z[0][i+1]-z[0][i])*(z[1][j+1]-z[1][j])*(z[2][k+1]-z[2][k]);\n                }\n            }\n    \n    printf(\"%lld\",ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0580: Fish\n// 2017.10.25 bal4u@uu\n// ???????????????????????±?????¨?????????????¨????\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX  52\n#define MAX2 104\n\ntypedef struct { int x1, y1, d1, x2, y2, d2; } PP;\nPP p[MAX];\nint x[MAX2], y[MAX2], d[MAX2], sz;\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint main()\n{\n\tint n, k, i, xx, yy, dd, c;\n\tlong long ans;\n\n\tscanf(\"%d%d\", &n, &k);\n\tfor (sz = 0, i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%d%d%d%d\", &p[i].x1, &p[i].y1, &p[i].d1, &p[i].x2, &p[i].y2, &p[i].d2);\n\t\tx[sz] = p[i].x1, x[sz+1] = p[i].x2;\n\t\ty[sz] = p[i].y1, y[sz+1] = p[i].y2;\n\t\td[sz] = p[i].d1, d[sz+1] = p[i].d2;\n\t\tsz += 2;\n\t}\n\tqsort(x, sz, sizeof(int), cmp);\n\tqsort(y, sz, sizeof(int), cmp);\n\tqsort(d, sz, sizeof(int), cmp);\n\n\tans = 0;\n\tfor (xx = 1; xx < sz; xx++) for (yy = 1; yy < sz; yy++) for (dd = 1; dd < sz; dd++) {\n\t\tc = 0;\n\t\tfor (i = 0; i < n; i++) {\n          if (p[i].x1 <= x[xx-1] && x[xx] <= p[i].x2 &&\n              p[i].y1 <= y[yy-1] && y[yy] <= p[i].y2 &&\n              p[i].d1 <= d[dd-1] && d[dd] <= p[i].d2) c++;\n        }\n        if (c >= k) ans += (long long)(x[xx]-x[xx-1]) * (y[yy]-y[yy-1]) * (d[dd]-d[dd-1]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint comp( const void *c1, const void *c2 )\n{\n  int tmp1 = *(int *)c1;\n  int tmp2 = *(int *)c2;\n\n  if( tmp1 < tmp2 )  return -1;\n  if( tmp1 == tmp2 ) return  0;\n  if( tmp1 > tmp2 )  return  1;\n}\n\ntypedef struct{\n\tint position;\n\tint label;\n} grid_index;\n\nint main(void){\n\tFILE *fp;\n\tfp = fopen(\"input.txt\",\"r\");\n\tint N, K;\n\tint ret;\n\tint i,p[3]={0},j=0,k=0,l=0;\n\tlong int x1,x2,y1,y2,d1,d2;\n\tlong int x1_index,x2_index,y1_index,y2_index,d1_index,d2_index;\n\tlong long int V=0;\n\tlong int x_begin,y_begin,d_begin,x_end,y_end,d_end;\n\tscanf(\"%d %d\", &N, &K);\n\tint data[6][N];\n\tfor(i=0; i<N; i++){\n\t\tscanf(\"%ld %ld %ld %ld %ld %ld\", &x1,&y1,&d1,&x2,&y2,&d2);\n\t\tdata[0][i] = x1;\n\t\tdata[1][i] = y1;\n\t\tdata[2][i] = d1;\n\t\tdata[3][i] = x2;\n\t\tdata[4][i] = y2;\n\t\tdata[5][i] = d2;\n\t}\n\tint tmp[2*N];\n\n\tfor(i=0; i<N; i++){\n\t\ttmp[i] = data[0][i];\n\t\ttmp[i+N] = data[3][i];\n\t}\n\tqsort(tmp,2*N,sizeof(int),comp);\n\tfor(i=0; i<N; i++){\n\t\tif(tmp[i] == tmp[i+1]){\n\t\t\tp[0]++;\n\t\t}\n\t}\n\tint gridx[2*N-p[0]];\n\tfor(i=0; i<2*N; i++){\n\t\tif(tmp[i] != tmp[i+1]){\n\t\t\tgridx[j] = tmp[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tj=0;\n\tfor(i=0; i<N; i++){\n\t\ttmp[i] = data[1][i];\n\t\ttmp[i+N] = data[4][i];\n\t}\n\tqsort(tmp,2*N,sizeof(int),comp);\n\tfor(i=0; i<2*N; i++){\n\t\tif(tmp[i] == tmp[i+1]){\n\t\t\tp[1]++;\n\t\t}\n\t}\n\tint gridy[2*N-p[1]];\n\tfor(i=0; i<2*N; i++){\n\t\tif(tmp[i] != tmp[i+1]){\n\t\t\tgridy[j] = tmp[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tj=0;\n\tfor(i=0; i<N; i++){\n\t\ttmp[i] = data[2][i];\n\t\ttmp[i+N] = data[5][i];\n\t}\n\tqsort(tmp,2*N,sizeof(int),comp);\n\tfor(i=0; i<N; i++){\n\t\tif(tmp[i] == tmp[i+1]){\n\t\t\tp[2]++;\n\t\t}\n\t}\n\tint gridd[2*N-p[2]];\n\tfor(i=0; i<2*N; i++){\n\t\tif(tmp[i] != tmp[i+1]){\n\t\t\tgridd[j] = tmp[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tgrid_index gx[2*N-p[0]];\n\tgrid_index gy[2*N-p[1]];\n\tgrid_index gd[2*N-p[2]];\n\tfor(i=0; i<2*N-p[0];i++){\n\t\tgx[i].label = i;\n\t\tgx[i].position = gridx[i];\n\t}\n\tfor(i=0; i<2*N-p[1];i++){\n\t\tgy[i].label = i;\n\t\tgy[i].position = gridy[i];\n\t}\n\tfor(i=0; i<2*N-p[2];i++){\n\t\tgd[i].label = i;\n\t\tgd[i].position = gridd[i];\n\t}\n\n\tint fish_dist[2*N-p[0]][2*N-p[1]][2*N-p[2]];\n\tfor(i=0; i<2*N-p[0];i++){\n\t\tfor(j=0; j<2*N-p[1];j++){\n\t\t\tfor(k=0; k<2*N-p[2];k++){\n\t\t\t\tfish_dist[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(i=0; i<N; i++){\n\t\tfor(j=0; j<2*N-p[0]; j++){\n\t\t\tif(data[0][i] == gx[j].position) {\n\t\t\t\tx1_index = gx[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[0];j++){\n\t\t\tif(data[3][i] == gx[j].position) {\n\t\t\t\tx2_index = gx[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[1];j++){\n\t\t\tif(data[1][i] == gy[j].position) {\n\t\t\t\ty1_index = gy[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[1];j++){\n\t\t\tif(data[4][i] == gy[j].position) {\n\t\t\t\ty2_index = gy[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[2];j++){\n\t\t\tif(data[2][i] == gd[j].position) {\n\t\t\t\td1_index = gd[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[2];j++){\n\t\t\tif(data[5][i] == gd[j].position) {\n\t\t\t\td2_index = gd[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(l=x1_index; l<x2_index; l++){\n\t\t\tfor(j=y1_index; j<y2_index; j++){\n\t\t\t\tfor(k=d1_index; k<d2_index; k++){\n\t\t\t\t\tfish_dist[l][j][k] += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=0; i<2*N-p[0]; i++){\n\t\tfor(j=0; j<2*N-p[1]; j++){\n\t\t\tfor(k=0; k<2*N-p[2]; k++){\n\t\t\t\tif(fish_dist[i][j][k] >= K){\n\t\t\t\t\tx_begin = gridx[i];\n\t\t\t\t\ty_begin = gridy[j];\n\t\t\t\t\td_begin = gridd[k];\n\t\t\t\t\tx_end = gridx[i+1];\n\t\t\t\t\ty_end = gridy[j+1];\n\t\t\t\t\td_end = gridd[k+1];\n\t\t\t\t\tV += (x_end - x_begin) * (y_end - y_begin) * (d_end - d_begin);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Volume : %lld\\n\",V);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0580: Fish\n// 2017.10.25 bal4u@uu\n// ???????????????????????±?????¨?????????????¨????\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX  52\n#define MAX2 104\n\ntypedef struct { int x1, y1, d1, x2, y2, d2; } PP;\nPP p[MAX];\nint x[MAX2], y[MAX2], d[MAX2], sz, xs, ys, ds;\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint uniq(int *a, int n)\n{\n\tint i, j;\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\twhile (j < n && a[j] == a[i]) j++;\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint main()\n{\n\tint n, k, i, xx, yy, dd, c;\n\tlong long ans;\n\n\tscanf(\"%d%d\", &n, &k);\n\tfor (sz = 0, i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%d%d%d%d\", &p[i].x1, &p[i].y1, &p[i].d1, &p[i].x2, &p[i].y2, &p[i].d2);\n\t\tx[sz] = p[i].x1, x[sz+1] = p[i].x2;\n\t\ty[sz] = p[i].y1, y[sz+1] = p[i].y2;\n\t\td[sz] = p[i].d1, d[sz+1] = p[i].d2;\n\t\tsz += 2;\n\t}\n\tqsort(x, sz, sizeof(int), cmp), xs = uniq(x, sz);\n\tqsort(y, sz, sizeof(int), cmp), ys = uniq(y, sz);\n\tqsort(d, sz, sizeof(int), cmp), ds = uniq(d, sz);\n\n\tans = 0;\n\tfor (xx = 1; xx < xs; xx++) for (yy = 1; yy < ys; yy++) for (dd = 1; dd < ds; dd++) {\n\t\tc = 0;\n\t\tfor (i = 0; i < n; i++) {\n          if (p[i].x1 <= x[xx-1] && x[xx] <= p[i].x2 &&\n              p[i].y1 <= y[yy-1] && y[yy] <= p[i].y2 &&\n              p[i].d1 <= d[dd-1] && d[dd] <= p[i].d2) c++;\n        }\n        if (c >= k) ans += (long long)(x[xx]-x[xx-1]) * (y[yy]-y[yy-1]) * (d[dd]-d[dd-1]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint comp( const void *c1, const void *c2 )\n{\n  int tmp1 = *(int *)c1;\n  int tmp2 = *(int *)c2;\n\n  if( tmp1 < tmp2 )  return -1;\n  if( tmp1 == tmp2 ) return  0;\n  if( tmp1 > tmp2 )  return  1;\n}\n\ntypedef struct{\n\tint position;\n\tint label;\n} grid_index;\n\nint main(void){\n\tFILE *fp;\n\tfp = fopen(\"input.txt\",\"r\");\n\tint N, K;\n\tint ret;\n\tint i,p[3]={0},j=0,k=0,l=0;\n\tlong int x1,x2,y1,y2,d1,d2;\n\tlong int x1_index,x2_index,y1_index,y2_index,d1_index,d2_index;\n\tlong long int V=0;\n\tlong int x_begin,y_begin,d_begin,x_end,y_end,d_end;\n\tscanf(\"%d %d\", &N, &K);\n\tint data[6][N];\n\tfor(i=0; i<N; i++){\n\t\tscanf(\"%ld %ld %ld %ld %ld %ld\", &x1,&y1,&d1,&x2,&y2,&d2);\n\t\tdata[0][i] = x1;\n\t\tdata[1][i] = y1;\n\t\tdata[2][i] = d1;\n\t\tdata[3][i] = x2;\n\t\tdata[4][i] = y2;\n\t\tdata[5][i] = d2;\n\t}\n\tint tmp[2*N];\n\n\tfor(i=0; i<N; i++){\n\t\ttmp[i] = data[0][i];\n\t\ttmp[i+N] = data[3][i];\n\t}\n\tqsort(tmp,2*N,sizeof(int),comp);\n\tfor(i=0; i<N; i++){\n\t\tif(tmp[i] == tmp[i+1]){\n\t\t\tp[0]++;\n\t\t}\n\t}\n\tint gridx[2*N-p[0]];\n\tfor(i=0; i<2*N; i++){\n\t\tif(tmp[i] != tmp[i+1]){\n\t\t\tgridx[j] = tmp[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tj=0;\n\tfor(i=0; i<N; i++){\n\t\ttmp[i] = data[1][i];\n\t\ttmp[i+N] = data[4][i];\n\t}\n\tqsort(tmp,2*N,sizeof(int),comp);\n\tfor(i=0; i<2*N; i++){\n\t\tif(tmp[i] == tmp[i+1]){\n\t\t\tp[1]++;\n\t\t}\n\t}\n\tint gridy[2*N-p[1]];\n\tfor(i=0; i<2*N; i++){\n\t\tif(tmp[i] != tmp[i+1]){\n\t\t\tgridy[j] = tmp[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tj=0;\n\tfor(i=0; i<N; i++){\n\t\ttmp[i] = data[2][i];\n\t\ttmp[i+N] = data[5][i];\n\t}\n\tqsort(tmp,2*N,sizeof(int),comp);\n\tfor(i=0; i<N; i++){\n\t\tif(tmp[i] == tmp[i+1]){\n\t\t\tp[2]++;\n\t\t}\n\t}\n\tint gridd[2*N-p[2]];\n\tfor(i=0; i<2*N; i++){\n\t\tif(tmp[i] != tmp[i+1]){\n\t\t\tgridd[j] = tmp[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tgrid_index gx[2*N-p[0]];\n\tgrid_index gy[2*N-p[1]];\n\tgrid_index gd[2*N-p[2]];\n\tfor(i=0; i<2*N-p[0];i++){\n\t\tgx[i].label = i;\n\t\tgx[i].position = gridx[i];\n\t}\n\tfor(i=0; i<2*N-p[1];i++){\n\t\tgy[i].label = i;\n\t\tgy[i].position = gridy[i];\n\t}\n\tfor(i=0; i<2*N-p[2];i++){\n\t\tgd[i].label = i;\n\t\tgd[i].position = gridd[i];\n\t}\n\n\tint fish_dist[2*N-p[0]][2*N-p[1]][2*N-p[2]];\n\tfor(i=0; i<2*N-p[0];i++){\n\t\tfor(j=0; j<2*N-p[1];j++){\n\t\t\tfor(k=0; k<2*N-p[2];k++){\n\t\t\t\tfish_dist[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(i=0; i<N; i++){\n\t\tfor(j=0; j<2*N-p[0]; j++){\n\t\t\tif(data[0][i] == gx[j].position) {\n\t\t\t\tx1_index = gx[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[0];j++){\n\t\t\tif(data[3][i] == gx[j].position) {\n\t\t\t\tx2_index = gx[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[1];j++){\n\t\t\tif(data[1][i] == gy[j].position) {\n\t\t\t\ty1_index = gy[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[1];j++){\n\t\t\tif(data[4][i] == gy[j].position) {\n\t\t\t\ty2_index = gy[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[2];j++){\n\t\t\tif(data[2][i] == gd[j].position) {\n\t\t\t\td1_index = gd[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(j=0; j<2*N-p[2];j++){\n\t\t\tif(data[5][i] == gd[j].position) {\n\t\t\t\td2_index = gd[j].label;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(l=x1_index; l<x2_index; l++){\n\t\t\tfor(j=y1_index; j<y2_index; j++){\n\t\t\t\tfor(k=d1_index; k<d2_index; k++){\n\t\t\t\t\tfish_dist[l][j][k] += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=0; i<2*N-p[0]; i++){\n\t\tfor(j=0; j<2*N-p[1]; j++){\n\t\t\tfor(k=0; k<2*N-p[2]; k++){\n\t\t\t\tif(fish_dist[i][j][k] >= K){\n\t\t\t\t\tx_begin = gridx[i];\n\t\t\t\t\ty_begin = gridy[j];\n\t\t\t\t\td_begin = gridd[k];\n\t\t\t\t\tx_end = gridx[i+1];\n\t\t\t\t\ty_end = gridy[j+1];\n\t\t\t\t\td_end = gridd[k+1];\n\t\t\t\t\tV += (x_end - x_begin) * (y_end - y_begin) * (d_end - d_begin);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",V);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0580: Fish\n// 2017.10.25 bal4u@uu\n// 2017.12.6\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX  52\n#define MAX2 104\n\ntypedef struct { int x1, y1, d1, x2, y2, d2; } PP;\nPP p[MAX];\nint x[MAX2], y[MAX2], d[MAX2], sz, xs, ys, ds;\nchar map[MAX2][MAX2][MAX2];\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint uniq(int *a, int n)\n{\n\tint i, j;\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\twhile (j < n && a[j] == a[i]) j++;\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint bsch(int *a, int x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n\t\tif (a[m] == x) break;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn m;\n}\n\nint main()\n{\n\tint n, k, i, xx, yy, dd, x1, y1, x2, y2, d1, d2;\n\tlong long ans;\n\n\tscanf(\"%d%d\", &n, &k);\n\tfor (sz = 0, i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%d%d%d%d\", &p[i].x1, &p[i].y1, &p[i].d1, &p[i].x2, &p[i].y2, &p[i].d2);\n\t\tx[sz] = p[i].x1, x[sz+1] = p[i].x2;\n\t\ty[sz] = p[i].y1, y[sz+1] = p[i].y2;\n\t\td[sz] = p[i].d1, d[sz+1] = p[i].d2;\n\t\tsz += 2;\n\t}\n\tqsort(x, sz, sizeof(int), cmp), xs = uniq(x, sz);\n\tqsort(y, sz, sizeof(int), cmp), ys = uniq(y, sz);\n\tqsort(d, sz, sizeof(int), cmp), ds = uniq(d, sz);\n\n\tfor (i = 0; i < n; i++) {\n\t\tx1 = bsch(x, p[i].x1, xs), x2 = bsch(x, p[i].x2, xs);\n\t\ty1 = bsch(y, p[i].y1, ys), y2 = bsch(y, p[i].y2, ys);\n\t\td1 = bsch(d, p[i].d1, ds), d2 = bsch(d, p[i].d2, ds);\n\t\tfor (xx = x1; xx < x2; xx++) for (yy = y1; yy < y2; yy++) for (dd = d1; dd < d2; dd++)\n\t\t\tmap[xx][yy][dd]++;\n\t}\n\n\tans = 0;\n\tfor (xx = 0; xx < xs; xx++) for (yy = 0; yy < ys; yy++) for (dd = 0; dd < ds; dd++) {\n        if (map[xx][yy][dd] >= k)\n\t\t\tans += (long long)(x[xx+1]-x[xx]) * (y[yy+1]-y[yy]) * (d[dd+1]-d[dd]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nlong long s=0,n,m,i,j,k,d[3][110],r[3][110],rr[3][110],c[110][110][110],b;\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tscanf(\"%d\",&d[j][i]);\n\t\t\tfor(k=i;k&&d[j][r[j][k-1]]>d[j][i];k--)r[j][k]=r[j][k-1];\n\t\t\tr[j][k]=i;\n\t\t}\n\t}\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<3;j++)rr[j][r[j][i]]=i;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<8;j++){\n\t\t\tb=0;\n\t\t\tfor(k=j;k;k/=2)b+=k%2;\n\t\t\tc[rr[0][i*2+(j/1%2)]][rr[1][i*2+(j/2%2)]][rr[2][i*2+(j/4%2)]]=1-(b%2*2);\n\t\t}\n\t}\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<n*2;j++){\n\t\t\tfor(k=0;k<n*2;k++){\n\t\t\t\tc[i][j][k+1]+=c[i][j][k];\n\t\t\t\tc[i][k+1][j]+=c[i][k][j];\n\t\t\t\tc[k+1][i][j]+=c[k][i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<n*2;j++){\n\t\t\tfor(k=0;k<n*2;k++){\n\t\t\t\tif(c[i][j][k]>=m)s+=(d[0][r[0][i+1]]-d[0][r[0][i]])\n\t\t\t\t\t\t\t\t   *(d[1][r[1][j+1]]-d[1][r[1][j]])\n\t\t\t\t\t\t\t\t   *(d[2][r[2][k+1]]-d[2][r[2][k]]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",s);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define CP_X 0\n#define CP_Y 1\n#define CP_D 2\n\nint N,K;\nstruct {\n\tint x1,y1,d1;\n\tint x2,y2,d2;\n} fishes[50];\n\nint cp_num[3]={0,0,0};\nint cp[3][110];\n\nvoid add_cp(int id,int num) {\n\tint i,pos;\n\tfor(i=0;i<cp_num[id];i++) {\n\t\tif(cp[id][i]==num)return;\n\t\tif(cp[id][i]>num)break;\n\t}\n\tpos=i;\n\tfor(i=cp_num[id];i>pos;i--)cp[id][i]=cp[id][i-1];\n\tcp[id][pos]=num;\n\tcp_num[id]++;\n}\n\nint get_cp(int id,int num) {\n\tint left,right,mid;\n\tleft=0;right=cp_num[id]-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(cp[id][mid]==num)return mid;\n\t\telse if(cp[id][mid]<num)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn cp_num[id];\n}\n\nint imos[110][110][110];\n\nint main(void) {\n\tint i,j,k;\n\tlong long result;\n\tscanf(\"%d%d\",&N,&K);\n\tfor(i=0;i<N;i++) {\n\t\tscanf(\"%d%d%d%d%d%d\",\n\t\t\t&fishes[i].x1,&fishes[i].y1,&fishes[i].d1,\n\t\t\t&fishes[i].x2,&fishes[i].y2,&fishes[i].d2);\n\t\tadd_cp(CP_X,fishes[i].x1);\n\t\tadd_cp(CP_X,fishes[i].x2);\n\t\tadd_cp(CP_Y,fishes[i].y1);\n\t\tadd_cp(CP_Y,fishes[i].y2);\n\t\tadd_cp(CP_D,fishes[i].d1);\n\t\tadd_cp(CP_D,fishes[i].d2);\n\t}\n\tfor(i=0;i<N;i++) {\n\t\tint x1,y1,d1,x2,y2,d2;\n\t\tx1=get_cp(CP_X,fishes[i].x1);\n\t\tx2=get_cp(CP_X,fishes[i].x2);\n\t\ty1=get_cp(CP_Y,fishes[i].y1);\n\t\ty2=get_cp(CP_Y,fishes[i].y2);\n\t\td1=get_cp(CP_D,fishes[i].d1);\n\t\td2=get_cp(CP_D,fishes[i].d2);\n\t\timos[x1][y1][d1]++;\n\t\timos[x1][y2][d1]--;\n\t\timos[x2][y1][d1]--;\n\t\timos[x2][y2][d1]++;\n\t\timos[x1][y1][d2]--;\n\t\timos[x1][y2][d2]++;\n\t\timos[x2][y1][d2]++;\n\t\timos[x2][y2][d2]--;\n\t}\n\tfor(k=0;k<cp_num[CP_D];k++) {\n\t\tfor(j=0;j<cp_num[CP_Y];j++) {\n\t\t\tfor(i=1;i<cp_num[CP_X];i++) {\n\t\t\t\timos[i][j][k]+=imos[i-1][j][k];\n\t\t\t}\n\t\t}\n\t\tfor(j=1;j<cp_num[CP_Y];j++) {\n\t\t\tfor(i=0;i<cp_num[CP_X];i++) {\n\t\t\t\timos[i][j][k]+=imos[i][j-1][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(k=1;k<cp_num[CP_D];k++) {\n\t\tfor(i=0;i<cp_num[CP_X];i++) {\n\t\t\tfor(j=0;j<cp_num[CP_Y];j++) {\n\t\t\t\timos[i][j][k]+=imos[i][j][k-1];\n\t\t\t}\n\t\t}\n\t}\n\tresult=0;\n\tfor(i=0;i<cp_num[CP_X];i++) {\n\t\tfor(j=0;j<cp_num[CP_Y];j++) {\n\t\t\tfor(k=0;k<cp_num[CP_D];k++) {\n\t\t\t\tif(imos[i][j][k]>=K) {\n\t\t\t\t\tresult+=\n\t\t\t\t\t\t(long long)(cp[CP_X][i+1]-cp[CP_X][i])*\n\t\t\t\t\t\t(long long)(cp[CP_Y][j+1]-cp[CP_Y][j])*\n\t\t\t\t\t\t(long long)(cp[CP_D][k+1]-cp[CP_D][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",result);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include <stdlib.h>\nint main(void){\n    int n,k,x[2][50],y[2][50],d[2][50],a[100],b[100],c[100],i,j,h,m,z,count;\n    long long int ans=0LL,surface;\n    scanf(\"%d%d\",&n,&k);\n    for(i=0; i<n; i++){\n        scanf(\"%d%d%d%d%d%d\",&x[0][i],&y[0][i],&d[0][i],&x[1][i],&y[1][i],&d[1][i]);\n    }\n    for(i=0; i<n; i++){\n        for(j=0; j<2; j++){\n            a[i*2+j]=x[j][i];\n            b[i*2+j]=y[j][i];\n            c[i*2+j]=d[j][i];\n        }\n    }\n    n*=2;\n    for(i=0; i<n-1; i++){\n        for(j=i+1; j<n; j++){\n            if(a[i]>a[j]){\n                z = a[i];\n                a[i] = a[j];\n                a[j] = z;\n            }\n            if(b[i]>b[j]){\n                z = b[i];\n                b[i] = b[j];\n                b[j] = z;\n            }\n            if(c[i]>c[j]){\n                z = c[i];\n                c[i] = c[j];\n                c[j] = z;\n            }\n        }\n    }\n    z = n-1;\n    n/=2;\n    for(i=0; i<z; i++){\n        for(j=0; j<z; j++){\n            for(h=0; h<z; h++){\n                count=0;\n                for(m=0; m<n; m++){\n                    if(x[0][m]<=a[i] && x[1][m]>=a[i+1] && y[0][m]<=b[j] && y[1][m]>=b[j+1] && d[0][m]<=c[h] && d[1][m]>=c[h+1]){\n                        count++;\n                    }\n                }\n                if(count>=k){\n                    surface  = (a[i+1]-a[i]);\n                    surface *= (b[j+1]-b[j]);\n                    surface *= (c[h+1]-c[h]);\n                    ans += surface;\n                }\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define NMAX 50\n\nint compare(const void *a, const void *b);\nint main(void)\n{\n  int t, i, x, y, z, n, k, sz = 0, cpe[6], cps[3] = {0};\n  int fp[6][NMAX], cp[3][2*NMAX+1];\n  long long res = 0;\n  char map[2*NMAX][2*NMAX][2*NMAX] = {0};\n  scanf(\"%d%d\", &n, &k);\n  for (i = 0; i < n; i++) {\n    for (t = 0; t < 6; t++) {\n      scanf(\"%d\", &fp[t][i]);\n      cp[t%3][sz+t/3] = fp[t][i];\n    }\n    sz += 2;\n  }\n  cp[0][sz] = cp[1][sz] = cp[2][sz] = -1;\n  for (t = 0; t < 3; t++) {\n    qsort(cp[t], sz, sizeof(int), compare);\n    for (i = 0; i < sz; i++) {\n      cp[t][cps[t]++] = cp[t][i];\n      while (cp[t][cps[t]-1] == cp[t][i+1]) i++;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    for (t = 0; t < 6; t++) {\n      int mid, dir = t % 3, lo = 0, hi = cps[dir] - 1;\n      while (hi >= lo) {\n        mid = (lo + hi) / 2;\n        if (cp[dir][mid] > fp[t][i]) hi = mid - 1;\n        else if (cp[dir][mid] < fp[t][i]) lo = mid + 1;\n        else break;\n      }\n      cpe[t] = mid;\n    }\n    for (x = cpe[0]; x < cpe[3]; x++) {\n      for (y = cpe[1]; y < cpe[4]; y++) {\n        for (z = cpe[2]; z < cpe[5]; z++) {\n          map[x][y][z]++;\n        }\n      }\n    }\n  }\n  for (x = 0; x < cps[0]; x++) {\n    for (y = 0; y < cps[1]; y++) {\n      for (z = 0; z < cps[2]; z++) {\n        if (map[x][y][z] >= k) {\n          res += (long long)(cp[0][x+1] - cp[0][x]) * (cp[1][y+1] - cp[1][y]) *(cp[2][z+1] - cp[2][z]);\n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\", res);\n}\n\nint compare(const void *a, const void *b) {\n  int ta = *(int*)a, tb = *(int*)b;\n  return ta - tb;\n}\n\n"
  },
  {
    "language": "C",
    "code": "\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint n,k;\n\tint x1[50],y1[50],d1[50],x2[50],y2[50],d2[50];\n\tlong long int sum;\n\tint area[102],flg[102];\n\tint y[102],d[102];\n\tint i,j,ii,jj,wk,p,c;\n\t\n\tscanf(\"%d %d\",&n,&k);\n\t\n\tfor(i=0;i<n;i++)\t{\n\t\tscanf(\"%d %d %d %d %d %d\",&x1[i],&y1[i],&d1[i],&x2[i],&y2[i],&d2[i]);\n\t}\n\tsum=0;\n\tfor(i=0;i<n;i++)\t{\n\t\ty[i]=y1[i];\n\t\ty[i+n]=y2[i];\n\t\td[i]=d1[i];\n\t\td[i+n]=d2[i];\n\t}\n\tfor(i=0;i<n*2-1;i++)\t{\n\t\tfor(j=i+1;j<n*2;j++)\t{\n\t\t\tif(y[i]>y[j])\t{\n\t\t\t\twk=y[i];\n\t\t\t\ty[i]=y[j];\n\t\t\t\ty[j]=wk;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<n*2-1;i++)\t{\n\t\tfor(j=i+1;j<n*2;j++)\t{\n\t\t\tif(d[i]>d[j])\t{\n\t\t\t\twk=d[i];\n\t\t\t\td[i]=d[j];\n\t\t\t\td[j]=wk;\n\t\t\t}\n\t\t}\n\t}\n\tsum=0;\n\tfor(ii=0;ii<n*2;ii++)\t{\n\t\tfor(jj=0;jj<n*2;jj++)\t{\n\t\t\tp=0;\n\t\t\tfor(i=0;i<n;i++)\t{\n\t\t\t\tif(y[ii]>=y1[i] && y[ii]<y2[i] && d[jj]>=d1[i] && d[jj]<d2[i])\t{\n\t\t\t\t\tarea[p]=x1[i];\n\t\t\t\t\tflg[p]=0;\n\t\t\t\t\tarea[p+1]=x2[i];\n\t\t\t\t\tflg[p+1]=1;\n\t\t\t\t\tp+=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<p-1;i++)\t{\n\t\t\t\tfor(j=i+1;j<p;j++)\t{\n\t\t\t\t\tif(area[i]>area[j])\t{\n\t\t\t\t\t\twk=area[i];\n\t\t\t\t\t\tarea[i]=area[j];\n\t\t\t\t\t\tarea[j]=wk;\n\t\t\t\t\t\twk=flg[i];\n\t\t\t\t\t\tflg[i]=flg[j];\n\t\t\t\t\t\tflg[j]=wk;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tc=0;\n\t\t\tfor(i=0;i<p-1;i++)\t{\n\t\t\t\tif(flg[i]==0)\tc++;\n\t\t\t\tif(flg[i]==1)\tc--;\n\t\t\t\tif(c>=k)\t{\n\t\t\t\t\tsum+=(long long int)(area[i+1]-area[i])*(y[ii+1]-y[ii])*(d[jj+1]-d[jj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n\nlong long X[ 100 ][ 2 ] ,x[ 100 ] ;\nlong long Y[ 100 ][ 2 ] ,y[ 100 ] ;\nlong long Z[ 100 ][ 2 ] ,z[ 100 ] ;\n\nint i ,j ,k ,l ;\n\n\nint cmp( const void *a ,const void *b )\n{\n\treturn *( int* )a - *( int* )b ;\n}\n\nvoid sort( long long *a ,int size )\n{\n\tqsort( a ,size ,sizeof( long long ) ,cmp ) ;\n}\n\nint check()\n{\n\tif(\n\t\t\tX[ l ][ 0 ] > x[ i ] || X[ l ][ 1 ] < x[ i + 1 ] ||\n\t\t\tY[ l ][ 0 ] > y[ j ] || Y[ l ][ 1 ] < y[ j + 1 ] ||\n\t\t\tZ[ l ][ 0 ] > z[ k ] || Z[ l ][ 1 ] < z[ k + 1 ]\n\t)\n\t{\n\t\treturn 1 ;\n\t}\n\n\treturn 0 ;\n}\n\nint main( void )\n{\n\tint N ,K ;\n\tscanf( \"%d %d\" ,&N ,&K ) ;\n\n\tN *= 2 ;\n\n\t--K ;\n\n\tint n = N - 1 ;\n\n\tfor( i = 0 ; i < N ; ++i )\n\t{\n\t\tscanf( \"%lld %lld %lld\" ,x + i ,y + i ,z + i ) ;\n\n\t\tX[ i / 2 ][ i % 2 ] = x[ i ] ;\n\t\tY[ i / 2 ][ i % 2 ] = y[ i ] ;\n\t\tZ[ i / 2 ][ i % 2 ] = z[ i ] ;\n\t}\n\n\tsort( x ,N ) ;\n\tsort( y ,N ) ;\n\tsort( z ,N ) ;\n\n\tlong long ans = 0 ;\n\tfor( i = 0 ; i < n ; ++i )\n\t{\n\t\tfor( j = 0 ; j < n ; ++j )\n\t\t{\n\t\t\tfor( k = 0 ; k < n ; ++k )\n\t\t\t{\n\t\t\t\tint cnt = 0 ;\n\n\t\t\t\tfor( l = 0 ; l < N ; ++l )\n\t\t\t\t{\n\t\t\t\t\tif( check() == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\t++cnt ;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( cnt > K )\n\t\t\t\t{\n\t\t\t\t\tans += ( x[ i + 1 ] - x[ i ] ) * ( y[ j + 1 ] - y[ j ] ) * ( z[ k + 1 ] - z[ k ] ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprintf( \"%lld\\n\" ,ans ) ;\n\n\treturn 0 ;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n\nlong long X[ 100 ][ 2 ] ,x[ 100 ] ;\nlong long Y[ 100 ][ 2 ] ,y[ 100 ] ;\nlong long Z[ 100 ][ 2 ] ,z[ 100 ] ;\n\nint i ,j ,k ,l ;\n\nvoid sort( long long *a ,int size )\n{\n\tqsort( a ,size ,sizeof( long long ) ,[]( const void *a ,const void *b ){ return *( int* )a - *( int* )b ; } ) ;\n}\n\nint check()\n{\n\tif(\n\t\t\tX[ l ][ 0 ] > x[ i ] || X[ l ][ 1 ] < x[ i + 1 ] ||\n\t\t\tY[ l ][ 0 ] > y[ j ] || Y[ l ][ 1 ] < y[ j + 1 ] ||\n\t\t\tZ[ l ][ 0 ] > z[ k ] || Z[ l ][ 1 ] < z[ k + 1 ]\n\t)\n\t{\n\t\treturn 1 ;\n\t}\n\n\treturn 0 ;\n}\n\nint main( void )\n{\n\tint N ,K ;\n\tscanf( \"%d %d\" ,&N ,&K ) ;\n\n\tN *= 2 ;\n\n\t--K ;\n\n\tint n = N - 1 ;\n\n\tfor( i = 0 ; i < N ; ++i )\n\t{\n\t\tscanf( \"%lld %lld %lld\" ,x + i ,y + i ,z + i ) ;\n\n\t\tX[ i / 2 ][ i % 2 ] = x[ i ] ;\n\t\tY[ i / 2 ][ i % 2 ] = y[ i ] ;\n\t\tZ[ i / 2 ][ i % 2 ] = z[ i ] ;\n\t}\n\n\tsort( x ,N ) ;\n\tsort( y ,N ) ;\n\tsort( z ,N ) ;\n\n\tlong long ans = 0 ;\n\tfor( i = 0 ; i < n ; ++i )\n\t{\n\t\tfor( j = 0 ; j < n ; ++j )\n\t\t{\n\t\t\tfor( k = 0 ; k < n ; ++k )\n\t\t\t{\n\t\t\t\tint cnt = 0 ;\n\n\t\t\t\tfor( l = 0 ; l < N ; ++l )\n\t\t\t\t{\n\t\t\t\t\tif( check() == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\t++cnt ;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( cnt > K )\n\t\t\t\t{\n\t\t\t\t\tans += ( x[ i + 1 ] - x[ i ] ) * ( y[ j + 1 ] - y[ j ] ) * ( z[ k + 1 ] - z[ k ] ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprintf( \"%lld\\n\" ,ans ) ;\n\n\treturn 0 ;\n}"
  },
  {
    "language": "C",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n#define MAX(x,y) ((x>y)?x:y)\n\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nint x[105],y[105],d[105];\nint sx[105],sy[105],sd[105];\nint c[105][105][105];\nint main(){\n\tint i,j,k,l,n,K;\n\tint xn,yn,dn;\n\tlong long ans;\n\t\n\tscanf(\"%d%d\",&n,&K);\n\tfor(i=0;i<n;i++)scanf(\"%d%d%d%d%d%d\",&x[i*2],&y[i*2],&d[i*2],&x[i*2+1],&y[i*2+1],&d[i*2+1]);\n\tmemcpy(sx,x,sizeof(int)*n*2);\n\tmemcpy(sy,y,sizeof(int)*n*2);\n\tmemcpy(sd,d,sizeof(int)*n*2);\n\t\n\tqsort(sx,n*2,sizeof(int),comp);\n\tqsort(sy,n*2,sizeof(int),comp);\n\tqsort(sd,n*2,sizeof(int),comp);\n\t\n\txn=yn=dn=1;\n\tfor(i=1;i<n*2;i++)if(sx[i]!=sx[i-1])sx[xn++]=sx[i];\n\tfor(i=1;i<n*2;i++)if(sy[i]!=sy[i-1])sy[yn++]=sy[i];\n\tfor(i=1;i<n*2;i++)if(sd[i]!=sd[i-1])sd[dn++]=sd[i];\n\t/*\n\tfor(i=0;i<xn;i++)printf(\"%3d \",sx[i]);printf(\"\\n\");\n\tfor(i=0;i<yn;i++)printf(\"%3d \",sy[i]);printf(\"\\n\");\n\tfor(i=0;i<dn;i++)printf(\"%3d \",sd[i]);printf(\"\\n\");\n\t*/\n\tmemset(c,0,sizeof(c));\n\tfor(i=0;i<n*2;i++){\n\t\tx[i]=lower_bound(sx,sx+xn,x[i])-sx;\n\t\ty[i]=lower_bound(sy,sy+yn,y[i])-sy;\n\t\td[i]=lower_bound(sd,sd+dn,d[i])-sd;\n\t\t//printf(\"%d %d %d\\n\",x[i],y[i],d[i]);\n\t\tif(i%2==1){\n\t\t\tfor(j=x[i-1];j<x[i];j++)\n\t\t\t\tfor(k=y[i-1];k<y[i];k++)\n\t\t\t\t\tfor(l=d[i-1];l<d[i];l++)c[j][k][l]++;\n\t\t}\n\t}\n\tans=0;\n\tfor(i=0;i<xn-1;i++)for(j=0;j<yn-1;j++)for(k=0;k<dn-1;k++){\n\t\tif(c[i][j][k]>=K)ans+=(long long)(sx[i+1]-sx[i])*\n\t\t\t\t\t\t\t  (long long)(sy[j+1]-sy[j])*\n\t\t\t\t\t\t\t  (long long)(sd[k+1]-sd[k]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nlong long s=0,n,m,i,j,k,d[3][110],r[3][110],rr[3][110],c[110][110][110],b;\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tscanf(\"%d\",&d[j][i]);\n\t\t\tfor(k=i;k&&d[j][r[j][k-1]]>d[j][i];k--)r[j][k]=r[j][k-1];\n\t\t\tr[j][k]=i;\n\t\t}\n\t}\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<3;j++)rr[j][r[j][i]]=i;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<8;j++){\n\t\t\tb=0;\n\t\t\tfor(k=j;k;k/=2)b+=k%2;\n\t\t\tc[rr[0][i*2+(j/1%2)]][rr[1][i*2+(j/2%2)]][rr[2][i*2+(j/4%2)]]=1-(b%2*2);\n\t\t}\n\t}\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<n*2;j++){\n\t\t\tfor(k=0;k<n*2;k++)c[i][j][k+1]+=c[i][j][k];\n\t\t}\n\t}\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<n*2;j++){\n\t\t\tfor(k=0;k<n*2;k++)c[i][k+1][j]+=c[i][k][j];\n\t\t}\n\t}\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<n*2;j++){\n\t\t\tfor(k=0;k<n*2;k++)c[k+1][i][j]+=c[k][i][j];\n\t\t}\n\t}\n\tfor(i=0;i<n*2;i++){\n\t\tfor(j=0;j<n*2;j++){\n\t\t\tfor(k=0;k<n*2;k++){\n\t\t\t\tif(c[i][j][k]>=m)s+=(d[0][r[0][i+1]]-d[0][r[0][i]])\n\t\t\t\t\t\t   *(d[1][r[1][j+1]]-d[1][r[1][j]])\n\t\t\t\t\t\t   *(d[2][r[2][k+1]]-d[2][r[2][k]]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",s);\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>?): Unit {\n    fun <T> List<T>.doubling(): List<T> = flatMap{listOf(it, it)}\n    val (n, k) = readLine()!!.trim().split(' ').map(String::toInt)\n    val areas = Array(n){\n        val (x1, y1, d1, x2, y2, d2) = readLine()!!.trim().split(' ').map(String::toInt)\n        Pair(Point(x1, y1, d1), Point(x2, y2, d2))\n    }\n    val points = areas.flatMap { listOf(it.first, it.second) }\n    val width = points.map(Point::x).doubling().toIntArray().apply{sort()}\n    val height = points.map(Point::y).doubling().toIntArray().apply{sort()}\n    val depth = points.map(Point::z).doubling().toIntArray().apply{sort()}\n    val space = Array(4 * n){Array(4 * n){IntArray(4 * n){0}}}\n    fun Point.toCompressed(): Point {\n        return Point(lowerBound(width, x), lowerBound(height, y), lowerBound(depth, z))\n    }\n    for ((l, r) in areas) {\n        val cl = l.toCompressed()\n        val cr = r.toCompressed()\n        space[cl.x][cl.y][cl.z]++\n        space[cr.x + 1][cl.y][cl.z]--\n        space[cl.x][cr.y + 1][cl.z]--\n        space[cl.x][cl.y][cr.z + 1]--\n        space[cl.x][cr.y + 1][cr.z + 1]++\n        space[cr.x + 1][cl.y][cr.z + 1]++\n        space[cr.x + 1][cr.y + 1][cl.z]++\n        space[cr.x + 1][cr.y + 1][cr.z + 1]--\n    }\n    for (x in 1 until 4 * n) for (y in 0 until 4 * n) for (z in 0 until 4 * n) space[x][y][z] += space[x - 1][y][z]\n    for (x in 0 until 4 * n) for (y in 1 until 4 * n) for (z in 0 until 4 * n) space[x][y][z] += space[x][y - 1][z]\n    for (x in 0 until 4 * n) for (y in 0 until 4 * n) for (z in 1 until 4 * n) space[x][y][z] += space[x][y][z - 1]\n    println(\n            (0 until 4 * n - 1).map{x -> (0 until 4 * n - 1).map{y -> (0 until 4 * n - 1).filter{z -> space[x][y][z] >= k }.map{z ->\n                (width[x + 1].toLong() - width[x]) * (height[y + 1].toLong() - height[y]) * (depth[z + 1].toLong() - depth[z])\n            }.sum()}.sum()}.sum()\n    )\n}\noperator fun <T> List<T>.component6(): T = this[5]\ndata class Point(val x: Int, val y: Int, val z: Int)\nfun lowerBound(array: IntArray, target: Int): Int {\n    var left = 0\n    var right = array.size\n    while(left < right){\n        val mid = (left + right) / 2\n        if (array[mid] < target) left = mid + 1\n        else right = mid\n    }\n    return right\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint N=in.nextInt();\n\t\t\tint K=in.nextInt();\n\t\t\tint x[]=new int[N*2];\n\t\t\tint y[]=new int[N*2];\n\t\t\tint d[]=new int[N*2];\n\t\t\tint X1[]=new int[N];\n\t\t\tint Y1[]=new int[N];\n\t\t\tint D1[]=new int[N];\n\t\t\tint X2[]=new int[N];\n\t\t\tint Y2[]=new int[N];\n\t\t\tint D2[]=new int[N];\n\t\t\tint xl=0;\n\t\t\tint yl=0;\n\t\t\tint dl=0;\n\t\t\tlong ans=0;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tX1[i]=in.nextInt();\n\t\t\t\tY1[i]=in.nextInt();\n\t\t\t\tD1[i]=in.nextInt();\n\t\t\t\tX2[i]=in.nextInt();\n\t\t\t\tY2[i]=in.nextInt();\n\t\t\t\tD2[i]=in.nextInt();\n\n\t\t\t}\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tx[xl++]=X1[i];\n\t\t\t\tx[xl++]=X2[i];\n\t\t\t\ty[yl++]=Y1[i];\n\t\t\t\ty[yl++]=Y2[i];\n\t\t\t\td[dl++]=D1[i];\n\t\t\t\td[dl++]=D2[i];\n\t\t\t}\n\t\t\tArrays.sort(x);\n\t\t\tArrays.sort(y);\n\t\t\tArrays.sort(d);\n\t\t\tfor(int i=0;i<N*2-1;i++)//x position\n\t\t\t\tfor(int j=0;j<N*2-1;j++)//y position\n\t\t\t\t\tfor(int k=0;k<N*2-1;k++)//d position\n\t\t\t\t\t{\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\tfor(int l=0;l<N;l++)//\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif((X1[l]<=x[i]&&x[i+1]<=X2[l])&&\n\t\t\t\t\t\t\t\t\t(Y1[l]<=y[j]&&y[j+1]<=Y2[l])&&\n\t\t\t\t\t\t\t\t\t(D1[l]<=d[k]&&d[k+1]<=D2[l]))\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt>=K)\n\t\t\t\t\t\t\tans+=(x[i+1]-x[i])*(y[j+1]-y[j])*(d[k+1]-d[k]);\n\t\t\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic public void debug(Object... o)\n\t{\n\t\tSystem.err.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint[] X1 = new int[N];\n\t\tint[] X2 = new int[N];\n\t\tint[] Y1 = new int[N];\n\t\tint[] Y2 = new int[N];\n\t\tint[] D1 = new int[N];\n\t\tint[] D2 = new int[N];\n\t\tTreeSet<Integer> xset = new TreeSet<Integer>();\n\t\tTreeSet<Integer> yset = new TreeSet<Integer>();\n\t\tTreeSet<Integer> dset = new TreeSet<Integer>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tX1[i] = sc.nextInt();\n\t\t\tY1[i] = sc.nextInt();\n\t\t\tD1[i] = sc.nextInt();\n\t\t\tX2[i] = sc.nextInt();\n\t\t\tY2[i] = sc.nextInt();\n\t\t\tD2[i] = sc.nextInt();\n\t\t\txset.add(X1[i]);\n\t\t\txset.add(X2[i]);\n\t\t\tyset.add(Y1[i]);\n\t\t\tyset.add(Y2[i]);\n\t\t\tdset.add(D1[i]);\n\t\t\tdset.add(D2[i]);\n\t\t}\n\t\tArrayList<Integer> xs = new ArrayList<Integer>();\n\t\tArrayList<Integer> ys = new ArrayList<Integer>();\n\t\tArrayList<Integer> ds = new ArrayList<Integer>();\n\t\tfor (int v : xset) {\n\t\t\txs.add(v);\n\t\t}\n\t\tfor (int v : yset) {\n\t\t\tys.add(v);\n\t\t}\n\t\tfor (int v : dset) {\n\t\t\tds.add(v);\n\t\t}\n\t\tHashMap<Integer, Integer> xmap = new HashMap<Integer, Integer>();\n\t\tHashMap<Integer, Integer> ymap = new HashMap<Integer, Integer>();\n\t\tHashMap<Integer, Integer> dmap = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < xs.size(); ++i) {\n\t\t\txmap.put(xs.get(i), i);\n\t\t}\n\t\tfor (int i = 0; i < ys.size(); ++i) {\n\t\t\tymap.put(ys.get(i), i);\n\t\t}\n\t\tfor (int i = 0; i < ds.size(); ++i) {\n\t\t\tdmap.put(ds.get(i), i);\n\t\t}\n\t\tint[][][] count = new int[xs.size()][ys.size()][ds.size()];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint minx = xmap.get(X1[i]);\n\t\t\tint maxx = xmap.get(X2[i]);\n\t\t\tint miny = ymap.get(Y1[i]);\n\t\t\tint maxy = ymap.get(Y2[i]);\n\t\t\tint mind = dmap.get(D1[i]);\n\t\t\tint maxd = dmap.get(D2[i]);\n\t\t\tfor (int j = minx; j < maxx; ++j) {\n\t\t\t\tfor (int k = miny; k < maxy; ++k) {\n\t\t\t\t\tfor (int l = mind; l < maxd; ++l) {\n\t\t\t\t\t\tcount[j][k][l]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < xs.size() - 1; ++i) {\n\t\t\tlong x = xs.get(i + 1) - xs.get(i);\n\t\t\tfor (int j = 0; j < ys.size() - 1; ++j) {\n\t\t\t\tlong y = ys.get(j + 1) - ys.get(j);\n\t\t\t\tfor (int k = 0; k < ds.size() - 1; ++k) {\n\t\t\t\t\tif (count[i][j][k] >= K) {\n\t\t\t\t\t\tlong d = ds.get(k + 1) - ds.get(k);\n\t\t\t\t\t\tans += x * y * d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N = sc.nextInt();\n\t\tfinal int K = sc.nextInt();\n\t\t\n\t\tint[][] fish = new int[N][6];\n\t\t\n\t\tTreeSet<Integer> x_tree = new TreeSet<Integer>();\n\t\tTreeSet<Integer> y_tree = new TreeSet<Integer>();\n\t\tTreeSet<Integer> d_tree = new TreeSet<Integer>();\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tfish[i][j] = sc.nextInt();\n\t\t\t\t\n\t\t\t\tswitch(j % 3){\n\t\t\t\tcase 0:\n\t\t\t\t\tx_tree.add(fish[i][j]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\ty_tree.add(fish[i][j]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\td_tree.add(fish[i][j]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tArrayList<Integer> x_list = new ArrayList<Integer>(x_tree);\n\t\tArrayList<Integer> y_list = new ArrayList<Integer>(y_tree);\n\t\tArrayList<Integer> d_list = new ArrayList<Integer>(d_tree);\n\t\t\n\t\tfinal int x_size = x_list.size();\n\t\tfinal int y_size = y_list.size();\n\t\tfinal int d_size = d_list.size();\n\t\t\n\t\tint[] x_dist = new int[x_size - 1];\n\t\tint[] y_dist = new int[y_size - 1];\n\t\tint[] d_dist = new int[d_size - 1];\n\t\tfor(int x = 0; x < x_size - 1; x++){\n\t\t\tx_dist[x] = x_list.get(x + 1) - x_list.get(x);\n\t\t}\n\t\tfor(int y = 0; y < y_size - 1; y++){\n\t\t\ty_dist[y] = y_list.get(y + 1) - y_list.get(y);\n\t\t}\n\t\tfor(int d = 0; d < d_size - 1; d++){\n\t\t\td_dist[d] = d_list.get(d + 1) - d_list.get(d);\n\t\t}\n\t\t\n\t\tint[][][] area = new int[d_size - 1][y_size - 1][x_size - 1];\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint x_start = Collections.binarySearch(x_list, fish[i][0]);\n\t\t\tint y_start = Collections.binarySearch(y_list, fish[i][1]);\n\t\t\tint d_start = Collections.binarySearch(d_list, fish[i][2]);\n\t\t\tint x_end   = Collections.binarySearch(x_list, fish[i][3]);\n\t\t\tint y_end   = Collections.binarySearch(y_list, fish[i][4]);\n\t\t\tint d_end   = Collections.binarySearch(d_list, fish[i][5]);\n\t\t\t\n\t\t\tif(x_start < 0){\n\t\t\t\tx_start = -(x_start + 1);\n\t\t\t}\n\t\t\tif(y_start < 0){\n\t\t\t\ty_start = -(y_start + 1);\n\t\t\t}\n\t\t\tif(d_start < 0){\n\t\t\t\td_start = -(d_start + 1);\n\t\t\t}\n\t\t\t\n\t\t\tif(x_end < 0){\n\t\t\t\tx_end = -(x_end + 2);\n\t\t\t}else{\n\t\t\t\tx_end--;\n\t\t\t}\n\t\t\tif(y_end < 0){\n\t\t\t\ty_end = -(y_end + 2);\n\t\t\t}else{\n\t\t\t\ty_end--;\n\t\t\t}\n\t\t\tif(d_end < 0){\n\t\t\t\td_end = -(d_end + 2);\n\t\t\t}else{\n\t\t\t\td_end--;\n\t\t\t}\n\t\t\t\n\t\t\tarea[d_start][y_start][x_start]++;\n\t\t\t//\n\t\t\tif(d_end + 1 < d_size - 1){\n\t\t\t\tarea[d_end + 1][y_start][x_start]--;\n\t\t\t}\n\t\t\tif(y_end + 1 < y_size - 1){\n\t\t\t\tarea[d_start][y_end + 1][x_start]--;\n\t\t\t}\n\t\t\tif(x_end + 1 < x_size - 1){\n\t\t\t\tarea[d_start][y_start][x_end + 1]--;\n\t\t\t}\n\t\t\t//\n\t\t\tif(d_end + 1 < d_size - 1 && y_end + 1 < y_size - 1){\n\t\t\t\tarea[d_end + 1][y_end + 1][x_start]++;\n\t\t\t}\n\t\t\tif(y_end + 1 < y_size - 1 && x_end + 1 < x_size - 1){\n\t\t\t\tarea[d_start][y_end + 1][x_end + 1]++;\n\t\t\t}\n\t\t\tif(d_end + 1 < d_size - 1 && x_end + 1 < x_size - 1){\n\t\t\t\tarea[d_end + 1][y_start][x_end + 1]++;\n\t\t\t}\n\t\t\t//\n\t\t\tif(d_end + 1 < d_size - 1 && y_end + 1 < y_size - 1 && x_end + 1 < x_size - 1){\n\t\t\t\tarea[d_end + 1][y_end + 1][x_end + 1]--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int d = 0; d < d_size - 1; d++){\n\t\t\tfor(int y = 0; y < y_size - 1; y++){\n\t\t\t\tfor(int x = 1; x < x_size - 1; x++){\n\t\t\t\t\tarea[d][y][x] += area[d][y][x-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int d = 0; d < d_size - 1; d++){\n\t\t\tfor(int x = 0; x < x_size - 1; x++){\n\t\t\t\tfor(int y = 1; y < y_size - 1; y++){\n\t\t\t\t\tarea[d][y][x] += area[d][y-1][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int y = 0; y < y_size - 1; y++){\n\t\t\tfor(int x = 0; x < x_size - 1; x++){\n\t\t\t\tfor(int d = 1; d < d_size - 1; d++){\n\t\t\t\t\tarea[d][y][x] += area[d-1][y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong sum = 0;\n\t\tfor(int d = 0; d < area.length; d++){\n\t\t\tfor(int y = 0; y < area[d].length; y++){\n\t\t\t\tfor(int x = 0; x < area[d][y].length; x++){\n\t\t\t\t\tif(area[d][y][x] >= K){\n\t\t\t\t\t\tlong x_d = x_dist[x];\n\t\t\t\t\t\tlong y_d = y_dist[y];\n\t\t\t\t\t\tlong d_d = d_dist[d];\n\t\t\t\t\t\tsum += (x_d * y_d * d_d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(sum);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N = sc.nextInt();\n\t\tfinal int K = sc.nextInt();\n\t\t\n\t\tint[][] fish = new int[N][6];\n\t\t\n\t\tTreeSet<Integer> x_tree = new TreeSet<Integer>();\n\t\tTreeSet<Integer> y_tree = new TreeSet<Integer>();\n\t\tTreeSet<Integer> d_tree = new TreeSet<Integer>();\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tfish[i][j] = sc.nextInt();\n\t\t\t\t\n\t\t\t\tswitch(j % 3){\n\t\t\t\tcase 0:\n\t\t\t\t\tx_tree.add(fish[i][j]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\ty_tree.add(fish[i][j]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\td_tree.add(fish[i][j]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tArrayList<Integer> x_list = new ArrayList<Integer>(x_tree);\n\t\tArrayList<Integer> y_list = new ArrayList<Integer>(y_tree);\n\t\tArrayList<Integer> d_list = new ArrayList<Integer>(d_tree);\n\t\t\n\t\tfinal int x_size = x_list.size();\n\t\tfinal int y_size = y_list.size();\n\t\tfinal int d_size = d_list.size();\n\t\t\n\t\tint[] x_dist = new int[x_size - 1];\n\t\tint[] y_dist = new int[y_size - 1];\n\t\tint[] d_dist = new int[d_size - 1];\n\t\tfor(int x = 0; x < x_size - 1; x++){\n\t\t\tx_dist[x] = x_list.get(x + 1) - x_list.get(x);\n\t\t}\n\t\tfor(int y = 0; y < y_size - 1; y++){\n\t\t\ty_dist[y] = y_list.get(y + 1) - y_list.get(y);\n\t\t}\n\t\tfor(int d = 0; d < d_size - 1; d++){\n\t\t\td_dist[d] = d_list.get(d + 1) - d_list.get(d);\n\t\t}\n\t\t\n\t\tint[][][] area = new int[d_size - 1][y_size - 1][x_size - 1];\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint x_start = Collections.binarySearch(x_list, fish[i][0]);\n\t\t\tint y_start = Collections.binarySearch(y_list, fish[i][1]);\n\t\t\tint d_start = Collections.binarySearch(d_list, fish[i][2]);\n\t\t\tint x_end   = Collections.binarySearch(x_list, fish[i][3]);\n\t\t\tint y_end   = Collections.binarySearch(y_list, fish[i][4]);\n\t\t\tint d_end   = Collections.binarySearch(d_list, fish[i][5]);\n\t\t\t\n\t\t\tif(x_start < 0){\n\t\t\t\tx_start = -(x_start + 1);\n\t\t\t}\n\t\t\tif(y_start < 0){\n\t\t\t\ty_start = -(y_start + 1);\n\t\t\t}\n\t\t\tif(d_start < 0){\n\t\t\t\td_start = -(d_start + 1);\n\t\t\t}\n\t\t\t\n\t\t\tif(x_end < 0){\n\t\t\t\tx_end = -(x_end + 2);\n\t\t\t}else{\n\t\t\t\tx_end--;\n\t\t\t}\n\t\t\tif(y_end < 0){\n\t\t\t\ty_end = -(y_end + 2);\n\t\t\t}else{\n\t\t\t\ty_end--;\n\t\t\t}\n\t\t\tif(d_end < 0){\n\t\t\t\td_end = -(d_end + 2);\n\t\t\t}else{\n\t\t\t\td_end--;\n\t\t\t}\n\t\t\t\n\t\t\tarea[d_start][y_start][x_start]++;\n\t\t\t//\n\t\t\tif(d_end + 1 < d_size - 1){\n\t\t\t\tarea[d_end + 1][y_start][x_start]--;\n\t\t\t}\n\t\t\tif(y_end + 1 < y_size - 1){\n\t\t\t\tarea[d_start][y_end + 1][x_start]--;\n\t\t\t}\n\t\t\tif(x_end + 1 < x_size - 1){\n\t\t\t\tarea[d_start][y_start][x_end + 1]--;\n\t\t\t}\n\t\t\t//\n\t\t\tif(d_end + 1 < d_size - 1 && y_end + 1 < y_size - 1){\n\t\t\t\tarea[d_end + 1][y_end + 1][x_start]++;\n\t\t\t}\n\t\t\tif(y_end + 1 < y_size - 1 && x_end + 1 < x_size - 1){\n\t\t\t\tarea[d_start][y_end + 1][x_end + 1]++;\n\t\t\t}\n\t\t\tif(d_end + 1 < d_size - 1 && x_end + 1 < x_size - 1){\n\t\t\t\tarea[d_end + 1][y_start][x_end + 1]++;\n\t\t\t}\n\t\t\t//\n\t\t\tif(d_end + 1 < d_size - 1 && y_end + 1 < y_size - 1 && x_end + 1 < x_size - 1){\n\t\t\t\tarea[d_end + 1][y_end + 1][x_end + 1]--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int d = 0; d < d_size - 1; d++){\n\t\t\tfor(int y = 0; y < y_size - 1; y++){\n\t\t\t\tfor(int x = 1; x < x_size - 1; x++){\n\t\t\t\t\tarea[d][y][x] += area[d][y][x-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int d = 0; d < d_size - 1; d++){\n\t\t\tfor(int x = 0; x < x_size - 1; x++){\n\t\t\t\tfor(int y = 1; y < y_size - 1; y++){\n\t\t\t\t\tarea[d][y][x] += area[d][y-1][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int y = 0; y < y_size - 1; y++){\n\t\t\tfor(int x = 0; x < x_size - 1; x++){\n\t\t\t\tfor(int d = 1; d < d_size - 1; d++){\n\t\t\t\t\tarea[d][y][x] += area[d-1][y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong sum = 0;\n\t\tfor(int d = 0; d < area.length; d++){\n\t\t\tfor(int y = 0; y < area[d].length; y++){\n\t\t\t\tfor(int x = 0; x < area[d][y].length; x++){\n\t\t\t\t\tif(area[d][y][x] >= K){\n\t\t\t\t\t\tlong x_d = x_dist[x];\n\t\t\t\t\t\tlong y_d = y_dist[y];\n\t\t\t\t\t\tlong d_d = d_dist[d];\n\t\t\t\t\t\tsum += (x_d * y_d * d_d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(sum);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tlong[] xS = new long[N];\n\t\tlong[] yS = new long[N];\n\t\tlong[] zS = new long[N];\n\t\tlong[] xT = new long[N];\n\t\tlong[] yT = new long[N];\n\t\tlong[] zT = new long[N];\n\t\tArrayList<Long> X = new ArrayList<Long>();\n\t\tArrayList<Long> Y = new ArrayList<Long>();\n\t\tArrayList<Long> Z = new ArrayList<Long>();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\txS[i] = sc.nextLong();\n\t\t\tyS[i] = sc.nextLong();\n\t\t\tzS[i] = sc.nextLong();\n\t\t\txT[i] = sc.nextLong();\n\t\t\tyT[i] = sc.nextLong();\n\t\t\tzT[i] = sc.nextLong();\n\t\t\tX.add(xS[i]);\n\t\t\tX.add(xT[i]);\n\t\t\tY.add(yS[i]);\n\t\t\tY.add(yT[i]);\n\t\t\tZ.add(zS[i]);\n\t\t\tZ.add(zT[i]);\n\t\t}\n\n\t\tCollections.sort(X);\n\t\tCollections.sort(Y);\n\t\tCollections.sort(Z);\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < N * 2 - 1; i++) {\n\t\t\tfor (int j = 0; j < N * 2 - 1; j++) {\n\t\t\t\tfor (int k = 0; k < N * 2 - 1; k++) {\n\t\t\t\t\tint overlap = 0;\n\t\t\t\t\t// x,y,z???????????????????????¨????????????????????????\n\t\t\t\t\t// ????????????????¢?????????????????????¬??????????????????\n\t\t\t\t\tfor (int l = 0; l < N; l++) {\n\t\t\t\t\t\tif (xS[l] <= X.get(i) && X.get(i + 1) <= xT[l]\n\t\t\t\t\t\t\t\t&& yS[l] <= Y.get(j) && Y.get(j + 1) <= yT[l]\n\t\t\t\t\t\t\t\t&& zS[l] <= Z.get(k) && Z.get(k + 1) <= zT[l]) {\n\t\t\t\t\t\t\toverlap++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (overlap >= K) {\n\t\t\t\t\t\tans += (X.get(i + 1) - X.get(i)) * (Y.get(j + 1) - Y.get(j)) * (Z.get(k + 1) - Z.get(k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\t\n\t\tArrayList<Integer> x = new ArrayList<Integer>();\n\t\tArrayList<Integer> y = new ArrayList<Integer>();\n\t\tArrayList<Integer> z = new ArrayList<Integer>();\n\t\tint[][] in = new int[n][6];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\tin[i][j] = sc.nextInt();\n\t\t\t\tif(j%3==0 && !x.contains(in[i][j])) x.add(in[i][j]);\n\t\t\t\telse if(j%3==1 && !y.contains(in[i][j])) y.add(in[i][j]);\n\t\t\t\telse if(j%3==2 && !z.contains(in[i][j])) z.add(in[i][j]);\n\t\t\t}\n\t\t}\n\t\tCollections.sort(x);\n\t\tCollections.sort(y);\n\t\tCollections.sort(z);\n\t\t\n\t\tint xc = x.size();\n\t\tint yc = y.size();\n\t\tint zc = z.size();\n\t\tlong[][][] cnt = new long[zc][yc][xc];\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1 = x.indexOf(in[i][0]);\n\t\t\tint y1 = y.indexOf(in[i][1]);\n\t\t\tint z1 = z.indexOf(in[i][2]);\n\t\t\tint x2 = x.indexOf(in[i][3]);\n\t\t\tint y2 = y.indexOf(in[i][4]);\n\t\t\tint z2 = z.indexOf(in[i][5]);\n\t\t\tfor(int a=z1;a<z2;a++){\n\t\t\t\tfor(int b=y1;b<y2;b++){\n\t\t\t\t\tfor(int c=x1;c<x2;c++){\n\t\t\t\t\t\tcnt[a][b][c]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong ans = 0;\n\t\tfor(int i=0;i<zc-1;i++){\n\t\t\tfor(int j=0;j<yc-1;j++){\n\t\t\t\tfor(int s=0;s<xc-1;s++){\n\t\t\t\t\tif(cnt[i][j][s]>=k){\n\t\t\t\t\t\tlong xx = x.get(s+1)-x.get(s);\n\t\t\t\t\t\tlong yy = y.get(j+1)-y.get(j);\n\t\t\t\t\t\tlong zz = z.get(i+1)-z.get(i);\n\t\t\t\t\t\tans += xx*yy*zz;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Main {\n\n    public static void main( final String[] args ) {\n\n\tfinal Scanner stdin = new Scanner( System.in );\n\n\tfinal int N = stdin.nextInt();\n\tfinal int K = stdin.nextInt();\n\n\tfinal long[][] rects = new long[ N ][ 6 ];\n\tfor ( int i = 0; i < N; i++ ) {\n\t    for ( int j = 0; j < 6; j++ ) {\n\t\trects[ i ][ j ] = stdin.nextLong();\n\t    }\n\t}\n\tfinal ArrayList<Long> xs = new ArrayList<Long>();\n\tfinal ArrayList<Long> ys = new ArrayList<Long>();\n\tfinal ArrayList<Long> zs = new ArrayList<Long>();\n\n\tfor ( int i = 0; i < N; i++ ) {\n\t    if ( !xs.contains( rects[ i ][ 0 ] ) ) {\n\t\txs.add( rects[ i ][ 0 ] );\n\t    }\n\t    if ( !xs.contains( rects[ i ][ 3 ] ) ) {\n\t\txs.add( rects[ i ][ 3 ] );\n\t    }\n\t    if ( !ys.contains( rects[ i ][ 1 ] ) ) {\n\t\tys.add( rects[ i ][ 1 ] );\n\t    }\n\t    if ( !ys.contains( rects[ i ][ 4 ] ) ) {\n\t\tys.add( rects[ i ][ 4 ] );\n\t    }\n\t    if ( !zs.contains( rects[ i ][ 2 ] ) ) {\n\t\tzs.add( rects[ i ][ 2 ] );\n\t    }\n\t    if ( !zs.contains( rects[ i ][ 5 ] ) ) {\n\t\tzs.add( rects[ i ][ 5 ] );\n\t    }\n\t}\n\tCollections.sort( xs );\n\tCollections.sort( ys );\n\tCollections.sort( zs );\n\n\tfinal int[][][] compressedRect = new int[ xs.size() ][ ys.size() ][ zs.size() ];\n\n\tfor ( int i = 0; i < N; i++ ) {\n\t    final int fromX = Collections.binarySearch( xs, rects[ i ][ 0 ] );\n\t    final int toX = Collections.binarySearch( xs, rects[ i ][ 3 ] );\n\t    final int fromY = Collections.binarySearch( ys, rects[ i ][ 1 ] );\n\t    final int toY = Collections.binarySearch( ys, rects[ i ][ 4 ] );\n\t    final int fromZ = Collections.binarySearch( zs, rects[ i ][ 2 ] );\n\t    final int toZ = Collections.binarySearch( zs, rects[ i ][ 5 ] );\n\n\t    for ( int x = fromX; x < toX; x++ ) {\n\t\tfor ( int y = fromY; y < toY; y++ ) {\n\t\t    for ( int z = fromZ; z < toZ; z++ ) {\n\t\t\tcompressedRect[ x ][ y ][ z ]++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tlong volume = 0L;\n\tfor ( int x = 0; x < compressedRect.length - 1; x++ ) {\n\t    for ( int y = 0; y < compressedRect[ x ].length - 1; y++ ) {\n\t\tfor ( int z = 0; z < compressedRect[ x ][ y ].length - 1; z++ ) {\n\t\t    if ( compressedRect[ x ][ y ][ z ] >= K ) {\n\t\t\tvolume += ( xs.get( x + 1 ) - xs.get( x ) ) *\n\t\t\t    ( ys.get( y + 1 ) - ys.get( y ) ) *\n\t\t\t    ( zs.get( z + 1 ) - zs.get( z ) );\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tSystem.out.println( volume );\n    }    \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint n, k;\n\tArrayList<Integer> x, y, z;\n\tint[][] in;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tn = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\t\n\t\tx = new ArrayList<Integer>();\n\t\ty = new ArrayList<Integer>();\n\t\tz = new ArrayList<Integer>();\n\t\tin = new int[n][6];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\tin[i][j] = sc.nextInt();\n\t\t\t\tif(j%3==0 && !x.contains(in[i][j])) x.add(in[i][j]);\n\t\t\t\telse if(j%3==1 && !y.contains(in[i][j])) y.add(in[i][j]);\n\t\t\t\telse if(j%3==2 && !z.contains(in[i][j])) z.add(in[i][j]);\n\t\t\t}\n\t\t}\n\t\tCollections.sort(x);\n\t\tCollections.sort(y);\n\t\tCollections.sort(z);\n\t\t\n\t\tint xc = x.size();\n\t\tint yc = y.size();\n\t\tint zc = z.size();\n\t\tlong[][][] cnt = new long[zc][yc][xc];\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x1 = x.indexOf(in[i][0]);\n\t\t\tint y1 = y.indexOf(in[i][1]);\n\t\t\tint z1 = z.indexOf(in[i][2]);\n\t\t\tint x2 = x.indexOf(in[i][3]);\n\t\t\tint y2 = y.indexOf(in[i][4]);\n\t\t\tint z2 = z.indexOf(in[i][5]);\n\t\t\tfor(int j=i;j<n;j++){\n\t\t\t\tint x3 = x.indexOf(in[j][0]);\n\t\t\t\tint y3 = y.indexOf(in[j][1]);\n\t\t\t\tint z3 = z.indexOf(in[j][2]);\n\t\t\t\tint x4 = x.indexOf(in[j][3]);\n\t\t\t\tint y4 = y.indexOf(in[j][4]);\n\t\t\t\tint z4 = z.indexOf(in[j][5]);\n\t\t\t\t\n\t\t\t\tif(x2<=x3 || x4<=x1) break;\n\t\t\t\tif(y2<=y3 || y4<=y1) break;\n\t\t\t\tif(z2<=z3 || z4<=z1) break;\n\t\t\t\tint left = Math.max(x1, x3);\n\t\t\t\tint right = Math.min(x2, x4);\n\t\t\t\tint up = Math.max(y1, y3);\n\t\t\t\tint dwn = Math.min(y2, y4);\n\t\t\t\tint top = Math.max(z1, z3);\n\t\t\t\tint btm = Math.min(z2, z4);\n\t\t\t\t\n\t\t\t\tfor(int a=top;a<btm;a++){\n\t\t\t\t\tfor(int b=up;b<dwn;b++){\n\t\t\t\t\t\tfor(int c=left;c<right;c++){\n\t\t\t\t\t\t\tcnt[a][b][c]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong ans = 0;\n\t\tfor(int i=0;i<zc-1;i++){\n\t\t\tfor(int j=0;j<yc-1;j++){\n\t\t\t\tfor(int s=0;s<xc-1;s++){\n\t\t\t\t\tif(cnt[i][j][s]>=k){\n\t\t\t\t\t\tlong xx = x.get(s+1)-x.get(s);\n\t\t\t\t\t\tlong yy = y.get(j+1)-y.get(j);\n\t\t\t\t\t\tlong zz = z.get(i+1)-z.get(i);\n\t\t\t\t\t\tans += xx*yy*zz;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N = sc.nextInt();\n\t\tfinal int K = sc.nextInt();\n\t\t\n\t\tint[][] fish = new int[N][6];\n\t\t\n\t\tTreeSet<Integer> x_tree = new TreeSet<Integer>();\n\t\tTreeSet<Integer> y_tree = new TreeSet<Integer>();\n\t\tTreeSet<Integer> d_tree = new TreeSet<Integer>();\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tfish[i][j] = sc.nextInt();\n\t\t\t\t\n\t\t\t\tswitch(j % 3){\n\t\t\t\tcase 0:\n\t\t\t\t\tx_tree.add(fish[i][j]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\ty_tree.add(fish[i][j]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\td_tree.add(fish[i][j]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tArrayList<Integer> x_list = new ArrayList<Integer>(x_tree);\n\t\tArrayList<Integer> y_list = new ArrayList<Integer>(y_tree);\n\t\tArrayList<Integer> d_list = new ArrayList<Integer>(d_tree);\n\t\t\n\t\tfinal int x_size = x_list.size();\n\t\tfinal int y_size = y_list.size();\n\t\tfinal int d_size = d_list.size();\n\t\t\n\t\tint[] x_dist = new int[x_size - 1];\n\t\tint[] y_dist = new int[y_size - 1];\n\t\tint[] d_dist = new int[d_size - 1];\n\t\tfor(int x = 0; x < x_size - 1; x++){\n\t\t\tx_dist[x] = x_list.get(x + 1) - x_list.get(x);\n\t\t}\n\t\tfor(int y = 0; y < y_size - 1; y++){\n\t\t\ty_dist[y] = y_list.get(y + 1) - y_list.get(y);\n\t\t}\n\t\tfor(int d = 0; d < d_size - 1; d++){\n\t\t\td_dist[d] = d_list.get(d + 1) - d_list.get(d);\n\t\t}\n\t\t\n\t\tint[][][] area = new int[d_size - 1][y_size - 1][x_size - 1];\n\t\tlong sum = 0;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint x_start = Collections.binarySearch(x_list, fish[i][0]);\n\t\t\tint y_start = Collections.binarySearch(y_list, fish[i][1]);\n\t\t\tint d_start = Collections.binarySearch(d_list, fish[i][2]);\n\t\t\tint x_end   = Collections.binarySearch(x_list, fish[i][3]);\n\t\t\tint y_end   = Collections.binarySearch(y_list, fish[i][4]);\n\t\t\tint d_end   = Collections.binarySearch(d_list, fish[i][5]);\n\t\t\t\n\t\t\tif(x_start < 0){\n\t\t\t\tx_start = -(x_start + 1);\n\t\t\t}\n\t\t\tif(y_start < 0){\n\t\t\t\ty_start = -(y_start + 1);\n\t\t\t}\n\t\t\tif(d_start < 0){\n\t\t\t\td_start = -(d_start + 1);\n\t\t\t}\n\t\t\t\n\t\t\tif(x_end < 0){\n\t\t\t\tx_end = -(x_end + 2);\n\t\t\t}else{\n\t\t\t\tx_end--;\n\t\t\t}\n\t\t\tif(y_end < 0){\n\t\t\t\ty_end = -(y_end + 2);\n\t\t\t}else{\n\t\t\t\ty_end--;\n\t\t\t}\n\t\t\tif(d_end < 0){\n\t\t\t\td_end = -(d_end + 2);\n\t\t\t}else{\n\t\t\t\td_end--;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int d = d_start; d <= d_end; d++){\n\t\t\t\tfor(int y = y_start; y <= y_end; y++){\n\t\t\t\t\tfor(int x = x_start; x <= x_end; x++){\n\t\t\t\t\t\tif(area[d][y][x] >= K){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tarea[d][y][x]++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(area[d][y][x] >= K){\n\t\t\t\t\t\t\t\tlong x_d = x_dist[x];\n\t\t\t\t\t\t\t\tlong y_d = y_dist[y];\n\t\t\t\t\t\t\t\tlong d_d = d_dist[d];\n\t\t\t\t\t\t\t\tsum += (x_d * y_d * d_d);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(sum);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint N=in.nextInt();\n\t\t\tint K=in.nextInt();\n\t\t\tlong x[]=new long[N*2];\n\t\t\tlong y[]=new long[N*2];\n\t\t\tlong d[]=new long[N*2];\n\t\t\tint X1[]=new int[N];\n\t\t\tint Y1[]=new int[N];\n\t\t\tint D1[]=new int[N];\n\t\t\tint X2[]=new int[N];\n\t\t\tint Y2[]=new int[N];\n\t\t\tint D2[]=new int[N];\n\t\t\tint xl=0;\n\t\t\tint yl=0;\n\t\t\tint dl=0;\n\t\t\tlong ans=0;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tX1[i]=in.nextInt();\n\t\t\t\tY1[i]=in.nextInt();\n\t\t\t\tD1[i]=in.nextInt();\n\t\t\t\tX2[i]=in.nextInt();\n\t\t\t\tY2[i]=in.nextInt();\n\t\t\t\tD2[i]=in.nextInt();\n\n\t\t\t}\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tx[xl++]=X1[i];\n\t\t\t\tx[xl++]=X2[i];\n\t\t\t\ty[yl++]=Y1[i];\n\t\t\t\ty[yl++]=Y2[i];\n\t\t\t\td[dl++]=D1[i];\n\t\t\t\td[dl++]=D2[i];\n\t\t\t}\n\t\t\tArrays.sort(x);\n\t\t\tArrays.sort(y);\n\t\t\tArrays.sort(d);\n\t\t\tfor(int i=0;i<N*2-1;i++)//x position\n\t\t\t\tfor(int j=0;j<N*2-1;j++)//y position\n\t\t\t\t\tfor(int k=0;k<N*2-1;k++)//d position\n\t\t\t\t\t{\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\tfor(int l=0;l<N;l++)//\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif((X1[l]<=x[i]&&x[i+1]<=X2[l])&&\n\t\t\t\t\t\t\t\t\t(Y1[l]<=y[j]&&y[j+1]<=Y2[l])&&\n\t\t\t\t\t\t\t\t\t(D1[l]<=d[k]&&d[k+1]<=D2[l]))\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt>=K)\n\t\t\t\t\t\t\tans+=(x[i+1]-x[i])*(y[j+1]-y[j])*(d[k+1]-d[k]);\n\t\t\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic public void debug(Object... o)\n\t{\n\t\tSystem.err.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace _0580\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tint[] x = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\t\t\tlong[,] fishes = new long[x[0], 6];\n\t\t\tHashSet<long>[] zahyo = new HashSet<long>[3];\n\t\t\tfor (int i = 0; i < 3; i++) zahyo[i] = new HashSet<long>();\n\t\t\tfor (int i = 0; i < x[0]; i++)\n\t\t\t{\n\t\t\t\tlong[] a = Console.ReadLine().Split().Select(long.Parse).ToArray();\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tzahyo[j].Add(a[j]); zahyo[j].Add(a[j + 3]);\n\t\t\t\t\tfishes[i, j] = a[j]; fishes[i, j + 3] = a[j + 3];\n\t\t\t\t}\n\t\t\t}\n\t\t\tList<long>[] len = new List<long>[3];\n\t\t\tList<long>[] list = new List<long>[3];\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tvar arr = zahyo[i].ToArray(); Array.Sort(arr); len[i] = arr.ToList();\n\t\t\t\tlist[i] = new List<long>();\n\t\t\t\tfor (int j = 0; j < arr.Count(); j++) list[i].Add(0);\n\t\t\t\tfor (int j = 0; j < x[0]; j++)\n\t\t\t\t{\n\t\t\t\t\tlist[i][Array.BinarySearch(arr, fishes[j, i])] ^= 1L << j;\n\t\t\t\t\tlist[i][Array.BinarySearch(arr, fishes[j, i + 3])] ^= 1L << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tlong now = 0;\n\t\t\t\tfor (int j = 0; j < list[i].Count; j++)\n\t\t\t\t{\n\t\t\t\t\tnow ^= list[i][j];\n\t\t\t\t\tlist[i][j] = now;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ret = 0;\n\t\t\tfor (int i = 0; i < list[0].Count - 1; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < list[1].Count - 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k < list[2].Count - 1; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tlong now = list[0][i] & list[1][j] & list[2][k];\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\tfor (int m = 0; m <= 60; m++)\n\t\t\t\t\t\t\tif ((now & (1L << m)) > 0) count++;\n\t\t\t\t\t\tif (count >= x[1])\n\t\t\t\t\t\t\tret += (len[0][i + 1] - len[0][i]) *\n\t\t\t\t\t\t\t\t   (len[1][j + 1] - len[1][j]) *\n\t\t\t\t\t\t\t\t   (len[2][k + 1] - len[2][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(ret);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nn, k = gets.strip.split(' ').map{|s| s.to_i}\n\nxhash = {}\nyhash = {}\nzhash = {}\ncbs = []\n\nn.times do\n  x0, y0, z0, x1, y1, z1 = gets.strip.split(' ').map{|s| s.to_i}\n  cbs << [x0, y0, z0, x1, y1, z1]\n  xhash[x0] = xhash[x1] = yhash[y0] = yhash[y1] = zhash[z0] = zhash[z1] = 0\nend\n\nxs = xhash.keys.sort\nys = yhash.keys.sort\nzs = zhash.keys.sort\nnxs = xs.length - 1\nnys = ys.length - 1\nnzs = zs.length - 1\n#p [xs, ys, zs]\n\nxs.each_with_index{|x, i| xhash[x] = i}\nys.each_with_index{|y, i| yhash[y] = i}\nzs.each_with_index{|z, i| zhash[z] = i}\n#p [xhash, yhash, zhash]\n\novls = nxs.times.map{nys.times.map{nzs.times.map{0}}}\n\nfor cb in cbs\n  x0, y0, z0, x1, y1, z1 = cb\n  for xi in (xhash[x0]...xhash[x1])\n    for yi in (yhash[y0]...yhash[y1])\n      for zi in (zhash[z0]...zhash[z1])\n        ovls[xi][yi][zi] += 1\n      end\n    end\n  end\nend\n\nvsum = 0\n\nfor xi in (0...nxs)\n  dx = xs[xi + 1] - xs[xi]\n  for yi in (0...nys)\n    dy = ys[yi + 1] - ys[yi]\n    for zi in (0...nzs)\n      dz = zs[zi + 1] - zs[zi]\n      if ovls[xi][yi][zi] >= k\n        vsum += dx * dy * dz\n      end\n    end\n  end\nend\n\nputs vsum"
  },
  {
    "language": "Ruby",
    "code": "n, k = gets.split.map(&:to_i)\nx = {}\ny = {}\nz = {}\nxs = []\nys = []\nzs = []\nareas = []\nn.times do\n  area = gets.split.map(&:to_i)\n  areas << area\n  xs << area[0]; xs << area[3]\n  ys << area[1]; ys << area[4]\n  zs << area[2]; zs << area[5]\nend\nxs.sort!\nys.sort!\nzs.sort!\nxss = xs.size\nyss = ys.size\nzss = zs.size\nxs.each_with_index{ |a, i| x[a] = i }\nys.each_with_index{ |b, i| y[b] = i }\nzs.each_with_index{ |c, i| z[c] = i }\nsea = Array.new(xss){ Array.new(yss){ Array.new(zss, 0) }}\nfor area in areas\n  x0, y0, z0, x1, y1, z1 = area\n  for a in (x[x0]...x[x1])\n    for b in (y[y0]...y[y1])\n      for c in (z[z0]...z[z1])\n        sea[a][b][c] += 1\n      end\n    end\n  end\nend\n\nret = 0\nfor a in (0...xss-1)\n  dx = xs[a+1] - xs[a]\n  for b in (0...yss-1)\n    dy = ys[b+1] - ys[b]\n    for c in (0...zss-1)\n      dz = zs[c+1] - zs[c]\n      if sea[a][b][c] >= k\n        ret += dx * dy * dz\n      end\n    end\n  end\nend\np ret"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Cuboid\n\tattr_reader *%w(x1 y1 z1 x2 y2 z2)\n\tdef initialize(*args)\n\t\t@x1, @y1, @z1, @x2, @y2, @z2 = args\n\tend\nend\n\t\t\nn, k = gets.split.map &:to_i\n\nz_events = []\nn.times {\n\tc = Cuboid.new(*gets.split.map(&:to_i))\n\tz_events << [:add, c, c.z1]\n\tz_events << [:del, c, c.z2]\n}\nz_events.sort_by!(&:last)\n\nvolume = 0\nz = 0\narea = 0\nz_cuboids = Set.new\nuntil z_events.empty?\n\tnext_z = z_events[0][2]\n\tvolume += area * (next_z - z)\n\twhile !z_events.empty? && z_events[0][2] == next_z\n\t\tcommand, c, _ = z_events.shift\n\t\tcommand == :add ? z_cuboids << c : z_cuboids.delete(c)\n\tend\n\t\t\n\ty_events = []\n\tz_cuboids.each {|c|\n\t\ty_events << [:add, c, c.y1]\n\t\ty_events << [:del, c, c.y2]\n\t}\n\ty_events.sort_by!(&:last)\n\tarea = 0\n\tlength = 0\n\ty = 0\n\ty_cuboids = Set.new\n\tuntil y_events.empty?\n\t\tnext_y = y_events[0][2]\n\t\tarea += length * (next_y - y)\n\t\twhile !y_events.empty? && y_events[0][2] == next_y\n\t\t\tcommand, c, _ = y_events.shift\n\t\t\tcommand == :add ? y_cuboids << c : y_cuboids.delete(c)\n\t\tend\n\n\t\tx_events = []\n\t\ty_cuboids.each {|c|\n\t\t\tx_events << [:add, c, c.x1]\n\t\t\tx_events << [:del, c, c.x2]\n\t\t}\n\t\tx_events.sort_by!(&:last)\n\t\tlength = 0\n\t\tx = 0\n\t\toverlap = 0\n\t\tuntil x_events.empty?\n\t\t\tnext_x = x_events[0][2]\n\t\t\tlength += next_x - x if overlap >= k\n\n\t\t\twhile !x_events.empty? && x_events[0][2] == next_x\n\t\t\t\tcommand, c, _ = x_events.shift\n\t\t\t\toverlap += (command == :add ? 1 : -1)\n\t\t\tend\n\t\t\tx = next_x\n\t\tend\n\n\t\ty = next_y\n\tend\n\tz = next_z\nend\n\np volume"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int K = input[1];\n    long[][] data = new long[][N];\n    bool[long][] aa = new bool[long][3];\n    foreach(i; 0..N) {\n        data[i] = readln.split.to!(long[]);\n        foreach(j; 0..3) {\n            aa[j][data[i][j]] = true;\n            aa[j][data[i][j+3]] = true;\n        }\n    }\n    int[long[3]] imos;\n    long[][] keys = new long[][3];\n    foreach(i; 0..3) keys[i] = aa[i].keys.sort;\n    aa = null;\n    foreach(k0; keys[0]) foreach(k1; keys[1]) foreach(k2; keys[2]) {\n        imos[[k0, k1, k2]] = 0;\n    }\n    foreach(e; data) {\n        imos[[e[0], e[1], e[2]]]++;\n        imos[[e[3], e[1], e[2]]]--;\n        imos[[e[0], e[4], e[2]]]--;\n        imos[[e[0], e[1], e[5]]]--;\n        imos[[e[3], e[4], e[2]]]++;\n        imos[[e[0], e[4], e[5]]]++;\n        imos[[e[3], e[1], e[5]]]++;\n        imos[[e[3], e[4], e[5]]]--;\n    }\n    foreach(i; 1..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                imos[[keys[0][i], keys[1][j], keys[2][k]]] += imos[[keys[0][i-1], keys[1][j], keys[2][k]]];\n            }\n        }\n    }\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 1..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                imos[[keys[0][i], keys[1][j], keys[2][k]]] += imos[[keys[0][i], keys[1][j-1], keys[2][k]]];\n            }\n        }\n    }\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 1..keys[2].length) {\n                imos[[keys[0][i], keys[1][j], keys[2][k]]] += imos[[keys[0][i], keys[1][j], keys[2][k-1]]];\n            }\n        }\n    }\n    long ans = 0;\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                if (imos[[keys[0][i], keys[1][j], keys[2][k]]]>=K) {\n                    ans += (keys[0][i+1]-keys[0][i])*(keys[1][j+1]-keys[1][j])*(keys[2][k+1]-keys[2][k]);\n                }\n            }\n        }\n    }\n    ans.writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int K = input[1];\n    long[][] data = new long[][N];\n    bool[long][] aa = new bool[long][3];\n    foreach(i; 0..N) {\n        data[i] = readln.split.to!(long[]);\n        foreach(j; 0..3) {\n            aa[j][data[i][j]] = true;\n            aa[j][data[i][j+3]] = true;\n        }\n    }\n    long[][] values = new long[][3];\n    foreach(i; 0..3) values[i] = aa[i].keys.sort;\n    int[long][] keys = new int[long][3];\n    foreach(i; 0..3) foreach(k, v; values[i]) keys[i][v] = k.to!int;\n    int[][][] imos = new int[][][](keys[0].length, keys[1].length, keys[2].length);\n    foreach(e; data) {\n        imos[keys[0][e[0]]][keys[1][e[1]]][keys[2][e[2]]]++;\n        imos[keys[0][e[3]]][keys[1][e[1]]][keys[2][e[2]]]--;\n        imos[keys[0][e[0]]][keys[1][e[4]]][keys[2][e[2]]]--;\n        imos[keys[0][e[0]]][keys[1][e[1]]][keys[2][e[5]]]--;\n        imos[keys[0][e[3]]][keys[1][e[4]]][keys[2][e[2]]]++;\n        imos[keys[0][e[0]]][keys[1][e[4]]][keys[2][e[5]]]++;\n        imos[keys[0][e[3]]][keys[1][e[1]]][keys[2][e[5]]]++;\n        imos[keys[0][e[3]]][keys[1][e[4]]][keys[2][e[5]]]--;\n    }\n    foreach(i; 1..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                imos[i][j][k] += imos[i-1][j][k];\n            }\n        }\n    }\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 1..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                imos[i][j][k] += imos[i][j-1][k];\n            }\n        }\n    }\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 1..keys[2].length) {\n                imos[i][j][k] += imos[i][j][k-1];\n            }\n        }\n    }\n    long ans = 0;\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                if (imos[i][j][k]>=K) {\n                    ans += (values[0][i+1]-values[0][i])*(values[1][j+1]-values[1][j])*(values[2][k+1]-values[2][k]);\n                }\n            }\n        }\n    }\n    ans.writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int K = input[1];\n    long[][] data = new long[][N];\n    bool[long][] aa = new bool[long][3];\n    foreach(i; 0..N) {\n        data[i] = readln.split.to!(long[]);\n        foreach(j; 0..3) {\n            aa[j][data[i][j]] = true;\n            aa[j][data[i][j+3]] = true;\n        }\n    }\n    long[long[3]] imos;\n    long[][] keys = new long[][3];\n    foreach(i; 0..3) keys[i] = aa[i].keys.sort;\n    foreach(k0; keys[0]) foreach(k1; keys[1]) foreach(k2; keys[2]) {\n        imos[[k0, k1, k2]] = 0;\n    }\n    foreach(e; data) {\n        imos[[e[0], e[1], e[2]]]++;\n        imos[[e[3], e[1], e[2]]]--;\n        imos[[e[0], e[4], e[2]]]--;\n        imos[[e[0], e[1], e[5]]]--;\n        imos[[e[3], e[4], e[2]]]++;\n        imos[[e[0], e[4], e[5]]]++;\n        imos[[e[3], e[1], e[5]]]++;\n        imos[[e[3], e[4], e[5]]]--;\n    }\n    foreach(i; 1..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                imos[[keys[0][i], keys[1][j], keys[2][k]]] += imos[[keys[0][i-1], keys[1][j], keys[2][k]]];\n            }\n        }\n    }\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 1..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                imos[[keys[0][i], keys[1][j], keys[2][k]]] += imos[[keys[0][i], keys[1][j-1], keys[2][k]]];\n            }\n        }\n    }\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 1..keys[2].length) {\n                imos[[keys[0][i], keys[1][j], keys[2][k]]] += imos[[keys[0][i], keys[1][j], keys[2][k-1]]];\n            }\n        }\n    }\n    long ans = 0;\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                if (imos[[keys[0][i], keys[1][j], keys[2][k]]]>=K) {\n                    ans += (keys[0][i+1]-keys[0][i])*(keys[1][j+1]-keys[1][j])*(keys[2][k+1]-keys[2][k]);\n                }\n            }\n        }\n    }\n    ans.writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int K = input[1];\n    long[][] data = new long[][N];\n    bool[long][] aa = new bool[long][3];\n    foreach(i; 0..N) {\n        data[i] = readln.split.to!(long[]);\n        foreach(j; 0..3) {\n            aa[j][data[i][j]] = true;\n            aa[j][data[i][j+3]] = true;\n        }\n    }\n    long[][] values = new long[][3];\n    foreach(i; 0..3) values[i] = aa[i].keys.sort;\n    int[long][] keys = new int[long][3];\n    foreach(i; 0..3) foreach(k, v; values[i]) keys[i][v] = k;\n    int[][][] imos = new int[][][](keys[0].length, keys[1].length, keys[2].length);\n    foreach(e; data) {\n        imos[keys[0][e[0]]][keys[1][e[1]]][keys[2][e[2]]]++;\n        imos[keys[0][e[3]]][keys[1][e[1]]][keys[2][e[2]]]--;\n        imos[keys[0][e[0]]][keys[1][e[4]]][keys[2][e[2]]]--;\n        imos[keys[0][e[0]]][keys[1][e[1]]][keys[2][e[5]]]--;\n        imos[keys[0][e[3]]][keys[1][e[4]]][keys[2][e[2]]]++;\n        imos[keys[0][e[0]]][keys[1][e[4]]][keys[2][e[5]]]++;\n        imos[keys[0][e[3]]][keys[1][e[1]]][keys[2][e[5]]]++;\n        imos[keys[0][e[3]]][keys[1][e[4]]][keys[2][e[5]]]--;\n    }\n    foreach(i; 1..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                imos[i][j][k] += imos[i-1][j][k];\n            }\n        }\n    }\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 1..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                imos[i][j][k] += imos[i][j-1][k];\n            }\n        }\n    }\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 1..keys[2].length) {\n                imos[i][j][k] += imos[i][j][k-1];\n            }\n        }\n    }\n    long ans = 0;\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                if (imos[i][j][k]>=K) {\n                    ans += (values[0][i+1]-values[0][i])*(values[1][j+1]-values[1][j])*(values[2][k+1]-values[2][k]);\n                }\n            }\n        }\n    }\n    ans.writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport core.stdc.stdio;\nimport std.algorithm;\n\nstruct cube{\n\tint x1;\n\tint x2;\n\tint y1;\n\tint y2;\n\tint z1;\n\tint z2;\n}\n\nint find(int[] d,int t){\n\tfor(int i=0;i<d.length;i++)\n\t\tif(d[i] == t)\n\t\t\treturn i;\n\treturn -1;\n}\n\nvoid main(){\n\tint n,k;\n\tint[] xs,ys,zs;\n\tcube[] cs;\n\tscanf(\"%d%d\",&n,&k);\n\txs = new int[n*2];\n\tys = new int[n*2];\n\tzs = new int[n*2];\n\tcs = new cube[n];\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d%d%d%d%d\",&cs[i].x1,&cs[i].y1,&cs[i].z1,&cs[i].x2,&cs[i].y2,&cs[i].z2);\n\t\txs[i*2] = cs[i].x1;\n\t\txs[i*2+1] = cs[i].x2;\n\t\tys[i*2] = cs[i].y1;\n\t\tys[i*2+1] = cs[i].y2;\n\t\tzs[i*2] = cs[i].z1;\n\t\tzs[i*2+1] = cs[i].z2;\n\t}\n\tsort(xs);\n\tsort(ys);\n\tsort(zs);\n\t//xs.writeln;\n\t//ys.writeln;\n\t//zs.writeln;\n\tint[] count =  new int[n*n*n*8];\n\tfor(int i=0;i<n;i++){\n\t\tint xl = xs.find(cs[i].x1);\n\t\tint xr = xs.find(cs[i].x2);\n\t\tint yl = ys.find(cs[i].y1);\n\t\tint yr = ys.find(cs[i].y2);\n\t\tint zl = zs.find(cs[i].z1);\n\t\tint zr = zs.find(cs[i].z2);\n\t\tfor(int x=xl;x<xr;x++){\n\t\t\tfor(int y=yl;y<yr;y++){\n\t\t\t\tfor(int z=zl;z<zr;z++){\n\t\t\t\t\tcount[(x*n*2+y)*n*2+z]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int x=0;x<n*2-1;x++){\n\t\tlong xd = xs[x+1]-xs[x];\n\t\tfor(int y=0;y<n*2-1;y++){\n\t\t\tlong yd = ys[y+1]-ys[y];\n\t\t\tfor(int z=0;z<n*2-1;z++){\n\t\t\t\tlong zd = zs[z+1]-zs[z];\n\t\t\t\tif(count[(x*n*2+y)*n*2+z]>=k){\n\t\t\t\t//\twriteln(x,\" \",y,\" \",z,\" \",xd,\" \",yd,\" \",zd);\n\t\t\t\t\tans += xd*yd*zd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int K = input[1];\n    long[][] data = new long[][N];\n    bool[long][] aa = new bool[long][3];\n    foreach(i; 0..N) {\n        data[i] = readln.split.to!(long[]);\n        foreach(j; 0..3) {\n            aa[j][data[i][j]] = true;\n            aa[j][data[i][j+3]] = true;\n        }\n    }\n    int[long[3]] imos;\n    long[][] keys = new long[][3];\n    foreach(i; 0..3) keys[i] = aa[i].keys.sort;\n    foreach(k0; keys[0]) foreach(k1; keys[1]) foreach(k2; keys[2]) {\n        imos[[k0, k1, k2]] = 0;\n    }\n    foreach(e; data) {\n        imos[[e[0], e[1], e[2]]]++;\n        imos[[e[3], e[1], e[2]]]--;\n        imos[[e[0], e[4], e[2]]]--;\n        imos[[e[0], e[1], e[5]]]--;\n        imos[[e[3], e[4], e[2]]]++;\n        imos[[e[0], e[4], e[5]]]++;\n        imos[[e[3], e[1], e[5]]]++;\n        imos[[e[3], e[4], e[5]]]--;\n    }\n    foreach(i; 1..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                imos[[keys[0][i], keys[1][j], keys[2][k]]] += imos[[keys[0][i-1], keys[1][j], keys[2][k]]];\n            }\n        }\n    }\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 1..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                imos[[keys[0][i], keys[1][j], keys[2][k]]] += imos[[keys[0][i], keys[1][j-1], keys[2][k]]];\n            }\n        }\n    }\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 1..keys[2].length) {\n                imos[[keys[0][i], keys[1][j], keys[2][k]]] += imos[[keys[0][i], keys[1][j], keys[2][k-1]]];\n            }\n        }\n    }\n    long ans = 0;\n    foreach(i; 0..keys[0].length) {\n        foreach(j; 0..keys[1].length) {\n            foreach(k; 0..keys[2].length) {\n                if (imos[[keys[0][i], keys[1][j], keys[2][k]]]>=K) {\n                    ans += (keys[0][i+1]-keys[0][i])*(keys[1][j+1]-keys[1][j])*(keys[2][k+1]-keys[2][k]);\n                }\n            }\n        }\n    }\n    ans.writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n \nint[ulong] C(ulong[] X) {\n    ulong[] Y = X.dup.sort.uniq.array;\n    int[ulong] ret;\n    foreach (int i, y; Y) {\n        ret[y] = i;\n    }\n    return ret;\n}\n\nvoid main() {\n    int N, K; readf(\"%d %d\\n\", &N, &K);\n    ulong[] X, Y, Z;\n    foreach (i; 0 .. N) {\n        ulong x, y, z;\n        readf(\"%d %d %d \", &x, &y, &z);\n        X ~= x; Y ~= y; Z ~= z;\n        readf(\"%d %d %d\\n\", &x, &y, &z);\n        X ~= x; Y ~= y; Z ~= z;\n    }\n    auto xM = C(X), yM = C(Y), zM = C(Z);\n    auto nx = xM.length,\n         ny = yM.length,\n         nz = zM.length;\n    int[][][] count = new int[][][](nx, ny, nz);\n    for (int i = 0; i < 2 * N; i += 2) {\n        foreach (x; xM[ X[i] ] .. xM[ X[i + 1] ]) {\n            foreach (y; yM[ Y[i] ] .. yM[ Y[i + 1] ]) {\n                foreach (z; zM[ Z[i] ] .. zM[ Z[i + 1] ]) {\n                    count[x][y][z]++;\n                }\n            }\n        }\n    }\n    ulong[] _X = X.dup.sort.uniq.array,\n            _Y = Y.dup.sort.uniq.array,\n            _Z = Z.dup.sort.uniq.array;\n    ulong ans = 0;\n    foreach (x; 0 .. nx) {\n        foreach (y; 0 .. ny) {\n            foreach (z; 0 .. nz) {\n                if (count[x][y][z] >= K) {\n                    ans += (_X[x + 1] - _X[x]) * (_Y[y + 1] - _Y[y]) * (_Z[z + 1] - _Z[z]);\n                }\n            }\n        }\n    }\n    ans.writeln;\n}"
  },
  {
    "language": "Python",
    "code": "# copy\nn, k = map(int, input().split())\nplst = []\nxlst = []\nylst = []\ndlst = []\n\nfor _ in range(n):\n    x1, y1, d1, x2, y2, d2 = map(int, input().split())\n    plst.append((x1, y1, d1, x2, y2, d2))\n    xlst.append(x1)\n    xlst.append(x2)\n    ylst.append(y1)\n    ylst.append(y2)\n    dlst.append(d1)\n    dlst.append(d2)\n\nxlst = list(set(xlst))\nylst = list(set(ylst))\ndlst = list(set(dlst))\n\nxlst.sort()\nylst.sort()\ndlst.sort()\n\nlx = len(xlst)\nly = len(ylst)\nld = len(dlst)\n\nxdic = dict(reversed(t) for t in enumerate(xlst))\nydic = dict(reversed(t) for t in enumerate(ylst))\nddic = dict(reversed(t) for t in enumerate(dlst))\n\nnew_map = [[[0] * ld for _ in range(ly)] for _ in range(lx)]\n\nfor p in plst:\n    x1, y1, d1, x2, y2, d2 = p\n    x1, y1, d1, x2, y2, d2 = \\\n        xdic[x1], ydic[y1], ddic[d1], xdic[x2], ydic[y2], ddic[d2]\n    for x in range(x1, x2):\n        for y in range(y1, y2):\n            for d in range(d1, d2):\n                new_map[x][y][d] += 1\n\nans = 0\nfor i in range(lx - 1):\n    xlsti = xlst[i]\n    xlsti1 = xlst[i + 1]\n    x = xdic[xlsti]\n    for j in range(ly - 1):\n        ylstj = ylst[j]\n        ylstj1 = ylst[j + 1]\n        y = ydic[ylstj]\n        for z in range(ld - 1):\n            dlstz = dlst[z]\n            dlstz1 = dlst[z + 1]\n            d = ddic[dlstz]\n            if new_map[x][y][d] >= k:\n                ans += (xlsti1 - xlsti) * (ylstj1 - ylstj) * (dlstz1 - dlstz)\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  n, k = map(int, input().split())\n  \n  plst = []\n  xlst = []\n  ylst = []\n  dlst = []\n  \n  for i in range(n):\n    x1,y1,d1,x2,y2,d2 = map(int, input().split())\n    plst.append((x1,y1,d1,x2,y2,d2))\n    xlst.append(x1)\n    xlst.append(x2)\n    ylst.append(y1)\n    ylst.append(y2)\n    dlst.append(d1)\n    dlst.append(d2)\n  \n  xlst = list(set(xlst))\n  ylst = list(set(ylst))\n  dlst = list(set(dlst))\n  \n  xlst.sort()\n  ylst.sort()\n  dlst.sort()\n  \n  xdic = {}\n  ydic = {}\n  ddic = {}\n  \n  for i, v in enumerate(xlst):\n    xdic[v] = i\n  for i, v in enumerate(ylst):\n    ydic[v] = i\n  for i, v in enumerate(dlst):\n    ddic[v] = i\n  \n  new_map = [[[0] * len(dlst) for _ in ylst] for _ in xlst]\n  \n  for p in plst:\n    x1, y1, d1, x2, y2, d2 = p\n    x1, y1, d1, x2, y2, d2 = xdic[x1], ydic[y1], ddic[d1], xdic[x2], ydic[y2], ddic[d2]\n    for x in range(x1, x2):\n      for y in range(y1, y2):\n        for d in range(d1, d2):\n          new_map[x][y][d] += 1\n  \n  ans = 0\n  for i in range(len(xlst) - 1):\n    xlsti = xlst[i]\n    xlsti1 = xlst[i - 1]\n    x = xdic[xlsti]\n    for j in range(len(ylst) - 1):\n      ylstj = ylst[j]\n      ylstj1 = ylst[j - 1]\n      y = ydic[ylstj]\n      for z in range(len(dlst) - 1):\n        dlstz = dlst[z]\n        dlstz1 = dlst[z - 1]\n        d = ddic[dlstz]\n        if new_map[x][y][d] >= k:\n          ans += (xlsti1 - xlsti) * (ylstj1 - ylstj) * (dlstz1 - dlstz)\n  print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  n, k = map(int, input().split())\n  \n  plst = []\n  xlst = []\n  ylst = []\n  dlst = []\n  \n  for i in range(n):\n    x1,y1,d1,x2,y2,d2 = map(int, input().split())\n    plst.append((x1,y1,d1,x2,y2,d2))\n    xlst.append(x1)\n    xlst.append(x2)\n    ylst.append(y1)\n    ylst.append(y2)\n    dlst.append(d1)\n    dlst.append(d2)\n  \n  xlst = list(set(xlst))\n  ylst = list(set(ylst))\n  dlst = list(set(dlst))\n  \n  xlst.sort()\n  ylst.sort()\n  dlst.sort()\n\n  lx = len(xlst)\n  ly = len(ylst)\n  ld = len(dlst)\n  \n  xdic = {}\n  ydic = {}\n  ddic = {}\n  \n  for i, v in enumerate(xlst):\n    xdic[v] = i\n  for i, v in enumerate(ylst):\n    ydic[v] = i\n  for i, v in enumerate(dlst):\n    ddic[v] = i\n  \n  new_map = [[[0] * ld for _ in range(ly)] for _ in range(lx)]\n  \n  for p in plst:\n    x1, y1, d1, x2, y2, d2 = p\n    x1, y1, d1, x2, y2, d2 = xdic[x1], ydic[y1], ddic[d1], xdic[x2], ydic[y2], ddic[d2]\n    for x in range(x1, x2):\n      for y in range(y1, y2):\n        for d in range(d1, d2):\n          new_map[x][y][d] += 1\n  \n  ans = 0\n  for i in range(lx - 1):\n    xlsti = xlst[i]\n    xlsti1 = xlst[i + 1]\n    x = xdic[xlsti]\n    for j in range(ly - 1):\n      ylstj = ylst[j]\n      ylstj1 = ylst[j + 1]\n      y = ydic[ylstj]\n      for z in range(ld - 1):\n        dlstz = dlst[z]\n        dlstz1 = dlst[z + 1]\n        d = ddic[dlstz]\n        if new_map[x][y][d] >= k:\n          ans += (xlsti1 - xlsti) * (ylstj1 - ylstj) * (dlstz1 - dlstz)\n  print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  n, k = map(int, input().split())\n  \n  plst = []\n  xlst = []\n  ylst = []\n  dlst = []\n  \n  for i in range(n):\n    x1,y1,d1,x2,y2,d2 = map(int, input().split())\n    plst.append((x1,y1,d1,x2,y2,d2))\n    xlst.append(x1)\n    xlst.append(x2)\n    ylst.append(y1)\n    ylst.append(y2)\n    dlst.append(d1)\n    dlst.append(d2)\n  \n  xlst = list(set(xlst))\n  ylst = list(set(ylst))\n  dlst = list(set(dlst))\n  \n  xlst.sort()\n  ylst.sort()\n  dlst.sort()\n  \n  xdic = {}\n  ydic = {}\n  ddic = {}\n  \n  for i, v in enumerate(xlst):\n    xdic[v] = i\n  for i, v in enumerate(ylst):\n    ydic[v] = i\n  for i, v in enumerate(dlst):\n    ddic[v] = i\n  \n  new_map = [[[0] * len(dlst) for _ in ylst] for _ in xlst]\n  \n  for p in plst:\n    x1, y1, d1, x2, y2, d2 = p\n    x1, y1, d1, x2, y2, d2 = xdic[x1], ydic[y1], ddic[d1], xdic[x2], ydic[y2], ddic[d2]\n    for x in range(x1, x2):\n      for y in range(y1, y2):\n        for d in range(d1, d2):\n          new_map[x][y][d] += 1\n  \n  ans = 0\n  for i in range(len(xlst) - 1):\n    xlsti = xlst[i]\n    xlsti1 = xlst[i + 1]\n    x = xdic[xlsti]\n    for j in range(len(ylst) - 1):\n      ylstj = ylst[j]\n      ylstj1 = ylst[j + 1]\n      y = ydic[ylstj]\n      for z in range(len(dlst) - 1):\n        dlstz = dlst[z]\n        dlstz1 = dlst[z + 1]\n        d = ddic[dlstz]\n        if new_map[x][y][d] >= k:\n          ans += (xlsti1 - xlsti) * (ylstj1 - ylstj) * (dlstz1 - dlstz)\n  print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "n, k = map(int, input().split())\n\nplst = []\nxlst = []\nylst = []\ndlst = []\n\nfor i in range(n):\n  x1,y1,d1,x2,y2,d2 = map(int, input().split())\n  plst.append((x1,y1,d1,x2,y2,d2))\n  xlst.append(x1)\n  xlst.append(x2)\n  ylst.append(y1)\n  ylst.append(y2)\n  dlst.append(d1)\n  dlst.append(d2)\n\nxlst = list(set(xlst))\nylst = list(set(ylst))\ndlst = list(set(dlst))\n\nxlst.sort()\nylst.sort()\ndlst.sort()\n\nxdic = {}\nydic = {}\nddic = {}\n\nfor i, v in enumerate(xlst):\n  xdic[v] = i\nfor i, v in enumerate(ylst):\n  ydic[v] = i\nfor i, v in enumerate(dlst):\n  ddic[v] = i\n\nnew_map = [[[0] * len(dlst) for _ in ylst] for _ in xlst]\n\nfor p in plst:\n  x1, y1, d1, x2, y2, d2 = p\n  x1, y1, d1, x2, y2, d2 = xdic[x1], ydic[y1], ddic[d1], xdic[x2], ydic[y2], ddic[d2]\n  for x in range(x1, x2):\n    for y in range(y1, y2):\n      for d in range(d1, d2):\n        new_map[x][y][d] += 1\n\nans = 0\nfor i in range(len(xlst) - 1):\n  for j in range(len(ylst) - 1):\n    for z in range(len(dlst) - 1):\n      x, y, d = xdic[xlst[i]], ydic[ylst[j]], ddic[dlst[z]]\n      if new_map[x][y][d] >= k:\n        ans += (xlst[i + 1] - xlst[i]) *(ylst[j + 1] - ylst[j]) * (dlst[z + 1] - dlst[z])\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\n\ninput_lines = sys.stdin.read().splitlines()\nN, K = [int(x) for x in input_lines[0].split(' ')]\nx_grid = set()\ny_grid = set()\nd_grid = set()\nfor line in input_lines[1:]:\n    x1, y1, d1, x2, y2, d2 = [int(x) for x in line.split(' ')]\n    x_grid.add(x1)\n    x_grid.add(x2)\n    y_grid.add(y1)\n    y_grid.add(y2)\n    d_grid.add(d1)\n    d_grid.add(d2)\n\nx_grid = sorted(x_grid)\ny_grid = sorted(y_grid)\nd_grid = sorted(d_grid)\nx_grid_index = {x[1]:x[0] for x in enumerate(x_grid)}\ny_grid_index = {y[1]:y[0] for y in enumerate(y_grid)}\nd_grid_index = {d[1]:d[0] for d in enumerate(d_grid)}\n\nfish_dist = [[[0 for i in range(len(d_grid))] for i in range(len(y_grid))] for i in range(len(x_grid))]\n\nfor line in input_lines[1:]:\n    x1, y1, d1, x2, y2, d2 = [int(x) for x in line.split(' ')]\n    x1_index = x_grid_index[x1]\n    x2_index = x_grid_index[x2]\n    y1_index = y_grid_index[y1]\n    y2_index = y_grid_index[y2]\n    d1_index = d_grid_index[d1]\n    d2_index = d_grid_index[d2]\n    for x, y, d in itertools.product( range(x1_index, x2_index), range(y1_index, y2_index), range(d1_index, d2_index) ):\n        fish_dist[x][y][d] += 1\n\nvolume = 0\nfor x_index, y_index, d_index in itertools.product(range(len(x_grid)), range(len(y_grid)), range(len(d_grid))):\n    if fish_dist[x_index][y_index][d_index] >= K:\n        x_begin = x_grid[x_index]\n        y_begin = y_grid[y_index]\n        d_begin = d_grid[d_index]\n        x_end = x_grid[x_index + 1]\n        y_end = y_grid[y_index + 1]\n        d_end = d_grid[d_index + 1]\n        volume += (x_end - x_begin) * (y_end - y_begin) * (d_end - d_begin)\nprint(volume)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\ninput_str = raw_input()\nN, K = [int(x) for x in input_str.split(' ')]\ninput_lines = []\nfor n in range(N):\n    input_str = raw_input()\n    input_lines.append(input_str)\nx_grid = set()\ny_grid = set()\nd_grid = set()\nfor line in input_lines:\n    x1, y1, d1, x2, y2, d2 = [int(x) for x in line.split(' ')]\n    x_grid.add(x1)\n    x_grid.add(x2)\n    y_grid.add(y1)\n    y_grid.add(y2)\n    d_grid.add(d1)\n    d_grid.add(d2)\n\nx_grid = sorted(x_grid)\ny_grid = sorted(y_grid)\nd_grid = sorted(d_grid)\nx_grid_index = {x[1]:x[0] for x in enumerate(x_grid)}\ny_grid_index = {y[1]:y[0] for y in enumerate(y_grid)}\nd_grid_index = {d[1]:d[0] for d in enumerate(d_grid)}\n\nfish_dist = np.zeros( (len(x_grid), len(y_grid), len(d_grid)), dtype=int )\n\nfor line in input_lines:\n    x1, y1, d1, x2, y2, d2 = [int(x) for x in line.split(' ')]\n    x1_index = x_grid_index[x1]\n    x2_index = x_grid_index[x2]\n    y1_index = y_grid_index[y1]\n    y2_index = y_grid_index[y2]\n    d1_index = d_grid_index[d1]\n    d2_index = d_grid_index[d2]\n    fish_dist[x1_index:x2_index, y1_index:y2_index, d1_index:d2_index] += 1\n\nvolume = 0\nfor (x_index, y_index, d_index), num in np.ndenumerate(fish_dist):\n    if num >= K:\n        x_begin = x_grid[x_index]\n        y_begin = y_grid[y_index]\n        d_begin = d_grid[d_index]\n        x_end = x_grid[x_index + 1]\n        y_end = y_grid[y_index + 1]\n        d_end = d_grid[d_index + 1]\n        volume += (x_end - x_begin) * (y_end - y_begin) * (d_end - d_begin)\nprint(volume)"
  },
  {
    "language": "Python",
    "code": "input_str = raw_input()\nN, K = [int(x) for x in input_str[0].split(' ')]\n\nx_grid = set()\ny_grid = set()\nd_grid = set()\n\nfor line in input_str[1:]:\n    x1, y1, d1, x2, y2, d2 = [int(x) for x in line.split(' ')]\n    x_grid.add(x1)\n    x_grid.add(x2)\n    y_grid.add(y1)\n    y_grid.add(y2)\n    d_grid.add(d1)\n    d_grid.add(d2)\n\nx_grid = sorted(x_grid)\ny_grid = sorted(y_grid)\nd_grid = sorted(d_grid)\nx_grid_index = {x[1]:x[0] for x in enumerate(x_grid)}\ny_grid_index = {y[1]:y[0] for y in enumerate(y_grid)}\nd_grid_index = {d[1]:d[0] for d in enumerate(d_grid)}\n\nfish_dist = np.zeros( (len(x_grid), len(y_grid), len(d_grid)), dtype=int )\n\nfor line in input_str[1:]:\n    x1, y1, d1, x2, y2, d2 = [int(x) for x in line.split(' ')]\n    x1_index = x_grid_index[x1]\n    x2_index = x_grid_index[x2]\n    y1_index = y_grid_index[y1]\n    y2_index = y_grid_index[y2]\n    d1_index = d_grid_index[d1]\n    d2_index = d_grid_index[d2]\n    fish_dist[x1_index:x2_index, y1_index:y2_index, d1_index:d2_index] += 1\n\nvolume = 0\nfor (x_index, y_index, d_index), num in np.ndenumerate(fish_dist):\n    if num >= K:\n        x_begin = x_grid[x_index]\n        y_begin = y_grid[y_index]\n        d_begin = d_grid[d_index]\n        x_end = x_grid[x_index + 1]\n        y_end = y_grid[y_index + 1]\n        d_end = d_grid[d_index + 1]\n        volume += (x_end - x_begin) * (y_end - y_begin) * (d_end - d_begin)\nprint volume"
  },
  {
    "language": "Python",
    "code": "import sys\nimport array\n\ninput_lines = sys.stdin.read().splitlines()\nN, K = [int(x) for x in input_lines[0].split(' ')]\nx_grid = set()\ny_grid = set()\nd_grid = set()\nfor line in input_lines[1:]:\n    x1, y1, d1, x2, y2, d2 = [int(x) for x in line.split(' ')]\n    x_grid.add(x1)\n    x_grid.add(x2)\n    y_grid.add(y1)\n    y_grid.add(y2)\n    d_grid.add(d1)\n    d_grid.add(d2)\n\nx_grid = sorted(x_grid)\ny_grid = sorted(y_grid)\nd_grid = sorted(d_grid)\nx_grid_index = {x[1]:x[0] for x in enumerate(x_grid)}\ny_grid_index = {y[1]:y[0] for y in enumerate(y_grid)}\nd_grid_index = {d[1]:d[0] for d in enumerate(d_grid)}\n\nfish_dist = array.array('i', [0 for x in range(len(x_grid) * len(y_grid) * len(d_grid))])\n\ndef index2arr(x, y, d):\n    return x + len(x_grid) * y + len(x_grid) * len(y_grid) * d\n\ndef arr2index(index):\n    x = index % len(x_grid)\n    y = ((index - x) // len(x_grid)) % len(y_grid)\n    d = (index - x - len(x_grid) * y) // len(x_grid) // len(d_grid)\n    return x, y, d\n\nfor line in input_lines[1:]:\n    x1, y1, d1, x2, y2, d2 = [int(x) for x in line.split(' ')]\n    x1_index = x_grid_index[x1]\n    x2_index = x_grid_index[x2]\n    y1_index = y_grid_index[y1]\n    y2_index = y_grid_index[y2]\n    d1_index = d_grid_index[d1]\n    d2_index = d_grid_index[d2]\n    for x in range(x1_index, x2_index):\n        for y in range(y1_index, y2_index):\n            for d in range(d1_index, d2_index):\n                fish_dist[index2arr(x,y,d)] += 1\n\nvolume = 0\nfor index, num in [x for x in enumerate(fish_dist) if x[1] >= K]:\n    x_index, y_index, d_index = arr2index(index)\n    x_begin = x_grid[x_index]\n    y_begin = y_grid[y_index]\n    d_begin = d_grid[d_index]\n    x_end = x_grid[x_index + 1]\n    y_end = y_grid[y_index + 1]\n    d_end = d_grid[d_index + 1]\n    volume += (x_end - x_begin) * (y_end - y_begin) * (d_end - d_begin)\nprint(volume)"
  },
  {
    "language": "Python",
    "code": "import itertools\n\ndef main():\n    input_lines = []\n    input_lines.append(input())\n    N, K = [int(x) for x in input_lines[0].split(' ')]\n    for i in range(N):\n        input_lines.append(input())\n\n    grid = [set() for i in range(3)]\n    data = []\n    for line in input_lines[1:]:\n        x1, y1, d1, x2, y2, d2 = [int(x) for x in line.split(' ')]\n        data.append((x1, y1, d1, x2, y2, d2))\n        grid[0].add(x1)\n        grid[0].add(x2)\n        grid[1].add(y1)\n        grid[1].add(y2)\n        grid[2].add(d1)\n        grid[2].add(d2)\n\n    grid = [sorted(g) for g in grid]\n    grid_index = [{x[1]:x[0] for x in enumerate(g)} for g in grid]\n    grid_len = [len(g) for g in grid]\n\n    fish_dist = [[[0 for i in range(grid_len[2])] for i in range(grid_len[1])] for i in range(grid_len[0])]\n\n    for x1, y1, d1, x2, y2, d2 in data:\n        x1_index = grid_index[0][x1]\n        x2_index = grid_index[0][x2]\n        y1_index = grid_index[1][y1]\n        y2_index = grid_index[1][y2]\n        d1_index = grid_index[2][d1]\n        d2_index = grid_index[2][d2]\n        for x_index, y_index, d_index in itertools.product( range(x1_index, x2_index), range(y1_index, y2_index), range(d1_index, d2_index) ):\n            fish_dist[x_index][y_index][d_index] += 1\n\n    volume = 0\n    for x_index, y_index, d_index in itertools.product(range(grid_len[0]), range(grid_len[1]), range(grid_len[2])):\n        if fish_dist[x_index][y_index][d_index] >= K:\n            x_begin = grid[0][x_index]\n            y_begin = grid[1][y_index]\n            d_begin = grid[2][d_index]\n            x_end = grid[0][x_index + 1]\n            y_end = grid[1][y_index + 1]\n            d_end = grid[2][d_index + 1]\n            volume += (x_end - x_begin) * (y_end - y_begin) * (d_end - d_begin)\n    print(volume)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "input_str = raw_input()\nN, K = [int(x) for x in input_str[0].split(' ')]\n\nx_grid = set()\ny_grid = set()\nd_grid = set()\n\nfor line in input_str[1:]:\n    x1, y1, d1, x2, y2, d2 = [int(x) for x in line.split(' ')]\n    x_grid.add(x1)\n    x_grid.add(x2)\n    y_grid.add(y1)\n    y_grid.add(y2)\n    d_grid.add(d1)\n    d_grid.add(d2)\n\nx_grid = sorted(x_grid)\ny_grid = sorted(y_grid)\nd_grid = sorted(d_grid)\nx_grid_index = {x[1]:x[0] for x in enumerate(x_grid)}\ny_grid_index = {y[1]:y[0] for y in enumerate(y_grid)}\nd_grid_index = {d[1]:d[0] for d in enumerate(d_grid)}\n\nfish_dist = np.zeros( (len(x_grid), len(y_grid), len(d_grid)), dtype=int )\n\nfor line in input_str[1:]:\n    x1, y1, d1, x2, y2, d2 = [int(x) for x in line.split(' ')]\n    x1_index = x_grid_index[x1]\n    x2_index = x_grid_index[x2]\n    y1_index = y_grid_index[y1]\n    y2_index = y_grid_index[y2]\n    d1_index = d_grid_index[d1]\n    d2_index = d_grid_index[d2]\n    fish_dist[x1_index:x2_index, y1_index:y2_index, d1_index:d2_index] += 1\n\nvolume = 0\nfor (x_index, y_index, d_index), num in np.ndenumerate(fish_dist):\n    if num >= K:\n        x_begin = x_grid[x_index]\n        y_begin = y_grid[y_index]\n        d_begin = d_grid[d_index]\n        x_end = x_grid[x_index + 1]\n        y_end = y_grid[y_index + 1]\n        d_end = d_grid[d_index + 1]\n        volume += (x_end - x_begin) * (y_end - y_begin) * (d_end - d_begin)\nprint volume"
  },
  {
    "language": "Python",
    "code": "import sys\nimport array\n\ninput_lines = sys.stdin.read().splitlines()\nN, K = [int(x) for x in input_lines[0].split(' ')]\nx_grid = set()\ny_grid = set()\nd_grid = set()\nfor line in input_lines[1:]:\n    x1, y1, d1, x2, y2, d2 = [int(x) for x in line.split(' ')]\n    x_grid.add(x1)\n    x_grid.add(x2)\n    y_grid.add(y1)\n    y_grid.add(y2)\n    d_grid.add(d1)\n    d_grid.add(d2)\n\nx_grid = sorted(x_grid)\ny_grid = sorted(y_grid)\nd_grid = sorted(d_grid)\nx_grid_index = {x[1]:x[0] for x in enumerate(x_grid)}\ny_grid_index = {y[1]:y[0] for y in enumerate(y_grid)}\nd_grid_index = {d[1]:d[0] for d in enumerate(d_grid)}\n\nfish_dist = array.array('i', [0 for x in xrange(len(x_grid) * len(y_grid) * len(d_grid))])\n\ndef index2arr(x, y, d):\n    return x + len(x_grid) * y + len(x_grid) * len(y_grid) * d\n\ndef arr2index(index):\n    x = index % len(x_grid)\n    y = ((index - x) / len(x_grid)) % len(y_grid)\n    d = (index - x - len(x_grid) * y) / len(x_grid) / len(d_grid)\n    return x, y, d\n\nfor line in input_lines[1:]:\n    x1, y1, d1, x2, y2, d2 = [int(x) for x in line.split(' ')]\n    x1_index = x_grid_index[x1]\n    x2_index = x_grid_index[x2]\n    y1_index = y_grid_index[y1]\n    y2_index = y_grid_index[y2]\n    d1_index = d_grid_index[d1]\n    d2_index = d_grid_index[d2]\n    for x in xrange(x1_index, x2_index):\n        for y in xrange(y1_index, y2_index):\n            for d in xrange(d1_index, d2_index):\n                fish_dist[index2arr(x,y,d)] += 1\n\nvolume = 0\nfor index, num in [x for x in enumerate(fish_dist) if x[1] >= K]:\n    x_index, y_index, d_index = arr2index(index)\n    x_begin = x_grid[x_index]\n    y_begin = y_grid[y_index]\n    d_begin = d_grid[d_index]\n    x_end = x_grid[x_index + 1]\n    y_end = y_grid[y_index + 1]\n    d_end = d_grid[d_index + 1]\n    volume += (x_end - x_begin) * (y_end - y_begin) * (d_end - d_begin)\nprint(volume)"
  }
]