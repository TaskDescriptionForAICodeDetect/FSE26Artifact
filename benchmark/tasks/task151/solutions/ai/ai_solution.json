[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x1, y1, z1, x2, y2, z2;\n} Rect;\n\nint max(int a, int b) { return a > b ? a : b; }\nint min(int a, int b) { return a < b ? a : b; }\n\nRect overlap(Rect a, Rect b) {\n    Rect res;\n    res.x1 = max(a.x1, b.x1);\n    res.y1 = max(a.y1, b.y1);\n    res.z1 = max(a.z1, b.z1);\n    res.x2 = min(a.x2, b.x2);\n    res.y2 = min(a.y2, b.y2);\n    res.z2 = min(a.z2, b.z2);\n    if (res.x1 >= res.x2 || res.y1 >= res.y2 || res.z1 >= res.z2) {\n        res.x1 = res.y1 = res.z1 = res.x2 = res.y2 = res.z2 = 0;\n    }\n    return res;\n}\n\nint volume(Rect r) {\n    return (r.x2 - r.x1) * (r.y2 - r.y1) * (r.z2 - r.z1);\n}\n\nvoid generateOverlaps(Rect *rects, int n, int k, int index, Rect current, int count, long long *total) {\n    if (index == n) {\n        if (count >= k) {\n            *total += volume(current);\n        }\n        return;\n    }\n    generateOverlaps(rects, n, k, index + 1, current, count, total);\n    Rect newRect = overlap(current, rects[index]);\n    if (volume(newRect) > 0) {\n        generateOverlaps(rects, n, k, index + 1, newRect, count + 1, total);\n    }\n}\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n    Rect *rects = malloc(N * sizeof(Rect));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d %d %d %d\", &rects[i].x1, &rects[i].y1, &rects[i].z1, &rects[i].x2, &rects[i].y2, &rects[i].z2);\n        if (rects[i].x1 > rects[i].x2) {\n            int temp = rects[i].x1;\n            rects[i].x1 = rects[i].x2;\n            rects[i].x2 = temp;\n        }\n        if (rects[i].y1 > rects[i].y2) {\n            int temp = rects[i].y1;\n            rects[i].y1 = rects[i].y2;\n            rects[i].y2 = temp;\n        }\n        if (rects[i].z1 > rects[i].z2) {\n            int temp = rects[i].z1;\n            rects[i].z1 = rects[i].z2;\n            rects[i].z2 = temp;\n        }\n    }\n\n    long long total = 0;\n    Rect universe = {INT_MIN, INT_MIN, INT_MIN, INT_MAX, INT_MAX, INT_MAX};\n    generateOverlaps(rects, N, K, 0, universe, 0, &total);\n\n    printf(\"%lld\\n\", total);\n    free(rects);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:49:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FishHabitatOverlap {\n    static class Cuboid {\n        int x1, y1, z1, x2, y2, z2;\n        \n        Cuboid(int x1, int y1, int z1, int x2, int y2, int z2) {\n            this.x1 = Math.min(x1, x2);\n            this.y1 = Math.min(y1, y2);\n            this.z1 = Math.min(z1, z2);\n            this.x2 = Math.max(x1, x2);\n            this.y2 = Math.max(y1, y2);\n            this.z2 = Math.max(z1, z2);\n        }\n    }\n\n    public static long calculateOverlapVolume(List<Cuboid> cuboids, int k) {\n        int MAX = 101;\n        int[][][] overlap = new int[MAX][MAX][MAX];\n        \n        for (Cuboid cuboid : cuboids) {\n            for (int x = cuboid.x1; x < cuboid.x2; x++) {\n                for (int y = cuboid.y1; y < cuboid.y2; y++) {\n                    for (int z = cuboid.z1; z < cuboid.z2; z++) {\n                        overlap[x][y][z]++;\n                    }\n                }\n            }\n        }\n        \n        long totalVolume = 0;\n        for (int x = 0; x < MAX; x++) {\n            for (int y = 0; y < MAX; y++) {\n                for (int z = 0; z < MAX; z++) {\n                    if (overlap[x][y][z] >= k) {\n                        totalVolume++;\n                    }\n                }\n            }\n        }\n        \n        return totalVolume;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n        \n        List<Cuboid> cuboids = new ArrayList<>();\n        \n        for (int i = 0; i < N; i++) {\n            int x1 = scanner.nextInt();\n            int y1 = scanner.nextInt();\n            int z1 = scanner.nextInt();\n            int x2 = scanner.nextInt();\n            int y2 = scanner.nextInt();\n            int z2 = scanner.nextInt();\n            \n            cuboids.add(new Cuboid(x1, y1, z1, x2, y2, z2));\n        }\n        \n        long result = calculateOverlapVolume(cuboids, K);\n        System.out.println(result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:49:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Rect {\n    int x1, y1, z1, x2, y2, z2;\n};\n\nvector<int> get_unique_coords(const vector<Rect>& rects, int (Rect::*a), int (Rect::*b)) {\n    vector<int> coords;\n    for (const auto& r : rects) {\n        coords.push_back(r.*a);\n        coords.push_back(r.*b);\n    }\n    sort(coords.begin(), coords.end());\n    coords.erase(unique(coords.begin(), coords.end()), coords.end());\n    return coords;\n}\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<Rect> rects(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> rects[i].x1 >> rects[i].y1 >> rects[i].z1 >> rects[i].x2 >> rects[i].y2 >> rects[i].z2;\n        if (rects[i].x1 > rects[i].x2) swap(rects[i].x1, rects[i].x2);\n        if (rects[i].y1 > rects[i].y2) swap(rects[i].y1, rects[i].y2);\n        if (rects[i].z1 > rects[i].z2) swap(rects[i].z1, rects[i].z2);\n    }\n\n    vector<int> xs = get_unique_coords(rects, &Rect::x1, &Rect::x2);\n    vector<int> ys = get_unique_coords(rects, &Rect::y1, &Rect::y2);\n    vector<int> zs = get_unique_coords(rects, &Rect::z1, &Rect::z2);\n\n    long long total_volume = 0;\n\n    for (int i = 0; i < xs.size() - 1; ++i) {\n        for (int j = 0; j < ys.size() - 1; ++j) {\n            for (int k = 0; k < zs.size() - 1; ++k) {\n                int x1 = xs[i], x2 = xs[i + 1];\n                int y1 = ys[j], y2 = ys[j + 1];\n                int z1 = zs[k], z2 = zs[k + 1];\n                int count = 0;\n                for (const auto& r : rects) {\n                    if (r.x1 <= x1 && r.x2 >= x2 && r.y1 <= y1 && r.y2 >= y2 && r.z1 <= z1 && r.z2 >= z2) {\n                        count++;\n                    }\n                }\n                if (count >= K) {\n                    total_volume += (long long)(x2 - x1) * (y2 - y1) * (z2 - z1);\n                }\n            }\n        }\n    }\n\n    cout << total_volume << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_FISH 100\n#define MAX_INTERSECTIONS 1000\n\ntypedef struct {\n    int x1, y1, z1;\n    int x2, y2, z2;\n} Habitat;\n\ntypedef struct {\n    int x1, y1, z1;\n    int x2, y2, z2;\n    int count;\n} Intersection;\n\nIntersection intersections[MAX_INTERSECTIONS];\nint intersectionCount = 0;\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nvoid addIntersection(int x1, int y1, int z1, int x2, int y2, int z2, int count) {\n    intersections[intersectionCount].x1 = x1;\n    intersections[intersectionCount].y1 = y1;\n    intersections[intersectionCount].z1 = z1;\n    intersections[intersectionCount].x2 = x2;\n    intersections[intersectionCount].y2 = y2;\n    intersections[intersectionCount].z2 = z2;\n    intersections[intersectionCount].count = count;\n    intersectionCount++;\n}\n\nlong long calculateVolume(Intersection* intersection) {\n    long long volume = (long long)(intersection->x2 - intersection->x1) *\n                       (intersection->y2 - intersection->y1) *\n                       (intersection->z2 - intersection->z1);\n    return volume;\n}\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    Habitat habitats[MAX_FISH];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d %d %d %d\", \n              &habitats[i].x1, &habitats[i].y1, &habitats[i].z1, \n              &habitats[i].x2, &habitats[i].y2, &habitats[i].z2);\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int x1 = max(habitats[i].x1, habitats[j].x1);\n            int y1 = max(habitats[i].y1, habitats[j].y1);\n            int z1 = max(habitats[i].z1, habitats[j].z1);\n            int x2 = min(habitats[i].x2, habitats[j].x2);\n            int y2 = min(habitats[i].y2, habitats[j].y2);\n            int z2 = min(habitats[i].z2, habitats[j].z2);\n\n            if (x1 < x2 && y1 < y2 && z1 < z2) {\n                addIntersection(x1, y1, z1, x2, y2, z2, 2);\n            }\n        }\n    }\n\n    long long totalVolume = 0;\n    for (int i = 0; i < intersectionCount; i++) {\n        if (intersections[i].count >= K) {\n            totalVolume += calculateVolume(&intersections[i]);\n        }\n    }\n\n    printf(\"%lld\\n\", totalVolume);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Habitat {\n    int x1, y1, z1, x2, y2, z2;\n};\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    \n    vector<Habitat> habitats(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> habitats[i].x1 >> habitats[i].y1 >> habitats[i].z1 \n            >> habitats[i].x2 >> habitats[i].y2 >> habitats[i].z2;\n    }\n    \n    long long totalVolume = 0;\n    \n    for (int mask = 1; mask < (1 << N); ++mask) {\n        if (__builtin_popcount(mask) < K) continue;\n        \n        int x1 = INT_MIN, y1 = INT_MIN, z1 = INT_MIN;\n        int x2 = INT_MAX, y2 = INT_MAX, z2 = INT_MAX;\n        \n        for (int i = 0; i < N; ++i) {\n            if (mask & (1 << i)) {\n                x1 = max(x1, habitats[i].x1);\n                y1 = max(y1, habitats[i].y1);\n                z1 = max(z1, habitats[i].z1);\n                x2 = min(x2, habitats[i].x2);\n                y2 = min(y2, habitats[i].y2);\n                z2 = min(z2, habitats[i].z2);\n            }\n        }\n        \n        if (x1 < x2 && y1 < y2 && z1 < z2) {\n            long long volume = (long long)(x2 - x1) * (y2 - y1) * (z2 - z1);\n            totalVolume += volume * (__builtin_popcount(mask) % 2 ? 1 : -1);\n        }\n    }\n    \n    cout << totalVolume << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FishHabitatOverlap {\n    static class Event implements Comparable<Event> {\n        int type; // 0 for x, 1 for y, 2 for z\n        int val;\n        int delta;\n\n        Event(int type, int val, int delta) {\n            this.type = type;\n            this.val = val;\n            this.delta = delta;\n        }\n\n        @Override\n        public int compareTo(Event other) {\n            if (this.val != other.val) {\n                return Integer.compare(this.val, other.val);\n            }\n            return Integer.compare(this.delta, other.delta);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n\n        List<Event> xEvents = new ArrayList<>();\n        List<Event> yEvents = new ArrayList<>();\n        List<Event> zEvents = new ArrayList<>();\n\n        for (int i = 0; i < N; i++) {\n            int x1 = scanner.nextInt();\n            int y1 = scanner.nextInt();\n            int z1 = scanner.nextInt();\n            int x2 = scanner.nextInt();\n            int y2 = scanner.nextInt();\n            int z2 = scanner.nextInt();\n\n            xEvents.add(new Event(0, Math.min(x1, x2), 1));\n            xEvents.add(new Event(0, Math.max(x1, x2), -1));\n\n            yEvents.add(new Event(1, Math.min(y1, y2), 1));\n            yEvents.add(new Event(1, Math.max(y1, y2), -1));\n\n            zEvents.add(new Event(2, Math.min(z1, z2), 1));\n            zEvents.add(new Event(2, Math.max(z1, z2), -1));\n        }\n\n        Collections.sort(xEvents);\n        Collections.sort(yEvents);\n        Collections.sort(zEvents);\n\n        long totalVolume = 0;\n        int activeX = 0;\n        int prevX = 0;\n\n        for (int i = 0; i < xEvents.size(); i++) {\n            Event e = xEvents.get(i);\n            if (activeX >= K) {\n                long deltaX = e.val - prevX;\n                if (deltaX > 0) {\n                    int activeY = 0;\n                    int prevY = 0;\n                    for (int j = 0; j < yEvents.size(); j++) {\n                        Event f = yEvents.get(j);\n                        if (activeY >= K) {\n                            long deltaY = f.val - prevY;\n                            if (deltaY > 0) {\n                                int activeZ = 0;\n                                int prevZ = 0;\n                                for (int k = 0; k < zEvents.size(); k++) {\n                                    Event g = zEvents.get(k);\n                                    if (activeZ >= K) {\n                                        long deltaZ = g.val - prevZ;\n                                        if (deltaZ > 0) {\n                                            totalVolume += deltaX * deltaY * deltaZ;\n                                        }\n                                    }\n                                    activeZ += g.delta;\n                                    prevZ = g.val;\n                                }\n                            }\n                        }\n                        activeY += f.delta;\n                        prevY = f.val;\n                    }\n                }\n            }\n            activeX += e.delta;\n            prevX = e.val;\n        }\n\n        System.out.println(totalVolume);\n    }\n}",
    "timestamp": "2025-08-05 18:51:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import accumulate\n\ndef calculate_overlapping_volume(n, k, habitats):\n    events = []\n    for x1, y1, z1, x2, y2, z2 in habitats:\n        events.append((x1, y1, z1, x2, y2, z2, 1))\n        events.append((x2, y1, z1, x1, y2, z2,-1))\n    \n    events.sort()\n    \n    total_volume = 0\n    active_intervals = []\n    \n    for x, y1, z1, y2, z2, x_op in events:\n        volume = 0\n        current_yz_intervals = []\n        for y_start, z_start, y_end, z_end, op in active_intervals:\n            if current_yz_intervals and current_yz_intervals[-1][0] >= y_start:\n                prev_y_start, prev_z_start, prev_y_end, prev_z_end, prev_op = current_yz_intervals.pop()\n                dr = op + prev_op\n                volume += (y_end - prev_y_start) * (z_end - prev_z_start) if dr >= k else 0\n                current_yz_intervals.append((y_start, z_start, y_end, z_end, dr))\n                continue\n            volume += (y_end - y_start) * (z_end - z_start) if op >= k else 0\n            current_yz_intervals.append((y_start, z_start, y_end, z_end, op))\n        \n        if active_intervals: \n            total_volume += volume * (x - active_intervals[-1][0])\n        \n        if x_op == 1:\n            active_intervals.append((x, y1, z1, y2, z2))\n        else:\n            active_intervals.remove((x, y1, z1, y2, z2))\n\n    return total_volume\n\nn, k = map(int, input().split())\nhabitats = [list(map(int, input().split())) for _ in range(n)]\nprint(calculate_overlapping_volume(n, k, habitats))",
    "timestamp": "2025-08-13 01:08:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class FishHabitatOverlap {\n    static class Event {\n        int x, y1, y2, z1, z2;\n        boolean isStart;\n\n        Event(int x, int y1, int y2, int z1, int z2, boolean isStart) {\n            this.x = x;\n            this.y1 = y1;\n            this.y2 = y2;\n            this.z1 = z1;\n            this.z2 = z2;\n            this.isStart = isStart;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n\n        List<Event> events = new ArrayList<>();\n        int[] xx = new int[2 * N];\n        \n        for (int i = 0; i < N; i++) {\n            int x1 = scanner.nextInt();\n            int y1 = scanner.nextInt();\n            int z1 = scanner.nextInt();\n            int x2 = scanner.nextInt();\n            int y2 = scanner.nextInt();\n            int z2 = scanner.nextInt();\n            events.add(new Event(x1, y1, y2, z1, z2, true));\n            events.add(new Event(x2, y1, y2, z1, z2, false));\n            xx[2 * i] = x1;\n            xx[2 * i + 1] = x2;\n        }\n\n        Arrays.sort(xx);\n        Collections.sort(events, Comparator.comparingInt(e -> e.x));\n\n        int totalVolume = 0;\n        int[] active = new int[1000]; // Assume suitable boundaries\n        for (int i = 0; i < xx.length - 1; i++) {\n            int x = xx[i];\n            List<int[]> yzEvents = new ArrayList<>();\n            \n            for (Event event : events) {\n                if (event.x <= x && event.x > x) {\n                    yzEvents.add(new int[] {event.y1, event.y2, event.z1, event.z2, event.isStart ? 1 : -1});\n                }\n            }\n            \n            int yLen = 0, zLen = 0;\n            Arrays.sort(yzEvents, Comparator.comparingInt(a -> a[0]));\n            int countY = 0;\n            \n            for (int j = 0; j < yzEvents.size(); j++) {\n                int[] e = yzEvents.get(j);\n                if (j > 0) {\n                    int yDelta = e[0] - yzEvents.get(j - 1)[0];\n                    if (countY >= K) {\n                        yLen += yDelta;\n                        int del = yzEvents.get(j - 1)[3] - e[3];\n                        if (del > 0) zLen += del;\n                    }\n                }\n                countY += e[4];\n            }\n            \n            totalVolume += yLen * zLen * (xx[i + 1] - xx[i]);\n        }\n        \n        System.out.println(totalVolume);\n    }\n}",
    "timestamp": "2025-08-13 01:08:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int x1, y1, z1, x2, y2, z2;\n} Habitat;\n\ntypedef struct {\n    int coord;\n    int type; // 1 for start, -1 for end\n    int index;\n} Event;\n\nint compare(const void *a, const void *b) {\n    Event *e1 = (Event*)a;\n    Event *e2 = (Event*)b;\n    if (e1->coord != e2->coord) return e1->coord - e2->coord;\n    return e1->type - e2->type; // Ensure starts come before ends at the same coordinate\n}\n\nlong long calculateArea(int *active, int len, Habitat *habitats, int K) {\n    int count = 0;\n    long long area = 0;\n    int prevY = 0;\n    \n    // Sort events in the y axis\n    Event y_events[2*len];\n    int y_size = 0;\n    for (int i = 0; i < len; i++) {\n        y_events[y_size++] = (Event){habitats[active[i]].y1, 1, active[i]};\n        y_events[y_size++] = (Event){habitats[active[i]].y2, -1, active[i]};\n    }\n    qsort(y_events, y_size, sizeof(Event), compare);\n    \n    int activeZ[y_size];\n    int activeZ_size = 0;\n    for (int i = 0; i < y_size; i++) {\n        int currentY = y_events[i].coord;\n        \n        if (count >= K) {\n            long long currentZ = 0;\n            int prevZ = 0;\n            \n            qsort(activeZ, activeZ_size, sizeof(int), compare);\n            \n            for (int j = 0; j < activeZ_size; j++) {\n                if (activeZ[j] & 1)\n                    currentZ += prevZ;\n                else\n                    currentZ -= prevZ;\n                \n                prevZ = activeZ[j] >> 1;\n            }\n            \n            area += (long long)(currentY - prevY) * currentZ;\n        }\n        \n        count += y_events[i].type;\n        \n        if (y_events[i].type == 1) {\n            activeZ[activeZ_size++] = habitats[y_events[i].index].z1 << 1;\n            activeZ[activeZ_size++] = (habitats[y_events[i].index].z2 << 1) | 1;\n        } else {\n            for (int j = 0; j < activeZ_size; j++) {\n                if ((activeZ[j] >> 1) == habitats[y_events[i].index].z1) {\n                    activeZ[j] = activeZ[--activeZ_size];\n                    j--;\n                }\n                if (((activeZ[j] >> 1) == habitats[y_events[i].index].z2) &&\n                    (activeZ[j] & 1)) {\n                    activeZ[j] = activeZ[--activeZ_size];\n                    j--;\n                }\n            }\n        }\n        \n        prevY = currentY;\n    }\n    \n    return area;\n}\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n    \n    Habitat habitats[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d %d %d %d\", &habitats[i].x1, &habitats[i].y1, &habitats[i].z1,\n              &habitats[i].x2, &habitats[i].y2, &habitats[i].z2);\n    }\n    \n    Event x_events[2*N];\n    int event_size = 0;\n    \n    for (int i = 0; i < N; i++) {\n        x_events[event_size++] = (Event){habitats[i].x1, 1, i};\n        x_events[event_size++] = (Event){habitats[i].x2, -1, i};\n    }\n    \n    qsort(x_events, event_size, sizeof(Event), compare);\n    \n    int active[N];\n    int active_size = 0;\n    long long totalVolume = 0;\n    int prevX = 0;\n    \n    for (int i = 0; i < event_size; i++) {\n        int currentX = x_events[i].coord;\n        \n        if (active_size > 0) {\n            long long area = calculateArea(active, active_size, habitats, K);\n            totalVolume += area * (currentX - prevX);\n        }\n        \n        if (x_events[i].type == 1) {\n            active[active_size++] = x_events[i].index;\n        } else {\n            for (int j = 0; j < active_size; j++) {\n                if (active[j] == x_events[i].index) {\n                    active[j] = active[--active_size];\n                    break;\n                }\n            }\n        }\n        \n        prevX = currentX;\n    }\n    \n    printf(\"%lld\\n\", totalVolume);\n    return 0;\n}",
    "timestamp": "2025-08-13 01:09:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_overlap_volume(N, K):\n    habitats = []\n    for _ in range(N):\n        x1, y1, z1, x2, y2, z2 = map(int, input().split())\n        habitats.append((x1, y1, z1, x2, y2, z2))\n    \n    # Find min and max coordinates\n    min_x = min(min(h[0], h[3]) for h in habitats)\n    max_x = max(max(h[0], h[3]) for h in habitats)\n    min_y = min(min(h[1], h[4]) for h in habitats)\n    max_y = max(max(h[1], h[4]) for h in habitats)\n    min_z = min(min(h[2], h[5]) for h in habitats)\n    max_z = max(max(h[2], h[5]) for h in habitats)\n    \n    # Create 3D grid to track overlaps\n    grid = [[[0 for _ in range(max_z - min_z + 1)] \n               for _ in range(max_y - min_y + 1)] \n               for _ in range(max_x - min_x + 1)]\n    \n    # Mark overlapping regions\n    for habitat in habitats:\n        x1, y1, z1, x2, y2, z2 = habitat\n        for x in range(x1 - min_x, x2 - min_x + 1):\n            for y in range(y1 - min_y, y2 - min_y + 1):\n                for z in range(z1 - min_z, z2 - min_z + 1):\n                    grid[x][y][z] += 1\n    \n    # Calculate volume of regions with at least K overlaps\n    total_volume = 0\n    for x in range(len(grid)):\n        for y in range(len(grid[0])):\n            for z in range(len(grid[0][0])):\n                if grid[x][y][z] >= K:\n                    total_volume += 1\n    \n    return total_volume\n\n# Read input and solve\nN, K = map(int, input().split())\nprint(calculate_overlap_volume(N, K))",
    "timestamp": "2025-08-13 01:09:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef compute_overlap_volume(cuboids, K):\n    if not cuboids:\n        return 0\n    \n    events = []\n    for idx, (x1, y1, z1, x2, y2, z2) in enumerate(cuboids):\n        x_start, x_end = sorted([x1, x2])\n        y_start, y_end = sorted([y1, y2])\n        z_start, z_end = sorted([z1, z2])\n        events.append((x_start, 'start', y_start, y_end, z_start, z_end))\n        events.append((x_end, 'end', y_start, y_end, z_start, z_end))\n    \n    events.sort(key=lambda x: (x[0], 0 if x[1] == 'start' else 1))\n    \n    active_intervals = []\n    total_volume = 0\n    prev_x = None\n    \n    for event in events:\n        x, typ, y1, y2, z1, z2 = event\n        if prev_x is not None and x != prev_x:\n            delta_x = x - prev_x\n            # Calculate the area in y-z plane with at least K overlaps\n            yz_events = []\n            for interval in active_intervals:\n                yi1, yi2, zi1, zi2 = interval\n                yz_events.append((yi1, 'start', zi1, zi2))\n                yz_events.append((yi2, 'end', zi1, zi2))\n            \n            yz_events.sort(key=lambda e: (e[0], 0 if e[1] == 'start' else 1))\n            \n            active_z_intervals = []\n            area = 0\n            prev_y = None\n            current_k = 0\n            \n            for yz_event in yz_events:\n                y, yz_typ, z1, z2 = yz_event\n                if prev_y is not None and y != prev_y and current_k >= K:\n                    delta_y = y - prev_y\n                    # Calculate the length in z with at least K overlaps\n                    z_events = []\n                    for z_interval in active_z_intervals:\n                        zi1, zi2 = z_interval\n                        z_events.append((zi1, 'start'))\n                        z_events.append((zi2, 'end'))\n                    \n                    z_events.sort(key=lambda e: (e[0], 0 if e[1] == 'start' else 1))\n                    \n                    active_z = 0\n                    z_length = 0\n                    prev_z = None\n                    current_z_k = 0\n                    \n                    for z_event in z_events:\n                        z, z_typ = z_event\n                        if prev_z is not None and z != prev_z and current_z_k >= K:\n                            delta_z = z - prev_z\n                            z_length += delta_z\n                        if z_typ == 'start':\n                            current_z_k += 1\n                        else:\n                            current_z_k -= 1\n                        prev_z = z\n                    \n                    area += delta_y * z_length\n                \n                if yz_typ == 'start':\n                    current_k += 1\n                    active_z_intervals.append((z1, z2))\n                else:\n                    current_k -= 1\n                    active_z_intervals.remove((z1, z2))\n                prev_y = y\n            \n            total_volume += delta_x * area\n        \n        if typ == 'start':\n            active_intervals.append((y1, y2, z1, z2))\n        else:\n            active_intervals.remove((y1, y2, z1, z2))\n        prev_x = x\n    \n    return total_volume\n\ndef main():\n    input_lines = [line.strip() for line in sys.stdin if line.strip()]\n    N, K = map(int, input_lines[0].split())\n    cuboids = []\n    for line in input_lines[1:N+1]:\n        x1, y1, z1, x2, y2, z2 = map(int, line.split())\n        cuboids.append((x1, y1, z1, x2, y2, z2))\n    print(compute_overlap_volume(cuboids, K))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 01:10:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nstruct Event {\n    int x, y1, y2, z1, z2, delta;\n};\n\nstruct Node {\n    int count;\n    long long length;\n};\n\nvector<Node> seg_tree;\nvector<int> compress_y, compress_z;\n\nvoid update(int node, int start, int end, int left, int right, int delta) {\n    if (left >= end || right <= start) return;\n    if (left <= start && end <= right) {\n        seg_tree[node].count += delta;\n    } else {\n        int mid = (start + end) / 2;\n        update(node * 2, start, mid, left, right, delta);\n        update(node * 2 + 1, mid, end, left, right, delta);\n    }\n    if (seg_tree[node].count > 0) {\n        seg_tree[node].length = compress_z[end] - compress_z[start];\n    } else if (start + 1 == end) {\n        seg_tree[node].length = 0;\n    } else {\n        seg_tree[node].length = seg_tree[node * 2].length + seg_tree[node * 2 + 1].length;\n    }\n}\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n\n    vector<Event> events;\n    vector<int> all_y, all_z;\n\n    for (int i = 0; i < N; ++i) {\n        int x1, y1, z1, x2, y2, z2;\n        cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n        events.push_back({x1, y1, y2, z1, z2, 1});\n        events.push_back({x2, y1, y2, z1, z2, -1});\n        all_y.push_back(y1);\n        all_y.push_back(y2);\n        all_z.push_back(z1);\n        all_z.push_back(z2);\n    }\n    \n    sort(events.begin(), events.end(), [](const Event &a, const Event &b) {\n        return a.x < b.x;\n    });\n\n    sort(all_y.begin(), all_y.end());\n    sort(all_z.begin(), all_z.end());\n    all_y.erase(unique(all_y.begin(), all_y.end()), all_y.end());\n    all_z.erase(unique(all_z.begin(), all_z.end()), all_z.end());\n\n    int M_y = all_y.size();\n    int M_z = all_z.size();\n\n    compress_y = all_y;\n    compress_z = all_z;\n    seg_tree.resize(4 * M_z);\n\n    long long total_volume = 0;\n    for (size_t i = 0; i < events.size(); ++i) {\n        if (i > 0) {\n            total_volume += seg_tree[1].length * (events[i].x - events[i - 1].x);\n        }\n        \n        int y1_idx = lower_bound(all_y.begin(), all_y.end(), events[i].y1) - all_y.begin();\n        int y2_idx = lower_bound(all_y.begin(), all_y.end(), events[i].y2) - all_y.begin();\n        int z1_idx = lower_bound(all_z.begin(), all_z.end(), events[i].z1) - all_z.begin();\n        int z2_idx = lower_bound(all_z.begin(), all_z.end(), events[i].z2) - all_z.begin();\n\n        update(1, 0, M_z, z1_idx, z2_idx, events[i].delta);\n    }\n    \n    cout << total_volume << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 10:58:32"
  }
]