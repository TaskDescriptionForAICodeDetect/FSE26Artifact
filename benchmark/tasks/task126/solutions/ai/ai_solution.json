[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100\n\nint N;\nint dist[MAX_N][MAX_N];\n\nvoid floydWarshall() {\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX && dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) {\n                dist[i][j] = 0;\n            } else {\n                dist[i][j] = INT_MAX;\n            }\n        }\n    }\n    \n    int u, v, w;\n    while (scanf(\"%d %d %d\", &u, &v, &w) == 3) {\n        dist[u][v] = w;\n        dist[v][u] = w;\n    }\n    \n    floydWarshall();\n    \n    int max_dist = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (dist[i][j] != INT_MAX && dist[i][j] > max_dist) {\n                max_dist = dist[i][j];\n            }\n        }\n    }\n    \n    int is_possible[MAX_N] = {0};\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (dist[i][j] == max_dist) {\n                is_possible[i] = 1;\n                is_possible[j] = 1;\n            }\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        if (!is_possible[i]) {\n            printf(\"%d\\n\", i);\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:43:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RelayRaceCourse {\n    static final int INF = Integer.MAX_VALUE / 2;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Read input\n        int N = sc.nextInt(); // Number of towns\n        int M = sc.nextInt(); // Number of roads\n        \n        // Initialize distance matrix with infinity\n        int[][] dist = new int[N][N];\n        for (int[] row : dist) {\n            Arrays.fill(row, INF);\n        }\n        \n        // Set diagonal to 0\n        for (int i = 0; i < N; i++) {\n            dist[i][i] = 0;\n        }\n        \n        // Read road connections\n        for (int i = 0; i < M; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            int d = sc.nextInt();\n            dist[a][b] = d;\n            dist[b][a] = d;\n        }\n        \n        // Floyd-Warshall algorithm\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        \n        // Find max shortest path between any two towns\n        int maxShortestPath = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (dist[i][j] != INF) {\n                    maxShortestPath = Math.max(maxShortestPath, dist[i][j]);\n                }\n            }\n        }\n        \n        // Find towns that cannot be in race course\n        List<Integer> excludedTowns = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            boolean canBeUsed = false;\n            for (int j = 0; j < N; j++) {\n                if (i != j && dist[i][j] == maxShortestPath) {\n                    canBeUsed = true;\n                    break;\n                }\n            }\n            if (!canBeUsed) {\n                excludedTowns.add(i + 1);\n            }\n        }\n        \n        // Output results\n        System.out.println(excludedTowns.size());\n        for (int town : excludedTowns) {\n            System.out.println(town);\n        }\n        \n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 18:43:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> findQuietestTowns(int N, const vector<pair<int, int>>& roads) {\n    vector<vector<int>> adj(N);\n    for (const auto& road : roads) {\n        int u = road.first;\n        int v = road.second;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector<vector<int>> dist(N, vector<int>(N, INT_MAX));\n    for (int i = 0; i < N; ++i) {\n        queue<int> q;\n        q.push(i);\n        dist[i][i] = 0;\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            for (int v : adj[u]) {\n                if (dist[i][v] == INT_MAX) {\n                    dist[i][v] = dist[i][u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n    }\n\n    int max_dist = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (dist[i][j] != INT_MAX && dist[i][j] > max_dist) {\n                max_dist = dist[i][j];\n            }\n        }\n    }\n\n    vector<bool> isOnAnyMaxPath(N, false);\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (dist[i][j] == max_dist) {\n                for (int k = 0; k < N; ++k) {\n                    if (dist[i][k] + dist[k][j] == dist[i][j]) {\n                        isOnAnyMaxPath[k] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    vector<int> quietTowns;\n    for (int i = 0; i < N; ++i) {\n        if (!isOnAnyMaxPath[i]) {\n            quietTowns.push_back(i);\n        }\n    }\n\n    return quietTowns;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<pair<int, int>> roads(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> roads[i].first >> roads[i].second;\n    }\n\n    vector<int> result = findQuietestTowns(N, roads);\n    for (int town : result) {\n        cout << town << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_TOWNS 500\n\nint graph[MAX_TOWNS][MAX_TOWNS];\nint dist[MAX_TOWNS][MAX_TOWNS];\nint n, m;\n\nvoid floyd_warshall() {\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX &&\n                    dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n}\n\nint find_max_shortest_path() {\n    int max_dist = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dist[i][j] != INT_MAX && dist[i][j] > max_dist) {\n                max_dist = dist[i][j];\n            }\n        }\n    }\n    return max_dist;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dist[i][j] = (i == j) ? 0 : INT_MAX;\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        u--; v--;\n        dist[u][v] = w;\n        dist[v][u] = w;\n    }\n\n    floyd_warshall();\n    int max_shortest_path = find_max_shortest_path();\n\n    for (int i = 0; i < n; i++) {\n        int can_be_used = 0;\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                if (dist[j][k] == max_shortest_path && \n                    (dist[j][i] + dist[i][k] == max_shortest_path)) {\n                    can_be_used = 1;\n                    break;\n                }\n            }\n            if (can_be_used) break;\n        }\n        if (!can_be_used) {\n            printf(\"%d\\n\", i + 1);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nvoid floyd_warshall(vector<vector<int>>& dist) {\n    int n = dist.size();\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i][k] != INF && dist[k][j] != INF) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int>> dist(N, vector<int>(N, INF));\n    for (int i = 0; i < N; i++) dist[i][i] = 0;\n\n    for (int i = 0; i < M; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        dist[a-1][b-1] = c;\n        dist[b-1][a-1] = c;\n    }\n\n    floyd_warshall(dist);\n\n    int max_shortest_path = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (dist[i][j] != INF) {\n                max_shortest_path = max(max_shortest_path, dist[i][j]);\n            }\n        }\n    }\n\n    vector<bool> not_in_race(N, true);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (dist[i][j] == max_shortest_path) {\n                not_in_race[i] = false;\n                not_in_race[j] = false;\n            }\n        }\n    }\n\n    vector<int> quiet_towns;\n    for (int i = 0; i < N; i++) {\n        if (not_in_race[i]) {\n            quiet_towns.push_back(i + 1);\n        }\n    }\n\n    cout << quiet_towns.size() << endl;\n    for (int town : quiet_towns) {\n        cout << town << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:45:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n\n        int[] maxDist = new int[N];\n        int maxPathLength = 0;\n\n        for (int i = 0; i < N; i++) {\n            int[] dist = new int[N];\n            Arrays.fill(dist, -1);\n            Queue<Integer> queue = new LinkedList<>();\n            dist[i] = 0;\n            queue.add(i);\n            while (!queue.isEmpty()) {\n                int u = queue.poll();\n                for (int v : adj.get(u)) {\n                    if (dist[v] == -1) {\n                        dist[v] = dist[u] + 1;\n                        queue.add(v);\n                    }\n                }\n            }\n            for (int j = 0; j < N; j++) {\n                if (dist[j] > maxDist[i]) {\n                    maxDist[i] = dist[j];\n                }\n            }\n            if (maxDist[i] > maxPathLength) {\n                maxPathLength = maxDist[i];\n            }\n        }\n\n        for (int i = 0; i < N; i++) {\n            if (maxDist[i] != maxPathLength) {\n                System.out.println(i + 1);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:45:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef dijkstra(n, graph, start):\n    dist = [float('inf')] * n\n    dist[start] = 0\n    queue = [(0, start)]\n    while queue:\n        current_dist, current_node = heapq.heappop(queue)\n        if current_dist > dist[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_dist + weight\n            if distance < dist[neighbor]:\n                dist[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return dist\n\ndef longest_shortest_paths(n, graph):\n    max_dist = 0\n    longest_path_pair = (-1, -1)\n    for i in range(n):\n        dist = dijkstra(n, graph, i)\n        for j in range(i + 1, n):\n            if dist[j] > max_dist:\n                max_dist = dist[j]\n                longest_path_pair = (i, j)\n    return longest_path_pair\n\ndef find_unused_towns(n, graph):\n    longest_pair = longest_shortest_paths(n, graph)\n    used = set(longest_pair)\n    \n    for town in longest_pair:\n        dist = dijkstra(n, graph, town)\n        for neighbor in range(n):\n            if dist[neighbor] + dijkstra(n, graph, neighbor)[longest_pair[1 - longest_pair.index(town)]] == dist[longest_pair[1 - longest_pair.index(town)]]:\n                used.add(neighbor)\n\n    unused_towns = set(range(n)) - used\n    return sorted(unused_towns)\n\n# Example graph creation (input example)\n# n = 4\n# graph = [\n#     [(1, 5), (2, 10)],  # Town 0\n#     [(0, 5), (3, 3)],   # Town 1\n#     [(0, 10), (3, 7)],  # Town 2\n#     [(1, 3), (2, 7)]    # Town 3\n# ]\n\n# n, graph = (get towns and paths information from input)\n# unused_towns = find_unused_towns(n, graph)\n# print(unused_towns)",
    "timestamp": "2025-08-13 00:42:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RelayRace {\n    static class Pair {\n        int town, dist;\n        Pair(int town, int dist) {\n            this.town = town;\n            this.dist = dist;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        List<List<Pair>> graph = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            int d = scanner.nextInt();\n            graph.get(u).add(new Pair(v, d));\n            graph.get(v).add(new Pair(u, d));\n        }\n        \n        int maxDistance = 0;\n        int[] longestShortestPaths = new int[N];\n\n        for (int i = 0; i < N; i++) {\n            int longestDistance = bfs(i, graph, N);\n            longestShortestPaths[i] = longestDistance;\n            if (longestDistance > maxDistance) {\n                maxDistance = longestDistance;\n            }\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            if (longestShortestPaths[i] < maxDistance) {\n                result.add(i + 1);\n            }\n        }\n\n        for (int town : result) {\n            System.out.println(town);\n        }\n        \n        scanner.close();\n    }\n\n    private static int bfs(int start, List<List<Pair>> graph, int N) {\n        Queue<Pair> queue = new LinkedList<>();\n        queue.add(new Pair(start, 0));\n        boolean[] visited = new boolean[N];\n        visited[start] = true;\n\n        int maxDistance = 0;\n        while (!queue.isEmpty()) {\n            Pair current = queue.poll();\n            int currentTown = current.town;\n            int currentDist = current.dist;\n            maxDistance = Math.max(maxDistance, currentDist);\n\n            for (Pair neighbor : graph.get(currentTown)) {\n                if (!visited[neighbor.town]) {\n                    visited[neighbor.town] = true;\n                    queue.add(new Pair(neighbor.town, currentDist + neighbor.dist));\n                }\n            }\n        }\n        return maxDistance;\n    }\n}",
    "timestamp": "2025-08-13 00:42:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n\nint N;\nint adj[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N];\n\nvoid floydWarshall() {\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX) {\n                    if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                        dist[i][j] = dist[i][k] + dist[k][j];\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int M;\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            adj[i][j] = (i == j ? 0 : INT_MAX);\n            dist[i][j] = adj[i][j];\n        }\n    }\n\n    for (int i = 0; i < M; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        adj[u][v] = w;\n        adj[v][u] = w;\n        dist[u][v] = w;\n        dist[v][u] = w;\n    }\n\n    floydWarshall();\n\n    int maxDist = 0;\n    int longestPair[2] = {-1, -1};\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i+1; j < N; j++) {\n            if (dist[i][j] != INT_MAX && dist[i][j] > maxDist) {\n                maxDist = dist[i][j];\n                longestPair[0] = i;\n                longestPair[1] = j;\n            }\n        }\n    }\n\n    bool canBeUsed[MAX_N] = {false};\n    if (longestPair[0] != -1) {\n        for (int i = 0; i < N; i++) {\n            if (dist[longestPair[0]][i] + dist[i][longestPair[1]] == maxDist) {\n                canBeUsed[i] = true;\n            }\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (!canBeUsed[i]) {\n            printf(\"%d\\n\", i);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 00:43:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef floyd_warshall(n, edges):\n    dist = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dist[i][i] = 0\n    for u, v, w in edges:\n        dist[u][v] = w\n        dist[v][u] = w\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    \n    return dist\n\ndef find_excluded_towns(n, edges):\n    dist = floyd_warshall(n, edges)\n    \n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            max_dist = max(max_dist, dist[i][j])\n    \n    excluded_towns = []\n    for town in range(n):\n        is_excluded = True\n        for i in range(n):\n            for j in range(n):\n                path_through_town = dist[i][town] + dist[town][j]\n                if path_through_town == max_dist:\n                    is_excluded = False\n                    break\n            if not is_excluded:\n                break\n        \n        if is_excluded:\n            excluded_towns.append(town)\n    \n    return sorted(excluded_towns)\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        edges.append((u-1, v-1, w))\n    \n    result = find_excluded_towns(n, edges)\n    \n    print(len(result))\n    if result:\n        print(*[x+1 for x in result])\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:43:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    adj = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a = int(input[ptr]) - 1\n        ptr += 1\n        b = int(input[ptr]) - 1\n        ptr += 1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    def bfs(start):\n        dist = [-1] * N\n        q = deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n        max_dist = max(dist)\n        node = dist.index(max_dist)\n        return node, max_dist\n    \n    # Find one end of the diameter\n    u, _ = bfs(0)\n    # Find the other end of the diameter\n    v, max_len = bfs(u)\n    # Get all nodes on the diameter\n    # Perform BFS from u to get parent pointers\n    parent = [-1] * N\n    q = deque()\n    q.append(u)\n    parent[u] = u\n    while q:\n        current = q.popleft()\n        for neighbor in adj[current]:\n            if parent[neighbor] == -1:\n                parent[neighbor] = current\n                q.append(neighbor)\n    # Trace back from v to u to get the diameter path\n    path = []\n    current = v\n    while current != u:\n        path.append(current)\n        current = parent[current]\n    path.append(u)\n    path_set = set(path)\n    \n    # Now, check for each node not in the path if it's part of any other diameter\n    # To do this, we can check if the node is part of any diameter by comparing distances\n    # Get distances from u and v\n    dist_u = [-1] * N\n    q = deque()\n    dist_u[u] = 0\n    q.append(u)\n    while q:\n        current = q.popleft()\n        for neighbor in adj[current]:\n            if dist_u[neighbor] == -1:\n                dist_u[neighbor] = dist_u[current] + 1\n                q.append(neighbor)\n    \n    dist_v = [-1] * N\n    q = deque()\n    dist_v[v] = 0\n    q.append(v)\n    while q:\n        current = q.popleft()\n        for neighbor in adj[current]:\n            if dist_v[neighbor] == -1:\n                dist_v[neighbor] = dist_v[current] + 1\n                q.append(neighbor)\n    \n    quiet_towns = []\n    for node in range(N):\n        if node not in path_set:\n            if dist_u[node] + dist_v[node] != max_len:\n                quiet_towns.append(node + 1)  # 1-based\n    \n    quiet_towns.sort()\n    for town in quiet_towns:\n        print(town)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 00:43:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nvector<int> dijkstra(int start, const vector<vector<pair<int, int>>>& graph) {\n    int n = graph.size();\n    vector<int> dist(n, INF);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n    dist[start] = 0;\n    pq.emplace(0, start);\n\n    while (!pq.empty()) {\n        int d = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (d > dist[u]) continue;\n\n        for (const auto &edge : graph[u]) {\n            int v = edge.first;\n            int weight = edge.second;\n\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                pq.emplace(dist[v], v);\n            }\n        }\n    }\n\n    return dist;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<pair<int, int>>> graph(N);\n\n    for (int i = 0; i < M; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        u--; v--;\n        graph[u].emplace_back(v, w);\n        graph[v].emplace_back(u, w);\n    }\n\n    vector<vector<int>> all_pairs_dists(N);\n    for (int i = 0; i < N; ++i) {\n        all_pairs_dists[i] = dijkstra(i, graph);\n    }\n\n    int max_diameter = 0;\n    vector<pair<int, int>> longest_paths;\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (all_pairs_dists[i][j] > max_diameter) {\n                max_diameter = all_pairs_dists[i][j];\n                longest_paths.clear();\n                longest_paths.emplace_back(i, j);\n            } else if (all_pairs_dists[i][j] == max_diameter) {\n                longest_paths.emplace_back(i, j);\n            }\n        }\n    }\n\n    vector<bool> on_longest_path(N, false);\n    for (const auto &p : longest_paths) {\n        int u = p.first;\n        int v = p.second;\n        vector<int> &dist_u = all_pairs_dists[u];\n        vector<int> &dist_v = all_pairs_dists[v];\n\n        for (int i = 0; i < N; ++i) {\n            if (dist_u[i] + dist_v[i] == max_diameter) {\n                on_longest_path[i] = true;\n            }\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        if (!on_longest_path[i]) {\n            cout << i + 1 << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:55:32"
  }
]