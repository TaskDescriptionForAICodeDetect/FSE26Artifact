[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport scala.io.StdIn._\nobject Main extends App {\n  val Array(n, r) = readLine.trim.split(' ').map(_.toInt)\n  val towns = Array.fill(n){Nil: List[(Int, Int)]}\n  for (_ ← 0 until r){\n    val Array(s, t, d) = readLine.trim.split(' ').map(_.toInt)\n    towns(s - 1) ::= (t - 1, d)\n    towns(t - 1) ::= (s - 1, d)\n  }\n  val heap = mutable.PriorityQueue()(Ordering.by[(Int, Int), Int](_._2).reverse)\n  val maxDistanceFrom = Array.fill(n){0}\n  val useWhenStartFrom = Array.fill(n){Array.fill(n){false}}\n  var maxDistance = 0\n  for (start ← 0 until n){\n    val minDistance = Array.fill(n){Int.MaxValue}\n    minDistance(start) = 0\n    heap.enqueue((start, 0))\n    var far = start\n    while (heap.nonEmpty) {\n      val (current, cost) = heap.dequeue()\n      if (minDistance(current) == cost) {\n        far = current\n        for ((next, length) ← towns(current)) {\n          if (minDistance(next) > cost + length) {\n            minDistance(next) = cost + length\n            heap.enqueue((next, cost + length))\n          }\n        }\n      }\n    }\n    maxDistanceFrom(start) = minDistance(far)\n    if (maxDistance <= minDistance(far)) {\n      maxDistance = minDistance(far)\n      val fars = (0 until n).filter(t ⇒ minDistance(t) == maxDistance)\n      val queue = mutable.Queue[Int](fars:_*)\n      fars.foreach(i ⇒ useWhenStartFrom(start)(i) = true)\n      while (queue.nonEmpty) {\n        val current = queue.dequeue()\n        for ((next, length) ← towns(current) if minDistance(next) + length == minDistance(current) && !useWhenStartFrom(start)(next)) {\n          useWhenStartFrom(start)(next) = true\n          queue.enqueue(next)\n        }\n      }\n    }\n  }\n  val buzzer = (0 until n).filter(t ⇒ maxDistanceFrom(t) == maxDistance)\n  val quiet = (0 until n).filterNot(t ⇒ buzzer.exists(b ⇒ useWhenStartFrom(b)(t)))\n  println(quiet.length)\n  if (quiet.nonEmpty) println(quiet.map{_ + 1}.mkString(\"\\n\"))\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n#define DB(x) cout<<#x<<'='<<x<<endl;\n\nint N,R;\nstruct edge{\n\tint to;LL cost;\n\tedge(int to_,LL cost_):\n\t\tto(to_),cost(cost_){}\n};\nconst LL INF=123456789012345;\nusing P = pair<LL,int>;\nvoid dijkstra(vector<edge>graph_[],LL dist[],int n_,int s_){\n\tpriority_queue<P,vector<P>,greater<P>>que;\n\tque.push({0,s_});\n\tfill(dist,dist+n_,INF);\n\tdist[s_]=0;\n\twhile(!que.empty()){\n\t\tauto q=que.top();\n\t\tque.pop();\n\t\tLL thd=q.first;\n\t\tint thv=q.second;\n\t\tif(thd>dist[thv])\n\t\t\tcontinue;\n\t\tfor(auto ed:graph_[thv]){\n\t\t\tif(dist[ed.to]>ed.cost+thd){\n\t\t\t\tdist[ed.to]=ed.cost+thd;\n\t\t\t\tque.push({dist[ed.to],ed.to});\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<edge>graph[1500];\nLL dist[1500][1500];\nint S[3000],T[3000],D[3000];\nint used[1500];\nint main(){\n\tcin>>N>>R;\n\tfor(int j=0;j<R;++j){\n\t\tint s,t,d;cin>>s>>t>>d;\n\t\t--s;--t;\n\t\tS[j]=s;T[j]=t;D[j]=d;\n\t\tgraph[s].push_back({t,d});\n\t\tgraph[t].push_back({s,d});\n\t}\n\tmap<LL,vector<pair<int,int>>>cos;\n\tfor(int i=0;i<N;++i){\n\t\tdijkstra(graph,dist[i],N,i);\n\t\tfor(int j=0;j<N;++j){\n\t\t\tcos[dist[i][j]].push_back({i,j});\n\t\t}\n\t}\n\tauto itr = cos.end();\n\t--itr;\n\tauto vec = itr->second;\n\tfor(auto p : vec){\n\t\tint start=p.first;\n\t\tint finish=p.second;\n\t\tfor(int mid=0;mid<N;++mid){\n\t\t\t//DB(dist[start][finish]);\n\t\t\t//DB(dist[start][mid]);\n\t\t\t//DB(dist[mid][finish]);\n\t\t\tif(dist[start][finish]==dist[start][mid]+dist[mid][finish]){\n\t\t\t\tused[mid]=true;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>answer;\n\tfor(int i=0;i<N;++i){\n\t  if(!used[i])answer.push_back(i);\n\t}\n\tcout<<answer.size()<<endl;\n\tfor(int out:answer)cout<<out+1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef pair<int, int> P;\n \nconst int inf = 1e9 + 9;\n \nstruct edge {\n  int to, cost;\n};\n \nint n, r;\nvector<edge> G[1550];\nvector<int> V[1550];\n//vector<int> L;\n\nint d[1550];\nbool f[1550], L[1550];\n \nvoid path(int u)\n{\n  L[u] = true;\n  //L.push_back(u);\n  if (d[u] == 0) return;\n  for (int i = 0; i < V[u].size(); i++){\n    path(V[u][i]);\n  }\n}\n \nint main()\n{\n  cin >> n >> r;\n  for (int i = 0; i < r; i++){\n    int s, t, d;\n    cin >> s >> t >> d;\n    s--; t--;\n    edge e;\n    e.to = t; e.cost = d;\n    G[s].push_back(e);\n    e.to = s;\n    G[t].push_back(e);\n  }\n \n  priority_queue<P, vector<P>, greater<P>> q;\n \n  int max_d = 0;\n  for (int i = 0; i < n; i++){\n    q.push(P(0, i));\n    fill(d, d + n, inf);\n    d[i] = 0;\n \n    vector<int> E;\n    int max_c = 0;\n \n    while (!q.empty()){\n      P p = q.top(); q.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (int j = 0; j < G[v].size(); j++){\n        edge e = G[v][j];\n \n        if (d[e.to] == d[v] + e.cost){\n          V[e.to].push_back(v);\n          q.push(P(d[e.to], e.to));\n        }\n        if (d[e.to] > d[v] + e.cost){\n          d[e.to] = d[v] + e.cost;\n          V[e.to].clear();\n          V[e.to].push_back(v);\n          q.push(P(d[e.to], e.to));\n        }\n      }\n    }\n \n    E.clear();\n    for (int j = 0; j < n; j++){\n      if (d[j] == max_c) {\n        E.push_back(j);\n      }\n      if (d[j] > max_c){\n        max_c = d[j];\n        E.clear();\n        E.push_back(j);\n      }\n    }\n \n    if (max_c == max_d){\n      for (int j = 0; j < E.size(); j++){\n        path(E[j]);\n      }\n    }\n    if (max_d < max_c){\n      //L.clear();\n      memset(L, false, sizeof(L));\n      max_d = max_c;\n      for (int j = 0; j < E.size(); j++){\n        path(E[j]);\n      }\n    }\n  }\n\n  //sort(L.begin(), L.end());\n  //L.erase(unique(L.begin(), L.end()), L.end());\n  /*\n  for (int i = 0; i < L.size(); i++){\n    f[i] = true;\n  }\n  */\n \n  vector<int> p;\n  for (int i = 0; i < n; i++){\n    if (!L[i]) p.push_back(i + 1);\n  }\n\n  cout << p.size() << endl;\n  for (int i = 0; i < p.size(); i++){\n    cout << p[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint n;\n\nvector<vector<P>> G(1510);\nvector<vector<int>> dist(1510, vector<int>(1510, 1e9));\nvoid dijkstra(int s){\n    priority_queue<P, vector<P>, greater<P>> que;\n    dist[s][s] = 0;\n    que.emplace(0, s);\n\n    while(!que.empty()){\n        int ccost, cv;\n        tie(ccost, cv) = que.top();\n        que.pop();\n\n        if(dist[s][cv] < ccost) continue;\n\n        for(auto x : G[cv]){\n            int nv, ncost;\n            tie(nv, ncost) = x;\n            \n            if(dist[s][cv] + ncost < dist[s][nv]){\n                dist[s][nv] = dist[s][cv] + ncost;\n                que.emplace(dist[s][nv], nv);\n            }\n        }\n    }\n}\n\nint main(){\n    int r; cin>>n>>r;\n    for(int i=0; i<r; i++){\n        int s, t, d; cin>>s>>t>>d;\n        s--, t--;\n        G[s].emplace_back(t, d);\n        G[t].emplace_back(s, d);\n    }\n\n    for(int i=0; i<n; i++){\n        dijkstra(i);\n    }\n\n    int maxdist = 0;\n    for(int i=0; i<n; i++){\n        for(int j=i+1; j<n; j++){\n            maxdist = max(maxdist, dist[i][j]);\n        }\n    }\n\n    vector<P> sg;\n    for(int i=0; i<n; i++){\n        for(int j=i+1; j<n; j++){\n            if(dist[i][j] != maxdist) continue;\n\n            sg.emplace_back(i, j);\n        }\n    }\n\n    vector<bool> visited(n, false);\n    for(int i=0; i<n; i++){\n        for(auto j:sg){\n            int s, g;\n            tie(s, g) = j;\n            if(dist[s][i] + dist[i][g] == maxdist){\n                visited[i] = true;\n                break;\n            }\n        }\n    }\n\n    vector<int> ans;\n    for(int i=0; i<n; i++){\n        if(!visited[i]){\n            ans.emplace_back(i+1);\n        }\n    }\n\n    cout << ans.size() << endl;\n    for(auto i:ans){\n        cout << i << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nint mp[1501];\n\ninline void dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      if(d[s][g[v][i].to] > d[s][v] + g[v][i].cost) {\n        d[s][g[v][i].to] = d[s][v] + g[v][i].cost;\n        que.push(P(d[s][g[v][i].to], g[v][i].to));\n      }\n    }\n  }\n}\n\ninline void solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    rep(k, 0, g[tp].size()) {\n      if(d[i][tp] == d[i][g[tp][k].to] + g[tp][k].cost && g[tp][k].to != i) {\n        st.push(g[tp][k].to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) {\n        mp[i] = 1;\n        solve(i, j);\n      }\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <tuple>\nusing AnsType = long long int;\nusing namespace std;\n\nvector< pair<int, int> > G[1510];\nAnsType rec[1510][1510];\nconst AnsType INF = 1LL << 60;\nusing Pair = pair<int, AnsType>;\nint main() {\n  int N, R; cin >> N >> R;\n  for(int i=0; i<R; i++) {\n    int s, t, d; cin >> s >> t >> d;\n    s--; t--;\n    G[s].emplace_back(t, d);\n    G[t].emplace_back(s, d);\n  }\n\n  fill(rec[0], rec[N+1], INF);\n  for(int s=0; s<N; s++) {\n    priority_queue< Pair, vector<Pair>, greater<Pair> > que;\n    que.emplace(s, 0);\n    rec[s][s] = 0;\n\n    while(que.size()) {\n      int cur; AnsType cost; tie(cur, cost) = que.top(); que.pop();\n      if(cost > rec[s][cur]) continue;\n      for(auto e : G[cur]) {\n        int to, c; tie(to, c) = e;\n        if(rec[s][to] > cost + c) {\n          rec[s][to] = cost + c;\n          que.emplace(to, cost + c);\n        }\n      }\n    }\n  }\n\n  vector<int> used(N);\n  AnsType max_dist = -1;\n  for(int i=0; i<N; i++) {\n    for(int j=0; j<N; j++) {\n      max_dist = max(max_dist, rec[i][j]);\n    }\n  }\n\n  vector< pair<int, int> > pairs;\n  for(int i=0; i<N; i++) {\n    for(int j=0; j<N; j++) {\n      if(rec[i][j] == max_dist) {\n        pairs.emplace_back(i, j);\n      }\n    }\n  }\n    \n  for(int i=0; i<N; i++) {\n    for(auto st : pairs) {\n      int s, t; tie(s, t) = st;\n      if(rec[s][i] + rec[i][t] == max_dist) {\n        used[i] = true;\n        break;\n      }\n    }\n  }\n\n  vector<int> ans;\n  for(int i=0; i<N; i++) {\n    if(!used[i]) ans.push_back(i+1);\n  }\n\n  cout << ans.size() << endl;\n  for(auto e : ans) cout << e << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nvoid solve(int i, int j) {\n  stack<int> st;\n  map<int, int> mapp;\n  st.push(j);\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    mapp[tp] = 1;\n    if(tp == i) continue;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(mapp[e.to]) continue;\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi \"QUIETTOWN.inp\"\n#define fo \"QUIETTOWN.out\"\n#define vt first\n#define gt second\n \nusing namespace std;\nconst int maxn=1700;\nconst int maxc=1e9;\n \npriority_queue < pair <int,int> > heap;\n \nint w,n,m,d[maxn][maxn],p[maxn][maxn],he[maxn*maxn],ke[maxn*maxn],e[maxn*maxn],ans;\nint l[maxn*maxn],r[maxn*maxn],dg[maxn*maxn],fu[maxn],fv[maxn];\nbool dau[maxn],kt[maxn];\n \nvoid open()\n{\n    w=0;\n    //freopen(fi,\"r\",stdin);\n    //freopen(fo,\"w\",stdout);\n \n    scanf(\"%d%d\",&n,&m);\n    int x,y,c;\n \n    for (int i=1; i<=m; i++)\n    {\n      scanf(\"%d%d%d\",&x,&y,&c);\n      he[x]++;\n      he[y]++;\n    }\n    for (int i=2; i<=n; i++) he[i]+=he[i-1];\n \n    freopen(fi,\"r\",stdin);\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1; i<=m; i++)\n    {\n      scanf(\"%d%d%d\",&x,&y,&c);\n      ke[he[x]]=y;\n      ke[he[y]]=x;\n      e[he[x]]=c;\n      e[he[y]]=c;\n      --he[x];\n      --he[y];\n    }\n    he[n+1]=m*2;\n}\n \nvoid dijkstra(int s, int t)\n{\n    for (int i=1; i<=n; i++) d[s][i]=maxc;\n    memset(dau,true,sizeof(dau));\n    d[s][s]=0;\n \n    heap.push(make_pair(0,s));\n \n    while (!heap.empty())\n    {\n      int u=heap.top().gt;\n      heap.pop();\n \n      dau[u]=false;\n      for (int iv=he[u]+1; iv<=he[u+1]; iv++)\n      {\n        int v=ke[iv];\n        if ((dau[v]) && (d[s][v]>d[s][u]+e[iv]))\n        {\n          d[s][v]=d[s][u]+e[iv];\n          p[s][v]=u;\n          heap.push(make_pair(-d[s][v],v));\n        }\n      }\n    }\n}\n \nvoid trace(int s, int u)\n{\n    kt[s]=true;\n    while (p[s][u]!=0)\n    {\n      u=p[s][u];\n      kt[u]=true;\n    }\n}\n \nvoid mocxichcuaconbeo()\n{\n    memset(kt,true,sizeof(kt));\n \n    for (int i=0; i<=n; i++)\n    {\n      l[i]=i-1;\n      r[i]=i+1;\n    }\n \n    for (int i=1; i<=w; i++)\n    {\n      int uu=fu[i];\n      int vv=fv[i];\n \n      int k=0;\n      while (k!=n+1)\n      {\n        if (d[uu][k]+d[k][vv]==ans)\n        {\n          kt[k]=false;\n          l[r[i]]=l[i];\n          r[l[i]]=r[i];\n        }\n        k=r[k];\n      }\n    }\n \n}\n \nvoid process()\n{\n    for (int i=1; i<=n; i++)\n    {\n        dijkstra(i,n);\n        for (int j=1; j<=n; j++)\n          if ((i!=j) && (d[i][j]!=maxc)) ans=max(ans,d[i][j]);\n    }\n \n \n    for (int i=1; i<=n; i++)\n      for (int j=1; j<=n; j++)\n      {\n        if (d[i][j]==ans)\n        {\n          fu[++w]=i;\n          fv[w]=j;\n        }\n      }\n \n    mocxichcuaconbeo();\n \n    int kq=0;\n    for (int i=1; i<=n; i++)\n      if (kt[i]==true) dg[++kq]=i;\n \n    printf(\"%d\\n\",kq);\n    for (int i=1; i<=kq; i++) printf(\"%d\\n\",dg[i]);\n}\n \nint main()\n{\n    open();\n    process();\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, init, n) for (int i = init; i < (n); i++)\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nvector<edge> graph[1500];\nint dist[1500][1500];\nint N, R, maxDist;\nbool ans[1500];\n\nvoid dijkstra(int start)\n{\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<bool> visited(N, false);\n    dist[start][start] = 0;\n    que.push({0, start});\n\n    while (!que.empty())\n    {\n        int d, now;\n        tie(d, now) = que.top();\n        que.pop();\n\n        if (visited[now])\n            continue;\n\n        visited[now] = true;\n\n        for (auto e : graph[now])\n        {\n            if (dist[start][e.to] <= d + e.cost)\n                continue;\n\n            dist[start][e.to] = dist[start][now] + e.cost;\n            que.push(P(d + e.cost, e.to));\n        }\n    }\n}\n\nvoid solve(int start)\n{\n    queue<int> que;\n    vector<int> _visited(N, false);\n\n    rep(i, N) if(dist[start][i] == maxDist) que.push(i);\n    \n    while(!que.empty())\n    {\n        int now = que.front();\n        que.pop();\n\n        if(_visited[now]) continue;\n\n        _visited[now] = true;\n        ans[now] = false;\n\n        for(auto e : graph[now])\n        {\n            if(dist[start][e.to] == dist[start][now] - e.cost)\n            {\n                que.push(e.to);\n            }\n        }\n    }\n\n    return;\n}\n\nint main()\n{\n    cin >> N >> R;\n\n    rep(i, R)\n    {\n        int s, t, d;\n        cin >> s >> t >> d;\n\n        s--;\n        t--;\n\n        graph[s].push_back({t, d});\n        graph[t].push_back({s, d});\n    }\n\n    rep(i, N) ans[i] = true;\n\n    rep(i, N) rep(j, N) dist[i][j] = iINF;\n\n    rep(i, N) dijkstra(i);\n    rep(i, N) rep(j, N) maxDist = max(maxDist, dist[i][j]);\n\n    vector<int> output;\n\n    rep(i, N) solve(i);\n\n    rep(i, N) if(ans[i]) output.push_back(i + 1);\n\n    cout << output.size() << endl;\n\n    rep(i, output.size()) cout << output[i] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\n\nint main() {\n  int n,m;\n  cin >> n >> m;\n  vector<P> v[n];\n  for(int i=0; i<m; i++) {\n    int x,y,z;\n    cin >> x >> y >> z;\n    x--,y--;\n    v[x].push_back(P(y,z));\n    v[y].push_back(P(x,z));\n  }\n  int M=0,cnt=0;\n  bool u[n];\n  memset(u,0,sizeof(u));\n  for(int k=0; k<n; k++) {\n    int d[n];\n    fill(d,d+n,1<<29);\n    d[k]=0;\n    vector<int> w[n];\n    priority_queue<P,vector<P>,greater<P> > que;\n    que.push(P(0,k));\n    while(!que.empty()) {\n      P p=que.top();que.pop();\n      int x=p.S,c=p.F;\n      if(d[x]<c) continue;\n      if(c>M) {\n        M=c;\n        memset(u,0,sizeof(u));\n      }\n      for(int i=0; i<v[x].size(); i++) {\n        int y=v[x][i].F,cc=v[x][i].S;\n        if(d[y]>d[x]+cc) {\n          d[y]=d[x]+cc;\n          que.push(P(d[y],y));\n          w[y].clear();\n        }\n        if(d[y]==d[x]+cc) w[y].push_back(x);\n      }\n    }\n    bool uu[n];\n    memset(uu,0,sizeof(uu));\n    queue<int> q;\n    for(int i=0; i<n; i++) {\n      if(d[i]==M) {\n        uu[i]=1;\n        q.push(i);\n      }\n    }\n    while(!q.empty()) {\n      int x=q.front();q.pop();\n      for(int i=0; i<w[x].size(); i++) {\n        int y=w[x][i];\n        if(uu[y]) continue;\n        uu[y]=1;\n        q.push(y);\n      }\n    }\n    for(int i=0; i<n; i++) u[i]|=uu[i];\n  }\n  for(int i=0; i<n; i++) if(!u[i]) cnt++;\n  cout << cnt << endl;\n  for(int i=0; i<n; i++) if(!u[i]) cout << i+1 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dist[2000];set<int>p[2000];\nvector<pair<int,int>> vec[2000];\nint n,m;\nbool used2[2000];\nset<int>R[2000][2000];\nint dst[2000][2000];\nvector<int>shor[2000];\nvoid dijkstra(int s){\n\tfor(int i=0;i<2000;i++){dist[i]=999999999;p[i].clear();}\n\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>Q;\n\tQ.push(make_pair(0,s));dist[s]=0;\n\twhile(!Q.empty()){\n\t\tint a1=Q.top().first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<(int)vec[a2].size();i++){\n\t\t\tint to=vec[a2][i].first,cost=vec[a2][i].second;\n\t\t\tif(dist[to]>a1+cost){\n\t\t\t\tp[to].clear();p[to].insert(a2);\n\t\t\t\tdist[to]=a1+cost;\n\t\t\t\tQ.push(make_pair(dist[to],to));\n\t\t\t}\n\t\t\tif(dist[to]==a1+cost && p[to].count(a2)==0){\n\t\t\t\tp[to].insert(a2);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<2000;i++){\n\t\tdst[s][i]=dist[i];\n\t\tR[s][i]=p[i];\n\t}\n}\nvoid solve(int s){\n\tqueue<int>Q;\n\tbool used[2000];for(int i=0;i<2000;i++)used[i]=false;\n\tfor(int i=0;i<(int)shor[s].size();i++){Q.push(shor[s][i]);used[shor[s][i]]=true;}\n\twhile(!Q.empty()){\n\t\tint a1=Q.front();Q.pop();\n\t\t\n\t\tfor(auto a2 : p[a1]){\n\t\t\tif(used[a2]==false){used[a2]=true;Q.push(a2);}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){if(used[i]==true)used2[i]=true;}\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\tvec[a].push_back(make_pair(b,c));\n\t\tvec[b].push_back(make_pair(a,c));\n\t}\n\tfor(int i=1;i<=n;i++)dijkstra(i);\n\tint maxn=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tmaxn=max(maxn,dst[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(dst[i][j]==maxn)shor[i].push_back(j);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)solve(i);\n\tint num=0;\n\tfor(int i=1;i<=n;i++){if(used2[i]==false)num++;}\n\tcout<<num<<endl;\n\tfor(int i=1;i<=n;i++){if(used2[i]==false)cout<<i<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\ninline void dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\ninline void solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    if(tp == i) continue;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0351\n\n#include<bits/stdc++.h>\nconst int N = 1505;\nconst int inf = 1e9;\nusing namespace std;\n\ntypedef pair <int, int> ii;\nvector <ii> adj[N];\nint n, m, d[N][N], ans, visit[N], f[N], ck[N];\n\nvoid dijkstra(int S){\n    for (int i = 1; i <= n; i++) d[S][i] = inf; d[S][S] = 0;\n    priority_queue <ii, vector <ii>, greater<ii> > mq; mq.push(ii(d[S][S], S));\n    while (mq.size()){\n        ii z = mq.top(); mq.pop();\n        int u = z.second, val = z.first;\n        if (val != d[S][u]) continue;\n        ans = max(ans, val);\n        for (int i = 0; i < adj[u].size(); i++){\n            int v = adj[u][i].first, cost = adj[u][i].second;\n            if (d[S][v] > d[S][u] + cost){\n                d[S][v] = d[S][u] + cost;\n                mq.push(ii(d[S][v], v));\n            }\n        }\n    }\n}\n\nvoid dfs(int u, int root){\n    if (visit[u]) return;\n    visit[u] = true;\n    f[u] = d[root][u];\n    for (int i = 0; i < adj[u].size(); i++){\n        int v = adj[u][i].first, cost = adj[u][i].second;\n        if (d[root][v] == d[root][u] + cost){\n            dfs(v, root); f[u] = max(f[u], f[v]);\n        }\n    }\n    if (f[u] == ans) ck[u] = 1;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++){\n        int u, v, d; cin >> u >> v >> d;\n        adj[u].push_back(ii(v, d));\n        adj[v].push_back(ii(u, d));\n    }\n    for (int i = 1; i <= n; i++) dijkstra(i);\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++) visit[j] = 0;\n        dfs(i, i);\n    }\n    int cnt = 0; for (int i = 1; i <= n; i++) if (!ck[i]) cnt++;\n    cout << cnt << \"\\n\";\n    for (int i = 1; i <= n; i++) if (!ck[i]) cout << i << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n    int to, cost;\n    edge() {}\n    edge(int to, int cost) : to{to}, cost{cost} {}\n};\n\nstruct State {\n    int v, c;\n    State() {}\n    State(int v, int c) : v{v}, c{c} {}\n\n    bool operator < (const State& st) const {\n        return c > st.c;\n    };\n};\n\nint main()\n{\n    int N, R;\n    cin >> N >> R;\n    \n    constexpr int INF = (1 << 29);\n    vector<vector<edge>> G(N);\n    vector<vector<int>> c(N, vector<int>(N, INF));\n    for (int i = 0; i < R; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        s--; t--;\n        c[s][t] = c[t][s] = d;\n        G[s].emplace_back(t, d);\n        G[t].emplace_back(s, d);\n    }\n\n    vector<vector<int>> d(N, vector<int>(N, INF));\n    for (int i = 0; i < N; i++) {\n        d[i][i] = 0;\n        priority_queue<State> pq;\n        pq.push(State(i, 0));\n\n        while (!pq.empty()) {\n            State st = pq.top(); pq.pop();\n            int v = st.v, c = st.c;\n            if (c > d[i][v]) continue;\n            for (auto& e : G[v]) {\n                if (d[i][v] + e.cost < d[i][e.to]) {\n                    d[i][e.to] = d[i][v] + e.cost;\n                    pq.push(State(e.to, d[i][e.to]));\n                }\n            }\n        }\n    }\n    \n    int mx = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            mx = max(mx, d[i][j]);            \n        }\n    }\n    \n    vector<int> a, b;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (mx == d[i][j]) {\n                a.emplace_back(i);\n                b.emplace_back(j);\n            }\n        }\n    }\n    \n    vector<int> town;\n    for (int i = 0; i < N; i++) {\n        bool quiet = 1;\n        for (int j = 0; j < (int)a.size(); j++) {\n            if (d[a[j]][i] + d[i][b[j]] == mx) {\n                quiet = 0;\n                break;\n            }\n        }\n        if (quiet) {\n            town.emplace_back(i + 1);\n        }\n    }\n    \n    int n = town.size();\n    cout << n << endl;\n    for (int i = 0; i < n; i++) {\n        cout << town[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(x, a, b) for (int x = a; x <= b; ++x)\n#define FOD(x, a, b) for (int x = a; x >= b; --x)\n#define REP(x, a, b) for (int x = a; x < b; ++x)\n#define DEBUG(X) { cout << #X << \" = \" << X << endl; }\n#define PR(A, n) { cout << #A << \" = \"; FOR(_, 1, n) cout << A[_] << \" \"; cout << endl; }\n#define PR0(A, n)  { cout << #A << \" = \"; REP(_, 0, n) cout << A[_] << \" \"; cout << endl; }\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> II;\n\nconst int N = 1500 + 10;\nconst int INF = 0x3f3f3f3f;\n\nint n, m;\nint d[N][N];\n\nbool ban[N], fre[N];\n\nII V[N];\n\nvector <II> adj[N];\n\nvoid Dijkstra(int *d, int s) {\n    priority_queue <II> pq;\n    d[s] = 0; pq.push(II(d[s], s));\n    while (pq.size()) {\n        int u = pq.top().second, w = pq.top().first; pq.pop();\n        if (w > d[u]) continue;\n        REP(k, 0, adj[u].size()) {\n            int v = adj[u][k].first, w = adj[u][k].second;\n            if (d[v] > d[u] + w) {\n                d[v] = d[u] + w;\n                pq.push(II(d[v], v));\n            }\n        }\n    }\n}\n\nint main() {\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif // LOCAL\n    scanf(\"%d%d\", &n, &m);\n    FOR(i, 1, m) {\n        int u, v, w; scanf(\"%d%d%d\", &u, &v, &w);\n        adj[u].push_back(II(v, w));\n        adj[v].push_back(II(u, w));\n        //cout << u << \" \" << v << \" \" << w << endl;\n    }\n    FOR(i, 1, n) {\n        memset(d[i], INF, sizeof d[i]);\n        Dijkstra(d[i], i);\n    }\n    int maxDist = -INF;\n    FOR(i, 1, n)\n        FOR(j, 1, n) maxDist = max(maxDist, d[i][j]);\n    int VSize = 0;\n    FOR(i, 1, n) ban[i] = true;\n    FOR(i, 1, n)\n        FOR(j, 1, n) if (d[i][j] == maxDist) {\n            V[++VSize] = II(i, j);\n            ban[i] = false;\n            ban[j] = false;\n        }\n    FOR(i, 1, n) if (ban[i] == true) {\n        FOR(j, 1, VSize) {\n            int x = V[j].first, y = V[j].second;\n            if (d[x][i] + d[i][y] == maxDist) ban[i] = false;\n        }\n    }\n    int sz = 0;\n    FOR(i, 1, n) if (ban[i]) ++sz;\n    printf(\"%d\\n\", sz);\n    FOR(i, 1, n) if (ban[i]) printf(\"%d\\n\", i);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define Link \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0351\"\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n\n#define TASK \"Quiet Town\"\n\nusing namespace std;\n\nvoid OpenFile()\n{\n    freopen(TASK\".INP\",\"r\",stdin);\n    freopen(TASK\".OUT\",\"w\",stdout);\n}\n\nconst int oo = 1e9 + 1;\nconst int maxn = 15e2 + 1;\nint n,r,d[maxn][maxn];\nvector <pair<int,int> > e[maxn];\npriority_queue <pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq;\nbool b[maxn],chose[maxn];\n\nvoid Enter()\n{\n    cin >> n >> r;\n    for (int i=1;i<=r;++i) {\n        int u,v,w;\n        cin >> u >> v >> w;\n        e[u].push_back({w,v});\n        e[v].push_back({w,u});\n    }\n}\n\nvoid Dijkstra(int s)\n{\n    fill(d[s],d[s]+n+1,+oo);\n    d[s][s] = 0;\n    pq.push({0,s});\n    while (!pq.empty()) {\n        int D = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n        if (D != d[s][u])\n            break;\n        for (auto p : e[u]) {\n            int w = p.first;\n            int v = p.second;\n            if (d[s][v] > d[s][u] + w) {\n                d[s][v] = d[s][u] + w;\n                pq.push({d[s][v],v});\n            }\n        }\n    }\n}\n\nvoid Init()\n{\n    for (int s=1;s<=n;++s)\n        Dijkstra(s);\n}\n\nvoid DFS(int t, int s)\n{\n    if (b[t])\n        return;\n    b[t] = 1;\n    for (auto p : e[t]) {\n        int w = p.first;\n        int v = p.second;\n        if (d[s][v] + w == d[s][t])\n            DFS(v,s);\n    }\n}\n\nvoid Print()\n{\n    int cnt = 0;\n    for (int i=1;i<=n;++i)\n        if (!chose[i])\n            ++cnt;\n    cout << cnt << '\\n';\n    for (int i=1;i<=n;++i)\n        if (!chose[i])\n            cout << i << '\\n';\n}\n\nvoid Solve()\n{\n    int mx = -oo;\n    for (int s=1;s<=n;++s)\n        for (int t=1;t<=n;++t)\n            if (d[s][t] != +oo)\n                mx = max(mx,d[s][t]);\n    for (int s=1;s<=n;++s) {\n        fill(b,b+n+1,0);\n        for (int t=1;t<=n;++t)\n            if (mx == d[s][t])\n                DFS(t,s);\n        for (int i=1;i<=n;++i)\n            chose[i] |= b[i];\n    }\n    Print();\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    //OpenFile();\n\n    Enter();\n    Init();\n    Solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n// clang-format on\n/* }}} */\n\nstruct Edge {\n  Edge() {}\n  Edge(int a, int b) { to = a; cost = b; }\n  int to, cost;\n};\nint N, R;\nvector<Edge> G[1500];\nbool pass[1500];\n\nvoid dijkstra(int s, vi &d) {\n  minPQ<pii> q;\n  d[s] = 0;\n  q.emplace(0, s);\n\n  while (q.size()) {\n    auto p = q.top(); q.pop();\n    int v = p.Se;\n    if (d[v] < p.Fi) continue;\n    EACH(e, G[v]) {\n      if (d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        q.emplace(d[e.to], e.to);\n      }\n    }\n  }\n}\n\nvoid bfs(int s, vi &d) {\n  queue<pii> q;\n  q.emplace(s, d[s]);\n  bool vis[1500] = {};\n  while (q.size()) {\n    auto p = q.front(); q.pop();\n    if (vis[p.Fi]) continue;\n    pass[p.Fi] = true;\n    vis[p.Fi] = true;\n    EACH(e, G[p.Fi]) {\n      if (d[e.to] != d[p.Fi] - e.cost) continue;\n      q.emplace(e.to, d[e.to]);\n    }\n  }\n}\n\nsigned main() {\n  cin >> N >> R;\n  vvi d(N, vi(N, INF));\n  REP(i, R) {\n    int s = in() - 1, t = in() - 1, d = in();\n    G[s].eb(t, d);\n    G[t].eb(s, d);\n  }\n  REP(i, N) dijkstra(i, d[i]);\n\n  int ma = 0;\n  REP(i, N) REP(j, N) chmax(ma, d[i][j]);\n\n  REP(i, N) REP(j, N) {\n    if (ma == d[i][j]) {\n      bfs(j, d[i]);\n    }\n  }\n  vi ans;\n  REP(i, N) {\n    if (!pass[i]) ans.eb(i + 1);\n  }\n  print(ans.size());\n  EACH(i, ans) print(i);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nusing P = pair<int, int>;\nusing P3 = pair<int, P>;\nusing PP = pair<P, P>;\nconstexpr int INF = 1 << 30;\nconstexpr ll MOD = ll(1e9) + 7;\nconstexpr int di[] = {0, 1, 0, -1};\nconstexpr int dj[] = {1, 0, -1, 0};\n\nvector<vector<P> > g;\nvector<int> d;\nvector<bool> visited;\nvector<bool> used; \nint maxi = 0;\nset<int> st;\n\nvoid dijkstra(int s, int f=0){\n    fill(d.begin(), d.end(), INF);\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P> > que;\n    que.push(P(d[s],s));\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(auto &e : g[v]){\n            int u = e.first, c = e.second;\n            if(d[u] > d[v] + c){\n                d[u] = d[v] + c;\n                que.push(P(d[u],u));\n            }\n        }\n    }\n    if(!f){\n        for(int i=0;i<int(g.size());i++){\n            if(d[i] > maxi){\n                st.clear();\n                st.insert(s);\n                st.insert(i);\n                maxi = d[i];\n            }\n            else if(d[i] == maxi && !visited[i]){\n                st.insert(i);\n                st.insert(s);\n            }\n        }\n    }else{\n        fill(visited.begin(), visited.end(), false);\n        queue<int> q;\n        for(int i=0;i<int(g.size());i++){\n            if(d[i] == maxi) q.push(i);\n        }\n        while(!q.empty()){\n            int v = q.front();\n            q.pop();\n            used[v] = true;\n            for(auto &e : g[v]){\n                int u = e.first , c = e.second;\n                if(!visited[u] && d[u]+c == d[v]){\n                    visited[u] = true;\n                    q.push(u);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int N, R;\n    cin >> N >> R;\n    g.resize(N);\n    d.resize(N);\n    visited.resize(N);\n    used.resize(N);\n    for(int i=0;i<R;i++){\n        int s, t, c;\n        cin >> s >> t >> c;\n        s--; t--;\n        g[s].emplace_back(P(t,c));\n        g[t].emplace_back(P(s,c));\n    }\n    for(int i=0;i<N;i++){\n        dijkstra(i);\n    }\n    for(auto v : st){\n        dijkstra(v, 1);\n    }\n    vector<int> ans;\n    for(int i=0;i<N;i++){\n        if(!used[i]){\n            ans.push_back(i+1);\n        }\n    }\n    cout << ans.size() << endl;\n    for(auto v : ans){\n        cout << v << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 3100\n\n/* Dijkstra O(NlogM)*/\n\nstruct Dijkstra{\n\n  typedef int Type;\n\n  int V;\n  vector<vector<pair<int,Type> > > G;\n  vector<int> cost;\n  \n  Dijkstra(int n):\n    V(n),G(n,vector<pair<int,Type> >()){}\n  \n  void add_edge(int u, int v, Type c){\n    G[u].push_back({v,c});\n  }\n  \n  Type solve(int s, int g = -1){\n    cost.assign(V,-1);\n    priority_queue<pair<Type,int> > pq;\n    Type max_cost = 0;\n    \n    pq.push({0,s});\n\n    while(pq.size()){\n      Type now_cost = pq.top().first;\n      int now = pq.top().second;\n      pq.pop();\n\n      if(cost[now] >= 0) continue;\n      \n      cost[now] = -now_cost;\n      max_cost = max(max_cost, -now_cost);\n      \n      if(now == g) return -now_cost;\n      \n      for(int i=0;i<(int)G[now].size();i++){\n        pq.push({now_cost-G[now][i].second, G[now][i].first});\n      }\n    }\n        \n    return max_cost;\n  }\n  \n};\n\n\nint main(){\n  int n,r;\n  int s[SIZE],t[SIZE],d[SIZE];\n  bool ans[SIZE] = {};\n  \n  scanf(\"%d%d\",&n,&r);\n\n  Dijkstra dij(n);\n  \n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",s+i,t+i,d+i);\n    s[i]--; t[i]--;\n    \n    dij.add_edge(t[i],s[i],d[i]);\n    dij.add_edge(s[i],t[i],d[i]);\n  }\n\n  int ans_dis = 0;\n  \n  for(int i=0;i<n;i++){\n    int max_dis = dij.solve(i);\n\n    if(max_dis > ans_dis){\n      for(int j=0;j<n;j++) ans[i] = false;\n      ans_dis = max_dis;\n    }\n\n    if(max_dis < ans_dis) continue;\n    \n    queue<int> que;\n    bool visited[SIZE] = {};\n    \n    for(int j=0;j<n;j++){\n      if(max_dis == dij.cost[j]){\n        que.push(j);\n      }\n    }\n\n    while(que.size()){\n      int p = que.front();\n      que.pop();\n      \n      if(visited[p]) continue;\n      visited[p] = true;\n      ans[p] = true;\n      \n      for(int j=0;j<dij.G[p].size();j++){\n        if(dij.cost[p] - dij.G[p][j].second == dij.cost[dij.G[p][j].first]){\n          que.push(dij.G[p][j].first);\n        }\n      }\n\n    }\n\n\n  }\n\n  int ans_count = 0;\n  for(int i=0;i<n;i++) ans_count += ans[i] == false;\n\n  printf(\"%d\\n\",ans_count);\n  \n  for(int i=0;i<n;i++){\n    if(ans[i] == false){\n      printf(\"%d\\n\",i+1);\n    }\n  }\n  \n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N,R;\nvector<vector<pair<int, int> > > MapData;\nvector<pair<int, int> > CourseInfo;\nint ShortDistOfEachNode[1501][1501];\nbool Used[1501];\nset<int> Result;\n\nconst int INF = 1e9;\n\nvoid findShortDistOfEachNode(int StartNode, int *dist) {\n\tint curNode, cost, sizeOfTo, nextNode, costTo;\n\tpriority_queue<pair<int, int> > NodeList;\n\t//priority_queue<pair<int, int>,vector<pair<int, int> >,greater<pair<int, int> > > NodeList;\n\tpair<int, int> tmp;\n\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfill(dist, dist + N + 1, INF);\n\t}\n\tdist[StartNode] = 0;\n\tNodeList.push({ StartNode,0 });\n\twhile (!NodeList.empty()) {\n\t\ttmp = NodeList.top();\n\t\tNodeList.pop();\n\n\t\tcurNode = tmp.first;\n\t\tcost = tmp.second;\n\t\tif (cost > dist[curNode]) {\n\t\t\tcontinue;\n\t\t}\n\t\tsizeOfTo = MapData[curNode].size();\n\t\tfor (int i = 0; i < sizeOfTo; ++i) {\n\t\t\tnextNode = MapData[curNode][i].first;\n\t\t\tcostTo = MapData[curNode][i].second;\n\t\t\tif (cost + costTo < dist[nextNode]) {\n\t\t\t\tdist[nextNode] = cost + costTo;\n\t\t\t\tNodeList.push({ nextNode,dist[nextNode] });\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nvoid findNode(int startNode, int curNode, int *dist) {\n\tint sizeOfTo, preNode, cost;\n\n\tif (Used[curNode]) {\n\t\treturn;\n\t}\n\tUsed[curNode] = true;\n\tResult.insert(curNode);\n\tif (startNode == curNode) {\n\t\treturn;\n\t}\n\n\tsizeOfTo = MapData[curNode].size();\n\tfor (int i = 0; i < sizeOfTo; ++i) {\n\t\tpreNode = MapData[curNode][i].first;\n\t\tcost = MapData[curNode][i].second;\n\t\tif (dist[curNode] == dist[preNode] + cost) {\n\t\t\tfindNode(startNode, preNode, dist);\n\t\t}\n\t}\n}\n\nint main() {\n\tint s, t, d, maxShortLen;\n\n\tcin >> N >> R;\n\tMapData.resize(N + 1);\n\tfor (int i = 0; i < R; ++i) {\n\t\tcin >> s >> t >> d;\n\t\tMapData[s].push_back({ t,d });\n\t\tMapData[t].push_back({ s,d });\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfindShortDistOfEachNode(i,ShortDistOfEachNode[i]);\n\t}\n\t\n\tmaxShortLen = 0;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 1; j <= N; ++j) {\n\t\t\tif (ShortDistOfEachNode[i][j] == INF) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmaxShortLen = max(maxShortLen, ShortDistOfEachNode[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= N; ++i) {\n\t\tmemset(Used, false, sizeof(Used));\n\t\tfor (int j = 1; j <= N; ++j) {\n\t\t\tif (ShortDistOfEachNode[i][j] == maxShortLen) {\n\t\t\t\tfindNode(i, j, ShortDistOfEachNode[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << N - Result.size() << endl;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (Result.find(i) == Result.end()) {\n\t\t\tcout << i << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi \"QUIETTOWN.inp\"\n#define fo \"QUIETTOWN.out\"\n#define vt first\n#define gt second\n#define maxn 1700\n#define maxc 1000000000\n\nusing namespace std;\n\npriority_queue < pair <int,int> > heap;\n\nint w,n,m,d[maxn][maxn],p[maxn][maxn],he[maxn*maxn],ke[maxn*maxn],e[maxn*maxn],ans;\nint l[maxn*maxn],r[maxn*maxn],dg[maxn*maxn],fu[maxn],fv[maxn];\nbool dau[maxn],kt[maxn];\n\nvoid open()\n{\n    w=0;\n //   freopen(fi,\"r\",stdin);\n   // freopen(fo,\"w\",stdout);\n\n    scanf(\"%d%d\",&n,&m);\n    int x,y,c;\n\n    for (int i=1; i<=m; i++)\n    {\n      scanf(\"%d%d%d\",&x,&y,&c);\n      he[x]++;\n      he[y]++;\n    }\n    for (int i=2; i<=n; i++) he[i]+=he[i-1];\n\n    freopen(fi,\"r\",stdin);\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1; i<=m; i++)\n    {\n      scanf(\"%d%d%d\",&x,&y,&c);\n      ke[he[x]]=y;\n      ke[he[y]]=x;\n      e[he[x]]=c;\n      e[he[y]]=c;\n      --he[x];\n      --he[y];\n    }\n    he[n+1]=m*2;\n}\n\nvoid dijkstra(int s, int t)\n{\n    for (int i=1; i<=n; i++) d[s][i]=maxc;\n    memset(dau,true,sizeof(dau));\n    d[s][s]=0;\n\n    heap.push(make_pair(0,s));\n\n    while (!heap.empty())\n    {\n      int u=heap.top().gt;\n      heap.pop();\n\n      dau[u]=false;\n      for (int iv=he[u]+1; iv<=he[u+1]; iv++)\n      {\n        int v=ke[iv];\n        if ((dau[v]) && (d[s][v]>d[s][u]+e[iv]))\n        {\n          d[s][v]=d[s][u]+e[iv];\n          p[s][v]=u;\n          heap.push(make_pair(-d[s][v],v));\n        }\n      }\n    }\n}\n\nvoid trace(int s, int u)\n{\n    kt[s]=true;\n    while (p[s][u]!=0)\n    {\n      u=p[s][u];\n      kt[u]=true;\n    }\n}\n\nvoid mocxichcuaconbeo()\n{\n    memset(kt,true,sizeof(kt));\n\n    for (int i=0; i<=n; i++)\n    {\n      l[i]=i-1;\n      r[i]=i+1;\n    }\n\n    for (int i=1; i<=w; i++)\n    {\n      int uu=fu[i];\n      int vv=fv[i];\n\n      int k=0;\n      while (k!=n+1)\n      {\n        if (d[uu][k]+d[k][vv]==ans)\n        {\n          kt[k]=false;\n          l[r[i]]=l[i];\n          r[l[i]]=r[i];\n        }\n        k=r[k];\n      }\n    }\n\n}\n\nvoid process()\n{\n    for (int i=1; i<=n; i++)\n    {\n        dijkstra(i,n);\n        for (int j=1; j<=n; j++)\n          if (i!=j) ans=max(ans,d[i][j]);\n    }\n\n    memset(kt,false,sizeof(kt));\n\n    for (int i=1; i<=n; i++)\n      for (int j=1; j<=n; j++)\n      {\n        if (d[i][j]==ans)\n        {\n          fu[++w]=i;\n          fv[w]=j;\n        }\n      }\n\n    mocxichcuaconbeo();\n\n    int kq=0;\n    for (int i=1; i<=n; i++)\n      if (kt[i]==true) dg[++kq]=i;\n\n    printf(\"%d\\n\",kq);\n    for (int i=1; i<=kq; i++) printf(\"%d\\n\",dg[i]);\n}\n\nint main()\n{\n    open();\n    process();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n// clang-format on\n/* }}} */\n\nstruct Edge {\n  Edge() {}\n  Edge(int a, int b) { to = a; cost = b; }\n  int to, cost;\n};\nint N, R;\nvector<Edge> G[1500];\nmap<int, bool> chie;\n\nvoid dijkstra(int s, vi &d) {\n  minPQ<pii> q;\n  d[s] = 0;\n  q.emplace(0, s);\n\n  while (q.size()) {\n    auto p = q.top(); q.pop();\n    int v = p.Se;\n    if (d[v] < p.Fi) continue;\n    EACH(e, G[v]) {\n      if (d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        q.emplace(d[e.to], e.to);\n      }\n    }\n  }\n}\n\nvoid bfs(int s, vi &d) {\n  queue<pii> q;\n  q.emplace(s, d[s]);\n  bool vis[1500] = {};\n  while (q.size()) {\n    auto p = q.front(); q.pop();\n    if (vis[p.Fi]) continue;\n    chie[p.Fi] = true;\n    vis[p.Fi] = true;\n    EACH(e, G[p.Fi]) {\n      if (d[e.to] != d[p.Fi] - e.cost) continue;\n      q.emplace(e.to, d[e.to]);\n    }\n  }\n}\n\nsigned main() {\n  cin >> N >> R;\n  vvi d(N, vi(N, INF));\n  REP(i, R) {\n    int s = in() - 1, t = in() - 1, d = in();\n    G[s].eb(t, d);\n    G[t].eb(s, d);\n  }\n  REP(i, N) dijkstra(i, d[i]);\n\n  int ma = 0;\n  REP(i, N) REP(j, N) chmax(ma, d[i][j]);\n\n  REP(i, N) REP(j, N) {\n    if (ma == d[i][j]) {\n      bfs(j, d[i]);\n    }\n  }\n\n  print(N - chie.size());\n  REP(i, N) if (!chie[i]) {\n    print(i + 1);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0351\n\n#include<bits/stdc++.h>\nconst int N = 1505;\nconst int inf = 1e9;\nusing namespace std;\n\ntypedef pair <int, int> ii;\nvector <ii> adj[N];\nint n, m, d[N][N], ans, visit[N], f[N], ck[N];\n\nvoid dijkstra(int S){\n    for (int i = 1; i <= n; i++) d[S][i] = inf; d[S][S] = 0;\n    priority_queue <ii, vector <ii>, greater<ii> > mq; mq.push(ii(d[S][S], S));\n    while (mq.size()){\n        ii z = mq.top(); mq.pop();\n        int u = z.second, val = z.first;\n        if (val != d[S][u]) continue;\n        ans = max(ans, val);\n        for (int i = 0; i < adj[u].size(); i++){\n            int v = adj[u][i].first, cost = adj[u][i].second;\n            if (d[S][v] > d[S][u] + cost){\n                d[S][v] = d[S][u] + cost;\n                mq.push(ii(d[S][v], v));\n            }\n        }\n    }\n}\n\nvoid dfs(int u, int root){\n    if (visit[u]) return;\n    visit[u] = true;\n    f[u] = d[root][u];\n    for (int i = 0; i < adj[u].size(); i++){\n        int v = adj[u][i].first, cost = adj[u][i].second;\n        if (d[root][v] == d[root][u] + cost){\n            dfs(v, root); f[u] = max(f[u], f[v]);\n        }\n    }\n    if (f[u] == ans) ck[u] = 1;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++){\n        int u, v, d; cin >> u >> v >> d;\n        adj[u].push_back(ii(v, d));\n        adj[v].push_back(ii(u, d));\n    }\n    for (int i = 1; i <= n; i++) dijkstra(i);\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++) visit[j] = 0;\n        dfs(i, i);\n    }\n    int cnt = 0; for (int i = 1; i <= n; i++) if (!ck[i]) cnt++;\n    cout << cnt << \"\\n\";\n    for (int i = 1; i <= n; i++) if (!ck[i]) cout << i << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n\nusing namespace std;\nconst int Maxn=1e3;\n\nstruct Weighted_Vertex\n{\n    int u,w;\n\n    bool operator< (Weighted_Vertex other) const\n    {\n        return w>other.w;\n    }\n};\n\nint n,m;\nvector <Weighted_Vertex> adj[Maxn];\n\nint d[Maxn][Maxn];\nvector <int> trace[Maxn][Maxn];\n\nbool in[Maxn],Check[Maxn];\n\nint main()\n{\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nint mp[1501];\n\ninline void dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\ninline void solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    if(tp == i) continue;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  while(1) {\n    mp[j] = 1;\n    if(j == i) break;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        j = e.to;\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(mas == d[i][j]) {\n        solve(i, j);\n      }\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1 ) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b)    for (int i = a; i <= (int) b; ++i)\n#define ii              pair <int, int>\nusing namespace std;\nconst int N = 1503;\nint n, m;\nvector <ii> adj[N];\n\nvoid init() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n}\n\npriority_queue <ii, vector <ii>, greater <ii> > Q;\nint d[N][N], Max;\nvoid dijk(int st) {\n    d[st][st] = 0; Q.push({ 0, st });\n    while (Q.size()) {\n        int u = Q.top().second, du = Q.top().first;\n        Q.pop();\n        if (du != d[st][u]) continue;\n        Max = max(Max, du);\n        for (ii it : adj[u]) {\n            int v = it.second, w = it.first;\n            if (d[st][v] > du + w) d[st][v] = du + w, Q.push({ d[st][v], v });\n        }\n    }\n}\n\nqueue <int> dm;\nint vis[N];\nvoid trace(int st) {\n    FOR(i, 1, n) if (d[st][i] == Max) dm.push(i), vis[i] = st;\n    while (dm.size()) {\n        int u = dm.front(); dm.pop();\n        for (ii it : adj[u]) {\n            int v = it.second, w = it.first;\n            if (d[st][u] == d[st][v] + w && vis[v] < st) vis[v] = st, dm.push(v);\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n >> m;\n    FOR(i, 1, m) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        adj[u].push_back({ w, v }), adj[v].push_back({ w, u });\n    }\n\n    memset(d, 0x3f, sizeof d);\n    FOR(i, 1, n) dijk(i);\n\n    FOR(i, 1, n) trace(i);\n    int dem = 0;\n    FOR(i, 1, n) if (vis[i] == 0) ++dem;\n    cout << dem << '\\n';\n    FOR(i, 1, n) if (vis[i] == 0) cout << i << '\\n';\n}\n\nmain() {\n    init(); solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n#define mk make_pair\n#define f first\n#define s second\n\nconst int N = 2e3 + 7;\nint t, res, n, m, ans;\nvector<ii> a[N];\nint way[N][N], gt[N];\nbool pass[N], choos[N];\n\nvoid djk(int u)\n{\n    priority_queue<ii, vector<ii>, greater<ii> > q; q.push(mk(0, u)); way[u][u] = 0;\n    while(!q.empty())\n    {\n        ii tmp = q.top(); q.pop();\n        if(tmp.f != way[u][tmp.s]) continue;\n        ans = max(ans, tmp.f);\n        for(int i = 0; i < a[tmp.s].size(); i ++)\n        {\n            int v = a[tmp.s][i].f, val = a[tmp.s][i].s;\n            if(way[u][v] > val + tmp.f)\n            {\n                way[u][v] = val + tmp.f;\n                q.push(mk(val + tmp.f, v));\n            }\n        }\n    }\n}\nvoid dfs(int u, int root)\n{\n    if(pass[u]) return ; pass[u] = true; gt[u] = 0;\n    for(int i = 0 ; i < a[u].size(); i ++)\n    {\n        int v = a[u][i].f, val = a[u][i].s;\n        if(way[root][v] == way[root][u] + val)\n        {\n            dfs(v, root);\n            gt[u] = max(gt[u], gt[v] + val);\n        }\n    }\n    if(gt[u] + way[root][u] == ans) choos[u] = true;\n//    cout << root << \"  \" << u << \"  \" << gt[u] << \"  \" << way[root][u] << \"\\n\";\n}\n\nmain()\n{\n#define file \"r\"\n//    freopen(file\".inp\", \"r\", stdin);\n//  freopen(file\".out\", \"w\", stdout);\n    ios_base::sync_with_stdio(false);\n    memset(way, 0x3f, sizeof(way));\n    cin >> n >> m;\n    for(int i = 1; i <= m; i ++)\n    {\n        int x, y, d; cin >> x >> y >> d;\n        a[x].push_back(mk(y, d)); a[y].push_back(mk(x, d));\n//        cout << x << \"  \" << y << \"  \" << d << \"\\n\";\n    }\n//    return 0;\n    for(int i = 1; i <= n; i ++) djk(i);\n    for(int i = 1; i <= n; i ++)\n    {\n        for(int j = 1; j <= n; j ++) pass[j] = false;\n        dfs(i, i);\n    }\n    for(int i = 1; i <= n; i ++) res += !choos[i];\n    cout << res << \"\\n\";\n    for(int i = 1; i <= n; i ++)\n        if(!choos[i]) cout << i << \"\\n\";\n//    cout << ans << \"\\n\";\n//    for(int i = 1; i <= n; i ++)\n//    {for(int j = 1; j <= n; j ++) cout << way[i][j] << \"  \"; cout << \"\\n\";}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std::chrono;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing pq_int=priority_queue<int,vector<int>,greater<int>>;\nconst ll LINF=0x3fffffffffffffff;\nconst ll MOD=1000000007;\nconst ll MODD=0x3b800001;\nconst int INF=0x3fffffff;\n#define _overload4(_1,_2,_3,_4,name,...) name\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep1(n) _rep2(i,n)\n#define _rep2(i,n) _rep3(i,0,n)\n#define _rep3(i,a,b) for(ll i=a;i<b;++i)\n#define _rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) _overload4(__VA_ARGS__,_rep4,_rep3,_rep2,_rep1)(__VA_ARGS__)\n#define _rrep1(n) _rrep2(i,n)\n#define _rrep2(i,n) _rrep3(i,0,n)\n#define _rrep3(i,a,b) for(ll i=b-1;i>=a;i--)\n#define _rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) _overload4(__VA_ARGS__,_rrep4,_rrep3,_rrep2,_rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto&& i:a)\n#define sum(...) accumulate(range(__VA_ARGS__),0)\n#define _range(i) (i).begin(),(i).end()\n#define _range2(i,k) (i).begin(),(i).begin()+k\n#define _range3(i,a,b) (i).begin()+a,(i).begin()+b\n#define range(...) _overload3(__VA_ARGS__,_range3,_range2,_range)(__VA_ARGS__)\n#define Yes(i) out(i?\"Yes\":\"No\")\n#define YES(i) out(i?\"YES\":\"NO\")\n//#define START auto start=system_clock::now()\n//#define END auto end=system_clock::now();cerr<<duration_cast<milliseconds>(end-start).count()<<\" ms\\n\"\n#define elif else if\n#define unless(a) if(!(a))\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n__attribute__((constructor)) void SETTINGS(){cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); cout<<fixed<<setprecision(15);};\ntemplate<class T>\ninline constexpr T gcd (T a,T b) {if(a==b)return a;else return gcd(b,(a-1)%b+1);}\ntemplate<class T>\ninline constexpr T min(vector<T>& v){return *min_element(range(v));}\ninline char min(string& v){return *min_element(range(v));}\ntemplate<class T>\ninline constexpr T max(vector<T>& v){return *max_element(range(v));}\ninline char max(string& v){return *max_element(range(v));}\ntemplate<typename T>\ninline bool update_min(T& mn,const T& cnt){if(mn>cnt){mn=cnt;return 1;}else return 0;}\ntemplate<typename T>\ninline bool update_max(T& mx,const T& cnt){if(mx<cnt){mx=cnt;return 1;}else return 0;}\ninline void in() {}\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& vec);\ntemplate<class T,size_t size>\nistream& operator >> (istream& is, array<T,size>& vec);\ntemplate<class T,class L>\nistream& operator >> (istream& is, pair<T,L>& p);\ntemplate<class T>\nostream& operator << (ostream& os, vector<T>& vec);\ntemplate<class T,class L>\nostream& operator << (ostream& os, pair<T,L>& p);\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& vec){for(T& x: vec) is >> x;return is;}\ntemplate<class T,class L>\nistream& operator >> (istream& is, pair<T,L>& p){is >> p.first;is >> p.second;return is;}\ntemplate<class T>\nostream& operator << (ostream& os, vector<T>& vec){os << vec[0];rep(i,1,vec.size()){os << ' ' << vec[i];}return os;}\ntemplate<class T>\nostream& operator << (ostream& os, deque<T>& deq){os << deq[0];rep(i,1,deq.size()){os << ' ' << deq[i];}return os;}\ntemplate<class T,class L>\nostream& operator << (ostream& os, pair<T,L>& p){os << p.first << \" \" << p.second;return os;}\ntemplate <class Head, class... Tail>\ninline void in(Head&& head,Tail&&... tail){cin>>head;in(move(tail)...);}\ntemplate <class T>\ninline void out(T t){cout<<t<<'\\n';}\ninline void out(){cout<<'\\n';}\ntemplate <class Head, class... Tail>\ninline void out(Head head,Tail... tail){cout<<head<<' ';out(move(tail)...);}\ntemplate <class T>\ninline void err(T t){cerr<<t<<'\\n';}\ninline void err(){cerr<<'\\n';}\ntemplate <class Head, class... Tail>\ninline void err(Head head,Tail... tail){cerr<<head<<' ';out(move(tail)...);}\n\n\n\nsigned main(){\n    vector<unordered_map<ll,ll>> d(1501);\n    INT(n,r);\n    rep(r){\n        INT(s,t,dis);\n        d[s][t]=d[t][s]=dis;\n    }\n    ll mx=0;\n    vec(bool,ans,n+1);\n    rep(i,1,n+1){\n        vec(ll,cost,n+1,LINF);\n        vec(bool,used,n+1);\n        vv(vector<ll>,route,n+1,0);\n        cost[i]=0;\n        route[i]={{i}};\n        priority_queue<pll,vector<pll>,greater<pll>> q;\n        q.push({0,i});\n        while(!q.empty()){\n            ll at=q.top().second,cnt=q.top().first;\n            q.pop();\n            if(used[at])continue;\n            used[at]=1;\n            each(j,d[at]){\n                if(cost[j.first]>j.second+cnt){\n                cost[j.first]=j.second+cnt;\n                route[j.first]=route[at];\n                each(v,route[j.first])v.push_back(j.first);\n                q.push({cost[j.first],j.first});\n                }\n                elif(cost[j.first]==j.second+cnt){\n                    each(k,route[at]){\n                        route[j.first].push_back(k);\n                        route[j.first].back().push_back(j.first);\n                    }\n                }\n            }\n        }\n        ll a=*max_element(cost.begin()+1,cost.end());\n        if(a>mx){\n            mx=a;\n            ans.assign(n+1,0);\n        }\n        rep(i,1,n+1)if(cost[i]==mx)each(j,route[i])each(k,j)ans[k]=1;\n    }\n    ll cnt=0;\n    rep(i,1,n+1)if(!ans[i])cnt++;\n    out(cnt);\n    rep(i,1,n+1)if(!ans[i])out(i);\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\nusing namespace std;\nusing i64 = long long;\n\nstruct Edge\n{\n  i64 to, cost;\n};\n\ni64 n;\nvector<vector<Edge>> edge;\nvector<vector<i64>> d;\nvector<bool> ok;\n\nvoid dijkstra(int s)\n{\n  d[s][s] = 0;\n  priority_queue<pair<i64, i64>, vector<pair<i64, i64>>, greater<pair<i64, i64>>> que;\n  que.push({0, s});\n  while (que.size())\n  {\n    pair<i64, i64> p = que.top();\n    que.pop();\n    for (Edge i : edge[p.second])\n      if (d[s][p.second] + i.cost < d[s][i.to])\n      {\n        d[s][i.to] = d[s][p.second] + i.cost;\n        que.push({d[s][i.to], i.to});\n      }\n  }\n  return;\n}\n\nvoid check(i64 s, i64 md)\n{\n  queue<i64> que;\n  vector<bool> vis(n);\n  for (i64 i = 0; i < n; i++)\n    if (d[s][i] == md)\n    {\n      que.push(i);\n      vis[i] = true;\n    }\n  while (que.size())\n  {\n    i64 p = que.front();\n    que.pop();\n    ok[p] = false;\n    for (Edge i : edge[p])\n      if (!vis[i.to] && d[s][i.to] == d[s][p] - i.cost)\n      {\n        vis[i.to] = true;\n        que.push(i.to);\n      }\n  }\n}\n\nint main()\n{\n  i64 r;\n  cin >> n >> r;\n  edge.resize(n);\n  for (i64 i = 0; i < r; i++)\n  {\n    i64 s, t, d;\n    cin >> s >> t >> d;\n    s--;\n    t--;\n    edge[s].push_back({t, d});\n    edge[t].push_back({s, d});\n  }\n  d.resize(n, vector<i64>(n, 1e9));\n  for (i64 i = 0; i < n; i++)\n    dijkstra(i);\n  i64 md = 0;\n  for (i64 i = 0; i < n; i++)\n    for (i64 j = 0; j < n; j++)\n      md = max(md, d[i][j]);\n  ok.resize(n, true);\n  for (i64 i = 0; i < n; i++)\n    check(i, md);\n  vector<i64> ans;\n  for (i64 i = 0; i < n; i++)\n    if (ok[i])\n      ans.push_back(i + 1);\n  cout << ans.size() << endl;\n  for (i64 i : ans)\n    cout << i << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  while(!st.empty()) {\n    mp[j] = 1;\n    if(j == i) continue;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nvoid solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  map<int, int> mpp;\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    if(mpp[tp]) continue;\n    mp[tp] = 1;\n    if(tp == i) continue;\n    mpp[tp] = 1;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1505;\nconst int INF = 1e9;\ntypedef pair<int,int> ii;\n\nint n, m;\nvector <ii> g[N];\nvector <int> rev[N];\nint d[N][N];\nint deg[N];\nbool ok[N];\nint mx;\n\nvoid dijkstra(int s) {\n    for (int i = 1; i <= n; ++i) d[s][i] = INF;\n    d[s][s] = 0;\n    priority_queue < ii, vector<ii>, greater<ii> > pq;\n    pq.push(ii(0, s));\n\n    while(!pq.empty()) {\n        ii top = pq.top(); pq.pop();\n        int u = top.second, du = top.first;\n        if (du != d[s][u]) continue;\n\n        for (auto &e : g[u]) {\n            int v = e.second, w = e.first;\n            if (d[s][v] > d[s][u] + w) {\n                pq.push(ii(d[s][v] = d[s][u] + w, v));\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n >> m;\n    while(m--) {\n        int u, v, w; cin >> u >> v >> w;\n        g[u].push_back(make_pair(w, v));\n        g[v].push_back(make_pair(w, u));\n    }\n    for (int i = 1; i <= n; ++i) {\n        dijkstra(i);\n        for (int j = 1; j <= n; ++j) {\n            mx = max(mx, d[i][j]);\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) deg[j] = 0, rev[j].clear();\n        for (int j = 1; j <= n; ++j) {\n            for (auto &e : g[j]) if (d[i][j] + e.first == d[i][e.second]) {\n                rev[e.second].push_back(j);\n            }\n        }\n        // solve\n        queue<int> q;\n        for (int j = 1; j <= n; ++j) if (d[i][j] == mx) deg[j] = 1, q.push(j);\n        while(!q.empty()) {\n            int u = q.front(); q.pop();\n            ok[u] = true;\n            for (int &v : rev[u]) {\n                if (!deg[v]) deg[v] = 1, q.push(v);\n            }\n        }\n    }\n\n    int res = 0;\n    for (int i = 1; i <= n; ++i) if (!ok[i]) ++res;\n    printf(\"%d\\n\", res);\n    for (int i = 1; i <= n; ++i) if (!ok[i]) printf(\"%d\\n\", i);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n \nusing namespace std;\nconst int Maxn=1500+100;\nconst int Maxd=1e9;\n \nstruct Weighted_Vertex\n{\n    int u,w;\n \n    bool operator< (Weighted_Vertex other) const\n    {\n        return w>other.w;\n    }\n};\n \nint n,m;\nvector <Weighted_Vertex> adj[Maxn];\n \nint d[Maxn][Maxn];\nvector <int> trace[Maxn][Maxn];\n \nbool in[Maxn],Check[Maxn];\n \nWeighted_Vertex MakeWV(int u, int w)\n{\n    Weighted_Vertex t;\n    t.u=u; t.w=w;\n    return t;\n}\n \nvoid DJK(int s, int d[Maxn], vector <int> trace[Maxn])\n{\n    priority_queue <Weighted_Vertex> q;\n \n    for (int i=1; i<=n; i++) d[i]=Maxd;\n    d[s]=0;\n    q.push(MakeWV(s,0));\n \n    while (!q.empty())\n    {\n        Weighted_Vertex t;\n        t=q.top(); q.pop();\n        if (d[t.u]!=t.w) continue;\n \n        int u=t.u;\n        for (int i=0; i<adj[u].size(); i++)\n        {\n        \tt=adj[u][i];\n            int v=t.u, w=t.w;\n            if (d[v]==d[u]+w) trace[v].push_back(u); else\n            if (d[v]>d[u]+w)\n            {\n                d[v]=d[u]+w;\n                trace[v].clear(); trace[v].push_back(u);\n                q.push(MakeWV(v,d[v]));\n            }\n        }\n    }\n}\n \nvoid DFS(int r, int u)\n{\n    in[u]=true;\n    Check[u]=false;\n \n    for (int i=0; i<trace[r][u].size(); i++)\n    {\n        int v=trace[r][u][i];\n        if (Check[v]) DFS(r,v);\n    }\n}\n \nvoid Solve()\n{\n    int Res=0;\n    for (int i=1; i<=n; i++)\n    for (int j=i+1; j<=n; j++) Res=max(Res,d[i][j]);\n \n    for (int i=1; i<=n; i++)\n    {\n        for (int j=1; j<=n; j++) Check[j]=true;\n        for (int j=i+1; j<=n; j++)\n            if (d[i][j]==Res) DFS(i,j);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1; i<=m; i++)\n    {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        adj[u].push_back(MakeWV(v,w));\n        adj[v].push_back(MakeWV(u,w));\n    }\n \n    for (int i=1; i<=n; i++) DJK(i,d[i],trace[i]);\n    Solve();\n \n    int Res=0;\n    for (int i=1; i<=n; i++)\n        if (!in[i]) Res++;\n \n    printf(\"%d\\n\",Res);\n    for (int i=1; i<=n; i++)\n        if (!in[i]) printf(\"%d\\n\",i);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define Link \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0351\"\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n\n#define TASK \"Quiet Town\"\n\nusing namespace std;\n\nvoid OpenFile()\n{\n    freopen(TASK\".INP\",\"r\",stdin);\n    freopen(TASK\".OUT\",\"w\",stdout);\n}\n\nconst int oo = 1e9 + 1;\nconst int maxn = 15e2 + 1;\nint n,r,d[maxn][maxn];\nvector <pair<int,int> > e[maxn];\npriority_queue <pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq;\nvector <int> trade[maxn][maxn];\nbool b[maxn],chose[maxn];\n\nvoid Enter()\n{\n    cin >> n >> r;\n    for (int i=1;i<=r;++i) {\n        int u,v,w;\n        cin >> u >> v >> w;\n        e[u].push_back({w,v});\n        e[v].push_back({w,u});\n    }\n}\n\nvoid Dijkstra(int s)\n{\n    fill(d[s],d[s]+n+1,+oo);\n    d[s][s] = 0;\n    pq.push({0,s});\n    while (!pq.empty()) {\n        int D = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n        if (D != d[s][u])\n            break;\n        for (pair<int,int> p : e[u]) {\n            int w = p.first;\n            int v = p.second;\n            if (d[s][v] > d[s][u] + w) {\n                d[s][v] = d[s][u] + w;\n                pq.push({d[s][v],v});\n                trade[s][v].clear();\n            }\n            if (d[s][v] == d[s][u] + w)\n                trade[s][v].push_back(u);\n        }\n    }\n}\n\nvoid Init()\n{\n    for (int s=1;s<=n;++s)\n        Dijkstra(s);\n}\n\nvoid Find_back(int t, int s)\n{\n    if (b[t])\n        return;\n    b[t] = 1;\n    if (t == s)\n        return;\n    for (int v : trade[s][t])\n        Find_back(v,s);\n}\n\nvoid Print()\n{\n    int cnt = 0;\n    for (int i=1;i<=n;++i)\n        if (!chose[i])\n            ++cnt;\n    cout << cnt << '\\n';\n    for (int i=1;i<=n;++i)\n        if (!chose[i])\n            cout << i << '\\n';\n}\n\nvoid Solve()\n{\n    int mx = -oo;\n    for (int s=1;s<=n;++s)\n        for (int t=s+1;t<=n;++t)\n            mx = max(mx,d[s][t]);\n    for (int s=1;s<=n;++s) {\n        fill(b,b+n+1,0);\n        for (int t=s+1;t<=n;++t)\n            if (mx == d[s][t])\n                Find_back(t,s);\n        for (int i=1;i<=n;++i)\n            chose[i] |= b[i];\n    }\n    Print();\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    //OpenFile();\n\n    Enter();\n    Init();\n    Solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<math.h>\nusing namespace std;\ntypedef long long ll;\n#define int long long\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\n#define fore(i,a) for(auto &i:a)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define eREP(i,n) for(int i=0;i<=n;i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define eFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define rSORT(c) sort((c).rbegin(),(c).rend())\n#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))\n#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))\n#define INF 1000000000\n#define LLINF 9223372036854775807\n#define mod 1000000007\n//vector<vector<int> > dp;\n//vector<vector<vector<int> > > vvvi;\n//dp=vector<vector<int> >(N, vector<int>(M,0));\n//vector<pair<int,int> > v;\n//v.push_back(make_pair(x,y));\n//priority_queue<int,vector<int>, greater<int> > q2;\n\nconst int N = 1505;\nvector<pii> adj[N];\nint n, m, d[N][N], ans, vis[N], f[N], ck[N];\n\nvoid dijkstra(int S) {\n\teFOR(i, 1, n)d[S][i] = INF; d[S][S] = 0;\n\tpriority_queue<pii, vector<pii>, greater<pii> >mp;\n\tmp.push(pii(d[S][S], S));\n\twhile (mp.size()) {\n\t\tpii z = mp.top();\n\t\tmp.pop();\n\t\tint u = z.second, val = z.first;\n\t\tif (val != d[S][u])continue;\n\t\tans = max(ans, val);\n\t\tREP(i, adj[u].size()) {\n\t\t\tint v = adj[u][i].first, cost = adj[u][i].second;\n\t\t\tif (d[S][v] > d[S][u] + cost) {\n\t\t\t\td[S][v] = d[S][u] + cost;\n\t\t\t\tmp.push(pii(d[S][v], v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int u, int root) {\n\tif (vis[u])return;\n\tvis[u] = true;\n\tf[u] = d[root][u];\n\tREP(i, adj[u].size()) {\n\t\tint v = adj[u][i].first, cost = adj[u][i].second;\n\t\tif (d[root][v] == d[root][u] + cost) {\n\t\t\tdfs(v, root);\n\t\t\tf[u] = max(f[u], f[v]);\n\t\t}\n\t}\n\tif (f[u] == ans)ck[u] = 1;\n}\n\nsigned main(){\ncin.tie(0);\nios::sync_with_stdio(false);\n\n\tcin >> n >> m;\n\teFOR(i, 1, m) {\n\t\tint u, v, d;\n\t\tcin >> u >> v >> d;\n\t\tadj[u].push_back(pii(v, d));\n\t\tadj[v].push_back(pii(u, d));\n\t}\n\teFOR(i, 1, n)dijkstra(i);\n\teFOR(i, 1, n) {\n\t\teFOR(j, 1, n)vis[j] = 0;\n\t\tdfs(i, i);\n\t}\n\tint cnt = 0;\n\teFOR(i, 1, n)if (!ck[i])cnt++;\n\tcout << cnt << endl;\n\teFOR(i, 1, n)if (!ck[i])cout << i << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <limits>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct edge {\n\tint to, cost;\n\tedge(int to_, int cost_) : to(to_), cost(cost_) {};\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\ntemplate<class Type>\nstd::vector<Type> shortest_path(std::vector<std::vector<edge> > &G, int s) {\n\tstd::priority_queue<edge> que; que.push(edge(s, 0));\n\tstd::vector<Type> ret(G.size(), std::numeric_limits<Type>::max()); ret[s] = 0;\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tif (ret[e.to] > ret[u.to] + e.cost) {\n\t\t\t\tret[e.to] = ret[u.to] + e.cost;\n\t\t\t\tque.push(edge(e.to, -ret[e.to]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nstd::vector<vector<int> > shortest_path_tree_all(std::vector<std::vector<edge> > &G, int s) {\n\tstd::priority_queue<edge> que; que.push(edge(s, 0));\n\tstd::vector<long long> ret(G.size(), std::numeric_limits<long long>::max()); ret[s] = 0;\n\tvector<vector<int> > res(G.size());\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tif (ret[e.to] > ret[u.to] + e.cost) {\n\t\t\t\tret[e.to] = ret[u.to] + e.cost;\n\t\t\t\tres[e.to].clear();\n\t\t\t\tque.push(edge(e.to, -ret[e.to]));\n\t\t\t}\n\t\t\tif (ret[e.to] == ret[u.to] + e.cost) {\n\t\t\t\tres[e.to].push_back(u.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint n, m, a, b, c;\nint main() {\n\tcin >> n >> m;\n\tvector<vector<edge> > G(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b >> c; a--, b--;\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, c));\n\t}\n\tvector<vector<int> > d(n);\n\tfor (int i = 0; i < n; i++) d[i] = shortest_path<int>(G, i);\n\tint s = 0, t = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (d[i][j] > d[s][t]) s = i, t = j;\n\t\t}\n\t}\n\tvector<vector<int> > f = shortest_path_tree_all(G, s);\n\tqueue<int> que; que.push(t);\n\tvector<bool> vis(n, false); vis[t] = true;\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tfor (int i : f[u]) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tvis[i] = true;\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!vis[i]) cnt++;\n\t}\n\tcout << cnt << endl;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!vis[i]) cout << i + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF 1500001\nint n,r,d[1500][1500],qt[1500];\nvector<P>e[1500];\nint main(void){\n   cin>>n>>r;\n   for(int i=0;i<r;i++){\n       int s,t,c;\n       cin>>s>>t>>c;\n       s--;\n       t--;\n       e[s].push_back(P(t,c));\n       e[t].push_back(P(s,c));\n   }\n   \n   for(int i=0;i<n;i++){\n       for(int j=0;j<n;j++){\n           d[i][j]=INF;\n       }\n   }\n   P mv(0,0);\n   int mc=0;\n    for(int i=0;i<n;i++){\n        priority_queue<P,vector<P>,greater<P> >k;\n        d[i][i]=0;\n        k.push(P(0,i));\n        while(!k.empty()){\n            int v=k.top().second,co=k.top().first;\n            k.pop();\n            if(d[i][v]!=co)continue;\n            for(int j=0;j<e[v].size();j++){\n                if(d[i][e[v][j].first]>d[i][v]+e[v][j].second){\n                    d[i][e[v][j].first]=d[i][v]+e[v][j].second;\n                    k.push(P(d[i][e[v][j].first],e[v][j].first));\n                }\n            }\n        }\n        for(int j=0;j<n;j++){\n            if(mc<d[i][j]){\n                mc=d[i][j];\n                mv=P(i,j);\n            }\n        }\n    }\n    vector<P>si;\n    si.push_back(mv);\n    for(int i=0;i<n;i++){\n        for(int j=i;j<n;j++){\n            if(d[i][j]==mc&&mv!=P(i,j))si.push_back(P(i,j));\n        }\n    }\n    \n    int ans=0;\n    for(int i=0;i<si.size();i++){\n        int s=si[i].first,t=si[i].second;\n        for(int j=0;j<n;j++){\n            if(d[s][j]+d[j][t]==mc&&qt[j]==0){\n                qt[j]=1;\n                ans++;\n            }\n        }\n    }  \n    cout<<n-ans<<endl;\n    for(int i=0;i<n;i++){\n        if(qt[i]==0)cout<<i+1<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  map<int, int> mapp;\n  while(st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    mapp[tp] = 1;\n    if(tp == i) break;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(mapp[e.to]) continue;\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\n#define ff(i,a,b) for (int i=(a);i<=(b);i++)\nusing namespace std;\nconst int N=1501, inf=1e9;\nint n,r,d[N][N],W,maxOf[N];\ntypedef pair<int,int> ii;\nvector <ii> adj[N];\nbool inEiden[N];\nbool visited[N][N];\n\nvoid dijkstra (int s, int d[]) {\n    ff(i,1,n) d[i]=inf;\n    priority_queue<ii, vector<ii>, greater<ii> > pq;\n    d[s]=0; pq.push(ii(d[s],s));\n    while (!pq.empty()) {\n        ii to=pq.top(); pq.pop();\n        int w=to.first, u=to.second;\n        if (w > d[u]) continue;\n        ff(i,0,(int)adj[u].size()-1) {\n            int v=adj[u][i].first, cost=adj[u][i].second;\n            if (d[u]+cost<d[v]) {\n                d[v]=d[u]+cost;\n                pq.push(ii(d[v],v));\n            }\n        }\n    }\n    ff(i,1,n) if (d[i]==inf) d[i]=-inf;\n}\nvoid dfs (int s, int u) {\n    visited[s][u]=1; inEiden[u]=1;\n    ff(i,0,(int)adj[u].size()-1) {\n        int v=adj[u][i].first, c=adj[u][i].second;\n        if (!visited[s][v] && d[s][v]+c==d[s][u])\n            dfs(s,v);\n    }\n}\n\nint main() {/*\n    freopen(\"in.txt\",\"r\",stdin); freopen(\"out.txt\",\"w\",stdout); //*/\n    scanf(\"%d%d\",&n,&r);\n    ff(i,1,r) {\n        int s,t,d; scanf(\"%d%d%d\",&s,&t,&d);\n        adj[s].push_back(ii(t,d)); adj[t].push_back(ii(s,d));\n    }\n    ff(i,1,n) {\n        dijkstra (i, d[i]); maxOf[i]=0; ff(j,1,n) maxOf[i]=max(maxOf[i], d[i][j]);\n        if (maxOf[i] < W) continue;\n        if (maxOf[i] > W) {W=maxOf[i]; fill(inEiden+1, inEiden+n+1, 0);}\n        ff(j,1,n) {\n            if (d[i][j] == W && !visited[i][j])\n                dfs (i, j);\n        }\n    }\n    int ans = 0;\n    ff(i,1,n) if (!inEiden[i]) ans++;\n    printf(\"%d\\n\",ans);\n    ff(i,1,n) if (!inEiden[i]) printf(\"%d\\n\",i);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n// clang-format on\n/* }}} */\n\nstruct Edge {\n  Edge() {}\n  Edge(int a, int b) { to = a; cost = b; }\n  int to, cost;\n};\nint N, R;\nvector<Edge> G[1500];\nbool res[1500];\nint cnt;\n\nvoid dijkstra(int s, vi &d) {\n  minPQ<pii> q;\n  d[s] = 0;\n  q.emplace(0, s);\n\n  while (q.size()) {\n    auto p = q.top(); q.pop();\n    int v = p.Se;\n    if (d[v] < p.Fi) continue;\n    EACH(e, G[v]) {\n      if (d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        q.emplace(d[e.to], e.to);\n      }\n    }\n  }\n}\n\nvoid bfs(int s, vi &d) {\n  queue<pii> q;\n  q.emplace(s, d[s]);\n  bool vis[1500] = {};\n  while (q.size()) {\n    auto p = q.front(); q.pop();\n    if (vis[p.Fi]) continue;\n    if (!res[p.Fi]) cnt++;\n    res[p.Fi] = true;\n    vis[p.Fi] = true;\n    EACH(e, G[p.Fi]) {\n      if (d[e.to] != d[p.Fi] - e.cost) continue;\n      q.emplace(e.to, d[e.to]);\n    }\n  }\n}\n\nsigned main() {\n  cin >> N >> R;\n  vvi d(N, vi(N, INF));\n  REP(i, R) {\n    int s = in() - 1, t = in() - 1, d = in();\n    G[s].eb(t, d);\n    G[t].eb(s, d);\n  }\n  REP(i, N) dijkstra(i, d[i]);\n\n  int ma = 0;\n  REP(i, N) REP(j, N) chmax(ma, d[i][j]);\n\n  REP(i, N) REP(j, N) {\n    if (ma == d[i][j]) {\n      bfs(j, d[i]);\n    }\n  }\n  print(N - cnt);\n  REP(i, N) {\n    if (!res[i]) print(i + 1);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n7 11\n1 2 2\n1 3 1\n2 4 2\n2 5 2\n2 6 1\n3 4 1\n3 5 1\n3 6 1\n4 7 2\n5 7 2\n6 7 1\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define N 1505\n#define bit(x,y) ((x>>y)&1LL)\n\nint n, m;\nvector<vector<pair<int, int> > > a(N);\nint dis[N][N];\n\nbool inqueue[N];\ndeque<int> q;\nint mxans = 0;\nint mx[N];\n\nvoid SPFA(int root) {\n\tdis[root][root] = 0;\n\tq.push_back(root); inqueue[root] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop_front(); inqueue[u] = false;\n\t\tfor (auto v : a[u]) {\n\t\t\tif (dis[root][v.fi] > dis[root][u] + v.se) {\n\t\t\t\tdis[root][v.fi] = dis[root][u] + v.se;\n\t\t\t\tif (!inqueue[v.fi]) {\n\t\t\t\t\tinqueue[v.fi] = true;\n\t\t\t\t\tif (!q.empty() && dis[root][v.fi] < dis[root][q.front()]) {\n\t\t\t\t\t\tq.push_front(v.fi);\n\t\t\t\t\t}\n\t\t\t\t\telse q.push_back(v.fi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) mxans = max(mxans, dis[root][i]);\n}\n\nbool visited[N]; bool mark[N];\nvoid dfs(int u, int root) {\n\tif (visited[u]) return;\n\tvisited[u] = true;\n\tmx[u] = dis[root][u];\n\tfor (auto v : a[u]) {\n\t\tif (dis[root][v.fi] == dis[root][u] + v.se) {\n\t\t\tdfs(v.fi, root); mx[u] = max(mx[u], mx[v.fi]);\n\t\t}\n\t}\n\tif (mx[u] == mxans)\n\t\tmark[u] = 1;\n}\n\nvector<int> order;\nsigned main() {\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#ifdef in1code\n\tfreopen(\"1test.inp\", \"r\", stdin);\n#endif\n\tmemset(dis, 127, sizeof(dis));\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\ta[u].push_back(mp(v, c));\n\t\ta[v].push_back(mp(u, c));\n\t}\n\tfor (int i = 1; i <= n; i++) SPFA(i);\n\tfor (int i = 1; i <= n; i++) {\n\t\tmemset(visited, 0, sizeof(visited)); dfs(i, i);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!mark[i]) order.push_back(i);\n\t}\n\tcout << order.size() << endl;\n\tfor (auto it : order) cout << it << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000007\ntypedef pair<int, int> P;\nvector<P> sg;\nvector<P> edge[1501];\nint leng[1501][1501], f[1501][1501], flg[1501];\nvector<int> fl;\nint main(void){\n\tint n, r;\n\tcin >> n >> r;\n//\tcout << n << endl;\n\tfor(int i = 0; i < r; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tedge[a].push_back(P(b, c)); edge[b].push_back(P(a, c));\n\t}\n\tfill(leng[0], leng[n + 1], INF);\n\tint mx = -1;\n\tfor(int i = 1; i <= n; i++){\n\t\tleng[i][i] = 0;\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tque.push(P(0, i));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint cost = p.first, from = p.second;\n\t\t\tif(leng[i][from] < cost) continue;\n\t\t\tfor(int j = 0; j < edge[from].size(); j++){\n\t\t\t\tint to = edge[from][j].first, cost = edge[from][j].second;\n\t\t\t\tif(leng[i][to] > leng[i][from] + cost){\n\t\t\t\t\tleng[i][to] = leng[i][from] + cost;\n\t\t\t\t\tque.push(P(leng[i][to], to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 1; j <= n; j++) if(leng[i][j] != INF) mx = max(mx, leng[i][j]);\n\t}\n/*\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++) cout << leng[i][j] << ' ';\n\t\tcout << endl;\n\t}*/\n\tfill(f[0], f[n + 1], 1);\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(f[i][j]){\n\t\t\t\tif(leng[i][j] == mx){\n\t\t\t\t\tsg.push_back(P(i, j));\n\t\t\t\t\tf[i][j] = 0; f[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//\tcout << sg.size() << endl;\n\tfill(flg, flg + n + 1, 1);\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++) if(!f[i][j]) flg[i] = 0, flg[j] = 0;\t\t\t\n\t}\n\tfor(int i = 1; i <= n; i++) if(flg[i]) fl.push_back(i);\n//\tcout << \"コアダンブ\" << endl;\n\tfor(int i = 0; i < sg.size(); i++){\n\t\tint start = sg[i].first, goal = sg[i].second;\n\t\tfor(int j = 0; j < fl.size(); j++){\n\t\t\tint via = fl[j];\n\t\t\tif(leng[start][via] + leng[via][goal] == mx) flg[via] = 0;\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor(int i = 1; i <= n; i++) if(flg[i]) cnt++;\n\tcout << cnt << endl;\n\tfor(int i = 1; i <= n; i++) if(flg[i]) cout << i << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF 1500001\nint n,r,d[1500][1500],qt[1500];\nvector<P>e[1500];\nint main(void){\n   cin>>n>>r;\n   for(int i=0;i<r;i++){\n       int s,t,c;\n       cin>>s>>t>>c;\n       s--;\n       t--;\n       e[s].push_back(P(t,c));\n       e[t].push_back(P(s,c));\n   }\n   \n   for(int i=0;i<n;i++){\n       for(int j=0;j<n;j++){\n           d[i][j]=INF;\n       }\n   }\n   P mvi={0,0};\n   int mc=0;\n    for(int i=0;i<n;i++){\n        priority_queue<P,vector<P>,greater<P> >k;\n        d[i][i]=0;\n        k.push(P(0,i));\n        while(!k.empty()){\n            int v=k.top().second,co=k.top().first;\n            k.pop();\n            if(d[i][v]!=co)continue;\n            for(int j=0;j<e[v].size();j++){\n                if(d[i][e[v][j].first]>d[i][v]+e[v][j].second){\n                    d[i][e[v][j].first]=d[i][v]+e[v][j].second;\n                    k.push(P(d[i][e[v][j].first],e[v][j].first));\n                }\n            }\n        }\n        for(int j=0;j<n;j++){\n            if(mc<d[i][j]){\n                mc=d[i][j];\n                mvi=P(i,j);\n            }\n        }\n    }\n    vector<P>si;\n    si.push_back(mvi);\n    for(int i=0;i<n;i++){\n        for(int j=i;j<n;j++){\n            if(d[i][j]==mc&&mvi!=P(i,j))si.push_back(P(i,j));\n        }\n    }\n    \n    int ans=0;\n    for(int i=0;i<si.size();i++){\n        int s=si[i].first,t=si[i].second;\n        for(int j=0;j<n;j++){\n            if(d[s][j]+d[j][t]==mc&&qt[j]==0){\n                qt[j]=1;\n                ans++;\n            }\n        }\n    }  \n    cout<<n-ans<<endl;\n    for(int i=0;i<n;i++){\n        if(qt[i]==0)cout<<i+1<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nstruct edge {\n    int to, cost;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nconstexpr int INF = 1e9;\n\nvector<int> dijkstra(graph& g, int s, vector<vector<int>>& prev) {\n    vector<int> d(g.size(), INF);\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push(make_pair(0, s));\n    while(!que.empty()) {\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v] < p.first) {\n            continue;\n        }\n        for(auto& e : g[v]) {\n            if(d[e.to] >= d[v] + e.cost) {\n                if(d[e.to] > d[v] + e.cost) {\n                    prev[e.to].clear();\n                }\n                prev[e.to].push_back(v);\n                d[e.to] = d[v] + e.cost;\n                que.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d;\n}\n\nvoid dfs(int v, vector<vector<int>> const& prev, set<int>& s) {\n    s.insert(v);\n    for(auto x : prev[v]) {\n        dfs(x, prev, s);\n    }\n}\n\nint main() {\n    int N, R;\n    cin >> N >> R;\n    graph g(N);\n    for(int i=0; i<R; ++i) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        s--; t--;\n        g[s].push_back((edge){t, d});\n        g[t].push_back((edge){s, d});\n    }\n    int ma = 0;\n    set<int> s;\n    for(int i=0; i<N; ++i) {\n        vector<vector<int>> prev(N);\n        vector<int> d = dijkstra(g, i, prev);\n        int max_d = *max_element(d.begin(), d.end());\n        if(ma <= max_d) {\n            if(ma < max_d) {\n                s.clear();\n            }\n            vector<int> max_v;\n            for(int j=0; j<N; ++j) {\n                if(d[j] == max_d) {\n                    max_v.push_back(j);\n                }\n            }\n            for(auto v : max_v) {\n                dfs(v, prev, s);\n            }\n            ma = max_d;\n        }\n    }\n    cout << N - s.size() << endl;\n    for(int i=0; i<N; ++i) {\n        if(s.count(i) == 0) {\n            cout << i + 1 << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\n\nvector<ll> daikus(vector<vector<mp> > &g,int s){\n\tpriority_queue<mp,vector<mp>,greater<mp> > q;\n\tll n = g.size();\n\tvector<bool> used(n,false);\n\tvector<ll> cost(n,(ll)1e10);\n\tq.push(mp(0,s) );\n\twhile(!q.empty()){\n\t\tmp now = q.top();\n\t\tq.pop();\n\t\tll nn = now.second;\n\t\tll c = now.first;\n\t\tif(used[nn] ) continue;\n\t\tused[nn] = true;\n\t\tcost[nn] = c;\n\t\tfor(int i=0;i<g[nn].size();i++){\n\t\t\tll next = g[nn][i].second;\n\t\t\tll nc = g[nn][i].first;\n\t\t\tif(used[next])continue;\n\t\t\tq.push(mp(c+nc,next) );\n\t\t}\n\t}\n\treturn cost;\n}\n\nint main(){\n\tll n,r;\n\tcin>>n>>r;\n\tvector<vector<mp> > g(n);\n\tfor(int i=0;i<r;i++){\n\t\tll a,b,d;\n\t\tcin>>a>>b>>d;\n\t\ta--,b--;\n\t\tg[a].push_back(mp(d,b) );\n\t\tg[b].push_back(mp(d,a) );\n\t}\n\n\tvector<vector<ll> > dis(n);\n\tfor(int i=0;i<n;i++) dis[i] = daikus(g,i);\n\tvector<mp> sai;\n\tll ma = 0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tma = max(ma,dis[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(ma==dis[i][j]){\n\t\t\t\tsai.push_back(mp(i,j) );\n\t\t\t}\n\t\t}\n\t}\n\tvector<bool> used(n,false);\n\tvector<int> ans;\n\tfor(int i=0;i<sai.size();i++){\n\t    \t\tint s = sai[i].first;\n\t\t\tint t = sai[i].second;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t    \tif(used[j])continue;\n\t\t\t\tif(dis[s][t] == dis[s][j] + dis[j][t] ){\n\t\t\t\t\tused[j] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i])ans.push_back(i+1);\n\t}\n\tcout<<ans.size()<<endl;\n\tfor(int i=0;i<ans.size();i++){\n\tcout<<ans[i]<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nconst int LIM = 1.5e3 + 5;\n\nstruct data { int x, d; };\nbool operator < (data a, data b) { return a.d > b.d; }\n\nint n, m, dis[LIM][LIM], max, ans;\nstd::vector<data> edg[LIM];\nbool chk[LIM], vis[LIM];\nstd::priority_queue<data> q;\n\nvoid dijkstra(int s, int *dis)\n{\n\tq.push({s, 0});\n\twhile (!q.empty())\n\t{\n\t\tdata x = q.top(); q.pop();\n\t\tif (!vis[x.x])\n\t\t{\n\t\t\tvis[x.x] = true;\n\t\t\tdis[x.x] = x.d;\n\t\t\tfor (data y : edg[x.x])\n\t\t\t\tif (!vis[y.x])\n\t\t\t\t\tq.push({y.x, x.d + y.d});\n\t\t}\n\t}\n}\n\nvoid trace(int x, int *dis)\n{\n\tif (!chk[x]) { --ans; chk[x] = true; }\n\tfor (data y : edg[x])\n\t\tif (!vis[y.x] && dis[y.x] == dis[x] - y.d)\n\t\t\ttrace(y.x, dis);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\twhile (m--)\n\t{\n\t\tint u, v, d; scanf(\"%d%d%d\", &u, &v, &d);\n\t\tedg[u].push_back({v, d});\n\t\tedg[v].push_back({u, d});\n\t}\n\t\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tmemset(vis, 0x00, sizeof(vis));\n\t\tdijkstra(i, dis[i]);\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tmax = std::max(max, dis[i][j]);\n\t}\n\t\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tmemset(vis, 0x00, sizeof(vis));\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (dis[i][j] == max)\n\t\t\t\ttrace(j, dis[i]);\n\t}\n\t\n\tprintf(\"%d\\n\", ans + n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!chk[i]) printf(\"%d\\n\", i);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, m; cin >> n >> m;\n\tvector<bool> use(n);\n\tvector<vector<pi>> e(n);\n\trep(i, m){\n\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\te[a].emplace_back(b, c);\n\t\te[b].emplace_back(a, c);\n\t}\n\tauto dij = [&](const vi &s){\n\t\tvi dist(n, inf);\n\t\tpriority_queue<pi> q;\n\t\tfor(int i : s) q.emplace(0, i);\n\t\twhile(!q.empty()){\n\t\t\tint c, co; tie(co, c) = q.top(); q.pop();\n\t\t\tif(dist[c] < -co) continue;\n\t\t\tdist[c] = -co;\n\t\t\tfor(pi p : e[c]){\n\t\t\t\tint to = p.first;\n\t\t\t\tif(dist[to] > -co + p.second){\n\t\t\t\t\tdist[to] = -co + p.second;\n\t\t\t\t\tq.emplace(co - p.second, to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t};\n\tint mxd = -1, ans = 0;\n\trep(s, n){\n\t\tvi go = dij(vi(1, s));\n\t\tint mx = *max_element(all(go));\n\t\tif(mx < mxd) continue;\n\t\tif(mx > mxd) use.clear();\n\t\tmxd = mx;\n\t\t\n\t\tvi far;\n\t\trep(i, n) if(go[i] == mx) far.pb(i);\n\t\tvi come = dij(far);\n\t\trep(i, n) if(mx == go[i] + come[i]) use[i] = 1;\n\t}\n\trep(i, n) if(!use[i]) ans++;\n\tcout << ans << endl;\n\trep(i, n) if(!use[i]) cout << i+1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dist[2000];set<int>p[2000];\nvector<pair<int,int>> vec[2000];\nint n,m;\nbool used2[2000];\nvector<int>R[2000][2000];\nint dst[2000][2000];\nvector<int>shor[2000];\nvoid dijkstra(int s){\n\tfor(int i=0;i<2000;i++){dist[i]=999999999;p[i].clear();}\n\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>Q;\n\tQ.push(make_pair(0,s));dist[s]=0;\n\twhile(!Q.empty()){\n\t\tint a1=Q.top().first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<(int)vec[a2].size();i++){\n\t\t\tint to=vec[a2][i].first,cost=vec[a2][i].second;\n\t\t\tif(dist[to]>a1+cost){\n\t\t\t\tp[to].clear();p[to].insert(a2);\n\t\t\t\tdist[to]=a1+cost;\n\t\t\t\tQ.push(make_pair(dist[to],to));\n\t\t\t}\n\t\t\tif(dist[to]==a1+cost && p[to].count(a2)==0){\n\t\t\t\tp[to].insert(a2);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<2000;i++){\n\t\tdst[s][i]=dist[i];\n\t\tfor(auto a3 : p[i]){\n\t\t\tR[s][i].push_back(a3);\n\t\t}\n\t}\n}\nvoid solve(int s){\n\tqueue<int>Q;\n\tbool used[2000];for(int i=0;i<2000;i++)used[i]=false;\n\tfor(int i=0;i<(int)shor[s].size();i++){Q.push(shor[s][i]);used[shor[s][i]]=true;}\n\twhile(!Q.empty()){\n\t\tint a1=Q.front();Q.pop();\n\t\t\n\t\tfor(int i=0;i<R[s][a1].size();i++){\n\t\t\tint a2=R[s][a1][i];\n\t\t\tif(used[a2]==false){used[a2]=true;Q.push(a2);}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){if(used[i]==true)used2[i]=true;}\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\tvec[a].push_back(make_pair(b,c));\n\t\tvec[b].push_back(make_pair(a,c));\n\t}\n\tfor(int i=1;i<=n;i++)dijkstra(i);\n\tint maxn=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tmaxn=max(maxn,dst[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(dst[i][j]==maxn)shor[i].push_back(j);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)solve(i);\n\tint num=0;\n\tfor(int i=1;i<=n;i++){if(used2[i]==false)num++;}\n\tcout<<num<<endl;\n\tfor(int i=1;i<=n;i++){if(used2[i]==false)cout<<i<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dist[2000];set<int>p[2000];\nvector<pair<int,int>> vec[2000];\nint n,m;\nbool used2[2000];\nset<int>R[2000][2000];\nint dst[2000][2000];\nvector<int>shor[2000];\nvoid dijkstra(int s){\n\tfor(int i=0;i<2000;i++){dist[i]=999999999;p[i].clear();}\n\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>Q;\n\tQ.push(make_pair(0,s));dist[s]=0;\n\twhile(!Q.empty()){\n\t\tint a1=Q.top().first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<(int)vec[a2].size();i++){\n\t\t\tint to=vec[a2][i].first,cost=vec[a2][i].second;\n\t\t\tif(dist[to]>a1+cost){\n\t\t\t\tp[to].clear();p[to].insert(a2);\n\t\t\t\tdist[to]=a1+cost;\n\t\t\t\tQ.push(make_pair(dist[to],to));\n\t\t\t}\n\t\t\tif(dist[to]==a1+cost && p[to].count(a2)==0){\n\t\t\t\tp[to].insert(a2);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<2000;i++){\n\t\tdst[s][i]=dist[i];\n\t\tR[s][i]=p[i];\n\t}\n}\nvoid solve(int s){\n\tqueue<int>Q;\n\tbool used[2000];for(int i=0;i<2000;i++)used[i]=false;\n\tfor(int i=0;i<(int)shor[s].size();i++){Q.push(shor[s][i]);used[shor[s][i]]=true;}\n\twhile(!Q.empty()){\n\t\tint a1=Q.front();Q.pop();\n\t\t\n\t\tfor(auto a2 : R[s][a1]){\n\t\t\tif(used[a2]==false){used[a2]=true;Q.push(a2);}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){if(used[i]==true)used2[i]=true;}\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\tvec[a].push_back(make_pair(b,c));\n\t\tvec[b].push_back(make_pair(a,c));\n\t}\n\tfor(int i=1;i<=n;i++)dijkstra(i);\n\tint maxn=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tmaxn=max(maxn,dst[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(dst[i][j]==maxn)shor[i].push_back(j);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)solve(i);\n\tint num=0;\n\tfor(int i=1;i<=n;i++){if(used2[i]==false)num++;}\n\tcout<<num<<endl;\n\tfor(int i=1;i<=n;i++){if(used2[i]==false)cout<<i<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nvector< vector<edge> > graph;\nvector< vector<int> > mincost;\n\nvoid dijkstra(int s)\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  mincost[s][s] = 0;\n  while(!que.empty()) {\n    int cost, now;\n    tie(cost, now) = que.top(); que.pop();\n    if(mincost[s][now] < cost) continue;\n    for(edge& e : graph[now]) {\n      if(e.cost + cost < mincost[s][e.to]) {\n\tmincost[s][e.to] = e.cost + cost;\n\tque.push(P(mincost[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, R;\n  cin >> N >> R;\n  graph.resize(N);\n  rep(i, R) {\n    int s, t, d;\n    cin >> s >> t >> d; s--, t--;\n    graph[s].emplace_back(t, d);\n    graph[t].emplace_back(s, d);\n  }\n\n  mincost.resize(N, vector<int>(N, inf));\n  int maxdist = 0;\n  rep(i, N) dijkstra(i);\n  rep(i, N) reps(j, i+1, N) maxdist = max(maxdist, mincost[i][j]);\n\n  vector<P> ep;\n  //vector<int> S, T;\n  rep(i, N) reps(j, i+1, N) {\n    if(mincost[i][j] == maxdist) {\n      ep.emplace_back(i, j);      \n      //S.push_back(i), T.push_back(j);\n    }\n  }\n\n  vector<int> ans;\n  rep(i, N) {\n    bool flag = true;\n    for(auto& p : ep) {\n      //rep(j, S.size()) {\n      int s, t; tie(s, t) = p;\n      if(mincost[s][i] + mincost[i][t] == maxdist) {      \n      //if(mincost[S[j]][i] + mincost[i][T[j]] == maxdist) {\n\tflag = false;\n\t//break;\n      }\n    }\n    if(flag) ans.push_back(i+1);\n  }\n  \n  cout << ans.size() << endl;\n  rep(i, ans.size()) cout << ans[i] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_town,int arg_cost){\n\t\ttown = arg_town;\n\t\tcost = arg_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn cost > arg.cost;\n\t};\n\tint town,cost;\n};\n\nstruct Dist{\n\tDist(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Data{\n\tData(int arg_start,int arg_goal){\n\t\tstart = arg_start;\n\t\tgoal = arg_goal;\n\t}\n\tint start,goal;\n};\n\nint main(){\n\n\tint N,R,s,t,d;\n\tscanf(\"%d %d\",&N,&R);\n\n\tvector<Dist> V[N+1];\n\tint** MIN_COST = new int*[N+1];\n\tfor(int i = 1; i <= N; i++){\n\t\tMIN_COST[i] = new int[N+1];\n\t\tfor(int k = 1; k <= N; k++)MIN_COST[i][k] = BIG_NUM; //??????????????????????????¨??????????????????\n\t}\n\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d %d %d\",&s,&t,&d);\n\t\tV[s].push_back(Dist(t,d));\n\t\tV[t].push_back(Dist(s,d));\n\t}\n\n\tint maximum = -1,min_index;\n\tstack<Data> S;\n\tpriority_queue<Info> Q;\n\n\tfor(int from = 1; from <= N-1;from++){\n\t\tfor(int i = 0; i < V[from].size();i++){\n\t\t\tMIN_COST[from][V[from][i].to] = V[from][i].cost;\n\t\t\tQ.push(Info(V[from][i].to,V[from][i].cost));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().cost > MIN_COST[from][Q.top().town]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tmin_index = Q.top().town;\n\t\t\t\tQ.pop();\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\tif(MIN_COST[from][V[min_index][i].to] > MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\tMIN_COST[from][V[min_index][i].to] = MIN_COST[from][min_index] + V[min_index][i].cost;\n\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[from][V[min_index][i].to]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(i != from && MIN_COST[from][i] != BIG_NUM && MIN_COST[from][i] > maximum){\n\t\t\t\tmaximum = MIN_COST[from][i];\n\t\t\t\twhile(!S.empty())S.pop();\n\t\t\t\tS.push(Data(from,i));\n\t\t\t}else if(i != from && MIN_COST[from][i] != BIG_NUM && MIN_COST[from][i] == maximum){\n\t\t\t\tS.push(Data(from,i));\n\t\t\t}\n\t\t}\n\t}\n\n\tbool* USED = new bool[N+1];\n\tfor(int i = 1; i <= N; i++)USED[i] = false;\n\n\tvector<int> PRE_TOWN[N+1];\n\tqueue<int> WORK;\n\tbool* CHECK = new bool[N+1];\n\tbool FLG;\n\n\tint start,goal;\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 1; k <=N; k++)MIN_COST[i][k] = BIG_NUM;\n\t}\n\n\twhile(!S.empty()){\n\t\tstart = S.top().start;\n\t\tgoal = S.top().goal;\n\t\tS.pop();\n\n\t\tUSED[start] = true;\n\t\tUSED[goal] = true;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tPRE_TOWN[i].clear();\n\t\t\tCHECK[i] = false;\n\t\t}\n\t\tCHECK[start] = true;\n\t\tCHECK[goal] = true;\n\n\t\tfor(int i = 0; i < V[start].size();i++){\n\t\t\tMIN_COST[start][V[start][i].to] = V[start][i].cost;\n\t\t\tQ.push(Info(V[start][i].to,V[start][i].cost));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().cost > MIN_COST[start][Q.top().town]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tmin_index = Q.top().town;\n\t\t\t\tQ.pop();\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\tif(MIN_COST[start][V[min_index][i].to] > MIN_COST[start][min_index] + V[min_index][i].cost){\n\t\t\t\t\tMIN_COST[start][V[min_index][i].to] = MIN_COST[start][min_index] + V[min_index][i].cost;\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].clear();\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[start][V[min_index][i].to]));\n\t\t\t\t}else if(MIN_COST[start][V[min_index][i].to] == MIN_COST[start][min_index] + V[min_index][i].cost){\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tfor(int k = 0; k < PRE_TOWN[V[min_index][i].to].size();k++){\n\t\t\t\t\t\tif(PRE_TOWN[V[min_index][i].to][k] == min_index){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(FLG){\n\t\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[start][V[min_index][i].to]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0 ; i < PRE_TOWN[goal].size(); i++){\n\t\t\tWORK.push(PRE_TOWN[goal][i]);\n\t\t}\n\n\t\twhile(!WORK.empty()){\n\t\t\tUSED[WORK.front()] = true;\n\t\t\tCHECK[WORK.front()] = true;\n\t\t\tfor(int i = 0; i < PRE_TOWN[WORK.front()].size();i++){\n\t\t\t\tif(CHECK[PRE_TOWN[WORK.front()][i]] == false){\n\t\t\t\t\tWORK.push(PRE_TOWN[WORK.front()][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tWORK.pop();\n\t\t}\n\t}\n\n\tint num = 0;\n\n\tfor(int i = 1; i <= N; i++)if(USED[i] == false)num++;\n\n\tprintf(\"%d\\n\",num);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(USED[i] == false){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t}\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\nconst int inf = 1e9;\n\nstruct Edge {\n  int to, cost;\n  Edge(int to, int cost) : to(to), cost(cost) {}\n  bool operator<(const Edge& rhs) const {\n    if (cost != rhs.cost) return cost > rhs.cost;\n    return to < rhs.to;\n  }\n};\nusing Graph = vector<vector<Edge>>;\n\nint dist[2048];\nvector<int> pre[2048];\nbool used[2048];\nbool vis[2048];\n\nint dfs(int v) {\n  used[v] = vis[v] = true;\n  for (int u : pre[v]) {\n    if (vis[u]) continue;\n    dfs(u);\n  }\n}\n\nint main() {\n  int N, R;\n  cin >> N >> R;\n  Graph G(N);\n  REP(i, R) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    s--;\n    t--;\n    G[s].emplace_back(t, d);\n    G[t].emplace_back(s, d);\n  }\n\n  int diag = 0;\n  REP(s, N) {\n    REP(i, N) {\n      dist[i] = inf;\n      pre[i].clear();\n    }\n    dist[s] = 0;\n    priority_queue<Edge> pq;\n    pq.emplace(s, 0);\n    while (not pq.empty()) {\n      auto e = pq.top();\n      pq.pop();\n      auto v = e.to;\n      if (e.cost > dist[e.to]) continue;\n      for (auto&& ee : G[e.to]) {\n        auto u = ee.to;\n        auto d = e.cost + ee.cost;\n        if (dist[u] < d) continue;\n        if (dist[u] > d) {\n          dist[u] = d;\n          pq.emplace(u, d);\n          pre[u].clear();\n        }\n        pre[u].push_back(v);\n      }\n    }\n    auto maxi = *max_element(dist + s + 1, dist + N);\n    if (diag > maxi) continue;\n    if (diag < maxi) {\n      diag = maxi;\n      memset(used, false, sizeof(used));\n    }\n    FOR(t, s + 1, N) {\n      if (dist[t] != diag) continue;\n      memset(vis, false, sizeof(vis));\n      dfs(t);\n    }\n  }\n  int M = count(used, used + N, false);\n  cout << M << endl;\n  REP(v, N) {\n    if (used[v]) continue;\n    cout << v + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nstruct edge{int to,cost;};\n\nconst int N = 1500;\nconst int INF = 19191919;\nvector<edge> G[N];\n\nint n;\nint d[N][N];\nbool can[N];\n\nvoid dijkstra(int s)\n{\n    d[s][s] = 0;\n    priority_queue<pi,vector<pi>,greater<pi>> pq;\n    pq.push({0,s});\n    while(!pq.empty())\n    {\n        pi now = pq.top();\n        pq.pop();\n        int v = now.se;\n        if(now.fi>d[s][v]) continue;\n        for(const auto &e:G[v])\n        {\n            if(d[s][e.to] > d[s][v]+e.cost)\n            {\n                d[s][e.to] = d[s][v]+e.cost;\n                pq.push({d[s][e.to],e.to});\n            }\n        }\n    }\n}\n\nvoid check(int s, int D)\n{\n    queue<int> que;\n    rep(i,n)if(d[s][i]==D) que.push(i);\n\n    vector<bool> vis(n);\n    while(!que.empty())\n    {\n        int v = que.front();\n        que.pop();\n        vis[v] = true;\n        can[v] = false;\n\n        for(const auto &e:G[v])\n        {\n            if(!vis[e.to] && d[s][e.to]==d[s][v]-e.cost) que.push(e.to);\n        }\n    }\n}\n\nint main()\n{\n    int r;\n    cin >>n >>r;\n    while(r--)\n    {\n        int s,t,w;\n        cin >>s >>t >>w;\n        --s; --t;\n        G[s].pb({t,w});\n        G[t].pb({s,w});\n    }\n\n    fill(d[0],d[N],INF);\n    fill(can,can+N,true);\n    rep(i,n) dijkstra(i);\n\n    int max_d = 0;\n    rep(i,n)rep(j,n) max_d = max(max_d,d[i][j]);\n\n    rep(i,n) check(i,max_d);\n\n    vector<int> ans;\n    rep(i,n)if(can[i]) ans.pb(i);\n\n    cout << ans.size() << endl;\n    for(const int &i:ans) cout << i+1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nconst int N = 1505, INF = 1E9 + 7;\n\nstruct SEdge\n{\n    int v, t;\n};\nstruct SNode\n{\n    int u, v;\n};\nstruct SLine\n{\n    int x, y;\n};\nvector<SEdge> adj[N];\nvector<SLine> cur;\nvector<int> ans;\nint n, m, u, v, t, dist[N][N];\n\ninline bool operator<(const SNode &a, const SNode &b)\n{\n    return a.v > b.v;\n}\npriority_queue<SNode, vector<SNode>, less<SNode>> pq;\n\nvoid Dijkstra(int st)\n{\n    fill(dist[st], dist[st] + N, INF);\n    pq.push((SNode){st, dist[st][st] = 0});\n    while (!pq.empty())\n    {\n        SNode cur = pq.top();\n        pq.pop();\n        for (SEdge v : adj[cur.u])\n            if (dist[st][v.v] > dist[st][cur.u] + v.t)\n                pq.push((SNode){v.v, dist[st][v.v] = dist[st][cur.u] + v.t});\n        while (!pq.empty() && pq.top().v > dist[st][pq.top().u])\n            pq.pop();\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    while (m--)\n    {\n        scanf(\"%d%d%d\", &u, &v, &t);\n        adj[u].push_back((SEdge){v, t});\n        adj[v].push_back((SEdge){u, t});\n    }\n    for (int i = 1; i <= n; i++)\n        Dijkstra(i);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            if (cur.empty() || dist[i][j] == dist[cur.back().x][cur.back().y])\n                cur.push_back((SLine){i, j});\n            else if (dist[i][j] > dist[cur.back().x][cur.back().y])\n            {\n                cur.clear();\n                cur.push_back((SLine){i, j});\n            }\n    for (int i = 1; i <= n; i++)\n    {\n        for (SLine v : cur)\n            if (dist[v.x][i] + dist[i][v.y] == dist[v.x][v.y])\n                goto br;\n        ans.push_back(i);\n    br:\n        continue;\n    }\n    printf(\"%d\\n\", ans.size());\n    for (int v : ans)\n        printf(\"%d\\n\", v);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  while(1) {\n    mp[j] = 1;\n    if(j == i) break;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        j = e.to;\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) fill(d[i], d[i] + n + 1, 1145141919);\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n    rep(j, 1, n + 1) {\n      d[j][i] = d[i][j];\n    }\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  stack<int> st;\n  map<int, int> mapp;\n  st.push(j);\n  while(!st.empty()) {\n    mp[j] = 1;\n    mapp[j] = 1;\n    if(j == i) continue;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(mapp[e.to]) continue;\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <stdlib.h>\n#include <functional>\n#include <string>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#include <nmmintrin.h>\n#include <chrono>\nconst double EPS = 1e-8;\n#define Scan(a) int a;scanf(\"%d\", &a);\n#define ScanS(a) char a[500];scanf(\"%s\", a);\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1LL)\n#define bitset(a,b)      ( a |= (1LL << b))\n#define bitunset(a,b)    (a &= ~(1LL << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#ifdef _MSC_VER\n#define __builtin_popcount _mm_popcnt_u32\n#define __builtin_popcountll _mm_popcnt_u64\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\n\npii Dir[8] = {\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\npii operator+(pii obj, pii obj2) {\n\treturn MP(obj.first + obj2.first, obj.second + obj2.second);\n}\npii operator-(pii obj, pii obj2) {\n\treturn MP(obj.first - obj2.first, obj.second - obj2.second);\n}\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n\tvoid scan(int edcount, bool oindexed, bool w) {\n\t\tREP(i, edcount) {\n\t\t\tint a, b, c = 1;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tif (w)scanf(\"%d\", &c);\n\t\t\tcon(a - oindexed, b - oindexed, c);\n\t\t}\n\t}\n};\nclass BiDGraph : public Graph {//無向\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b, w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\nclass DGraph : public Graph {//有向\npublic:\n\tDGraph(int n) : Graph(n) {}\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tsumcost++;\n\t}\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //ｘの入ってる集合と yの入ってる集合を併合\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //xとyが同じ集合に入っているかどうかを判定\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nint main() {\n\tint n, r;\n\tcin >> n >> r;\n\n\tBiDGraph g(n);\n\tg.scan(r,1,1);\n\n\n\n\tvector<vector<int>> dis(n,vector<int>(n, -1));\n\n\tREP(cc, n) {\n\t\tvector<bool> al(n);\n\t\tpriority_queue<pii, vector<pii>, greater<pii>> pq;\n\n\t\tpq.push({ 0, cc });\n\n\t\twhile (pq.size()) {\n\t\t\tauto cur = pq.top();\n\t\t\tpq.pop();\n\t\t\tif (al[cur.second]) continue;\n\t\t\tdis[cc][cur.second] = cur.first;\n\t\t\tdis[cur.second][cc] = cur.first;\n\t\t\tal[cur.second] = 1;\n\t\t\tfor (auto itr : g.g[cur.second]) {\n\t\t\t\tif (!al[itr.first]) {\n\t\t\t\t\tpq.push({cur.first + itr.second, itr.first});\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\n\t}\n\n\tvector<bool> used(n);\n\tvector<vector<bool>> al(n,vector<bool>(n));\n\n\tint Max = 0;\n\n\tREP(i,n)\n\t\tREP(j, n) {\n\t\tMax = max(Max, dis[i][j]);\n\t\t}\n\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tif (dis[i][j] == Max) {\n\n\t\t\t\tqueue<int> que;\n\t\t\t\tque.push(i);\n\t\t\t\tused[i] = 1;\n\t\t\t\tused[j] = 1;\n\t\t\t\twhile (que.size()) {\n\t\t\t\t\tint cur = que.front();\n\t\t\t\t\tque.pop();\n\n\t\t\t\t\tif (cur == j || al[cur][j]) continue;\n\t\t\t\t\tal[cur][j] = 1;\n\t\t\t\t\tused[cur] = 1;\n\n\t\t\t\t\tfor (auto itr : g.g[cur]) {\n\t\t\t\t\t\tif (dis[itr.first][j] == dis[cur][j] - itr.second && !al[itr.first][j]) {\n\t\t\t\t\t\t\tque.push(itr.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tint sum = 0;\n\tREP(i, n)\n\t\tsum += 1 - used[i];\n\tcout << sum << endl;\n\tREP(i, n)\n\t\tif (used[i] == 0) {\n\t\t\tprintf(\"%d\\n\", i + 1);\n\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\nint nCity , nRoad ;\n\nvector < pair < int , int > > g[1510] ;\n\nint d[1510][1510] ;\n\nvoid dijistra(int start){\n\td[start][start] = 0 ;\n\tpriority_queue < pair < int  , int > > q ; q.push( make_pair(0 , start) ) ;\n\twhile( !q.empty() ){\n\t\tint du = -q.top().first , u = q.top().second ;\n\t\tq.pop() ;\n\t\tif( d[start][u] != du ) continue ;\n\t\tfor( int i = 0 ; i < (int)g[u].size() ; ++ i ){\n\t\t\tint v = g[u][i].first , w = g[u][i].second ;\n\t\t\tif( d[start][v] > du + w ){\n\t\t\t\td[start][v] = du + w ;\n\t\t\t\tq.push( make_pair( -d[start][v] , v ) ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector < pair < int , int > > MaximumPath ; \n\nbool ok[1510] ;\n\nvector < int > lis ;\n\nint main(){\n\t#define NAME \"QuietTown\"\n\t//freopen( NAME\".inp\" , \"r\" , stdin ) ; freopen( NAME\".out\" , \"w\" , stdout ) ;\n\n\tcin >> nCity >> nRoad ;\n\n\tfor( int i = 1 ; i <= nRoad ; ++ i ){\n\t\tint u , v , w ; cin >> u >> v >> w ;\n\t\tg[u].push_back(make_pair(v , w)) ; g[v].push_back(make_pair(u , w)) ;\n\t}\n\n\tmemset(d , 0x3f , sizeof(d)) ;\n\n\tfor( int i = 1 ; i <= nCity ; ++ i ) dijistra(i) ;\n\n\tint max_element = -(int)2e9 ;\n \n\tfor( int u = 1 ; u <= nCity ; ++ u ){\n\t\tfor( int v = u + 1 ; v <= nCity ; ++ v ){\n\t\t\tmax_element = max( max_element , d[u][v] ) ;\n\t\t}\n\t}\n\tfor( int u = 1 ; u <= nCity ; ++ u ){\n\t\tfor( int v = u + 1 ; v <= nCity ; ++ v ){\n\t\t\tif( d[u][v] == max_element ) MaximumPath.push_back(make_pair(u , v)) , ok[u] = ok[v] = false ;\n\t\t}\n\t}\n\n\tfor( int u = 1 ; u <= nCity ; ++ u ) ok[u] = true ;\n\n\tfor( int u = 1 ; u <= nCity ; ++ u ){\n\t\tif( !ok[u] ) continue ;\n\t\tfor( int i = 0 ; i < (int)MaximumPath.size() ; ++ i ){\n\t\t\tpair < int , int > v = MaximumPath[i] ;\n\t\t\tif( d[u][v.first] + d[u][v.second] == max_element ) {ok[u] = false ; break ;}\n\t\t}\n\t\tif(ok[u]) lis.push_back(u) ;\n\t}\n\n\tcout << (int)lis.size() << endl ;\n\n\tfor( int i = 0 ; i < (int)lis.size() ; ++ i ) cout << lis[i] << endl ;\n\n\treturn 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nvoid solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  map<int, int> mpp;\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    if(tp == i) continue;\n    mpp[tp] = 1;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(mpp[e.to]) continue;\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0351\n\n#include<bits/stdc++.h>\nconst int N = 1505;\nconst int inf = 1e9;\nusing namespace std;\n\ntypedef pair <int, int> ii;\nvector <ii> adj[N];\nint n, m, d[N][N], ans, visit[N], f[N], ck[N];\n\nvoid dijkstra(int S){\n    for (int i = 1; i <= n; i++) d[S][i] = inf; d[S][S] = 0;\n    priority_queue <ii, vector <ii>, greater<ii> > mq; mq.push(ii(d[S][S], S));\n    while (mq.size()){\n        ii z = mq.top(); mq.pop();\n        int u = z.second, val = z.first;\n        if (val != d[S][u]) continue;\n        ans = max(ans, val);\n        for (int i = 0; i < adj[u].size(); i++){\n            int v = adj[u][i].first, cost = adj[u][i].second;\n            if (d[S][v] > d[S][u] + cost){\n                d[S][v] = d[S][u] + cost;\n                mq.push(ii(d[S][v], v));\n            }\n        }\n    }\n}\n\nvoid dfs(int u, int root){\n    if (visit[u]) return;\n    visit[u] = true;\n    f[u] = d[root][u];\n    for (int i = 0; i < adj[u].size(); i++){\n        int v = adj[u][i].first, cost = adj[u][i].second;\n        if (d[root][v] == d[root][u] + cost){\n            dfs(v, root); f[u] = max(f[u], f[v]);\n        }\n    }\n    if (f[u] == ans) ck[u] = 1;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++){\n        int u, v, d; cin >> u >> v >> d;\n        adj[u].push_back(ii(v, d));\n        adj[v].push_back(ii(u, d));\n    }\n    for (int i = 1; i <= n; i++) dijkstra(i);\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++) visit[j] = 0;\n        dfs(i, i);\n    }\n    int cnt = 0; for (int i = 1; i <= n; i++) if (!ck[i]) cnt++;\n    cout << cnt << \"\\n\";\n    for (int i = 1; i <= n; i++) if (!ck[i]) cout << i << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*input\n7 11\n1 2 2\n1 3 1\n2 4 2\n2 5 2\n2 6 1\n3 4 1\n3 5 1\n3 6 1\n4 7 2\n5 7 2\n6 7 1\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define int long long\n#define N 1505\n#define bit(x,y) ((x>>y)&1LL)\n\nint n, m;\nvector<vector<pair<int, int> > > a(N);\nint dis[N][N];\n\nbool inqueue[N];\nqueue<int> q;\nint mx = 0;\n\nvoid SPFA(int root) {\n\tdis[root][root] = 0;\n\tq.push(root); inqueue[root] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop(); inqueue[u] = false;\n\t\tfor (auto v : a[u]) {\n\t\t\tif (dis[root][v.fi] > dis[root][u] + v.se) {\n\t\t\t\tdis[root][v.fi] = dis[root][u] + v.se;\n\t\t\t\tif (!inqueue[v.fi]) {\n\t\t\t\t\tinqueue[v.fi] = true;\n\t\t\t\t\tq.push(v.fi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) mx = max(mx, dis[root][i]);\n}\n\nbool mark[N];\nvector<int> order;\nsigned main() {\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#ifdef in1code\n\tfreopen(\"1test.inp\", \"r\", stdin);\n#endif\n\tmemset(dis, 127, sizeof(dis));\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\ta[u].push_back(mp(v, c));\n\t\ta[v].push_back(mp(u, c));\n\t}\n\tfor (int i = 1; i <= n; i++) SPFA(i);\n\tfor (int u = 1; u <= n; u++) {\n\t\tfor (int v = u; v <= n; v++) {\n\t\t\tif (dis[u][v] != mx) continue;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (dis[u][i] + dis[i][v] == mx) {\n\t\t\t\t\tmark[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!mark[i]) order.push_back(i);\n\t}\n\tcout << order.size() << endl;\n\tfor (auto it : order) cout << it << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  while(1) {\n    mp[j] = 1;\n    if(j == i) break;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        j = e.to;\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  int done[1501][1501] = {};\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(!done[i][j] && mas == d[i][j]) {\n        solve(i, j);\n        done[j][i] = 1;\n      }\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1 ) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n\n#define ff(i,a,b) for (int i=(a);i<=(b);i++)\nusing namespace std;\nconst int N=1501, inf=1e9;\ntypedef pair<int,int> ii;\n\nvector<ii> adj[N];\nint n,r,W;\nint d[N][N], maxFrom[N], trace[N][N];\nbool inEiden[N];\n\nvoid dijkstra (int s, int d[], int trace[]) {\n    ff(i,1,n) d[i]=inf;\n    priority_queue<ii, vector<ii>, greater<ii> > pq;\n    d[s]=0; pq.push(ii(d[s],s)); trace[s]=-1;\n    while (!pq.empty()) {\n        ii to=pq.top(); pq.pop();\n        int w=to.first, u=to.second;\n        if (w > d[u]) continue;\n        ff(i,0,(int)adj[u].size()-1) {\n            int v=adj[u][i].first, cost=adj[u][i].second;\n            if (d[u]+cost<d[v]) {\n                d[v]=d[u]+cost;\n                pq.push(ii(d[v],v));\n                trace[v]=u;\n            }\n        }\n    }\n    ff(i,1,n) if (d[i]==inf) d[i]=-inf;\n}\nvoid Trace (int u, int trace[]) {\n    do {\n        if (u==-1) break;\n        inEiden[u] = 1;\n        u = trace[u];\n    } while (1);\n}\nint main() {/*\n    freopen(\"in.txt\",\"r\",stdin); freopen(\"out.txt\",\"w\",stdout); //*/\n    scanf(\"%d%d\",&n,&r);\n    ff(i,1,r) {\n        int s,t,d; scanf(\"%d%d%d\",&s,&t,&d);\n        adj[s].push_back(ii(t,d)); adj[t].push_back(ii(s,d));\n    }\n    ff(i,1,n) {\n        dijkstra (i, d[i], trace[i]);\n        maxFrom[i]=0; ff(j,1,n) maxFrom[i]=max(maxFrom[i], d[i][j]);\n\n        if (maxFrom[i] < W) continue;\n        if (maxFrom[i] > W) {W=maxFrom[i]; fill(inEiden+1, inEiden+n+1, 0);}\n\n        ff(j,1,n) {\n            if (d[i][j]==W) Trace(j, trace[i]);\n        }\n    }\n    int ans=0;\n    ff(i,1,n) if (!inEiden[i]) ans++;\n    printf(\"%d\\n\",ans);\n    ff(i,1,n) if (!inEiden[i]) printf(\"%d\\n\",i);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nvector< vector<edge> > graph;\nvector< vector<int> > mincost;\n\nint dijkstra(int s)\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  mincost[s][s] = 0;\n  while(!que.empty()) {\n    int cost, now;\n    tie(cost, now) = que.top(); que.pop();\n    if(mincost[s][now] < cost) continue;\n    for(edge& e : graph[now]) {\n      if(e.cost + cost < mincost[s][e.to]) {\n\tmincost[s][e.to] = e.cost + cost;\n\tque.push(P(mincost[s][e.to], e.to));\n      }\n    }\n  }\n  return *max_element(all(mincost[s]));\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, R;\n  cin >> N >> R;\n  graph.resize(N);\n  rep(i, R) {\n    int s, t, d;\n    cin >> s >> t >> d; s--, t--;\n    graph[s].emplace_back(t, d);\n    graph[t].emplace_back(s, d);\n  }\n\n  mincost.resize(N, vector<int>(N, inf));\n  int maxdist = 0;\n  rep(i, N) maxdist = max(maxdist, dijkstra(i));\n  //rep(i, N) reps(j, i+1, N) maxdist = max(maxdist, mincost[i][j]);\n\n  vector<P> ep;\n  //vector<int> S, T;\n  rep(i, N) reps(j, i+1, N) {\n    if(mincost[i][j] == maxdist) {\n      ep.emplace_back(i, j);      \n      //S.push_back(i), T.push_back(j);\n    }\n  }\n\n  vector<int> ans;\n  rep(i, N) {\n    bool flag = true;\n    for(auto& p : ep) {\n      //rep(j, S.size()) {\n      int s, t; tie(s, t) = p;\n      if(mincost[s][i] + mincost[i][t] == maxdist) {      \n      //if(mincost[S[j]][i] + mincost[i][T[j]] == maxdist) {\n\tflag = false;\n\t//break;\n      }\n    }\n    if(flag) ans.push_back(i+1);\n  }\n  \n  cout << ans.size() << endl;\n  rep(i, ans.size()) cout << ans[i] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n7 11\n1 2 2\n1 3 1\n2 4 2\n2 5 2\n2 6 1\n3 4 1\n3 5 1\n3 6 1\n4 7 2\n5 7 2\n6 7 1\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define int long long\n#define N 1505\n#define bit(x,y) ((x>>y)&1LL)\n\nint n, m;\nvector<vector<pair<int, int> > > a(N);\nint dis[N][N];\n\nbool inqueue[N];\nqueue<int> q;\nint mxans = 0;\nint mx[N];\n\nvoid SPFA(int root) {\n\tdis[root][root] = 0;\n\tq.push(root); inqueue[root] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop(); inqueue[u] = false;\n\t\tfor (auto v : a[u]) {\n\t\t\tif (dis[root][v.fi] > dis[root][u] + v.se) {\n\t\t\t\tdis[root][v.fi] = dis[root][u] + v.se;\n\t\t\t\tif (!inqueue[v.fi]) {\n\t\t\t\t\tinqueue[v.fi] = true;\n\t\t\t\t\tq.push(v.fi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) mxans = max(mxans, dis[root][i]);\n}\n\nbool visited[N]; bool mark[N];\nvoid dfs(int u, int root) {\n\tif (visited[u]) return;\n\tvisited[u] = true;\n\tmx[u] = dis[root][u];\n\tfor (auto v : a[u]) {\n\t\tif (dis[root][v.fi] == dis[root][u] + v.se) {\n\t\t\tdfs(v.fi, root); mx[u] = max(mx[u], mx[v.fi]);\n\t\t}\n\t}\n\tif (mx[u] == mxans)\n\t\tmark[u] = 1;\n}\n\nvector<int> order;\nsigned main() {\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#ifdef in1code\n\tfreopen(\"1test.inp\", \"r\", stdin);\n#endif\n\tmemset(dis, 127, sizeof(dis));\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\ta[u].push_back(mp(v, c));\n\t\ta[v].push_back(mp(u, c));\n\t}\n\tfor (int i = 1; i <= n; i++) SPFA(i);\n\tfor (int i = 1; i <= n; i++) {\n\t\tmemset(visited, 0, sizeof(visited)); dfs(i, i);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!mark[i]) order.push_back(i);\n\t}\n\tcout << order.size() << endl;\n\tfor (auto it : order) cout << it << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  map<int, int> mapp;\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    mapp[tp] = 1;\n    if(tp == i) continue;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(mapp[e.to]) continue;\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n// clang-format on\n/* }}} */\n\nstruct Edge {\n  Edge() {}\n  Edge(int a, int b) { to = a; cost = b; }\n  int to, cost;\n};\nint N, R;\nvector<Edge> G[1500];\nvi Gprev[1500];\nmap<int, bool> chie;\n\nvoid dijkstra(int s, vi &d) {\n  minPQ<pii> q;\n  d[s] = 0;\n  q.emplace(0, s);\n\n  while (q.size()) {\n    auto p = q.top(); q.pop();\n    int v = p.Se;\n    if (d[v] < p.Fi) continue;\n    EACH(e, G[v]) {\n      if (d[e.to] == d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        Gprev[e.to].eb(v);\n        q.emplace(d[e.to], e.to);\n      } else if (d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        Gprev[e.to] = vi();\n        Gprev[e.to].eb(v);\n        q.emplace(d[e.to], e.to);\n      }\n    }\n  }\n}\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.emplace(s);\n  bool vis[1500] = {};\n  while (q.size()) {\n    int p = q.front(); q.pop();\n    if (vis[p]) continue;\n    chie[p] = true;\n    vis[p] = true;\n    EACH(e, Gprev[p]) {\n      q.emplace(e);\n    }\n  }\n}\n\nsigned main() {\n  cin >> N >> R;\n  vvi d(N, vi(N, INF));\n  REP(i, R) {\n    int s = in() - 1, t = in() - 1, d = in();\n    G[s].eb(t, d);\n    G[t].eb(s, d);\n  }\n  REP(i, N) dijkstra(i, d[i]);\n\n  int ma = 0;\n  REP(i, N) REP(j, N) chmax(ma, d[i][j]);\n\n  REP(i, N) REP(j, N) {\n    if (ma == d[i][j]) {\n      bfs(j);\n    }\n  }\n\n  print(N - chie.size());\n  REP(i, N) {\n    if (!chie[i]) print(i + 1);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b)    for (int i = a; i <= (int) b; ++i)\n#define ii              pair <int, int>\nusing namespace std;\nconst int N = 1503;\nint n, m;\nvector <ii> adj[N];\n\nvoid init() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n}\n\npriority_queue <ii, vector <ii>, greater <ii> > Q;\nint d[N][N], Max;\nvoid dijk(int st) {\n    d[st][st] = 0; Q.push({ 0, st });\n    while (Q.size()) {\n        int u = Q.top().second, du = Q.top().first;\n        Q.pop();\n        if (du != d[st][u]) continue;\n        Max = max(Max, du);\n        for (ii it : adj[u]) {\n            int v = it.second, w = it.first;\n            if (d[st][v] > du + w) d[st][v] = du + w, Q.push({ d[st][v], v });\n        }\n    }\n}\n\nqueue <int> dm;\nint vis[N];\nvoid trace(int st) {\n    FOR(i, 1, n) if (d[st][i] == Max) dm.push(i), vis[i] = st;\n    while (dm.size()) {\n        int u = dm.front(); dm.pop();\n        for (ii it : adj[u]) {\n            int v = it.second, w = it.first;\n            if (d[st][u] == d[st][v] + w && vis[v] < st) vis[v] = st, dm.push(v);\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n >> m;\n    FOR(i, 1, m) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        adj[u].push_back({ w, v }), adj[v].push_back({ w, u });\n    }\n\n    memset(d, 0x3f, sizeof d);\n    FOR(i, 1, n) dijk(i);\n\n    FOR(i, 1, n) trace(i);\n    int dem = 0;\n    FOR(i, 1, n) if (vis[i] == 0) ++dem;\n    cout << dem << '\\n';\n    FOR(i, 1, n) if (vis[i] == 0) cout << i << '\\n';\n}\n\nmain() {\n    init(); solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nint mp[1501];\n\ninline void dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      if(d[s][e.to] > d[s][v] + g[v][i].cost) {\n        d[s][e.to] = d[s][v] + g[v][i].cost;\n        que.push(P(d[s][e.to], g[v][i].to));\n      }\n    }\n  }\n}\n\ninline void solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    rep(k, 0, g[tp].size()) {\n      if(d[i][tp] == d[i][g[tp][k].to] + g[tp][k].cost && g[tp][k].to != i) {\n        st.push(g[tp][k].to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) {\n        mp[i] = 1;\n        solve(i, j);\n      }\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=998244353;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,R,i,j;cin>>n>>R;\n\tstatic int dist[1500][1500];\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){dist[i][j]=mod;}\n\t\tdist[i][i]=0;\n\t}\n\tvector<vector<pair<int,int>>>go(n);\n\tfor(i=0;i<R;i++){\n\t\tint s,t,d;cin>>s>>t>>d;\n\t\ts--;t--;\n\t\tgo[s].pub(mp(t,d));\n\t\tgo[t].pub(mp(s,d));\n\t}\n\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>que;\n\tfor(int sta=0;sta<n;sta++){\n\t\tque.push(mp(0,sta));\n\t\twhile(que.size()){\n\t\t\tint now=que.top().fir;\n\t\t\tint town=que.top().sec;\n\t\t\tque.pop();\n\t\t\tif(dist[sta][town]<now){continue;}\n\t\t\tfor(auto it:go[town]){\n\t\t\t\tif(mineq(dist[sta][it.fir],now+it.sec)){que.push(mp(now+it.sec,it.fir));}\n\t\t\t}\n\t\t}\n\t}\n\tstatic bool ans[1500]={0};\n\tint longest=0;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\t//cerr<<dist[i][j]<<\" \";\n\t\t\tmaxeq(longest,dist[i][j]);}\n\t\t//cerr<<endl;\n\t}\n\tfor(int sta=0;sta<n;sta++){\n\t\t//自分からの距離が遠い順にdp\n\t\tvector<pair<int,int>>toi(n);\n\t\tfor(i=0;i<n;i++){toi[i]=mp(dist[sta][i],i);}\n\t\tSO(toi);REV(toi);\n\t\tif(toi[0].fir<longest){continue;}//ないです\n\t\tvector<int>dp(n,mod);\n\t\tfor(i=0;i<n;i++){\n\t\t\tint town=toi[i].sec;\n\t\t\tif(dist[sta][town]==longest){dp[town]=0;}\n\t\t\tfor(auto it:go[town]){mineq(dp[town],dp[it.fir]+it.sec);}\n\t\t\tif(dp[town]+dist[sta][town]==longest){ans[town]=1;}\n\t\t}\n\t\t//for(i=0;i<n;i++){cerr<<dp[i]<<\" \";}cerr<<endl;\n\t}\n\tint kazu=0;\n\t\tfor(i=0;i<n;i++){if(!ans[i]){kazu++;}}\n\tcout<<kazu<<endl;\n\tfor(i=0;i<n;i++){\n\t\tif(!ans[i]){cout<<i+1<<endl;}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, M;\nvector<P> G[1500];\nint D[1500][1500];\nvoid dijkstra(int s) {\n  int *dist = D[s];\n  priority_queue<P, vector<P>, greater<P> > q;\n  dist[s] = 0;\n  q.push(P(0, s));\n  while (!q.empty()) {\n    int x = q.top()._2,\n        r = q.top()._1;\n    q.pop();\n    if (dist[x] < r) continue;\n\n    for (P p : G[x]) {\n      int t = p._1, l = p._2;\n      if (dist[t] > r+l) {\n        dist[t] = r+l;\n        q.push(P(r+l, t));\n      }\n    }\n  }\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M;\n  rep(i, M) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    s--, t--;\n    G[s].pb(P(t, d));\n    G[t].pb(P(s, d));\n  }\n  rep(i, N) rep(j, N) D[i][j] = INF;\n  rep(i, N) dijkstra(i);\n  int R = 0;\n  rep(i, N) rep(j, N) R = max(R, D[i][j]);\n\n  vector<int> ans;\n  rep(i, N) {\n    vector<int> rs;\n    map<int, vector<int > > vs;\n    rep(j, N) rs.pb(D[i][j]), vs[D[i][j]].pb(j);\n    sort(all(rs));\n    //for (int x:rs)cout<<x<<\",\";cout<<\" i=\"<<i<<\"\\n\";\n    bool ok = true;\n    for (int x : rs) {\n      if (binary_search(all(rs), R-x)) {\n        for (int s : vs[x]) {\n          for (int t : vs[R-x]) {\n            if (D[s][t] == R) {\n              ok = false;\n              break;\n            }\n          }\n        }\n      }\n    }\n    if (ok) ans.pb(i);\n  }\n  cout << ans.size() << \"\\n\";\n  for (int x : ans) cout << x+1 << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n7 11\n1 2 2\n1 3 1\n2 4 2\n2 5 2\n2 6 1\n3 4 1\n3 5 1\n3 6 1\n4 7 2\n5 7 2\n6 7 1\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define int long long\n#define N 1505\n#define bit(x,y) ((x>>y)&1LL)\n\nint n, m;\nvector<vector<pair<int, int> > > a(N);\nint dis[N][N];\n\nbool inqueue[N];\nqueue<int> q;\nint mx = 0;\n\nvoid SPFA(int root) {\n\tdis[root][root] = 0;\n\tq.push(root); inqueue[root] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop(); inqueue[u] = false;\n\t\tfor (auto v : a[u]) {\n\t\t\tif (dis[root][v.fi] > dis[root][u] + v.se) {\n\t\t\t\tdis[root][v.fi] = dis[root][u] + v.se;\n\t\t\t\tif (!inqueue[v.fi]) {\n\t\t\t\t\tinqueue[v.fi] = true;\n\t\t\t\t\tq.push(v.fi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) mx = max(mx, dis[root][i]);\n}\n\nbool mark[N];\nvector<int> order;\nsigned main() {\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#ifdef in1code\n\tfreopen(\"1test.inp\", \"r\", stdin);\n#endif\n\tmemset(dis, 127, sizeof(dis));\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\ta[u].push_back(mp(v, c));\n\t\ta[v].push_back(mp(u, c));\n\t}\n\tfor (int i = 1; i <= n; i++) SPFA(i);\n\tfor (int u = 1; u <= n; u++) {\n\t\tfor (int v = u; v <= n; v++) {\n\t\t\tif (dis[u][v] != mx) continue;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (dis[u][i] + dis[i][v] == mx) {\n\t\t\t\t\tmark[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!mark[i]) order.push_back(i);\n\t}\n\tcout << order.size() << endl;\n\tfor (auto it : order) cout << it << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1501\nusing namespace std;\nstruct pt { int u,k; };\npt h[N];\nvector <int> a[N],c[N],vec;\nconst int oo=round(1e9);\nint u,v,k,n,m,i,f[N][N],d[N],vt[N],nh,ma,dd[N];\nvoid up(int u)\n{\n    while(1)\n    {\n        int p=u/2;\n        if(p==0 || h[p].k<h[u].k) break;\n        swap(vt[h[u].u],vt[h[p].u]);\n        swap(h[u],h[p]);\n        u=p;\n    }\n}\nvoid down(int u)\n{\n    while(1)\n    {\n        int p=u*2;\n        if(p<nh && h[p+1].k<h[p].k) p++;\n        if(p>nh || h[p].k>h[u].k) break;\n        swap(vt[h[u].u],vt[h[p].u]);\n        swap(h[u],h[p]);\n        u=p;\n    }\n}\nvoid push(int u,int k)\n{\n    h[++nh]={ u,k }; vt[u]=nh;\n    up(nh);\n}\nvoid pop()\n{\n    swap(h[1],h[nh--]); vt[h[1].u]=1;\n    down(1);\n}\nvoid dijkstraf(int s)\n{\n    nh=0;\n    for(int u=1;u<=n;u++) { vt[u]=0; f[s][u]=oo; }\n    f[s][s]=0; push(s,0);\n    while(nh>0)\n    {\n        int u=h[1].u; pop();\n        ma=max(ma,f[s][u]);\n        for(int i=0;i<a[u].size();i++)\n        {\n            int v=a[u][i];\n            if(f[s][v]>f[s][u]+c[u][i])\n            {\n                f[s][v]=f[s][u]+c[u][i];\n                if(vt[v]==0) push(v,f[s][v]);\n                else { h[vt[v]].k=f[s][v]; up(vt[v]); }\n            }\n        }\n    }\n}\nvoid dijkstrad(int s)\n{\n    nh=0;\n    for(int u=1;u<=n;u++) { vt[u]=0; d[u]=oo; }\n    for(int u=1;u<=n;u++)\n        if(f[s][u]==ma) { d[u]=0; push(u,0); }\n    while(nh>0)\n    {\n        int u=h[1].u; pop();\n        if(f[s][u]+d[u]==ma) dd[u]=1;\n        for(int i=0;i<a[u].size();i++)\n        {\n            int v=a[u][i];\n            if(d[v]>d[u]+c[u][i])\n            {\n                d[v]=d[u]+c[u][i];\n                if(vt[v]==0) push(v,d[v]);\n                else { h[vt[v]].k=d[v]; up(vt[v]); }\n            }\n        }\n    }\n}\nint main()\n{\n    //freopen(\"ztown.inp\",\"r\",stdin);\n    //freopen(\"Ztown.out\",\"w\",stdout);\n    cin>>n>>m;\n    while(m--)\n    {\n        cin>>u>>v>>k;\n        a[u].push_back(v); a[v].push_back(u);\n        c[u].push_back(k); c[v].push_back(k);\n    }\n    for(u=1;u<=n;u++) dijkstraf(u);\n    for(u=1;u<=n;u++) dijkstrad(u);\n    for(u=1;u<=n;u++)\n        if(dd[u]==0) vec.push_back(u);\n    cout<<vec.size()<<'\\n';\n    for(i=0;i<vec.size();i++) cout<<vec[i]<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nconst int INF = 1 << 29;\n\nint main()\n{\n  int N, R, A[1500], B[1500], D[1500];\n  int cost[1500][1500];\n  bool edge[1500][1500] = {{}};\n  fill_n(*cost, 1500 * 1500, INF);\n  rep(i, 1500) cost[i][i] = 0;\n\n  cin >> N >> R;\n  rep(i, R) {\n    cin >> A[i] >> B[i] >> D[i];\n    --A[i], --B[i];\n    cost[A[i]][B[i]] = D[i];\n    cost[B[i]][A[i]] = D[i];\n  }\n  rep(i, N) rep(j, N) rep(k, N) cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n  int ret = 0;\n  rep(i, N) rep(j, N) ret = max(ret, cost[i][j]);\n\n  int cnt = 0;\n  bool used[1500] = {};\n  rep(i, N) rep(j, N) {\n      if(cost[i][j] == ret) {\n        rep(k, N) if(cost[i][k] + cost[k][j] == ret) used[k] = true;\n      }\n    }\n\n  cout << count(used, used + N, false) << endl;\n  rep(i, N) if(!used[i]) cout << i + 1 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fto(i, x, y) for(int i = (x); i <= (y); ++i)\n#define fdto(i, x, y) for(int i = (x); i >= (y); --i)\n#define ftoa(i, x, y, a) for(int i = (x); i <= (y); i += a)\n#define ftoit(it, var) for (__typeof(var.begin()) it = var.begin(); it != var.end(); ++it)\n\n#define ii pair<int, int>\n#define mp make_pair\n#define FF first\n#define SS second\n\n#define vi vector<int>\n#define vii vector<ii>\n#define ll long long\n#define vll vector<ll>\n\n#define eb emplace_back\n#define ef emplace_front\n#define lb lower_bound\n#define ub upper_bound\n#define sz(a) (int)a.size()\n\n#define oo 1000000007\n#define OO 1000000000000000007LL\n\nusing namespace std;\n\n#define Pro \"tmp\"\n#define maxN 1507\n\nint D[maxN];\nvii adj[maxN];\n\nint f[maxN][maxN];\nint n, m;\n\nbool ans[maxN];\n\nvoid dijkstra(int u) {\n    fto (i, 1, n) D[i] = oo;\n    D[u] = 0;\n\n    set <ii> st;\n    st.insert(mp(0, u));\n\n    while (!st.empty()) {\n        int u = (*st.begin()).SS;\n        st.erase(st.begin());\n\n        fto (i, 0, (int)adj[u].size()-1) {\n            int v = adj[u][i].FF;\n            int w = adj[u][i].SS;\n\n            if (D[v] > D[u]+w) {\n                st.erase(mp(D[v], v));\n                D[v] = D[u]+w;\n                st.insert(mp(D[v], v));\n            }\n        }\n    }\n\n    return;\n}\n\nint main() {\n    #ifndef ONLINE_JUDGE\n        freopen(Pro\".inp\", \"r\", stdin);\n        freopen(Pro\".out\", \"w\", stdout);\n    #endif // ONLINE_JUDGE\n\n    scanf(\"%d%d\", &n, &m);\n    fto (i, 1, m) {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        adj[u].eb(mp(v, w));\n        adj[v].eb(mp(u, w));\n    }\n\n    int maxAns = 0;\n    fto (i, 1, n) {\n        dijkstra(i);\n        fto (j, 1, n) {\n            f[i][j] = D[j];\n            maxAns = max(maxAns, f[i][j]);\n        }\n    }\n\n//    fto (i, 1, n) {\n//        fto (j, 1, n) cout << f[i][j] << \" \";\n//        puts(\"\");\n//    }\n\n    set <int> st;\n    fto (i, 1, n) st.insert(i);\n\n    fto (i, 1, n) {\n        fto (j, i, n) {\n            if (f[i][j] != maxAns) continue;\n            fto (k, 1, n) {\n                if (f[i][k]+f[k][j] == maxAns) ans[k] = 1;\n            }\n        }\n    }\n\n    int num = 0;\n    fto (i, 1, n) num += !ans[i];\n\n    printf(\"%d\\n\", num);\n    fto (i, 1, n) if (!ans[i]) printf(\"%d\\n\", i);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nconst int LIM = 1.5e3 + 5;\n\nstruct edge { int x, d; };\nstruct data { int x, d, p; };\nbool operator < (data a, data b) { return a.d > b.d; }\n\nint n, m, dis[LIM][LIM], pre[LIM][LIM], max, ans;\nstd::vector<edge> edg[LIM];\nbool chk[LIM], vis[LIM];\nstd::priority_queue<data> q;\n\nvoid dijkstra(int s, int *dis, int *pre)\n{\n\tq.push({s, 0, 0});\n\twhile (!q.empty())\n\t{\n\t\tdata x = q.top(); q.pop();\n\t\tif (!vis[x.x])\n\t\t{\n\t\t\tvis[x.x] = true;\n\t\t\tdis[x.x] = x.d;\n\t\t\tpre[x.x] = x.p;\n\t\t\tfor (edge y : edg[x.x])\n\t\t\t\tif (!vis[y.x])\n\t\t\t\t\tq.push({y.x, x.d + y.d, x.x});\n\t\t}\n\t}\n}\n\nvoid trace(int x, int *dis, int *pre)\n{\n\tif (!chk[x]) { --ans; chk[x] = true; }\n\tfor (edge y : edg[x])\n\t\tif (!vis[y.x] && dis[y.x] == dis[x] - y.d)\n\t\t\ttrace(y.x, dis, pre);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\twhile (m--)\n\t{\n\t\tint u, v, d; scanf(\"%d%d%d\", &u, &v, &d);\n\t\tedg[u].push_back({v, d});\n\t\tedg[v].push_back({u, d});\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tmemset(vis, 0x00, sizeof(vis));\n\t\tdijkstra(i, dis[i], pre[i]);\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tmax = std::max(max, dis[i][j]);\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tmemset(vis, 0x00, sizeof(vis));\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (dis[i][j] == max)\n\t\t\t{\n\t\t\t\ttrace(j, dis[i], pre[i]);\n//\t\t\t\tprintf(\"found %d %d\\n\", i, j);\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!chk[i]) printf(\"%d\\n\", i);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int INF = INT_MAX / 4;\n\ntemplate <class T>\nclass EdgeBase\n{\npublic:\n    int to;\n    T cost;\n    EdgeBase(){};\n    EdgeBase(int to0, T cost0){to = to0; cost = cost0;}\n};\ntypedef EdgeBase<int> Edge;\n\ntemplate<class T>\nvoid shortestPath(const vector<vector<EdgeBase<T> > >& edges, int start, vector<T>& dist)\n{\n    dist.assign(edges.size(), INF);\n    dist[start] = 0;\n    priority_queue<pair<T,int>, vector<pair<T,int> >, greater<pair<T,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<T, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            EdgeBase<T> e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\ntemplate <class T>\nvoid shortestPath(const vector<vector<EdgeBase<T> > >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    int n, r;\n    cin >> n >> r;\n    vector<vector<Edge> > edges(n);\n    for(int i=0; i<r; ++i){\n        int s, t, d;\n        cin >> s >> t >> d;\n        -- s;\n        -- t;\n        edges[s].push_back(Edge(t, d));\n        edges[t].push_back(Edge(s, d));\n    }\n\n    vector<vector<int> > dist;\n    shortestPath(edges, dist);\n    int maxDist = 0;\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<n; ++j){\n            if(dist[i][j] < INF)\n                maxDist = max(maxDist, dist[i][j]);\n        }\n    }\n\n    vector<bool> check(n, true);\n    for(int i=0; i<n; ++i){\n        queue<int> q;\n        vector<bool> used(n, false);\n        for(int j=0; j<n; ++j){\n            if(dist[i][j] == maxDist){\n                q.push(j);\n                check[j] = false;\n                used[j] = true;\n            }\n        }\n        while(!q.empty()){\n            int a = q.front();\n            q.pop();\n            for(const Edge& e : edges[a]){\n                if(!used[e.to] && dist[i][e.to] + e.cost == dist[i][a]){\n                    q.push(e.to);\n                    check[e.to] = false;\n                    used[e.to] = true;\n                }\n            }\n        }\n    }\n\n    vector<int> ans;\n    for(int i=0; i<n; ++i){\n        if(check[i])\n            ans.push_back(i+1);\n    }\n    cout << ans.size() << endl;\n    for(int a : ans)\n        cout << a << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 110\n\n/* Dijkstra O(NlogM)*/\n\nstruct Dijkstra{\n\n  typedef int Type;\n\n  int V;\n  vector<vector<pair<int,Type> > > G;\n  vector<int> cost;\n  \n  Dijkstra(int n):\n    V(n),G(n,vector<pair<int,Type> >()){}\n  \n  void add_edge(int u, int v, Type c){\n    G[u].push_back({v,c});\n  }\n  \n  Type solve(int s, int g = -1){\n    cost.assign(V,-1);\n    priority_queue<pair<Type,int> > pq;\n    Type max_cost = 0;\n    \n    pq.push({0,s});\n\n    while(pq.size()){\n      Type now_cost = pq.top().first;\n      int now = pq.top().second;\n      pq.pop();\n\n      if(cost[now] >= 0) continue;\n      \n      cost[now] = -now_cost;\n      max_cost = max(max_cost, -now_cost);\n      \n      if(now == g) return -now_cost;\n      \n      for(int i=0;i<(int)G[now].size();i++){\n        pq.push({now_cost-G[now][i].second, G[now][i].first});\n      }\n    }\n        \n    return max_cost;\n  }\n  \n};\n\n\nint main(){\n  int n,r;\n  int s[SIZE],t[SIZE],d[SIZE];\n  bool ans[SIZE] = {};\n  \n  scanf(\"%d%d\",&n,&r);\n\n  Dijkstra dij(n);\n  \n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",s+i,t+i,d+i);\n    s[i]--; t[i]--;\n    \n    dij.add_edge(t[i],s[i],d[i]);\n    dij.add_edge(s[i],t[i],d[i]);\n  }\n\n  int ans_dis = 0;\n  \n  for(int i=0;i<n;i++){\n    int max_dis = dij.solve(i);\n\n    if(max_dis > ans_dis){\n      for(int j=0;j<n;j++) ans[i] = false;\n      ans_dis = max_dis;\n    }\n\n    if(max_dis < ans_dis) continue;\n    \n    queue<int> que;\n    bool visited[SIZE] = {};\n    \n    for(int j=0;j<n;j++){\n      if(max_dis == dij.cost[j]){\n        que.push(j);\n      }\n    }\n\n    while(que.size()){\n      int p = que.front();\n      que.pop();\n      \n      if(visited[p]) continue;\n      visited[p] = true;\n      ans[p] = true;\n      \n      for(int j=0;j<dij.G[p].size();j++){\n        if(dij.cost[p] - dij.G[p][j].second == dij.cost[dij.G[p][j].first]){\n          que.push(dij.G[p][j].first);\n        }\n      }\n\n    }\n\n\n  }\n\n  int ans_count = 0;\n  for(int i=0;i<n;i++) ans_count += ans[i] == false;\n\n  printf(\"%d\\n\",ans_count);\n  \n  for(int i=0;i<n;i++){\n    if(ans[i] == false){\n      printf(\"%d\\n\",i+1);\n    }\n  }\n  \n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nconst int INF = 1<<30;\n\nint main(){\n    int n, r;\n    cin >> n >> r;\n    vector<pair<int,int>> v[n];\n    for(int i = 0; i < r; i++){\n        int s, t, d;\n        cin >> s >> t >> d;\n        s--, t--;\n        v[s].push_back({t, d});\n        v[t].push_back({s, d});\n    }\n    vector<vector<int>> dp(n, vector<int>(n, INF));\n    for(int i = 0; i < n; i++){\n        priority_queue<pair<int,int>> pq;\n        dp[i][i] = 0;\n        pq.push({-0, i});\n        while(!pq.empty()){\n            pair<int,int> p = pq.top();  pq.pop();\n            int x = p.second;\n            if(dp[i][x] != -p.first)    continue;\n            for(pair<int,int> next : v[x]){\n                int ni = next.first, ncost = dp[i][x]+next.second;\n                if(dp[i][ni] > ncost){\n                    dp[i][ni] = ncost;\n                    pq.push({-ncost, ni});\n                }\n            }\n        }\n    }\n    int mad = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            mad = max(mad, dp[i][j]);\n        }\n    }\n    vector<bool> ng(n, 0);\n    for(int i = 0; i < n; i++){\n        vector<bool> visit(n, 0);\n        queue<int> q;\n        for(int j = i+1; j < n; j++){\n            if(dp[i][j] != mad) continue;\n            q.push(j);\n            visit[j] = true;    ng[j] = true;\n        }\n        while(!q.empty()){\n            int x = q.front();  q.pop();\n            for(pair<int,int> next : v[x]){\n                if(visit[next.first]) continue;\n                if(dp[i][x]-next.second == dp[i][next.first]){\n                    visit[next.first] = true;   ng[next.first] = true;\n                    q.push(next.first);\n                }\n            }\n        }\n    }\n    vector<int> res;\n    for(int i = 0; i < n; i++){\n        if(!ng[i])  res.push_back(i+1);\n    }\n    cout << res.size() << endl;\n    for(int i : res)    cout << i << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nll rec[1600][1600];\nstruct Elem {\n    ll pos, cost;\n    Elem() {}\n    Elem(ll a, ll b) : pos(a), cost(b) {}\n    bool operator<(const Elem &e) const {\n        return cost > e.cost;\n    }\n};\n \nint main() {\n    int N, R; cin >> N >> R;\n    vector< vector< pair<int, int> > > G(N);\n    for(int i=0; i<R; i++) {\n        int u, v, d; cin >> u >> v >> d;\n        u--; v--;\n        G[u].emplace_back(v, d);\n        G[v].emplace_back(u, d);\n    }\n\n    fill(rec[0], rec[N], INF);\n    for(int s=0; s<N; s++) {\n        priority_queue<Elem> que;\n        que.emplace(s, 0);\n        rec[s][s] = 0;\n        while(que.size()) {\n            Elem cur = que.top(); que.pop();\n            if(cur.cost > rec[s][cur.pos]) continue;\n            for(auto e : G[cur.pos]) {\n                int u = cur.pos, v = e.first, c = e.second;\n                if(rec[s][v] > cur.cost + c) {\n                    rec[s][v] = cur.cost + c;\n                    que.emplace(v, rec[s][v]);\n                }\n            }\n        }\n    }\n\n    ll max_cost = -1;\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<N; j++) {\n            max_cost = max(max_cost, rec[i][j]);\n        }\n    }\n\n    vector< pair<int, int> > pairs;\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<N; j++) {\n            if(rec[i][j] != max_cost) continue;\n            pairs.emplace_back(i, j);\n        }\n    }\n\n    // fprintf(stderr, \"pairs size = %zu\\n\", pairs.size());\n    vector<int> used(N);\n    for(int i=0; i<N; i++) {\n        for(auto st : pairs) {\n            int s, t; tie(s, t) = st;\n            if(rec[s][i] + rec[i][t] == max_cost) {\n                used[i] = true;\n                break;\n            }\n        }\n    }\n\n    vector<int> ans;\n    for(int i=0; i<N; i++) if(!used[i]) ans.emplace_back(i);\n    cout << ans.size() << endl;\n    for(auto e : ans) cout << e+1 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fto(i, x, y) for(int i = (x); i <= (y); ++i)\n#define fdto(i, x, y) for(int i = (x); i >= (y); --i)\n#define ftoa(i, x, y, a) for(int i = (x); i <= (y); i += a)\n#define ftoit(it, var) for (__typeof(var.begin()) it = var.begin(); it != var.end(); ++it)\n\n#define ii pair<int, int>\n#define mp make_pair\n#define FF first\n#define SS second\n\n#define vi vector<int>\n#define vii vector<ii>\n#define ll long long\n#define vll vector<ll>\n\n#define eb emplace_back\n#define ef emplace_front\n#define lb lower_bound\n#define ub upper_bound\n#define sz(a) (int)a.size()\n\n#define oo 1000000007\n#define OO 1000000000000000007LL\n\nusing namespace std;\n\n#define Pro \"tmp\"\n#define maxN 1507\n\nint D[maxN];\nvii adj[maxN];\n\nint f[maxN][maxN];\nint n, m;\n\nbool ans[maxN];\n\nvoid dijkstra(int u) {\n    fto (i, 1, n) D[i] = oo;\n    D[u] = 0;\n\n    set <ii> st;\n    st.insert(mp(0, u));\n\n    while (!st.empty()) {\n        int u = (*st.begin()).SS;\n        st.erase(st.begin());\n\n        fto (i, 0, (int)adj[u].size()-1) {\n            int v = adj[u][i].FF;\n            int w = adj[u][i].SS;\n\n            if (D[v] > D[u]+w) {\n                st.erase(mp(D[v], v));\n                D[v] = D[u]+w;\n                st.insert(mp(D[v], v));\n            }\n        }\n    }\n\n    return;\n}\n\nint main() {\n//    #ifndef ONLINE_JUDGE\n//        freopen(Pro\".inp\", \"r\", stdin);\n//        freopen(Pro\".out\", \"w\", stdout);\n//    #endif // ONLINE_JUDGE\n\n    scanf(\"%d%d\", &n, &m);\n    fto (i, 1, m) {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        adj[u].eb(mp(v, w));\n        adj[v].eb(mp(u, w));\n    }\n\n    int maxAns = 0;\n    vii trace;\n\n    fto (i, 1, n) {\n        dijkstra(i);\n        fto (j, 1, n) {\n            f[i][j] = D[j];\n            if (maxAns < f[i][j]) {\n                maxAns = f[i][j];\n                trace.clear();\n                trace.eb(i, j);\n            }\n            else if (maxAns == f[i][j]) trace.eb(i, j);\n        }\n    }\n\n\n    fto (w, 1, n) {\n        fto (i, 0, (int)trace.size()-1) {\n            int u = trace[i].FF;\n            int v = trace[i].SS;\n            if (f[u][w]+f[w][v] == maxAns) {\n                ans[w] = 1;\n                break;\n            }\n        }\n    }\n\n    int num = 0;\n    fto (i, 1, n) num += !ans[i];\n\n    printf(\"%d\\n\", num);\n    fto (i, 1, n) if (!ans[i]) printf(\"%d\\n\", i);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0351\n\n#include<bits/stdc++.h>\nconst int N = 1505;\nconst int inf = 1e9;\nusing namespace std;\n\ntypedef pair <int, int> ii;\nvector <ii> adj[N];\nint n, m, d[N][N], ans, visit[N], f[N], ck[N];\n\nvoid dijkstra(int S){\n    for (int i = 1; i <= n; i++) d[S][i] = inf; d[S][S] = 0;\n    priority_queue <ii, vector <ii>, greater<ii> > mq; mq.push(ii(d[S][S], S));\n    while (mq.size()){\n        ii z = mq.top(); mq.pop();\n        int u = z.second, val = z.first;\n        if (val != d[S][u]) continue;\n        ans = max(ans, val);\n        for (int i = 0; i < adj[u].size(); i++){\n            int v = adj[u][i].first, cost = adj[u][i].second;\n            if (d[S][v] > d[S][u] + cost){\n                d[S][v] = d[S][u] + cost;\n                mq.push(ii(d[S][v], v));\n            }\n        }\n    }\n}\n\nvoid dfs(int u, int root){\n    if (visit[u]) return;\n    visit[u] = true;\n    f[u] = d[root][u];\n    for (int i = 0; i < adj[u].size(); i++){\n        int v = adj[u][i].first, cost = adj[u][i].second;\n        if (d[root][v] == d[root][u] + cost){\n            dfs(v, root); f[u] = max(f[u], f[v]);\n        }\n    }\n    if (f[u] == ans) ck[u] = 1;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++){\n        int u, v, d; cin >> u >> v >> d;\n        adj[u].push_back(ii(v, d));\n        adj[v].push_back(ii(u, d));\n    }\n    for (int i = 1; i <= n; i++) dijkstra(i);\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++) visit[j] = 0;\n        dfs(i, i);\n    }\n    int cnt = 0; for (int i = 1; i <= n; i++) if (!ck[i]) cnt++;\n    cout << cnt << \"\\n\";\n    for (int i = 1; i <= n; i++) if (!ck[i]) cout << i << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  while(1) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    if(tp == i) break;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(a,b) for(int a=0; a<b; ++a)\n\nusing ll=long long;\nusing pi=pair<int,int>;\n\ntemplate<typename T>\nusing vec=vector<T>;\ntemplate<typename T>\nusing mat=vector<vec<T>>;\n\nmat<int> dist;\nmat<pi> gr;\n\nvoid dijkstra(int s){\n\tpriority_queue<pi,vec<pi>,greater<pi>> que;\n\tdist[s][s]=0;\n\tque.emplace(dist[s][s],s);\n\twhile(!que.empty()){\n\t\tint cost,idx;\n\t\ttie(cost,idx)=que.top(); que.pop();\n\t\tif(dist[s][idx]<cost) continue;\n\t\tfor(auto &e:gr[idx]){\n\t\t\tint ncos=cost+e.second;\n\t\t\tif(dist[s][e.first]<=ncos) continue;\n\t\t\tdist[s][e.first]=ncos;\n\t\t\tque.emplace(dist[s][e.first],e.first);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint N,R; cin>>N>>R;\n\tdist.resize(N,vec<int>(N,INT_MAX));\n\tgr.resize(N);\n\trep(i,R){\n\t\tint s,t,d; cin>>s>>t>>d;\n\t\t--s,--t; gr[s].emplace_back(pi(t,d)),gr[t].emplace_back(pi(s,d));\n\t}\n\trep(i,N) dijkstra(i);\n\t\n\tint longest=0;\n\tfor(int i=0; i<N; ++i){\n\t\tfor(int j=i+1; j<N; ++j){\n\t\t\tlongest=max(longest,dist[i][j]);\n\t\t}\n\t}\n\t\n\tvec<bool> unuse(N,true);\n\tvec<pi> course;\n\tfor(int i=0; i<N; ++i){\n\t\tfor(int j=i+1; j<N; ++j){\n\t\t\tif(dist[i][j]==longest){\n\t\t\t\tcourse.emplace_back(i,j);\n\t\t\t\tunuse[i]=unuse[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvec<int> ans;\n\tfor(int i=0; i<N; ++i){\n\t\tif(!unuse[i]) continue;\n\t\tfor(int j=0; j<course.size(); ++j){\n\t\t\tint x=course[j].first,y=course[j].second;\n\t\t\tif(dist[x][i]+dist[i][y]==dist[x][y]){\n\t\t\t\tunuse[i]=false; break;\n\t\t\t}\n\t\t}\n\t\tif(unuse[i]) ans.emplace_back(i+1);\n\t}\n\t\n\tcout<<ans.size()<<endl;\n\tfor(auto &e:ans) cout<<e<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nvoid solve(int i, int j) {\n  stack<int> st;\n  map<int, int> mapp;\n  st.push(j);\n  while(!st.empty()) {\n    mp[j] = 1;\n    mapp[j] = 1;\n    int tp = st.top(); st.pop();\n    if(j == i) continue;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(mapp[e.to]) continue;\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define endl '\\n'\n#define pque priority_queue\n#define pi acos(-1)\n#define int long long\n#define N 1000000\ntypedef pair < int, int > ii;\ntypedef vector < int > vi;\ntypedef pair < int, ii > iii;\nconst int mod = 1000000007;\nint n, m, d[1009][1009], ans, imax;\nbool check[1009];\npque < iii, vector < iii >, greater < iii > > pq;\nvector < ii > v[1009];\nsigned main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor(int i = 1; i <= m; i ++)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tv[a].pb(mp(b, c));\n\t\tv[b].pb(mp(a, c));\n\t}\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\td[i][j] = mod, d[i][i] = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t\tpq.push(mp(0, mp(i, i)));\n\twhile(!pq.empty())\n\t{\n\t\tint c = pq.top().fi;\n\t\tint a = pq.top().se.fi;\n\t\tint b = pq.top().se.se;\n\t\tpq.pop();\n\t\tif(d[a][b] < c)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < v[b].size(); i ++)\n\t\t{\n\t\t\tint e = v[b][i].fi;\n\t\t\tint f = v[b][i].se;\n\t\t\tif(c + f < d[a][e])\n\t\t\t\td[a][e] = c + f, pq.push(mp(d[a][e], mp(a, e)));\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\timax = max(imax, d[i][j]);\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif(d[i][j] == imax)\n\t\t\t\tpq.push(mp(d[i][j], mp(i, j)));\n\twhile(!pq.empty())\n\t{\n\t\tint a = pq.top().se.fi;\n\t\tint b = pq.top().se.se;\n\t\tint c = pq.top().fi;\n\t\tpq.pop();\n\t\tif(!check[b])\n\t\t\tans ++;\n\t\tcheck[b] = true;\n\t\tfor(int i = 0; i < v[b].size(); i ++)\n\t\t{\n\t\t\tint e = v[b][i].fi;\n\t\t\tint f = v[b][i].se;\n\t\t\tif(d[a][e] + f == d[a][b])\n\t\t\t\tpq.push(mp(d[a][e], mp(a, e)));\n\t\t}\n\t}\n\tcout << n - ans << endl;\n\tfor(int i = 1; i <= n; i ++)\n\t\tif(!check[i])\n\t\t\tcout << i << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nvector< vector<edge> > graph;\nvector< vector<int> > mincost;\n\nint dijkstra(int s)\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  mincost[s][s] = 0;\n  while(!que.empty()) {\n    int cost, now;\n    tie(cost, now) = que.top(); que.pop();\n    if(mincost[s][now] < cost) continue;\n    for(edge& e : graph[now]) {\n      if(e.cost + cost < mincost[s][e.to]) {\n\tmincost[s][e.to] = e.cost + cost;\n\tque.push(P(mincost[s][e.to], e.to));\n      }\n    }\n  }\n  return *max_element(all(mincost[s]));\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, R;\n  cin >> N >> R;\n  graph.resize(N);\n  rep(i, R) {\n    int s, t, d;\n    cin >> s >> t >> d; s--, t--;\n    graph[s].emplace_back(t, d);\n    graph[t].emplace_back(s, d);\n  }\n\n  mincost.resize(N, vector<int>(N, inf));\n  int maxdist = 0;\n  rep(i, N) maxdist = max(maxdist, dijkstra(i));\n\n  vector<P> ep;\n  rep(i, N) reps(j, i+1, N) {\n    if(mincost[i][j] == maxdist) {\n      ep.emplace_back(i, j);      \n    }\n  }\n\n  vector<int> ans;\n  rep(i, N) {\n    bool flag = true;\n    for(auto& p : ep) {\n      int s, t; tie(s, t) = p;\n      if(mincost[s][i] + mincost[i][t] == maxdist) {      \n\tflag = false;\n\tbreak;\n      }\n    }\n    if(flag) ans.push_back(i+1);\n  }\n  \n  cout << ans.size() << endl;\n  rep(i, ans.size()) cout << ans[i] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int inf = 1e9 + 9;\n\nstruct edge {\n  int to, cost;\n};\n\nint n, r;\nvector<edge> G[1550];\nvector<int> V[1550];\nvector<int> L;\n\nint d[1550];\nbool f[1550];\n\nvoid path(int u)\n{\n  L.push_back(u);\n  if (d[u] == 0) return;\n  for (int i = 0; i < V[u].size(); i++){\n    path(V[u][i]);\n  }\n}\n\nint main()\n{\n  cin >> n >> r;\n  for (int i = 0; i < r; i++){\n    int s, t, d;\n    cin >> s >> t >> d;\n    s--; t--;\n    edge e;\n    e.to = t; e.cost = d;\n    G[s].push_back(e);\n    e.to = s;\n    G[t].push_back(e);\n  }\n\n  priority_queue<P, vector<P>, greater<P>> q;\n\n  int max_d = 0;\n  for (int i = 0; i < n; i++){\n    q.push(P(0, i));\n    fill(d, d + n, inf);\n    d[i] = 0;\n\n    vector<int> E;\n    int max_c = 0;\n\n    while (!q.empty()){\n      P p = q.top(); q.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (int j = 0; j < G[v].size(); j++){\n        edge e = G[v][j];\n\n        if (d[e.to] == d[v] + e.cost){\n          V[e.to].push_back(v);\n          q.push(P(d[e.to], e.to));\n        }\n        if (d[e.to] > d[v] + e.cost){\n          d[e.to] = d[v] + e.cost;\n          V[e.to].clear();\n          V[e.to].push_back(v);\n          q.push(P(d[e.to], e.to));\n        }\n      }\n    }\n\n    E.clear();\n    for (int j = 0; j < n; j++){\n      if (d[j] == max_c) {\n        E.push_back(j);\n      }\n      if (d[j] > max_c){\n        max_c = d[j];\n        E.clear();\n        E.push_back(j);\n      }\n    }\n\n    if (max_c == max_d){\n      for (int j = 0; j < E.size(); j++){\n        path(E[j]);\n      }\n    }\n    if (max_d < max_c){\n      L.clear();\n      max_d = max_c;\n      for (int j = 0; j < E.size(); j++){\n        path(E[j]);\n      }\n    }\n  }\n\n  sort(L.begin(), L.end());\n  L.erase(unique(L.begin(), L.end()), L.end());\n  for (int i = 0; i < L.size(); i++){\n    f[L[i]] = true;\n  }\n\n  vector<int> p;\n  for (int i = 0; i < n; i++){\n    if (!f[i]) p.push_back(i + 1);\n  }\n\n  cout << p.size() << endl;\n  for (int i = 0; i < p.size(); i++){\n    cout << p[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi \"QUIETTOWN.inp\"\n#define fo \"QUIETTOWN.out\"\n#define vt first\n#define gt second\n#define maxn 1700\n#define maxc 1000000000\n\nusing namespace std;\n\npriority_queue < pair <int,int> > heap;\n\nint w,n,m,d[maxn][maxn],p[maxn][maxn],he[maxn*maxn],ke[maxn*maxn],e[maxn*maxn],ans;\nint l[maxn*maxn],r[maxn*maxn],dg[maxn*maxn],fu[maxn],fv[maxn];\nbool dau[maxn],kt[maxn];\n\nvoid open()\n{\n    w=0;\n//    freopen(fi,\"r\",stdin);\n  //  freopen(fo,\"w\",stdout);\n\n    scanf(\"%d%d\",&n,&m);\n    int x,y,c;\n\n    for (int i=1; i<=m; i++)\n    {\n      scanf(\"%d%d%d\",&x,&y,&c);\n      he[x]++;\n      he[y]++;\n    }\n    for (int i=2; i<=n; i++) he[i]+=he[i-1];\n\n    freopen(fi,\"r\",stdin);\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1; i<=m; i++)\n    {\n      scanf(\"%d%d%d\",&x,&y,&c);\n      ke[he[x]]=y;\n      ke[he[y]]=x;\n      e[he[x]]=c;\n      e[he[y]]=c;\n      --he[x];\n      --he[y];\n    }\n    he[n+1]=m*2;\n}\n\nvoid dijkstra(int s, int t)\n{\n    for (int i=1; i<=n; i++) d[s][i]=maxc;\n    memset(dau,true,sizeof(dau));\n    d[s][s]=0;\n\n    heap.push(make_pair(0,s));\n\n    while (!heap.empty())\n    {\n      int u=heap.top().gt;\n      heap.pop();\n\n      dau[u]=false;\n      for (int iv=he[u]+1; iv<=he[u+1]; iv++)\n      {\n        int v=ke[iv];\n        if ((dau[v]) && (d[s][v]>d[s][u]+e[iv]))\n        {\n          d[s][v]=d[s][u]+e[iv];\n          p[s][v]=u;\n          heap.push(make_pair(-d[s][v],v));\n        }\n      }\n    }\n}\n\nvoid trace(int s, int u)\n{\n    kt[s]=true;\n    while (p[s][u]!=0)\n    {\n      u=p[s][u];\n      kt[u]=true;\n    }\n}\n\nvoid mocxichcuaconbeo()\n{\n    memset(kt,true,sizeof(kt));\n\n    for (int i=0; i<=n; i++)\n    {\n      l[i]=i-1;\n      r[i]=i+1;\n    }\n\n    for (int i=1; i<=w; i++)\n    {\n      int uu=fu[i];\n      int vv=fv[i];\n\n      int k=0;\n      while (k!=n+1)\n      {\n        if (d[uu][k]+d[k][vv]==ans)\n        {\n          kt[k]=false;\n          l[r[i]]=l[i];\n          r[l[i]]=r[i];\n        }\n        k=r[k];\n      }\n    }\n\n}\n\nvoid process()\n{\n    for (int i=1; i<=n; i++)\n    {\n        dijkstra(i,n);\n        for (int j=1; j<=n; j++)\n          if (i!=j) ans=max(ans,d[i][j]);\n    }\n\n    memset(kt,false,sizeof(kt));\n\n    for (int i=1; i<=n; i++)\n      for (int j=1; j<=n; j++)\n      {\n        if (d[i][j]==ans)\n        {\n          fu[++w]=i;\n          fv[w]=j;\n        }\n      }\n\n    mocxichcuaconbeo();\n\n    int kq=0;\n    for (int i=1; i<=n; i++)\n      if (kt[i]==true) dg[++kq]=i;\n\n    printf(\"%d\\n\",kq);\n    for (int i=1; i<=kq; i++) printf(\"%d\\n\",dg[i]);\n}\n\nint main()\n{\n    open();\n    process();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cstring>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge { int dst, w; };\nstruct Data {\n  int cur, w;\n  bool operator < ( const Data &data ) const {\n    if( w != data.w ) return w > data.w;\n    return cur < data.cur;\n  }\n};\n\n#define MAX_V 2000\n\nint V,E;\nvector<Edge> G[MAX_V];\nint mini[MAX_V][MAX_V];\n\nvoid dijkstra(int sp) {\n  rep(i,V) mini[sp][i] = INT_MAX;\n  mini[sp][sp] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){sp,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    int cur = data.cur;\n    rep(i,(int)G[cur].size()) {\n      Edge &e = G[cur][i];\n      if( mini[sp][e.dst] > data.w + e.w ) {\n\tmini[sp][e.dst] = data.w + e.w;\n\tQ.push((Data){e.dst,mini[sp][e.dst]});\n      }\n    }\n  }\n}\n\ntypedef pair<int,int> ii;\nbool used[MAX_V];\nvoid compute() {\n  rep(i,V) dijkstra(i);\n  int maxi = 0;\n  rep(i,V) REP(j,i+1,V) maxi = max(maxi,mini[i][j]);\n  vector<ii> vec;\n  rep(i,V) REP(j,i+1,V) {\n    if( maxi == mini[i][j] ) {\n      vec.push_back(ii(i,j));\n      used[i] = used[j] = true;\n    }\n  }\n  rep(i,V) if( !used[i] ) {\n    rep(j,(int)vec.size()) {\n      int s = vec[j].first, t = vec[j].second;\n      if( mini[s][i] + mini[i][t] == maxi ) {\n\tused[i] = true;\n\tbreak;\n      }\n    }\n  }\n  int answer = 0;\n  rep(i,V) answer += !used[i];\n  cout << answer << endl;\n  rep(i,V) if( !used[i] ) cout << i + 1 << endl;\n\n}\n\nint main() {\n  cin >> V >> E;\n  rep(i,E) {\n    int s,t,d;\n    cin >> s >> t >> d;\n    --s, --t;\n    G[s].push_back((Edge){t,d});\n    G[t].push_back((Edge){s,d});\n  }\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define endl '\\n'\n#define pque priority_queue\n#define pi acos(-1)\n#define int long long\n#define N 1000000\ntypedef pair < int, int > ii;\ntypedef vector < int > vi;\ntypedef pair < int, ii > iii;\nconst int mod = 1000000007;\nint n, m, d[2000][2000], ans, imax;\nbool check[2000];\npque < iii, vector < iii >, greater < iii > > pq;\nvector < ii > v[2000];\nqueue < ii > q;\nsigned main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor(int i = 1; i <= m; i ++)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tv[a].pb(mp(b, c));\n\t\tv[b].pb(mp(a, c));\n\t}\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\td[i][j] = mod, d[i][i] = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t\tpq.push(mp(0, mp(i, i)));\n\twhile(!pq.empty())\n\t{\n\t\tint c = pq.top().fi;\n\t\tint a = pq.top().se.fi;\n\t\tint b = pq.top().se.se;\n\t\tpq.pop();\n\t\tif(d[a][b] < c)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < v[b].size(); i ++)\n\t\t{\n\t\t\tint e = v[b][i].fi;\n\t\t\tint f = v[b][i].se;\n\t\t\tif(c + f < d[a][e])\n\t\t\t\td[a][e] = c + f, pq.push(mp(d[a][e], mp(a, e)));\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\timax = max(imax, d[i][j]);\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif(d[i][j] == imax)\n\t\t\t\tq.push(mp(i, j));\n\twhile(!q.empty())\n\t{\n\t\tint a = q.front().fi;\n\t\tint b = q.front().se;\n\t\tq.pop();\n\t\tif(!check[b])\n\t\t\tans ++;\n\t\tcheck[b] = true;\n\t\tfor(int i = 0; i < v[b].size(); i ++)\n\t\t{\n\t\t\tint e = v[b][i].fi;\n\t\t\tint f = v[b][i].se;\n\t\t\tif(d[a][e] + f == d[a][b])\n\t\t\t\tq.push(mp(a, e));\n\t\t}\n\t}\n\tcout << n - ans << endl;\n\tfor(int i = 1; i <= n; i ++)\n\t\tif(!check[i])\n\t\t\tcout << i << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = a; i < (int)(b); i++)\n#define REP(i, n) FOR(i, 0, n)\nconst int inf = 1e9;\n\ntemplate <typename T = int>\ninline T in() {\n  T x;\n  cin >> x;\n  return x;\n}\ntemplate <typename T, typename U>\ninline bool chmin(T& x, U y) {\n  return y <= x && (x = y, 1);\n}\nstruct Edge {\n  int from, to, cost;\n  Edge(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n  bool operator<(const Edge& rhs) const {\n    if (cost != rhs.cost) return cost > rhs.cost;\n    if (from != rhs.from) return from < rhs.from;\n    return to < rhs.to;\n  }\n};\nusing Graph = vector<vector<Edge>>;\n\nint main() {\n  int N = in(), R = in();\n  Graph g(N);\n  REP(i, R) {\n    int s = in() - 1, t = in() - 1, d = in();\n    g[s].emplace_back(s, t, d);\n    g[t].emplace_back(t, s, d);\n  }\n  vector<vector<int>> mdist(N, vector<int>(N, inf));\n  vector<vector<vector<int>>> mpre(N, vector<vector<int>>(N));\n\n  vector<pair<int, int>> cand;\n  int maxi = -inf;\n  REP(v, N) {\n    auto& dist = mdist[v];\n    auto& pre = mpre[v];\n    dist[v] = 0;\n    priority_queue<Edge> pq;\n    pq.emplace(-1, v, 0);\n    while (not pq.empty()) {\n      auto e = pq.top();\n      pq.pop();\n      if (e.cost > dist[e.to]) continue;\n      pre[e.to].push_back(e.from);\n      if (pre[e.to].size() > 1) continue;\n      for (auto&& ee : g[e.to]) {\n        int nxtc = ee.cost + e.cost;\n        if (chmin(dist[ee.to], nxtc)) { pq.emplace(ee.from, ee.to, nxtc); }\n      }\n    }\n    FOR(u, v + 1, N) {\n      if (dist[u] < maxi) continue;\n      if (dist[u] > maxi) cand.clear();\n      maxi = dist[u];\n      cand.emplace_back(v, u);\n    }\n  }\n  vector<bool> used(N, false);\n  for (auto&& st : cand) {\n    int s = st.first;\n    int t = st.second;\n    auto& pre = mpre[s];\n    vector<bool> vis(N, false);\n    vis[t] = true;\n    queue<int> Q;\n    Q.emplace(t);\n    while (not Q.empty()) {\n      int v = Q.front();\n      Q.pop();\n      for (int u : pre[v]) {\n        if (u < 0) continue;\n        if (vis[u]) continue;\n        vis[u] = true;\n        Q.push(u);\n      }\n    }\n    REP(i, N) used[i] = used[i] || vis[i];\n  }\n  vector<int> ans;\n  REP(i, N) {\n    if (used[i]) continue;\n    ans.push_back(i + 1);\n  }\n  cout << ans.size() << endl;\n  for (int v : ans) {\n    cout << v << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int INF = INT_MAX / 4;\n\ntemplate <class T>\nclass EdgeBase\n{\npublic:\n    int to;\n    T cost;\n    EdgeBase(){};\n    EdgeBase(int to0, T cost0){to = to0; cost = cost0;}\n};\ntypedef EdgeBase<int> Edge;\n\ntemplate<class T>\nvoid shortestPath(const vector<vector<EdgeBase<T> > >& edges, int start, vector<T>& dist)\n{\n    dist.assign(edges.size(), INF);\n    dist[start] = 0;\n    priority_queue<pair<T,int>, vector<pair<T,int> >, greater<pair<T,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<T, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            EdgeBase<T> e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\ntemplate <class T>\nvoid shortestPath(const vector<vector<EdgeBase<T> > >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    int n, r;\n    cin >> n >> r;\n    vector<vector<Edge> > edges(n);\n    for(int i=0; i<r; ++i){\n        int s, t, d;\n        cin >> s >> t >> d;\n        -- s;\n        -- t;\n        edges[s].push_back(Edge(t, d));\n        edges[t].push_back(Edge(s, d));\n    }\n\n    vector<vector<int> > dist;\n    shortestPath(edges, dist);\n    int maxDist = 0;\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<n; ++j){\n            if(dist[i][j] < INF)\n                maxDist = max(maxDist, dist[i][j]);\n        }\n    }\n\n    vector<bool> check(n, true);\n    for(int i=0; i<n; ++i){\n        queue<int> q;\n        for(int j=0; j<n; ++j){\n            if(dist[i][j] == maxDist){\n                q.push(j);\n                check[j] = false;\n            }\n        }\n        while(!q.empty()){\n            int a = q.front();\n            q.pop();\n            for(const Edge& e : edges[a]){\n                if(dist[i][e.to] + e.cost == dist[i][a]){\n                    q.push(e.to);\n                    check[e.to] = false;\n                }\n            }\n        }\n    }\n\n    vector<int> ans;\n    for(int i=0; i<n; ++i){\n        if(check[i])\n            ans.push_back(i+1);\n    }\n    cout << ans.size() << endl;\n    for(int a : ans)\n        cout << a << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b)    for (int i = a; i <= (int) b; ++i)\n#define ii              pair <int, int>\nusing namespace std;\nconst int N = 1503;\nint n, m;\nvector <ii> adj[N];\n\nvoid init() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    //freopen(\"main.inp\",\"r\",stdin);\n    //freopen(\"main.out\",\"w\",stdout);\n}\n\npriority_queue <ii, vector <ii>, greater <ii> > Q;\nint d[N][N], Max;\nvoid dijk(int st) {\n    d[st][st] = 0; Q.push({ 0, st });\n    while (Q.size()) {\n        int u = Q.top().second, du = Q.top().first;\n        Q.pop();\n        if (du != d[st][u]) continue;\n        Max = max(Max, du);\n        for (ii it : adj[u]) {\n            int v = it.second, w = it.first;\n            if (d[st][v] > du + w) d[st][v] = du + w, Q.push({ d[st][v], v });\n        }\n    }\n}\n\nqueue <int> dm;\nint vis[N];\nvoid trace(int st) {\n    FOR(i, 1, n) if (d[st][i] == Max) dm.push(i), vis[i] = st;\n    while (dm.size()) {\n        int u = dm.front(); dm.pop();\n        for (ii it : adj[u]) {\n            int v = it.second, w = it.first;\n            if (d[st][u] == d[st][v] + w && vis[v] < st) vis[v] = st, dm.push(v);\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n >> m;\n    FOR(i, 1, m) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        adj[u].push_back({ w, v }), adj[v].push_back({ w, u });\n    }\n\n    memset(d, 0x3f, sizeof d);\n    FOR(i, 1, n) dijk(i);\n\n    FOR(i, 1, n) trace(i);\n    int dem = 0;\n    FOR(i, 1, n) if (vis[i] == 0) ++dem;\n    cout << dem << '\\n';\n    FOR(i, 1, n) if (vis[i] == 0) cout << i << '\\n';\n}\n\nmain() {\n    init(); solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 3005\n#define INF (1e9)\n\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\n\nint N,R;\nvector<edge> G[MAX_N];\nint t[MAX_N][MAX_N];\nset<int> ans;\nbool visited[MAX_N];\n\nvoid dfs(int pos,int d[MAX_N]){\n  if(visited[pos])return;\n  visited[pos]=true;\n  ans.insert(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    edge e=G[pos][i];\n    if(d[e.to]+e.cost==d[pos])\n      dfs(e.to,d);\n  }\n}\n\nvoid dijkstra(int S,int d[MAX_N]){\n  fill(d,d+N,INF);\n  d[S]=0;\n  priority_queue< P ,vector<P> ,greater<P> > Q;\n  Q.push(P(0,S));\n  while(!Q.empty()){\n    P p=Q.top();Q.pop();\n    int cost=p.first;\n    int pos=p.second;\n    if(cost>d[pos])continue;\n    for(int i=0;i<(int)G[pos].size();i++){\n      edge e=G[pos][i];\n      if(d[e.to]>cost+e.cost){\n        d[e.to]=cost+e.cost;\n        Q.push(P(d[e.to],e.to));\n      }\n    }\n  }\n}\n\nint main(){\n  cin>>N>>R;\n  for(int i=0;i<R;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--,b--;\n    G[a].push_back((edge){b,c});\n    G[b].push_back((edge){a,c});\n  }\n  \n  for(int i=0;i<N;i++)\n    dijkstra(i,t[i]);\n  \n  int maxm=0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      maxm=max(maxm,t[i][j]);\n\n  for(int i=0;i<N;i++){\n    fill(visited,visited+N,false);\n    for(int j=0;j<N;j++)\n      if(t[i][j]==maxm)\n        dfs(j,t[i]);\n  }\n\n  \n  cout<<N-ans.size()<<endl;\n  for(int i=0;i<N;i++)\n    if(ans.count(i)==0)\n      cout<<i+1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  while(1) {\n    mp[j] = 1;\n    if(j == i) break;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        j = e.to;\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) fill(d[i], d[i] + n, 114514);\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n    rep(j, 1, n + 1) {\n      d[j][i] = d[i][j];\n    }\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  int done[1501][1501] = {};\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(!done[i][j] && mas == d[i][j]) {\n        solve(i, j);\n        done[j][i] = 0;\n      }\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1 ) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nvoid solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    if(tp == i) continue;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nconst int Maxn=1500+100;\nconst int Maxd=1e9;\n\nstruct Weighted_Vertex\n{\n    int u,w;\n\n    bool operator< (Weighted_Vertex other) const\n    {\n        return w>other.w;\n    }\n};\n\nint n,m;\nvector <Weighted_Vertex> adj[Maxn];\n\nint d[Maxn][Maxn];\nvector <int> trace[Maxn][Maxn];\n\nbool in[Maxn],Check[Maxn];\n\nWeighted_Vertex MakeWV(int u, int w)\n{\n    Weighted_Vertex t;\n    t.u=u; t.w=w;\n    return t;\n}\n\nvoid DJK(int s, int d[Maxn], vector <int> trace[Maxn])\n{\n    priority_queue <Weighted_Vertex> q;\n\n    for (int i=1; i<=n; i++) d[i]=Maxd;\n    d[s]=0;\n    q.push(MakeWV(s,0));\n\n    while (!q.empty())\n    {\n        Weighted_Vertex t;\n        t=q.top(); q.pop();\n        if (d[t.u]!=t.w) continue;\n\n        int u=t.u;\n        for (t:adj[u])\n        {\n            int v=t.u, w=t.w;\n            if (d[v]==d[u]+w) trace[v].push_back(u); else\n            if (d[v]>d[u]+w)\n            {\n                d[v]=d[u]+w;\n                trace[v].clear(); trace[v].push_back(u);\n                q.push(MakeWV(v,d[v]));\n            }\n        }\n    }\n}\n\nvoid DFS(int r, int u)\n{\n    in[u]=true;\n    Check[u]=false;\n\n    for (int v:trace[r][u])\n        if (Check[v]) DFS(r,v);\n}\n\nvoid Solve()\n{\n    int Res=0;\n    for (int i=1; i<=n; i++)\n    for (int j=i+1; j<=n; j++) Res=max(Res,d[i][j]);\n\n    for (int i=1; i<=n; i++)\n    {\n        for (int j=1; j<=n; j++) Check[j]=true;\n        for (int j=i+1; j<=n; j++)\n            if (d[i][j]==Res) DFS(i,j);\n    }\n}\nint main()\n{\n    //freopen(\"QuietTown.inp\",\"r\",stdin);\n    //freopen(\"QuietTown.out\",\"w\",stdout);\n\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1; i<=m; i++)\n    {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        adj[u].push_back(MakeWV(v,w));\n        adj[v].push_back(MakeWV(u,w));\n    }\n\n    for (int i=1; i<=n; i++) DJK(i,d[i],trace[i]);\n    Solve();\n\n    int Res=0;\n    for (int i=1; i<=n; i++)\n        if (!in[i]) Res++;\n\n    printf(\"%d\\n\",Res);\n    for (int i=1; i<=n; i++)\n        if (!in[i]) printf(\"%d\\n\",i);\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nvector<P>E[1500];\nint d[1500][1500];\nvector<int>pre[1500][1500];\nbool b[1500];\nint main() {\n\tint n, r; scanf(\"%d%d\", &n, &r);\n\trep(i, r) {\n\t\tint s, t, d; scanf(\"%d%d%d\", &s, &t, &d); s--; t--;\n\t\tE[s].push_back(P(d, t));\n\t\tE[t].push_back(P(d, s));\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, n) {\n\t\td[i][i] = 0;\n\t\tque.push(P(0, i));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (p.first != d[i][p.second])continue;\n\t\t\tfor (P v : E[p.second]) {\n\t\t\t\tif (d[i][v.second] == p.first + v.first)\n\t\t\t\t\tpre[i][v.second].push_back(p.second);\n\t\t\t\tif (d[i][v.second] > p.first + v.first) {\n\t\t\t\t\tpre[i][v.second].clear();\n\t\t\t\t\tpre[i][v.second].push_back(p.second);\n\t\t\t\t\td[i][v.second] = p.first + v.first;\n\t\t\t\t\tque.push(P(d[i][v.second], v.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Max = 0;\n\trep(i, n)rep(j, n)Max = max(Max, d[i][j]);\n\trep(i, n)rep(j, n) {\n\t\tif (d[i][j] != Max)continue;\n\t\tqueue<int>que;\n\t\tque.push(j);\n\t\twhile (!que.empty()) {\n\t\t\tint d = que.front(); que.pop();\n\t\t\tb[d] = true;\n\t\t\tfor (int j : pre[i][d])que.push(j);\n\t\t}\n\t}\n\tlist<int>v;\n\trep(i, n) {\n\t\tif (!b[i])v.push_back(i + 1);\n\t}\n\tprintf(\"%d\\n\", v.size());\n\tfor (int i : v)printf(\"%d\\n\", i);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint n;\n\nvector<vector<P>> G(1510);\nvector<vector<int>> dist(1510, vector<int>(1510, 1e9));\nvoid dijkstra(int s){\n    priority_queue<P, vector<P>, greater<P>> que;\n    dist[s][s] = 0;\n    que.emplace(0, s);\n\n    while(!que.empty()){\n        int ccost, cv;\n        tie(ccost, cv) = que.top();\n        que.pop();\n\n        if(dist[s][cv] < ccost) continue;\n\n        for(auto x : G[cv]){\n            int nv, ncost;\n            tie(nv, ncost) = x;\n            \n            if(dist[s][cv] + ncost < dist[s][nv]){\n                dist[s][nv] = dist[s][cv] + ncost;\n                que.emplace(dist[s][nv], nv);\n            }\n        }\n    }\n}\n\nint main(){\n    int r; cin>>n>>r;\n    for(int i=0; i<r; i++){\n        int s, t, d; cin>>s>>t>>d;\n        s--, t--;\n        G[s].emplace_back(t, d);\n        G[t].emplace_back(s, d);\n    }\n\n    for(int i=0; i<n; i++){\n        dijkstra(i);\n    }\n\n    int maxdist = 0;\n    for(int i=0; i<n; i++){\n        for(int j=i+1; j<n; j++){\n            maxdist = max(maxdist, dist[i][j]);\n        }\n    }\n\n    vector<P> sg;\n    for(int i=0; i<n; i++){\n        for(int j=i+1; j<n; j++){\n            if(dist[i][j] != maxdist) continue;\n\n            sg.emplace_back(i, j);\n        }\n    }\n\n    vector<bool> visited(n, false);\n    for(int i=0; i<n; i++){\n        for(auto j:sg){\n            int s, g;\n            tie(s, g) = j;\n            if(dist[s][i] + dist[i][g] == maxdist){\n                visited[i] = true;\n                break;\n            }\n        }\n    }\n\n    vector<int> ans;\n    for(int i=0; i<n; i++){\n        if(!visited[i]){\n            ans.emplace_back(i+1);\n        }\n    }\n\n    cout << ans.size() << endl;\n    for(auto i:ans){\n        cout << i << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, M;\nvector<P> G[1500];\nint D[1500][1500];\nbool used[1500], marked[1500];\n\nvoid dijkstra(int s) {\n  int *dist = D[s];\n  priority_queue<P, vector<P>, greater<P> > q;\n  dist[s] = 0;\n  q.push(P(0, s));\n  while (!q.empty()) {\n    int x = q.top()._2,\n        r = q.top()._1;\n    q.pop();\n    if (dist[x] < r) continue;\n\n    for (P p : G[x]) {\n      int t = p._1, l = p._2;\n      if (dist[t] > r+l) {\n        dist[t] = r+l;\n        q.push(P(r+l, t));\n      }\n    }\n  }\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M;\n  rep(i, M) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    s--, t--;\n    G[s].pb(P(t, d));\n    G[t].pb(P(s, d));\n  }\n  rep(i, N) rep(j, N) D[i][j] = INF;\n  rep(i, N) dijkstra(i);\n  int R = 0;\n  rep(i, N) rep(j, N) R = max(R, D[i][j]);\n\n  rep(s, N) {\n    int *dist = D[s];\n    queue<int> q;\n    rep(i, N) used[i] = false;\n    rep(i, N) {\n      if (dist[i] == R) q.push(i), used[i] = true;\n    }\n    while (!q.empty()) {\n      int x = q.front();\n      q.pop();\n\n      for (P p : G[x]) {\n        int t = p._1, r = p._2;\n        if (dist[t]+r == dist[x]) {\n          if (!used[t]) {\n            used[t] = true;\n            q.push(t);\n          }\n        }\n      }\n    }\n    rep(i, N) marked[i] |= used[i];\n  }\n  vector<int> ans;\n  rep(i, N) if (!marked[i]) ans.pb(i);\n  cout << ans.size() << \"\\n\";\n  for (int x : ans) cout << x+1 << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n7 11\n1 2 2\n1 3 1\n2 4 2\n2 5 2\n2 6 1\n3 4 1\n3 5 1\n3 6 1\n4 7 2\n5 7 2\n6 7 1\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define int long long\n#define N 1505\n#define bit(x,y) ((x>>y)&1LL)\n\nint n, m;\nvector<vector<pair<int, int> > > a(N);\nint dis[N][N];\n\nbool inqueue[N];\ndeque<int> q;\nint mxans = 0;\nint mx[N];\nint suminQueue = 0;\nvoid SPFA(int root) {\n#define f dis[root]\n\tf[root] = 0;\n\tq.push_back(root); inqueue[root] = true;\n\twhile (!q.empty()) {\n\t\twhile (f[q.front()]*q.size() > suminQueue) {\n\t\t\tq.push_back(q.front());\n\t\t\tq.pop_front();\n\t\t}\n\t\tint u = q.front(); q.pop_front(); inqueue[u] = false; suminQueue -= f[u];\n\t\tfor (auto v : a[u]) {\n\t\t\tif (f[v.fi] > f[u] + v.se) {\n\t\t\t\tf[v.fi] = f[u] + v.se;\n\t\t\t\tif (!inqueue[v.fi]) {\n\t\t\t\t\tinqueue[v.fi] = true;\n\t\t\t\t\tif (!q.empty() && f[v.fi] < f[q.front()]) {\n\t\t\t\t\t\tq.push_front(v.fi);\n\t\t\t\t\t}\n\t\t\t\t\telse q.push_back(v.fi);\n\t\t\t\t\tsuminQueue += f[v.fi];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) mxans = max(mxans, dis[root][i]);\n}\n\nbool visited[N]; bool mark[N];\nvoid dfs(int u, int root) {\n\tif (visited[u]) return;\n\tvisited[u] = true;\n\tmx[u] = dis[root][u];\n\tfor (auto v : a[u]) {\n\t\tif (dis[root][v.fi] == dis[root][u] + v.se) {\n\t\t\tdfs(v.fi, root); mx[u] = max(mx[u], mx[v.fi]);\n\t\t}\n\t}\n\tif (mx[u] == mxans)\n\t\tmark[u] = 1;\n}\n\nvector<int> order;\nsigned main() {\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#ifdef in1code\n\tfreopen(\"1test.inp\", \"r\", stdin);\n#endif\n\tmemset(dis, 127, sizeof(dis));\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\ta[u].push_back(mp(v, c));\n\t\ta[v].push_back(mp(u, c));\n\t}\n\tfor (int i = 1; i <= n; i++) SPFA(i);\n\tfor (int i = 1; i <= n; i++) {\n\t\tmemset(visited, 0, sizeof(visited)); dfs(i, i);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!mark[i]) order.push_back(i);\n\t}\n\tcout << order.size() << endl;\n\tfor (auto it : order) cout << it << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1555;\nconst int INF = 1e9;\n\ntypedef pair<int, int> ii;\n\nint n, m;\nint max_dis;\nint dis[N][N];\nbool vis[N], vis2[N];\nvector<ii> G[N];\n\nvoid calc(int r) {\n\tfor (int i = 1; i <= n; ++i) dis[r][i] = INF;\n\tpriority_queue< ii, vector<ii>, greater<ii> > pq;\n\tpq.push(ii(0, r)), dis[r][r] = 0;\n\twhile (pq.size()) {\n\t\tii u = pq.top(); pq.pop();\n\t\tif (u.first != dis[r][u.second]) continue; \n\t\tfor (auto i : G[u.second]) {\n\t\t\tii v = ii(u.first + i.first, i.second);\n\t\t\tif (dis[r][v.second] > v.first) {\n\t\t\t\tdis[r][v.second] = v.first, pq.push(v);\n\t\t\t}\n\t\t}\n\t} \n}\n\nvoid solve(int r) {\n\tqueue<int> qu;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (dis[r][i] == max_dis) {\n\t\t\tvis[i] = 1, qu.push(i);\n\t\t}\n\t\telse vis[i] = 0;\n\t}\n\twhile (qu.size()) {\n\t\tint u = qu.front(); qu.pop(), vis2[u] = 1;\n\t\tfor (auto v : G[u]) {\n\t\t\tif (dis[r][v.second] + v.first == dis[r][u] && !vis[v.second]) {\n\t\t\t\tvis[v.second] = 1, qu.push(v.second);\n\t\t\t} \n\t\t} \n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint u, v, w; cin >> u >> v >> w;\n\t\tG[u].push_back(ii(w, v));\n\t\tG[v].push_back(ii(w, u));\n\t}\n\tfor (int i = 1; i <= n; ++i) calc(i);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) max_dis = max(max_dis, dis[i][j]);\n\t}\n\tfor (int i = 1; i <= n; ++i) solve(i);\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i) if (!vis2[i]) cnt++;\n\tcout << cnt << '\\n';\n\tfor (int i = 1; i <= n; ++i) if (!vis2[i]) cout << i << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n#define let auto const\n\ntemplate<typename... Types>\nstruct dynarr: std::vector<Types...> {\n  using std::vector<Types...>::vector;\n  using size_type = typename std::vector<Types...>::size_type;\n  auto&& operator[](size_type i) { return this->at(i); }\n  auto&& operator[](size_type i) const { return this->at(i); }\n};\n\nstruct edge {\n  i64 s;\n  i64 t;\n  i64 d;\n};\n\nint main() {\n  i64 N, R;\n  cin >> N >> R;\n  vector<vector<edge>> G(N);\n  rep(r,0,R) {\n    i64 s, t, d;\n    cin >> s >> t >> d;\n    s--;\n    t--;\n    G[s].push_back({s, t, d});\n    G[t].push_back({t, s, d});\n  }\n\n  vector<vector<i64>> dist(N, vector<i64>(N, 1e18));\n  rep(i,0,N){\n    using P = pair<i64, i64>;\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({ 0, i });\n    dist[i][i] = 0;\n    while(!que.empty()) {\n      i64 v = que.top().second;\n      i64 d = que.top().first;\n      que.pop();\n\n      if(dist[i][v] > d) continue;\n      for(auto e: G[v]) {\n        if(dist[i][e.t] > d + e.d) {\n          dist[i][e.t] = d + e.d;\n          que.push({ dist[i][e.t], e.t });\n        }\n      }\n    }\n  }\n\n  vector<i64> used(N, 0);\n\n  i64 MAX = 0;\n  rep(i,0,N) MAX = max(MAX, *max_element(all(dist[i])));\n\n  rep(i,0,N) {\n    queue<i64> que;\n    vector<i64> vis(N);\n    rep(j,0,N) {\n      if(dist[i][j] == MAX) {\n        que.push(j);\n        vis[j] = true;\n      }\n    }\n    while(!que.empty()) {\n      i64 v = que.front();\n      que.pop();\n      used[v] = true;\n      for(auto e: G[v]) {\n        if(dist[i][e.t] + e.d == dist[i][e.s] && !vis[e.t]) {\n          que.push(e.t);\n          vis[e.t] = true;\n        }\n      }\n    }\n  }\n  cout << std::count(all(used), false) << endl;\n  rep(i,0,N) {\n    if(!used[i]) {\n      cout << i + 1 << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nconst int Maxn=1500+100;\nconst int Maxd=1e9;\n\nstruct Weighted_Vertex\n{\n    int u,w;\n\n    bool operator< (Weighted_Vertex other) const\n    {\n        return w>other.w;\n    }\n};\n\nint n,m;\nvector <Weighted_Vertex> adj[Maxn];\nint d[Maxn][Maxn];\nvector <int> trace[Maxn][Maxn];\nbool in[Maxn],Check[Maxn];\n\nWeighted_Vertex MakeWV(int u, int w)\n{\n    Weighted_Vertex t;\n    t.u=u; t.w=w;\n    return t;\n}\n\nvoid DJK(int s, int d[Maxn], vector <int> trace[Maxn])\n{\n    priority_queue <Weighted_Vertex> q;\n\n    for (int i=1; i<=n; i++) d[i]=Maxd;\n    d[s]=0;\n    q.push(MakeWV(s,0));\n\n    while (!q.empty())\n    {\n        Weighted_Vertex t;\n        t=q.top(); q.pop();\n        if (d[t.u]!=t.w) continue;\n\n        int u=t.u;\n        for (t:adj[u])\n        {\n            int v=t.u, w=t.w;\n            if (d[v]==d[u]+w) trace[v].push_back(u); else\n            if (d[v]>d[u]+w)\n            {\n                d[v]=d[u]+w;\n                trace[v].clear(); trace[v].push_back(u);\n                q.push(MakeWV(v,d[v]));\n            }\n        }\n    }\n}\n\nvoid DFS(int r, int u)\n{\n    in[u]=true;\n    Check[u]=false;\n\n    for (int v:trace[r][u])\n        if (Check[v]) DFS(r,v);\n}\n\nvoid Solve()\n{\n    int Res=0;\n    for (int i=1; i<=n; i++)\n    for (int j=i+1; j<=n; j++) Res=max(Res,d[i][j]);\n\n    for (int i=1; i<=n; i++)\n    {\n        for (int j=1; j<=n; j++) Check[j]=true;\n        for (int j=i+1; j<=n; j++)\n            if (d[i][j]==Res) DFS(i,j);\n    }\n}\n\nint main()\n{\n    //freopen(\"QuietTown.inp\",\"r\",stdin);\n    //freopen(\"QuietTown.out\",\"w\",stdout);\n\n    cin >> n >> m;\n    for (int i=1; i<=m; i++)\n    {\n        int u,v,w;\n        cin >> u >> v >> w;\n        adj[u].push_back(MakeWV(v,w));\n        adj[v].push_back(MakeWV(u,w));\n    }\n\n    for (int i=1; i<=n; i++) DJK(i,d[i],trace[i]);\n    Solve();\n\n    int Res=0;\n    for (int i=1; i<=n; i++)\n        if (!in[i]) Res++;\n\n    cout << Res << \"\\n\";\n    for (int i=1; i<=n; i++)\n        if (!in[i]) cout << i << \"\\n\";\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nvector< vector<edge> > graph;\nvector< vector<int> > mincost;\n\nvoid dijkstra(int s)\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  mincost[s][s] = 0;\n  while(!que.empty()) {\n    int cost, now;\n    tie(cost, now) = que.top(); que.pop();\n    if(mincost[s][now] < cost) continue;\n    for(edge& e : graph[now]) {\n      if(e.cost + cost < mincost[s][e.to]) {\n\tmincost[s][e.to] = e.cost + cost;\n\tque.push(P(mincost[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, R;\n  cin >> N >> R;\n  graph.resize(N);\n  rep(i, R) {\n    int s, t, d;\n    cin >> s >> t >> d; s--, t--;\n    graph[s].emplace_back(t, d);\n    graph[t].emplace_back(s, d);\n  }\n\n  mincost.resize(N, vector<int>(N, inf));\n  int maxdist = 0;\n  rep(i, N) dijkstra(i);\n  rep(i, N) reps(j, i+1, N) maxdist = max(maxdist, mincost[i][j]);\n\n  //vector<P> ep;\n  vector<int> S, T;\n  rep(i, N) reps(j, i+1, N) {\n    if(mincost[i][j] == maxdist) S.push_back(i), T.push_back(j);//ep.emplace_back(i, j);\n  }\n\n  vector<int> ans;\n  rep(i, N) {\n    bool flag = true;\n    //for(auto& p : ep) {\n    rep(j, S.size()) {\n      //int s, t; tie(s, t) = p;\n      if(mincost[S[j]][i] + mincost[i][T[j]] == maxdist) {\n\tflag = false;\n\tbreak;\n      }\n    }\n    if(flag) ans.push_back(i+1);\n  }\n  \n  cout << ans.size() << endl;\n  rep(i, ans.size()) cout << ans[i] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <typename T>\nstruct edge {\n    int from, to; T cost;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n};\n\ntemplate <class K, class V>\nclass RadixHeap {\n    static constexpr int bit_length = sizeof(K)*8;\n    K last;\n    size_t sz, cnt;\n\n    array<vector<pair<K, V>>, bit_length> v;\n    static inline int bsr(int x){\n        return x ? bit_length-__builtin_clz(x) : 0;\n    }\n    static inline int bsr(ll x){\n        return x ? bit_length-__builtin_clzll(x) : 0;\n    }\n\n    void pull() {\n        if(cnt < v[0].size()) return;;\n        int i = 1;\n        while(v[i].empty()) i++;\n        last = min_element(v[i].begin(),v[i].end())->first;\n        for (auto &&x : v[i]) v[bsr(x.first ^ last)].push_back(x);\n        v[i].clear();\n    }\npublic:\n    RadixHeap() : last(0), sz(0), cnt(0) {}\n    void emplace(K x, V val){\n        sz++;\n        v[bsr(x^last)].emplace_back(x, val);\n    }\n\n    pair<K, V> top() {\n        pull();\n        return v[0][cnt];\n    }\n\n    void pop() {\n        pull();\n        sz--;\n        cnt++;\n    }\n\n    size_t size() const { return sz; }\n    bool empty() const { return !sz; }\n};\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<edge<int>>> G(n);\n    for (int i = 0; i < m; ++i) {\n        int s, t, d;\n        scanf(\"%d %d %d\", &s, &t, &d);\n        s--; t--;\n        G[s].emplace_back(t, d);\n        G[t].emplace_back(s, d);\n    }\n    RadixHeap<int, int> Q;\n    auto d = make_v(n, n, INF<int>);\n    vector<int> ok(n, 1);\n    for (int s = 0; s < n; ++s) {\n        d[s][s] = 0;\n        Q.emplace(0, s);\n        while(!Q.empty()){\n            int cost; int i;\n            tie(cost, i) = Q.top(); Q.pop();\n            if(d[s][i] < cost) continue;\n            for (auto &&e : G[i]) {\n                auto cost2 = cost + e.cost;\n                if(d[s][e.to] <= cost2) continue;\n                d[s][e.to] = cost2;\n                Q.emplace(d[s][e.to], e.to);\n            }\n        }\n    }\n    int val = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            chmax(val, d[i][j]);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        queue<int> q;\n        vector<int> visited(n);\n        for (int j = 0; j < n; ++j) {\n            if(d[i][j] == val){\n                q.emplace(j);\n                visited[j] = 1;\n            }\n        }\n        while(!q.empty()){\n            int x = q.front(); q.pop();\n            ok[x] = 0;\n            for (auto &&y : G[x]) {\n                if(!visited[y.to] && d[i][y.to]+y.cost == d[i][x]){\n                    q.emplace(y.to);\n                    visited[y.to] = 1;\n                }\n            }\n        }\n    }\n    cout << accumulate(ok.begin(),ok.end(), 0) << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        if(ok[i]) cout << i+1 << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nstruct edge\n{\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nvector< vector<edge> > graph;\nvector< vector<int> > mincost;\n\nvoid dijkstra(int s)\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  mincost[s][s] = 0;\n  while(!que.empty()) {\n    int cost, now;\n    tie(cost, now) = que.top(); que.pop();\n    if(mincost[s][now] < cost) continue;\n    for(edge& e : graph[now]) {\n      if(e.cost + cost < mincost[s][e.to]) {\n\tmincost[s][e.to] = e.cost + cost;\n\tque.push(P(mincost[s][e.to], e.to));\n      }\n    }\n  }\n  //return *max_element(all(mincost[s]));\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, R;\n  cin >> N >> R;\n  graph.resize(N);\n  rep(i, R) {\n    int s, t, d;\n    cin >> s >> t >> d; s--, t--;\n    graph[s].emplace_back(t, d);\n    graph[t].emplace_back(s, d);\n  }\n\n  mincost.resize(N, vector<int>(N, inf));\n  int maxdist = 0;\n  rep(i, N) dijkstra(i); //maxdist = max(maxdist, dijkstra(i));\n  rep(i, N) rep(j, i+1, N) maxdist = max(maxdist, mincost[i][j]);\n\n  vector<P> ep;\n  rep(i, N) reps(j, i+1, N) {\n    if(mincost[i][j] == maxdist) ep.emplace_back(i, j);\n  }\n\n  vector<int> ans;\n  rep(i, N) {\n    bool flag = true;\n    for(auto& p : ep) {\n      int s, t; tie(s, t) = p;\n      if(mincost[s][i] + mincost[i][t] == maxdist) flag = false;\n    }\n    if(flag) ans.push_back(i+1);\n  }\n  \n  cout << ans.size() << endl;\n  rep(i, ans.size()) cout << ans[i] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n\ntypedef pair<int, int> P;\nconst int INF = 1e9 + 9;\n\nstruct edge {\n  int to, cost;\n};\n/*\nstruct State {\n  int from, to, len;\n};\n*/\nint n, r;\nvector<edge> g[2000];\nint d[2000];\nint mi;\nint ans;\nvector<vector<int> > path;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > q;\n  int prev[2000];\n  fill(d, d + n, INF);\n  fill(prev, prev + n, -1);\n  d[s] = 0;\n  q.push(P(0, s));\n  while (!q.empty()) {\n    P p = q.top(); q.pop();\n    int v = p.second;\n    if (d[v] < p.first) continue;\n    REP(i, g[v].size()) {\n      edge e = g[v][i];\n      if (d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        prev[e.to] = v;\n        q.push(P(d[e.to], e.to));\n      }\n    }\n  }\n\n  int c = 0;\n  vector<int> res;\n  REP(i, n) {\n    if (s == i) continue;\n    if (c == d[i]) {\n      res.push_back(i);\n    }\n    if (c < d[i]) {\n      c = d[i];\n      res = vector<int>();\n      res.push_back(i);\n    }\n  }\n\n  if (c == ans) {\n    vector<int> patht;\n    REP(i, res.size()) {\n      int t = res[i];\n      for (; t != -1; t = prev[t]) patht.push_back(t);\n      reverse(patht.begin(), patht.end());\n      path.push_back(patht);\n    }\n  } else if (c > ans) {\n    ans = c;\n    path = vector<vector<int> >();\n    vector<int> patht;\n    REP(i, res.size()) {\n      int t = res[i];\n      for (; t != -1; t = prev[t]) patht.push_back(t);\n      reverse(patht.begin(), patht.end());\n      path.push_back(patht);\n    }\n  }\n  /*\n  REP(i, n) {\n    printf(\"from %d to %d cost %d\\n\", s, i, d[i]);\n  }*/\n}\n\nint main() {\n  cin >> n >> r;\n  ans = -INF;\n  REP(i, r) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    s--; t--;\n    g[s].push_back((edge){t, d});\n    g[t].push_back((edge){s, d});\n  }\n  REP(i, n) {\n    dijkstra(i);\n  }\n  bool chie[2000] = {};\n  REP(i, path.size()) {\n    REP(j, path[i].size()) {\n      chie[path[i][j]] = true;\n      //printf(\"p: %d %d\\n\", i, path[i][j]);\n    }\n  }\n  vector<int> v;\n  REP(i, n) {\n    if (!chie[i]) {\n      v.push_back(i + 1);\n    }\n  }\n  cout << v.size() << endl;\n  REP(i, v.size()) printf(\"%d\\n\", v[i]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_town,int arg_cost){\n\t\ttown = arg_town;\n\t\tcost = arg_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn cost > arg.cost;\n\t};\n\tint town,cost;\n};\n\nstruct Dist{\n\tDist(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Data{\n\tData(int arg_start,int arg_goal){\n\t\tstart = arg_start;\n\t\tgoal = arg_goal;\n\t}\n\tint start,goal;\n};\n\nint main(){\n\n\tint N,R,s,t,d;\n\tscanf(\"%d %d\",&N,&R);\n\n\tvector<Dist> V[N+1];\n\tint* MIN_COST = new int[N+1];\n\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d %d %d\",&s,&t,&d);\n\t\tV[s].push_back(Dist(t,d));\n\t\tV[t].push_back(Dist(s,d));\n\t}\n\n\tint maximum = -1,min_index;\n\tstack<Data> S;\n\tpriority_queue<Info> Q;\n\n\tfor(int from = 1; from <= N-1;from++){\n\t\tfor(int to = from+1; to <= N; to++){\n\n\t\t\tfor(int i = 1; i <= N; i++)MIN_COST[i] = BIG_NUM;\n\n\t\t\tfor(int i = 0; i < V[from].size();i++){\n\t\t\t\tMIN_COST[V[from][i].to] = V[from][i].cost;\n\t\t\t\tQ.push(Info(V[from][i].to,V[from][i].cost));\n\t\t\t}\n\n\t\t\twhile(!Q.empty()){\n\t\t\t\tif(Q.top().cost > MIN_COST[Q.top().town]){\n\t\t\t\t\tQ.pop();\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tmin_index = Q.top().town;\n\t\t\t\t\tQ.pop();\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\t\tif(MIN_COST[V[min_index][i].to] > MIN_COST[min_index] + V[min_index][i].cost){\n\t\t\t\t\t\tMIN_COST[V[min_index][i].to] = MIN_COST[min_index] + V[min_index][i].cost;\n\t\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[V[min_index][i].to]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(MIN_COST[to] > maximum){\n\t\t\t\tmaximum = MIN_COST[to];\n\t\t\t\twhile(!S.empty())S.pop();\n\t\t\t\tS.push(Data(from,to));\n\t\t\t}else if(MIN_COST[to] == maximum){\n\t\t\t\tS.push(Data(from,to));\n\t\t\t}\n\t\t}\n\t}\n\n\tbool* USED = new bool[N+1];\n\tfor(int i = 1; i <= N; i++)USED[i] = false;\n\n\tvector<int> PRE_TOWN[N+1];\n\tqueue<int> WORK;\n\tbool* CHECK = new bool[N+1];\n\tbool FLG;\n\n\tint start,goal;\n\n\twhile(!S.empty()){\n\t\tstart = S.top().start;\n\t\tgoal = S.top().goal;\n\t\tS.pop();\n\n\t\tUSED[start] = true;\n\t\tUSED[goal] = true;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tPRE_TOWN[i].clear();\n\t\t\tCHECK[i] = false;\n\t\t}\n\t\tCHECK[start] = true;\n\t\tCHECK[goal] = true;\n\n\t\tfor(int i = 1; i <= N; i++)MIN_COST[i] = BIG_NUM;\n\n\t\tfor(int i = 0; i < V[start].size();i++){\n\t\t\tMIN_COST[V[start][i].to] = V[start][i].cost;\n\t\t\tQ.push(Info(V[start][i].to,V[start][i].cost));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().cost > MIN_COST[Q.top().town]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tmin_index = Q.top().town;\n\t\t\t\tQ.pop();\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\tif(MIN_COST[V[min_index][i].to] > MIN_COST[min_index] + V[min_index][i].cost){\n\t\t\t\t\tMIN_COST[V[min_index][i].to] = MIN_COST[min_index] + V[min_index][i].cost;\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].clear();\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[V[min_index][i].to]));\n\t\t\t\t}else if(MIN_COST[V[min_index][i].to] == MIN_COST[min_index] + V[min_index][i].cost){\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tfor(int k = 0; k < PRE_TOWN[V[min_index][i].to].size();k++){\n\t\t\t\t\t\tif(PRE_TOWN[V[min_index][i].to][k] == min_index){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(FLG){\n\t\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[V[min_index][i].to]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0 ; i < PRE_TOWN[goal].size(); i++){\n\t\t\tWORK.push(PRE_TOWN[goal][i]);\n\t\t}\n\n\t\twhile(!WORK.empty()){\n\t\t\tUSED[WORK.front()] = true;\n\t\t\tCHECK[WORK.front()] = true;\n\t\t\tfor(int i = 0; i < PRE_TOWN[WORK.front()].size();i++){\n\t\t\t\tif(CHECK[PRE_TOWN[WORK.front()][i]] == false){\n\t\t\t\t\tWORK.push(PRE_TOWN[WORK.front()][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tWORK.pop();\n\t\t}\n\t}\n\n\tint num = 0;\n\n\tfor(int i = 1; i <= N; i++)if(USED[i] == false)num++;\n\n\tprintf(\"%d\\n\",num);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(USED[i] == false){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t}\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  using Edge = pair<int, int>;\n  using Graph = vector<vector<Edge>>;\n\n  int N, M;\n  cin >> N >> M;\n\n  Graph G(N);\n  for(auto i = 0; i < M; ++i) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    --s, --t;\n    G[s].emplace_back(t, d);\n    G[t].emplace_back(s, d);\n  }\n\n  // Djikstra\n  vector<int> m(N, -1);\n  vector<vector<int>> d(N, vector<int>(N, -1));\n  vector<vector<vector<int>>> p(N, vector<vector<int>>(N));\n\n  for(auto i = 0; i < N; ++i) {\n    using Node = tuple<int, int, int>;\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    q.emplace(0, i, i);\n\n    while(!q.empty()) {\n      int cost, cur, pre;\n      tie(cost, cur, pre) = q.top();\n      q.pop();\n\n      if(d[i][cur] == cost) p[i][cur].emplace_back(pre);\n      if(d[i][cur] != -1) continue;\n      m[i] = max(m[i], cost);\n      d[i][cur] = cost;\n      p[i][cur] = {pre};\n\n      for(auto e: G[cur]) {\n        auto nex = e.first;\n        auto c = cost + e.second;\n        if(d[i][nex] == -1) q.emplace(c, nex, cur);\n      }\n    }\n  }\n\n  // BFS\n  vector<bool> use(N);\n  auto D = *max_element(begin(m), end(m));\n\n  for(auto i = 0; i < N; ++i) {\n    queue<int> q;\n    for(auto v = 0; v < N; ++v) if(d[i][v] == D) q.emplace(v);\n\n    while(!q.empty()) {\n      auto cur = q.front();\n      q.pop();\n      use[cur] = true;\n      for(auto nex: p[i][cur]) if(nex != cur) q.emplace(nex);\n    }\n  }\n\n  vector<int> ans;\n  for(auto i = 0; i < N; ++i) if(!use[i]) ans.emplace_back(i + 1);\n  cout << ans.size() << endl;\n  for(auto i: ans) cout << i << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  while(1) {\n    mp[j] = 1;\n    if(j == i) break;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        j = e.to;\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) fill(d[i], d[i] + n, 114514);\n\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n    rep(j, 1, n + 1) {\n      d[j][i] = d[i][j];\n    }\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  int done[1501][1501] = {};\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(!done[i][j] && mas == d[i][j]) {\n        solve(i, j);\n        done[j][i] = 1;\n      }\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1 ) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\n#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_town,int arg_cost){\n\t\ttown = arg_town;\n\t\tcost = arg_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn cost > arg.cost;\n\t};\n\tint town,cost;\n};\n\nstruct Dist{\n\tDist(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Data{\n\tData(int arg_start,int arg_goal){\n\t\tstart = arg_start;\n\t\tgoal = arg_goal;\n\t}\n\tint start,goal;\n};\n\nint main(){\n\n\tint N,R,s,t,d;\n\tscanf(\"%d %d\",&N,&R);\n\n\tvector<Dist> V[N+1];\n\tint** MIN_COST = new int*[N+1];\n\tfor(int i = 1; i <= N; i++){\n\t\tMIN_COST[i] = new int[N+1];\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tif(i != k)MIN_COST[i][k] = BIG_NUM;\n\t\t\telse{\n\t\t\t\tMIN_COST[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d %d %d\",&s,&t,&d);\n\t\tV[s].push_back(Dist(t,d));\n\t\tV[t].push_back(Dist(s,d));\n\t}\n\n\tint maximum = -1,min_index;\n\tstack<Data> S;\n\tpriority_queue<Info> Q;\n\tqueue<int> WORK;\n\tvector<int> ANS;\n\tvector<int> PRE_TOWN[N+1];\n\n\tbool* VISITED = new bool[N+1];\n\n\tfor(int from = 1; from <= N;from++){\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tPRE_TOWN[i].clear();\n\t\t\tPRE_TOWN[i].push_back(from);\n\t\t}\n\n\t\tfor(int i = 0; i < V[from].size();i++){\n\t\t\tMIN_COST[from][V[from][i].to] = V[from][i].cost;\n\t\t\tQ.push(Info(V[from][i].to,V[from][i].cost));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().cost > MIN_COST[from][Q.top().town]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tmin_index = Q.top().town;\n\t\t\t\tQ.pop();\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\tif(MIN_COST[from][V[min_index][i].to] > MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\tMIN_COST[from][V[min_index][i].to] = MIN_COST[from][min_index] + V[min_index][i].cost;\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].clear();\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[from][V[min_index][i].to]));\n\t\t\t\t}else if(MIN_COST[from][V[min_index][i].to] == MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(maximum <= MIN_COST[from][i]){\n\t\t\t\tif(maximum < MIN_COST[from][i]){\n\t\t\t\t\tANS.clear();\n\t\t\t\t}\n\t\t\t\tmaximum = MIN_COST[from][i];\n\n\t\t\t\tfor(int k = 1; k <= N; k++)VISITED[k] = false;\n\n\t\t\t\tWORK.push(i);\n\t\t\t\tVISITED[i] = true;\n\t\t\t\tANS.push_back(i);\n\n\t\t\t\twhile(!WORK.empty()){\n\t\t\t\t\tfor(int k = 0; k < PRE_TOWN[WORK.front()].size(); k++){\n\t\t\t\t\t\tif(VISITED[PRE_TOWN[WORK.front()][k]] == false){\n\t\t\t\t\t\t\tVISITED[PRE_TOWN[WORK.front()][k]] = true;\n\t\t\t\t\t\t\tANS.push_back(PRE_TOWN[WORK.front()][k]);\n\t\t\t\t\t\t\tWORK.push(PRE_TOWN[WORK.front()][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tWORK.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool* USED = new bool[N+1];\n\tfor(int i = 1; i <= N; i++)USED[i] = false;\n\n\tfor(int i = 0; i < ANS.size(); i++)USED[ANS[i]] = true;\n\n\tint num = 0;\n\n\tfor(int i = 1; i <= N; i++)if(USED[i] == false)num++;\n\n\tprintf(\"%d\\n\",num);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(USED[i] == false){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t}\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n// clang-format on\n/* }}} */\n\nstruct Edge {\n  Edge() {}\n  Edge(int a, int b) { to = a; cost = b; }\n  int to, cost;\n};\nint N, R;\nvector<Edge> G[1500];\nmap<int, bool> chie;\n\nvoid dijkstra(int s, vi &d) {\n  minPQ<pii> q;\n  d[s] = 0;\n  q.emplace(0, s);\n\n  while (q.size()) {\n    auto p = q.top(); q.pop();\n    int v = p.Se;\n    if (d[v] < p.Fi) continue;\n    EACH(e, G[v]) {\n      if (d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        q.emplace(d[e.to], e.to);\n      }\n    }\n  }\n}\n\nvoid bfs(int s, vi &d) {\n  queue<pii> q;\n  q.emplace(s, d[s]);\n  bool vis[1500] = {};\n  while (q.size()) {\n    auto p = q.front(); q.pop();\n    if (vis[p.Fi]) continue;\n    chie[p.Fi] = true;\n    vis[p.Fi] = true;\n    EACH(e, G[p.Fi]) {\n      if (d[e.to] != d[p.Fi] - e.cost) continue;\n      q.emplace(e.to, d[e.to]);\n    }\n  }\n}\n\nsigned main() {\n  cin >> N >> R;\n  vvi d(N, vi(N, INF));\n  REP(i, R) {\n    int s = in() - 1, t = in() - 1, d = in();\n    G[s].eb(t, d);\n    G[t].eb(s, d);\n  }\n  REP(i, N) dijkstra(i, d[i]);\n\n  int ma = 0;\n  REP(i, N) REP(j, N) chmax(ma, d[i][j]);\n\n  REP(i, N) REP(j, N) {\n    if (ma == d[i][j]) {\n      bfs(j, d[i]);\n    }\n  }\n\n  print(N - chie.size());\n  REP(i, chie.size()) if (!chie[i]) {\n    print(i + 1);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dist[2000];set<int>p[2000];\nvector<pair<int,int>> vec[2000];\nint n,m;\nbool used2[2000];\nset<int>R[2000][2000];\nint dst[2000][2000];\nvector<int>shor[2000];\nvoid dijkstra(int s){\n\tfor(int i=0;i<2000;i++){dist[i]=999999999;p[i].clear();}\n\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>Q;\n\tQ.push(make_pair(0,s));dist[s]=0;\n\twhile(!Q.empty()){\n\t\tint a1=Q.top().first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<(int)vec[a2].size();i++){\n\t\t\tint to=vec[a2][i].first,cost=vec[a2][i].second;\n\t\t\tif(dist[to]>a1+cost){\n\t\t\t\tp[to].clear();p[to].insert(a2);\n\t\t\t\tdist[to]=a1+cost;\n\t\t\t\tQ.push(make_pair(dist[to],to));\n\t\t\t}\n\t\t\tif(dist[to]==a1+cost && p[to].count(a2)==0){\n\t\t\t\tp[to].insert(a2);\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int i=0;i<2000;i++){\n\t\tdst[s][i]=dist[i];\n\t\tR[s][i]=p[i];\n\t}*/\n}\nvoid solve(int s){\n\tqueue<int>Q;\n\tbool used[2000];for(int i=0;i<2000;i++)used[i]=false;\n\tfor(int i=0;i<(int)shor[s].size();i++){Q.push(shor[s][i]);used[shor[s][i]]=true;}\n\twhile(!Q.empty()){\n\t\tint a1=Q.front();Q.pop();\n\t\t\n\t\tfor(auto a2 : p[a1]){\n\t\t\tif(used[a2]==false){used[a2]=true;Q.push(a2);}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){if(used[i]==true)used2[i]=true;}\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\tvec[a].push_back(make_pair(b,c));\n\t\tvec[b].push_back(make_pair(a,c));\n\t}\n\tfor(int i=1;i<=n;i++)dijkstra(i);\n\tint maxn=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tmaxn=max(maxn,dst[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(dst[i][j]==maxn)shor[i].push_back(j);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)solve(i);\n\tint num=0;\n\tfor(int i=1;i<=n;i++){if(used2[i]==false)num++;}\n\tcout<<num<<endl;\n\tfor(int i=1;i<=n;i++){if(used2[i]==false)cout<<i<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int INF = 500000000;\nint n, r;\nvector<int> et[1500];\nvector<int> ec[1500];\nbool flag[1500];\n\nint dijkstra(int s, int maxDist) {\n\tint i, dist[1500];\n\ttypedef pair<int, int> P;\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor (i = 0; i < n; i++) dist[i] = INF;\n\tque.push(P(0, s));\n\t\n\twhile (!que.empty()) {\n\t\tP now = que.top(); que.pop();\n\t\tint cst = now.first;\n\t\tint v = now.second;\n\t\t\n\t\tif (dist[v] <= cst) continue;\n\t\tdist[v] = cst;\n\t\t\n\t\tfor (i = 0; i < et[v].size(); i++) {\n\t\t\tque.push(P(cst + ec[v][i], et[v][i]));\n\t\t}\n\t}\n\t\n\t//?????§?????¢????±???????\n\tint ret = 0;\n\tfor (i = 0; i < n; i++) ret = max(ret, dist[i]);\n\tif (maxDist != ret) return ret;\n\t\n\t//??????????????¢?´¢?????????????????¨????????????\n\tqueue<int> qu;\n\tbool visit[1500] = {false};\n\t\n\tfor (i = 0; i < n; i++) if (dist[i] == maxDist) qu.push(i);\n\twhile (!qu.empty()) {\n\t\tint v = qu.front(); qu.pop();\n\t\tflag[v] = true;\n\t\t\n\t\tfor (i = 0; i < et[v].size(); i++) {\n\t\t\tif (dist[et[v][i]] + ec[v][i] == dist[v] && !visit[et[v][i]]) {\n\t\t\t\tqu.push(et[v][i]);\n\t\t\t\tvisit[et[v][i]] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint i;\n\t\n\tcin >> n >> r;\n\tfor (i = 0; i < r; i++) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\ts--; t--;\n\t\tet[s].push_back(t);\n\t\tet[t].push_back(s);\n\t\tec[s].push_back(d);\n\t\tec[t].push_back(d);\n\t}\n\t\n\tint maxDist = -1;\n\tfor (i = 0; i < n; i++) {\n\t\tmaxDist = max(maxDist, dijkstra(i, INF));\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tdijkstra(i, maxDist);\n\t}\n\t\n\tvector<int> ans;\n\tfor (i = 0; i < n; i++) {\n\t\tif (!flag[i]) ans.push_back(i + 1);\n\t}\n\t\n\tcout << ans.size() << endl;\n\tfor (i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int INF = 500000000;\nint n, r;\nvector<int> et[1500];\nvector<int> ec[1500];\nbool flag[1500];\n\nint dijkstra(int s, int maxDist) {\n\tint i, dist[1500];\n\ttypedef pair<int, int> P;\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor (i = 0; i < n; i++) dist[i] = INF;\n\tque.push(P(0, s));\n\t\n\twhile (!que.empty()) {\n\t\tP now = que.top(); que.pop();\n\t\tint cst = now.first;\n\t\tint v = now.second;\n\t\t\n\t\tif (dist[v] <= cst) continue;\n\t\tdist[v] = cst;\n\t\t\n\t\tfor (i = 0; i < et[v].size(); i++) {\n\t\t\tque.push(P(cst + ec[v][i], et[v][i]));\n\t\t}\n\t}\n\t\n\t//?????§?????¢????±???????\n\tint ret = 0;\n\tfor (i = 0; i < n; i++) ret = max(ret, dist[i]);\n\tif (maxDist != ret) return ret;\n\t\n\t//??????????????¢?´¢?????????????????¨????????????\n\tqueue<int> qu;\n\tbool visit[1500] = {false};\n\t\n\tfor (i = 0; i < n; i++) if (dist[i] == maxDist) qu.push(i);\n\twhile (!qu.empty()) {\n\t\tint v = qu.front(); qu.pop();\n\t\tflag[v] = true;\n\t\tvisit[v] = true;\n\t\t\n\t\tfor (i = 0; i < et[v].size(); i++) {\n\t\t\tif (dist[et[v][i]] + ec[v][i] == dist[v] && !visit[et[v][i]]) {\n\t\t\t\tqu.push(et[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint i;\n\t\n\tcin >> n >> r;\n\tfor (i = 0; i < r; i++) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\ts--; t--;\n\t\tet[s].push_back(t);\n\t\tet[t].push_back(s);\n\t\tec[s].push_back(d);\n\t\tec[t].push_back(d);\n\t}\n\t\n\tint maxDist = -1;\n\tfor (i = 0; i < n; i++) {\n\t\tmaxDist = max(maxDist, dijkstra(i, INF));\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tdijkstra(i, maxDist);\n\t}\n\t\n\tvector<int> ans;\n\tfor (i = 0; i < n; i++) {\n\t\tif (!flag[i]) ans.push_back(i + 1);\n\t}\n\t\n\tcout << ans.size() << endl;\n\tfor (i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fto(i, x, y) for(int i = (x); i <= (y); ++i)\n#define fdto(i, x, y) for(int i = (x); i >= (y); --i)\n#define ftoa(i, x, y, a) for(int i = (x); i <= (y); i += a)\n#define ftoit(it, var) for (__typeof(var.begin()) it = var.begin(); it != var.end(); ++it)\n\n#define ii pair<int, int>\n#define mp make_pair\n#define FF first\n#define SS second\n\n#define vi vector<int>\n#define vii vector<ii>\n#define ll long long\n#define vll vector<ll>\n\n#define eb emplace_back\n#define ef emplace_front\n#define lb lower_bound\n#define ub upper_bound\n#define sz(a) (int)a.size()\n\n#define oo 1000000007\n#define OO 1000000000000000007LL\n\nusing namespace std;\n\n#define Pro \"tmp\"\n#define maxN 1507\n\nint D[maxN];\nvii adj[maxN];\n\nint f[maxN][maxN];\nint n, m;\n\nbool ans[maxN];\n\nvoid dijkstra(int u) {\n    fto (i, 1, n) D[i] = oo;\n    D[u] = 0;\n\n    set <ii> st;\n    st.insert(mp(0, u));\n\n    while (!st.empty()) {\n        int u = (*st.begin()).SS;\n        st.erase(st.begin());\n\n        fto (i, 0, (int)adj[u].size()-1) {\n            int v = adj[u][i].FF;\n            int w = adj[u][i].SS;\n\n            if (D[v] > D[u]+w) {\n                st.erase(mp(D[v], v));\n                D[v] = D[u]+w;\n                st.insert(mp(D[v], v));\n            }\n        }\n    }\n\n    return;\n}\n\nint main() {\n//    #ifndef ONLINE_JUDGE\n//        freopen(Pro\".inp\", \"r\", stdin);\n//        freopen(Pro\".out\", \"w\", stdout);\n//    #endif // ONLINE_JUDGE\n\n    scanf(\"%d%d\", &n, &m);\n    fto (i, 1, m) {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        adj[u].eb(mp(v, w));\n        adj[v].eb(mp(u, w));\n    }\n\n    int maxAns = 0;\n    fto (i, 1, n) {\n        dijkstra(i);\n        fto (j, 1, n) {\n            f[i][j] = D[j];\n            maxAns = max(maxAns, f[i][j]);\n        }\n    }\n\n//    fto (i, 1, n) {\n//        fto (j, 1, n) cout << f[i][j] << \" \";\n//        puts(\"\");\n//    }\n\n    set <int> st;\n    fto (i, 1, n) st.insert(i);\n\n    fto (i, 1, n) {\n        fto (j, i, n) {\n            if (f[i][j] != maxAns) continue;\n            fto (k, 1, n) {\n                if (f[i][k]+f[k][j] == maxAns) ans[k] = 1;\n            }\n        }\n    }\n\n    int num = 0;\n    fto (i, 1, n) num += !ans[i];\n\n    printf(\"%d\\n\", num);\n    fto (i, 1, n) if (!ans[i]) printf(\"%d\\n\", i);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_town,int arg_cost){\n\t\ttown = arg_town;\n\t\tcost = arg_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn cost > arg.cost;\n\t};\n\tint town,cost;\n};\n\nstruct Dist{\n\tDist(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Data{\n\tData(int arg_start,int arg_goal){\n\t\tstart = arg_start;\n\t\tgoal = arg_goal;\n\t}\n\tint start,goal;\n};\n\nstruct Info2{\n\tint sum,current_town;\n\tbool check[1501];\n};\n\nint main(){\n\n\tint N,R,s,t,d;\n\tscanf(\"%d %d\",&N,&R);\n\n\tvector<Dist> V[N+1];\n\tint** MIN_COST = new int*[N+1];\n\tfor(int i = 1; i <= N; i++){\n\t\tMIN_COST[i] = new int[N+1];\n\t\tfor(int k = 1; k <= N; k++)MIN_COST[i][k] = BIG_NUM;\n\t}\n\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d %d %d\",&s,&t,&d);\n\t\tV[s].push_back(Dist(t,d));\n\t\tV[t].push_back(Dist(s,d));\n\t}\n\n\tint maximum = -1,min_index;\n\tstack<Data> S;\n\tpriority_queue<Info> Q;\n\n\tfor(int from = 1; from <= N;from++){\n\t\tfor(int i = 0; i < V[from].size();i++){\n\t\t\tMIN_COST[from][V[from][i].to] = V[from][i].cost;\n\t\t\tQ.push(Info(V[from][i].to,V[from][i].cost));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().cost > MIN_COST[from][Q.top().town]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tmin_index = Q.top().town;\n\t\t\t\tQ.pop();\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\tif(MIN_COST[from][V[min_index][i].to] > MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\tMIN_COST[from][V[min_index][i].to] = MIN_COST[from][min_index] + V[min_index][i].cost;\n\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[from][V[min_index][i].to]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(i != from && MIN_COST[from][i] != BIG_NUM && MIN_COST[from][i] > maximum){\n\t\t\t\tmaximum = MIN_COST[from][i];\n\t\t\t\twhile(!S.empty())S.pop();\n\t\t\t\tS.push(Data(from,i));\n\t\t\t}else if(i != from && MIN_COST[from][i] != BIG_NUM && MIN_COST[from][i] == maximum){\n\t\t\t\tS.push(Data(from,i));\n\t\t\t}\n\t\t}\n\t}\n\n\tbool* USED = new bool[N+1];\n\tfor(int i = 1; i <= N; i++)USED[i] = false;\n\n\tint start,goal;\n\n\tqueue<Info2> Q2;\n\n\t//start??????goal?????§?§??????????cost???maximum??????????????????????????¬????????¶???\n\twhile(!S.empty()){\n\t\tstart = S.top().start;\n\t\tgoal = S.top().goal;\n\t\tS.pop();\n\n\t\tUSED[start] = true;\n\t\tUSED[goal] = true;\n\n\t\tfor(int i = 0; i < V[start].size();i++){\n\t\t\tInfo2 info;\n\t\t\tfor(int k = 1; k <= N; k++)info.check[k] = false;\n\t\t\tinfo.check[start] = true;\n\t\t\tinfo.check[V[start][i].to] = true;\n\t\t\tinfo.sum = V[start][i].cost;\n\t\t\tinfo.current_town = V[start][i].to;\n\t\t\tQ2.push(info);\n\t\t}\n\n\t\twhile(!Q2.empty()){\n\t\t\tif(Q2.front().sum > maximum || Q2.front().sum > MIN_COST[start][Q2.front().current_town]){ //maximum????¶?????????????????????????????????§???????????????????£?\n\t\t\t\tQ2.pop();\n\t\t\t\tcontinue;\n\t\t\t}else if(Q2.front().sum == maximum){ //sum???maximum????????????\n\t\t\t\tif(Q2.front().current_town == goal){ //?????¨??°?????´????????¨?????????\n\t\t\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\t\t\tif(Q2.front().check[i] == true){\n\t\t\t\t\t\t\tUSED[i] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ2.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V[Q2.front().current_town].size();i++){\n\t\t\t\tif(Q2.front().check[V[Q2.front().current_town][i].to] == false){ //???????????£?????????????????????????????´???\n\t\t\t\t\tInfo2 info;\n\t\t\t\t\tfor(int k = 1; k <= N; k++)info.check[k] = Q2.front().check[k];\n\t\t\t\t\tinfo.check[V[Q2.front().current_town][i].to] = true;\n\t\t\t\t\tinfo.current_town = V[Q2.front().current_town][i].to;\n\t\t\t\t\tinfo.sum = Q2.front().sum + V[Q2.front().current_town][i].cost;\n\t\t\t\t\tQ2.push(info);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ2.pop();\n\t\t}\n\t}\n\n\tint num = 0;\n\n\tfor(int i = 1; i <= N; i++)if(USED[i] == false)num++;\n\n\tprintf(\"%d\\n\",num);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(USED[i] == false){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t}\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int INF = 500000000;\nint n, r;\nvector<int> et[1500];\nvector<int> ec[1500];\nbool flag[1500];\n\nint dijkstra(int s, int maxDist) {\n\tint i, dist[1500];\n\ttypedef pair<int, int> P;\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor (i = 0; i < n; i++) dist[i] = INF;\n\tque.push(P(0, s));\n\t\n\twhile (!que.empty()) {\n\t\tP now = que.top(); que.pop();\n\t\tint cst = now.first;\n\t\tint v = now.second;\n\t\t\n\t\tif (dist[v] <= cst) continue;\n\t\tdist[v] = cst;\n\t\t\n\t\tfor (i = 0; i < et[v].size(); i++) {\n\t\t\tque.push(P(cst + ec[v][i], et[v][i]));\n\t\t}\n\t}\n\t\n\t//?????§?????¢????±???????\n\tint ret = 0;\n\tfor (i = 0; i < n; i++) ret = max(ret, dist[i]);\n\tif (maxDist != ret) return ret;\n\t\n\t//??????????????¢?´¢?????????????????¨????????????\n\tqueue<int> qu;\n\n\tfor (i = 0; i < n; i++) if (dist[i] == maxDist) qu.push(i);\n\twhile (!qu.empty()) {\n\t\tint v = qu.front(); qu.pop();\n\t\t\n\t\tfor (i = 0; i < et[v].size(); i++) {\n\t\t\tif (dist[et[v][i]] + ec[v][i] == dist[v] && !flag[et[v][i]]) {\n\t\t\t\tqu.push(et[v][i]);\n\t\t\t\tflag[v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint i;\n\t\n\tcin >> n >> r;\n\tfor (i = 0; i < r; i++) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\ts--; t--;\n\t\tet[s].push_back(t);\n\t\tet[t].push_back(s);\n\t\tec[s].push_back(d);\n\t\tec[t].push_back(d);\n\t}\n\t\n\tint maxDist = -1;\n\tfor (i = 0; i < n; i++) {\n\t\tmaxDist = max(maxDist, dijkstra(i, INF));\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tdijkstra(i, maxDist);\n\t}\n\t\n\tvector<int> ans;\n\tfor (i = 0; i < n; i++) {\n\t\tif (!flag[i]) ans.push_back(i + 1);\n\t}\n\t\n\tcout << ans.size() << endl;\n\tfor (i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi \"QUIETTOWN.inp\"\n#define fo \"QUIETTOWN.out\"\n#define vt first\n#define gt second\n\nusing namespace std;\nconst int maxn=1700;\nconst int maxc=1e9;\n\npriority_queue < pair <int,int> > heap;\n\nint w,n,m,d[maxn][maxn],p[maxn][maxn],he[maxn*maxn],ke[maxn*maxn],e[maxn*maxn],ans;\nint l[maxn*maxn],r[maxn*maxn],dg[maxn*maxn],fu[maxn],fv[maxn];\nbool dau[maxn],kt[maxn];\n\nvoid open()\n{\n    w=0;\n    //freopen(fi,\"r\",stdin);\n    //freopen(fo,\"w\",stdout);\n\n    scanf(\"%d%d\",&n,&m);\n    int x,y,c;\n\n    for (int i=1; i<=m; i++)\n    {\n      scanf(\"%d%d%d\",&x,&y,&c);\n      he[x]++;\n      he[y]++;\n    }\n    for (int i=2; i<=n; i++) he[i]+=he[i-1];\n\n    freopen(fi,\"r\",stdin);\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1; i<=m; i++)\n    {\n      scanf(\"%d%d%d\",&x,&y,&c);\n      ke[he[x]]=y;\n      ke[he[y]]=x;\n      e[he[x]]=c;\n      e[he[y]]=c;\n      --he[x];\n      --he[y];\n    }\n    he[n+1]=m*2;\n}\n\nvoid dijkstra(int s, int t)\n{\n    for (int i=1; i<=n; i++) d[s][i]=maxc;\n    memset(dau,true,sizeof(dau));\n    d[s][s]=0;\n\n    heap.push(make_pair(0,s));\n\n    while (!heap.empty())\n    {\n      int u=heap.top().gt;\n      heap.pop();\n\n      dau[u]=false;\n      for (int iv=he[u]+1; iv<=he[u+1]; iv++)\n      {\n        int v=ke[iv];\n        if ((dau[v]) && (d[s][v]>d[s][u]+e[iv]))\n        {\n          d[s][v]=d[s][u]+e[iv];\n          p[s][v]=u;\n          heap.push(make_pair(-d[s][v],v));\n        }\n      }\n    }\n}\n\nvoid trace(int s, int u)\n{\n    kt[s]=true;\n    while (p[s][u]!=0)\n    {\n      u=p[s][u];\n      kt[u]=true;\n    }\n}\n\nvoid mocxichcuaconbeo()\n{\n    memset(kt,true,sizeof(kt));\n\n    for (int i=0; i<=n; i++)\n    {\n      l[i]=i-1;\n      r[i]=i+1;\n    }\n\n    for (int i=1; i<=w; i++)\n    {\n      int uu=fu[i];\n      int vv=fv[i];\n\n      int k=0;\n      while (k!=n+1)\n      {\n        if (d[uu][k]+d[k][vv]==ans)\n        {\n          kt[k]=false;\n          l[r[i]]=l[i];\n          r[l[i]]=r[i];\n        }\n        k=r[k];\n      }\n    }\n\n}\n\nvoid process()\n{\n    for (int i=1; i<=n; i++)\n    {\n        dijkstra(i,n);\n        for (int j=1; j<=n; j++)\n          if ((i!=j) && (d[i][j]!=maxc)) ans=max(ans,d[i][j]);\n    }\n\n\n    for (int i=1; i<=n; i++)\n      for (int j=1; j<=n; j++)\n      {\n        if (d[i][j]==ans)\n        {\n          fu[++w]=i;\n          fv[w]=j;\n        }\n      }\n\n    mocxichcuaconbeo();\n\n    int kq=0;\n    for (int i=1; i<=n; i++)\n      if (kt[i]==true) dg[++kq]=i;\n\n    printf(\"%d\\n\",kq);\n    for (int i=1; i<=kq; i++) printf(\"%d\\n\",dg[i]);\n}\n\nint main()\n{\n    open();\n    process();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[i], d[i] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  while(1) {\n    mp[j] = 1;\n    if(j == i) break;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        j = e.to;\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF 1500001\nint n,r,d[1500][1500],qt[1500],ans=0;\nvector<P>e[1500];\nvector<int>p[1500][1500];\nint dfs(int a,int b){\n    if(b==a)return 0;\n    for(int i=0;i<p[a][b].size();i++){\n        if(qt[p[a][b][i]]==0)ans++;\n        qt[p[a][b][i]]=1;\n        dfs(a,p[a][b][i]);\n    }\n    return 0;\n}\nint main(void){\n   cin>>n>>r;\n   for(int i=0;i<r;i++){\n       int s,t,c;\n       cin>>s>>t>>c;\n       s--;\n       t--;\n       e[s].push_back(P(t,c));\n       e[t].push_back(P(s,c));\n   }\n   \n   for(int i=0;i<n;i++){\n       for(int j=0;j<n;j++){\n           d[i][j]=INF;\n       }\n   }\n   int mc=0;\n    for(int i=0;i<n;i++){\n        priority_queue<P,vector<P>,greater<P> >k;\n        d[i][i]=0;\n        k.push(P(0,i));\n        while(!k.empty()){\n            int v=k.top().second,co=k.top().first;\n            k.pop();\n            if(d[i][v]!=co)continue;\n            for(int j=0;j<e[v].size();j++){\n                if(d[i][e[v][j].first]==d[i][v]+e[v][j].second)p[i][e[v][j].first].push_back(v);\n                else if(d[i][e[v][j].first]>d[i][v]+e[v][j].second){\n                    p[i][e[v][j].first].clear();\n                    p[i][e[v][j].first].push_back(v);\n                    d[i][e[v][j].first]=d[i][v]+e[v][j].second;\n                    k.push(P(d[i][e[v][j].first],e[v][j].first));\n                }\n            }\n        }\n        for(int j=0;j<n;j++){\n            if(mc<d[i][j]){\n                mc=d[i][j];\n            }\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(d[i][j]==mc){\n                dfs(i,j);\n            }\n        }\n    }\n    cout<<n-ans<<endl;\n    for(int i=0;i<n;i++){\n        if(qt[i]==0)cout<<i+1<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = a; i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\nconst int inf = 1e9;\n\nstruct Edge {\n  int to, cost;\n  Edge(int to, int cost) : to(to), cost(cost) {}\n  bool operator<(const Edge& rhs) const {\n    if (cost != rhs.cost) return cost > rhs.cost;\n    return to < rhs.to;\n  }\n};\nusing Graph = vector<vector<Edge>>;\nint dist[1500][1500];\n\nint main() {\n  int N, R;\n  cin >> N >> R;\n  Graph G(N);\n  REP(i, R) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    s--, t--;\n    G[s].emplace_back(t, d);\n    G[t].emplace_back(s, d);\n  }\n  REP(s, N) {\n    int* di = dist[s];\n    REP(i, N) di[i] = inf;\n    di[s] = 0;\n    priority_queue<Edge> pq;\n    pq.emplace(s, 0);\n    while (not pq.empty()) {\n      auto e = pq.top();\n      pq.pop();\n      if (e.cost > di[e.to]) continue;\n      for (auto&& ee : G[e.to]) {\n        auto w = e.cost + ee.cost;\n        if (di[ee.to] > w) {\n          di[ee.to] = w;\n          pq.emplace(ee.to, w);\n        }\n      }\n    }\n  }\n  int diam = 0;\n  REP(s, N) REP(t, N) {\n    if (diam < dist[s][t]) diam = dist[s][t];\n  }\n  vector<pair<int, int>> cand;\n  REP(s, N) FOR(t, s + 1, N) {\n    if (dist[s][t] == diam) cand.emplace_back(s, t);\n  }\n  vector<int> town;\n  REP(v, N) {\n    bool quiet = true;\n    for (auto&& st : cand) {\n      int s = st.first, t = st.second;\n      if (dist[s][v] + dist[v][t] == dist[s][t]) {\n        quiet = false;\n        break;\n      }\n    }\n    if (quiet) town.push_back(v);\n  }\n  cout << town.size() << endl;\n  for (int v : town) {\n    cout << v + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n7 11\n1 2 2\n1 3 1\n2 4 2\n2 5 2\n2 6 1\n3 4 1\n3 5 1\n3 6 1\n4 7 2\n5 7 2\n6 7 1\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define int long long\n#define N 1505\n#define bit(x,y) ((x>>y)&1LL)\n\nint n, m;\nvector<vector<pair<int, int> > > a(N);\nint dis[N][N];\n\nbool inqueue[N];\ndeque<int> q;\nint mxans = 0;\nint mx[N];\n\nvoid SPFA(int root) {\n\tdis[root][root] = 0;\n\tq.push_back(root); inqueue[root] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop_front(); inqueue[u] = false;\n\t\tfor (auto v : a[u]) {\n\t\t\tif (dis[root][v.fi] > dis[root][u] + v.se) {\n\t\t\t\tdis[root][v.fi] = dis[root][u] + v.se;\n\t\t\t\tif (!inqueue[v.fi]) {\n\t\t\t\t\tinqueue[v.fi] = true;\n\t\t\t\t\tif (!q.empty() && dis[root][v.fi] < dis[root][q.front()]) {\n\t\t\t\t\t\tq.push_front(v.fi);\n\t\t\t\t\t}\n\t\t\t\t\telse q.push_back(v.fi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) mxans = max(mxans, dis[root][i]);\n}\n\nbool visited[N]; bool mark[N];\nvoid dfs(int u, int root) {\n\tif (visited[u]) return;\n\tvisited[u] = true;\n\tmx[u] = dis[root][u];\n\tfor (auto v : a[u]) {\n\t\tif (dis[root][v.fi] == dis[root][u] + v.se) {\n\t\t\tdfs(v.fi, root); mx[u] = max(mx[u], mx[v.fi]);\n\t\t}\n\t}\n\tif (mx[u] == mxans)\n\t\tmark[u] = 1;\n}\n\nvector<int> order;\nsigned main() {\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#ifdef in1code\n\tfreopen(\"1test.inp\", \"r\", stdin);\n#endif\n\tmemset(dis, 127, sizeof(dis));\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\ta[u].push_back(mp(v, c));\n\t\ta[v].push_back(mp(u, c));\n\t}\n\tfor (int i = 1; i <= n; i++) SPFA(i);\n\tfor (int i = 1; i <= n; i++) {\n\t\tmemset(visited, 0, sizeof(visited)); dfs(i, i);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!mark[i]) order.push_back(i);\n\t}\n\tcout << order.size() << endl;\n\tfor (auto it : order) cout << it << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, m; cin >> n >> m;\n\tvector<bool> use(n);\n\tvector<vector<pi>> e(n);\n\trep(i, m){\n\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\te[a].emplace_back(b, c);\n\t\te[b].emplace_back(a, c);\n\t}\n\tauto dij = [&](const vi &s){\n\t\tvi dist(n, inf);\n\t\tpriority_queue<pi> q;\n\t\tfor(int i : s) q.emplace(0, i);\n\t\twhile(!q.empty()){\n\t\t\tint c, co; tie(co, c) = q.top(); q.pop();\n\t\t\tif(dist[c] < -co) continue;\n\t\t\tdist[c] = -co;\n\t\t\tfor(pi p : e[c]){\n\t\t\t\tint to = p.first;\n\t\t\t\tif(dist[to] > -co + p.second){\n\t\t\t\t\tdist[to] = -co + p.second;\n\t\t\t\t\tq.emplace(co - p.second, to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t};\n\tint mxd = -1, ans = 0;\n\trep(s, n){\n\t\tvi go = dij(vi(1, s));\n\t\tint mx = *max_element(all(go));\n\t\tif(mx < mxd) continue;\n\t\tif(mx > mxd) { use.clear(); use.resize(n); }\n\t\tmxd = mx;\n\t\t\n\t\tvi far;\n\t\trep(i, n) if(go[i] == mx) far.pb(i);\n\t\tvi come = dij(far);\n\t\trep(i, n) if(mx == go[i] + come[i]) use[i] = 1;\n\t}\n\trep(i, n) if(!use[i]) ans++;\n\tcout << ans << endl;\n\trep(i, n) if(!use[i]) cout << i+1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\n#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_town,int arg_cost){\n\t\ttown = arg_town;\n\t\tcost = arg_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn cost > arg.cost;\n\t};\n\tint town,cost;\n};\n\nstruct Dist{\n\tDist(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Data{\n\tData(int arg_start,int arg_goal){\n\t\tstart = arg_start;\n\t\tgoal = arg_goal;\n\t}\n\tint start,goal;\n};\n\nint main(){\n\n\tint N,R,s,t,d;\n\tscanf(\"%d %d\",&N,&R);\n\n\tvector<Dist> V[N+1];\n\tint** MIN_COST = new int*[N+1];\n\tfor(int i = 1; i <= N; i++){\n\t\tMIN_COST[i] = new int[N+1];\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tif(i != k)MIN_COST[i][k] = BIG_NUM; //??????????????????????????¨??????????????????\n\t\t\telse{\n\t\t\t\tMIN_COST[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d %d %d\",&s,&t,&d);\n\t\tV[s].push_back(Dist(t,d));\n\t\tV[t].push_back(Dist(s,d));\n\t}\n\n\tint maximum = -1,min_index;\n\tstack<Data> S;\n\tpriority_queue<Info> Q;\n\tqueue<int> WORK;\n\tvector<int> ANS;\n\tvector<int> PRE_TOWN[N+1];\n\n\tbool* VISITED = new bool[N+1];\n\n\tfor(int from = 1; from <= N;from++){\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tPRE_TOWN[i].clear();\n\t\t\tPRE_TOWN[i].push_back(from);\n\t\t}\n\n\t\tfor(int i = 0; i < V[from].size();i++){\n\t\t\tMIN_COST[from][V[from][i].to] = V[from][i].cost;\n\t\t\tQ.push(Info(V[from][i].to,V[from][i].cost));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().cost > MIN_COST[from][Q.top().town]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tmin_index = Q.top().town;\n\t\t\t\tQ.pop();\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\tif(MIN_COST[from][V[min_index][i].to] > MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\tMIN_COST[from][V[min_index][i].to] = MIN_COST[from][min_index] + V[min_index][i].cost;\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].clear();\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[from][V[min_index][i].to]));\n\t\t\t\t}else if(MIN_COST[from][V[min_index][i].to] == MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t\t//V[min_index][i].to??????????°??????????????§????Q????????£????????????????????????????????§????????§????????£????????????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//?????§?????¢??????????????´????????????????????????????????¢????????§??¨?????£?????°?????????????????????????????§????¶???°???????????????????????????vector????????£??????\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(maximum <= MIN_COST[from][i]){\n\t\t\t\tif(maximum < MIN_COST[from][i]){\n\t\t\t\t\t//printf(\"from:%d goal:%d ANS???????????¢\\n\",from,i);\n\t\t\t\t\tANS.clear(); //??´??????&????¶???°?????????????????????\n\t\t\t\t}\n\t\t\t\tmaximum = MIN_COST[from][i];\n\n\t\t\t\tfor(int k = 1; k <= N; k++)VISITED[k] = false;\n\n\t\t\t\tWORK.push(i);\n\t\t\t\tVISITED[i] = true;\n\t\t\t\tANS.push_back(i);\n\n\t\t\t\twhile(!WORK.empty()){\n\t\t\t\t\tfor(int k = 0; k < PRE_TOWN[WORK.front()].size(); k++){\n\t\t\t\t\t\tif(VISITED[PRE_TOWN[WORK.front()][k]] == false){\n\t\t\t\t\t\t\t//printf(\"from:%d goal:%d ?????¨??°:%d ????????°???:%d\\n\",from,i,WORK.front(),PRE_TOWN[WORK.front()][k]);\n\t\t\t\t\t\t\tVISITED[PRE_TOWN[WORK.front()][k]] = true;\n\t\t\t\t\t\t\tANS.push_back(PRE_TOWN[WORK.front()][k]);\n\t\t\t\t\t\t\tWORK.push(PRE_TOWN[WORK.front()][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tWORK.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool* USED = new bool[N+1];\n\tfor(int i = 1; i <= N; i++)USED[i] = false;\n\n\tfor(int i = 0; i < ANS.size(); i++)USED[ANS[i]] = true;\n\n\tint num = 0;\n\n\tfor(int i = 1; i <= N; i++)if(USED[i] == false)num++;\n\n\tprintf(\"%d\\n\",num);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(USED[i] == false){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t}\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dist[2000];set<int>p[2000];\nvector<pair<int,int>> vec[2000];\nint n,m;\nbool used2[2000];\nset<int>R[2000][2000];\nint dst[2000][2000];\nvector<int>shor[2000];\nvoid dijkstra(int s){\n\tfor(int i=0;i<2000;i++){dist[i]=999999999;p[i].clear();}\n\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>Q;\n\tQ.push(make_pair(0,s));dist[s]=0;\n\twhile(!Q.empty()){\n\t\tint a1=Q.top().first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<(int)vec[a2].size();i++){\n\t\t\tint to=vec[a2][i].first,cost=vec[a2][i].second;\n\t\t\tif(dist[to]>a1+cost){\n\t\t\t\tp[to].clear();p[to].insert(a2);\n\t\t\t\tdist[to]=a1+cost;\n\t\t\t\tQ.push(make_pair(dist[to],to));\n\t\t\t}\n\t\t\tif(dist[to]==a1+cost && p[to].count(a2)==0){\n\t\t\t\tp[to].insert(a2);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<2000;i++){\n\t\tdst[s][i]=dist[i];\n\t\tR[s][i]=p[i];\n\t}\n}\nvoid solve(int s){\n\tqueue<int>Q;\n\tbool used[2000];for(int i=0;i<2000;i++)used[i]=false;\n\tfor(int i=0;i<(int)shor[s].size();i++){Q.push(shor[s][i]);used[shor[s][i]]=true;}\n\twhile(!Q.empty()){\n\t\tint a1=Q.front();Q.pop();\n\t\t\n\t\tfor(auto a2 : p[a1]){\n\t\t\tif(used[a2]==false){used[a2]=true;Q.push(a2);}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){if(used[i]==true)used2[i]=true;}\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\tvec[a].push_back(make_pair(b,c));\n\t\tvec[b].push_back(make_pair(a,c));\n\t}\n\tfor(int i=1;i<=n;i++)dijkstra(i);\n\tint maxn=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tmaxn=max(maxn,dst[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(dst[i][j]==maxn)shor[i].push_back(j);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)solve(i);\n\tint num=0;\n\tfor(int i=1;i<=n;i++){if(used2[i]==false)num++;}\n\tcout<<num<<endl;\n\tfor(int i=1;i<=n;i++){if(used2[i]==false)cout<<i<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int from, to, weight;\n  Edge(int f, int t, int w) : from(f), to(t), weight(w) {}\n};\nusing Graph = vector<vector<Edge>>;\n\npair<int, vector<int>> Dijkstra(auto& G, auto s) {\n  int b = 0;\n  vector<int> d(G.size(), -1);\n  using Node = pair<int, int>;\n  priority_queue<Node, vector<Node>, greater<Node>> q;\n  q.emplace(0, s);\n  while(!q.empty()) {\n    int cost, v;\n    tie(cost, v) = q.top();\n    q.pop();\n    if(~d[v]) continue;\n    d[v] = cost;\n    b = max(b, cost);\n    for(auto& e: G[v]) if(! ~d[e.to]) q.emplace(cost + e.weight, e.to);\n  }\n  return {b, d};\n}\n\nset<int> exclusion(auto& G, auto s, auto b, auto& d) {\n  vector<int> ok(G.size());\n  function<int(int, int)> dfs = [&](int cost, int v) {\n    if(ok[v]) return ok[v];\n    if(d[v] == b) return ok[v] = 1;\n    for(auto& e: G[v]) if(d[e.to] == cost + e.weight) if(dfs(cost + e.weight, e.to) == 1) return ok[v] = 1;\n    return ok[v] = -1;\n  };\n  dfs(0, s);\n  set<int> result;\n  for(auto i = 0; i < G.size(); ++i) if(! ~ok[i]) result.insert(i);\n  return result;\n}\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  Graph G(N);\n  for(auto i = 0; i < M; ++i) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    --s, --t;\n    G[s].emplace_back(s, t, d);\n    G[t].emplace_back(t, s, d);\n  }\n\n  int best = 0;\n  vector<pair<int, set<int>>> result;\n  for(auto s = 0; s < N; ++s) {\n    int b;\n    vector<int> d;\n    tie(b, d) = Dijkstra(G, s);\n    best = max(best, b);\n    result.emplace_back(b, exclusion(G, s, b, d));\n  }\n\n  set<int> answer;\n  for(auto& i: result) if(i.first == best) answer.insert(begin(i.second), end(i.second));\n  cout << answer.size() << endl;\n  for(auto i: answer) cout << i + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\n#include<map>\n#include<unordered_map>\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint mincost[1500][1500];\nvector<P>rinsetu[1500];\nlist<int>L[1500][1500];\nbool s[1500];\nsigned main() {\n\tint a, b; cin >> a >> b;\n\tfor (int c = 0; c < b; c++) {\n\t\tint d, e, f; scanf(\"%d%d%d\", &d, &e, &f); d--; e--;\n\t\trinsetu[d].push_back(P(f, e)); \n\t\trinsetu[e].push_back(P(f, d));\n\t}\n\tfor (int c = 0; c < a; c++) {\n\t\tfill(mincost[c], mincost[c] + a, 1 << 29);\n\t\tmincost[c][c] = 0;\n\t\tpriority_queue<P, vector<P>, greater<P>>Q;\n\t\tQ.push(P(0,c));\n\t\twhile (Q.size()) {\n\t\t\tP t = Q.top(); Q.pop();\n\t\t\tif (t.first > mincost[c][t.second])continue;\n\t\t\tfor (P u : rinsetu[t.second]) {\n\t\t\t\tif (mincost[c][u.second] > t.first + u.first) {\n\t\t\t\t\tmincost[c][u.second] = t.first + u.first;\n\t\t\t\t\tQ.push(P(mincost[c][u.second], u.second));\n\t\t\t\t\tL[c][u.second].clear();\n\t\t\t\t\tL[c][u.second].push_back(t.second);\n\t\t\t\t}\n\t\t\t\telse if (mincost[c][u.second] == t.first + u.first) {\n\t\t\t\t\tL[c][u.second].push_back(t.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint MAX = 0;\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < a; j++) {\n\t\t\tMAX = max(MAX, mincost[i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < a; j++) {\n\t\t\tif (mincost[i][j] != MAX)continue;\n\t\t\tqueue<int>Q;\n\t\t\tQ.push(j);\n\t\t\twhile (Q.size()) {\n\t\t\t\tint o = Q.front(); Q.pop();\n\t\t\t\ts[o] = true;\n\t\t\t\tfor (int k : L[i][o]) {\n\t\t\t\t\tQ.push(k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlist<int>w;\n\tfor (int i = 0; i < a; i++) {\n\t\tif (!s[i])w.push_back(i);\n\t}\n\tcout << w.size() << endl;\n\tfor (int u : w)cout << u+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nint N,R;\nint s,t,d;\n\nint dist[1501][1501];\nbool used[1501] = {false};\nbool memo[1501][1501] = {false};\n\ntypedef pair<int,int> PR;\nvector<PR> li[1501];\n\nvector<PR> course;\n\nvoid dijkstra(int rt){\n\tpriority_queue<PR,vector<PR>,greater<PR> > que;\n\tque.push(make_pair(0,rt));\n\n\twhile(!que.empty()){\n\t\tPR p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif(dist[rt][v] < p.first) continue;\n\t\tfor(int i = 0; i < li[v].size(); i++){\n\t\t\tPR e = li[v][i];\n\t\t\tif(dist[rt][e.second] > dist[rt][v] + e.first){\n\t\t\t\tdist[rt][e.second] = dist[rt][v] + e.first;\n\t\t\t\tque.push(make_pair(dist[rt][e.second],e.second));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid running(int src,int dst){\n\tif(src == dst){\n\t\treturn;\n\t}\n\tif(memo[src][dst]){\n\t\treturn;\n\t}\n\tmemo[src][dst] = memo[dst][src] = true;\n\tused[dst] = true;\n\tfor(int i = 0; i < li[dst].size(); i++){\n\t\tint cost = li[dst][i].first;\n\t\tint from = li[dst][i].second;\n\t\tif(dist[src][from] + cost == dist[src][dst]){\n\t\t\tused[from] = true;\n\t\t\trunning(src,from);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&N,&R);\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d%d%d\",&s,&t,&d);\n\t\tli[s].push_back(make_pair(d,t));\n\t\tli[t].push_back(make_pair(d,s));\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tdist[i][j] = i == j ? 0 : INF;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tdijkstra(i);\n\t}\n\n\tint mxdist = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = i+1; j <= N; j++){\n\t\t\tmxdist = max(mxdist,dist[i][j]);\n\t\t}\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = i+1; j <= N; j++){\n\t\t\tif(dist[i][j] == mxdist){\n\t\t\t\tcourse.push_back(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < course.size(); i++){\n\t\trunning(course[i].first,course[i].second);\n\t}\n\n\tint cnt = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(!used[i]){\n\t\t\tcnt++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cnt);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(!used[i]){\n\t\t\tprintf(\"%d\\n\",i);\t\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n int N,M;\nint D[1500][1500];\nvpint G[1500];\n\nbool ng[1500];\n\nsigned main(){\n    cin>>N>>M;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        G[a].pb({b,c});\n        G[b].pb({a,c});\n    }\n\n    rep(i,N){\n        fill_n(D[i],N,INF);\n        D[i][i]=0;\n        priority_queue<pint,vector<pint>,greater<pint>>que;\n        que.push({0,i});\n        while(que.size()){\n            int c,v;\n            tie(c,v)=que.top();\n            que.pop();\n            if(D[i][v]<c)continue;\n            for(auto &e:G[v]){\n                if(D[i][e.fi]<=c+e.se)continue;\n                D[i][e.fi]=c+e.se;\n                que.push({c+e.se,e.fi});\n            }\n        }\n    }\n\n    int len=0;\n    rep(i,N)rep(j,N)chmax(len,D[i][j]);\n\n\n    rep(i,N){\n        bool used[1500]={};\n        queue<int>que;\n        rep(j,N)if(D[i][j]==len){\n            used[j]=true;\n            que.push(j);\n        }\n        while(que.size()){\n            int v=que.front();\n            que.pop();\n            for(auto &e:G[v]){\n                if(D[i][e.fi]+e.se==D[i][v]&&!used[e.fi]){\n                    used[e.fi]=true;\n                    que.push(e.fi);\n                }\n            }\n        }\n        rep(j,N)ng[j]|=used[j];\n    }\n\n    vint ans;\n    rep(i,N)if(!ng[i])ans.pb(i);\n    cout<<ans.size()<<endl;\n    rep(i,ans.size())cout<<ans[i]+1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dist[2000];set<int>p[2000];\nvector<pair<int,int>> vec[2000];\nint n,m;\nbool used2[2000];\nset<int>R[2000][2000];\nint dst[2000][2000];\nvector<int>shor[2000];\nvoid dijkstra(int s){\n\tfor(int i=0;i<2000;i++){dist[i]=999999999;p[i].clear();}\n\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>Q;\n\tQ.push(make_pair(0,s));dist[s]=0;\n\twhile(!Q.empty()){\n\t\tint a1=Q.top().first,a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<(int)vec[a2].size();i++){\n\t\t\tint to=vec[a2][i].first,cost=vec[a2][i].second;\n\t\t\tif(dist[to]>a1+cost){\n\t\t\t\tp[to].clear();p[to].insert(a2);\n\t\t\t\tdist[to]=a1+cost;\n\t\t\t\tQ.push(make_pair(dist[to],to));\n\t\t\t}\n\t\t\tif(dist[to]==a1+cost && p[to].count(a2)==0){\n\t\t\t\tp[to].insert(a2);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<2000;i++){\n\t\tdst[s][i]=dist[i];\n\t\tR[s][i]=p[i];\n\t}\n}\nvoid solve(int s){\n\tqueue<int>Q;\n\tbool used[2000];for(int i=0;i<2000;i++)used[i]=false;\n\tfor(int i=0;i<(int)shor[s].size();i++){Q.push(shor[s][i]);used[shor[s][i]]=true;}\n\twhile(!Q.empty()){\n\t\tint a1=Q.front();Q.pop();\n\t\t\n\t\tfor(auto a2 : R[a1]){\n\t\t\tif(used[a2]==false){used[a2]=true;Q.push(a2);}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){if(used[i]==true)used2[i]=true;}\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\tvec[a].push_back(make_pair(b,c));\n\t\tvec[b].push_back(make_pair(a,c));\n\t}\n\tfor(int i=1;i<=n;i++)dijkstra(i);\n\tint maxn=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tmaxn=max(maxn,dst[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(dst[i][j]==maxn)shor[i].push_back(j);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)solve(i);\n\tint num=0;\n\tfor(int i=1;i<=n;i++){if(used2[i]==false)num++;}\n\tcout<<num<<endl;\n\tfor(int i=1;i<=n;i++){if(used2[i]==false)cout<<i<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n// clang-format on\n/* }}} */\n\nstruct Edge {\n  Edge() {}\n  Edge(int a, int b) { to = a; cost = b; }\n  int to, cost;\n};\nint N, R;\nvector<Edge> G[1500];\nvi Gprev[1500][1500];\nmap<int, bool> chie;\n\nvoid dijkstra(int s, vi &d) {\n  minPQ<pii> q;\n  d[s] = 0;\n  q.emplace(0, s);\n\n  while (q.size()) {\n    auto p = q.top(); q.pop();\n    int v = p.Se;\n    if (d[v] < p.Fi) continue;\n    EACH(e, G[v]) {\n      if (d[e.to] == d[v] + e.cost) {\n        Gprev[s][e.to].eb(v);\n        q.emplace(d[e.to], e.to);\n      } else if (d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        Gprev[s][e.to] = vi();\n        Gprev[s][e.to].eb(v);\n        q.emplace(d[e.to], e.to);\n      }\n    }\n  }\n}\n\nvoid bfs(int s, int t) {\n  queue<int> q;\n  q.emplace(s);\n  bool vis[1500] = {};\n  while (q.size()) {\n    int p = q.front(); q.pop();\n    if (vis[p]) continue;\n    chie[p] = true;\n    vis[p] = true;\n    EACH(e, Gprev[t][p]) {\n      q.emplace(e);\n    }\n  }\n}\n\nsigned main() {\n  cin >> N >> R;\n  vvi d(N, vi(N, INF));\n  REP(i, R) {\n    int s = in() - 1, t = in() - 1, d = in();\n    G[s].eb(t, d);\n    G[t].eb(s, d);\n  }\n  REP(i, N) dijkstra(i, d[i]);\n\n  int ma = 0;\n  REP(i, N) REP(j, N) chmax(ma, d[i][j]);\n\n  REP(i, N) REP(j, N) {\n    if (ma == d[i][j]) {\n      bfs(j, i);\n    }\n  }\n\n  print(N - chie.size());\n  REP(i, N) {\n    if (!chie[i]) print(i + 1);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nvector<P> G[100005];\nbool flag[100005];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N,R; cin >> N >> R;\n\n    for (int i = 0;i < R;i++){\n        ll a,b,d;\n        cin >> a >> b >> d;\n        G[a].push_back(P(b,d));\n        G[b].push_back(P(a,d));\n    }\n\n    vector<vector<ll> > d(N+1,vector<ll>(N+1,INT_MAX));\n\n    ll ma = 0;\n\n    for (int i = 1;i <= N;i++){\n        priority_queue<P,vector<P>, greater<P> > que; \n        que.push(P(0,i));\n        for (int j = 1;j <= N;j++){\n            d[i][j] = INT_MAX;\n        }\n        d[i][i] = 0;\n        while(que.size()){\n            P p = que.top(); que.pop();\n            ll now = p.second;\n            ll sum = p.first;\n            if(sum > d[i][now]) continue;\n            for (int j = 0;j < G[now].size();j++){\n                ll to = G[now][j].first;\n                ll l = G[now][j].second;\n                //cout << now << \" \" << to << \" \" << sum  << \" \" << l << \" \" << d[to] << endl;\n                if(d[i][to] > sum+l){\n                    d[i][to] = sum+l;\n                    que.push(P(d[i][to],to));\n                }\n            }\n        }\n        for (int j = i;j <= N;j++){\n            ma = max(d[i][j],ma);\n        }\n        //cout << i << \" \" << ma << endl;\n    }\n\n    vector<ll> mp[10005];\n\n    for (int i = 1;i <= N;i++){\n        for (int j = i;j <= N;j++){\n            if(d[i][j] == ma){ mp[i].push_back(j);}\n        }\n    }\n\n    for (int i = 1;i <= N;i++){\n        ll from = i;\n        queue<ll> que;\n        bool used[10005];\n        memset(used,0,sizeof(used));\n        for (int j = 0;j < mp[i].size();j++){\n            que.push(mp[i][j]);\n            used[mp[i][j]] = true;\n            flag[mp[i][j]] = true;\n        }\n        while(que.size()){\n            ll now = que.front(); que.pop();\n            for (int j = 0;j < G[now].size();j++){\n                ll nex = G[now][j].first;\n                ll cos = G[now][j].second;\n                if(!used[nex] && (d[from][nex]+cos == d[from][now])){\n                    used[nex] = true;\n                    flag[nex] = true;\n                    que.push(nex);\n                }\n            }\n        }\n    }\n\n    ll M = 0;\n    vector<ll> ans;\n    for (int i = 1;i <= N;i++){\n        if(!flag[i]){\n            M++;\n            ans.push_back(i);\n        } \n    }\n\n    cout << M << endl;\n\n    for (int i = 0;i < ans.size();i++){\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  while(1) {\n    mp[j] = 1;\n    if(j == i) break;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        j = e.to;\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <limits>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct edge {\n\tint to, cost;\n\tedge(int to_, int cost_) : to(to_), cost(cost_) {};\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\ntemplate<class Type>\nstd::vector<Type> shortest_path(std::vector<std::vector<edge> > &G, int s) {\n\tstd::priority_queue<edge> que; que.push(edge(s, 0));\n\tstd::vector<Type> ret(G.size(), std::numeric_limits<Type>::max()); ret[s] = 0;\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tif (ret[e.to] > ret[u.to] + e.cost) {\n\t\t\t\tret[e.to] = ret[u.to] + e.cost;\n\t\t\t\tque.push(edge(e.to, -ret[e.to]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nstd::vector<vector<int> > shortest_path_tree_all(std::vector<std::vector<edge> > &G, int s) {\n\tstd::priority_queue<edge> que; que.push(edge(s, 0));\n\tstd::vector<long long> ret(G.size(), std::numeric_limits<long long>::max()); ret[s] = 0;\n\tvector<vector<int> > res(G.size());\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tif (ret[e.to] > ret[u.to] + e.cost) {\n\t\t\t\tret[e.to] = ret[u.to] + e.cost;\n\t\t\t\tres[e.to].clear();\n\t\t\t\tque.push(edge(e.to, -ret[e.to]));\n\t\t\t}\n\t\t\tif (ret[e.to] == ret[u.to] + e.cost) {\n\t\t\t\tres[e.to].push_back(u.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint n, m, a, b, c;\nint main() {\n\tcin >> n >> m;\n\tvector<vector<edge> > G(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b >> c; a--, b--;\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, c));\n\t}\n\tvector<vector<int> > d(n);\n\tfor (int i = 0; i < n; i++) d[i] = shortest_path<int>(G, i);\n\tint x = -1;\n\tvector<vector<int> > p;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (d[i][j] > x) x = d[i][j];\n\t\t\tif (d[i][j] == x) p.push_back({ i, j });\n\t\t}\n\t}\n\tvector<bool> ret(n, false);\n\tfor (vector<int> g : p) {\n\t\tvector<vector<int> > f = shortest_path_tree_all(G, g[0]);\n\t\tqueue<int> que; que.push(g[1]);\n\t\tvector<bool> vis(n, false); vis[g[1]] = true;\n\t\twhile (!que.empty()) {\n\t\t\tint u = que.front(); que.pop();\n\t\t\tfor (int i : f[u]) {\n\t\t\t\tif (!vis[i]) {\n\t\t\t\t\tvis[i] = true;\n\t\t\t\t\tret[i] = true;\n\t\t\t\t\tque.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!ret[i]) cnt++;\n\t}\n\tcout << cnt << endl;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!ret[i]) cout << i + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501], done[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  while(1) {\n    mp[j] = 1;\n    if(j == i) break;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        j = e.to;\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) fill(d[i], d[i] + n, 114514);\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n    rep(j, 1, n + 1) {\n      d[j][i] = d[i][j];\n    }\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(!done[i][j] && mas == d[i][j]) {\n        solve(i, j);\n        done[j][i] = 0;\n      }\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1 ) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nconst int LIM = 1.5e3 + 5;\n\nstruct data { int x, d; };\nbool operator < (data a, data b) { return a.d > b.d; }\n\nint n, m, dis[LIM][LIM], max, ans;\nstd::vector<data> edg[LIM];\nbool chk[LIM], vis[LIM];\nstd::priority_queue<data> q;\n\nvoid dijkstra(int s, int *dis)\n{\n\tq.push({s, 0});\n\twhile (!q.empty())\n\t{\n\t\tdata x = q.top(); q.pop();\n\t\tif (!vis[x.x])\n\t\t{\n\t\t\tvis[x.x] = true;\n\t\t\tdis[x.x] = x.d;\n\t\t\tfor (data y : edg[x.x])\n\t\t\t\tif (!vis[y.x])\n\t\t\t\t\tq.push({y.x, x.d + y.d});\n\t\t}\n\t}\n}\n\nvoid trace(int x, int *dis)\n{\n\tvis[x] = true;\n\tif (!chk[x]) { --ans; chk[x] = true; }\n\tfor (data y : edg[x])\n\t\tif (!vis[y.x] && dis[y.x] == dis[x] - y.d)\n\t\t\ttrace(y.x, dis);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\twhile (m--)\n\t{\n\t\tint u, v, d; scanf(\"%d%d%d\", &u, &v, &d);\n\t\tedg[u].push_back({v, d});\n\t\tedg[v].push_back({u, d});\n\t}\n\t\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tmemset(vis, 0x00, sizeof(vis));\n\t\tdijkstra(i, dis[i]);\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tmax = std::max(max, dis[i][j]);\n\t}\n\t\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tmemset(vis, 0x00, sizeof(vis));\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (dis[i][j] == max)\n\t\t\t\ttrace(j, dis[i]);\n\t}\n\t\n\tprintf(\"%d\\n\", ans + n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!chk[i]) printf(\"%d\\n\", i);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <limits>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct edge {\n\tint to, cost;\n\tedge(int to_, int cost_) : to(to_), cost(cost_) {};\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\ntemplate<class Type>\nstd::vector<Type> shortest_path(std::vector<std::vector<edge> > &G, int s) {\n\tstd::priority_queue<edge> que; que.push(edge(s, 0));\n\tstd::vector<Type> ret(G.size(), std::numeric_limits<Type>::max()); ret[s] = 0;\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tif (ret[e.to] > ret[u.to] + e.cost) {\n\t\t\t\tret[e.to] = ret[u.to] + e.cost;\n\t\t\t\tque.push(edge(e.to, -ret[e.to]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nstd::vector<vector<int> > shortest_path_tree_all(std::vector<std::vector<edge> > &G, int s) {\n\tstd::priority_queue<edge> que; que.push(edge(s, 0));\n\tstd::vector<long long> ret(G.size(), std::numeric_limits<long long>::max()); ret[s] = 0;\n\tvector<vector<int> > res(G.size());\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tif (ret[e.to] > ret[u.to] + e.cost) {\n\t\t\t\tret[e.to] = ret[u.to] + e.cost;\n\t\t\t\tres[e.to].clear();\n\t\t\t\tque.push(edge(e.to, -ret[e.to]));\n\t\t\t}\n\t\t\tif (ret[e.to] == ret[u.to] + e.cost) {\n\t\t\t\tres[e.to].push_back(u.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint n, m, a, b, c;\nint main() {\n\tcin >> n >> m;\n\tvector<vector<edge> > G(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b >> c; a--, b--;\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, c));\n\t}\n\tvector<vector<int> > d(n);\n\tfor (int i = 0; i < n; i++) d[i] = shortest_path<int>(G, i);\n\tint x = -1;\n\tvector<vector<int> > p;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (d[i][j] > x) x = d[i][j], p.clear();\n\t\t\tif (d[i][j] == x) p.push_back({ i, j });\n\t\t}\n\t}\n\tvector<bool> ret(n, false);\n\tfor (vector<int> g : p) {\n\t\tvector<vector<int> > f = shortest_path_tree_all(G, g[0]);\n\t\tqueue<int> que; que.push(g[1]);\n\t\tvector<bool> vis(n, false); vis[g[1]] = true; ret[g[1]] = true;\n\t\twhile (!que.empty()) {\n\t\t\tint u = que.front(); que.pop();\n\t\t\tfor (int i : f[u]) {\n\t\t\t\tif (!vis[i]) {\n\t\t\t\t\tvis[i] = true;\n\t\t\t\t\tret[i] = true;\n\t\t\t\t\tque.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!ret[i]) cnt++;\n\t}\n\tcout << cnt << endl;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!ret[i]) cout << i + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nstruct edge{int to,cost;};\n\nconst int N = 1500;\nconst int INF = 19191919;\nvector<edge> G[N];\n\nint n;\nint d[N][N];\nbool can[N];\n\nvoid dijkstra(int s)\n{\n    d[s][s] = 0;\n    priority_queue<pi,vector<pi>,greater<pi>> pq;\n    pq.push({0,s});\n    while(!pq.empty())\n    {\n        pi now = pq.top();\n        pq.pop();\n        int v = now.se;\n        if(now.fi>d[s][v]) continue;\n        for(const auto &e:G[v])\n        {\n            if(d[s][e.to] > d[s][v]+e.cost)\n            {\n                d[s][e.to] = d[s][v]+e.cost;\n                pq.push({d[s][e.to],e.to});\n            }\n        }\n    }\n}\n\nvoid check(int s, int D)\n{\n    queue<int> que;\n    vector<bool> vis(n);\n\n    rep(i,n)if(d[s][i]==D)\n    {\n        que.push(i);\n        vis[i] = true;\n    }\n\n    while(!que.empty())\n    {\n        int v = que.front();\n        que.pop();\n        vis[v] = true;\n        can[v] = false;\n\n        for(const auto &e:G[v])\n        {\n            if(!vis[e.to] && d[s][e.to]==d[s][v]-e.cost)\n            {\n                vis[e.to] = true;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint main()\n{\n    int r;\n    cin >>n >>r;\n    while(r--)\n    {\n        int s,t,w;\n        cin >>s >>t >>w;\n        --s; --t;\n        G[s].pb({t,w});\n        G[t].pb({s,w});\n    }\n\n    fill(d[0],d[N],INF);\n    fill(can,can+N,true);\n    rep(i,n) dijkstra(i);\n\n    int max_d = 0;\n    rep(i,n)rep(j,n) max_d = max(max_d,d[i][j]);\n\n    rep(i,n) check(i,max_d);\n\n    vector<int> ans;\n    rep(i,n)if(can[i]) ans.pb(i);\n\n    cout << ans.size() << endl;\n    for(const int &i:ans) cout << i+1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, M;\nvector<P> G[1500];\nint D[1500][1500];\nvoid dijkstra(int s) {\n  int *dist = D[s];\n  priority_queue<P, vector<P>, greater<P> > q;\n  dist[s] = 0;\n  q.push(P(0, s));\n  while (!q.empty()) {\n    int x = q.top()._2,\n        r = q.top()._1;\n    q.pop();\n    if (dist[x] < r) continue;\n\n    for (P p : G[x]) {\n      int t = p._1, l = p._2;\n      if (dist[t] > r+l) {\n        dist[t] = r+l;\n        q.push(P(r+l, t));\n      }\n    }\n  }\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M;\n  rep(i, M) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    s--, t--;\n    G[s].pb(P(t, d));\n    G[t].pb(P(s, d));\n  }\n  rep(i, N) rep(j, N) D[i][j] = INF;\n  rep(i, N) dijkstra(i);\n  int R = 0;\n  rep(i, N) rep(j, N) R = max(R, D[i][j]);\n\n  vector<int> ans;\n  rep(i, N) {\n    vector<int> rs;\n    map<int, vector<int > > vs;\n    rep(j, N) rs.pb(D[i][j]), vs[D[i][j]].pb(j);\n    sort(all(rs)); uniq(rs);\n    //for (int x:rs)cout<<x<<\",\";cout<<\" i=\"<<i<<\"\\n\";\n    bool ok = true;\n    for (int x : rs) {\n      if (binary_search(all(rs), R-x)) {\n        for (int s : vs[x]) {\n          for (int t : vs[R-x]) {\n            if (D[s][t] == R) {\n              ok = false;\n              break;\n            }\n          }\n        }\n      }\n    }\n    if (ok) ans.pb(i);\n  }\n  cout << ans.size() << \"\\n\";\n  for (int x : ans) cout << x+1 << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nconst int INF = 1 << 29;\n\nint N, R;\nint A[3000], B[3000], D[3000];\nint cost[1500][1500];\nbool used[1500], v[1500];\nvector< int > g[1500];\n\nvoid dfs(int idx, int *dist)\n{\n  if(v[idx]++) return;\n  used[idx]++;\n  for(auto &i : g[idx]) {\n    if(A[i] == idx && dist[B[i]] + D[i] == dist[idx]) dfs(B[i], dist);\n    if(B[i] == idx && dist[A[i]] + D[i] == dist[idx]) dfs(A[i], dist);\n  }\n}\n\nint main()\n{\n  fill_n(*cost, 1500 * 1500, INF);\n  rep(i, 1500) cost[i][i] = 0;\n\n  cin >> N >> R;\n  rep(i, R) {\n    cin >> A[i] >> B[i] >> D[i];\n    --A[i], --B[i];\n    cost[A[i]][B[i]] = cost[B[i]][A[i]] = D[i];\n    g[A[i]].push_back(i);\n    g[B[i]].push_back(i);\n  }\n  rep(i, N) rep(j, N) rep(k, N) cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\n  int ret = 0;\n  rep(i, N) rep(j, N) if(cost[i][j] != INF) ret = max(ret, cost[i][j]);\n\n  rep(i, N) rep(j, N) {\n      memset(v, false, sizeof(v));\n      if(cost[i][j] == ret) dfs(j, cost[i]);\n    }\n  cout << count(used, used + N, false) << endl;\n  rep(i, N) if(!used[i]) cout << i + 1 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nint mp[1501];\nint mmp[1501][1501];\n\ninline void dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      if(d[s][g[v][i].to] > d[s][v] + g[v][i].cost) {\n        d[s][g[v][i].to] = d[s][v] + g[v][i].cost;\n        que.push(P(d[s][g[v][i].to], g[v][i].to));\n      }\n    }\n  }\n}\n\ninline void solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mmp[i][tp] = 1;\n    rep(k, 0, g[tp].size()) {\n      if(d[i][tp] == d[i][g[tp][k].to] + g[tp][k].cost && !mmp[i][g[tp][k].to]) {\n        st.push(g[tp][k].to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) {\n        mp[i] = 1;\n        solve(i, j);\n      }\n    }\n  }\n  rep(i, 0, n + 1) {\n    rep(j, 0, n + 1) {\n      if(mmp[i][j]) mp[j] = 1;\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200005;\n\nint n, w, h;\nint val[N], res[N];\n\nstruct Ant {\n\tint x, y, id; \n\tchar t;\n\n\tvoid debug() {\n\t\tcout << x << ' ' << y << ' ' << t << '\\n';\n\t}\n} a[N];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i].x >> a[i].y >> a[i].t, a[i].id = i;\n\t\tif (a[i].t == 'E') val[i] = w - a[i].x;\n\t\telse val[i] = h - a[i].y;\n\t}\n\tsort(a, a + n, [&] (Ant p, Ant q) {\n\t\treturn p.x + p.y < q.x + q.y;\n\t});\n\tfor (int i = 0; i < n; ++i) {\n\t\tvector<Ant> go[2];\n\t\tint j = i;\n\t\twhile (i < n && a[j].x + a[j].y == a[i].x + a[i].y) {\n\t\t\tif (a[i].t == 'E') {\n\t\t\t\tgo[a[i].y & 1].push_back(a[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgo[a[i].x & 1].push_back(a[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tsort(go[j].begin(), go[j].end(), [&] (Ant p, Ant q) {\n\t\t\t\treturn p.x == q.x ? p.t < q.t : p.x < q.x;\n\t\t\t});\n\t\t\tvector<Ant> vec;\n\t\t\tfor (auto k : go[j]) {\n\t\t\t\tif (k.t == 'E') {\n\t\t\t\t\tk.x = w + 1, vec.push_back(k);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk.y = h + 1, vec.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec.begin(), vec.end(), [&] (Ant p, Ant q) {\n\t\t\t\treturn p.x == q.x ? p.y < q.y : p.x < q.x;\n\t\t\t});\n\t\t\tfor (int k = 0; k < vec.size(); ++k) {\n\t\t\t\tres[go[j][k].id] = val[vec[k].id];\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n\tvector<int> p;\n\tfor (int i = 0; i < n; ++i) p.push_back(i);\n\tsort(p.begin(), p.end(), [&] (int x, int y) {\n\t\treturn res[x] == res[y] ? x < y : res[x] < res[y];\n\t});\n\tfor (auto i : p) cout << i + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0351\n\n#include<bits/stdc++.h>\nconst int N = 1505;\nconst int inf = 1e9;\nusing namespace std;\n\ntypedef pair <int, int> ii;\nvector <ii> adj[N];\nint n, m, d[N][N], ans, visit[N], f[N], ck[N];\n\nvoid dijkstra(int S){\n    for (int i = 1; i <= n; i++) d[S][i] = inf; d[S][S] = 0;\n    priority_queue <ii, vector <ii>, greater<ii> > mq; mq.push(ii(d[S][S], S));\n    while (mq.size()){\n        ii z = mq.top(); mq.pop();\n        int u = z.second, val = z.first;\n        if (val != d[S][u]) continue;\n        ans = max(ans, val);\n        for (int i = 0; i < adj[u].size(); i++){\n            int v = adj[u][i].first, cost = adj[u][i].second;\n            if (d[S][v] > d[S][u] + cost){\n                d[S][v] = d[S][u] + cost;\n                mq.push(ii(d[S][v], v));\n            }\n        }\n    }\n}\n\nvoid dfs(int u, int root){\n    if (visit[u]) return;\n    visit[u] = true;\n    f[u] = d[root][u];\n    for (int i = 0; i < adj[u].size(); i++){\n        int v = adj[u][i].first, cost = adj[u][i].second;\n        if (d[root][v] == d[root][u] + cost){\n            dfs(v, root); f[u] = max(f[u], f[v]);\n        }\n    }\n    if (f[u] == ans) ck[u] = 1;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++){\n        int u, v, d; cin >> u >> v >> d;\n        adj[u].push_back(ii(v, d));\n        adj[v].push_back(ii(u, d));\n    }\n    for (int i = 1; i <= n; i++) dijkstra(i);\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++) visit[j] = 0;\n        dfs(i, i);\n    }\n    int cnt = 0; for (int i = 1; i <= n; i++) if (!ck[i]) cnt++;\n    cout << cnt << \"\\n\";\n    for (int i = 1; i <= n; i++) if (!ck[i]) cout << i << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 3100\n\n/* Dijkstra O(NlogM)*/\n\nstruct Dijkstra{\n\n  typedef int Type;\n\n  int V;\n  vector<vector<pair<int,Type> > > G;\n  vector<int> cost;\n  \n  Dijkstra(int n):\n    V(n),G(n,vector<pair<int,Type> >()){}\n  \n  void add_edge(int u, int v, Type c){\n    G[u].push_back({v,c});\n  }\n  \n  Type solve(int s, int g = -1){\n    cost.assign(V,-1);\n    priority_queue<pair<Type,int> > pq;\n    Type max_cost = 0;\n    \n    pq.push({0,s});\n\n    while(pq.size()){\n      Type now_cost = pq.top().first;\n      int now = pq.top().second;\n      pq.pop();\n\n      if(cost[now] >= 0) continue;\n      \n      cost[now] = -now_cost;\n      max_cost = max(max_cost, -now_cost);\n      \n      if(now == g) return -now_cost;\n      \n      for(int i=0;i<(int)G[now].size();i++){\n        pq.push({now_cost-G[now][i].second, G[now][i].first});\n      }\n    }\n        \n    return max_cost;\n  }\n  \n};\n\n\nint main(){\n  int n,r;\n  int s[SIZE],t[SIZE],d[SIZE];\n  bool ans[SIZE] = {};\n  \n  scanf(\"%d%d\",&n,&r);\n\n  Dijkstra dij(n);\n  \n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",s+i,t+i,d+i);\n    s[i]--; t[i]--;\n    \n    dij.add_edge(t[i],s[i],d[i]);\n    dij.add_edge(s[i],t[i],d[i]);\n  }\n\n  int ans_dis = 0;\n  \n  for(int i=0;i<n;i++){\n    int max_dis = dij.solve(i);\n\n    if(max_dis > ans_dis){\n      for(int j=0;j<n;j++) ans[j] = false;\n      ans_dis = max_dis;\n    }\n\n    if(max_dis < ans_dis) continue;\n    \n    queue<int> que;\n    bool visited[SIZE] = {};\n    \n    for(int j=0;j<n;j++){\n      if(max_dis == dij.cost[j]){\n        que.push(j);\n      }\n    }\n\n    while(que.size()){\n      int p = que.front();\n      que.pop();\n      \n      if(visited[p]) continue;\n      visited[p] = true;\n      ans[p] = true;\n      \n      for(int j=0;j<dij.G[p].size();j++){\n        if(dij.cost[p] - dij.G[p][j].second == dij.cost[dij.G[p][j].first]){\n          que.push(dij.G[p][j].first);\n        }\n      }\n    }\n  }\n\n  int ans_count = 0;\n  for(int i=0;i<n;i++) ans_count += ans[i] == false;\n\n  printf(\"%d\\n\",ans_count);\n  \n  for(int i=0;i<n;i++){\n    if(ans[i] == false){\n      printf(\"%d\\n\",i+1);\n    }\n  }\n  \n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nvector< vector<edge> > graph;\nvector< vector<int> > mincost;\n\nvoid dijkstra(int s)\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  mincost[s][s] = 0;\n  while(!que.empty()) {\n    int cost, now;\n    tie(cost, now) = que.top(); que.pop();\n    if(mincost[s][now] < cost) continue;\n    for(edge& e : graph[now]) {\n      if(e.cost + cost < mincost[s][e.to]) {\n\tmincost[s][e.to] = e.cost + cost;\n\tque.push(P(mincost[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, R;\n  cin >> N >> R;\n  graph.resize(N);\n  rep(i, R) {\n    int s, t, d;\n    cin >> s >> t >> d; s--, t--;\n    graph[s].emplace_back(t, d);\n    graph[t].emplace_back(s, d);\n  }\n\n  mincost.resize(N, vector<int>(N, inf));\n  int maxdist = 0;\n  rep(i, N) dijkstra(i);\n  rep(i, N) reps(j, i+1, N) maxdist = max(maxdist, mincost[i][j]);\n\n  vector<P> ep;\n  rep(i, N) reps(j, i+1, N) {\n    if(mincost[i][j] == maxdist) ep.emplace_back(i, j);\n  }\n\n  vector<int> ans;\n  rep(i, N) {\n    bool flag = true;\n    for(auto& p : ep) {\n      int s, t; tie(s, t) = p;\n      if(mincost[s][i] + mincost[i][t] == maxdist) flag = false;\n    }\n    if(flag) ans.push_back(i+1);\n  }\n  \n  cout << ans.size() << endl;\n  rep(i, ans.size()) cout << ans[i] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  while(1) {\n    mp[j] = 1;\n    if(j == i) break;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        j = e.to;\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  int done[1501][1501] = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(!done[i][j] && mas == d[i][j]) {\n        solve(i, j);\n        done[j][i] = 1;\n      }\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1 ) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define Link \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0351\"\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n\n#define TASK \"Quiet Town\"\n\nusing namespace std;\n\nvoid OpenFile()\n{\n    freopen(TASK\".INP\",\"r\",stdin);\n    freopen(TASK\".OUT\",\"w\",stdout);\n}\n\nconst int oo = 1e9 + 1;\nconst int maxn = 15e2 + 1;\nint n,r,d[maxn][maxn];\nvector <pair<int,int> > e[maxn];\npriority_queue <pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq;\nbool b[maxn],chose[maxn];\n\nvoid Enter()\n{\n    cin >> n >> r;\n    for (int i=1;i<=r;++i) {\n        int u,v,w;\n        cin >> u >> v >> w;\n        e[u].push_back({w,v});\n        e[v].push_back({w,u});\n    }\n}\n\nvoid Dijkstra(int s)\n{\n    fill(d[s],d[s]+n+1,+oo);\n    d[s][s] = 0;\n    pq.push({0,s});\n    while (!pq.empty()) {\n        int D = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n        if (D != d[s][u])\n            break;\n        for (auto p : e[u]) {\n            int w = p.first;\n            int v = p.second;\n            if (d[s][v] > d[s][u] + w) {\n                d[s][v] = d[s][u] + w;\n                pq.push({d[s][v],v});\n            }\n        }\n    }\n}\n\nvoid Init()\n{\n    for (int s=1;s<=n;++s)\n        Dijkstra(s);\n}\n\nvoid DFS(int t, int s)\n{\n    if (b[t])\n        return;\n    b[t] = 1;\n    for (auto p : e[t]) {\n        int w = p.first;\n        int v = p.second;\n        if (d[s][v] + w == d[s][t])\n            DFS(v,s);\n    }\n}\n\nvoid Print()\n{\n    int cnt = 0;\n    for (int i=1;i<=n;++i)\n        if (!chose[i])\n            ++cnt;\n    cout << cnt << '\\n';\n    for (int i=1;i<=n;++i)\n        if (!chose[i])\n            cout << i << '\\n';\n}\n\nvoid Solve()\n{\n    int mx = -oo;\n    for (int s=1;s<=n;++s)\n        for (int t=1;t<=n;++t)\n            if (d[s][t] != +oo)\n                mx = max(mx,d[s][t]);\n    for (int s=1;s<=n;++s) {\n        fill(b,b+n+1,0);\n        for (int t=1;t<=n;++t)\n            if (mx == d[s][t])\n                DFS(t,s);\n        for (int i=1;i<=n;++i)\n            chose[i] |= b[i];\n    }\n    Print();\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    OpenFile();\n\n    Enter();\n    Init();\n    Solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nconst int INF = 1 << 29;\n\nint main()\n{\n  int N, R, A[1500], B[1500], D[1500];\n  int cost[1500][1500];\n  bool edge[1500][1500] = {{}};\n  fill_n(*cost, 1500 * 1500, INF);\n  rep(i, 1500) cost[i][i] = 0;\n\n  cin >> N >> R;\n  rep(i, R) {\n    cin >> A[i] >> B[i] >> D[i];\n    --A[i], --B[i];\n    cost[A[i]][B[i]] = D[i];\n    cost[B[i]][A[i]] = D[i];\n  }\n  rep(i, N) rep(j, N) rep(k, N) cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n  int ret = 0;\n  rep(i, N) rep(j, N) if(cost[i][j] != INF) ret = max(ret, cost[i][j]);\n\n  int cnt = 0;\n  bool used[1500] = {};\n  rep(i, N) rep(j, N) {\n      if(cost[i][j] == ret) {\n        rep(k, N) if(cost[i][k] + cost[k][j] == ret) used[k] = true;\n      }\n    }\n\n  cout << count(used, used + N, false) << endl;\n  rep(i, N) if(!used[i]) cout << i + 1 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  using Edge = pair<int, int>;\n  using Graph = vector<vector<Edge>>;\n\n  int N, M;\n  cin >> N >> M;\n\n  Graph G(N);\n  for(auto i = 0; i < M; ++i) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    --s, --t;\n    G[s].emplace_back(t, d);\n    G[t].emplace_back(s, d);\n  }\n\n  // Djikstra\n  vector<int> m(N, -1);\n  vector<vector<int>> d(N, vector<int>(N, -1));\n  vector<vector<vector<int>>> p(N, vector<vector<int>>(N));\n\n  for(auto i = 0; i < N; ++i) {\n    using Node = tuple<int, int, int>;\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    q.emplace(0, i, i);\n\n    while(!q.empty()) {\n      int cost, cur, pre;\n      tie(cost, cur, pre) = q.top();\n      q.pop();\n\n      if(d[i][cur] != -1) continue;\n      m[i] = max(m[i], cost);\n      d[i][cur] = cost;\n      p[i][cur] = {pre};\n\n      for(auto e: G[cur]) {\n        auto nex = e.first;\n        auto c = cost + e.second;\n        if(d[i][nex] == c) p[i][nex].emplace_back(cur);\n        if(d[i][nex] == -1) q.emplace(c, nex, cur);\n      }\n    }\n  }\n\n  // BFS\n  vector<bool> use(N);\n  auto D = *max_element(begin(m), end(m));\n\n  for(auto i = 0; i < N; ++i) {\n    vector<bool> visited(N);\n    queue<int> q;\n    for(auto v = 0; v < N; ++v) if(d[i][v] == D) q.emplace(v);\n\n    while(!q.empty()) {\n      auto cur = q.front();\n      q.pop();\n\n      if(visited[cur]) continue;\n      visited[cur] = true;\n\n      for(auto nex: p[i][cur]) if(!visited[nex]) q.emplace(nex);\n    }\n\n    for(auto v = 0; v < N; ++v) if(visited[v]) use[v] = true;\n  }\n\n  vector<int> ans;\n  for(auto i = 0; i < N; ++i) if(!use[i]) ans.emplace_back(i + 1);\n  cout << ans.size() << endl;\n  for(auto i: ans) cout << i << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_town,int arg_cost){\n\t\ttown = arg_town;\n\t\tcost = arg_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn cost > arg.cost;\n\t};\n\tint town,cost;\n};\n\nstruct Dist{\n\tDist(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Data{\n\tData(int arg_start,int arg_goal){\n\t\tstart = arg_start;\n\t\tgoal = arg_goal;\n\t}\n\tint start,goal;\n};\n\nint main(){\n\n\tint N,R,s,t,d;\n\tscanf(\"%d %d\",&N,&R);\n\n\tvector<Dist> V[N+1];\n\tint** MIN_COST = new int*[N+1];\n\tfor(int i = 1; i <= N; i++){\n\t\tMIN_COST[i] = new int[N+1];\n\t\tfor(int k = 1; k <= N; k++)MIN_COST[i][k] = BIG_NUM; //??????????????????????????¨??????????????????\n\t}\n\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d %d %d\",&s,&t,&d);\n\t\tV[s].push_back(Dist(t,d));\n\t\tV[t].push_back(Dist(s,d));\n\t}\n\n\tint maximum = -1,min_index;\n\tstack<Data> S;\n\tpriority_queue<Info> Q;\n\n\tfor(int from = 1; from <= N-1;from++){\n\t\tfor(int to = from+1; to <= N; to++){\n\n\t\t\tfor(int i = 0; i < V[from].size();i++){\n\t\t\t\tMIN_COST[from][V[from][i].to] = V[from][i].cost;\n\t\t\t\tQ.push(Info(V[from][i].to,V[from][i].cost));\n\t\t\t}\n\n\t\t\twhile(!Q.empty()){\n\t\t\t\tif(Q.top().cost > MIN_COST[from][Q.top().town]){\n\t\t\t\t\tQ.pop();\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tmin_index = Q.top().town;\n\t\t\t\t\tQ.pop();\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\t\tif(MIN_COST[from][V[min_index][i].to] > MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\t\tMIN_COST[from][V[min_index][i].to] = MIN_COST[from][min_index] + V[min_index][i].cost;\n\t\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[from][V[min_index][i].to]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(MIN_COST[from][to] > maximum){\n\t\t\t\tmaximum = MIN_COST[from][to];\n\t\t\t\twhile(!S.empty())S.pop();\n\t\t\t\tS.push(Data(from,to));\n\t\t\t}else if(MIN_COST[from][to] == maximum){\n\t\t\t\tS.push(Data(from,to));\n\t\t\t}\n\t\t}\n\t}\n\n\tbool* USED = new bool[N+1];\n\tfor(int i = 1; i <= N; i++)USED[i] = false;\n\n\tvector<int> PRE_TOWN[N+1];\n\tqueue<int> WORK;\n\tbool* CHECK = new bool[N+1];\n\tbool FLG;\n\n\tint start,goal;\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 1; k <=N; k++)MIN_COST[i][k] = BIG_NUM;\n\t}\n\n\twhile(!S.empty()){\n\t\tstart = S.top().start;\n\t\tgoal = S.top().goal;\n\t\tS.pop();\n\n\t\tUSED[start] = true;\n\t\tUSED[goal] = true;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tPRE_TOWN[i].clear();\n\t\t\tCHECK[i] = false;\n\t\t}\n\t\tCHECK[start] = true;\n\t\tCHECK[goal] = true;\n\n\t\tfor(int i = 0; i < V[start].size();i++){\n\t\t\tMIN_COST[start][V[start][i].to] = V[start][i].cost;\n\t\t\tQ.push(Info(V[start][i].to,V[start][i].cost));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().cost > MIN_COST[start][Q.top().town]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tmin_index = Q.top().town;\n\t\t\t\tQ.pop();\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\tif(MIN_COST[start][V[min_index][i].to] > MIN_COST[start][min_index] + V[min_index][i].cost){\n\t\t\t\t\tMIN_COST[start][V[min_index][i].to] = MIN_COST[start][min_index] + V[min_index][i].cost;\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].clear();\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[start][V[min_index][i].to]));\n\t\t\t\t}else if(MIN_COST[start][V[min_index][i].to] == MIN_COST[start][min_index] + V[min_index][i].cost){\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tfor(int k = 0; k < PRE_TOWN[V[min_index][i].to].size();k++){\n\t\t\t\t\t\tif(PRE_TOWN[V[min_index][i].to][k] == min_index){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(FLG){\n\t\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[start][V[min_index][i].to]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0 ; i < PRE_TOWN[goal].size(); i++){\n\t\t\tWORK.push(PRE_TOWN[goal][i]);\n\t\t}\n\n\t\twhile(!WORK.empty()){\n\t\t\tUSED[WORK.front()] = true;\n\t\t\tCHECK[WORK.front()] = true;\n\t\t\tfor(int i = 0; i < PRE_TOWN[WORK.front()].size();i++){\n\t\t\t\tif(CHECK[PRE_TOWN[WORK.front()][i]] == false){\n\t\t\t\t\tWORK.push(PRE_TOWN[WORK.front()][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tWORK.pop();\n\t\t}\n\t}\n\n\tint num = 0;\n\n\tfor(int i = 1; i <= N; i++)if(USED[i] == false)num++;\n\n\tprintf(\"%d\\n\",num);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(USED[i] == false){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t}\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define endl '\\n'\n#define pque priority_queue\n#define pi acos(-1)\n#define int long long\n#define N 1000000\ntypedef pair < int, int > ii;\ntypedef vector < int > vi;\ntypedef pair < int, ii > iii;\nconst int mod = 1000000007;\nint n, m, d[2000][2000], ans, imax;\nbool check[2000];\npque < iii, vector < iii >, greater < iii > > pq;\nvector < ii > v[2000];\nsigned main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor(int i = 1; i <= m; i ++)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tv[a].pb(mp(b, c));\n\t\tv[b].pb(mp(a, c));\n\t}\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\td[i][j] = mod, d[i][i] = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t\tpq.push(mp(0, mp(i, i)));\n\twhile(!pq.empty())\n\t{\n\t\tint c = pq.top().fi;\n\t\tint a = pq.top().se.fi;\n\t\tint b = pq.top().se.se;\n\t\tpq.pop();\n\t\tif(d[a][b] < c)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < v[b].size(); i ++)\n\t\t{\n\t\t\tint e = v[b][i].fi;\n\t\t\tint f = v[b][i].se;\n\t\t\tif(c + f < d[a][e])\n\t\t\t\td[a][e] = c + f, pq.push(mp(d[a][e], mp(a, e)));\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\timax = max(imax, d[i][j]);\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif(d[i][j] == imax)\n\t\t\t\tpq.push(mp(d[i][j], mp(i, j)));\n\twhile(!pq.empty())\n\t{\n\t\tint a = pq.top().se.fi;\n\t\tint b = pq.top().se.se;\n\t\tint c = pq.top().fi;\n\t\tpq.pop();\n\t\tif(!check[b])\n\t\t\tans ++;\n\t\tcheck[b] = true;\n\t\tfor(int i = 0; i < v[b].size(); i ++)\n\t\t{\n\t\t\tint e = v[b][i].fi;\n\t\t\tint f = v[b][i].se;\n\t\t\tif(d[a][e] + f == d[a][b])\n\t\t\t\tpq.push(mp(d[a][e], mp(a, e)));\n\t\t}\n\t}\n\tcout << n - ans << endl;\n\tfor(int i = 1; i <= n; i ++)\n\t\tif(!check[i])\n\t\t\tcout << i << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define up(i, a, b) for (int i = a, _b = b; i <= _b; i++)\n#define down(i, a, b) for (int i = a, _b = b; i >= _b; i--)\n#define long long long\n#define endl '\\n'\n#define w first\n#define v second\n#define II pair<int, int>\n#define debug(X) cerr << #X << \" = \" << X << endl\n#define debug2(X, Y) cerr << #X << \" = \" << X << \" , \" << #Y << \" = \" << Y << endl\n#define show(X, a, b) { cerr << #X << \" = \"; up(_, a, b) cerr << X[_] << \" \"; cerr << endl; }\n#define gc getchar\n#define pc putchar\nusing namespace std;\ninline void read(int &x) {\n        register int c = gc();\n        x = 0;\n        int neg = 0;\n        for (; ((c<48 || c>57) && c != '-'); c = gc());\n        if(c=='-') {neg=1; c=gc();}\n        for(; c>47 && c<58; c = gc()) {x = (x<<1) + (x<<3) + c - 48;}\n        if(neg) x=-x;\n}\ninline void writeln(int x) {\n\n        char buffor[21];\n        register int i=0;\n        int neg=0; if (x<0) {neg=1; x= -x;}\n        do {\n                buffor[i++]=(x%10)+'0';\n                x/=10;\n        } while(x);\n        i--;\n        if (neg) pc('-');\n        while(i>=0) pc(buffor[i--]);\n        pc('\\n');\n}\nconst int N = 1510;\nconst int oo = 1e9;\nint d[N], rev_d[N], n, m;\nvector<II> a[N];\nbool useful[N];\nvector<int> candidate[N];\nint max_from[N];\nvoid input() {\n        cin >> n >> m;\n        up(i, 1, m) {\n            int u, v, w; cin >> u >> v >> w;\n            a[u].push_back(II(w, v));\n            a[v].push_back(II(w, u));\n        }\n}\nvoid dijikstra(int s) {\n        up(i, 1, n) d[i] = oo;\n        d[s] = 0;\n        priority_queue<II, vector<II>, greater<II> > pq;\n        pq.push(II(d[s], s));\n        while (!pq.empty()) {\n            int du = pq.top().w, u = pq.top().v; pq.pop();\n            if (du != d[u]) continue;\n            for (auto e: a[u])\n              if (d[e.v] > d[u] + e.w) {\n                d[e.v] = d[u] + e.w; pq.push(II(d[e.v], e.v));\n              }\n        }\n\n        int maxd = 0;\n        up(i, 1, n)\n          if (d[i] > maxd) maxd = d[i];\n        max_from[s] = maxd;\n\n        //from now we use rev_d\n        up(i, 1, n) rev_d[i] = oo;\n        up(i, 1, n)\n          if (d[i] == maxd) rev_d[i] = 0, pq.push(II(rev_d[i], i));\n        while (!pq.empty()) {\n            int rev_du = pq.top().w, u = pq.top().v; pq.pop();\n            if (rev_du != rev_d[u]) continue;\n            for (auto e: a[u])\n              if (rev_d[e.v] > rev_d[u] + e.w) {\n                 rev_d[e.v] = rev_d[u] + e.w; pq.push(II(rev_d[e.v], e.v));\n              }\n        }\n\n        up(i, 1, n)\n          if (d[i] + rev_d[i] == maxd) candidate[s].push_back(i);\n}\nvoid solve() {\n        up(i, 1, n) dijikstra(i);\n        int max_all = 0;\n        up(i, 1, n) max_all = max(max_all, max_from[i]);\n        up(i, 1, n)\n          if (max_from[i] == max_all)\n            for (auto v: candidate[i]) useful[v] = 1;\n        int res = 0;\n        up(i, 1, n)\n          if (!useful[i]) res++;\n        cout << res << endl;\n        up(i, 1, n)\n          if (!useful[i]) cout << i << endl;\n}\nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(NULL);\n\n  #ifdef I_Love_Pork\n  #define TASK \"tmp\"\n        freopen(TASK \".inp\",\"r\",stdin);\n        freopen(TASK \".out\",\"w\",stdout);\n  #endif\n\n\n        input();\n        solve();\n\n\n\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501], done[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  while(1) {\n    mp[j] = 1;\n    if(j == i) break;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        j = e.to;\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) fill(d[i], d[i] + n, 114514);\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(!done[i][j] && mas == d[i][j]) {\n        solve(i, j);\n        done[j][i] = 1;\n      }\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1 ) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_town,int arg_cost){\n\t\ttown = arg_town;\n\t\tcost = arg_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn cost > arg.cost;\n\t};\n\tint town,cost;\n};\n\nstruct Dist{\n\tDist(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Data{\n\tData(int arg_start,int arg_goal){\n\t\tstart = arg_start;\n\t\tgoal = arg_goal;\n\t}\n\tint start,goal;\n};\n\nint main(){\n\n\tint N,R,s,t,d;\n\tscanf(\"%d %d\",&N,&R);\n\n\tvector<Dist> V[N+1];\n\tint** MIN_COST = new int*[N+1];\n\tfor(int i = 1; i <= N; i++){\n\t\tMIN_COST[i] = new int[N+1];\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tif(i != k)MIN_COST[i][k] = BIG_NUM;\n\t\t\telse{\n\t\t\t\tMIN_COST[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d %d %d\",&s,&t,&d);\n\t\tV[s].push_back(Dist(t,d));\n\t\tV[t].push_back(Dist(s,d));\n\t}\n\n\tint maximum = -1,min_index;\n\tstack<Data> S;\n\tpriority_queue<Info> Q;\n\tqueue<int> WORK;\n\tvector<int> ANS;\n\tvector<int> PRE_TOWN[N+1];\n\n\tbool* VISITED = new bool[N+1];\n\n\tfor(int from = 1; from <= N;from++){\n\n\t\tfor(int i = 0; i < V[from].size();i++){\n\t\t\tMIN_COST[from][V[from][i].to] = V[from][i].cost;\n\t\t\tQ.push(Info(V[from][i].to,V[from][i].cost));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().cost > MIN_COST[from][Q.top().town]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tmin_index = Q.top().town;\n\t\t\t\tQ.pop();\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\tif(MIN_COST[from][V[min_index][i].to] > MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\tMIN_COST[from][V[min_index][i].to] = MIN_COST[from][min_index] + V[min_index][i].cost;\n\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[from][V[min_index][i].to]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)maximum = max(maximum,MIN_COST[from][i]);\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tif(i != k)MIN_COST[i][k] = BIG_NUM;\n\t\t\telse{\n\t\t\t\tMIN_COST[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int from = 1; from <= N;from++){\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tPRE_TOWN[i].clear();\n\t\t\tPRE_TOWN[i].push_back(from);\n\t\t}\n\n\t\tfor(int i = 0; i < V[from].size();i++){\n\t\t\tMIN_COST[from][V[from][i].to] = V[from][i].cost;\n\t\t\tQ.push(Info(V[from][i].to,V[from][i].cost));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().cost > MIN_COST[from][Q.top().town]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tmin_index = Q.top().town;\n\t\t\t\tQ.pop();\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\tif(MIN_COST[from][V[min_index][i].to] > MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\tMIN_COST[from][V[min_index][i].to] = MIN_COST[from][min_index] + V[min_index][i].cost;\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].clear();\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[from][V[min_index][i].to]));\n\t\t\t\t}else if(MIN_COST[from][V[min_index][i].to] == MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(maximum == MIN_COST[from][i]){\n\t\t\t\tfor(int k = 1; k <= N; k++)VISITED[k] = false;\n\n\t\t\t\tWORK.push(i);\n\t\t\t\tVISITED[i] = true;\n\t\t\t\tANS.push_back(i);\n\n\t\t\t\twhile(!WORK.empty()){\n\t\t\t\t\tfor(int k = 0; k < PRE_TOWN[WORK.front()].size(); k++){\n\t\t\t\t\t\tif(VISITED[PRE_TOWN[WORK.front()][k]] == false){\n\t\t\t\t\t\t\tVISITED[PRE_TOWN[WORK.front()][k]] = true;\n\t\t\t\t\t\t\tANS.push_back(PRE_TOWN[WORK.front()][k]);\n\t\t\t\t\t\t\tWORK.push(PRE_TOWN[WORK.front()][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tWORK.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool* USED = new bool[N+1];\n\tfor(int i = 1; i <= N; i++)USED[i] = false;\n\n\tfor(int i = 0; i < ANS.size(); i++)USED[ANS[i]] = true;\n\n\tint num = 0;\n\n\tfor(int i = 1; i <= N; i++)if(USED[i] == false)num++;\n\n\tprintf(\"%d\\n\",num);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(USED[i] == false){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t}\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int INF = INT_MAX / 4;\n\ntemplate <class T>\nclass EdgeBase\n{\npublic:\n    int to;\n    T cost;\n    EdgeBase(){};\n    EdgeBase(int to0, T cost0){to = to0; cost = cost0;}\n};\ntypedef EdgeBase<int> Edge;\n\ntemplate<class T>\nvoid shortestPath(const vector<vector<EdgeBase<T> > >& edges, int start, vector<T>& dist)\n{\n    const T EPS = static_cast<T>(1.0e-10);\n\n    dist.assign(edges.size(), INF);\n    dist[start] = 0;\n    priority_queue<pair<T,int>, vector<pair<T,int> >, greater<pair<T,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<T, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first - EPS)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            EdgeBase<T> e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to] - EPS){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\ntemplate <class T>\nvoid shortestPath(const vector<vector<EdgeBase<T> > >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    int n, r;\n    cin >> n >> r;\n    vector<vector<Edge> > edges(n);\n    for(int i=0; i<r; ++i){\n        int s, t, d;\n        cin >> s >> t >> d;\n        -- s;\n        -- t;\n        edges[s].push_back(Edge(t, d));\n        edges[t].push_back(Edge(s, d));\n    }\n\n    vector<vector<int> > dist;\n    shortestPath(edges, dist);\n    int maxDist = 0;\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<n; ++j){\n            if(dist[i][j] < INF)\n                maxDist = max(maxDist, dist[i][j]);\n        }\n    }\n\n    vector<bool> check(n, true);\n    for(int i=0; i<n; ++i){\n        queue<int> q;\n        for(int j=0; j<n; ++j){\n            if(dist[i][j] == maxDist){\n                q.push(j);\n                check[j] = false;\n            }\n        }\n        while(!q.empty()){\n            int a = q.front();\n            q.pop();\n            for(const Edge& e : edges[a]){\n                if(dist[i][e.to] + e.cost == dist[i][a]){\n                    q.push(e.to);\n                    check[e.to] = false;\n                }\n            }\n        }\n    }\n\n    vector<int> ans;\n    for(int i=0; i<n; ++i){\n        if(check[i])\n            ans.push_back(i+1);\n    }\n    cout << ans.size() << endl;\n    for(int a : ans)\n        cout << a << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi \"QUIETTOWN.inp\"\n#define fo \"QUIETTOWN.out\"\n#define vt first\n#define gt second\n#define maxn 1700\n#define maxc 1000000000\n\nusing namespace std;\n\npriority_queue < pair <int,int> > heap;\n\nint n,m,d[maxn][maxn],p[maxn][maxn],he[maxn*maxn],ke[maxn*maxn],e[maxn*maxn],ans,dg[maxn*maxn];\nbool dau[maxn],kt[maxn];\n\nvoid open()\n{\n //   freopen(fi,\"r\",stdin);\n   // freopen(fo,\"w\",stdout);\n\n    scanf(\"%d%d\",&n,&m);\n    int x,y,c;\n\n    for (int i=1; i<=m; i++)\n    {\n      scanf(\"%d%d%d\",&x,&y,&c);\n      he[x]++;\n      he[y]++;\n    }\n    for (int i=2; i<=n; i++) he[i]+=he[i-1];\n\n    freopen(fi,\"r\",stdin);\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1; i<=m; i++)\n    {\n      scanf(\"%d%d%d\",&x,&y,&c);\n      ke[he[x]]=y;\n      ke[he[y]]=x;\n      e[he[x]]=c;\n      e[he[y]]=c;\n      --he[x];\n      --he[y];\n    }\n    he[n+1]=m*2;\n}\n\nvoid dijkstra(int s, int t)\n{\n    for (int i=1; i<=n; i++) d[s][i]=maxc;\n    memset(dau,true,sizeof(dau));\n    d[s][s]=0;\n\n    heap.push(make_pair(0,s));\n\n    while (!heap.empty())\n    {\n      int u=heap.top().gt;\n      heap.pop();\n\n      dau[u]=false;\n      for (int iv=he[u]+1; iv<=he[u+1]; iv++)\n      {\n        int v=ke[iv];\n        if ((dau[v]) && (d[s][v]>d[s][u]+e[iv]))\n        {\n          d[s][v]=d[s][u]+e[iv];\n          p[s][v]=u;\n          heap.push(make_pair(-d[s][v],v));\n        }\n      }\n    }\n}\n\nvoid trace(int s, int u)\n{\n    kt[s]=true;\n    while (p[s][u]!=0)\n    {\n      u=p[s][u];\n      kt[u]=true;\n    }\n}\n\nvoid process()\n{\n    for (int i=1; i<=n; i++)\n    {\n        dijkstra(i,n);\n        for (int j=1; j<=n; j++)\n          if (i!=j) ans=max(ans,d[i][j]);\n    }\n\n    memset(kt,false,sizeof(kt));\n\n    for (int i=1; i<=n; i++)\n      for (int j=1; j<=n; j++)\n      {\n        if (d[i][j]==ans)\n        {\n          trace(i,j);\n        }\n      }\n\n    int kq=0;\n    for (int i=1; i<=n; i++)\n      if (kt[i]==false) dg[++kq]=i;\n\n    printf(\"%d\\n\",kq);\n    for (int i=1; i<=kq; i++) printf(\"%d\\n\",dg[i]);\n}\n\nint main()\n{\n    open();\n    process();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define up(i, a, b) for (int i = a, _b = b; i <= _b; i++)\n#define down(i, a, b) for (int i = a, _b = b; i >= _b; i--)\n#define long long long\n#define endl '\\n'\n#define w first\n#define v second\n#define II pair<int, int>\n#define debug(X) cerr << #X << \" = \" << X << endl\n#define debug2(X, Y) cerr << #X << \" = \" << X << \" , \" << #Y << \" = \" << Y << endl\n#define show(X, a, b) { cerr << #X << \" = \"; up(_, a, b) cerr << X[_] << \" \"; cerr << endl; }\n#define gc getchar\n#define pc putchar\nusing namespace std;\ninline void read(int &x) {\n        register int c = gc();\n        x = 0;\n        int neg = 0;\n        for (; ((c<48 || c>57) && c != '-'); c = gc());\n        if(c=='-') {neg=1; c=gc();}\n        for(; c>47 && c<58; c = gc()) {x = (x<<1) + (x<<3) + c - 48;}\n        if(neg) x=-x;\n}\ninline void writeln(int x) {\n\n        char buffor[21];\n        register int i=0;\n        int neg=0; if (x<0) {neg=1; x= -x;}\n        do {\n                buffor[i++]=(x%10)+'0';\n                x/=10;\n        } while(x);\n        i--;\n        if (neg) pc('-');\n        while(i>=0) pc(buffor[i--]);\n        pc('\\n');\n}\nconst int N = 1510;\nconst int oo = 1e9;\nint d[N], rev_d[N], n, m;\nvector<II> a[N];\nbool useful[N];\nvector<int> candidate[N];\nint max_from[N];\nvoid input() {\n        cin >> n >> m;\n        up(i, 1, m) {\n            int u, v, w; cin >> u >> v >> w;\n            a[u].push_back(II(w, v));\n            a[v].push_back(II(w, u));\n        }\n}\nvoid dijikstra(int s) {\n        up(i, 1, n) d[i] = oo;\n        d[s] = 0;\n        priority_queue<II, vector<II>, greater<II> > pq;\n        pq.push(II(d[s], s));\n        while (!pq.empty()) {\n            int du = pq.top().w, u = pq.top().v; pq.pop();\n            if (du != d[u]) continue;\n            for (auto e: a[u])\n              if (d[e.v] > d[u] + e.w) {\n                d[e.v] = d[u] + e.w; pq.push(II(d[e.v], e.v));\n              }\n        }\n\n        int maxd = 0;\n        up(i, 1, n)\n          if (d[i] > maxd) maxd = d[i];\n        max_from[s] = maxd;\n\n        //from now we use rev_d\n        up(i, 1, n) rev_d[i] = oo;\n        up(i, 1, n)\n          if (d[i] == maxd) rev_d[i] = 0, pq.push(II(rev_d[i], i));\n        while (!pq.empty()) {\n            int rev_du = pq.top().w, u = pq.top().v; pq.pop();\n            if (rev_du != rev_d[u]) continue;\n            for (auto e: a[u])\n              if (rev_d[e.v] > rev_d[u] + e.w) {\n                 rev_d[e.v] = rev_d[u] + e.w; pq.push(II(rev_d[e.v], e.v));\n              }\n        }\n\n        up(i, 1, n)\n          if (d[i] + rev_d[i] == maxd) candidate[s].push_back(i);\n}\nvoid solve() {\n        up(i, 1, n) dijikstra(i);\n        int max_all = 0;\n        up(i, 1, n) max_all = max(max_all, max_from[i]);\n        up(i, 1, n)\n          if (max_from[i] == max_all)\n            for (auto v: candidate[i]) useful[v] = 1;\n        int res = 0;\n        up(i, 1, n)\n          if (!useful[i]) res++;\n        cout << res << endl;\n        up(i, 1, n)\n          if (!useful[i]) cout << i << endl;\n}\nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(NULL);\n\n  #ifdef I_Love_Pork\n  #define TASK \"tmp\"\n        freopen(TASK \".inp\",\"r\",stdin);\n        freopen(TASK \".out\",\"w\",stdout);\n  #endif\n\n\n        input();\n        solve();\n\n\n\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nstruct edge{int to,cost;};\n\nconst int N = 1500;\nconst int INF = 19191919;\nvector<edge> G[N];\n\nint n;\nint d[N][N];\nbool can[N];\n\nvoid dijkstra(int s)\n{\n    d[s][s] = 0;\n    priority_queue<pi,vector<pi>,greater<pi>> pq;\n    pq.push({0,s});\n    while(!pq.empty())\n    {\n        pi now = pq.top();\n        pq.pop();\n        int v = now.se;\n        if(now.fi>d[s][v]) continue;\n        for(const auto &e:G[v])\n        {\n            if(d[s][e.to] > d[s][v]+e.cost)\n            {\n                d[s][e.to] = d[s][v]+e.cost;\n                pq.push({d[s][e.to],e.to});\n            }\n        }\n    }\n}\n\nvoid check(int s, int D)\n{\n    queue<int> que;\n    rep(i,n)if(d[s][i]==D) que.push(i);\n\n    while(!que.empty())\n    {\n        int v = que.front();\n        que.pop();\n        can[v] = false;\n\n        for(const auto &e:G[v])\n        {\n            if(d[s][e.to]==d[s][v]-e.cost) que.push(e.to);\n        }\n    }\n}\n\nint main()\n{\n    int r;\n    cin >>n >>r;\n    while(r--)\n    {\n        int s,t,w;\n        cin >>s >>t >>w;\n        --s; --t;\n        G[s].pb({t,w});\n        G[t].pb({s,w});\n    }\n\n    fill(d[0],d[N],INF);\n    fill(can,can+N,true);\n    rep(i,n) dijkstra(i);\n\n    int max_d = 0;\n    rep(i,n)rep(j,n) max_d = max(max_d,d[i][j]);\n\n    rep(i,n) check(i,max_d);\n\n    vector<int> ans;\n    rep(i,n)if(can[i]) ans.pb(i);\n\n    cout << ans.size() << endl;\n    for(const int &i:ans) cout << i+1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 1000000000\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_town,int arg_cost){\n\t\ttown = arg_town;\n\t\tcost = arg_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn cost > arg.cost;\n\t};\n\tint town,cost;\n};\n\nstruct Dist{\n\tDist(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Data{\n\tData(int arg_start,int arg_goal){\n\t\tstart = arg_start;\n\t\tgoal = arg_goal;\n\t}\n\tint start,goal;\n};\n\nint main(){\n\n\tint N,R,s,t,d;\n\tscanf(\"%d %d\",&N,&R);\n\n\tvector<Dist> V[N+1];\n\tint** MIN_COST = new int*[N+1];\n\tfor(int i = 1; i <= N; i++){\n\t\tMIN_COST[i] = new int[N+1];\n\t\tfor(int k = 1; k <= N; k++)MIN_COST[i][k] = BIG_NUM;\n\t}\n\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d %d %d\",&s,&t,&d);\n\t\tV[s].push_back(Dist(t,d));\n\t\tV[t].push_back(Dist(s,d));\n\t}\n\n\tint maximum = -1,min_index;\n\tstack<Data> S;\n\tpriority_queue<Info> Q;\n\n\tfor(int from = 1; from <= N;from++){\n\t\tfor(int i = 0; i < V[from].size();i++){\n\t\t\tMIN_COST[from][V[from][i].to] = V[from][i].cost;\n\t\t\tQ.push(Info(V[from][i].to,V[from][i].cost));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().cost > MIN_COST[from][Q.top().town]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tmin_index = Q.top().town;\n\t\t\t\tQ.pop();\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\tif(MIN_COST[from][V[min_index][i].to] > MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\tMIN_COST[from][V[min_index][i].to] = MIN_COST[from][min_index] + V[min_index][i].cost;\n\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[from][V[min_index][i].to]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(i != from && MIN_COST[from][i] != BIG_NUM && MIN_COST[from][i] > maximum){\n\t\t\t\tmaximum = MIN_COST[from][i];\n\t\t\t\twhile(!S.empty())S.pop();\n\t\t\t\tS.push(Data(from,i));\n\t\t\t}else if(i != from && MIN_COST[from][i] != BIG_NUM && MIN_COST[from][i] == maximum){\n\t\t\t\tS.push(Data(from,i));\n\t\t\t}\n\t\t}\n\t}\n\n\tbool* USED = new bool[N+1];\n\tfor(int i = 1; i <= N; i++)USED[i] = false;\n\n\tint start,goal;\n\n\twhile(!S.empty()){\n\t\tstart = S.top().start;\n\t\tgoal = S.top().goal;\n\t\tS.pop();\n\n\t\tUSED[start] = true;\n\t\tUSED[goal] = true;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(maximum == MIN_COST[start][i]+MIN_COST[i][goal]){\n\t\t\t\tUSED[i] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tint num = 0;\n\n\tfor(int i = 1; i <= N; i++)if(USED[i] == false)num++;\n\n\tprintf(\"%d\\n\",num);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(USED[i] == false){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t}\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nint mp[1501];\n\ninline void dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      if(d[s][g[v][i].to] > d[s][v] + g[v][i].cost) {\n        d[s][g[v][i].to] = d[s][v] + g[v][i].cost;\n        que.push(P(d[s][g[v][i].to], g[v][i].to));\n      }\n    }\n  }\n}\n\ninline void solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  int mmp[1501] = {};\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mmp[tp] = 1;\n    rep(k, 0, g[tp].size()) {\n      if(d[i][tp] == d[i][g[tp][k].to] + g[tp][k].cost && !mmp[tp]) {\n        st.push(g[tp][k].to);\n      }\n    }\n  }\n  rep(i, 1, n + 1) {\n    if(mmp[i]) mp[i] = 1;\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) {\n        mp[i] = 1;\n        solve(i, j);\n      }\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  map<int, int> mapp;\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    mapp[tp] = 1;\n    if(tp == i) continue;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(mapp[e.to]) continue;\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <cmath>\n#include <string>\n#define FI first\n#define SE second\n#define PF push_front\n#define PB push_back\n#define PPF pop_front\n#define PPB pop_back\n#define MA make_pair\n#define ll long long\n#define PA pair<int,int>\n#define VE vector<int>\n#define VP vector<PA>\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define ROF(i,a,b) for(int i=b-1;i>=a;i--)\n#define YES(i) cout<<(i?\"YES\":\"NO\")<<endl\n#define Yes(i) cout<<(i?\"Yes\":\"No\")<<endl\nusing namespace std;\n//\nconst int INF=1e9+7;\nconst int mod=1e9+7;\n//\n//\nstruct poi{\n  int X;int Y;int Z;\n  bool operator<(const poi&R)const{\n    return X==R.X ? Y==R.Y ? Z<R.Z : Y<R.Y : X<R.X;\n  }\n};\n//\n//\nint V,E;\nstruct edge {int to,cost;};\nvector<edge> G[1500];\nint D[1500];\n//\nvoid dijkstra(int S){\n  priority_queue<PA,vector<PA>,greater<PA> > que;\n  fill(D,D+V,INF);\n  D[S]=0;\n  que.push(MA(0,S));\n  while(que.size()){\n    PA P=que.top();\n    que.pop();\n    int vv=P.SE;\n    if(D[vv]<P.FI){\n      continue;\n    }else{\n      FOR(i,0,(int)G[vv].size()){\n        edge e=G[vv][i];\n        if(D[e.to]>D[vv]+e.cost){\n          D[e.to]=D[vv]+e.cost;\n          que.push(MA(D[e.to],e.to));\n        }\n      }\n    }\n  }\n}\n//\nset<int> S;\n//\nint a;\nbool check(int s,int g,int d){\n\tif(d>a){\n\t\treturn false;\n\t}\n\tif(s==g){\n\t\tif(d==a){\n\t\t\tS.insert(s);\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\tFOR(i,0,(int)G[s].size()){\n\t\tif(check(G[s][i].to,g,G[s][i].cost+d)){\n\t\t\tS.insert(s);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n//\nint main(){\n\tcin>>V>>E;\n\tFOR(i,0,E){\n\t\tint s,g,d;\n\t\tcin>>s>>g>>d;\n\t\ts--;g--;\n\t\tedge e;\n\t\te.to=g;e.cost=d;\n\t\tG[s].PB(e);\n\t\te.to=s;\n\t\tG[g].PB(e);\n\t}\n\tint mam=-1;\n\tVP mem;\n\tFOR(i,0,V){\n\t\tdijkstra(i);\n\t\tint ma=-1;\n\t\tVP me;\n\t\tFOR(j,0,V){\n\t\t\tif(ma<D[j]){\n\t\t\t\tma=D[j];\n\t\t\t\tme.clear();\n\t\t\t\tme.PB(MA(i,j));\n\t\t\t}else if(ma==D[j]){\n\t\t\t\tme.PB(MA(i,j));\n\t\t\t}\n\t\t}\n\t\tif(ma>mam){\n\t\t\tmam=ma;\n\t\t\tmem.clear();\n\t\t\twhile(!me.empty()){\n\t\t\t\tmem.PB(me.back());\n\t\t\t\tme.PPB();\n\t\t\t}\n\t\t}else if(ma==mam){\n\t\t\tmem.PB(me.back());\n\t\t\tme.PPB();\n\t\t}\n\t}\n\ta=mam;\n\twhile(!mem.empty()){\n\t\tPA num=mem.back();\n\t\tmem.PPB();\n\t\tcheck(num.FI,num.SE,0);\n\t}\n\tcout<<V-(int)S.size()<<endl;\n\tFOR(i,0,V){\n\t\tif(S.find(i)==S.end()){\n\t\t\tcout<<i+1<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long i64;\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nstd::vector<std::vector<std::pair<int, int>>> g;\nint n, m;\n\nstd::vector<int> solve(int s) {\n\ttypedef std::pair<int, int> P;\n\tstd::vector<int> min_cost(n, 1 << 30); min_cost[s] = 0;\n\tstd::priority_queue<P, std::vector<P>, std::greater<P>> qu; qu.push({0, s});\n\twhile(!qu.empty()) {\n\t\tauto p = qu.top(); qu.pop();\n\t\t\n\t\tfor(auto e : g[p.second]) {\n\t\t\tif(p.first + e.second >= min_cost[e.first]) continue;\n\t\t\tmin_cost[e.first] = p.first + e.second;\n\t\t\tqu.push({min_cost[e.first], e.first});\n\t\t}\n\t}\n\treturn min_cost;\n}\n\nint main() {\n\tcin >> n >> m; g.resize(n);\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\n\t\tg[a - 1].push_back({b - 1, c});\n\t\tg[b - 1].push_back({a - 1, c});\n\t}\n\t\n\tint ma = 0;\n\tstd::vector<std::vector<int>> dist(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tdist[i] = solve(i);\n\t\tfor(int j = 0; j < n; j++) ma = std::max(ma, dist[i][j]);\n\t}\n\t\n\tstd::set<int> st;\n\tfor(int i = 0; i < n; i++) {\n\t\tstd::queue<int> qu;\n\t\tfor(int j = i + 1; j < n; j++) if(dist[i][j] == ma) qu.push(j);\n\t\t\n\t\tstd::vector<bool> used(n, false);\n\t\twhile(!qu.empty()) {\n\t\t\tauto p = qu.front(); qu.pop(); st.insert(p);\n\t\t\tif(used[p]) continue; used[p] = true;\n\t\t\t\n\t\t\tfor(auto e : g[p]) {\n\t\t\t\tif(dist[i][p] != dist[i][e.first] + e.second) continue;\n\t\t\t\tqu.push(e.first);\n\t\t\t}\n\t\t}\n\t}\n\tcout << n - st.size() << endl;\n\tfor(int i = 0; i < n; i++) if(!st.count(i)) cout << i + 1 << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nvector< vector<edge> > graph;\nvector< vector<int> > mincost;\n\nint dijkstra(int s)\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  mincost[s][s] = 0;\n  while(!que.empty()) {\n    int cost, now;\n    tie(cost, now) = que.top(); que.pop();\n    if(mincost[s][now] < cost) continue;\n    for(edge& e : graph[now]) {\n      if(e.cost + cost < mincost[s][e.to]) {\n\tmincost[s][e.to] = e.cost + cost;\n\tque.push(P(mincost[s][e.to], e.to));\n      }\n    }\n  }\n  return *max_element(all(mincost[s]));\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, R;\n  cin >> N >> R;\n  graph.resize(N);\n  rep(i, R) {\n    int s, t, d;\n    cin >> s >> t >> d; s--, t--;\n    graph[s].emplace_back(t, d);\n    graph[t].emplace_back(s, d);\n  }\n\n  mincost.resize(N, vector<int>(N, inf));\n  int maxdist = 0;\n  rep(i, N) maxdist = max(maxdist, dijkstra(i));\n  //rep(i, N) dijkstra(i);\n  //rep(i, N) reps(j, i+1, N) maxdist = max(maxdist, mincost[i][j]);\n\n  vector<P> ep;\n  //vector<int> S, T;\n  rep(i, N) reps(j, i+1, N) {\n    if(mincost[i][j] == maxdist) {\n      ep.emplace_back(i, j);      \n      //S.push_back(i), T.push_back(j);\n    }\n  }\n\n  vector<int> ans;\n  rep(i, N) {\n    bool flag = true;\n    for(auto& p : ep) {\n      //rep(j, S.size()) {\n      int s, t; tie(s, t) = p;\n      if(mincost[s][i] + mincost[i][t] == maxdist) {      \n      //if(mincost[S[j]][i] + mincost[i][T[j]] == maxdist) {\n\tflag = false;\n\tbreak;\n      }\n    }\n    if(flag) ans.push_back(i+1);\n  }\n  \n  cout << ans.size() << endl;\n  rep(i, ans.size()) cout << ans[i] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9+7;\nconst double EPS  = 1e-10;\nconst bool debug = 0;\n//---------------------------//\n\nint N, M;\nvector<pii> g[1500], rg[1500];\nint d[1500];\nbool done[1500];\n\nint dijkstra(int st) {\n\tpriority_queue<pii, vector<pii>, greater<pii> > pq;\n\t\n\tfill(d, d + N, INF);\n\t\n\tpq.push(pii(0, st));\n\td[st] = 0;\n\twhile (!pq.empty()) {\n\t\tint c = pq.top().fi, u = pq.top().se;\n\t\tpq.pop();\n\t\t\n\t\tREP(i, g[u].size()) {\n\t\t\tint v = g[u][i].fi;\n\t\t\tint nc = c + g[u][i].se;\n\t\t\tif (chmin(d[v], nc)) pq.push(pii(nc, v));\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tREP(i, N) chmax(res, d[i]);\n\treturn res;\n}\n\nint main(){\n\tcin >> N >> M;\n\tREP(i, M) {\n\t\tint s, t, d;\n\t\tscanf(\"%d %d %d\", &s, &t, &d);\n\t\ts--; t--;\n\t\tg[s].push_back(pii(t, d));\n\t\tg[t].push_back(pii(s, d));\n\t}\n\t\n\tint ma = 0;\n\tREP(i, N) chmax(ma, dijkstra(i));\n\t\n\tREP(st, N) {\n\t\tif (dijkstra(st) < ma) continue;\n\t\t\n\t\tREP(i, N) rg[i].clear();\n\t\tREP(i, N) {\n\t\t\tREP(j, g[i].size()) {\n\t\t\t\tint v = g[i][j].fi;\n\t\t\t\tif (d[i] + g[i][j].se == d[v]) rg[v].push_back(pii(i, g[i][j].se));\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<int> que;\n\t\tREP(i, N) if (d[i] == ma) que.push(i);\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tint u = que.front(); que.pop();\n\t\t\tdone[u] = true;\n\t\t\t\n\t\t\tREP(i, rg[u].size()) {\n\t\t\t\tint v = rg[u][i].fi;\n\t\t\t\tif (d[v] + rg[u][i].se == d[u]) que.push(v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> ans;\n\tREP(i, N) if (!done[i]) ans.push_back(i + 1);\n\t\n\tcout << ans.size() << endl;\n\tREP(i, ans.size()) printf(\"%d\\n\", ans[i]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N,R;\nvector<vector<pair<int, int> > > MapData;\nint ShortDistOfEachNode[1501][1501];\nbool Used[1501];\nset<int> Result;\n\nconst int INF = 1e9;\n\nvoid findShortDistOfEachNode(int StartNode, int *dist) {\n\tint curNode, cost, sizeOfTo, nextNode, costTo;\n\tpriority_queue<pair<int, int> > NodeList;\n\tpair<int, int> tmp;\n\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfill(dist, dist + N + 1, INF);\n\t}\n\tdist[StartNode] = 0;\n\tNodeList.push({ StartNode,0 });\n\twhile (!NodeList.empty()) {\n\t\ttmp = NodeList.top();\n\t\tNodeList.pop();\n\n\t\tcurNode = tmp.first;\n\t\tcost = tmp.second;\n\t\tif (cost > dist[curNode]) {\n\t\t\tcontinue;\n\t\t}\n\t\tsizeOfTo = MapData[curNode].size();\n\t\tfor (int i = 0; i < sizeOfTo; ++i) {\n\t\t\tnextNode = MapData[curNode][i].first;\n\t\t\tcostTo = MapData[curNode][i].second;\n\t\t\tif (cost + costTo < dist[nextNode]) {\n\t\t\t\tdist[nextNode] = cost + costTo;\n\t\t\t\tNodeList.push({ nextNode,dist[nextNode] });\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nvoid findNode(int startNode, int curNode, int *dist) {\n\tint sizeOfTo, preNode, cost;\n\n\tif (Used[curNode]) {\n\t\treturn;\n\t}\n\tUsed[curNode] = true;\n\tResult.insert(curNode);\n\tif (startNode == curNode) {\n\t\treturn;\n\t}\n\n\tsizeOfTo = MapData[curNode].size();\n\tfor (int i = 0; i < sizeOfTo; ++i) {\n\t\tpreNode = MapData[curNode][i].first;\n\t\tcost = MapData[curNode][i].second;\n\t\tif (dist[curNode] == dist[preNode] + cost) {\n\t\t\tfindNode(startNode, preNode, dist);\n\t\t}\n\t}\n}\n\nint main() {\n\tint s, t, d, maxShortLen;\n\n\tcin >> N >> R;\n\tMapData.resize(N + 1);\n\tfor (int i = 0; i < R; ++i) {\n\t\tcin >> s >> t >> d;\n\t\tMapData[s].push_back({ t,d });\n\t\tMapData[t].push_back({ s,d });\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfindShortDistOfEachNode(i,ShortDistOfEachNode[i]);\n\t}\n\t\n\tmaxShortLen = 0;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 1; j <= N; ++j) {\n\t\t\tif (ShortDistOfEachNode[i][j] == INF) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmaxShortLen = max(maxShortLen, ShortDistOfEachNode[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= N; ++i) {\n\t\tmemset(Used, false, sizeof(Used));\n\t\tfor (int j = 1; j <= N; ++j) {\n\t\t\tif (ShortDistOfEachNode[i][j] == maxShortLen) {\n\t\t\t\tfindNode(i, j, ShortDistOfEachNode[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << N - Result.size() << endl;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (Result.find(i) == Result.end()) {\n\t\t\tcout << i << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  while(1) {\n    mp[j] = 1;\n    if(j == i) break;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        j = e.to;\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0351\n\n#include<bits/stdc++.h>\nconst int N = 1505;\nconst int inf = 1e9;\nusing namespace std;\n\ntypedef pair <int, int> ii;\nvector <ii> adj[N];\nint n, m, d[N][N], ans, visit[N], f[N], ck[N];\n\nvoid dijkstra(int S){\n    for (int i = 1; i <= n; i++) d[S][i] = inf; d[S][S] = 0;\n    priority_queue <ii, vector <ii>, greater<ii> > mq; mq.push(ii(d[S][S], S));\n    while (mq.size()){\n        ii z = mq.top(); mq.pop();\n        int u = z.second, val = z.first;\n        if (val != d[S][u]) continue;\n        ans = max(ans, val);\n        for (int i = 0; i < adj[u].size(); i++){\n            int v = adj[u][i].first, cost = adj[u][i].second;\n            if (d[S][v] > d[S][u] + cost){\n                d[S][v] = d[S][u] + cost;\n                mq.push(ii(d[S][v], v));\n            }\n        }\n    }\n}\n\nvoid dfs(int u, int root){\n    if (visit[u]) return;\n    visit[u] = true;\n    f[u] = d[root][u];\n    for (int i = 0; i < adj[u].size(); i++){\n        int v = adj[u][i].first, cost = adj[u][i].second;\n        if (d[root][v] == d[root][u] + cost){\n            dfs(v, root); f[u] = max(f[u], f[v]);\n        }\n    }\n    if (f[u] == ans) ck[u] = 1;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++){\n        int u, v, d; cin >> u >> v >> d;\n        adj[u].push_back(ii(v, d));\n        adj[v].push_back(ii(u, d));\n    }\n    for (int i = 1; i <= n; i++) dijkstra(i);\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++) visit[j] = 0;\n        dfs(i, i);\n    }\n    int cnt = 0; for (int i = 1; i <= n; i++) if (!ck[i]) cnt++;\n    cout << cnt << \"\\n\";\n    for (int i = 1; i <= n; i++) if (!ck[i]) cout << i << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define REP(i,n) for(ll (i) = 0; (i) < (n); ++(i))\n#define FOR(i,k,n) for(ll (i) = (k); (i) < (n); ++(i))\n\nconst ll INF = 1e9;\n\nsigned main(){\n    int n,m;\n    cin >> n >> m;\n    vector<int> a(m);\n    vector<int> b(m);\n    vector<int> c(m);\n    REP(i,m){\n        cin >> a[i] >> b[i] >> c[i];\n        --a[i];--b[i];\n    }\n    vector<vector<P>> edges(n);\n    REP(i,m){\n        edges[a[i]].emplace_back(b[i], c[i]);\n        edges[b[i]].emplace_back(a[i], c[i]);\n    }\n\n    auto dijk = [&](int st){\n        vector<ll> range(n, INF);\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.emplace(0, st);\n        vector<int> flag(n, 0);\n        range[st] = 0;\n\n        while(!que.empty()){\n            ll pos, ran;\n            std::tie(ran, pos) = que.top();\n            que.pop();\n\n            if(flag[pos])continue;\n            flag[pos] = 1;\n\n            for(auto xx : edges[pos])\n                if(range[xx.first] > ran + xx.second){\n                    range[xx.first] = ran + xx.second;\n                    que.emplace(range[xx.first], xx.first);\n                }\n        }\n        return range;\n    };\n\n    ll ma = 0;\n    vector<P> mapos;\n\n    std::vector<std::vector<ll>> ranges(n);\n    REP(i,n){\n        ranges[i] = move(dijk(i));\n        REP(j,n)\n            if(ma <= ranges[i][j]){\n                if(ma < ranges[i][j])\n                    mapos.clear();\n                ma = ranges[i][j];\n                if(i < j)\n                    mapos.emplace_back(i, j);\n            }\n    }\n    vector<int> fl(n, false);\n    REP(i,n){\n        for(auto xx : mapos)\n            if(ranges[i][xx.first] + ranges[i][xx.second] == ma)\n                fl[i] = true;\n    }\n\n\n    /*\n    for(auto xx : ranges){\n        for(auto yy : xx)cout << yy << \" \";\n        cout << endl;\n    }\n\n    cout << ma << endl;\n    for(auto xx : mapos)cout << xx.first << \" \" << xx.second << endl;\n    */\n\n    cout << count(fl.begin(), fl.end(), 0) << endl;\n    REP(i,n)if(fl[i] == 0)cout << i + 1 << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nconst int INF = 1 << 29;\n\nint N, R;\nint A[3000], B[3000], D[3000];\nint cost[1500][1500];\nbool used[1500], v[1500];\n\nvoid dfs(int idx, int *dist)\n{\n  if(v[idx]++) return;\n  used[idx]++;\n  for(int i = 0; i < R; i++) {\n    if(idx == A[i] && dist[B[i]] + D[i] == dist[idx]) dfs(B[i], dist);\n    if(idx == B[i] && dist[A[i]] + D[i] == dist[idx]) dfs(A[i], dist);\n  }\n}\n\nint main()\n{\n  fill_n(*cost, 1500 * 1500, INF);\n  rep(i, 1500) cost[i][i] = 0;\n\n  cin >> N >> R;\n  rep(i, R) {\n    cin >> A[i] >> B[i] >> D[i];\n    --A[i], --B[i];\n    cost[A[i]][B[i]] = cost[B[i]][A[i]] = D[i];\n  }\n  rep(i, N) rep(j, N) rep(k, N) cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\n  int ret = 0;\n  rep(i, N) rep(j, N) if(cost[i][j] != INF) ret = max(ret, cost[i][j]);\n\n  rep(i, N) rep(j, N) {\n      memset(v, false, sizeof(v));\n      if(cost[i][j] == ret) dfs(j, cost[i]);\n    }\n  cout << count(used, used + N, false) << endl;\n  rep(i, N) if(!used[i]) cout << i + 1 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nconst int INF = 1 << 29;\n\nint N, R;\nint A[3000], B[3000], D[3000];\nint cost[1500][1500];\nbool used[1500], v[1500];\nvector< int > g[1500];\n\nvoid dfs(int idx, int *dist)\n{\n  if(v[idx]++) return;\n  used[idx]++;\n  for(auto &i : g[idx]) if(dist[B[i]] + D[i] == dist[idx]) dfs(B[i], dist);\n}\n\nint main()\n{\n  fill_n(*cost, 1500 * 1500, INF);\n  rep(i, 1500) cost[i][i] = 0;\n\n  cin >> N >> R;\n  rep(i, R) {\n    cin >> A[i] >> B[i] >> D[i];\n    --A[i], --B[i];\n    cost[A[i]][B[i]] = cost[B[i]][A[i]] = D[i];\n    g[A[i]].push_back(i);\n    g[B[i]].push_back(i);\n  }\n  rep(i, N) rep(j, N) rep(k, N) cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\n  int ret = 0;\n  rep(i, N) rep(j, N) if(cost[i][j] != INF) ret = max(ret, cost[i][j]);\n\n  rep(i, N) rep(j, N) {\n      memset(v, false, sizeof(v));\n      if(cost[i][j] == ret) dfs(j, cost[i]);\n    }\n  cout << count(used, used + N, false) << endl;\n  rep(i, N) if(!used[i]) cout << i + 1 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 1000000000\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_town,int arg_cost){\n\t\ttown = arg_town;\n\t\tcost = arg_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn cost > arg.cost;\n\t};\n\tint town,cost;\n};\n\nstruct Dist{\n\tDist(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Data{\n\tData(int arg_start,int arg_goal){\n\t\tstart = arg_start;\n\t\tgoal = arg_goal;\n\t}\n\tint start,goal;\n};\n\nint main(){\n\n\tint N,R,s,t,d;\n\tscanf(\"%d %d\",&N,&R);\n\n\tvector<Dist> V[N+1];\n\tint** MIN_COST = new int*[N+1];\n\tfor(int i = 1; i <= N; i++){\n\t\tMIN_COST[i] = new int[N+1];\n\t\tfor(int k = 1; k <= N; k++)MIN_COST[i][k] = BIG_NUM;\n\t}\n\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d %d %d\",&s,&t,&d);\n\t\tV[s].push_back(Dist(t,d));\n\t\tV[t].push_back(Dist(s,d));\n\t}\n\n\tint maximum = -1,min_index;\n\tstack<Data> S;\n\tpriority_queue<Info> Q;\n\n\tfor(int from = 1; from <= N;from++){\n\t\tfor(int i = 0; i < V[from].size();i++){\n\t\t\tMIN_COST[from][V[from][i].to] = V[from][i].cost;\n\t\t\tQ.push(Info(V[from][i].to,V[from][i].cost));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().cost > MIN_COST[from][Q.top().town]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tmin_index = Q.top().town;\n\t\t\t\tQ.pop();\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\tif(MIN_COST[from][V[min_index][i].to] > MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\tMIN_COST[from][V[min_index][i].to] = MIN_COST[from][min_index] + V[min_index][i].cost;\n\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[from][V[min_index][i].to]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(i != from && MIN_COST[from][i] != BIG_NUM && MIN_COST[from][i] > maximum){\n\t\t\t\tmaximum = MIN_COST[from][i];\n\t\t\t\twhile(!S.empty())S.pop();\n\t\t\t\tS.push(Data(from,i));\n\t\t\t}else if(i != from && MIN_COST[from][i] != BIG_NUM && MIN_COST[from][i] == maximum){\n\t\t\t\tS.push(Data(from,i));\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> G;\n\tstack<int> D[N+1];\n\n\tbool FLG;\n\n\twhile(!S.empty()){\n\t\tFLG = true;\n\t\tfor(int i = 0;i < G.size(); i++){\n\t\t\tif(G[i] == S.top().start){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(FLG)G.push_back(S.top().start);\n\n\t\tD[S.top().start].push(S.top().goal);\n\n\t\tS.pop();\n\t}\n\n\n\tbool* USED = new bool[N+1];\n\tfor(int i = 1; i <= N; i++)USED[i] = false;\n\n\tint start,goal;\n\n\tfor(int i = 0; i < G.size(); i++){\n\t\tstart = G[i];\n\t\tUSED[start] = true;\n\n\t\twhile(!D[start].empty()){\n\t\t\tgoal = D[start].top();\n\t\t\tD[start].pop();\n\t\t\tUSED[goal] = true;\n\n\t\t\tfor(int k = 1; k <= N; k++){\n\t\t\t\tif(maximum == MIN_COST[start][k] + MIN_COST[k][goal])USED[k] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tint num = 0;\n\n\tfor(int i = 1; i <= N; i++)if(USED[i] == false)num++;\n\n\tprintf(\"%d\\n\",num);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(USED[i] == false){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t}\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nlist<P>E[1500];\nint d[1500][1500];\nlist<int>pre[1500][1500];\nbool b[1500];\nint main() {\n\tint n, r; scanf(\"%d%d\", &n, &r);\n\trep(i, r) {\n\t\tint s, t, d; scanf(\"%d%d%d\", &s, &t, &d); s--; t--;\n\t\tE[s].push_back(P(d, t));\n\t\tE[t].push_back(P(d, s));\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, n) {\n\t\td[i][i] = 0;\n\t\tque.push(P(0, i));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (p.first != d[i][p.second])continue;\n\t\t\tfor (P v : E[p.second]) {\n\t\t\t\tif (d[i][v.second] == p.first + v.first)\n\t\t\t\t\tpre[i][v.second].push_back(p.second);\n\t\t\t\tif (d[i][v.second] > p.first + v.first) {\n\t\t\t\t\tpre[i][v.second].clear();\n\t\t\t\t\tpre[i][v.second].push_back(p.second);\n\t\t\t\t\td[i][v.second] = p.first + v.first;\n\t\t\t\t\tque.push(P(d[i][v.second], v.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Max = 0;\n\trep(i, n)rep(j, n)Max = max(Max, d[i][j]);\n\trep(i, n)rep(j, n) {\n\t\tif (d[i][j] != Max)continue;\n\t\tqueue<int>que;\n\t\tque.push(j);\n\t\twhile (!que.empty()) {\n\t\t\tint d = que.front(); que.pop();\n\t\t\tb[d] = true;\n\t\t\tfor (int j : pre[i][d])que.push(j);\n\t\t}\n\t}\n\tlist<int>v;\n\trep(i, n) {\n\t\tif (!b[i])v.push_back(i + 1);\n\t}\n\tprintf(\"%d\\n\", v.size());\n\tfor (int i : v)printf(\"%d\\n\", i);\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0351\n\n#include<bits/stdc++.h>\nconst int N = 1505;\nconst int inf = 1e9;\nusing namespace std;\n\ntypedef pair <int, int> ii;\nvector <ii> adj[N];\nint n, m, d[N][N], ans, visit[N], f[N], ck[N];\n\nvoid dijkstra(int S){\n    for (int i = 1; i <= n; i++) d[S][i] = inf; d[S][S] = 0;\n    priority_queue <ii, vector <ii>, greater<ii> > mq; mq.push(ii(d[S][S], S));\n    while (mq.size()){\n        ii z = mq.top(); mq.pop();\n        int u = z.second, val = z.first;\n        if (val != d[S][u]) continue;\n        ans = max(ans, val);\n        for (int i = 0; i < adj[u].size(); i++){\n            int v = adj[u][i].first, cost = adj[u][i].second;\n            if (d[S][v] > d[S][u] + cost){\n                d[S][v] = d[S][u] + cost;\n                mq.push(ii(d[S][v], v));\n            }\n        }\n    }\n}\n\nvoid dfs(int u, int root){\n    if (visit[u]) return;\n    visit[u] = true;\n    f[u] = d[root][u];\n    for (int i = 0; i < adj[u].size(); i++){\n        int v = adj[u][i].first, cost = adj[u][i].second;\n        if (d[root][v] == d[root][u] + cost){\n            dfs(v, root); f[u] = max(f[u], f[v]);\n        }\n    }\n    if (f[u] == ans) ck[u] = 1;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++){\n        int u, v, d; cin >> u >> v >> d;\n        adj[u].push_back(ii(v, d));\n        adj[v].push_back(ii(u, d));\n    }\n    for (int i = 1; i <= n; i++) dijkstra(i);\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++) visit[j] = 0;\n        dfs(i, i);\n    }\n    int cnt = 0; for (int i = 1; i <= n; i++) if (!ck[i]) cnt++;\n    cout << cnt << \"\\n\";\n    for (int i = 1; i <= n; i++) if (!ck[i]) cout << i << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  while(1) {\n    mp[j] = 1;\n    if(j == i) break;\n    rep(k, 0, g[j].size()) {\n      edge e = g[j][k];\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        j = e.to;\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nint mp[1501];\n\ninline void dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\ninline void solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  int mpp[1501] = {};\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    mpp[tp] = 1;\n    if(tp == i) continue;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(mpp[e.to]) continue;\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> #define FOR(i, a, b) for (int i = a; i <= (int) b; ++i) #define ii pair <int, int> using namespace std; const int N = 1503; int n, m; vector <ii> adj[N]; void init() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); freopen(\"main.inp\",\"r\",stdin); freopen(\"main.out\",\"w\",stdout); } priority_queue <ii, vector <ii>, greater <ii> > Q; int d[N][N], Max; void dijk(int st) { d[st][st] = 0; Q.push({ 0, st }); while (Q.size()) { int u = Q.top().second, du = Q.top().first; Q.pop(); if (du != d[st][u]) continue; Max = max(Max, du); for (ii it : adj[u]) { int v = it.second, w = it.first; if (d[st][v] > du + w) d[st][v] = du + w, Q.push({ d[st][v], v }); } } } queue <int> dm; int vis[N]; void trace(int st) { FOR(i, 1, n) if (d[st][i] == Max) dm.push(i), vis[i] = st; while (dm.size()) { int u = dm.front(); dm.pop(); for (ii it : adj[u]) { int v = it.second, w = it.first; if (d[st][u] == d[st][v] + w && vis[v] < st) vis[v] = st, dm.push(v); } } } void solve() { cin >> n >> m; FOR(i, 1, m) { int u, v, w; cin >> u >> v >> w; adj[u].push_back({ w, v }), adj[v].push_back({ w, u }); } memset(d, 0x3f, sizeof d); FOR(i, 1, n) dijk(i); FOR(i, 1, n) trace(i); int dem = 0; FOR(i, 1, n) if (vis[i] == 0) ++dem; cout << dem << '\\n'; FOR(i, 1, n) if (vis[i] == 0) cout << i << '\\n'; } main() { init(); solve(); }\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 3100\n\n/* Dijkstra O(NlogM)*/\n\nstruct Dijkstra{\n\n  typedef int Type;\n\n  int V;\n  vector<vector<pair<int,Type> > > G;\n  vector<int> cost;\n  \n  Dijkstra(int n):\n    V(n),G(n,vector<pair<int,Type> >()){}\n  \n  void add_edge(int u, int v, Type c){\n    G[u].push_back({v,c});\n  }\n  \n  Type solve(int s, int g = -1){\n    cost.assign(V,-INF);\n    priority_queue<pair<Type,int> > pq;\n    Type max_cost = 0;\n    \n    pq.push({0,s});\n\n    while(pq.size()){\n      Type now_cost = pq.top().first;\n      int now = pq.top().second;\n      pq.pop();\n\n      if(cost[now] >= 0) continue;\n      \n      cost[now] = -now_cost;\n      max_cost = max(max_cost, -now_cost);\n      \n      if(now == g) return -now_cost;\n      \n      for(int i=0;i<(int)G[now].size();i++){\n        pq.push({now_cost-G[now][i].second, G[now][i].first});\n      }\n    }\n        \n    return max_cost;\n  }\n  \n};\n\n\nint main(){\n  int n,r;\n  int s[SIZE],t[SIZE],d[SIZE];\n  bool ans[SIZE] = {};\n  \n  scanf(\"%d%d\",&n,&r);\n\n  Dijkstra dij(n);\n  \n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",s+i,t+i,d+i);\n    s[i]--; t[i]--;\n    \n    dij.add_edge(t[i],s[i],d[i]);\n    dij.add_edge(s[i],t[i],d[i]);\n  }\n\n  int ans_dis = 0;\n  \n  for(int i=0;i<n;i++){\n    int max_dis = dij.solve(i);\n\n    if(max_dis > ans_dis){\n      for(int j=0;j<n;j++) ans[i] = false;\n      ans_dis = max_dis;\n    }\n\n    if(max_dis < ans_dis) continue;\n    \n    queue<int> que;\n    bool visited[SIZE] = {};\n    \n    for(int j=0;j<n;j++){\n      if(max_dis == dij.cost[j]){\n        que.push(j);\n      }\n    }\n\n    while(que.size()){\n      int p = que.front();\n      que.pop();\n      \n      if(visited[p]) continue;\n      visited[p] = true;\n      ans[p] = true;\n      \n      for(int j=0;j<dij.G[p].size();j++){\n        if(dij.cost[p] - dij.G[p][j].second == dij.cost[dij.G[p][j].first]){\n          que.push(dij.G[p][j].first);\n        }\n      }\n    }\n  }\n\n  int ans_count = 0;\n  for(int i=0;i<n;i++) ans_count += ans[i] == false;\n\n  printf(\"%d\\n\",ans_count);\n  \n  for(int i=0;i<n;i++){\n    if(ans[i] == false){\n      printf(\"%d\\n\",i+1);\n    }\n  }\n  \n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <limits>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct edge {\n\tint to, cost;\n\tedge(int to_, int cost_) : to(to_), cost(cost_) {};\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\ntemplate<class Type>\nstd::vector<Type> shortest_path(std::vector<std::vector<edge> > &G, int s) {\n\tstd::priority_queue<edge> que; que.push(edge(s, 0));\n\tstd::vector<Type> ret(G.size(), std::numeric_limits<Type>::max()); ret[s] = 0;\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tif (ret[e.to] > ret[u.to] + e.cost) {\n\t\t\t\tret[e.to] = ret[u.to] + e.cost;\n\t\t\t\tque.push(edge(e.to, -ret[e.to]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nstd::vector<vector<int> > shortest_path_tree_all(std::vector<std::vector<edge> > &G, int s) {\n\tstd::priority_queue<edge> que; que.push(edge(s, 0));\n\tstd::vector<long long> ret(G.size(), std::numeric_limits<long long>::max()); ret[s] = 0;\n\tvector<vector<int> > res(G.size());\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tif (ret[e.to] > ret[u.to] + e.cost) {\n\t\t\t\tret[e.to] = ret[u.to] + e.cost;\n\t\t\t\tres[e.to].clear();\n\t\t\t\tque.push(edge(e.to, -ret[e.to]));\n\t\t\t}\n\t\t\tif (ret[e.to] == ret[u.to] + e.cost) {\n\t\t\t\tres[e.to].push_back(u.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint n, m, a, b, c;\nint main() {\n\tcin >> n >> m;\n\tvector<vector<edge> > G(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b >> c; a--, b--;\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, c));\n\t}\n\tvector<vector<int> > d(n);\n\tfor (int i = 0; i < n; i++) d[i] = shortest_path<int>(G, i);\n\tint x = -1;\n\tvector<vector<int> > p;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (d[i][j] > x) x = d[i][j];\n\t\t\tif (d[i][j] == x) p.push_back({ i, j });\n\t\t}\n\t}\n\tvector<bool> ret(n, false);\n\tfor (vector<int> g : p) {\n\t\tvector<vector<int> > f = shortest_path_tree_all(G, g[0]);\n\t\tqueue<int> que; que.push(g[1]);\n\t\tvector<bool> vis(n, false); vis[g[1]] = true; ret[g[1]] = true;\n\t\twhile (!que.empty()) {\n\t\t\tint u = que.front(); que.pop();\n\t\t\tfor (int i : f[u]) {\n\t\t\t\tif (!vis[i]) {\n\t\t\t\t\tvis[i] = true;\n\t\t\t\t\tret[i] = true;\n\t\t\t\t\tque.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!ret[i]) cnt++;\n\t}\n\tcout << cnt << endl;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!ret[i]) cout << i + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <limits>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct edge {\n\tint to, cost;\n\tedge(int to_, int cost_) : to(to_), cost(cost_) {};\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\ntemplate<class Type>\nstd::vector<Type> shortest_path(std::vector<std::vector<edge> > &G, int s) {\n\tstd::priority_queue<edge> que; que.push(edge(s, 0));\n\tstd::vector<Type> ret(G.size(), std::numeric_limits<Type>::max()); ret[s] = 0;\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tif (ret[e.to] > ret[u.to] + e.cost) {\n\t\t\t\tret[e.to] = ret[u.to] + e.cost;\n\t\t\t\tque.push(edge(e.to, -ret[e.to]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nstd::vector<vector<int> > shortest_path_tree_all(std::vector<std::vector<edge> > &G, int s) {\n\tstd::priority_queue<edge> que; que.push(edge(s, 0));\n\tstd::vector<long long> ret(G.size(), std::numeric_limits<long long>::max()); ret[s] = 0;\n\tvector<vector<int> > res(G.size());\n\twhile (!que.empty()) {\n\t\tedge u = que.top(); que.pop();\n\t\tfor (edge e : G[u.to]) {\n\t\t\tif (ret[e.to] > ret[u.to] + e.cost) {\n\t\t\t\tret[e.to] = ret[u.to] + e.cost;\n\t\t\t\tres[e.to].clear();\n\t\t\t\tque.push(edge(e.to, -ret[e.to]));\n\t\t\t}\n\t\t\tif (ret[e.to] == ret[u.to] + e.cost) {\n\t\t\t\tres[e.to].push_back(u.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint n, m, a, b, c;\nint main() {\n\tcin >> n >> m;\n\tvector<vector<edge> > G(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b >> c; a--, b--;\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, c));\n\t}\n\tvector<vector<int> > d(n);\n\tfor (int i = 0; i < n; i++) d[i] = shortest_path<int>(G, i);\n\tint x = -1;\n\tvector<vector<int> > p;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (d[i][j] > x) x = d[i][j], p.clear();\n\t\t\tif (d[i][j] == x) p.push_back({ i, j });\n\t\t}\n\t}\n\tvector<vector<int> > gp(n);\n\tfor (vector<int> i : p) {\n\t\tgp[i[0]].push_back(i[1]);\n\t\tgp[i[1]].push_back(i[0]);\n\t}\n\tvector<bool> ret(n, false);\n\tfor (int t = 0; t < n; t++) {\n\t\tvector<vector<int> > f = shortest_path_tree_all(G, t);\n\t\tqueue<int> que; vector<bool> vis(n, false);\n\t\tfor (int t2 : gp[t]) {\n\t\t\tque.push(t2);\n\t\t\tvis[t2] = true;\n\t\t\tret[t2] = true;\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tint u = que.front(); que.pop();\n\t\t\tfor (int i : f[u]) {\n\t\t\t\tif (!vis[i]) {\n\t\t\t\t\tvis[i] = true;\n\t\t\t\t\tret[i] = true;\n\t\t\t\t\tque.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!ret[i]) cnt++;\n\t}\n\tcout << cnt << endl;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!ret[i]) cout << i + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <bitset>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\n#define PB push_back\nconst int N=3e3+10;\nconst int INF=1e9+10;\nint max(int a,int b){return a>b?a:b;}\nint main(){\n    int n,m,dis[N][N],top=0,l,r,d;\n    bool f;\n    bitset<N> used,went;\n    priority_queue<pi,vector<pi>,greater<pi>>pq;\n    pi now;\n    vector<int> ans;\n    vector<pi> graph[N],v;\n    scanf(\"%d%d\",&n,&m);\n    while(m--){\n        scanf(\"%d%d%d\",&l,&r,&d);\n        graph[l].PB({r,d});\n        graph[r].PB({l,d});\n    }\n    used.reset();\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)dis[i][j]=INF;\n    for(int i=1;i<=n;i++){\n        went.reset();\n        pq.push({0,i});\n        dis[i][i]=0;\n        while(!pq.empty()){\n            now=pq.top();\n            pq.pop();\n            if(!went[now.S]){\n                went[now.S]=true;\n                for(pi j:graph[now.S])if(j.S+now.F<dis[i][j.F]){\n                    dis[i][j.F]=j.S+now.F;\n                    pq.push({dis[i][j.F],j.F});\n                }\n            }\n        }\n    }\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(dis[i][j]==top)v.PB({i,j});\n    else if(dis[i][j]>top){\n        top=dis[i][j];\n        v.clear();\n        v.PB({i,j});\n    }\n    for(int i=1;i<=n;i++)for(pi j:graph[i])if(!(used[i]&&used[j.F])){\n        f=false;\n        for(pi u:v)if(dis[u.F][i]+j.S+dis[j.F][u.S]==top||dis[u.F][j.F]+j.S+dis[i][u.S]==top){\n            f=true;\n            break;\n        }\n        if(f)used[i]=used[j.F]=true;\n    }\n    for(int i=1;i<=n;i++)if(!used[i])ans.PB(i);\n    printf(\"%ld\\n\",ans.size());\n    for(int i:ans)printf(\"%d\\n\",i);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b)    for (int i = a; i <= (int) b; ++i)\n#define ii              pair <int, int>\nusing namespace std;\nconst int N = 1503;\nint n, m;\nvector <ii> adj[N];\n\nvoid init() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    freopen(\"main.inp\",\"r\",stdin);\n    freopen(\"main.out\",\"w\",stdout);\n}\n\npriority_queue <ii, vector <ii>, greater <ii> > Q;\nint d[N][N], Max;\nvoid dijk(int st) {\n    d[st][st] = 0; Q.push({ 0, st });\n    while (Q.size()) {\n        int u = Q.top().second, du = Q.top().first;\n        Q.pop();\n        if (du != d[st][u]) continue;\n        Max = max(Max, du);\n        for (ii it : adj[u]) {\n            int v = it.second, w = it.first;\n            if (d[st][v] > du + w) d[st][v] = du + w, Q.push({ d[st][v], v });\n        }\n    }\n}\n\nqueue <int> dm;\nint vis[N];\nvoid trace(int st) {\n    FOR(i, 1, n) if (d[st][i] == Max) dm.push(i), vis[i] = st;\n    while (dm.size()) {\n        int u = dm.front(); dm.pop();\n        for (ii it : adj[u]) {\n            int v = it.second, w = it.first;\n            if (d[st][u] == d[st][v] + w && vis[v] < st) vis[v] = st, dm.push(v);\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n >> m;\n    FOR(i, 1, m) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        adj[u].push_back({ w, v }), adj[v].push_back({ w, u });\n    }\n\n    memset(d, 0x3f, sizeof d);\n    FOR(i, 1, n) dijk(i);\n\n    FOR(i, 1, n) trace(i);\n    int dem = 0;\n    FOR(i, 1, n) if (vis[i] == 0) ++dem;\n    cout << dem << '\\n';\n    FOR(i, 1, n) if (vis[i] == 0) cout << i << '\\n';\n}\n\nmain() {\n    init(); solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1505;\nconst int INF = 1e9;\ntypedef pair<int,int> ii;\n\nint n, m;\nvector <ii> g[N];\nvector <int> rev[N];\nint d[N][N];\nint deg[N];\nbool ok[N];\nint mx;\n\nvoid dijkstra(int s) {\n    for (int i = 1; i <= n; ++i) d[s][i] = INF;\n    d[s][s] = 0;\n    priority_queue < ii, vector<ii>, greater<ii> > pq;\n    pq.push(ii(0, s));\n\n    while(!pq.empty()) {\n        ii top = pq.top(); pq.pop();\n        int u = top.second, du = top.first;\n        if (du != d[s][u]) continue;\n\n        for (auto &e : g[u]) {\n            int v = e.second, w = e.first;\n            if (d[s][v] > d[s][u] + w) {\n                pq.push(ii(d[s][v] = d[s][u] + w, v));\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n >> m;\n    while(m--) {\n        int u, v, w; cin >> u >> v >> w;\n        g[u].push_back(make_pair(w, v));\n        g[v].push_back(make_pair(w, u));\n    }\n    for (int i = 1; i <= n; ++i) {\n        dijkstra(i);\n        for (int j = 1; j <= n; ++j) {\n            mx = max(mx, d[i][j]);\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) deg[j] = 0, rev[j].clear();\n        for (int j = 1; j <= n; ++j) {\n            for (auto &e : g[j]) if (d[i][j] + e.first == d[i][e.second]) {\n                ++deg[j];\n                rev[e.second].push_back(j);\n            }\n        }\n        // solve\n        queue<int> q;\n        for (int j = 1; j <= n; ++j) if (d[i][j] == mx) q.push(j);\n        while(!q.empty()) {\n            int u = q.front(); q.pop();\n            ok[u] = true;\n            for (int &v : rev[u]) {\n                if (--deg[v] == 0) q.push(v);\n            }\n        }\n    }\n\n    int res = 0;\n    for (int i = 1; i <= n; ++i) if (!ok[i]) ++res;\n    printf(\"%d\\n\", res);\n    for (int i = 1; i <= n; ++i) if (!ok[i]) printf(\"%d\\n\", i);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int from, to, weight;\n  Edge(int f, int t, int w) : from(f), to(t), weight(w) {}\n};\nusing Graph = vector<vector<Edge>>;\n\npair<int, vector<int>> Dijkstra(auto& G, auto s) {\n  int b = 0;\n  vector<int> d(G.size(), -1);\n  using Node = pair<int, int>;\n  priority_queue<Node, vector<Node>, greater<Node>> q;\n  q.emplace(0, s);\n  while(!q.empty()) {\n    int cost, v;\n    tie(cost, v) = q.top();\n    q.pop();\n    if(~d[v]) continue;\n    d[v] = cost;\n    b = max(b, cost);\n    for(auto& e: G[v]) if(! ~d[e.to]) q.emplace(cost + e.weight, e.to);\n  }\n  return {b, d};\n}\n\nset<int> exclusion(auto& G, auto s, auto b, auto& d) {\n  vector<int> ok(G.size());\n  function<int(int, int)> dfs = [&](int cost, int v) {\n    if(ok[v]) return ok[v];\n    if(d[v] == b) return ok[v] = 1;\n    for(auto& e: G[v]) if(d[e.to] == cost + e.weight) if(dfs(cost + e.weight, e.to) == 1) return ok[v] = 1;\n    return ok[v] = -1;\n  };\n  dfs(0, s);\n  set<int> result;\n  for(auto i = 0; i < G.size(); ++i) if(! ~ok[i]) result.insert(i);\n  return result;\n}\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  Graph G(N);\n  for(auto i = 0; i < M; ++i) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    --s, --t;\n    G[s].emplace_back(s, t, d);\n    G[t].emplace_back(t, s, d);\n  }\n\n  int best = 0;\n  vector<pair<int, set<int>>> result;\n  for(auto s = 0; s < N; ++s) {\n    int b;\n    vector<int> d;\n    tie(b, d) = Dijkstra(G, s);\n    best = max(best, b);\n    result.emplace_back(b, exclusion(G, s, b, d));\n  }\n\n  set<int> answer;\n  for(auto& i: result) if(i.first == best) answer.insert(begin(i.second), end(i.second));\n  cout << answer.size() << endl;\n  for(auto i: answer) cout << i + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n4 5\n1 2 2\n1 3 2\n2 3 1\n2 4 2\n3 4 1\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pti;\n\nconst int N = 1505, inf = 1e9;\nvector<pti> child[N];\nvector<int> Adj[N];\nint d[N], mark[N], n, r;\n\nint main(){\n\tscanf(\"%d%d\", &n, &r);\n\tfor(int i = 1; i <= r; ++i) {\n\t\tint u, v, w; scanf(\"%d%d%d\", &u, &v, &w);\n\t\tchild[u].push_back(make_pair(v, w));\n\t\tchild[v].push_back(make_pair(u, w));\n\t}\n\n\tint maxdist = - inf;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = 1; j <= n; ++j) d[j] = inf;\n\n\t\tpriority_queue<pti, vector<pti>, greater<pti> > q;\n\t\td[i] = 0;\n\t\tq.push(make_pair(0, i));\n\n\t\twhile(!q.empty()) {\n\t\t\tpti u = q.top(); q.pop();\n\t\t\tif(u.first != d[u.second]) continue;\n\t\t\tfor(auto v : child[u.second])\n\t\t\t\tif(d[v.first] > u.first + v.second) {\n\t\t\t\t\td[v.first] = u.first + v.second;\n\t\t\t\t\tq.push(make_pair(d[v.first], v.first));\n\t\t\t\t}\n\t\t}\n\t\tfor(int j = 1; j <= n; ++j) maxdist = max(maxdist, d[j]);\n\t}\n\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = 1; j <= n; ++j) d[j] = inf, Adj[i].clear();\n\n\t\tpriority_queue<pti, vector<pti>, greater<pti> > q;\n\t\tqueue<int> qu;\n\t\td[i] = 0;\n\t\tq.push(make_pair(0, i));\n\n\t\twhile(!q.empty()) {\n\t\t\tpti u = q.top(); q.pop();\n\t\t\tif(u.first != d[u.second]) continue;\n\t\t\tif(u.first == maxdist) qu.push(u.second);\n\n\t\t\tfor(auto v : child[u.second])\n\t\t\t\tif(d[v.first] > u.first + v.second) {\n\t\t\t\t\td[v.first] = u.first + v.second;\n\t\t\t\t\tAdj[v.first].clear(), Adj[v.first].push_back(u.second);\n\t\t\t\t\tq.push(make_pair(d[v.first], v.first));\n\t\t\t\t}\n\t\t\t\telse if(d[v.first] == u.first + v.second) \n\t\t\t\t\tAdj[v.first].push_back(u.second);\n\t\t}\n\n\t\twhile(qu.size()) {\n\t\t\tint u = qu.front(); qu.pop(); mark[u] = 1;\n\t\t\tfor(int v : Adj[u])\tmark[v] = 1, qu.push(v);\n\t\t}\n\t}\n\n\tvector<int> res;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(mark[i] == 0) res.push_back(i);\n\n\tprintf(\"%d\\n\", (int)res.size());\n\tfor(int v : res) printf(\"%d\\n\", v);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nconst int INF = 1 << 29;\n\nint N, R;\nint A[3000], B[3000], D[3000];\nint cost[1500][1500];\nbool used[1500], v[1500];\nvector< int > g[1500];\n\nvoid dfs(int idx, int *dist)\n{\n  if(v[idx]++) return;\n  used[idx]++;\n  for(auto &i : g[idx]) {\n    if(A[i] == idx && dist[B[i]] + D[i] == dist[idx]) dfs(B[i], dist);\n    if(B[i] == idx && dist[A[i]] + D[i] == dist[idx]) dfs(A[i], dist);\n  }\n}\n\nint main()\n{\n  fill_n(*cost, 1500 * 1500, INF);\n  rep(i, 1500) cost[i][i] = 0;\n\n  cin >> N >> R;\n  rep(i, R) {\n    cin >> A[i] >> B[i] >> D[i];\n    --A[i], --B[i];\n    cost[A[i]][B[i]] = cost[B[i]][A[i]] = D[i];\n    g[A[i]].push_back(i);\n    g[B[i]].push_back(i);\n  }\n  rep(i, N) rep(j, N) rep(k, N) cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\n  int ret = 0;\n  rep(i, N) rep(j, N) if(cost[i][j] != INF) ret = max(ret, cost[i][j]);\n\n  rep(i, N) {\n    memset(v, false, sizeof(v));\n    rep(j, N) if(cost[i][j] == ret) dfs(j, cost[i]);\n  }\n  cout << count(used, used + N, false) << endl;\n  rep(i, N) if(!used[i]) cout << i + 1 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int from, to, weight;\n  Edge(int f, int t, int w) : from(f), to(t), weight(w) {}\n};\nusing Graph = vector<vector<Edge>>;\n\npair<int, vector<int>> Dijkstra(auto& G, auto s) {\n  int b = 0;\n  vector<int> d(G.size(), -1);\n  using Node = pair<int, int>;\n  priority_queue<Node, vector<Node>, greater<Node>> q;\n  q.emplace(0, s);\n  while(!q.empty()) {\n    int cost, v;\n    tie(cost, v) = q.top();\n    q.pop();\n    if(~d[v]) continue;\n    d[v] = cost;\n    b = max(b, cost);\n    for(auto& e: G[v]) if(! ~d[e.to]) q.emplace(cost + e.weight, e.to);\n  }\n  return {b, d};\n}\n\nset<int> exclusion(auto& G, auto s, auto b, auto& d) {\n  vector<int> ok(G.size());\n  function<int(int, int)> dfs = [&](int cost, int v) {\n    if(ok[v]) return ok[v];\n    if(d[v] == b) return ok[v] = 1;\n    for(auto& e: G[v]) if(d[e.to] == cost + e.weight) if(dfs(cost + e.weight, e.to) == 1) return ok[v] = 1;\n    return ok[v] = -1;\n  };\n  dfs(0, s);\n  set<int> result;\n  for(auto i = 0; i < G.size(); ++i) if(ok[i] != 1) result.insert(i);\n  return result;\n}\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  Graph G(N);\n  for(auto i = 0; i < M; ++i) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    --s, --t;\n    G[s].emplace_back(s, t, d);\n    G[t].emplace_back(t, s, d);\n  }\n\n  int best = 0;\n  vector<pair<int, set<int>>> result;\n  for(auto s = 0; s < N; ++s) {\n    int b;\n    vector<int> d;\n    tie(b, d) = Dijkstra(G, s);\n    best = max(best, b);\n    result.emplace_back(b, exclusion(G, s, b, d));\n  }\n\n  set<int> answer;\n  for(auto& i: result) if(i.first == best) answer.insert(begin(i.second), end(i.second));\n  cout << answer.size() << endl;\n  for(auto i: answer) cout << i + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_town,int arg_cost){\n\t\ttown = arg_town;\n\t\tcost = arg_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn cost > arg.cost;\n\t};\n\tint town,cost;\n};\n\nstruct Dist{\n\tDist(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nstruct Data{\n\tData(int arg_start,int arg_goal){\n\t\tstart = arg_start;\n\t\tgoal = arg_goal;\n\t}\n\tint start,goal;\n};\n\nint main(){\n\n\tint N,R,s,t,d;\n\tscanf(\"%d %d\",&N,&R);\n\n\tvector<Dist> V[N+1];\n\tint** MIN_COST = new int*[N+1];\n\tfor(int i = 1; i <= N; i++){\n\t\tMIN_COST[i] = new int[N+1];\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tif(i != k)MIN_COST[i][k] = BIG_NUM;\n\t\t\telse{\n\t\t\t\tMIN_COST[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d %d %d\",&s,&t,&d);\n\t\tV[s].push_back(Dist(t,d));\n\t\tV[t].push_back(Dist(s,d));\n\t}\n\n\tint maximum = -1,min_index;\n\tstack<Data> S;\n\tpriority_queue<Info> Q;\n\tqueue<int> WORK;\n\tvector<int> ANS;\n\tvector<int> PRE_TOWN[N+1];\n\n\tbool* VISITED = new bool[N+1];\n\n\tfor(int from = 1; from <= N;from++){\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tPRE_TOWN[i].clear();\n\t\t\tPRE_TOWN[i].push_back(from);\n\t\t}\n\n\t\tfor(int i = 0; i < V[from].size();i++){\n\t\t\tMIN_COST[from][V[from][i].to] = V[from][i].cost;\n\t\t\tQ.push(Info(V[from][i].to,V[from][i].cost));\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().cost > MIN_COST[from][Q.top().town]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tmin_index = Q.top().town;\n\t\t\t\tQ.pop();\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V[min_index].size(); i++){\n\t\t\t\tif(MIN_COST[from][V[min_index][i].to] > MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\tMIN_COST[from][V[min_index][i].to] = MIN_COST[from][min_index] + V[min_index][i].cost;\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].clear();\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t\tQ.push(Info(V[min_index][i].to,MIN_COST[from][V[min_index][i].to]));\n\t\t\t\t}else if(MIN_COST[from][V[min_index][i].to] == MIN_COST[from][min_index] + V[min_index][i].cost){\n\t\t\t\t\tPRE_TOWN[V[min_index][i].to].push_back(min_index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(maximum <= MIN_COST[from][i]){\n\t\t\t\tif(maximum < MIN_COST[from][i]){\n\t\t\t\t\tANS.clear();\n\t\t\t\t}\n\t\t\t\tmaximum = MIN_COST[from][i];\n\n\t\t\t\tfor(int k = 1; k <= N; k++)VISITED[k] = false;\n\n\t\t\t\tWORK.push(i);\n\t\t\t\tVISITED[i] = true;\n\t\t\t\tANS.push_back(i);\n\n\t\t\t\twhile(!WORK.empty()){\n\t\t\t\t\tfor(int k = 0; k < PRE_TOWN[WORK.front()].size(); k++){\n\t\t\t\t\t\tif(VISITED[PRE_TOWN[WORK.front()][k]] == false){\n\t\t\t\t\t\t\tVISITED[PRE_TOWN[WORK.front()][k]] = true;\n\t\t\t\t\t\t\tANS.push_back(PRE_TOWN[WORK.front()][k]);\n\t\t\t\t\t\t\tWORK.push(PRE_TOWN[WORK.front()][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tWORK.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool* USED = new bool[N+1];\n\tfor(int i = 1; i <= N; i++)USED[i] = false;\n\n\tfor(int i = 0; i < ANS.size(); i++)USED[ANS[i]] = true;\n\n\tint num = 0;\n\n\tfor(int i = 1; i <= N; i++)if(USED[i] == false)num++;\n\n\tprintf(\"%d\\n\",num);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(USED[i] == false){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t}\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nint mp[1501];\n\ninline void dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      if(d[s][g[v][i].to] > d[s][v] + g[v][i].cost) {\n        d[s][g[v][i].to] = d[s][v] + g[v][i].cost;\n        que.push(P(d[s][g[v][i].to], g[v][i].to));\n      }\n    }\n  }\n}\n\ninline void solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  int mmp[1501] = {};\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mmp[tp] = 1;\n    rep(k, 0, g[tp].size()) {\n      if(d[i][tp] == d[i][g[tp][k].to] + g[tp][k].cost && !mmp[g[tp][k].to]) {\n        st.push(g[tp][k].to);\n      }\n    }\n  }\n  rep(i, 1, n + 1) {\n    if(mmp[i]) mp[i] = 1;\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) {\n        mp[i] = 1;\n        solve(i, j);\n      }\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int INF = 1e9;\nconst int MAX_N = 1500 + 9;\nvector<pair<int, int> > g[MAX_N], Path;\nint n, m, maxDist;\nint dist[MAX_N][MAX_N];\nbool used[MAX_N];\n\nvoid read(){\n    cin >> n >> m;\n    for(int i = 0; i < m; i++){\n        int u, v, w;\n        cin >> u >> v >> w;\n        g[u].push_back(make_pair(v, w));\n        g[v].push_back(make_pair(u, w));\n    }\n}\n\nvoid dijk(int s){\n    for(int i = 1; i <= n; i++)\n        dist[s][i] = INF;\n\n    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    dist[s][s] = 0; pq.push(make_pair(dist[s][s], s));\n    while(!pq.empty()){\n        int du = pq.top().first, u = pq.top().second; pq.pop();\n\n        if(du != dist[s][u])\n            continue;\n\n        for(int i = 0, L = g[u].size(); i < L; i++){\n            int v = g[u][i].first;\n            int w = g[u][i].second;\n            if(dist[s][v] > dist[s][u] + w){\n                dist[s][v] = dist[s][u] + w;\n                pq.push(make_pair(dist[s][v], v));\n            }\n        }\n    }\n}\n\nvoid solve(){\n    for(int i = 1; i <= n; i++)\n        dijk(i);\n\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            maxDist = max(maxDist, dist[i][j]);\n\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            if(dist[i][j] == maxDist)\n                Path.push_back(make_pair(i, j));\n\n    for(int i = 1; i <= n; i++)\n        if(!used[i]){\n            for(int j = 0, L = Path.size(); j < L; j++){\n                int u = Path[j].first, v = Path[j].second;\n                if(dist[u][i] + dist[i][v] == dist[u][v]){\n                    used[i] = true;\n                    break;\n                }\n            }\n        }\n\n    int res = 0;\n    for(int i = 1; i <= n; i++)\n        if(!used[i])    res++;\n\n    cout << res << '\\n';\n    for(int i = 1; i <= n; i++)\n        if(!used[i])    cout << i << '\\n';\n}\n\nint main()\n{\n    read();\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nint mp[1501];\n\ninline void dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\ninline void solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    if(tp == i) continue;\n    rep(k, 0, g[tp].size()) {\n      if(d[i][tp] == d[i][g[tp][k].to] + g[tp][k].cost && g[tp][k].to != i) {\n        st.push(g[tp][k].to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) {\n        mp[i] = 1;\n        solve(i, j);\n      }\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nint n,m,u,v,w;\nint dis[1507][1507],vis[1507],ans[1507],ret=0,mx=0;\nvector < pair<int,int> > edge[1507];\nvector < int > ed[1507];\nconst int inf=1e9;\nqueue <int> q;\nvoid dijkstra(int st){\n\tpriority_queue < pair<int,int> , vector < pair<int,int> > , greater < pair<int,int> > > pr;\n\tpr.push(mp(0,st));\n\twhile(!pr.empty()){\n\t\tint u=pr.top().se;\n\t\tint val=pr.top().fi;\n\t\tpr.pop();\n\t\tif(dis[st][u]!=val) continue;\n\t\tfor(int i=0;i<(int)edge[u].size();i++){\n\t\t\tint v=edge[u][i].fi;\n\t\t\tint w=edge[u][i].se;\n\t\t\tif(val+w<dis[st][v]){\n\t\t\t\tdis[st][v]=val+w;\n\t\t\t\tpr.push(mp(dis[st][v],v));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>u>>v>>w;\n\t\tedge[u].pb(mp(v,w));\n\t\tedge[v].pb(mp(u,w));\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j) dis[i][j]=0;\n\t\t\telse dis[i][j]=inf;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdijkstra(i);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tmx=max(mx,dis[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++) ed[j].clear(), vis[j]=0;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=0;k<(int)edge[j].size();k++){\n\t\t\t\tint v=edge[j][k].fi;\n\t\t\t\tint w=edge[j][k].se;\n\t\t\t\tif(dis[i][j]+w==dis[i][v]){\n\t\t\t\t\ted[v].pb(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dis[i][j]==mx){\n\t\t\t\tq.push(j);\n\t\t\t\tvis[j]=1;\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();\n\t\t\tq.pop();\n\t\t\tans[u]=1;\n\t\t\tfor(int v:ed[u]){\n\t\t\t\tif(vis[v]) continue;\n\t\t\t\tvis[v]=1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) ret+=(ans[i]==0) ? 1:0;\n\tcout<<ret<<\"\\n\";\n\tfor(int i=1;i<=n;i++){\n\t\tif(ans[i]==0) cout<<i<<\"\\n\";\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nvector< vector<edge> > graph;\nvector< vector<int> > mincost;\n\nvoid dijkstra(int s)\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  mincost[s][s] = 0;\n  while(!que.empty()) {\n    int cost, now;\n    tie(cost, now) = que.top(); que.pop();\n    if(mincost[s][now] < cost) continue;\n    for(edge& e : graph[now]) {\n      if(e.cost + cost < mincost[s][e.to]) {\n\tmincost[s][e.to] = e.cost + cost;\n\tque.push(P(mincost[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, R;\n  cin >> N >> R;\n  graph.resize(N);\n  rep(i, R) {\n    int s, t, d;\n    cin >> s >> t >> d; s--, t--;\n    graph[s].emplace_back(t, d);\n    graph[t].emplace_back(s, d);\n  }\n\n  mincost.resize(N, vector<int>(N, inf));\n  int maxdist = 0;\n  rep(i, N) dijkstra(i);\n  rep(i, N) reps(j, i+1, N) maxdist = max(maxdist, mincost[i][j]);\n\n  vector<P> ep;\n  //vector<int> S, T;\n  rep(i, N) reps(j, i+1, N) {\n    if(mincost[i][j] == maxdist) {\n      ep.emplace_back(i, j);      \n      //S.push_back(i), T.push_back(j);\n    }\n  }\n\n  vector<int> ans;\n  rep(i, N) {\n    bool flag = true;\n    for(auto& p : ep) {\n      //rep(j, S.size()) {\n      int s, t; tie(s, t) = p;\n      if(mincost[s][i] + mincost[i][t] == maxdist) {      \n      //if(mincost[S[j]][i] + mincost[i][T[j]] == maxdist) {\n\tflag = false;\n\tbreak;\n      }\n    }\n    if(flag) ans.push_back(i+1);\n  }\n  \n  cout << ans.size() << endl;\n  rep(i, ans.size()) cout << ans[i] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool read(int &x)\n{ return scanf(\"%d\", &x)  != EOF; }\nvoid write(int x)\n{ printf(\"%d\", x); }\n\nconst int N = 1500 + 10;\nconst int M = 3000 + 10;\n\nint n, m;\nstruct EDG { int u, v, wei; int getNode(int x) { return x ^ u ^ v; } } edg[M];\nvector<int > adj[N];\n\nbool mark[N];\nbool finalMark[N];\nint minDist[N][N];\nqueue<pair<int, int > > Q;\n\nconst int inf = 1e9 + 7;\n\nstruct data {\n    int u, du, source;\n    bool operator < (const data &A) const\n    { return du > A.du; }\n};\npriority_queue<data > PQ;\n\nvoid build_mintable(){\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++) minDist[i][j] = inf;\n        minDist[i][i] = 0;\n        PQ.push({i, 0, i});\n    }\n    while (!PQ.empty()){\n        data tmp = PQ.top(); PQ.pop();\n        int u = tmp.u, du = tmp.du, su = tmp.source;\n        if (du != minDist[su][u]) continue;\n        for (int id : adj[u]){\n            int v = edg[id].getNode(u);\n            if (minDist[su][v] > du + edg[id].wei) {\n                minDist[su][v] = du + edg[id].wei;\n                PQ.push({v, minDist[su][v], su});\n            }\n        }\n    }\n}\n\nmain(){\n    // freopen(\"7.inp\", \"r\", stdin);\n    // freopen(\"7.out\", \"w\", stdout);\n    read(n); read(m);\n    for (int i = 1; i <= m; i++){\n        int a, b, c;\n        read(a); read(b), read(c);\n        edg[i] = {a, b, c};\n        adj[a].push_back(i);\n        adj[b].push_back(i);\n    }\n\n    build_mintable();\n\t\tstatic vector<int > finAns;\n    int maxD = 0;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) maxD = max(maxD, minDist[i][j]);\n    for (int i = 1; i <= n; i++){\n        memset(mark, 0, sizeof mark);\n        while (Q.size()) Q.pop();\n        for (int j = i + 1; j <= n; j++)\n            if (minDist[i][j] == maxD)\n                Q.push({j, j}), mark[j] = 1;\n        while (!Q.empty()){\n            int u = Q.front().first;\n            int su = Q.front().second;\n            Q.pop();\n            for (int id : adj[u]){\n                int v = edg[id].getNode(u);\n                if (minDist[v][i] + edg[id].wei + minDist[u][su] == minDist[su][i] && !mark[v]){\n                    mark[v] = 1;\n                    Q.push({v, su});\n                }\n            }\n        }\n\n        for (int j = 1; j <= n; j++)\n            finalMark[j] |= mark[j];\n    }\n    for (int i = 1; i <= n; i++)\n        if (!finalMark[i]) finAns.push_back(i);\n\twrite(finAns.size()); printf(\"\\n\");\n\tfor (int u : finAns)\n\t\twrite(u), printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nvoid solve(int i, int j) {\n  stack<int> st;\n  map<int, int> mapp;\n  st.push(j);\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n   mapp[tp] = 1;\n    if(tp == i) continue;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[i][k];\n      if(mapp[e.to]) continue;\n      if(d[i][j] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, init, n) for (int i = init; i < (n); i++)\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nvector<edge> graph[1500];\nint dist[1500][1500];\nint N, R, maxDist;\nbool ans[1500];\n\nvoid dijkstra(int start)\n{\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<bool> visited(N, false);\n    dist[start][start] = 0;\n    que.push({0, start});\n\n    while (!que.empty())\n    {\n        int d, now;\n        tie(d, now) = que.top();\n        que.pop();\n\n        if (visited[now])\n            continue;\n\n        visited[now] = true;\n\n        for (auto e : graph[now])\n        {\n            if (dist[start][e.to] <= d + e.cost)\n                continue;\n\n            dist[start][e.to] = dist[start][now] + e.cost;\n            que.push(P(d + e.cost, e.to));\n        }\n    }\n}\n\nvoid solve(int start)\n{\n    queue<int> que;\n    vector<int> _visited(N, false);\n\n    rep(i, N) if(dist[start][i] == maxDist)\n    {\n        que.push(i);\n        _visited[i] = true;\n    }\n\n    while(!que.empty())\n    {\n        int now = que.front();\n        que.pop();\n\n        _visited[now] = true;\n        ans[now] = false;\n\n        for(auto e : graph[now])\n        {\n            if(!_visited[e.to] && dist[start][e.to] + e.cost == dist[start][now])\n            {\n                _visited[e.to] = true;\n                que.push(e.to);\n            }\n        }\n    }\n\n    return;\n}\n\nint main()\n{\n    cin >> N >> R;\n\n    rep(i, R)\n    {\n        int s, t, d;\n        cin >> s >> t >> d;\n\n        s--;\n        t--;\n\n        graph[s].push_back({t, d});\n        graph[t].push_back({s, d});\n    }\n\n    rep(i, N) ans[i] = true;\n\n    rep(i, N) rep(j, N) dist[i][j] = iINF;\n\n    rep(i, N) dijkstra(i);\n    rep(i, N) rep(j, N) maxDist = max(maxDist, dist[i][j]);\n\n    vector<int> output;\n\n    rep(i, N) solve(i);\n\n    rep(i, N) if(ans[i]) output.push_back(i + 1);\n\n    cout << output.size() << endl;\n\n    rep(i, output.size()) cout << output[i] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> ii;\n#define st first\n#define nd second\n\nconst int N = 1505;\n\nint n, m, d[N], check[N];\nvector<ii> G[N];\nqueue<ii> res;\nvector<int> trace[N][N];\n\nint main() {\n\tcin >> n >> m;\n\tfor(int i = 1; i <= m; ++i) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tG[u].push_back(ii(v, w));\n\t\tG[v].push_back(ii(u, w));\n\t}\n\tint mx_total = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = 1; j <= n; ++j) d[j] = 1e9;\n\t\td[i] = 0;\n\t\tpriority_queue<ii, vector<ii>, greater<ii> > pq;\n\t\tpq.push(ii(0, i));\n\t\tint mx = 0;\n\t\twhile(pq.size()) {\n\t\t\tint u = pq.top().nd, du = pq.top().st;\n\t\t\tpq.pop();\n\t\t\tmx = max(mx, d[u]);\n\t\t\tif(du != d[u]) continue;\n\t\t\tfor(int k = 0; k < G[u].size(); ++k) {\n\t\t\t\tint v = G[u][k].st, w = G[u][k].nd;\n\t\t\t\tif(d[v] > du + w) {\n\t\t\t\t\ttrace[i][v].clear();\n\t\t\t\t\td[v] = du + w;\n\t\t\t\t\tpq.push(ii(d[v], v));\n\t\t\t\t}\n\t\t\t\tif(d[v] == du + w) trace[i][v].push_back(u);\n\t\t\t}\n\t\t}\n\t\tif(mx > mx_total) {\n\t\t\tmx_total = mx;\n\t\t\twhile(res.size()) res.pop();\n\t\t}\n\t\t//if(i == 1) cout << d[2] << ' ' << d[3] << ' ' << d[4] << endl;\n\t\tif(mx == mx_total) {\n\t\t\tfor(int k = 1; k <= n; ++k) if(d[k] == mx) res.push(ii(i, k));\n\t\t}\n\t}\n\t//cout << mx_total << endl;\n\twhile(res.size()) {\n\t\tii u = res.front(); res.pop();\n\t\t//cout << u.st << ' ' << u.nd << endl;\n\t\tcheck[u.nd] = true;\n\t\tfor(int i = 0; i < trace[u.st][u.nd].size(); ++i) {\n\t\t\tint v = trace[u.st][u.nd][i];\n\t\t\tres.push(ii(u.st, v));\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor(int i = 1; i <= n; ++i) if(!check[i]) cnt++;\n\tcout << cnt << '\\n';\n\tfor(int i = 1; i <= n; ++i) if(!check[i]) cout << i << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nint solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  map<int, int> mapp;\n  while(1) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    mapp[tp] = 1;\n    if(tp == i) break;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(mapp[e.to]) continue;\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nvector< vector<edge> > graph;\nvector< vector<int> > mincost;\n\nvoid dijkstra(int s)\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  mincost[s][s] = 0;\n  while(!que.empty()) {\n    int cost, now;\n    tie(cost, now) = que.top(); que.pop();\n    if(mincost[s][now] < cost) continue;\n    for(edge& e : graph[now]) {\n      if(e.cost + cost < mincost[s][e.to]) {\n\tmincost[s][e.to] = e.cost + cost;\n\tque.push(P(mincost[s][e.to], e.to));\n      }\n    }\n  }\n  //return *max_element(all(mincost[s]));\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, R;\n  cin >> N >> R;\n  graph.resize(N);\n  rep(i, R) {\n    int s, t, d;\n    cin >> s >> t >> d; s--, t--;\n    graph[s].emplace_back(t, d);\n    graph[t].emplace_back(s, d);\n  }\n\n  mincost.resize(N, vector<int>(N, inf));\n  int maxdist = 0;\n  rep(i, N) dijkstra(i); //maxdist = max(maxdist, dijkstra(i));\n  rep(i, N) reps(j, i+1, N) maxdist = max(maxdist, mincost[i][j]);\n\n  vector<P> ep;\n  rep(i, N) reps(j, i+1, N) {\n    if(mincost[i][j] == maxdist) ep.emplace_back(i, j);\n  }\n\n  vector<int> ans;\n  rep(i, N) {\n    bool flag = true;\n    for(auto& p : ep) {\n      int s, t; tie(s, t) = p;\n      if(mincost[s][i] + mincost[i][t] == maxdist) flag = false;\n    }\n    if(flag) ans.push_back(i+1);\n  }\n  \n  cout << ans.size() << endl;\n  rep(i, ans.size()) cout << ans[i] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nset<int> town;\nvector<int> v[111][111];\nbool used[111][111];\nvoid rec(int s,int t){\n  town.insert(s);\n  town.insert(t);\n  //cout << s << \" \" << t << endl;\n  if(used[s][t]) return;\n  used[s][t]=1;\n  for(int i=0;i<v[s][t].size();i++){\n    rec(s,v[s][t][i]);\n    rec(v[s][t][i],t);\n  }\n}\nint main(){\n  int n,r;cin>>n>>r;\n  int e[n][n],i,j,k,s,t,d,inf=1<<20;\n  for(i=0;i<n;i++)\n    for(j=0;j<n;j++)\n      e[i][j]=inf;\n  for(i=0;i<n;i++) e[i][i]=0;\n  for(i=0;i<r;i++){\n    cin>>s>>t>>d;\n    s--;t--;\n    //cout << s << \" \" << t << \" \" << d << endl;\n    e[s][t]=d;\n    e[t][s]=d;\n  }\n  vector<P> l;\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      v[i][j].clear();\n      v[i][j].push_back(i);\n    }\n  }\n  \n  for(k=0;k<n;k++)\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++){\n\tif(e[i][j]==e[i][k]+e[k][j]){\n\t  v[i][j].push_back(k);\n\t}\n\tif(e[i][j]>e[i][k]+e[k][j]){\n\t  e[i][j]=e[i][k]+e[k][j];\n\t  v[i][j].clear();\n\t  v[i][j].push_back(k);\n\t}\n      }\n\n  \n  k=0;\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      //cout << i << \" \" << j << \"/\" << e[i][j] << endl;\n      if(e[i][j]==k){\n\tl.push_back(P(i,j));\n      }\n      if(e[i][j]>k){\n\tk=e[i][j];\n\tl.clear();\n\tl.push_back(P(i,j));\n      }\n    }\n  }\n\n  for(k=0;k<l.size();k++){\n    s=l[k].first;t=l[k].second;\n    //cout << s << \" \" << t << endl;\n    for(i=0;i<v[s][t].size();i++){\n      memset(used,0,sizeof(used));\n      rec(s,v[s][t][i]);\n      rec(v[s][t][i],t);\n    }\n  }\n  \n  cout << n-town.size() << endl;\n  for(i=0;i<n;i++){\n    if(town.find(i)==town.end()) cout << i+1 << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n// clang-format on\n/* }}} */\n\nstruct Edge {\n  Edge() {}\n  Edge(int a, int b) { to = a; cost = b; }\n  int to, cost;\n};\nint N, R;\nvector<Edge> G[1500];\nvvi allp;\nint ma = -INF;\n\nvi getp(int t, vi &prev) {\n  vi path;\n  for (; t != -1; t = prev[t]) path.eb(t);\n  // reverse(ALL(path));\n  return path;\n}\n\nvoid dijkstra(int s) {\n  minPQ<pii> q;\n  vi d(N, INF);\n  vi prev(N, -1);\n  d[s] = 0;\n  q.emplace(0, s);\n\n  while (q.size()) {\n    auto p = q.top(); q.pop();\n    int v = p.Se;\n    if (d[v] < p.Fi) continue;\n    EACH(e, G[v]) {\n      if (d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        prev[e.to] = v;\n        q.emplace(d[e.to], e.to);\n      }\n    }\n  }\n\n  vi c;\n  REP(i, N) {\n    if (d[i] > ma) {\n      ma = d[i];\n      allp = vvi();\n      c = vi();\n      c.eb(i);\n    } else if (d[i] == ma) {\n      c.eb(i);\n    }\n  }\n\n  EACH(i, c) {\n    allp.eb(getp(i, prev));\n  }\n}\n\nsigned main() {\n  cin >> N >> R;\n  REP(i, R) {\n    int s = in() - 1, t = in() - 1, d = in();\n    G[s].eb(t, d);\n    G[t].eb(s, d);\n  }\n  REP(i, N) dijkstra(i);\n\n  bool vis[1500] = {};\n  EACH(v, allp) EACH(i, v) {\n    vis[i] = true;\n  }\n\n  vi res;\n  REP(i, N) if (!vis[i]) {\n    res.eb(i + 1);\n  }\n  print(res.size());\n  EACH(i, res) print(i);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\ninline void solve(int i, int j) {\n\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(d[i], d[i] + n + 1, 1145141919);\n    d[i][i] = 0;\n    que.push(P(0, i));\n\n    while(!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(d[i][v] < p.first) continue;\n      rep(k, 0, g[v].size()) {\n        edge e = g[v][k];\n        if(d[i][e.to] > d[i][v] + e.cost) {\n          d[i][e.to] = d[i][v] + e.cost;\n          que.push(P(d[i][e.to], e.to));\n        }\n      }\n    }\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, i + 1, n + 1) {\n      if(mas == d[i][j]) {\n        stack<int> st;\n        st.push(j);\n        while(!st.empty()) {\n          int tp = st.top(); st.pop();\n          mp[tp] = 1;\n          if(tp == i) continue;\n          rep(k, 0, g[tp].size()) {\n            edge e = g[tp][k];\n            if(d[i][tp] == d[i][e.to] + e.cost) {\n              st.push(e.to);\n            }\n          }\n        }\n      }\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge\n{\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nvector< vector<edge> > graph;\nvector< vector<int> > mincost;\n\nint dijkstra(int s)\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  mincost[s][s] = 0;\n  while(!que.empty()) {\n    int cost, now;\n    tie(cost, now) = que.top(); que.pop();\n    if(mincost[s][now] < cost) continue;\n    for(edge& e : graph[now]) {\n      if(e.cost + cost < mincost[s][e.to]) {\n\tmincost[s][e.to] = e.cost + cost;\n\tque.push(P(mincost[s][e.to], e.to));\n      }\n    }\n  }\n  return *max_element(all(mincost[s]));\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, R;\n  cin >> N >> R;\n  graph.resize(N);\n  rep(i, R) {\n    int s, t, d;\n    cin >> s >> t >> d; s--, t--;\n    graph[s].emplace_back(t, d);\n    graph[t].emplace_back(s, d);\n  }\n\n  mincost.resize(N, vector<int>(N, inf));\n  int maxdist = 0;\n  rep(i, N) maxdist = max(maxdist, dijkstra(i));\n\n  vector<P> ep;\n  rep(i, N) reps(j, i+1, N) {\n    if(mincost[i][j] == maxdist) ep.emplace_back(i, j);\n  }\n\n  vector<int> ans;\n  rep(i, N) {\n    bool flag = true;\n    for(auto& p : ep) {\n      int s, t; tie(s, t) = p;\n      if(mincost[s][i] + mincost[i][t] == maxdist) flag = false;\n    }\n    if(flag) ans.push_back(i+1);\n  }\n  \n  cout << ans.size() << endl;\n  rep(i, ans.size()) cout << ans[i] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nvoid solve(int i, int j) {\n  stack<int> st;\n  map<int, int> mapp;\n  st.push(j);\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    mapp[tp] = 1;\n    if(tp == i) continue;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(mapp[e.to]) continue;\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF 1500001\nint n,r,d[1500][1500],qt[1500];\nvector<P>e[1500];\nint main(void){\n   cin>>n>>r;\n   for(int i=0;i<r;i++){\n       int s,t,c;\n       cin>>s>>t>>c;\n       s--;\n       t--;\n       e[s].push_back(P(t,c));\n       e[t].push_back(P(s,c));\n   }\n   \n   for(int i=0;i<n;i++){\n       for(int j=0;j<n;j++){\n           d[i][j]=INF;\n       }\n   }\n   P mv={0,0};\n   int mc=0;\n    for(int i=0;i<n;i++){\n        priority_queue<P,vector<P>,greater<P>>k;\n        d[i][i]=0;\n        k.push(P(0,i));\n        while(!k.empty()){\n            int v=k.top().second,co=k.top().first;\n            k.pop();\n            if(d[i][v]!=co)continue;\n            for(int j=0;j<e[v].size();j++){\n                if(d[i][e[v][j].first]>d[i][v]+e[v][j].second){\n                    d[i][e[v][j].first]=d[i][v]+e[v][j].second;\n                    k.push(P(d[i][e[v][j].first],e[v][j].first));\n                }\n            }\n        }\n        for(int j=0;j<n;j++){\n            if(mc<d[i][j]){\n                mc=d[i][j];\n                mv=P(i,j);\n            }\n        }\n    }\n    vector<P>si;\n    si.push_back(mv);\n    for(int i=0;i<n;i++){\n        for(int j=i;j<n;j++){\n            if(d[i][j]==mc&&mv!=P(i,j))si.push_back(P(i,j));\n        }\n    }\n    \n    int ans=0;\n    for(int i=0;i<si.size();i++){\n        int s=si[i].first,t=si[i].second;\n        for(int j=0;j<n;j++){\n            if(d[s][j]+d[j][t]==mc&&qt[j]==0){\n                qt[j]=1;\n                ans++;\n            }\n        }\n    }  \n    cout<<n-ans<<endl;\n    for(int i=0;i<n;i++){\n        if(qt[i]==0)cout<<i+1<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fto(i, x, y) for(int i = (x); i <= (y); ++i)\n#define fdto(i, x, y) for(int i = (x); i >= (y); --i)\n#define ftoa(i, x, y, a) for(int i = (x); i <= (y); i += a)\n#define ftoit(it, var) for (__typeof(var.begin()) it = var.begin(); it != var.end(); ++it)\n\n#define ii pair<int, int>\n#define mp make_pair\n#define FF first\n#define SS second\n\n#define vi vector<int>\n#define vii vector<ii>\n#define ll long long\n#define vll vector<ll>\n\n#define eb emplace_back\n#define ef emplace_front\n#define lb lower_bound\n#define ub upper_bound\n#define sz(a) (int)a.size()\n\n#define oo 1000000007\n#define OO 1000000000000000007LL\n\nusing namespace std;\n\n#define Pro \"tmp\"\n#define maxN 1507\n\nint D[maxN];\nvii adj[maxN];\n\nint f[maxN][maxN];\nint n, m;\n\nbool ans[maxN];\n\nvoid dijkstra(int u) {\n    fto (i, 1, n) D[i] = oo;\n    D[u] = 0;\n\n    set <ii> st;\n    st.insert(mp(0, u));\n\n    while (!st.empty()) {\n        int u = (*st.begin()).SS;\n        st.erase(st.begin());\n\n        fto (i, 0, (int)adj[u].size()-1) {\n            int v = adj[u][i].FF;\n            int w = adj[u][i].SS;\n\n            if (D[v] > D[u]+w) {\n                st.erase(mp(D[v], v));\n                D[v] = D[u]+w;\n                st.insert(mp(D[v], v));\n            }\n        }\n    }\n\n    return;\n}\n\nint main() {\n    #ifndef ONLINE_JUDGE\n        freopen(Pro\".inp\", \"r\", stdin);\n        freopen(Pro\".out\", \"w\", stdout);\n    #endif // ONLINE_JUDGE\n\n    scanf(\"%d%d\", &n, &m);\n    fto (i, 1, m) {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        adj[u].eb(mp(v, w));\n        adj[v].eb(mp(u, w));\n    }\n\n    int maxAns = 0;\n    vii trace;\n\n    fto (i, 1, n) {\n        dijkstra(i);\n        fto (j, 1, n) {\n            f[i][j] = D[j];\n            if (maxAns < f[i][j]) {\n                maxAns = f[i][j];\n                trace.clear();\n                trace.eb(i, j);\n            }\n            else if (maxAns == f[i][j]) trace.eb(i, j);\n        }\n    }\n\n\n    fto (w, 1, n) {\n        fto (i, 0, (int)trace.size()-1) {\n            int u = trace[i].FF;\n            int v = trace[i].SS;\n            if (f[u][w]+f[w][v] == maxAns) {\n                ans[w] = 1;\n                break;\n            }\n        }\n    }\n\n    int num = 0;\n    fto (i, 1, n) num += !ans[i];\n\n    printf(\"%d\\n\", num);\n    fto (i, 1, n) if (!ans[i]) printf(\"%d\\n\", i);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(x, a, b) for (int x = a; x <= b; ++x)\n#define FOD(x, a, b) for (int x = a; x >= b; --x)\n#define REP(x, a, b) for (int x = a; x < b; ++x)\n#define DEBUG(X) { cout << #X << \" = \" << X << endl; }\n#define PR(A, n) { cout << #A << \" = \"; FOR(_, 1, n) cout << A[_] << \" \"; cout << endl; }\n#define PR0(A, n)  { cout << #A << \" = \"; REP(_, 0, n) cout << A[_] << \" \"; cout << endl; }\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> II;\n\nconst int N = 1500 + 10;\nconst int INF = 0x3f3f3f3f;\n\nint n, m;\nint d[N][N];\n\nbool ban[N], fre[N];\n\nII V[2 * N];\n\nvector <II> adj[N];\npriority_queue <II> pq;\n\nvoid Dijkstra(int *d, int s) {\n    d[s] = 0; pq.push(II(-d[s], s));\n    while (pq.size()) {\n        int u = pq.top().second, w = -pq.top().first; pq.pop();\n        if (w > d[u]) continue;\n        REP(k, 0, adj[u].size()) {\n            int v = adj[u][k].first, w = adj[u][k].second;\n            if (d[v] > d[u] + w) {\n                d[v] = d[u] + w;\n                pq.push(II(-d[v], v));\n            }\n        }\n    }\n}\n\nint main() {\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif // LOCAL\n    scanf(\"%d%d\", &n, &m);\n    FOR(i, 1, m) {\n        int u, v, w; scanf(\"%d%d%d\", &u, &v, &w);\n        adj[u].push_back(II(v, w));\n        adj[v].push_back(II(u, w));\n        //cout << u << \" \" << v << \" \" << w << endl;\n    }\n    memset(d, INF, sizeof d);\n    FOR(i, 1, n) {\n        Dijkstra(d[i], i);\n    }\n    int maxDist = -INF;\n    FOR(i, 1, n)\n        FOR(j, 1, n) maxDist = max(maxDist, d[i][j]);\n    int VSize = 0;\n    FOR(i, 1, n) ban[i] = true;\n    FOR(i, 1, n)\n        FOR(j, 1, n) if (d[i][j] == maxDist) {\n            V[++VSize] = II(i, j);\n            ban[i] = false;\n            ban[j] = false;\n        }\n    FOR(i, 1, n) if (ban[i] == true) {\n        FOR(j, 1, VSize) {\n            int x = V[j].first, y = V[j].second;\n            if (d[x][i] + d[i][y] == maxDist) ban[i] = false;\n        }\n    }\n    int sz = 0;\n    FOR(i, 1, n) if (ban[i]) ++sz;\n    printf(\"%d\\n\", sz);\n    FOR(i, 1, n) if (ban[i]) printf(\"%d\\n\", i);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct edge {int to, cost;};\n\nint n, r;\nvector<edge> g[1501];\nint d[1501][1501];\nmap<int, int> mp;\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[s], d[s] + n + 1, 1145141919);\n  d[s][s] = 0;\n  que.push(P(0, s));\n\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[s][v] < p.first) continue;\n    rep(i, 0, g[v].size()) {\n      edge e = g[v][i];\n      if(d[s][e.to] > d[s][v] + e.cost) {\n        d[s][e.to] = d[s][v] + e.cost;\n        que.push(P(d[s][e.to], e.to));\n      }\n    }\n  }\n}\n\nvoid solve(int i, int j) {\n  stack<int> st;\n  st.push(j);\n  while(!st.empty()) {\n    int tp = st.top(); st.pop();\n    mp[tp] = 1;\n    if(tp == i) continue;\n    rep(k, 0, g[tp].size()) {\n      edge e = g[tp][k];\n      if(d[i][tp] == d[i][e.to] + e.cost) {\n        st.push(e.to);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> r;\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edge e;\n    e.to = b, e.cost = c;\n    g[a].pb(e);\n    e.to = a;\n    g[b].pb(e);\n  }\n  rep(i, 1, n + 1) {\n    dijkstra(i);\n  }\n  int mas = 0;\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      mas = max(mas, d[i][j]);\n    }\n  }\n  rep(i, 1, n + 1) {\n    rep(j, 1, n + 1) {\n      if(mas == d[i][j]) solve(i, j);\n    }\n  }\n  int count = 0;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) count++;\n  }\n  cout << count << endl;\n  rep(i, 1, n + 1) {\n    if(!mp[i]) cout << i << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nstruct edge{int to,cost;};\n\nconst int N = 1500;\nconst int INF = 19191919;\nvector<edge> G[N];\n\nint n;\nint d[N][N];\nbool can[N];\n\nvoid dijkstra(int s)\n{\n    d[s][s] = 0;\n    priority_queue<pi,vector<pi>,greater<pi>> pq;\n    pq.push({0,s});\n    while(!pq.empty())\n    {\n        pi now = pq.top();\n        pq.pop();\n        int v = now.se;\n        if(now.fi>d[s][v]) continue;\n        for(const auto &e:G[v])\n        {\n            if(d[s][e.to] > d[s][v]+e.cost)\n            {\n                d[s][e.to] = d[s][v]+e.cost;\n                pq.push({d[s][e.to],e.to});\n            }\n        }\n    }\n}\n\nvoid check(int s, int D)\n{\n    queue<int> que;\n    rep(i,n)if(d[s][i]==D) que.push(i);\n\n    while(!que.empty())\n    {\n        int v = que.front();\n        que.pop();\n        if(!can[v]) continue;\n        can[v] = false;\n\n        for(const auto &e:G[v])\n        {\n            if(d[s][e.to]==d[s][v]-e.cost) que.push(e.to);\n        }\n    }\n}\n\nint main()\n{\n    int r;\n    cin >>n >>r;\n    while(r--)\n    {\n        int s,t,w;\n        cin >>s >>t >>w;\n        --s; --t;\n        G[s].pb({t,w});\n        G[t].pb({s,w});\n    }\n\n    fill(d[0],d[N],INF);\n    fill(can,can+N,true);\n    rep(i,n) dijkstra(i);\n\n    int max_d = 0;\n    rep(i,n)rep(j,n) max_d = max(max_d,d[i][j]);\n\n    rep(i,n) check(i,max_d);\n\n    vector<int> ans;\n    rep(i,n)if(can[i]) ans.pb(i);\n\n    cout << ans.size() << endl;\n    for(const int &i:ans) cout << i+1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0351 Quiet Town\n// 2018.2.25 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 2000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 1503\nint n, dmax;\nshort hi[MAX], *to[MAX], *dt[MAX];\t\t// to, dist\nshort hi2[MAX], *to2[MAX];\nint   dist[MAX];\nchar  mk[MAX], ans[MAX];\nshort q[2*MAX], top, tail;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, d, e;\n\tint max;\n\n\tmemset(dist, INF, n << 2);\n\tmemset(hi2, 0, n << 1);\n\tqsize = 0;\n\tdist[start] = 0, enq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + dt[s][i];\n\t\t\tif (dist[e] < d) continue;\n\t\t\tif (dist[e] > d) hi2[e] = 0, dist[e] = d, enq(e, d);\n\t\t\tto2[e][hi2[e]++] = s;\n\t\t}\n\t}\n\n\ttop = 0, tail = 0;\n\tmax = 0; for (i = 1; i < n; i++) {\n\t\tif (dist[i] > max) max = dist[i], q[0] = i, tail = 1;\n\t\telse if (dist[i] == max) q[tail++] = i;\n\t}\n\n\tif (max < dmax) return;\n\tif (max > dmax) { dmax = max, memset(ans, 0, n); }\n\n\tmemset(mk, 0, n);\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tif (mk[s]) continue;\n\t\tmk[s] = 1;\n\t\tfor (i = 0; i < hi2[s]; i++) {\n\t\t\te = to2[s][i];\n\t\t\tif (mk[e]) continue;\n\t\t\tq[tail++] = e;\n\t\t\tans[s] = ans[e] = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, j, r, k, s, t, d;\n\tshort *memo;\n\t\n\tn = in()+1, r = in();\n\tmemo = malloc(r*6);\n\tj = 0, i = r; while (i--) {\n\t\tmemo[j++] = s = in(), hi[s]++;\n\t\tmemo[j++] = t = in(), hi[t]++;\n\t\tmemo[j++] = in();\n\t\t\n\t}\n\tfor (s = 0; s < n; s++) if (hi[s]) {\n\t\tto [s] = malloc(hi[s] << 1), dt[s] = malloc(hi[s] << 1);\n\t\tto2[s] = malloc(hi[s] << 1);\n\t}\n\t\n\tmemset(hi, 0, n << 1);\n\tj = 0; while (r--) {\n\t\ts = memo[j++], t = memo[j++], d = memo[j++];\n\t\tk = hi[s]++, to[s][k] = t, dt[s][k] = d;\n\t\tk = hi[t]++, to[t][k] = s, dt[t][k] = d;\n\t}\n\tfree(memo);\n\n\tk = n-1; if (k > 100) k >>= 1;\n\tfor (s = 1; s <= k; s++) dijkstra(s);\n\n\tk = 0; for (s = 1; s < n; s++) if (!ans[s]) k++;\n\tprintf(\"%d\\n\", k);\n\tif (k) for (s = 1; s < n; s++) if (!ans[s]) printf(\"%d\\n\", s);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0351 Quiet Town\n// 2018.2.25 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 2000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 1503\nint n, dmax, sz;\nshort hi[MAX], *to[MAX], *dt[MAX];\t\t// to, dist\nshort hi2[MAX], *to2[MAX];\nint   dist[MAX];\nchar  mk[MAX], ans[MAX];\nshort q[2*MAX], top, tail;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, d, e;\n\tint max;\n\n\tmemset(dist, INF, n << 2);\n\tmemset(hi2, 0, n << 1);\n\tqsize = 0;\n\tdist[start] = 0, enq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + dt[s][i];\n\t\t\tif (dist[e] < d) continue;\n\t\t\tif (dist[e] > d) hi2[e] = 0, dist[e] = d, enq(e, d);\n\t\t\tto2[e][hi2[e]++] = s;\n\t\t}\n\t}\n\n\ttop = 0, tail = 0;\n\tmax = 0; for (i = 1; i < n; i++) {\n\t\tif (dist[i] > max) max = dist[i], q[0] = i, tail = 1;\n\t\telse if (dist[i] == max) q[tail++] = i;\n\t}\n\n\tif (max < dmax) return;\n\tif (max > dmax) { dmax = max, sz = n-1, memset(ans, 0, n); }\n\n\tmemset(mk, 0, n);\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tif (mk[s]) continue;\n\t\tmk[s] = 1;\n\t\tfor (i = 0; i < hi2[s]; i++) {\n\t\t\te = to2[s][i];\n\t\t\tif (mk[e]) continue;\n\t\t\tq[tail++] = e;\n\t\t\tif (!ans[s]) sz--, ans[s] = 1;\n\t\t\tif (!ans[e]) sz--, ans[e] = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, j, r, k, s, t, d;\n\tshort *memo;\n\t\n\tn = in()+1, r = in();\n\tmemo = malloc(r*6);\n\tj = 0, i = r; while (i--) {\n\t\tmemo[j++] = s = in(), hi[s]++;\n\t\tmemo[j++] = t = in(), hi[t]++;\n\t\tmemo[j++] = in();\n\t\t\n\t}\n\tfor (s = 0; s < n; s++) if (hi[s]) {\n\t\tto [s] = malloc(hi[s] << 1), dt[s] = malloc(hi[s] << 1);\n\t\tto2[s] = malloc(hi[s] << 1);\n\t}\n\t\n\tmemset(hi, 0, n << 1);\n\tj = 0; while (r--) {\n\t\ts = memo[j++], t = memo[j++], d = memo[j++];\n\t\tk = hi[s]++, to[s][k] = t, dt[s][k] = d;\n\t\tk = hi[t]++, to[t][k] = s, dt[t][k] = d;\n\t}\n\tfree(memo);\n\n\tsz = k = n-1; if (k > 100) k >>= 1;\n\tfor (s = 1; s <= k && sz; s++) dijkstra(s);\n\n\tprintf(\"%d\\n\", sz);\n\tif (sz) for (s = 1; s < n; s++) if (!ans[s]) printf(\"%d\\n\", s);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0351: Quiet Town\n// 2018.1.9 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 15000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define W 100\nint n, sz;\nshort to[1501][W], dt[1501][W], hi[1501];\t// to, dist, len\nint dmax;\t\t\t\t\t\t\t\t\t// max d\nint tbl[1501][W]; short w[1501];\nint dist[1501];\t\t\t\t\t\t\t\nshort prev[1501];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, d, e;\n\tint max;\n\n\tmemset(dist, 0x33, sizeof(dist));\n\tmemset(prev, -1, sizeof(prev));\n\n\tqsize = 0;\n\tdist[start] = 0, enq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i];\n\t\t\td = dist[s] + dt[s][i];\n\t\t\tif (d < dist[e]) prev[e] = s, dist[e] = d, enq(e, d);\n\t\t}\n\t}\n\tmax = 0; for (i = 0; i < n; i++) if (dist[i] > max) max = dist[i];\n\tif (max > dmax) dmax = max;\n\tif (max == dmax) for (i = 0; i < n; i++) if (dist[i] == max) {\n\t\tfor (s = i; s >= 0; s = prev[s]) tbl[s][w[s]++] = max;\n\t}\n}\n\nint main()\n{\n\tint r, k, s, t, d;\n\tint *ans;\n\n\tn = in(), r = in();\n\twhile (r--) {\n\t\ts = in()-1, t = in()-1, d = in();\n\t\tk = hi[s]++, to[s][k] = t, dt[s][k] = d;\n\t\tk = hi[t]++, to[t][k] = s, dt[t][k] = d;\n\t}\n\n\tfor (s = 0; s < n; s++) dijkstra(s);\n\n\tans = dist;\tfor (s = 0; s < n; s++) {\n\t\tfor (k = 0; ; k++) {\n\t\t\tif (k == w[s]) { ans[sz++] = s; break; }\n\t\t\tif (tbl[s][k] == dmax) break; \n\t\t}\n\t}\n\tprintf(\"%d\\n\", sz);\n\tfor (k = 0; k < sz; k++) printf(\"%d\\n\", 1+ans[k]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0351 Quiet Town\n// 2018.2.25 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 2000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 1503\nint n, dmax, sz;\nshort hi[MAX], *to[MAX], *dt[MAX];\t\t// to, dist\nshort hi2[MAX], *to2[MAX];\nint   dist[MAX];\nchar  mk[MAX], ans[MAX];\nshort q[2*MAX], top, tail;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, d, e;\n\tint max;\n\n\tmemset(dist, INF, n << 2);\n\tmemset(hi2, 0, n << 1);\n\tqsize = 0;\n\tdist[start] = 0, enq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + dt[s][i];\n\t\t\tif (dist[e] < d) continue;\n\t\t\tif (dist[e] > d) hi2[e] = 0, dist[e] = d, enq(e, d);\n\t\t\tto2[e][hi2[e]++] = s;\n\t\t}\n\t}\n\n\ttop = 0, tail = 0;\n\tmax = 0; for (i = 1; i < n; i++) {\n\t\tif (dist[i] > max) max = dist[i], q[0] = i, tail = 1;\n\t\telse if (dist[i] == max) q[tail++] = i;\n\t}\n\n\tif (max < dmax) return;\n\tif (max > dmax) { dmax = max, sz = n-1, memset(ans, 0, n); }\n\n\tif (!ans[start]) sz--, ans[start] = 1;\n\tmemset(mk, 0, n);\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tif (mk[s]) continue;\n\t\tmk[s] = 1;\n\t\tfor (i = 0; i < hi2[s]; i++) {\n\t\t\te = to2[s][i];\n\t\t\tif (mk[e]) continue;\n\t\t\tq[tail++] = e;\n\t\t\tif (!ans[s]) sz--, ans[s] = 1;\n\t\t\tif (!ans[e]) sz--, ans[e] = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, j, r, k, s, t, d;\n\tshort *memo;\n\t\n\tn = in()+1, r = in();\n\tmemo = malloc(r*6);\n\tj = 0, i = r; while (i--) {\n\t\tmemo[j++] = s = in(), hi[s]++;\n\t\tmemo[j++] = t = in(), hi[t]++;\n\t\tmemo[j++] = in();\n\t\t\n\t}\n\tfor (s = 0; s < n; s++) if (hi[s]) {\n\t\tto [s] = malloc(hi[s] << 1), dt[s] = malloc(hi[s] << 1);\n\t\tto2[s] = malloc(hi[s] << 1);\n\t}\n\t\n\tmemset(hi, 0, n << 1);\n\tj = 0; while (r--) {\n\t\ts = memo[j++], t = memo[j++], d = memo[j++];\n\t\tk = hi[s]++, to[s][k] = t, dt[s][k] = d;\n\t\tk = hi[t]++, to[t][k] = s, dt[t][k] = d;\n\t}\n\tfree(memo);\n\n\tsz = n-1; for (s = 1; s <= n/2 && sz; s++) dijkstra(s);\n\n\tprintf(\"%d\\n\", sz);\n\tif (sz) for (s = 1; s < n; s++) if (!ans[s]) printf(\"%d\\n\", s);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0351 Quiet Town\n// 2018.2.25 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 2000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 1503\nint n, dmax, sz;\nshort hi[MAX], *to[MAX], *dt[MAX];\t\t// to, dist\nshort hi2[MAX], *to2[MAX];\nint   dist[MAX];\nchar  mk[MAX], ans[MAX];\nshort q[2*MAX], top, tail;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, d, e;\n\tint max;\n\n\tmemset(dist, INF, n << 2);\n\tmemset(hi2, 0, n << 1);\n\tqsize = 0;\n\tdist[start] = 0, enq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + dt[s][i];\n\t\t\tif (dist[e] < d) continue;\n\t\t\tif (dist[e] > d) hi2[e] = 0, dist[e] = d, enq(e, d);\n\t\t\tto2[e][hi2[e]++] = s;\n\t\t}\n\t}\n\n\ttop = 0, tail = 0;\n\tmax = 0; for (i = 1; i < n; i++) {\n\t\tif (dist[i] > max) max = dist[i], q[0] = i, tail = 1;\n\t\telse if (dist[i] == max) q[tail++] = i;\n\t}\n\n\tif (max < dmax) return;\n\tif (max > dmax) { dmax = max, sz = 1, memset(ans, 0, n); }\n\n\tif (!ans[start]) sz++, ans[start] = 1;\n\tmemset(mk, 0, n);\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tif (mk[s]) continue;\n\t\tmk[s] = 1;\n\t\tfor (i = 0; i < hi2[s]; i++) {\n\t\t\te = to2[s][i];\n\t\t\tif (mk[e]) continue;\n\t\t\tq[tail++] = e;\n\t\t\tif (!ans[s]) sz++, ans[s] = 1;\n\t\t\tif (!ans[e]) sz++, ans[e] = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, j, r, k, s, t, d;\n\tshort *memo;\n\t\n\tn = in()+1, r = in();\n\tmemo = malloc(r*6);\n\tj = 0, i = r; while (i--) {\n\t\tmemo[j++] = s = in(), hi[s]++;\n\t\tmemo[j++] = t = in(), hi[t]++;\n\t\tmemo[j++] = in();\n\t\t\n\t}\n\tfor (s = 0; s < n; s++) if (hi[s]) {\n\t\tto [s] = malloc(hi[s] << 1), dt[s] = malloc(hi[s] << 1);\n\t\tto2[s] = malloc(hi[s] << 1);\n\t}\n\t\n\tmemset(hi, 0, n << 1);\n\tj = 0; while (r--) {\n\t\ts = memo[j++], t = memo[j++], d = memo[j++];\n\t\tk = hi[s]++, to[s][k] = t, dt[s][k] = d;\n\t\tk = hi[t]++, to[t][k] = s, dt[t][k] = d;\n\t}\n\tfree(memo);\n\n\tsz = 1;\n\tfor (s = 1; s < n && sz < n; s++) dijkstra(s);\n\n\tsz = n - sz;\n\tprintf(\"%d\\n\", sz);\n\tif (sz) for (s = 1; s < n; s++) if (!ans[s]) printf(\"%d\\n\", s);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0351: Quiet Town\n// 2018.1.9 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\n//int qmax;\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\t//if (qsize > qmax) qmax = qsize;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define W 1500\nint n, sz;\nshort to[1501][W], dt[1501][W], hi[1501];\t// to, dist, len\nint dmax;\t\t\t\t\t\t\t\t\t// max d\nint tbl[1501][W]; short w[1501];\nint dist[1501];\t\t\t\t\t\t\t\nshort prev[1501];\nchar marked[1501];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint check(int s)\n{\n\tint i, e, l, h;\n\n//printf(\"check s %d\\n\", s+1);\n\tl = h = 0;\n\tfor (i = 0; i < hi[s]; i++) {\n\t\te = to[s][i];\n//printf(\"s %d, i %d, w %d, dist %d --> e %d, dist %d\\n\",s+1,i,dt[s][i],dist[s],e+1,dist[e]); \n\t\tif (!marked[e]) continue;\n\t\tif (dist[e] >= dist[s]) {\n\t\t\tif (dist[s] + dt[s][i] == dist[e]) h++;\n\t\t} else {\n\t\t\tif (dist[s] - dt[s][i] == dist[e]) l++;\n\t\t}\n\t}\n//printf(\"!!!! low %d, hi %d\\n\", l, h);\n\treturn l >= 1 && h >= 1; \n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, d, e;\n\tint max;\n\n\tmemset(dist, 0x33, n << 2);\n\tmemset(prev, -1, n << 1);\n\n\tqsize = 0;\n\tdist[start] = 0, enq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i];\n\t\t\td = dist[s] + dt[s][i];\n\t\t\tif (d < dist[e]) prev[e] = s, dist[e] = d, enq(e, d);\n\t\t}\n\t}\n\tmax = 0; for (i = 0; i < n; i++) if (dist[i] > max) max = dist[i];\n//printf(\"start %d, max %d, dmax %d\\n\", start+1, max, dmax);\n\tif (max > dmax) dmax = max;\n\tif (max == dmax) {\n\t\tmemset(marked, 0, n);\n\t\tfor (i = 0; i < n; i++) if (dist[i] == max) {\n\t\t\tfor (s = i; s >= 0; s = prev[s]) if (!marked[s]) {\n\t\t\t\tmarked[s] = 1, tbl[s][w[s]++] = max;\n\t\t\t}\n\t\t}\n\t\tfor (s = 0; s < n; s++) if (!marked[s]) {\n\t\t\tif (check(s)) tbl[s][w[s]++] = max;\n\t\t}\n\t}\n//for (s = 0; s < n; s++) printf(\"[%d] w %d, tbl %d,%d\\n\", s+1, w[s], tbl[s][0], tbl[s][1]);\n}\n\n//int hmax;\n\nint main()\n{\n\tint r, k, s, t, d;\n\tint *ans;\n\n\tn = in(), r = in();\n\twhile (r--) {\n\t\ts = in()-1, t = in()-1, d = in();\n\t\tk = hi[s]++, to[s][k] = t, dt[s][k] = d;\n\t\tk = hi[t]++, to[t][k] = s, dt[t][k] = d;\n\t}\n//for (s = 0; s < n; s++) if (hi[s] > hmax) hmax = hi[s];\n\n\tfor (s = 0; s < n; s++) dijkstra(s);\n\n\tans = dist;\tfor (s = 0; s < n; s++) {\n\t\tfor (k = 0; ; k++) {\n\t\t\tif (k == w[s]) { ans[sz++] = s; break; }\n\t\t\tif (tbl[s][k] == dmax) break; \n\t\t}\n\t}\n\tprintf(\"%d\\n\", sz);\n\tfor (k = 0; k < sz; k++) printf(\"%d\\n\", 1+ans[k]);\n\n//\tprintf(\"hmax %d, qmax %d\\n\", hmax, qmax);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0351 Quiet Town\n// 2018.2.25 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 2000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 1501\nint n, dmax;\nshort hi[MAX], *to[MAX], *dt[MAX];\t\t// to, dist\nshort hi2[MAX], *to2[MAX];\nint   dist[MAX];\nchar  mk[MAX], ans[MAX];\nshort q[MAX], top, tail;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, d, e;\n\tint max;\n\n\tmemset(dist, INF, n << 2);\n\tmemset(hi2, 0, n << 1);\n\tqsize = 0;\n\tdist[start] = 0, enq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + dt[s][i];\n\t\t\tif (dist[e] < d) continue;\n\t\t\tif (dist[e] > d) hi2[e] = 0, dist[e] = d, enq(e, d);\n\t\t\tto2[e][hi2[e]++] = s;\n\t\t}\n\t}\n\n\ttop = 0, tail = 0;\n\tmax = 0; for (i = 1; i < n; i++) {\n\t\tif (dist[i] > max) max = dist[i], q[0] = i, tail = 1;\n\t\telse if (dist[i] == max) q[tail++] = i;\n\t}\n\n\tif (max < dmax) return;\n\tif (max > dmax) { dmax = max, memset(ans, 0, n); }\n\n\tans[start] = 1;\n\tmemset(mk, 0, n);\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tif (mk[s]) continue;\n\t\tmk[s] = 1;\n\t\tfor (i = 0; i < hi2[s]; i++) {\n\t\t\te = to2[s][i];\n\t\t\tif (mk[e]) continue;\n\t\t\tq[tail++] = e;\n\t\t\tans[e] = ans[s] = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, j, r, k, s, t, d;\n\tshort *memo;\n\t\n\tn = in()+1, r = in();\n\tmemo = malloc(r*6);\n\tj = 0, i = r; while (i--) {\n\t\tmemo[j++] = s = in(), hi[s]++;\n\t\tmemo[j++] = t = in(), hi[t]++;\n\t\tmemo[j++] = in();\n\t\t\n\t}\n\tfor (s = 0; s < n; s++) if (hi[s]) {\n\t\tto [s] = malloc(hi[s] << 1), dt[s] = malloc(hi[s] << 1);\n\t\tto2[s] = malloc(hi[s] << 1);\n\t}\n\t\n\tmemset(hi, 0, n << 1);\n\tj = 0; while (r--) {\n\t\ts = memo[j++], t = memo[j++], d = memo[j++];\n\t\tk = hi[s]++, to[s][k] = t, dt[s][k] = d;\n\t\tk = hi[t]++, to[t][k] = s, dt[t][k] = d;\n\t}\n\tfree(memo);\n\n\tfor (s = 1; s < n; s++) dijkstra(s);\n\n\tk = 0; for (s = 1; s < n; s++) if (!ans[s]) k++;\n\tprintf(\"%d\\n\", k);\n\tfor (s = 1; s < n; s++) if (!ans[s]) printf(\"%d\\n\", s);\n\treturn 0;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AOJ.Volume3\n{\n    public class QuietTown\n    {\n        public static int Main()\n        {\n            var input = Console.ReadLine().Split(' ');\n            int n = int.Parse(input[0]);\n            int r = int.Parse(input[1]);\n\n            // ?????????\n            // ??????????????´??????-1\n            var map = new int[n + 1, n + 1];\n            for(int i = 0; i <= n; i++)\n            {\n                for(int j = 0; j <= n; j++)\n                {\n                    if (i == j) { map[i, j] = 0; }\n                    else { map[i, j] = -1; }\n                }\n            }\n\n            for(int i = 0; i < r; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                int f = int.Parse(input[0]);\n                int t = int.Parse(input[1]);\n                int d = int.Parse(input[2]);\n                map[f, t] = d;\n                map[t, f] = d;\n            }\n\n            // ???????????????????????§?????¢????????????\n            var dist = new int[n + 1, n + 1];\n            int max_dist = 0;\n            for (int i = 1; i <= n - 1; i++)\n            {\n                for (int j = i + 1; j <= n; j++)\n                {\n                    int tmp_dist = Dijkstra(n, i, j, map);\n                    dist[i, j] = tmp_dist;\n                    if (tmp_dist > max_dist) { max_dist = tmp_dist; }\n                }\n            }\n\n            var ans = new List<int>();\n            for(int i = 1; i <= n; i++) { ans.Add(i); }\n            for(int i = 1; i <= n; i++)\n            {\n                for(int j = i + 1; j <= n; j++)\n                {\n                    if (dist[i, j] == max_dist)\n                    {\n                        if (ans.Contains(i)) { ans.Remove(i); }\n                        if (ans.Contains(j)) { ans.Remove(j); }\n                    }\n                }\n            }\n\n            Console.WriteLine(ans.Count);\n            foreach(var i in ans.OrderBy(x => x)) { Console.WriteLine(i); }\n\n            return 0;\n        }\n\n        private static int Dijkstra(int n, int start, int goal, int[,] map)\n        {\n            var confirm = new bool[n + 1];\n            var dist = new int[n + 1];\n            for(int i = 1; i <= n; i++)\n            {\n                confirm[i] = false;\n                dist[i] = int.MaxValue;\n            }\n\n            confirm[start] = true;\n            dist[start] = 0;\n            int current = start;\n            while (true)\n            {\n                for(int i = 1; i <= n; i++)\n                {\n                    if(i == current) { continue; }\n                    if (map[current, i] < 0) { continue; }\n                    dist[i] = Math.Min(dist[i], dist[current] + map[current, i]);\n                }\n\n                int tmp_dist = int.MaxValue;\n                int next = 0;\n                for(int i = 1; i <= n; i++)\n                {\n                    if (confirm[i]) { continue; }\n                    if (dist[i] < tmp_dist)\n                    {\n                        next = i;\n                        tmp_dist = dist[i];\n                    }\n                }\n                confirm[next] = true;\n                current = next;\n\n                if (confirm[goal]) { break; }\n            }\n\n            return dist[goal];\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AOJ.Volume3\n{\n    public class QuietTown\n    {\n        private class Info\n        {\n            public int Distance { get; set; }\n            public string Root { get; set; }\n        }\n\n        public static int Main()\n        {\n            var input = Console.ReadLine().Split(' ');\n            int n = int.Parse(input[0]);\n            int r = int.Parse(input[1]);\n\n            // ?????????\n            // ??????????????´??????-1\n            var map = new int[n + 1, n + 1];\n            for(int i = 0; i <= n; i++)\n            {\n                for(int j = 0; j <= n; j++)\n                {\n                    if (i == j) { map[i, j] = 0; }\n                    else { map[i, j] = -1; }\n                }\n            }\n\n            for(int i = 0; i < r; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                int f = int.Parse(input[0]);\n                int t = int.Parse(input[1]);\n                int d = int.Parse(input[2]);\n                map[f, t] = d;\n                map[t, f] = d;\n            }\n\n            // ???????????????????????§?????¢????????????\n            var dist = new Info[n + 1, n + 1];\n            int max_dist = 0;\n            for (int i = 1; i <= n - 1; i++)\n            {\n                for (int j = i + 1; j <= n; j++)\n                {\n                    var inf = Dijkstra(n, i, j, map);\n                    dist[i, j] = inf;\n                    if (inf.Distance > max_dist) { max_dist = inf.Distance; }\n                }\n            }\n\n            var ans = new List<int>();\n            for(int i = 1; i <= n; i++) { ans.Add(i); }\n\n            for(int i = 1; i <= n - 1; i++)\n            {\n                for(int j = i + 1; j <= n; j++)\n                {\n                    if(dist[i,j].Distance == max_dist)\n                    {\n                        var tmp_str = dist[i, j].Root.Trim();\n                        var tmp = tmp_str.Split(' ');\n                        foreach(var s in tmp)\n                        {\n                            var t = int.Parse(s);\n                            if (ans.Contains(t)) { ans.Remove(t); }\n                        }\n                        if (ans.Contains(j)) { ans.Remove(j); }\n                    }\n                }\n            }\n\n            Console.WriteLine(ans.Count);\n            foreach(var i in ans.OrderBy(x => x)) { Console.WriteLine(i); }\n\n            return 0;\n        }\n\n        private static Info Dijkstra(int n, int start, int goal, int[,] map)\n        {\n            var confirm = new bool[n + 1];\n            var dist = new int[n + 1];\n            var root = new string[n + 1];\n            for(int i = 1; i <= n; i++)\n            {\n                confirm[i] = false;\n                dist[i] = int.MaxValue;\n                root[i] = \"\";\n            }\n\n            confirm[start] = true;\n            dist[start] = 0;\n            int current = start;\n            while (true)\n            {\n                for(int i = 1; i <= n; i++)\n                {\n                    if(i == current) { continue; }\n                    if (map[current, i] < 0) { continue; }\n                    if (dist[i] > dist[current] + map[current, i])\n                    {\n                        dist[i] = dist[current] + map[current, i];\n                        root[i] = root[current] + \" \" + current;\n                    }\n                }\n\n                int tmp_dist = int.MaxValue;\n                int next = 0;\n                for(int i = 1; i <= n; i++)\n                {\n                    if (confirm[i]) { continue; }\n                    if (dist[i] < tmp_dist)\n                    {\n                        next = i;\n                        tmp_dist = dist[i];\n                    }\n                }\n                confirm[next] = true;\n                current = next;\n\n                if (confirm[goal]) { break; }\n            }\n\n            var ret = new Info { Distance = dist[goal], Root = root[goal] };\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nfrom collections import deque\nn, r = map(int, input().split())\nG = [[] for i in range(n)]\nfor i in range(r):\n    s, t, d = map(int, input().split())\n    G[s-1].append((t-1, d))\n    G[t-1].append((s-1, d))\n\nINF = 10**18\ndef dijkstra(s):\n    dist = [INF]*n\n    dist[s] = 0\n    que = [(0, s)]\n    while que:\n        cost, s = heappop(que)\n        if dist[s] < cost:\n            continue\n        for t, d in G[s]:\n            if cost + d < dist[t]:\n                dist[t] = cost + d\n                heappush(que, (cost + d, t))\n    ma = max(dist)\n    assert ma != INF\n    goal = [i for i in range(n) if dist[i] == ma]\n    used = set(goal)\n    deq = deque(goal)\n    while deq:\n        s = deq.popleft()\n        for t, d in G[s]:\n            if dist[t] + d == dist[s] and t not in used:\n                used.add(t)\n                deq.append(t)\n    return ma, used\n\nA = [dijkstra(s) for s in range(n)]\nB = max(ma for ma, used in A)\nans = {i for i in range(n)}\nfor ma, used in A:\n    if ma == B:\n        ans -= used\nprint(len(ans))\nfor e in sorted(ans):\n    print(e+1)"
  }
]