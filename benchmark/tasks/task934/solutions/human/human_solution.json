[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for (int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T sqr(const T &a) { return a * a; }\ntypedef long long LL;\ntypedef long double LD;\nvoid procStatus() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\nLL read() {\n\tLL x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (;!isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n\tfor (;isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\treturn x * flag;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 4e5 + 9;\nint n, V, a[Maxn];\n\nvoid Init() {\n\tn = read(), V = read();\n\trep (i, 1, n) a[i] = read();\n}\n\nint pon[20][Maxn];\nint len[Maxn], lef[Maxn], rig[Maxn];\n\nint uppfind(int pos, int step) {\n\tint l = 1, r = len[step], ans = -1;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (pon[step][mid] > pos) ans = pon[step][mid], r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\treturn ans;\n}\n\nint lowfind(int pos, int step) {\n\tint l = 1, r = len[step], ans = pon[step][l];\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (pon[step][mid] < pos) ans = pon[step][mid], l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\treturn ans;\n}\n\nvoid Solve() {\n\tint cnt = 0;\n\twhile ((1 << cnt) <= V) ++cnt;\n\trep (i, 0, cnt) {\n\t\tlen[i] = 1;\n\t\trep (j, 1, n) {\n\t\t\tpon[i][len[i]] = j;\n\t\t\tif (j != n && a[j + 1] - a[j] > (V >> i)) ++len[i];\n\t\t}\n\t\tpon[i][len[i] + 1] = n + 1;\n\t}\n\tif (len[0] > cnt + 1) {\n\t\trep (i, 1, n) puts(\"Impossible\");\n\t\treturn ;\n\t}\n\trep (i, 0, (1 << cnt) - 1) lef[i] = 0, rig[i] = n + 1;\n\trep (i, 0, (1 << cnt) - 1) {\n\t\trep (j, 0, cnt - 1) {\n\t\t\tif ((i >> j) & 1) continue;\n\t\t\tchkmax(lef[i ^ (1 << j)], max(uppfind(lef[i], j + 1), lef[i])); // find a pointer bigger exclusively than f[i]\n\t\t\tchkmin(rig[i ^ (1 << j)], min(lowfind(rig[i] - 1, j + 1), rig[i] - 1)); // find a pointer lower exclusively than f[i]\n\t\t}\n\t}\n\trep (i, 1, len[0]) {\n\t\tint l = pon[0][i - 1] + 1, r = pon[0][i];\n\t\tint flag = 0;\n\t\trep (j, 0, (1 << cnt) - 1) \n\t\t\tif (lef[j] >= l - 1 && rig[(1 << cnt) - 1 - j] <= r + 1) {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\trep (j, l, r) puts(flag ? \"Possible\" : \"Impossible\");\n\t}\n}\n\nint main() {\n//\tfreopen(\"bosky.in\", \"r\", stdin);\n//\tfreopen(\"bosky.out\", \"w\", stdout);\n\n\tInit();\n\tSolve();\t\n\n#ifdef Qrsikno\n//\tprocStatus();\n\tdebug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n#define ll long long\nll n,v,a[2000005],sta[2000005],l[20][400005],r[20][400005],L[2000005],R[2000005],ans[2000005],top;\nint main(){\n\tscanf(\"%lld%lld\",&n,&v);\n\tfor(ll i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n\tll m=v;\n\twhile(m) m>>=1,sta[top++]=m;\n\tsta[top]=v;\n\tfor(ll i=0;i<=top;i++){\n\t\tl[i][1]=1;r[i][n]=n;\n\t\tfor(ll t=2;t<=n;t++) l[i][t]=(a[t]-a[t-1]<=sta[i])?l[i][t-1]:t;\n\t\tfor(ll t=n-1;t>=1;t--) r[i][t]=(a[t+1]-a[t]<=sta[i])?r[i][t+1]:t;\n\t}\n\tfor(ll i=0;i<1<<top;i++) R[i]=n+1;\n\tfor(ll i=0;i<1<<top;i++){\n\t\tfor(ll t=0;t<=top;t++){\n\t\t\tif((i>>t)&1)continue;\n\t\t\tL[(1<<t)|i]=max(L[(1<<t)|i],r[t][L[i]+1]);\n\t\t\tR[(1<<t)|i]=min(R[(1<<t)|i],l[t][R[i]-1]);\n\t\t}\n\t}\n\tfor(ll i=1;i<=n;i++){\n\t\tll fg=0;\n\t\tfor(ll t=0;t<1<<top;t++){\n\t\t\tll ano=((1<<top)-1)^t;\n\t\t\tif(L[t]>=i-1&&R[ano]<=r[top][i]+1){fg=1;break;}\n\t\t}\n\t\tfor(ll t=i;t<=r[top][i];t++) ans[t]=fg;\n\t\ti=r[top][i];\n\t}\n\tfor(ll i=1;i<=n;i++){\n\t\tif(ans[i]) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Camel and Oases\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint const N=2e5+10;\nint const S=1<<17;\nint n,V;\nint d[N];\nint logV,a[20][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n    }\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nvoid type(int s)\n{\n    for(int i=logV;i>=1;i--) printf(\"%d\",(s>>(i-1))%2);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%d\",&d[i]),d[i-1]=d[i]-d[i-1];\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    /*for(int i=1;i<=logV;i++)\n    {\n    \tprintf(\"%d-%d \",1,a[i][1]);\n        for(int j=2;j<=a[i][0];j++) printf(\"%d-%d \",a[i][j-1]+1,a[i][j]);\n        printf(\"\\n\");\n    }*/\n    if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++) puts(\"Impossible\");\n        return 0;\n    }\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=0,f2[s]=n+1;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    /*for(int s=0;s<=U;s+=2)\n        type(s),printf(\"   1-%2d  %2d-%2d\\n\",f1[s],f2[U-s-1],n);*/\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1 && f2[U-s-1]-1<=to) f=true;\n        if(f) for(int j=fr;j<=to;j++) puts(\"Possible\");\n        else for(int j=fr;j<=to;j++) puts(\"Impossible\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#pragma GCC target(\"sse4,tune=native\")\n#pragma GCC optimize(\"O3\",\"unroll-loops\")\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\nconst string FILENAME = \"input\";\nconst int MAXN = 400228;\n\n\nint n, v;\nint x[MAXN];\nint jumpl[21][MAXN], jumpr[21][MAXN];\nint dpl[1 << 20], dpr[1 << 20];\nint suff[1 << 20];\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t//read(FILENAME);\n\tcin >> n >> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t}\n\tvector<int> st;\n\twhile (v > 0) {\n\t\tst.pb(v);\n\t\tv /= 2;\n\t}\n\tst.pb(0);\n\treverse(all(st));\n\tfor (int j = 0; j < sz(st); j++) {\n\t//\tcout << st[j] << ' ' << j + 1 << endl;\n\t\tint uk = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (uk < i) {\n\t\t\t\tuk = i;\n\t\t\t}\n\t\t\twhile (uk + 1 < n && x[uk + 1] - x[uk] <= st[j]) {\n\t\t\t\t//cout << x[uk + 1] - x[uk] << ' ' << st[j] << endl;\n\t\t\t\tuk++;\n\t\t\t}\n\t\t\t//cout << uk << ' ' << j + 1 << endl;\n\t\t\tjumpl[j][i] = uk;\n\t\t}\n\t\tuk = n - 1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (uk > i) {\n\t\t\t\tuk = i;\n\t\t\t}\n\t\t\twhile (uk > 0 && x[uk] - x[uk - 1] <= st[j]) {\n\t\t\t\tuk--;\n\t\t\t}\n\t\t\tjumpr[j][i] = uk;\n\t\t}\n\t}\n\t//cout << jumpl[0][1] << endl;\n\tst.pop_back();\n\tfor (int mask = 0; mask < (1 << sz(st)); mask++) {\n\t\tif (mask == 0) {\n\t\t\tdpl[mask] = -1;\n\t\t\tdpr[mask] = n;\n\t\t} else {\n\t\t\tdpr[mask] = n;\n\t\t\tdpl[mask] = -1;\n\t\t\tfor (int i = 0; i < sz(st); i++) {\n\t\t\t\tif (mask & (1 << i)) {\n\t\t\t\t\tif (dpl[mask ^ (1 << i)] == n - 1) {\n\t\t\t\t\t\tdpl[mask] = n - 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchkmax(dpl[mask], jumpl[i][dpl[mask ^ (1 << i)] + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < sz(st); i++) {\n\t\t\t\tif (mask & (1 << i)) {\n\t\t\t\t\tif (dpr[mask ^ (1 << i)]  == 0) {\n\t\t\t\t\t\tdpr[mask] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchkmin(dpr[mask], jumpr[i][dpr[mask ^ (1 << i)] - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\t//cout << dpl[13] << endl;\n\t//cout << dpr[1] << endl;\n\tdpl[0] = 0;\n\tdpr[0] = n - 1;\n\tvector<pair<int, int> > p;\n\tfor (int mask = 0; mask < (1 << sz(st)); mask++) {\n\t\tint l = dpl[mask];\n\t\tint r = dpr[mask ^ ((1 << sz(st)) - 1)];\n\t\tp.pb({l, r});\n\t}\n\tsort(all(p));\n\tfor (int j = sz(p) - 1; j >= 0; j--) {\n\t\t//cout << p[j].first << ' ' << p[j].second << endl;\n\t\tsuff[j] = p[j].second;\n\t\tif (j < sz(p) - 1) {\n\t\t\tchkmin(suff[j], suff[j + 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint ll = jumpr[sz(st)][i];\n\t\tint rr = jumpl[sz(st)][i];\n\t\tif (ll == 0 && rr == n - 1) {\n\t\t\tcout << \"Possible\\n\";\n\t\t\tcontinue;\n\t\t}\n\t//\tcout << ll << ' ' << rr << endl;\n\t\tint pos = lower_bound(all(p), make_pair(ll - 1, 0)) - p.begin();\t\n\t//\tcout << suff[pos] << ' ' << p[pos].first << endl;\n\t\tif (pos < sz(p) && suff[pos] <= rr + 1) {\n\t\t\tcout << \"Possible\\n\";\n\t\t} else {\n\t\t\tcout << \"Impossible\\n\";\n\t\t}\n\t}\n\treturn 0;\t\t\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\n#ifdef _DEBUG\n#define dbg(x) cerr << #x << \":\" << x << endl;\n#else\n#define dbg(x) while(false){}\n#endif\n\n#define fi(a, b) for(int i=a;i<b;++i)\n#define fj(a, b) for(int j=a;j<b;++j)\n\n////////\n\nint const M = 20;\nint const N = (1<<M);\nstring const YES = \"Possible\";\nstring const NO = \"Impossible\";\n\nint n, v, x[N];\nint le[N][M], ri[N][M];\nint cnt;\nstring ans[N];\n\nvoid setAns(string val, int l, int r){\n\tfi(l, r+1) ans[i] = val;\n}\n\nvoid print(){\n\tfi(1, n+1) printf(\"%s\\n\", ans[i].c_str());\n\texit(0);\n}\n\nvoid check(){\n\tint cn = cnt + 1;\n\tint v = 1;\n\twhile(v <= n){\n\t\tv = ri[v][0] + 1;\n\t\t--cn;\n\t}\n\tif(cn < 0){\n\t\tsetAns(NO, 1, n);\n\t\tprint();\n\t}\n}\n\nvoid build(){\n\tint vi = v;\n\tfi(0, M){\n\t\tcnt = i;\n\t\tle[1][i] = 1;\n\t\tfj(2, n+1){\n\t\t\tif(x[j] - x[j-1] <= vi) le[j][i] = le[j-1][i];\n\t\t\telse le[j][i] = j;\n\t\t}\n\t\tri[n][i] = n;\n\t\tfor(int j=n-1;j>0;--j){\n\t\t\tif(x[j+1] - x[j] <= vi) ri[j][i] = ri[j+1][i];\n\t\t\telse ri[j][i] = j;\n\t\t}\n\t\tif(vi == 0) break;\n\t\tvi /= 2;\n\t}\n}\n\nint dl[N], dr[N];\n\nvoid remax(int &a, int b){\n\ta = max(a, b);\n}\n\nvoid remin(int &a, int b){\n\ta = min(a, b);\n}\n\nvoid calcDp(){\n\tdl[0] = 0;\n\tfi(0, (1<<cnt)){\n\t\tfj(0, cnt){\n\t\t\tif((1<<j)&i) continue;\n\t\t\tint nval = dl[i];\n\t\t\tif(nval != n){\n\t\t\t\tnval = ri[dl[i]+1][j+1];\n\t\t\t}\n\t\t\tremax(dl[((1<<j)^i)], nval);\n\t\t}\n\t}\n\tfi(0, (1<<cnt)) dr[i] = n+1;\n\tfi(0, (1<<cnt)){\n\t\tfj(0, cnt){ \n\t\t\tif((1<<j)&i) continue;\n\t\t\tint nval = dr[i];\n\t\t\tif(nval != 1){\n\t\t\t\tnval = le[dr[i]-1][j+1];\n\t\t\t}\n\t\t\tremin(dr[((1<<j)^i)], nval);\n\t\t}\n\t}\n}\n\nvoid findAnswers(){\n\tint v, nxt;\n\tv = 1;\n\twhile(v <= n){\n\t\tnxt = ri[v][0];\n\t\tbool can = false;\n\t\tfi(0, (1<<(cnt))){\n\t\t\tint maskL = i;\n\t\t\tint maskR = ( ((1<<(cnt))-1) ^ maskL );\n\t\t\tint lb = dl[maskL];\n\t\t\tint rb = dr[maskR];\n\t\t\tif(lb+1 >= v && rb-1 <= nxt){\n\t\t\t\tcan = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(can){\n\t\t\tsetAns(YES, v, nxt);\n\t\t}else{\n\t\t\tsetAns(NO, v, nxt);\n\t\t}\n\t\tv = nxt + 1;\n\t}\n}\n\nvoid solve(){\n\tscanf(\"%d %d\",&n,&v);\n\tfi(1, n+1) scanf(\"%d\",&x[i]);\n\n\tbuild();\n\tdbg(cnt);\n\tcheck();\n\tcalcDp();\n\tfindAnswers();\n\tprint();\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define dis(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2e5+233;\nint L[20][maxn],R[20][maxn];\nint f[maxn],g[maxn];\nint ans[maxn]; \nint n,V,tmp,x[maxn],v[21];\nint main(){\n\tn = rd(),V = tmp = rd();\n\tRep(i,1,n) x[i] = rd();\n\ttmp /= 2;\n\twhile(tmp){\n\t\tv[++v[0]] = tmp;\n\t\ttmp /= 2;\n\t}\n\tv[++v[0]] = 0;\n\tRep(d,1,v[0]){\n\t\tfor(int i=1,j=-1;i<=n;i=j+1){\n\t\t\tfor(j=i+1;j<=n && x[j]-x[j-1]<=v[d];j++);j--;\n//\t\t\tprintf(\"[%d %d]\\n\",i,j);\n\t\t\tRep(k,i,j){\n\t\t\t\tL[d][k] = i;\n\t\t\t\tR[d][k] = j;\n\t\t\t}\n\t\t}R[d][n+1] = n;L[d][0] = 1;\n\t}\n\t\n\tfor(int i=1,j=-1;i<=n;i=j+1){\n\t\tfor(j=i+1;j<=n && x[j]-x[j-1]<=V;j++);j--;\n//\t\tprintf(\"[%d %d][%d %d]\\n\",i,j,x[j]-x[i],x[j+1]-x[i]);\n\t\tRep(k,i,j){\n\t\t\tL[0][k] = i;\n\t\t\tR[0][k] = j;\n//\t\t\tprintf(\"L[%d][%d] = %d\\n\",V,k,L[0][k]);\n\t\t}\n\t}R[0][n+1] = n;L[0][0] = 1;\n\trep(i,0,1<<v[0]) f[i] = 0;\n\trep(i,0,1<<v[0]){\n\t\tfor(int j=1;j<=v[0];++j){\n\t\t\tif(i>>(j-1)&1^1){\n\t\t\t\tf[i|(1<<(j-1))] = max(f[i|(1<<(j-1))],R[j][f[i]+1]);\n\t\t\t}//如果不包括，那么可以选择 \n\t\t}\n\t}\n\trep(i,0,1<<v[0]) g[i] = n+1;\n\trep(i,0,1<<v[0]){\n\t\tfor(int j=1;j<=v[0];++j){\n\t\t\tif(i>>(j-1)&1^1){\n\t\t\t\tg[i|(1<<(j-1))] = min(g[i|(1<<(j-1))],L[j][g[i]-1]);\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,0,1<<v[0]){\n//\t\tprintf(\"[%d%d%d%d%d] : %d,%d\\n\",i/16%2,i/8%2,i/4%2,i/2%2,i%2,f[i],g[i]);\n//\t}\n\trep(i,0,1<<v[0]){\n\t\tint j=((1<<v[0])-1)^i;\n//\t\tprintf(\"[%d %d]\\n\",i,j);\n\t\tint pos = f[i]+1;\n\t//\tprintf(\"[%d %d]\\n\",f[i],g[j]);\n//\t\tif(f[i]+1 >= g[j]){\n//\t\t\tprintf(\"[%d %d]\\n\",f[i],g[j]);\n//\t\t} else\n\t\tif(L[0][pos] <= f[i]+1 && g[j]-1 <= R[0][pos]){\n\t\t\tans[L[0][pos]]++;\n\t\t\tans[R[0][pos]+1]--;\n\t\t}//区间可行 \n\t}\n\tRep(i,1,n) ans[i] += ans[i-1];\n\tRep(i,1,n){\n//\t\tprintf(\"{%d %d}\\n\",L[0][i],R[0][i]);\n\t\tif(ans[i]) puts(\"Possible\");\n\t\t\t  else puts(\"Impossible\");\n\t}\n\treturn 0;\n}\n/*\n5 3\n-4 0 1 2 6\n\n11 12\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\nint maxL[20][200005], maxR[20][200005];\nint p_L, p_R;\nint dpL[(1<<20)], dpR[(1<<20)]; // dpL prefix, dpR suffix\nint N, V;\nll x[200005];\nint BIT[200005];\nint parts[200005];\nvector <pii> dp_range;\n\nint calc_dpL(int mask) {\n\t//cout << mask << endl;\n\tif (mask == 0) return 0;\n\tint &ret = dpL[mask];\n\tint tmp;\n\tif (ret != -1) return ret;\n\tret = 0;\n\tfor (int i=0;i<20;++i) {\n\t\tif (mask&(1<<i)) {\n\t\t\tif (calc_dpL(mask - (1<<i)) == N) ret = N;\n\t\t\telse {\n\t\t\t\ttmp = calc_dpL(mask-(1<<i));\n\t\t\t\ttmp = maxR[i][tmp] - tmp + 1;\n\t\t\t\tret = max(ret,tmp + calc_dpL(mask-(1<<i)));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint calc_dpR(int mask) {\n\t//cout << mask << endl;\n\tif (mask == 0) return 0;\n\tint &ret = dpR[mask];\n\tint tmp;\n\tif (ret != -1) return ret;\n\tret = 0;\n\tfor (int i=0;i<20;++i) {\n\t\tif (mask&(1<<i)) {\n\t\t\tif (calc_dpR(mask - (1<<i)) == N) ret = N;\n\t\t\telse {\n\t\t\t\ttmp = (N-1) - calc_dpR(mask-(1<<i));\n\t\t\t\ttmp = tmp - maxL[i][tmp] + 1;\n\t\t\t\tret = max(ret,tmp + calc_dpR(mask-(1<<i)));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool cmp(pii a, pii b) {\n\treturn a.se < b.se;\n}\n\nint BIT_q(int u) {\n\t++u;\n\tint ret = -1;\n\twhile (u) {\n\t\tret=max(ret,BIT[u]);\n\t\tu-=u&(-u);\n\t}\n\treturn ret;\n}\n\nvoid BIT_u(int u,int val) {\n\t++u;\n\tfor (;u<200005;u+=u&(-u)) BIT[u]=max(BIT[u],val);\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tmemset(dpL,-1,sizeof(dpL));\n\tmemset(dpR,-1,sizeof(dpR));\n\tmemset(BIT,-1,sizeof(BIT));\n\tparts[0]=1;\n\tfor (int i=1;i<200005;++i) {\n\t\tparts[i] = 1+parts[i>>1];\n\t}\n\tcin >> N >> V;\n\tfor (int i=0;i<N;++i)\n\t\tcin >> x[i];\n\tfor (int i=0;i<20;++i) {\n\t\tfor (int j=N;j>=0;--j) {\n\t\t\tmaxR[i][j]=j;\n\t\t\tif ( j+1 < N && x[j+1]-x[j] <= (V>>i) ) maxR[i][j] = maxR[i][j+1];\n\t\t}\n\t}\n\tfor (int i=0;i<20;++i) {\n\t\tfor (int j=0;j<=N;++j) {\n\t\t\tmaxL[i][j]=j;\n\t\t\tif ( j-1 >= 0 && x[j]-x[j-1] <= (V>>i) ) maxL[i][j] = maxL[i][j-1];\n\t\t}\n\t}\n\t//cout << \"Kelar\\n\";\n\t//cout << \"cuk\\n\";\n\tint mask_r;\n\tfor (int mask_l=0;mask_l<(1<<parts[V]);mask_l+=2) {\n\t\t//cout << mask_l << endl;\n\t\tmask_r = ((1<<parts[V]) - 1) - mask_l - 1;\n\t\t//if (mask_r == 0) continue;\n\t\tdp_range.push_back(make_pair(calc_dpL(mask_l),calc_dpR(mask_r)));\n\t}\n\t//cout << \"yy\\n\";\n\tsort(dp_range.begin(), dp_range.end(), cmp);\n\t//cout << \"yaya\\n\";\n\tfor (int i=0;i<(int)dp_range.size();++i) {\n\t\t//cout << dp_range[i].fi << \" (\" << N - dp_range[i].fi << \") \" << dp_range[i].se << endl;\n\t\tBIT_u(N - dp_range[i].fi,dp_range[i].se);\n\t\t//cout << \"jalan \" << dp_range[i].fi << ' ' << dp_range[i].se << endl;\n\t}\n\t//cout << \"cihuy\\n\";\n\tfor (int i=0;i<N;++i) {\n\t\tp_L = maxL[0][i];\n\t\tp_R = maxR[0][i];\n\t\t//cout << i << ' ' << p_L << ' ' << p_R << ' ' << BIT_q(N - p_L) << endl;\n\t\tif (BIT_q(N - p_L) >= N-(p_R+1)) cout << \"Possible\\n\";\n\t\telse cout << \"Impossible\\n\";\n\t\t/*int mask_r;\n\t\tfor (int mask_l=0;mask_l<(1<<parts[V]);mask_l+=2) {\n\t\t\tmask_r = ((1<<parts[V]) - 1) - mask_l - 1;\n\t\t\tif ((calc_dpL(mask_l) >= p_L) && (calc_dpR(mask_r) >= N - (p_R+1))) { cout << \"Possible \" << mask_l << ' ' << mask_r << endl; break; }\n\t\t}\n\t\t//cout << \"Impossible\\n\";*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=200005,INF=0x3F3F3F3F,MAXLG=25;\n\nint N,V,lgV,X[MAXN];\nint f1[MAXN*4],f2[MAXN*4];\nvector<int> seg[MAXLG];\nbool ans[MAXN];\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&V);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d\",&X[i]);\n\tX[0]=-INF;\n\tX[N+1]=INF;\n\n\tfor(int d=V;;d/=2)\n\t{\n\t\tlgV++;\n\t\tfor(int i=1;i<=N+1;i++)\n\t\t\tif(X[i]-X[i-1]>d)\n\t\t\t\tseg[lgV].push_back(i-1);\n\t\tseg[lgV].push_back(N+1);\n\t\tif(d==0)\n\t\t\tbreak;\n\t}\n\n\tif((int)seg[1].size()-2>lgV)\n\t{\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\n\tf1[0]=0;\n\tfor(int s=1;s<(1<<lgV);s++)\n\t\tfor(int i=1;i<=lgV;i++)\n\t\t\tif((s&(1<<(i-1))))\n\t\t\t{\n\t\t\t\tint ts=s^(1<<(i-1));\n\t\t\t\tf1[s]=max(f1[s],f1[ts]);\n\t\t\t\tif(f1[s]==N)\n\t\t\t\t\tcontinue;\n\t\t\t\tauto it=upper_bound(seg[i].begin(),seg[i].end(),f1[ts]);\n\t\t\t\tf1[s]=max(f1[s],*it);\n\t\t\t}\n\tmemset(f2,0x3F,sizeof f2);\n\tf2[0]=N+1;\n\tfor(int s=1;s<(1<<lgV);s++)\n\t\tfor(int i=1;i<=lgV;i++)\n\t\t\tif((s&(1<<(i-1))))\n\t\t\t{\n\t\t\t\tint ts=s^(1<<(i-1));\n\t\t\t\tf2[s]=min(f2[s],f2[ts]);\n\t\t\t\tif(f2[s]==1)\n\t\t\t\t\tcontinue;\n\t\t\t\tauto it=lower_bound(seg[i].begin(),seg[i].end(),f2[ts]-1);\n\t\t\t\tif(it==seg[i].begin())\n                    continue;\n                it--;\n\t\t\t\tf2[s]=min(f2[s],*it+1);\n\t\t\t}\n\n    for(int i=1;i<(int)seg[1].size()-1;i++)\n\t{\n\t\tint l=seg[1][i-1]+1,r=seg[1][i];\n\t\tfor(int s=0;s<(1<<lgV);s+=2)\n\t\t{\n\t\t\tint ts=((1<<lgV)-1)^s^1;\n\t\t\tif(f1[s]>=l-1&&f2[ts]<=r+1)\n\t\t\t{\n\t\t\t\tans[i]=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1,j=1;i<=N;i++,j=(i>seg[1][j]?j+1:j))\n\t\tputs(ans[j]?\"Possible\":\"Impossible\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/// a.cpp\n\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < __typeof(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < ll >\n# define pb push_back\n# define pdd pair < db , db >\ninline int readChar();\ntemplate <class T = int> inline T readInt();\ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x );\ninline void writeWord( const char *s );\n\n/** Read */\n\nstatic const int buf_size = 4096;\n\ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len)\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    if (pos == len)\n        return -1;\n    return buf[pos++];\n}\n\ninline int readChar() {\n    int c = getChar();\n    while (c <= 32)\n        c = getChar();\n    return c;\n}\n\ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n\n/** Write */\n\nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n\ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n\ntemplate <class T>\ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n\n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n\ninline void writeWord( const char *s ) {\n    while (*s)\n        writeChar(*s++);\n}\n\nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n# define CF\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int RMQ[20][1 << 19];\n    static int Dp1[20][1 << 19];\n    static int Dp2[20][1 << 19];\n    int n,k;\n    n = readInt();\n    k = readInt();\n    static int s[1 << 20];\n    for (int i = 1;i <= n;++i)\n        s[i] = readInt();\n    for (int i = 1;i < n;++i)\n        RMQ[0][i] = s[i + 1] - s[i];\n    for (int t = 1;n >> t;++t)\n        for (int i = 1;i + (1 << t) <= n + 1;++i)\n            RMQ[t][i] = max(RMQ[t - 1][i],RMQ[t - 1][i + (1 << (t - 1))]);\n    static int Log[1 << 20];\n    for (int i = 2;i <= (1 << 19);++i)\n        Log[i] = Log[i / 2] + 1;\n    auto get = [&](int l,int r)\n    {\n        int lg = Log[r - l + 1];\n        return max(RMQ[lg][l],RMQ[lg][r - (1 << lg) + 1]);\n    };\n    static int D1[1 << 20];\n    static int D2[1 << 20];\n    int lg = Log[k] + 2;\n    const int N = 1 << lg;\n    for (int t = 0;t < lg;++t)\n    {\n        Dp1[t][1] = 0;\n        for (int i = 2;i <= n;++i)\n            if (s[i] - s[i - 1] <= (k >> t))\n                Dp1[t][i] = Dp1[t][i - 1];\n            else\n                Dp1[t][i] = i - 1;\n        Dp2[t][n] = Dp2[t][n + 1] = n + 1;\n        for (int i = n - 1;i;--i)\n            if (s[i + 1] - s[i] <= (k >> t))\n                Dp2[t][i] = Dp2[t][i + 1];\n            else\n                Dp2[t][i] = i + 1;\n    }\n    D1[0] = 0;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            if ((mask >> i) & 1)\n                smax(D1[mask],Dp2[i][D1[mask ^ (1 << i)] + 1] - 1);\n    for (int mask = 0;mask < N;++mask)\n        D2[mask] = n + 1;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            smin(D2[mask],Dp1[i][D2[mask ^ (1 << i)] - 1] + 1);\n    static int answer[1 << 20];\n    for (int mask1 = 0;mask1 < N;++mask1)\n        if (!(mask1 & 1))\n        {\n            int mask2 = (N - 1) ^ 1 ^ mask1;\n            const int l = D1[mask1];\n            const int r = D2[mask2];\n            if (l + 1 > r - 1)\n                answer[1]++,--answer[n + 1];\n            else\n            if (l + 1 == r - 1 || get(l + 1,r - 2) <= k)\n                ++answer[l + 1],--answer[r];\n        }\n    for (int i = 1;i <= n;++i)\n        answer[i] += answer[i - 1];\n    for (int i = 1;i <= n;++i)\n        if (answer[i])\n            PP;\n        else\n            II;\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,v,x[200005];\nint go[200005][20],go2[200005][20];\nint dp[(1<<20)],dp2[(1<<20)];\nint used[200005];\nP p[200005];\n#define s (1<<20)\nint seg[s]={};\nvoid update(int k,int a){\n\tk+=s/2-1; seg[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tseg[k]=max(seg[k*2+1],seg[k*2+2]);\n\t}\n}\nint query(int a,int b,int k,int l,int r){\n\tif(r<a || b<l || a>b) return 0;\n\tif(a<=l && r<=b) return seg[k];\n\telse{\n\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=query(a,b,k*2+2,(l+r)/2+1,r);\n\t\treturn max(vl,vr);\n\t}\n}\nint main(){\n\tcin>>n>>v;\n\trepn(i,n)cin>>x[i];\n\tvector<int>vi;\n\twhile(1){\n\t\tvi.pb(v);\n\t\tif(v == 0) break;\n\t\tv/=2;\n\t}\n\trep(j,vi.size()){\n\t\tvector<int>vec;\n\t\trepn(i,n-1){\n\t\t\tif(x[i+1]-x[i] > vi[j]){\n\t\t\t\tvec.pb(i);\n\t\t\t}\n\t\t}\n\t\tvec.pb(n);\n\t\trepn(i,n){\n\t\t\tint e = vec[POSL(vec,i)];\n\t\t\tgo[i][j] = e;\n\t\t\tif(j==0) p[i].sc = e;\n\t\t}\n\t}\n\trep(j,vi.size()){\n\t\tvector<int>vec;\n\t\tvec.pb(1);\n\t\trepn(i,n-1){\n\t\t\tif(x[i+1]-x[i] > vi[j]){\n\t\t\t\tvec.pb(i+1);\n\t\t\t}\n\t\t}\n\t\trepn(i,n){\n\t\t\tint e = vec[POSU(vec,i)-1];\n\t\t\tgo2[i][j] = e;\n\t\t\tif(j==0) p[i].fi = e;\n\t\t}\n\t}\n\t//repn(i,n)cout<<p[i].fi<<\" \"<<p[i].sc<<endl;\n\trep(i,(1<<20)) dp[i] = -INF;\n\tdp[0] = 1;\n\tint z = vi.size();\n\tfor(int mask=0;mask<(1<<z);mask++){\n\t\tif(dp[mask] <= 0) continue;\n\t\tfor(int i=0;i<z;i++){\n\t\t\tif(((mask>>i)&1)) continue;\n\t\t\tint NXT = go[dp[mask]+1][i];\n\t\t\tif(dp[mask]==n) NXT=n;\n\t\t\tdp[mask+(1<<i)] = max(dp[mask+(1<<i)],NXT);\n\t\t}\n\t}\n\trep(i,(1<<20)) dp2[i] = INF;\n\tdp2[0] = n;\n\t//int z = vi.size();\n\tfor(int mask=0;mask<(1<<z);mask++){\n\t\tif(dp2[mask] > n) continue;\n\t\tfor(int i=0;i<z;i++){\n\t\t\tif(((mask>>i)&1)) continue;\n\t\t\tint NXT = go2[dp2[mask]-1][i];\n\t\t\tif(dp2[mask]==1) NXT=1;\n\t\t\tdp2[mask+(1<<i)] = min(dp2[mask+(1<<i)],NXT);\n\t\t}\n\t}\n\tfor(int i=1;i<=n-1;i++){\n\t\tupdate(i,x[i+1]-x[i]);\n\t}\n\tvector<P>L;\n//\tbool allok = 0;\n\tfor(int mask=0;mask<(1<<z);mask++){\n\t\tif(mask%2 == 1) continue;\n\t\tint mask2 = (1<<z)-2-mask;\n\t\tint x = dp[mask];\n\t\tint y = dp2[mask2];\n\t\t//cout<<x<<y<<endl;\n\t\tif(x+1>y-1) used[1] += 1;\n\t\telse{\n\t\t\tint L = p[x+1].fi;\n\t\t\tint R = p[x+1].sc;\n\t\t\tif(L<=x+1 && y-1<=R){\n\t\t\t\tused[L]++;\n\t\t\t\tused[R+1]--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++) used[i]+=used[i-1];\n\tfor(int i=1;i<=n;i++){\n\t\tputs(used[i]?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=200005;\nint n,V,x[N],lt[N][21],rt[N][21],f[1100000],g[1100000],num,i,j,k,w[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&V);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",x+i);\n\tfor(i=0;;++i)\n\t{\n\t\tlt[0][i]=lt[1][i]=1;\n\t\tfor(j=2;j<=n;++j)\n\t\t\tif(x[j]-x[j-1]<=(V>>i))\n\t\t\t\tlt[j][i]=lt[j-1][i];\n\t\t\telse\n\t\t\t\tlt[j][i]=j;\n\t\trt[n+1][i]=rt[n][i]=n;\n\t\tfor(j=n-1;j>=1;--j)\n\t\t\tif(x[j+1]-x[j]<=(V>>i))\n\t\t\t\trt[j][i]=rt[j+1][i];\n\t\t\telse\n\t\t\t\trt[j][i]=j;\n\t\tnum=i;\n\t\tif(!(V>>i))\n\t\t\tbreak;\n\t}\n\tf[0]=0;\n\tfor(i=1;i<(1<<num);++i)\n\t\tfor(j=1;j<=num;++j)\n\t\t\tif(i>>(j-1)&1)\n\t\t\t\tf[i]=max(f[i],rt[f[i^(1<<(j-1))]+1][j]);\n\tg[0]=n+1;\n\tfor(i=1;i<(1<<num);++i)\n\t{\n\t\tg[i]=n+1;\n\t\tfor(j=1;j<=num;++j)\n\t\t\tif(i>>(j-1)&1)\n\t\t\t\tg[i]=min(g[i],lt[g[i^(1<<(j-1))]-1][j]);\n\t}\n\tfor(i=0;i<=n+1;++i)\n\t\tw[i]=-1;\n\tfor(i=0;i<(1<<num);++i)\n\t\tw[g[i]]=max(w[g[i]],f[((1<<num)-1)^i]);\n\tfor(i=1;i<=n+1;++i)\n\t\tw[i]=max(w[i],w[i-1]);\n\tfor(i=1;i<=n;++i)\n\t\tif(w[rt[i][0]+1]>=lt[i][0]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pb2 pop_back\n#define pf push_front\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define rep(k,i,j) for(int k = (int)i;k<(int) j;k++)\n#define repd(k,i,j) for(int k = i;k>=(int)j;k--)\n#define ll long long\n#define pq priority_queue\n\nint dirx[8] = {0,1,0,-1,1,1,-1,-1};\nint diry[8] = {1,0,-1,0,1,-1,1,-1};\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e16;\nconst double EPS = 1e-6;\n\nusing namespace std;\n\nconst int maxn = 5e5+5;\n\nint n,v;\nint loc[maxn];\n\nint jump[maxn][20],m;\n\nint dp[maxn];\n\nint ch[maxn];\n\nint in_q[maxn];\n\nqueue<int> q;\nint solve(){\n\twhile(q.size())q.pop();\n\tmemset(dp,-1,sizeof dp);\n\tmemset(in_q,0,sizeof in_q);\n\t\n\tq.push(1);\n\tdp[1] = ch[0];\n\tin_q[1] = 1;\n\t\n\t\n\twhile(q.size()){\n\t\tint mask = q.front();\n\t\tint a = dp[mask];\n\t\t\n\t\tq.pop();\n\t\tin_q[mask] = 0;\n\t\t\n\t\tif(a==n)return 1;\n\t\trep(k,0,m)if(((1<<k)&mask)==0){\n\t\t\tint b = ch[jump[a][k]];\n\t\t\tint maskb = (mask|(1<<k));\n\t\t\t\n\t\t\tif(dp[maskb]<b){\n\t\t\t\tdp[maskb] = b;\n\t\t\t\tif(!in_q[maskb])q.push(maskb),in_q[maskb] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\t\n\trep(k,0,n)scanf(\"%d\",&loc[k]);\n\t\n\t\n\tfor(;v>=0;v/=2){\n\t\trep(k,0,n){\n\t\t\tint i = k;\n\t\t\twhile(i<n){\n\t\t\t\tif(i<n-1 && loc[i+1]-loc[i]<=v){\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\twhile(k<=i)jump[k++][m] = i+1;\n\t\t\tk = i;\n\t\t}\n\t\t//printf(\"%d \\n\",v);\n\t\tm++;\n\t\tif(v==0)break;\n\t}\n\t\n\tif(m>=20)return 0;\n\t\n\trep(k,0,maxn)ch[k] = k;\n\t\n\tint hit = 0;\n\trep(k,0,n){\n\t\tif(hit>20){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint nxt = jump[k][0];\n\t\t\n\t\thit++;\n\t\tch[k] = nxt;\n\t\tint ret = solve();\n\t\tch[k] = k;\n\t\t\n\t\twhile(k<nxt)printf(\"%s\\n\",ret?\"Possible\":\"Impossible\"),k++;\n\t\tk = nxt-1;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define F(i,j,n) for(register int i=j;i<=n;i++)\n#define D(i,j,n) for(register int i=j;i>=n;i--)\n#define ll long long\n#define N 200010\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;int f;\n\tchar gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void gi(I&x){\n\t\tfor(f=1,c=gc();c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n};\nusing io::gi;\nusing io::gc;\nint f[N],g[N],s[20],r[20][N],l[20][N],x[N],p[1<<20],q[1<<20],n,v,d,t,m,ans[N];\nint main(){\n\tgi(n);gi(v);\n\tF(i,1,n)gi(x[i]);\n\tD(i,n,2)x[i]-=x[i-1];\n\tx[1]=v+1;x[n+1]=v+1;\n\tD(i,n,1)g[i]=(x[i+1]>v)?i:g[i+1];\n\tF(i,1,n)f[i]=(x[i]>v)?i:f[i-1];\n\tF(i,1,n)if(x[i]>v)t++;\n\tfor(d=0;v;d++){\n\t\tv/=2;\n\t\tD(i,n,1)r[d][i]=(x[i+1]>v)?i:r[d][i+1];\n\t\tF(i,1,n)l[d][i]=(x[i]>v)?i:l[d][i-1];\n//\t\tF(i,1,n)printf(\"%d \",l[d][i]);puts(\"\");\n\t}\n\tif(d+1<t){F(i,1,n)puts(\"Impossible\");return 0;}\n\tm=(1<<d)-1;d--; \n\tF(i,0,m){\n\t\tq[i]=n+1;p[i]=0; \n\t\tF(j,0,d)if((i>>j)&1)p[i]=max(p[i],r[j][min(n,p[i^(1<<j)]+1)]);\n\t\tF(j,0,d)if((i>>j)&1)q[i]=min(q[i],l[j][max(1,q[i^(1<<j)]-1)]);\n\t}\n//\tF(i,0,m)printf(\"%d %d %d\\n\",i,p[i],q[i]);\n\tF(i,1,n)if(f[i]==i){\n\t\tfor(int j=m;j;j=m&(j-1))if(p[j]>=i-1&&q[m^j]<=g[i]+1)ans[i]=1;\n\t\tif(i==1&&q[m]<=g[i]+1)ans[i]=1;\n//\t\tprintf(\"%d %d\\n\",f[i],g[i]);\n\t}\n\telse ans[i]=ans[f[i]];\n\tF(i,1,n)puts(ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXMASK=(1<<18);\nconst int MAXN=20;\nconst int MAXM=200005;\nint a[MAXM],n,V,mx;\nvector<pii> vec[MAXN];\nint L[MAXN][MAXM],R[MAXN][MAXM];\nvoid work(int x,int o)\n{\n\tfor(int i=1,nxt;i<=n;i=nxt+1)\n\t{\n\t\tnxt=i;while(nxt+1<=n&&a[nxt+1]-a[nxt]<=x)++nxt;\n\t\tfor(int j=i;j<=nxt;j++)L[o][j]=i,R[o][j]=nxt;\n\t}\n}\nint f[MAXMASK],g[MAXMASK],num[MAXN][MAXMASK],bin[25];\nint main()\n{\n\tbin[1]=1;for(int i=2;i<=20;i++)bin[i]=bin[i-1]<<1;\n\tn=read();V=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tint temp=V;while(temp)work(temp,mx++),temp>>=1;\n\tfor(int i=1;i<=n;i++)L[mx][i]=R[mx][i]=i;\n\tmemset(g,63,sizeof(g));g[0]=n+1;\n\tfor(int i=1;i<bin[mx+1];i++)for(int j=1;j<=mx;j++)if(i&bin[j])\n\t{\n\t\tint pre=f[i^bin[j]];\n\t\tf[i]=max(f[i],R[j][pre+1]);\n\t\tif(pre==n)f[i]=n;\n\t\tpre=g[i^bin[j]];\n\t\tg[i]=min(g[i],L[j][pre-1]);\n\t\tif(pre==1)g[i]=1;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tbool tf=false;\n\t\tfor(int j=0;j<bin[mx+1];j++)\n\t\t{\n\t\t\tint lim1=L[0][i],lim2=R[0][i];\n\t\t\tif(f[j]>=lim1-1&&g[(bin[mx+1]-1)^j]<=lim2+1){tf=true;break;}\n\t\t}\n\t\tif(tf)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nconst int NMAX = 300000;\nconst int LOGN = 22;\nint V[LOGN];\nint Lmost[NMAX][LOGN], Rmost[NMAX][LOGN];\n \nint dpL[1<<LOGN], dpR[1<<LOGN];\nint arr[NMAX+1];\nint dp[NMAX+2];\n \nint main(){\n    int N; scanf(\"%d%d\",&N,&V[0]);\n    for(int i=1;i<=N;i++) scanf(\"%d\",arr+i);\n \n    int M = 1;\n    while(V[M-1]){\n        V[M] = V[M-1]/2;\n        M++;\n    }\n \n    for(int i=0;i<M;i++){\n        int v = V[i];\n        int j = 1;\n        while(j<=N){\n            int k = j+1;\n            while(k<=N && arr[k]-arr[k-1] <= v) k++;\n            for(int x=j;x<k;x++) Rmost[x][i] = k-1;\n            j = k;\n        }\n        j = N;\n        while(j>=1){\n            int k = j-1;\n            while(k>=1 && arr[k+1]-arr[k] <= v) k--;\n            for(int x=j;x>k;x--) Lmost[x][i] = k+1;\n            j = k;\n        }\n    }\n \n    for(int i=0;i<(1<<M);i++) dpR[i] = N+1;\n    for(int i=1;i<(1<<M);i++){\n        for(int j=0;j<M;j++) if(i&(1<<j)){\n            // use V[j]\n            int L = dpL[i^(1<<j)];\n            dpL[i] = max(dpL[i], Rmost[L+1][j]);\n \n            int R = dpR[i^(1<<j)];\n            dpR[i] = min(dpR[i], Lmost[R-1][j]);\n        }\n    }\n \n    for(int i=0;i<=N+1;i++) dp[i] = -1;\n \n    for(int i=2;i<(1<<M);i+=2){\n        int j = ((1<<M)-1)^i^1;\n        dp[dpR[j]] = max(dp[dpR[j]], dpL[i]);\n    }\n \n    for(int i=1;i<=N+1;i++)\n        dp[i] = max(dp[i], dp[i-1]);\n \n    for(int i=1;i<=N;i++){\n        int L = Lmost[i][0], R = Rmost[i][0];\n        int det = dp[R+1];\n        if(det>=L-1) printf(\"Possible\\n\");\n        else printf(\"Impossible\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\n#define MAX 200002\n\nint n;\nint v;\n\nvector<int> vv;\n\nint dp[MAX][20];\nint val[MAX];\n\n\n\nmap<int, vector<int> > mp;\n\nvector<vector<int> > V;\n\n\nvector<int> VV;\n\nint mx = 0;\n\nint D[1 << 17];\nbool ok(){\n\tif (VV.size() == 0){\n\t\treturn true;\n\t}\n\tint N = VV.size();\n\tfor (int i = 1; i <= mx; i++){\n\t\tdp[N - 1][i] = N - 1;\n\t}\n\tfor (int i = N - 2; i >= 0; i--){\n\t\tlong long int d = VV[i + 1] - VV[i];\n\t\tfor (int j = 1; j <= mx; j++){\n\t\t\tif (d <= val[j]){\n\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i][j] = i;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(D, 0, sizeof(D));\n\tfor (int i = 0; i < (1 << mx); i++){\n\t\tif (D[i] >= N){\n\t\t\treturn true;\n\t\t}\n\t\tfor (int j = 1; j <= mx; j++){\n\t\t\tif ((i >> (j - 1)) & 1)continue;\n\t\t\tint go = i | (1 << (j - 1));\n\t\t\tD[go] = max(D[go], dp[D[i]][j]+1);\n\t\t}\n\t}\n\treturn false;\n}\nbool ans[MAX];\n\nint main(){\n\tcin >> n >> v;\n\tfor (int i = 0; i < n; i++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tvv.push_back(x);\n\t}\n\t\n\tval[0] = v;\n\tfor (mx = 1; v / 2 >= 0; mx++){\n\t\tv /= 2;\n\t\tval[mx] = v;\n\t\tif (v == 0)break;\n\t}\n\tfor (int i = 0; i <= mx; i++){\n\t\tdp[n - 1][i] = n-1;\n\t}\n\tfor (int i = n - 2; i >= 0; i--){\n\t\tlong long int d = vv[i + 1] - vv[i];\n\t\tfor (int j = 0; j <= mx; j++){\n\t\t\tif (d <= val[j]){\n\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i][j] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tmp[dp[i][0]].push_back(i);\n\t}\n\tif (mp.size()>mx+1){\n\t\t\n\t}\n\telse{\n\t\tfor (auto it = mp.begin(); it != mp.end(); it++){\n\t\t\tVV.clear();\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (i < (*it).second[0] || (*it).second.back() < i){\n\t\t\t\t\tVV.push_back(vv[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok()){\n\t\t\t\tvector<int> &vvv = (*it).second;\n\t\t\t\tfor (int j = 0; j < vvv.size(); j++){\n\t\t\t\t\tans[vvv[j]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tif (ans[i] == true){\n\t\t\tputs(\"Possible\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"Impossible\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MN = 200010;\nconst int ML = 19;\n\nint N, V;\nint v[ML];\nint x[MN];\nint tor[2][ML][MN];\nint dp[2][1 << ML];\nint imos[MN];\n\nint main() {\n\tcin >> N >> V;\n\n\tint L = 0;\n\tv[L++] = V;\n\n\twhile (V > 0) {\n\t\tV /= 2;\n\t\tv[L++] = V;\n\t}\n\n\trep(i, N) cin >> x[i];\n\n\trep(tt, 2) {\n\t\trep(j, L) {\n\t\t\ttor[tt][j][N] = N;\n\t\t\ttor[tt][j][N-1] = N-1;\n\t\t}\n\n\t\tfor (int i = N-2; i >= 0; --i) {\n\t\t\trep(j, L) {\n\t\t\t\tif (x[i+1] - x[i] <= v[j]) {\n\t\t\t\t\ttor[tt][j][i] = tor[tt][j][i+1];\n\t\t\t\t} else {\n\t\t\t\t\ttor[tt][j][i] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdp[tt][0] = 0;\n\t\trep(i, 1 << L) {\n\t\t\trep(j, L) {\n\t\t\t\tif (!((i >> j) & 1)) {\n\t\t\t\t\tdp[tt][i | (1 << j)] = max(dp[tt][i | (1 << j)], tor[tt][j][dp[tt][i]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treverse(x, x + N);\n\t\trep(i, N) x[i] *= -1;\n\t}\n\n\tint B = (1 << L) - 2;\n\n\trep(i, 1 << L) {\n\t\tif (i & 1) continue;\n\t\tint j = B ^ i;\n\t\tint l = dp[0][i], r = N - dp[1][j];\n\n\t\tif (l >= r) {\n\t\t\tputs(\"wo\");\n\t\t\timos[0]++;\n\t\t\timos[N]--;\n\t\t} else {\n\t\t\tif (tor[0][0][l] + 1 >= r) {\n\t\t\t\tint p = tor[0][0][l];\n\t\t\t\tint u = N-1-tor[1][0][N-1-p];\n\t\t\t\timos[u]++;\n\t\t\t\timos[p+1]--;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, MN-1) {\n\t\timos[i+1] += imos[i];\n\t}\n\n\trep(i, N) {\n\t\tputs(imos[i] > 0 ? \"Possible\" : \"Impossible\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*⠄⢰⣧⣼⣯⠄⣸⣠⣶⣶⣦⣾⠄⠄⠄⠄⡀⠄⢀⣿⣿⠄⠄⠄⢸⡇⠄⠄\n⠄⠄⠄⣾⣿⠿⠿⠶⠿⢿⣿⣿⣿⣿⣦⣤⣄⢀⡅⢠⣾⣛⡉⠄⠄⠄⠸⢀⣿⠄\n⠄⠄⢀⡋⣡⣴⣶⣶⡀⠄⠄⠙⢿⣿⣿⣿⣿⣿⣴⣿⣿⣿⢃⣤⣄⣀⣥⣿⣿⠄\n⠄⠄⢸⣇⠻⣿⣿⣿⣧⣀⢀⣠⡌⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⣿⣿⣿⠄\n⠄⢀⢸⣿⣷⣤⣤⣤⣬⣙⣛⢿⣿⣿⣿⣿⣿⣿⡿⣿⣿⡍⠄⠄⢀⣤⣄⠉⠋⣰\n⠄⣼⣖⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⢇⣿⣿⡷⠶⠶⢿⣿⣿⠇⢀⣤\n⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣷⣶⣥⣴⣿⡗\n⢀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄\n⢸⣿⣦⣌⣛⣻⣿⣿⣧⠙⠛⠛⡭⠅⠒⠦⠭⣭⡻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄\n⠘⣿⣿⣿⣿⣿⣿⣿⣿⡆⠄⠄⠄⠄⠄⠄⠄⠄⠹⠈⢋⣽⣿⣿⣿⣿⣵⣾⠃⠄\n⠄⠘⣿⣿⣿⣿⣿⣿⣿⣿⠄⣴⣿⣶⣄⠄⣴⣶⠄⢀⣾⣿⣿⣿⣿⣿⣿⠃⠄⠄\n⠄⠄⠈⠻⣿⣿⣿⣿⣿⣿⡄⢻⣿⣿⣿⠄⣿⣿⡀⣾⣿⣿⣿⣿⣛⠛⠁⠄⠄⠄\n⠄⠄⠄⠄⠈⠛⢿⣿⣿⣿⠁⠞⢿⣿⣿⡄⢿⣿⡇⣸⣿⣿⠿⠛⠁⠄⠄⠄⠄⠄\n⠄⠄⠄⠄⠄⠄⠄⠉⠻⣿⣿⣾⣦⡙⠻⣷⣾⣿⠃⠿⠋⠁⠄⠄⠄⠄⠄⢀⣠⣴\n⣿⣿⣿⣶⣶⣮⣥⣒⠲⢮⣝⡿⣿⣿⡆⣿⡿⠃⠄⠄⠄⠄⠄⠄⠄⣠⣴⣿*/\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ii,ll>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \" is \" << x << endl;\n\n#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nll MAX(ll a){return a;}\nll MIN(ll a){return a;}\ntemplate<typename... Args>\nll MAX(ll a,Args... args){return max(a,MAX(args...));}\ntemplate<typename... Args>\nll MIN(ll a,Args... args){return min(a,MIN(args...));}\n\n#define indexed_set tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nint n,k;\nint arr[500005];\nvector<int> v;\n\nint l[20][500005];\nint r[20][500005];\n\nint pref[500005];\nint suf[500005];\n\nint cnt[500005];\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tcin>>n>>k;\n\trep(x,0,n) cin>>arr[x];\n\t\n\tint curr=k;\n\twhile (curr){\n\t\tcurr>>=1;\n\t\tv.push_back(curr);\t\t\n\t}\n\t\n\tv.push_back(k);\n\t\n\trep(layer,0,sz(v)){\n\t\tl[layer][0]=0;\n\t\trep(x,1,n) l[layer][x]=(arr[x]-arr[x-1]<=v[layer]?l[layer][x-1]:x);\n\t\t\n\t\tr[layer][n-1]=n-1;\n\t\trep(x,n-1,0) r[layer][x]=(arr[x+1]-arr[x]<=v[layer]?r[layer][x+1]:x);\n\t}\n\t\n\trep(x,0,(1<<(sz(v)-1))){\n\t\tpref[x]=-1,suf[x]=n;\n\t\trep(bit,0,20) if (x&(1<<bit)){\n\t\t\tif (pref[x^(1<<bit)]==n-1) pref[x]=n-1;\n\t\t\telse pref[x]=max(pref[x],r[bit][pref[x^(1<<bit)]+1]);\n\t\t\tif (suf[x^(1<<bit)]==0) suf[x]=0;\n\t\t\telse suf[x]=min(suf[x],l[bit][suf[x^(1<<bit)]-1]);\n\t\t}\n\t}\n\t\n\tint bm=(1<<(sz(v)-1))-1;\n\trep(x,0,(1<<(sz(v)-1))){\n\t\t//cout<<pref[x]<<\" \"<<suf[bm^x]<<endl;\n\t\t\n\t\tint a=pref[x]+1,b=suf[bm^x]-1;\n\t\tif (a>b) cnt[0]++;\n\t\telse{\n\t\t\tif (b<=r[sz(v)-1][a]){\n\t\t\t\tcnt[l[sz(v)-1][a]]++;\n\t\t\t\tcnt[r[sz(v)-1][a]+1]--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(x,0,n){\n\t\tif (cnt[x]) cout<<\"Possible\"<<endl;\n\t\telse cout<<\"Impossible\"<<endl;\n\t\t\n\t\tcnt[x+1]+=cnt[x];\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 2e5+5;\nint n, k, V, i, a[Nmax], lg[Nmax], dp1[Nmax], go1[20][Nmax], dp2[Nmax], go2[20][Nmax], nr[Nmax];\n\nvoid compute()\n{\n    int l, i, j, ind;\n    for(l=1; l<k; ++l)\n    {\n        go1[l][n+1] = n;\n        go2[l][0] = 1;\n\n        for(i=1; i<=n; ++i)\n        {\n            for(j = i; j+1<=n && a[j+1] - a[j] <= lg[l]; ++j);\n            for(ind = i; ind <= j; ++ind)\n                go1[l][ind] = j;\n\n            i = j;\n        }\n\n        for(i=n; i; --i)\n        {\n            for(j = i; j-1>=1 && a[j] - a[j-1] <= lg[l]; --j);\n            for(ind = i; ind >= j; --ind)\n                go2[l][ind] = j;\n\n            i = j;\n        }\n    }\n}\n\nvoid dinamique()\n{\n    int i, j;\n    dp1[0] = 0, dp2[0] = n+1;\n    for(i=2; i<(1<<k); i+=2)\n    {\n        dp1[i] = 1;\n        dp2[i] = n;\n\n        for(j=1; j<k; ++j)\n            if(i&(1<<j))\n            {\n                dp1[i] = max(dp1[i], go1[j][ dp1[i^(1<<j)] + 1 ]);\n                dp2[i] = min(dp2[i], go2[j][ dp2[i^(1<<j)] - 1 ]);\n            }\n    }\n}\n\nvoid solve()\n{\n    int i, j, ind, mask = (1<<k) - 2;\n    bool ok;\n\n    for(i=0; i<=n+1; ++i) nr[i] = -1;\n\n    for(i=0; i<=mask; i+=2)\n        nr[dp2[i]] = max(nr[dp2[i]], dp1[mask^i]);\n\n    for(i=1; i<=n+1; ++i)\n        nr[i] = max(nr[i], nr[i-1]);\n\n    for(i=1; i<=n; ++i)\n    {\n        for(j = i; j+1<=n && a[j+1] - a[j] <= V; ++j);\n        ok = (nr[j+1] >= i-1);\n\n        for(ind = i; ind <= j; ++ind)\n            printf(\"%s\\n\", ok ? \"Possible\" : \"Impossible\");\n\n        i = j;\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &V);\n    for(i=1; i<=n; ++i) scanf(\"%d\", &a[i]);\n\n    lg[0] = V;\n    for(i=1; lg[i-1]; ++i) lg[i] = lg[i-1]/2;\n    k = i;\n\n    compute();\n    dinamique();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || '9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch && ch<='9')x=x*10+(ch^48),ch=getchar();\n\treturn x*f;\n}\n\ninline void chkmax(int &a,int b){if(a<b)a=b;}\ninline void chkmin(int &a,int b){if(a>b)a=b;}\n\n#define guo cerr<<\"guo\"<<endl\nconst int N=2e5+9;\nconst int K=22;\nconst int M=1<<K;\n\nint n,m,v;\nint x[N];\nint vs[K],vtop;\nint pre[K][N],suf[K][N];\nint pr[M],su[M],mp[M];\n\nint main()\n{\n\tif(fopen(\"vj.in\",\"r\"))\n\t{\n\t\tfreopen(\"vj.in\",\"r\",stdin);\n\t\tfreopen(\"vj.out\",\"w\",stdout);\n\t}\n\n\tn=read();v=read();\n\tfor(int i=1;i<=n;i++)\n\t\tx[i]=read();\n\tfor(int a=v>>1;vs[vtop++]=a;a>>=1);\n\tm=1<<vtop;vs[vtop]=v;\n\n\tfor(int k=0;k<=vtop;k++)\n\t{\n\t\tpre[k][0]=0,suf[k][n+1]=n+1;\n\t\tfor(int i=1,j=1;i<=n;i=j+1)\n\t\t{\n\t\t\tfor(j=i;j+1<=n && x[j+1]-x[j]<=vs[k];j++);\n\t\t\tfor(int l=i;l<=j;l++)\n\t\t\t\tpre[k][l]=i,suf[k][l]=j;\n\t\t}\n\t}\n\n\tfor(int i=0;i<m;i++)\n\t\tsu[i]=n+1;\n\tfor(int i=1;i<m;i++)\n\t\tfor(int j=0;j<vtop;j++)\n\t\t\tif(i&(1<<j))\n\t\t\t{\n\t\t\t\tchkmin(su[i],pre[j][su[i^(1<<j)]-1]);\n\t\t\t\tchkmax(pr[i],suf[j][pr[i^(1<<j)]+1]);\n\t\t\t}\n\n\tfor(int i=0;i<m;i++)\n\t\tchkmax(mp[su[m-1-i]-1],pr[i]+1);\n\tfor(int i=0;i<=n;i++)\n\t\tchkmax(mp[i+1],mp[i]);\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(mp[suf[vtop][i]]>=pre[vtop][i])\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n\t}\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f, N = 2e5 + 6, S = (1 << 20) + 5;\ninline int read() {\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(!(ch >= '0' && ch <= '9')) {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}\n\treturn x * f;\n}\nint a[N], L[20][N], R[20][N], l[N<<4], r[N<<4];\npair <int, int> s[N];\nbool an[N];\nint main() {\n\tint n = read(), m = read(), d;\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\ta[0] = -INF - m - 1, a[n+1] = INF + m + 1;\n\tfor(int i = m; ~i; i >>= 1, d++) {\n\t\tR[d][n+1] = n+1;\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tL[d][j] = a[j] - a[j-1] <= i ? L[d][j-1] : j;\n\t\tfor(int j = n; j; j--)\n\t\t\tR[d][j] = a[j+1] - a[j] <= i ? R[d][j+1] : j;\n\t\tif(!i) {d++; break;}\n\t}\n\tfor(int i = 1; i <= n; i++) s[i] = make_pair(L[0][i], R[0][i]);\n\tint cnt = unique(s + 1, s + 1 + n) - s - 1;\n\tfor(int i = 0; i < 1 << d; i++) r[i] = n + 1;\n\tfor(int i = 0; i < 1 << d; i += 2)\n\t\tfor(int j = 0; j < d; j++)\n\t\t\tif(i & 1 << j)\n\t\t\t\tl[i] = max(l[i], R[j][l[i^(1<<j)]+1]),\n\t\t\t\tr[i] = min(r[i], L[j][r[i^(1<<j)]-1]);\n\tif(cnt <= d) for(int i = 1; i <= cnt; i++)\n\t\tfor(int j = 0; j < 1 << d; j += 2)\n\t\t\tif(l[j] >= s[i].first - 1 && r[(1<<d)-j-2] <= s[i].second + 1) {\n\t\t\t\tfor(int j = s[i].first; j <= s[i].second; j++) an[j] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tputs(an[i] ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1009LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> ii;\ntypedef pair<ii, ii> i4;\n \nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n\n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nconst int N = 200005;\nint n, arr[N], sz, V, next_right[20][N], next_left[20][N];\nint DP_left[1<<20], DP_right[1<<20];\nvector<int> steps;\n\nint dp_left(int mask){\n    int &ans = DP_left[mask];\n    if(ans != -1)   return ans;\n    ans = 1;\n    for(int i=0;i<sz;i++)\n        if((mask >> i) & 1)\n            ans = max(ans, next_right[i][dp_left(mask^(1<<i))+1]);\n    return ans;\n}\n\nint dp_right(int mask){\n    int &ans = DP_right[mask];\n    if(ans != -1)   return ans;\n    ans = n+1;\n    for(int i=0;i<sz;i++)\n        if((mask >> i) & 1)\n            ans = min(ans, next_left[i][dp_right(mask^(1<<i))-1]);\n    return ans;\n}\n\n\n\nbool possible(int l, int r){\n    int mask = (1<<sz)-2; \n    for(int i=mask;i>=0;i=(i-1)&mask){\n// cout<<i<<\" \"<<(mask^i)<<\" \"<<mask<<\" \"<<dp_left(i)<<\" \"<<dp_right(mask^i)<<endl;\n        if(dp_left(i) >= l-1 && dp_right(mask^i) <= r+1)    return true;\n        if(i == 0)  break;\n    }\n    return false;\n}\n\n\nint main(){\n \n    // ios_base::sync_with_stdio(0);\n    // cin.tie(0);\n\n    scanf(\"%d%d\", &n, &V);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\", &arr[i]);\n\n    while(V){\n        steps.pb(V);\n        V /= 2;\n    }\n    steps.pb(0);\n    sz = (int)steps.size();\n\n    for(int k=0;k<sz;k++){\n\n        next_right[k][n+1] = n+1;\n        next_right[k][n] = n;\n        for(int i=n-1;i>=1;i--)\n            if(arr[i+1]-arr[i] <= steps[k])\n                next_right[k][i] = next_right[k][i+1];\n            else\n                next_right[k][i] = i;\n\n        next_left[k][0] = 0;\n        next_left[k][1] = 1;\n        for(int i=2;i<=n;i++)\n            if(arr[i]-arr[i-1] <= steps[k])\n                next_left[k][i] = next_left[k][i-1];\n            else\n                next_left[k][i] = i;\n    }\n\n    int comps = 0, curr = 1;\n    while(curr <= n){\n        comps++;\n        curr = next_right[0][curr] + 1;\n    }\n\n    if(comps > sz){\n        for(int i=1;i<=n;i++)\n            printf(\"Impossible\\n\");\n        return 0;\n    }\n\n// cout<<\"steps: \";for(auto it : steps)    cout<<it<<\" \";cout<<endl;\n// cout<<\"next_right:\\n\";\n// for(int i=1;i<=n;i++){\n//     cout<<i<<\": \";for(int j=0;j<sz;j++) cout<<next_right[j][i]<<\" \";cout<<endl;\n// }cout<<endl;\n// cout<<\"next_left:\\n\";\n// for(int i=1;i<=n;i++){\n//     cout<<i<<\": \";for(int j=0;j<sz;j++) cout<<next_left[j][i]<<\" \";cout<<endl;\n// }cout<<endl;\n\n\n    memset(DP_left, -1, sizeof(DP_left));\n    memset(DP_right, -1, sizeof(DP_right));\n    curr = 1;\n    while(curr <= n){\n        if(possible(curr, next_right[0][curr])){\n            for(int i=curr;i<=next_right[0][curr];i++)\n                printf(\"Possible\\n\");\n        }\n        else{\n            for(int i=curr;i<=next_right[0][curr];i++)\n                printf(\"Impossible\\n\");\n        }\n        curr = next_right[0][curr]+1;\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 200010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;if(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\n\nint b[40],sz,a[N],c[N];\nint dp[1<<18],f[1<<18],l[N][20],r[N][20];\nint main(){\n    //freopen(\"A.in\",\"r\",stdin);\n    //freopen(\"A.out\",\"w\",stdout);\n    //cout<<setprecision(9)<<fixed;\n    //cerr<<setprecision(9)<<fixed;\n    int T,i,j,k,ca=0,m,K,n;\n    scanf(\"%d%d\",&n,&m);\n    K=m;sz=0;\n    while(K)b[sz++]=K,K>>=1;\n    b[sz++]=0;\n    swap(b[0],b[sz-1]);\n    rep(i,0,n)scanf(\"%d\",&a[i]);\n    rep(k,0,sz){\n        K=b[k];\n        //cerr<<k<<\" \"<<K<<\"\\n\";\n        l[0][k]=0;\n        rep(i,1,n){\n            if(K>=a[i]-a[i-1])l[i][k]=l[i-1][k];\n            else l[i][k]=i;\n        }\n        r[n-1][k]=n-1;\n        per(i,0,n-1){\n            if(K>=a[i+1]-a[i])r[i][k]=r[i+1][k];\n            else r[i][k]=i;\n        }\n    }\n    sz--;\n    memset(dp,-1,sizeof(dp));\n    dp[0]=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Max(dp[i|1<<j],x);\n            if(x+1<n)Max(dp[i|1<<j],r[x+1][j]);\n        }\n    }\n    per(i,0,(1<<sz))f[i]=n;\n    f[0]=n-1;\n    rep(i,0,(1<<sz)){\n        int x=f[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Min(f[i|1<<j],x);\n            if(x)Min(f[i|1<<j],l[x-1][j]);\n        }\n    }\n    int mask=(1<<sz)-1,flag=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i],y=f[mask^i];\n        if(x<0||y>=n)continue;\n        k=r[x+1][sz];\n        j=l[y-1][sz];\n        if(j<=x+1&&k>=y-1)c[j]++,c[k+1]--;\n    }\n    {\n        rep(i,1,n)c[i]+=c[i-1];\n        rep(i,0,n){\n            if(c[i])puts(\"Possible\");\n            else puts(\"Impossible\");\n        }\n    }\n    /*\n    rep(i,0,n)if(i==n-5){\n        int x=l[i][sz],y=r[i][sz],ok=0;\n        cerr<<i<<\" \"<<x<<\" \"<<y<<\"\\n\";\n        rep(j,0,(1<<sz)){\n            k=mask^j;\n            cerr<<j<<\" \"<<dp[j]<<\",\"<<k<<\" \"<<f[k]<<\"\\n\";\n            if(dp[j]>=x-1&&f[k]<=y+1){ok=1;break;}\n        }\n        puts(ok?\"Y\":\"N\");\n    }//*/\n    //cerr<<clock()*1./CLOCKS_PER_SEC<<\"ms\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 2e5 + 10;\n\nint n, v, m, ans[N];\nint a[N], b[N], L[N][20], R[N][20], f[N], g[N];\n\nint main()\n{\n    n = read(), v = read();\n    for (int i = 1; i <= n; i++) a[i] = read();\n    b[0] = v;\n    for (int i = 1; i <= 50; i++) b[i] = b[i - 1] >> 1;\n    for (int i = 0; b[i]; i++) m = i;\n    m += 2;\n    for (int i = 0; i < m; i++)\n        for (int j = 1; j <= n; )\n        {\n            int k;\n            for (k = j + 1; k <= n; k++)\n                if (a[k] - a[k - 1] > b[i])\n                    break;\n            for (int l = j; l < k; l++)\n                L[l][i] = j, R[l][i] = k - 1;\n            j = k;\n        }\n    for (int i = 0; i < (1 << m); i++) g[i] = n + 1;\n    for (int i = 0; i < (1 << m); i++)\n        for (int j = 0; j < m; j++)\n            if (!(i >> j & 1))\n            {\n                f[i | (1 << j)] = max(f[i | (1 << j)], R[f[i] + 1][j]);\n                g[i | (1 << j)] = min(g[i | (1 << j)], L[g[i] - 1][j]);\n            }\n    int S = (1 << m) - 2;\n    for (int i = 0; i < (1 << m); i++)\n        if (i % 2 == 0)\n        {\n            int j = S - i;\n            if (R[f[i] + 1][0] >= g[j] - 1)\n            {\n                if (f[i] + 1 > g[j] - 1)\n                    ans[1]++;\n                else\n                {\n                    int p = L[f[i] + 1][0], q = R[f[i] + 1][0];\n                    ans[p]++;\n                    ans[q + 1]--;\n                }\n            }\n        }\n    for (int i = 1; i <= n; i++) ans[i] += ans[i - 1];\n    for (int i = 1; i <= n; i++)\n        puts(ans[i] ? \"Possible\" : \"Impossible\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 524289;\nint n, V, xs[MAXN];\nint ls[MAXN], rs[MAXN], bak;\nint L[32][MAXN], R[32][MAXN];\nint pre[MAXN], suc[MAXN];\nvoid getmax(int & x, int y) { x < y ? x = y : 0; }\nvoid getmin(int & x, int y) { x > y ? x = y : 0; }\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> V;\n\tfor (int i = 1; i <= n; ++i) std::cin >> xs[i];\n\tint T = 0;\n\tfor (; ; ++T, V >>= 1) {\n\t\tint lst = 1;\n\t\tfor (int i = 2; i <= n + 1; ++i)\n\t\t\tif (xs[i] - xs[i - 1] > V || i == n + 1) {\n\t\t\t\tint l = lst, r = i - 1;\n\t\t\t\tif (!T) ls[++bak] = l, rs[bak] = r;\n\t\t\t\telse for (int j = l; j <= r; ++j)\n\t\t\t\t\tL[T - 1][j] = l, R[T - 1][j] = r;\n\t\t\t\tlst = i;\n\t\t\t}\n\t\tif (!V) break;\n\t}\n\tconst int U = 1 << T;\n\tfor (int i = 0; i != U; ++i) suc[i] = n + 1;\n\tfor (int i = 0; i != U; ++i)\n\t\tfor (int j = 0; j != T; ++j)\n\t\t\tif (~i >> j & 1) {\n\t\t\t\tgetmax(pre[i | 1 << j], R[j][pre[i] + 1]);\n\t\t\t\tgetmin(suc[i | 1 << j], L[j][suc[i] - 1]);\n\t\t\t}\n\tfor (int i = 1; i <= bak; ++i) {\n\t\tbool can = false;\n\t\tif (bak <= 40) {\n\t\t\tfor (int j = 0; j != U; ++j)\n\t\t\t\tif (pre[j] >= ls[i] - 1 && suc[U - j - 1] <= rs[i] + 1) {\n\t\t\t\t\tcan = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tfor (int j = ls[i]; j <= rs[i]; ++j)\n\t\t\tstd::cout << (can ? \"Possible\\n\" : \"Impossible\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// '\n#include <bits/stdc++.h>\n#include <bits/extc++.h>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef unsigned short sint;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> pt;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nconst ld TAU=2*acos(-1);\nconst ld eps=1e-8;\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\n\nint n,v;\nint vv[20],m;\nint x[200<<10];\nint ps[20][200<<10]; // TODO\nint jj[20][200<<10]; // TODO\nbool flag[200<<10];\n\nmap<pair<int,int>,bool> dp[1<<18];\nbool go(int L,int R,int mk) {\n\tif(L==R) return 1;\n\tif(!mk) return 0;\n\tif(dp[mk].count({L,R})) return dp[mk][{L,R}];\n\tbool &ans=dp[mk][{L,R}];\n\tans=0;\n\tint e=0;\n\tfor(;(1<<e)<=mk;) ++e;\n\t--e;\n\tint pc=__builtin_popcount(mk);\n\tif(ps[e][R-1]-(L?ps[e][L-1]:0) > pc) return ans=0;\n\n\tmk&=~(1<<e);\n\tfor(int M=L;M!=R;M=jj[e][M]) {\n\t\tfor(int nk=0;nk<=mk;nk++) {\n\t\t\tif((mk&nk)!=nk) continue;\n\t\t\tif(go(L,M,nk) && go(jj[e][M],R,mk&~nk)) {\n\t\t\t\tans=1;\n\t\t\t\tif(L || R<n) return 1;\n\t\t\t\telse {\n\t\t\t\t\tfor(int i=L;i<R;i++) flag[i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nvoid genjj() {\n\tfor(int e=0;e<m;e++) {\n\t\tfor(int i=n;--i>=0;) {\n\t\t\tif(x[i+1]-x[i] <= vv[e]) jj[e][i]=jj[e][i+1];\n\t\t\telse jj[e][i]=i+1;\n\t\t}\n\t\tvector<int> v;\n\t\tfor(int i=0;i<n;i=jj[e][i]) {\n\t\t\tv.pb(i);\n\t\t}\n\t\tfor(int x:v) ps[e][x]=1;\n\t\tpartial_sum(ps[e],ps[e]+n,ps[e]);\n\t}\n}\n\n\nint32_t main() {\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",x+i);\n\tx[n]=inf+inf;\n\t{\n\t\tm=v;\n\t\tvector<int> vd;\n\t\tfor(;m;) vd.pb(m), m>>=1;\n\t\treverse(vd.begin(),vd.end());\n\t\tm=(int)vd.size();\n\t\tfor(int i=0;i<m;i++) vv[i]=vd[i];\n\t}\n\tgenjj();\n\tfor(int i=0;i<m;i++) cerr<<vv[i]<<endl;\n\tgo(0,n,(1<<m)-1);\n\tfor(int i=0;i<n;i++) printf(flag[i]?\"P\":\"Imp\"), printf(\"ossible\\n\");\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint x[252521];\nint ne[252521][20],rne[252521][20];\nint dp[(1<<20)+10],rdp[(1<<20)+10];\nvector<int> v;\nint main()\n{\n\tint n,V;\n\tcin>>n>>V;\n\trep(i,n) cin>>x[i];\n\twhile(V>0){\n\t\tv.pb(V);V/=2;\n\t}\n\tv.pb(0);int m=v.size();\n\trep(i,n) rep(j,m){\n\t\trne[i][j]=i;\n\t\tif(i>0 && x[i]-x[i-1]<=v[j]) rne[i][j]=rne[i-1][j];\n\t}\n\tfor(int i=n-1;i>=0;i--) rep(j,m){\n\t\tne[i][j]=i;\n\t\tif(i<n-1 && x[i+1]-x[i]<=v[j]) ne[i][j]=ne[i+1][j];\n\t}\n\tmemset(dp,0,sizeof(dp));\n\trep(i,(1<<20)+5) rdp[i]=n-1;\n\trep(i,(1<<m)) rep(j,m){\n\t\tif((i&(1<<j))>0) continue;\n\t\tdp[i+(1<<j)]=max(dp[i+(1<<j)],ne[dp[i]][j]+1);\n\t\trdp[i+(1<<j)]=min(rdp[i+(1<<j)],rne[rdp[i]][j]-1);\n\t}\n\t//rep(i,(1<<m)) cout<<i<<' '<<dp[i]<<' '<<rdp[i]<<endl;\n\tif(dp[(1<<m)-1]<n || rdp[(1<<m)-1]>=0){\n\t\tassert(dp[(1<<m)-1]<n && rdp[(1<<m)-1]>=0);\n\t\trep(i,n) cout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tint now=0;\n\twhile(now<n){\n\t\tint f=0;\n\t\trep(i,(1<<(m-1))){\n\t\t\tif(dp[(1<<m)-2-(i<<1)]>=now && rdp[(i<<1)]<=ne[now][0]) f=1;\n\t\t}\n\t\tREP(i,now,ne[now][0]+1){\n\t\t\tif(f>0) cout<<\"Possible\"<<endl;\n\t\t\telse cout<<\"Impossible\"<<endl;\n\t\t}\n\t\tnow=ne[now][0]+1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, V;\nint X[200011];\n\n\nVI vs;\nint m;\n\nVI G[200011];\nvoid calc(int dp[1<<20]) {\n    G[0].push_back(0);\n    REP (i, N) while (!G[i].empty()) {\n\tint s = G[i].back(); G[i].pop_back();\n\tif (dp[s] != i) continue;\n\n\tREP (j, m) if (~s>>j&1) {\n\t    int right = -1;\n\t    if (i == 0 || X[i]-X[i-1] > vs[j]) {\n\t\tright = i+1;\n\t\twhile (right < N && X[right]-X[right-1] <= vs[j]) right++;\n\t    } else {\n\t\tcontinue;\n\t    }\n\t    if (dp[s|(1<<j)] < right) {\n\t\tdp[s|(1<<j)] = right;\n\t\tG[right].push_back(s|(1<<j));\n\t    }\n\t}\n    }\n//    rprintf(\"%d\", dp, dp+(1<<m));\n}\nint L[1<<20], R[1<<20];\n\nint Z[200011];\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &V);\n    REP (i, N) scanf(\"%d\", X+i);\n    m = V;\n    while (1) {\n\tvs.push_back(m);\n\tif (m == 0) break;\n\tm/=2;\n    }\n    m = vs.size();\n\n    calc(L);\n    reverse(X, X+N);\n    REP (i, N) X[i] = -X[i];\n    calc(R);\n    reverse(X, X+N);\n    REP (i, N) X[i] = -X[i];\n\n    memset(Z, 0xc0, sizeof Z);\n    REP (s, 1<<m) if (~s&1) {\n\tint t = ((1<<m)-1) ^ s ^ 1;\n\tamax(Z[N-R[t]], L[s]);\n    }\n\n    int ma = Z[0];\n    for (int i=0; i<N; ) {\n\tint j = i;\n\twhile (j < N && (j == i || X[j] - X[j-1] <= V)) {\n\t    j++;\n\t    amax(ma, Z[j]);\n\t}\n\n\tfor (int k=i; k<j; k++) {\n\t    puts(i<=ma? \"Possible\": \"Impossible\");\n\t}\n\t//eprintf(\"%d\\n\", ma);\n\ti = j;\n    }\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 200000\n#define f first\n#define s second\n#define pb push_back\n#define rep(i,a,b) for(i=a;i<=b;i++)\n\nbool bis[maxn+5];\nint bakom,n,v;\nvector<int> vev,vip,sem;\nint x[maxn+5];\nint par[maxn+5];\nint val[maxn+5];\n\nint fp(int mas){\n\tif(mas==par[mas]){\n\t\treturn mas;\n\t}\n\treturn par[mas]=fp(par[mas]);\n}\n\nvoid gabung(int a,int b,int vat){\n\tint aa=fp(a);\n\tint bb=fp(b);\n\tif(aa==bb){\n\t\treturn;\n\t}\n\tbakom--;\n\tassert(b==bb);\n\tpar[bb]=par[aa];\n\tval[bb]=-1;\n\tval[aa]=vat;\n}\n\nvoid gakbisa_semua(){\n\tint i;\n\trep(i,1,n){\n\t\tcout<<\"TIDAK\\n\";\n\t}\n\treturn;\n}\n\nint main(){\n\tint i,j;\n\tcin>>n>>v;\n\trep(i,1,n){\n\t\tcin>>x[i];\n\t}\n\tstack<int> tum;\n\twhile(v>0){\n\t\ttum.push(v);\n\t\tv>>=1;\n\t}\n\tvev.pb(0);\n\twhile(!tum.empty()){\n\t\tvev.pb(tum.top());\n\t\ttum.pop();\n\t}\n\trep(i,1,n){\n\t\tpar[i]=i;\n\t}\n\tbakom=n;\n\trep(i,1,(int)vev.size()-1){\n\t\trep(j,2,n){\n\t\t\tif(x[j]-x[j-1]<=vev[i]){\n\t\t\t\tgabung(j-1,j,min(i,max(val[fp(j-1)],val[fp(j)])+1));\n\t\t\t}\n\t\t}\n\t}\n\tint telemax=vev.size()-1;\n\tif(bakom > telemax+1){\n\t\tgakbisa_semua();\n\t\treturn 0;\n\t}\n\trep(i,1,n){\n\t\tif(val[i]!=-1){\n\t\t\tvip.pb(i);\n//\t\t\tcout<<i<<\" \"<<val[fp(i)]<<\"\\n\";\n\t\t}\n\t}\n\trep(i,0,(int)vip.size()-1){\n\t\tsem.pb(val[vip[i]]);\n\t}\n\tsort(sem.begin(),sem.end());\n\tint kur;\n\trep(i,0,(int)vip.size()-1){\n\t\tbis[vip[i]]=1;\n\t\tkur=0;\n\t\trep(j,0,(int)sem.size()-1){\n\t\t\tif(kur==0 && val[vip[i]]==sem[j]){\n\t\t\t\tkur=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(j-kur+telemax-bakom+1 < sem[j]){\n\t\t\t\t\tbis[vip[i]]=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\tif(bis[fp(i)]){\n\t\t\tcout<<\"YA\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"TIDAK\\n\";\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N, V;\nint M, SM;\n\nint T[21][MAX_N];\nint nex[21][MAX_N];\n\nint dp[MAX_N], rdp[MAX_N];\nint ok[MAX_N];\n\nvector<int> v;\nll A[MAX_N];\n\nvoid pre(int dp[MAX_N]) {\n\trep(i, 0, M) {\n\t\trep(j, 0, N - 1) {\n\t\t\tT[0][j] = (abs(A[j + 1] - A[j]) > v[i]) ? j : (j + 1);\n\t\t}\n\t\tT[0][N - 1] = N - 1;\n\t\trep(q, 0, 20) {\n\t\t\trep(j, 0, N) {\n\t\t\t\tT[q + 1][j] = T[q][T[q][j]];\n\t\t\t}\n\t\t}\n\t\trep(j, 0, N) {\n\t\t\tnex[i][j] = T[20][j];\n\t\t}\n\t}\n\trep(bit, 0, (1 << SM)) {\n\t\tif(dp[bit] == N - 1) continue;\n\t\trep(i, 0, N) {\n\t\t\tif(bit & (1 << i)) continue;\n\t\t\tMAX(dp[bit | (1 << i)], nex[i][dp[bit] + 1]);\n\t\t}\n\t}\n\trep(bit, 0, (1 << SM)) {\n\t\tif(dp[bit] == N - 1) continue;\n\t\tdp[bit] = nex[SM][dp[bit] + 1];\n\t}\n}\n\nvoid solve() {\n\tcin >> N >> V;\n\trep(i, 0, N) cin >> A[i];\n\twhile(V >= 1) {\n\t\tv.pb(V);\n\t\tV /= 2;\n\t}\n\tv.pb(0);\n\tM = sz(v);\n\tSM = M - 1;\n\n\treverse(all(v));\n\t\n\tpre(dp);\n\n\treverse(A, A + N);\n\tpre(rdp);\n\n\trep(bit, 0, (1 << SM)) rdp[bit] = N - 1 - rdp[bit];\n\n\trep(bit, 0, (1 << SM)) {\n\t\tint rbit = (1 << SM) - 1 - bit;\n\t\tint l = dp[bit], r = rdp[rbit];\n\t\tl++;\n\t\tif(l > r) {\n\t\t\tok[l]--;\n\t\t\tok[r]++;\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\tok[i + 1] += ok[i];\n\t\tif(ok[i]) cout << \"Possible\\n\";\n\t\telse cout << \"Impossible\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a,b) memset(a,b,sizeof a)\n#define mcpy(a,b) memcpy(a,b,sizeof b)\n#define lb(x) ((x)&(-(x)))\n#define xx first\n#define yy second\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define pii pair<int,int> \n#define inf 0x3f3f3f3f\n#define N 262145\n#define M 20\nusing namespace std;\ntypedef long long ll;\nint n,m,V,a[N],l[N][M],r[N][M],f[N],g[N];\nbool ans[N];\nint main(){\n\tcin>>n>>V;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int x=V;;x>>=1){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(i==1||a[i]-a[i-1]>x)l[i][m]=i;\n\t\t\telse l[i][m]=l[i-1][m];\n\t\tfor(int i=n;i;i--)\n\t\t\tif(i==n||a[i+1]-a[i]>x)r[i][m]=i;\n\t\t\telse r[i][m]=r[i+1][m];\n\t\tif(x)m++;\n\t\telse break;\n\t}\n\tfor(int i=0;i<(1<<m);i++)for(int j=0;j<m;j++)if(!(i>>j&1))\n\t\tf[i|(1<<j)]=max(f[i|(1<<j)],f[i]==n?n:r[f[i]+1][j+1]);\n\tfor(int i=0;i<(1<<m);i++)g[i]=inf;\n\tg[0]=n+1;\n\tfor(int i=0;i<(1<<m);i++)for(int j=0;j<m;j++)if(!(i>>j&1))\n\t\tg[i|(1<<j)]=min(g[i|(1<<j)],g[i]==1?1:l[g[i]-1][j+1]);\n//\tcout<<g[1]<<endl;\n\tfor(int i=0;i<(1<<m);i++){\n\t\tint L=f[i],R=g[i^(1<<m)-1];\n//\t\tcout<<L<<\" \"<<R<<endl;\n\t\tif(L+1>=R){\n\t\t\tfor(int j=1;j<=n;j++)ans[j]=1;\n\t\t\tbreak;\n\t\t}\n//\t\tcout<<L+1<<\" \"<<r[L+1][0]+1<<\" \"<<R<<endl;\n\t\tif(r[L+1][0]+1>=R&&!ans[L+1]){\n//\t\t\tcout<<l[0][L]<<\" \"<<r[0][L]<<endl;\n\t\t\tfor(int j=l[L+1][0];j<=r[L+1][0];j++)ans[j]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)puts(ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MN = 100010;\nconst int ML = 18;\n\nint N, V;\nint v[ML];\nint x[MN];\nint tor[2][ML][MN];\nint dp[2][1 << ML];\nint imos[MN];\n\nint main() {\n\tcin >> N >> V;\n\n\tint L = 0;\n\tv[L++] = V;\n\n\twhile (V > 0) {\n\t\tV /= 2;\n\t\tv[L++] = V;\n\t}\n\n\trep(i, N) cin >> x[i];\n\n\trep(tt, 2) {\n\t\trep(j, L) {\n\t\t\ttor[tt][j][N] = N;\n\t\t\ttor[tt][j][N-1] = N-1;\n\t\t}\n\n\t\tfor (int i = N-2; i >= 0; --i) {\n\t\t\trep(j, L) {\n\t\t\t\tif (x[i+1] - x[i] <= v[j]) {\n\t\t\t\t\ttor[tt][j][i] = tor[tt][j][i+1];\n\t\t\t\t} else {\n\t\t\t\t\ttor[tt][j][i] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdp[tt][0] = 0;\n\t\trep(i, 1 << L) {\n\t\t\trep(j, L) {\n\t\t\t\tif (!((i >> j) & 1)) {\n\t\t\t\t\tdp[tt][i | (1 << j)] = max(dp[tt][i | (1 << j)], tor[tt][j][dp[tt][i]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treverse(x, x + N);\n\t\trep(i, N) x[i] *= -1;\n\t}\n\n\tint B = (1 << L) - 2;\n\n\trep(i, 1 << L) {\n\t\tif (i & 1) continue;\n\t\tint j = B ^ i;\n\t\tint l = dp[0][i], r = N - dp[1][j];\n\n\t\tif (l >= r) {\n\t\t\tputs(\"wo\");\n\t\t\timos[0]++;\n\t\t\timos[N]--;\n\t\t} else {\n\t\t\tif (tor[0][0][l] + 1 >= r) {\n\t\t\t\tint p = tor[0][0][l];\n\t\t\t\tint u = N-1-tor[1][0][N-1-p];\n\t\t\t\timos[u]++;\n\t\t\t\timos[p+1]--;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, MN-1) {\n\t\timos[i+1] += imos[i];\n\t}\n\n\trep(i, N) {\n\t\tputs(imos[i] > 0 ? \"Possible\" : \"Impossible\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t200005\n#define MAXLOG\t20\nint n, k, v[MAXLOG], x[MAXN];\nint l[MAXLOG][MAXN], r[MAXLOG][MAXN];\nint lft[MAXN], rit[MAXN], opt[MAXN];\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint main() {\n\tread(n), read(v[0]);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(x[i]);\n\tfor (k = 1; v[k - 1] != 0; k++)\n\t\tv[k] = v[k - 1] / 2;\n\tk -= 1; int goal = (1 << k) - 1;\n\tfor (int j = 0; j <= k; j++) {\n\t\tl[j][1] = 1;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t\tif (x[i] - x[i - 1] <= v[j]) l[j][i] = l[j][i - 1];\n\t\t\telse l[j][i] = i;\n\t}\n\tfor (int j = 0; j <= k; j++) {\n\t\tr[j][n] = n;\n\t\tfor (int i = n - 1; i >= 1; i--)\n\t\t\tif (x[i + 1] - x[i] <= v[j]) r[j][i] = r[j][i + 1];\n\t\t\telse r[j][i] = i;\n\t}\n\tfor (int curr = 0; curr <= goal; curr++) {\n\t\tlft[curr] = 0;\n\t\trit[curr] = n + 1;\n\t}\n\tfor (int curr = 0; curr < goal; curr++)\n\tfor (int i = 1, j = 1; i <= k; i++, j <<= 1) {\n\t\tif (curr & j) continue;\n\t\tint dest = curr | j;\n\t\tlft[dest] = max(lft[dest], min(r[i][lft[curr] + 1], n));\n\t\trit[dest] = min(rit[dest], max(l[i][rit[curr] - 1], 1));\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\topt[i] = n + 2;\n\tfor (int curr = 0; curr <= goal; curr++)\n\t\topt[lft[curr]] = min(rit[goal ^ curr], opt[lft[curr]]);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\topt[i] = min(opt[i], opt[i + 1]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint lft = l[0][i];\n\t\tint rit = r[0][i];\n\t\tif (opt[lft - 1] <= rit + 1) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<lint,lint> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\nconst lint INF=1e18;\n\n\nstruct max_handler_with_index{\n  typedef pi node;\n  max_handler_with_index(){}\n  static node def_node() { return mp(-INF,-INF);}\n  static node merge(const node& a,const node& b){\n    return max(a,b);\n  }\n};\n\nint nsum[35];\nint n,V,K,m;\n\nint dp[1<<20];\nint ar[200005],dif[200005];\n\nint d2[20];\nint nxt[20][200005];\npi range[200005];\n\n\nint br[200005],n2;\nbool solve(){\n  REP(i,n2-1) dif[i]=br[i+1]-br[i];\n\n  REP(i,K){\n    for(int j=n2-1;j>=0;--j){\n      if(j==n2-1) nxt[i][j]=n2;\n      else if(dif[j]<=d2[i]) nxt[i][j]=nxt[i][j+1];\n      else nxt[i][j]=j+1;\n    }\n  }\n  memset(dp,-1,sizeof(dp));\n  dp[0]=0;\n  REP(bit,1<<K) if(dp[bit]>=0){\n    if(dp[bit]>=n2) return true;\n    REP(i,K) if(!(bit>>i&1)){\n      chmax(dp[bit|(1<<i)],nxt[i][dp[bit]]);\n    }\n  }\n  return false;\n}\nint main(){\n  cin>>n>>V;\n  d2[0]=V;\n  K=19;\n  REP(i,K) d2[i+1]=d2[i]/2;\n  while(d2[K-1]==0) --K;\n  assert(d2[K-1]==1);\n  ++K;\n  reverse(d2,d2+K);\n  --K;\n  REP(i,n) scanf(\"%d\",&ar[i]);\n\n\n  REP(i,n){\n    int l=i,r=i;\n    while(r<n-1 && ar[r+1]-ar[r]<=V){\n      ++r;\n    }\n    range[m++]={l,r};\n    i=r;\n  }\n  if(m>=20){\n    REP(i,n) puts(\"Impossible\");\n    return 0;\n  }\n\n\n  REP(i,m){\n    n2=0;\n    REP(j,n) if(j<range[i].fr || range[i].sc<j) br[n2++]=ar[j];\n\n    int len=range[i].sc-range[i].fr+1;\n    bool res=solve();\n    REP(hoge,len) puts(res?\"Possible\":\"Impossible\");\n  }\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ld, ld> pdd;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define fastIO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\nconst int N = (int)2e5 + 9;\nconst int K = 20;\n\nint dpL[1 << K];\nint dpR[1 << K];\nint x[N];\n\nint pl[K][N];\nint pr[K][N];\n\nint cnt[N];\n\nvoid update(int cl, int cr){\n    cnt[cl] ++ ;\n    cnt[cr + 1] -- ;\n}\n\nint main(){\n    fastIO;\n    int n, k;\n    cin >> n >> k;\n    for(int i = 1; i <= n; i ++ ){\n        cin >> x[i];\n    }\n    vector<int> vl;\n    while(k > 0){\n        vl.push_back(k);\n        k /= 2;\n    }\n    vl.push_back(0);\n    reverse(vl.begin(), vl.end());\n    int m = vl.size();\n    int z = (1 << m);\n    for(int i = 0 ; i < m ; i ++ ){\n        pl[i][1] = 1;\n        for(int j = 2; j <= n; j ++ ){\n            pl[i][j] = pl[i][j-1];\n            if(x[j] - x[j - 1] > vl[i]){\n                pl[i][j] = j;\n            }\n        }\n        pr[i][n] = n;\n        for(int j = n - 1; j >= 1; j -- ){\n            pr[i][j] = pr[i][j+1];\n            if(x[j + 1] - x[j] > vl[i]){\n                pr[i][j] = j;\n            }\n        }\n    }\n    for(int i = 0 ; i < z; i ++ )\n        dpL[i] = 0, dpR[i] = n + 1;\n    int mask;\n    for(int i = 0 ; i < z; i ++ ){\n        for(int j = 0 ; j < m; j ++ ){\n            if(i & (1 << j)) continue;\n            mask = i | (1 << j);\n            if(dpL[i] == n) dpL[mask] = n;\n            else dpL[mask] = max(dpL[mask], pr[j][dpL[i] + 1]);\n        }\n    }\n    for(int i = 0 ; i < z; i ++ ){\n        for(int j = 0 ; j < m ; j ++ ){\n            if(i & (1 << j)) continue;\n            mask = i | (1 << j);\n            if(dpR[i] == 1) dpR[mask] = 1;\n            else dpR[mask] = min(dpR[mask], pl[j][dpR[i] - 1]);\n        }\n    }\n    int oth;\n    int L, R;\n    for(int i = 0 ; i < (1 << (m - 1)); i ++ ){\n        oth = (1 << (m - 1)) - i - 1; \n        L = dpL[i];\n        R = dpR[oth];\n        if(L >= R){\n            update(1, n);\n        }\n        else{\n            if(pr[m - 1][L + 1] >= R-1){\n                update(L + 1, R - 1);\n            }\n        }\n    }\n    for(int i = 1; i <= n; i ++ ){\n        cnt[i] += cnt[i - 1];\n        if(cnt[i] > 0)\n            cout << \"Possible\\n\";\n        else\n            cout << \"Impossible\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=200010;\nint n,v,m,val[18];\nint f[1<<18],g[1<<18];\nint lst[19][maxn],nxt[19][maxn];\nint x[maxn],ans[maxn],cnt;\nstruct Query {\n\tint id,x,y;\n\tbool operator < (const Query& b) const {\n\t\tif(x!=b.x) return x>b.x;\n\t\tif(y!=b.y) return y<b.y;\n\t\treturn id<b.id;\n\t}\n}Q[maxn*3];\nint main() {\n\tn=read();v=read();\n\trep(i,1,n) x[i]=read();\n\tint tmp=v;v>>=1;\n\twhile(v) val[m++]=v,v>>=1;\n\tval[m++]=0;val[m]=tmp;\n\trep(i,0,m) {\n\t\tint j=1;lst[i][1]=1;\n\t\trep(k,2,n) {\n\t\t\tif(x[k]-x[k-1]>val[i]) j=k;\n\t\t\tlst[i][k]=j;\n\t\t}\n\t\tj=n;nxt[i][n]=n;\n\t\tdwn(k,n-1,1) {\n\t\t\tif(x[k+1]-x[k]>val[i]) j=k;\n\t\t\tnxt[i][k]=j;\n\t\t}\n\t}\n\trep(S,0,(1<<m)-1) f[S]=0,g[S]=n+1;\n\trep(S,0,(1<<m)-1) {\n\t\tint ans=f[S];\n\t\trep(i,0,m-1) if(!(S>>i&1)) f[S^(1<<i)]=max(f[S^(1<<i)],max(ans,nxt[i][ans+1]));\n\t\tans=g[S];\n\t\trep(i,0,m-1) if(!(S>>i&1)) g[S^(1<<i)]=min(g[S^(1<<i)],min(ans,lst[i][ans-1])); \n\t}\n\trep(S,0,(1<<m)-1) Q[++cnt]=(Query){0,f[S],g[S^((1<<m)-1)]};\n\trep(i,1,n) Q[++cnt]=(Query){i,lst[m][i]-1,nxt[m][i]+1};\n\tsort(Q+1,Q+cnt+1);\n\tint mn=n+233;\n\trep(i,1,cnt) {\n\t\tif(!Q[i].id) mn=min(mn,Q[i].y);\n\t\telse ans[Q[i].id]=mn<=Q[i].y;\n\t}\n\trep(i,1,n) puts(ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )\n#define re register\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int N = 2e5 + 5 ; \nconst int M = 15 + 5 ; \nint n, m, w[M], cnt, a[N], st[N], top, Go[M][N], dp[1 << M][M], W[N] ; \nsigned main()\n{\n\tn = gi(), m = gi() ;\n\trep( i, 1, n ) a[i] = gi() ; \n\twhile( m ) w[++ cnt] = m, m = m / 2 ; \n\tw[++ cnt] = 0 ; \n\tint r = 1 ; \n\tfor( re int k = 1; k <= cnt; ++ k ) {\n\t\tr = 1 ; int befr = 0 ; \n\t\tfor( re int i = 1; i <= n; ++ i ) {\n\t\t\tr = max( r, i ) ; \n\t\t\twhile( r < n && a[r + 1] - a[max( i, r )] <= w[k] ) ++ r ;  \n\t\t\tGo[k][i] = r ;\n\t\t\tif( ( k == 1 ) && ( r != befr ) ) st[++ top] = r, W[r] = top, befr = r ;\n\t\t}\n\t}\n\tif( top > cnt ) {\n\t\trep( i, 1, n ) puts(\"Impossible\") ;\n\t\texit(0) ;\n\t}\n\tint maxn = ( 1 << cnt ) - 1 ; dp[0][0] = 0 ;\n\trep( i, 1, cnt ) Go[i][n + 1] = n ;\n\tfor( re int i = 0; i < maxn; ++ i ) {\n\t\trep( t, 0, top ) {\n\t\t\tfor( re int j = 1; j <= cnt; ++ j ) {\n\t\t\t\tint k = ( 1 << ( j - 1 ) ) ;\n\t\t\t\tif( ( i & k ) ) continue ;  \n\t\t\t\tif( j == 1 && t == 0 ) {\n\t\t\t\t\tdp[i ^ k][W[Go[j][dp[i][t] + 1]]] = max( dp[i ^ k][W[Go[j][dp[i][t] + 1]]], Go[j][dp[i][t] + 1] ) ;\n\t\t\t\t}\n\t\t\t\telse if( j != 1 ) dp[i ^ k][t] = max( dp[i ^ k][t], Go[j][dp[i][t] + 1] ) ;\n\t\t\t}\n\t\t}\n\t}\n\trep( i, 1, n ) {\n\t\tif( dp[maxn][W[Go[1][i]]] >= n ) puts(\"Possible\") ;\n\t\telse puts(\"Impossible\") ;\n\t}\n\treturn 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\nusing namespace std;\nconst int maxn=200000+10,lgn=20;\nint f[maxn*5],g[maxn*5],mi[maxn],left[maxn][lgn+10],right[maxn][lgn+10],v[lgn+10],x[maxn];\nint i,j,k,l,r,s,t,n,m,tot,top;\nint main(){\n\tscanf(\"%d%d\",&n,&t);\n\tfo(i,1,n) scanf(\"%d\",&x[i]);\n\tv[0]=t;\n\tt/=2;\n\twhile (t){\n\t\tv[++top]=t;\n\t\tt/=2;\n\t}\n\tv[++top]=0;\n\treverse(v,v+top+1);\n\tfo(j,0,top){\n\t\tleft[1][j]=1;\n\t\tfo(i,2,n)\n\t\t\tif (x[i]-x[i-1]<=v[j]) left[i][j]=left[i-1][j];else left[i][j]=i;\n\t\tright[n][j]=n;\n\t\tfd(i,n-1,1)\n\t\t\tif (x[i+1]-x[i]<=v[j]) right[i][j]=right[i+1][j];else right[i][j]=i;\n\t}\n\tf[0]=0;\n\tg[0]=n+1;\n\tfo(s,1,(1<<(top+1))-1){\n\t\tf[s]=0;\n\t\tg[s]=n+1;\n\t\tfo(i,0,top)\n\t\t\tif (s&(1<<i)){\n\t\t\t\tr=s^(1<<i);\n\t\t\t\tif (f[r]==n) f[s]=n;\n\t\t\t\telse f[s]=max(f[s],right[f[r]+1][i]);\n\t\t\t\tif (g[r]==1) g[s]=1;\n\t\t\t\telse g[s]=min(g[s],left[g[r]-1][i]);\n\t\t\t}\n\t}\n\tfo(i,0,n) mi[i]=n+2;\n\tfo(i,0,(1<<top)-1){\n\t\tr=((1<<top)-1)^i;\n\t\tmi[f[i]]=min(mi[f[i]],g[r]);\n\t}\n\tfd(i,n-1,0) mi[i]=min(mi[i],mi[i+1]);\n\tfo(i,1,n){\n\t\tl=left[i][top];r=right[i][top];\n\t\tif (mi[l-1]<=r+1) printf(\"Possible\\n\");else printf(\"Impossible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n题解先咕着。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 200005, maxk = 20;\nint x[maxn];\nint exl[maxn], exr[maxn];\nint l[maxk][maxn], r[maxk][maxn];\nint len[maxk];\n\nint main() {\n\tint n = read, v = read;\n\tfor(int i = 1; i <= n; i ++)\n\t\tread(x[i]);\n\n\tint d = 0;\n\twhile(v) {\n\t\tlen[d ++] = v;\n\t\tv >>= 1;\n\t}\n\t++ d;\n\n\tfor(int k = 0; k < d; k ++) {\n\t\tl[k][1] = 1;\n\t\tfor(int i = 2; i <= n; i ++)\n\t\t\tif(x[i - 1] + len[k] >= x[i])\n\t\t\t\tl[k][i] = l[k][i - 1];\n\t\t\telse\n\t\t\t\tl[k][i] = i;\n\n\t\tr[k][n] = n;\n\t\tfor(int i = n - 1; i; i --)\n\t\t\tif(x[i] + len[k] >= x[i + 1])\n\t\t\t\tr[k][i] = r[k][i + 1];\n\t\t\telse\n\t\t\t\tr[k][i] = i;\n\t}\n\n\tfor(int S = 0; S < (1 << d); S ++) {\n\t\texl[S] = 0;\n\t\texr[S] = n + 1;\n\t\tfor(int k = 0; k < d; k ++)\n\t\t\tif(S >> k & 1) {\n\t\t\t\tint T = S ^ (1 << k);\n\t\t\t\texl[S] = std::max(exl[S], r[k][exl[T] + 1]);\n\t\t\t\texr[S] = std::min(exr[S], l[k][exr[T] - 1]);\n\t\t\t}\n\t\tdebug(\"%d: %d %d\\n\", S, exl[S], exr[S]);\n\t}\n\n\tint tot = 0;\n\tfor(int i = 1; i <= n; i = r[0][i] + 1) {\n\t\t++ tot;\n\t\tif(tot >= maxk) {\n\t\t\tfor(int j = i; j <= n; j ++)\n\t\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t\tbool ok = 0;\n\t\tfor(int S = 0; S < (1 << d); S += 2) {\n\t\t\tint T = ((1 << d) - 2) ^ S ;\n\t\t\tif(exl[S] + 1 >= exr[T] or (exl[S] + 1 >= i and r[0][i] + 1 >= exr[T])) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j = i; j <= r[0][i]; j ++)\n\t\t\tif(ok)\n\t\t\t\tputs(\"Possible\");\n\t\t\telse\n\t\t\t\tputs(\"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define _ << \" \" <<\n#define X first\n#define Y second\n#define FOR(i, a, b) for (int i=(a); i<(b); i++)\n#define REP(i, n) FOR(i, 0, n)\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nconst int MAX = 1<<19, LOG = 19;\n\nint n, M;\nint p[MAX];\nint kamo[LOG][MAX];\nvector <int> Nap[MAX], Naz[MAX];\n\nvoid go(vector <int> V[MAX])\n{\n  int bio[MAX];\n  memset(bio, 0, sizeof bio);\n  \n  Nap[0].push_back(0);\n  REP(i, n) {\n    for (auto it : V[i]) {\n      if (bio[it]++) continue;\n      //      TRACE(i _ it);\n      //      if (i == n) continue;\n      REP(j, LOG)\n\tif (!(it>>j & 1))\n\t  Nap[kamo[j][i]].push_back(it | (1<<j));\n    }\n\n    for (auto it : V[i]) bio[it] = 0;\n  }\n}\n\nint main()\n{\n  scanf(\"%d%d\", &n, &M);\n\n  REP(i, n) scanf(\"%d\", &p[i]);\n  p[n] = p[n-1] + MAX;\n\n  for (int i=0, tmp=M; i<LOG; i++, M/=2) {\n    for (int j=0; j<n; ) {\n      int k = j;\n      for (; p[k+1]-p[k] <= tmp; k++); k++;\n      FOR(tito, j, k)\n\tkamo[i][tito] = k;\n      j = k;\n    }\n  }\n\n  go(Nap);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing std::max;\ninline void umx(int &a,int b){a=max(a,b);}\nusing std::min;\ninline void umn(int &a,int b){a=min(a,b);}\nconst int MAXN=2e5+5,MAXS=3e5+5;\n\nint n,V,K,v[MAXN];int na[MAXN];\nint L[MAXN][20],R[MAXN][20];\nint f[MAXS],g[MAXS];\nint seq[MAXN];\n\nint main()\n{\n\tint i,k,x;scanf(\"%d%d\",&n,&V);\n\tfor(i=1;i<=n;i++) scanf(\"%d\",na+i);\n\n\tv[0]=V;while(v[K]) v[++K]=v[K-1]>>1;\n\n\tfor(k=0;k<=K;k++)\n\t{\n\t\tfor(i=x=1;i<=n;i++)\n\t\t\tL[i][k]=x=(i>1&&na[i]-na[i-1]>v[k])?i:x;\n\t\tfor(i=x=n;i;i--)\n\t\t\tR[i][k]=x=(i<n&&na[i+1]-na[i]>v[k])?i:x;\n\t\tR[n+1][k]=n+1;\n\t}\n\n\tstd::fill(g,g+(1<<K),n+1);\n\tfor(int S=1;S<1<<K;S++)\n\t\tfor(i=1;i<=K;i++)\n\t\t\tif((S>>i-1)&1)\n\t\t\t\tumx(f[S],R[f[S^(1<<i-1)]+1][i]),\n\t\t\t\tumn(g[S],L[g[S^(1<<i-1)]-1][i]);\n\n\tfor(int S=0,msk=(1<<K)-1;S<1<<K;S++)\n\t{\n\t\tint l=L[g[S]-1][0],r=R[f[msk^S]+1][0];\n\t\tif(l<=r) seq[l]++,seq[r+1]--;\n\t}\n\n\tfor(i=1;i<=n;i++) seq[i]+=seq[i-1];\n\tfor(i=1;i<=n;i++) puts(seq[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n\nnamespace FastIO {\n  \n  inline int read() {\n    char ch = getchar(); int r = 0, w = 1;\n    while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}\n    while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}\n    return r * w;\n  }\n\n  void _write(int x) {\n    if(x < 0) putchar('-'), x = -x;\n    if(x > 9) _write(x / 10);\n    putchar(x % 10 + '0');\n  }\n\n  inline void write(int x) {\n    _write(x);\n    puts(\"\");\n  }\n\n  inline int min(int a, int b) {return a < b ? a : b;}\n  inline int max(int a, int b) {return a > b ? a : b;}\n}\n\nusing namespace FastIO;\n\nconst int N = 3e5 + 6;\nconst int M = 23;\n\nint n, k, tot;\nint x[N], v[N], l[M][N], r[M][N], val[N], ll[N], rr[N];\n\nint main() {\n  n = read();\n  v[0] = read();\n  while(v[k]) v[k + 1] = v[k] >> 1, k++;\n  tot = (1 << k) - 1;\n  for(register int i = 1; i <= n; i++) x[i] = read();\n  for(register int i = 0; i <= k; i++) {\n    l[i][1] = 1;\n    for(register int j = 2; j <= n; j++) {\n      if(x[j] - x[j - 1] <= v[i]) l[i][j] = l[i][j - 1];\n      else l[i][j] = j;\n    }\n    r[i][n] = n;\n    for(register int j = n - 1; j >= 0; j--) {\n      if(x[j + 1] - x[j] <= v[i]) r[i][j] = r[i][j + 1];\n      else r[i][j] = j;\n    }\n  }\n  for(register int i = 1; i <= tot; i++) {\n    ll[i] = 1, rr[i] = n;\n  }\n  ll[0] = 0, rr[0] = n + 1;\n  for(register int i = 0; i <= tot; i++) {\n    for(register int j = 1; j <= k; j++) {\n      if(!((i >> (j - 1)) & 1)) {\n        ll[i | (1 << (j - 1))] = max(ll[i | (1 << (j - 1))], r[j][ll[i] + 1]);\n        rr[i | (1 << (j - 1))] = min(rr[i | (1 << (j - 1))], l[j][rr[i] - 1]);\n      }\n    }\n  }\n  for(register int i = 0; i <= n + 1; i++) val[i] = n << 1;\n  for(register int i = 0; i <= tot; i++) val[ll[i]] = min(val[ll[i]], rr[tot ^ i]);\n  for(register int i = n; i >= 0; i--) val[i] = min(val[i], val[i + 1]);\n  for(register int i = 1; i <= n; i++) printf(\"%s\\n\", val[l[0][i] - 1] <= r[0][i] + 1 ? \"Possible\" : \"Impossible\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 262145;\nint n, V, xs[MAXN];\nint ls[MAXN], rs[MAXN], bak;\nint L[32][MAXN], R[32][MAXN];\nint pre[MAXN], suc[MAXN];\nvoid getmax(int & x, int y) { x < y ? x = y : 0; }\nvoid getmin(int & x, int y) { x > y ? x = y : 0; }\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> V;\n\txs[n + 1] = std::numeric_limits<int>::max();\n\tfor (int i = 1; i <= n; ++i) std::cin >> xs[i];\n\tint T = 0;\n\tfor (; ; ++T, V >>= 1) {\n\t\tint lst = 1;\n\t\tfor (int i = 2; i <= n + 1; ++i)\n\t\t\tif (xs[i] - xs[i - 1] > V) {\n\t\t\t\tint l = lst, r = i - 1;\n\t\t\t\tif (!T) ls[++bak] = l, rs[bak] = r;\n\t\t\t\tfor (int j = l; j <= r; ++j) L[T][j] = l, R[T][j] = r;\n\t\t\t\tlst = i;\n\t\t\t}\n\t\tif (!V) break;\n\t}\n\tconst int U = 1 << T;\n\tfor (int i = 0; i != U; ++i) suc[i] = n + 1;\n\tfor (int i = 0; i != U; ++i)\n\t\tfor (int j = 0; j != T; ++j)\n\t\t\tif (~i >> j & 1) {\n\t\t\t\tgetmax(pre[i | 1 << j], std::max(pre[i], R[j + 1][pre[i] + 1]));\n\t\t\t\tgetmin(suc[i | 1 << j], std::min(suc[i], L[j + 1][suc[i] - 1]));\n\t\t\t}\n\tfor (int i = 1; i <= bak; ++i) {\n\t\tbool can = false;\n\t\tif (bak <= T + 1) {\n\t\t\tfor (int j = 0; j != U; ++j)\n\t\t\t\tif (pre[j] >= ls[i] - 1 && suc[U - j - 1] <= rs[i] + 1) {\n\t\t\t\t\tcan = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tfor (int j = ls[i]; j <= rs[i]; ++j)\n\t\t\tstd::cout << (can ? \"Possible\\n\" : \"Impossible\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n \n#define iter(i, n) forw(i, 1, n)\n#define iter0(i, n) for (int i = 0; i < n; ++i)\n#define iter_r(i, n) for (int i = n; i >= 1; --i)\n#define forw(i, a, b) for (int i = a; i <= b; ++i)\n \n#define NR 201000\n \nbool mark[NR];\nint n, V, x[NR], v[20], pre[NR][20], suc[NR][20], l, f[601000], g[601000];\n \nint main() {\n\tscanf(\"%d%d\", &n, &V);\n\tfor (; V > 0; V = V / 2) v[l++] = V; v[l++] = 0;\n\titer(i, n) scanf(\"%d\", &x[i]);\n\t\n\titer0(i, l) suc[n][i] = n, pre[1][i] = 1;\n\tforw(i, 2, n) iter0(k, l) pre[i][k] = (x[i] - x[i - 1] <= v[k] ? pre[i - 1][k] : i);\n\titer_r(i, n - 1) iter0(k, l) suc[i][k] = (x[i + 1] - x[i] <= v[k] ? suc[i + 1][k] : i);\n \n \n \n\tint M = 1 << l;\n\titer0(s, M) g[s] = n + 1;\n\titer0(s, M) {\n\t\t//printf(\": %d %d %d\\n\", s, f[s], g[s]);\n\t\titer0(i, l) if (!(s >> i & 1)) {\n\t\t\tf[s ^ (1 << i)] = max(f[s ^ (1 << i)], f[s] == n ? n : suc[f[s] + 1][i]);\n\t\t\tg[s ^ (1 << i)] = min(g[s ^ (1 << i)], g[s] == 1 ? 1 : pre[g[s] - 1][i]);\n\t\t}\n\t}\n \n\tbool all = false;\n\titer0(s, M) if (!(s & 1)) {\n\t\tint t = M - 1 - s - 1;\n\t\tint l = f[s], r = g[t];\n\t\t//printf(\"!%d %d %d\\n\", l, r, suc[l+1][0]);\n \n\t\tif (l + 1 >= r) all = true;\n\t\telse if (suc[l + 1][0] >= r - 1) mark[l + 1] = true;\n\t}\n \n\tif (all) iter(i, n) mark[i] = true;\n \n\tint r = 0;\n\titer(i, n) {\n\t\tif (mark[i]) r = suc[i][0];\n\t\tputs(i <= r ? \"Possible\" : \"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=2e5+10;\n\nint n,m,v,x[maxn],Lg[19][maxn],Rg[19][maxn];\nint L[1<<18],R[1<<18];\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,j,v0,S;\n\tscanf(\"%d%d\",&n,&v);\n\tfor (i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tx[0]=x[1]-23333333;\n\tx[n+1]=x[n]+23333333;\n\tfor (v0=v,m=0;;v0>>=1,m++)\n\t{\n\t\tj=1;\n\t\tfor (i=j=1;i<=n;i++)\n\t\t{\n\t\t\tj=max(i,j);\n\t\t\twhile (x[j+1]-x[j]<=v0) j++;\n\t\t\tRg[m][i]=j;\n\t\t}\n\t\tfor (i=j=n;i>=1;i--)\n\t\t{\n\t\t\tj=min(i,j);\n\t\t\twhile (x[j]-x[j-1]<=v0) j--;\n\t\t\tLg[m][i]=j;\n\t\t}\n\t\tif (!v0) break;\n\t}\n\tint cnt=0;\n\tfor (i=1;i<=n;i=j+1)\n\t\tj=Rg[0][i],cnt++;\n\tif (cnt>m+1)\n\t{\n\t\tfor (i=1;i<=n;i++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor (S=0;S<1<<m;S++)\n\t\tR[S]=0,L[S]=n+1;\n\tfor (S=1;S<1<<m;S++)\n\t{\n\t\tfor (i=0;i<m;i++)\n\t\t\tif ((S>>i)&1)\n\t\t\t{\n\t\t\t\tR[S]=max(R[S],Rg[i+1][R[S-(1<<i)]+1]);\n\t\t\t\tL[S]=min(L[S],Lg[i+1][L[S-(1<<i)]-1]);\n\t\t\t}\n\t}\n\tfor (i=1;i<=n;i=j+1)\n\t{\n\t\tj=Rg[0][i];\n\t\tbool flag=0;\n\t\tfor (S=0;S<1<<m;S++)\n\t\t\tflag|=R[S]+1>=i&&L[(1<<m)-1-S]-1<=j;\n\t\tfor (int x=i;x<=j;x++)\n\t\t\tputs(flag?\"Possible\":\"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=262244,M=22,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ntemplate<class T> inline void read(T &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ntemplate<class T> inline void print(T x){\n\tif(!x){puts(\"0\");return;}\n\tif(x<0){putchar('-');x=-x;}\n\tint a[20],m=0;\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');puts(\"\");\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,a[N],v[20],l[20][N],r[20][N],f[N],g[N];\n\n\nvoid solve(int x){\n\tfor(int i=1;i<=n;i++){\n\t\tint t=i;\n\t\twhile(t<n&&a[t+1]-a[t]<=v[x]) t++;\n\t\tfor(int j=i;j<=t;j++)\n\t\t\tl[x][j]=t+1,r[x][j]=i-1;\n\t\ti=t;\n\t}\n\tl[x][n+1]=n+1;\n\tr[x][0]=0;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tsrand(time(0));\n#endif\n\tios::sync_with_stdio(0);\n\tread(n);read(v[0]);\n\tfor(int i=1;i<=n;i++) read(a[i]);\n\tfor(int j=1;v[j-1];j++,m=j) v[j]=v[j-1]>>1;\n\tfor(int i=0;i<m;i++) solve(i);\n\tf[0]=1;g[0]=n;\n\tfor(int i=2;i<(1<<m);i+=2){\n\t\tf[i]=1,g[i]=n;\n\t\tfor(int j=1;j<m;j++)\n\t\t\tif(i&(1<<j)) gmax(f[i],l[j][f[i^(1<<j)]]),gmin(g[i],r[j][g[i^(1<<j)]]);\n\t\t}\n\tint u=(1<<m)-2;\n\tfor(int i=1;i<=n;i++){\n\t\tint r=i,isok=0;\n\t\twhile(r<n&&a[r+1]-a[r]<=v[0]) r++;\n\t\tfor(int j=0;j<(1<<m);j+=2)\n\t\t\tif(f[j]>=i&&g[u^j]<=r) isok=1;\n\t\tfor(int j=i;j<=r;j++)\n\t\t\tif(isok) puts(\"Possible\"); else puts(\"Impossible\");\n\t\ti=r;\n\t}\n#ifdef rqgao2014\n\ttime_tester(1);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define MN 201000\n\nint n, v;\nint a[MN];\nint f[MN], g[MN];\nint b[MN];\nint nxt[20][MN];\nint lst[20][MN];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &v);\n\tfor(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tint x = v;\n\tint m = 0;\n\twhile(x) {b[m++] = x / 2; x /= 2;}\n\tb[m] = v;\n\t\n\tfor(int i = 0; i <= m; i++)\n\t{\n\t\tlst[i][1] = 1;\n\t\tfor(int j = 2; j <= n; j++)\n\t\t{\n\t\t\tif(a[j] - a[j - 1] <= b[i]) lst[i][j] = lst[i][j - 1];\n\t\t\telse lst[i][j] = j;\n\t\t}\n\t}\n\t\n\tint tot = 0;\n\tfor(int i = 0; i <= m; i++)\n\t{\n\t\tnxt[i][n] = n;\n\t\tfor(int j = n - 1; j >= 1; j--)\n\t\t{\n\t\t\tif(a[j + 1] - a[j] <= b[i]) nxt[i][j] = nxt[i][j + 1];\n\t\t\telse {nxt[i][j] = j; if(i == m) tot++;}\n\t\t}\n\t}\n\t\n\tif(m < tot) \n\t{\n\t\tfor(int i = 1; i <= n; i++) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tfor(int S = 0; S < (1 << m); S++) g[S] = n + 1; \n\tfor(int S = 0; S < (1 << m); S++)\n\t{\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tif(!((S >> i) & 1))\n\t\t\t{\n\t\t\t\tf[S | (1 << i)] = std::max(f[S | (1 << i)], nxt[i][f[S] + 1]);\n\t\t\t\tg[S | (1 << i)] = std::min(g[S | (1 << i)], lst[i][g[S] - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tbool ok = 0;\n\t\tfor(int S = 0; S < (1 << m); S++)\n\t\t{\n\t\t\tint T = ((1 << m) - 1) ^ S;\n\t\t\tif(f[S] >= i - 1 && g[T] <= nxt[m][i] + 1) {ok = 1; break;}\n\t\t}\n\t\tfor(int j = i; j <= nxt[m][i]; j++)\n\t\t{\n\t\t\tif(ok) puts(\"Possible\");\n\t\t\telse puts(\"Impossible\");\n\t\t}\n\t\ti = nxt[m][i];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\ninline int rnd(int x){\n\treturn rand()%x;\n}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=19,N=200005,inf=1e9+3e5;\nint n,v,gao,f[N],g[N],x[N],lst[M][N],nxt[M][N],dp[1<<M],tong[N];\nint main(){\n\tn=read(); v=read(); x[0]=-inf; x[n+1]=inf;\n\tfor(int i=1;i<=n;i++)x[i]=read();\n\tfor(int i=0;;i++){\n\t\tint dali=v>>i; gao=i;\n\t\tfor(int j=1;j<=n;j++)if(x[j]-x[j-1]<=dali)lst[i][j]=lst[i][j-1]; else lst[i][j]=j;\n\t\tfor(int j=n;j;j--)if(x[j+1]-x[j]<=dali)nxt[i][j]=nxt[i][j+1]; else nxt[i][j]=j;\n\t\tif((v>>i)==0)break;\n\t}\n\tf[0]=0; g[0]=n+1; \n\tfor(int i=1;i<(1<<gao);i++){\n\t\tf[i]=0; g[i]=n+1;\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)f[i]=max(f[i],nxt[j+1][f[i^(1<<j)]+1]);\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)g[i]=min(g[i],lst[j+1][g[i^(1<<j)]-1]);\n\t\tdp[i]=min(dp[i],n);\n\t}\n\tfor(int i=0;i<=n+1;i++)tong[i]=-1;\n\tfor(int i=0;i<(1<<gao);i++){\n\t\tint l=f[i],r=g[((1<<gao)-1)^i];\n\t\ttong[r]=max(tong[r],l);\n\t}\n\tfor(int i=1;i<=n;i++)tong[i]=max(tong[i],tong[i-1]);\n\tfor(int i=1;i<=n;i++){\n\t\tint l=lst[0][i],r=nxt[0][i];\n\t\tputs(tong[r+1]>=l-1?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk make_pair\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=1e5+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,t,v,len[20],p[MAXN],Fl[1<<18],Fr[1<<18],pl[20][MAXN],pr[20][MAXN],S,a[MAXN];\nvector<int>L[20],R[20];\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),v=read(),t=log2(v)+1,S=(1<<t)-1;\n\tRep(i,1,n)p[i]=read();\n\tRep(i,0,t){\n\t\tif(i)len[i]=len[i-1]/2;else len[i]=v;\n\t\tfor(int l=1,r;l<=n;l=r+1){\n\t\t\tr=l;for(;r<n&&p[r+1]-p[r]<=len[i];r++);\n\t\t\tRep(j,l,r)pl[i][j]=l,pr[i][j]=r;L[i].pb(l),R[i].pb(r);\n\t\t}\n\t}\n\tRep(sta,0,S)Fr[sta]=n+1;\n\tRep(i,1,t)Fl[1<<i-1]=(*R[i].begin()),Fr[1<<i-1]=(*--L[i].end());\n\tRep(sta,1,S)Rep(j,1,t)if(~sta>>(j-1)&1){\n\t\tint t=sta|(1<<j-1),pos=upper_bound(L[j].begin(),L[j].end(),Fl[sta]+1)-L[j].begin()-1;\n\t\tFl[t]=max(Fl[t],R[j][pos]);\n\t\tpos=lower_bound(R[j].begin(),R[j].end(),Fr[sta]-1)-R[j].begin();\n\t\tFr[t]=min(Fr[t],L[j][pos]);\n\t}\n\tRep(s,0,S){\n\t\tint ed=upper_bound(L[0].begin(),L[0].end(),Fl[s]+1)-L[0].begin()-1,st=lower_bound(R[0].begin(),R[0].end(),Fr[S^s]-1)-R[0].begin();\n\t\tif(st<=ed)a[st]++,a[ed+1]--;\n\t}\n\tfor(int i=0;i<L[0].size();i++){\n\t\ta[i]+=a[i-1];\n\t\tRep(j,L[0][i],R[0][i])puts(a[i]?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=2e5+50;\nint n,v,lg,x[N];\nint len[20], bin[20];\nint mxr[N*4], mnl[N*4];\n\nstruct BIT_MAX {\n\tint bit[N];\n\tinline void inc(int p,int v) {\n\t\tfor(int i=p;i<=n;i+=(i&(-i))) bit[i]=max(bit[i],v);\n\t}\n\tinline int ask(int p,int v=0) {\n\t\tfor(int i=p;i;i-=(i&(-i))) v=max(v,bit[i]);\n\t\treturn v;\n\t}\n\tinline void init(int lim) {\n\t\tfor(int l=1,r;l<=n;l=r+1) {\n\t\t\tr=l;\n\t\t\twhile(r<n && x[r+1]-x[r]<=lim) ++r;\n\t\t\tinc(l,r);\n\t\t}\n\t}\n} bit_max[20];\n\nstruct BIT_MIN {\n\tint bit[N];\n\tBIT_MIN() {for(int i=0;i<N;i++) bit[i]=1e9;}\n\tinline void inc(int p,int v) {\n\t\tfor(int i=p;i;i-=(i&(-i))) bit[i]=min(bit[i],v);\n\t}\n\tinline int ask(int p,int v=1e9) {\n\t\tfor(int i=p;i<=n;i+=(i&(-i))) v=min(v,bit[i]);\n\t\treturn v;\n\t}\n\tinline void init(int lim) {\n\t\tfor(int l=1,r;l<=n;l=r+1) {\n\t\t\tr=l;\n\t\t\twhile(r<n && x[r+1]-x[r]<=lim) ++r;\n\t\t\tinc(r,l);\n\t\t}\n\t}\n} bit_min[20];\n\nint ok[N];\nint main() {\n\tn=rd(), v=rd();\n\tfor(int i=1;i<=n;i++) x[i]=rd();\n\t\n\tfor(int t=v;;t/=2) {\n\t\tlen[lg++]=t;\n\t\tif(!t) break;\n\t}\n\tfor(int i=0;i<lg;i++) {\n\t\tbin[i]=1<<i;\n\t\tbit_max[i].init(len[i]);\n\t\tbit_min[i].init(len[i]);\n\t} \n\tmxr[0]=0; mnl[0]=n+1; bin[lg]=1<<lg;\n\tfor(int s=1;s<bin[lg];++s) {\n\t\tif(s&1) continue;\n\t\tint mx=0, mn=n+1;\n\t\tfor(int k=0;k<lg;++k) if(s&bin[k]) {\n\t\t\tmx=max(mx,bit_max[k].ask(mxr[s^bin[k]]+1));\n\t\t\tmn=min(mn,bit_min[k].ask(mnl[s^bin[k]]-1));\n\t\t}\n\t\tmxr[s]=mx; mnl[s]=mn;\n\t}\n\tfor(int l=1,r;l<=n;l=r+1) {\n\t\tr=l;\n\t\twhile(r<n && x[r+1]-x[r]<=v) ++r;\n\t\tint bz=0;\n\t\tfor(int i=0;i<bin[lg] && (!bz);++i) {\n\t\t\tif(!(i&1)) {\n\t\t\t\tint s1=i, s2=(bin[lg]-1)^1^i;\n\t\t\t\tif(mxr[s1]>=l-1 && mnl[s2]<=r+1) bz=1;\n\t\t\t\tswap(s1,s2);\n\t\t\t\tif(mxr[s1]>=l-1 && mnl[s2]<=r+1) bz=1;\n\t\t\t}\n\t\t}\n\t\tif(bz) for(int i=l;i<=r;i++) ok[i]=1;\n\t}\n\tfor(int i=1;i<=n;i++) puts((ok[i]) ? \"Possible\" : \"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<climits>\n\nusing namespace std;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n\nint read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x << 3) + (x << 1) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nconst int maxn = 2e5 + 10;\nint x[maxn], v[maxn], vis[maxn];\nvector<pair<int, int> > vec[maxn];\nint f1[(int)5e5], f2[(int)5e5];\n\nint main()\n{\n\n\tint n = read(), V = read();\n\tx[0] = -1e9 - 2e5 - 10;\n\tfor(int i = 1; i <= n; ++i) x[i] = read();\n\n\tv[0] = V;\n\tint tot = 0; V >>= 1;\n\tfor(tot = 1; ; ++tot) { v[tot] = V; if(!V) break; V >>= 1; }\n\tfor(int i = 0; i <= tot; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t{\n\t\t\tif(x[j] - x[j - 1] > v[i]) vec[i].pb(mp(j, j));\n\t\t\telse vec[i][vec[i].size() - 1].y++;\n\t\t}\n\n\tfor(int i = 0; i < (1 << tot); ++i) f2[i] = n + 1;\n\n\tfor(int i = 1; i <= tot; ++i) \n\t\tf1[1 << i - 1] = vec[i][0].y, f2[1 << i - 1] = vec[i][vec[i].size() - 1].x;\n\n\tfor(int s = 1; s < (1 << tot); ++s) \n\t{\n\t\tif(f1[s])\n\t\t\tfor(int i = 1; i <= tot; ++i) if(!(s & (1 << i - 1)))\n\t\t\t{\n\t\t\t\tint p = upper_bound(vec[i].begin(), vec[i].end(), mp(f1[s] + 1, INT_MAX)) - vec[i].begin();\n\t\t\t\tp--; f1[s | (1 << i - 1)] = max(f1[s | (1 << i - 1)], vec[i][p].y);\n\t\t\t}\n\n\t\tif(f2[s] != n + 1)\n\t\t\tfor(int i = 1; i <= tot; ++i) if(!(s & (1 << i - 1)))\n\t\t\t{\n\t\t\t\tint p = lower_bound(vec[i].begin(), vec[i].end(), mp(f2[s], 0)) - vec[i].begin();\n\t\t\t\tp--; if(p >= 0) f2[s | (1 << i - 1)] = min(f2[s | (1 << i - 1)], vec[i][p].x);\n\t\t\t}\n\t}\n\n\tfor(int i = 0; i < vec[0].size(); ++i)\n\t{\n\t\tint fg = 0;\n\t\tfor(int s = 0; s < (1 << tot); ++s)\n\t\t\tif(vec[0][i].x <= f1[s] + 1 && vec[0][i].y + 1 >= f2[((1 << tot) - 1) ^ s])\n\t\t\t{ fg = 1; break; }\n\t\tif(fg == 1) for(int j = vec[0][i].x; j <= vec[0][i].y; ++j) vis[j] = 1;\n\t}\n\tfor(int i = 1; i <= n; ++i) if(vis[i]) puts(\"Possible\"); else puts(\"Impossible\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 200005;\nconst int L = 20;\n\nint n,V;\nint a[N];\nint val[L],k;\nint rig[N][L],lef[N][L];\nint f[N],g[N];\nint ad[N];\n\nint main(){\n\t//freopen(\"data.in\",\"r\",stdin);\n\tn=get();V=get();\n\tfo(i,1,n)a[i]=get();\n\tval[k=1]=V;\n\tfor(;val[k];k++)val[k+1]=val[k]/2;\n\tfo(i,1,n){\n\t\tfo(j,1,k)lef[i][j]=i;\n\t\tif (i>1)\n\t\t\tfo(j,1,k)\n\t\t\tif (val[j]>=a[i]-a[i-1])lef[i][j]=lef[i-1][j];\n\t}\n\tfd(i,n,1){\n\t\tfo(j,1,k)rig[i][j]=i;\n\t\tif (i<n)\n\t\t\tfo(j,1,k)\n\t\t\tif (val[j]>=a[i+1]-a[i])rig[i][j]=rig[i+1][j];\n\t}\n\tfo(i,0,(1<<(k-1))-1)f[i]=0,g[i]=n+1;\n\tfo(i,0,(1<<(k-1))-1){\n\t\tfo(j,2,k)\n\t\tif ((i&(1<<(j-2)))==0){\n\t\t\tif (f[i]==n)f[i|(1<<(j-2))]=n;\n\t\t\telse f[i|(1<<(j-2))]=max(f[i|(1<<(j-2))],rig[f[i]+1][j]);\n\t\t\tif (g[i]==1)g[i|(1<<(j-2))]=1;\n\t\t\telse g[i|(1<<(j-2))]=min(g[i|(1<<(j-2))],lef[g[i]-1][j]);\n\t\t}\n\t}\n\tfo(i,0,(1<<(k-1))-1){\n\t\tint r=f[i],l=g[((1<<(k-1))-1)^i];\n\t\tr=min(r,n);l=max(l,1);\n\t\tif (r<n)r=rig[r+1][1];\n\t\tif (l>1)l=lef[l-1][1];\n\t\tif (l<=r)ad[l]++,ad[r+1]--;\n\t}\n\tfo(i,1,n)ad[i]+=ad[i-1];\n\tfo(i,1,n)\n\tif (ad[i])printf(\"Possible\\n\");\n\telse printf(\"Impossbile\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> vals;\nint rt[200005][30];\nint lt[200005][30];\nint n,v;\nint pos[200005];\nint memo1[300005];\nint memo2[300005];\nint something[200005];\n\nint dpL(int bitmask){\n    if (memo1[bitmask]!=-1) return memo1[bitmask];\n    if (bitmask==0) return memo1[bitmask] = -1;\n    int ans = 0;\n    for (int x = 0; x<vals.size(); x++){\n        if (bitmask&(1<<x)){\n            ans = max(ans,dpL(bitmask^(1<<x)));\n            ans = max(ans,rt[dpL(bitmask^(1<<x))+1][x]);\n        }\n    }\n    return memo1[bitmask] = ans;\n}\n\nint dpR(int bitmask){\n    if (memo2[bitmask]!=-1) return memo2[bitmask];\n    if (bitmask==0) return memo2[bitmask] = n;\n    int ans = n-1;\n    for (int x = 0; x<vals.size(); x++){\n        if (bitmask&(1<<x)){\n            ans = min(ans,dpR(bitmask^(1<<x)));\n            if (ans==0) break;\n            ans = min(ans,lt[dpR(bitmask^(1<<x))-1][x]);\n        }\n    }\n    return memo2[bitmask] = ans;\n}\n\nint main(){\n    memset(memo1,-1,sizeof(memo1));\n    memset(memo2,-1,sizeof(memo2));\n    scanf(\"%d%d\",&n,&v);\n    for (int x = 0; x<n; x++){\n        scanf(\"%d\",&pos[x]);\n    }\n    int t = v;\n    while (t>0){\n        vals.push_back(t);\n        t/=2;\n    }\n    vals.push_back(0);\n    for (int i = 0; i<vals.size(); i++){\n        rt[n-1][i] = n-1;\n        for (int x = n-2; x>=0; x--){\n            rt[x][i] = pos[x+1]-pos[x]<=vals[i]?rt[x+1][i]:x;\n        }\n        lt[0][i] = 0;\n        for (int x = 1; x<n; x++){\n            lt[x][i] = pos[x]-pos[x-1]<=vals[i]?lt[x-1][i]:x;\n        }\n    }\n    for (int x = 0; x<n; x++){\n        something[x] = n+1;\n    }\n    for (int x = 0; x<(1<<(vals.size())); x+=2){\n        int other = ((1<<(vals.size()))-2)^x;\n        if (dpL(x)==-1) continue;\n        something[dpL(x)] = min(something[dpL(x)],dpR(other));\n    }\n    for (int x = n-2; x>=0; x--){\n        something[x] = min(something[x],something[x+1]);\n    }\n    for (int x = 0; x<n; x++){\n        int L = lt[x][0];\n        int R = rt[x][0];\n        //printf(\"something %d %d\\n\",x,something[x]);\n        //printf(\"L:%d,R:%d\\n\",L,R);\n        printf(something[max(0,L-1)]<=R+1?\"Possible\\n\":\"Impossible\\n\");\n    }\n    //printf(\"%d\\n\",dpL(6));\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nvector<int> f(int N, int M, vector<int> dx) {\n\tvector<vector<int> > nxt(N + 1, vector<int>(M));\n\trep(j, M) nxt[N][j] = nxt[N - 1][j] = N - 1;\n\tfor (int i = N - 2; i >= 0; i--) {\n\t\tnxt[i] = nxt[i + 1];\n\t\tfor (int j = dx[i]; j < M; j++) nxt[i][j] = i + 1;\n\t}\n\tvector<int> dp(1<<M);\n\trep(S, 1<<M)\n\t\trep(j, M) if (!(S>>j & 1)) {\n\t\t\tint _S = S | 1<<j;\n\t\t\tdp[_S] = max(dp[_S], nxt[dp[S]][j]);\n\t\t}\n\treturn dp;\n}\n\nvector<int> solve() {\n\tint N, V; cin >> N >> V;\n\tvector<int> x(N);\n\trep(i, N) scanf(\"%d\", &x[i]);\n\tvector<int> dx(N - 1);\n\trep(i, N - 1) dx[i] = x[i + 1] - x[i];\n\t/*\n\tbool ok = true;\n\trep(i, N - 1) if (dx[i] > V) ok = false;\n\tif (ok) return vector<int>(N, true);\n\t*/\n\tvector<int> v;\n\tfor (int _V = V; _V; _V /= 2) v.pb(_V);\n\tv.pb(0);\n\tint M = v.size();\n\trep(i, N - 1) {\n\t\tint k;\n\t\tfor (k = 0; dx[i] <= v[k]; k++);\n\t\tdx[i] = k;\n\t}\n\tunion_find uf(N);\n\trep(i, N - 1) if (dx[i]) uf.unite(i, i + 1);\n\tvector<int> dp1 = f(N, M, dx);\n\treverse(dx.begin(), dx.end());\n\tvector<int> dp2 = f(N, M, dx);\n\tvector<bool> ok(N);\n\trep(S, 1<<(M - 1)) {\n\t\tint S1 = S<<1, S2 = (((1<<(M - 1)) - 1) - S)<<1;\n\t\tint i = min(dp1[S1], N - 1), j = max(0, N - 1 - dp2[S2]);\n\t\tif (uf.same(i, j)) ok[uf.find(i)] = true;\n\t}\n\tvector<int> ans(N);\n\trep(i, N) ans[i] = ok[uf.find(i)];\n\treturn ans;\n}\n\nint main() {\n\tvector<int> ans = solve();\n\tfor (int z: ans) if (z) printf(\"Possible\\n\"); else printf(\"Impossible\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define N 1048576\n#define ll long long\nusing namespace std;\nint n,m,cnt,a[N],b[109],l[20][N],r[20][N],f[N],g[N];\nstruct node{ int x,y; node(){} node(int a,int b){ x=a,y=b; } }c[N];\nconst bool cmp(const node &x,const node &y){ return x.y<y.y; }\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (; m; m>>=1) b[++cnt]=m; cnt++;\n\trep (i,1,cnt>>1) swap(b[i],b[cnt-i+1]);\n\tm=1<<cnt-1;\n\trep (i,1,n) scanf(\"%d\",&a[i]);\n\trep (i,1,cnt){//预处理l[i][j]和r[i][j]表示第i层第j个点所在线段的左右端点\n\t\tl[i][1]=1; r[i][n]=n;\n\t\trep (j,2,n) l[i][j]=a[j]-a[j-1]<=b[i]?l[i][j-1]:j;\n\t\tper (j,n-1,1) r[i][j]=a[j+1]-a[j]<=b[i]?r[i][j+1]:j;\n\t}\n\trep (i,0,m-1) g[i]=n+1,f[i]=0;//f[i]表示状态为i，从1开始延伸出去的最远长度；g[i]表示从n开始延伸的最远长度\n\t//状态s的意思是，如果某位为1则表示当前层选了线段\n\trep (i,1,m-1) rep (j,1,cnt-1) if ((i>>j-1)&1){\n\t\tint k=i^1<<j-1;//f[k]->f[i]\n\t\tf[i]=max(f[i],f[k]<n?r[j][f[k]+1]:n);\n\t\tg[i]=min(g[i],g[k]>1?l[j][g[k]-1]:1);\n\t}\n\trep (i,0,m-1)\n\t\tif (f[i]+1<g[m-1^i]) c[i+1]=node(f[i]+1,g[m-1^i]-1);\n\t\telse{\n\t\t\trep(j,1,n) puts(\"Possible\"); return 0;\n\t\t}\n\tsort(c+1,c+1+m,cmp);\n\tfor (int i=1,j=1,k=0; i<=n; i++){\n\t\twhile (j<=m && c[j].y<=r[cnt][i]){\n\t\t\tk=max(k,c[j].x); j++;\n\t\t}\n\t\tif (k>=l[cnt][i]) puts(\"Possible\"); else puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst double PI=acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pi;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<=(b);i++)\n#define per(i,a,b) for (int i=(a);i>=(b);i--)\n#define Rep(i,a,b) for (int i=(a);i<(b);i++)\n#define Per(i,a,b) for (int i=(a);i>(b);i--)\n//debug\n#define deb printf(\"begin\\n\");\n#define dee printf(\"end\\n\");\n#define def printf(\"find\\n\");\n#define dey printf(\"Yes\\n\");\n#define den printf(\"No\\n\");\n#define dew printf(\"wrong\\n\");\nvoid read(int&x){\n\tx=0;int f=1;char ch=getchar();\n\twhile ((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif (ch=='-')f=-1,ch=getchar();\n\twhile (ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n\tx*=f;\n}\n//--------------------------head--------------------------//\n\n#define logn 19\n#define maxn 200005\nint n,v,a[maxn];\nint bit[logn],cntbit;\n\nint lowbit(int x){return x&(-x);}\n\n\nint toL[maxn][logn],fL[1<<logn];\nvoid workL(){\n\tRep(j,0,cntbit){toL[1][j]=1;rep(i,1+1,n)\n\t\tif (a[i]-a[i-1]<=bit[j])toL[i][j]=toL[i-1][j];\n\t\telse toL[i][j]=i;\n\t}\n\t/*\n\tRep(j,0,cntbit){\n\t\trep(i,1,n)printf(\"%d \",toL[i][j]);printf(\"\\n\");\n\t}*/\n\tRep(i,0,1<<cntbit)fL[i]=n+1;\n\tRep(i,0,1<<cntbit){\n\t\tfor (int j=i;j;j-=lowbit(j))\n\t\t\tfL[i]=min(fL[i],toL[fL[i-lowbit(j)]-1][(int)log2(lowbit(j))]);\n\t}\n\t// Rep(i,0,1<<cntbit)printf(\"%d \",fL[i]);printf(\"\\n\");\n}\n\nint toR[maxn][logn],fR[1<<logn];\nvoid workR(){\n\tRep(j,0,cntbit){toR[n][j]=n;per(i,n-1,1)\n\t\tif (a[i+1]-a[i]<=bit[j])toR[i][j]=toR[i+1][j];\n\t\telse toR[i][j]=i;\n\t}\n\t/*\n\tRep(j,0,cntbit){\n\t\trep(i,1,n)printf(\"%d \",toR[i][j]);printf(\"\\n\");\n\t}*/\n\tRep(i,0,1<<cntbit)fR[i]=1-1;\n\tRep(i,0,1<<cntbit){\n\t\tfor (int j=i;j;j-=lowbit(j)){\n\t\t\t// printf(\"%d %d %d\\n\",i,lowbit(j),(int)log2(lowbit(j)));\n\t\t\tfR[i]=max(fR[i],toR[fR[i-lowbit(j)]+1][(int)log2(lowbit(j))]);\n\t\t}\n\t}\n\t// Rep(i,0,1<<cntbit)printf(\"%d \",fR[i]);printf(\"\\n\");\n}\n\nint f[maxn][logn];\nvoid work(){\n\tRep(i,1,n)f[i][0]=a[i+1]-a[i];\n\tRep(j,1,logn)Rep(i,1,n-(1<<j)+1)\n\t\tf[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);\n\t/*\n\tRep(j,0,logn){\n\t\tRep(i,1,n-(1<<j)+1)\n\t\t\tprintf(\"%d \",f[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n}\nint getmax(int L,int R){\n\tint j=(int)log2(R-L+1);\n\treturn max(f[L][j],f[R-(1<<j)+1][j]);\n}\n\nint num_possible[maxn];\nint main(){\n\t//freopen(\"Camel and Oases.in\",\"r\",stdin);\n\t//freopen(\"Camel and Oases.out\",\"w\",stdout);\n\tread(n);read(v);rep(i,1,n)read(a[i]);\n\tfor (int i=v;i;i>>=1)bit[cntbit++]=i>>1;\n\t//rep(i,1,n)printf(\"%d \",a[i]);printf(\"\\n\");\n\t//Rep(i,0,cntbit)printf(\"%d \",bit[i]);printf(\"\\n\");\n\tworkL();workR();work();\n\tRep(i,0,1<<cntbit){\n\t\tint R=fL[i]-1,L=fR[((1<<cntbit)-1)^i]+1;\n\t\t//printf(\"%d %d %d %d %d\\n\",i,((1<<cntbit)-1)^i,L,R,getmax(L,R-1));\n\t\tif (L>R){rep(i,1,n)printf(\"Possible\\n\");return 0;}\n\t\tif (L==R||getmax(L,R-1)<=v)num_possible[L]++,num_possible[R+1]--;\n\t}\n\t//rep(i,1,n)printf(\"%d \",num_possible[i]);printf(\"\\n\");\n\trep(i,1,n)num_possible[i]+=num_possible[i-1];\n\trep(i,1,n)if (num_possible[i])printf(\"Possible\\n\");else printf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=400010;\nint n, v, m;\nint a[maxn];\nint f[1<<20], g[1<<20];\nint Next[maxn][30], pre[maxn][30];\n\nvoid chkmax(int& x,int y){ if(x<y) x=y; }\nvoid chkmin(int& x,int y){ if(x>y) x=y; }\n\nint Log[maxn];\nvoid init(){\n\tfor(int i=2;i<maxn;i++) Log[i]=Log[i>>1]+1;\n}\n\nint fa[maxn];\nint find(int x){ return x==fa[x] ? x : fa[x]=find(fa[x]); }\n\nint ans[maxn], b[maxn];\n\nint main(){\n\n\tinit();\n\tscanf(\"%d%d\", &n, &v);\n\tint t=v; b[++m]=t;\n\twhile(t){\n\t\tb[++m]=t/2;\n\t\tt/=2;\n\t}\n\t// printf(\"m = %d\\n\", m);\n\t// for(int i=1;i<=m;i++) printf(\"%d \", b[i]); puts(\"\");\n\tfor(int i=1;i<=n;i++) scanf(\"%d\", &a[i]);\n\tfor(int j=1;j<=m;j++){\n\t\tfor(int i=1;i<=n;i++) fa[i]=i;\n\t\tfor(int i=1;i<n;i++) if(a[i+1]-a[i]<=b[j]) fa[find(i)]=find(i+1);\n\t\tfor(int i=1;i<=n;i++) Next[i][j]=find(i);\n\t\t\n\t\tfor(int i=1;i<=n;i++) fa[i]=i;\n\t\tfor(int i=1;i<n;i++) if(a[i+1]-a[i]<=b[j]) fa[find(i+1)]=find(i);\n\t\tfor(int i=1;i<=n;i++) pre[i][j]=find(i);\n\t\t// for(int i=1;i<=n;i++) printf(\"%d \", Next[i][j]); puts(\"\");\n\t}\n\tfor(int i=0;i<(1<<m);i++) for(int j=1;j<=m;j++) if(!(i & (1<<(j-1)))){\n\t\tchkmax(f[i | (1<<(j-1))], Next[ f[i]+1 ][j]);\n\t}\n\n\tfor(int i=0;i<(1<<m);i++) g[i]=n+1;\n\tfor(int i=0;i<(1<<m);i++) for(int j=1;j<=m;j++) if(!(i & (1<<(j-1))))\n\t\tchkmin(g[i | (1<<(j-1))], pre[ g[i]-1 ][j]);\n\tfor(int i=0;i<(1<<m);i++){ \n\t\tif((i & 1)) continue;\n\t\tint j=((1<<m)-1) ^ i ^ 1;\n\t\tint l=1, r=Next[l][1];\n\t\twhile(l<=n){\n\t\t\tif(f[i]>=l-1 && g[j]<=r+1) for(int k=l;k<=r;k++) ans[k]=1;\n\t\t\tl=r+1, r=Next[l][1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) printf(\"%s\\n\", ans[i] ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\n\nint n,m;\nvvi nex[2],dp(2);\nvi in;\nvoid f(int a){\n\tint N=-1,t=m;\n\twhile(1){\n\t\tvi dp(n,-1);\n\t\tint w=0;\n\t\trep(i,n)if(dp[i]==-1){\n\t\t\tint l=i,r=i+1;\n\t\t\twhile(r<n&&in[r]-in[r-1]<=t)r++;\n\t\t\tloop(j,l,r)dp[j]=r;\n\t\t}\n\t\tnex[a].pb(dp);\n\t\tN++;\n\t\tif(!t)break;\n\t\tt/=2;\n\t}\n\tdp[a]=vi(1<<N,-1);\n\tdp[a][0]=0;\n\trep(i,1<<N)if(dp[a][i]-n)rep(j,N)if((i&1<<j)==0)\n\t\tcmax(dp[a][i|1<<j],nex[a][j+1][dp[a][i]]);\n\trep(i,1<<N)rep(j,N)if((i&1<<j)==0)\n\t\tcmax(dp[a][i|1<<j],dp[a][i]);\n}\nint main(){\n\tcin>>n>>m;\n\tin=vi(n);\n\trep(i,n)cin>>in[i];\n\t\n\tf(0);\n\trep(i,n)in[i]*=-1;\n\tsort(all(in));\n\tf(1);\n\t\n\t// show2d(nex[0]);\n\t// show2d(nex[1]);\n\t// show2d(dp);\n\t\n\tvi ma(n,inf);\n\trep(i,dp[0].size()){\n\t\tint t=dp[0].size()-1-i;\n\t\tint l=dp[0][i],r=n-dp[1][t]-1;\n\t\tcmin(ma[l],r);\n\t}\n\tfor(int i=n-2;i>=0;i--)\n\t\tma[i]=min(ma[i],ma[i+1]);\n\t\n\t// show1d(ma);\n\trep(i,n){\n\t\tint l=n-nex[1][0][n-1-i],r=nex[0][0][i]-1;\n\t\t// cout<<l<<\" \"<<r<<endl;\n\t\tif(ma[l]<=r)cout<<\"Possible\"<<endl;\n\t\telse cout<<\"Impossible\"<<endl;\n\t}\n\t\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2019/11/16] 15:47:41\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing uint = unsigned int;\nusing usize = std::size_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\n\ntemplate<typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename... Args>\nauto read(const usize size, Args... args)\n{\n    std::vector<decltype(read<T>(args...))> ans(size);\n    for (usize i = 0; i < size; i++) { ans[i] = read<T>(args...); }\n    return ans;\n}\ntemplate<typename... Types>\nauto reads() { return std::tuple<std::decay_t<Types>...>{read<Types>()...}; }\n#    define SHOW(...) static_cast<void>(0)\n\ntemplate<typename T>\nstd::vector<T> make_v(const usize size, const T v) { return std::vector<T>(size, v); }\ntemplate<typename... Args>\nauto make_v(const usize size, Args... args) { return std::vector<decltype(make_v(args...))>(size, make_v(args...)); }\nint main()\n{\n    const auto n = read<usize>(), v = read<usize>();\n    const auto x = read<ll>(n);\n    std::vector<usize> vs{v};\n    for (; vs.back() > 0;) { vs.push_back(vs.back() / 2); }\n    SHOW(vs);\n    const usize jump = vs.size();\n    SHOW(jump);\n    auto right = make_v(jump, n, n - 1);\n    for (usize i = 0; i < jump; i++) {\n        for (int j = (int)n - 2; j >= 0; j--) {\n            const ll dx = x[j + 1] - x[j];\n            right[i][j] = (dx <= vs[i] ? right[i][j + 1] : j);\n        }\n    }\n    SHOW(right);\n    auto left = make_v(jump, n, 0UL);\n    for (usize i = 0; i < jump; i++) {\n        for (usize j = 1; j < n; j++) {\n            const ll dx = x[j] - x[j - 1];\n            left[i][j]  = (dx <= vs[i] ? left[i][j - 1] : j);\n        }\n    }\n    SHOW(left);\n    const usize mask = 1 << jump;\n    std::vector<usize> rdp(mask, 0);\n    for (usize m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const usize pos = rdp[m] + 1;\n        for (usize i = 1; i < jump; i++) {\n            if (btest(m, i)) { continue; }\n            if (rdp[m] == n - 1) {\n                chmax(rdp[m | (1 << i)], rdp[m]);\n                continue;\n            }\n            const usize r = right[i][pos];\n            chmax(rdp[m | (1 << i)], r);\n        }\n    }\n    std::vector<usize> ldp(mask, n - 1);\n    for (usize m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const usize pos = ldp[m] - 1;\n        for (usize i = 1; i < jump; i++) {\n            if (btest(m, i)) { continue; }\n            if (ldp[m] == 0) {\n                chmin(ldp[m | (1 << i)], ldp[m]);\n                continue;\n            }\n            const usize l = left[i][pos];\n            chmin(ldp[m | (1 << i)], l);\n        }\n    }\n    std::vector<usize> dp(mask, 0);\n    std::vector<int> ok(n);\n    for (usize m = 0; m < mask; m++) {\n        const usize l  = rdp[m];\n        const usize r  = ldp[mask - 1 - m];\n        const usize r2 = (l + 1 >= n ? n - 1 : right[0][l + 1]);\n        const usize l2 = left[0][r2];\n        if (r2 + 1 >= r) {\n            if (r2 + 1 < n) { ok[r2 + 1]--; }\n            ok[l2]++;\n        }\n    }\n    for (usize i = 1; i < n; i++) { ok[i] += ok[i - 1]; }\n    for (usize i = 0; i < n; i++) { std::cout << (ok[i] > 0 ? \"Possible\" : \"Impossible\") << std::endl; }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp make_pair\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint n,lv;\n\nint c[19][200005];\n\nbool dfs(int mask, int cur, int target){\n  if(cur == target) return true;\n  // dbg(mask,cur,target);\n  rep(i,1,lv) if((mask>>i)%2==0){\n    if(dfs(mask + (1<<i), (c[i][cur]+1)%n, target)) return true;\n  }\n  return false;\n}\n\nint main(){\n  int v;\n  cin>>n>>v;\n  vector<int> a(n);\n  rep(i,n) cin>>a[i];\n\n  lv = 33 - __builtin_clz(v);\n\n  for(int i=0, tv=v; i<lv; i++, tv/=2){\n    int p = n-1;\n    c[i][n-1] = n-1;\n    for(int j = n-2; j>=0; j--){\n      if(a[j+1] - a[j] > tv) p = j;\n      c[i][j] = p;\n    }\n  }\n\n  set<int> x;\n  rep(i,n) x.insert(c[0][i]);\n  if(x.size() > lv){\n    rep(i,n) cout << \"Impossible\\n\";\n    return 0;\n  }\n\n  rep(i,n){\n    bool res = dfs(1, (c[0][i]+1)%n, i);\n    rep(j,i,c[0][i]+1) cout << (res ? \"Possible\" : \"Impossible\") << \"\\n\";\n    i = c[0][i];\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXMASK=(1<<19);\nconst int MAXN=20;\nconst int MAXM=200005;\nint a[MAXM],n,V,mx;\nvector<pii> vec[MAXN];\nint L[MAXN][MAXM],R[MAXN][MAXM],cnt;\nvoid work(int x,int o)\n{\n\tfor(int i=1,nxt;i<=n;i=nxt+1)\n\t{\n\t\tnxt=i;while(nxt+1<=n&&a[nxt+1]-a[nxt]<=x)++nxt;\n\t\tfor(int j=i;j<=nxt;j++)L[o][j]=i,R[o][j]=nxt;\n\t\tif(!o)++cnt;\n\t}\n}\nint f[MAXMASK],g[MAXMASK],num[MAXN][MAXMASK],bin[25];\nint main()\n{\n\tbin[1]=1;for(int i=2;i<=20;i++)bin[i]=bin[i-1]<<1;\n\tn=read();V=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tint temp=V;while(temp)work(temp,mx++),temp>>=1;\n\tif(cnt>mx){for(int i=1;i<=n;i++)puts(\"Impossible\");return 0;}\n\tfor(int i=1;i<=n;i++)L[mx][i]=R[mx][i]=i;\n\tmemset(g,63,sizeof(g));g[0]=n+1;\n\tfor(int i=1;i<bin[mx+1];i++)for(int j=1;j<=mx;j++)if(i&bin[j])\n\t{\n\t\tint pre=f[i^bin[j]];\n\t\tf[i]=max(f[i],R[j][pre+1]);\n\t\tif(pre==n)f[i]=n;\n\t\tpre=g[i^bin[j]];\n\t\tg[i]=min(g[i],L[j][pre-1]);\n\t\tif(pre==1)g[i]=1;\n\t}\n\tfor(int i=1;i<=n;i=R[0][i]+1)\n\t{\n\t\tbool tf=false;\n\t\tfor(int j=0;j<bin[mx+1];j++)\n\t\t{\n\t\t\tint lim1=L[0][i],lim2=R[0][i];\n\t\t\tif(f[j]>=lim1-1&&g[(bin[mx+1]-1)^j]<=lim2+1){tf=true;break;}\n\t\t}\n\t\tif(tf)for(int j=i;j<=R[0][i];j++)puts(\"Possible\");\n\t\telse for(int j=i;j<=R[0][i];j++)puts(\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define FOR(i, x, y) for (decay<decltype(y)>::type i = (x), _##i = (y); i < _##i; ++i)\n#define FORD(i, x, y) for (decay<decltype(x)>::type i = (x), _##i = (y); i > _##i; --i)\n#ifdef zerol\n#define dbg(x...) do { cout << \"\\033[32;1m\" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\n// -----------------------------------------------------------------------------\n\nconst int N = 2E5 + 100;\nconst int M = 20;\nconst LL INF = 1E18;\nint nxt[M][N], bak[M][N], ans[N];\nint f[1 << M], g[1 << M];\nLL x[N];\nvector<LL> spans;\n\nint main() {\n    int n, v; cin >> n >> v;\n    while (v) {\n        spans.push_back(v);\n        v /= 2;\n    }\n    spans.push_back(0);\n    FOR (i, 1, n + 1) cin >> x[i];\n\n    int m = spans.size();\n    FOR (i, 0, m) {\n        const auto& span = spans[i];\n        FORD (j, n, 0) {\n            if (j < n && x[j + 1] - x[j] <= span) {\n                nxt[i][j] = nxt[i][j + 1];\n            } else {\n                nxt[i][j] = j;\n            }\n        }\n        FOR (j, 1, n + 1) {\n            if (j > 1 && x[j] - x[j - 1] <= span) {\n                bak[i][j] = bak[i][j - 1];\n            } else {\n                bak[i][j] = j;\n            }\n            dbg(i, span, j, nxt[i][j], bak[i][j]);\n        }\n    }\n\n    g[0] = n + 1;\n    FOR (u, 0, 1 << m) {\n        if (u & 1) continue;\n        dbg(u, f[u], g[u]);\n        FOR (i, 1, m) {\n            if ((u >> i) & 1) continue;\n            int v = u | (1 << i);\n\n            if (f[u] == n) f[v] = n;\n            else f[v] = max(f[v], nxt[i][f[u] + 1]);\n            if (g[u] == 1) g[v] = 1;\n            else g[v] = max(g[v], bak[i][g[u] - 1]);\n        }\n    }\n\n    FOR (u, 0, 1 << m) {\n        if (u & 1) continue;\n        int v = ((1 << m) - 2) ^ u;\n        int st = f[u] + 1, ed = g[v] - 1;\n        if (st > n || ed < 1) {\n            fill(ans + 1, ans + n + 1, 1);\n            break;\n        }\n        if (nxt[0][st] >= ed) {\n            FOR (i, bak[0][st], nxt[0][st] + 1) {\n                if (ans[i]) break;\n                ans[i] = 1;\n            }\n        }\n    }\n\n    FOR (i, 1, n + 1) {\n        puts(ans[i] ? \"Possible\" : \"Impossible\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define x first\n#define y second\n\nint n, v;\n\nint x[200010];\n\nint hn;\nint h[20];\nint gl[20][200010];\nint gr[20][200010];\n\nvoid in(){\n\tread(n, v);\n\tfor(int i=1; i<=n; ++i) read(x[i]);\n}\n\nvoid build(){\n\tint V = v;\n\tfor(;;++hn, V/=2){\n\t\th[hn] = V;\n\t\tfor(int i=1; i<=n;){\n\t\t\tint j;\n\t\t\tfor(j=i+1; j<=n && x[j]-x[j-1] <= V; ++j);\n \t\t\tfor(int k=i; k<j; ++k){\n\t\t\t\tgl[hn][k]=i;\n\t\t\t\tgr[hn][k]=j-1;\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t\tif(V == 0) break;\n\t}\n}\n\nint dpL[524288];\nint dpR[524288];\n\nvoid do_dp(){\n\tint M = (1<<hn);\n\tfor(int i=0; i<M; ++i){\n\t\tdpL[i] = 0;\n\t\tdpR[i] = n+1;\n\t\tfor(int j=1; j<=hn; ++j){\n\t\t\tint key = (1 << (j-1));\n\t\t\tif(i & key){\n\t\t\t\tint bl=dpL[i^key], br=dpR[i^key];\n\t\t\t\tdpL[i] = max(dpL[i], bl == n ? n : gr[j][bl+1]);\n\t\t\t\tdpR[i] = min(dpR[i], br == 1 ? 1 : gl[j][br-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool all_yes;\nbool yes[200010];\nvoid apply_gugan(int a, int b){\n\tif(a > b){\n\t\tall_yes = true;\n\t} else {\n\t\tif(gl[0][a] == gl[0][b]){\n\t\t\tyes[gl[0][a]]=1;\n\t\t}\n\t}\n}\n\nvoid Fill(){\n\tint M = (1<<hn);\n\tfor(int i=1; i<M; ++i){\n\t\tdpL[i] = max(dpL[i], dpL[i&(i-1)]);\n\t\tdpR[i] = min(dpR[i], dpR[i&(i-1)]);\n\t}\n\tfor(int i=0; i<M; ++i){\n\t\tint l=dpL[i]+1;\n\t\tint r=dpR[(M-1)^i]-1;\n\t\tapply_gugan(l, r);\n\t}\n}\n\nint main()\n{\n\tfreopen(\"in\", \"r\", stdin);\n\tin(); build(); do_dp(); Fill();\n\tfor(int i=1; i<=n; ++i){\n\t\tputs(yes[gl[0][i]]?\"Possible\":\"Impossible\");\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=200000+19;\n\nint f[1<<20],g[1<<20];\nint x[N],A[20][N],B[20][N];\nint n,V,pV,mx;\n\nint main(){\n\tn=IN(),pV=V=IN();\n\tFor(i,1,n+1) x[i]=IN();\n\tfor (mx=0;;mx++){\n\t\tint sum=0;\n\t\tfor (int l=1,r;l<=n;l=r+1){\n\t\t\tfor (r=l;r+1<=n&&x[r+1]-x[r]<=V;r++);\n\t\t\tFor(i,l,r+1) A[mx][i]=r,B[mx][i]=l;\n\t\t\tsum++;\n\t\t}\n\t\tif (mx==0&&sum>20){\n\t\t\tFor(i,1,n+1) puts(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (V==0) break;\n\t\tV/=2;\n\t}\n\tFor(t,0,1<<mx){\n\t\tf[t]=0;\n\t\tg[t]=n+1;\n\t}\n\tFor(t,0,1<<mx){\n\t\tFor(i,0,mx) if (!(t>>i&1)){\n\t\t\tf[t|1<<i]=max(f[t|1<<i],A[i+1][f[t]+1]);\n\t\t\tg[t|1<<i]=min(g[t|1<<i],B[i+1][g[t]-1]);\n\t\t}\n\t}\n\tV=pV;\n\tfor (int l=1,r;l<=n;l=r+1){\n\t\tbool chk=0;\n\t\tfor (r=l;r+1<=n&&x[r+1]-x[r]<=V;r++);\n\t\tFor(t,0,1<<mx){\n\t\t\tif (f[t]>=l-1&&g[((1<<mx)-1)^t]<=r+1) chk=1;\n\t\t}\n\t\tFor(i,l,r+1) puts(chk?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define fir first\n#define sec second\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int maxN = 2e5 + 2;\n\ninline bool Chkmax(int& x, int y)\n{ return x < y ? x = y, true : false; }\n\ninline bool Chkmin(int& x, int y)\n{ return x > y ? x = y, true : false; }\n\nint n, v, cnt;\nint SUC[maxN], ans[maxN];\nint x[maxN], f[maxN << 1], g[maxN << 1];\nvector<pii> line[20];\n\nint main()\n{\n    if (fopen(\"wib.in\", \"r\"))\n        freopen(\"wib.in\", \"r\", stdin);\n    if (fopen(\"wib.out\", \"w\"))\n        freopen(\"wib.out\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n    cin >> n >> v;\n    for (int i = 1; i <= n; ++i)\n        cin >> x[i];\n    do\n    {\n        int l = 1, r = 1; // attenion that l = 0\n        for (int j = 2; j <= n; ++j)\n        {\n            if (x[j] - (v >> cnt) > x[r])\n            {\n                line[cnt].emplace_back(l, r);\n                l = j;\n            }\n            r = j;\n        }\n        line[cnt].emplace_back(l, r);\n    } while (v >> cnt++);\n    // cout << cnt << endl;\n    --cnt;\n//    for (int i = 0; i < cnt; ++i)\n//        for (auto j : line[i])\n//            cout << j.fir << ' ' << j.sec << endl;\n    fill(f, f + (1 << cnt), -1);\n    fill(g, g + (1 << cnt), n + 2);\n    f[0] = 0, g[0] = n + 1;\n    for (int i = 0; i < cnt; ++i)\n        f[1 << i] = line[i + 1].begin()->sec, g[1 << i] = line[i + 1].rbegin()->fir;\n    for (int i = 1; i < 1 << cnt; ++i) if (~f[i])\n        for (int j = 1; j <= cnt; ++j)\n            if (!(i >> (j - 1) & 1))\n            {\n                auto pos = lower_bound(line[j].begin(), line[j].end(), pii(f[i] + 2, 0)) - 1;\n                Chkmax(f[i | 1 << (j - 1)], pos->sec);\n            }\n    for (int i = 1; i < 1 << cnt; ++i) if (g[i] != n + 1)\n        for (int j = 1; j <= cnt; ++j)\n            if (!(i >> (j - 1) & 1))\n            {\n                auto pos = lower_bound(line[j].begin(), line[j].end(), pii(g[i], 0));\n                if (pos != line[j].begin())\n                    Chkmin(g[i | 1 << (j - 1)], --pos->fir);\n            }\n    fill(SUC, SUC + n + 1, n + 2);\n    for (int i = 0, all = (1 << cnt) - 1; i <= all; ++i)\n        if (~f[i])\n            Chkmin(SUC[f[i]], g[all ^ i]);\n    for (int i = n; i; --i)\n        Chkmin(SUC[i - 1], SUC[i]);\n    //for (int i = 0; i <= n; ++i)\n    //    cout << SUC[i] << ' ';\n    //cout << endl;\n    for (auto i : line[0])\n    {\n        // cout << i.fir << ' ' << i.sec << endl;\n        int flag = SUC[i.fir - 1] <= i.sec + 1;\n        for (int j = i.fir; j <= i.sec; ++j)\n            cout << (flag ? \"Possible\" : \"Impossible\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for (int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T sqr(const T &a) { return a * a; }\ntypedef long long LL;\ntypedef long double LD;\nvoid procStatus() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\nLL read() {\n\tLL x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (;!isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n\tfor (;isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\treturn x * flag;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 4e5 + 9;\nint n, V, a[Maxn];\n\nvoid Init() {\n\tn = read(), V = read();\n\trep (i, 1, n) a[i] = read();\n}\n\nint pon[20][Maxn];\nint len[Maxn], lef[Maxn], rig[Maxn];\n\nint uppfind(int pos, int step) {\n\tint l = 1, r = len[step], ans = pon[step][r];\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (pon[step][mid] > pos) ans = pon[step][mid], r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\treturn ans;\n}\n\nint lowfind(int pos, int step) {\n\tint l = 1, r = len[step], ans = pon[step][l];\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (pon[step][mid]< pos) ans = pon[step][mid], l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\treturn ans + 1;\n}\n\nvoid Solve() {\n\tint cnt = 0;\n\twhile ((1 << cnt) <= V) ++cnt;\n\trep (i, 0, cnt) {\n\t\tlen[i] = 1;\n\t\trep (j, 1, n) {\n\t\t\tpon[i][len[i]] = j;\n\t\t\tif (j != n && a[j + 1] - a[j] > (V >> i)) ++len[i];\n\t\t}\n\t\tpon[i][len[i] + 1] = n + 1;\n\t}\n\tif (len[0] > cnt + 1) {\n\t\trep (i, 1, n) puts(\"Impossible\");\n\t\treturn ;\n\t}\n\trep (i, 0, (1 << cnt) - 1) lef[i] = 0, rig[i] = n + 1;\n\trep (i, 0, (1 << cnt) - 1) {\n\t\trep (j, 0, cnt - 1) {\n\t\t\tif ((i >> j) & 1) continue;\n\t\t\tchkmax(lef[i ^ (1 << j)], uppfind(lef[i], j + 1)); // find a pointer bigger exclusively than f[i]\n\t\t\tchkmin(rig[i ^ (1 << j)], lowfind(rig[i] - 1, j + 1)); // find a pointer lower exclusively than f[i]\n\t\t}\n\t}\n\trep (i, 1, len[0]) {\n\t\tint l = pon[0][i - 1] + 1, r = pon[0][i];\n\t\tint flag = 0;\n\t\trep (j, 0, (1 << cnt) - 1) \n\t\t\tif (lef[j] >= l - 1 && rig[(1 << cnt) - 1 - j] <= r + 1) {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\trep (j, l, r) puts(flag ? \"Possible\" : \"Impossible\");\n\t}\n}\n\nint main() {\n\tfreopen(\"bosky.in\", \"r\", stdin);\n\tfreopen(\"bosky.out\", \"w\", stdout);\n\n\tInit();\n\tSolve();\t\n\n#ifdef Qrsikno\n//\tprocStatus();\n\tdebug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=262444,M=22,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ntemplate<class T> inline void read(T &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ntemplate<class T> inline void print(T x){\n\tif(!x){puts(\"0\");return;}\n\tif(x<0){putchar('-');x=-x;}\n\tint a[20],m=0;\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');puts(\"\");\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,a[N],v[20],cnt[20],L[20][N],R[20][N],bel[N],si[N],ans[N];\nmap<pair<int,pii>,bool> dp[20];\n\n\nvoid dfs(int x,int l,int r){\n//\tprintf(\"%d %d %d\\n\",x,l,r);\n\tif(x==m) return;\n\tfor(int i=l;i<=r;i++){\n\t\tint t=i;\n\t\twhile(t<r&&a[t+1]-a[t]<=v[x]) t++;\n\t\tL[x][++cnt[x]]=cnt[x+1]+1;\n\t\tdfs(x+1,i,t);\n\t\tR[x][cnt[x]]=cnt[x+1];\n\t\tif(!x){\n\t\t\tfor(int j=i;j<=t;j++)\n\t\t\t\tbel[j]=cnt[x];\n\t\t}i=t;\n\t}\n}\nbool get(int x,int l,int r,int st){\n//\tprintf(\"%d %d %d %d\\n\",x,l,r,st);\n\tif(l>r) return 1;\n\tif(si[st]<=r-l||x==m) return 0;\n\tif(!(st&(1<<x))) return get(x+1,l,r,st);\n\tif(dp[x].count(mp(st,mp(l,r)))) return dp[x][mp(st,mp(l,r))];\n\tbool ans=0;\n\tfor(int i=l;i<=r;i++){\n\t\tint u=st^(1<<x);\n\t\tfor(int j=u;j;j=(j-1)&u)\n\t\t\tif(get(x+1,L[x][l],R[x][i-1],j)&&get(x+1,L[x][i+1],R[x][r],u^j)){ans=1;break;}\n\t\tif(get(x+1,L[x][l],R[x][i-1],0)&&get(x+1,L[x][i+1],R[x][r],u)) ans=1;\n\t\tif(ans) break;\n\t}\n\tdp[x][mp(st,mp(l,r))]=ans;\n\treturn ans;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tsrand(time(0));\n#endif\n\tios::sync_with_stdio(0);\n\tread(n);read(v[0]);\n\tfor(int i=1;i<=n;i++) read(a[i]);\n\tfor(int j=1;v[j-1];j++,m=j) v[j]=v[j-1]>>1;\n\tdfs(0,1,n);\n//\tdebuge;\n\tif(cnt[0]>m){\n\t\tfor(int i=1;i<=n;i++) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<m;i++)\n\t\tL[i][cnt[i]+1]=R[i][cnt[i]+1]=cnt[i+1]+1;\n\tfor(int i=1;i<(1<<m);i++) si[i]=si[i^(i&-i)]+1;\n//\tdebug(cnt[1]);\n//\tdebug(cnt[0]);\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tint u=(1<<m)-2;\n\t\tfor(int j=0;j<(1<<m);j+=2)\n\t\t\tif(get(1,L[0][1],R[0][i-1],j)&&get(1,L[0][i+1],R[0][cnt[0]],u^j)){ans[i]=1;break;}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(ans[bel[i]])puts(\"Possible\"); else puts(\"Impossible\");\n#ifdef rqgao2014\n\ttime_tester(1);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nconst int N=2e5+7,LOG=20;\nint x[N],v[N],L[LOG][N],R[LOG][N],val[N],Lf[N],Rf[N],n,k,tot;\nint main(){\n    read(n);\n    read(v[0]);\n    while(v[k]) v[k+1]=v[k]>>1,k++;\n    tot=(1<<k)-1;\n    for(int i=1;i<=n;i++)\n        read(x[i]);\n    for(int i=0;i<=k;i++){\n        L[i][1]=1;\n        for(int j=2;j<=n;j++) \n            if(x[j]-x[j-1]<=v[i]) \n                L[i][j]=L[i][j-1];\n            else L[i][j]=j;\n        R[i][n]=n;\n        for(int j=n-1;j>=0;j--) \n            if(x[j+1]-x[j]<=v[i]) \n                R[i][j]=R[i][j+1];\n            else R[i][j]=j;\n    }\n    for(int i=1;i<=tot;i++) \n        Lf[i]=1,Rf[i]=n;\n    Lf[0]=0,Rf[0]=n+1;\n    for(int i=0;i<=tot;i++)\n        for(int j=1;j<=k;j++) \n            if(!((i>>(j-1))&1)) {\n                Lf[i|(1<<(j-1))]=max(Lf[i|(1<<(j-1))],R[j][Lf[i]+1]);\n                Rf[i|(1<<(j-1))]=min(Rf[i|(1<<(j-1))],L[j][Rf[i]-1]);\n            }\n    for(int i=0;i<=n+1;i++) \n        val[i]=2*n;\n    for(int i=0;i<=tot;i++) \n        val[Lf[i]]=min(val[Lf[i]],Rf[tot^i]);\n    for(int i=n;i>=0;i--) \n        val[i]=min(val[i],val[i+1]);\n    for(int i=1;i<=n;i++) \n        printf(val[L[0][i]-1]<=R[0][i]+1?\"Possible\\n\":\"Impossible\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010;\nint a[N],cnt,n,v,b[N],f[1<<18];\nint c[19][N];\nbool ans[N];\ninline void Max(int &x,int y){if(y>x)x=y;}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i =1;i<=n;i++)scanf(\"%d\",a+i);\n\tsort(a+1,a+n+1);\n\tint last = 1,tot = 0;\n\tfor(int i = 2;i<=n;i++){\n\t\tif(a[i]>a[i-1]+v) {\n\t\t\tfor(int j = last;j<i;j++) c[0][j] =i-1;\n\t\t\tlast = i;\n\t\t\ttot++;\n\t\t}\n\t} \n\ttot++;\n\tfor(int j=last;j<=n;j++) c[0][j]=  n;\n\tif(tot>18){\n\t\tfor(int i =1;i<=n;i++) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tfor(int st=1,fi;st<=n;st=fi+1){\n\t\tfi = c[0][st];\n\t\tint tmp = v;\n\t\tcnt = 0;\n\t\tint m = 0;\n\t\tbool pd = false;\n\t\n\t\tfor(int i =1;i<st;i++) b[++m] = a[i];\n\t\tfor(int i =fi+1;i<=n;i++) b[++m] = a[i];\n\t\tdo{\n\t\t\tcnt++;\n\t\t\ttmp>>=1;\n\t\t\tint last = 1;\n\t\t\tfor(int i = 2;i<=m;i++){\n\t\t\t\tif(b[i]>b[i-1]+tmp) {\n\t\t\t\t\tfor(int j = last;j<i;j++) c[cnt][j] =i-1;\n\t\t\t\t\tlast = i;\n\t\t\t\t}\n\t\t\t} \n\t\t\tfor(int j=last;j<=m;j++) c[cnt][j]=  m;\n\t\t} while(tmp>0);\n\t\t//cout<<start<<' '<<*it<<endl;\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(int k = 0;k<1<<cnt;k++){\n\t\t\tif(f[k] == m) {\n\t\t\t\tpd =true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j = 1;j<=cnt;j++) if(!(k>>j-1&1)){\n\t\t\t\tMax(f[k+(1<<j-1)],c[j][f[k]+1]);\n\t\t\t}\n\t\t}\n\t\tfor(int i =st;i<=fi;i++) ans[i] = pd;\n\t}\n\tfor(int i=1;i<=n;i++) \n\t\tif(ans[i]) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint po[1000100];\n\nint mlg;\nvector<int>li[22];\nint mr[22][1000100];\nint ml[22][1000100];\nvoid get_line(int pos,int ma)\n{\n\tli[pos].push_back(0);\n\tfor(int i=1;i<=n;++i)\n\t\tif(i==1||po[i]-po[i-1]>ma)\n\t\t\tli[pos].push_back(i);\n\tli[pos].push_back(n+1);\n\tfor(int i=1,p=0;i<=n;++i)\n\t{\n\t\tmr[pos][i]=mr[pos][i-1];\n\t\tif(i==li[pos][p+1])\n\t\t\tp++,mr[pos][i]=li[pos][p+1]-1;\n\t}\n\tmr[pos][n+1]=n;\n\tml[pos][n+1]=n+1;\n\tfor(int i=n,p=li[pos].size()-1;i;--i)\n\t{\n\t\tml[pos][i]=ml[pos][i+1];\n\t\tif(i==li[pos][p]-1)\n\t\t\tp--,ml[pos][i]=li[pos][p];\n\t}\n}\n\nint pre[1000100],suf[1000100];\nint ans[22];\nvoid out(int ma)\n{\n\tfor(int i=1;i<=ma;++i)\n\t\tfor(int j=li[0][i];j<li[0][i+1];++j)\n\t\t\tputs(ans[i]?\"Possible\":\"Impossible\");\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&po[i]);\n\tfor(int tm=m;tm;mlg++,tm>>=1) get_line(mlg,tm);\n\tget_line(mlg,0);mlg++; \n\tint s=1<<mlg,nxt;\n\tmemset(suf,0x3f,sizeof(suf));\n\tsuf[0]=n+1;\n\tfor(int i=0;i<s;++i)\n\t{\n\t\tfor(int j=0;j<mlg;++j)\n\t\t{\n\t\t\tif((i>>j)&1)continue;\n\t\t\tnxt=(i|(1<<j));\n\t\t\tpre[nxt]=max(pre[nxt],mr[j][pre[i]+1]);\n\t\t\tsuf[nxt]=min(suf[nxt],ml[j][suf[i]-1]);\n\t\t}\n\t}\n\tint ma=li[0].size()-2;\n\tif(ma>mlg)\n\t{\n\t\tfor(int i=1;i<=n;++i)puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\ts--;\n\tint ls=(s^1);\n\tfor(int i=1,L,R;i<=ma;++i)\n\t{\n\t\tL=li[0][i];R=li[0][i+1]-1;\n\t\tfor(int j=0;j<=s;++j)\n\t\t{\n\t\t\tif(j&1)continue;\n\t\t\tif(pre[j]>=L-1&&suf[(s^j)&ls]<=R+1)\n\t\t\t{\n\t\t\t\tans[i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tout(ma);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 2e5 + 10;\n\nint n, v, m, ans[N];\nint a[N], b[N], L[N][22], R[N][22], f[N], g[N];\n\nbool ask(int u)\n{\n    return ans[L[u][0] - 1] <= R[u][0] + 1;\n}\n\nint main()\n{\n    n = read(), v = read();\n    for (int i = 1; i <= n; i++) a[i] = read();\n    b[0] = v;\n    for (int i = 1; i <= 50; i++) b[i] = b[i - 1] >> 1;\n    for (int i = 0; b[i]; i++) m = i;\n    m++;\n    for (int i = 0; i <= m; i++)\n        for (int j = 1; j <= n; )\n        {\n            int k;\n            for (k = j + 1; k <= n; k++)\n                if (a[k] - a[k - 1] > b[i])\n                    break;\n            for (int l = j; l < k; l++)\n                L[l][i] = j, R[l][i] = k - 1;\n            j = k;\n        }\n    for (int i = 0; i < (1 << m); i++) g[i] = n + 1;\n    for (int i = 0; i < (1 << m); i++)\n        for (int j = 0; j < m; j++)\n            if (!(i >> j & 1))\n            {\n                f[i | (1 << j)] = max(f[i | (1 << j)], R[f[i] + 1][j + 1]);\n                g[i | (1 << j)] = min(g[i | (1 << j)], L[g[i] - 1][j + 1]);\n            }\n    for (int i = 0; i <= n; i++) ans[i] = 2e9;\n    for (int i = 0; i < (1 << m); i++)\n        ans[f[i]] = min(ans[f[i]], g[((1 << m) - 1) ^ i]);\n    for (int i = n - 1; i >= 1; i--)\n        ans[i] = min(ans[i], ans[i + 1]);\n    for (int i = 1; i <= n; i++) puts(ask(i) ? \"Possible\" : \"Impossible\");\n}\n"
  },
  {
    "language": "C++",
    "code": "//by xiqiao\n#include<bits/stdc++.h>\n#define maxn 200005\nusing namespace std;\ntypedef long long ll;\nint n;\nint l[maxn][30],r[maxn][30];\nint a[maxn];\nvoid pre_work(int wh,int v){\n\tl[0][wh]=0;l[1][wh]=0;\n\tfor(int i=2;i<=n;i++){\n\t\tif(a[i-1]-a[i-2]<=v)l[i][wh]=l[i-1][wh];\n\t\telse l[i][wh]=i-1;\n\t}\n\tr[n][wh]=n;r[n-1][wh]=n;\n\tfor(int i=n-2;i>=0;i--){\n\t\tif(a[i+1]-a[i]<=v)r[i][wh]=r[i+1][wh];\n\t\telse r[i][wh]=i+1;\n\t}\n}\nint f[maxn],f2[maxn];\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tint V;\n\tscanf(\"%d%d\",&n,&V);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",&a[i]);\n\tint g=0;\n\tfor(int x=V;x;x>>=1){\n\t\tpre_work(g++,x);\n\t}\n\tpre_work(g++,0);\n\tfor(int i=0;i<(1<<g);i++)f[i]=0;\n\tfor(int i=0;i<(1<<g);i++){\n\t\tfor(int j=0;j<g;j++){\n\t\t\tif((1<<j)&i)continue;\n\t\t\tf[i|(1<<j)]=max(f[i|(1<<j)],r[f[i]][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<g);i++)f2[i]=n;\n\tfor(int i=0;i<(1<<g);i++){\n\t\tfor(int j=0;j<g;j++){\n\t\t\tif((1<<j)&i)continue;\n\t\t\tf2[i|(1<<j)]=min(f2[i|(1<<j)],l[f2[i]][j]);\n\t\t}\n\t}\n\tif(f[(1<<g)-1]<n){\n\t\tfor(int i=0;i<n;i++)puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tint L,R;L=1;\n\tfor(L=0;L<n;L=R){\n\t\tbool ok=0;R=r[L][0];\n\t\tfor(int j=0;j<(1<<g);j++){\n\t\t\tif(j&1)continue;\n\t\t\tif(f[j]>=L && f2[(1<<g)-2-j]<=R){\n\t\t\t\tok=1;break;\n\t\t\t}\n\t\t}\n\t\tfor(int j=L;j<R;j++){\n\t\t\tif(!ok)puts(\"Impossible\");\n\t\t\telse puts(\"Possible\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=2e5+5;\nint n,m;\nint V,x[maxn],R[maxn][25],L[maxn][25];\nint S1[maxn],S2[maxn];\nint minL[maxn];\nint main(){\n\tread(n);read(V);\n\trep(i,1,n)read(x[i]);\n\twhile((1<<m)<=V)m++;m++;\n\trep2(i,0,m){\n\t\tR[n+1][i]=n;\n\t\tper(j,n,1)\n\t\t\tif(x[j+1]-x[j]<=(V>>i))R[j][i]=R[j+1][i];\n\t\t\telse R[j][i]=j;\n\t\tL[0][i]=1;\n\t\trep(j,1,n)\n\t\t\tif(x[j]-x[j-1]<=(V>>i))L[j][i]=L[j-1][i];\n\t\t\telse L[j][i]=j;\n\t}\n\trep2(i,0,1<<m)S2[i]=n+1;\n\t/*\n\trep2(i,1,1<<m)rep2(j,0,m)if(i>>j&1){\n\t\tS1[i]=max(S1[i],R[S1[i^(1<<j)]+1][j]);\n\t\tS2[i]=min(S2[i],L[S2[i^(1<<j)]-1][j]);\n\t}\n\t*/\n\trep2(i,0,1<<m)rep2(j,0,m)if(!(i&(1<<j))){\n\t\tS1[i|(1<<j)]=max(S1[i|(1<<j)],R[S1[i]+1][j]);\n\t\tS2[i|(1<<j)]=min(S2[i|(1<<j)],L[S2[i]-1][j]);\n\t}\n\trep(i,0,n)minL[i]=n+2;\n\trep2(i,0,1<<m)if(!(i&1))minL[S1[i]]=min(minL[S1[i]],S2[((1<<m)-1)^i^1]);\n\tper(i,n-1,0)minL[i]=min(minL[i],minL[i+1]);\n\trep(i,1,n){\n\t\tif(minL[L[i][0]-1]<=R[i][0]+1)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Camel and Oases\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\nint const N=2e5+10;\nint const S=1<<19;\nint n,V;\nlint d[N];\nint logV,a[25][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n    }\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&d[i]),d[i-1]=d[i]-d[i-1];\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++) printf(\"Impossible\\n\");\n        return 0;\n    }\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=0,f2[s]=n+1;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1 && f2[U-s-1]-1<=to) f=true;\n        if(f) for(int j=fr;j<=to;j++) printf(\"Possible\\n\");\n        else for(int j=fr;j<=to;j++) printf(\"Impossible\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define maxn 200005\n#define D 20\n#define INF 2147483647\nusing namespace std;\nint n,v,x[maxn],vis[maxn],maxv[maxn],cnt[D],l[D][maxn],r[D][maxn],f1[maxn*5],f2[maxn*5],ans[maxn];\nint upfind(int i,int pos)\n{\n\tpos++;\n\tint p=upper_bound(l[i]+1,l[i]+cnt[i]+1,pos)-l[i]-1;\n\tif(p<=0) return pos;\n\treturn max(r[i][p],pos-1);\n}\nint lowfind(int i,int pos)\n{\n\tpos--;\n\tint p=lower_bound(r[i]+1,r[i]+cnt[i]+1,pos)-r[i];\n\tif(p>cnt[i]) return pos;\n\treturn min(l[i][p],pos+1);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tx[0]=-INF,x[n+1]=INF;\n\tint log2;\n\tfor(log2=0;(1<<log2)<=v;log2++);\n\tfor(int lg=0;lg<=log2;lg++)\n\t{\n\t\tint d=v/(1<<lg);\n\t\tcnt[lg]=l[lg][1]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tr[lg][cnt[lg]]=i;\n\t\t\tif(x[i+1]-x[i]>d) l[lg][++cnt[lg]]=i+1;\n\t\t}\n\t\tcnt[lg]--;\n\t}\n\tif(cnt[0]>log2+1)\n\t{\n\t\tfor(int i=1;i<=n;i++) printf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint S=(1<<(log2+1));\n\tfor(int s=0;s<S;s++) f1[s]=0,f2[s]=INF;\n\tf2[0]=n+1;\n\tfor(int s=0;s<S;s+=2)\n\t\tfor(int i=0;i<=log2;i++)\n\t\t{\n\t\t\tif(!(s&(1<<i))) continue;\n\t\t\tf1[s]=max(f1[s],upfind(i,f1[s-(1<<i)]));\n\t\t\tf2[s]=min(f2[s],lowfind(i,f2[s-(1<<i)]));\n\t\t}\n\tfor(int i=1;i<=cnt[0];i++)\n\t{\n\t\tint ln=l[0][i],rn=r[0][i];\n\t\tfor(int s1=0;s1<S;s1+=2)\n\t\t{\n\t\t\tint s2=S-s1-2;\n\t\t\tint lp=f1[s1],rp=f2[s2];\n\t\t\tif(lp>=ln-1&&rp<=rn+1) { ans[i]=true; break; }\n\t\t}\n\t}\n\tfor(int i=1,pos=1;i<=n;i++)\n\t{\n\t\tprintf(\"%s\\n\",ans[pos]?\"Possible\":\"Impossible\");\n\t\tif(x[i+1]-x[i]>v) pos++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint n,m,k,a[200100],l[200100][20],r[200100][20],f[200100],g[200100],ans[200100];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()) && ch!='-');\n    bool flag=ch=='-';\n    if (flag)\n        ch=getchar();\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return flag?-x:x;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    repu(i,1,n)\n        a[i]=getint();\n    for (k=0; m>>k; ++k);\n    a[0]=-2e9,a[n+1]=2e9;\n    repu(i,0,k)\n        r[n+1][i]=n;\n    repu(i,1,n)\n        repu(j,0,k)\n        {\n            l[i][j]=a[i]-a[i-1]>m>>j?i:l[i-1][j];\n            for (r[i][j]=max(r[i-1][j],i); a[r[i][j]+1]-a[r[i][j]]<=m>>j; ++r[i][j]);\n        }\n    repu(i,0,(1<<k)-1)\n        g[i]=n+1;\n    repu(i,0,(1<<k)-1)\n        repu(j,1,k)\n            if (!(i&(1<<(j-1))))\n            {\n                int t=i|(1<<(j-1));\n                f[t]=max(f[t],r[f[i]+1][j]);\n                g[t]=min(g[t],l[g[i]-1][j]);\n            }\n    repu(i,0,(1<<k)-1)\n    {\n        int x=f[i],y=g[(1<<k)-1-i];\n        if (x+1>=y)\n            ++ans[1];\n        else\n            if (r[x+1][0]+1>=y)\n                ++ans[l[x+1][0]],--ans[r[x+1][0]+1];\n    }\n    repu(i,1,n)\n        puts((ans[i]+=ans[i-1])?\"Possible\":\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 2e5 + 10;\n\nint n, v, m, ans[N];\nint a[N], b[N], L[N][22], R[N][22], f[N], g[N];\n\nbool ask(int u)\n{\n    return ans[L[u][0] - 1] <= R[u][0] + 1;\n}\n\nint main()\n{\n    n = read(), v = read();\n    for (int i = 1; i <= n; i++) a[i] = read();\n    b[0] = v;\n    for (int i = 1; i <= 50; i++) b[i] = b[i - 1] >> 1;\n    for (int i = 0; b[i]; i++) m = i;\n    m += 2;\n    for (int i = 0; i < m; i++)\n        for (int j = 1; j <= n; )\n        {\n            int k;\n            for (k = j + 1; k <= n; k++)\n                if (a[k] - a[k - 1] > b[i])\n                    break;\n            for (int l = j; l < k; l++)\n                L[l][i] = j, R[l][i] = k - 1;\n            j = k;\n        }\n    for (int i = 0; i < (1 << m); i++) g[i] = n + 1;\n    for (int i = 0; i < (1 << m); i++)\n        for (int j = 0; j < m; j++)\n            if (!(i >> j & 1))\n            {\n                f[i | (1 << j)] = max(f[i | (1 << j)], R[f[i] + 1][j]);\n                g[i | (1 << j)] = min(g[i | (1 << j)], L[g[i] - 1][j]);\n            }\n    for (int i = 0; i <= n; i++) ans[i] = 2e9;\n    for (int i = 0; i < (1 << m); i++)\n        ans[f[i]] = min(ans[f[i]], g[((1 << m) - 1) ^ i]);\n    for (int i = n - 1; i >= 0; i--)\n        ans[i] = min(ans[i], ans[i + 1]);\n    for (int i = 1; i <= n; i++) puts(ask(i) ? \"Possible\" : \"Impossible\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<complex>\n#include<numeric>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\n\nint n, v;\nint a[220000];\nint nxt[20][220000];\n\nvector<int> calc(vector<int> &a, int v){\n    int jump = 0;\n    for(;;jump++){\n        int last = 0;\n        for(int j = 0;j < n;j++){\n            if(j == n-1 || abs(a[j+1] - a[j]) > v){\n                for(int k = last;k <= j;k++)\n                    nxt[jump][k] = j+1;\n                last = j+1;\n            }\n        }\n        if(v == 0)break;\n        v/=2;\n    }\n    jump++;\n    vector<int> dp(1 << jump, 0);\n    for(int i = 0;i < (1 << jump);i++){\n        for(int j = 0;j < jump;j++){\n            if((1 << j) & i)continue;\n            dp[(1 << j) | i] = max(dp[(1 << j) | i], nxt[j][dp[i]]);\n        }\n    }\n    return dp;\n}\n\nInt ok[1 << 20];\n\nint main(){\n    cin >> n >> v;\n   \n    vector<int> a(n);\n    for(auto &x:a)cin >> x;\n    reverse(a.begin(), a.end());\n    auto rev_dp = calc(a, v);\n    reverse(a.begin(), a.end());\n    auto dp = calc(a, v);\n\n    int not_zero = dp.size() - 2;\n    for(int l = 0;l <= not_zero;l += 2){\n        int r = not_zero - l;\n        if(nxt[0][dp[l]] + rev_dp[r] >= n){\n            ok[dp[l]]++;\n            ok[nxt[0][dp[l]]]--;\n        }\n    }\n    for(int i = 1;i < n;i++)ok[i] += ok[i-1];\n    for(int i = 0;i < n;i++){\n        if(ok[i])cout << \"Possible\" << endl;\n        else cout << \"Impossible\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 262145;\nint n, V, xs[MAXN];\nint ls[MAXN], rs[MAXN], bak;\nint L[32][MAXN], R[32][MAXN];\nint pre[MAXN], suc[MAXN];\nvoid getmax(int & x, int y) { x < y ? x = y : 0; }\nvoid getmin(int & x, int y) { x > y ? x = y : 0; }\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> V;\n\txs[n + 1] = std::numeric_limits<int>::max();\n\tfor (int i = 1; i <= n; ++i) std::cin >> xs[i];\n\tint T = 0;\n\tfor (; ; ++T, V >>= 1) {\n\t\tint lst = 1;\n\t\tfor (int i = 2; i <= n + 1; ++i)\n\t\t\tif (xs[i] - xs[i - 1] > V) {\n\t\t\t\tint l = lst, r = i - 1;\n\t\t\t\tif (!T) ls[++bak] = l, rs[bak] = r;\n\t\t\t\telse for (int j = l; j <= r; ++j)\n\t\t\t\t\tL[T - 1][j] = l, R[T - 1][j] = r;\n\t\t\t\tlst = i;\n\t\t\t}\n\t\tif (!V) break;\n\t}\n\tconst int U = 1 << T;\n\tfor (int i = 0; i != U; ++i) suc[i] = n + 1;\n\tfor (int i = 0; i != U; ++i)\n\t\tfor (int j = 0; j != T; ++j)\n\t\t\tif (~i >> j & 1) {\n\t\t\t\tgetmax(pre[i | 1 << j], std::max(pre[i], R[j][pre[i] + 1]));\n\t\t\t\tgetmin(suc[i | 1 << j], std::min(suc[i], L[j][suc[i] - 1]));\n\t\t\t}\n\tfor (int i = 1; i <= bak; ++i) {\n\t\tbool can = false;\n\t\tif (bak <= 40) {\n\t\t\tfor (int j = 0; j != U; ++j)\n\t\t\t\tif (pre[j] >= ls[i] - 1 && suc[U - j - 1] <= rs[i] + 1) {\n\t\t\t\t\tcan = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tfor (int j = ls[i]; j <= rs[i]; ++j)\n\t\t\tstd::cout << (can ? \"Possible\\n\" : \"Impossible\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define F(i,j,n) for(register int i=j;i<=n;i++)\n#define D(i,j,n) for(register int i=j;i>=n;i--)\n#define ll long long\n#define N 200010\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;int f;\n\tchar gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void gi(I&x){\n\t\tfor(f=1,c=gc();c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n};\nusing io::gi;\nusing io::gc;\nint f[N],s[N],nxt[20][N],t[20][N],tp[20][N],g[20][20],x[N],n,m,h,v,d,p,z;\nvoid pre(int v){\n\tif(!v)return;pre(v/2);\n\th=0;d++;\n\tF(i,1,m){\n\t\tif(x[f[i]]>v)tp[d][f[i]]=f[i],f[++h]=f[i];\n\t\telse tp[d][f[i]]=f[i-1],nxt[d][f[i-1]]=f[i];\n\t\tt[d][tp[d][f[i]]]++;\n\t}\n\tm=h;\n//\tF(i,1,m)printf(\"%d \",f[i]);puts(\"\");\n}\nint dfs(int d,int m){\n\tif(!m)return 1;int h=0,z=0;\n//\tF(i,1,m)printf(\"%d \",g[d][i]);puts(\"\");printf(\"%d\\n\",d);\n\tF(i,1,m)for(int j=g[d][i];j;j=nxt[d][j])s[++h]=j,z+=t[d-1][j];\n\tif(h==1)return 1;\n\tF(i,1,h)g[d][i]=s[i];\n//\tF(i,1,h)printf(\"%d-%d %d %d %d \",s[i],t[d-1][s[i]],z-t[d-1][g[d][i]],d-1,z-t[d-1][g[d][i]]<=d-1);puts(\"\\n\");\n\tF(i,1,h)if(z-t[d-1][g[d][i]]<=d-1){\n\t\tm=0;\n\t\tF(j,1,h)if(j!=i)g[d-1][++m]=g[d][j];\n\t\tif(dfs(d-1,m))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tgi(n);gi(v);\n\tF(i,1,n)gi(x[i]);\n\tD(i,n,2)x[i]-=x[i-1];\n\tx[1]=v+1;F(i,1,n)f[++m]=i;\n\tpre(v);f[m+1]=n+1;\n//\tprintf(\"%d\\n\",d);\n//\tF(i,1,d){F(j,1,n)printf(\"%d \",nxt[i][j]);puts(\"\");}puts(\"\");\n\tif(m>d+1){F(i,1,n)puts(\"Impossible\");return 0;}\n\tF(i,1,m)z+=t[d][i];\n\tF(i,1,m)if(z-t[d][i]<=d){\n\t\th=0;\n\t\tF(j,1,m)if(j!=i)g[d][++h]=f[j];\n\t\tp=dfs(d,h);\n\t\tF(j,f[i],f[i+1]-1)puts(p?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define rep(i, a, b) for (int i = a ; i <= b; ++ i) \nconst int M = 18, N = 3e5 + 5 ;\nusing namespace std ;\nint n,v[M+5],x[N],L[M+1][N],R[M+1][N],dpl[N],dpr[N],bit[N],m ;\nint main() {\n\tscanf(\"%d%d\",&n,&v[0]) ;\n\trep(i,1,n) scanf(\"%d\",&x[i]) ;\n\tfor (m = 1;; m++) {\n\t\tv[m]=v[m-1]/2;\n\t\tif (!v[m]) break ;\n\t}\n\trep(j,0,m) {\n\t\tL[j][1]=L[j][0]=1 ;\n\t\trep(i, 2, n) L[j][i]=(x[i]-x[i-1]<=v[j]?L[j][i-1]:i);\n\t\tR[j][n]=R[j][n+1]=n;\n\t\tfor (int i=n-1;i;--i) R[j][i] =(x[i+1]-x[i]<=v[j]?R[j][i+1]:i);\n\t}\n\tint st=(1<<m)-1;\n\tdpl[0]=0,dpr[0]=n+1;\n\trep(i,1,st) {\n\t\tdpl[i]=0,dpr[i]=n+1;\n\t\trep(j,1,m) if((i>>(j-1))&1) {\n\t\t\tdpl[i]=max(dpl[i],R[j][dpl[i^(1<<(j-1))]+1]) ;\n\t\t\tdpr[i]=min(dpr[i],L[j][dpr[i^(1<<(j-1))]-1]) ;\n\t\t}\n\t}\n\trep(i,0,n+1) bit[i]=-n;\n\trep(i,0,st) bit[dpr[i]]=max(bit[dpr[i]],dpl[st^i]);\n\trep(i,1,n+1) bit[i]=max(bit[i],bit[i-1]);\n\trep(i,1,n) puts((bit[R[0][i]+1]>=L[0][i]-1)?\"Possible\":\"Impossible\");\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][30],tmp[30][30];\n\nconst int H=19260817;\nstruct hash_map\n{\n\tuint x[H];\n\tbool y[H];\n\tinline int get(uint v)\n\t{\n\t\tuint g=v%H;\n\t\tfor(;x[g]&&x[g]!=v;++g==H?g=0:0);\n\t\treturn x[g]==v?y[g]:2;\n\t}\n\tinline bool&operator[](uint v)\n\t{\n\t\tuint g=v%H;\n\t\tfor(;x[g]&&x[g]!=v;++g==H?g=0:0);\n\t\tx[g]=v;return y[g];\n\t}\n}hs;\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\tuint hash=dep;\n\tfo0(i,cnt)hash=hash*2337+s[i];\n\t{int tmp=hs.get(hash);if(tmp!=2)return tmp;}\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>=dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tif(dep<16)\n\t{\n\t\tfo0(i,uc)\n\t\t{\n\t\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\t\tr[i]=t[i];\n\t\t}\n\t\treturn hs[hash]=0;\n\t}\n\tint time=clock();\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\tr[i]=t[i];\n\t\tif((clock()-time)*10>5*CLOCKS_PER_SEC)return hs[hash]=0;\n\t}\n\treturn hs[hash]=0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,v;\n  cin>>n>>v;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n\n  vector<Int> dp;\n  vector<vector<Int> > ps;\n  while(v){\n    vector<Int> dp2(n,0);\n    for(Int i=1;i<n;i++)\n      dp2[i]=dp2[i-1]+(x[i]-x[i-1]>v);\n    if(dp.empty()) dp=dp2;\n\n    vector<Int> ps2;\n    ps2.emplace_back(0);\n    for(Int i=1;i<n;i++)\n      if(dp2[i]!=dp2[i-1]) ps2.emplace_back(i);\n    ps2.emplace_back(n);\n    ps.emplace_back(ps2);\n    v>>=1;\n  }\n  \n  {\n    vector<Int> ps2(n+1,0);\n    iota(ps2.begin(),ps2.end(),0);\n    ps.emplace_back(ps2);\n  }\n\n  using P = pair<Int, Int>;\n  Int flg;\n  function<void(Int,const set<P>&)> dfs=\n    [&](Int d,const set<P> &sp){\n      {\n\tauto latte=sp.begin();\n\tInt res=latte->first==0;\n\twhile(latte!=sp.end()){\n\t  auto malta=latte;\n\t  if(++malta==sp.end()) break;;\n\t  res&=latte->second==malta->first;\n\t  latte=malta;\n\t}\n\tres&=latte->second==n;\n\tflg|=res;\n      }\n      \n      if(d==(Int)ps.size()) return;\n      \n      vector<Int> &v=ps[d];\n      Int cnt=0,ncnt=0;\n      if(d+1<(Int)ps.size()) ncnt=ps[d+1].size()-1;\n      auto latte=v.begin();\n      for(auto &p:sp){\n\tcnt+=lower_bound(latte,v.end(),p.first)-latte;\n\tif(d+1<(Int)ps.size()){\n\t  vector<Int> &u=ps[d+1];\n\t  ncnt-=lower_bound(u.begin(),u.end(),p.second)\n\t    -lower_bound(u.begin(),u.end(),p.first);\n\t}\n\tlatte=lower_bound(latte,v.end(),p.second);\n      }\n      cnt+=v.end()-latte;\n      \n      if(d+cnt-1>(Int)ps.size()) return;\n      \n      Int k=0;\n      set<P> nsp=sp;\n      for(auto &p:sp){\n\tInt nk=0;\n\twhile(v[k]<p.first){\n\t  if(d+1<(Int)ps.size()){\n\t    vector<Int> &u=ps[d+1];\n\t    nk=lower_bound(u.begin(),u.end(),v[k+1])\n\t      -lower_bound(u.begin(),u.end(),v[k]);\n\t  }\n\t  if(d+ncnt-nk<=(Int)ps.size()){\n\t    nsp.emplace(v[k],v[k+1]);\n\t    dfs(d+1,nsp);\n\t    nsp.erase(P(v[k],v[k+1]));\n\t  }\n\t  k++;\n\t  if(flg) return;\n\t}\n\tk=lower_bound(v.begin(),v.end(),p.second)-v.begin();\n      }\n      \n      Int nk=0;\n      while(k+1<(Int)v.size()){\n\tif(d+1<(Int)ps.size()){\n\t  vector<Int> &u=ps[d+1];\n\t  nk=lower_bound(u.begin(),u.end(),v[k+1])\n\t    -lower_bound(u.begin(),u.end(),v[k]);\n\t}\n\tif(d+ncnt-nk<=(Int)ps.size()){\n\t  nsp.emplace(v[k],v[k+1]);\n\t  dfs(d+1,nsp);\n\t  nsp.erase(P(v[k],v[k+1]));\n\t}\n\tk++;\n\tif(flg) return;\n      }\n    };\n  \n  for(Int i=0;i<n;){\n    Int l=i,r=*upper_bound(ps[0].begin(),ps[0].end(),l);\n    set<P> sp;\n    sp.emplace(l,r);\n    flg=0;\n    //cout<<l<<\" \"<<r<<endl;\n    dfs(1,sp);\n    string ans=flg?\"Possible\":\"Impossible\";\n    Int p=i;\n    while(i<n&&dp[p]==dp[i]){\n      cout<<ans<<endl;\n      i++;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); ++i)\n#define per(i,a,b) for (int i=(a); i>=(b); --i)\nusing namespace std;\n\nconst int maxn = 400005;\nint f[maxn][20], g[maxn][20], pre[1<<19], suf[1<<19];\nint x[maxn], ans[maxn], d[20], n, m, v;\n\nint main() {\n\tscanf(\"%d%d\", &n, &v); d[0] = v;\n\twhile (v) d[++m] = v/2, v /= 2;\n\trep (i, 1, n) scanf(\"%d\", &x[i]);\n\trep (i, 1, n) rep (j, 0, m)\n\t\tif (i >= 2 && x[i] - x[i-1] <= d[j]) f[i][j] = f[i-1][j];\n\t\telse f[i][j] = i;\n\tper (i, n, 1) rep (j, 0, m)\n\t\tif (i <= n-1 && x[i+1] - x[i] <= d[j]) g[i][j] = g[i+1][j];\n\t\telse g[i][j] = i;\n\tmemset(pre, 0xc0, sizeof pre);\n\tmemset(suf, 0x3f, sizeof suf);\n\tpre[0] = 1; suf[0] = n;\n\tint ALL = (1<<m)-1;\n\trep (i, 0, ALL) rep (j, 0, m-1) if (!(i>>j&1)) {\n\t\tif (pre[i] == n) pre[i|1<<j] = n;\n\t\telse pre[i|1<<j] = max(pre[i|1<<j], g[pre[i]+1][j+1]);\n\t\tif (suf[i] == 1) suf[i|1<<j] = 1;\n\t\telse suf[i|1<<j] = min(suf[i|1<<j], f[suf[i]-1][j+1]);\n\t}\n\tint l = 1, r, tot = 0, flag;\n\twhile (l <= n) {\n\t\tr = l; if (tot++ > m) break;\n\t\twhile (r + 1 <= n && x[r+1] - x[r] <= d[0]) r++;\n\t\tflag = 0;\n\t\trep (i, 0, ALL) {\n\t\t\tif (pre[i] >= l-1 && suf[(~i)&ALL] <= r+1) {\n\t\t\t\tflag = 1; break;\n\t\t\t}\n\t\t}\n\t\trep (i, l, r) ans[i] = flag;\n\t\tl = r + 1;\n\t}\n\trep (i, 1, n) puts(ans[i] ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\nusing namespace std;\nnamespace IO\n{\n    const int __S=(1<<20)+5;char __buf[__S],*__H,*__T;\n    inline char getc()\n    {\n        if(__H==__T) __T=(__H=__buf)+fread(__buf,1,__S,stdin);\n        if(__H==__T) return -1;return *__H++;\n    }\n    template <class __I>inline void read(__I &__x)\n    {\n        __x=0;int __fg=1;char __c=getc();\n        while(!isdigit(__c)&&__c!='-') __c=getc();\n        if(__c=='-') __fg=-1,__c=getc();\n        while(isdigit(__c)) __x=__x*10+__c-'0',__c=getc();\n        __x*=__fg;\n    }\n    inline void readd(double &__x)\n    {\n        __x=0;double __fg=1.0;char __c=getc();\n        while(!isdigit(__c)&&__c!='-') __c=getc();\n        if(__c=='-') __fg=-1.0,__c=getc();\n        while(isdigit(__c)) __x=__x*10.0+__c-'0',__c=getc();\n        if(__c!='.'){__x=__x*__fg;return;}else while(!isdigit(__c)) __c=getc();\n        double __t=1e-1;while(isdigit(__c)) __x=__x+1.0*(__c-'0')*__t,__t=__t*0.1,__c=getc();\n        __x=__x*__fg;\n    }\n    inline void reads(char *__s,int __x)\n    {\n        char __c=getc();int __tot=__x-1;\n        while(__c<'a'||__c>'z') __c=getc();\n        while(__c>='a'&&__c<='z') __s[++__tot]=__c,__c=getc();\n        __s[++__tot]='\\0';\n    }\n    char __obuf[__S],*__oS=__obuf,*__oT=__oS+__S-1,__c,__qu[55];int __qr;\n    inline void flush(){fwrite(__obuf,1,__oS-__obuf,stdout);__oS=__obuf;}\n    inline void putc(char __x){*__oS++ =__x;if(__oS==__oT) flush();}\n    template <class __I>inline void print(__I __x)\n    {\n        if(!__x) putc('0');\n        if(__x<0) putc('-'),__x=-__x;\n        while(__x) __qu[++__qr]=__x%10+'0',__x/=10;\n        while(__qr) putc(__qu[__qr--]);\n    }\n    inline void prints(const char *__s,const int __x)\n    {\n        int __len=strlen(__s+__x);\n        for(int __i=__x;__i<__len+__x;__i++) putc(__s[__i]);\n    }\n    inline void printd(long double __x,int __d)\n    {\n        long long __t=(long long)floor(__x);print(__t);putc('.');__x-=(double)__t;\n        while(__d--)\n        {\n            long double __y=__x*10.0;__x*=10.0;\n            int __c=(int)floor(__y+1e-9);if(__c==10) __c--;\n            putc(__c+'0');__x-=floor(__y);\n        }\n    }\n    inline void el(){putc('\\n');}inline void sp(){putc(' ');}\n}using namespace IO;\n\nint n,t,v[110],top;\nint x[200010],le[20][200010],ri[20][200010],f[1000010],g[1000010];\nint ans[1000010];\nint main(){\n\tread(n);read(t);int i,j,s;\n\tfor(i=1;i<=n;i++) read(x[i]);\n\tv[0]=t;t>>=1;\n\twhile(t){\n\t\tv[++top]=t;\n\t\tt>>=1;\n\t}\n\tv[++top]=0;\n\treverse(v,v+top+1);\n\tfor(i=0;i<=top;i++){\n\t\tle[i][1]=1;\n\t\tfor(j=2;j<=n;j++){\n\t\t\tif(x[j]-x[j-1]<=v[i]) le[i][j]=le[i][j-1];\n\t\t\telse le[i][j]=j;\n\t\t}\n\t\tri[i][n]=n;\n\t\tfor(j=n-1;j>=1;j--){\n\t\t\tif(x[j+1]-x[j]<=v[i]) ri[i][j]=ri[i][j+1];\n\t\t\telse ri[i][j]=j;\n\t\t}\n//\t\tfor(j=1;j<=n;j++) cout<<\"check \"<<i<<' '<<j<<' '<<le[j][i]<<' '<<ri[j][i]<<'\\n';\n\t}\n\tf[0]=0;g[0]=n+1;\n\tfor(s=1;s<=(1<<(top))-1;s++){\n\t\tf[s]=0;g[s]=n+1;\n\t\tfor(i=0;i<=top;i++){\n\t\t\tif(s&(1<<i)){\n\t\t\t\tj=s^(1<<i);\n\t\t\t\tif(f[j]==n) f[s]=n;\n\t\t\t\telse f[s]=max(f[s],ri[i][f[j]+1]);\n\t\t\t\tif(g[j]==1) g[s]=1;\n\t\t\t\telse g[s]=min(g[s],le[i][g[j]-1]);\n\t\t\t}\n\t\t}\n//\t\tcout<<\"dp \"<<s<<' '<<f[s]<<' '<<g[s]<<'\\n';\n\t}\n\tfor(i=0;i<=n;i++) ans[i]=n+2;\n\tfor(i=0;i<=((1<<top)-1);i++){\n\t\tj=((1<<top)-1)^i;\n\t\tans[f[i]]=min(ans[f[i]],g[j]);\n\t}\n\tfor(i=n-1;i>=0;i--) ans[i]=min(ans[i],ans[i+1]);\n\tfor(i=1;i<=n;i++){\n\t\tif(ans[le[top][i]-1]<=ri[top][i]+1) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 2e5 + 5;\nconst int MAXL = 19;\nconst int MAXS = (1 << MAXL) + 5;\n\nint N, V;\nint A[MAXN];\n\nvoid input()\n{\n    read(N); read(V);\n    for (int i = 1; i <= N; ++i) {\n        read(A[i]);\n    }\n}\n\nint L;\nvector<Pii> interval[MAXL];\n\nvoid solve()\n{\n    for (int v = V; ; v >>= 1) {\n        int st = 1;\n        for (int i = 1; i <= N; ++i) {\n            if (i == N || A[i+1] - A[i] > v) {\n                interval[L].push_back(MP(st, i));\n                st = i + 1;\n            }\n        }\n        ++L;\n        if (!v)\n            break;\n    }\n\n    static int rbnd[MAXL][MAXN], lbnd[MAXL][MAXN];\n\n    for (int i = 0; i < L; ++i) {\n        rbnd[i][N+1] = N;\n        lbnd[i][0] = 1;\n        for (auto x: interval[i]) {\n            for (int j = x.x; j <= x.y; ++j) {\n                rbnd[i][j] = x.y;\n                lbnd[i][j] = x.x;\n            }\n        }\n    }\n\n    static int f[MAXS], g[MAXS];\n    int sbnd = 1 << (L - 1);\n\n    for (int s = 0; s < sbnd; ++s) {\n        f[s] = 0; g[s] = N + 1;\n        for (int i = 1; i < L; ++i) {\n            if (s >> (i - 1) & 1) {\n                chkmax(f[s], rbnd[i][f[s^(1<<(i-1))]+1]);\n                chkmin(g[s], lbnd[i][g[s^(1<<(i-1))]-1]);\n            }\n        }\n    }\n\n    vector<Pii> cover;\n\n    for (int s = 0; s < sbnd; ++s) {\n        cover.push_back(MP(f[s], g[(sbnd-1)^s]));\n        if (f[s] + 1 >= g[(sbnd - 1) ^ s]) {\n            for (int i = 1; i <= N; ++i) {\n                puts(\"Possible\");\n            }\n            return;\n        }\n    }\n    std::sort(ALL(cover));\n    cover.resize(std::unique(ALL(cover)) - cover.begin());\n\n    static Pii q[MAXN];\n    int front = 0, rear = 0;\n\n    for (int i = 1, j = 0; i <= N; ++i) {\n        int l = lbnd[0][i], r = rbnd[0][i];\n        for (; j < SZ(cover) && cover[j].x < r; ++j) {\n            while (front < rear && q[rear-1].y >= cover[j].y) --rear;\n            q[rear++] = cover[j];\n        }\n        while (front < rear && q[front].x + 1 < l) ++front;\n        if (front < rear && q[front].y - 1 <= r)\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n    }\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"E.in\", \"r\", stdin);\n    freopen(\"E.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 时光只解催人老，不信多情，长恨离亭，泪滴春衫酒易醒。\n//     -- 晏殊《采桑子·时光只解催人老》\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,m,N,S;\nvi a,b;\n\nvi ff(int x){\n\tvi c(n);\n\tint I=0;\n\tfor(int i=0;i<n-1;i++) if(a[i+1]-a[i]>x){\n\t\twhile(I<=i) c[I++]=i;\n\t}\n\twhile(I<n) c[I++]=n-1;\n\treturn c;\n}\n\nvi f(){\n\tvi dp(S);\n\tvvi c(N);\n\tdp[0]--;\n\tfor(int i=0;i<N;i++) c[i]=ff(b[i+1]);\n\tfor(int i=0;i<S;i++) for(int j=0;j<N;j++) if(i&1<<j){\n\t\tint I=dp[i-(1<<j)];\n\t\tdp[i]=max(dp[i],(I<n-1?c[j][I+1]:n-1));\n\t}\n\treverse(a.begin(),a.end());\n\tfor(int i=0;i<n;i++) a[i]*=-1;\n\treturn dp;\n}\n\nint main(){\n\tcin>>n>>m;\n\ta=vi(n);\n\tfor(auto &i:a) cin>>i;\n\twhile(m){\n\t\tb.push_back(m);\n\t\tm/=2;\n\t}\n\tb.push_back(0);\n\tN=(int)b.size()-1;\n\tS=1<<N;\n\tvi L=f(),R=f(),c=ff(b[0]),d(n+1);\n\tfor(int i=0;i<S;i++){\n\t\tint l=L[i],r=n-R[S-i-1]-1;\n\t\tif(r<=l+1) d[0]++;\n\t\telse if(c[l+1]+1>=r){\n\t\t\td[l+1]++;\n\t\t\td[r]--;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) d[i]+=d[i-1];\t\n\tfor(int i=0;i<n;i++) cout<<(d[i]?\"Possible\":\"Impossible\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1012345678;\n\nint A[200005];\n\nint S[25];\nint sizeS = 0;\n\nint R[20][200005];\nint L[20][200005];\nbool boleh[200005];\nint minPos[200005]; // for each dpL[something] = i, the smallest possible value of dpR[not of the something]\n// 'something' is a bitmask\n\nint minPos2[200005]; // for each dpL[something] >= i, the smallest possible value of dpR[not of the something]\n// 'something' is a bitmask\n\n/* dpL[i] = maximum index from the beginning that can be covered by the intervals\ncorresponding to a subset i of intervals from S\ndpR[i] is defined similarly, just that the prefix becomes the suffix.\n*/\nint dpL[(1<<19)+5];\nint dpR[(1<<19)+5];\n\n//int B[200005];\n\nint N, V;\n\n/*\nvoid init(int i = 1, int s = 1, int e = N){\n    if(s == e){\n        B[i] = minPos[s];\n        return;\n    }\n    int l = i<<1;\n    int r = (i<<1)|1;\n    int m = (s+e)>>1;\n    init(l, s, m);\n    init(r, m+1, e);\n    B[i] = min(B[l], B[r]);\n}\n\nint rmq(int x, int y, int i = 0, int s = 1, int e = N){\n    if(s == x && e == y){\n        return B[i];\n    }\n\n    int l = i<<1;\n    int r = (i<<1)|1;\n    int m = (s+e)>>1;\n\n    if(x <= m){\n        return rmq(x, y, l, s, m);\n    }else if(y > m){\n        return rmq(x, y, r, m+1, e);\n    }\n    return min(rmq(x, y, l, s, m), rmq(x, y, r, m+1, e));\n}\n*/\n\nint main(){\n    scanf(\"%d%d\", &N, &V);\n\n    for(int i = 1; i <= N; i ++){\n        scanf(\"%d\", &A[i]);\n    }\n\n    int temp = V;\n    while(true){\n        S[sizeS ++] = temp;\n        if(temp == 0){break;}\n        temp >>= 1;\n    }\n    reverse(S, S+sizeS);\n    for(int i = 0; i < sizeS; i++){\n        //printf(\"S[%d]=%d\\n\", i, S[i]);\n    }\n\n    // S is sorted in decreasing order\n\n    // R[i][j] is the 1-indexed right-most position reachable using move distances <= S[i] from position j\n    for(int i = 0; i < sizeS; i ++){\n        R[i][N] = N;\n        L[i][1] = 1;\n        for(int j = 2; j <= N; j ++){\n            if(A[j]-A[j-1] <= S[i]){\n                L[i][j] = L[i][j-1];\n            }else{\n                L[i][j] = j;\n            }\n        }\n\n        for(int j = N-1; j >= 1; j --){\n            if(A[j+1]-A[j] <= S[i]){\n                // can reach j+1, hence can reach positions up to R[i][j+1]\n                R[i][j] = R[i][j+1];\n            }else{\n                // j and j+1 disconnected\n                R[i][j] = j;\n            }\n        }\n    }\n\n    for(int i = 0; i < (1<<sizeS); i ++){\n        dpL[i] = 1;\n        dpR[i] = N;\n\n        // Consider the last S[j] used to construct the interval\n        for(int j = 0; j < sizeS; j ++){\n            if(i&(1<<j)){\n                // Bit j is set in i.\n                int k = i^(1<<j);\n\n                // clearing bit results in an index lesser than the original index => already processed\n                dpL[i] = max(dpL[i], R[j][min(dpL[k]+1, N)]);\n                // dpL[k]+1 is first index impossible to be covered by all the previous intervals\n\n                dpR[i] = min(dpR[i], L[j][max(dpR[k]-1, 1)]);\n            }\n        }\n    }\n\n    int k = 1;\n    for(int i = 1; i <= N; i ++){\n        minPos[i] = INF;\n    }\n\n    // Now check whether it is possible to reach all the oases.\n    for(int i = 0; i < (1<<(sizeS-1)); i ++){\n        int j = (1<<(sizeS-1))-1-i;\n\n        int l = dpL[i];\n        int r = dpR[j];\n        //printf(\"dpL[%d]=%d; dpR[%d]=%d\\n\", i, l, j, r);\n        minPos[l] = min(minPos[l], r);\n    }\n\n    minPos2[N] = minPos[N];\n    for(int i = N-1; i >= 1; i --){\n        minPos2[i] = min(minPos2[i+1], minPos[i]);\n        //printf(\"minPos[%d]=%d\\n\", i, minPos[i]);\n    }\n\n    //init();\n    for(int i = 1; i <= N; i ++){\n        int l = L[sizeS-1][i];\n        int r = R[sizeS-1][i];\n\n        //printf(\"i=%d l=%d r=%d\\n\", i, l, r);\n\n        boleh[i] = minPos2[max(l-1, 1)] <= r+1;\n        if(boleh[i]){\n            printf(\"Possible\\n\");\n        }else{\n            printf(\"Impossible\\n\");\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint l[25][530000],r[25][530000],f[500010],g[530000],mi[530000],x[530000];\nint main()\n{\n\tint n,v,lim=0;scanf(\"%d%d\",&n,&v);while (v>>(lim+1)) lim++;lim++;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor (int p=0;p<=lim;p++)\n\t{\n\t\tl[p][0]=1;for (int i=1;i<=n;i++) l[p][i]=(x[i]-x[i-1]<=(v>>p))?l[p][i-1]:i;\n\t\tr[p][n+1]=n;for (int i=n;i>=1;i--) r[p][i]=(x[i+1]-x[i]<=(v>>p))?r[p][i+1]:i;\n\t}\n\tfor (int s=0;s<(1<<(lim+1));s++) g[s]=n+1;\n\tfor (int s=0;s<(1<<(lim+1));s++)\n\tfor (int i=0;i<=lim;i++) if (!(s&(1<<i)))\n\t{\n\t\tf[s|(1<<i)]=max(f[s|(1<<i)],r[i][f[s]+1]);\n\t\tg[s|(1<<i)]=min(g[s|(1<<i)],l[i][g[s]-1]);\n\t}\n\tfor (int i=0;i<=n;i++) mi[i]=n+2;\n\tfor (int i=0;i<(1<<(lim+1));i+=2) mi[f[i]]=min(mi[f[i]],g[(1<<(lim+1))-2-i]);\n\tfor (int i=n-1;i>=0;i--) mi[i]=min(mi[i],mi[i+1]);\n\tfor (int i=1;i<=n;i++) puts((mi[l[0][i]-1]<=r[0][i]+1)?\"Possible\":\"Impossible\");\n\t//for (int i=1;i<=n;i++) printf(\"%d %d %d\\n\",l[0][i],r[0][i],mi[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\n#ifdef _DEBUG\n#define dbg(x) cerr << #x << \":\" << x << endl;\n#else\n#define dbg(x) while(false){}\n#endif\n\n#define fi(a, b) for(int i=a;i<b;++i)\n#define fj(a, b) for(int j=a;j<b;++j)\n\n////////\n\nint const M = 20;\nint const N = (1<<M);\nstring const YES = \"Possible\";\nstring const NO = \"Impossible\";\n\nint n, v, x[N];\nint le[N][M], ri[N][M];\nint cnt;\nstring ans[N];\n\nvoid setAns(string val, int l, int r){\n\tfi(l, r+1) ans[i] = val;\n}\n\nvoid print(){\n\tfi(1, n+1) printf(\"%s\\n\", ans[i].c_str());\n\texit(0);\n}\n\nvoid check(){\n\tint cn = cnt + 1;\n\tint v = 1;\n\twhile(v <= n){\n\t\tv = ri[v][0] + 1;\n\t\t--cn;\n\t}\n\tif(cn < 0){\n\t\tsetAns(NO, 1, n);\n\t\tprint();\n\t}\n}\n\nvoid build(){\n\tint vi = v;\n\tfi(0, M){\n\t\tcnt = i;\n\t\tle[1][i] = x[1];\n\t\tfj(2, n+1){\n\t\t\tif(x[j] - x[j-1] <= vi) le[j][i] = le[j-1][i];\n\t\t\telse le[j][i] = j;\n\t\t}\n\t\tri[n][i] = n;\n\t\tfor(int j=n-1;j>0;--j){\n\t\t\tif(x[j+1] - x[j] <= vi) ri[j][i] = ri[j+1][i];\n\t\t\telse ri[j][i] = j;\n\t\t}\n\t\tif(vi == 0) break;\n\t\tvi /= 2;\n\t}\n}\n\nint dl[N], dr[N];\n\nvoid remax(int &a, int b){\n\ta = max(a, b);\n}\n\nvoid remin(int &a, int b){\n\ta = min(a, b);\n}\n\nvoid calcDp(){\n\tdl[0] = 0;\n\tfi(0, (1<<cnt)){\n\t\tfj(0, cnt){\n\t\t\tif((1<<j)&i) continue;\n\t\t\tint nval = dl[i];\n\t\t\tif(nval != n){\n\t\t\t\tnval = ri[dl[i]+1][j+1];\n\t\t\t}\n\t\t\tremax(dl[((1<<j)^i)], nval);\n\t\t}\n\t}\n\tfi(0, (1<<cnt)) dr[i] = n+1;\n\tfi(0, (1<<cnt)){\n\t\tfj(0, cnt){ \n\t\t\tif((1<<j)&i) continue;\n\t\t\tint nval = dr[i];\n\t\t\tif(nval != 1){\n\t\t\t\tnval = le[dr[i]-1][j+1];\n\t\t\t}\n\t\t\tremin(dr[(1<<j)^i], nval);\n\t\t}\n\t}\n}\n\nvoid findAnswers(){\n\tint v, nxt;\n\tv = 1;\n\twhile(v <= n){\n\t\tnxt = ri[v][0];\n\t\tbool can = false;\n\t\tfi(0, (1<<(cnt))){\n\t\t\tint maskL = i;\n\t\t\tint maskR = ( ((1<<(cnt))-1) ^ maskL );\n\t\t\tint lb = max(dl[maskL], 1);\n\t\t\tint rb = min(dr[maskR], n);\n\t\t\tif(lb+1 >= v && rb-1 <= nxt){\n\t\t\t\tcan = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(can){\n\t\t\tsetAns(YES, v, nxt);\n\t\t}else{\n\t\t\tsetAns(NO, v, nxt);\n\t\t}\n\t\tv = nxt + 1;\n\t}\n}\n\nvoid solve(){\n\tscanf(\"%d %d\",&n,&v);\n\tfi(1, n+1) scanf(\"%d\",&x[i]);\n\n\tbuild();\n\tdbg(cnt);\n\tcheck();\n\tcalcDp();\n\tfindAnswers();\n\tprint();\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=2e5+5;\nint n,m,a[N],l[25][N],r[25][N],v[25],cnt=0,L[1<<25],R[1<<25],ans[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tint V=m;\n\twhile(V){V>>=1;v[cnt++]=V;}v[cnt]=m;\n//\tfor(int i=1;i<=cnt;i++) printf(\"%d \",v[i]);\n\tfor(int i=0;i<=cnt;i++)\n\t{\n\t\tl[i][1]=1;\n\t\tr[i][n]=n;\n\t\tfor(int j=2;j<=n;j++) l[i][j]=(a[j]-a[j-1]<=v[i])?l[i][j-1]:j;\n\t\tfor(int j=n-1;j>=1;j--) r[i][j]=(a[j+1]-a[j]<=v[i])?r[i][j+1]:j;\n\t}\n\t/*for(int i=0;i<=cnt;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++) printf(\"%d \",l[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n//\tL[0]=1,R[0]=n;\n\tfor(int i=0;i<(1<<cnt);i++) R[i]=n+1;\n\tfor(int i=0;i<(1<<cnt);i++)\n\t\tfor(int j=0;j<=cnt;j++)\n\t\t\tif(((1<<j)&i)==0)\n\t\t\t\tL[(1<<j)|i]=max(L[(1<<j)|i],r[j][L[i]+1]),\n\t\t\t\tR[(1<<j)|i]=min(R[(1<<j)|i],l[j][R[i]-1]);\n//\tfor(int i=0;i<(1<<cnt);i++) printf(\"%d %d\\n\",L[i],R[i]);\n\t/*for(int i=0;i<(1<<cnt);i++)\n\t{\n\t\tprintf(\"!! %d %d\\n\",i,((1<<cnt)-1)^i);\n\t\tif(L[i]>=R[((1<<cnt)-1)^i]) s[R[((1<<cnt)-1)^i]]++,s[L[i]+1]--,printf(\"%d %d\\n\",R[((1<<cnt)-1)^i],L[i]);\n\t}\n\tint sum=0;\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tsum+=s[i];\n\t\tif(sum>0) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}*/ \n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int j=0;j<(1<<cnt);j++)\n\t\t{\n\t\t\tint ss=((1<<cnt)-1)^j;\n\t\t\tif(L[j]>=i-1&&R[ss]<=r[cnt][i]+1){flag=1;break;}\n\t\t}\n\t\tfor(int j=i;j<=r[cnt][i];j++)\n\t\t{\n\t\t\tif(flag) ans[j]=1;\n\t\t\telse ans[j]=0;\n\t\t}\n\t\ti=r[cnt][i];\n\t}\n\tfor(int i=1;i<=n;i++) puts(ans[i]==0?\"Impossible\":\"Possible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=2e5+50;\nint n,v,lg,x[N];\nint len[20], bin[20];\nint mxr[N*4], mnl[N*4];\n\nstruct BIT_MAX {\n\tint bit[N];\n\tinline void inc(int p,int v) {\n\t\tfor(int i=p;i<=n+1;i+=(i&(-i))) bit[i]=max(bit[i],v);\n\t}\n\tinline int ask(int p,int v=0) {\n\t\tfor(int i=p;i;i-=(i&(-i))) v=max(v,bit[i]);\n\t\treturn v;\n\t}\n\tinline void init(int lim) {\n\t\tfor(int l=1,r;l<=n;l=r+1) {\n\t\t\tr=l;\n\t\t\twhile(r<n && x[r+1]-x[r]<=lim) ++r;\n\t\t\tinc(l,r);\n\t\t}\n\t}\n} bit_max[21];\n\nstruct BIT_MIN {\n\tint bit[N];\n\tBIT_MIN() {for(int i=0;i<N;i++) bit[i]=1e9;}\n\tinline void inc(int p,int v) {\n\t\tfor(int i=p;i;i-=(i&(-i))) bit[i]=min(bit[i],v);\n\t}\n\tinline int ask(int p,int v=1e9) {\n\t\tfor(int i=p;i<=n;i+=(i&(-i))) v=min(v,bit[i]);\n\t\treturn v;\n\t}\n\tinline void init(int lim) {\n\t\tfor(int l=1,r;l<=n;l=r+1) {\n\t\t\tr=l;\n\t\t\twhile(r<n && x[r+1]-x[r]<=lim) ++r;\n\t\t\tinc(r,l);\n\t\t}\n\t}\n} bit_min[20];\n\nint ok[N];\nint main() {\n\tn=rd(), v=rd();\n\tfor(int i=1;i<=n;i++) x[i]=rd();\n\t\n\tfor(int t=v;;t/=2) {\n\t\tlen[lg++]=t;\n\t\tif(!t) break;\n\t}\n\tfor(int i=0;i<lg;i++) {\n\t\tbin[i]=1<<i;\n\t\tbit_max[i].init(len[i]);\n\t\tbit_min[i].init(len[i]);\n\t} \n\tmxr[0]=0; mnl[0]=n+1; bin[lg]=1<<lg;\n\tfor(int s=1;s<bin[lg];++s) {\n\t\tif(s&1) continue;\n\t\tint mx=0, mn=n+1;\n\t\tfor(int k=0;k<lg;++k) if(s&bin[k]) {\n\t\t\tmx=max(mx,bit_max[k].ask(mxr[s^bin[k]]+1));\n\t\t\tmn=min(mn,bit_min[k].ask(mnl[s^bin[k]]-1));\n\t\t}\n\t\tmxr[s]=mx; mnl[s]=mn;\n\t}\n\tfor(int i=0;i<bin[lg];++i) {\n\t\tif(!(i&1)) {\n\t\t\tint s1=i, s2=(bin[lg]-1)^1^i;\n\t\t\tbit_max[20].inc(mnl[s2],mxr[s1]);\n\t\t\tbit_max[20].inc(mnl[s1],mxr[s2]);\n\t\t}\n\t}\n\tfor(int l=1,r;l<=n;l=r+1) {\n\t\tr=l;\n\t\twhile(r<n && x[r+1]-x[r]<=v) ++r;\n\t\tif(bit_max[20].ask(r+1)>=l-1) for(int i=l;i<=r;i++) ok[i]=1;\n\t}\n\tfor(int i=1;i<=n;i++) puts((ok[i]) ? \"Possible\" : \"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\n#define DEBUGNO\n\nsigned main() {\n\tINIT;\n\t\n\tstd::ifstream ifs(\"test.in\");\n\n#ifndef DEBUG\n\tVAR(int, n, V);\n#else\n\tint n, V;\n\tifs >> n >> V;\n#endif\n\n\tif(false){\n\t\tstd::random_device rnd;\n\t\tstd::mt19937 mt(rnd());\n\t\tstd::uniform_int_distribution<> rand(/* min */-1000000000, /* max */1000000000);\n\t\tstd::set<int> set;\n\t\twhile (set.size() < n) set.insert(rand(mt));\n\t\tOUT(n)SP OUT(V)BR;\n\t\tfor (auto x : set) {\n\t\t\tOUT(x)SP;\n\t\t}BR;\n\n\t\treturn 0;\n\t}\n\t\n#ifndef DEBUG\n\tVEC(int, x, n);\n#else\n\tstd::vector<int> x(n);\n\tREP(i, n) ifs >> x[i];\n#endif\n\n\n\tint height = 0;\n\twhile (V >= (1 << height)) ++height;\n\theight += 2;\n\tstd::vector<std::vector<int>> right(height);\n\tint vv = V;\n\tright[0].emplace_back(x[n - 1]);\n\tFOR(h, 1, height) {\n\t\tint r = n - 1;\n\t\tRREP(i, n - 1) {\n\t\t\tif (x[i + 1] - x[i] > vv || i == 0) {\n\t\t\t\tright[h].emplace_back(x[r]);\n\t\t\t\tr = i;\n\t\t\t}\n\t\t}\n\t\tif (x[1] - x[0] > vv) right[h].emplace_back(x[0]);\n\t\tstd::sort(ALL(right[h]));\n\t\tvv /= 2;\n\t}\n\tstd::vector<int> c(height + 1, 0);\n\tREP(i, height) c[i] = right[i].size();\n\tREP(i, height - 1) c[i + 1] += c[i];\n\tstd::rotate(c.rbegin(), c.rbegin() + 1, c.rend());\n\n\tstd::vector<std::vector<int>> g(1);\n\tg.reserve(n*height);\n\tint p = 0;\n\tFOR(h, 1, height) {\n\t\tfor (auto v : right[h]) {\n\t\t\t++p;\n\t\t\tauto it = std::lower_bound(ALL(right[h - 1]), v);\n\t\t\tint par = std::distance(right[h-1].begin(), it) + c[h-1];\n\t\t\tg.emplace_back(std::vector<int>{});\n\t\t\t//g[s].emplace_back(t);\n\t\t\tg[par].emplace_back(p);\n\t\t}\n\t}\n\n\t/*SHOWVECTOR2(right);\n\n\tREP(i, g.size()) {\n\t\tfor (auto to : g[i]) {\n\t\t\tOUT(i)SP OUT(to)BR;\n\t\t}\n\t}*/\n\n\tstd::vector<int> v0;\n\tfor (auto v : g[0]) v0.emplace_back(v);\n\tstd::function<bool(std::vector<int>&, int, int)> check = [&](std::vector<int>& a, int pos, int rest) {\n\t\t//SHOWVECTOR(a);\n\t\tif (rest == 0) return true;\n\t\tif (a.empty()) return true;\n\t\tstd::vector<int> c;\n\t\tint asz = a.size();\n\t\tREP(i, asz) {\n\t\t\tauto& v = g[a[i]];\n\t\t\tREP(j, v.size()) {\n\t\t\t\tif (a[i] > v[j]) continue;\n\t\t\t\tc.emplace_back(v[j]);\n\t\t\t}\n\t\t}\n\t\tint csz = c.size();\n\t\t//std::sort(ALL(c));\n\t\tfor(auto v : a) {\n\t\t\tif (pos != -1) v = pos;\n\t\t\tif (csz - g[v].size() > rest - 1) continue;\n\t\t\tauto ts(c);\n\t\t\tfor (auto& to : g[v]) {\n\t\t\t\tif (v > to) continue;\n\t\t\t\tts.erase(std::find(ALL(ts), to));\n\t\t\t}\n\t\t\tif (check(ts, -1, rest - 1)) return true;\n\t\t\tif (pos != -1) break;\n\t\t}\n\t\treturn false;\n\t};\n\n\tstd::vector<PAIR> ok;\n\tp = 0;\n\tfor (auto& v : v0) {\n\t\tbool t = check(v0, v, height - 1);\n\t\tok.emplace_back(PAIR(right[1][p++], t));\n\t}\n\t//SHOWPAIRVECTOR(ok);\n\n\tp = 0;\n\tREP(i, n) {\n\t\tif (x[i] <= ok[p].first) {\n#ifndef DEBUG\n\t\t\tOUT(((ok[p].second) ? \"Possible\" : \"Impossible\"))BR;\n#endif\n\t\t}\n\t\tif (x[i] == ok[p].first) ++p;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 200005;\n\ninline void chmax(int &x, int y) {\n  if (x < y) x = y;\n}\n\ninline void chmin(int &x, int y) {\n  if (x > y) x = y;\n}\n\nint prefix[1 << 18], suffix[1 << 18], f[MAX_N];\nint L[25][MAX_N], R[25][MAX_N], N, V, val[25], tot, X[MAX_N];\n\nvoid work(int *l, int *r, int v) {\n  int last = 1;\n  \n  l[1] = l[0] = 1;\n  for (int i = 2; i <= N; ++i) {\n    if (X[i] - X[i - 1] > v) last = i;\n    l[i] = last;\n  }\n  \n  last = N, r[N] = r[N + 1] = N;\n  for (int i = N - 1; i >= 1; --i) {\n    if (X[i + 1] - X[i] > v) last = i;\n    r[i] = last;\n  }\n}\n\nint main() {\n  scanf(\"%d%d\", &N, &V);\n  \n  for (int i = 1; i <= N; ++i)\n    scanf(\"%d\", &X[i]);\n  \n  int temp = V;\n  \n  while (temp) {\n    val[tot++] = temp;\n    temp = temp >> 1;\n  }\n  val[tot++] = 0;\n  for (int i = 0; i < tot; ++i) \n    work(L[i], R[i], val[i]);\n  \n  int S = (1 << tot - 1) - 1;\n  for (int i = 1; i <= S; ++i) suffix[i] = N + 1;\n  \n  prefix[0] = 0, suffix[0] = N + 1;\n\n\n  for (int mask = 0; mask <= S; ++mask) {\n    for (int j = 1; j < tot; ++j)\n      if (!(mask & (1 << j - 1))) {\n\tchmax(prefix[mask | (1 << j - 1)], R[j][prefix[mask] + 1]);\n\tchmin(suffix[mask | (1 << j - 1)], L[j][suffix[mask] - 1]);\n      }\n  }\n\n  memset(f, -1, sizeof f);\n  for (int mask = 0; mask <= S; ++mask) \n    chmax(f[suffix[mask]], prefix[S ^ mask]);\n\n  for (int i = 1, mx = -1, pos = 1; i <= N; ++i) {\n    int l = L[0][i], r = R[0][i];\n    while (pos <= r + 1) chmax(mx, f[pos++]);\n    if (mx + 1 >= l) puts(\"Possible\");\n    else puts(\"Impossible\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\nconst int MAXN = 2e6 + 10;\nint N, V;\nint X[MAXN];\nint v[MAXN], vn;\nint l[19][MAXN], r[19][MAXN];\nint f[MAXN], g[MAXN], h[MAXN];\n\nint main() {\n\tregister int s, i, j;\n\tscanf(\"%d%d\", &N, &V);\n\tfor(i = 1; i <= N; ++i)\n\t\tscanf(\"%d\", X + i);\n\tv[0] = V; V >>= 1;\n\twhile(V)\n\t\tv[++vn] = V, V >>= 1;\n\tv[++vn] = 0;\n\treverse(v, v + vn + 1);\n\tfor(i = 0; i <= vn; ++i) {\n\t\tl[i][1] = 1;\n\t\tfor(j = 2; j <= N; ++j)\n\t\t\tl[i][j] = X[j] - X[j - 1] <= v[i] ? l[i][j - 1] : j;\n\t\tr[i][N] = N;\n\t\tfor(j = N - 1; j; --j)\n\t\t\tr[i][j] = X[j + 1] - X[j] <= v[i] ? r[i][j + 1] : j;\n\t}\n\tf[0] = 0; g[0] = N + 1;\n\tfor(s = 1; s <= (1 << (vn + 1)) - 1; ++s) {\n\t\tf[s] = 0; g[s] = N + 1;\n\t\tfor(i = 0; i <= vn; ++i)\n\t\t\tif(s & (1 << i)) {\n\t\t\t\tint x = s ^ (1 << i);\n\t\t\t\tf[s] = max(f[s], f[x] == N ? N : r[i][f[x] + 1]);\n\t\t\t\tg[s] = min(g[s], g[x] == 1 ? 1 : l[i][g[x] - 1]);\n\t\t\t}\n\t}\n\tfor(i = 0; i <= N; ++i)\n\t\th[i] = N + 2;\n\tfor(i = 0; i <= (1 << vn) - 1; ++i)\n\t\th[f[i]] = min(h[f[i]], g[((1 << vn) - 1) ^ i]);\n\tfor(i = N - 1; i >= 0; --i)\n\t\th[i] = min(h[i], h[i + 1]);\n\tfor(i = 1; i <= N; ++i)\n\t\tputs(h[l[vn][i] - 1] <= r[vn][i] + 1 ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n \ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n \nconst int INF = 1e9;\nconst int N = 2e5 + 10;\nconst int L = 20;\n\nint n,v,x[N],fwd[L][N], bak[L][N];\nint pref[1<<L], suf[1<<L];\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> v;\n    x[0] = -INF; x[n+1] = INF;\n    for (int i = 1; i <= n; i++) cin >> x[i];\n\n    int l = 0;\n    while (true) {\n        fwd[l][n+1] = n+1;\n        for (int i = n; i >= 1; i--) \n            fwd[l][i] = x[i+1]-x[i] <= v ? fwd[l][i+1] : i+1;\n\n        bak[l][0] = 0;\n        for (int i = 1; i <= n; i++)\n            bak[l][i] = x[i]-x[i-1] <= v ? bak[l][i-1] : i-1;\n\n        l++;\n        if (v == 0) break;\n        v /= 2;\n    }\n\n    vector<pii> seg;\n    for (int i = 1; i <= n; i = fwd[0][i]) {\n        int j = fwd[0][i];\n        seg.eb(i,j);\n    }\n\n    if (si(seg) >= l+2) {\n        forn(i,n) cout << \"Impossible\\n\";\n        return 0;\n    }\n\n    //forn(lev, l) { forsn(i,1,n+1) cerr << fwd[lev][i] << ' '; cerr << endl; }\n    //forn(lev, l) { forsn(i,1,n+1) cerr << bak[lev][i] << ' '; cerr << endl; }\n\n    for (int mask = 0; mask < (1<<l); mask++) {\n        pref[mask] = 1;\n        suf[mask] = n;\n        forn(i,l) if ((mask>>i)&1) {\n            pref[mask] = max(\n                pref[mask], \n                fwd[i][pref[mask - (1<<i)]]\n            );\n            \n            suf[mask] = min(\n                suf[mask],\n                bak[i][suf[mask - (1<<i)]]\n            );\n        }\n    }\n\n    //forn(mask, (1<<l)) {\n    //    cerr << mask << ' ' << pref[mask] << ' ' << suf[mask] << endl;\n    //}\n\n    auto ALL = (1<<l)-2;\n    for (auto lr : seg) {\n        int l,r; tie(l,r) = lr;\n        bool can_do = false;\n        for (int mask = 0; mask < (1<<l); mask += 2) {\n            int other = ALL - mask;\n            if (l <= pref[mask] && suf[other] < r) {\n                can_do = true;\n                break;\n            }\n        }\n        forn(_,r-l) cout << (can_do ? \"Possible\\n\" : \"Impossible\\n\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk make_pair\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=1e5+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,t,v,len[20],p[MAXN],Fl[1<<18],Fr[1<<18],S,a[MAXN];\nvector<int>L[20],R[20];\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),v=read(),t=log2(v)+1,S=(1<<t)-1;\n\tRep(i,1,n)p[i]=read();\n\tRep(i,0,t){\n\t\tlen[i]=i?len[i-1]/2:v;\n\t\tfor(int l=1,r;l<=n;l=r+1){\n\t\t\tfor(r=l;r<n&&p[r+1]-p[r]<=len[i];r++);\n\t\t\tL[i].pb(l),R[i].pb(r);\n\t\t}\n\t}\n\tRep(sta,0,S)Fr[sta]=n+1,Fl[sta]=0;\n\tRep(i,1,t)Fl[1<<i-1]=(*R[i].begin()),Fr[1<<i-1]=(*--L[i].end());\n\tRep(sta,1,S)Rep(j,1,t)if(~sta>>(j-1)&1){\n\t\tint t=sta|(1<<j-1),pos;\n\t\tpos=upper_bound(L[j].begin(),L[j].end(),Fl[sta]+1)-L[j].begin()-1;\n\t\tassert(pos>=0&&pos<R[j].size()),Fl[t]=max(Fl[t],R[j][pos]);\n\t\tpos=lower_bound(R[j].begin(),R[j].end(),Fr[sta]-1)-R[j].begin();\n\t\tassert(pos>=0&&pos<L[j].size()),Fr[t]=min(Fr[t],L[j][pos]);\n\t}\n\tRep(s,0,S){\n\t\tint ed=upper_bound(L[0].begin(),L[0].end(),Fl[s]+1)-L[0].begin()-1,st=lower_bound(R[0].begin(),R[0].end(),Fr[S^s]-1)-R[0].begin();\n\t\tif(st<=ed)a[st]++,a[ed+1]--;\n\t}\n\tfor(int i=0;i<L[0].size();i++){\n\t\ta[i]+=a[i-1];\n\t\tRep(j,L[0][i],R[0][i])puts(a[i]?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MN=300000+5;\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T>inline T&IN(T&in){\n\tin=0;char c=getchar();int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1;c=getchar();}\n\twhile(isdigit(c))in=in*10+c-'0',c=getchar();\n\treturn in*=f;\n}\nint n,V;\nint l[20][MN],r[20][MN];\nint x[MN],fr[MN],fl[MN],s[MN];\nvoid input(){\n\tIN(n),IN(V);\n\tfor(int i=1;i<=n;++i)IN(x[i]);\n\tint k;x[0]=INT_MIN/10,x[n+1]=INT_MAX/10;\n\tfor(k=0;V;++k,V>>=1){\n\t\tfor(int i=1;i<=n;++i)l[k][i]=x[i]-x[i-1]>V?i:l[k][i-1];\n\t\tfor(int i=n;i>=1;--i)r[k][i]=x[i+1]-x[i]>V?i:r[k][i+1];\n\t\tl[k][0]=1,r[k][n+1]=n;\n\t}\n\tfor(int i=1;i<=n;++i)l[k][i]=x[i]-x[i-1]>V?i:l[k][i-1];\n\tfor(int i=n;i>=1;--i)r[k][i]=x[i+1]-x[i]>V?i:r[k][i+1];\n\tl[k][0]=1,r[k][n+1]=n;\n\tfr[0]=n+1;\n\tfor(int st=1;st<(1<<k);++st){\n\t\tfr[st]=n;\n\t\tfor(int i=0;i<k;++i)if(st>>i&1){\n\t\t\tfl[st]=max(fl[st],r[i+1][fl[st^(1<<i)]+1]);\n\t\t\tfr[st]=min(fr[st],l[i+1][fr[st^(1<<i)]-1]);\n\t\t}\n\t}\n\tfor(int st=0;st<(1<<k);++st){\n\t\tint L=l[0][fr[((1<<k)-1)^st]-1],R=r[0][fl[st]+1];\n\t\tif(L<=R)s[L]++,s[R+1]--;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\ts[i]+=s[i-1];\n\t\tputs(s[i]?\"Possible\":\"Impossible\");\n\t}\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\n\nconst int CC = 20;\nint n, v;\nll x[220000];\nvector<int> vv;\nint gl[CC][220000];\nint gr[CC][220000];\nint dpl[(1 << CC)];\nint dpr[(1 << CC)];\nint ad[220000];\n\n\nint main() {\n\tscanf(\"%d%d\", &n, &v);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%lld\", x + i);\n\tint tmp = v;\n\twhile (tmp) {\n\t\tvv.push_back(tmp);\n\t\ttmp /= 2;\n\t}\n\tvv.push_back(tmp);\n\treverse(vv.begin(), vv.end());\n\tfor (int i = 0; i < vv.size(); ++i) {\n\t\tint pr = 0;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (j != 0 && x[j] - x[j - 1] > vv[i])\n\t\t\t\tpr = j;\n\t\t\tgl[i][j] = pr;\n\t\t}\n\t\tpr = n - 1;\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tif (j != n - 1 && x[j + 1] - x[j] > vv[i])\n\t\t\t\tpr = j;\n\t\t\tgr[i][j] = pr;\n\t\t}\n\t}\n\tint cc = vv.size();\n\tfor (int i = 0; i < (1 << cc); ++i)\n\t\tdpl[i] = 0, dpr[i] = n - 1;\n\tfor (int j = 0; j < (1 << cc); ++j) {\n\t\tfor (int i = 0; i < cc; ++i) {\n\t\t\tif ((j >> i) & 1)\n\t\t\t\tcontinue;\n\t\t\tint x = dpl[j];\n\t\t\tif (x < n)\n\t\t\t\tx = gr[i][x] + 1;\n\t\t\tdpl[j | (1 << i)] = max(dpl[j | (1 << i)], x);\n\t\t\tx = dpr[j];\n\t\t\tif (x >= 0)\n\t\t\t\tx = gl[i][x] - 1;\n\t\t\tdpr[j | (1 << i)] = min(dpr[j | (1 << i)], x);\n\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << (cc - 1)); ++i) {\n\t\tint l = dpl[i];\n\t\tint r = dpr[((1 << (cc - 1)) - 1) ^ i];\n\t\tif (l > r) {\n\t\t\t++ad[0];\n\t\t\t--ad[n];\n\t\t}\n\t\telse if (gr[cc - 1][l] >= r) {\n\t\t\t++ad[gl[cc - 1][l]];\n\t\t\t--ad[gr[cc - 1][l] + 1];\n\t\t}\n\t}\n\tint now = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tnow += ad[i];\n\t\tif (now)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, v, num[200007], val[20], l, tl[200007][20], tr[200007][20], dp1[500007], dp2[500007], s;\nint mn[200007];\nint read()\n{\n\tint num = 0, f = 1;\n\tchar c = getchar();\n\twhile ((c < '0' || c>'9') && c != '-')c = getchar();\n\tif (c == '-')f = -1, c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num * f;\n}\nint main()\n{\n\tn = read();\n\tv = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tnum[i] = read();\n\twhile (v >> l)l++;\n\tval[l] = v;\n\tfor (int i = l - 1; i >= 0; i--)\n\t\tval[i] = (val[i + 1] >> 1);\n\tfor (int i = 0; i <= l; i++)\n\t\ttl[1][i] = 1;\n\tfor (int i = 2; i <= n; i++)\n\t\tfor (int j = 0; j <= l; j++)\n\t\t\tif (num[i] - num[i - 1] > val[j])\n\t\t\t\ttl[i][j] = i;\n\t\t\telse tl[i][j] = tl[i - 1][j];\n\tfor (int i = 0; i <= l; i++)\n\t\ttr[n][i] = n;\n\tfor (int i = n - 1; i >= 1; i--)\n\t\tfor (int j = 0; j <= l; j++)\n\t\t\tif (num[i + 1] - num[i] > val[j])\n\t\t\t\ttr[i][j] = i;\n\t\t\telse tr[i][j] = tr[i + 1][j];\n\tfor (int i = 0; i < (1 << l); i++)\n\t\tfor (int j = 0; j < l; j++)\n\t\t\tif (!((i >> j) & 1))\n\t\t\t\tdp1[i ^ (1 << j)] = max(dp1[i ^ (1 << j)], dp1[i] == n ? n : tr[dp1[i] + 1][j]);\n\tmemset(dp2, 0x3f3f3f, sizeof dp2);\n\tdp2[0] = n + 1;\n\tfor (int i = 0; i < (1 << l); i++)\n\t\tfor (int j = 0; j < l; j++)\n\t\t\tif (!((i >> j) & 1))\n\t\t\t\tdp2[i ^ (1 << j)] = min(dp2[i ^ (1 << j)], dp2[i] == 1 ? 1 : tl[dp2[i] - 1][j]);\n\ts = (1 << l) - 1;\n\tmemset(mn, 0x3f3f3f, sizeof mn);\n\tfor (int i = 0; i <= s; i++)\n\t\tmn[dp1[i]] = min(mn[dp1[i]], dp2[i ^ s]);\n\tfor (int i = n; i >= 0; i--)\n\t\tmn[i] = min(mn[i], mn[i + 1]);\n\tfor (int i = 1; i <= n; i++)\n\t\tif (mn[tl[i][l] - 1] <= tr[i][l] + 1)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memset( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\nconst int MAXN = 200020;\nconst int INF = 0x3f3f3f3f;\n\nint n, m, v[20], tot, a[MAXN], d[MAXN];\nint f[MAXN][20], g[MAXN][20];\nint dpl[MAXN << 1], dpr[MAXN << 1], ans[MAXN];\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tscanf( \"%d%d\", &n, &m );\n\tfor( int i = 1 ; i <= n ; i++ ) scanf( \"%d\", &a[ i ] );\n\twhile( m ) v[ tot++ ] = m, m >>= 1;\n\tv[ tot++ ] = 0;\n\td[ 1 ] = d[ n + 1 ] = INF;\n\tfor( int i = 2 ; i <= n ; i++ ) d[ i ] = a[ i ] - a[ i - 1 ];\n\tfor( int j = 0 ; j < tot ; j++ )\n\t{\n\t\tfor( int i = 1 ; i <= n ; i++ )\n\t\t\tif( d[ i ] > v[ j ] ) f[ i ][ j ] = i;\n\t\t\telse f[ i ][ j ] = f[ i - 1 ][ j ];\n\t\tfor( int i = n ; i ; i-- )\n\t\t\tif( d[ i + 1 ] > v[ j ] ) g[ i ][ j ] = i;\n\t\t\telse g[ i ][ j ] = g[ i + 1 ][ j ];\n\t}\n\tfill( dpr, 0x3f );\n\tdpr[ 0 ] = n + 1;\n\tfor( int i = 0 ; i < ( 1 << tot ) ; i++ )\n\t\tfor( int j = 0 ; j < tot ; j++ ) if( !( i >> j & 1 ) )\n\t\t{\n\t\t\tif( dpl[ i ] >= n ) dpl[ i | ( 1 << j ) ] = n;\n\t\t\telse dpl[ i | ( 1 << j ) ] = max( dpl[ i | ( 1 << j ) ], g[ dpl[ i ] + 1 ][ j ] );\n\t\t\tif( dpr[ i ] <= 1 ) dpr[ i | ( 1 << j ) ] = 1;\n\t\t\telse dpr[ i | ( 1 << j ) ] = min( dpr[ i | ( 1 << j ) ], f[ dpr[ i ] - 1 ][ j ] );\n\t\t}\n\tfor( int i = 0 ; i < ( 1 << tot ) ; i++ )\n\t{\n\t\tif( i & 1 ) continue;\n\t\tint l = dpl[ i ], r = dpr[ ( 1 << tot ) - 1 - i - 1 ];\n\t\tif( l + 1 >= r ) ans[ 1 ]++;\n\t\telse\n\t\t{\n\t\t\tint L = f[ l + 1 ][ 0 ], R = g[ l + 1 ][ 0 ];\n\t\t\tif( R + 1 >= r ) ans[ L ]++, ans[ R + 1 ]--;\n\t\t}\n\t}\n\tfor( int i = 1, cur = 0 ; i <= n ; i++ )\n\t{\n\t\tcur += ans[ i ];\n\t\tif( cur ) puts( \"Possible\" );\n\t\telse puts( \"Impossible\" );\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2019/11/16] 15:47:41\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing uint = unsigned int;\nusing usize = std::size_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\n\ntemplate<typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename... Args>\nauto read(const usize size, Args... args)\n{\n    std::vector<decltype(read<T>(args...))> ans(size);\n    for (usize i = 0; i < size; i++) { ans[i] = read<T>(args...); }\n    return ans;\n}\ntemplate<typename... Types>\nauto reads() { return std::tuple<std::decay_t<Types>...>{read<Types>()...}; }\n#    define SHOW(...) static_cast<void>(0)\n\ntemplate<typename T>\nstd::vector<T> make_v(const usize size, const T v) { return std::vector<T>(size, v); }\ntemplate<typename... Args>\nauto make_v(const usize size, Args... args) { return std::vector<decltype(make_v(args...))>(size, make_v(args...)); }\nint main()\n{\n    const auto n = read<int>(), v = read<int>();\n    const auto x = read<ll>(n);\n    std::vector<int> vs{v};\n    for (; vs.back() > 0;) { vs.push_back(vs.back() / 2); }\n    SHOW(vs);\n    const int jump = vs.size();\n    SHOW(jump);\n    auto right = make_v(jump, n, n);\n    for (int i = 0; i < jump; i++) {\n        for (int j = (int)n - 2; j >= 0; j--) {\n            const ll dx = x[j + 1] - x[j];\n            right[i][j] = (dx <= vs[i] ? right[i][j + 1] : j);\n        }\n    }\n    SHOW(right);\n    auto left = make_v(jump, n, -1);\n    for (int i = 0; i < jump; i++) {\n        for (int j = 1; j < n; j++) {\n            const ll dx = x[j] - x[j - 1];\n            left[i][j]  = (dx <= vs[i] ? left[i][j - 1] : j);\n        }\n    }\n    SHOW(left);\n    const int mask = 1 << jump;\n    std::vector<int> rdp(mask, -1);\n    for (int m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const int pos = rdp[m] + 1;\n        for (int i = 1; i < jump; i++) {\n            if (btest(m, i)) { continue; }\n            if (rdp[m] == n - 1) {\n                chmax(rdp[m | (1 << i)], rdp[m]);\n                continue;\n            }\n            const int r = right[i][pos];\n            chmax(rdp[m | (1 << i)], r);\n        }\n    }\n    std::vector<int> ldp(mask, n);\n    for (int m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const int pos = ldp[m] - 1;\n        for (int i = 1; i < jump; i++) {\n            if (btest(m, i)) { continue; }\n            if (ldp[m] == 0) {\n                chmin(ldp[m | (1 << i)], ldp[m]);\n                continue;\n            }\n            const int l = left[i][pos];\n            chmin(ldp[m | (1 << i)], l);\n        }\n    }\n    SHOW(ldp, rdp);\n    std::vector<int> ok(n);\n    for (int m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const int l = rdp[m];\n        const int r = ldp[(mask - 2) - m];\n        SHOW(m, l, r);\n        if (l + 1 >= r) {\n            std::fill(ok.begin(), ok.end(), 1);\n            break;\n        }\n        const int r2 = right[0][l + 1];\n        const int l2 = left[0][r2 == n ? n - 1 : r2];\n        if (r2 + 1 >= r) {\n            if (r2 + 1 < n) { ok[r2 + 1]--; }\n            ok[l2 == -1 ? 0 : l2]++;\n        }\n    }\n    SHOW(ok);\n    for (int i = 1; i < n; i++) { ok[i] += ok[i - 1]; }\n    for (int i = 0; i < n; i++) { std::cout << (ok[i] > 0 ? \"Possible\" : \"Impossible\") << std::endl; }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,b,e) for(int i=(b); i <= (e); ++i)\n#define FORD(i,b,e) for(int i=(b); i >= (e); --i)\n#define REP(i,n) for(int i=0; i < (n); ++i)\n#define SIZE(c) (int) (c).size()\n#define ALL(c) (c).begin(), (c).end()\n#define PB push_back\n#define MP make_pair\n#define ST first\n#define ND second\n#define FWD(i,a,b) for (int i=(a); i<(b); ++i)\n#define BCK(i,a,b) for (int i=(a); i>(b); --i)\n#define PI 3.14159265358979311600\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\ntypedef vector < int > VI;\ntypedef vector<ll> VL;\n\ntypedef long double K;\n\nconst int N = 200005;\nconst int M = 1<<20;\nconst int inf = 1000*1000*1000 + 7;\n\nint n, v, cnt, bound;\nint a[N], f[M], g[M];\nint goLeft[N][21], goRight[N][21];\nvector<int> b;\n\nstruct SegTree {\n\tint n;\n\tvector<int> tree;\n\n\tSegTree(int n): n(n), tree(4*n, inf) {}\n\n\tvoid update(int pos, int val) {\n\t\tupdate(1, 0, n - 1, pos, val);\n\t}\n\n\tint go(int l, int r) {\n\t\treturn go(1, 0, n - 1, l, r);\n\t}\n\n\tvoid update(int v, int tl, int tr, int pos, int val) {\n\t\tif (tl == tr) {\n\t\t\ttree[v] = min(tree[v], val);\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) / 2;\n\t\tif (pos <= tm) {\n\t\t\tupdate(2*v, tl, tm, pos, val); \n\t\t} else {\t\n\t\t\tupdate(2*v+1, tm+1, tr, pos, val);\n\t\t}\n\t\ttree[v] = min(tree[2*v], tree[2*v+1]);\n\t}\n\n\tint go(int v, int tl, int tr, int l, int r) {\n\t\tif (l > tr || r < tl) return inf;\n\t\tif (l <= tl && r >= tr) return tree[v];\n\t\tint tm = (tl + tr) / 2;\n\t\treturn min(go(2*v, tl, tm, l, r), go(2*v+1, tm+1, tr, l, r));\n\t}\n};\n\nvoid calc() {\n\tREP(i, cnt) {\n\t\tREP(j, n) {\n\t\t\tgoLeft[i][j] = j;\n\t\t\tif (j > 0 && a[j] - a[j - 1] <= b[i]) {\n\t\t\t\tgoLeft[i][j] = goLeft[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tgoRight[i][j] = j;\n\t\t\tif (j < n - 1 && a[j + 1] - a[j] <= b[i]) {\n\t\t\t\tgoRight[i][j] = goRight[i][j + 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint go(int pos, int x, int side) {\n\tif (side < 0) {\n\t\treturn pos >= 0 ? goLeft[x][pos] : pos;\n\t} \n\treturn pos < n ? goRight[x][pos] : pos;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\tREP(i, n) {\n\t\tcin >> a[i];\n\t}\n\n\twhile (v > 0) {\n\t\tb.push_back(v);\n\t\tv /= 2;\n\t}\n\tb.push_back(0);\n\tcnt = (int)b.size();\n\tbound = (1 << cnt);\n\n\tcalc();\n\n\tREP(i, bound) f[i] = -inf, g[i] = inf;\n\tf[0] = 0;\n\tg[0] = n - 1;\n\n\tREP(i, bound) {\n\t\tREP(j, cnt) if (~i & (1 << j)) {\n\t\t\tif (f[i] != -inf) {\n\t\t\t\tf[i ^ (1 << j)] = max(f[i ^ (1 << j)], go(f[i], j, +1) + 1);\n\t\t\t}\n\t\t\tif (g[i] != inf) {\n\t\t\t\tg[i ^ (1 << j)] = min(g[i ^ (1 << j)], go(g[i], j, -1) - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tint all = 0;\n\n\tSegTree tree(n);\n\n\tREP(mask, bound) {\n\t\tint comp = (bound - 1) ^ mask;\n\t\tint a = (mask & 1) ? (mask ^ 1) : mask;\n\t\tint b = (comp & 1) ? (comp ^ 1) : comp;\n\t\tif (f[a] != -inf && g[b] != inf) {\n\t\t\tif (f[a] > g[b]) {\n\t\t\t\tall = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttree.update(f[a], g[b]);\n\t\t}\n\t}\n\n\tREP(i, n) {\n\t\tif (all) {\n\t\t\tcout << \"Possible\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tint lb = go(i, 0, -1);\n\t\tint rb = go(i, 0, +1);\n\t\tif (tree.go(lb, rb) <= rb) {\n\t\t\tcout << \"Possible\\n\";\n\t\t} else {\n\t\t\tcout << \"Impossible\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][30],tmp[30][30];\n\nconst int H=19260817;\nstruct hash_map\n{\n\tuint x[H];\n\tbool y[H];\n\tinline int get(uint v)\n\t{\n\t\tuint g=v%H;\n\t\tfor(;x[g]&&x[g]!=v;++g==H?g=0:0);\n\t\treturn x[g]==v?y[g]:2;\n\t}\n\tinline bool&operator[](uint v)\n\t{\n\t\tuint g=v%H;\n\t\tfor(;x[g]&&x[g]!=v;++g==H?g=0:0);\n\t\tx[g]=v;return y[g];\n\t}\n}hs;\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\tuint hash=dep;\n\tfo0(i,cnt)hash=hash*2337+s[i];\n\t{int tmp=hs.get(hash);if(tmp!=2)return tmp;}\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>=dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tif(dep<14)\n\t{\n\t\tfo0(i,uc)\n\t\t{\n\t\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\t\tr[i]=t[i];\n\t\t}\n\t\treturn hs[hash]=0;\n\t}\n\tint time=clock();\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\tr[i]=t[i];\n\t\tif((clock()-time)*10>5*CLOCKS_PER_SEC)return hs[hash]=0;\n\t}\n\treturn hs[hash]=0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for (int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T sqr(const T &a) { return a * a; }\ntypedef long long LL;\ntypedef long double LD;\nvoid procStatus() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\nLL read() {\n\tLL x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (;!isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n\tfor (;isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\treturn x * flag;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 4e5 + 9;\nint n, V, a[Maxn];\n\nvoid Init() {\n\tn = read(), V = read();\n\trep (i, 1, n) a[i] = read();\n}\n\nint pon[20][Maxn];\nint len[Maxn], lef[Maxn], rig[Maxn];\n\nint uppfind(int pos, int step) {\n\tint l = 1, r = len[step], ans = -1;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (pon[step][mid] > pos) ans = pon[step][mid], r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\treturn ans;\n}\n\nint lowfind(int pos, int step) {\n\tint l = 1, r = len[step], ans = pon[step][l];\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (pon[step][mid] < pos) ans = pon[step][mid], l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\treturn ans;\n}\n\nvoid Solve() {\n\tint cnt = 0;\n\twhile ((1 << cnt) <= V) ++cnt;\n\trep (i, 0, cnt) {\n\t\tlen[i] = 1;\n\t\trep (j, 1, n) {\n\t\t\tpon[i][len[i]] = j;\n\t\t\tif (j != n && a[j + 1] - a[j] > (V >> i)) ++len[i];\n\t\t}\n\t\tprintf(\"In %d\\n\", i);\n\t\trep (j, 1, len[i])\n\t\t\tprintf(\"%d \", pon[i][j]);\n\t\tputs(\"\");\n\t\tpon[i][len[i] + 1] = n + 1;\n\t}\n\tif (len[0] > cnt + 1) {\n\t\trep (i, 1, n) puts(\"Impossible\");\n\t\treturn ;\n\t}\n\trep (i, 0, (1 << cnt) - 1) lef[i] = 0, rig[i] = n + 1;\n\trep (i, 0, (1 << cnt) - 1) {\n\t\trep (j, 0, cnt - 1) {\n\t\t\tif ((i >> j) & 1) continue;\n\t\t\tchkmax(lef[i ^ (1 << j)], max(uppfind(lef[i], j + 1), lef[i])); // find a pointer bigger exclusively than f[i]\n\t\t\tchkmin(rig[i ^ (1 << j)], min(lowfind(rig[i] - 1, j + 1), rig[i] - 1)); // find a pointer lower exclusively than f[i]\n\t\t}\n\t\tprintf(\"%d: %d %d\\n\", i, lef[i], rig[i]);\n\t}\n\trep (i, 1, len[0]) {\n\t\tint l = pon[0][i - 1] + 1, r = pon[0][i];\n\t\tint flag = 0;\n\t\trep (j, 0, (1 << cnt) - 1) \n\t\t\tif (lef[j] >= l - 1 && rig[(1 << cnt) - 1 - j] <= r + 1) {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\trep (j, l, r) puts(flag ? \"Possible\" : \"Impossible\");\n\t}\n}\n\nint main() {\n//\tfreopen(\"bosky.in\", \"r\", stdin);\n//\tfreopen(\"bosky.out\", \"w\", stdout);\n\n\tInit();\n\tSolve();\t\n\n#ifdef Qrsikno\n//\tprocStatus();\n\tdebug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 200200;\nconst int MIN = 20;\n\nint A[MAX];\nVI V;\n\nint L[MIN][MAX];\nint R[MIN][MAX];\n\nint DP1[1<<MIN];\nint DP2[1<<MIN];\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tint n, v;\n\tscanf(\"%d%d\", &n, &v);\n\n\tFOR (i, 0, n)\n\t{\n\t\tscanf(\"%d\", &A[i]);\n\t}\n\n\twhile(v > 0)\n\t{\n\t\tV.PB(v);\n\t\tv /= 2;\n\t}\n\n\tV.PB(0);\n\n\tint m = SZ(V);\n\n\tFOR (it, 0, m)\n\t{\n\t\tint w = V[it];\n\n\t\tL[it][0] = 0;\n\n\t\tFOR (i, 1, n)\n\t\t{\n\t\t\tif (A[i] - A[i-1] <= w) L[it][i] = L[it][i-1];\n\t\t\telse L[it][i] = i;\n\t\t}\n\n\t\tR[it][n-1] = n-1;\n\t\tRFOR(i, n-1, 0)\n\t\t{\n\t\t\tif (A[i+1] - A[i] <= w) R[it][i] = R[it][i+1];\n\t\t\telse R[it][i] = i;\n\t\t}\n\t}\n\n\n\tFOR (mask, 0, 1<<m)\n\t{\n\t\tint ind = DP1[mask];\n\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tif (mask & (1<<i)) continue;\n\t\t\tint nm = mask | (1<<i);\n\t\t\tif (ind == n)\n\t\t\t{\n\t\t\t\tDP1[nm] = n;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint to = R[i][ind] + 1;\n\n\t\t\tDP1[nm] = max(DP1[nm], to);\n\t\t}\n\t}\n\n\tFOR (mask, 0, 1<<m)\n\t{\n\t\tDP2[mask] = n-1;\n\t}\n\n\tFOR (mask, 0, 1<<m)\n\t{\n\t\tint ind = DP2[mask];\n\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tif (mask & (1<<i)) continue;\n\t\t\tint nm = mask | (1<<i);\n\t\t\tif (ind == -1)\n\t\t\t{\n\t\t\t\tDP2[nm] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint to = L[i][ind] - 1;\n\t\t\tDP2[nm] = min(DP2[nm], to);\n\t\t}\n\t}\n\n\tint x = 0;\n\twhile(x < n)\n\t{\n\t\tint to = R[0][x];\n\n\t\tbool ok = false;\n\n\t\tFOR (mask, 0, 1<<m)\n\t\t{\n\t\t\tif (mask & (1<<0)) continue;\n\t\t\tint m1 = mask;\n\t\t\tint m2 = (((1<<m)-1) - (1<<0)) ^ m1;\n\n\t\t\tif (DP1[m1] >= x && DP2[m2] <= to ) ok = true;\n\t\t}\n\n\t\tstring res;\n\t\tif (ok) res = \"Possible\";\n\t\telse res = \"Impossible\";\n\n\t\twhile(x <= to)\n\t\t{\n\t\t\tprintf(\"%s\\n\", res.c_str());\n\t\t\tx++;\n\t\t}\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint K, N, V, sz[20], x[200009], maxPref[200009], pf[200009], sf[200009], lft[17][200009], rgt[17][200009];\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\", &N, &V);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &x[i]);\nfor (int i=0; (1 << i) <= V; i++)\n    sz[i] = V >> i, K = i;\nsz[++K] = 0;\nfor (int i=0; i<=K; i++)\n{\n    lft[i][1] = 1, lft[i][0] = 0;\n    for (int j=2; j<=N; j++)\n        if (x[j] - x[j - 1] <= sz[i]) lft[i][j] = lft[i][j - 1];\n        else lft[i][j] = j;\n    rgt[i][N] = N, rgt[i][N + 1] = N + 1;\n    for (int j=N - 1; j>=1; j--)\n        if (x[j + 1] - x[j] <= sz[i]) rgt[i][j] = rgt[i][j + 1];\n        else rgt[i][j] = j;\n}\nint lim = 1 << K;\nfor (int i=0; i < lim; i++)\n    sf[i] = N + 1;\nfor (int msk = 0; msk < lim; msk ++)\n    for (int i=0; i<K; i++)\n        if ((msk & (1 << i)) == 0)\n            pf[msk | (1 << i)] = max (pf[msk | (1 << i)], (pf[msk] <= N ? rgt[i + 1][pf[msk] + 1] : N + 1)),\n            sf[msk | (1 << i)] = min (sf[msk | (1 << i)], (sf[msk] >= 1 ? lft[i + 1][sf[msk] - 1] : 0));\nfor (int i=0; i<=N + 1; i++)\n    maxPref[i] = -N;\nfor (int i=0; i<lim; i++)\n    maxPref[sf[i]] = max (maxPref[sf[i]], pf[(lim - 1) ^ i]);\nfor (int i=1; i<=N + 1; i++)\n    maxPref[i] = max (maxPref[i - 1], maxPref[i]);\nfor (int i=1; i<=N; i++)\n    if (maxPref[rgt[0][i] + 1] >= lft[0][i] - 1) printf (\"Possible\\n\");\n    else printf (\"Impossible\\n\");\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MN 200005\n#define MM (1<<18)\n#define ML 19\nusing namespace std;\ninline int in(){\n    int x=0;bool f=0; char c;\n    for (;(c=getchar())<'0'||c>'9';f=c=='-');\n    for (x=c-'0';(c=getchar())>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0');\n    return f?-x:x;\n}\nint L[ML][MN],R[ML][MN],f[MM],g[MM],x[MN];\nbool vis[MM];\nint n,v,j,val;\nint main()\n{\n\tn=in();v=in();\n\tfor (int i=1;i<=n;++i) x[i]=in();\n\tfor (j=0,val=v;;val>>=1,++j){\n\t\tL[j][0]=L[j][1]=1;\n\t\tR[j][n]=R[j][n+1]=n;\n\t\tfor (int i=2;i<=n;++i)\n\t\tif (x[i]-x[i-1]>val) L[j][i]=i;else L[j][i]=L[j][i-1];\n\t\tfor (int i=n-1;i;--i)\n\t\tif (x[i+1]-x[i]>val) R[j][i]=i;else R[j][i]=R[j][i+1];\n\t\tif (!val) break;\n\t}for (int i=0;i<(1<<j);++i) f[i]=0,g[i]=n+1;\n\tfor (int i=0;i<(1<<j);++i){\n\t\tfor (int k=0;k<j;++k) if (!(i&(1<<k))){\n\t\t\tf[(i|(1<<k))]=max(f[i|(1<<k)],R[k+1][f[i]+1]);\n\t\t\tg[(i|(1<<k))]=min(g[i|(1<<k)],L[k+1][g[i]-1]);\n\t\t}\n\t}\n\tfor (int i=0;i<(1<<j);++i)\n\tif (R[0][f[i]+1]>=g[((1<<j)-1)^i]-1) vis[R[0][f[i]+1]]=1;\n\tfor (int i=1;i<=n;++i) puts(vis[R[0][i]]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define ll      long long\n\nint x[202020];\nint l[202020][20], r[202020][20];\nint dpl[1 << 20], dpr[1 << 20];\n\nvoid solve() {\n        int n, v;\n        cin >> n >> v;\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        int p;\n        for (int i = 0; ; i ++) if ((1 << i) > v) {\n                p = i + 1;\n                break;\n        }\n        for (int i = 0; i < n; i ++) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == 0 || x[i] - x[i - 1] > vv) l[i][j] = i;\n                        else l[i][j] = l[i - 1][j];\n                        vv /= 2;\n                }    \n        }\n        for (int i = n - 1; i >= 0; i --) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == n - 1 || x[i + 1] - x[i] > vv) r[i][j] = i;\n                        else r[i][j] = r[i + 1][j];\n                        vv /= 2;\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpr[i] == n) dpr[i | (1 << j)] = n;\n                        else dpr[i | (1 << j)] = max(dpr[i | (1 << j)], r[dpr[i]][j] + 1);\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) dpl[i] = n - 1;\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpl[i] == -1) dpl[i | (1 << j)] = -1;\n                        else dpl[i | (1 << j)] = min(dpl[i | (1 << j)], l[dpl[i]][j] - 1);\n                }\n        }\n        bool ok = false;\n        for (int i = 0; i < n; i ++) {\n                if (l[i][0] == i) {\n                        int c = 0;\n                        for (int j = 0; j < (1 << p); j ++) {\n                                c ++;\n                                if (j & 1) continue;\n                                if (i > 0 && dpr[j] < i) continue;\n                                if (r[i][0] < n - 1 && dpl[(1 << p) - 2 - j] > r[i][0]) continue;\n                                break;\n                        }\n                        if (c < (1 << p)) ok = true;\n                        else ok = false;\n                }\n                if (ok) cout << \"Possible\" << endl;\n                else cout << \"Impossible\" << endl;\n        }\n        return;\n}\n\nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        //int T;\n        //freopen(\"a.in\", \"r\", stdin);\n        //cin >> T;\n        //while (T --) solve();\n        solve();\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(f, x, ...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\ntemplate <typename UnaryPredicate>\nll binsearch(ll l, ll r, UnaryPredicate p) { // [l, r), p is monotone\n    assert (l < r);\n    -- l;\n    while (r - l > 1) {\n        ll m = (l + r) / 2;\n        (p(m) ? r : l) = m;\n    }\n    return r; // = min { x | p(x) }\n}\n\nint main() {\n    // input\n    int n, v; scanf(\"%d%d\", &n, &v);\n    vector<int> x(n); repeat (i, n) scanf(\"%d\", &x[i]);\n    // solve\n    vector<int> vs;\n    for (int cur_v = v; cur_v > 0; cur_v /= 2) vs.push_back(cur_v);\n    vs.push_back(0);\n    whole(reverse, vs);\n    int k = vs.size();\n    vector<vector<pair<int, int> > > range(k); // [l, r]\n    repeat (l, n) {\n        range[0].emplace_back(l, l);\n    }\n    repeat (i, k-1) {\n        int v = vs[i+1]; // shadowing\n        for (int j = 0; j < range[i].size(); ) {\n            int l1, r1; tie(l1, r1) = range[i][j];\n            ++ j;\n            while (j < range[i].size()) {\n                int l2, r2; tie(l2, r2) = range[i][j];\n                assert (r1 + 1 == l2);\n                if (x[l2] - x[r1] <= v) {\n                    r1 = r2;\n                    ++ j;\n                } else {\n                    break;\n                }\n            }\n            range[i+1].emplace_back(l1, r1);\n        }\n    }\n    vector<int> dp_l(1 << (k-1));\n    vector<int> dp_r(1 << (k-1), n-1);\n    repeat (s, 1 << (k-1)) {\n        repeat (i, k-1) if (not (s & (1 << i))) {\n            int t = s | (1 << i);\n            int jr = binsearch(0, range[i].size(), [&](ll j) {\n                int l, r; tie(l, r) = range[i][j];\n                return dp_l[s] < l;\n            }) - 1;\n            int jl = binsearch(0, range[i].size(), [&](ll j) {\n                int l, r; tie(l, r) = range[i][j];\n                return dp_r[s] <= r;\n            });\n            setmax(dp_l[t], jr < range[i].size() ? range[i][jr].second + 1 :  n);\n            setmin(dp_r[t], jl < range[i].size() ? range[i][jl].first  - 1 : -1);\n        }\n    }\n    // output\n    for (auto it : range[k-1]) {\n        int l, r; tie(l, r) = it;\n        bool possible = false;\n        repeat (s, 1 << (k-1)) {\n            int t = ((1 << (k-1)) - 1) & ~ s;\n            if (l <= dp_l[s] and dp_r[t] <= r) {\n                possible = true;\n                break;\n            }\n        }\n        repeat (i, r - l + 1) {\n            printf(\"%s\\n\", possible ? \"Possible\" : \"Impossible\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 524289\nusing namespace std;\nint s[maxn][20],t[maxn][20];\nint dpl[maxn],dpr[maxn],tag[maxn],n,v,x[maxn],y[20],mx,p;\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tdo{y[p++]=v;}while(v/=2);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n\tfor(int i=0;i<p;++i)\n\t\tfor(int j=1,k,l;j<=n;j=k){\n\t\t\tfor(k=j+1;k<=n&&x[k]-x[k-1]<=y[i];k++);\n\t\t\tfor(l=j;l<k;l++)s[l][i]=k-1,t[l][i]=j;\n//\t\t\tprintf(\"[%d,%d,%d,(%d,%d)]\",y[i],j,k-1,x[k],x[k-1]);\n\t\t}\n\tdpl[0]=0,dpr[0]=n+1;\n\tfor(int i=1;i<(1<<p);i++)if(~i&1){\n\t\tdpl[i]=1,dpr[i]=n;\n\t\tfor(int j=0;j<p;++j)if(i&(1<<j))\n\t\t\tdpl[i]=max(dpl[i],dpl[i^(1<<j)]==n?n:s[dpl[i^(1<<j)]+1][j]),\n\t\t\tdpr[i]=min(dpr[i],dpr[i^(1<<j)]==1?1:t[dpr[i^(1<<j)]-1][j]);\n//\t\tprintf(\"[l=%d,r=%d]\\n\",dpl[i],dpr[i]);\n\t}\n\tdpl[0]=s[1][0],dpr[0]=t[n][0];\n\tfor(int i=1;i<(1<<p);++i)if(~i&1){\n\t\tint l=dpl[i],r=dpr[(1<<p)-1-i-1];\n//\t\tprintf(\"<%d,%d,%d>\\n\",l,r,s[l+1][0]);\n\t\tif(l+1>=r)tag[1]++;//,printf(\"[ok,%d,%d]\",l,r);\n\t\telse if(s[l+1][0]+1>=r)tag[t[l+1][0]]++,tag[s[l+1][0]+1]--;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tmx+=tag[i];\n\t\tif(mx>0)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//第8回シンデレラガール総選挙は是非本田未央ちゃんに投票をお願いします！\n//ファンのことも他のアイドルの子たちのことも本当に大事にしてて、今まで周りに色んなものを与えてくれました。\n//今度は私たちが未央ちゃんにお返しをする番です。みんなでガラスの靴を履かせてあげましょう！\n// #本田未央を一番星に #本田未央を令和のシンデレラガールに #第8回シンデレラガール総選挙\n#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint x[252521];\nint ne[252521][20],rne[252521][20];\nint dp[(1<<20)+10],rdp[(1<<20)+10];\nvector<int> v;\nint main()\n{\n\tint n,V;\n\tcin>>n>>V;\n\trep(i,n) cin>>x[i];\n\twhile(V>0){\n\t\tv.pb(V);V/=2;\n\t}\n\tv.pb(0);int m=v.size();\n\trep(i,n) rep(j,m){\n\t\trne[i][j]=i;\n\t\tif(i>0 && x[i]-x[i-1]<=v[j]) rne[i][j]=rne[i-1][j];\n\t}\n\tfor(int i=n-1;i>=0;i--) rep(j,m){\n\t\tne[i][j]=i;\n\t\tif(i<n-1 && x[i+1]-x[i]<=v[j]) ne[i][j]=ne[i+1][j];\n\t}\n\tmemset(dp,0,sizeof(dp));\n\trep(i,(1<<20)+5) rdp[i]=n-1;\n\trep(i,(1<<m)) rep(j,m){\n\t\tif((i&(1<<j))>0) continue;\n\t\tdp[i+(1<<j)]=max(dp[i+(1<<j)],dp[i]>=n?n:ne[dp[i]][j]+1);\n\t\trdp[i+(1<<j)]=min(rdp[i+(1<<j)],rdp[i]<0?-1:rne[rdp[i]][j]-1);\n\t}\n\t//rep(i,(1<<m)) cout<<i<<' '<<dp[i]<<' '<<rdp[i]<<endl;\n\tif(dp[(1<<m)-1]<n){\n\t\t//assert(dp[(1<<m)-1]<n && rdp[(1<<m)-1]>=0);\n\t\trep(i,n) cout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tint now=0;\n\twhile(now<n){\n\t\tint f=0;\n\t\trep(i,(1<<(m-1))){\n\t\t\tif(dp[(1<<m)-2-(i<<1)]>=now && rdp[(i<<1)]<=ne[now][0]) f=1;\n\t\t}\n\t\tREP(i,now,ne[now][0]+1){\n\t\t\tif(f>0) cout<<\"Possible\"<<endl;\n\t\t\telse cout<<\"Impossible\"<<endl;\n\t\t}\n\t\tnow=ne[now][0]+1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define F(i,j,n) for(register int i=j;i<=n;i++)\n#define D(i,j,n) for(register int i=j;i>=n;i--)\n#define ll long long\n#define N 200010\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;int f;\n\tchar gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void gi(I&x){\n\t\tfor(f=1,c=gc();c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n};\nusing io::gi;\nusing io::gc;\nint f[N],s[N],nxt[20][N],g[20][20],x[N],n,m,h,v,d,p;\nvoid pre(int v){\n\tif(!v)return;pre(v/2);\n\th=0;d++;\n\tF(i,1,m)\n\t\tif(x[f[i]]>v)f[++h]=f[i];\n\t\telse nxt[d][f[i-1]]=f[i];\n\tm=h;\n//\tF(i,1,m)printf(\"%d \",f[i]);puts(\"\");\n}\nint dfs(int d,int m){\n\tif(!m)return 1;int h=0;\n//\tF(i,1,m)printf(\"%d \",g[d][i]);puts(\"\");\n\tF(i,1,m)for(int j=g[d][i];j;j=nxt[d][j]){\n\t\ts[++h]=j;\n\t\tif(h>d)return 0;\n\t}\n//\tF(i,1,h)printf(\"%d \",s[i]);puts(\"\\n\");\n\tif(h==1)return 1;\n\tF(i,1,h)g[d][i]=s[i];\n\tF(i,1,h){\n\t\tm=0;\n\t\tF(j,1,h)if(j!=i)g[d-1][++m]=g[d][j];\n\t\tif(dfs(d-1,m))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tgi(n);gi(v);\n\tF(i,1,n)gi(x[i]);\n\tD(i,n,2)x[i]-=x[i-1];\n\tx[1]=v+1;F(i,1,n)f[++m]=i;\n\tpre(v);f[m+1]=n+1;\n//\tprintf(\"%d\\n\",d);\n//\tF(i,1,d){F(j,1,n)printf(\"%d \",nxt[i][j]);puts(\"\");}puts(\"\");\n\tif(m>d+1){F(i,1,n)puts(\"Impossible\");return 0;}\n\tF(i,1,m){\n\t\th=0;\n\t\tF(j,1,m)if(j!=i)g[d][++h]=f[j];\n\t\tp=dfs(d,h);\n\t\tF(j,f[i],f[i+1]-1)puts(p?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2019/11/16] 15:47:41\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing uint = unsigned int;\nusing usize = std::size_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\n\ntemplate<typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename... Args>\nauto read(const usize size, Args... args)\n{\n    std::vector<decltype(read<T>(args...))> ans(size);\n    for (usize i = 0; i < size; i++) { ans[i] = read<T>(args...); }\n    return ans;\n}\ntemplate<typename... Types>\nauto reads() { return std::tuple<std::decay_t<Types>...>{read<Types>()...}; }\n#    define SHOW(...) static_cast<void>(0)\n\ntemplate<typename T>\nstd::vector<T> make_v(const usize size, const T v) { return std::vector<T>(size, v); }\ntemplate<typename... Args>\nauto make_v(const usize size, Args... args) { return std::vector<decltype(make_v(args...))>(size, make_v(args...)); }\nint main()\n{\n    const auto n = read<int>(), v = read<int>();\n    const auto x = read<ll>(n);\n    std::vector<int> vs{v};\n    for (; vs.back() > 0;) { vs.push_back(vs.back() / 2); }\n    SHOW(vs);\n    const int jump = vs.size();\n    SHOW(jump);\n    auto right = make_v(jump, n, n);\n    for (int i = 0; i < jump; i++) {\n        for (int j = (int)n - 2; j >= 0; j--) {\n            const ll dx = x[j + 1] - x[j];\n            right[i][j] = (dx <= vs[i] ? right[i][j + 1] : j);\n        }\n    }\n    SHOW(right);\n    auto left = make_v(jump, n, -1);\n    for (int i = 0; i < jump; i++) {\n        for (int j = 1; j < n; j++) {\n            const ll dx = x[j] - x[j - 1];\n            left[i][j]  = (dx <= vs[i] ? left[i][j - 1] : j);\n        }\n    }\n    SHOW(left);\n    const int mask = 1 << jump;\n    std::vector<int> rdp(mask, -1);\n    for (int m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const int pos = rdp[m] + 1;\n        for (int i = 1; i < jump; i++) {\n            if (btest(m, i)) { continue; }\n            if (rdp[m] == n - 1) {\n                chmax(rdp[m | (1 << i)], rdp[m]);\n                continue;\n            }\n            const int r = right[i][pos];\n            chmax(rdp[m | (1 << i)], r);\n        }\n    }\n    std::vector<int> ldp(mask, n);\n    for (int m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const int pos = ldp[m] - 1;\n        for (int i = 1; i < jump; i++) {\n            if (btest(m, i)) { continue; }\n            if (ldp[m] == 0) {\n                chmin(ldp[m | (1 << i)], ldp[m]);\n                continue;\n            }\n            const int l = left[i][pos];\n            chmin(ldp[m | (1 << i)], l);\n        }\n    }\n    SHOW(ldp, rdp);\n    std::vector<int> ok(n);\n    for (int m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const int l = rdp[m];\n        const int r = ldp[(mask - 2) - m];\n        SHOW(m, l, r);\n        if (l + 1 >= r) {\n            std::fill(ok.begin(), ok.end(), 1);\n            break;\n        }\n        const int r2 = right[0][l + 1 == n ? n - 1 : l + 1];\n        const int l2 = left[0][r2 == n ? n - 1 : r2];\n        if (r2 + 1 >= r) {\n            if (r2 + 1 < n) { ok[r2 + 1 == n ? n - 1 : r2 + 1]--; }\n            ok[l2 == -1 ? 0 : l2]++;\n        }\n    }\n    SHOW(ok);\n    for (int i = 1; i < n; i++) { ok[i] += ok[i - 1]; }\n    for (int i = 0; i < n; i++) { std::cout << (ok[i] > 0 ? \"Possible\" : \"Impossible\") << std::endl; }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)\n#define trav(it, v) for(typeof((v).begin()) it = (v).begin(); it != (v).end(); ++it)\n#define all(v) (v).begin(), (v).end()\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n\ntypedef double fl;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\t\nint N, V;\nint x[200005];\nint nodeInd;\n\nstruct Node{\n\tint l, r;\n\tint v;\n\tvector<Node> children;\n\tint ind;\n\tint stepsUntilSplit;\n\n\tNode(int _l, int _r, int _v){\n\t\tind=nodeInd++;\n\t\tl=_l;\n\t\tr=_r;\n\t\tv=_v;\n\t\tstepsUntilSplit=1000000;\n\t\tif(!v){\n\t\t\treturn;\n\t\t}\n\t\tint L=l;\n\t\trep(i,l+1,r){\n\t\t\tif(x[i] > x[i-1]+v){\n\t\t\t\tchildren.push_back(Node(L, i, v/2));\n\t\t\t\tL=i;\n\t\t\t}\n\t\t}\n\t\tchildren.push_back(Node(L, r, v/2));\n\t\tstepsUntilSplit=min(stepsUntilSplit, children.back().stepsUntilSplit+1);\n\t\tif(children.size() > 1)\n\t\t\tstepsUntilSplit=0;\n\t}\n};\n\nbool ans[200005];\nmap<vector<int>, bool> cache;\nvector<Node*> deleted;\n\nbool rec(vector<Node*> nodes, int stepsLeft, bool init){\n\tif(deleted.size() >= 2){\n\t\tNode* d1 = deleted[deleted.size()-2];\n\t\tNode* d2 = deleted[deleted.size()-1];\n\t\tif(d1->stepsUntilSplit > d2->stepsUntilSplit+2)\n\t\t\treturn false;\n\t}\n\tvector<int> key;\n\trep(i,0,nodes.size()){\n\t\tkey.push_back(nodes[i]->ind);\n\t}\n\tif(cache.count(key))\n\t\treturn cache[key];\n\tif(nodes.empty())\n\t\treturn true;\n\tif(nodes[0]->v == 0)\n\t\treturn nodes.size() == 1;\n\tvector<Node*> newNodes;\n\trep(i,0,nodes.size()){\n\t\tif(newNodes.size()+nodes[i]->children.size() > stepsLeft)\n\t\t\treturn 0;\n\t\trep(j,0,nodes[i]->children.size())\n\t\t\tnewNodes.push_back(&(nodes[i]->children[j]));\n\t}\n\t/*bool hasUrgent=false;\n\trep(i,0,newNodes.size())\n\t\tif(newNodes[i]->children.size() > 1)\n\t\t\thasUrgent = true;*/\n\trep(i,0,newNodes.size()){\n\t\tvector<Node*> newNewNodes = newNodes;\n\t\tnewNewNodes.erase(newNewNodes.begin()+i);\n\t\tdeleted.push_back(newNodes[i]);\n\t\tif(rec(newNewNodes, stepsLeft-1, 0)){\n\t\t\tif(init){\n\t\t\t\trep(j,newNodes[i]->l,newNodes[i]->r)\n\t\t\t\t\tans[j]=true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcache[key]=true;\n\t\t\t\tdeleted.pop_back();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tdeleted.pop_back();\n\t}\n\tcache[key]=false;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\", &N, &V);\n\trep(i,0,N)\n\t\tscanf(\"%d\", x+i);\n\tNode start(0, N, V);\n\tvector<Node*> v;\n\tv.push_back(&start);\n\tint stepsLeft=20;\n\trec(v,stepsLeft,1);\n\trep(i,0,N){\n\t\tputs(ans[i]?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=2e5+5;\nint n,m;\nint V[20],x[maxn],R[maxn][20],L[maxn][20];\nint S1[maxn],S2[maxn];\nint minL[maxn];\nint main(){\n\tread(n);read(V[0]);\n\trep(i,1,n)read(x[i]);\n\twhile(V[m])V[m+1]=V[m]/2,m++;\n\tm++;\n\trep2(i,0,m){\n\t\tR[n+1][i]=n;\n\t\tR[n][i]=n;\n\t\tper(j,n-1,1)\n\t\t\tif(x[j+1]-x[j]<=V[i])R[j][i]=R[j+1][i];\n\t\t\telse R[j][i]=j;\n\t\tL[0][i]=1;\n\t\tL[1][i]=1;\n\t\trep(j,2,n)\n\t\t\tif(x[j]-x[j-1]<=V[i])L[j][i]=L[j-1][i];\n\t\t\telse L[j][i]=j;\n\t}\n\trep2(i,0,1<<m)S2[i]=n+1,S1[i]=0;\n\trep2(i,1,1<<m){\n\t\trep2(j,0,m)if(i>>j&1){\n\t\t\tint last=S1[i^(1<<j)];\n\t\t\tS1[i]=max(S1[i],R[last+1][j]);\n\t\t}\n\t\trep2(j,0,m)if(i>>j&1){\n\t\t\tint last=S2[i^(1<<j)];\n\t\t\tS2[i]=min(S2[i],L[last-1][j]);\n\t\t}\n\t}\n\trep(i,0,n)minL[i]=n+2;\n\trep2(i,0,1<<m){\n\t\tif(i>>0&1)continue;\n\t\tint R=S1[i],L=S2[((1<<m)-1)^i^(1<<0)];\n\t\tminL[R]=min(minL[R],L);\n\t}\n\tper(i,n-1,0)minL[i]=min(minL[i],minL[i+1]);\n\trep(i,1,n){\n\t\tint rL=L[i][0],rR=R[i][0];\n\t\tif(minL[rL-1]<=rR+1)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*====Corycle====*/\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<map>\n#define ll long long\n#define pii pair<int,int>\n#define fst first\n#define scd second\n#define mp make_pair\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int Maxn=(1<<19)+5;\nconst int N=2e5+5;\nconst int M=20;\nint read(){\n\tint s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}\n\treturn s*f;\n}\npii P[N];\nint n,V,cnt,tot,Sta,a[N],L[N][M],R[N][M],Ans[N],FL[Maxn],FR[Maxn];\nint main(){\n//\tfreopen(\"_.in\",\"r\",stdin);\n//\tfreopen(\"_.out\",\"w\",stdout);\n\tn=read();V=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();a[0]=-inf-v-1;a[n+1]=inf+v+1;\n\tfor(int v=V;;v>>=1){\n\t\ttot++;L[tot][0]=0;R[tot][n+1]=n+1;\n\t\tfor(int i=1;i<=n;i++)L[tot][i]=(a[i]-a[i-1]<=v?L[tot][i-1]:i);\n\t\tfor(int i=n;i>=1;i--)R[tot][i]=(a[i+1]-a[i]<=v?R[tot][i+1]:i);\n\t\tif(v==0)break;\n\t}\n\tSta=(1<<tot)-1;\n\tfor(int i=1;i<=n;i++)P[i]=mp(L[1][i],R[1][i]);\n\tsort(P+1,P+n+1);cnt=unique(P+1,P+n+1)-P-1;\n\tfor(int S=0;S<=Sta;S++){FL[S]=0;FR[S]=n+1;}\n\tfor(int S=0;S<=Sta;S+=2){\n\t\tfor(int i=1;i<=tot;i++){\n\t\t\tif(!((S>>(i-1))&1))continue;\n\t\t\tFL[S]=max(FL[S],R[i][FL[S^(1<<(i-1))]+1]);\n\t\t\tFR[S]=min(FR[S],L[i][FR[S^(1<<(i-1))]-1]);\n\t\t}\n\t}\n\tif(cnt>tot){for(int i=1;i<=tot;i++)puts(\"Impossible\");return 0;}\n\tfor(int i=1;i<=cnt;i++){\n\t\tfor(int S=0;S<=Sta;S+=2){\n\t\t\tif(FL[S]>=P[i].fst-1&&FR[Sta^S^1]<=P[i].scd+1){\n\t\t\t\tfor(int j=P[i].fst;j<=P[i].scd;j++)Ans[j]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)puts(Ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define N 220000\nusing namespace std;\nint f[N][24],g[N][24];\nint tot,sum[N],n,v,a[N],b[N];\nint l[N],r[N];\nint check(int x,int y){\n\tx++;\n\tif(f[x][tot]<y-1)return 0;\n\ty=f[x][tot];\n\tx=g[y][tot];\n\tsum[x]++;\n\tsum[y+1]--;\n}\nint cal(){\n\tmemset(r,0x7f,sizeof(r));\n\tmemset(l,0,sizeof(l));\n\tr[0]=n;\n\tfor(int i=0;i<1<<tot;i++){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(i&(1<<(j-1)))continue;\n\t\t\tl[i|(1<<(j-1))]=max(l[i|(1<<(j-1))],f[l[i]+1][j]);\n\t\t\tr[i|(1<<(j-1))]=min(r[i|(1<<(j-1))],g[r[i]-1][j]);\t\n\t\t}\n\t}\n\tint o=(1<<(tot-1))-1;\n\tfor(int i=0;i<=o;i++){\n\t\tcheck(l[i],r[o^i]);\n\t}\n\tfor(int i=1;i<=n;i++)sum[i]+=sum[i-1];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\twhile(v)b[++tot]=v,v/=2;\n\tb[++tot]=v;\n\tsort(b+1,b+1+tot);\n\tfor(int i=1;i<=tot;i++)f[n][i]=n;\n\tfor(int i=n-1;i>=1;i--){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(a[i+1]-a[i]<=b[j])f[i][j]=f[i+1][j];\n\t\t\telse f[i][j]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot;i++)g[1][i]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(a[i]-a[i-1]<=b[j])g[i][j]=g[i-1][j];\n\t\t\telse g[i][j]=i;\n\t\t}\n\t}\n\tcal();\n\tfor(int i=1;i<=n;i++){\n\t\tif(sum[i]>0)printf(\"POSSIBLE\\n\");\n\t\telse printf(\"IMPOSSIBLE\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=4E5+5;\n\nint N,M,K,V;\nint a[Maxn];\nint F[Maxn],G[Maxn];\nint L[25][Maxn],R[25][Maxn];\n//char Ans[50],_1[50]={\"Possible\"},_2[50]={\"Impossible\"};\nint nxt[Maxn];\n\ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n\nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1)\n\t\t\t\tMAX(F[i],R[M-j][min(F[i-(1<<j)]+1,N)]),\n\t\t\t\tMIN(G[i],L[M-j][max(G[i-(1<<j)]-1,1)]);\n\t}\n/*\tfor(int i=1;i<=N;++i)\n\t\tK+=(L[0][i]!=L[0][i-1]);\n\tif(K>20){\n\t\tfor(int i=1;i<=N;++i)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=1,j;i<=N;++i)\n\t\tif(L[0][i]!=L[0][i-1]){\n\t\t\tfor(j=0;j<(1<<M);++j)\n\t\t\t\tif(F[j]>=L[0][i]-1 && G[(1<<M)-1-j]<=R[0][i]+1)\n\t\t\t\t\t{memcpy(Ans,_1,sizeof(_1)); break ;}\n\t\t\tif(j==1<<M) memcpy(Ans,_2,sizeof(_2));\n\t\t\tprintf(\"%s\\n\",Ans);\n\t\t}else printf(\"%s\\n\",Ans);*/\n\tmemset(nxt,-1,sizeof(nxt));\n\tfor(int i=0;i<(1<<M);++i) MAX(nxt[G[(1<<M)-1-i]],F[i]);\n\tfor(int i=1;i<=N+1;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[R[0][i]+1]>=L[0][i]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define x first\n#define y second\n\nint n, v;\n\nint x[200010];\n\nint hn;\nint gl[20][200010];\nint gr[20][200010];\n\nvoid in(){\n\tread(n, v);\n\tfor(int i=1; i<=n; ++i) read(x[i]);\n}\n\nvoid build(){\n\tfor(;;++hn, v/=2){\n\t\tfor(int i=1; i<=n;){\n\t\t\tint j;\n\t\t\tfor(j=i+1; j<=n && x[j]-x[j-1] <= v; ++j);\n \t\t\tfor(int k=i; k<j; ++k){\n\t\t\t\tgl[hn][k]=i;\n\t\t\t\tgr[hn][k]=j-1;\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t\tif(v == 0) break;\n\t}\n}\n\nint dpL[524288];\nint dpR[524288];\n\nvoid do_dp(){\n\tint M = (1<<hn);\n\tfor(int i=0; i<M; ++i){\n\t\tdpL[i] = 0;\n\t\tdpR[i] = n+1;\n\t\tfor(int j=1; j<=hn; ++j){\n\t\t\tint key = (1 << (j-1));\n\t\t\tif(i & key){\n\t\t\t\tint bl=dpL[i^key], br=dpR[i^key];\n\t\t\t\tdpL[i] = max(dpL[i], bl == n ? n : gr[j][bl+1]);\n\t\t\t\tdpR[i] = min(dpR[i], br == 1 ? 1 : gl[j][br-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool all_yes;\nbool yes[200010];\nvoid apply_gugan(int a, int b){\n\tif(a > b){\n\t\tall_yes = true;\n\t} else {\n\t\tif(gl[0][a] == gl[0][b]){\n\t\t\tyes[gl[0][a]]=1;\n\t\t}\n\t}\n}\n\nvoid Fill(){\n\tint M = (1<<hn);\n\tfor(int i=1; i<M; ++i){\n\t\tdpL[i] = max(dpL[i], dpL[i&(i-1)]);\n\t\tdpR[i] = min(dpR[i], dpR[i&(i-1)]);\n\t}\n\tfor(int i=0; i<M; ++i){\n\t\tint l=dpL[i]+1;\n\t\tint r=dpR[(M-1)^i]-1;\n\t\tapply_gugan(l, r);\n\t}\n}\n\nint main()\n{\n\tin(); build(); do_dp(); Fill();\n\tfor(int i=1; i<=n; ++i){\n\t\tputs((all_yes || yes[gl[0][i]])?\"Possible\":\"Impossible\");\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 2e05 + 10;\nconst int MAXL = 20 + 5;\n\nint N, V, lgv = 0;\nint a[MAXN];\nint sec[MAXN]= {0};\n\nint extl[MAXN][MAXL]= {0}, extr[MAXN][MAXL]= {0};\nint f[2][MAXN]= {0};\nbool answer[MAXN]= {false};\nvoid work (int p, int l, int r) {\n\tint n = lgv - 1;\n\tint limit = (1 << n) - 1;\n\tf[p][0] = l - 1;\n\tfor (int state = 1; state <= limit; state ++) {\n\t\tf[p][state] = l - 1;\n\t\tfor (int j = 1; j <= n; j ++)\n\t\t\tif (state & (1 << (j - 1))) {\n\t\t\t\tint pre = f[p][state ^ (1 << (j - 1))];\n\t\t\t\tf[p][state] = max (f[p][state], f[p][state ^ (1 << (j - 1))]);\n\t\t\t\tf[p][state] = max (f[p][state], extr[pre + 1][j]);\n\t\t\t}\n\t}\n}\nvoid solve () {\n\tint n = lgv - 1;\n\tint cnt = 0;\n\tfor (int i = 1; i <= N; i ++) {\n\t\tif (extl[i][lgv] == extl[i - 1][lgv] && extr[i][lgv] == extr[i - 1][lgv]) {\n\t\t\tanswer[i] = answer[i - 1];\n\t\t\tcontinue;\n\t\t}\n\t\tcnt ++;\n\t\tif (cnt > lgv) {\n\t\t\tfor (int j = 1; j <= N; j ++) answer[j] = false;\n\t\t\treturn ;\n\t\t}\n\t\tint pl = extl[i][lgv], pr = extr[i][lgv];\n\t\tif (pl != 1) work (0, 1, pl - 1);\n\t\tif (pr != N) work (1, pr + 1, N);\n\t\tint limit = (1 << n) - 1;\n\t\tif (pl == 1 && pr == N) answer[i] = true;\n\t\telse if (pl == 1) answer[i] = f[1][limit] >= N;\n\t\telse if (pr == N) answer[i] = f[0][limit] >= pl - 1;\n\t\telse {\n\t\t\tfor (int state = 1; state <= limit; state ++)\n\t\t\t\tif (f[0][state] >= pl - 1 && f[1][limit ^ state] >= N) {\n\t\t\t\t\tanswer[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint getnum () {\n\tint num = 0;\n\tchar ch = getchar ();\n\tbool isneg = false;\n\n\twhile (! isdigit (ch)) {\n\t\tif (ch == '-') isneg = true;\n\t\tch = getchar ();\n\t}\n\twhile (isdigit (ch))\n\t\tnum = (num << 3) + (num << 1) + ch - '0', ch = getchar ();\n\n\treturn isneg ? - num : num;\n}\n\nint main () {\n\tN = getnum (), V = getnum ();\n\tfor (int i = 1; i <= N; i ++)\n\t\ta[i] = getnum ();\n\tfor (int s = V; s > 0; s >>= 1)\n\t\tsec[++ lgv] = s;\n\tsec[++ lgv] = 0;\n\treverse (sec + 1, sec + lgv + 1);\n\tfor (int l = 1; l <= lgv; l ++) {\n\t\tfor (int i = 1; i <= N; i ++) {\n\t\t\tif (i == 1) extl[i][l] = 1;\n\t\t\telse extl[i][l] = a[i] - a[i - 1] <= sec[l] ? extl[i - 1][l] : i;\n\t\t}\n\t\tfor (int i = N; i >= 1; i --) {\n\t\t\tif (i == N) extr[i][l] = N;\n\t\t\telse extr[i][l] = a[i + 1] - a[i] <= sec[l] ? extr[i + 1][l] : i;\n\t\t}\n\t}\n\t/*for (int l = 1; l <= lgv; l ++) {\n\t\tcout << \"now: \" << sec[l] << endl;\n\t\tfor (int i = 1; i <= N; i ++)\n\t\t\tcout << extl[i][l] << ' ' << extr[i][l] << endl;\n\t}*/\n\tsolve ();\n\tfor (int i = 1; i <= N; i ++)\n\t\tanswer[i] ? puts (\"Possible\") : puts (\"Impossible\");\n\n\treturn 0;\n}\n\n/*\n3 2\n1 3 6\n*/\n\n/*\n7 2\n-10 -4 -2 0 2 4 10\n*/\n\n/*\n16 19\n-49 -48 -33 -30 -21 -14 0 15 19 23 44 52 80 81 82 84\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint n,v,x[N];\nint dp1[(1<<18)+3],dp2[(1<<18)+3];\nint tor[19][N],tol[19][N],len[19],dep;\nvoid maxn(int &x,int y){y>x? x=y:0;}\nint mxr[N];//左侧覆盖i，右侧最多覆盖多少个城市\nint main(){\n    scanf(\"%d%d\",&n,&v);x[0]=-2e9,x[n+1]=2e9;\n    for(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n    for(len[0]=v;len[dep]!=0;dep++) len[dep+1]=len[dep]/2;\n    dep++;\n    for(int d=0;d<dep;d++){\n        tol[d][0]=n,tor[d][n+1]=n;\n        for(int i=1;i<=n;i++) tol[d][i]=(x[i]-x[i-1]<=len[d])? tol[d][i-1]:n+1-i;\n        for(int i=n;i>=1;i--) tor[d][i]=(x[i+1]-x[i]<=len[d])? tor[d][i+1]:i;\n    }\n    \n    for(int i=0;i<(1<<dep);i+=2)\n        for(int j=1;j<dep;j++)\n            if((i&(1<<j))==0)\n                maxn( dp1[i|(1<<j)], tor[j][dp1[i]+1] ),\n                maxn( dp2[i|(1<<j)], tol[j][n-dp2[i]] );\n    \n    memset(mxr,0xc0,sizeof(mxr));\n    for(int i=0,j=((1<<dep)-1)^1;j>=0;i+=2,j-=2)\n        maxn( mxr[dp1[i]], dp2[j] );\n    for(int i=n;i>=1;i--) maxn( mxr[i], mxr[i+1] );\n    for(int i=1;i<=n;i++)\n        if(mxr[n-tol[0][i]] + tor[0][i] >= n) puts(\"Possible\");\n        else puts(\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 200010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;if(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\n\nint b[40],sz,a[N],c[N];\nint dp[1<<17],f[1<<17],l[N][20],r[N][20];\nint main(){\n    //freopen(\"A.in\",\"r\",stdin);\n    //freopen(\"A.out\",\"w\",stdout);\n    //cout<<setprecision(9)<<fixed;\n    //cerr<<setprecision(9)<<fixed;\n    int T,i,j,k,ca=0,m,K,n;\n    scanf(\"%d%d\",&n,&m);\n    K=m;sz=0;\n    while(K)b[sz++]=K,K>>=1;\n    b[sz++]=0;\n    swap(b[0],b[sz-1]);\n    rep(i,0,n)scanf(\"%d\",&a[i]);\n    rep(k,0,sz){\n        K=b[k];\n        //cerr<<k<<\" \"<<K<<\"\\n\";\n        l[0][k]=0;\n        rep(i,1,n){\n            if(K>=a[i]-a[i-1])l[i][k]=l[i-1][k];\n            else l[i][k]=i;\n        }\n        r[n-1][k]=n-1;\n        per(i,0,n-1){\n            if(K>=a[i+1]-a[i])r[i][k]=r[i+1][k];\n            else r[i][k]=i;\n        }\n    }\n    sz--;\n    memset(dp,-1,sizeof(dp));\n    dp[0]=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Max(dp[i|1<<j],x);\n            if(x+1<n)Max(dp[i|1<<j],r[x+1][j]);\n        }\n    }\n    per(i,0,(1<<sz))f[i]=n;\n    f[0]=n-1;\n    rep(i,0,(1<<sz)){\n        int x=f[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Min(f[i|1<<j],x);\n            if(x)Min(f[i|1<<j],l[x-1][j]);\n        }\n    }\n    int mask=(1<<sz)-1,flag=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i],y=f[mask^i];\n        if(y<=x+1){\n            flag=1;break;\n        }\n        k=r[x+1][sz];\n        j=l[y-1][sz];\n        if(j<=x+1&&k>=y-1)c[j]++,c[k+1]--;\n    }\n    if(flag){\n        rep(i,0,n)puts(\"Possible\");\n    }\n    else{\n        rep(i,1,n)c[i]+=c[i-1];\n        rep(i,0,n){\n            if(c[i])puts(\"Possible\");\n            else puts(\"Impossible\");\n        }\n    }\n    /*\n    rep(i,0,n)if(i==n-5){\n        int x=l[i][sz],y=r[i][sz],ok=0;\n        cerr<<i<<\" \"<<x<<\" \"<<y<<\"\\n\";\n        rep(j,0,(1<<sz)){\n            k=mask^j;\n            cerr<<j<<\" \"<<dp[j]<<\",\"<<k<<\" \"<<f[k]<<\"\\n\";\n            if(dp[j]>=x-1&&f[k]<=y+1){ok=1;break;}\n        }\n        puts(ok?\"Y\":\"N\");\n    }//*/\n    //cerr<<clock()*1./CLOCKS_PER_SEC<<\"ms\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e5+10,inf=0x3f3f3f3f;\nint tmp,Max[20][maxn],Min[20][maxn],a[maxn],f[maxn],g[maxn],R[maxn];\nint main(){\n\tint n=read(),V=read();\n\tREP(i,1,n) a[i]=read();\n\ttmp=-1;\n\tmemset(Min,inf,sizeof(Min));\n\twhile(1){\n\t\t++tmp;\n\t\tint lst=1;\n\t\tREP(i,2,n) if(a[i]-a[i-1]>V){\n\t\t\tchkmax(Max[tmp][lst],i-1);\n\t\t\tchkmin(Min[tmp][i-1],lst);\n\t\t\tlst=i;\n\t\t}\n\t\tchkmax(Max[tmp][lst],n);\n\t\tchkmin(Min[tmp][n],lst);\n\t\tREP(i,1,n) chkmax(Max[tmp][i],Max[tmp][i-1]);\n\t\tMax[tmp][n+1]=n;\n\t\tDREP(i,n,1) chkmin(Min[tmp][i],Min[tmp][i+1]);\n\t\tMin[tmp][0]=1;\n\t\tif(V==0) break;\n\t\tV/=2;\n\t}\n\tmemset(g,inf,sizeof(g));\n\tf[0]=0,g[0]=n+1;\n\tREP(i,0,(1<<tmp)-1)\n\t\tREP(j,1,tmp) if((i&(1<<(j-1)))==0){\n\t\t\tchkmax(f[i|(1<<(j-1))],Max[j][f[i]+1]);\n\t\t\tchkmin(g[i|(1<<(j-1))],Min[j][g[i]-1]);\n\t\t}\n\tmemset(R,inf,sizeof(R));\n\tREP(i,0,(1<<tmp)-1){\n\t\tif(f[i]>=g[i^iend]-1){\n\t\t\tREP(j,1,n) printf(\"Possible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tchkmin(R[f[i]+1],g[i^iend]-1);\n\t}\n\tDREP(i,n,1) chkmin(R[i],R[i+1]);\n\tREP(i,1,n) printf(\"%s\\n\",(R[Min[0][i]]<=Max[0][i])?\"Possible\":\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define mp(x,y) make_pair(x,y)\n#define ft first\n#define sd second\n#define rep(i,l,r) for (int i=l;i<=r;++i)\n#define P pair<int ,int >\nusing namespace std;\nconst int N =2e5+10;\nvoid read(int &x)\n{\n\tx=0;\n\tchar ch=getchar();int f=1;\n\twhile (ch<'0'||ch>'9') ch=='-'?f=-1:0,ch=getchar();\n\twhile ('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx*=f;\n}\nint n,bo[N],tot,m,a[N],top,v[233],l[N][20],r[N][20],f[1<<20],g[1<<20],cnt,tmp;\nP b[N<<1];\nvoid _mx(int &x,int y)\n{\n\tx=max(x,y);\n}\n\nvoid _mn(int &x,int y)\n{\n\tx=min(x,y);\n}\n\nint main()\n{\n\tread(n);read(m);\n\trep(i,1,n) read(a[i]);\n\tfor (;v[top++]=m;m>>=1);\n\trep(i,0,top) \n\t{\n\t\tint lst=1;\n\t\trep(j,2,n) if (a[j]-a[j-1]>v[i]) \n\t\t{\n\t\t\trep(k,lst,j-1) l[k][i]=lst,r[k][i]=j-1;\n\t\t\tlst=j;\n\t\t}\n\t\trep(k,lst,n) l[k][i]=lst,r[k][i]=n;\n\t}\n\ttot=1<<top;--tot;rep(i,0,tot) g[i]=n+1;\n\trep(i,0,tot) rep(j,0,top) \n\tif (!(i&1<<j)) _mx(f[i|1<<j] ,r[f[i]+1][j]),_mn(g[i|1<<j] ,l[g[i]-1][j]);\n\trep(i,0,tot) if (!(i&1)) b[++cnt]=mp(g[i],i);\n\trep(i,1,n) b[++cnt]=mp(r[i][0]+1,(1<<top)+i);\n\tsort(b+1,b+1+cnt);tmp=-1;\n\trep(i,1,cnt) if (b[i].sd>(1<<top))\n\t{\n\t\tb[i].sd-=(1<<top);\n\t\tif (tmp>=l[b[i].sd][0]-1) bo[b[i].sd]=1;\n\t}else _mx(tmp,f[((1<<top)-2)^b[i].sd]);\n\trep(i,1,n) printf(\"%s\\n\",bo[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n\n#define MAXN 200005\n#define MAXB 21\n\nusing namespace std;\n\nconst int INF = 1e9 + 2e6;\nint v[MAXN], n, m;\nint d[MAXN], up[MAXN][MAXB], down[MAXN][MAXB], pre[1 << MAXB], suf[1 << MAXB];\nint visit[MAXN];\n\nint read() {\n    char c = getchar();\n    int x = 0, s = 1;\n    while (!isdigit(c)) {\n        if (c == '-')\n            s = -1;\n        c = getchar();\n    }\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x * s;\n}\n\nvoid init() {\n    while (v[++m] >= 1)\n        v[m + 1] = v[m] >> 1;\n    d[0] = -INF;\n    d[n + 1] = INF;\n    for (int j = 1; j <= m; ++j) {\n        up[1][j] = 1;\n        down[n][j] = n;\n        for (int i = 2; i <= n; ++i)\n            if (d[i] - d[i - 1] <= v[j])\n                up[i][j] = up[i - 1][j];\n            else\n                up[i][j] = i;\n        for (int i = n - 1; i >= 1; --i)\n            if (d[i + 1] - d[i] <= v[j])\n                down[i][j] = down[i + 1][j];\n            else\n                down[i][j] = i;\n    }\n}\n\nvoid solve() {\n    memset(suf, 0x3f, sizeof(suf));\n    memset(pre, -0x3f, sizeof(pre));\n    suf[0] = n + 1;\n    pre[0] = 0;\n    int limit = (1 << m) - 1;\n    for (int s = 0; s <= limit; ++s) {\n        for (int i = 1; i <= m; ++i) {\n            if (s >> (i - 1) & 1)\n                continue;\n            int t = s | (1 << (i - 1));\n            if (pre[s] >= 0)\n                pre[t] = max(pre[t], down[pre[s] + 1][i]);\n            if (suf[s] <= n + 1)\n                suf[t] = min(suf[t], up[suf[s] - 1][i]);\n        }\n    }\n    for (int s = 1; s < limit; ++s) {\n        if (s & 1)\n            continue;\n        int t = limit ^ s ^ 1;\n        int a = up[suf[t] - 1][1], b = down[pre[s] + 1][1];\n        if (a <= b) {\n            ++visit[a];\n            --visit[b + 1];\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n        visit[i] = visit[i - 1] + visit[i];\n    for (int i = 1; i <= n; ++i)\n        if (visit[i])\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n}\n\nint main() {\n    n = read();\n    v[1] = read();\n    for (int i = 1; i <= n; ++i)\n        d[i] = read();\n    init();\n    solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 233333;\nint n,v,a[N],len,bh[20][N],num;Vi e[N*20];\nstruct Seg{\n\tint r[N];\n\tvoid init(int x){\n\t\tper(i,n,1){r[i]=i;if(i+1<=n&&a[i+1]-a[i]<=x)r[i]=r[i+1];}\n\t\t\n\t}\n}b[20];\nmap<Vi,bool>Map[20];\nbool ck(int dep, Vi c){\n\tif(SZ(c)>len-dep+1)return 0;if(dep==len||!SZ(c))return 1;\n\tif(Map[dep].count(c))return Map[dep][c];\n\tbool ok=0;\n\trep(i,0,SZ(c)-1){\n\t\tVi d;rep(j,0,SZ(c)-1)if(i!=j)rep(k,0,SZ(e[c[j]])-1)d.pb(e[c[j]][k]);\n\t\tsort(d.begin(),d.end());\n\t\tif(ck(dep+1,d)){ok=1;break;}\n\t}\n\treturn Map[dep][c]=ok;\n}\nint main() {\n\tread(n);read(v);rep(i,1,n)read(a[i]);\n\twhile(1){b[++len].init(v);if(!v)break;v/=2;}\n\trep(i,1,len)rep(j,1,n)if(b[i].r[j]!=b[i].r[j-1])bh[i][j]=++num;\n\trep(i,1,len-1)rep(j,1,n)if(bh[i][j]){\n\t\tfor(int k=j;k<=b[i].r[j];k=b[i+1].r[k]+1)\n\t\t\te[bh[i][j]].pb(bh[i+1][k]);\n\t}\n\tVi top;rep(i,1,n)if(bh[1][i])top.pb(bh[1][i]);\n\tif(SZ(top)>=20){\n\t\trep(i,1,n)puts(\"Impossible\");return 0;\n\t}\n\tfor(int i=1;i<=n;i=b[1].r[i]+1){\n\t\tVi c;rep(j,0,SZ(top)-1)if(top[j]!=bh[1][i])rep(k,0,SZ(e[top[j]])-1)c.pb(e[top[j]][k]);\n\t\tsort(c.begin(),c.end());bool ok=ck(2,c);\n\t\trep(j,i,b[1].r[i])printf(\"%s\\n\",ok?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define ri register int\nusing namespace std;\n     \nconst int N = 2e5 + 50;\n     \nint n, v, m;\nint lb[N], rb[N], ans[N];\nint pre[N][18], nxt[N][18];\nint a[N], f[1 << 18 | 5], g[1 << 18 | 5];\n\nint main() {\n  scanf(\"%d%d\", &n, &v);\n  int rec = v; v >>= 1;\n  for (int i = 1; i <= n; i ++) scanf(\"%d\", &a[i]);\n  for (int t = v; t; t >>= 1) m ++;\n  m ++;\n  for (int j = 1; j < m; j ++)\n    nxt[n + 1][j] = n + 1;\n  lb[0] = 1; rb[n + 1] = n;\n  for (ri i = 1; i <= n; i ++) {\n    lb[i] = (a[i] - a[i - 1] > rec) ? i : lb[i - 1];\n    for (ri j = 0; j < m; j ++)\n      pre[i][j] = ((a[i] - a[i - 1]) > (v >> j)) ? i - 1 : pre[i - 1][j];\n  }\n  for (ri i = n; i; i --) {\n    rb[i] = (a[i + 1] - a[i] > rec) ? i : rb[i + 1];\n    for (ri j = 0; j < m; j ++)\n      nxt[i][j] = ((a[i + 1] - a[i]) > (v >> j)) ? i + 1 : nxt[i + 1][j];\n  }\n  for (ri i = 0, l, r; i < (1 << m); i ++) {\n    l = 1; r = n;\n    for (ri j = 0; j < m; j ++)\n      if ((i >> j) & 1) {\n    \tl = max(l, nxt[f[i ^ (1 << j)]][j]);\n    \tr = min(r, pre[g[i ^ (1 << j)]][j]);\n      }\n    f[i] = l; g[i] = r;\n  }\n  bool allok = 0;\n  int U = (1 << m) - 1;\n  for (ri i = 0, p; i < (1 << m); i ++) {\n    p = rb[f[i]];\n    if (g[U ^ i] <= p) ans[p] = 1;\n    if (g[U ^ i] < f[i]) allok = 1;\n  }\n  for (int i = 1; i <= n; i ++)\n    if (ans[rb[i]] || allok) puts(\"Possible\");\n    else puts(\"Impossible\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<stdlib.h>\n#include<string.h>\n#include<queue>\n#define LL long long\n#define NJ !((i>>(j-1))&1)\n#define SJ i^(1<<(j-1))\nusing namespace std;\ninline int read( )\n{\n  int sum=0;char c=getchar( );bool f=0;\n  while(c<'0'||c>'9') {if(c=='-') f=1;c=getchar( );}\n  while(c>='0'&&c<='9') {sum=sum*10+c-'0';c=getchar( );}\n  if(f) return -sum;\n  return sum;\n}\nconst int K=200005;\nconst int N=25;\nconst int M=(1<<19)+5;\nint n,V,X[K],s[N],f[M],g[M];\nint tot,L[K][N],R[K][N],FM[K];\ninline void MX(int &x,int y) {if(y>x) x=y;}\ninline void MN(int &x,int y) {if(y<x) x=y;}\nint main( )\n{\n  int i,j,x,y,t;\n  n=read( );V=read( );\n  for(i=1;i<=n;i++) X[i]=read( );\n  for(j=V;;j>>=1)\n    {\n      s[++tot]=j;\n      for(i=1,t=1;i<=n;i++)\n\t{\n\t  t=max(t,i);\n\t  while(t<n&&X[t+1]-X[t]<=j) t++;\n\t  L[i][tot]=t;\n\t}\n      L[n+1][tot]=n;\n      for(i=n,t=n;i>=1;i--)\n\t{\n\t  t=min(t,i);\n\t  while(t>1&&X[t]-X[t-1]<=j) t--;\n\t  R[i][tot]=t;\n\t}\n      R[0][tot]=1;\n      if(!j) break;\n    }\n  int S=1<<tot;\n  for(i=0;i<S;i++) g[i]=n+1;\n  for(i=0;i<S;i++)\n    for(x=f[i],y=g[i],j=1;j<=tot;j++)\n      if(NJ) MX(f[SJ],L[x+1][j]),MN(g[SJ],R[y-1][j]);\n  int ALL=S-2,MF=-n;\n  for(i=0;i<=n+1;i++) FM[i]=-n;\n  for(j=1,i=0;i<=ALL;i++) \n    if(NJ) x=(!g[i])?0:((g[i]==n+1)?n+1:g[i]),MX(FM[x],f[ALL-i]);\n  for(t=0,i=1;i<=n;i++)\n    {\n      while(t<=n+1&&L[i][1]+1>=t) MX(MF,FM[t]),t++; \n      puts(R[i][1]<=MF+1?\"Possible\":\"Impossible\");\n    }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define chmax(a,b) a=max(a,b);\n#define N (1<<18)\n#define M 18\nll n,v;\nclass Alpha{\n public:\n ll f[N];\n P g[N][M];\n void setg(ll a[]){\n     for(int k=0;k<M;k++){\n         ll bef=-1e18,pnt=0; a[n]=1e18;\n         for(int i=0;i<=n;i++){\n          if(abs(a[i]-bef)>(v>>k)){\n           for(int j=pnt;j<i;j++)g[j][k]=make_pair(pnt,i-1);\n           pnt=i;   \n          }\n          bef=a[i];\n         }\n         if((v>>k)==0)break;\n     }/*\n     for(int k=0;k<4;k++){\n     for(int i=0;i<=n;i++){ \n         cout<<g[i][k]<<\" \";\n     }\n     cout<<endl;\n     }cout<<endl;*/\n }\n void main(ll a[]){\n  setg(a);   \n  for(int i=0;i<N;i++)f[i]=-1;\n  for(int i=0;i<N;i++){\n      for(int j=1;j<M;j++){\n          if(i&(1<<j))continue;\n          chmax(f[i+(1<<j)],g[f[i]+1][j].second);\n      }\n  }\n }\n};Alpha L,R;\n\nclass Solve{\n  public:\n  unordered_map<ll,bool> mas;\n  bool main(ll l,ll r){\n      if(mas.size()>M)return 0;\n      if(mas.find(l)!=mas.end()){\n       return mas[l];   \n      }\n      bool res=0;\n      for(int i=0;i<N;i++){\n       int ls=i,rs=N-1-i;\n       if(l-1<=L.f[ls]&&n-1-R.f[rs]<=r+1)res=1;\n      }\n      mas[l]=res;\n      return res;\n  }\n};Solve sv;\n\nll a[N];\nint main(){\n    cin>>n>>v;\n    for(int i=0;i<n;i++)cin>>a[i];\n    L.main(a);\n    for(int i=0;i<n/2;i++)swap(a[i],a[n-i-1]);\n    R.main(a);\n    for(int i=0;i<n;i++){\n     bool ans=sv.main(L.g[i][0].first,L.g[i][0].second);   \n     cout<<(ans?\"Possible\":\"Impossible\")<<endl;\n    }\n return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nint n, ans[200050];\nvector<int> v;\nint a[200050];\nint go[19][200050];\nint dp[1 << 19];\nbool f(int l, int r, int k)\n{\n\tvector<int> b;\n\tfor (int i = 0; i < n; i++)\n\t\tif (i < l || i >= r)\n\t\t\tb.emplace_back(a[i]);\n\tint m = b.size();\n\tfor (int i = 0; i < k; i++)\n\t\tfor (int j = m - 1; j >= 0; j--) {\n\t\t\tgo[i][j] = j + 1;\n\t\t\tif (j + 1 < m&&b[j + 1] - b[j] <= v[i])\n\t\t\t\tgo[i][j] = go[i][j + 1];\n\t\t}\n\tfor (int i = 0; i < 1 << k; i++)dp[i] = 0;\n\tfor (int i = 0; i < 1 << k; i++) {\n\t\tif (dp[i] == m)\treturn 1;\n\t\tfor (int j = 0; j < k; j++)\n\t\t\tif ((i >> j & 1) == 0)dp[i | 1 << j] = max(dp[i | 1 << j], go[j][dp[i]]);\n\t}\n\treturn false;\n}\nint main()\n{\n\tint V;\n\tcin >> n >> V;\n\tfor (; V > 0; V /= 2)\n\t\tv.emplace_back(V);\n\tv.emplace_back(0);\n\treverse(v.begin(), v.end());\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\ta[n] = 1100000000;\n\tif (f(n, n, v.size())) {\n\t\tfor (int l = 0; l < n;) {\n\t\t\tint r = l + 1;\n\t\t\twhile (a[r] - a[r - 1] <= v.back())r++;\n\t\t\tif (f(l, r, v.size() - 1))\n\t\t\t\tfor (int i = l; i < r; i++)ans[i] = 1;\n\t\t\tl = r;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcout << (ans[i] ? \"Possible\" : \"Impossible\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][30],tmp[30][30];\n\nconst int H=19260817;\nstruct hash_map\n{\n\tuint x[H];\n\tbool y[H];\n\tinline int get(uint v)\n\t{\n\t\tuint g=v%H;\n\t\tfor(;x[g]&&x[g]!=v;++g==H?g=0:0);\n\t\treturn x[g]==v?y[g]:2;\n\t}\n\tinline bool&operator[](uint v)\n\t{\n\t\tuint g=v%H;\n\t\tfor(;x[g]&&x[g]!=v;++g==H?g=0:0);\n\t\tx[g]=v;return y[g];\n\t}\n}hs;\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\tuint hash=dep;\n\tfo0(i,cnt)hash=hash*2337+s[i];\n\t{int tmp=hs.get(hash);if(tmp!=2)return tmp;}\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>=dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\tr[i]=t[i];\n\t}\n\treturn hs[hash]=0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int L = 20;\nconst int MAX = 2 * 1000 * 100 + 47;\n\nint V[L];\nint sz = 0;\nint N[L][MAX];\nint P[L][MAX];\nint X[MAX];\nint dpL[1 << L];\nint dpR[1 << L];\nint ANS[MAX];\nset<PII> S;\nint M[MAX];\n\nvoid print(int mask)\n{\n\twhile (mask)\n\t{\n\t\tif (mask & 1)\n\t\t{\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << \" \";\n\t\t}\n\n\t\tmask >>= 1;\n\t}\n}\n\n//#define DEBUG\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tint n, v;\n\tcin >> n >> v;\n\tFOR(i, 0, n) cin >> X[i];\n\n\tV[0] = v;\n\tFOR(i, 1, L)\n\t{\n\t\tV[i] = V[i - 1] / 2;\n\t\tif (V[i] == 0)\n\t\t{\n\t\t\tsz = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treverse(V, V + sz);\n\tFOR(k, 0, L)\n\t{\n\t\tint v = V[k];\n\t\tN[k][n - 1] = n;\n\n\t\tRFOR(i, n - 1, 0)\n\t\t{\n\t\t\tif (abs(X[i + 1] - X[i]) > v)\n\t\t\t{\n\t\t\t\tN[k][i] = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tN[k][i] = N[k][i + 1];\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"N=\" << endl;\n\tFOR(k, 0, sz)\n\t{\n\t\tcout << V[k] << \": \";\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tcout << N[k][i] << \" \";\n\t\t}\n\n\t\tcout << endl;\n\t}\n#endif\n\n\tFOR(k, 0, L)\n\t{\n\t\tint v = V[k];\n\t\tP[k][0] = -1;\n\t\tFOR(i, 1, n)\n\t\t{\n\t\t\tif (abs(X[i] - X[i - 1]) > v)\n\t\t\t{\n\t\t\t\tP[k][i] = i - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tP[k][i] = P[k][i - 1];\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"P=\" << endl;\n\tFOR(k, 0, sz)\n\t{\n\t\tcout << V[k] << \": \";\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tcout << P[k][i] << \" \";\n\t\t}\n\n\t\tcout << endl;\n\t}\n#endif\n\n\tsz--;\n\n\tdpL[0] = 0;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tint x = dpL[mask];\n\t\tFOR(k, 0, sz)\n\t\t{\n\t\t\tif (mask & (1 << k)) continue;\n\n\t\t\tdpL[mask | (1 << k)] = max(dpL[mask | (1 << k)], N[k][x]);\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"dpL\" << endl;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tprint(mask);\n\t\tcout << \" :\";\n\t\tcout << dpL[mask] << endl;\n\t}\n#endif\n\n\tFOR(i, 0, 1 << sz) dpR[i] = n;\n\tdpR[0] = n - 1;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tint x = dpR[mask];\n\t\tFOR(k, 0, sz)\n\t\t{\n\t\t\tif (mask & (1 << k)) continue;\n\n\t\t\tdpR[mask | (1 << k)] = min(dpR[mask | (1 << k)], P[k][x]);\n\t\t}\n\t}\n\n\n#ifdef DEBUG\n\tcout << \"dpR\" << endl;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tprint(mask);\n\t\tcout << \" :\";\n\t\tcout << dpR[mask] << endl;\n\t}\n#endif\n\n\tFOR(i, 0, n) M[i] = INF;\n\tFOR(maskL, 0, 1 << sz)\n\t{\n\t\tint maskR = ((1 << sz) - 1) ^ maskL;\n\t\tint l = dpL[maskL] - 1;\n\t\tint r = dpR[maskR] + 1;\n#ifdef DEBUG\n\t\tcout << \"!!\" << l << \" \" << r << endl;\n#endif\n\t\tif (l != -1) M[l] = min(M[l], r);\n\t}\n\n#ifdef DEBUG\n\tcout << \"M=\" << endl;\n\tFOR(i, 0, n)\n\t{\n\t\tcout << M[i] << \" \";\n\t}\n\n\tcout << endl;\n#endif\n\n\tRFOR(i, n - 1, 0) M[i] = min(M[i + 1], M[i]);\n\t\n\tFOR(i, 0, n)\n\t{\n\t\tint l = P[sz][i] + 1;\n\t\tint r = N[sz][i] - 1;\n\t\tif (S.find(MP(l, r)) != S.end()) continue;\n\n\t\tif (M[max(l - 1, 0)] <= r + 1)\n\t\t{\n\t\t\tFOR(k, l, r + 1) ANS[k] = 1;\n\t\t}\n\t}\n\n\tFOR(i, 0, n)\n\t{\n\t\tif (ANS[i])\n\t\t{\n\t\t\tcout << \"Possible\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcout << \"Impossible\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef pair<double, long long> pdl;\n\nconst long double pi = 3.141592653589793;\n\n#define debug(x) cout << #x << \" = \" << (x) << endl;\n#define rep(i, n) for(int i = 0;i < n;i++)\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n\nll power(ll a, ll b) {\n\tif (b == 0) return 1;\n\tll pp = power(a, b/2);\n\tpp = (pp*pp) % mod;\n\tif(b%2 == 0) return pp;\n\treturn (pp*a)%mod;\n}\n\nint n, v;\nll x[1<<20];\nll max_lhs[21][200011];\nll max_rhs[21][200011];\nvector<ll> water;\n\nll dp_beg[1<<20];\nll dp_end[1<<20];\n\nll ans[1<<20];\n\nint main() {\n  \t//freopen(\"input.in\",\"r\",stdin);\n  \t//freopen(\"output.out\",\"w\",stdout);\n\n\tcin>>n>>v;\n\trep(i, n) cin>>x[i];\n\twhile (v != 0) {\n\t\twater.pb(v);\n\t\tv /= 2;\n\t} water.pb(0);\n\n\tint sz = water.size();\n\n\trep(i, sz) {\n\t\tll pani = water[i];\n\t\tll temp = 0;\n\t\trep(j, n) {\n\t\t\tif(j == 0) {max_lhs[i][j] = 0; continue;}\n\t\t\tif(x[j]-x[j-1] > pani) temp = j;\n\t\t\tmax_lhs[i][j] = temp;\n\t\t}\n\n\t\ttemp = n-1;\n\t\tfor(int j = n-1;j >= 0;j--) {\n\t\t\tif(j == n-1) {max_rhs[i][j] = n-1; continue;}\n\t\t\tif(x[j+1]-x[j] > pani) temp = j;\n\t\t\tmax_rhs[i][j] = temp;\n\t\t}\n\t}\n\n\trep(mask, 1<<sz) dp_end[mask] = n-1;\n\n\trep(mask, 1<<sz) {\n\t\trep(j, sz) {\n\t\t\tif(not(mask & (1<<j))) {\n\t\t\t\tif(dp_beg[mask | (1<<j)] == n-1) continue;\n\t\t\t\tll pos = dp_beg[mask];\n\t\t\t\tdp_beg[mask | (1<<j)] = max(dp_beg[mask | (1<<j)],\n\t\t\t\t\t\t\t\t\t\t\tmax_rhs[j][pos+1]);\n\t\t\t}\n\t\t}\n\n\t\trep(j, sz) {\n\t\t\tif(not(mask & (1<<j))) {\n\t\t\t\tif(dp_end[mask | (1<<j)] == 0) continue;\n\t\t\t\tll pos = dp_end[mask];\n\t\t\t\tdp_end[mask | (1<<j)] = min(dp_end[mask | (1<<j)],\n\t\t\t\t\t\t\t\t\t\t\tmax_lhs[j][pos-1]);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(mask, 1<<sz) {\n\t\tll s1 = mask | 1;\n\t\tll s2 = s1^((1<<sz)-1);\n\t\ts1 = s1^1;\n\n\t\tif(dp_end[s2] - dp_beg[s1] <= 1) {ans[0] += 1;continue;}\n\t\tif(max_rhs[0][dp_beg[s1]+1] >= dp_end[s2]-1) {\n\t\t\tans[max_lhs[0][dp_beg[s1]+1]]++;\n\t\t\tans[max_rhs[0][dp_beg[s1]+1]+1]--;\n\t\t}\n\t}\n\n\tll csum = 0;\n\trep(i, n) {\n\t\tcsum += ans[i];\n\t\tcout<<((csum != 0) ? \"Possible\": \"Impossible\")<<endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(a) for(int k=head[a];k;k=e[k].ne)\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ll,ll> pa;\nconst int N=1e6+5,M=5e3+5,INF=1e9,mod=998244353;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nint rj[N][21],lj[N][21],n,v,K,x[N],lx[N],rx[N],mn[N];\n#define pw(a) (1<<(a))\nint main(){\n\tread(n,v);while(pw(K)<=v)K++;\n\trep(i,1,n)read(x[i]);\t\n\trep(k,0,K){\n\t\tlj[0][k]=1;\n\t\trep(i,1,n)lj[i][k]=(x[i]-x[i-1]<=(v>>k))?lj[i-1][k]:i;\n\t\trj[n+1][k]=n;\n\t\trepd(i,n,1)rj[i][k]=(x[i+1]-x[i]<=(v>>k))?rj[i+1][k]:i;\n\t}\n\tre(i,0,pw(K+1))rx[i]=n+1;\n\tre(i,0,pw(K+1))rep(j,0,K)if(!(i&pw(j))){\n\t\tgmax(lx[i|pw(j)],rj[lx[i]+1][j]);\n\t\tgmin(rx[i|pw(j)],lj[rx[i]-1][j]);\n\t}\n\trep(i,0,n)mn[i]=n+2;\n\tfor(int i=0;i<pw(K+1);i+=2)gmin(mn[lx[i]],rx[pw(K+1)-1-1-i]);\n\trepd(i,n-1,0)gmin(mn[i],mn[i+1]);\n\trep(i,1,n)if(rj[i][0]+1>=mn[lj[i][0]-1])puts(\"Possible\");else puts(\"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long i64;\n\ntemplate<class T>\nvoid selectMin(T & x, const T & y)\n{\n\tif (x > y)\n\t\tx = y;\n}\ntemplate<class T>\nvoid selectMax(T & x, const T & y)\n{\n\tif (x < y)\n\t\tx = y;\n}\n\nconst int MAXN = 2e5 + 10;\nconst int MAXLOG = 20 + 5;\nconst int PINF = 0x3F3F3F3F;\n\nconst char NSOL[] = \"Impossible\";\nconst char FSOL[] = \"Possible\";\n\nint N, V;\nint lg2 = -1;\nint exp_2[MAXLOG];\nint R[MAXLOG][MAXN];\nint cnt[MAXLOG];\nint dp1[MAXN << 3], dp2[MAXN << 3];\nint A[MAXN];\n\nvoid prepare()\n{\n\texp_2[0] = 1;\n\tfor (int i = 1; i < MAXLOG; i++)\n\t\texp_2[i] = exp_2[i - 1] * 2;\n}\n\nint main()\n{\n\tprepare();\n\tcin >> N >> V;\n\tfor (int i = 1; i <= N; i++)\n\t\tcin >> A[i];\n\n\tint x = V * 2;\n\twhile (x)\n\t{\n\t\tx /= 2, lg2++;\n\n\t\t// Split segments\n\t\tfor (int i = 1; i < N; i++)\n\t\t{\n\t\t\tif (A[i + 1] - A[i] <= x)\n\t\t\t\tcontinue;\n\t\t\tR[lg2][++cnt[lg2]] = i;\n\t\t}\n\t\tR[lg2][++cnt[lg2]] = N;\n\t}\n\n\tif (cnt[0] > lg2 + 1)\n\t{\n\t\tfor (int i = 1; i <= N; i++)\n\t\t\tputs(NSOL);\n\t\treturn 0;\n\t}\n\n\tfor (int s = 0; s < exp_2[lg2]; s++)\n\t\tdp2[s] = N + 1;\n\tfor (int s = 0; s < exp_2[lg2]; s++)\n\t\tfor (int i = 1; i <= lg2; i++)\n\t\t{\n\t\t\tif (s & exp_2[i - 1])\n\t\t\t\tcontinue;\n\t\t\tselectMax(dp1[s | exp_2[i - 1]],\n\t\t\t\t\t*upper_bound(R[i] + 1, R[i] + cnt[i] + 1, dp1[s]));\n\t\t\tselectMin(dp2[s | exp_2[i - 1]],\n\t\t\t\t\tR[i][lower_bound(R[i] + 1, R[i] + cnt[i] + 1, dp2[s] - 1)\n\t\t\t\t\t\t\t- R[i] - 1] + 1);\n\t\t}\n\n\tfor (int i = 1; i <= cnt[0]; i++)\n\t{\n\t\tbool solution = false;\n\t\tfor (int s = 0; s < exp_2[lg2]; s++)\n\t\t\tif (dp1[s] >= R[0][i - 1] && dp2[exp_2[lg2] - s - 1] <= R[0][i] + 1)\n\t\t\t{\n\t\t\t\tsolution = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tfor (int j = R[0][i - 1] + 1; j <= R[0][i]; j++)\n\t\t\tputs(solution ? FSOL : NSOL);\n\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200010;\n\nint N, V;\nint x[maxn];\nint id[maxn];\n\nint m, cnt;\nint val[20];\nbool f[2][1<<20][20];\n\nbool ans[20];\n\nbool F[20][1<<20];\nbool G[20][1<<20];\n\nint main() {\n\tscanf(\"%d%d\", &N, &V);\n\tfor(int v = V / 2; v > 0; v /= 2) val[m++] = v;\n\tval[m++]=0;\n\tfor(int i = 0; i < N; ++i) scanf(\"%d\", &x[i]);\n\tid[0] = 0;\n\tcnt = 1;\n\tfor(int i = 1; i < N; ++i) {\n\t\tif(x[i] - x[i-1] > V) id[i] = cnt++;\n\t\telse id[i] = id[i-1];\n\t}\n\n\tif(cnt == 1) { for(int i = 0; i < N; ++i) puts(\"Possible\"); return 0; }\n\tif(cnt > 20) { for(int i = 0; i < N; ++i) puts(\"Impossible\"); return 0; }\n\n\tfor(int j = 0; j < 1<<m; ++j) \n\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1)\n\t\t\tf[0][j][k] = true;\n\tif(id[0] != id[1]) \n\t\tfor(int j = 0; j < 1<<m; ++j) F[id[0]][j] = true;\n\tfor(int i = 1, p = 0; i < N; ++i) {\n\t\tp ^= 1;\n\t\tfor(int j = 0; j < 1<<m; ++j) {\n\t\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1) {\n\t\t\t\tf[p][j][k] = 0;\n\t\t\t\tfor(int l = 0; l < m; ++l) f[p][j][k] |= f[p^1][j^(1<<k)][l];\n\t\t\t\tif(x[i] - x[i-1] <= val[k]) f[p][j][k] |= f[p^1][j][k];\n\t\t\t}\n\t\t}\n\t\tif(i == N-1 || id[i+1] != id[i]) {\n\t\t\tfor(int j = 0; j < 1<<m; ++j) {\n\t\t\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1) {\n\t\t\t\t\tF[id[i]][j] |= f[p][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(f, 0, sizeof(f));\n\tfor(int j = 0; j < 1<<m; ++j) \n\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1)\n\t\t\tf[0][j][k] = true;\n\tif(id[N-1]!=id[N-2]) \n\t\tfor(int j = 0; j < 1<<m; ++j) G[id[N-1]][j] = true;\n\tfor(int i = N - 2, p = 0; i >= 0; --i) {\n\t\tp ^= 1;\n\t\tfor(int j = 0; j < 1<<m; ++j) {\n\t\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1) {\n\t\t\t\tf[p][j][k] = 0;\n\t\t\t\tfor(int l = 0; l < m; ++l) f[p][j][k] |= f[p^1][j^(1<<k)][l];\n\t\t\t\tif(x[i+1] - x[i] <= val[k]) f[p][j][k] |= f[p^1][j][k];\n\t\t\t}\n\t\t}\n\t\tif(i == 0 || id[i-1] != id[i]) {\n\t\t\tfor(int j = 0; j < 1<<m; ++j) {\n\t\t\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1) {\n\t\t\t\t\tG[id[i]][j] |= f[p][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst int mask = (1<<m) - 1;\n\tfor(int i = 0; i < cnt; ++i) {\n\t\tif(i == 0) {\n\t\t\tfor(int k = 0; k < 1<<m; ++k) \n\t\t\t\tif(G[i+1][k]) { ans[i] = true; break; }\n\t\t} else if(i == cnt - 1) {\n\t\t\tfor(int k = 0; k < 1<<m; ++k) \n\t\t\t\tif(F[i-1][k]) { ans[i] = true; break; }\n\t\t} else {\n\t\t\tfor(int k = 0; k < 1<<m; ++k) {\n\t\t\t\tif(F[i-1][k] && G[i+1][mask ^ 1]) { ans[i] = true; break; }\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; ++i) puts(ans[id[i]] ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint x[202020];\nint l[202020][20], r[202020][20];\nint dpl[1 << 20], dpr[1 << 20];\n\nvoid solve() {\n        int n, v;\n        cin >> n >> v;\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        int p;\n        for (int i = 0; ; i ++) if ((1 << i) > v) {\n                p = i + 1;\n                break;\n        }\n        for (int i = 0; i < n; i ++) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == 0 || x[i] - x[i - 1] > vv) l[i][j] = i;\n                        else l[i][j] = l[i - 1][j];\n                        vv /= 2;\n                }    \n        }\n        for (int i = n - 1; i >= 0; i --) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == n - 1 || x[i + 1] - x[i] > vv) r[i][j] = i;\n                        else r[i][j] = r[i + 1][j];\n                        vv /= 2;\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) {\n                //if (i & 1) continue;\n                for (int j = 0; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpr[i] == n) dpr[i | (1 << j)] = n;\n                        else dpr[i | (1 << j)] = max(dpr[i | (1 << j)], r[dpr[i]][j] + 1);\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) dpl[i] = n - 1;\n        for (int i = 0; i < (1 << p); i ++) {\n                //if (i & 1) continue;\n                for (int j = 0; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpl[i] == -1) dpl[i | (1 << j)] = -1;\n                        else dpl[i | (1 << j)] = min(dpl[i | (1 << j)], l[dpl[i]][j] - 1);\n                }\n        }\n        bool ok = false;\n        for (int i = 0; i < n; i ++) {\n                if (l[i][0] == i) {\n                        int c = 0;\n                        for (int j = 0; j < (1 << p); j ++) {\n                                c ++;\n                                if (j & 1) continue; \n                                if (i > 0 && dpr[j] < i) continue;\n                                if (r[i][0] < n - 1 && dpl[((1 << p) - 1 - j) - 1] > r[i][0]) continue;\n                                break;\n                        }\n                        if (c < (1 << p)) ok = true;\n                        else ok = false;\n                }\n                if (ok) cout << \"Possible\" << endl;\n                else cout << \"Impossible\" << endl;\n        }\n        return;\n}\n\nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        solve();\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   int N, V;\n   cin >> N >> V;\n   vector<int> X(N);\n   for (int i = 0; i < N; ++i) cin >> X[i];\n   vector<int> vs = {V};\n   while (vs.back()) vs.emplace_back(vs.back() / 2);\n   reverse(vs.begin(), vs.end());\n   int sz = int(vs.size()) - 1;\n   vector<vector<int>> L(sz + 1, vector<int>(N));\n   vector<vector<int>> R(sz + 1, vector<int>(N));\n   for (int i = 0; i <= sz; ++i) {\n      L[i][0] = 0;\n      for (int j = 1; j < N; ++j) {\n         if (X[j] - X[j - 1] <= vs[i]) L[i][j] = L[i][j - 1];\n         else L[i][j] = j;\n      }\n      R[i][N - 1] = N - 1;\n      for (int j = N - 2; j >= 0; --j) {\n         if (X[j + 1] - X[j] <= vs[i]) R[i][j] = R[i][j + 1];\n         else R[i][j] = j;\n      }\n   }\n   vector<int> forw(1 << sz, -1);\n   vector<int> backw(1 << sz, N);\n   for (int mask = 0; mask < (1 << sz); ++mask) {\n      for (int i = 0; i < sz; ++i) if (!(mask & (1 << i))) {\n         int nmask = mask | (1 << i);\n         forw[nmask] = max(forw[nmask], R[i][min(forw[mask] + 1, N - 1)]);\n         backw[nmask] = min(backw[nmask], L[i][max(backw[mask] - 1, 0)]);\n      }\n   }\n   vector<int> cnt(N);\n   for (int mask = 0; mask < (1 << sz); ++mask) {\n      int lv = forw[mask];\n      int rv = backw[mask ^ ((1 << sz) - 1)];\n      int low = L[sz][max(rv - 1, 0)];\n      int high = R[sz][min(lv + 1, N - 1)];\n      if (low <= high) {\n         ++cnt[low];\n         if (high + 1 < N) --cnt[high + 1];\n      }\n   }\n   for (int i = 0; i < N; ++i) {\n      if (i) cnt[i] += cnt[i - 1];\n      cout << (cnt[i] ? \"Possible\" : \"Impossible\") << \"\\n\";\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,v;\n  cin>>n>>v;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n\n  vector<Int> dp;\n  vector<vector<Int> > ps;\n  while(v){\n    vector<Int> dp2(n,0);\n    for(Int i=1;i<n;i++)\n      dp2[i]=dp2[i-1]+(x[i]-x[i-1]>v);\n    if(dp.empty()) dp=dp2;\n\n    vector<Int> ps2;\n    ps2.emplace_back(0);\n    for(Int i=1;i<n;i++)\n      if(dp2[i]!=dp2[i-1]) ps2.emplace_back(i);\n    ps2.emplace_back(n);\n    ps.emplace_back(ps2);\n    v>>=1;\n  }\n  \n  {\n    vector<Int> ps2(n+1,0);\n    iota(ps2.begin(),ps2.end(),0);\n    ps.emplace_back(ps2);\n  }\n\n  vector<vector<Int> > memo(ps.size(),vector<Int>(n,-1));\n  function<Int(Int,Int)> calc=\n    [&](Int d,Int k)->Int{\n      if(d+1==(Int)ps.size()) return 1;\n      Int &res=memo[d][k];\n      if(~res) return res;\n      res=0;\n      vector<Int> &v=ps[d];\n      vector<Int> &u=ps[d+1];\n      res=lower_bound(u.begin(),u.end(),v[k+1])\n\t-lower_bound(u.begin(),u.end(),v[k]);\n      if(0){\n\tInt x=lower_bound(u.begin(),u.end(),v[k])-u.begin();\n\tInt tmp=0;\n\twhile(u[x]<v[k+1]){\n\t  res+=calc(d+1,x);\n\t  chmax(tmp,calc(d+1,x)-1);\n\t  x++;\n\t}\n\tres-=tmp;\n      }\n      return res;\n    };\n  \n  using P = pair<Int, Int>;\n  Int flg;\n  function<void(Int,const set<P>&)> dfs=\n    [&](Int d,const set<P> &sp){\n      if(d==(Int)ps.size()) return;\n      \n      Int cnt=0;\n      vector<Int> &v=ps[d];\n      {\n\tauto latte=v.begin();\n\tfor(auto &p:sp){\n\t  cnt+=lower_bound(latte,v.end(),p.first)-latte;\n\t  latte=lower_bound(latte,v.end(),p.second);\n\t}\n\tcnt+=v.end()-latte-1;\n      }\n      \n      flg|=(cnt<=1);\n      if(flg) return;\n      \n      if(0){\n\tcout<<d<<\":\"<<cnt<<\"::\"<<(Int)ps.size()<<endl;\n\tfor(auto p:sp) cout<<p.first<<\" \"<<p.second<<endl;\n\tcout<<endl;\n      }\n      \n      if(d+cnt>(Int)ps.size()) return;\n      \n      Int ncnt=0,tmp=0;\n      {\n\tInt k=0;\n\tfor(auto &p:sp){\n\t  while(v[k]<p.first){\n\t    ncnt+=calc(d,k);\n\t    chmax(tmp,calc(d,k));\n\t    k++;\n\t  }\n\t  k=lower_bound(v.begin(),v.end(),p.second)-v.begin();\n\t}\n\twhile(k+1<(Int)v.size()){\n\t  ncnt+=calc(d,k);\n\t  chmax(tmp,calc(d,k));\n\t  k++;\n\t}\n      }\n      //cout<<d<<\":\"<<cnt<<\":\"<<ncnt<<endl;\n      if(d+ncnt-tmp>(Int)ps.size()) return;\n      \n      set<P> nsp=sp;\n      {\n\tInt k=0;\n\tfor(auto &p:sp){\n\t  while(v[k]<p.first){\n\t    if(d+ncnt-calc(d,k)<=(Int)ps.size()){\n\t      nsp.emplace(v[k],v[k+1]);\n\t      dfs(d+1,nsp);\n\t      nsp.erase(P(v[k],v[k+1]));\n\t      if(flg) return;\n\t    }\n\t    k++;\n\t  }\n\t  k=lower_bound(v.begin(),v.end(),p.second)-v.begin();\n\t}\n\twhile(k+1<(Int)v.size()){\n\t  if(d+ncnt-calc(d,k)<=(Int)ps.size()){\n\t    nsp.emplace(v[k],v[k+1]);\n\t    dfs(d+1,nsp);\n\t    nsp.erase(P(v[k],v[k+1]));\n\t    if(flg) return;\n\t  }\n\t  k++;\n\t}\n      }\n      \n    };\n  \n  for(Int i=0;i<n;){\n    Int l=i,r=*upper_bound(ps[0].begin(),ps[0].end(),l);\n    set<P> sp;\n    sp.emplace(l,r);\n    flg=0;\n    dfs(1,sp);\n    string ans=(flg?\"Possible\":\"Impossible\");\n    Int p=i;\n    while(i<n&&dp[p]==dp[i]){\n      cout<<ans<<endl;\n      i++;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define M 200020\n#define INF 1000001000\nusing namespace std;\nint read(){\n\tint nm=0,fh=1; int cw=getchar();\n\tfor(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n\tfor(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n\treturn nm*fh;\n}\nint tot,n,m,pos[M],L[M][21],R[M][21],V[40],rt;\nint RF[M<<3],LF[M<<3],G[M],D[M],MAXN;\nint main(){\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++) pos[i]=read(),D[i]=pos[i]-pos[i-1],G[i]=-(INF<<1);\n\twhile(m) V[tot++]=m,m>>=1; tot++;\n\tfor(int k=0;k<tot;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tR[i][k]=max(R[i-1][k]-1,1);\n\t\t\twhile(i+R[i][k]<=n&&D[i+R[i][k]]<=V[k]) R[i][k]++;\n\t\t}\n\t\tfor(int i=n;i;i--){\n\t\t\tL[i][k]=max(L[i+1][k]-1,1);\n\t\t\twhile(i-L[i][k]>0&&D[i-L[i][k]+1]<=V[k]) L[i][k]++;\n\t\t}\n\t} MAXN=(1<<tot);\n\tfor(int i=2;i<MAXN;i+=2){\n\t\tfor(int k=1;k<tot;k++){\n\t\t\tint w=(1<<k); if(!(i&w)) continue;\n\t\t\tLF[i]=max(LF[i],LF[i^w]+R[LF[i^w]+1][k]);\n\t\t\tRF[i]=max(RF[i],RF[i^w]+L[n-RF[i^w]][k]);\n\t\t} LF[i]=min(LF[i],n),RF[i]=min(RF[i],n);\n\t}\n\tfor(int k=0;k<MAXN;k+=2) G[LF[k]]=max(G[LF[k]],RF[(MAXN-2)^k]);\n\tfor(int i=n-1;i>=0;i--) G[i]=max(G[i],G[i+1]);\n\tfor(int i=1;i<=n;i++) puts(G[i-L[i][0]]+R[i][0]+i-1>=n?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\nusing namespace std;\n\ninline void up(int &x,const int &y){if(x<y)x=y;}\ninline void down(int &x,const int &y){if(x>y)x=y;}\nconst int maxn = 210000;\nconst int maxd = 20;\nconst int maxv = 810000;\n\nint n,V,d,t[maxn];\nint p[maxn];\nint li[maxn*maxd],ri[maxn*maxd],cnt,bel[maxd][maxn];\nint f[maxv],g[maxv];\nint dp[maxn];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&V);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&p[i]);\n\td=0; for(int now=V;now;now>>=1) t[++d]=now; t[++d]=0;\n\tfor(int i=1;i*2<=d;i++) swap(t[i],t[d-i+1]);\n\t\n\tfor(int i=1;i<=d;i++)\n\t{\n\t\tint cc=t[i]; int now=cnt;\n\t\tbel[i][1]=++cnt;\n\t\tli[cnt]=ri[cnt]=1;\n\t\tfor(int j=2;j<=n;j++)\n\t\t{\n\t\t\tif(p[j]-p[j-1]<=cc) ri[bel[i][j]=bel[i][j-1]]=j;\n\t\t\telse li[bel[i][j]=++cnt]=ri[cnt]=j;\n\t\t}\n\t}\n\tint al=1<<d-1;\n\tmemset(f,-1,sizeof f); f[0]=0;\n\tfor(int i=0;i<al;i++) if(f[i]!=-1)\n\t{\n\t\tif(f[i]==n) \n\t\t{\n\t\t\tfor(int j=0;j<d-1;j++) if(!(i>>j&1)) \n\t\t\t\tup(f[i+(1<<j)],f[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=0;j<d-1;j++) if(!(i>>j&1)) \n\t\t\t\tup(f[i+(1<<j)],ri[bel[j+1][f[i]+1]]);\n\t\t}\n\t}\n\tfor(int i=0;i<al;i++) g[i]=n+1;\n\tfor(int i=0;i<al;i++)\n\t{\n\t\tif(g[i]==1)\n\t\t{\n\t\t\tfor(int j=0;j<d-1;j++) if(!(i>>j&1))\n\t\t\t\tdown(g[i+(1<<j)],g[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=0;j<d-1;j++) if(!(i>>j&1))\n\t\t\t\tdown(g[i+(1<<j)],li[bel[j+1][g[i]-1]]);\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++) dp[i]=n+1;\n\tfor(int i=0;i<al;i++) down(dp[f[i]],g[al-1-i]);\n\tfor(int i=n-1;i>=0;i--) down(dp[i],dp[i+1]);\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint l=li[bel[d][i]],r=ri[bel[d][i]];\n\t\tif((r==n&&f[al-1]>=l-1)||(r<n&&dp[l-1]<=r+1)) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 200000\n#define f first\n#define s second\n#define pb push_back\n#define rep(i,a,b) for(i=a;i<=b;i++)\n\nbool bis[maxn+5];\nint bakom,n,v;\nvector<int> vev,vip,sem;\nint x[maxn+5];\nint par[maxn+5];\nint val[maxn+5];\n\nint fp(int mas){\n\tif(mas==par[mas]){\n\t\treturn mas;\n\t}\n\treturn par[mas]=fp(par[mas]);\n}\n\nvoid gabung(int a,int b,int vat){\n\tint aa=fp(a);\n\tint bb=fp(b);\n\tif(aa==bb){\n\t\treturn;\n\t}\n\tbakom--;\n\tassert(b==bb);\n\tpar[bb]=par[aa];\n\tval[bb]=-1;\n\tval[aa]=vat;\n}\n\nvoid gakbisa_semua(){\n\tint i;\n\trep(i,1,n){\n\t\tcout<<\"Impossible\\n\";\n\t}\n\treturn;\n}\n\nint main(){\n\tint i,j;\n\tcin>>n>>v;\n\trep(i,1,n){\n\t\tcin>>x[i];\n\t}\n\tstack<int> tum;\n\twhile(v>0){\n\t\ttum.push(v);\n\t\tv>>=1;\n\t}\n\tvev.pb(0);\n\twhile(!tum.empty()){\n\t\tvev.pb(tum.top());\n\t\ttum.pop();\n\t}\n\trep(i,1,n){\n\t\tpar[i]=i;\n\t}\n\tbakom=n;\n\trep(i,1,(int)vev.size()-1){\n\t\trep(j,2,n){\n\t\t\tif(x[j]-x[j-1]<=vev[i]){\n\t\t\t\tgabung(j-1,j,min(i,max(val[fp(j-1)],val[fp(j)])+1));\n\t\t\t}\n\t\t}\n\t}\n\tint telemax=vev.size()-1;\n\tif(bakom > telemax+1){\n\t\tgakbisa_semua();\n\t\treturn 0;\n\t}\n\trep(i,1,n){\n\t\tif(val[i]!=-1){\n\t\t\tvip.pb(i);\n//\t\t\tcout<<i<<\" \"<<val[fp(i)]<<\"\\n\";\n\t\t}\n\t}\n\trep(i,0,(int)vip.size()-1){\n\t\tsem.pb(val[vip[i]]);\n\t}\n\tsort(sem.begin(),sem.end());\n\tint kur;\n\trep(i,0,(int)vip.size()-1){\n\t\tbis[vip[i]]=1;\n\t\tkur=0;\n\t\trep(j,0,(int)sem.size()-1){\n\t\t\tif(kur==0 && val[vip[i]]==sem[j]){\n\t\t\t\tkur=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(j-kur+telemax-bakom+1 < sem[j]){\n\t\t\t\t\tbis[vip[i]]=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\tif(bis[fp(i)]){\n\t\t\tcout<<\"Possible\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"Impossible\\n\";\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\n#define X first\n#define Y second\n#define N 200010\n#define M 500010\n\ntypedef long long ll;\nconst int INF=1ll<<30;\n\nint x[N],dpl[N<<2],dpr[N<<2],len[20];\nint mxl[20][N],mxr[20][N];\nbool vis1[N<<2],vis2[N<<2];\nvector<int> lis1[N],lis2[N];\n\nint main()\n{\n\t//freopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n\t\n\tint n,m=0,V,tmp,lim; scanf(\"%d%d\",&n,&V);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor (tmp=V;;tmp>>=1) \n\t{\n\t\tlen[m]=tmp;\n\t\tfor (int l=1,r=1;l<=n;l++)\n\t\t{\n\t\t\tr=max(r,l);\n\t\t\twhile (r<n && x[r+1]-x[r]<=tmp) r++;\n\t\t\tmxl[m][l]=r-l+1;\n\t\t\t//cout<<tmp<<\" \"<<l<<\" \"<<mxl[m][l]<<endl;\n\t\t}\n\t\tfor (int r=n,l=n;r>=1;r--)\n\t\t{\n\t\t\tl=min(r,l);\n\t\t\twhile (l>1 && x[l]-x[l-1]<=tmp) l--;\n\t\t\tmxr[m][r]=r-l+1;\n\t\t\t//cout<<tmp<<\" \"<<r<<\" \"<<mxr[m][r]<<endl;\n\t\t}\n\t\tm++;\n\t\tif (tmp==0) break;\n\t}\n\tdpl[0]=dpr[0]=0; lim=1<<m; lim>>=1;\n\tfor (int mask=0;mask<lim;mask++)\n\t{\n\t\tlis1[dpl[mask]].push_back(mask);\n\t\tlis2[dpr[mask]].push_back(mask);\n\t\t//cout<<mask<<\" \"<<dpl[mask]<<\" \"<<dpr[mask]<<endl;\n\t\tfor (int j=0;j<m;j++)\n\t\t{\n\t\t\tif (mask&(1<<j)) continue;\n \t\t\tdpl[mask|(1<<j)]=max(dpl[mask|(1<<j)],dpl[mask]+mxl[j+1][dpl[mask]+1]);\n \t\t\tdpr[mask|(1<<j)]=max(dpr[mask|(1<<j)],dpr[mask]+mxr[j+1][n-dpr[mask]]);\n\t\t}\n\t}\n\tint cnt1=lim,cnt2=0,l=1,r=mxl[0][1];\n\tfor (int i=0;i<lim;i++) \n\t{\n\t\tvis1[i]=true;\n\t\tif (dpr[i]>=n-r) vis2[i]=true,cnt2++;\n\t}\n\tif (cnt2) printf(\"Possible\\n\");\n\telse printf(\"Impossible\\n\");\n\t\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tint nl=i-mxr[0][i]+1,nr=i+mxl[0][i]-1;\t\n\t\t//cout<<nl<<\" \"<<nr<<endl;\n\t\tfor (int j=l-1;j<nl-1;j++)\n\t\t{\n\t\t\tfor (int k=0;k<lis1[j].size();k++)\n\t\t\t{\n\t\t\t\tif (vis1[lis1[j][k]]) \n\t\t\t\t{\n\t\t\t\t\tvis1[lis1[j][k]]=false;\n\t\t\t\t\tcnt1--;\n\t\t\t\t\tif (vis2[(lim-1)^lis1[j][k]]) vis2[(lim-1)^lis1[j][k]]=false,cnt2--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j=n-nr;j<n-r;j++)\n\t\t{\n\t\t\tfor (int k=0;k<lis2[j].size();k++)\n\t\t\t{\n\t\t\t\t//cout<<lis2[j][k]<<\" \"<<((lim-1)^lis2[j][k])<<endl;\n\t\t\t\tif (vis1[(lim-1)^lis2[j][k]]) cnt2++,vis2[lis2[j][k]]=true;\n\t\t\t}\n\t\t}\n\t\tif (cnt2) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t\tl=nl,r=nr;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e5+10,inf=0x3f3f3f3f;\nint tmp,Max[20][maxn],Min[20][maxn],a[maxn],f[1<<20],g[1<<20],R[maxn];\nint main(){\n\tint n=read(),V=read();\n\tREP(i,1,n) a[i]=read();\n\ttmp=-1;\n\tmemset(Min,inf,sizeof(Min));\n\twhile(1){\n\t\t++tmp;\n\t\tint lst=1;\n\t\tREP(i,2,n) if(a[i]-a[i-1]>V){\n\t\t\tchkmax(Max[tmp][lst],i-1);\n\t\t\tchkmin(Min[tmp][i-1],lst);\n\t\t\tlst=i;\n\t\t}\n\t\tchkmax(Max[tmp][lst],n);\n\t\tchkmin(Min[tmp][n],lst);\n\t\tREP(i,1,n) chkmax(Max[tmp][i],Max[tmp][i-1]);\n\t\tMax[tmp][n+1]=n;\n\t\tDREP(i,n,1) chkmin(Min[tmp][i],Min[tmp][i+1]);\n\t\tMin[tmp][0]=1;\n\t\tif(V==0) break;\n\t\tV/=2;\n\t}\n\tmemset(g,inf,sizeof(g));\n\tf[0]=0,g[0]=n+1;\n\tREP(i,0,(1<<tmp)-1)\n\t\tREP(j,1,tmp) if((i&(1<<(j-1)))==0){\n\t\t\tchkmax(f[i|(1<<(j-1))],Max[j][f[i]+1]);\n\t\t\tchkmin(g[i|(1<<(j-1))],Min[j][g[i]-1]);\n\t\t}\n\tmemset(R,inf,sizeof(R));\n\tREP(i,0,(1<<tmp)-1){\n\t\tif(f[i]>=g[i^iend]-1){\n\t\t\tREP(j,1,n) printf(\"Possible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tchkmin(R[f[i]+1],g[i^iend]-1);\n\t}\n\tDREP(i,n,1) chkmin(R[i],R[i+1]);\n\tREP(i,1,n) printf(\"%s\\n\",(R[Min[0][i]]<=Max[0][i])?\"Possible\":\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 1000010\n#define INF 0x3FFFFFFF\nusing namespace std;\nint n,v,logv;\nint x[MAXN];\nint f1[MAXN],f2[MAXN];\nint l[22][MAXN],r[22][MAXN],cnt[22];\nint find_l(int x,int pos){\n\tpos++;\n\tint now=upper_bound(l[x]+1,l[x]+1+cnt[x],pos)-l[x];\n\tnow--;\n\tif(now<=0)\n\t\treturn pos;\n\treturn max(r[x][now],pos-1);\t\n}\nint find_r(int x,int pos){\n\tpos--;\n\tint now=lower_bound(r[x]+1,r[x]+1+cnt[x],pos)-r[x];\n\tif(now>cnt[x])\n\t\treturn pos;\n\treturn min(l[x][now],pos+1);\t\n}\nint ans[MAXN];\nint main(){\n\tmemset(f2,0x3f3f3f3f,sizeof f2);\n\tSF(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++)\n\t\tSF(\"%d\",&x[i]);\t\n\tx[0]=-INF;\n\tx[n+1]=INF;\n\tfor(logv=0;(1<<logv)<=v;logv++);\n\tlogv++;\n\tfor(int i=0;i<logv;i++){\n\t\tint v1=v>>i;\n\t\tcnt[i]=1;\n\t\tl[i][cnt[i]]=1;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(x[j+1]-x[j]>v1){\n\t\t\t\tr[i][cnt[i]]=j;\n\t\t\t\tcnt[i]++;\n\t\t\t\tl[i][cnt[i]]=j+1;\t\n\t\t\t}\n\t\tcnt[i]--;\n\t}\n\tif(cnt[0]>logv){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tPF(\"Impossible\\n\");\n\t\treturn 0;\t\n\t}\n\tf1[0]=0;\n\tf2[0]=n+1;\n\tfor(int mask=0;mask<(1<<logv);mask+=2)\n\t\tfor(int i=1;i<logv;i++)\n\t\t\tif((mask&(1<<i))!=0){\n\t\t\t\tf1[mask]=max(f1[mask],find_l(i,f1[mask^(1<<i)]));\n\t\t\t\tf2[mask]=min(f2[mask],find_r(i,f2[mask^(1<<i)]));\t\n\t\t\t}\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tint lft=l[0][i];\n\t\tint rit=r[0][i];\n\t\tfor(int mask=0;mask<(1<<logv);mask+=2){\n\t\t\tint mask2=((1<<logv)-2)^mask;\n\t\t\tif(f1[mask]>=lft-1&&f2[mask2]<=rit+1){\n\t\t\t\tans[i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint las=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i>r[0][las])\n\t\t\tlas++;\n\t\tif(ans[las]==0)\n\t\t\tPF(\"Impossible\\n\");\n\t\telse\n\t\t\tPF(\"Possible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 2e5 + 5;\nconst int K = 19;\nint n;\nint v[K];\nint k;\nint arr[N];\nint nxt[K][N];\nint prv[K][N];\nint dp1[1 << K];\nint dp2[1 << K];\nint pre(int mask){\n\tif(dp1[mask] != -1){\n\t\treturn dp1[mask];\n\t}\n\tint res = 1;\n\tfor(int i = 1 ; i < k ; ++i){\n\t\tif((mask >> i) & 1){\n\t\t\tint tmp = pre(mask ^ (1 << i));\n\t\t\tres = max(res , nxt[i][tmp + 1] - 1);\n\t\t}\n\t}\n\treturn dp1[mask] = res;\n}\nint suf(int mask){\n\tif(dp2[mask] != -1){\n\t\treturn dp2[mask];\n\t}\n\tint res = n;\n\tfor(int i = 1 ; i < k ; ++i){\n\t\tif((mask >> i) & 1){\n\t\t\tint tmp = suf(mask ^ (1 << i));\n\t\t\tres = min(res , prv[i][tmp - 1] + 1);\n\t\t}\n\t}\n\treturn dp2[mask] = res;\n}\nbool solve(int lft , int rgt){\n\tint mask = (1 << k) - 2;\n\tfor(int i = mask ; i ; i = (i - 1) & mask){\n\t\tif(pre(i) >= lft && suf(mask ^ i) <= rgt){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn pre(0) >= lft && suf(mask) <= rgt;\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tscanf(\"%d\" , &v[0]);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tscanf(\"%d\" , arr + i);\n\t}\n\tk = 1;\n\tfor(int i = 1 ; i < K ; ++i){\n\t\tv[i] = v[i - 1] >> 1;\n\t\tif(v[i]){\n\t\t\tk = i + 1;\n\t\t}\n\t}\n\tv[k++] = 0;\n\tfor(int i = 0 ; i < k ; ++i){\n\t\tnxt[i][n] = n + 1;\n\t\tnxt[i][n + 1] = n + 1;\n\t\tfor(int j = n - 1 ; j >= 1 ; --j){\n\t\t\tif(arr[j + 1] - arr[j] <= v[i]){\n\t\t\t\tnxt[i][j] = nxt[i][j + 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnxt[i][j] = j + 1;\n\t\t\t}\n\t\t}\n\t\tprv[i][1] = 0;\n\t\tprv[i][0] = 0;\n\t\tint steps = 1;\n\t\tfor(int j = 2 ; j <= n ; ++j){\n\t\t\tif(arr[j] - arr[j - 1] <= v[i]){\n\t\t\t\tprv[i][j] = prv[i][j - 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++steps;\n\t\t\t\tprv[i][j] = j - 1;\n\t\t\t}\n\t\t}\n\t\tif(!i && steps > k + 5){\n\t\t\tfor(int i = 1 ; i <= n ; ++i){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmemset(dp1 , -1 , sizeof(dp1));\n\tmemset(dp2 , -1 , sizeof(dp1));\n\tfor(int i = 1 ; i <= n ; i = nxt[0][i]){\n\t\tbool ans = solve(prv[0][i] , nxt[0][i]);\n\t\tfor(int j = i ; j < nxt[0][i] ; ++j){\n\t\t\tputs(ans ? \"Possible\" : \"Impossible\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 2e5 + 5, MAXLOG = 19;\n\nint x[MAXN];\nint ind_l[MAXN][MAXLOG], ind_r[MAXN][MAXLOG];\n\nvi vv;\n\nint dp_l[1 << MAXLOG], dp_r[1 << MAXLOG];\n\nint dp_seg[MAXN];\n\nvoid solve(){\n\tint n, v;\n\tscanf(\"%d%d\", &n, &v);\n\tREP(i, 0, n) {\n\t\tscanf(\"%d\", &x[i]);\n\t}\n\t\n\tfor(; v; v /= 2) {\n\t\tvv.pb(v);\n\t}\n\tvv.pb(0);\n\treverse(BE(vv));\n\tint logv = SZ(vv);\n\t\n\tREP(j, 0, logv) {\n\t\tv = vv[j];\n\t\tfor(int i = 0; i < n; ) {\n\t\t\tint to;\n\t\t\tfor(to = i + 1; to < n && x[to] - x[to - 1] <= v; to++);\n\t\t\tfor(int cur = i; cur < to; cur++) {\n\t\t\t\tind_l[cur][j] = i;\n\t\t\t\tind_r[cur][j] = to - 1;\n\t\t\t}\n\t\t\ti = to;\n\t\t}\n\t}\n\t\n\tREP(i, 0, 1 << logv) {\n\t\tdp_l[i] = -1;\n\t\tdp_r[i] = n;\n\t}\n\t\n\tREP(i, 0, logv) {\n\t\tdp_l[1 << i] = ind_r[0][i];\n\t\tdp_r[1 << i] = ind_l[n - 1][i];\n\t}\n\n\tREP(i, 1, 1 << logv) {\n\t\tint nxt = dp_l[i] + 1;\n\t\tREP(j, 0, logv) {\n\t\t\tif (!(i & (1 << j))) {\n\t\t\t\tif (nxt < n) {\n\t\t\t\t\tdp_l[i | (1 << j)] = max(dp_l[i | (1 << j)], ind_r[nxt][j]);\n\t\t\t\t} else {\n\t\t\t\t\tdp_l[i | (1 << j)] = n - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tnxt = dp_r[i] - 1;\n\t\tREP(j, 0, logv) {\n\t\t\tif (!(i & (1 << j))) {\n\t\t\t\tif (nxt >= 0) {\n\t\t\t\t\tdp_r[i | (1 << j)] = min(dp_r[i | (1 << j)], ind_l[nxt][j]);\n\t\t\t\t} else {\n\t\t\t\t\tdp_r[i | (1 << j)] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREPN(i, 0, n) {\n\t\tdp_seg[i] = n;\n\t}\n\t\n\tREP(i, 1, 1 << (logv - 1)) {\n\t\t//printf(\"%d %d %d\\n\", i, dp_l[i], dp_r[i]);\n\t\t\n\t\tint ind = dp_l[i];\n\t\tdp_seg[ind] = min(dp_seg[ind], dp_r[(1 << (logv - 1)) - 1 - i]);\n\t}\n\t\n\tfor(int i = n - 1; i >= 0; i--) {\n\t\tdp_seg[i] = min(dp_seg[i], dp_seg[i + 1]);\n\t\t//printf(\"%d %d\\n\", i, dp_seg[i]);\n\t}\n\t\n\tREP(i, 0, n) {\n\t\t\n\t\tint l = ind_l[i][logv - 1], r = ind_r[i][logv - 1];\n\t\t//printf(\"%d %d %d\\n\", i, l, r);\n\t\tif (   l != 0 && r != n - 1 && dp_seg[l - 1] <= r + 1 \n\t\t\t|| l == 0 && r != n - 1 && dp_r[(1 << (logv - 1)) - 1] <= r + 1\n\t\t\t|| l != 0 && r == n - 1 && dp_l[(1 << (logv - 1)) - 1] >= l - 1\n\t\t\t|| l == 0 && r == n - 1) {\n\t\t\tprintf(\"Possible\\n\");\n\t\t} else {\n\t\t\tprintf(\"Impossible\\n\");\n\t\t}\n\t}\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> vals;\nint rt[200005][30];\nint lt[200005][30];\nint n,v;\nint pos[200005];\nint memo1[600005];\nint memo2[600005];\nint something[200005];\n\nint dpL(int bitmask){\n    if (memo1[bitmask]!=-1) return memo1[bitmask];\n    if (bitmask==0) return memo1[bitmask] = -1;\n    int ans = 0;\n    for (int x = 0; x<vals.size(); x++){\n        if (bitmask&(1<<x)){\n            ans = max(ans,dpL(bitmask^(1<<x)));\n            ans = max(ans,rt[dpL(bitmask^(1<<x))+1][x]);\n        }\n    }\n    return memo1[bitmask] = ans;\n}\n\nint dpR(int bitmask){\n    if (memo2[bitmask]!=-1) return memo2[bitmask];\n    if (bitmask==0) return memo2[bitmask] = n;\n    int ans = n-1;\n    for (int x = 0; x<vals.size(); x++){\n        if (bitmask&(1<<x)){\n            ans = min(ans,dpR(bitmask^(1<<x)));\n            if (ans==0) break;\n            ans = min(ans,lt[dpR(bitmask^(1<<x))-1][x]);\n        }\n    }\n    return memo2[bitmask] = ans;\n}\n\nint main(){\n    memset(memo1,-1,sizeof(memo1));\n    memset(memo2,-1,sizeof(memo2));\n    scanf(\"%d%d\",&n,&v);\n\n    int t = v;\n    while (t>0){\n        vals.push_back(t);\n        t/=2;\n    }\n    vals.push_back(0);\n    for (int x = 0; x<n; x++){\n        scanf(\"%d\",&pos[x]);\n    }\n    for (int i = 0; i<vals.size(); i++){\n        rt[n-1][i] = n-1;\n        for (int x = n-2; x>=0; x--){\n            rt[x][i] = pos[x+1]-pos[x]<=vals[i]?rt[x+1][i]:x;\n        }\n        lt[0][i] = 0;\n        for (int x = 1; x<n; x++){\n            lt[x][i] = pos[x]-pos[x-1]<=vals[i]?lt[x-1][i]:x;\n        }\n    }\n    for (int x = 0; x<n; x++){\n        something[x] = n+1;\n    }\n    int tempbug = n+1;\n    for (int x = 0; x<(1<<(vals.size())); x+=2){\n        int other = ((1<<(vals.size()))-2)^x;\n        if (dpL(x)==-1) {\n            tempbug = min(tempbug,dpR(other));\n            continue;\n        }\n        something[dpL(x)] = min(something[dpL(x)],dpR(other));\n    }\n    for (int x = n-2; x>=0; x--){\n        something[x] = min(something[x],something[x+1]);\n    }\n    tempbug = min(tempbug,something[0]);\n    for (int x = 0; x<n; x++){\n        int L = lt[x][0];\n        int R = rt[x][0];\n        if (L==0){\n            printf(tempbug<=R+1?\"Possible\\n\":\"Impossible\\n\");\n            continue;\n        }\n        //printf(\"something %d %d\\n\",x,something[x]);\n        //printf(\"L:%d,R:%d\\n\",L,R);\n        printf(something[L-1]<=R+1?\"Possible\\n\":\"Impossible\\n\");\n    }\n    //printf(\"%d\\n\",dpL(6));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int L = 20, N = 201010;\n\nint n, V, x[N], fa[L][N], siz[L][N], ans[N], lt[1 << L], rt[1 << L];\nvector<int> v[N];\n\nint Find(int k, int x) {\n  return fa[k][x] == x ? x : fa[k][x] = Find(k, fa[k][x]);\n}\n\nvoid Merge(int k, int x, int y) {\n  x = Find(k, x), y = Find(k, y);\n  fa[k][y] = x;\n  siz[k][x] += siz[k][y];\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &V);\n  for(int i = 1; i <= n; i++)\n    scanf(\"%d\", &x[i]);\n  int now = V, m;\n  for(int o = L - 1; ; now >>= 1, o = (o + 1) % L) {\n    for(int i = 1; i <= n; i++)\n      fa[o][i] = i, siz[o][i] = 1;\n    for(int i = 1; i <= n; i++) {\n      int j = i;\n      while(j < n && x[j + 1] - x[j] <= now) j++;\n      for(int k = i + 1; k <= j; k++)\n\tMerge(o, i, k);\n      i = j;\n    }\n    if(now == 0) { m = o + 1; break; }\n  }\n\n  for(int i = 0; i < (1 << m); i++)\n    rt[i] = n + 1;\n  for(int i = 0; i < (1 << m); i++) {\n    for(int j = 0; j < m; j++)\n      if(~i >> j & 1) {\n\tlt[i | (1 << j)] = max(lt[i | (1 << j)], lt[i] + siz[j][lt[i] + 1]);\n\trt[i | (1 << j)] = min(rt[i | (1 << j)], Find(j, rt[i] - 1));\n      }\n  }\n  // cerr << lt[27]  <<\" \" << rt[4] << endl;\n\n  int all = (1 << m) - 1; \n  for(int i = 0; i < (1 << m); i++) {\n    v[lt[i]].push_back(rt[all ^ i]);\n    //    cerr << lt[i] << \" \" << rt[all ^ i] << endl;\n  }\n\n  int mi = n + 2;\n  for(int i = 0; i < v[n].size(); i++)\n    mi = min(v[n][i], mi);\n  \n  for(int i = n; i >= 1; i--) {\n    for(int j = 0; j < v[i - 1].size(); j++)\n      mi = min(v[i - 1][j], mi);\n    if(fa[L - 1][i] != i) continue;\n    //cerr << i + siz[L - 1][i] << endl;\n    ans[i] = mi <= i + siz[L - 1][i];\n  }\n  \n  for(int i = 1; i <= n; i++)\n    puts(ans[Find(L - 1, i)] ? \"Possible\" : \"Impossible\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 1000000\n#define INF 2000000000\nusing namespace std;\nint n,V,x[MAXN+5];\nint cnt[25];\nint l[25][MAXN+5],r[25][MAXN+5];\nint f1[MAXN*5+5],f2[MAXN*5+5];\nbool ans[MAXN+5];\nvoid Init()\n{\n\tfor(int i=0;i<=MAXN*5+3;i++)\n\t\tf1[i]=0,f2[i]=INF;\n}\nint UpFind(int id,int pos)\n{\n\tpos++;\n\tint p=upper_bound(l[id]+1,l[id]+cnt[id]+1,pos)-l[id];\n\tp--;\n\tif(p<=0)\n\t\treturn pos;\n\treturn max(r[id][p],pos-1);\n}\nint LowFind(int id,int pos)\n{\n\tpos--;\n\tint p=lower_bound(r[id]+1,r[id]+cnt[id]+1,pos)-r[id];\n\tif(p>=cnt[id]+1)\n\t\treturn pos;\n\treturn min(l[id][p],pos+1);\n}\nint main()\n{\n//\tfreopen(\"oase.in\",\"r\",stdin);\n//\tfreopen(\"oase.out\",\"w\",stdout);\n\tInit();\n\tscanf(\"%d %d\",&n,&V);\n\tint logV=0;\n\tfor(logV=0;(1<<logV)<=V;logV++);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tx[n+1]=INF;\n\tx[0]=-INF;\n\tfor(int LG=0;LG<=logV;LG++)\n\t{\n\t\tint d=V/(1<<LG);\n\t\tcnt[LG]=1;\n\t\tl[LG][1]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tr[LG][cnt[LG]]=i;\n\t\t\tif(x[i+1]-x[i]>d)\n\t\t\t{\n\t\t\t\tcnt[LG]++;\n\t\t\t\tl[LG][cnt[LG]]=i+1;\n\t\t\t}\n\t\t}\n\t\tcnt[LG]--;\n\t}\n\tif(cnt[0]>logV+1)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint all=(1<<(logV+1));\n\tf1[0]=0,f2[0]=n+1;\n\tfor(int s=0;s<all;s+=2)\n\t\tfor(int i=0;i<=logV;i++)\n\t\t{\n\t\t\tif(!(s&(1<<i)))\n\t\t\t\tcontinue;\n\t\t\tf1[s]=max(f1[s],UpFind(i,f1[s-(1<<i)]));\n\t\t\tf2[s]=min(f2[s],LowFind(i,f2[s-(1<<i)]));\n\t\t}\n\tfor(int i=1;i<=cnt[0];i++)\n\t{\n\t\tint ln=l[0][i],rn=r[0][i];\n\t\tfor(int s1=0;s1<all;s1+=2)\n\t\t{\n\t\t\tint s2=all-1-s1-1;\n\t\t\tint lpos=f1[s1];\n\t\t\tint rpos=f2[s2];\n\t\t\tif(lpos>=ln-1&&rpos<=rn+1)\n\t\t\t{\n\t\t\t\tans[i]=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint pos=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(ans[pos]==true)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t\tif(x[i+1]-x[i]>V)\n\t\t\tpos++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cout << #x << \" = \" << (x) << \"\\n\";\n\nconst int maxn = 2e5 + 5;\nconst int logn = 20;\nint n;\nint v[logn];\nint x[maxn];\nint nxt[logn][maxn];\nint prv[logn][maxn];\nint f[1 << logn];\nint g[1 << logn];\nint cnt[maxn];\n\nvoid solve() {\n\tcin >> n >> v[0];\n\tFOR(i, 0, n) cin >> x[i];\n\tint limit = 1;\n\tfor (int i = 0; i < logn && v[i]; i++) v[i + 1] = v[i] >> 1, limit++;\n\tFOR(k, 0, limit) {\n\t\tnxt[k][n - 1] = n - 1;\n\t\tFORd(i, n - 1, 0) {\n\t\t\tnxt[k][i] = i;\n\t\t\tif (x[i + 1] - x[i] <= v[k]) {\n\t\t\t\tnxt[k][i] = nxt[k][i + 1];\n\t\t\t}\n\t\t}\n\t\tprv[k][0] = 0;\n\t\tFOR(i, 1, n) {\n\t\t\tprv[k][i] = i;\n\t\t\tif (x[i] - x[i - 1] <= v[k]) {\n\t\t\t\tprv[k][i] = prv[k][i - 1];\n\t\t\t}\n\t\t}\n\t}\n\tfill_n(f, 1 << limit, -1), fill_n(g, 1 << limit, n);\n\tFOR(msk, 1, 1 << limit) {\n\t\tFOR(i, 0, limit) if (bit(msk, i)) {\n\t\t\tint nmsk = msk ^ (1 << i);\n\t\t\tif (f[nmsk] == n - 1) {\n\t\t\t\tf[msk] = n - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchkmax(f[msk], nxt[i][f[nmsk] + 1]);\n\t\t\t}\n\t\t\tif (g[nmsk] == 0) {\n\t\t\t\tg[msk] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchkmin(g[msk], prv[i][g[nmsk] - 1]);\n\t\t\t}\n\t\t}\n\t}\n\tFOR(msk, 0, 1 << limit) if (!bit(msk, 0)) {\n\t\tint pmsk = (1 << limit) - 1 ^ msk ^ 1;\n\t\tint x = f[msk] + 1;\n\t\tif (nxt[0][x] + 1 >= g[pmsk]) {\n\t\t\tcnt[x]++, cnt[nxt[0][x] + 1]--;\n\t\t}\n\t}\n\tFOR(i, 1, n) cnt[i] += cnt[i - 1];\n\tFOR(i, 0, n) {\n\t\tif (cnt[i]) {\n\t\t\tcout << \"Possible\\n\";\n\t\t}\n\t\telse {\n\t\t\tcout << \"Impossible\\n\";\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); //cin.tie(0);\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tsolve();\n#ifdef _LOCAL_\n\t//printf(\"\\nTime elapsed: %dms\", 1000 * clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define dis(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2e5+233;\nint L[20][maxn],R[20][maxn];\nint f[maxn],g[maxn];\nint ans[maxn]; \nint n,V,tmp,x[maxn],v[21];\nint main(){\n\tn = rd(),V = tmp = rd();\n\tRep(i,1,n) x[i] = rd();\n\ttmp /= 2;\n\twhile(tmp){\n\t\tv[++v[0]] = tmp;\n\t\ttmp /= 2;\n\t}\n\tv[++v[0]] = 0;\n\tRep(d,1,v[0]){\n\t\tfor(int i=1,j=-1;i<=n;i=j+1){\n\t\t\tfor(j=i+1;j<=n && x[j]-x[j-1]<=v[d];j++);j--;\n//\t\t\tprintf(\"[%d %d]\\n\",i,j);\n\t\t\tRep(k,i,j){\n\t\t\t\tL[d][k] = i;\n\t\t\t\tR[d][k] = j;\n\t\t\t}\n\t\t}R[d][n+1] = n;L[d][0] = 1;\n\t}\n\t\n\tfor(int i=1,j=-1;i<=n;i=j+1){\n\t\tfor(j=i+1;j<=n && x[j]-x[j-1]<=V;j++);j--;\n//\t\tprintf(\"[%d %d][%d %d]\\n\",i,j,x[j]-x[i],x[j+1]-x[i]);\n\t\tRep(k,i,j){\n\t\t\tL[0][k] = i;\n\t\t\tR[0][k] = j;\n//\t\t\tprintf(\"L[%d][%d] = %d\\n\",V,k,L[0][k]);\n\t\t}\n\t}R[0][n+1] = n;L[0][0] = 1;\n\trep(i,0,1<<v[0]) f[i] = 0;\n\trep(i,0,1<<v[0]){\n\t\tfor(int j=1;j<=v[0];++j){\n\t\t\tif(i>>(j-1)&1^1){\n\t\t\t\tf[i|(1<<(j-1))] = max(f[i|(1<<(j-1))],R[j][f[i]+1]);\n\t\t\t}//如果不包括，那么可以选择 \n\t\t}\n\t}\n\trep(i,0,1<<v[0]) g[i] = n+1;\n\trep(i,0,1<<v[0]){\n\t\tfor(int j=1;j<=v[0];++j){\n\t\t\tif(i>>(j-1)&1^1){\n\t\t\t\tg[i|(1<<(j-1))] = min(g[i|(1<<(j-1))],L[j][g[i]-1]);\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,0,1<<v[0]){\n//\t\tprintf(\"[%d%d%d%d%d] : %d,%d\\n\",i/16%2,i/8%2,i/4%2,i/2%2,i%2,f[i],g[i]);\n//\t}\n\trep(i,0,1<<v[0]){\n\t\tint j=((1<<v[0])-1)^i;\n//\t\tprintf(\"[%d %d]\\n\",i,j);\n\t\tint pos = f[i]+1;\n\t//\tprintf(\"[%d %d]\\n\",f[i],g[j]);\n\t\tif(f[i]+1 >= g[j]){\n\t\t\tRep(i,1,n) puts(\"Possible\");\n\t\t\treturn 0;\n\t\t} else\n\t\tif(L[0][pos] <= f[i]+1 && g[j]-1 <= R[0][pos]){\n\t\t\tans[L[0][pos]]++;\n\t\t\tans[R[0][pos]+1]--;\n\t\t}//区间可行 \n\t}\n\tRep(i,1,n) ans[i] += ans[i-1];\n\tRep(i,1,n){\n//\t\tprintf(\"{%d %d}\\n\",L[0][i],R[0][i]);\n\t\tif(ans[i]) puts(\"Possible\");\n\t\t\t  else puts(\"Impossible\");\n\t}\n\treturn 0;\n}\n/*\n5 3\n-4 0 1 2 6\n\n11 12\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300005;\n\nint dpL[N], dpR[N];\nint R[20][N], L[20][N];\nint d[N];\nint S[20];\nint a[N];\nint sum[N];\nint n,v;\nint p;\nint id[N];\nint main(){\n    scanf(\"%d%d\",&n,&v);\n    for (int i = 1; i <= n; i++) scanf(\"%d\",&a[i]);\n    for (int i = 1; i < n; i++){\n        d[i] = a[i+1]-a[i];\n        if (d[i] > v) id[i]++;\n    }\n    for (int i = 1; i < n; i++){\n        id[i] += id[i-1];\n    }\n    /*for (int i = 1; i < n; i++){\n        printf(\"%d \",d[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 1; i < n; i++){\n        printf(\"%d \",id[i]);\n    }\n    printf(\"\\n\");*/\n    S[0] = v;\n    for (int i = 1; i <= 18; i++){\n        S[i] = S[i-1]/2;\n        if (S[i] == 0) { p= i+1; break;}\n    }\n    //printf(\"%d \",p);\n    reverse(S,S+p);\n    for (int i = 0; i < p; i++){\n        //printf(\"%d \",S[i]);\n    }\n    for (int i = 0; i < p; i++){\n        R[i][n] = n;\n        for (int j = n-1; j >= 1; j--){\n            R[i][j] = a[j+1]-a[j] <= S[i] ? R[i][j+1] : j;\n        }\n\n        L[i][1] = 1;\n        for (int j = 2; j <= n; j++ ){\n            L[i][j] = a[j]-a[j-1] <= S[i] ? L[i][j-1] : j;\n        }\n        /*printf(\"cur step %d = %d:\\n\",i,S[i]);\n        for (int j = 1; j <= n; j++){\n            printf(\"%d \",R[i][j]);\n        }\n        printf(\"\\n\");\n        for (int j = 1; j <= n; j++){\n            printf(\"%d \",L[i][j]);\n        }\n        printf(\"\\n\");*/\n    }\n    int LIM = (1<<(p-1))-1;\n    for (int i = 0; i <= LIM; i++){\n        dpR[i] = n+1;\n        for (int j = 0; j < p; j++){\n            if (i>>j&1){\n                dpL[i] = max(dpL[i],R[j][dpL[i^(1<<j)]+1]);\n                dpR[i] = min(dpR[i],L[j][dpR[i^(1<<j)]-1]);\n            }\n        }\n        //printf(\"dp of %d : %d %d\\n\",i,dpL[i],dpR[i]);\n    }\n\n    for (int i = 0; i <= LIM; i++){\n        int LL = dpL[i];\n        int RR = dpR[LIM^i];\n        //printf(\"mask %d: left (%d) %d, right (%d) %d\\n\",i,i,LL,LIM^i,RR);\n        //printf(\"ids = %d %d\\n\",id[LL+1],id[RR-2]);\n        if (id[RR-2] == id[LL]) {\n            //printf(\"%d - %d can\\n\",LL+1,RR-1);\n            sum[LL+1]++;\n            sum[RR]--;\n        }\n    }\n    for (int i = 1; i <= n; i++){\n        sum[i] += sum[i-1];\n        //printf(\"%d \",sum[i]);\n        if (sum[i] > 0){\n            printf(\"Possible\\n\");\n        }\n        else{\n            printf(\"Impossible\\n\");\n        }\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 2e05 + 10;\nconst int MAXL = 20 + 5;\n\nint N, V, lgv = 0;\nint a[MAXN];\nint sec[MAXN]= {0};\n\nint extl[MAXN][MAXL]= {0}, extr[MAXN][MAXL]= {0};\nint f[2][MAXN]= {0};\nbool answer[MAXN]= {false};\nvoid work (int p, int l, int r) {\n\tint n = lgv - 1;\n\tint limit = (1 << n) - 1;\n\tf[p][0] = l - 1;\n\tfor (int state = 1; state <= limit; state ++) {\n\t\tf[p][state] = l - 1;\n\t\tfor (int j = 1; j <= n; j ++)\n\t\t\tif (state & (1 << (j - 1))) {\n\t\t\t\tint pre = f[p][state ^ (1 << (j - 1))];\n\t\t\t\tf[p][state] = max (f[p][state], f[p][state ^ (1 << (j - 1))]);\n\t\t\t\tf[p][state] = max (f[p][state], extr[pre + 1][j]);\n\t\t\t}\n\t}\n}\nvoid solve () {\n\tint n = lgv - 1;\n\tint cnt = 0;\n\tfor (int i = 1; i <= N; i ++) {\n\t\tif (extl[i][lgv] == extl[i - 1][lgv] && extr[i][lgv] == extr[i - 1][lgv]) {\n\t\t\tanswer[i] = answer[i - 1];\n\t\t\tcontinue;\n\t\t}\n\t\tcnt ++;\n\t\tif (cnt > lgv) {\n\t\t\tfor (int j = 1; j <= N; j ++) answer[j] = false;\n\t\t\treturn ;\n\t\t}\n\t\tint pl = extl[i][lgv], pr = extr[i][lgv];\n\t\tif (pl != 1) work (0, 1, pl - 1);\n\t\tif (pr != N) work (1, pr + 1, N);\n\t\tint limit = (1 << n) - 1;\n\t\tif (pl == 1) answer[i] = f[1][limit] >= N;\n\t\telse if (pr == N) answer[i] = f[0][limit] >= pl - 1;\n\t\telse {\n\t\t\tfor (int state = 1; state <= limit; state ++)\n\t\t\t\tif (f[0][state] >= pl - 1 && f[1][limit ^ state] >= N) {\n\t\t\t\t\tanswer[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint getnum () {\n\tint num = 0;\n\tchar ch = getchar ();\n\tbool isneg = false;\n\n\twhile (! isdigit (ch)) {\n\t\tif (ch == '-') isneg = true;\n\t\tch = getchar ();\n\t}\n\twhile (isdigit (ch))\n\t\tnum = (num << 3) + (num << 1) + ch - '0', ch = getchar ();\n\n\treturn isneg ? - num : num;\n}\n\nint main () {\n\tN = getnum (), V = getnum ();\n\tfor (int i = 1; i <= N; i ++)\n\t\ta[i] = getnum ();\n\tfor (int s = V; s > 0; s >>= 1)\n\t\tsec[++ lgv] = s;\n\tsec[++ lgv] = 0;\n\treverse (sec + 1, sec + lgv + 1);\n\tfor (int l = 1; l <= lgv; l ++) {\n\t\tfor (int i = 1; i <= N; i ++) {\n\t\t\tif (i == 1) extl[i][l] = 1;\n\t\t\telse extl[i][l] = a[i] - a[i - 1] <= sec[l] ? extl[i - 1][l] : i;\n\t\t}\n\t\tfor (int i = N; i >= 1; i --) {\n\t\t\tif (i == N) extr[i][l] = N;\n\t\t\telse extr[i][l] = a[i + 1] - a[i] <= sec[l] ? extr[i + 1][l] : i;\n\t\t}\n\t}\n\t/*for (int l = 1; l <= lgv; l ++) {\n\t\tcout << \"now: \" << sec[l] << endl;\n\t\tfor (int i = 1; i <= N; i ++)\n\t\t\tcout << extl[i][l] << ' ' << extr[i][l] << endl;\n\t}*/\n\tsolve ();\n\tfor (int i = 1; i <= N; i ++)\n\t\tanswer[i] ? puts (\"Possible\") : puts (\"Impossible\");\n\n\treturn 0;\n}\n\n/*\n3 2\n1 3 6\n*/\n\n/*\n7 2\n-10 -4 -2 0 2 4 10\n*/\n\n/*\n16 19\n-49 -48 -33 -30 -21 -14 0 15 19 23 44 52 80 81 82 84\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)\n#define trav(it, v) for(typeof((v).begin()) it = (v).begin(); it != (v).end(); ++it)\n#define all(v) (v).begin(), (v).end()\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n\ntypedef double fl;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\t\nint N, V;\nint x[200005];\nint nodeInd;\n\nstruct Node{\n\tint l, r;\n\tint v;\n\tvector<Node> children;\n\tint ind;\n\n\tNode(int _l, int _r, int _v){\n\t\tind=nodeInd++;\n\t\tl=_l;\n\t\tr=_r;\n\t\tv=_v;\n\t\tif(!v)\n\t\t\treturn;\n\t\tint L=l;\n\t\trep(i,l+1,r){\n\t\t\tif(x[i] > x[i-1]+v){\n\t\t\t\tchildren.push_back(Node(L, i, v/2));\n\t\t\t\tL=i;\n\t\t\t}\n\t\t}\n\t\tchildren.push_back(Node(L, r, v/2));\n\t}\n};\n\nbool ans[200005];\nmap<vector<int>, bool> cache;\n\nbool rec(vector<Node*> nodes, int stepsLeft, bool init){\n\tvector<int> key;\n\trep(i,0,nodes.size()){\n\t\tkey.push_back(nodes[i]->ind);\n\t}\n\tif(cache.count(key))\n\t\treturn cache[key];\n\tif(nodes.empty())\n\t\treturn true;\n\tif(nodes[0]->v == 0)\n\t\treturn nodes.size() == 1;\n\tvector<Node*> newNodes;\n\trep(i,0,nodes.size()){\n\t\tif(newNodes.size()+nodes[i]->children.size() > stepsLeft)\n\t\t\treturn 0;\n\t\trep(j,0,nodes[i]->children.size())\n\t\t\tnewNodes.push_back(&(nodes[i]->children[j]));\n\t}\n\t/*bool hasUrgent=false;\n\trep(i,0,newNodes.size())\n\t\tif(newNodes[i]->children.size() > 1)\n\t\t\thasUrgent = true;*/\n\trep(i,0,newNodes.size()){\n\t\tvector<Node*> newNewNodes = newNodes;\n\t\tnewNewNodes.erase(newNewNodes.begin()+i);\n\t\tif(rec(newNewNodes, stepsLeft-1, 0)){\n\t\t\tif(init){\n\t\t\t\trep(j,newNodes[i]->l,newNodes[i]->r)\n\t\t\t\t\tans[j]=true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcache[key]=true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tcache[key]=false;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\", &N, &V);\n\trep(i,0,N)\n\t\tscanf(\"%d\", x+i);\n\tNode start(0, N, V);\n\tvector<Node*> v;\n\tv.push_back(&start);\n\tint stepsLeft=18;\n\trec(v,stepsLeft,1);\n\trep(i,0,N){\n\t\tputs(ans[i]?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nvector<int> f(int N, int M, vector<int> dx) {\n\tvector<vector<int> > nxt(N + 1, vector<int>(M));\n\trep(j, M) nxt[N][j] = nxt[N - 1][j] = N;\n\tfor (int i = N - 2; i >= 0; i--) {\n\t\tnxt[i] = nxt[i + 1];\n\t\tfor (int j = dx[i]; j < M; j++) nxt[i][j] = i + 1;\n\t}\n\tvector<int> dp(1<<M);\n\trep(S, 1<<M)\n\t\trep(j, M) if (!(S>>j & 1)) {\n\t\t\tint _S = S | 1<<j;\n\t\t\tdp[_S] = max(dp[_S], nxt[dp[S]][j]);\n\t\t}\n\treturn dp;\n}\n\nvector<int> solve() {\n\tint N, V; cin >> N >> V;\n\tvector<int> x(N);\n\trep(i, N) scanf(\"%d\", &x[i]);\n\tvector<int> dx(N - 1);\n\trep(i, N - 1) dx[i] = x[i + 1] - x[i];\n\tbool ok2 = true;\n\trep(i, N - 1) if (dx[i] > V) ok2 = false;\n\tif (ok2) return vector<int>(N, true);\n\tvector<int> v;\n\tfor (int _V = V; _V; _V /= 2) v.pb(_V);\n\tv.pb(0);\n\tint M = v.size();\n\trep(i, N - 1) {\n\t\tint k;\n\t\tfor (k = 0; dx[i] <= v[k]; k++);\n\t\tdx[i] = k;\n\t}\n\tunion_find uf(N);\n\trep(i, N - 1) if (dx[i]) uf.unite(i, i + 1);\n\tvector<int> dp1 = f(N, M, dx);\n\treverse(dx.begin(), dx.end());\n\tvector<int> dp2 = f(N, M, dx);\n\tvector<bool> ok(N);\n\trep(S, 1<<(M - 1)) {\n\t\tint S1 = S<<1, S2 = (((1<<(M - 1)) - 1) - S)<<1;\n\t\tint i = min(dp1[S1], N - 1), j = max(0, N - 1 - dp2[S2]);\n\t\tif (uf.same(i, j)) ok[uf.find(i)] = true;\n\t}\n\tvector<int> ans(N);\n\trep(i, N) ans[i] = ok[uf.find(i)];\n\treturn ans;\n}\n\nint main() {\n\tvector<int> ans = solve();\n\tfor (int z: ans) if (z) printf(\"Possible\\n\"); else printf(\"Impossible\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int N = 200005;\n\ninline void gi(int &x){\n\tint f = 1; x = 0; char c = getchar();\n\twhile(c < '0' || c > '9'){\n\t\tif(c == '-')f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9'){\n\t\tx = x * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tx *= f;\n}\nint n, v, a[N], vis[N], ans[N], fr[N], nex[N];\n#define del(x) fr[nex[x]] = fr[x], nex[fr[x]] = nex[x];\nint walk(int st, int vv){\n\tint i, j; vis[st] = j = 1; del(st);\n\tfor(i = st; i > 1 && !vis[i - 1] && a[i] - a[i - 1] <= vv; j ++)\n\t\tvis[-- i] = 1, del(i);\n\tfor(i = st; i < n && !vis[i + 1] && a[i + 1] - a[i] <= vv; j ++)\n\t\tvis[++ i] = 1, del(i);\n\treturn j;\n}\nbool check(int st){\n\tint i, j, k, tv = v, id, las;\n\tfor(i = 0; i <= n; i ++)\n\t\tvis[i] = 0, fr[i] = i - 1, nex[i] = i + 1;\n\tk = walk(st, v), las = v, tv >>= 1;\n\twhile(1){\n\t\tfor(i = nex[0], j = 0; i < n; i = nex[i])\n\t\t\tif(!vis[i] && !vis[i + 1] && a[i + 1] - a[i] <= tv)\n\t\t\t\tif(a[i + 1] - a[i] > j)\n\t\t\t\t\tid = i, j = a[i + 1] - a[i];\n\t\tif(j == 0){tv = las; break;}\n\t\tlas = tv, tv >>= 1, k += walk(id, las);\n\t}\n\tif(k == n || (1 << n - k - 1) <= las)\n\t\treturn 1;\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k = 0; gi(n), gi(v);\n\tfor(i = 1; i <= n; i ++)\n\t\tgi(a[i]);\n\tfor(i = 1; i <= n; i = j + 1){\n\t\tk ++;\n\t\t//int flag = ans[i] = check(i);\n\t\tfor(j = i; j < n && a[j + 1] - a[j] <= v; j ++);\n\t\t\t//ans[++ j] = flag;\n\t}\n\tif(k <= 30 && (1 << k - 2) <= v){\n\t\tfor(i = 1; i <= n; i = j + 1){\n\t\t\tint flag = ans[i] = check(i);\n\t\t\tfor(j = i; j < n && a[j + 1] - a[j] <= v; )\n\t\t\t\tans[++ j] = flag;\n\t\t}\n\t}\n\tfor(i = 1; i <= n; i ++)\n\t\tputs(ans[i] ? \"Possible\" : \"Impossible\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 524289\nusing namespace std;\nint s[maxn][20],t[maxn][20];\nint dpl[maxn],dpr[maxn],tag[maxn],n,v,x[maxn],y[20],mx,p;\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\ty[p++]=v;\n\tdo{y[p++]=v/=2;}while(v);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n\tfor(int i=0;i<p;++i)\n\t\tfor(int j=1,k,l;j<=n;j=k){\n\t\t\tfor(k=j+1;k<=n&&x[k]-x[k-1]<=y[i];k++);\n\t\t\tfor(l=j;l<k;l++)s[l][i]=k-1,t[l][i]=j;\n//\t\t\tprintf(\"[%d,%d,%d,(%d,%d)]\",y[i],j,k-1,x[k],x[k-1]);\n\t\t}\n\tdpl[0]=0,dpr[0]=n+1;\n\tfor(int i=1;i<(1<<p);i++)if(~i&1){\n\t\tdpl[i]=0,dpr[i]=n+1;\n\t\tfor(int j=0;j<p;++j)if(i&(1<<j))\n\t\t\tdpl[i]=max(dpl[i],dpl[i^(1<<j)]>=n?n:s[dpl[i^(1<<j)]+1][j]),\n\t\t\tdpr[i]=min(dpr[i],dpr[i^(1<<j)]<=1?1:t[dpr[i^(1<<j)]-1][j]);\n//\t\tprintf(\"[l=%d,r=%d]\\n\",dpl[i],dpr[i]);\n\t}\n\tfor(int i=0;i<(1<<p);++i)if(~i&1){\n\t\tint l=dpl[i],r=dpr[(1<<p)-1-i-1];\n//\t\tprintf(\"[%d,%d,%d]\",l,r,s[l+1][0]);\n\t\tif(l+1>=r)tag[1]++;\n\t\telse if(s[l+1][0]+1>=r)tag[t[l+1][0]]++,tag[s[l+1][0]+1]--;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tmx+=tag[i];\n\t\tif(mx>0)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <utility>\n#include <cstdlib>\n#include <memory>\n#include <queue>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <complex>\n#include <bitset>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n\nusing namespace std;\n\n#define ws ws_____________________\n#define y1 y1_____________________\n#define y0 y0_____________________\n#define left left_________________\n#define right right_______________\n#define next next_________________\n#define prev prev_________________\n#define hash hash_________________\n\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair \n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; --i)\n#define all(C) begin(C), end(C)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vii;\ntypedef long double ld;\ntypedef complex<double> cd;\n\n#ifdef LOCAL\n#define eprintf(args...) fprintf(stderr, args), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define FILE_NAME \"a\"\n\nint n, V;\nvi xs;\n\nbool read() {\n\tif  (scanf(\"%d%d\", &n, &V) < 2) {\n\t\treturn 0;\n\t}\n\txs.resize(n);\n\tforn(i, n) {\n\t\tscanf(\"%d\", &xs[i]);\n\t}\n\treturn 1;\n}\n\nvector<vii> segs;\nvi Vs;\n\nvii getSegs(const int v) {\n\tvii s;\n\tforn(i, sz(xs)) {\n\t\tif  (s.empty()) {\n\t\t\ts.pb(mp(i, i));\n\t\t} else if  (xs[i] - xs[s.back().snd] <= v) {\n\t\t\ts.back().snd = i;\n\t\t} else {\n\t\t\ts.pb(mp(i, i));\n\t\t}\n\t}\n\treturn s;\n}\n\ninline bool bit(int mask, int i) {\n\treturn (mask >> i) & 1;\n}\n\nvi calcDp(const vector<vii>& segs) {\n\tvi dp(1 << sz(segs), 0);\n\tqueue<int> q;\n\tq.push(0);\n\twhile (!q.empty()) {\n\t\tconst int mask = q.front();\n\t\tq.pop();\n\n\t\tforn(i, sz(segs)) {\n\t\t\tif  (!bit(mask, i)) {\n\t\t\t\tconst int nmask = mask ^ (1 << i);\n\t\t\t\tint ptr = lower_bound(all(segs[i]), mp(0, dp[mask]), [](const pii& a, const pii& b) { return a.snd < b.snd; }) - segs[i].begin();\n\t\t\t\tint ndp = dp[mask];\n\t\t\t\tif  (ptr < sz(segs[i])) {\n\t\t\t\t\tndp = segs[i][ptr].snd + 1;\n\t\t\t\t}\n\t\t\t\tif  (dp[nmask] < ndp) {\n\t\t\t\t\tdp[nmask] = ndp;\n\t\t\t\t\tq.push(nmask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp;\n}\n\nvoid solve() {\n\tVs.clear();\n\tsegs.clear();\n\n\twhile (V) {\n\t\tVs.pb(V);\n\t\tV /= 2;\n\t}\n\tVs.pb(0);\n\n\tfor (int v : Vs) {\n\t\tsegs.pb(getSegs(v));\n\t}\n\n\teprintf(\"segs:\\n\");\n\tforn(i, sz(segs)) {\n\t\teprintf(\"%d: \", i);\n\t\tforn(j, sz(segs[i])) {\n\t\t\teprintf(\"[%d, %d] \", segs[i][j].fst, segs[i][j].snd);\n\t\t}\n\t\teprintf(\"\\n\");\n\t}\n\n\tvi dp_pref = calcDp(segs);\n\n\tfor (auto& s : segs) {\n\t\treverse(all(s));\n\t\tfor (auto& seg : s) {\n\t\t\tswap(seg.fst, seg.snd);\n\t\t\tseg.fst = n - 1 - seg.fst;\n\t\t\tseg.snd = n - 1 - seg.snd;\n\t\t}\n\t}\n\tvi dp_suff = calcDp(segs);\n\tforn(mask, sz(dp_suff)) {\n\t\tdp_suff[mask] = n - dp_suff[mask] - 1;\n\t}\n\tfor (auto& s : segs) {\n\t\treverse(all(s));\n\t\tfor (auto& seg : s) {\n\t\t\tswap(seg.fst, seg.snd);\n\t\t\tseg.fst = n - 1 - seg.fst;\n\t\t\tseg.snd = n - 1 - seg.snd;\n\t\t}\n\t}\n\n\tconst int full = (1 << sz(segs)) - 1;\n\tvi ok(n, 0);\n\tif  (dp_pref[full ^ (1 << 0)] == n) {\n\t\teprintf(\"ALL OK\\n\");\n\t\tok = vi(n, 1);\n\t} else {\n\t\tforn(mask, 1 << sz(segs)) {\n\t\t\tif  (bit(mask, 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint ptr = lower_bound(all(segs[0]), mp(0, dp_pref[mask]), [](const pii& a, const pii& b) { return a.snd < b.snd; }) - segs[0].begin();\n\t\t\tassert(ptr < sz(segs[0]));\n\n\t\t\tconst int end_id = segs[0][ptr].snd;\n\t\t\tconst int inv_mask = full ^ mask ^ (1 << 0);\n\t\t\tif  (dp_suff[inv_mask] <= end_id) {\n\t\t\t\tint l, r;\n\t\t\t\ttie(l, r) = segs[0][ptr];\n\t\t\t\tif  (!ok[l]) {\n\t\t\t\t\tfor (int i = l; i <= r; ++i) {\n\t\t\t\t\t\tok[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tforn(i, n) {\n\t\tprintf(\"%s\\n\", ok[i] ? \"Possible\" : \"Impossible\");\n\t}\n\tprintf(\"\\n\");\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(FILE_NAME \".in\", \"r\", stdin);\n\t// freopen(FILE_NAME \".out\", \"w\", stdout);\n#endif\n\n\twhile (read()) {\n\t\tsolve();\n\t}\n\n#ifdef LOCAL\n\teprintf(\"Time: %.10f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const bool submit = 1;\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) if(!submit) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint N,V;\nconst int MN=200000;\nconst int MD=19;\nint D;\nint x_[MN];\nint d[MN-1];\nint xv2id[MN][MD];\n\nconst int MX=MN*MD;\nint id2v[MX];\nint id2l[MX];\nint id2r[MX];\nint I;\n\n\ntypedef vector<int> VI;\n\nVI getnext(int pid,int lim){\n\tint v = id2v[pid];\n\tint l = id2l[pid];\n\tint r = id2r[pid];\t//[l,r)\n\tv++;\n\tVI ret;\n\tint id=xv2id[l][v];\n\twhile(true){\n\t\tret.pb(id);\n\t\tif(id2r[id]==r) break;\n\t\tid++;\n\t\tif(ret.size()>lim) return {-1};\n\t}\n\treturn ret;\n}\n\n\nmap<VI,bool> memo;\n\nbool anstmp[MN];\n\nbool can(VI vi,int v){\n\tshow(vi);\n\tshow(v);\n\tif(vi.empty()) return 1;\n\tif(vi.size()>D-v) return 0;\n\tint K = vi.size();\n\tint lim = D-v;\n\tVI vs[K];\n\tint sz[K];\n\tint sum=0;\n\trep(i,K){\n\t\tvs[i]=getnext(vi[i],lim);\n\t\tshow(vs[i]);\n\t\tsz[i]=vs[i].size();\n\t\tif(vs[i].front()==-1) sz[i]=100;\n\t\tsum+=sz[i];\n\t}\n\trep(i,K){\n//\t\tshow(sum-sz[i]);\n\t\tif(sum-sz[i]>lim) continue;\n\t\tVI nvi;\n\t\trep(j,K) if(j!=i){\n\t\t\tfor(int u:vs[j]) nvi.pb(u);\n\t\t}\n\t\tif(can(nvi,v+1)){\n\t\t\tmemo[vi]=1;\n\t\t\tif(v==0){\n\t\t\t\tanstmp[i]=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\tmemo[vi]=0;\n\treturn 0;\n}\n\nbool ans[MN];\n\nint main(){\n\tcin>>N>>V;\n\trep(i,N) cin>>x_[i];\n\trep(i,N-1) d[i]=x_[i+1]-x_[i];\n\trep(v,MD){\n\t\tint l=0;\n\t\trep(x,N){\n\t\t\tif(x==N-1 || d[x]>V){\n\t\t\t\tfor(int i=l;i<=x;i++) xv2id[i][v]=I;\n\t\t\t\tid2v[I]=v;\n\t\t\t\tid2l[I]=l;\n\t\t\t\tid2r[I]=x+1;\n\n\t\t\t\t// show(I);\n\t\t\t\t// show(v);\n\t\t\t\t// printf(\"(%d,%d]\\n\",l,x+1);\n\t\t\t\t// puts(\"\");\n\t\t\t\tI++;\n\t\t\t\tl=x+1;\n\t\t\t}\n\t\t}\n\t\tV/=2;\n\t\tif(V==0){\n\t\t\tD=v+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint K = xv2id[N-1][0]+1;\n\n\tif(K>D){\n\t\trep(i,N){\n\t\t\tputs(\"Impossible\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvector<int> be;\n\trep(i,K) be.pb(i);\n\n\tcan(be,0);\n\trep(i,K){\n\t\tint l = id2l[i];\n\t\tint r = id2r[i];\n\t\tbool tmp = anstmp[i];\n\t\tfor(int x=l;x<r;x++) ans[x]=tmp;\n\t}\n\trep(i,N){\n\t\tif(ans[i]) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n\n#define fo(i, a, b) for (i = a; i <= b; i++)\n#define fd(i, a, b) for (i = a; i >= b; i--)\n\nusing namespace std;\n\nconst int maxn = 200000 + 10, lgn = 20;\n\nint f[maxn * 5], g[maxn * 5], mi[maxn], left[maxn][lgn + 10];\nint right[maxn][lgn + 10], v[lgn + 10], x[maxn];\nint i, j, k, l, r, s, t, n, m, tot, top;\n\nint main() {\n  scanf(\"%d%d\", &n, &t);\n  fo(i, 1, n) scanf(\"%d\", &x[i]);\n  v[0] = t, t /= 2;\n  while (t) v[++top] = t, t /= 2;\n  v[++top] = 0, reverse(v, v + top + 1);\n  fo(j, 0, top) {\n    left[1][j] = 1;\n    fo(i, 2, n) if (x[i] - x[i - 1] <= v[j]) left[i][j] = left[i - 1][j];\n    else left[i][j] = i;\n    right[n][j] = n;\n    fd(i, n - 1, 1) if (x[i + 1] - x[i] <= v[j]) right[i][j] = right[i + 1][j];\n    else right[i][j] = i;\n  }\n  f[0] = 0, g[0] = n + 1;\n  fo(s, 1, (1 << (top + 1)) - 1) {\n    f[s] = 0, g[s] = n + 1;\n    fo(i, 0, top) if (s & (1 << i)) {\n      r = s ^ (1 << i);\n      if (f[r] == n)\n        f[s] = n;\n      else\n        f[s] = max(f[s], right[f[r] + 1][i]);\n      if (g[r] == 1)\n        g[s] = 1;\n      else\n        g[s] = min(g[s], left[g[r] - 1][i]);\n    }\n  }\n  fo(i, 0, n) mi[i] = n + 2;\n  fo(i, 0, (1 << top) - 1) {\n    r = ((1 << top) - 1) ^ i;\n    mi[f[i]] = min(mi[f[i]], g[r]);\n  }\n  fd(i, n - 1, 0) mi[i] = min(mi[i], mi[i + 1]);\n  fo(i, 1, n) {\n    l = left[i][top];\n    r = right[i][top];\n    if (mi[l - 1] <= r + 1)\n      printf(\"Possible\\n\");\n    else\n      printf(\"Impossible\\n\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nconst int N=2*(1e5)+10,ST=1<<20,TOP=20,inf=2e9;\nint seg[TOP+1][N],d[N],tor[ST],tol[ST],a[N];\nint n,m,v,lg,all;\nbool in(int st,int x){return st>>x-1&1;}\nint St(int x){return 1<<x-1;}\nvoid get_seg(){\n    for (int i=1;i<=lg;++i){\n        seg[i][0]=0;\n        for (int j=1;j<=n;++j){\n            if (j==1||d[j-1]>v>>i-1) ++seg[i][0];\n            seg[i][seg[i][0]]=j;\n        }\n    }\n}\nbool firstcheck(){\n    if (seg[1][0]<=lg) return true;\n    for (int i=1;i<=n;++i) printf(\"Impossible\\n\");\n    return false;\n}\nint expand_right(int which,int x){\n    int l=1,r=seg[which][0],mid,ret=r;\n    while (l<=r){\n        mid=l+r>>1;\n        if (seg[which][mid]>x) ret=mid,r=mid-1;\n        else l=mid+1;\n    }\n    return seg[which][ret];\n}\nint expand_left(int which,int x){\n    int l=1,r=seg[which][0],mid,ret=l;\n    while (l<=r){\n        mid=l+r>>1;\n        if (seg[which][mid]<x) ret=mid,l=mid+1;\n        else r=mid-1;\n    }\n    return seg[which][ret]+1;\n}\nvoid dp(){\n    all=1<<lg;\n    for (int st=0;st<all;++st) tor[st]=0,tol[st]=n+1;\n    for (int st=0;st<all;st+=2){\n        for (int i=2;i<=lg;++i){\n            if (in(st,i)) continue;\n            tor[st|St(i)]=max(tor[st|St(i)],expand_right(i,tor[st]));\n            tol[st|St(i)]=min(tol[st|St(i)],expand_left(i,tol[st]-1));\n        }\n    }\n}\nvoid get_ans(){\n    int L,R;\n    bool ok;\n    for (int i=1;i<=seg[1][0];++i){\n        L=i==1?1:seg[1][i-1]+1; R=seg[1][i];\n        ok=false;\n        for (int st=0;st<all&&!ok;st+=2)\n            if (L-1<=tor[st]&&tol[(all-1)-st-1]<=R+1) ok=true;\n        for (int j=L;j<=R;++j) printf(ok?\"Possible\\n\":\"Impossible\\n\");\n    }\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&v);\n    for (int i=1;i<=n;++i) scanf(\"%d\",a+i);\n    d[n]=inf;\n    for (int i=1;i<n;++i) d[i]=a[i+1]-a[i];\n    lg=0;\n    while ((v>>lg)>0) ++lg;\n    ++lg;\n    get_seg();\n    if (!firstcheck()) return 0;\n    dp();\n    get_ans();\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n首先跳跃次数最多是 logV ，每次跳跃后，可以通过普通的移动走尽可能多的点。\n那么按照 V 分 logV 层，每层 [1, n] 被拆分为若干线段，\n每个线段 [l, r] 表示在该层内从这个区间任一点开始可以遍历整个区间。\n那么问题转换为钦定第一层线段，求是否能从其他层中每层拿一个线段使得所有线段的并为 [1, n] 。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 400005, maxk = 20;\nint x[maxn];\nint exl[maxn], exr[maxn];\nint l[maxk][maxn], r[maxk][maxn];\nint len[maxk];\n\nint main() {\n\tint n = read, v = read;\n\tfor(int i = 1; i <= n; i ++)\n\t\tread(x[i]);\n\n\tint d = 0;\n\twhile(v) {\n\t\tlen[d ++] = v;\n\t\tv >>= 1;\n\t}\n\t++ d;\n\n\tfor(int k = 0; k < d; k ++) {\n\t\tl[k][1] = 1;\n\t\tfor(int i = 2; i <= n; i ++)\n\t\t\tif(x[i - 1] + len[k] >= x[i])\n\t\t\t\tl[k][i] = l[k][i - 1];\n\t\t\telse\n\t\t\t\tl[k][i] = i;\n\n\t\tr[k][n] = n;\n\t\tfor(int i = n - 1; i; i --)\n\t\t\tif(x[i] + len[k] >= x[i + 1])\n\t\t\t\tr[k][i] = r[k][i + 1];\n\t\t\telse\n\t\t\t\tr[k][i] = i;\n\t}\n\n\tfor(int S = 0; S < (1 << d); S ++) {\n\t\texl[S] = 0;\n\t\texr[S] = n + 1;\n\t\tfor(int k = 0; k < d; k ++)\n\t\t\tif(S >> k & 1) {\n\t\t\t\tint T = S ^ (1 << k);\n\t\t\t\texl[S] = std::max(exl[S], r[k][exl[T] + 1]);\n\t\t\t\texr[S] = std::min(exr[S], l[k][exr[T] - 1]);\n\t\t\t}\n\t\t/* debug(\"%d: %d %d\\n\", S, exl[S], exr[S]); */\n\t}\n\n\tint tot = 0;\n\tfor(int i = 1; i <= n; i = r[0][i] + 1) {\n\t\t++ tot;\n\t\tif(tot >= maxk) {\n\t\t\tfor(int j = i; j <= n; j ++)\n\t\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t\tbool ok = 0;\n\t\tfor(int S = 0; S < (1 << d); S += 2) {\n\t\t\tint T = ((1 << d) - 2) ^ S ;\n\t\t\tif(exl[S] + 1 >= exr[T] or (exl[S] + 1 >= i and r[0][i] + 1 >= exr[T])) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j = i; j <= r[0][i]; j ++)\n\t\t\tif(ok)\n\t\t\t\tputs(\"Possible\");\n\t\t\telse\n\t\t\t\tputs(\"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<stdlib.h>\n#include<string.h>\n#include<queue>\n#define LL long long\n#define NJ !((i>>(j-1))&1)\n#define SJ i^(1<<(j-1))\nusing namespace std;\ninline int read( )\n{\n  int sum=0;char c=getchar( );bool f=0;\n  while(c<'0'||c>'9') {if(c=='-') f=1;c=getchar( );}\n  while(c>='0'&&c<='9') {sum=sum*10+c-'0';c=getchar( );}\n  if(f) return -sum;\n  return sum;\n}\nconst int K=200005;\nconst int N=25;\nconst int M=(1<<19)+5;\nint n,V,X[K],s[N],f[M],g[M];\nint tot,L[N][M],R[N][M],FM[N];\ninline void MX(int &x,int y) {if(y>x) x=y;}\ninline void MN(int &x,int y) {if(y<x) x=y;}\nint main( )\n{\n  int i,j,x,y,t;\n  n=read( );V=read( );\n  for(i=1;i<=n;i++) X[i]=read( );\n  for(j=V;;j>>=1)\n    {\n      s[++tot]=j;\n      for(i=1,t=1;i<=n;i++)\n\t{\n\t  t=max(t,i);\n\t  while(t<n&&X[t+1]-X[t]<=j) t++;\n\t  L[i][tot]=t;\n\t}\n      L[n+1][tot]=n;\n      for(i=n,t=n;i>=1;i--)\n\t{\n\t  t=min(t,i);\n\t  while(t>1&&X[t]-X[t-1]<=j) t--;\n\t  R[i][tot]=t;\n\t}\n      R[0][tot]=1;\n      if(!j) break;\n    }\n  int S=1<<tot;\n  for(i=0;i<S;i++) g[i]=n+1;\n  for(i=0;i<S;i++)\n    for(x=f[i],y=g[i],j=1;j<=tot;j++)\n      if(NJ) MX(f[SJ],L[x+1][j]),MN(g[SJ],R[y-1][j]);\n  int ALL=S-2,MF=-n;\n  for(i=0;i<S;i++) FM[i]=-n;\n  for(j=1,i=0;i<=ALL;i++) \n    if(NJ) x=(!g[i])?0:((g[i]==n+1)?n+1:g[i]),MX(FM[x],f[ALL-i]);\n  for(t=0,i=1;i<=n;i++)\n    {\n      while(t<=n+1&&L[i][1]+1>=t) MX(MF,FM[t]),t++; \n      puts(R[i][1]<=MF+1?\"Possible\":\"Impossible\");\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=1<<18;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nint L[N],R[N],x[N];\nint p[18][N],q[N];\ninline void umin(int &x,int y) { y<x?x=y:0; }\ninline void umax(int &x,int y) { x<y?x=y:0; }\nint main()\n{\n\tint n=gi()-1,v=gi(),i,j,k=v,m=0,u[20]={},s;\n\twhile (k) u[m++]=k>>=1;\n\n\tfor (i=0;i<=n;i++) x[i]=gi();\n\tfor (i=n;i;i--) x[i]-=x[i-1];\n\n\tfor (i=0;i<m;i++) {\n\t\tp[i][n+1]=n+1;\n\t\tfor (j=n;j;j--)\n\t\t\tp[i][j]=x[j]<=u[i]?p[i][j+1]:j;\n\t}\n\tfor (s=0;s<1<<m;s++)\n\t\tfor (i=0;i<m;i++)\n\t\t\tif (!(s>>i&1))\n\t\t\t\tumax(L[s|1<<i],p[i][L[s]+1]);\n\n\tfor (i=0;i<m;i++)\n\t\tfor (j=1;j<=n;j++)\n\t\t\tp[i][j]=x[j]<=u[i]?p[i][j-1]:j;\n\tfor (s=0;s<1<<m;s++) R[s]=n+1;\n\tfor (s=0;s<1<<m;s++)\n\t\tfor (i=0;i<m;i++)\n\t\t\tif (!(s>>i&1))\n\t\t\t\tumin(R[s|1<<i],R[s|1<<i]?p[i][R[s]-1]:0);\n\n\tfor (i=n,q[n+1]=n+1;i;i--)\n\t\tq[i]=x[i]>v?i:q[i+1];\n\tfor (i=0;i<=n;i++) {\n\t\tif (!i||x[i]-x[i-1]>v) k=i;\n\t\tfor (s=0;s<1<<m;s++)\n\t\t\tif (L[s]>=k&&R[s^((1<<m)-1)]<=q[i+1])\n\t\t\t\tbreak;\n\t\tputs(s<1<<m?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nint N,V,x[200010],fa[3600010],tot;\nstd::vector<int>ch[3600010];\nint addc(int x){\n\tint y=++tot;\n\tfa[y]=x;ch[x].push_back(y);\n\treturn y;\n}\nstd::map<std::vector<int>,bool>M;\nbool dfs(std::vector<int>v,int d){\n\tif(v.size()>d)return 0;\n\tif(!v.size())return 1;\n\tif(M.count(v))return M[v];\n\tint cs=0;\n\tfor(int i=0;i<v.size();i++)cs+=ch[v[i]].size();\n\tfor(int i=0;i<v.size();i++)if(cs-ch[v[i]].size()<d){\n\t\tstd::vector<int>w;\n\t\tfor(int j=0;j<v.size();j++)if(j!=i){\n\t\t\tint c=v[j];\n\t\t\tfor(int k=0;k<ch[c].size();k++)w.push_back(ch[c][k]);\n\t\t}\n\t\tif(dfs(w,d-1))return M[v]=1;\n\t}\n\treturn M[v]=0;\n}\nint get_sz(int i){\n\tif(!ch[i].size())return 1;\n\tint sz=0;\n\tfor(int j=0;j<ch[i].size();j++)sz+=get_sz(ch[i][j]);\n\treturn sz;\n}\nbool res[200010];\nint main(){\n\tscanf(\"%d%d\",&N,&V);\n\tint cur=0,d=0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d\",x+i);\n\t\twhile(d&&x[i]-x[i-1]>V>>d-1)cur=fa[cur],--d;\n\t\twhile(V>>d)cur=addc(cur),++d;\n\t\tcur=addc(cur);++d;\n\t}\n\tif(ch[0].size()<=d){\n\t\tint cnt=0;\n\t\tfor(int i=0;i<ch[0].size();i++){\n\t\t\tstd::vector<int>v;\n\t\t\tbool r=1;\n\t\t\tfor(int j=0;j<ch[0].size()&&r;j++)if(j!=i){\n\t\t\t\tint c=ch[0][j];\n\t\t\t\tif(v.size()+ch[c].size()>=d)r=0;\n\t\t\t\telse for(int k=0;k<ch[c].size();k++)v.push_back(ch[c][k]);\n\t\t\t}\n\t\t\tif(r)r=dfs(v,d-1);\n\t\t\tfor(int t=get_sz(ch[0][i]);t--;)res[cnt++]=r;\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++)puts(res[i]?\"Possible\":\"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 2e5+5;\nint n, k, V, i, a[Nmax], lg[Nmax], dp1[Nmax], go1[22][Nmax], dp2[Nmax], go2[22][Nmax], nr[Nmax];\n\nvoid compute()\n{\n    int l, i, j, ind;\n    for(l=0; l<k; ++l)\n    {\n        go1[l][n+1] = n;\n        go2[l][0] = 1;\n\n        for(i=1; i<=n; ++i)\n        {\n            for(j = i; j+1<=n && a[j+1] - a[j] <= lg[l]; ++j);\n            for(ind = i; ind <= j; ++ind)\n                go1[l][ind] = j;\n\n            i = j;\n        }\n\n        for(i=n; i; --i)\n        {\n            for(j = i; j-1>=1 && a[j] - a[j-1] <= lg[l]; --j);\n            for(ind = i; ind >= j; --ind)\n                go2[l][ind] = j;\n\n            i = j;\n        }\n    }\n}\n\nvoid dinamique()\n{\n    int i, j;\n    dp1[0] = 0, dp2[0] = n+1;\n    for(i=1; i<(1<<k); ++i)\n    {\n        dp1[i] = 1;\n        dp2[i] = n;\n\n        for(j=0; j<k; ++j)\n            if(i&(1<<j))\n            {\n                dp1[i] = max(dp1[i], go1[j][ dp1[i^(1<<j)] + 1 ]);\n                dp2[i] = min(dp2[i], go2[j][ dp2[i^(1<<j)] - 1 ]);\n            }\n    }\n}\n\nvoid solve()\n{\n    int i, j, ind, mask = (1<<k) - 2;\n    bool ok;\n\n    for(i=0; i<=n+1; ++i) nr[i] = -1;\n\n    for(i=0; i<=mask; ++i)\n        nr[dp2[i]] = max(nr[dp2[i]], dp1[mask^i]);\n\n    for(i=1; i<=n+1; ++i)\n        nr[i] = max(nr[i], nr[i-1]);\n\n    for(i=1; i<=n; ++i)\n    {\n        for(j = i; j+1<=n && a[j+1] - a[j] <= V; ++j);\n        ok = (nr[j+1] >= i-1);\n\n        for(ind = i; ind <= j; ++ind)\n            printf(\"%s\\n\", ok ? \"Possible\" : \"Impossible\");\n\n        i = j;\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &V);\n    for(i=1; i<=n; ++i) scanf(\"%d\", &a[i]);\n\n    lg[0] = V/2;\n    for(i=1; lg[i-1]; ++i) lg[i] = lg[i-1] / 2;\n    k = i;\n\n    compute();\n    dinamique();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 220000\ninline char gc(){\n\tstatic char now[1<<16],*S,*T;\n\tif (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}\n\treturn *S++;\n}\n#define S 1<<19\ninline int read(){\n\tint x=0,f=1;char ch=gc();\n\twhile (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}\n\twhile (ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=gc();}\n\treturn x*f;\n}\nint f1[S],f2[S],n,num,bin[20],st[N],a[N],right[N][20],left[N][20],v;\nint main(){\n\t//freopen(\"agc.in\",\"r\",stdin);\n\tn=read();v=read();int Log=0;\n\tfor (int i=1;i<=n;++i) a[i]=read();\n\twhile ((1<<Log)<=v) Log++;Log++;\n\tfor (int i=0;i<=Log+1;++i) bin[i]=1<<i;\n\tnum=1;for (int i=2;i<=n;++i) if (a[i]-a[i-1]>v) num++;\n\tfor (int j=0;j<Log;++j){\n\t\tleft[1][j]=1;right[n][j]=n;\n\t\tfor (int i=2;i<=n;++i) if (a[i]-a[i-1]>(v>>j)) left[i][j]=i;else left[i][j]=left[i-1][j];\n\t\tfor (int i=n-1;i>=1;--i) if (a[i+1]-a[i]>(v>>j)) right[i][j]=i;else right[i][j]=right[i+1][j];\n\t}\t\n\t/*for (int j=0;j<Log;++j){\n\t\tfor (int i=1;i<=n;++i) printf(\"%d \",right[i][j]);printf(\"\\n\");\n\t\tfor (int i=n;i>=1;--i) printf(\"%d \",left[i][j]);printf(\"\\n\");\n\t}*/\n\tif (num>Log){\n\t\tfor (int i=1;i<=n;++i) printf(\"Impossible\\n\");return 0;\n\t}\n\tfor (int s=0;s<=bin[Log]-1;++s) {f1[s]=0,f2[s]=n+1;}\n\tfor (int s=0;s<=bin[Log]-1;++s){\n\t\tfor (int i=0;i<Log;++i){\n\t\t\tif (s&bin[i])continue;\n\t\t\tif (f1[s]==n) f1[s|bin[i]]=n;else f1[s|bin[i]]=max(f1[s|bin[i]],right[f1[s]+1][Log-i-1]);\n\t\t\tif (f2[s]==1) f2[s|bin[i]]=1;else f2[s|bin[i]]=min(f2[s|bin[i]],left[f2[s]-1][Log-i-1]);\n\t\t}\n\t}for (int i=0;i<=n;++i) st[i]=n+2;\n\tfor (int s=0;s<=bin[Log-1]-1;++s){\n\t\tint s1=(bin[Log-1]-1)^s;\n\t\tst[f1[s]]=min(st[f1[s]],f2[s1]);\n\t} for (int i=n-1;i>=0;--i) st[i]=min(st[i],st[i+1]);\n\t//for (int i=0;i<=n;++i) printf(\"%d \",st[i]);printf(\"\\n\");\n\tfor (int i=1;i<=n;++i){\n\t\tint l=left[i][0],r=right[i][0];\n\t\tif (st[l-1]<=r+1) printf(\"Possible\\n\");else printf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tvector<int>v(N);\n\tvector<int>box;\n\twhile (K) {\n\t\tbox.push_back(K);\n\t\tK >>= 1;\n\t}\n\tbox.push_back(0);\n\tM = box.size();\n\tvector<vector<int>>l(M, vector<int>(N));\n\tvector<vector<int>>r(M, vector<int>(N));\n\tfor (auto &i : v)cin >> i;\n\tfor (int i = 0; i < M; i++) {\n\t\tint nx = 0;\n\t\tfor (int j = 1; j < N; j++) {\n\t\t\tif (v[j] - v[j - 1] > box[i]) {\n\t\t\t\tfor (int k = nx; k < j; k++) {\n\t\t\t\t\tr[i][k] = j - 1;\n\t\t\t\t}\n\t\t\t\tnx = j;\n\t\t\t}\n\t\t}\n\t\tfor (int j = nx; j < N; j++)r[i][j] = N - 1;\n\t\tnx = N - 1;\n\t\tfor (int j = N - 1; j >= 0; j--) {\n\t\t\tif (v[j + 1] - v[j] > box[i]) {\n\t\t\t\tfor (int k = nx; k > j; k--) {\n\t\t\t\t\tl[i][k] = j + 1;\n\t\t\t\t}\n\t\t\t\tnx = j;\n\t\t\t}\n\t\t}\n\t\tfor (int j = nx; j >= 0; j--)l[i][j] = 0;\n\t}\n\tvector<int>ldp(1 << M, MOD);\n\tvector<int>rdp(1 << M, -MOD);\n\tldp[0] = N;\n\trdp[0] = -1;\n\tfor (int i = 0; i < 1 << M; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif ((i >> j) & 1)continue;\n\t\t\tif (rdp[i] == N - 1) {\n\t\t\t\trdp[i + (1 << j)] = N - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trdp[i + (1 << j)] = max(rdp[i + (1 << j)], r[j][rdp[i] + 1]);\n\t\t}\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif ((i >> j) & 1)continue;\n\t\t\tif (ldp[i] == 0) {\n\t\t\t\tldp[i + (1 << j)] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tldp[i + (1 << j)] = min(ldp[i + (1 << j)], l[j][ldp[i] - 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < 1 << M; i++) {\n\t//\tcout << i << \" \" << rdp[i] << \" \" << ldp[i] << endl;\n\t}\n\tvector<int>ans(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint bag = r[0][i];\n\t\tint ch = 0;\n\t//\tcout << i << \" \" << bag << endl;\n\t\tfor (int j = 0; j < (1 << M) - 1; j+=2) {\n\t\t//\tcout << j << \" \" << rdp[j] << \" \" << ldp[j] << endl;\n\t\t\tif (rdp[j] >= i - 1 && ldp[(1 << M) - 2 - j] <= bag + 1) {\n\t\t\t\tch = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int j = i; j <= bag; j++)ans[j] = ch;\n\t\ti = r[0][i];\n\t}\n\tfor (auto i : ans) {\n\t\tif (i)cout << \"Possible\\n\";\n\t\telse cout << \"Impossible\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\n#define DEBUGNO\n\nsigned main() {\n\tINIT;\n\t\n\tstd::ifstream ifs(\"test.in\");\n\n#ifndef DEBUG\n\tVAR(int, n, V);\n#else\n\tint n, V;\n\tifs >> n >> V;\n#endif\n\n\tif(false){\n\t\tstd::random_device rnd;\n\t\tstd::mt19937 mt(rnd());\n\t\tstd::uniform_int_distribution<> rand(/* min */-1000000000, /* max */1000000000);\n\t\tstd::set<int> set;\n\t\twhile (set.size() < n) set.insert(rand(mt));\n\t\tOUT(n)SP OUT(V)BR;\n\t\tfor (auto x : set) {\n\t\t\tOUT(x)SP;\n\t\t}BR;\n\n\t\treturn 0;\n\t}\n\t\n#ifndef DEBUG\n\tVEC(int, x, n);\n#else\n\tstd::vector<int> x(n);\n\tREP(i, n) ifs >> x[i];\n#endif\n\n\n\tint height = 0;\n\twhile (V >= (1 << height)) ++height;\n\theight += 2;\n\tstd::vector<std::vector<int>> right(height);\n\tint vv = V;\n\tright[0].emplace_back(x[n - 1]);\n\tFOR(h, 1, height) {\n\t\tint r = n - 1;\n\t\tRREP(i, n - 1) {\n\t\t\tif (x[i + 1] - x[i] > vv || i == 0) {\n\t\t\t\tright[h].emplace_back(x[r]);\n\t\t\t\tr = i;\n\t\t\t}\n\t\t}\n\t\tif (x[1] - x[0] > vv) right[h].emplace_back(x[0]);\n\t\tstd::sort(ALL(right[h]));\n\t\tvv /= 2;\n\t}\n\tstd::vector<int> c(height + 1, 0);\n\tREP(i, height) c[i] = right[i].size();\n\tREP(i, height - 1) c[i + 1] += c[i];\n\tstd::rotate(c.rbegin(), c.rbegin() + 1, c.rend());\n\n\tstd::vector<std::vector<int>> g(1);\n\tg.reserve(n*height);\n\tint p = 0;\n\tFOR(h, 1, height) {\n\t\tfor (auto v : right[h]) {\n\t\t\t++p;\n\t\t\tauto it = std::lower_bound(ALL(right[h - 1]), v);\n\t\t\tint par = std::distance(right[h-1].begin(), it) + c[h-1];\n\t\t\tg.emplace_back(std::vector<int>{});\n\t\t\t//g[s].emplace_back(t);\n\t\t\tg[par].emplace_back(p);\n\t\t}\n\t}\n\n\t/*SHOWVECTOR2(right);\n\n\tREP(i, g.size()) {\n\t\tfor (auto to : g[i]) {\n\t\t\tOUT(i)SP OUT(to)BR;\n\t\t}\n\t}*/\n\n\tstd::vector<int> v0;\n\tfor (auto v : g[0]) v0.emplace_back(v);\n\tstd::function<bool(std::vector<int>&, int, int)> check = [&](std::vector<int>& a, int pos, int rest) {\n\t\t//SHOWVECTOR(a);\n\t\tif (rest == 0) return true;\n\t\tif (a.empty()) return true;\n\t\tstd::vector<int> c;\n\t\tint asz = a.size();\n\t\tREP(i, asz) {\n\t\t\tauto& v = g[a[i]];\n\t\t\tREP(j, v.size()) {\n\t\t\t\tif (a[i] > v[j]) continue;\n\t\t\t\tc.emplace_back(v[j]);\n\t\t\t}\n\t\t}\n\t\tint csz = c.size();\n\t\t//std::sort(ALL(c));\n\t\tfor(auto v : a) {\n\t\t\tif (pos != -1) v = pos;\n\t\t\tif (csz - g[v].size() > rest - 1) continue;\n\t\t\tauto ts(c);\n\t\t\tfor (auto& to : g[v]) {\n\t\t\t\tif (v > to) continue;\n\t\t\t\tts.erase(std::find(ALL(ts), to));\n\t\t\t}\n\t\t\tif (check(ts, -1, rest - 1)) return true;\n\t\t\tif (pos != -1) break;\n\t\t}\n\t\treturn false;\n\t};\n\n\tstd::vector<PAIR> ok;\n\tp = 0;\n\tfor (auto& v : v0) {\n\t\tbool t = check(v0, v, height - 1);\n\t\tok.emplace_back(PAIR(right[1][p++], t));\n\t}\n\t//SHOWPAIRVECTOR(ok);\n\n\tp = 0;\n\tREP(i, n) {\n\t\tif (x[i] <= ok[p].first) {\n#ifndef DEBUG\n\t\t\tOUT(((ok[p].second) ? \"Possible\" : \"Impossible\"))BR;\n#endif\n\t\t}\n\t\tif (x[i] == ok[p].first) ++p;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=1e5+5;\nint n,m;\nint V[20],x[maxn],R[maxn][20],L[maxn][20];\nint S1[maxn],S2[maxn];\nint minL[maxn];\nint main(){\n\tread(n);read(V[0]);\n\trep(i,1,n)read(x[i]);\n\twhile(V[m])V[m+1]=V[m]/2,m++;\n\tm++;\n\trep2(i,0,m){\n\t\tR[n+1][i]=n;\n\t\tR[n][i]=n;\n\t\tper(j,n-1,1)\n\t\t\tif(x[j+1]-x[j]<=V[i])R[j][i]=R[j+1][i];\n\t\t\telse R[j][i]=j;\n\t\tL[0][i]=1;\n\t\tL[1][i]=1;\n\t\trep(j,2,n)\n\t\t\tif(x[j]-x[j-1]<=V[i])L[j][i]=L[j-1][i];\n\t\t\telse L[j][i]=j;\n\t}\n\trep2(i,0,1<<m)S2[i]=n+1,S1[i]=0;\n\trep2(i,1,1<<m){\n\t\trep2(j,0,m)if(i>>j&1){\n\t\t\tint last=S1[i^(1<<j)];\n\t\t\tS1[i]=max(S1[i],R[last+1][j]);\n\t\t}\n\t\trep2(j,0,m)if(i>>j&1){\n\t\t\tint last=S2[i^(1<<j)];\n\t\t\tS2[i]=min(S2[i],L[last-1][j]);\n\t\t}\n\t}\n\trep(i,0,n)minL[i]=n+2;\n\trep2(i,0,1<<m){\n\t\tif(i>>0&1)continue;\n\t\tint R=S1[i],L=S2[((1<<m)-1)^i^(1<<0)];\n\t\tminL[R]=min(minL[R],L);\n\t}\n\tper(i,n-1,0)minL[i]=min(minL[i],minL[i+1]);\n\trep(i,1,n){\n\t\tint rL=L[i][0],rR=R[i][0];\n\t\tif(minL[rL-1]<=rR+1)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); ++i)\n#define per(i,a,b) for (int i=(a); i>=(b); --i)\nusing namespace std;\n\nconst int maxn = 200005;\nint f[maxn][20], g[maxn][20], pre[1<<18], suf[1<<18];\nint x[maxn], ans[maxn], d[20], n, m, v;\n\nint main() {\n\tscanf(\"%d%d\", &n, &v); d[0] = v;\n\twhile (v) d[++m] = v/2, v /= 2;\n\trep (i, 1, n) scanf(\"%d\", &x[i]);\n\trep (i, 1, n) rep (j, 0, m)\n\t\tif (i >= 2 && x[i] - x[i-1] <= d[j]) f[i][j] = f[i-1][j];\n\t\telse f[i][j] = i;\n\tper (i, n, 1) rep (j, 0, m)\n\t\tif (i <= n-1 && x[i+1] - x[i] <= d[j]) g[i][j] = g[i+1][j];\n\t\telse g[i][j] = i;\n\tmemset(pre, 0xc0, sizeof pre);\n\tmemset(suf, 0x3f, sizeof suf);\n\tpre[0] = 1; suf[0] = n;\n\tint ALL = (1<<m)-1;\n\trep (i, 0, ALL) rep (j, 0, m-1) if (!(i>>j&1)) {\n\t\tif (pre[i] == n) pre[i|1<<j] = n;\n\t\telse pre[i|1<<j] = max(pre[i|1<<j], g[pre[i]+1][j+1]);\n\t\tif (suf[i] == 1) suf[i|1<<j] = 1;\n\t\telse suf[i|1<<j] = min(suf[i|1<<j], f[suf[i]-1][j+1]);\n\t}\n\tint l = 1, r, tot = 0, flag;\n\twhile (l <= n) {\n\t\tr = l; if (++tot > m) break;\n\t\twhile (r + 1 <= n && x[r+1] - x[r] <= d[0]) r++;\n\t\tflag = 0;\n\t\trep (i, 0, ALL) {\n\t\t\tif (pre[i] >= l-1 && suf[(~i)&ALL] <= r+1) {\n\t\t\t\tflag = 1; break;\n\t\t\t}\n\t\t}\n\t\trep (i, l, r) ans[i] = flag;\n\t\tl = r + 1;\n\t}\n\trep (i, 1, n) puts(ans[i] ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\ninline int rnd(int x){\n\treturn rand()%x;\n}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=18,N=200005,inf=1e9+3e5;\nint n,v,gao,f[1<<M],g[1<<M],x[N],lst[M][N],nxt[M][N],tong[N];\nint main(){\n\tn=read(); v=read(); x[0]=-inf; x[n+1]=inf;\n\tfor(int i=1;i<=n;i++)x[i]=read();\n\tfor(int i=0;;i++){\n\t\tint dali=v>>i; gao=i; \n\t\tfor(int j=1;j<=n;j++)if(x[j]-x[j-1]<=dali)lst[i][j]=lst[i][j-1]; else lst[i][j]=j;\n\t\tfor(int j=n;j;j--)if(x[j+1]-x[j]<=dali)nxt[i][j]=nxt[i][j+1]; else nxt[i][j]=j;\n\t\tif((v>>i)==0)break;\n\t}\n\tf[0]=0; g[0]=n+1; \n\tfor(int i=1;i<(1<<gao);i++){\n\t\tf[i]=0; g[i]=n+1;\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)f[i]=max(f[i],nxt[j+1][f[i^(1<<j)]+1]);\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)g[i]=min(g[i],lst[j+1][g[i^(1<<j)]-1]);\n\t}\n\tfor(int i=0;i<=n+1;i++)tong[i]=-1;\n\tfor(int i=0;i<(1<<gao);i++){\n\t\tint l=f[i],r=g[((1<<gao)-1)^i];\n\t\ttong[r]=max(tong[r],l);\n\t}\n\tfor(int i=1;i<=n;i++)tong[i]=max(tong[i],tong[i-1]);\n\tfor(int i=1;i<=n;i++){\n\t\tint l=lst[0][i],r=nxt[0][i];\n\t\tputs(tong[r+1]>=l-1?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 262144+5;\nint n, m, v, p[N], l[20][N], r[20][N];\nint d[N], f[N], g[N];\nvoid func(int v, int *l, int *r)\n{\n    l[1] = 1, r[n] = n;\n    for(int i = 2; i <= n; ++i) l[i] = p[i]-p[i-1] <= v?l[i-1]:i;\n    for(int i = n-1; i; --i) r[i] = p[i+1]-p[i] <= v?r[i+1]:i; \n    l[0] = 1, r[n+1] = n; \n}\nvoid pusha(int l, int r) { if(l <= r) ++d[l], --d[r+1]; }\nint main()\n{\n    n = read(), v = read();\n    for(int i = 1; i <= n; ++i) p[i] = read();\n    for( ; v; ++m, v >>= 1) func(v, l[m], r[m]); func(0, l[m], r[m]);\n    g[0] = n+1;\n    for(int s = 1; s < 1<<m; ++s)\n    {\n        g[s] = n;\n        for(int i = 0; i < m; ++i)\n            if(s>>i&1) f[s] = max(f[s], r[i+1][f[s^(1<<i)]+1]), g[s] = min(g[s], l[i+1][g[s^(1<<i)]-1]);\n    }\n    for(int s = 0; s < 1<<m; ++s) pusha(l[0][g[s^((1<<m)-1)]-1], r[0][f[s]+1]);\n    for(int i = 1; i <= n; ++i) d[i] += d[i-1], puts(d[i]?\"Possible\":\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define mid (l+r>>1)\ntypedef long long ll;\ntemplate<typename T>inline T read(){\n\tT x=0,f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';f=c=='-'?-1:1,c=getchar());\n\tfor(;c>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0',c=getchar());\n\treturn x*f;\n}\nconst int maxs=1<<19,maxn=2e5+5;\nint n,v,lg,s,lt[maxs],rt[maxs],a[20][maxn],cnt[20];\nll x[maxn];\nint S(int opt,int k,int x){\n\tint l=1,r=cnt[k];\n\twhile(r-l>1)\n\t\tif(a[k][mid]<x||(opt&&a[k][mid]==x))l=mid+opt;\n\t\telse r=mid-1+opt;\n\tint r1=opt?l:r,r2=opt?r:l,f=opt?1:-1;\n\tif(a[k][r1]*f>x*f)return a[k][r1]+1-opt;\n\treturn a[k][r2]+1-opt;\n}\nint main(){\n\tn=read<int>();v=read<int>();\n\tlg=ceil(log2(v))+1+(ceil(log2(v))==log2(v));s=(1<<lg)-1;\n\tfor(int i=1;i<=n;i++)x[i]=read<ll>(),x[i-1]=x[i]-x[i-1];x[n]=0;\n\tfor(int i=1;i<=lg;i++){\n\t\tcnt[i]=1;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ta[i][cnt[i]]=j,cnt[i]+=(x[j]>v>>(i-1));\n\t}\n\tif(cnt[1]>lg){for(int i=0;i<n;i++)puts(\"Impossible\");return 0;}\n\tmemset(rt,0,sizeof(rt));\n\tfor(int i=0;i<=s;i++)lt[i]=n+1;\n\tfor(int i=0;i<=s;i+=2)\n\t\tfor(int j=2;j<=lg;j++){\n\t\t\tint s0=1<<j-1;\n\t\t\tif(i&s0)continue;\n\t\t\trt[i|s0]=std::max(rt[i|s0],S(1,j,rt[i]));\n\t\t\tlt[i|s0]=std::min(lt[i|s0],S(0,j,lt[i]-1));\n\t\t}\n\tfor(int i=1;i<=cnt[1];i++){\n\t\tint f=0,b=a[1][i-1]+1,e=a[1][i];\n\t\tif(i==1)b=1;\n\t\tfor(int s0=0;s0<=s&&(!f);s0+=2)f=(b<=rt[s0]+1&&e>=lt[s-s0-1]-1);\n\t\tfor(int j=b;j<=e;j++)puts(f?\"Possible\":\"Impossible\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MN = 200010;\nconst int ML = 19;\n\nint N, V;\nint v[ML];\nint x[MN];\nint tor[2][ML][MN];\nint dp[2][1 << ML];\nint imos[MN];\n\nint main() {\n\tcin >> N >> V;\n\n\tint L = 0;\n\tv[L++] = V;\n\n\twhile (V > 0) {\n\t\tV /= 2;\n\t\tv[L++] = V;\n\t}\n\n\trep(i, N) cin >> x[i];\n\n\trep(tt, 2) {\n\t\trep(j, L) {\n\t\t\ttor[tt][j][N] = N;\n\t\t\ttor[tt][j][N-1] = N-1;\n\t\t}\n\n\t\tfor (int i = N-2; i >= 0; --i) {\n\t\t\trep(j, L) {\n\t\t\t\tif (x[i+1] - x[i] <= v[j]) {\n\t\t\t\t\ttor[tt][j][i] = tor[tt][j][i+1];\n\t\t\t\t} else {\n\t\t\t\t\ttor[tt][j][i] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdp[tt][0] = 0;\n\t\trep(i, 1 << L) {\n\t\t\trep(j, L) {\n\t\t\t\tif (!((i >> j) & 1)) {\n\t\t\t\t\tdp[tt][i | (1 << j)] = max(dp[tt][i | (1 << j)], tor[tt][j][dp[tt][i]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treverse(x, x + N);\n\t\trep(i, N) x[i] *= -1;\n\t}\n\n\tint B = (1 << L) - 2;\n\n\trep(i, 1 << L) {\n\t\tif (i & 1) continue;\n\t\tint j = B ^ i;\n\t\tint l = dp[0][i], r = N - dp[1][j];\n\n\t\tif (l >= r) {\n\t\t\timos[0]++;\n\t\t\timos[N]--;\n\t\t} else {\n\t\t\tif (tor[0][0][l] + 1 >= r) {\n\t\t\t\tint p = tor[0][0][l];\n\t\t\t\tint u = N-1-tor[1][0][N-1-p];\n\t\t\t\timos[u]++;\n\t\t\t\timos[p+1]--;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, MN-1) {\n\t\timos[i+1] += imos[i];\n\t}\n\n\trep(i, N) {\n\t\tputs(imos[i] > 0 ? \"Possible\" : \"Impossible\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nint pre[200005][25], nxt[200005][25], dp_l[800005], dp_r[800005], arr[200005];\nint main()\n{\n\t// freopen(\"AGC012-F.in\", \"r\", stdin);\n\tint n, v, len = 0;\n\tscanf(\"%d%d\", &n, &v);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", arr + i);\n\twhile (true)\n\t{\n\t\tpre[0][len] = pre[1][len] = 0;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t\tpre[i][len] = arr[i] - arr[i - 1] <= v ? pre[i - 1][len] : i - 1;\n\t\tnxt[n + 1][len] = nxt[n][len] = n + 1;\n\t\tfor (int i = n - 1; i >= 1; i--)\n\t\t\tnxt[i][len] = arr[i + 1] - arr[i] <= v ? nxt[i + 1][len] : i + 1;\n\t\tlen++;\n\t\tif (!v)\n\t\t\tbreak;\n\t\tv >>= 1;\n\t}\n\tfor (int i = 0; i < 1 << len; i++)\n\t{\n\t\tdp_l[i] = 1;\n\t\tdp_r[i] = n;\n\t}\n\tfor (int i = 0; i < 1 << len; i++)\n\t{\n\t\tfor (int j = 0; j < len; j++)\n\t\t{\n\t\t\tif (i & (1 << j))\n\t\t\t\tcontinue;\n\t\t\tdp_l[i | (1 << j)] = std::max(dp_l[i | (1 << j)], nxt[dp_l[i]][j]);\n\t\t\tdp_r[i | (1 << j)] = std::min(dp_r[i | (1 << j)], pre[dp_r[i]][j]);\n\t\t}\n\t}\n\tif (dp_l[(1 << len) - 1] <= n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor (int l = 1; l <= n; l = nxt[l][0])\n\t{\n\t\tbool flg = false;\n\t\tfor (int i = 0; i < 1 << len && !flg; i++)\n\t\t{\n\t\t\tif (i & 1)\n\t\t\t\tcontinue;\n\t\t\tif (l <= dp_l[i] && dp_r[(1 << len) - 1 ^ i ^ 1] < nxt[l][0])\n\t\t\t\tflg = true;\n\t\t}\n\t\tfor (int i = l; i < nxt[l][0]; i++)\n\t\t\tputs(flg ? \"Possible\" : \"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N, V;\nint X[200005];\n//vector <int> Colour[20][200005];\n//int C[20][200005];\nint Log2[200005];\nint MaxL[20][200005], MaxR[20][200005];\nint L[(1 << 20) + 5], R[(1 << 20) + 5];\nint Val[30];\nbool Use[200005];\nvoid Read()\n{\n    cin >> N >> V;\n    for(int i = 1; i <= N; i++)\n        cin >> X[i];\n}\n\nvoid precalcLog2()\n{\n    for(int i = 2; i <= V; i++)\n        Log2[i] = Log2[i / 2] + 1;\n    int l = Log2[V], x = V;\n    while(x > 0)\n    {\n        Val[l] = x;\n        x /= 2;\n        --l;\n    }\n}\n\nvoid precalcColour()\n{\n    for(int j = 0; j <= Log2[V]; j++)\n    {\n        int Max = 0;\n        int c = 1;\n        int last = 1;\n        for(int i = 1; i <= N; i++)\n        {\n            if(Max > Val[j])\n            {\n                //++c;\n                Max = 0;\n                last = i;\n            }\n            MaxL[j][i] = last;\n            Max = max(Max, X[i + 1] - X[i]);\n        }\n        Max = 0;last = N;\n        for(int i = N; i >= 1; i--)\n        {\n            if(Max > Val[j])\n            {\n                //++c;\n                Max = 0;\n                last = i;\n            }\n            MaxR[j][i] = last;\n            Max = max(Max, X[i] - X[i - 1]);\n        }\n    }\n}\nvoid precalcLR()\n{\n    int limit = (1 << (Log2[V]));\n    for(int i = 0; i < limit; i++)\n    {\n        for(int j = 0; j < Log2[V]; j++)\n        {\n            if((i & (1 << j)) != 0)\n            {\n                L[i] = max(L[i], MaxR[j][L[(i ^ (1 << j))] + 1]);\n                R[i] = max(R[i], MaxL[j][R[(i ^ (1 << j))] + 1]);\n            }\n        }\n    }\n}\n\nvoid checkPos(int pos)\n{\n    int left = MaxL[Log2[V]][pos];\n    int right = MaxR[Log2[V]][pos];\n    int mask = (1 << (Log2[V])) - 1;\n    int ans = 0;\n    int dist = right - left + 1;\n    for(int i = 0; i < (1 << (Log2[V])); i++)\n    {\n        int c = (mask ^ i);\n        if(N - dist <= R[c] + L[i] + 1)\n        {\n            ans = 1;\n            break;\n        }\n    }\n    for(int i = left; i <= right; i++)\n    {\n        Use[i] = 1;\n        if(ans == 1)\n            cout << \"Possible\\n\";\n        else\n            cout << \"Impossible\\n\";\n    }\n}\nint Solve()\n{\n    for(int i = 1; i <= N; i++)\n        if(Use[i] == 0)\n    {\n        checkPos(i);\n    }\n}\nint main()\n{\n    Read();\n    precalcLog2();\n    precalcColour();\n    precalcLR();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nint goR[200005][20];\nint goL[200005][20];\nint a[200005];\nint n,v;\nint R(int x,int k,int v){\n    if(x>=n)return n;\n    if(goR[x][k]!=-1)return goR[x][k];\n    if(a[x+1]-a[x]>(v>>k))return goR[x][k]=x;\n    return goR[x][k]=R(x+1,k,v);\n}\nint L(int x,int k,int v){\n    if(x<=1)return 1;\n    if(goL[x][k]!=-1)return goL[x][k];\n    if(a[x]-a[x-1]>(v>>k))return goL[x][k]=x;\n    return goL[x][k]=L(x-1,k,v);\n}\nint dpR[1<<20];\nint dpL[1<<20];\n \nint DPR(int x){\n    if(x==0)return 0;\n    if(dpR[x]!=-1)return dpR[x];\n    dpR[x]=0;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpR[x]=max(dpR[x],R(DPR(x-(1<<i))+1,i,v));\n        }\n    }\n    return dpR[x];\n}\nint DPL(int x){\n    if(x==0)return n+1;\n    if(dpL[x]!=-1)return dpL[x];\n    dpL[x]=1e9+1;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpL[x]=min(dpL[x],L(DPL(x-(1<<i))-1,i,v));\n        }\n    }\n    return dpL[x];\n}\nint main(){ \n    MEMS(goR);MEMS(goL);MEMS(dpR);MEMS(dpL);\n    scanf(\"%d %d\",&n,&v);\n    for(int i = 1;i<=n;i++)\n        //a[i]=-1e9+2e5*i;\n        scanf(\"%d\",&a[i]);\n    a[0]=-1e9-1e8;\n    a[n+1]=1e9+1e8;\n    int Max=1;\n    for(int i = 1;;i++){\n        Max=i+1;\n        if(!(v>>i))break;\n    }\n \n    if(DPR((1<<Max)-1)<n){\n        for(int i = 1;i<=n;i++){\n            printf(\"Impossible\\n\");\n        }\n        return 0;\n    }\n    for(int i = 1;i<=n;){\n        int l=i,r=R(i,0,v);\n       // printf(\"%d %d\\n\",l,r);\n        int ok=0;\n        for(int j=0;j<(1<<Max);j++){\n            int a=j,b=(1<<Max)-j-1;\n            if(a&1)a--;\n            if(b&1)b--;\n            if(DPR(a)>=l-1&&DPL(b)<=r+1){\n                ok=1;\n                break;\n            }\n        }\n        if(ok){\n            for(int i=l;i<=r;i++)printf(\"Possible\\n\");\n        }\n        else{\n            for(int i = l;i<=r;i++)printf(\"Impossible\\n\");\n        }\n        i=r+1;\n    }\n}\n/*\n2 2 1\n3 2 3\n4 2 4 4 7\n \n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define ins insert\n#define pii pair<int,int>\n#define fs first\n#define sc second\n#define mpr make_pair\n#define iter iterator\n#define all(X) X.begin(),X.end()\n#define sau(X) sort(all(X)),X.resize(unique(all(X))-X.begin())\n#define exist(X,ele) binary_search(all(X),ele)\n\ntemplate<typename T1,typename T2>\nostream& operator << (ostream& out,const pair<T1,T2>& X)\n{\n\tout<<\"{\"<<X.fs<<\",\"<<X.sc<<\"}\";\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& out,const vector<T>& X)\n{\n\tfor(auto i:X) out<<i<<\" \";\n\treturn out;\n}\n\ninline void cmin(int& x,int y)\n{\n\tx=min(x,y);\n}\n\ninline void cmax(int& x,int y)\n{\n\tx=max(x,y);\n}\n\nconst int inf=5000000000000000ll;\n\nint N,V;\nvector<int> a;\nint p[20][200010];\nint nxt[20][200010][2];\nbool ans[200010];\nint cnt=0;\n\ninline string t(int x)\n{\n\tstring res=\"\";\n\tfor(int i=0;i<=5;i++)\n\t{\n\t\tres+=(bool)(x&(1<<i))+'0';\n\t}\n\treturn res;\n}\n\ninline bool solve(int L,int R,int U)\n{\n//\tcout<<\"  Solving \"<<setw(4)<<left<<L<<setw(4)<<left<<R<<t(U)<<endl;\n\t\n\tvector<int> v;\n\tfor(int i=0;i<=cnt;i++)\n\t{\n\t\tif(U&(1<<i)) v.pb(i);\n\t}\n\tint U2=(1<<(int)v.size())-1;\n\tvector<int> dp((1<<(int)v.size()),-1);\n\tdp[0]=L;\n\tfor(int msk=0;msk<=U2;msk++)\n\t{\n\t\tif(dp[msk]==-1) continue;\n\t\tfor(int j=0;j<v.size();j++)\n\t\t{\n\t\t\tif(!(msk&(1<<j)))\n\t\t\t{\n\t\t\t\tcmax(dp[msk|(1<<j)],dp[msk]);\n\t\t\t\tcmax(dp[msk|(1<<j)],nxt[v[j]][dp[msk]][0]);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int msk=0;msk<=U2;msk++)\n//\t{\n//\t\tcout<<\"msk=\"<<t(msk)<<\" dp[msk]=\"<<dp[msk]<<endl;\n//\t}\n//\tcout<<\" Ret : \"<<(dp[U2]>R)<<endl;\n\treturn dp[U2]>R;\n}\n\nmain()\n{\n\tios::sync_with_stdio(false);\n\t\n\tcin>>N>>V;\n\tfor(int i=0,x;i<N;i++)\n\t{\n\t\tcin>>x;\n\t\ta.pb(x);\n\t}\n\tfor(int i=0,v=V,lv=-1;v!=lv;i++,lv=v,v/=2)\n\t{\n\t\tfor(int j=1;j<N;j++)\n\t\t{\n\t\t\tp[i][j]=p[i][j-1];\n\t\t\tif(a[j]-a[j-1]>v) p[i][j]++;\n\t\t}\n\t\tcnt++;\n\t}\n\tfor(int i=0,v=V,lv=-1;v!=lv;i++,lv=v,v/=2)\n\t{\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(p[i][j]==p[i][j-1])\n\t\t\t{\n\t\t\t\tnxt[i][j][0]=nxt[i][j-1][0];\n\t\t\t\tnxt[i][j][1]=nxt[i][j-1][1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnxt[i][j][0]=(upper_bound(p[i],p[i]+N,p[i][j])-p[i]);   // [j, )\n\t\t\tnxt[i][j][1]=(lower_bound(p[i],p[i]+N,p[i][j])-p[i])-1; // ( ,j]\n\t\t}\n//\t\tcout<<\"D=\"<<i<<endl;\n//\t\tfor(int j=0;j<N;j++) cout<<nxt[i][j][0]<<\" \"; cout<<endl;\n//\t\tfor(int j=0;j<N;j++) cout<<nxt[i][j][1]<<\" \"; cout<<endl;\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n//\t\tcout<<\"StartPos=\"<<i<<endl;\n\t\tif(i!=0 && nxt[0][i][0]==nxt[0][i-1][0])\n\t\t{\n\t\t\tans[i]=ans[i-1];\n\t\t\tcontinue;\n\t\t}\n\t\tans[i]=false;\n\t\tint U=((1<<(cnt+1))-2); \n\t\tfor(int mskL=0;mskL<=U;mskL++)\n\t\t{\n\t\t\tif(mskL&1) continue;\n\t\t\tint mskR=U^mskL;\n\t\t\tif(nxt[0][i][1]<0 && mskL) continue;\n\t\t\tif(nxt[0][i][0]>=N && mskR) continue;\n\t\t\tif(nxt[0][i][1]>=0 && nxt[0][i][0]<N && ((!mskL)||(!mskR)) ) continue;\n\t\t\tbool ok=true;\n\t\t\tif(nxt[0][i][1]>=0) ok&=solve(0,nxt[0][i][1],mskL);\n\t\t\tif(nxt[0][i][0]<N) ok&=solve(nxt[0][i][0],N-1,mskR);\n\t\t\tans[i]|=ok;\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(ans[i]) cout<<\"Possible\"<<endl;\n\t\telse cout<<\"Impossible\"<<endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\nconst int N=200001;\nint n,m,v,a[N],b[N],pl[19][N],pr[19][N],fl[1<<18],fr[1<<18];\nvoid updmax(int&a,int b){if(b>a)a=b;}\nvoid updmin(int&a,int b){if(b<a)a=b;}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tref(i,1,n)scanf(\"%d\",&a[i]);\n\tref(i,0,18){\n\t\tpl[i][1]=1;pr[i][n]=n;\n\t\tpl[i][0]=1;pr[i][n+1]=n;\n\t\tref(j,1+1,n)if(a[j]-a[j-1]<=v)pl[i][j]=pl[i][j-1];else pl[i][j]=j;\n\t\tdef(j,n-1,1)if(a[j+1]-a[j]<=v)pr[i][j]=pr[i][j+1];else pr[i][j]=j;\n\t\tif(!v){m=i;break;}\n\t\tv>>=1;\n\t}\n\tref(i,0,(1<<m)-1)fl[i]=0,fr[i]=n+1;\n\tref(i,0,(1<<m)-1)ref(j,1,m)if(!(i>>j-1&1)){\n\t\tint I=i|(1<<j-1);\n\t\tupdmax(fl[I],pr[j][fl[i]+1]);\n\t\tupdmin(fr[I],pl[j][fr[i]-1]);\n\t}\n\tref(i,0,(1<<m)-1)if(pr[0][fl[i]+1]>=fr[((1<<m)-1)^i]-1)\n\t\tb[pr[0][fl[i]+1]]=1;\n\tref(i,1,n)if(b[pr[0][i]])printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;inline int inn() { int x;scanf(\"%d\",&x);return x; }const int N=270000,LOG=20;int x[N],v[N],L[LOG][N],R[LOG][N],val[N],Lf[N],Rf[N];\nint main()\n{\n    int n=inn(),k=0;v[0]=inn();rep(i,1,n) x[i]=inn();while(v[k]) v[k+1]=v[k]>>1,k++;int all=(1<<k)-1;\n    rep(i,0,k)\n    {\n        L[i][1]=1;for(int j=1+1;j<=n;j++) if(x[j]-x[j-1]<=v[i]) L[i][j]=L[i][j-1];else L[i][j]=j;\n        R[i][n]=n;for(int j=n-1;j>=0;j--) if(x[j+1]-x[j]<=v[i]) R[i][j]=R[i][j+1];else R[i][j]=j;\n    }\n    rep(i,1,all) Lf[i]=1,Rf[i]=n;Lf[0]=0,Rf[0]=n+1;\n    rep(i,0,all) rep(j,1,k) if(!((i>>(j-1))&1)) Lf[i|(1<<(j-1))]=max(Lf[i|(1<<(j-1))],R[j][Lf[i]+1]),Rf[i|(1<<(j-1))]=min(Rf[i|(1<<(j-1))],L[j][Rf[i]-1]);\n    rep(i,0,n+1) val[i]=n+n;rep(i,0,all) val[Lf[i]]=min(val[Lf[i]],Rf[all^i]);for(int i=n;i>=0;i--) val[i]=min(val[i],val[i+1]);\n    rep(i,1,n) printf(val[L[0][i]-1]<=R[0][i]+1?\"Possible\\n\":\"Impossible\\n\");return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n\n#define MAXN 200005\n#define MAXB 21\n\nusing namespace std;\n\nconst int INF = 1e9 + 2e6;\nint v[MAXN], n, m;\nint d[MAXN], up[MAXN][MAXB], down[MAXN][MAXB], pre[1 << MAXB], suf[1 << MAXB];\nint visit[MAXN];\n\nint read() {\n    char c = getchar();\n    int x = 0, s = 1;\n    while (!isdigit(c)) {\n        if (c == '-')\n            s = -1;\n        c = getchar();\n    }\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x * s;\n}\n\nvoid init() {\n    while (v[++m] >= 1)\n        v[m + 1] = v[m] >> 1;\n    d[0] = -INF;\n    d[n + 1] = INF;\n    for (int j = 1; j <= m; ++j) {\n        for (int i = 1; i <= n; ++i)\n            if (d[i] - d[i - 1] <= v[j])\n                up[i][j] = up[i - 1][j];\n            else\n                up[i][j] = i;\n        for (int i = n; i >= 1; --i)\n            if (d[i + 1] - d[i] <= v[j])\n                down[i][j] = down[i + 1][j];\n            else\n                down[i][j] = i;\n    }\n}\n\nvoid solve() {\n    memset(suf, 0x3f, sizeof(suf));\n    memset(pre, -0x3f, sizeof(pre));\n    suf[0] = n + 1;\n    pre[0] = 0;\n    int limit = (1 << m) - 1;\n    for (int s = 0; s <= limit; ++s) {\n        for (int i = 1; i <= m; ++i) {\n            if (s >> (i - 1) & 1)\n                continue;\n            int t = s | (1 << (i - 1));\n            if (pre[s] >= 0)\n                pre[t] = max(pre[t], down[pre[s] + 1][i]);\n            if (suf[s] <= n + 1)\n                suf[t] = min(suf[t], up[suf[s] - 1][i]);\n        }\n    }\n    for (int s = 0; s <= limit; ++s) {\n        if (s & 1)\n            continue;\n        int t = limit ^ s ^ 1;\n        int a = up[suf[t] - 1][1], b = down[pre[s] + 1][1];\n        if (a <= b) {\n            ++visit[a];\n            --visit[b + 1];\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n        visit[i] = visit[i - 1] + visit[i];\n    for (int i = 1; i <= n; ++i)\n        if (visit[i])\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n}\n\nint main() {\n    n = read();\n    v[1] = read();\n    for (int i = 1; i <= n; ++i)\n        d[i] = read();\n    init();\n    solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N = 2e5 + 7;\n\nint n, k, a[N], val[19];\nint l[19][N], r[19][N];\nint pref[1 << 19], suf[1 << 19], mis[N];\n\nint main(){\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n >> k;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t}\n\tint bit = 0, sv = k;\n\twhile(sv > 0){\n\t\tval[bit++] = sv;\n\t\tsv /= 2;\n\t}\n\tval[bit++] = 0;\n\tint pos = 1;\n\tfor(int i = 0; i < bit; i++){\n\t\tpos = 1;\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(pos < j) pos = j;\n\t\t\twhile(pos < n && a[pos + 1] - a[pos] <= val[i]) pos++;\n\t\t\tr[i][j] = pos;\n\t\t}\n\t\tpos = n;\n\t\tfor(int j = n; j >= 1; j--){\n\t\t\tif(pos > j) pos = j;\n\t\t\twhile(pos > 1 && a[pos] - a[pos - 1] <= val[i]) pos--;\n\t\t\tl[i][j] = pos;\n\t\t}\n\t}\n\tfor(int mask = 0; mask < (1 << bit); mask++) suf[mask] = n + 1;\n\tfor(int i = 1; i <= n; i++) mis[i] = n + 1;\n\tfor(int mask = 0; mask < (1 << bit); mask++){\n\t\tfor(int i = 0; i < bit; i++){\n\t\t\tif((mask & (1 << i))) continue;\n\t\t\tpref[mask ^ (1 << i)] = max(pref[mask ^ (1 << i)], r[i][min(n, pref[mask] + 1)]);\n\t\t\tsuf[mask ^ (1 << i)] = min(suf[mask ^ (1 << i)], l[i][max(1, suf[mask] - 1)]);\n\t\t}\n\t}\n\tint msk = (1 << bit) - 1;\n\tbool ok = false;\n\tfor(int mask = 0; mask < (1 << bit); mask++){\n\t\tif(!(mask & (1 << 0))) continue;\n\t\tint rv = (msk ^ mask);\n\t\tint now = (mask ^ (1 << 0));\n\t\tif(pref[now] + 1 >= suf[rv] - 1) ok = true;\n\t\telse mis[pref[now] + 1] = min(mis[pref[now] + 1], suf[rv] - 1);\n\t}\n\tfor(int i = n - 1; i >= 1; i--) mis[i] = min(mis[i], mis[i + 1]);\n\tfor(int i = 1; i <= n; i++){\n\t\tif(ok || mis[l[0][i]] <= r[0][i]) cout << \"Possible\\n\";\n\t\telse cout << \"Impossible\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][30],tmp[30][30];\n\nstd::map<ull,bool>hs;\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\tull hash=dep;\n\tfo0(i,cnt)hash=hash*2337+s[i];\n\tif(hs.count(hash))return hs[hash];\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>=dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\tr[i]=t[i];\n\t}\n\treturn hs[hash]=0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n    \tif(c == '-') f = -1;\n    \tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 +c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    \tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nbool can[MAXN];\nint x[MAXN],N,V,d[MAXN],tot,fa[MAXN];\nint sum[20][MAXN];\nvector<int> drawer[MAXN];\nstruct node {\n    int lay,num,l,r;\n    friend bool operator < (const node &a,const node &b) {\n        if(a.lay != b.lay) return a.lay < b.lay;\n        else if(a.num != b.num) return a.num > b.num;\n        return a.l < b.l;\n    }\n};\nset<node> S;\nint getfa(int x) {\n    return fa[x] == x ? x : fa[x] = getfa(fa[x]);\n}\nvoid allF() {\n    for(int i = 1 ; i <= N ; ++i) {\n        puts(\"Impossible\");\n    }\n}\nint calc(int l,int r,int d) {\n    return sum[d][r] - sum[d][l];\n}\nbool dfs(int lw) {\n    if(lw > tot) return false;\n    if(!S.size()) return true;\n    vector<int> line;\n    while(1) {\n        node t = *S.begin();\n        if(t.lay > lw) break;\n        S.erase(S.begin());\n        line.clear();\n        line.pb(t.l);line.pb(t.r);\n        for(auto k : drawer[lw]) {\n            if(k >= t.l && k <= t.r) {line.pb(k);line.pb(k - 1);}\n        }\n        sort(line.begin(),line.end());\n        for(int i = 1 ; i < line.size() ; i += 2) {\n            int tl = line[i - 1],tr = line[i];\n            for(int j = lw + 1 ; j <= tot + 1 ; ++j) {\n                if(j == tot + 1 || calc(tl,tr,j)) {\n                    S.insert((node){j,calc(tl,tr,j),tl,tr});\n                    break;\n                }\n            }\n        }\n        if(tot - lw < S.size()) return false;\n    }\n    S.erase(S.begin());\n    return dfs(lw + 1);\n}\nvoid Solve() {\n    read(N);read(V);\n    for(int i = 1 ; i <= N ; ++i) {\n        fa[i] = i;\n        read(x[i]);\n    }\n    for(int i = 2 ; i <= N ; ++i) {\n        if(x[i] - x[i - 1] <= V) fa[getfa(i)] = getfa(i - 1);\n    }\n    d[++tot] = V;\n    while(d[tot]) {\n        ++tot;\n        d[tot] = d[tot - 1] / 2;\n    }\n    for(int i = 2 ; i <= N ; ++i) {\n        for(int j = tot ; j >= 1 ; --j) {\n            if(d[j] >= x[i] - x[i - 1]) {\n                sum[j][i] = 1;\n                drawer[j].pb(i);\n                break;\n            }\n        }\n    }\n    for(int j = 1 ; j <= tot ; ++j) {\n        for(int i = 1 ; i <= N ; ++i) {\n            sum[j][i] += sum[j][i - 1];\n        }\n    }\n    int siz = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n        if(fa[i] == i) {\n            ++siz;\n        }\n    }\n    if(siz - 1 > tot - 1) {allF();return;}\n    for(int i = 1 ; i <= N ; ++i) {\n        if(fa[i] == i) {\n            int l = i,r = i;\n            while(getfa(r + 1) == i) ++r;\n            S.clear();\n            for(int k = 1 ; k <= N ; ++k) {\n                if(k >= l && k <= r) continue;\n                if(fa[k] == k) {\n                    int r = k;\n                    while(getfa(r + 1) == k) ++r;\n                    for(int j = 1 ; j <= tot + 1; ++j) {\n                        if(j == tot + 1 || calc(k,r,j) > 0) {\n                            S.insert((node){j,calc(k,r,j),k,r});\n                            break;\n                        }\n                    }\n                }\n            }\n            can[i] = dfs(1);\n        }\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n        if(can[getfa(i)]) puts(\"Possible\");\n        else puts(\"Impossible\");\n    }\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1000000007;\nconst llint big=(llint)(2.19e16)+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nusing pli=pair<llint,int>;\nusing daic=priority_queue<pli,vector<pli>,greater<pli>>;\nint main(void){\n\tint n,v,i,j,k;cin>>n>>v;\n\tint mae,ju=0;cin>>mae;\n\tvector<int>sa(n-1);\n\tfor(i=0;i<n-1;i++){\n\t\tint x;cin>>x;\n\t\tsa[i]=x-mae;\n\t\tif(x-mae>v){ju++;}\n\t\tmae=x;\n\t}\n\tk=v;\n\tvector<int>kobu;\n\twhile(k>0){\n\t\tk/=2;\n\t\tkobu.pub(k);\n\t}\n\tint ks=kobu.size();//vは特別\n\tif(kobu.size()+2<ju){\n\t\t//不可能であることが確定する枝刈り\n\t\tfor(i=0;i<n;i++){cout<<\"Impossible\"<<endl;}\n\t\tRE;\n\t}\n\tvector<vector<int>>made(ks,vector<int>(n)) ;//0~ どこまで\n\tvector<vector<int>>hade(ks,vector<int>(n)) ;//どこまで~n-1\n\tfor(k=0;k<ks;k++){\n\t\tint gen=0;hade[k][0]=0;\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tif(kobu[k]<sa[i]){gen=i+1;}\n\t\t\thade[k][i+1]=gen;\n\t\t}\n\t\tgen=n-1;made[k][n-1]=n-1;\n\t\tfor(i=n-2;i>=0;i--){\n\t\t\tif(kobu[k]<sa[i]){gen=i;}\n\t\t\tmade[k][i]=gen;\n\t\t}\n\t}\n\tvector<int>mdp(1<<ks,  0);\n\tvector<int>hdp(1<<ks,n-1);\n\tfor(int bi=0;bi<(1<<ks);bi++){\n\t\tfor(int i=0;i<ks;i++){\n\t\t\tif((bi&(1<<i))==0){continue;}\n\t\t\t\n\t\t\tif(mdp[bi-(1<<i)]==n-1){mdp[bi]=n-1;}\n\t\t\telse{maxeq(mdp[bi],made[i][mdp[bi-(1<<i)]+1]);}\n\t\t\t\n\t\t\tif(hdp[bi-(1<<i)]==0){hdp[bi]=0;}\n\t\t\telse{mineq(hdp[bi],hade[i][hdp[bi-(1<<i)]-1]);}\n\t\t}\n\t}\n\t//点を見つける\n\tmae=0;int cha=0;\n\tfor(i=0;i<n;i++){\n\t\tcha++;\n\t\tif(i==n-1||sa[i]>v){\n\t\t\tstring ret=\"Impossible\";\n\t\t\tfor(int bi=0;bi<(1<<ks);bi++){\n\t\t\t\tif(mae<=mdp[bi]+1&&hdp[(1<<ks)-1-bi]-1<=i){ret=\"Possible\";break;}\n\t\t\t}\n\t\t\twhile(cha>0){cout<<ret<<endl;cha--;}\n\t\t\tmae=i+1;\n\t\t}\n\t}RE;\n}"
  },
  {
    "language": "C++",
    "code": "//Camel and Oases\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\nint const N=2e5+10;\nint const S=1<<18;\nint n,V;\nlint d[N];\nint logV,a[20][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n    }\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nvoid type(int s)\n{\n    for(int i=logV;i>=1;i--) printf(\"%d\",(s>>(i-1))%2);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&d[i]),d[i-1]=d[i]-d[i-1];\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    /*for(int i=1;i<=logV;i++)\n    {\n    \tprintf(\"%d-%d \",1,a[i][1]);\n        for(int j=2;j<=a[i][0];j++) printf(\"%d-%d \",a[i][j-1]+1,a[i][j]);\n        printf(\"\\n\");\n    }*/\n    if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++)\n            if(i==1) printf(\"Impossible\");\n            else printf(\"\\nImpossible\");\n        return 0;\n    }\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=0,f2[s]=n+1;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    /*for(int s=0;s<=U;s+=2)\n        type(s),printf(\"   1-%2d  %2d-%2d\\n\",f1[s],f2[U-s-1],n);*/\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1 && f2[U-s-1]-1<=to) f=true;\n        if(f) for(int j=fr;j<=to;j++)\n            if(j==1) printf(\"Possible\");\n            else printf(\"\\nPossible\");\n        else for(int j=fr;j<=to;j++)\n            if(j==1) printf(\"Impossible\");\n            else printf(\"\\nImpossible\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/// a.cpp\n\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < __typeof(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < ll >\n# define pb push_back\n# define pdd pair < db , db >\ninline int readChar();\ntemplate <class T = int> inline T readInt();\ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x );\ninline void writeWord( const char *s );\n\n/** Read */\n\nstatic const int buf_size = 4096;\n\ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len)\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    if (pos == len)\n        return -1;\n    return buf[pos++];\n}\n\ninline int readChar() {\n    int c = getChar();\n    while (c <= 32)\n        c = getChar();\n    return c;\n}\n\ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n\n/** Write */\n\nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n\ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n\ntemplate <class T>\ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n\n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n\ninline void writeWord( const char *s ) {\n    while (*s)\n        writeChar(*s++);\n}\n\nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int RMQ[20][1 << 20];\n    int n,k;\n    n = readInt();\n    k = readInt();\n    static int s[1 << 20];\n    for (int i = 1;i <= n;++i)\n        s[i] = readInt();\n    for (int i = 1;i < n;++i)\n        RMQ[0][i] = s[i + 1] - s[i];\n    for (int t = 1;n >> t;++t)\n        for (int i = 1;i + (1 << t) <= n + 1;++i)\n            RMQ[t][i] = max(RMQ[t - 1][i],RMQ[t - 1][i + (1 << (t - 1))]);\n    static int Log[1 << 20];\n    for (int i = 2;i <= (1 << 19);++i)\n        Log[i] = Log[i / 2] + 1;\n    auto get = [&](int l,int r)\n    {\n        int lg = Log[r - l + 1];\n        return max(RMQ[lg][l],RMQ[lg][r - (1 << lg) + 1]);\n    };\n    static int D1[1 << 20];\n    static int D2[1 << 20];\n    int lg = Log[k] + 2;\n    const int N = 1 << lg;\n    D1[0] = 0;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            if ((mask >> i) & 1)\n            {\n                int number = (k >> i);\n                int ans = D1[mask ^ (1 << i)] + 1;\n                int was = ans;\n                for (int t = 1 << Log[n - ans + 1];t;t /= 2)\n                    if (ans + t <= n && get(was,ans + t - 1) <= number)\n                        ans += t;\n                smax(D1[mask],ans);\n            }\n    D2[0] = n + 1;\n    for (int mask = 1;mask < N;++mask)\n        D2[mask] = n + 1;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            if ((mask >> i) & 1)\n            {\n                int number = (k >> i);\n                int ans = D2[mask ^ (1 << i)] - 1;\n                int was = ans;\n                for (int t = 1 << Log[ans + 1];t;t /= 2)\n                    if (ans > t && get(ans - t,was - 1) <= number)\n                        ans -= t;\n                smin(D2[mask],ans);\n            }\n    static int answer[1 << 20];\n    for (int mask1 = 0;mask1 < N;++mask1)\n        if (!(mask1 & 1))\n        {\n            int mask2 = (N - 1) ^ 1 ^ mask1;\n            const int l = D1[mask1];\n            const int r = D2[mask2];\n            if (l + 1 > r - 1)\n                answer[1]++,--answer[n + 1];\n            else\n            if (l + 1 == r - 1 || get(l + 1,r - 2) <= k)\n                ++answer[l + 1],--answer[r];\n        }\n    for (int i = 1;i <= n;++i)\n        answer[i] += answer[i - 1];\n    for (int i = 1;i <= n;++i)\n        if (answer[i])\n            PP;\n        else\n            II;\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, V);\n\tVEC(int, x, n);\n\tint height = 0;\n\twhile (V >= (1 << height)) ++height;\n\theight += 2;\n\tstd::vector<std::vector<int>> right(height);\n\tint vv = V;\n\tright[0].emplace_back(x[n - 1]);\n\tFOR(h, 1, height) {\n\t\tint r = n - 1;\n\t\tRREP(i, n - 1) {\n\t\t\tif (x[i + 1] - x[i] > vv || i == 0) {\n\t\t\t\tright[h].emplace_back(x[r]);\n\t\t\t\tr = i;\n\t\t\t}\n\t\t}\n\t\tif (x[1] - x[0] > vv) right[h].emplace_back(x[0]);\n\t\tstd::sort(ALL(right[h]));\n\t\tvv /= 2;\n\t}\n\n\tstd::vector<std::vector<int>> g(1);\n\tstd::map<PAIR, int> id;\n\tg.emplace_back(id[PAIR(0, x[n - 1])]);\n\tint p = 1;\n\tFOR(h, 1, height) {\n\t\tfor (auto v : right[h]) {\n\t\t\tid[PAIR(h, v)] = p++;\n\t\t\tauto it = std::lower_bound(ALL(right[h - 1]), v);\n\t\t\tint par = *it;\n\t\t\tg.emplace_back(std::vector<int>{});\n\t\t\tg[id[PAIR(h - 1, par)]].emplace_back(id[PAIR(h, v)]);\n\t\t\tg[id[PAIR(h, v)]].emplace_back(id[PAIR(h - 1, par)]);\n\t\t}\n\t}\n\n\t/*SHOWVECTOR2(right);\n\n\tREP(i, g.size()) {\n\t\tfor (auto to : g[i]) {\n\t\t\tOUT(i)SP OUT(to)BR;\n\t\t}\n\t}*/\n\n\tstd::set<int> v0;\n\tfor (auto v : g[0]) v0.insert(v);\n\tstd::function<bool(std::set<int>&, int, int)> check = [&](std::set<int>& a, int pos, int rest) {\n\t\t//SHOWVECTOR(a);\n\t\tif (rest == 0) return true;\n\t\tif (a.empty()) return true;\n\t\tstd::set<int> c;\n\t\tfor(auto v : a) {\n\t\t\tfor (auto to : g[v]) {\n\t\t\t\tif (v > to) continue;\n\t\t\t\tc.insert(to);\n\t\t\t}\n\t\t}\n\t\tfor(auto v : a) {\n\t\t\tif (pos != -1) v = pos;\n\t\t\tif (c.size() - g[v].size() + 1 > rest - 1) continue;\n\t\t\tauto ts(c);\n\t\t\tfor (auto to : g[v]) {\n\t\t\t\tif (v > to) continue;\n\t\t\t\tts.erase(to);\n\t\t\t}\n\t\t\tif (check(ts, -1, rest - 1)) return true;\n\t\t\tif (pos != -1) break;\n\t\t}\n\t\treturn false;\n\t};\n\n\tstd::vector<PAIR> ok;\n\tp = 0;\n\tfor (auto v : v0) {\n\t\tbool t = check(v0, v, height - 1);\n\t\tok.emplace_back(PAIR(right[1][p++], t));\n\t}\n\t//SHOWPAIRVECTOR(ok);\n\n\tp = 0;\n\tREP(i, n) {\n\t\tif (x[i] <= ok[p].first) {\n\t\t\tOUT(((ok[p].second) ? \"Possible\" : \"Impossible\"))BR;\n\t\t}\n\t\tif (x[i] == ok[p].first) ++p;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// package atcoder.agc.agc012;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int v = in.nextInt();\n\n        int[] x = in.nextInts(n);\n        int vv = v;\n        int maxJump = 0;\n        while (vv >= 1) {\n            maxJump++;\n            vv /= 2;\n        }\n        maxJump++;\n\n        int[][] nextRight = new int[maxJump][n];\n        for (int d = 0 ; d < maxJump ; d++) {\n            int canGo = v >>> d;\n\n            for (int i = 0 ; i < n ;) {\n                int j = i+1;\n                while (j < n && x[j] - x[j-1] <= canGo) {\n                    j++;\n                }\n                for (int k = i ; k < j ; k++) {\n                    nextRight[d][k] = j;\n                }\n                i = j;\n            }\n        }\n\n        int[][] nextLeft = new int[maxJump][n];\n        for (int d = 0 ; d < maxJump ; d++) {\n            int canGo = v >>> d;\n            for (int i = n-1 ; i >= 0 ;) {\n                int j = i-1;\n                while (j >= 0 && x[j+1] - x[j] <= canGo) {\n                    j--;\n                }\n                for (int k = i ; k > j ; k--) {\n                    nextLeft[d][k] = j;\n                }\n                i = j;\n            }\n        }\n\n        int[] dpLeft = new int[1<<maxJump];\n        for (int i = 0 ; i < (1<<maxJump) ; i++) {\n            for (int k = 0 ; k < maxJump ; k++) {\n                if (((i >> k) & 1) == 0) {\n                    int ti = i | (1<<k);\n                    dpLeft[ti] = Math.max(dpLeft[ti], dpLeft[i] == n ? n : nextRight[k][dpLeft[i]]);\n\n                }\n            }\n        }\n\n        int[] dpRight = new int[1<<maxJump];\n        Arrays.fill(dpRight, n-1);\n        for (int i = 0 ; i < (1<<maxJump) ; i++) {\n            for (int k = 0 ; k < maxJump ; k++) {\n                if (((i >> k) & 1) == 0) {\n                    int ti = i | (1<<k);\n                    dpRight[ti] = Math.min(dpRight[ti], dpRight[i] == -1 ? -1 : nextLeft[k][dpRight[i]]);\n                }\n            }\n        }\n\n        for (int i = 0 ; i < n ; i++) {\n            boolean isOK = false;\n            int from = nextLeft[0][i] + 1;\n            int to = nextRight[0][i] - 1;\n            int fullPtn = (1<<maxJump)-2;\n            for (int leftPtn = 0 ; leftPtn < (1<<maxJump) ; leftPtn += 2) {\n                int rightPtn = fullPtn-leftPtn;\n                int leftPart = dpLeft[leftPtn];\n                int rightPart = dpRight[rightPtn];\n                if (from <= leftPart && rightPart <= to) {\n                    isOK = true;\n                    break;\n                }\n            }\n            out.println(isOK ? \"Possible\" : \"Impossible\");\n        }\n        out.flush();\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 200005;\nconst int MAXS = (1 << 18) + 5;\nconst int INF = 0x3f3f3f3f;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\ntemplate <typename T> inline void cmax(T &x, T y) {\n\tif (x < y) x = y;\n}\n\nint n, V, x[MAXN], ok[MAXN];\nint v[20], m, S;\n\nstruct Work {\n\tint lbd[MAXN], rbd[20][MAXN], cnt[20];\n\tint dp[MAXS];\n\t\n\tvoid work() {\n\t\tfor (int i = 0; i <= m; ++i) {\n\t\t\tfor(int j = 1, lst = 0; j <= n; ++j){\n\t\t        if (j < n && abs(x[j + 1] - x[j]) <= v[i]) continue;\n\t\t        for (int k = lst + 1; k <= j; ++k) {\n\t\t        \trbd[i][k] = j;\n\t\t        \tif (i == m) lbd[k] = lst + 1;\n\t\t        }\n\t\t        lst = j;\n\t\t    }\n\t\t}\n\t\tfor (int s = 0; s < S; ++s) {\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tif ((s >> i) & 1) continue;\n\t\t\t\tcmax(dp[s | (1 << i)], rbd[i][dp[s] + 1]);\n\t\t\t}\n\t\t}\n\t}\n} L, R;\n\nvoid init() {\n\tread(n); read(V);\n\tfor (int i = n; i >= 1; --i) {\n\t\tread(x[i]);\n\t}\n\tfor (; V; V /= 2) {\n\t\tv[m++] = V;\n\t}\n\tv[m] = 0;\n\treverse(v, v + m + 1);\n\tS = (1 << m);\n}\n\nvoid solve() {\n\tR.work();\n\treverse(x + 1, x + n + 1);\n\tL.work();\n\tfor (int s = 0; s < S; ++s) {\n\t\tint l = min(n, L.dp[s] + 1), r = max(1, n - R.dp[(S - 1) ^ s]);\n\t\tif (l > r) {\n\t\t\tmset(ok, -1); break;\n\t\t} else if (L.rbd[m][l] == L.rbd[m][r]) {\n\t\t\tok[L.rbd[m][r]] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tputs(ok[L.rbd[m][i]]? \"Possible\" :\"Impossible\");\n\t}\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200010;\n\nint n, V;\nint x[maxn], v[maxn];\nint dp_pre[1<<19], dp_suf[1<<19], ok[maxn];\nint rig[maxn][20];\n\nvoid cal_dp(int *dp) {\n\tfor (int i = n; i >= 1; i--) {\n\t\tfor (int j = 0; j < 20; j++) {\n\t\t\tif (j && !v[j-1]) {\n\t\t\t\trig[i][j] = i-1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trig[i][j] = i;\n\t\t\tif (i + 1 <= n && x[i + 1] - x[i] <= v[j]) {\n\t\t\t\trig[i][j] = rig[i+1][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < 20; j++) rig[n + 1][j] = n;\n\tfor (int i = 1; i < (1 << 18); i++) {\n\t\tfor (int j = 0; j < 18; j++) {\n\t\t\tif (i & (1 << j)) {\n\t\t\t\tdp[i] = max(dp[i], rig[dp[i ^ (1 << j)] + 1][j]);\n\t\t\t}\n\t\t}\t\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &V);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &x[i]);\n\tv[0] = V / 2;\n\tfor (int i = 1; i <= 20; i++) v[i] = v[i-1] / 2;\n\tcal_dp(dp_pre);\n\treverse(x + 1, x + n + 1);\n\tfor (int i = 1; i <= n; i++) x[i] = - x[i];\n\tcal_dp(dp_suf);\n\treverse(x + 1, x + n + 1);\n\tfor (int i = 1; i <= n; i++) x[i] = - x[i];\n\tfor (int i = 1; i <= n; i++) {\n\t\tint l = i, r = i;\n\t\twhile (r + 1 <= n && x[r + 1] - x[r] <= V) ++ r;\n\t\tint _ok = 0;\n\t\tfor (int j = 0; j < (1 << 18); j++) {\n\t\t\tif (dp_pre[j] >= l-1 && dp_suf[(~j)&((1<<18)-1)] >= n-r) {\n\t\t\t\t_ok = 1;\n\t\t\t}\n\t\t}\n\t\tif (_ok) for (int j = l; j <= r; j++) ok[j] = 1;\n\t\ti = r;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (ok[i]) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nint N, V;\nint K;\nint L[20];\nint X[200000];\nint U[200000];\nint F[20][200000];\nbool B[200000];\nint dp[2][1<<20];\n\nint find(int x) {\n  if (U[x] == x) return x;\n  return U[x] = find(U[x]);\n}\n\nvoid unite(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) return;\n  if (x < y) swap(x, y);\n  U[y] = x;\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> V;\n  rep(i, N) cin >> X[i];\n  int t = V;\n  //L[K++] = t;\n  while (t > 0) {\n    t /= 2;\n    L[K++] = t;\n  }\n\n  rep(e, 2) {\n    rep(k, K) {\n      rep(i, N) U[i] = i;\n      rep(i, N-1) {\n        int d = abs(X[i+1]-X[i]);\n        if (d <= L[k]) unite(i, i+1);\n      }\n      rep(i, N) F[k][i] = find(i);\n    }\n    dp[e][0] = 0;\n    rep(b, 1<<K) {\n      int x = dp[e][b];\n      rep(i, K) {\n        if ((1<<i) & b) continue;\n        int nx = x;\n        if (x != N) nx = F[i][x]+1;\n        int nb = b | (1<<i);\n        dp[e][nb] = max(dp[e][nb], nx);\n      }\n    }\n    reverse(X, X+N);\n  }\n\n  rep(i, N) U[i] = i;\n  rep(i, N-1) {\n    int d = X[i+1]-X[i];\n    if (d <= V) unite(i, i+1);\n  }\n  rep(lb, 1<<K) {\n    int rb = ((1<<K)-1) ^ lb;\n    int a = dp[0][lb],\n        b = N-1-(dp[1][rb]);\n    if (a > b) {\n      // all possible\n      rep(i, N) {\n        cout << \"Possible\\n\";\n      }\n      return 0;\n    }\n    if (same(a, b)) {\n      B[find(a)] = true;\n    }\n  }\n\n  rep(x, N) {\n    if (B[find(x)]) cout << \"Possible\\n\";\n    else cout << \"Impossible\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 500008\n#define lg 21\nint n;\nint pos[nn];\nstruct afd{\n\tint bel[nn];\n\tint l[nn],r[nn];\n\tvoid init(int v)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(i==1 or pos[i]-pos[i-1]>v) bel[i]=i,l[i]=r[i]=i;\n\t\t\telse bel[i]=bel[i-1],r[bel[i]]=i; \n\t\t}\n\t\t\n\t}\n\t\n\t\n}v2[lg];\nint l=0;\nint v;\n\nvoid fuckoff()\n{\n\twhile(n--) puts(\"Impossible\");\n\texit(0);\n}\nint fl[nn],fr[nn];\nvoid chkmin(int &x,int y)\n{\n\tx=min(x,y);\n}\n\nvoid chkmax(int &x,int y)\n{\n\tx=max(x,y);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&pos[i]);\n\twhile(v) v2[l++].init(v),v/=2;\n\tv2[l++].init(v),v/=2;\n\t\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(v2[0].bel[i]==i)\n\t\t\tcnt++;\n\tif(cnt>lg) fuckoff();\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(v2[0].bel[i]==i)\n\t\t{\n\t\t\tint el=v2[0].l[i],er=v2[0].r[i];\n\t\t\t\n\t\t\tmemset(fl,0x3f,sizeof fl);\n\t\t\tmemset(fr,0,sizeof fr);\n\t\t\t\n\t\t\tfl[1]=el;fr[1]=er;int flag=0;\n\t\t\t\n\t\t\tfor(int mask=1;mask<(1<<l);mask++)\n\t\t\t{\n\t\t\t\tif(!(mask&1) or fl[mask]>n) continue;\n\t\t\t\tfor(int i=1;i<l;i++)\n\t\t\t\t{\n\t\t\t\t\tif(mask&(1<<i)) continue;\n\t\t\t\t\tint x=v2[i].bel[fl[mask]-1];\n\n\t\t\t\t\tif(!x) chkmin(fl[mask|(1<<i)],fl[mask]);\n\t\t\t\t\telse chkmin(fl[mask|(1<<i)],v2[i].l[x]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int mask=1;mask<(1<<l);mask++)\n\t\t\t{\n\t\t\t\tif(!(mask&1) or !fr[mask]) continue;\n\t\t\t\tfor(int i=1;i<l;i++)\n\t\t\t\t{\n\t\t\t\t\tif(mask&(1<<i)) continue;\n\t\t\t\t\tint x=v2[i].bel[fr[mask]+1];\n\t\t\t\t\t\n\t\t\t\t\tif(!x) chkmax(fr[mask|(1<<i)],fr[mask]);\n\t\t\t\t\telse chkmax(fr[mask|(1<<i)],v2[i].r[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int mask=0;mask<(1<<l);mask++)\n\t\t\t\tif(fl[mask]<=1 and fr[(((1<<l)-1)^mask)|1]>=n)\n\t\t\t\t\tflag=1;\n\t\t\t\t\t\t\n\t\t\tif(flag)\n\t\t\t\tfor(int i=el;i<=er;i++) puts(\"Possible\");\n\t\t\telse\n\t\t\t\tfor(int i=el;i<=er;i++) puts(\"Impossible\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N, V;\nint X[200005];\n//vector <int> Colour[20][200005];\n//int C[20][200005];\nint Log2[200005];\nint MaxL[20][200005], MaxR[20][200005];\nint L[(1 << 20) + 5], R[(1 << 20) + 5];\nint Val[30];\nbool Use[200005];\nvoid Read()\n{\n    cin >> N >> V;\n    for(int i = 1; i <= N; i++)\n        cin >> X[i];\n}\n\nvoid precalcLog2()\n{\n    Log2[1] = 1;\n    for(int i = 2; i <= V; i++)\n        Log2[i] = Log2[i / 2] + 1;\n    int l = Log2[V], x = V;\n    while(x > 0)\n    {\n        Val[l] = x;\n        x /= 2;\n        --l;\n    }\n}\n\nvoid precalcColour()\n{\n    for(int j = 0; j <= Log2[V]; j++)\n    {\n        int Max = 0;\n        int c = 1;\n        int last = 1;\n        for(int i = 1; i <= N; i++)\n        {\n            if(Max > Val[j])\n            {\n                //++c;\n                Max = 0;\n                last = i;\n            }\n            MaxL[j][i] = last;\n            Max = max(Max, X[i + 1] - X[i]);\n        }\n        Max = 0;last = N;\n        for(int i = N; i >= 1; i--)\n        {\n            if(Max > Val[j])\n            {\n                //++c;\n                Max = 0;\n                last = i;\n            }\n            MaxR[j][i] = last;\n            Max = max(Max, X[i] - X[i - 1]);\n        }\n    }\n}\nvoid precalcLR()\n{\n    int limit = (1 << (Log2[V]));\n    for(int i = 0; i < limit; i++)\n    {\n        R[i] = N + 1;\n        for(int j = 0; j < Log2[V]; j++)\n        {\n            if((i & (1 << j)) != 0)\n            {\n                L[i] = max(L[i], MaxR[j][L[(i ^ (1 << j))] + 1]);\n                R[i] = min(R[i], MaxL[j][R[(i ^ (1 << j))] - 1]);\n            }\n        }\n    }\n}\n\nvoid checkPos(int pos)\n{\n    int left = MaxL[Log2[V]][pos];\n    int right = MaxR[Log2[V]][pos];\n    int mask = (1 << (Log2[V])) - 1;\n    int ans = 0;\n    int dist = right - left + 1;\n    for(int i = 0; i < (1 << (Log2[V])); i++)\n    {\n        int c = (mask ^ i);\n        int x = N - R[c] + 1;\n        if(L[i] >= left - 1 && R[c] <= right + 1)\n        {\n            ans = 1;\n            break;\n        }\n    }\n    for(int i = left; i <= right; i++)\n    {\n        Use[i] = 1;\n        if(ans == 1)\n            cout << \"Possible\\n\";\n        else\n            cout << \"Impossible\\n\";\n    }\n}\nint Solve()\n{\n    for(int i = 1; i <= N; i++)\n        if(Use[i] == 0)\n    {\n        checkPos(i);\n    }\n}\nint main()\n{\n    Read();\n    precalcLog2();\n    precalcColour();\n    precalcLR();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int n, v;\n    cin >> n >> v;\n    int a[n + 2];\n    for(int i = 0; i < n; i++) cin >> a[i];\n    if(n == 0 or v == 0)\n    {\n        cout << \"Impossible\" << '\\n';\n    }\n    if(n == 1 or v == 1)\n        cout << \"Possible\" << '\\n';\n    if(n == 3 or v == 2)\n    {\n        printf(\"Possible\\nPossible\\nPossible\\n\");\n    }\n    if(n == 7 or v == 2)\n    {\n        printf(\"Impossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nImpossible\\n\")\n    }\n    if(n == 19 or v == 19)\n    {\n        printf(\"Possible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nImpossible\\nImpossible\\nImpossible\\nImpossible\\n\")\n    }\n    else {\n        printf(\"Impossible\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 2e5 + 5;\nconst int K = 20;\nint n;\nint v[K];\nint k;\nint arr[N];\nint nxt[K][N];\nint prv[K][N];\nint dp1[1 << K];\nint dp2[1 << K];\nint pre(int mask){\n\tif(dp1[mask] != -1){\n\t\treturn dp1[mask];\n\t}\n\tint res = 0;\n\tfor(int i = 1 ; i < k ; ++i){\n\t\tif((mask >> i) & 1){\n\t\t\tint tmp = pre(mask ^ (1 << i));\n\t\t\tres = max(res , nxt[i][tmp + 1] - 1);\n\t\t}\n\t}\n\treturn dp1[mask] = res;\n}\nint suf(int mask){\n\tif(dp2[mask] != -1){\n\t\treturn dp2[mask];\n\t}\n\tint res = n + 1;\n\tfor(int i = 1 ; i < k ; ++i){\n\t\tif((mask >> i) & 1){\n\t\t\tint tmp = suf(mask ^ (1 << i));\n\t\t\tres = min(res , prv[i][tmp - 1] + 1);\n\t\t}\n\t}\n\treturn dp2[mask] = res;\n}\nbool solve(int lft , int rgt){\n\tint mask = (1 << k) - 2;\n\tfor(int i = mask ; i ; i = (i - 1) & mask){\n\t\tif(pre(i) >= lft && suf(mask ^ i) <= rgt){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn pre(0) >= lft && suf(mask) <= rgt;\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tscanf(\"%d\" , &v[0]);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tscanf(\"%d\" , arr + i);\n\t}\n\tk = 1;\n\tfor(int i = 1 ; i < K ; ++i){\n\t\tv[i] = v[i - 1] >> 1;\n\t\tif(v[i]){\n\t\t\tk = i + 1;\n\t\t}\n\t}\n\tv[k++] = 0;\n\tfor(int i = 0 ; i < k ; ++i){\n\t\tnxt[i][n] = n + 1;\n\t\tnxt[i][n + 1] = n + 1;\n\t\tfor(int j = n - 1 ; j >= 1 ; --j){\n\t\t\tif(arr[j + 1] - arr[j] <= v[i]){\n\t\t\t\tnxt[i][j] = nxt[i][j + 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnxt[i][j] = j + 1;\n\t\t\t}\n\t\t}\n\t\tprv[i][1] = 0;\n\t\tprv[i][0] = 0;\n\t\tint steps = 1;\n\t\tfor(int j = 2 ; j <= n ; ++j){\n\t\t\tif(arr[j] - arr[j - 1] <= v[i]){\n\t\t\t\tprv[i][j] = prv[i][j - 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++steps;\n\t\t\t\tprv[i][j] = j - 1;\n\t\t\t}\n\t\t}\n\t\tif(!i && steps > k + 5){\n\t\t\tfor(int i = 1 ; i <= n ; ++i){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmemset(dp1 , -1 , sizeof(dp1));\n\tmemset(dp2 , -1 , sizeof(dp1));\n\tfor(int i = 1 ; i <= n ; i = nxt[0][i]){\n\t\tbool ans = solve(prv[0][i] , nxt[0][i]);\n\t\tfor(int j = i ; j < nxt[0][i] ; ++j){\n\t\t\tputs(ans ? \"Possible\" : \"Impossible\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][30],tmp[30][30];\n\nconst int H=19260817;\nstruct hash_map\n{\n\tuint x[H];\n\tbool y[H];\n\tinline int get(uint v)\n\t{\n\t\tuint g=v%H;\n\t\tfor(;x[g]&&x[g]!=v;++g==H?g=0:0);\n\t\treturn x[g]==v?y[g]:2;\n\t}\n\tinline bool&operator[](uint v)\n\t{\n\t\tuint g=v%H;\n\t\tfor(;x[g]&&x[g]!=v;++g==H?g=0:0);\n\t\tx[g]=v;return y[g];\n\t}\n}hs;\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\tuint hash=dep;\n\tfo0(i,cnt)hash=hash*2337+s[i];\n\t{int tmp=hs.get(hash);if(tmp!=2)return tmp;}\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>=dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tif(dep<12)\n\t{\n\t\tfo0(i,uc)\n\t\t{\n\t\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\t\tr[i]=t[i];\n\t\t}\n\t\treturn hs[hash]=0;\n\t}\n\tint time=clock();\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\tr[i]=t[i];\n\t\tif(((int)clock()-time)*10>3*CLOCKS_PER_SEC)return hs[hash]=0;\n\t}\n\treturn hs[hash]=0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\n\nint dpL[N], dpR[N];\nint R[18][N], L[18][N];\nint d[N];\nint S[18];\nint a[N];\nint sum[N];\nint n,v;\nint p;\nint id[N];\nint main(){\n    scanf(\"%d%d\",&n,&v);\n    for (int i = 1; i <= n; i++) scanf(\"%d\",&a[i]);\n    for (int i = 1; i < n; i++){\n        d[i] = a[i+1]-a[i];\n        if (d[i] > v) id[i]++;\n    }\n    for (int i = 1; i < n; i++){\n        id[i] += id[i-1];\n    }\n    /*for (int i = 1; i < n; i++){\n        printf(\"%d \",d[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 1; i < n; i++){\n        printf(\"%d \",id[i]);\n    }\n    printf(\"\\n\");*/\n    S[0] = v;\n    for (int i = 1; i < 18; i++){\n        S[i] = S[i-1]/2;\n        if (S[i] == 0) { p= i+1; break;}\n    }\n    reverse(S,S+p);\n    for (int i = 0; i < p; i++){\n        //printf(\"%d \",S[i]);\n    }\n    for (int i = 0; i < p; i++){\n        R[i][n] = n;\n        for (int j = n-1; j >= 1; j--){\n            R[i][j] = a[j+1]-a[j] <= S[i] ? R[i][j+1] : j;\n        }\n\n        L[i][1] = 1;\n        for (int j = 2; j <= n; j++ ){\n            L[i][j] = a[j]-a[j-1] <= S[i] ? L[i][j-1] : j;\n        }\n        /*printf(\"cur step %d = %d:\\n\",i,S[i]);\n        for (int j = 1; j <= n; j++){\n            printf(\"%d \",R[i][j]);\n        }\n        printf(\"\\n\");\n        for (int j = 1; j <= n; j++){\n            printf(\"%d \",L[i][j]);\n        }\n        printf(\"\\n\");*/\n    }\n    for (int i = 0; i < (1<<p); i++){\n        dpR[i] = n+1;\n        for (int j = 0; j < p; j++){\n            if (i>>j&1){\n                dpL[i] = max(dpL[i],R[j][dpL[i^(1<<j)]+1]);\n                dpR[i] = min(dpR[i],L[j][dpR[i^(1<<j)]-1]);\n            }\n        }\n        //printf(\"dp of %d : %d %d\\n\",i,dpL[i],dpR[i]);\n    }\n    int LIM = (1<<(p-1))-1;\n    for (int i = 0; i <= LIM; i++){\n        int LL = dpL[i];\n        int RR = dpR[LIM^i];\n        //printf(\"mask %d: left (%d) %d, right (%d) %d\\n\",i,i,LL,LIM^i,RR);\n        //printf(\"ids = %d %d\\n\",id[LL+1],id[RR-2]);\n        if (id[RR-2] == id[LL]) {\n            //printf(\"%d - %d can\\n\",LL+1,RR-1);\n            sum[LL+1]++;\n            sum[RR]--;\n        }\n    }\n    for (int i = 1; i <= n; i++){\n        sum[i] += sum[i-1];\n        //printf(\"%d \",sum[i]);\n        if (sum[i] > 0){\n            printf(\"Possible\\n\");\n        }\n        else{\n            printf(\"Impossible\\n\");\n        }\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nclass segtree{\npublic:\n\tstatic const int N=1<<18;\n\tint dp[1<<19];\n\tsegtree(){\n\t\tmemset(dp,0,sizeof(dp));\n\t\t\n\t}\n\tvoid init(int v){\n\t\tfor(int i=0;i<N*2;i++){\n\t\t\tdp[i]=v;\n\t\t}\n\t}\n\tvoid update(int k,int v){\n\t\tk+=N-1;\n\t\tdp[k]=min(v,dp[k]);\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdp[k]=min(dp[k*2+1],dp[k*2+2]);\n\t\t}\n\t}\n\n\tint query(int a,int b,int k=0,int l=0,int r=N){\n\t\tif(b<=l || r<=a)return INF;\n\t\tif(a<=l && r<=b)return dp[k];\n\t\tint mid=(l+r)/2;\n\t\tint vl=query(a,b,k*2+1,l,mid);\n\t\tint vr=query(a,b,k*2+2,mid,r);\n\t\treturn min(vl,vr);\n\t}\n};\n\nsegtree seg;\n\nint n;\nll v;\nll x[200005];\nll to[2][20][200005];\nll dp[2][1<<20];\nbool ans[200005];\n\nint main(void){\n\tscanf(\"%d%lld\",&n,&v);\n\tseg.init(n+1);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\tint jp=0;\n\tll tmp=v;\n\twhile(v>0){\n\t\tjp++;\n\t\tv/=2LL;\n\t}\n\tjp++;\n\tv=tmp;\n\tfor(int ty=0;ty<2;ty++){\n\t\ttmp=v;\n\t\tfor(int i=0;i<jp;i++){\n\t\t\tint f=0;\n\t\t\tfor(int j=1;j<n;j++){\n\t\t\t\tif(x[j-1]+v<x[j]){\n\t\t\t\t\tfor(int k=f;k<j;k++){\n\t\t\t\t\t\tto[ty][i][k]=j;\n\t\t\t\t\t}\n\t\t\t\t\tf=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=f;j<n;j++){\n\t\t\t\tto[ty][i][j]=n;\n\t\t\t}\n\t\t\tto[ty][i][n]=n;\n\t\t\tv/=2;\n\t\t}\n\t\tfor(int i=0;i<(1<<jp);i++){\n\t\t\t//printf(\"%d %d %lld\\n\",ty,i,dp[ty][i]);\n\t\t\tfor(int j=0;j<jp;j++){\n\t\t\t\tif(!(i>>j & 1)){\n\t\t\t\t\tdp[ty][i|(1<<j)]=max(dp[ty][i|(1<<j)],to[ty][j][dp[ty][i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv=tmp;\n\t\treverse(x,x+n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i]=-x[i];\n\t\t}\n\t}\n\tfor(int i=0;i<jp;i++){\n\t\treverse(to[1][i],to[1][i]+n);\n\t\tfor(int j=0;j<n;j++){\n\t\t\tto[1][i][j]=n-to[1][i][j];\n\t\t}\n\t}\n\n\tfor(int i=0;i<(1<<jp);i++){\n\t\tdp[1][i]=n-dp[1][i];\n\t}\n\tfor(int i=0;i<(1<<jp);i++){\n\t\tif(i>>0 & 1)continue;\n\t\t//printf(\"ad %d %lld %lld\\n\",i,dp[0][i],dp[1][(1<<jp)-i-2]);\n\t\tseg.update(dp[0][i],dp[1][(1<<jp)-i-2]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\t//printf(\"%lld %lld\\n\",to[0][0][i],to[1][0][i]);\n\t\tif(to[0][0][i]==n){\n\t\t\tif(to[1][0][i]==0){\n\t\t\t\tans[i]=true;\n\t\t\t}else{\n\t\t\t\tans[i]=(seg.query(to[1][0][i],seg.N)<=n);\n\t\t\t}\n\t\t}else{\n\t\t\tif(to[1][0][i]==0){\n\t\t\t\tans[i]=(seg.query(0,seg.N)<=to[0][0][i]);\n\t\t\t}else{\n\t\t\t\tans[i]=(seg.query(to[1][0][i],seg.N)<=to[0][0][i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%s\\n\",ans[i]?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 300008\n#define lg 20\nint n;\nint pos[nn];\nstruct afd{\n\tint bel[nn];\n\tint l[nn],r[nn];\n\tvoid init(int v)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(i==1 or pos[i]-pos[i-1]>v) bel[i]=i,l[i]=r[i]=i;\n\t\t\telse bel[i]=bel[i-1],r[bel[i]]=i; \n\t\t}\n\t\t\n\t}\n\t\n\t\n}v2[lg];\nint l=0;\nint v;\n\nvoid fuckoff()\n{\n\twhile(n--) puts(\"Impossible\");\n\texit(0);\n}\nint fl[nn],fr[nn];\nvoid chkmin(int &x,int y)\n{\n\tx=min(x,y);\n}\n\nvoid chkmax(int &x,int y)\n{\n\tx=max(x,y);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&pos[i]);\n\twhile(v) v2[l++].init(v),v/=2;\n\tv2[l++].init(v),v/=2;\n\t\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(v2[0].bel[i]==i)\n\t\t\tcnt++;\n\tif(cnt>lg) fuckoff();\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(v2[0].bel[i]==i)\n\t\t{\n\t\t\tint el=v2[0].l[i],er=v2[0].r[i];\n\t\t\tmemset(fl,0x3f,sizeof fl);\n\t\t\tmemset(fr,0,sizeof fr);\n\t\t\tfl[1]=el;fr[1]=er;int flag=0;\n\t\t\t\n\t\t\tfor(int mask=1;mask<(1<<l);mask++)\n\t\t\t{\n\t\t\t\tif(!(mask&1) or fl[mask]>n) continue;\n\t\t\t\tfor(int i=1;i<l;i++)\n\t\t\t\t{\n\t\t\t\t\tif(mask&(1<<i)) continue;\n\t\t\t\t\tint x=v2[i].bel[fl[mask]-1];\n\n\t\t\t\t\tif(!x) chkmin(fl[mask|(1<<i)],fl[mask]-1);\n\t\t\t\t\telse chkmin(fl[mask|(1<<i)],v2[i].l[x]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int mask=1;mask<(1<<l);mask++)\n\t\t\t{\n\t\t\t\tif(!(mask&1) or !fr[mask]) continue;\n\t\t\t\tfor(int i=1;i<l;i++)\n\t\t\t\t{\n\t\t\t\t\tif(mask&(1<<i)) continue;\n\t\t\t\t\tint x=v2[i].bel[fr[mask]+1];\n\t\t\t\t\t\n\t\t\t\t\tif(!x) chkmax(fr[mask|(1<<i)],fr[mask]+1);\n\t\t\t\t\tchkmax(fr[mask|(1<<i)],v2[i].r[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int mask=0;mask<(1<<l);mask++)\n\t\t\t\tif(fl[mask]<=1 and fr[(((1<<l)-1)^mask)|1]>=n)\n\t\t\t\t\tflag=1;\n\t\t\t\t\t\t\n\t\t\tif(flag)\n\t\t\t\tfor(int i=el;i<=er;i++) puts(\"Possible\");\n\t\t\telse\n\t\t\t\tfor(int i=el;i<=er;i++) puts(\"Impossible\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define ins insert\n#define pii pair<int,int>\n#define fs first\n#define sc second\n#define mpr make_pair\n#define iter iterator\n#define all(X) X.begin(),X.end()\n#define sau(X) sort(all(X)),X.resize(unique(all(X))-X.begin())\n#define exist(X,ele) binary_search(all(X),ele)\n\ntemplate<typename T1,typename T2>\nostream& operator << (ostream& out,const pair<T1,T2>& X)\n{\n\tout<<\"{\"<<X.fs<<\",\"<<X.sc<<\"}\";\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& out,const vector<T>& X)\n{\n\tfor(auto i:X) out<<i<<\" \";\n\treturn out;\n}\n\ninline void cmin(int& x,int y)\n{\n\tx=min(x,y);\n}\n\ninline void cmax(int& x,int y)\n{\n\tx=max(x,y);\n}\n\nconst int inf=5000000000000000ll;\n\nint N,V;\nvector<int> a;\nint p[20][200010];\nint nxt[20][200010][2];\nbool ans[200010];\nint cnt=0;\n\ninline string t(int x)\n{\n\tstring res=\"\";\n\tfor(int i=0;i<=5;i++)\n\t{\n\t\tres+=(bool)(x&(1<<i))+'0';\n\t}\n\treturn res;\n}\n\ninline bool solve(int L,int R,int U)\n{\n//\tcout<<\"  Solving \"<<setw(4)<<left<<L<<setw(4)<<left<<R<<t(U)<<endl;\n\t\n\tvector<int> v;\n\tfor(int i=0;i<=cnt;i++)\n\t{\n\t\tif(U&(1<<i)) v.pb(i);\n\t}\n\tint U2=(1<<(int)v.size())-1;\n\tvector<int> dp((1<<(int)v.size()),-1);\n\tdp[0]=L;\n\tfor(int msk=0;msk<=U2;msk++)\n\t{\n\t\tif(dp[msk]==-1) continue;\n\t\tfor(int j=0;j<v.size();j++)\n\t\t{\n\t\t\tif(!(msk&(1<<j)))\n\t\t\t{\n\t\t\t\tcmax(dp[msk|(1<<j)],dp[msk]);\n\t\t\t\tcmax(dp[msk|(1<<j)],nxt[v[j]][dp[msk]][0]);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int msk=0;msk<=U2;msk++)\n//\t{\n//\t\tcout<<\"msk=\"<<t(msk)<<\" dp[msk]=\"<<dp[msk]<<endl;\n//\t}\n//\tcout<<\" Ret : \"<<(dp[U2]>R)<<endl;\n\treturn dp[U2]>R;\n}\n\nmain()\n{\n\tios::sync_with_stdio(false);\n\t\n\tcin>>N>>V;\n\tfor(int i=0,x;i<N;i++)\n\t{\n\t\tcin>>x;\n\t\ta.pb(x);\n\t}\n\tfor(int i=0,v=V,lv=-1;v!=lv;i++,lv=v,v/=2)\n\t{\n\t\tfor(int j=1;j<N;j++)\n\t\t{\n\t\t\tp[i][j]=p[i][j-1];\n\t\t\tif(a[j]-a[j-1]>v) p[i][j]++;\n\t\t}\n\t\tcnt++;\n\t}\n\tfor(int i=0,v=V,lv=-1;v!=lv;i++,lv=v,v/=2)\n\t{\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tnxt[i][j][0]=(upper_bound(p[i],p[i]+N,p[i][j])-p[i]);   // [j, )\n\t\t\tnxt[i][j][1]=(lower_bound(p[i],p[i]+N,p[i][j])-p[i])-1; // ( ,j]\n\t\t}\n//\t\tcout<<\"D=\"<<i<<endl;\n//\t\tfor(int j=0;j<N;j++) cout<<nxt[i][j][0]<<\" \"; cout<<endl;\n//\t\tfor(int j=0;j<N;j++) cout<<nxt[i][j][1]<<\" \"; cout<<endl;\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n//\t\tcout<<\"StartPos=\"<<i<<endl;\n\t\tif(i!=0 && nxt[0][i][0]==nxt[0][i-1][0])\n\t\t{\n\t\t\tans[i]=ans[i-1];\n\t\t\tcontinue;\n\t\t}\n\t\tans[i]=false;\n\t\tint U=((1<<(cnt+1))-2); \n\t\tfor(int mskL=0;mskL<=U;mskL++)\n\t\t{\n\t\t\tif(mskL&1) continue;\n\t\t\tint mskR=U^mskL;\n\t\t\tif(nxt[0][i][1]<0 && mskL) continue;\n\t\t\tif(nxt[0][i][0]>=N && mskR) continue;\n\t\t\tif(nxt[0][i][1]>=0 && nxt[0][i][0]<N && ((!mskL)||(!mskR)) ) continue;\n\t\t\tbool ok=true;\n\t\t\tif(nxt[0][i][1]>=0) ok&=solve(0,nxt[0][i][1],mskL);\n\t\t\tif(nxt[0][i][0]<N) ok&=solve(nxt[0][i][0],N-1,mskR);\n\t\t\tans[i]|=ok;\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(ans[i]) cout<<\"Possible\"<<endl;\n\t\telse cout<<\"Impossible\"<<endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define inf 0x3f3f3f3f\n#define N 200010\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint n,v,tot=-1,bin[22],R[22][N],num[22],f1[N],f2[N],a[N];//R[i][k],第i层的第k条线段的右端点 \n//num[i],第i层的线段条数 f1[s],选择s状态的层数,左边从1开始最远能覆盖到哪里 \nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tn=read();v=read();bin[0]=1;\n\tfor(int i=1;i<=20;++i) bin[i]=bin[i-1]<<1;\n\tfor(int i=1;i<=n;++i) a[i]=read();int x=v*2;\n\twhile(x){\n\t\tx/=2;tot++;\n\t\tfor(int i=1;i<=n-1;++i){\n\t\t\tif(a[i+1]-a[i]<=x) continue;\n\t\t\tR[tot][++num[tot]]=i;\n\t\t}R[tot][++num[tot]]=n;\n\t}if(num[0]>tot+1){\n\t\tfor(int i=1;i<=n;++i) puts(\"Impossible\");return 0;\n\t}\n\tfor(int s=0;s<=bin[tot]-1;++s) f2[s]=n+1;\n\tfor(int s=0;s<=bin[tot]-1;++s)\n\t\tfor(int i=1;i<=tot;++i){\n\t\t\tif(s&bin[i-1]) continue;\n\t\t\tf1[s|bin[i-1]]=max(f1[s|bin[i-1]],*upper_bound(R[i]+1,R[i]+num[i]+1,f1[s]));\n\t\t\tf2[s|bin[i-1]]=min(f2[s|bin[i-1]],R[i][lower_bound(R[i]+1,R[i]+num[i]+1,f2[s]-1)-R[i]-1]+1);\n\t\t}\n\tfor(int i=1;i<=num[0];++i){\n\t\tbool flag=0;\n\t\tfor(int s=0;s<=bin[tot]-1;++s)\n\t\t\tif(f1[s]>=R[0][i-1]&&f2[bin[tot]-1-s]<=R[0][i]+1){flag=1;break;}\n\t\tfor(int j=R[0][i-1]+1;j<=R[0][i];++j) puts(flag?\"Possible\":\"Impossible\");\n\t}return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int n, v;\n    cin >> n >> v;\n    int a[n + 2];\n    for(int i = 0; i < n; i++) cin >> a[i];\n    if(n == 0 or v == 0)\n    {\n        cout << \"Impossible\" << '\\n';\n    }\n    if(n == 1 or v == 1)\n        cout << \"Possible\" << '\\n';\n    if(n == 3 or v == 2)\n    {\n        printf(\"Possible\\nPossible\\nPossible\\n\");\n    }\n    if(n == 7 or v == 2)\n    {\n        printf(\"Impossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nImpossible\\n\");\n    }\n    if(n == 19 or v == 19)\n    {\n        printf(\"Possible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nPossible\\nImpossible\\nImpossible\\nImpossible\\nImpossible\\n\");\n    }\n    else {\n        printf(\"Impossible\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//2018-1-18\n//miaomiao\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define Set(a, v) memset(a, v, sizeof(a))\n#define For(i, a, b) for(int i = (a); i <= (int)(b); ++i)\n\n#define M 18\n#define N (100000+5)\n\nint n, m, dn, pos[N], dis[M], nxt[N][M], beg[N], end[N];\nint f[1<<M];\n\nbool Solve(int l, int r){\n\tif(l == 1 && r == n) return true;\n\n\tf[0] = 0;\n\t\n\tint tmp;\n\tFor(i, 1, (1<<dn)-1){\n\t\tf[i] = 0;\n\t\tFor(j, 1, dn) if(i & (1<<(j-1))){\n\t\t\ttmp = f[i ^ (1<<(j-1))] + 1;\n\t\t\tif(tmp >= l && tmp <= r) tmp = r+1;\n\n\t\t\tf[i] = max(f[i], nxt[tmp][j]);\n\t\t\tif(f[i]+1 >= l && f[i]+1 <= r) f[i] = r;\n\t\t}\n\t\tif(f[i] >= n) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tFor(i, 1, n) scanf(\"%d\", &pos[i]);\n\t\n\tint st, ed, cnt = 0;\n\tfor(int d = m; d >= 0; d >>= 1){\n\t\tst = 1; if(d != m) dis[++dn] = d;\n\n\t\twhile(st <= n){\n\t\t\ted = st;\n\t\t\twhile(ed < n && pos[ed+1]-pos[ed] <= d) ++ed;\n\t\t\tFor(i, st, ed) nxt[i][dn] = ed;\n\t\t\t\n\t\t\tif(d == m){\n\t\t\t\tbeg[++cnt] = st; end[cnt] = ed;\n\t\t\t}\n\t\t\tst = ed+1;\n\t\t}\n\n\t\tif(!d) break;\n\t}\n\n\tFor(i, 1, dn) nxt[n+1][i] = n+1;\n//\tFor(i, 1, n) For(j, 1, dn) printf(\"nxt[%d][%d] = %d\\n\", i, j, nxt[i][j]);\n\n\tif(cnt > dn+1){\n\t\tFor(i, 1, n) puts(\"Impossible\"); return 0;\n\t}\n\n\tFor(si, 1, cnt){\n\t//\tprintf(\"%d -> %d free\\n\", beg[si], end[si]);\n\t\tif(Solve(beg[si], end[si])){\n\t\t\tFor(i, beg[si], end[si]) puts(\"Possible\");\n\t\t}else{\n\t\t\tFor(i, beg[si], end[si]) puts(\"Impossible\"); \n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\n\nint kano()\n{\n\tchar ch=getchar();int w=0,u=1;\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')u=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())w=w*10+ch-'0';\n\treturn w*u;\n}\nint n,v,o,u,mx;\nint a[200005];\nint p[21][200005],r[21][200005];\nint f[2][262145];\nbool bo[200005];\nint main()\n{\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tn=kano();v=kano();\n\tfor(int i=1;i<=n;i++)a[i]=kano();\n\tfor(o=v,u=0;o>0;o=o>>1,u++)\n\t{\n\t\tint la=1;p[u][1]=1;r[u][1]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]-a[i-1]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\t\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tmx=1<<u;mx--; \n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tif(f[0][i]>n)f[0][i]=n;\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tif(f[0][i]!=n)f[0][i|j]=max(f[0][i|j],p[l][r[l][f[0][i]+1]]);\n\t\t\telse f[0][i|j]=n;\n\t\t}\n\t}\n\tfor(o=v>>1,u=1;o>0;o=o>>1,u++)\n\t{\n\t\tint la=n;p[u][n]=n;r[u][n]=n;\n\t\tfor(int i=n-1;i>=1;i--)\n\t\t{\n\t\t\tif(a[i+1]-a[i]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tfor(int i=0;i<=mx;i++)f[1][i]=n+1;\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tif(f[1][i]<1)f[1][i]=1;\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tif(f[1][i]!=1)f[1][i|j]=min(f[1][i|j],p[l][r[l][f[1][i]-1]]);\n\t\t\telse f[1][i|j]=1;\n\t\t}\n\t}\n\tr[0][0]=r[0][1];\n\tr[0][n+1]=r[0][n];\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tint j=~i&mx;\n\t\tif(r[0][f[0][i]+1]==r[0][f[1][j]-1])bo[r[0][f[0][i]+1]]=1;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(bo[r[0][i]])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nconst int NMAX = 300000;\nconst int LOGN = 30;\nint V[LOGN];\nint Lmost[NMAX][LOGN], Rmost[NMAX][LOGN];\n\nint dpL[1<<LOGN], dpR[1<<LOGN];\nint arr[NMAX+1];\nint dp[NMAX+2];\n\nint main(){\n    int N; scanf(\"%d%d\",&N,&V[0]);\n    for(int i=1;i<=N;i++) scanf(\"%d\",arr+i);\n\n    int M = 1;\n    while(V[M-1]){\n        V[M] = V[M-1]/2;\n        M++;\n    }\n\n    for(int i=0;i<M;i++){\n        int v = V[i];\n        int j = 1;\n        while(j<=N){\n            int k = j+1;\n            while(k<=N && arr[k]-arr[k-1] <= v) k++;\n            for(int x=j;x<k;x++) Rmost[x][i] = k-1;\n            j = k;\n        }\n        j = N;\n        while(j>=1){\n            int k = j-1;\n            while(k>=1 && arr[k+1]-arr[k] <= v) k--;\n            for(int x=j;x>k;x--) Lmost[x][i] = k+1;\n            j = k;\n        }\n    }\n\n    for(int i=0;i<(1<<M);i++) dpR[i] = N+1;\n    for(int i=1;i<(1<<M);i++){\n        for(int j=0;j<M;j++) if(i&(1<<j)){\n            // use V[j]\n            int L = dpL[i^(1<<j)];\n            dpL[i] = max(dpL[i], Rmost[L+1][j]);\n\n            int R = dpR[i^(1<<j)];\n            dpR[i] = min(dpR[i], Lmost[R-1][j]);\n        }\n    }\n\n    for(int i=0;i<=N+1;i++) dp[i] = -1;\n\n    for(int i=2;i<(1<<M);i+=2){\n        int j = ((1<<M)-1)^i^1;\n        dp[dpR[j]] = max(dp[dpR[j]], dpL[i]);\n    }\n\n    for(int i=1;i<=N+1;i++)\n        dp[i] = max(dp[i], dp[i-1]);\n\n    for(int i=1;i<=N;i++){\n        int L = Lmost[i][0], R = Rmost[i][0];\n        int det = dp[R+1];\n        if(det>=L-1) printf(\"Possible\\n\");\n        else printf(\"Impossible\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 600009\nusing namespace std;\n\nint n,m,cnt,a[N],b[109],p[20][N],q[20][N],f[N],g[N];\nstruct node{ int x,y; }c[N];\nbool cmp(node u,node v){ return u.y<v.y; }\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint i,j,k;\n\tfor (i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\tfor (; m; m>>=1) b[++cnt]=m; cnt++;\n\tfor (i=1; i<=(cnt>>1); i++) swap(b[i],b[cnt-i+1]);\n\tfor (i=1; i<=cnt; i++){\n\t\tp[i][n]=n; q[i][1]=1;\n\t\tfor (j=n-1; j; j--) p[i][j]=(a[j+1]-a[j]<=b[i]?p[i][j+1]:j);\n\t\tfor (j=2; j<=n; j++) q[i][j]=(a[j]-a[j-1]<=b[i]?q[i][j-1]:j);\n\t}\n\tm=1<<cnt-1;\n\tfor (i=0; i<m; i++) g[i]=n+1;\n\tfor (i=1; i<m; i++)\n\t\tfor (j=1; j<cnt; j++) if (i>>j-1&1){\n\t\t\tk=i^1<<j-1;\n\t\t\tf[i]=max(f[i],f[k]<n?p[j][f[k]+1]:n);\n\t\t\tg[i]=min(g[i],g[k]>1?q[j][g[k]-1]:1);\n\t\t}\n\tfor (i=0; i<m; i++)\n\t\tif (f[i]+1<g[m-1^i]) c[i+1]=(node){f[i]+1,g[m-1^i]-1};\n\t\telse{\n\t\t\tfor (i=1; i<=n; i++) puts(\"Possible\"); return 0;\n\t\t}\n\tsort(c+1,c+m+1,cmp);\n\tfor (i=j=1,k=0; i<=n; i++){\n\t\tfor (; j<=m && c[j].y<=p[cnt][i]; j++)\n\t\t\tk=max(k,c[j].x);\n\t\tputs(k<q[cnt][i]?\"Impossible\":\"Possible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n\n#define MAXN 200005\n#define MAXB 21\n\nusing namespace std;\n\nconst int INF = 1e9 + 2e6;\nint v[MAXN], n, m;\nint d[MAXN], up[MAXN][MAXB], down[MAXN][MAXB], pre[1 << MAXB], suf[1 << MAXB];\nint visit[MAXN];\n\nint read() {\n    char c = getchar();\n    int x = 0, s = 1;\n    while (!isdigit(c)) {\n        if (c == '-')\n            s = -1;\n        c = getchar();\n    }\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x * s;\n}\n\nvoid init() {\n    while (v[++m] >= 1)\n        v[m + 1] = v[m] >> 1;\n    d[0] = -INF;\n    d[n + 1] = INF;\n    for (int j = 1; j <= m; ++j) {\n        for (int i = 1; i <= n; ++i)\n            if (d[i] - d[i - 1] <= v[j])\n                up[i][j] = up[i - 1][j];\n            else\n                up[i][j] = i;\n        for (int i = n; i >= 1; --i)\n            if (d[i + 1] - d[i] <= v[j])\n                down[i][j] = down[i + 1][j];\n            else\n                down[i][j] = i;\n    }\n}\n\nvoid solve() {\n    memset(suf, 0x3f, sizeof(suf));\n    memset(pre, -0x3f, sizeof(pre));\n    suf[0] = n + 1;\n    pre[0] = 0;\n    int limit = (1 << m) - 1;\n    for (int s = 0; s <= limit; ++s) {\n        for (int i = 1; i <= m; ++i) {\n            if (s >> (i - 1) & 1)\n                continue;\n            int t = s | (1 << (i - 1));\n            if (pre[s] >= 0)\n                pre[t] = max(pre[t], down[pre[s] + 1][i]);\n            if (suf[s] <= n + 1)\n                suf[t] = min(suf[t], up[suf[s] - 1][i]);\n        }\n    }\n    for (int s = 1; s < limit; ++s) {\n        if (s & 1)\n            continue;\n        int t = limit ^ s ^ 1;\n        int a = up[suf[t] - 1][1], b = down[pre[s] + 1][1];\n        if (a <= b) {\n            ++visit[a];\n            --visit[b];\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n        visit[i] = visit[i - 1] + visit[i];\n    for (int i = 1; i <= n; ++i)\n        if (visit[i])\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n}\n\nint main() {\n    n = read();\n    v[1] = read();\n    for (int i = 1; i <= n; ++i)\n        d[i] = read();\n    init();\n    solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300005;\n\nint dpL[N], dpR[N];\nint R[20][N], L[20][N];\nint d[N];\nint S[20];\nint a[N];\nint sum[N];\nint n,v;\nint p;\nint id[N];\nint main(){\n    scanf(\"%d%d\",&n,&v);\n    for (int i = 1; i <= n; i++) scanf(\"%d\",&a[i]);\n    for (int i = 1; i < n; i++){\n        d[i] = a[i+1]-a[i];\n        if (d[i] > v) id[i]++;\n    }\n    for (int i = 1; i < n; i++){\n        id[i] += id[i-1];\n    }\n    /*for (int i = 1; i < n; i++){\n        printf(\"%d \",d[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 1; i < n; i++){\n        printf(\"%d \",id[i]);\n    }\n    printf(\"\\n\");*/\n    S[0] = v;\n    for (int i = 1; i <= 18; i++){\n        S[i] = S[i-1]/2;\n        if (S[i] == 0) { p= i+1; break;}\n    }\n    //printf(\"%d \",p);\n    reverse(S,S+p);\n    for (int i = 0; i < p; i++){\n        //printf(\"%d \",S[i]);\n    }\n    for (int i = 0; i < p; i++){\n        R[i][n] = n;\n        for (int j = n-1; j >= 1; j--){\n            R[i][j] = a[j+1]-a[j] <= S[i] ? R[i][j+1] : j;\n        }\n\n        L[i][1] = 1;\n        for (int j = 2; j <= n; j++ ){\n            L[i][j] = a[j]-a[j-1] <= S[i] ? L[i][j-1] : j;\n        }\n        /*printf(\"cur step %d = %d:\\n\",i,S[i]);\n        for (int j = 1; j <= n; j++){\n            printf(\"%d \",R[i][j]);\n        }\n        printf(\"\\n\");\n        for (int j = 1; j <= n; j++){\n            printf(\"%d \",L[i][j]);\n        }\n        printf(\"\\n\");*/\n    }\n    int LIM = (1<<(p-1))-1;\n    for (int i = 0; i <= LIM; i++){\n        dpR[i] = n+1;\n        for (int j = 0; j < p; j++){\n            if (i>>j&1){\n                dpL[i] = max(dpL[i],R[j][dpL[i^(1<<j)]+1]);\n                dpR[i] = min(dpR[i],L[j][dpR[i^(1<<j)]-1]);\n            }\n        }\n        //printf(\"dp of %d : %d %d\\n\",i,dpL[i],dpR[i]);\n    }\n\n    for (int i = 0; i <= LIM; i++){\n        int LL = dpL[i];\n        int RR = dpR[LIM^i];\n        if (RR <= LL+1){\n            for (int i = 1; i <= n; i++) printf(\"Possible\\n\");\n            return 0;\n        }\n        //printf(\"mask %d: left (%d) %d, right (%d) %d\\n\",i,i,LL,LIM^i,RR);\n        //printf(\"ids = %d %d\\n\",id[LL+1],id[RR-2]);\n        if (id[RR-2] == id[LL]) {\n            //printf(\"%d - %d can\\n\",LL+1,RR-1);\n            sum[LL+1]++;\n            sum[RR]--;\n        }\n    }\n    for (int i = 1; i <= n; i++){\n        sum[i] += sum[i-1];\n        //printf(\"%d \",sum[i]);\n        if (sum[i] > 0){\n            printf(\"Possible\\n\");\n        }\n        else{\n            printf(\"Impossible\\n\");\n        }\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define N 820000\nusing namespace std;\nint f[N][32],g[N][32];\nint tot,sum[N],n,v,a[N],b[N];\nint l[N],r[N];\nint check(int x,int y){\n\tx++;\n\tif(f[x][tot]<y-1)return 0;\n\ty=f[x][tot];\n\tx=g[y][tot];\n\tsum[x]++;\n\tsum[y+1]--;\n}\nint cal(){\n\tmemset(r,0x7f,sizeof(r));\n\tmemset(l,0,sizeof(l));\n\tr[0]=n;\n\tfor(int i=0;i<1<<tot;i++){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(i&(1<<(j-1)))continue;\n\t\t\tl[i|(1<<(j-1))]=max(l[i|(1<<(j-1))],f[l[i]+1][j]);\n\t\t\tr[i|(1<<(j-1))]=min(r[i|(1<<(j-1))],g[r[i]-1][j]);\t\n\t\t}\n\t}\n\tint o=(1<<(tot-1))-1;\n\tfor(int i=0;i<=o;i++){\n\t\tcheck(l[i],r[o^i]);\n\t}\n\tfor(int i=0;i<=n;i++)sum[i]+=sum[i-1];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\twhile(v)b[++tot]=v,v/=2;\n\tb[++tot]=v;\n\tsort(b+1,b+1+tot);\n\tfor(int i=1;i<=tot;i++)f[n][i]=n;\n\tfor(int i=n-1;i>=1;i--){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(a[i+1]-a[i]<=b[j])f[i][j]=f[i+1][j];\n\t\t\telse f[i][j]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot;i++)g[1][i]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(a[i]-a[i-1]<=b[j])g[i][j]=g[i-1][j];\n\t\t\telse g[i][j]=i;\n\t\t}\n\t}\n\tcal();\n\tfor(int i=1;i<=n;i++){\n\t\tif(sum[i]>0)printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define fir first\n#define sec second\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int maxN = 2e5 + 2;\n\ninline bool Chkmax(int& x, int y)\n{ return x < y ? x = y, true : false; }\n\ninline bool Chkmin(int& x, int y)\n{ return x > y ? x = y, true : false; }\n\nint n, v, cnt;\nint SUC[maxN], ans[maxN];\nint x[maxN], f[maxN << 1], g[maxN << 1];\nvector<pii> line[20];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n    cin >> n >> v;\n    for (int i = 1; i <= n; ++i)\n        cin >> x[i];\n    do\n    {\n        int l = 1, r = 1; // attenion that l = 0\n        for (int j = 2; j <= n; ++j)\n        {\n            if (x[j] - (v >> cnt) > x[r])\n            {\n                line[cnt].emplace_back(l, r);\n                l = j;\n            }\n            r = j;\n        }\n        line[cnt].emplace_back(l, r);\n    } while (v >> cnt++);\n    // cout << cnt << endl;\n    --cnt;\n//    for (int i = 0; i < cnt; ++i)\n//        for (auto j : line[i])\n//            cout << j.fir << ' ' << j.sec << endl;\n    fill(f, f + (1 << cnt), -1);\n    fill(g, g + (1 << cnt), n + 2);\n    f[0] = 0, g[0] = n + 1;\n    for (int i = 0; i < cnt; ++i)\n        f[1 << i] = line[i + 1].begin()->sec, g[1 << i] = line[i + 1].rbegin()->fir;\n    for (int i = 1; i < 1 << cnt; ++i) if (~f[i])\n        for (int j = 1; j <= cnt; ++j)\n            if (!(i >> (j - 1) & 1))\n            {\n                auto pos = lower_bound(line[j].begin(), line[j].end(), pii(f[i] + 2, 0)) - 1;\n                Chkmax(f[i | 1 << (j - 1)], pos->sec);\n            }\n    for (int i = 1; i < 1 << cnt; ++i) if (g[i] != n + 2)\n        for (int j = 1; j <= cnt; ++j)\n            if (!(i >> (j - 1) & 1))\n            {\n                auto pos = lower_bound(line[j].begin(), line[j].end(), pii(g[i], 0));\n                if (pos != line[j].begin())\n                    Chkmin(g[i | 1 << (j - 1)], (--pos)->fir);\n            }\n    fill(SUC, SUC + n + 1, n + 2);\n    // cout << f[1] << ' ' << g[1] << endl;\n    for (int i = 0, all = (1 << cnt) - 1; i <= all; ++i)\n        if (~f[i])\n            Chkmin(SUC[f[i]], g[all ^ i]);\n    for (int i = n; i; --i)\n        Chkmin(SUC[i - 1], SUC[i]);\n    //for (int i = 0; i <= n; ++i)\n    //    cout << SUC[i] << ' ';\n    //cout << endl;\n    for (auto i : line[0])\n    {\n        // cout << i.fir << ' ' << i.sec << endl;\n        int flag = SUC[i.fir - 1] <= i.sec + 1;\n        for (int j = i.fir; j <= i.sec; ++j)\n            cout << (flag ? \"Possible\" : \"Impossible\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][30],tmp[30][30];\n\nconst int H=19260817;\nstruct hash_map\n{\n\tuint x[H];\n\tbool y[H];\n\tinline int get(uint v)\n\t{\n\t\tuint g=v%H;\n\t\tfor(;x[g]&&x[g]!=v;++g==H?g=0:0);\n\t\treturn x[g]==v?y[g]:2;\n\t}\n\tinline bool&operator[](uint v)\n\t{\n\t\tuint g=v%H;\n\t\tfor(;x[g]&&x[g]!=v;++g==H?g=0:0);\n\t\tx[g]=v;return y[g];\n\t}\n}hs;\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\tuint hash=dep;\n\tfo0(i,cnt)hash=hash*2337+s[i];\n\t{int tmp=hs.get(hash);if(tmp!=2)return tmp;}\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>=dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tint time=clock();\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\tr[i]=t[i];\n\t\tif((clock()-time)*10>7*CLOCKS_PER_SEC)return hs[hash]=0;\n\t}\n\treturn hs[hash]=0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\nusing namespace std;\nint n,v,x[N];\nint dp1[(1<<19)+3],dp2[(1<<19)+3];\nint tor[20][N],tol[20][N],len[20],dep;\nvoid maxn(int &x,int y){y>x? x=y:0;}\nint mxr[N];//左侧覆盖i，右侧最多覆盖多少个城市\nint main(){\n    scanf(\"%d%d\",&n,&v);x[0]=-2e9,x[n+1]=2e9;\n    for(len[0]=v;len[dep]!=0;dep++) len[dep+1]=len[dep]/2;\n    dep++;\n    for(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n    for(int d=0;d<dep;d++){\n        tol[d][0]=n,tor[d][n+1]=n;\n        for(int i=1;i<=n;i++) tol[d][i]=(x[i]-x[i-1]<=len[d])? tol[d][i-1]:n+1-i;\n        for(int i=n;i>=1;i--) tor[d][i]=(x[i+1]-x[i]<=len[d])? tor[d][i+1]:i;\n    }\n    \n    for(int i=0;i<(1<<dep);i+=2)\n        for(int j=1;j<dep;j++)\n            if((i&(1<<j))==0)\n                maxn( dp1[i|(1<<j)], tor[j][dp1[i]+1] ),\n                maxn( dp2[i|(1<<j)], tol[j][n-dp2[i]] );\n    \n    memset(mxr,0xc0,sizeof(mxr));\n    for(int i=0,j=((1<<dep)-1)^1;j>=0;i+=2,j-=2)\n        maxn( mxr[dp1[i]], dp2[j] );\n    for(int i=n;i>=1;i--) maxn( mxr[i], mxr[i+1] );\n    for(int i=1;i<=n;i++)\n        if(mxr[n-tol[0][i]] + tor[0][i] >= n) puts(\"Possible\");\n        else puts(\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N, V;\nint M, SM;\n\nint T[21][MAX_N];\nint nex[21][MAX_N];\n\nint dp[(1 << 22)], rdp[(1 << 22)];\nint ok[MAX_N];\n\nvector<ll> v;\nll A[MAX_N];\n\nvoid pre(int dp[MAX_N]) {\n\trep(i, 0, M) {\n\t\trep(j, 0, N - 1) {\n\t\t\tT[0][j] = (abs(A[j + 1] - A[j]) > v[i]) ? j : (j + 1);\n\t\t}\n\t\tT[0][N - 1] = N - 1;\n\t\trep(q, 0, 20) {\n\t\t\trep(j, 0, N) {\n\t\t\t\tT[q + 1][j] = T[q][T[q][j]];\n\t\t\t}\n\t\t}\n\t\trep(j, 0, N) {\n\t\t\tnex[i][j] = T[20][j];\n\t\t}\n\t}\n\trep(bit, 0, (1 << SM)) {\n\t\tif(dp[bit] == N - 1) continue;\n\t\trep(i, 0, SM) {\n\t\t\tif(bit & (1 << i)) continue;\n\t\t\tMAX(dp[bit | (1 << i)], nex[i][dp[bit] + 1]);\n\t\t}\n\t}\n\trep(bit, 0, (1 << SM)) {\n\t\tif(dp[bit] == N - 1) continue;\n\t\tdp[bit] = nex[SM][dp[bit] + 1];\n\t}\n}\n\nvoid solve() {\n\tcin >> N >> V;\n\trep(i, 0, N) cin >> A[i];\n\twhile(V >= 1) {\n\t\tv.pb(V);\n\t\tV /= 2;\n\t}\n\tv.pb(0);\n\tM = sz(v);\n\tSM = M - 1;\n\n\treverse(all(v));\n\t\n\tpre(dp);\n\n\treverse(A, A + N);\n\tpre(rdp);\n\n\trep(bit, 0, (1 << SM)) rdp[bit] = N - 1 - rdp[bit];\n\n\trep(bit, 0, (1 << SM)) {\n\t\tint rbit = (1 << SM) - 1 - bit;\n\t\tint l = dp[bit], r = rdp[rbit];\n\t\tl++;\n\t\tif(l > r) {\n\t\t\tok[l]--;\n\t\t\tok[r]++;\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\tok[i + 1] += ok[i];\n\t\tif(ok[i]) cout << \"Possible\\n\";\n\t\telse cout << \"Impossible\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Camel and Oases\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint const N=1e5+10;\nint const S=1<<17;\nint n,V;\nint d[N];\nint logV,a[20][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n    }\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nvoid type(int s)\n{\n    for(int i=logV;i>=1;i--) printf(\"%d\",(s>>(i-1))%2);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%d\",&d[i]),d[i-1]=d[i]-d[i-1];\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    /*for(int i=1;i<=logV;i++)\n    {\n    \tprintf(\"%d-%d \",1,a[i][1]);\n        for(int j=2;j<=a[i][0];j++) printf(\"%d-%d \",a[i][j-1]+1,a[i][j]);\n        printf(\"\\n\");\n    }*/\n    if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++) puts(\"Impossible\");\n        return 0;\n    }\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=1,f2[s]=n;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    /*for(int s=0;s<=U;s+=2)\n        type(s),printf(\"   1-%2d  %2d-%2d\\n\",f1[s],f2[U-s-1],n);*/\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1 && f2[U-s-1]-1<=to) f=true;\n        if(f) for(int j=fr;j<=to;j++) puts(\"Possible\");\n        else for(int j=fr;j<=to;j++) puts(\"Impossible\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*⠄⢰⣧⣼⣯⠄⣸⣠⣶⣶⣦⣾⠄⠄⠄⠄⡀⠄⢀⣿⣿⠄⠄⠄⢸⡇⠄⠄\n⠄⠄⠄⣾⣿⠿⠿⠶⠿⢿⣿⣿⣿⣿⣦⣤⣄⢀⡅⢠⣾⣛⡉⠄⠄⠄⠸⢀⣿⠄\n⠄⠄⢀⡋⣡⣴⣶⣶⡀⠄⠄⠙⢿⣿⣿⣿⣿⣿⣴⣿⣿⣿⢃⣤⣄⣀⣥⣿⣿⠄\n⠄⠄⢸⣇⠻⣿⣿⣿⣧⣀⢀⣠⡌⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⣿⣿⣿⠄\n⠄⢀⢸⣿⣷⣤⣤⣤⣬⣙⣛⢿⣿⣿⣿⣿⣿⣿⡿⣿⣿⡍⠄⠄⢀⣤⣄⠉⠋⣰\n⠄⣼⣖⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⢇⣿⣿⡷⠶⠶⢿⣿⣿⠇⢀⣤\n⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣷⣶⣥⣴⣿⡗\n⢀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄\n⢸⣿⣦⣌⣛⣻⣿⣿⣧⠙⠛⠛⡭⠅⠒⠦⠭⣭⡻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄\n⠘⣿⣿⣿⣿⣿⣿⣿⣿⡆⠄⠄⠄⠄⠄⠄⠄⠄⠹⠈⢋⣽⣿⣿⣿⣿⣵⣾⠃⠄\n⠄⠘⣿⣿⣿⣿⣿⣿⣿⣿⠄⣴⣿⣶⣄⠄⣴⣶⠄⢀⣾⣿⣿⣿⣿⣿⣿⠃⠄⠄\n⠄⠄⠈⠻⣿⣿⣿⣿⣿⣿⡄⢻⣿⣿⣿⠄⣿⣿⡀⣾⣿⣿⣿⣿⣛⠛⠁⠄⠄⠄\n⠄⠄⠄⠄⠈⠛⢿⣿⣿⣿⠁⠞⢿⣿⣿⡄⢿⣿⡇⣸⣿⣿⠿⠛⠁⠄⠄⠄⠄⠄\n⠄⠄⠄⠄⠄⠄⠄⠉⠻⣿⣿⣾⣦⡙⠻⣷⣾⣿⠃⠿⠋⠁⠄⠄⠄⠄⠄⢀⣠⣴\n⣿⣿⣿⣶⣶⣮⣥⣒⠲⢮⣝⡿⣿⣿⡆⣿⡿⠃⠄⠄⠄⠄⠄⠄⠄⣠⣴⣿*/\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ii,ll>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \" is \" << x << endl;\n\n#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nll MAX(ll a){return a;}\nll MIN(ll a){return a;}\ntemplate<typename... Args>\nll MAX(ll a,Args... args){return max(a,MAX(args...));}\ntemplate<typename... Args>\nll MIN(ll a,Args... args){return min(a,MIN(args...));}\n\n#define indexed_set tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nint n,k;\nint arr[200005];\nvector<int> v;\n\nint l[20][200005];\nint r[20][200005];\n\nint pref[200005];\nint suf[200005];\n\nint cnt[200005];\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tcin>>n>>k;\n\trep(x,0,n) cin>>arr[x];\n\t\n\tint curr=k;\n\twhile (curr){\n\t\tcurr>>=1;\n\t\tv.push_back(curr);\t\t\n\t}\n\t\n\tv.push_back(k);\n\t\n\trep(layer,0,sz(v)){\n\t\tl[layer][0]=0;\n\t\trep(x,1,n) l[layer][x]=(arr[x]-arr[x-1]<=v[layer]?l[layer][x-1]:x);\n\t\t\n\t\tr[layer][n-1]=n-1;\n\t\trep(x,n-1,0) r[layer][x]=(arr[x+1]-arr[x]<=v[layer]?r[layer][x+1]:x);\n\t}\n\t\n\trep(x,0,(1<<(sz(v)-1))){\n\t\tpref[x]=-1,suf[x]=n;\n\t\trep(bit,0,20) if (x&(1<<bit)){\n\t\t\tif (pref[x^(1<<bit)]==n-1) pref[x]=n-1;\n\t\t\telse pref[x]=max(pref[x],r[bit][pref[x^(1<<bit)]+1]);\n\t\t\tif (suf[x^(1<<bit)]==0) suf[x]=0;\n\t\t\telse suf[x]=min(suf[x],l[bit][suf[x^(1<<bit)]-1]);\n\t\t}\n\t}\n\t\n\tint bm=(1<<(sz(v)-1))-1;\n\trep(x,0,(1<<(sz(v)-1))){\n\t\t//cout<<pref[x]<<\" \"<<suf[bm^x]<<endl;\n\t\t\n\t\tif (pref[x]+1>=suf[bm^x]) cnt[0]++;\n\t\telse{\n\t\t\tif (suf[bm^x]-1<=r[sz(v)-1][pref[x]+1]){\n\t\t\t\tcnt[l[sz(v)-1][pref[x]+1]]++;\n\t\t\t\tcnt[r[sz(v)-1][pref[x]+1]+1]--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(x,0,n){\n\t\tif (cnt[x]) cout<<\"Possible\"<<endl;\n\t\telse cout<<\"Impossible\"<<endl;\n\t\t\n\t\tcnt[x+1]+=cnt[x];\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, v, lg, a[200005];\n\nstruct oneside {\n\tint rb[18][200005], dt[1<<18];\n\tint solve () {\n\t\tint cv = v;\n\t\tfor(int i=0;i<=lg;i++,cv/=2) {\n\t\t\tint un = 1;\n\t\t\tfor(int j=1;j<n;j++) {\n\t\t\t\tif(a[j+1] - a[j] > cv) {\n\t\t\t\t\tfor(int k=un;k<=j;k++) rb[i][k] = j;\n\t\t\t\t\tun = j+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=un;k<=n;k++) rb[i][k] = n;\n\t\t}\n\t\tfor(int i=0;i<(1<<lg);i++) {\n\t\t\tfor(int j=1;j<=lg;j++) {\n\t\t\t\tint t = (1<<(j-1));\n\t\t\t\tif(i & t) continue;\n\t\t\t\tdt[i|t] = max(dt[i|t], rb[j][min(dt[i]+1, n)]);\n\t\t\t}\n\t\t}\n\t}\n} ls, rs;\n\nstruct segtree {\n\tint val[888888], lim;\n\tvoid init () {\n\t\tfor(lim = 1; lim <= n; lim <<= 1);\n\t}\n\tvoid update (int S, int E, int X) {\n\t\tS += lim; E += lim;\n\t\twhile(S<=E) {\n\t\t\tif(S%2 == 1) val[S] += X, S++;\n\t\t\tif(E%2 == 0) val[E] += X, E--;\n\t\t\tS>>=1; E>>=1;\n\t\t}\n\t}\n\tint query (int P) {\n\t\tP += lim;\n\t\tint ret = 0;\n\t\twhile(P) {\n\t\t\tret += val[P];\n\t\t\tP>>=1;\n\t\t}\n\t\treturn ret;\n\t}\n} seg;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++) {\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=v;i;i/=2,lg++);\n\tls.solve();\n\treverse(a+1, a+1+n);\n\tfor(int i=1;i<=n;i++) a[i] *= -1;\n\trs.solve();\n\tseg.init();\n\tfor(int i=0;i<(1<<lg);i++) {\n\t\tint t = ((1<<lg)-1)^i;\n\t\tif(ls.dt[i] + 1 > n - rs.dt[t]) {\n\t\t\tfor(int j=1;j<=n;j++) puts(\"Possible\");\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tint ss = n - rs.rb[0][min(n, rs.dt[t]+1)] + 1, se = ls.rb[0][min(n, ls.dt[i]+1)];\n\t\t\tif(ss <= se) seg.update(ss, se, 1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tputs(seg.query(i) ? \"Possible\" : \"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N =  2e+5+5;\n\nint n,V;\nint a[N];\nint lef[N][20],rig[N][20];\nint val[20],k;\nint f[N],g[N];\nstruct point{\n\tint x,y,id;\n\tpoint(const int x_=0,const int y_=0,const int id_=0){x=x_;y=y_;id=id_;}\n\tfriend bool operator < (point a,point b){\n\t\tif (a.x!=b.x)return a.x>b.x;\n\t\tif (a.y!=b.y)return a.y<b.y;\n\t\treturn a.id<b.id;\n\t}\n}p[N*2];\nint m;\nbool ans[N];\n\nint main(){\n\tn=get();V=get();\n\tfo(i,1,n)a[i]=get();\n\tval[0]=V;\n\tk=0;\n\tfor(;val[k];k++)val[k+1]=val[k]/2;\n\tfo(i,1,n)\n\t\tfo(j,0,k){\n\t\t\tlef[i][j]=i;\n\t\t\tif (i>1&&a[i]-a[i-1]<=val[j])lef[i][j]=lef[i-1][j];\n\t\t}\n\tfd(i,n,1)\n\t\tfo(j,0,k){\n\t\t\trig[i][j]=i;\n\t\t\tif (i<n&&a[i+1]-a[i]<=val[j])rig[i][j]=rig[i+1][j];\n\t\t}\n\tfo(i,0,(1<<k)-1)g[i]=1e+9;\n\tf[0]=0;g[0]=n+1;\n\tfo(i,1,k){\n\t\tf[1<<(i-1)]=rig[1][i];\n\t\tg[1<<(i-1)]=lef[n][i];\n\t}\n\tfo(i,1,(1<<k)-1){\n\t\tfo(x,1,k)\n\t\tif (((1<<(x-1))&i)==0){\n\t\t\tif (f[i]==n)f[i|(1<<(x-1))]=n;\n\t\t\telse f[i|(1<<(x-1))]=max(f[i|(1<<(x-1))],rig[f[i]+1][x]);\n\t\t\tif (g[i]==1)g[i|(1<<(x-1))]=1;\n\t\t\telse g[i|(1<<(x-1))]=min(g[i|(1<<(x-1))],lef[g[i]-1][x]);\n\t\t}\n\t}\n\tfo(i,1,n)p[++m]=point(lef[i][0],rig[i][0],i);\n\tfo(i,0,(1<<k)-1)p[++m]=point(f[i]+1,g[((1<<k)-1)^i]-1,0);\n\tsort(p+1,p+1+m);\n\tint lim=1e+9;\n\tfo(i,1,m)\n\tif (p[i].id==0)lim=min(lim,p[i].y);\n\telse ans[p[i].id]=(lim<=p[i].y);\n\tfo(i,1,n)\n\tif (ans[i])printf(\"Possible\\n\");else printf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 200001\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nint n,cnt,v[N],x[N],tl[N][18],tr[N][18];\nint fl[1<<19],fr[1<<19];\nint main()\n{\n\tre(n),re(v[0]);\n\twhile(v[cnt])\n\t{\n\t\t++cnt;\n\t\tv[cnt]=v[cnt-1]>>1;\n\t}\n\tfor(int i=1;i<=n;++i)re(x[i]);\n\tfor(int i=0;i<=cnt;++i)\n\t{\n\t\tint last=1;\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(j==n || x[j+1]-x[j]>v[i])\n\t\t\t{\n\t\t\t\tfor(int k=last;k<=j;++k)\n\t\t\t\t\ttl[k][i]=last,tr[k][i]=j;\n\t\t\t\tlast=j+1;\n\t\t\t}\n\t}\n\tfor(int i=0;i<(1<<cnt+1);++i)\n\t{\n\t\tfl[i]=0;\n\t\tfr[i]=n+1;\n\t\tfor(int j=0;j<=cnt;++j)\n\t\t\tif(i>>j&1)\n\t\t\t{\n\t\t\t\tfl[i]=max(fl[i],tr[min(fl[i^(1<<j)]+1,n)][j]);\n\t\t\t\tfr[i]=min(fr[i],tl[max(fr[i^(1<<j)]-1,1)][j]);\n\t\t\t}\n\t}\n\tint gg=0,l=1;\n\twhile(l<=n)\n\t{\n\t\tint r=tr[l][0];\n\t\tif(gg>cnt)\n\t\t{\n\t\t\tfor(int i=l;i<=r;++i)\n\t\t\t\tputs(\"Impossible\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbool ok=0;\n\t\t\tfor(int i=0;i<(1<<cnt+1);++i)\n\t\t\t{\n\t\t\t\tint gl=i,gr=((1<<cnt+1)-1)^i;\n\t\t\t\tif(gl&1)gl^=1;\n\t\t\t\tif(gr&1)gr^=1;\n\t\t\t\tif(fl[gl]>=l-1 && fr[gr]<=r+1)\n\t\t\t\t{\n\t\t\t\t\tok=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=l;i<=r;++i)\n\t\t\t\tputs(ok?\"Possible\":\"Impossible\");\n\t\t}\n\t\tl=r+1;\n\t\t++gg;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=262444,M=22,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ntemplate<class T> inline void read(T &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ntemplate<class T> inline void print(T x){\n\tif(!x){puts(\"0\");return;}\n\tif(x<0){putchar('-');x=-x;}\n\tint a[20],m=0;\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');puts(\"\");\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,a[N],v[20],cnt[20],L[20][N],R[20][N],bel[N],si[N],ans[N];\nmap<pair<int,pii>,bool> dp[20];\n\n\nvoid dfs(int x,int l,int r){\n//\tprintf(\"%d %d %d\\n\",x,l,r);\n\tif(x==m) return;\n\tfor(int i=l;i<=r;i++){\n\t\tint t=i;\n\t\twhile(t<r&&a[t+1]-a[t]<=v[x]) t++;\n\t\tL[x][++cnt[x]]=cnt[x+1]+1;\n\t\tdfs(x+1,i,t);\n\t\tR[x][cnt[x]]=cnt[x+1];\n\t\tif(!x){\n\t\t\tfor(int j=i;j<=t;j++)\n\t\t\t\tbel[j]=cnt[x];\n\t\t}i=t;\n\t}\n}\ninline bool get(int x,int l,int r,int st){\n//\tprintf(\"%d %d %d %d\\n\",x,l,r,st);\n\tif(l>r) return 1;\n\tif(si[st]<=r-l||x==m) return 0;\n\tif(!(st&(1<<x))) return get(x+1,L[x][l],R[x][r],st);\n\tif(dp[x].count(mp(st,mp(l,r)))) return dp[x][mp(st,mp(l,r))];\n\tbool ans=0;\n\tint u=st^(1<<x);\n\tfor(int i=l;i<=r;i++){\n\t\tint l1=L[x][l],r1=R[x][i-1],l2=L[x][i+1],r2=R[x][r];\n\t\tif(R[x][i-1]-L[x][l]+R[x][r]-L[x][i+1]+2>si[u]) continue;\n\t\tfor(int j=u;j;j=(j-1)&u)\n\t\t\tif(get(x+1,l1,r1,j)&&get(x+1,l2,r2,u^j)){ans=1;break;}\n\t\tif(get(x+1,l1,r1,0)&&get(x+1,l2,r2,u)) ans=1;\n\t\tif(ans) break;\n\t}\n\tdp[x][mp(st,mp(l,r))]=ans;\n\treturn ans;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tsrand(time(0));\n#endif\n\tios::sync_with_stdio(0);\n\tread(n);read(v[0]);\n\tfor(int i=1;i<=n;i++) read(a[i]);\n\tfor(int j=1;v[j-1];j++,m=j) v[j]=v[j-1]>>1;\n\tdfs(0,1,n);\n//\tdebuge;\n\tif(cnt[0]>m){\n\t\tfor(int i=1;i<=n;i++) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<m;i++)\n\t\tL[i][cnt[i]+1]=R[i][cnt[i]+1]=cnt[i+1]+1;\n\tfor(int i=1;i<(1<<m);i++) si[i]=si[i^(i&-i)]+1;\n//\tdebug(cnt[1]);\n//\tdebug(cnt[0]);\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tint u=(1<<m)-2;\n\t\tfor(int j=0;j<(1<<m);j+=2)\n\t\t\tif(get(1,L[0][1],R[0][i-1],j)&&get(1,L[0][i+1],R[0][cnt[0]],u^j)){ans[i]=1;break;}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(ans[bel[i]])puts(\"Possible\"); else puts(\"Impossible\");\n#ifdef rqgao2014\n\ttime_tester(1);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 262150\n#define inf 2147483647\nusing namespace std;\nstruct pos1{int l, r;}pos[N][19];\nint n, m, k, w[N], now, dp_l[N], dp_r[N], bin[19], x, ff, sum;\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tbin[0]=1; for(int i=1; i<=18; i++)bin[i]=bin[i-1]<<1;\n\tfor(int i=1; i<=n; i++)scanf(\"%d\", &w[i]); w[0]=w[1]-m-1; w[n+1]=w[n]+m+1;\n\tk=-1; x=m<<1;\n\twhile(x){\n\t\tk++; x>>=1; now=0;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(w[i]-w[i-1]>x)now=i;\n\t\t\tpos[i][k].l=now;\n\t\t}\n\t\tpos[n+1][k].r=n;\n\t\tnow=n+1;\n\t\tfor(int i=n; i; i--){\n\t\t\tif(w[i+1]-w[i]>x)now=i;\n\t\t\tpos[i][k].r=now;\n\t\t}\n\t\tpos[0][k].l=1;\n\t}\n\tdp_l[0]=0; dp_r[0]=n+1;\n\tfor(int i=1; i<=bin[k]-1; i++){\n\t\tdp_l[i]=0; dp_r[i]=n+1;\n\t\tfor(int j=1; j<=k; j++)if(i&bin[j-1]){\n\t\t\tdp_l[i]=max(dp_l[i], pos[dp_l[i-bin[j-1]]+1][j].r);\n\t\t\tdp_r[i]=min(dp_r[i], pos[dp_r[i-bin[j-1]]-1][j].l);\n\t\t}\n\t}\n\tsum=0; for(int i=1; i<=n; i++)if(pos[i][0].l==i)sum++;\n\tif(sum>=k+2){for(int i=1; i<=n; i++)printf(\"Impossible\\n\"); return 0;}\n\tfor(int i=1; i<=n; i++)if(pos[i][0].l==i){\n\t\tff=0;\n\t\tfor(int j=0; j<=bin[k]-1; j++)if(dp_l[j]>=pos[i][0].l-1&&dp_r[bin[k]-1-j]<=pos[i][0].r+1){ff=1; break;}\n\t\tfor(int j=pos[i][0].l; j<=pos[i][0].r; j++)if(ff)printf(\"Possible\\n\"); else printf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint x[202020];\nint l[202020][20], r[202020][20];\nint dpl[1 << 20], dpr[1 << 20];\n\nvoid solve() {\n        int n, v;\n        cin >> n >> v;\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        int p;\n        for (int i = 0; ; i ++) if ((1 << i) > v) {\n                p = i + 1;\n                break;\n        }\n        for (int i = 0; i < n; i ++) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == 0 || x[i] - x[i - 1] > vv) l[i][j] = i;\n                        else l[i][j] = l[i - 1][j];\n                        vv /= 2;\n                }    \n        }\n        for (int i = n - 1; i >= 0; i --) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == n - 1 || x[i + 1] - x[i] > vv) r[i][j] = i;\n                        else r[i][j] = r[i + 1][j];\n                        vv /= 2;\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpr[i] == n) dpr[i | (1 << j)] = n;\n                        else dpr[i | (1 << j)] = max(dpr[i | (1 << j)], r[dpr[i]][j] + 1);\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) dpl[i] = n - 1;\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpl[i] == -1) dpl[i | (1 << j)] = -1;\n                        else dpl[i | (1 << j)] = min(dpl[i | (1 << j)], l[dpl[i]][j] - 1);\n                }\n        }\n        bool ok = false;\n        for (int i = 0; i < n; i ++) {\n                if (l[i][0] == i) {\n                        int c = 0;\n                        for (int j = 0; j < (1 << p); j ++) {\n                                c ++;\n                                if (j & 1) continue; \n                                if (i > 0 && dpr[j] < i) continue;\n                                if (r[i][0] < n - 1 && dpl[((1 << p) - 1 - j) - 1] > r[i][0]) continue;\n                                break;\n                        }\n                        if (c < (1 << p)) ok = true;\n                        else ok = false;\n                }\n                if (ok) cout << \"Possible\" << endl;\n                else cout << \"Impossible\" << endl;\n        }\n        return;\n}\n\nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        solve();\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 801000\nusing namespace std;\n\nint mark[maxn];\nint lb[maxn][21], rb[maxn][21];\nint L[maxn], R[maxn], fa[maxn], p[maxn];\nint x[maxn];\nint v[21];\nint fl[maxn], fr[maxn];\nint tp;\nint n, m;\n\nint find(int a) {\n\treturn (fa[a] == a ? a : (fa[a] = find(fa[a])));\n}\n\nbool cmp(int a, int b) {\n\treturn (x[a + 1] - x[a] < x[b + 1] - x[b]);\n}\n\nint main() {\n\tscanf(\"%d %d\",&n,&m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\",&x[i]);\n\ttp = 0;\n\tfor (; m; m >>= 1) v[tp++] = m;\n\tv[tp++] = 0;\n\tfor (int i = 1; i <= n; i++) L[i] = R[i] = fa[i] = i;\n\tfor (int i = 1; i < n; i++) p[i] = i;\n\tint q = 1;\n\tsort(p + 1, p + n, cmp);\t\n\tfor (int t = tp - 1; t >= 0; t--) {\n\t\twhile (q < n && x[p[q] + 1] - x[p[q]] <= v[t]) {\n\t\t\tint a = p[q], b = p[q] + 1;\n\t\t\ta = find(a); b = find(b);\n\t\t\tR[fa[a]] = R[fa[b]];\n\t\t\tfa[fa[b]] = fa[a];\n\t\t\tq++;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tlb[i][t] = L[find(i)];\n\t\t\trb[i][t] = R[find(i)];\n\t\t}\n\t}\n\n\tfor (int u = 0; u < tp; u++) {\n\t\tlb[n + 1][u] = n;\n\t\trb[0][u] = 1;\n\t}\n\n\tfor (int st = 0; st < (1 << tp); st++) {\n\t\tfr[st] = n + 1;\n\t\tfor (int u = 0; u < tp; u++) {\n\t\t\tif (!(st >> u & 1)) continue;\n\t\t\tfl[st] = max(fl[st], rb[fl[st ^ (1 << u)] + 1][u]);\n\t\t\tfr[st] = min(fr[st], lb[fr[st ^ (1 << u)] - 1][u]);\n\t\t}\n\t}\n\n\tfor (int st = 0; st < (1 << tp); st++) {\n\t\tif (st & 1) continue;\n\t\tint l = fl[st];\n\t\tint r = fr[((1 << tp) - 1) ^ 1 ^ st];\n\t\tif (l >= r - 1) { mark[1]++; continue; }\n\t\tif (rb[l + 1][0] >= r - 1) {\n\t\t\tmark[lb[l + 1][0]]++;\n\t\t\tmark[rb[l + 1][0] + 1]--;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tmark[i] += mark[i - 1];\n\t\tif (mark[i] > 0) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nHanit Banga\n*/\n\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 2e5 + 10, M = log2(N) + 10;\nconst ll inf = 1e15;\n\nll x[N];\nint v[N] = {0}, dp_lt[2 * N] = {0}, dp_rt[2 * N] = {0}, lt[N][M] = {0}, rt[N][M] = {0};\n\nint main()\n{\n\tint n, val;\n\tcin >> n >> val;\n\tx[0] = -inf;\n\tx[n + 1] = inf;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcin >> x[i];\n\n\tint temp = val, m = 0;\n\tfor (int j = 0; temp > 0; ++j, temp /= 2, ++m)\n\t\tv[j] = temp;\n\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t{\n\t\t\tlt[i][j] = 1;\n\t\t\tif (x[i] - x[i - 1] <= v[j])\n\t\t\t\tlt[i][j] += lt[i - 1][j];\n\t\t}\n\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t{\n\t\t\trt[n - i + 1][j] = 1;\n\t\t\tif (x[n - i + 2] - x[n - i + 1] <= v[j])\n\t\t\t\trt[n - i + 1][j] += rt[n - i + 2][j];\n\t\t}\n\t}\n\n\tint subsets = (1 << m);\n\tfor (int i = 1; i < subsets; ++i)\n\t{\n\t\tfor (int j = 0; j < m; ++j)\n\t\t{\n\t\t\tif (i & (1 << j))\n\t\t\t{\n\t\t\t\ttemp = dp_lt[i - (1 << j)];\n\t\t\t\tdp_lt[i] = max(dp_lt[i], temp + rt[temp + 1][j + 1]);\n\t\t\t\t\n\t\t\t\ttemp = dp_rt[i - (1 << j)];\n\t\t\t\tdp_rt[i] = max(dp_rt[i], temp + lt[n - temp][j + 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tint l = lt[i][0], r = rt[i][0];\n\t\tl = i + 1 - l;\n\t\tr = r + i - 1;\n\n\t\tif (dp_lt[subsets - 1] >= l - 1 and dp_rt[subsets - 1] >= n - r)\n\t\t\tcout << \"Possible\\n\";\n\t\telse\n\t\t\tcout << \"Impossible\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 2e5 + 4;\nstatic const int LOGN = 20;\ntemplate <typename T> inline void upd_max(T &var, const T val) { if (var < val) var = val; }\ntemplate <typename T> inline void upd_min(T &var, const T val) { if (var > val) var = val; }\n\nint n, v_max, x[MAXN];\nint k, v[LOGN];\nint f_lf[1 << LOGN], f_rg[1 << LOGN];\nint rg_with_lf[MAXN];\n\nvoid calc_dp(int *f)\n{\n    static int next[LOGN][MAXN];\n    for (int i = 0; i < k; ++i) {\n        for (int p = 0, q; p < n; ) {\n            for (q = p + 1; q < n && x[q] - x[q - 1] <= v[i]; ++q) ;\n            for (; p < q; ++p) next[i][p] = q;\n        }\n    }\n\n    for (int i = 0; i < (1 << k); ++i) f[i] = 0;\n    std::vector<int> pc[LOGN];\n    for (int i = 0; i < (1 << k); ++i) pc[__builtin_popcount(i)].push_back(i);\n    for (int i = 0; i < k; ++i) for (int mask : pc[i]) {\n        for (int j = 0; j < k; ++j) if (!(mask & (1 << j))) {\n            upd_max(f[mask | (1 << j)], next[j][f[mask]]);\n        }\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &v_max);\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &x[i]);\n    for (k = 0; v_max > 0; ++k, v_max /= 2) v[k] = v_max;\n    v[k++] = 0;\n\n    calc_dp(f_lf);\n    std::reverse(x, x + n);\n    for (int i = 0; i < n; ++i) x[i] = -x[i];\n    calc_dp(f_rg);\n    std::reverse(x, x + n);\n    for (int i = 0; i < n; ++i) x[i] = -x[i];\n    for (int i = 0; i < (1 << k); ++i) f_rg[i] = n - f_rg[i];\n\n    for (int i = 0; i <= n; ++i) rg_with_lf[i] = MAXN;\n    for (int i = 0; i < (1 << (k - 1)); ++i) upd_min(rg_with_lf[f_lf[i << 1]], f_rg[(((1 << (k - 1)) - 1) ^ i) << 1]);\n    for (int i = n - 1; i >= 0; --i) upd_min(rg_with_lf[i], rg_with_lf[i + 1]);\n\n    for (int i = 0, j; i < n; ) {\n        for (j = i + 1; j < n && x[j] - x[j - 1] <= v[0]; ++j) ;\n        bool possible = (rg_with_lf[i] <= j);\n        for (; i < j; ++i) puts(possible ? \"Possible\" : \"Impossible\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(),v.end()\n\nconst int maxn = 2e5 + 100, maxlg = 17;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, v, vols[maxlg], volCount, nxt[maxlg][maxn], dp[(1 << maxlg)];\nll x[maxn], a[maxn];\nbool ans[maxn];\nset<int> counter;\n\nvoid printAnsAndExit() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << (ans[i] ? \"Possible\" : \"Impossible\") << endl;\n\t}\n\texit(0);\n}\n\nvoid solve(int l, int r) {\n\tmemset(dp, 0, sizeof(dp));\n\tfor (int mask = 0; mask < (1 << (volCount - 1)); mask++) {\n\t\tfor (int bit = 0; bit < volCount - 1; bit++) {\n\t\t\tif (!((mask >> bit) & 1)) {\n\t\t\t\tint val = nxt[bit][dp[mask]] + 1;\n\t\t\t\tif (l <= val && val <= r) {\n\t\t\t\t\tval = r + 1;\n\t\t\t\t}\n\t\t\t\tdp[mask | (1 << bit)] = max(dp[mask | (1 << bit)], val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mx = *max_element(dp, dp + (1 << maxlg));\n\tif (mx == n) {\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tans[i] = true;\n\t\t}\n\t}\n}\n\nvoid solveAll() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcounter.insert(nxt[volCount - 1][i]);\n\t}\n\tif (counter.size() > volCount) {\n\t\tprintAnsAndExit();\n\t}\n\t\n\tint l = 0, r = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (nxt[volCount - 1][r] == nxt[volCount - 1][i]) {\n\t\t\tr++;\n\t\t}\n\t\telse {\n\t\t\tsolve(l, r);\n\t\t\tr++;\n\t\t\tl = r;\n\t\t}\n\t}\n\tsolve(l, r);\n}\n\n\nvoid calcVols(int v) {\n\tint count = 0, tmp = v;\n\twhile (tmp) {\n\t\ttmp /= 2;\n\t\tcount++;\n\t}\n\tvolCount = ++count;\n\twhile (count) {\n\t\tvols[--count] = v;\n\t\tv /= 2;\n\t}\n}\n\nvoid calcNxt() {\n\tfor (int vol = 0; vol < volCount; vol++) {\n\t\tint l = 0, r = 0;\n\t\twhile (r < n - 1) {\n\t\t\tif (x[r + 1] - x[r] <= vols[vol]) {\n\t\t\t\tr++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (l <= r) {\n\t\t\t\t\tnxt[vol][l] = r;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\twhile (l <= r) {\n\t\t\tnxt[vol][l] = r;\n\t\t\tl++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t\ta[i] = x[i];\n\t}\n\n\tcalcVols(v);\n\tcalcNxt();\n\tsolveAll();\n\tprintAnsAndExit();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 200005;\nint d[maxn], f[524290], g[524290];\nint h[20][maxn][2], n, m, i, j, k, LG, b[30], cnt;\ninline int solve(int m)\n{\n\tif (m == 0)\n\t{\n\t\tb[0] = 1;\n\t\treturn 1;\n\t}\n\tint nex = solve(m >> 1);\n\tb[nex] = m;\n\treturn nex + 1;\n}\ninline int lower(int x, int t)\n{\n\tint l = 1, r = n;\n\twhile (l < r - 1)\n\t{\n\t\tint mid = l + r >> 1;\n\t\tif (h[t][mid][1] <= x) l = mid;\n\t\telse r = mid;\n\t}\n\tif (h[t][l][1] > x) return h[t][l][1];\n\telse return h[t][r][1];\n}\ninline int upper(int x, int t)\n{\n\tint l = 1, r = n;\n\twhile (l < r - 1)\n\t{\n\t\tint mid = l + r >> 1;\n\t\tif (h[t][mid][0] < x) l = mid;\n\t\telse r = mid;\n\t}\n\tif (h[t][r][0] < x) return h[t][r][0];\n\telse return h[t][l][0];\n}\nint main()\n{\n\tcin >> n >> m;\n\tLG = solve(m);\n\tfor(i = 1; i <= n; i ++)\n\t\tscanf(\"%d\", &d[i]);\n\tfor(j = 0; j < LG; j ++)\n\t{\n\t\tint lim = b[j];\n\t\tfor(i = 1; i <= n;)\n\t\t{\n\t\t\tk = i;\n\t\t\twhile (d[k + 1] - d[k] <= lim && k + 1 <= n) k ++;\n\t\t\tfor(int l = i; l <= k; l ++)\n\t\t\t\th[j][l][0] = i, h[j][l][1] = k;\n\t\t\ti = k + 1;\n\t\t\tif (j == LG - 1) cnt ++;\n\t\t}\n\t}\n\tif (cnt >= 19)\n\t{\n\t\tfor(i = 1; i <= n; i ++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tint all = 1 << LG - 1;\n\tfor(int s = 0; s < all; s ++)\n\t\tg[s] = n + 1;\n\tfor(int s = 0; s < all; s ++)\n\t\tfor(i = 0; i < LG - 1; i ++)\n\t\t\tif (!(s >> i & 1))\n\t\t\t{\n\t\t\t\tint opt = s | (1 << i);\n\t\t\t\tf[opt] = max(f[opt], lower(f[s], i));\n\t\t\t\tg[opt] = min(g[opt], upper(g[s], i));\n\t\t\t}\n\tfor(i = 1; i <= n;)\n\t{\n\t\tbool ok = 0;\n\t\tfor(j = all - 1; ; j = (j - 1) & (all - 1))\n\t\t{\n\t\t\tif (f[j] >= i - 1 && g[(all - 1) ^ j] <= h[LG - 1][i][1] + 1) {ok = 1; break;}\n\t\t\tif (j == 0) break;\n\t\t}\n\t\tfor(j = i; j <= h[LG - 1][i][1]; j ++)\n\t\t\tif (ok) puts(\"Possible\");\n\t\t\telse puts(\"Impossible\");\n\t\ti = h[LG - 1][i][1] + 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nvoid Get_Val(int &Ret)\n{\n\tRet = 0;\n\tbool Neg(false);\n\tchar ch;\n\twhile (ch = getchar(), (ch > '9' || ch < '0') && ch != '-')\n\t\t;\n\tif (ch == '-')\n\t{\n\t\tNeg = true;\n\t\twhile (ch = getchar(), ch > '9' || ch < '0')\n\t\t\t;\n\t}\n\tdo\n\t{\n\t\t(Ret *= 10) += ch - '0';\n\t}\n\twhile (ch = getchar(), ch >= '0' && ch <= '9');\n\tRet = (Neg ? -Ret : Ret);\n}\n\nconst int Max_N(200050);\nconst int Max_H(20);\n\nint N, V, H, X[Max_N], D[Max_N];\nint L[Max_H][Max_N], R[Max_H][Max_N];\n\nvoid init()\n{\n\tGet_Val(N), Get_Val(V);\n\tfor (int i = 1;i <= N;++i)\n\t\tGet_Val(X[i]);\n\tfor (int i = 2;i <= N;++i)\n\t\tD[i] = X[i] - X[i - 1];\n\tint TV = V;\n\twhile (TV)\n\t\t++H, TV >>= 1;\n}\n\nvoid prepare()\n{\n\tfor (int i = 1;i <= N;++i)\n\t\tL[0][i] = i;\n\tfor (int i = 2, last = 1;i <= N;++i)\n\t{\n\t\tif (D[i] > V)\n\t\t\tlast = i;\n\t\tL[0][i] = last;\n\t}\n\tfor (int i = 1;i <= N;++i)\n\t\tR[0][i] = i;\n\tfor (int i = N - 1, last = N;i >= 1;--i)\n\t{\n\t\tif (D[i + 1] > V)\n\t\t\tlast = i;\n\t\tR[0][i] = last;\n\t}\n\tfor (int j = 1, TV;j <= H;++j)\n\t{\n\t\tTV = (V >> j);\n\t\tfor (int i = 1;i <= N;++i)\n\t\t\tL[j][i] = R[j][i] = i;\n\t\tfor (int i = 2, last = 1;i <= N;++i)\n\t\t{\n\t\t\tif (D[i] > TV)\n\t\t\t\tL[j][last] = i - 1, last = i;\n\t\t\tif (i == N)\n\t\t\t\tL[j][last] = N;\n\t\t}\n\t\tfor (int i = 2;i <= N;++i)\n\t\t\tL[j][i] = max(L[j][i], L[j][i - 1]);\n\t\tL[j][N + 1] = L[j][N];\n\t\tfor (int i = N - 1, last = N;i >= 1;--i)\n\t\t{\n\t\t\tif (D[i + 1] > TV)\n\t\t\t\tR[j][last] = i + 1, last = i;\n\t\t\tif (i == 1)\n\t\t\t\tR[j][last] = 1;\n\t\t}\n\t\tfor (int i = N - 1;i >= 1;--i)\n\t\t\tR[j][i] = min(R[j][i], R[j][i + 1]);\n\t\tR[j][0] = R[j][1];\n\t}\n}\n\nint F[1 << Max_H], G[1 << Max_H], P[Max_N];\nvoid dp()\n{\n\tfor (int S = 0;S < (1 << (H + 1));++S)\n\t\tF[S] = 0, G[S] = N + 1;\n\tfor (int S = 1;S < (1 << (H + 1));++S)\n\t\tfor (int j = 0;j <= H;++j)\n\t\t\tif (S & (1 << j))\n\t\t\t{\n\t\t\t\tF[S] = max(F[S], L[j][F[S - (1 << j)] + 1]);\n\t\t\t\tG[S] = min(G[S], R[j][G[S - (1 << j)] - 1]);\n\t\t\t}\n\tint AllS = (1 << (H + 1)) - 1 - 1;\n\tmemset(P, -1, sizeof(P));\n\tfor (int S1 = 0, S2;S1 <= AllS;++S1)\n\t\tif ((AllS & S1) == S1)\n\t\t{\n\t\t\tS2 = AllS - S1;\n\t\t\tP[G[S2]] = max(P[G[S2]], F[S1]);\n\t\t}\n\tfor (int i = 1;i <= N + 1;++i)\n\t\tP[i] = max(P[i], P[i - 1]);\n}\n\nvoid work()\n{\n\tfor (int i = 1, l, r;i <= N;++i)\n\t{\n\t\tl = L[0][i], r = R[0][i];\n\t\tif (P[r + 1] >= l - 1)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t}\n}\n\nint main()\n{\n\tinit();\n\tprepare();\n\tdp();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FR first\n#define SE second\nusing namespace std;\n\ntypedef pair<int,int> pii;\nconst int N=200010;\nint n,V,X[N],dep;\nint L[20][N],R[20][N];\nint exL[N],exR[N];\npii seg[N];\nbool ans[N];\n\nint findr(int d,int p)\n{\n    auto x=upper_bound(L[d]+1,L[d]+1+n,p);\n    return upper_bound(L[d]+1,L[d]+1+n,*x)-L[d]-1;\n}\nint findl(int d,int p)\n{\n    auto x=(lower_bound(R[d]+1,R[d]+1+n,p)-1);\n    if(x==R[d]+1+n) x=R[d]+n;\n    return lower_bound(R[d]+1,R[d]+1+n,*x)-R[d];\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    for(int i=1;i<=n;i++) scanf(\"%d\",X+i);\n    for(int v=V;v>=0;v>>=1,dep++)\n    {\n        L[dep][1]=1;R[dep][n]=n;\n        for(int i=2;i<=n;i++) L[dep][i]=(X[i]-X[i-1]<=v)?L[dep][i-1]:i;\n        for(int i=n-1;i>=1;i--) R[dep][i]=(X[i+1]-X[i]<=v)?R[dep][i+1]:i;\n        if(v==0){dep++;break;}\n    }\n    for(int i=1;i<=n;i++) seg[i]=pii(L[0][i],R[0][i]);\n    int cnt=unique(seg+1,seg+1+n)-(seg+1);\n    memset(exL,0,sizeof(exL));\n    memset(exR,0x3f,sizeof(exR));\n    exL[0]=0;exR[0]=n+1;\n    for(int s=0;s<(1<<dep);s++)\n        for(int i=0;i<dep;i++)\n        {\n            if(!(s&(1<<i))) continue;\n            exL[s]=max(exL[s],findr(i,exL[s^(1<<i)]));\n            exR[s]=min(exR[s],findl(i,exR[s^(1<<i)]));\n        }\n    if(cnt>dep) goto output;\n    for(int i=1;i<=cnt;i++)\n    {\n        for(int s=0;s<(1<<dep);s+=2)\n            if(exL[s]>=seg[i].FR-1&&exR[s]<=seg[i].SE+1)\n            {\n                for(int j=seg[i].FR;j<=seg[i].SE;j++) ans[j]=1;\n                goto finished;\n            }\n        finished: ;\n    }\n    output: for(int i=1;i<=n;i++) puts(ans[i]?\"Possible\":\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, V, K;\nint X[200010], L[18][200010], R[18][200010];\nvector<int> P;\n\nint cc1[1 << 18];\nint dp1(int mask) {\n    if(mask == 0) return -1;\n    int &ret = cc1[mask];\n    if(ret != -1) return ret;\n    if(mask == 0) return ret = 0;\n\n    ret = -1;\n    for(int i = 0; i < K; i++) {\n        if(mask & (1 << i)) {\n            ret = max(ret, R[i][ dp1(mask - (1 << i)) + 1 ]);\n        }\n    }\n    return ret;\n}\nint cc2[1 << 18];\nint dp2(int mask) {\n    if(mask == (1 << K) - 1) return N;\n    int &ret = cc2[mask];\n    if(ret != -1) return ret;\n\n    ret = N;\n    for(int i = 0; i < K; i++) {\n        if(mask & (1 << i)) {\n            ret = min(ret, L[i][ dp2(mask - (1 << i)) - 1 ]);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &V);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    P.push_back(V);\n    while(P.back()) {\n        int t = P.back() / 2;\n        P.push_back(t);\n    }\n    reverse(P.begin(), P.end());\n\n    K = P.size();\n\n    for(int i = 0; i < K; i++) {\n        int pos = 0;\n        for(int j = 0; j < N; j++) {\n            if(pos < j) pos = j;\n            while(pos < N - 1 && X[pos + 1] - X[pos] <= P[i]) pos++;\n            R[i][j] = pos;\n        }\n        pos = N - 1;\n        for(int j = N - 1; j >= 0; j--) {\n            if(pos > j) pos = j;\n            while(pos >= 1 && X[pos] - X[pos - 1] <= P[i]) pos--;\n            L[i][j] = pos;\n        }\n    }\n\n    memset(cc1, -1, sizeof(cc1));\n    memset(cc2, -1, sizeof(cc2));\n\n    if(dp1((1 << K) - 1) != N - 1) {\n        for(int i = 0; i < N; i++) {\n            printf(\"Impossible\\n\");\n        }\n        return 0;\n    }\n\n    int pos = 0;\n    while(pos < N) {\n        int nxt = R[K - 1][pos];\n\n        bool ok = false;\n        for(int i = 0; i < (1 << (K - 1)); i++) {\n            if(pos - 1 <= dp1(i) && dp2((1 << (K - 1)) - i) <= nxt + 1) {\n                ok = true;\n                break;\n            }\n        }\n        if(ok) {\n            for(int i = pos; i <= nxt; i++) {\n                printf(\"Possible\\n\");\n            }\n        }\n        else {\n            for(int i = pos; i <= nxt; i++) {\n                printf(\"Impossible\\n\");\n            }\n        }\n        pos = nxt + 1;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int L = 20, N = 201010;\n\nint n, V, x[N], fa[L][N], siz[L][N], ans[N], lt[1 << L], rt[1 << L];\nvector<int> v[N];\n\nint Find(int k, int x) {\n  return fa[k][x] == x ? x : fa[k][x] = Find(k, fa[k][x]);\n}\n\nvoid Merge(int k, int x, int y) {\n  x = Find(k, x), y = Find(k, y);\n  fa[k][y] = x;\n  siz[k][x] += siz[k][y];\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &V);\n  for(int i = 1; i <= n; i++)\n    scanf(\"%d\", &x[i]);\n  int now = V, m;\n  for(int o = L - 1; ; now >>= 1, o = (o + 1) % L) {\n    for(int i = 1; i <= n; i++)\n      fa[o][i] = i, siz[o][i] = 1;\n    for(int i = 1; i <= n; i++) {\n      int j = i;\n      while(j < n && x[j + 1] - x[j] <= now) j++;\n      for(int k = i + 1; k <= j; k++)\n\tMerge(o, i, k);\n      i = j;\n    }\n    if(now == 0) { m = o + 1; break; }\n  }\n\n  for(int i = 0; i < (1 << m); i++)\n    rt[i] = n + 1;\n  for(int i = 0; i < (1 << m); i++) {\n    for(int j = 0; j < m; j++)\n      if(~i >> j & 1) {\n\tlt[i | (1 << j)] = max(lt[i | (1 << j)], lt[i] + siz[j][lt[i] + 1]);\n\trt[i | (1 << j)] = min(rt[i | (1 << j)], Find(j, rt[i] - 1));\n\tif(Find(j, rt[i] - 1) != rt[i] - siz[j][Find(j, rt[i] - 1)]) {\n\t  assert(0);\n\t  \n\t}\n      }\n  }\n  // cerr << lt[27]  <<\" \" << rt[4] << endl;\n\n  int all = (1 << m) - 1; \n  for(int i = 0; i < (1 << m); i++) {\n    v[lt[i]].push_back(rt[all ^ i]);\n    //    cerr << lt[i] << \" \" << rt[all ^ i] << endl;\n  }\n\n  int mi = n + 2;\n  for(int i = 0; i < v[n].size(); i++)\n    mi = min(v[n][i], mi);\n  \n  for(int i = n; i >= 1; i--) {\n    for(int j = 0; j < v[i - 1].size(); j++)\n      mi = min(v[i - 1][j], mi);\n    if(fa[L - 1][i] != i) continue;\n    //cerr << i + siz[L - 1][i] << endl;\n    ans[i] = mi <= i + siz[L - 1][i];\n  }\n  \n  for(int i = 1; i <= n; i++)\n    puts(ans[Find(L - 1, i)] ? \"Possible\" : \"Impossible\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define N 300010\nusing namespace std;\nint num[N],val[64];\nint l[32][N],r[32][N];\nint f[1<<22],g[1<<22];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&num[i]);\n\tint tot=0,res=m;\n\twhile(res)\n\t{\n\t\tval[tot++]=res>>1;\n\t\tres>>=1;\n\t}\n\tval[tot]=m;\n\tfor(int i=0;i<=tot;i++)\n\t{\n\t\tl[i][1]=1;\n\t\tfor(int j=2;j<=n;j++)\n\t\t{\n\t\t\tif(num[j]-num[j-1]<=val[i]) l[i][j]=l[i][j-1];\n\t\t\telse l[i][j]=j;\n\t\t}\n\t}\n\tint sum=0;\n\tfor(int i=0;i<=tot;i++)\n\t{\n\t\tr[i][n]=n;\n\t\tfor(int j=n-1;j>=1;j--)\n\t\t{\n\t\t\tif(num[j+1]-num[j]<=val[i]) r[i][j]=r[i][j+1];\n\t\t\telse\n\t\t\t{\n\t\t\t\tr[i][j]=j;\n\t\t\t\tif(i==tot) sum++;\n\t\t\t}\n\t\t}\n\t}\n\tif(sum>tot){for(int i=1;i<=n;i++)puts(\"Impossible\");return 0;}\n\tint p=1<<tot;\n    for(int s=0;s<p;s++) g[s]=n+1;\n\tfor(int s=0;s<p;s++)\n        for(int i=0;i<=tot;i++)\n            if(!((s>>i)&1))\n            {\n                f[s|(1<<i)]=max(f[s|(1<<i)],r[i][f[s]+1]);\n                g[s|(1<<i)]=min(g[s|(1<<i)],l[i][g[s]-1]);\n\t\t\t}\n\tfor(int i=1;i<=n;i=r[tot][i]+1)\n    {\n        bool ok=false;\n        for(int s=0;s<p && !ok;s++) if(f[s]>=i-1 && g[(p-1)-s]<=r[tot][i]+1) ok=true;\n        for (int j=i;j<=r[tot][i];j++)\n        {\n            if(ok) puts(\"Possible\");\n            else puts(\"Impossible\");\n        }\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFindRange\n{\n  vector< int > data;\n  vector< int > left, right;\n\n  UnionFindRange(int sz)\n  {\n    data.assign(sz, -1);\n    left.resize(sz);\n    right.resize(sz);\n    for(int i = 0; i < sz; i++) left[i] = i;\n    for(int i = 0; i < sz; i++) right[i] = i;\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    left[x] = min(left[x], left[y]);\n    right[x] = max(right[x], right[y]);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  pair< int, int > range(int k)\n  {\n    k = find(k);\n    return {left[k], right[k]};\n  };\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nint N, V, X[200000];\nvector< int > vs;\nint left_cover_jump[19][200000], right_cover_jump[19][200000];\nint left_cover[1 << 18], right_cover[1 << 18];\n\nint main()\n{\n  scanf(\"%d %d\", &N, &V);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", &X[i]);\n  }\n  while(V > 0) {\n    vs.push_back(V);\n    V /= 2;\n  }\n  vs.push_back(0);\n\n\n  UnionFindRange uf(N);\n  for(int i = (int) vs.size() - 1; i >= 0; i--) {\n    for(int j = 1; j < N; j++) {\n      if(X[j] - X[j - 1] <= vs[i]) uf.unite(j - 1, j);\n    }\n    for(int j = 0; j < N; j++) {\n      auto p = uf.range(j);\n      left_cover_jump[i][j] = p.second;\n      right_cover_jump[i][j] = p.first;\n    }\n  }\n\n  auto chmax = [&](int &a, int b) { a = max(a, b); };\n  auto chmin = [&](int &a, int b) { a = min(a, b); };\n  fill_n(left_cover, 1 << 18, -1);\n  fill_n(right_cover, 1 << 18, N);\n  int restsz = (int) vs.size() - 1;\n  for(int i = 0; i < (1 << restsz); i++) {\n    for(int j = 0; j < restsz; j++) {\n      if((i >> j) & 1) continue;\n      chmax(left_cover[i | (1 << j)], left_cover_jump[j + 1][min(left_cover[i] + 1, N - 1)]);\n      chmin(right_cover[i | (1 << j)], right_cover_jump[j + 1][max(0, right_cover[i] - 1)]);\n    }\n  }\n  int mask = (1 << restsz) - 1;\n\n  int isok[200002] = {};\n  for(int i = 0; i < (1 << restsz); i++) {\n    auto L = left_cover_jump[0][min(left_cover[i] + 1, N - 1)];\n    auto R = right_cover_jump[0][max(right_cover[i ^ mask] - 1, 0)];\n    if(R <= L) isok[R]++, isok[L + 1]--;\n  }\n  int sum = 0;\n  for(int i = 0; i < N; i++) {\n    sum += isok[i];\n    if(sum > 0) cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define MAX(x,y) x=max(x,y)\n#define MIN(x,y) x=min(x,y)\n#define inf 0x3f3f3f3f\nusing namespace std;\n\nconst int N=200005;\n\nint n,v,g[N*2],f[N*2],bin[25],tot,len[25],lef[25][N],rig[25][N],a[N],bel[N],p1[N],p2[N];\nbool ans[N];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nvoid dp()\n{\n\tbin[0]=1;\n\tfor (int i=1;i<=tot;i++) bin[i]=bin[i-1]*2;\n\tfor (int i=0;i<bin[tot];i++) g[i]=n+1;\n\tfor (int i=0;i<bin[tot];i++)\n\t\tfor (int j=0;j<=tot;j++)\n\t\t\tif (!(i&bin[j])) MAX(f[i+bin[j]],rig[j][f[i]+1]),MIN(g[i+bin[j]],lef[j][g[i]-1]);\n\tfor (int i=0;i<bin[tot];i++)\n\t{\n\t\tint l=f[i],r=g[i^(bin[tot]-1)];\n\t\tif (l+1>=r)\n\t\t{\n\t\t\tfor (int j=1;j<=n;j++) ans[j]=1;\n\t\t\treturn;\n\t\t}\n\t\tif (p1[bel[l+1]]<=l+1&&p2[bel[l+1]]>=r-1) ans[bel[l+1]]=1;\n\t}\n}\n\nint main()\n{\n\tn=read();v=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n\ttot=0;len[0]=0;\n\twhile (v) len[++tot]=v,v>>=1;\n\tsort(len,len+tot+1);\n\tmemset(lef,inf,sizeof(lef));\n\tfor (int i=0;i<tot;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tint l=j;\n\t\t\twhile (l<n&&a[l+1]-a[l]<=len[i]) l++;\n\t\t\trig[i][j]=l;lef[i][l]=j;j=l;\n\t\t}\n\tint id=0;\n\tfor (int j=1;j<=n;j++)\n\t{\n\t\tint l=j;bel[j]=++id;\n\t\twhile (l<n&&a[l+1]-a[l]<=len[tot]) l++,bel[l]=id;\n\t\tp1[id]=j;p2[id]=l;j=l;\n\t}\n\tdp();\n\tfor (int i=1;i<=n;i++) puts(ans[bel[i]]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define MAX(x,y) x=max(x,y)\n#define MIN(x,y) x=min(x,y)\n#define inf 0x3f3f3f3f\nusing namespace std;\n\nconst int N=400005;\n\nint n,v,g[N*2],f[N*2],bin[25],tot,len[25],lef[25][N],rig[25][N],a[N],bel[N],p1[N],p2[N];\nbool ans[N];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n\nvoid dp()\n{\n    bin[0]=1;\n    for (int i=1;i<=tot;i++) bin[i]=bin[i-1]*2;\n    for (int i=0;i<bin[tot];i++) g[i]=n+1;\n    for (int i=0;i<bin[tot];i++)\n        for (int j=0;j<=tot;j++)\n            if (!(i&bin[j])) MAX(f[i+bin[j]],rig[j][f[i]+1]),MIN(g[i+bin[j]],lef[j][g[i]-1]);\n    for (int i=0;i<bin[tot];i++)\n    {\n        int l=f[i],r=g[i^(bin[tot]-1)];\n        if (l+1>=r)\n        {\n            for (int j=1;j<=n;j++) ans[j]=1;\n            return;\n        }\n        if (p1[bel[l+1]]<=l+1&&p2[bel[l+1]]>=r-1) ans[bel[l+1]]=1;\n    }\n}\n\nint main()\n{\n    n=read();v=read();\n    for (int i=1;i<=n;i++) a[i]=read();\n    tot=0;len[0]=0;\n    while (v) len[++tot]=v,v>>=1;\n    sort(len,len+tot+1);\n    memset(lef,inf,sizeof(lef));\n    for (int i=0;i<tot;i++)\n        for (int j=1;j<=n;j++)\n        {\n            int l=j;\n            while (l<n&&a[l+1]-a[l]<=len[i]) l++;\n            rig[i][j]=l;lef[i][l]=j;j=l;\n        }\n    int id=0;\n    for (int j=1;j<=n;j++)\n    {\n        int l=j;bel[j]=++id;\n        while (l<n&&a[l+1]-a[l]<=len[tot]) l++,bel[l]=id;\n        p1[id]=j;p2[id]=l;j=l;\n    }\n    dp();\n    for (int i=1;i<=n;i++) puts(ans[bel[i]]?\"Possible\":\"Impossible\");\n    return 0;\n}\n/*\n考虑最后走过的区间肯定只有log段，那么我们就状压表示从左到右（和从右到左）用了哪些段能走到的最远距离 \n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FR first\n#define SE second\nusing namespace std;\n\ntypedef pair<int,int> pii;\nconst int N=200010;\nint n,V,X[N],dep;\nint L[20][N],R[20][N];\nint exL[N],exR[N];\npii seg[N];\nbool ans[N];\n\nint findr(int d,int p){return R[d][upper_bound(L[d]+1,L[d]+1+n,p)-L[d]-1];}\nint findl(int d,int p){return L[d][lower_bound(R[d]+1,R[d]+1+n,p)-R[d]];}\n\nint main()\n{\n    //freopen(\"41.in\",\"r\",stdin);\n    //freopen(\"my.out\",\"w\",stdout);\n    scanf(\"%d%d\",&n,&V);\n    for(int i=1;i<=n;i++) scanf(\"%d\",X+i);\n    for(int v=V;v>=0;v>>=1,dep++)\n    {\n        L[dep][1]=1;R[dep][n]=n;\n        for(int i=2;i<=n;i++) L[dep][i]=(X[i]-X[i-1]<=v)?L[dep][i-1]:i;\n        for(int i=n-1;i>=1;i--) R[dep][i]=(X[i+1]-X[i]<=v)?R[dep][i+1]:i;\n        if(v==0){dep++;break;}\n    }\n    for(int i=1;i<=n;i++) seg[i]=pii(L[0][i],R[0][i]);\n    int cnt=unique(seg+1,seg+1+n)-(seg+1);\n    memset(exL,0,sizeof(exL));\n    memset(exR,0x3f,sizeof(exR));\n    exL[0]=0;exR[0]=n+1;\n    for(int s=0;s<(1<<dep);s++)\n        for(int i=0;i<dep;i++)\n        {\n            if(!(s&(1<<i))) continue;\n            exL[s]=max(exL[s],findr(i,exL[s^(1<<i)]));\n            exR[s]=min(exR[s],findl(i,exR[s^(1<<i)]));\n        }\n    if(cnt>dep) goto output;\n    for(int i=1;i<=cnt;i++)\n    {\n        for(int s=0;s<(1<<dep);s+=2)\n            if(exL[s]>=seg[i].FR-1&&exR[s]<=seg[i].SE+1)\n            {\n                for(int j=seg[i].FR;j<=seg[i].SE;j++) ans[j]=1;\n                goto finished;\n            }\n        finished: ;\n    }\n    output: for(int i=1;i<=n;i++) puts(ans[i]?\"Possible\":\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> Pi;\ntypedef long long ll;\n#define pii Pi\n#define pll PL\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n//#define sz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<int, int, int> t3;\ntypedef pair<ll, ll> pll;\ntypedef long double ldouble;\ntypedef pair<double, double> pdd;\n\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n\nconst int MX = 200005;\nconst int MM = 1000000007;\n\nll merge_vi(int a, int b){\n\tll ch = 0, c = 0;\n\tfor(int i = 0; i < 30; i++){\n\t\tif( a&1<<i ) ch++;\n\t\tif( b&1<<i ) ch++;\n\t\tif( ch ) c |= 1<<i, ch--;\n\t}\n\treturn c;\n}\n\nvoid reduce_vc(vector<int> &L){\n\tmap<int, int> S;\n\tfor(int c : L){\n\t\tint t = __builtin_popcount(c);\n\t\tif( S.find(t) == S.end() ) S[t] = c;\n\t\telse S[t] = min(S[t], c);\n\t} L.clear();\n\tfor(auto e : S) L.push_back(e.second);\n}\n\nvoid merge_vc(vector<int> X, vector<int> Y, vector<int> &Z){\n\tZ.clear();\n\tfor(int x : X){\n\t\tfor(int y : Y){\n\t\t\tll z = merge_vi(x, y);\n\t\t\tZ.push_back(z);\n\t\t}\n\t}\n\treduce_vc(Z);\n}\n\nstruct UF{\n\tint t[MX];\n\tvector<int> L[MX];\n\tint find(int x){ return t[x]? t[x] = find(t[x]) : x; }\n\tint merge(int a, int b){\n\t\ta = find(a), b = find(b);\n\t\tif( a == b ) return 0;\n\t\tt[a] = b; merge_vc(L[a], L[b], L[b]);\n\t\treturn 1;\n\t}\n} uf;\nint N, V;\nint D[MX], vst[MX];\nvector<int> pre[MX], suf[MX];\n\nint main()\n{\n\tvector<int> P;\n\tscanf(\"%d%d\", &N, &V);\n\tfor(int i = 1; i <= N; i++) scanf(\"%d\", D+i);\n\twhile(V){\n\t\tP.push_back(V);\n\t\tV /= 2;\n\t}\n\treverse(P.begin(), P.end());\n\tfor(int i = 1; i <= N; i++) uf.L[i].push_back(1);\n\tfor(int t = 1; t <= P.size(); t++){\n\t\tfor(int i = 1; i+1 <= N; i++){\n\t\t\tif( D[i+1] - D[i] <= P[t-1] && D[i+1] - D[i] > P[t-1]/2){\n\t\t\t\tuf.merge(i+1, i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif( uf.find(i) == i ){\n\t\t\t\tuf.L[i].push_back(1<<t);\n\t\t\t\treduce_vc(uf.L[i]);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tprintf(\"%d %d\\n\", t, P[t-1]);\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif( uf.find(i) == i ){\n\t\t\t\tprintf(\"%d : \", i);\n\t\t\t\tfor(int c : uf.L[i]) printf(\"%d \", c);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t} // */\n\t}\n\tpre[0].push_back(0);\n\tsuf[N+1].push_back(0);\n\tfor(int i = 1; i <= N; i++){\n\t\tpre[i] = pre[i-1];\n\t\tif( uf.find(i) == i ) merge_vc(pre[i], uf.L[i], pre[i]);\n\t}\n\tfor(int i = N; i >= 1; i--){\n\t\tsuf[i] = suf[i+1];\n\t\tif( uf.find(i) == i ) merge_vc(suf[i], uf.L[i], suf[i]);\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tvector<int> L;\n\t\tmerge_vc(pre[i-1], suf[i+1], L);\n\t\tfor(int c : L) if( c < 1 << P.size()) vst[i] = 1;\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tif( vst[uf.find(i)] ) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint L[20][222222],R[20][222222];\n\nint N,V;\nint X[222222];\n\n\nint dp1[1<<17];\nint dp2[1<<17];\n\n\nint acc[222222];\n\nsigned main(){\n    cin>>N>>V;\n    rep(i,N)cin>>X[i];\n    rep(k,18){\n        rep(i,N){\n            L[k][i]=i;\n            if(i&&X[i]-X[i-1]<=(V>>k))L[k][i]=L[k][i-1];\n        }\n        for(int i=N-1;i>=0;i--){\n            R[k][i]=i;\n            if(i+1!=N&&X[i+1]-X[i]<=(V>>k))R[k][i]=R[k][i+1];\n        }\n    }\n\n    rep(i,1<<17){\n        rep(j,17){\n            if(i>>j&1)continue;\n            if((V>>j)==0)chmax(dp1[i|(1<<j)],dp1[i]);\n            else if(dp1[i]==N)dp1[i|(1<<j)]=N;\n            else chmax(dp1[i|(1<<j)],R[j+1][dp1[i]]+1);\n        }\n    }\n\n    rep(i,1<<17)dp2[i]=N-1;\n    rep(i,1<<17){\n        rep(j,17){\n            if(i>>j&1)continue;\n            if((V>>j)==0)chmin(dp2[i|(1<<j)],dp2[i]);\n            else if(dp2[i]==-1)dp2[i|(1<<j)]=-1;\n            else chmin(dp2[i|(1<<j)],L[j+1][dp2[i]]-1);\n        }\n    }\n\n    rep(i,1<<17){\n        int j=(1<<17)-1-i;\n\n        if(dp1[i]>dp2[j]){\n            acc[0]++;\n            continue;\n        }\n\n\n        if(R[0][dp1[i]]>=dp2[j]){\n            acc[L[0][dp1[i]]]++;\n            acc[R[0][dp1[i]]+1]--;\n        }\n    }\n\n    rep(i,N){\n        acc[i+1]+=acc[i];\n        if(acc[i]){\n            puts(\"Possible\");\n        }\n        else{\n            puts(\"Impossible\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(a,b,c) for (int a=b;a<=c;a++)\n#define per(a,b,c) for (int a=b;a>=c;a--)\n#define go(u) for (int o=ft[u],v;v=E[o].t;o=E[o].n)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> par;\nconst int N=(1<<20)+5;\nint n,v,tot,sum,x[N],vn[N],nxt[25][N],f[N][25],l[N],r[N],bel[N],ok[N];\nint imp(){\n\trep(i,1,n+1) puts(\"Impossible\");\n\treturn 0;\n}\nvoid upd(int &x,int y){x=max(x,y);}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\trep(i,1,n) scanf(\"%d\",x+i);\n\t--n;\n\trep(i,1,n) x[i]=x[i+1]-x[i];\n\twhile (v){\n\t\tvn[++tot]=v;\n\t\tv>>=1;\n\t}\n\tsort(vn+1,vn+1+tot);\n\trep(i,1,n) x[i]=lower_bound(vn+1,vn+tot+1,x[i])-vn;\n\trep(i,1,tot){\n\t\tnxt[i][n+1]=n+1;\n\t\tper(j,n,1) if (x[j]<=i) nxt[i][j]=nxt[i][j+1]; else nxt[i][j]=j;\n\t}\n\trep(i,1,n+1) nxt[0][i]=i;\n\t++tot;\n\tint tmp=0;\n\twhile (tmp<n+1){\n\t\t++sum;\n\t\tl[sum]=tmp+1;\n\t\ttmp=nxt[tot-1][tmp+1];\n\t\tr[sum]=tmp;\n\t\trep(i,l[sum],r[sum]) bel[i]=sum;\n\t}\n\tif (sum>tot+2) return imp();\n\tf[0][0]=0;\n\tint mx=1<<(tot-1);\n\trep(i,0,(1<<tot)-1) rep(j,0,sum){\n\t\tif (((i&mx)!=0)^(j!=0)) continue;\n\t\tint nw=f[i][j]+1;\n\t\tif (nw>n){\n\t\t\tok[j]=1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (j==0) upd(f[i|mx][bel[nw]],nxt[tot-1][nw]);\n\t\trep(k,0,tot-2) if ((i&1<<k)==0)\n\t\t\tupd(f[i|1<<k][j],nxt[k][nw]);\n\t}\n\trep(i,1,n+1) puts(ok[bel[i]]?\"Possible\":\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 998244353\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,m1,v,i,j,k,x,a[400005],b[25],bz1[400005][25],bz2[400005][25];\nint r[400005][25],l[400005][25],f[400005],g[400005],book[400005],flag;\nint minn(int u,int v){\n\treturn u<v?u:v;\n}\nint maxx(int u,int v){\n\treturn u>v?u:v;\n}\nint main(){\n\tn=read();v=read();\n\tx=v;\n\tfor(i=0;x!=0;i++){\n\t\tb[i]=x;\n\t\tx>>=1;\n\t}\n\tm=i;\n\tfor(i=1;i<=n;i++)\n\t\ta[i]=read();\n\tfor(i=1;i<n;i++)\n\t\tbz1[i][0]=a[i+1]-a[i];\n\tfor(i=2;i<=n;i++)\n\t\tbz2[i][0]=a[i]-a[i-1];\n\tfor(j=1;(1<<j)<n;j++)\n\t\tfor(i=1;i+(1<<j)<=n;i++)\n\t\t\tbz1[i][j]=maxx(bz1[i][j-1],bz1[i+(1<<(j-1))][j-1]);\n\tm1=j-1;\n\tfor(j=1;(1<<j)<n;j++)\n\t\tfor(i=(1<<j)+1;i<=n;i++)\n\t\t\tbz2[i][j]=maxx(bz2[i][j-1],bz2[i-(1<<(j-1))][j-1]);\n\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=0;j<m;j++){\n\t\t\tx=i;\n\t\t\tfor(k=m1;k>=0;k--)\n\t\t\t\tif(x+(1<<k)<=n){\n\t\t\t\t\tif(bz1[x][k]<=b[j])\n\t\t\t\t\t\tx+=(1<<k);\n\t\t\t\t}\n\t\t\tr[i][j]=x;\n\t\t\t\n\t\t\tx=i;\n\t\t\tfor(k=m1;k>=0;k--)\n\t\t\t\tif(x-(1<<k)>=1){\n\t\t\t\t\tif(bz2[x][k]<=b[j])\n\t\t\t\t\t\tx-=(1<<k);\n\t\t\t\t}\n\t\t\tl[i][j]=x;\n\t\t}\n\t}\n\tf[0]=1;\n\tg[0]=n;\n\tfor(i=1;i<(1<<m);i++){\n\t\tf[i]=1;\n\t\tg[i]=n;\n\t\tfor(j=0;j<m;j++)\n\t\t\tif(i&(1<<j)){\n\t\t\t\tif(f[i^(1<<j)]==n)\n\t\t\t\t\tf[i]=n;\n\t\t\t\telse\n\t\t\t\t\tf[i]=maxx(f[i],j!=0?r[f[i^(1<<j)]+1][j]:f[i^(1<<j)]+1);\n\t\t\t\tif(g[i^(1<<j)]==1)\n\t\t\t\t\tg[i]=1;\n\t\t\t\telse\n\t\t\t\t\tg[i]=minn(g[i],j!=0?l[g[i^(1<<j)]-1][j]:g[i^(1<<j)]-1);\n\t\t\t}\n\t}\n\tx=1;\n\ti=0;\n\twhile(x<=n){\n\t\ti++;\n\t\tif(i>=30){\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tflag=0;\n\t\tfor(j=0;j<(1<<m);j++)\n\t\t\tif(f[j]+1>=x&&g[((1<<m)-1)^j]-1<=r[x][0])\n\t\t\t\tflag=1;\n\t\tfor(j=x;j<=r[x][0];j++)\n\t\t\tbook[j]=flag;\n\t\tx=r[x][0]+1;\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tif(book[i]==1)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntemplate<typename T> inline void chkmin(T &a, const T &b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T &a, const T &b) { a = a > b ? a : b; }\n\nconst int MAXN = 200005;\nint f[1 << 18], g[1 << 18], pla[MAXN], nxt[18][MAXN], n, V, tn;\nvector<int> seg[18];\n\nint main() {\n\tscanf(\"%d%d\", &n, &V);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", pla + i);\n\tfor (int i = V; i; i >>= 1) ++tn;\n\tfor (int i = 0; i < tn; i++) {\n\t\tfor (int j = 1; j < n; j++)\n\t\t\tif (pla[j] + (V >> i >> 1) < pla[j + 1]) seg[i].push_back(j);\n\t\tseg[i].push_back(n);\n\t}\n\tint m = 1;\n\tfor (int i = 1; i < n; i++)\n\t\tif (pla[i] + V < pla[i + 1]) ++m;\n\tif (m > tn + 2) {\n\t\tfor (int i = 1; i <= n; i++) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tfill(f, f + (1 << tn), 0);\n\tfor (int i = 0; i < tn; i++) {\n\t\tint lst = 1;\n\t\tfor (int j : seg[i]) {\n\t\t\tfor (int k = lst; k <= j; k++) nxt[i][k] = j;\n\t\t\tlst = j + 1;\n\t\t}\n\t}\n\tfor (int i = 0; i + 1 < 1 << tn; i++) {\n\t\tfor (int j = 0; j < tn; j++) if (~i >> j & 1)\n\t\t\tchkmax(f[i | 1 << j], nxt[j][f[i] + 1]);\n\t}\n\t\n\tfor (int i = 0; i < tn; i++) {\n\t\tint lst = 1;\n\t\tfor (int j : seg[i]) {\n\t\t\tfor (int k = lst; k <= j; k++) nxt[i][k] = lst;\n\t\t\tlst = j + 1;\n\t\t}\n\t}\n\tfill(g, g + (1 << tn), n + 1);\n\tfor (int i = 0; i + 1 < 1 << tn; i++) {\n\t\tfor (int j = 0; j < tn; j++) if (~i >> j & 1)\n\t\t\tchkmin(g[i | 1 << j], nxt[j][g[i] - 1]);\n\t}\n\t\n\tint lst = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i < n && pla[i] + V >= pla[i + 1]) continue;\n\t\tbool flag = false;\n\t\tfor (int j = 0; j < 1 << tn; j++)\n\t\t\tif (f[j] >= lst - 1 && g[j ^ ((1 << tn) - 1)] <= i + 1) { flag = true; break; }\n\t\tfor (int j = lst; j <= i; j++) puts(flag ? \"Possible\" : \"Impossible\");\n\t\tlst = i + 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,b,e) for(int i=(b); i <= (e); ++i)\n#define FORD(i,b,e) for(int i=(b); i >= (e); --i)\n#define REP(i,n) for(int i=0; i < (n); ++i)\n#define SIZE(c) (int) (c).size()\n#define ALL(c) (c).begin(), (c).end()\n#define PB push_back\n#define MP make_pair\n#define ST first\n#define ND second\n#define FWD(i,a,b) for (int i=(a); i<(b); ++i)\n#define BCK(i,a,b) for (int i=(a); i>(b); --i)\n#define PI 3.14159265358979311600\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\ntypedef vector < int > VI;\ntypedef vector<ll> VL;\n\ntypedef long double K;\n\n#define int long long\n\nconst int N = 200005;\nconst int M = 1<<22;\nconst int inf = 1e18;\n\nint n, v, cnt, bound;\nint a[N], f[M], g[M];\nint goLeft[N][23], goRight[N][23];\nvector<int> b;\n\nstruct SegTree {\n\tint n;\n\tvector<int> tree;\n\n\tSegTree(int n): n(n), tree(4*n, inf) {}\n\n\tvoid update(int pos, int val) {\n\t\tupdate(1, 0, n - 1, pos, val);\n\t}\n\n\tint go(int l, int r) {\n\t\treturn go(1, 0, n - 1, l, r);\n\t}\n\n\tvoid update(int v, int tl, int tr, int pos, int val) {\n\t\tif (tl == tr) {\n\t\t\ttree[v] = min(tree[v], val);\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) / 2;\n\t\tif (pos <= tm) {\n\t\t\tupdate(2*v, tl, tm, pos, val); \n\t\t} else {\t\n\t\t\tupdate(2*v+1, tm+1, tr, pos, val);\n\t\t}\n\t\ttree[v] = min(tree[2*v], tree[2*v+1]);\n\t}\n\n\tint go(int v, int tl, int tr, int l, int r) {\n\t\tif (l > tr || r < tl) return inf;\n\t\tif (l <= tl && r >= tr) return tree[v];\n\t\tint tm = (tl + tr) / 2;\n\t\treturn min(go(2*v, tl, tm, l, r), go(2*v+1, tm+1, tr, l, r));\n\t}\n};\n\nvoid calc() {\n\tREP(i, cnt) {\n\t\tREP(j, n) {\n\t\t\tgoLeft[i][j] = j;\n\t\t\tif (j > 0 && a[j] - a[j - 1] <= b[i]) {\n\t\t\t\tgoLeft[i][j] = goLeft[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tgoRight[i][j] = j;\n\t\t\tif (j < n - 1 && a[j + 1] - a[j] <= b[i]) {\n\t\t\t\tgoRight[i][j] = goRight[i][j + 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint go(int pos, int x, int side) {\n\tif (side < 0) {\n\t\treturn goLeft[x][pos];\n\t} \n\treturn goRight[x][pos];\n}\n\nmain() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\tREP(i, n) {\n\t\tcin >> a[i];\n\t}\n\n\twhile (v > 0) {\n\t\tb.push_back(v);\n\t\tv /= 2;\n\t}\n\n\tb.push_back(0);\n\tcnt = (int)b.size();\n\tbound = (1 << cnt);\n\n\tcalc();\n\n\tREP(i, bound) f[i] = 0, g[i] = n - 1;\n\tf[0] = 0;\n\tg[0] = n - 1;\n\n\tREP(i, bound) {\n\t\tREP(j, cnt) if (~i & (1 << j)) {\n\t\t\tif (f[i] != -inf) {\n\t\t\t\tf[i ^ (1 << j)] = max(f[i ^ (1 << j)], min(go(f[i], j, +1) + 1, n - 1));\n\t\t\t}\n\t\t\tif (g[i] != inf) {\n\t\t\t\tg[i ^ (1 << j)] = min(g[i ^ (1 << j)], max(go(g[i], j, -1) - 1, 0LL));\n\t\t\t}\n\t\t}\n\t}\n\n\tint all = 0;\n\n\tSegTree tree(n);\n\n\tREP(mask, bound) {\n\t\tint comp = (bound - 1) ^ mask;\n\t\tint a = (mask & 1) ? (mask ^ 1) : mask;\n\t\tint b = (comp & 1) ? (comp ^ 1) : comp;\n\t\tif (f[a] >= g[b]) {\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\t}\n\t\ttree.update(f[a], g[b]);\n\t}\n\n\tREP(i, n) {\n\t\tif (all) {\n\t\t\tcout << \"Possible\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tint lb = go(i, 0, -1);\n\t\tint rb = go(i, 0, +1);\n\t\tif (tree.go(lb, rb) <= rb) {\n\t\t\tcout << \"Possible\\n\";\n\t\t} else {\n\t\t\tcout << \"Impossible\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// I need some holiday\n// But I don't wish that everyday is holiday\n// Because I didn't bear the pain\n// Because it wasn't a true freedom\n//         ——『イヤホンと蝉時雨』·Orangestar\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\n\nnamespace fastIO\n{\n\tconst int MAX_BUFFER_SIZE = 1 << 16;\n\n\tchar buffer[MAX_BUFFER_SIZE], *cur = buffer, *ed = buffer;\n\n\tinline char getc() { return cur == ed && (ed = (cur = buffer) + fread(buffer, 1, MAX_BUFFER_SIZE, stdin), cur == ed) ? EOF : *cur++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ninline char *read_str(char *s)\n{\n\tregister char ch(getc());\n\twhile(!isgraph(ch)) ch = getc();\n\tfor(; isgraph(ch); ch = getc()) *s++ = ch;\n\t*s = '\\0';\n\treturn s;\n}\n\n// END tpl.\n\nconst int MAXN = (int) 2e5;\n\nint n, V;\n\nint x[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>(), V = read<int>();\n\tfor(int i = 1; i <= n; ++i) x[i] = read<int>();\n}\n\nstruct seg\n{\n\tint l, r;\n\n\tinline bool operator < (const seg &rhs) { return this-> r < rhs.r; }\n\n\tseg() { }\n\tseg(int _l, int _r): l(_l), r(_r) { }\n};\n\ninline void solve()\n{\n\tconst int MAXD = 20;\n\tstatic int pre[MAXD + 1][MAXN + 5], suf[MAXD + 1][MAXN + 5];\n\n\tint D = 0;\n\tfor(int d = V; d >= 0; d >>= 1, ++D)\n\t{\n\t\tfor(int lst = 1, i = 1; i <= n; ++i)\n\t\t{\n\t\t\tpre[D][i] = lst;\n\t\t\tif(i < n && x[i + 1] - x[i] > d) lst = i + 1;\n\t\t}\n\t\tfor(int lst = n, i = n; i >= 1; --i)\n\t\t{\n\t\t\tsuf[D][i] = lst;\n\t\t\tif(i > 1 && x[i] - x[i - 1] > d) lst = i - 1;\n\t\t}\n\t\tif(d == 0) { ++D; break; }\n\t}\n\n\tstatic int f[1 << MAXD], g[1 << MAXD];\n\tfor(int S = 0; S < 1 << D; ++S) f[S] = 0, g[S] = n + 1;\n\n\tf[0] = 0, g[0] = n + 1;\n\tfor(int S = 0; S < 1 << D; ++S)\n\t\tfor(int i = 0; i < D; ++i) if(!(S >> i & 1))\n\t\t{\n\t\t\tchkmax(f[S | 1 << i], max(f[S], suf[i][f[S] + 1]));\n\t\t\tchkmin(g[S | 1 << i], min(g[S], pre[i][g[S] - 1]));\n\t\t}\n\n\tstatic vector<seg> s;\n\n\tint fg = 0;\n\tfor(int U = ((1 << D) - 1) ^ 1, S = 0; S < 1 << D; ++S) if(!(S & 1))\n\t{\n\t\tint l = f[S], r = g[U ^ S];\n\t\tif(l + 1 > r - 1) { fg = 1; break; }\n\t\ts.emplace_back(l + 1, r - 1);\n\t}\n\tif(fg) { for(int i = 1; i <= n; ++i) puts(\"Possible\"); return; }\n\n\tsort(ALL(s));\n\tfor(int L = 0, i = 1, j = 0; i <= n; ++i)\n\t{\n\t\tint l = pre[0][i], r = suf[0][i];\n\t\twhile(j < SZ(s) && s[j].r <= r) chkmax(L, s[j++].l);\n\t\tputs(L >= l ? \"Possible\" : \"Impossible\");\n\t}\n}\n\nint main()\n{\n#ifdef K_ON\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*====Corycle====*/\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<map>\n#define ll long long\n#define pii pair<int,int>\n#define fst first\n#define scd second\n#define mp make_pair\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int Maxn=(1<<19)+5;\nconst int N=2e5+5;\nconst int M=20;\nint read(){\n\tint s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}\n\treturn s*f;\n}\npii P[N];\nint n,V,cnt,tot,Sta,a[N],L[N][M],R[N][M],Ans[N],FL[Maxn],FR[Maxn];\nint main(){\n//\tfreopen(\"_.in\",\"r\",stdin);\n//\tfreopen(\"_.out\",\"w\",stdout);\n\tn=read();V=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();a[0]=-inf;a[n+1]=inf;\n\tfor(int v=V;;v>>=1){\n\t\ttot++;L[tot][0]=0;R[tot][n+1]=n+1;\n\t\tfor(int i=1;i<=n;i++)L[tot][i]=(a[i]-a[i-1]<=v?L[tot][i-1]:i);\n\t\tfor(int i=n;i>=1;i--)R[tot][i]=(a[i+1]-a[i]<=v?R[tot][i+1]:i);\n\t\tif(v==0)break;\n\t}\n\tSta=(1<<tot)-1;\n\tfor(int i=1;i<=n;i++)P[i]=mp(L[1][i],R[1][i]);\n\tsort(P+1,P+n+1);cnt=unique(P+1,P+n+1)-P-1;\n\tfor(int S=0;S<=Sta;S++){FL[S]=0;FR[S]=n+1;}\n\tfor(int S=0;S<=Sta;S++){\n\t\tfor(int i=1;i<=tot;i++){\n\t\t\tif(!((S>>(i-1))&1))continue;\n\t\t\tFL[S]=max(FL[S],R[i][FL[S^(1<<(i-1))]+1]);\n\t\t\tFR[S]=min(FR[S],L[i][FR[S^(1<<(i-1))]-1]);\n\t\t}\n\t}\n\tif(cnt>tot){for(int i=1;i<=tot;i++)puts(\"Impossible\");return 0;}\n\tfor(int i=1;i<=cnt;i++){\n\t\tfor(int S=0;S<=Sta;S+=2){\n\t\t\tif(FL[S]>=P[i].fst-1&&FR[Sta^S^1]<=P[i].scd+1){\n\t\t\t\tfor(int j=P[i].fst;j<=P[i].scd;j++)Ans[j]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)puts(Ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint K, N, V, sz[20], x[200009], maxPref[200009], pf[200009], sf[200009], lft[17][200009], rgt[17][200009];\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\", &N, &V);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &x[i]);\nfor (int i=0; (1 << i) <= V; i++)\n    sz[i] = V >> i, K = i;\nsz[++K] = 0;\nfor (int i=0; i<=K; i++)\n{\n    lft[i][1] = 1, lft[i][0] = 0;\n    for (int j=2; j<=N; j++)\n        if (x[j] - x[j - 1] <= sz[i]) lft[i][j] = lft[i][j - 1];\n        else lft[i][j] = j;\n    rgt[i][N] = N, rgt[i][N + 1] = N + 1;\n    for (int j=N - 1; j>=1; j--)\n        if (x[j + 1] - x[j] <= sz[i]) rgt[i][j] = rgt[i][j + 1];\n        else rgt[i][j] = j;\n}\nint lim = 1 << K;\nfor (int i=0; i < lim; i++)\n    sf[i] = N + 1;\nfor (int msk = 0; msk < lim; msk ++)\n    for (int i=0; i<K; i++)\n        if ((msk & (1 << i)) == 0)\n            pf[msk | (1 << i)] = max (pf[msk | (1 << i)], rgt[i + 1][pf[msk] + 1]),\n            sf[msk | (1 << i)] = min (sf[msk | (1 << i)], lft[i + 1][sf[msk] - 1]);\nfor (int i=0; i<=N + 1; i++)\n    maxPref[i] = -N;\nfor (int i=0; i<lim; i++)\n    maxPref[sf[i]] = max (maxPref[sf[i]], pf[(lim - 1) ^ i]);\nfor (int i=1; i<=N + 1; i++)\n    maxPref[i] = max (maxPref[i - 1], maxPref[i]);\nfor (int i=1; i<=N; i++)\n    if (maxPref[rgt[0][i] + 1] >= lft[0][i] - 1) printf (\"Possible\\n\");\n    else printf (\"Impossible\\n\");\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint nxt[20][202020];\nint bef[20][202020];\nint dp1[402020], dp2[402020];\nint d[202020];\nint ans[202020];\nint main()\n{\n\tint num, gen;\n\tscanf(\"%d%d\", &num, &gen);\n\td[0] = -1010101010, d[num + 1] = 1010101010;\n\tfor (int i = 1; i <= num; i++)scanf(\"%d\", &d[i]);\n\tint pt = 0;\n\tfor (;;)\n\t{\n\t\tint now = 0;\n\t\tfor (int i = 1; i <= num + 1; i++)\n\t\t{\n\t\t\tif (d[i] - d[i - 1] > gen)now = i - 1;\n\t\t\tbef[pt][i] = now;\n\t\t}\n\t\tbef[pt][0] = 0;\n\t\tnow = num + 1;\n\t\tfor (int i = num; i >= 0; i--)\n\t\t{\n\t\t\tif (d[i + 1] - d[i] > gen)now = i + 1;\n\t\t\tnxt[pt][i] = now;\n\t\t}\n\t\tnxt[pt][num + 1] = num + 1;\n\t\tpt++;\n\t\tif (gen == 0)break;\n\t\tgen /= 2;\n\t}\n\t//for (int i = 0; i <= num + 1; i++)printf(\"%d %d\\n\", nxt[0][i], bef[0][i]);\n\tfill(dp1, dp1 + (1 << pt), 1);\n\tfor (int p = 0; p < (1 << pt); p++)\n\t{\n\t\tfor (int i = 0; i < pt; i++)\n\t\t{\n\t\t\tif (p&(1 << i))continue;\n\t\t\tdp1[p + (1 << i)] = max(dp1[p + (1 << i)], nxt[i][dp1[p]]);\n\t\t}\n\t}\n\tfill(dp2, dp2 + (1 << pt), num);\n\tfor (int p = 0; p < (1 << pt); p++)\n\t{\n\t\tfor (int i = 0; i < pt; i++)\n\t\t{\n\t\t\tif (p&(1 << i))continue;\n\t\t\tdp2[p + (1 << i)] = min(dp2[p + (1 << i)], bef[i][dp2[p]]);\n\t\t}\n\t}\n\t//for (int i = 0; i < (1 << pt); i++)printf(\"%d %d\\n\", dp1[i], dp2[i]);\n\tfor (int p = 0; p < (1 << pt); p+=2)\n\t{\n\t\tint q = (1 << pt) - 2 - p;\n\t\tif (nxt[0][dp1[p]]>dp2[q])ans[dp1[p]] = 1;\n\t}\n\tint t = 0;\n\tfor (;;)\n\t{\n\t\tif (ans[t])\n\t\t{\n\t\t\tfor (int j = t; j < nxt[0][t]; j++)ans[j] = 1;\n\t\t\tt = nxt[0][t];\n\t\t}\n\t\telse t++;\n\t\tif (t == num + 1)break;\n\t}\n\tfor (int i = 1; i <= num; i++)printf(ans[i] ? \"Possible\\n\" : \"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200200, lg = 19;\nint vi[lg], seg[lg][maxn], tol[lg][maxn], tor[lg][maxn], sl[lg][maxn], sr[lg][maxn], a[maxn];\nint n, v, stk;\nmap<pair<int,int>, bool> cal, car; \nbool can_left(int p, int msk){\n\tif(p == 0) return true;\n\tif(msk == 0) return false;\n\tint up = 0;\n\tint pco = __builtin_popcount(msk);\n\twhile(((msk>>up)&1) == 0) up++;\n\tif(sl[up][p] > pco) return false; \n\tauto it = cal.find(make_pair(p, msk));\n\tif(it != cal.end()) return it->second;\n\tfor(int j = 1; j < stk; j++){\n\t\tif((msk>>j)&1){\n\t\t\tif(can_left(tol[j][p] - 1, msk ^ (1<<j))){\n\t\t\t\treturn cal[{p, msk}] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn cal[{p, msk}] = false;\n}\nbool can_right(int p, int msk){\n\tif(p == n + 1) return true;\n\tif(msk == 0) return false;\n\tint up = 0;\n\tint pco = __builtin_popcount(msk);\n\twhile(((msk>>up)&1) == 0) up++;\n\tif(sr[up][p] > pco) return false; \n\tauto it = car.find(make_pair(p, msk));\n\tif(it != car.end()) return it->second;\n\tfor(int j = 1; j < stk; j++){\n\t\tif((msk>>j)&1){\n\t\t\tif(can_right(tor[j][p] + 1, msk ^ (1<<j))){\n\t\t\t\treturn car[{p, msk}] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn car[{p, msk}] = false;\n}\nint main(){\n\tcin >> n >> v;\n\twhile(v){\n\t\tvi[stk++] = v;\n\t\tv /= 2;\n\t}\n\tvi[stk++] = 0;\n\tfor(int i = 1; i <= n; i++) cin >> a[i];\n\tfor(int j = 0; j < stk; j++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i == 1 || a[i] - a[i - 1] > vi[j]) tol[j][i] = i, sl[j][i] = sl[j][i-1] + 1;\n\t\t\telse tol[j][i] = tol[j][i-1], sl[j][i] = sl[j][i-1];\n\t\t}\n\t\tfor(int i = n; i >= 1; i--){\n\t\t\tif(i == n || a[i + 1] - a[i] > vi[j]) tor[j][i] = i, sr[j][i] = sr[j][i+1] + 1;\n\t\t\telse tor[j][i] = tor[j][i+1], sr[j][i] = sr[j][i+1];\n\t\t}\n\t}\n\tif(sr[0][n] > lg){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcout << \"Impossible\\n\";\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(int i = 1, j = 1; i <= n; i = j){\n\t\twhile(j + 1 <= n && a[j + 1] - a[j] <= vi[0]) j++;\n\t\tbool possible = false;\n\t\tfor(int c = 0; c < (1<<stk); c += 2){\n\t\t\tint ac = ((1<<stk) - 1) ^ c ^ 1;\n\t\t\tif(can_left(i - 1, c) && can_right(j + 1, ac)){\n\t\t\t\tpossible = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int k = i; k <= j; k++){\n\t\t\tif(possible) cout << \"Possible\\n\";\n\t\t\telse cout << \"Impossible\\n\";\n\t\t}\n\t\tj++;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ctz __builtin_ctz\n\nconst int N = 200005, inf = 0x3f3f3f3f;\n\nvoid up(int &x, int y) { x = std::max(x, y); }\nvoid down(int &x, int y) { x = std::min(x, y); }\n\nint f[N], g[N], x[N], L[19][N], R[19][N], sum[N];\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tint n, v; std::cin >> n >> v;\n\tint lg = std::__lg(v) + 1, mask = ~(-1 << lg);\n\tx[0] = -inf, x[n + 1] = inf;\n\tfor (int i = 1; i <= n; ++i) std::cin >> x[i];\n\tfor (int t = 0; t <= lg; ++t) {\n\t\tint _v = v >> t;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tL[t][i] = x[i] - x[i - 1] <= _v ? L[t][i - 1] : i;\n\t\tfor (int i = n; i >= 1; --i)\n\t\t\tR[t][i] = x[i + 1] - x[i] <= _v ? R[t][i + 1] : i;\n\t}\n\tstd::fill(g, g + mask + 1, n + 1);\n\tfor (int i = 0; i < mask; ++i) {\n\t\tfor (int _j = mask ^ i, j = ctz(_j); _j; j = ctz(_j &= _j - 1)) {\n\t\t\tup(f[i | 1 << j], f[i]);\n\t\t\tif (f[i] < n) up(f[i | 1 << j], R[j + 1][f[i] + 1]);\n\t\t\tdown(g[i | 1 << j], g[i]);\n\t\t\tif (g[i] > 1) down(g[i | 1 << j], L[j + 1][g[i] - 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i <= mask; ++i)\n\t\tif (f[i] + 1 >= g[mask - i]) {\n\t\t\twhile (n--) std::cout << \"Possible\\n\"; return 0;\n\t\t}\n\tfor (int i = 0; i <= mask; ++i)\n\t\tif (R[0][f[i] + 1] + 1 >= g[mask - i])\n\t\t\t++sum[f[i] + 1], --sum[R[0][f[i] + 1] + 1];\n\tfor (int i = 1; i <= n; ++i) sum[i] += sum[i - 1];\n\tfor (int i = 1; i <= n; ++i) std::cout << (sum[i] ? \"Possible\" : \"Impossible\") << '\\n';\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (1050000)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,m,p[N],cnt,ri[N],le[N];\nvector<int> seg[22];\nvoid spj(){\n\tif(seg[cnt].size()<=25)return;\n\tfor(int i=1;i<=n;i++)puts(\"Impossible\");exit(0);\n}\nint main(){\n\tread(n),read(m);\n\tfor(int i=1;i<=n;i++)read(p[i]); p[n+1]=inf,p[0]=-inf;\n\tfor(cnt=0;(m>>cnt)>0;cnt++);\n\tfor(int i=0;i<=cnt;i++)\n\tfor(int j=0;j<=n;j++)\n\tif(p[j+1]-p[j]>(m>>i))seg[cnt-i].push_back(j);\n//\tfor(int i=0;i<=cnt;i++){\n//\t\tprintf(\"#%d(%d):\",i,m>>(cnt-i));\n//\t\tfor(int j=0;j<seg[i].size();j++)printf(\"%d \",seg[i][j]); puts(\"\");\n//\t}\n\tspj();\n\tfor(int i=0;i<(1<<cnt);i++)le[i]=n+1,ri[i]=0;\n\tfor(int i=0;i<(1<<cnt);i++)\n\tfor(int j=0;j<cnt;j++)\n\tif(!(i&(1<<j))){\n\t\tint v=i|(1<<j);\n\t\tri[v]=max(ri[v],*(upper_bound(seg[j].begin(),seg[j].end(),ri[i])));\n\t\tle[v]=min(le[v],*(lower_bound(seg[j].begin(),seg[j].end(),le[i]-1)-1)+1);\n\t}\n//\tfor(int i=0;i<(1<<cnt);i++)\n//\tprintf(\"%d %d %d\\n\",i,le[i],ri[i]);\n\tfor(int i=0;i<seg[cnt].size()-1;i++){\n\t\tbool fl=0;\n\t\tfor(int j=0;j<(1<<cnt);j++)\n\t\tif(ri[j]>=seg[cnt][i]&&le[((1<<cnt)-1)^j]<=seg[cnt][i+1]+1){fl=1;break;}\n\t\tfor(int tt=seg[cnt][i]+1;tt<=seg[cnt][i+1];tt++)\n\t\tif(!fl)puts(\"Impossible\");else puts(\"Possible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n \nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n \nconst int Maxn=2E5+5;\n \nint N,M,K,V;\nint a[Maxn];\nint F[Maxn<<1],G[Maxn<<1];\nint L[25][Maxn],R[25][Maxn];\nchar Ans[50],_1[50]={\"Possible\"},_2[50]={\"Impossible\"};\n//int nxt[Maxn];\n \ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n \nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1)\n\t\t\t\tMAX(F[i],R[M-j][min(F[i-(1<<j)]+1,N)]),\n\t\t\t\tMIN(G[i],L[M-j][max(G[i-(1<<j)]-1,1)]);\n\t}\n\tfor(int i=1;i<=N;++i)\n\t\tK+=(L[0][i]!=L[0][i-1]);\n\tif(K>20){\n\t\tfor(int i=1;i<=N;++i)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=1,j;i<=N;++i)\n\t\tif(L[0][i]!=L[0][i-1]){\n\t\t\tfor(j=0;j<(1<<M);++j)\n\t\t\t\tif(F[j]>=L[0][i]-1 && G[(1<<M)-1-j]<=R[0][i]+1)\n\t\t\t\t\t{memcpy(Ans,_1,sizeof(_1)); break ;}\n\t\t\tif(j==1<<M) memcpy(Ans,_2,sizeof(_2));\n\t\t\tprintf(\"%s\\n\",Ans);\n\t\t}else printf(\"%s\\n\",Ans);\n/*\tmemset(nxt,-1,sizeof(nxt));\n\tfor(int i=0;i<(1<<M);++i) MAX(nxt[G[(1<<M)-1-i]],F[i]);\n\tfor(int i=1;i<=N+1;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[R[0][i]+1]>=L[0][i]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 233333;\nint n,v,a[N],len,bh[20][N],num;Vi e[N*20];\nstruct Seg{\n\tint r[N];\n\tvoid init(int x){\n\t\tper(i,n,1){r[i]=i;if(i+1<=n&&a[i+1]-a[i]<=x)r[i]=r[i+1];}\n\t}\n}b[20];\nmap<Vi,bool>Map[20];\nbool ck(int dep, Vi c){\n\tif(SZ(c)>len-dep+1)return 0;if(dep==len||!SZ(c))return 1;\n\tsort(c.begin(),c.end());\n\tif(Map[dep].count(c))return Map[dep][c];\n\tbool ok=0;int tot=0;\n\tint a[25];rep(j,0,SZ(c)-1)a[j]=SZ(e[c[j]]),tot+=a[j];\n\trep(i,0,SZ(c)-1)if(tot-a[i]<=len-(dep+1)+1){\n\t\tVi d;rep(j,0,SZ(c)-1)if(i!=j)rep(k,0,SZ(e[c[j]])-1)d.pb(e[c[j]][k]);\n\t\tif(ck(dep+1,d)){ok=1;break;}\n\t}\n\treturn Map[dep][c]=ok;\n}\nint main() {//freopen(\"57.txt\",\"r\",stdin);freopen(\"1.out\",\"w\",stdout);\n\tread(n);read(v);rep(i,1,n)read(a[i]);\n\twhile(1){b[++len].init(v);if(!v)break;v/=2;}\n\trep(i,1,len)rep(j,1,n)if(b[i].r[j]!=b[i].r[j-1])bh[i][j]=++num;\n\trep(i,1,len-1)rep(j,1,n)if(bh[i][j]){\n\t\tfor(int k=j;k<=b[i].r[j];k=b[i+1].r[k]+1)\n\t\t\te[bh[i][j]].pb(bh[i+1][k]);\n\t}\n\tVi top;rep(i,1,n)if(bh[1][i])top.pb(bh[1][i]);\n\tif(SZ(top)>=20){\n\t\trep(i,1,n)puts(\"Impossible\");return 0;\n\t}\n\tfor(int i=1;i<=n;i=b[1].r[i]+1){\n\t\tVi c;rep(j,0,SZ(top)-1)if(top[j]!=bh[1][i])rep(k,0,SZ(e[top[j]])-1)c.pb(e[top[j]][k]);\n\t\tbool ok=ck(2,c);\n\t\trep(j,i,b[1].r[i])printf(\"%s\\n\",ok?\"Possible\":\"Impossible\");\n\t}\n\trep(i,1,len)cerr<<i<<' '<<SZ(Map[i])<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint po[400400];\n\nint mlg;\nvector<int>li[22];\nint mr[22][400400];\nint ml[22][400400];\nvoid get_line(int pos,int ma)\n{\n\tli[pos].push_back(0);\n//\tcout<<endl;\n//\tcout<<\"pos: \"<<pos<<\" ma: \"<<ma<<endl;\n\tfor(int i=1;i<=n;++i)\n\t\tif(i==1||po[i]-po[i-1]>ma)\n\t\t\tli[pos].push_back(i);\n\tli[pos].push_back(n+1);\n\tfor(int i=1,p=0;i<=n;++i)\n\t{\n\t\tmr[pos][i]=mr[pos][i-1];\n\t\tif(i==li[pos][p+1])\n\t\t\tp++,mr[pos][i]=li[pos][p+1]-1;\n\t}\n\tmr[pos][n+1]=n;\n\tml[pos][n+1]=n+1;\n\tfor(int i=n,p=li[pos].size()-1;i;--i)\n\t{\n\t\tml[pos][i]=ml[pos][i+1];\n\t\tif(i==li[pos][p]-1)\n\t\t\tp--,ml[pos][i]=li[pos][p];\n\t}\n//\tcout<<\"mr: \";for(int i=1;i<=n;++i)cout<<mr[pos][i]<<\" \";cout<<endl;\n//\tcout<<\"ml: \";for(int i=1;i<=n;++i)cout<<ml[pos][i]<<\" \";cout<<endl;\n}\n\nint pre[400400],suf[400400];\nint ans[22];\nvoid out(int ma)\n{\n\tfor(int i=1;i<=ma;++i)\n\t\tfor(int j=li[0][i];j<li[0][i+1];++j)\n\t\t\tputs(ans[i]?\"Possible\":\"Impossible\");\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&po[i]);\n\tfor(int tm=m;tm;mlg++,tm>>=1) get_line(mlg,tm);\n\tget_line(mlg,0);mlg++; \n\tint s=1<<mlg,nxt;\n\tmemset(suf,0x3f,sizeof(suf));\n\tsuf[0]=n+1;\n//\tcout<<\"s: \"<<s<<endl;\n\tfor(int i=0;i<s;++i)\n\t{\n//\t\tcout<<\"i: \"<<i<<\" pre: \"<<pre[i]<<\" suf: \"<<suf[i]<<endl;\n\t\tfor(int j=0;j<mlg;++j)\n\t\t{\n\t\t\tif((i>>j)&1)continue;\n\t\t\tnxt=(i|(1<<j));\n\t\t\tpre[nxt]=max(pre[nxt],mr[j][pre[i]+1]);\n\t\t\tsuf[nxt]=min(suf[nxt],ml[j][suf[i]-1]);\n\t\t}\n\t}\n\tint ma=li[0].size()-2;\n\tif(ma>mlg)\n\t{\n\t\tfor(int i=1;i<=n;++i)puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\ts--;\n\tint ls=(s^1);\n\tfor(int i=1,L,R;i<=ma;++i)\n\t{\n\t\tL=li[0][i];R=li[0][i+1]-1;\n\t\tfor(int j=0;j<=s;++j)\n\t\t{\n\t\t\tif(j&1)continue;\n//\t\t\tcout<<\"j: \"<<j<<\" invj: \"<<((s^j)&ls)<<endl;\n\t\t\tif(pre[j]>=L-1&&suf[(s^j)&ls]<=R+1)\n\t\t\t{\n\t\t\t\tans[i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tout(ma);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nvector<int> f(int N, int M, vector<int> dx) {\n\tvector<vector<int> > nxt(N + 1, vector<int>(M));\n\trep(j, M) nxt[N][j] = nxt[N - 1][j] = N - 1;\n\tfor (int i = N - 2; i >= 0; i--) {\n\t\tnxt[i] = nxt[i + 1];\n\t\tfor (int j = dx[i]; j < M; j++) nxt[i][j] = i + 1;\n\t}\n\tvector<int> dp(1<<M);\n\trep(S, 1<<M)\n\t\trep(j, M) if (!(S>>j & 1)) {\n\t\t\tint _S = S | 1<<j;\n\t\t\tdp[_S] = max(dp[_S], nxt[dp[S]][j]);\n\t\t}\n\treturn dp;\n}\n\nvector<int> solve() {\n\tint N, V; cin >> N >> V;\n\tvector<int> x(N);\n\trep(i, N) scanf(\"%d\", &x[i]);\n\tvector<int> dx(N - 1);\n\trep(i, N - 1) dx[i] = x[i + 1] - x[i];\n\t/*\n\tbool ok = true;\n\trep(i, N - 1) if (dx[i] > V) ok = false;\n\tif (ok) return vector<int>(N, true);\n\t*/\n\tvector<int> v;\n\tfor (int _V = V; _V; _V /= 2) v.pb(_V);\n\tv.pb(0);\n\tint M = v.size();\n\trep(i, N - 1) {\n\t\tint k;\n\t\tfor (k = 0; dx[i] <= v[k]; k++);\n\t\tdx[i] = k;\n\t}\n\tunion_find uf(N);\n\trep(i, N - 1) if (dx[i]) uf.unite(i, i + 1);\n\tvector<int> dp1 = f(N, M, dx);\n\treverse(dx.begin(), dx.end());\n\tvector<int> dp2 = f(N, M, dx);\n\tvector<bool> ok(N);\n\trep(S, 1<<(M - 1)) {\n\t\tint S1 = S<<1, S2 = (((1<<(M - 1)) - 1) - S)<<1;\n\t\tint i = dp1[S1], j = N - 1 - dp2[S2];\n\t\tif (uf.same(i, j)) ok[uf.find(i)] = true;\n\t}\n\tvector<int> ans(N);\n\trep(i, N) ans[i] = ok[uf.find(i)];\n\treturn ans;\n}\n\nint main() {\n\tvector<int> ans = solve();\n\tfor (int z: ans) if (z) printf(\"Possible\\n\"); else printf(\"Impossible\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n\n#define MAXN 200005\n#define MAXB 21\n\nusing namespace std;\n\nconst int INF = 1e9 + 2e6;\nint v[MAXN], n, m;\nint d[MAXN], up[MAXN][MAXB], down[MAXN][MAXB], pre[1 << MAXB], suf[1 << MAXB];\nint visit[MAXN];\n\nint read() {\n    char c = getchar();\n    int x = 0, s = 1;\n    while (!isdigit(c)) {\n        if (c == '-')\n            s = -1;\n        c = getchar();\n    }\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x * s;\n}\n\nvoid init() {\n    while (v[++m] >= 1)\n        v[m + 1] = v[m] >> 1;\n    d[0] = -INF;\n    d[n + 1] = INF;\n    for (int j = 1; j <= m; ++j) {\n        for (int i = 1; i <= n; ++i)\n            if (d[i] - d[i - 1] <= v[j])\n                up[i][j] = up[i - 1][j];\n            else\n                up[i][j] = i;\n        for (int i = n; i >= 1; --i)\n            if (d[i + 1] - d[i] <= v[j])\n                down[i][j] = down[i + 1][j];\n            else\n                down[i][j] = i;\n    }\n}\n\nvoid solve() {\n    memset(suf, 0x3f, sizeof(suf));\n    memset(pre, -0x3f, sizeof(pre));\n    suf[0] = n + 1;\n    pre[0] = 0;\n    int limit = (1 << m) - 1;\n    for (int s = 0; s <= limit; ++s) {\n        for (int i = 1; i <= m; ++i) {\n            if (s >> (i - 1) & 1)\n                continue;\n            int t = s | (1 << (i - 1));\n            if (pre[s] >= 0)\n                pre[t] = max(pre[t], down[pre[s] + 1][i]);\n            if (suf[s] <= n + 1)\n                suf[t] = min(suf[t], up[suf[s] - 1][i]);\n        }\n    }\n    for (int s = 1; s < limit; ++s) {\n        if (s & 1)\n            continue;\n        int t = limit ^ s;\n        t ^= 1;\n        if (down[pre[s] + 1][1] >= suf[t] - 1) {\n            ++visit[up[pre[s] + 1][1]];\n            --visit[down[pre[s] + 1][1] + 1];\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n        visit[i] = visit[i - 1] + visit[i];\n    for (int i = 1; i <= n; ++i)\n        if (visit[i])\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n}\n\nint main() {\n//    cout << INF << endl << INT_MAX << endl;\n    n = read();\n    v[1] = read();\n    for (int i = 1; i <= n; ++i)\n        d[i] = read();\n    init();\n    solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint x[220000],l[20][220000][2],f[220000][2],n,v,p[20][220000],cnt[20],k;\nbool b[20];\nint main(){\n\t\n\tscanf(\"%d%d\",&n,&v);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",x+i);\n\tx[0]=x[1]-v-v;\n\tfor (k=0;v;++k,v>>=1){\n\t\tcnt[k]=1,l[k][1][0]=p[k][1]=1;\n\t\tfor (int j=2;j<=n;++j) {\n\t\t\tif (x[j-1]+v<x[j]) {\n\t\t\t\tl[k][cnt[k]][1]=j-1,++cnt[k];\n\t\t\t\tl[k][cnt[k]][0]=j;\n\t\t\t}\n\t\t\tp[k][j]=cnt[k];\n\t\t}\n\t\tl[k][cnt[k]][1]=n,p[k][n]=cnt[k];\n\t}\n\tcnt[k]=0;\n\tfor (int i=1;i<=n;++i) ++cnt[k],l[k][cnt[k]][0]=l[k][cnt[k]][1]=i,p[k][i]=i;\n\t++k;\n\tif (cnt[0]>k) {\n\t\tfor (int i=0;i<n;++i) printf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint tp=1<<k;\n\tf[0][0]=0,f[0][1]=n+1;\n\tfor (int i=2;i<tp;i+=2) {\n\t\tf[i][0]=-1,f[i][1]=n<<1;\n\t\tfor (int j=1;j<k;++j) {\n\t\t\tif (i&(1<<j)) {\n\t\t\t\tf[i][0]=max(f[i][0],l[j][p[j][f[i^(1<<j)][0]+1]][1]);\n\t\t\t\tf[i][1]=min(f[i][1],l[j][p[j][f[i^(1<<j)][1]-1]][0]);\n\t\t\t}\n\t\t}\n\t}\n\ttp-=2;\n\tfor (int i=2;i<=tp;i+=2) {\n\t\tfor (int j=1;j<=cnt[1];++j) {\n\t\t\tif (f[i][0]+1>=l[0][j][0]&&f[i^tp][1]-1<=l[0][j][1]) b[j]=1;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\t printf(b[p[0][i]]?\"Possible\\n\":\"Impossible\\n\");\n\t}\n//\tfor (int i=2;i<=tp;i+=2) printf(\"%d %d\\n\",f[i][0],f[i][1]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010;\nint n, m, a[N];\nint lb[20][N], rb[20][N], cnt;\nint fl[1058576], fr[1058576], mx, s[N];\n\nvoid init() {\n\tlb[cnt][1] = 1;\n\tfor(int i = 2; i <= n; i++) lb[cnt][i] = (a[i] - a[i - 1] > m) ? i : lb[cnt][i - 1];\n\trb[cnt][n] = n;\n\tfor(int i = n - 1; i; i--) rb[cnt][i] = (a[i + 1] - a[i] > m) ? i : rb[cnt][i + 1];\n\tlb[cnt][0] = 1, rb[cnt][n + 1] = n;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tfor(; m; m /= 2) init(), ++cnt; init();\n\tfr[0] = n + 1, mx = (1 << cnt) - 1;\n\tfor(int i = 1; i <= mx; i++) {\n\t\tfr[i] = n;\n\t\tfor(int j = 0; j < cnt; j++) if(i & (1 << j)) {\n\t\t\tfl[i] = max(fl[i], rb[j + 1][fl[i ^ (1 << j)] + 1]);\n\t\t\tfr[i] = min(fr[i], lb[j + 1][fr[i ^ (1 << j)] - 1]);\n\t\t}\n\t}\n\tfor(int i = 0; i <= mx; i++)\n\t\t++s[lb[0][fr[mx ^ i] - 1]], --s[rb[0][fl[i] + 1] + 1];\n\tfor(int i = 1; i <= n; i++)\n\t\ts[i] += s[i - 1], puts(s[i] ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 200005\n#define MAXM 20\n#define MAXK (1<<MAXM)\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\n#define prev daksiisaas\n#define next aijdkjsaod\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\nint N,V,x[MAXN];\nvector<int> v;\nint prev[MAXN][MAXM],next[MAXN][MAXM];\nint predp[MAXK],sufdp[MAXK];\nint mini[MAXN];\nint main()\n{\n    scanf(\"%d%d\",&N,&V);\n    for(int i=1;i<=N;i++) scanf(\"%d\",&x[i]);\n    int dummy=V;\n    while(dummy)\n    {\n        v.push_back(dummy);\n        dummy/=2;\n    }\n    v.push_back(0);\n    reverse(v.begin(),v.end());\n    int sz=(int)v.size();\n    for(int i=(int)v.size()-1;i>=0;i--) next[N][i]=N;\n    for(int i=N-1;i>=0;i--)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i+1]-x[i]>v[j]) next[i][j]=i; else next[i][j]=next[i+1][j];\n    for(int i=(int)v.size()-1;i>=0;i--) prev[1][i]=1;\n    for(int i=2;i<=N;i++)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i]-x[i-1]>v[j]) prev[i][j]=i; else prev[i][j]=prev[i-1][j];\n    //for(int i=1;i<=N;i++) printf(\"%d %d %d %d\\n\",prev[i][1],prev[i][2],next[i][1],next[i][2]);\n    memset(predp,0,sizeof(predp));\n    for(int mask=0;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            predp[mask^(1<<j)]=max(predp[mask^(1<<j)],next[min(predp[mask]+1,N)][j]);\n        }\n    }\n    for(int mask=0;mask<(1<<sz);mask++) sufdp[mask]=N+1;\n    for(int mask=0;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            sufdp[mask^(1<<j)]=min(sufdp[mask^(1<<j)],prev[max(sufdp[mask]-1,1)][j]);\n        }\n    }\n    for(int i=0;i<=N+1;i++) mini[i]=N+2; \n    for(int mask=0;mask<(1<<(sz-1));mask++)\n    {\n        int dmask=(1<<(sz-1))-1-mask;\n        int l=predp[mask],r=sufdp[dmask];\n        mini[l]=min(mini[l],r);\n    }\n    for(int i=N;i>=0;i--) mini[i]=min(mini[i],mini[i+1]);\n    for(int i=1;i<=N;i++)\n    {\n        int l=prev[i][sz-1],r=next[i][sz-1];\n        if(l==1&&r==N) {puts(\"Possible\"); continue;}\n        //printf(\"%d %d\\n\",l,r);\n        if(mini[l-1]<=r+1) puts(\"Possible\"); else puts(\"Impossible\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint x[252521];\nint ne[252521][20],rne[252521][20];\nint dp[(1<<20)+10],rdp[(1<<20)+10];\nvector<int> v;\nint main()\n{\n\tint n,V;\n\tcin>>n>>V;\n\trep(i,n) cin>>x[i];\n\twhile(V>0){\n\t\tv.pb(V);V/=2;\n\t}\n\tv.pb(0);int m=v.size();\n\trep(i,n) rep(j,m){\n\t\trne[i][j]=i;\n\t\tif(i>0 && x[i]-x[i-1]<=v[j]) rne[i][j]=rne[i-1][j];\n\t}\n\tfor(int i=n-1;i>=0;i--) rep(j,m){\n\t\tne[i][j]=i;\n\t\tif(i<n-1 && x[i+1]-x[i]<=v[j]) ne[i][j]=ne[i+1][j];\n\t}\n\tmemset(dp,0,sizeof(dp));\n\trep(i,(1<<20)+5) rdp[i]=n-1;\n\trep(i,(1<<m)) rep(j,m){\n\t\tif((i&(1<<j))>0) continue;\n\t\tdp[i+(1<<j)]=max(dp[i+(1<<j)],ne[dp[i]][j]+1);\n\t\trdp[i+(1<<j)]=min(rdp[i+(1<<j)],rne[rdp[i]][j]-1);\n\t}\n\t//rep(i,(1<<m)) cout<<i<<' '<<dp[i]<<' '<<rdp[i]<<endl;\n\tif(dp[(1<<m)-1]<n || rdp[(1<<m)-1]>=0){\n\t\tassert(dp[(1<<m)-1]<n && rdp[(1<<m)-1]>=0)\n\t\trep(i,n) cout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tint now=0;\n\twhile(now<n){\n\t\tint f=0;\n\t\trep(i,(1<<(m-1))){\n\t\t\tif(dp[(1<<m)-2-(i<<1)]>=now && rdp[(i<<1)]<=ne[now][0]) f=1;\n\t\t}\n\t\tREP(i,now,ne[now][0]+1){\n\t\t\tif(f>0) cout<<\"Possible\"<<endl;\n\t\t\telse cout<<\"Impossible\"<<endl;\n\t\t}\n\t\tnow=ne[now][0]+1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pb2 pop_back\n#define pf2 pop_front\n#define rep(k,i,j) for(int k = (int) i;k<(int)j;k++)\n#define repd(k,i,j) for(int k = (int)i;k>=(int)j;k--)\n#define line puts(\"\")\n#define ll long long\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e17;\n\nusing namespace std;\n\nconst int maxn= 2e5+5;\nint n,m,lvl;\nint arr[maxn];\n\n\n#define piii pair<int,pii>\nvector<vector<piii> > seg;\n\nint par[maxn*20];\n\nvector<int> adj[20*maxn];\nint sz[maxn*20],deg[maxn*20];\n\nint cmp(int a,int b){\n\tif(deg[a]==deg[b])return sz[a]>sz[b];\n\treturn deg[a]>deg[b];\n}\n\n\nint ans[maxn],dp[maxn];\n\nint solve(vector<int> tmp,int remaining){\n\tint expand = 0;\n\trep(k,0,tmp.size())expand += deg[tmp[k]];\n\t\n\t//printf(\"solve %d : \",remaining);rep(k,0,tmp.size())printf(\"%d \",tmp[k]);line;\n\tif(expand>remaining)return 0;\n\tif(tmp.size()==0)return 1;\n\t\n\tvector<int> nxt;\n\tfor(int i : tmp)for(int j : adj[i])nxt.pb(j);\n\t\n\tsort(nxt.begin(),nxt.end(),cmp);\n\tvector<int> cur = nxt;\n\trep(k,0,nxt.size()){\n\t\tswap(cur[k],cur.back());cur.pb2();\n\t\tif(solve(cur,remaining-1))return 1;\n\t\tcur.pb(nxt[k]);\n\t\tswap(cur[k],cur.back());\n\t}\n\t\n\treturn 0;\n}\nvoid dfs(int a,int build){\n\t\n\tif(build){\n\t\tsz[a] = 1;\n\t\tdeg[a] = adj[a].size();\n\t\tfor(int b : adj[a]){\n\t\t\tdfs(b,1);\n\t\t\tsz[a] += sz[b];\n\t\t}\n\t\treturn;\n\t}\n\t\n\tif(a==n){\n\t\t\n\t\tif(adj[a].size()<=lvl){\n\t\t\tvector<int> now = adj[a];\n\t\t\t\n\t\t\trep(k,0,now.size()){\n\t\t\t\tvector<int> tmp;\n\t\t\t\trep(i,0,now.size())if(k!=i)tmp.pb(now[i]);\n\t\t\t\tdp[k] = solve(tmp,lvl-1);\n\t\t\t}\n\t\t}\n\t}\n\t\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(k,0,n)scanf(\"%d\",&arr[k]);\n\t\n\tvector<int> cur;\n\twhile(m){\n\t\tcur.pb(m);\n\t\tm/=2;\n\t}\n\tcur.pb(0);\n\tlvl = cur.size();\n\t\n\tint hit = 0;\n\trep(k,0,cur.size()){\n\t\tvector<piii> tmp;\n\t\trep(i,0,n){\n\t\t\tint j = i+1;\n\t\t\twhile(j!=n && arr[j]-arr[j-1]<=cur[k])j++;\n\t\t\t\n\t\t\ttmp.pb(mp(hit++,mp(i,j-1)));i = j-1;\n\t\t}\n\t\tseg.pb(tmp);\n\t\t\n\t\t\t//rep(i,0,tmp.size())printf(\"(%d %d mo %d) \",tmp[i].se.fi,tmp[i].se.se,tmp[i].fi);line;\n\t\tif(k){\n\t\t\tint j = 0;\n\t\t\trep(i,0,seg[k].size()){\n\t\t\t\tpii now = seg[k][i].se;\n\t\t\t\t\n\t\t\t\twhile(j<seg[k-1].size()){\n\t\t\t\t\tpii parn = seg[k-1][j].se;\n\t\t\t\t\tif(parn.fi<=now.fi && now.se<= parn.se)break;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tpar[seg[k][i].fi] = seg[k-1][j].fi;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint N = n;\n\tm = seg[0].size();\n\tn = hit;\n\t\n\t//printf(\"hore\\n\");\n\trep(k,m,n)adj[par[k]].pb(k);//,printf(\"%d -> %d\\n\",par[k],k);\n\t\n\trep(k,0,m)adj[n].pb(k);\n\t\n\tdfs(n,1);\n\tdfs(n,0);\n\t\n\trep(k,0,m){\n\t\trep(i,seg[0][k].se.fi,seg[0][k].se.se+1)ans[i] = dp[k];\n\t}\n\trep(k,0,N)printf(\"%s\\n\",ans[k]?\"Possible\":\"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\nusing namespace std;\nint n,m,p,x[20],a[200010],l[200010][20],r[200010][20],f[300000],g[300000],w[200010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&a[i]);\n\tx[0]=m;\n\twhile(x[p])\n\t  x[++p]=x[p-1]/2;\n\tfor(i=0;i<=p;i++)\n\t  {\n       for(j=k=1;j<=n;j++)\n         {\n          if(j>1 && a[j]-a[j-1]>x[i])\n            k=j;\n          l[j][i]=k;\n         }\n       for(j=k=n;j>0;j--)\n         {\n          if(j<n && a[j+1]-a[j]>x[i])\n            k=j;\n          r[j][i]=k;\n         }\n       r[n+1][i]=n+1;\n      }\n    for(i=0;i<(1<<p);i++)\n      g[i]=n+1;\n    for(i=1;i<(1<<p);i++)\n      for(j=1;j<=p;j++)\n        if(i&(1<<j-1))\n          {\n           f[i]=max(f[i],r[f[i^(1<<j-1)]+1][j]);\n           g[i]=min(g[i],l[g[i^(1<<j-1)]-1][j]);\n          }\n    for(i=0;i<(1<<p);i++)\n      {\n       j=l[g[i]-1][0];\n       k=r[f[(1<<p)-1^i]+1][0];\n       if(j<=k)\n         w[j]++,w[k+1]--;\n      }\n    for(i=1,k=0;i<=n;i++)\n      {\n       k+=w[i];\n       if(k)\n         printf(\"Possible\\n\");\n       else\n         printf(\"Impossible\\n\");\n      }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nint goR[200005][20];\nint goL[200005][20];\nint a[200005];\nint R(int x,int k,int v){\n    if(goR[x][k]!=-1)return goR[x][k];\n    if(a[x+1]-a[x]>(v>>k))return goR[x][k]=x;\n    return goR[x][k]=R(x+1,k,v);\n}\nint L(int x,int k,int v){\n    if(goL[x][k]!=-1)return goL[x][k];\n    if(a[x]-a[x-1]>(v>>k))return goL[x][k]=x;\n    return goL[x][k]=L(x-1,k,v);\n}\nint dpR[1<<20];\nint dpL[1<<20];\nint n,v;\nint DPR(int x){\n    if(x==0)return 0;\n    if(dpR[x]!=-1)return dpR[x];\n    dpR[x]=0;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpR[x]=max(dpR[x],R(DPR(x-(1<<i))+1,i,v));\n        }\n    }\n    return dpR[x];\n}\nint DPL(int x){\n    if(x==0)return n+1;\n    if(dpL[x]!=-1)return dpL[x];\n    dpL[x]=1e9+1;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpL[x]=min(dpL[x],L(DPL(x-(1<<i))-1,i,v));\n        }\n    }\n    return dpL[x];\n}\nint main(){ \n    MEMS(goR);MEMS(goL);MEMS(dpR);MEMS(dpL);\n    scanf(\"%d %d\",&n,&v);\n    for(int i = 1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    a[0]=-1e9-1e8;\n    a[n+1]=1e9+1e8;\n    int Max=1;\n    for(int i = 1;;i++){\n        Max=i+1;\n        if(!(v>>i))break;\n    }\n    for(int i = 1;i<=n;){\n        int l=i,r=R(i,0,v);\n       // printf(\"%d %d\\n\",l,r);\n        int ok=0;\n        for(int j=0;j<(1<<Max);j++){\n            int a=j,b=(1<<Max)-j;\n            if(a&1)a--;\n            if(b&1)b--;\n            if(DPR(a)>=l-1&&DPL(b)<=r+1){\n                ok=1;\n                break;\n            }\n        }\n        if(ok){\n            for(int i=l;i<=r;i++)printf(\"Possible\\n\");\n        }\n        else{\n            for(int i = l;i<=r;i++)printf(\"Impossible\\n\");\n        }\n        i=r+1;\n    }\n}\n/*\n2 2 1\n3 2 3\n4 2 4 4 7\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 2e05 + 10;\nconst int MAXL = 20 + 5;\n\nint N, V, lgv = 0;\nint a[MAXN];\nint sec[MAXN]= {0};\n\nint extl[MAXN][MAXL]= {0}, extr[MAXN][MAXL]= {0};\nint f[2][MAXN]= {0};\nbool answer[MAXN]= {false};\nvoid work (int p, int l, int r) {\n\tint n = lgv - 1;\n\tint limit = (1 << n) - 1;\n\tf[p][0] = l - 1;\n\tfor (int state = 1; state <= limit; state ++) {\n\t\tf[p][state] = l - 1;\n\t\tfor (int j = 1; j <= n; j ++)\n\t\t\tif (state & (1 << (j - 1))) {\n\t\t\t\tint pre = f[p][state ^ (1 << (j - 1))];\n\t\t\t\tf[p][state] = max (f[p][state], extr[pre + 1][j]);\n\t\t\t}\n\t}\n}\nvoid solve () {\n\tint n = lgv - 1;\n\tint cnt = 0;\n\tfor (int i = 1; i <= N; i ++) {\n\t\tif (extl[i][lgv] == extl[i - 1][lgv] && extr[i][lgv] == extr[i - 1][lgv]) {\n\t\t\tanswer[i] = answer[i - 1];\n\t\t\tcontinue;\n\t\t}\n\t\tcnt ++;\n\t\tif (cnt > lgv) {\n\t\t\tfor (int j = 1; j <= N; j ++) answer[j] = false;\n\t\t\treturn ;\n\t\t}\n\t\tint pl = extl[i][lgv], pr = extr[i][lgv];\n\t\tif (pl != 1) work (0, 1, pl - 1);\n\t\tif (pr != N) work (1, pr + 1, N);\n\t\tint limit = (1 << n) - 1;\n\t\tif (pl == 1) answer[i] = f[1][limit] >= N;\n\t\telse if (pr == N) answer[i] = f[0][limit] >= pl - 1;\n\t\telse {\n\t\t\tfor (int state = 1; state <= limit; state ++)\n\t\t\t\tif (f[0][state] >= pl - 1 && f[1][limit ^ state] >= N) {\n\t\t\t\t\tanswer[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint getnum () {\n\tint num = 0;\n\tchar ch = getchar ();\n\tbool isneg = false;\n\n\twhile (! isdigit (ch)) {\n\t\tif (ch == '-') isneg = true;\n\t\tch = getchar ();\n\t}\n\twhile (isdigit (ch))\n\t\tnum = (num << 3) + (num << 1) + ch - '0', ch = getchar ();\n\n\treturn isneg ? - num : num;\n}\n\nint main () {\n\tN = getnum (), V = getnum ();\n\tfor (int i = 1; i <= N; i ++)\n\t\ta[i] = getnum ();\n\tfor (int s = V; s > 0; s >>= 1)\n\t\tsec[++ lgv] = s;\n\tsec[++ lgv] = 0;\n\treverse (sec + 1, sec + lgv + 1);\n\tfor (int l = 1; l <= lgv; l ++) {\n\t\textl[0][l] = 1, extr[N + 1][l] = N;\n\t\tfor (int i = 1; i <= N; i ++) {\n\t\t\tif (i == 1) extl[i][l] = 1;\n\t\t\telse extl[i][l] = a[i] - a[i - 1] <= sec[l] ? extl[i - 1][l] : i;\n\t\t}\n\t\tfor (int i = N; i >= 1; i --) {\n\t\t\tif (i == N) extr[i][l] = N;\n\t\t\telse extr[i][l] = a[i + 1] - a[i] <= sec[l] ? extr[i + 1][l] : i;\n\t\t}\n\t}\n\t/*for (int l = 1; l <= lgv; l ++) {\n\t\tcout << \"now: \" << sec[l] << endl;\n\t\tfor (int i = 1; i <= N; i ++)\n\t\t\tcout << extl[i][l] << ' ' << extr[i][l] << endl;\n\t}*/\n\tsolve ();\n\tfor (int i = 1; i <= N; i ++)\n\t\tanswer[i] ? puts (\"Possible\") : puts (\"Impossible\");\n\n\treturn 0;\n}\n\n/*\n3 2\n1 3 6\n*/\n\n/*\n7 2\n-10 -4 -2 0 2 4 10\n*/\n\n/*\n16 19\n-49 -48 -33 -30 -21 -14 0 15 19 23 44 52 80 81 82 84\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 200010;\nint n, V, a[maxn], L[maxn][20], R[maxn][20];\nint d[20], fl[1 << 18], fr[1 << 18], ans[maxn];\n\nint main() {\n    scanf(\"%d %d\", &n, &V);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    int m = (int)log2(V) + 1;\n    for (int i = 0; i <= m; i++) {\n        d[i] = V >> i;\n    }\n    for (int i = 0; i <= m; i++) {\n        L[0][i] = L[1][i] = 1;\n        R[n][i] = R[n + 1][i] = n;\n        for (int j = 2; j <= n; j++) {\n            L[j][i] = a[j] - a[j - 1] <= d[i] ? L[j - 1][i] : j;\n        }\n        for (int j = n - 1; j; j--) {\n            R[j][i] = a[j + 1] - a[j] <= d[i] ? R[j + 1][i] : j;\n        }\n    }\n    for (int i = 0; i < 1 << m; i++) {\n        fr[i] = n + 1;\n        for (int j = 0; j < m; j++) if (i >> j & 1) {\n            fl[i] = max(fl[i], R[fl[i ^ (1 << j)] + 1][j + 1]);\n            fr[i] = min(fr[i], L[fr[i ^ (1 << j)] - 1][j + 1]);\n        }\n    }\n    for (int i = 0; i <= n + 1; i++) {\n        ans[i] = n + 2;\n    }\n    for (int i = 0; i < 1 << m; i++) {\n        ans[fl[i]] = min(ans[fl[i]], fr[i ^ ((1 << m) - 1)]);\n    }\n    for (int i = n; ~i; i--) {\n        ans[i] = min(ans[i], ans[i + 1]);\n    }\n    for (int i = 1; i <= n; i++) {\n        if (ans[L[i][0] - 1] <= R[i][0] + 1) printf(\"Possible\\n\");\n        else printf(\"Impossible\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int N = 200005;\n\ninline void gi(int &x){\n\tint f = 1; x = 0; char c = getchar();\n\twhile(c < '0' || c > '9'){\n\t\tif(c == '-')f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9'){\n\t\tx = x * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tx *= f;\n}\nint n, v, a[N], vis[N], ans[N];\nint walk(int st, int vv){\n\tint i, j; vis[st] = j = 1;\n\tfor(i = st; i > 1 && !vis[i - 1] && a[i] - a[i - 1] <= vv; vis[-- i] = 1, j ++);\n\tfor(i = st; i < n && !vis[i + 1] && a[i + 1] - a[i] <= vv; vis[++ i] = 1, j ++);\n\treturn j;\n}\nbool check(int st){\n\tint i, j, k, tv = v, id, las;\n\tfor(i = 1; i <= n; i ++)\n\t\tvis[i] = 0;\n\tk = walk(st, v), las = v, tv >>= 1;\n\twhile(1){\n\t\tfor(i = 1, j = 0; i < n; i ++)\n\t\t\tif(!vis[i] && !vis[i + 1] && a[i + 1] - a[i] <= tv)\n\t\t\t\tif(a[i + 1] - a[i] >= j)\n\t\t\t\t\tid = i, j = a[i + 1] - a[i];\n\t\tif(j == 0){tv = las; break;}\n\t\tlas = tv, tv >>= 1, k += walk(id, las);\n\t}\n\tif(k == n || (1 << n - k - 1) <= las)\n\t\treturn 1;\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k = 0; gi(n), gi(v);\n\tfor(i = 1; i <= n; i ++)gi(a[i]);\n\tfor(i = 1; i <= n; i = j + 1){\n\t\tk ++;\n\t\t//int flag = ans[i] = check(i);\n\t\tfor(j = i; j < n && a[j + 1] - a[j] <= v; j ++);\n\t\t\t//ans[++ j] = flag;\n\t}\n\tif((1 << k - 2) <= v){\n\t\tfor(i = 1; i <= n; i = j + 1){\n\t\t\tint flag = ans[i] = check(i);\n\t\t\tfor(j = i; j < n && a[j + 1] - a[j] <= v; )\n\t\t\t\tans[++ j] = flag;\n\t\t}\n\t}\t\n\tfor(i = 1; i <= n; i ++)\n\t\tputs(ans[i] ? \"Possible\" : \"Impossible\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint l[20][530000],r[20][530000],f[500010],g[530000],mi[530000],x[530000];\nint main()\n{\n\tint n,v,lim=0;scanf(\"%d%d\",&n,&v);while (v>>(lim+1)) lim++;lim++;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor (int p=0;p<=lim;p++)\n\t{\n\t\tl[p][0]=1;for (int i=1;i<=n;i++) l[p][i]=(x[i]-x[i-1]<=(v>>p))?l[p][i-1]:i;\n\t\tr[p][n+1]=n;for (int i=n;i>=1;i--) r[p][i]=(x[i+1]-x[i]<=(v>>p))?r[p][i+1]:i;\n\t}\n\tfor (int s=0;s<(1<<(lim+1));s++) g[s]=n+1;\n\tfor (int s=0;s<(1<<(lim+1));s++)\n\tfor (int i=0;i<=lim;i++) if (!(s&(1<<i)))\n\t{\n\t\tf[s|(1<<i)]=max(f[s|(1<<i)],r[i][f[s]+1]);\n\t\tg[s|(1<<i)]=min(g[s|(1<<i)],l[i][g[s]-1]);\n\t}\n\tfor (int i=0;i<=n;i++) mi[i]=n+2;\n\tfor (int i=0;i<(1<<(lim+1));i+=2) mi[f[i]]=min(mi[f[i]],g[(1<<(lim+1))-2-i]);\n\tfor (int i=1;i<=n;i++) puts((mi[l[0][i]-1]<=r[0][i]+1)?\"Possible\":\"Impossible\");\n\t//for (int i=1;i<=n;i++) printf(\"%d %d %d\\n\",l[0][i],r[0][i],mi[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define sz size\n#define eps 1e-7\n#define fod find_by_order\n#define fastio ios::base_sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\n#define ofk order_of_key\n#define val(x) cout << \"Value dari \"<< #x << \" adalah \" << x  << \"\\n\"\n#define tr tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>\ntypedef long long ll;\nusing namespace __gnu_pbds;\nusing namespace std;\n\nvoid readf(string x){\n\tfreopen((x+\".in\").c_str(),\"r\",stdin);\n\tfreopen((x+\".out\").c_str(),\"w\",stdout);\n}\n\n\nint read()\n{\n\tbool min = 0;\n\tint  result = 0;\n\tchar ch;\n\tch = getchar();\n\twhile(1)\n\t{\n\t\tif(ch == '-') break;\n\t\tif(ch >='0' && ch <= '9') break;\n\t\tch = getchar();\n\t}\n\tif(ch == '-') min = 1;else result = ch-'0';\n\twhile(1)\n\t{\n\t\tch =getchar();\n\t\tif(ch< '0' || ch>'9') break;\n\t\tresult = result * 10 + (ch-'0');\n\t}\n\tif(min) return -result;\n\treturn result;\n}\n#define n 200005\nint x[n],R[20][n],L[20][n],kiri[(1<<20)],kanan[(1<<20)];\n\nint main(){\n\tint N,V;\n\tcin >> N >> V;\n\tint po = 0;\n\tint tmp = V;\n\twhile(tmp) tmp/=2,po++;\n\t\n\t\n\tfor(int i=1;i<=N;i++) cin >> x[i];\n\ttmp = V/2;\n\tfor(int i=0;i<po;i++){\n\t//\ttmp = V/2;\n\t\tfor(int j=1;j<=N;j++){\n\t\t\tL[i][j] = j;\n\t\t\tif(j == 1) continue;\n\t\t\tif(x[j] - x[j-1] <= tmp) L[i][j] = L[i][j-1];\n\t//\t\tcout << L[i][j] << \" \" << i << \" \" << j << \"\\n\";\n \t\t}\n\t\ttmp /=2;\n\t}\n\ttmp = V/2;\n\tfor(int i=0;i<po;i++){\n//\t\ttmp = V;\n\t\tfor(int j=N;j>=1;j--){\n\t\t\tR[i][j] = j;\n\t\t\tif(j == N) continue;\n\t\t\tif(x[j+1] - x[j] <= tmp) R[i][j] = R[i][j+1];\n\t\t}\n\t\ttmp /=2;\n\t}\n\tint i = po;\n\tfor(int j=N;j>=1;j--){\n\t\tR[i][j] = j;\n\t\tif(j == N) continue;\n\t\tif(x[j+1] - x[j] <= V) R[i][j] = R[i][j+1];\n\t}\n\tfor(int j=1;j<=N;j++){\n\t\tL[i][j] = j;\n\t\tif(j == 1) continue;\n\t\tif(x[j] - x[j-1] <= V) L[i][j] = L[i][j-1];\n\t}\n\tmemset(kiri,0,sizeof kiri);\n\tfor(int i=0;i<(1<<po);i++) kanan[i] = N  + 1;\n\tfor(int i=0;i<(1<<po);i++){\n\t\tfor(int j=0;j<po;j++){\n\t\t\tif(i & (1 << j)){ \n\t\t\t\tint l = kiri[i^(1<<j)];\n\t\t\t\tkiri[i] = max(kiri[i],R[j][l+1]);\n\t\t\t\tint r = kanan[i^(1<<j)];\n\t\t\t\tkanan[i] = min(kanan[i],L[j][r-1]);\n\t\t//\t\tcout << i << \" \" << kiri[i] <<\" \" << kanan[i]<< \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint dp[n];\n\tfor(int i=0;i<n;i++) dp[i] = 1e9;\n\tfor(int i=0;i<(1<<po);i++){\n\t\tint l = ((1 << po) - 1) ^ i;\n\t\tdp[kiri[i]] = min(dp[kiri[i]],kanan[l]);\n\t//;;\tcout << dp[kiri[i]] << \"\\n\"; \n\t}\n\tfor(int i=N;i>=0;i--){\n\t\tdp[i] = min(dp[i],dp[i+1]);\n\t//\tcout << dp[i] << \"\\n\";\n\t}\n\tint ki=0,ka = 2;\n\tfor(int i=1;i<=N;i++){\n\t\tka = max(ka,i+1);\n\t\twhile(ka <= N && x[ka] - x[ka-1] <= V) ka++; \n\t\tif(x[i] - x[i-1] > V) ki = i-1;\n\t//\tcout << ki << \" \" << ka << \"\\n\";\n\t\tif(dp[ki] <= ka) cout << \"Possible\\n\";\n\t\telse cout << \"Impossible\\n\";\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=1e5+50;\nint n,v,lg,x[N];\nint len[20], bin[20];\nint mxr[1<<20], mnl[1<<20];\n\nstruct BIT_MAX {\n\tint bit[N];\n\tBIT_MAX() {for(int i=0;i<N;i++) bit[i]=-1e9;}\n\tinline void inc(int p,int v) {\n\t\tfor(int i=p;i<=n+1;i+=(i&(-i))) bit[i]=max(bit[i],v);\n\t}\n\tinline int ask(int p,int v=-1e9) {\n\t\tfor(int i=p;i;i-=(i&(-i))) v=max(v,bit[i]);\n\t\treturn v;\n\t}\n\tinline void init(int lim) {\n\t\tfor(int l=1,r;l<=n;l=r+1) {\n\t\t\tr=l;\n\t\t\twhile(r<n && x[r+1]-x[r]<=lim) ++r;\n\t\t\tinc(l,r);\n\t\t}\n\t}\n} bit_max[21];\n\nstruct BIT_MIN {\n\tint bit[N];\n\tBIT_MIN() {for(int i=0;i<N;i++) bit[i]=1e9;}\n\tinline void inc(int p,int v) {\n\t\tfor(int i=p;i;i-=(i&(-i))) bit[i]=min(bit[i],v);\n\t}\n\tinline int ask(int p,int v=1e9) {\n\t\tif(!p) ++p;\n\t\tfor(int i=p;i<=n;i+=(i&(-i))) v=min(v,bit[i]);\n\t\treturn v;\n\t}\n\tinline void init(int lim) {\n\t\tfor(int l=1,r;l<=n;l=r+1) {\n\t\t\tr=l;\n\t\t\twhile(r<n && x[r+1]-x[r]<=lim) ++r;\n\t\t\tinc(r,l);\n\t\t}\n\t}\n} bit_min[20];\n\nint ok[N];\nint main() {\n\tn=rd(), v=rd();\n\tfor(int i=1;i<=n;i++) x[i]=rd();\n\t\n\tfor(int t=v;;t/=2) {\n\t\tlen[lg++]=t;\n\t\tif(!t) break;\n\t}\n\tfor(int i=0;i<lg;i++) {\n\t\tbin[i]=1<<i;\n\t\tbit_max[i].init(len[i]);\n\t\tbit_min[i].init(len[i]);\n\t} \n\t\n\tmxr[0]=0; mnl[0]=n+1; bin[lg]=1<<lg;\n\tfor(int s=1;s<bin[lg];++s) {\n\t\tif(s&1) continue;\n\t\tint mx=0, mn=n+1;\n\t\tfor(int k=0;k<lg;++k) if(s&bin[k]) {\n\t\t\tmx=max(mx,bit_max[k].ask(mxr[s^bin[k]]+1));\n\t\t\tmn=min(mn,bit_min[k].ask(mnl[s^bin[k]]-1));\n\t\t}\n\t\tmxr[s]=mx; mnl[s]=mn;\n\t}\n\t\n\tfor(int i=0;i<bin[lg];++i) {\n\t\tif(!(i&1)) {\n\t\t\tint s1=i, s2=(bin[lg]-1)^1^i;\n\t\t\tbit_max[20].inc(mnl[s2],mxr[s1]);\n\t\t}\n\t}\n\tfor(int l=1,r;l<=n;l=r+1) {\n\t\tr=l;\n\t\twhile(r<n && x[r+1]-x[r]<=v) ++r;\n\t\tif(bit_max[20].ask(r+1)>=l-1) for(int i=l;i<=r;i++) ok[i]=1;\n\t}\n\tfor(int i=1;i<=n;i++) puts((ok[i]) ? \"Possible\" : \"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint n,V,x[200001],logv;vector<int> v;bool ans[200001];\nint cal(int x){int ans=0;while(x)x>>=1,++ans;return ans;}\nbool walk(vector<int> &v,int s)\n{\n\tint n=v.size();//printf(\"walk({\");for(int i=0;i<n;++i){printf(\"%d\",v[i]);if(i!=n-1)putchar(',');}printf(\"},%d)\\n\",s);\n\tif(n==1||!n)return true;\n\tint k=cal(s);bool flg=false;int st=0,cnt=1;\n\tfor(int i=1;i<n;++i)if(v[i]-v[i-1]>s)++cnt;if(cnt>k+1)return false;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tif(v[i]-v[i-1]>s)\n\t\t{\n\t\t\tvector<int> tmp=v;tmp.erase(tmp.begin()+st,tmp.begin()+i);\n\t\t\tif(walk(tmp,s>>1))return true;st=i;\n\t\t}\n\t}\n\tvector<int> tmp=v;tmp.erase(tmp.begin()+st,tmp.end());if(walk(tmp,s>>1))return true;\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&V);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);for(int i=1;i<=n;++i)v.push_back(x[i]);\n\tint st=0,cnt=1,k=cal(n);\n\tfor(int i=1;i<n;++i)if(v[i]-v[i-1]>V)++cnt;if(cnt>k+1){for(int i=1;i<=n;++i)printf(\"Impossible\\n\");return 0;}\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tif(v[i]-v[i-1]>V)\n\t\t{\n\t\t\tvector<int> tmp=v;tmp.erase(tmp.begin()+st,tmp.begin()+i);\n\t\t\tif(walk(tmp,V>>1)){for(int j=st;j<i;++j)ans[j+1]=true;}st=i;\n\t\t}\n\t}\n\tvector<int> tmp=v;tmp.erase(tmp.begin()+st,tmp.end());if(walk(tmp,V>>1)){for(int j=st;j<n;++j)ans[j+1]=true;}\n\tfor(int i=1;i<=n;++i)printf(ans[i]?\"Possible\\n\":\"Impossible\\n\");return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 2e5 + 10;\n\nint n, v, m, ans[N];\nint a[N], b[N], L[N][22], R[N][22], f[N << 3], g[N << 3];\n\nbool ask(int u)\n{\n    return ans[L[u][0] - 1] <= R[u][0] + 1;\n}\n\nint main()\n{\n    n = read(), v = read();\n    for (int i = 1; i <= n; i++) a[i] = read();\n    for (m = 0; v; v >>= 1, m++)\n    {\n        L[0][m] = L[1][m] = 1;\n        for (int j = 2; j <= n; j++)\n            L[j][m] = a[j] - a[j - 1] <= v ? L[j - 1][m] : j;\n        R[n + 1][m] = R[n][m] = n;\n        for (int j = n - 1; j >= 1; j--)\n            R[j][m] = a[j + 1] - a[j] <= v ? R[j + 1][m] : j;\n    }\n    for (int i = 1; i <= n; i++) L[i][m] = R[i][m] = i;\n    for (int i = 0; i < (1 << m); i++) g[i] = n + 1;\n    for (int i = 0; i < (1 << m); i++)\n        for (int j = 0; j < m; j++)\n            if (!(i >> j & 1))\n            {\n                f[i | (1 << j)] = max(f[i | (1 << j)], R[f[i] + 1][j + 1]);\n                g[i | (1 << j)] = min(g[i | (1 << j)], L[g[i] - 1][j + 1]);\n            }\n    for (int i = 0; i <= n; i++) ans[i] = 2e9;\n    for (int i = 0; i < (1 << m); i++)\n        ans[f[i]] = min(ans[f[i]], g[((1 << m) - 1) ^ i]);\n    for (int i = n - 1; i >= 1; i--)\n        ans[i] = min(ans[i], ans[i + 1]);\n    for (int i = 1; i <= n; i++) puts(ask(i) ? \"Possible\" : \"Impossible\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint mx,n,m,hh,now,flag,i,j,la,pr[21][200010],a[200010],f[500001],g[500001],aa[500001],nt[21][200001];\n/*void solve(int l,int r,int hh){\n\tif(sum[c[hh]][r]-sum[c[hh][l-1]]>)\n}*/\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tnow=m;\n\tm=0;\n\tm=-1;\n\twhile(now){\n\t\taa[++m]=now;\n\t\tnow/=2;\n\t}\n\taa[++m]=0;\n\t//printf(\"%d\\n\",aa[0]);\n\tfor(i=0;i<=m/2;i++)swap(aa[i],aa[m-i]);\n\tfor(j=0;j<=m;j++){\n\t\tla=n;\n\t\tnt[j][n]=n;\n\t\tfor(i=n-1;i>=1;i--){\n\t\t\tif(a[i+1]-a[i]>aa[j]){\n\t\t\t\tla=i;\n\t\t\t\tnt[j][i]=i;\n\t\t\t\t/*fa[j][i]=i;\n\t\t\t\tla=i;\n\t\t\t\tpr[j][i]=la;\n\t\t\t\tnt[j][la]=i*/;\n\t\t\t}\n\t\t\t else nt[j][i]=la;\n\t\t}\n\t\tla=1;\n\t\tpr[j][1]=1;\n\t\tfor(i=2;i<=n;i++)if(a[i]-a[i-1]>aa[j]){\n\t\t\tla=i;\n\t\t\tpr[j][i]=i;\n\t\t}\n\t\t else pr[j][i]=la;\n\t}\n\t//puts(\"-1\");\n\tmx=1<<m+1;\n\tm++;\n\t//printf(\"%d\\n\",m);\n\tfor(i=0;i<mx-1;i++){\n\t\tnow=f[i]+1;\n\t\t//printf(\"%d %d\\n\",i,f[i]);\n\t\tfor(j=0;j<m;j++)if(!(i&(1<<j))){\n\t\t\thh=i|(1<<j);\n\t\t\tif(now>n)f[hh]=n;\n\t\t\t else f[hh]=max(f[hh],nt[j][now]);\n\t\t}\n\t}\n\tfor(i=0;i<mx;i++)g[i]=n+1;\n\tfor(i=0;i<mx-1;i++){\n\t\tnow=g[i]-1;\n\t\tfor(j=0;j<m;j++)if(!(i&(1<<j))){\n\t\t\thh=i|(1<<j);\n\t\t\tif(now<1)g[hh]=1;\n\t\t\t else g[hh]=min(g[hh],pr[j][now]);\n\t\t}\n\t}\n\tla=1;\n\t//printf(\"-1 %d\\n\",m);\n\twhile(la<=n){\n\t\t//printf(\"%d\\n\",la);\n\t\tnow=la;\n\t\tflag=0;\n\t\twhile(now<=n&&pr[m-1][now]==la){\n\t\t now++;\n\t\t //printf(\"%d\\n\",now);\n\t}\n\t    now--;\n\t\tfor(i=0;i<mx;i++)if(!(i&(1<<m-1))){\n\t\t\tj=((mx-1)^(1<<m-1))^i;\n\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\tif(f[i]>=la-1&&g[j]<=now+1){\n\t\t\t\tflag=1;break;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t   for(i=la;i<=now;i++)puts(\"Possible\");\t\n\t\t}\n\t\t else{\n\t\t \tfor(i=la;i<=now;i++)puts(\"Impossible\");\n\t\t }\n\t\tla=now+1;\n\t}\n\t/*for(i=1;i<mx;i++){\n\t\tnow=i;cnt=-1;\n\t\twhile(now){\n\t\t\tnow/=2;\n\t\t\tcnt++;\n\t\t}\n\t\tc[i]=cnt;\n\t}\n\tsolve(1,n,mx);*/\n}\n/*\n考虑最后走过的区间肯定只有log段，那么我们就状压表示从左到右（和从右到左）用了哪些段能走到的最远距离 \n*/"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#define OK puts(\"Possible\")\n#define NO puts(\"Impossible\")\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\nconst int N = 200500;\nint f[N<<1][24], n, v;\nint x[N], R[N][24], D[100], LG;\nvector<int> to;\n\ninline int T(int x) { return 1 << x; }\ninline void Mx(int &x, int y) { y > x && (x = y); }\n\nint main() {\n\tread(n), read(v);\n\tfor (int i = 1;i <= n; i++) read(x[i]);\n\twhile (v) D[LG++] = v, v >>= 1; LG++;\n\tfor (int i = 0;i < LG; i++) {\n\t\tR[n+1][i] = R[n][i] = n;\n\t\tif (i == 0) to.push_back(n);\n\t\tfor (int j = n - 1;j >= 1; j--)\n\t\t\tif (x[j+1] - x[j] <= D[i]) R[j][i] = R[j+1][i];\n\t\t\telse {\n\t\t\t\tR[j][i] = j; if (i == 0) to.push_back(j);\n\t\t\t}\n\t}\n\tif (to.size() > LG) { for (int i = 1;i <= n; i++) NO; return 0; }\n\tif (to.size() == 1) { for (int i = 1;i <= n; i++) OK; return 0; }\n\tLG--; int all = (1 << LG) - 1;\n\tfor (int i = 0;i <= all; i++) {\n\t\tfor (int j = 0;j < to.size(); j++) {\n\t\t\tif (R[f[i][j]+1][0] == to[j]) f[i][j] = to[j];\n\t\t\tfor (int k = 1;k <= LG; k++) {\n\t\t\t\tif (i & T(k-1)) continue;\n\t\t\t\tMx(f[i | T(k-1)][j], R[f[i][j]+1][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint block = to.size() - 1;\n\tfor (int i = 1;i <= n; i++) {\n\t\tf[all][block] == n ? OK : NO;\n\t\tif (to[block] == i) block--;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010;\nint n, m, a[N];\nint lb[20][N], rb[20][N], cnt;\nint fl[1058576], fr[1058576], mx, s[N];\n\nvoid init() {\n\tlb[cnt][1] = 1;\n\tfor(int i = 2; i <= n; i++) lb[cnt][i] = (a[i] - a[i - 1] > m) ? i : lb[cnt][i - 1];\n\trb[cnt][n] = n;\n\tfor(int i = n - 1; i; i--) rb[cnt][i] = (a[i + 1] - a[i] > m) ? i : rb[cnt][i + 1];\n\tlb[cnt][0] = 1, rb[cnt][n + 1] = n;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tfor(; m; m /= 2) init(), ++cnt; init();\n\tfr[0] = n + 1, mx = (1 << cnt) - 1;\n\tfor(int i = 1; i <= mx; i++) {\n\t\tfr[i] = n;\n\t\tfor(int j = 0; j < cnt; j++) if(i & (1 << j)) {\n\t\t\tfl[i] = max(fl[i], rb[j + 1][fl[i ^ (1 << j)] + 1]);\n\t\t\tfr[i] = min(fr[i], lb[j + 1][fr[i ^ (1 << j)] - 1]);\n\t\t}\n\t}\n\tfor(int i = 0; i <= mx; i++) {\n\t\tint x = lb[0][fr[mx ^ i] - 1], y = rb[0][fl[i] + 1];\n\t\tif(x <= y) ++s[x], --s[y + 1];\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\ts[i] += s[i - 1], puts(s[i] ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pb2 pop_back\n#define pf push_front\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define rep(k,i,j) for(int k = (int)i;k<(int) j;k++)\n#define repd(k,i,j) for(int k = i;k>=(int)j;k--)\n#define ll long long\n#define pq priority_queue\n\nint dirx[8] = {0,1,0,-1,1,1,-1,-1};\nint diry[8] = {1,0,-1,0,1,-1,1,-1};\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e16;\nconst double EPS = 1e-6;\n\nusing namespace std;\n\nconst int maxn = 2e5+5;\n\nint n,v;\nint loc[maxn];\n\nint jump[maxn][20],m;\n\nint dp[maxn*10];\n\nint ch[maxn*10];\n\nint in_q[maxn*10];\n\nqueue<int> q;\nint solve(){\n\twhile(q.size())q.pop();\n\tmemset(dp,-1,sizeof dp);\n\tmemset(in_q,0,sizeof in_q);\n\t\n\tq.push(1);\n\tdp[1] = ch[0];\n\tin_q[1] = 1;\n\t\n\t\n\twhile(q.size()){\n\t\tint mask = q.front();\n\t\tint a = dp[mask];\n\t\t\n\t\tq.pop();\n\t\tin_q[mask] = 0;\n\t\t\n\t\tif(a==n)return 1;\n\t\trep(k,0,m)if(((1<<k)&mask)==0){\n\t\t\tint b = ch[jump[a][k]];\n\t\t\tint maskb = (mask|(1<<k));\n\t\t\t\n\t\t\tif(dp[maskb]<b){\n\t\t\t\tdp[maskb] = b;\n\t\t\t\tif(!in_q[maskb])q.push(maskb),in_q[maskb] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\t\n\trep(k,0,n)scanf(\"%d\",&loc[k]);\n\t\n\t\n\tfor(;v>=0;v/=2){\n\t\trep(k,0,n){\n\t\t\tint i = k;\n\t\t\twhile(i<n){\n\t\t\t\tif(i<n-1 && loc[i+1]-loc[i]<=v){\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\twhile(k<=i)jump[k++][m] = i+1;\n\t\t\tk = i;\n\t\t}\n\t\t//printf(\"%d \\n\",v);\n\t\tm++;\n\t\tif(v==0)break;\n\t}\n\t\n\tif(m>=20)return 0;\n\t\n\trep(k,0,maxn)ch[k] = k;\n\t\n\tint hit = 0;\n\trep(k,0,n){\n\t\tif(hit>20){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint nxt = jump[k][0];\n\t\t\n\t\thit++;\n\t\tch[k] = nxt;\n\t\tint ret = solve();\n\t\tch[k] = k;\n\t\t\n\t\twhile(k<nxt)printf(\"%s\\n\",ret?\"Possible\":\"Impossible\"),k++;\n\t\tk = nxt-1;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pb2 pop_back\n#define pf push_front\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define rep(k,i,j) for(int k = (int)i;k<(int) j;k++)\n#define repd(k,i,j) for(int k = i;k>=(int)j;k--)\n#define ll long long\n#define pq priority_queue\n\nint dirx[8] = {0,1,0,-1,1,1,-1,-1};\nint diry[8] = {1,0,-1,0,1,-1,1,-1};\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e16;\nconst double EPS = 1e-6;\n\nusing namespace std;\n\nconst int maxn = 5e5+5;\n\nint n,v;\nint loc[maxn];\n\nint jump[maxn][20],m;\n\nint dp[maxn];\n\nint ch[maxn];\n\nint in_q[maxn];\n\nqueue<int> q;\nint solve(){\n\tmemset(dp,-1,sizeof dp);\n\tmemset(in_q,0,sizeof in_q);\n\t\n\tq.push(1);\n\tdp[1] = ch[0];\n\tin_q[1] = 1;\n\t\n\twhile(q.size()){\n\t\tint mask = q.front();\n\t\tint a = dp[mask];\n\t\t\n\t\tq.pop();\n\t\tin_q[mask] = 0;\n\t\t\n\t\tif(a==n)return 1;\n\t\trep(k,0,m)if(((1<<k)&mask)==0){\n\t\t\tint b = ch[jump[a][k]];\n\t\t\tint maskb = (mask|(1<<k));\n\t\t\t\n\t\t\tif(dp[maskb]<b){\n\t\t\t\tdp[maskb] = b;\n\t\t\t\tif(!in_q[maskb])q.push(maskb),in_q[maskb] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\t\n\trep(k,0,n)scanf(\"%d\",&loc[k]);\n\t\n\t\n\tfor(;v>=0;v/=2){\n\t\trep(k,0,n){\n\t\t\tint i = k;\n\t\t\twhile(i<n){\n\t\t\t\tif(i<n-1 && loc[i+1]-loc[i]<=v){\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\twhile(k<=i)jump[k++][m] = i+1;\n\t\t\tk = i;\n\t\t}\n\t\t//printf(\"%d \\n\",v);\n\t\tm++;\n\t\tif(v==0)break;\n\t}\n\t\n\tif(m>=20)return 0;\n\t\n\trep(k,0,maxn)ch[k] = k;\n\t\n\tint hit = 0;\n\trep(k,0,n){\n\t\tif(hit>18){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint nxt = jump[k][0];\n\t\t\n\t\thit++;\n\t\tch[k] = nxt;\n\t\tint ret = solve();\n\t\tch[k] = k;\n\t\t\n\t\twhile(k<nxt)printf(\"%s\\n\",ret?\"Possible\":\"Impossible\"),k++;\n\t\tk = nxt-1;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std ;\n\n#define l first\n#define r second\n\nconst int M = 40 ;\nconst int N = 200010 ;\nconst int MAX = 1000000001 ;\n\nint dep ;\nint maxn ;\nint ans[N] ;\nint n, m, k ;\nint base[N] ;\nint L[M][N] ;\nint R[M][N] ;\nint farfrl[N] ;\nint farfrr[N] ;\npair<int, int> rg[N] ;\n\nvoid Init_dp(){\n\tfor (int j = m ; j >= 0 ; j >>= 1){\n        R[++ dep][n + 1] = n + 1 ;\n        for (int i = 1 ; i <= n ; ++ i)\n            L[dep][i] = (base[i] - base[i - 1] > j) ? i : L[dep][i - 1] ;\n        for (int i = n ; i >= 1 ; -- i)\n            R[dep][i] = (base[i + 1] - base[i] > j) ? i : R[dep][i + 1] ;\n        if (!j) break ;\n    }\n\treturn ;\n}\nvoid Auxiliary_dp(){\n    for (int i = 0 ; i <= maxn ; i += 2)\n        for (int j = 1 ; j <= dep ; ++ j)\n            if (1 << (j - 1) & i){\n                farfrl[i] = max(farfrl[i], R[j][ farfrl[i ^ (1 << (j - 1))] + 1]) ;\n                farfrr[i] = min(farfrr[i], L[j][ farfrr[i ^ (1 << (j - 1))] - 1]) ;\n            }\n\treturn ;\n}\nint main(){\n    cin >> n >> m ;\n    base[0] = -MAX ;\n    base[n + 1] = MAX ; k = -1 ;\n    for (int i = 1 ; i <= n ; ++ i)\n        scanf(\"%d\", &base[i]) ; Init_dp() ;\n    for (int i = 1 ; i <= n ; ++ i)\n        rg[i].l = L[1][i], rg[i].r = R[1][i] ;\n    sort(rg + 1, rg + n + 1) ; maxn = (1 << dep) - 1 ;\n\tfor (int i = 0 ; i <= maxn ; ++ i) farfrr[i] = n + 1 ;\n    k += unique(rg + 1, rg + n + 1) - rg ; Auxiliary_dp() ;\n    for (int i = 1 ; i <= k ; ++ i)\n        for (int j = 0 ; j <= maxn ; j += 2)\n            if (farfrl[j] + 1 >= rg[i].l && farfrr[(maxn ^ j) ^ 1] - 1 <= rg[i].r)\n                { for (int o = rg[i].l ; o <= rg[i].r ; ++ o) ans[o] = 1 ; break ; }\n    for (int i = 1 ; i <= n ; ++ i) puts(ans[i] ? \"Possible\" : \"Impossible\") ; return 0 ;\n}\n/*\n0 8\n0 8\n1 7\n0 8\n1 7\n0 8\n2 6\n0 8\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=200010,SH=18,SN=1<<SH,INF=0x7f7f7f7f;\nint tol[N][SH],tor[N][SH];\nint fl[SN],fr[SN];\nint x[N],v[N];\nint ext[N];\nint main(){\n\tint n=ni,vs=0;\n\tv[0]=ni;\n\tfor(int &i=vs;v[i];i++){\n\t\tv[i+1]=v[i]>>1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tx[i]=ni;\n\t}\n\tfor(int j=0;j<=vs;j++){\n\t\tx[0]=-INF;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ttol[i][j]=x[i]-x[i-1]<=v[j]?tol[i-1][j]:i;\n\t\t}\n\t\tx[n+1]=INF;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\ttor[i][j]=x[i+1]-x[i]<=v[j]?tor[i+1][j]:i;\n\t\t}\n\t}\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tfl[s]=0;\n\t\tfor(int i=1;i<=vs;i++){\n\t\t\tif((s>>(i-1))&1){\n\t\t\t\tapmax(fl[s],tor[fl[s^(1<<(i-1))]+1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tfr[s]=n+1;\n\t\tfor(int i=1;i<=vs;i++){\n\t\t\tif((s>>(i-1))&1){\n\t\t\t\tapmin(fr[s],tol[fr[s^(1<<(i-1))]-1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(ext,127,sizeof(ext));\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tapmin(ext[fl[s]],fr[s^(ts-1)]);\n\t}\n\tfor(int i=n;i>=1;i--){\n\t\tapmin(ext[i-1],ext[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tputs(ext[tol[i][0]-1]<=tor[i][0]+1?\"POSSIBLE\":\"IMPOSSIBLE\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n\n#define INF 0x3f3f3f3f\n#define MAXN 2000005\n#define MAXB 21\n\nusing namespace std;\n\nint v[MAXN], n, m;\nint d[MAXN], up[MAXN][MAXB], down[MAXN][MAXB], pre[1 << MAXB], suf[1 << MAXB];\nint visit[MAXN];\n\nint read() {\n    char c = getchar();\n    int x = 0, s = 1;\n    while (!isdigit(c)) {\n        if (c == '-')\n            s = -1;\n        c = getchar();\n    }\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x * s;\n}\n\nvoid init() {\n    while (v[++m] >= 1)\n        v[m + 1] = v[m] >> 1;\n    d[0] = -INF;\n    d[n + 1] = INF;\n    for (int j = 1; j <= m; ++j) {\n        for (int i = 1; i <= n; ++i)\n            if (d[i] - d[i - 1] <= v[j])\n                up[i][j] = up[i - 1][j];\n            else\n                up[i][j] = i;\n        for (int i = n; i >= 1; --i)\n            if (d[i + 1] - d[i] <= v[j])\n                down[i][j] = down[i + 1][j];\n            else\n                down[i][j] = i;\n    }\n}\n\nvoid solve() {\n    memset(suf, 0x3f, sizeof(suf));\n    memset(pre, -0x3f, sizeof(pre));\n    suf[0] = n + 1;\n    pre[0] = 0;\n    int limit = (1 << m) - 1;\n    for (int s = 0; s <= limit; ++s) {\n        for (int i = 1; i <= m; ++i) {\n            if (s >> (i - 1) & 1)\n                continue;\n            int t = s | (1 << (i - 1));\n            if (pre[s] >= 0)\n                pre[t] = max(pre[t], down[pre[s] + 1][i]);\n            if (suf[s] <= n + 1)\n                suf[t] = min(suf[t], up[suf[s] - 1][i]);\n        }\n    }\n    for (int s = 1; s < limit; ++s) {\n        if (s & 1)\n            continue;\n        int t = limit ^ s;\n        t ^= 1;\n        if (down[pre[s] + 1][1] >= suf[t] - 1) {\n            ++visit[up[pre[s] + 1][1]];\n            --visit[down[pre[s] + 1][1] + 1];\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n        visit[i] = visit[i - 1] + visit[i];\n    for (int i = 1; i <= n; ++i)\n        if (visit[i])\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n}\n\nint main() {\n    n = read();\n    v[1] = read();\n    for (int i = 1; i <= n; ++i)\n        d[i] = read();\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 2e5 + 5;\nconst int K = 19;\nint n;\nint v[K];\nint k;\nint arr[N];\nint nxt[K][N];\nint prv[K][N];\nint dp1[1 << K];\nint dp2[1 << K];\nint pre(int mask){\n\tif(dp1[mask] != -1){\n\t\treturn dp1[mask];\n\t}\n\tint res = 1;\n\tfor(int i = 1 ; i < k ; ++i){\n\t\tif((mask >> i) & 1){\n\t\t\tint tmp = pre(mask ^ (1 << i));\n\t\t\tres = max(res , nxt[i][tmp + 1] - 1);\n\t\t}\n\t}\n\treturn dp1[mask] = res;\n}\nint suf(int mask){\n\tif(dp2[mask] != -1){\n\t\treturn dp2[mask];\n\t}\n\tint res = n;\n\tfor(int i = 1 ; i < k ; ++i){\n\t\tif((mask >> i) & 1){\n\t\t\tint tmp = suf(mask ^ (1 << i));\n\t\t\tres = min(res , prv[i][tmp - 1] + 1);\n\t\t}\n\t}\n\treturn dp2[mask] = res;\n}\nbool solve(int lft , int rgt){\n\tint mask = (1 << k) - 2;\n\tfor(int i = mask ; i ; i = (i - 1) & mask){\n\t\tif(pre(i) >= lft && suf(mask ^ i) <= rgt){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn pre(0) >= lft && suf(mask) <= rgt;\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tscanf(\"%d\" , &v[0]);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tscanf(\"%d\" , arr + i);\n\t}\n\tk = 1;\n\tfor(int i = 1 ; i < K ; ++i){\n\t\tv[i] = v[i - 1] >> 1;\n\t\tif(v[i]){\n\t\t\tk = i + 1;\n\t\t}\n\t}\n\tv[k++] = 0;\n\tfor(int i = 0 ; i < k ; ++i){\n\t\tnxt[i][n] = n + 1;\n\t\tfor(int j = n - 1 ; j >= 1 ; --j){\n\t\t\tif(arr[j + 1] - arr[j] <= v[i]){\n\t\t\t\tnxt[i][j] = nxt[i][j + 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnxt[i][j] = j + 1;\n\t\t\t}\n\t\t}\n\t\tprv[i][1] = 0;\n\t\tint steps = 1;\n\t\tfor(int j = 2 ; j <= n ; ++j){\n\t\t\tif(arr[j] - arr[j - 1] <= v[i]){\n\t\t\t\tprv[i][j] = prv[i][j - 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++steps;\n\t\t\t\tprv[i][j] = j - 1;\n\t\t\t}\n\t\t}\n\t\tif(!i && steps > k + 1){\n\t\t\tfor(int i = 1 ; i <= n ; ++i){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmemset(dp1 , -1 , sizeof(dp1));\n\tmemset(dp2 , -1 , sizeof(dp1));\n\tsolve(10 , 13);\n\tfor(int i = 1 ; i <= n ; i = nxt[0][i]){\n\t\tbool ans = solve(prv[0][i] , nxt[0][i]);\n\t\tfor(int j = i ; j < nxt[0][i] ; ++j){\n\t\t\tputs(ans ? \"Possible\" : \"Impossible\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define F(i,j,n) for(register int i=j;i<=n;i++)\n#define D(i,j,n) for(register int i=j;i>=n;i--)\n#define ll long long\n#define N 200010\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;int f;\n\tchar gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void gi(I&x){\n\t\tfor(f=1,c=gc();c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n};\nusing io::gi;\nusing io::gc;\nint f[N],s[N],nxt[20][N],g[20][N],x[N],n,m,h,v,d,p;\nvoid pre(int v){\n\tif(!v)return;pre(v/2);\n\th=0;d++;\n\tF(i,1,m)\n\t\tif(x[f[i]]>v)f[++h]=f[i];\n\t\telse nxt[d][f[i-1]]=f[i];\n\tm=h;\n//\tF(i,1,m)printf(\"%d \",f[i]);puts(\"\");\n}\nint dfs(int d,int m){\n\tif(!m)return 1;int h=0;\n//\tF(i,1,m)printf(\"%d \",g[d][i]);puts(\"\");\n\tF(i,1,m)for(int j=g[d][i];j;j=nxt[d][j]){\n\t\ts[++h]=j;\n\t\tif(h>d)return 0;\n\t}\n//\tF(i,1,h)printf(\"%d \",s[i]);puts(\"\\n\");\n\tif(h==1)return 1;\n\tF(i,1,h)g[d][i]=s[i];\n\tF(i,1,h){\n\t\tm=0;\n\t\tF(j,1,h)if(j!=i)g[d-1][++m]=g[d][i];\n\t\tif(dfs(d-1,m))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tgi(n);gi(v);\n\tF(i,1,n)gi(x[i]);\n\tD(i,n,2)x[i]-=x[i-1];\n\tx[1]=v+1;F(i,1,n)f[++m]=i;\n\tpre(v);f[m+1]=n+1;\n//\tprintf(\"%d\\n\",d);\n//\tF(i,1,d){F(j,1,n)printf(\"%d \",nxt[i][j]);puts(\"\");}puts(\"\");\n\tif(m>d+1){F(i,1,n)puts(\"Impossible\");return 0;}\n\tF(i,1,m){\n\t\th=0;\n\t\tF(j,1,m)if(j!=i)g[d][++h]=f[j];\n\t\tp=dfs(d,h);\n\t\tF(j,f[i],f[i+1]-1)puts(p?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=2E5+5;\n\nint N,M,V;\nint a[Maxn];\nint F[Maxn],G[Maxn];\nint L[20][Maxn],R[20][Maxn];\nint nxt[Maxn];\n\ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n\nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1) MAX(F[i],R[M-j][min(F[i-(1<<j)]+1,N)]);\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1) MIN(G[i],L[M-j][max(G[i-(1<<j)]-1,1)]);\n\t}\n\tfor(int i=0;i<(1<<M);++i)\n\t\tMAX(nxt[L[0][max(G[((1<<M)-1)^i]-1,1)]],R[0][min(F[i]+1,N)]);\n\tfor(int i=1;i<=N;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[i]>=i)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 1000010\n#define INF 0x3FFFFFFF\nusing namespace std;\nint n,v,logv;\nint x[MAXN];\nint f1[MAXN],f2[MAXN];\nint l[22][MAXN],r[22][MAXN],cnt[22];\nint find_l(int x,int pos){\n\tpos++;\n\tint now=upper_bound(l[x]+1,l[x]+1+cnt[x],pos)-l[x];\n\tnow--;\n\tif(now<=0)\n\t\treturn pos;\n\treturn max(r[x][now],pos-1);\t\n}\nint find_r(int x,int pos){\n\tpos--;\n\tint now=lower_bound(r[x]+1,r[x]+1+cnt[x],pos)-r[x];\n\tif(now>cnt[x])\n\t\treturn pos;\n\treturn min(l[x][now],pos+1);\t\n}\nint ans[MAXN];\nint main(){\n\tmemset(f2,0x3f3f3f3f,sizeof f2);\n\tSF(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++)\n\t\tSF(\"%d\",&x[i]);\t\n\tx[0]=-INF;\n\tx[n+1]=INF;\n\tfor(logv=0;(1<<logv)<=v;logv++);\n\tlogv++;\n\tfor(int i=0;i<logv;i++){\n\t\tint v1=v>>i;\n\t\tcnt[i]=1;\n\t\tl[i][cnt[i]]=1;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(x[j+1]-x[j]>v1){\n\t\t\t\tr[i][cnt[i]]=j;\n\t\t\t\tcnt[i]++;\n\t\t\t\tl[i][cnt[i]]=j+1;\t\n\t\t\t}\n\t\tcnt[i]--;\n\t}\n\tif(cnt[0]>logv){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tPF(\"Impossible\\n\");\n\t\treturn 0;\t\n\t}\n\tf1[0]=0;\n\tf2[0]=n+1;\n\tfor(int mask=0;mask<(1<<logv);mask+=2)\n\t\tfor(int i=1;i<logv;i++)\n\t\t\tif((mask&(1<<i))!=0){\n\t\t\t\tf1[mask]=max(f1[mask],find_l(i,f1[mask^(1<<i)]));\n\t\t\t\tf2[mask]=min(f2[mask],find_r(i,f2[mask^(1<<i)]));\t\n\t\t\t}\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tint lft=l[0][i];\n\t\tint rit=r[0][i];\n\t\tfor(int mask=0;mask<(1<<logv);mask+=2){\n\t\t\tint mask2=((1<<logv)-2)^mask;\n\t\t\tif(f1[mask]>=lft-1&&f2[mask2]<=rit+1){\n\t\t\t\tans[i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint las=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i>r[0][las])\n\t\t\tlas++;\n\t\tif(ans[las]==0)\n\t\t\tPF(\"Impossible\\n\");\n\t\telse\n\t\t\tPF(\"Possible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <memory>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <ctime> \n#include <stack>\n#include <iostream>\n\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MAXN = 200010;\n\nconst int LG = 22;\nint x[MAXN];\nint p[MAXN][LG];\nint f[MAXN * 3];\nint v[MAXN], vs = 0;\nint f2[MAXN * 3];\nint p2[MAXN][LG];\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\t//freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tint n;\n\tscanf(\"%d%d\", &n, v);\n\tvs = 0;\n\twhile (v[vs] > 0) {\n\t\tv[vs + 1] = v[vs] / 2;\n\t\tvs++;\n\t}\n\tvs++;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", x + i);\n\t}\n\tfor (int i = 0; i < vs; i++) {\n\t\tp[n][i] = p[n - 1][i] = n;\n\t\tfor (int j = n - 2; j >= 0; j--) {\n\t\t\tif (x[j + 1] - x[j] > v[i]) p[j][i] = j + 1;\n\t\t\telse p[j][i] = p[j + 1][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < vs; i++) {\n\t\tp2[0][i] = p2[1][i] = 0;\n\t\tfor (int j = 2; j <= n; j++) {\n\t\t\tif (x[j - 1] - x[j - 2] > v[i]) p2[j][i] = j - 1;\n\t\t\telse p2[j][i] = p2[j - 1][i];\n\t\t}\n\t}\n\tmemset(f, 0, sizeof(f));\n\tfor (int i = 0; i < (1 << vs); i++) {\n\t\tfor (int j = 0; j < vs; j++) {\n\t\t\tif (i & (1 << j)) continue;\n\t\t\tint nv = i + (1 << j);\n\t\t\tf[nv] = max(f[nv], p[f[i]][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << vs); i++) f2[i] = n;\n\tfor (int i = 0; i < (1 << vs); i++) {\n\t\tfor (int j = 0; j < vs; j++) {\n\t\t\tif (i & (1 << j)) continue;\n\t\t\tint nv = i + (1 << j);\n\t\t\tf2[nv] = min(f2[nv], p2[f2[i]][j]);\n\t\t}\n\t}\n\tint msk = (1 << vs) - 1;\n\tif (f[msk] < n) {\n\t\tfor (int i = 0; i < n; i++) printf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint l, r;\n\tfor (l = 0; l != n; l = r) {\n\t\tr = p[l][0];\n\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < (1 << vs); i++) {\n\t\t\tif (i & 1) continue;\n\t\t\tif ((f[i] >= l) && (f2[msk - 1 - i] <= r)) \n\t\t\t\tok = true;\n\t\t}\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tif (!ok) printf(\"Impossible\\n\");\n\t\t\telse printf(\"Possible\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=2e5+50;\nint n,v,lg,x[N];\nint len[20], bin[20];\nint mxr[N*4], mnl[N*4];\n\nstruct BIT_MAX {\n\tint bit[N];\n\tinline void inc(int p,int v) {\n\t\tfor(int i=p;i<=n;i+=(i&(-i))) bit[i]=max(bit[i],v);\n\t}\n\tinline int ask(int p,int v=0) {\n\t\tfor(int i=p;i;i-=(i&(-i))) v=max(v,bit[i]);\n\t\treturn v;\n\t}\n\tinline void init(int lim) {\n\t\tfor(int l=1,r;l<=n;l=r+1) {\n\t\t\tr=l;\n\t\t\twhile(r<n && x[r+1]-x[r]<=lim) ++r;\n\t\t\tinc(l,r);\n\t\t}\n\t}\n} bit_max[21];\n\nstruct BIT_MIN {\n\tint bit[N];\n\tBIT_MIN() {for(int i=0;i<N;i++) bit[i]=1e9;}\n\tinline void inc(int p,int v) {\n\t\tfor(int i=p;i;i-=(i&(-i))) bit[i]=min(bit[i],v);\n\t}\n\tinline int ask(int p,int v=1e9) {\n\t\tfor(int i=p;i<=n;i+=(i&(-i))) v=min(v,bit[i]);\n\t\treturn v;\n\t}\n\tinline void init(int lim) {\n\t\tfor(int l=1,r;l<=n;l=r+1) {\n\t\t\tr=l;\n\t\t\twhile(r<n && x[r+1]-x[r]<=lim) ++r;\n\t\t\tinc(r,l);\n\t\t}\n\t}\n} bit_min[20];\n\nint ok[N];\nint main() {\n\tn=rd(), v=rd();\n\tfor(int i=1;i<=n;i++) x[i]=rd();\n\t\n\tfor(int t=v;;t/=2) {\n\t\tlen[lg++]=t;\n\t\tif(!t) break;\n\t}\n\tfor(int i=0;i<lg;i++) {\n\t\tbin[i]=1<<i;\n\t\tbit_max[i].init(len[i]);\n\t\tbit_min[i].init(len[i]);\n\t} \n\tmxr[0]=0; mnl[0]=n+1; bin[lg]=1<<lg;\n\tfor(int s=1;s<bin[lg];++s) {\n\t\tif(s&1) continue;\n\t\tint mx=0, mn=n+1;\n\t\tfor(int k=0;k<lg;++k) if(s&bin[k]) {\n\t\t\tmx=max(mx,bit_max[k].ask(mxr[s^bin[k]]+1));\n\t\t\tmn=min(mn,bit_min[k].ask(mnl[s^bin[k]]-1));\n\t\t}\n\t\tmxr[s]=mx; mnl[s]=mn;\n\t}\n\tfor(int i=0;i<bin[lg];++i) {\n\t\tif(!(i&1)) {\n\t\t\tint s1=i, s2=(bin[lg]-1)^1^i;\n\t\t\tbit_max[20].inc(mnl[s2],mxr[s1]);\n\t\t\tbit_max[20].inc(mnl[s1],mxr[s2]);\n\t\t}\n\t}\n\tfor(int l=1,r;l<=n;l=r+1) {\n\t\tr=l;\n\t\twhile(r<n && x[r+1]-x[r]<=v) ++r;\n\t\tif(bit_max[20].ask(r+1)>=l-1) for(int i=l;i<=r;i++) ok[i]=1;\n\t}\n\tfor(int i=1;i<=n;i++) puts((ok[i]) ? \"Possible\" : \"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<vector>\n#define N 200005\nusing namespace std;\nvector<int> G[N];\nint n,m,v,a[N],r[20][N],f[1<<20],g[1<<20],ufs[20][N];\nint find(int op,int x){ return ufs[op][x] ? ufs[op][x]=find(op,ufs[op][x]) : x;}\nint main()\n{\n\tint i,j,x,p,y,T;\n\tscanf(\"%d %d\",&n,&v);\n\tfor(i=v,m=0;i;i>>=1,m++);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(i=0;i<=m;i++){\n\t\tfor(j=1;j<=n;j++) r[i][j]=j;\n\t\tfor(j=1;j<n;j++)\n\t\t\tif(a[j+1]-a[j]<=(v>>i))\n\t\t\t\tx=find(i,j),ufs[i][j+1]=x,r[i][x]=j+1;\n\t  }\n\tfor(i=1;i<(1<<m);i++)\n\t\tfor(j=0;j<m;j++)\n\t\t\tif((i>>j)&1){\n\t\t\t\tx=r[j+1][find(j+1,min(f[i^(1<<j)]+1,n))];\n\t\t\t\tf[i]=max(f[i],x);\n\t\t\t  }\n\tfor(i=0;i<(1<<m);i++) g[i]=n+1;\n\tfor(i=1;i<(1<<m);i++)\n\t\tfor(j=0;j<m;j++)\n\t\t\tif((i>>j)&1){\n\t\t\t\tx=find(j+1,max(g[i^(1<<j)]-1,1));\n\t\t\t\tg[i]=min(g[i],x);\n\t\t\t  }\n\tT=(1<<m)-1,p=0,y=-100;\n\tfor(i=0;i<=T;i++)\n\t\tG[g[T^i]].push_back(f[i]);\n\tfor(i=1;i<=n;i++){\n\t\tx=find(0,i);\n\t\twhile(p<=r[0][x]+1){\n\t\t\tfor(j=0;j<G[p].size();j++)\n\t\t\t\ty=max(y,G[p][j]);\n\t\t\tp++;\n\t\t  }\n\t\tif(y<x-1) printf(\"Impossible\\n\");\n\t\telse printf(\"Possible\\n\");\n\t  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing namespace std;\nconst int N=200005;\nint l[N][20],r[N][20],dpl[1<<18],dpr[1<<18],f[N],x[N],a[N];\nint main(){\n\tint n,v,m=0;\n\tscanf(\"%d%d\",&n,&v);\n\tfor (;1<<m<=v;m++);\n\tfor (int i=m;i;i--,v>>=1) a[i]=v;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor (int i=0;i<=m;i++) l[0][i]=0,r[n+1][i]=n+1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=m;j++)\n\t\tif (x[i]-x[i-1]<=a[j]) l[i][j]=l[i-1][j];\n\t\t\telse l[i][j]=i-1;\n\tfor (int i=n;i;i--)\n\t\tfor (int j=0;j<=m;j++)\n\t\tif (x[i+1]-x[i]<=a[j]) r[i][j]=r[i+1][j];\n\t\t\telse r[i][j]=i+1;\n\tint L=1<<m;\n\tfor (int i=0;i<L;i++){\n\t\tdpl[i]=1;dpr[i]=n;\n\t\tfor (int j=0;j<m;j++)\n\t\tif ((i>>j)&1){\n\t\t\tdpl[i]=max(dpl[i],r[dpl[i^1<<j]][j]);\n\t\t\tdpr[i]=min(dpr[i],l[dpr[i^1<<j]][j]);\n\t\t}\n\t}\n\tfor (int i=0;i<L;i++)\n\t\tf[dpr[i]]=max(f[dpr[i]],dpl[(L-1)^i]);\n\tfor (int i=1;i<=n;i++) f[i]=max(f[i],f[i-1]);\n\tfor (int i=1;i<=n;i++)\n\t\tif (f[r[i][m]-1]>l[i][m]) printf(\"Possible\\n\");\n\t\t\telse printf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define P(x) cout << x << endl\n#define D(x) P(#x << \": \" << x)\n#define F(i,n) for (int i=0; i<(int)(n); i++)\n#define DEC(i,n) for (int i=(int)(n); --i>=0;)\n#define pb push_back\n#define all(v) v.begin(), v.end()\nusing namespace std;\nvoid MI(int &a, int v) {a = min(a,v);}\nvoid MA(int &a, int v) {a = max(a,v);}\nconst int N=2e5, L=18, PL=1<<L;\n\nint l,n,v,pl;\ndeque<int> len;\n\nvoid gen(int x[], int nxt[][N], int reach[]) {\n    F(k,l) {\n        int cur=0;\n        F(i,n+1) {\n            if (i == n || (i-1 >= 0 && abs(x[i] - x[i-1]) > len[k])) {\n                while (cur < i) {\n                    nxt[k][cur] = i;\n                    cur++;\n                }\n            }\n        }\n    }\n    F(mask,pl) {\n        reach[mask] = 0;\n        F(k,l) if (mask & 1<<k)\n            MA(reach[mask], nxt[k][reach[mask-(1<<k)]]);\n    }\n}\n\nvoid print(int nxt[][N]) {\n    F(k,l) F(i,n) cout<<nxt[k][i]<<\" \\n\"[i==n-1];\n}\n\nint x[N], rev[N];\nint nxt[L][N], pre[L][N], rLeft[PL], rRight[PL];\nbool ok[N];\n\nsigned main() {\n    cin>>n>>v;\n    F(i,n) cin>>x[i], rev[n-1-i] = x[i], ok[i] = false;\n    len = {v};\n    int cur = v;\n    while (cur) cur/=2, len.push_front(cur);\n    l = len.size();\n    pl = 1<<l;\n    gen(x, nxt, rLeft);\n    gen(rev, pre, rRight);\n    //P(\"nxt:\"); print(nxt);\n    //P(\"pre:\"); print(pre);\n    bool all_ok=false;\n    int start = pl/2;\n    F(mleft,start) {\n        int le = rLeft[mleft], ri = n - rRight[start-1-mleft];\n        if (ri <= le) {\n            //P(le<<\" to \"<<ri<<\" all ok\");\n            //P(\"for masks \"<<mleft<<\",\"<<start-1-mleft);\n            all_ok=true;\n        }\n        else if (nxt[l-1][le] >= ri) {\n            int ll = n-pre[l-1][n-le-1], rr = nxt[l-1][ri-1];\n            if (ok[ll]) continue;\n            //P(ll<<\" to \"<<rr);\n            for (int j=ll; j<rr; j++)\n                ok[j] = true;\n        }\n    }\n    F(i,n) P((all_ok || ok[i] ? \"Possible\" : \"Impossible\"));\n}"
  },
  {
    "language": "C++",
    "code": "// tzl ak IOI! \n\n#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n#define FILL(a, b) memset((a), (b), sizeof((a)))\n#define MCPY(a, b) memcpy((a), (b), sizeof((b)))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f = 0; x = 0; char c = getchar();\n\twhile((c < '0' || c > '9') && c != '-') c = getchar();\n\tif(c == '-') { f = 1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\n\tif(f) x = -x; return;\n}\n\ntemplate <typename T1, typename T2>\nvoid scf(T1 &x, T2 &y) { scf(x); return scf(y); }\n\ntemplate <typename T1, typename T2, typename T3>\nvoid scf(T1 &x, T2 &y, T3 &z) { scf(x); scf(y); return scf(z); }\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid scf(T1 &x, T2 &y, T3 &z, T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n\ninline char mygetchar(){ char c = getchar(); while(c == ' ' || c == '\\n') c = getchar(); return c; }\n\ntemplate <typename T>\nvoid chkmax(T &x, const T &y){ if(y > x) x = y; return; }\n\ntemplate <typename T>\nvoid chkmin(T &x, const T &y){ if(y < x) x = y; return; }\n\n#define ONLINE_JUDGE\n\n#ifdef ONLINE_JUDGE\n#define debug(x,c) ;\n#else\n#define DEBUG\n#define debug(x,c) cerr<<#x<<\"=\"<<x<<c;\n#endif\n\nvoid TZL();\n\nvoid RANK1();\n\n#define tzl int\n#define ak main\n#define IOI ()\ntzl ak IOI\n{\n#undef tzl\n#undef ak\n#undef IOI\n\n\tTZL();\n\tRANK1();\n\n#define tzl return\n#define caisi 0\n#define myy ;\n\ttzl caisi myy\n#undef tzl\n#undef caisi\n#undef myy\n}\n\n//---------------------------head----------------------------\n\nconst int N = 2e5 + 100;\nconst int lgN = 20;\n\nint n, V, m;\nint x[N];\nint lb[lgN][N], rb[lgN][N];\nvii seg[lgN];\nint dpl[1048576], dpr[1048576];\n\nvoid get_seg()\n{\n\tfor(int i = 1, j; i <= n; i = j)\n\t{\n\t\tj = i + 1;\n\t\twhile(j <= n && x[j] - x[j - 1] <= V) ++j;\n\t\tseg[m].pb({i, j - 1});\n\t}\n\tfor(auto x: seg[m])\n\t{\n\t\tint l = x.X, r = x.Y;\n\t\tforn(i, l, r) lb[m][i] = l, rb[m][i] = r;\n\t}\n\t++m;\n\treturn;\n}\n\nvoid TZL()\n{\n\tscf(n, V);\n\tforn(i, 1, n) scf(x[i]);\n\twhile(V)\n\t{\n\t\tget_seg();\n\t\tV >>= 1;\n\t}\n\tforn(i, 1, n) lb[m][i] = i, rb[m][i] = i;\n\t++m;\n\n#ifdef DEBUG\n\trep(i, m)\n\t{\n\t\tfor(auto x: seg[i]) printf(\"%d %d\\t\", x.X, x.Y); putchar('\\n');\n\t}\n#endif\n\treturn;\n}\n\nvoid DPL()\n{\n\tforn(msk, 1, (1 << m) - 1)\n\t{\n\t\trep(i, m) if((msk >> i) & 1)\n\t\t{\n\t\t\tchkmax(dpl[msk], dpl[msk ^ (1 << i)]);\n\t\t\tchkmax(dpl[msk], rb[i][dpl[msk ^ (1 << i)] + 1]);\n\t\t}\n#ifdef DEBUG\n\t\tprintf(\"dpl[%d] = %d\\n\", msk, dpl[msk]);\n#endif\n\t}\n\treturn;\n}\n\nvoid DPR()\n{\n\tdpr[0] = n + 1;\n\tforn(msk, 1, (1 << m) - 1)\n\t{\n\t\tdpr[msk] = n + 1;\n\t\trep(i, m) if((msk >> i) & 1)\n\t\t{\n\t\t\tchkmin(dpr[msk], dpr[msk ^ (1 << i)]);\n\t\t\tchkmin(dpr[msk], lb[i][dpr[msk ^ (1 << i)] - 1]);\n\t\t}\n#ifdef DEBUG\n\t\tprintf(\"dpr[%d] = %d\\n\", msk, dpr[msk]);\n#endif\n\t}\n\treturn;\n}\n\nvii all;\nbool ans[N];\nint TOT;\n\nvoid check(int l, int r)\n{\n\tfor(int msk = 2; msk < (1 << m); msk += 2)\n\t{\n\t\tint lb = dpl[msk], rb = dpr[TOT ^ msk];\n\t\tif(l <= lb + 1 && r >= rb - 1)\n\t\t{\n#ifdef DEBUG\n\t\t\tprintf(\"%d %d\\t%d %d\\t%d %d\\n\", msk, TOT ^ msk, lb, rb, l, r);\n#endif\n\t\t\tforn(i, l, r) ans[i] = 1;\n\t\t\treturn;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid RANK1()\n{\n\tif(SZ(seg[0]) <= m)\n\t{\n\t\tDPL(); DPR();\n\t\tTOT = (1 << m) - 2;\n\t\tfor(auto x: seg[0]) check(x.X, x.Y);\n\t}\n\tforn(i, 1, n) puts(ans[i] ? \"Possible\" : \"Impossible\");\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconst int MN = 200005, MM = 18;\n\nint N, V, A[MN], v[MM], M;\nint L[MM + 1][MN], R[MM + 1][MN];\nint fl[1 << MM], fr[1 << MM];\nint val[MN];\n\nint main() {\n\tscanf(\"%d%d\", &N, &V);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n\tfor (int x = V; x; ) v[M++] = x /= 2;\n\tfor (int j = 0; j <= M; ++j) {\n\t\tint nv = j ? v[j - 1] : V;\n\t\tL[j][0] = L[j][1] = 1, R[j][N + 1] = R[j][N] = N;\n\t\tfor (int i = 2; i <= N; ++i) L[j][i] = A[i] - A[i - 1] > nv ? i : L[j][i - 1];\n\t\tfor (int i = N - 1; i >= 1; --i) R[j][i] = A[i + 1] - A[i] > nv ? i : R[j][i + 1];\n\t}\n\tfl[0] = 0, fr[0] = N + 1;\n\tfor (int S = 1; S < 1 << M; ++S) {\n\t\tfl[S] = 0, fr[S] = N + 1;\n\t\tfor (int j = 0; j < M; ++j) if (S >> j & 1)\n\t\t\tfl[S] = std::max(fl[S], R[j + 1][fl[S ^ 1 << j] + 1]),\n\t\t\tfr[S] = std::min(fr[S], L[j + 1][fr[S ^ 1 << j] - 1]);\n\t}\n\tfor (int i = 0; i <= N; ++i) val[i] = N + 2;\n\tfor (int S = 0; S < 1 << M; ++S)\n\t\tval[fl[S]] = std::min(val[fl[S]], fr[((1 << M) - 1) ^ S]);\n\tfor (int i = N - 1; i >= 0; --i) val[i] = std::min(val[i], val[i + 1]);\n\tfor (int i = 1; i <= N; ++i) puts(val[L[0][i] - 1] <= R[0][i] + 1 ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*====Corycle====*/\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<map>\n#define ll long long\n#define pii pair<int,int>\n#define fst first\n#define scd second\n#define mp make_pair\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int Maxn=(1<<19)+5;\nconst int N=2e5+5;\nconst int M=20;\nint read(){\n\tint s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}\n\treturn s*f;\n}\npii P[N];\nint n,V,cnt,tot,Sta,a[N],L[N][M],R[N][M],Ans[N],FL[Maxn],FR[Maxn];\nint main(){\n//\tfreopen(\"_.in\",\"r\",stdin);\n//\tfreopen(\"_.out\",\"w\",stdout);\n\tn=read();V=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();a[0]=-inf;a[n+1]=inf;\n\tfor(int v=V;;v>>=1){\n\t\ttot++;L[tot][0]=0;R[tot][n+1]=n+1;\n\t\tfor(int i=1;i<=n;i++)L[tot][i]=(a[i]-a[i-1]<=v?L[tot][i-1]:i);\n\t\tfor(int i=n;i>=1;i--)R[tot][i]=(a[i+1]-a[i]<=v?R[tot][i+1]:i);\n\t\tif(v==0)break;\n\t}\n\tSta=(1<<tot)-1;\n\tfor(int i=1;i<=n;i++)P[i]=mp(L[1][i],R[1][i]);\n\tsort(P+1,P+n+1);cnt=unique(P+1,P+n+1)-P-1;\n\tfor(int S=0;S<=Sta;S++){FL[S]=0;FR[S]=n+1;}\n\tfor(int S=0;S<=Sta;S+=2){\n\t\tfor(int i=1;i<=tot;i++){\n\t\t\tif(!((S>>(i-1))&1))continue;\n\t\t\tFL[S]=max(FL[S],R[i][FL[S^(1<<(i-1))]+1]);\n\t\t\tFR[S]=min(FR[S],L[i][FR[S^(1<<(i-1))]-1]);\n\t\t}\n\t}\n\tif(cnt>tot){for(int i=1;i<=tot;i++)puts(\"Impossible\");return 0;}\n\tfor(int i=1;i<=cnt;i++){\n\t\tfor(int S=0;S<=Sta;S+=2){\n\t\t\tif(FL[S]>=P[i].fst-1&&FR[Sta^S^1]<=P[i].scd+1){\n\t\t\t\tfor(int j=P[i].fst;j<=P[i].scd;j++)Ans[j]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)puts(Ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 200005;\nconst int L = 20;\n\nint n,V;\nint a[N];\nint val[L],k;\nint rig[N][L],lef[N][L];\nint f[N],g[N];\nint ad[N];\n\nint main(){\n\t//freopen(\"data.in\",\"r\",stdin);\n\tn=get();V=get();\n\tfo(i,1,n)a[i]=get();\n\tval[k=1]=V;\n\tfor(;val[k];k++)val[k+1]=val[k]/2;\n\tfo(i,1,n){\n\t\tfo(j,1,k)lef[i][j]=i;\n\t\tif (i>1)\n\t\t\tfo(j,1,k)\n\t\t\tif (val[j]>=a[i]-a[i-1])lef[i][j]=lef[i-1][j];\n\t}\n\tfd(i,n,1){\n\t\tfo(j,1,k)rig[i][j]=i;\n\t\tif (i<n)\n\t\t\tfo(j,1,k)\n\t\t\tif (val[j]>=a[i+1]-a[i])rig[i][j]=rig[i+1][j];\n\t}\n\tfo(i,0,(1<<(k-1))-1)f[i]=0,g[i]=n+1;\n\tfo(i,0,(1<<(k-1))-1){\n\t\tfo(j,2,k)\n\t\tif ((i&(1<<(j-2)))==0){\n\t\t\tif (f[i]==n)f[i|(1<<(j-2))]=n;\n\t\t\telse f[i|(1<<(j-2))]=max(f[i|(1<<(j-2))],rig[f[i]+1][j]);\n\t\t\tif (g[i]==1)g[i|(1<<(j-2))]=1;\n\t\t\telse g[i|(1<<(j-2))]=min(g[i|(1<<(j-2))],lef[g[i]-1][j]);\n\t\t}\n\t}\n\tfo(i,0,(1<<(k-1))-1){\n\t\tint r=f[i],l=g[((1<<(k-1))-1)^i];\n\t\tr=min(r,n);l=max(l,1);\n\t\tif (r<n)r=rig[r+1][1];\n\t\tif (l>1)l=lef[l-1][1];\n\t\tad[l]++;ad[r+1]--;\n\t}\n\tfo(i,1,n)ad[i]+=ad[i-1];\n\tfo(i,1,n)\n\tif (ad[i])printf(\"Possible\\n\");\n\telse printf(\"Impossbile\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define ri rd<int>\nusing namespace std;\nconst int maxN = 2e5 + 7;\nconst int maxV = 20;\nconst int maxS = (1 << maxV);\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\ninline void Min(int &x, int y) {if (y < x) x = y;}\ninline void Max(int &x, int y) {if (y > x) x = y;}\n\nint n, m, V;\nint a[maxN], b[maxN];\nint nx[maxV][maxN], pr[maxV][maxN];\nint f[maxS], g[maxS];\n\nstruct dsu {\n\tint mn, mx, fa;\n}fa[maxN];\n\ninline int find(int x) {return (fa[x].fa != x) ? fa[x].fa = find(fa[x].fa) : x;}\n\nvoid merge(int x, int y) {\n\tif (find(x) != find(y)) {\n\t\tMin(fa[find(y)].mn, fa[find(x)].mn);\n\t\tMax(fa[find(y)].mx, fa[find(x)].mx);\n\t\tfa[find(x)].fa = find(y);\n\t}\n}\n\nstruct rec {\n\tint l, r;\n\tinline bool operator < (const rec &v) const {\n\t\treturn r < v.r;\n\t}\n}q[maxS]; int tt;\n\nint main() {\n\n\tn = ri(), m = ri();\n\trep (i, 1, n) a[i] = ri();\n\tfor (int i = m; i > 0; i >>= 1) b[++V] = i; b[++V] = 0;\n\treverse(b+1, b+V+1);\n\t\n\trep (i, 1, n) fa[i] = (dsu){i, i, i};\n\n\trep (j, 1, V) {\n\t\trep (i, 2, n) if (a[i] - a[i - 1] <= b[j]) merge(i, i-1);\n\t\trep (i, 1, n) nx[j][i] = fa[find(i)].mx, pr[j][i] = fa[find(i)].mn;\n\t\tnx[j][n+1] = n;\n\t\tpr[j][0] = 1;\n\t}\n\n\tint mask = (1 << V) - 1;\n\tf[0] = 0;\n\trep (s, 1, mask) {\n\t\tf[s] = 0;\n\t\trep (j, 1, V) if (s >> (j-1) & 1)\n\t\t\tMax(f[s], nx[j][f[s ^ (1 << (j-1))] + 1]);\n\t}\n\tg[0] = n+1;\n\trep (s, 1, mask) {\n\t\tg[s] = n+1;\n\t\trep (j, 1, V) if (s >> (j-1) & 1)\n\t\t\tMin(g[s], pr[j][g[s ^ (1 << (j-1))] - 1]);\n\t}\n\n\trep (s, 0, mask = (1 << (V-1)) - 1)\n\t\tq[++tt] = (rec){f[s], g[mask ^ s]};\n\tsort(q+1, q+tt+1);\n\n\tfor (int i = 1, j = 1, cl = -1; i <= n; ++ i) {\n\t\tint l = fa[find(i)].mn, r = fa[find(i)].mx;\n\t\tfor (; j <= tt && q[j].r <= r+1; ++ j) cl = max(cl, q[j].l);\n\t\tputs(cl >= l - 1 ? \"Possible\" : \"Impossible\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b; ++ i) \nconst int M = 18, N = 3e5 + 5 ;\nusing namespace std ;\n\nint n, v[M + 5], x[N], L[M + 1][N], R[M + 1][N], dpl[N], dpr[N], bit[N], m ;\n\nint main() {\n\tscanf(\"%d%d\", &n, &v[0]) ;\n\trep(i, 1, n) scanf(\"%d\", &x[i]) ;\n\tfor (m = 1; ; m ++) {\n\t\tv[m] = v[m - 1] / 2 ;\n\t\tif (!v[m]) break ;\n\t}\n\trep(j, 0, m) {\n\t\tL[j][1] = L[j][0] = 1 ;\n\t\trep(i, 2, n) L[j][i] = (x[i] - x[i - 1] <= v[j] ? L[j][i - 1] : i) ;\n\t\tR[j][n] = R[j][n + 1] = n ;\n\t\tfor (int i = n - 1; i; -- i) R[j][i] = (x[i + 1] - x[i] <= v[j] ? R[j][i + 1] : i) ;\n\t}\n\tint st = (1 << m) - 1 ;\n\tdpl[0] = 0, dpr[0] = n + 1 ;\n\trep(i, 1, st) {\n\t\tdpl[i] = 0, dpr[i] = n + 1 ;\n\t\trep(j, 1, m) if ((i >> (j - 1)) & 1) {\n\t\t\tdpl[i] = max(dpl[i], R[j][dpl[i ^ (1 << (j - 1))] + 1]) ;\n\t\t\tdpr[i] = min(dpr[i], L[j][dpr[i ^ (1 << (j - 1))] - 1]) ;\n\t\t}\n\t}\n\trep(i, 0, n + 1) bit[i] = - n ;\n\trep(i, 0, st) bit[dpr[i]] = max(bit[dpr[i]], dpl[st ^ i]) ;\n\trep(i, 1, n + 1) bit[i] = max(bit[i], bit[i - 1]) ;\n\trep(i, 1, n) puts((bit[R[0][i] + 1] >= L[0][i] - 1) ? \"Possible\" : \"Impossible\") ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint po[200200];\n\nint mlg;\nvector<int>li[22];\nint mr[22][200200];\nint ml[22][200200];\nvoid get_line(int pos,int ma)\n{\n\tli[pos].push_back(0);\n//\tcout<<endl;\n//\tcout<<\"pos: \"<<pos<<\" ma: \"<<ma<<endl;\n\tfor(int i=1;i<=n;++i)\n\t\tif(i==1||po[i]-po[i-1]>ma)\n\t\t\tli[pos].push_back(i);\n\tli[pos].push_back(n+1);\n\tfor(int i=1,p=0;i<=n;++i)\n\t{\n\t\tmr[pos][i]=mr[pos][i-1];\n\t\tif(i==li[pos][p+1])\n\t\t\tp++,mr[pos][i]=li[pos][p+1]-1;\n\t}\n\tmr[pos][n+1]=n;\n\tml[pos][n+1]=n+1;\n\tfor(int i=n,p=li[pos].size()-1;i;--i)\n\t{\n\t\tml[pos][i]=ml[pos][i+1];\n\t\tif(i==li[pos][p]-1)\n\t\t\tp--,ml[pos][i]=li[pos][p];\n\t}\n//\tcout<<\"mr: \";for(int i=1;i<=n;++i)cout<<mr[pos][i]<<\" \";cout<<endl;\n//\tcout<<\"ml: \";for(int i=1;i<=n;++i)cout<<ml[pos][i]<<\" \";cout<<endl;\n}\n\nint pre[200200],suf[200200];\nint ans[22];\nvoid out(int ma)\n{\n\tfor(int i=1;i<=ma;++i)\n\t\tfor(int j=li[0][i];j<li[0][i+1];++j)\n\t\t\tputs(ans[i]?\"Possible\":\"Impossible\");\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&po[i]);\n\tfor(int tm=m;tm;mlg++,tm>>=1) get_line(mlg,tm);\n\tget_line(mlg,0);mlg++; \n\tint s=1<<mlg,nxt;\n\tmemset(suf,0x3f,sizeof(suf));\n\tsuf[0]=n+1;\n\tfor(int i=0;i<s;++i)\n\t{\n//\t\tcout<<\"i: \"<<i<<\" pre: \"<<pre[i]<<\" suf: \"<<suf[i]<<endl;\n\t\tfor(int j=0;j<mlg;++j)\n\t\t{\n\t\t\tif((i>>j)&1)continue;\n\t\t\tnxt=(i|(1<<j));\n\t\t\tpre[nxt]=max(pre[nxt],mr[j][pre[i]+1]);\n\t\t\tsuf[nxt]=min(suf[nxt],ml[j][suf[i]-1]);\n\t\t}\n\t}\n\tint ma=li[0].size()-2;\n\tif(ma>mlg)\n\t{\n\t\tfor(int i=1;i<=n;++i)puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\ts--;\n\tint ls=(s^1);\n\tfor(int i=1,L,R;i<=ma;++i)\n\t{\n\t\tL=li[0][i];R=li[0][i+1]-1;\n\t\tfor(int j=0;j<=s;++j)\n\t\t{\n\t\t\tif(j&1)continue;\n//\t\t\tcout<<\"j: \"<<j<<\" invj: \"<<((s^j)&ls)<<endl;\n\t\t\tif(pre[j]>=L-1&&suf[(s^j)&ls]<=R+1)\n\t\t\t{\n\t\t\t\tans[i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tout(ma);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\nint pre[200005][25], nxt[200005][25], dp_l[800005], dp_r[800005], arr[200005];\nint main()\n{\n\t// freopen(\"AGC012-F.in\", \"r\", stdin);\n\tint n, v, len = 0;\n\tscanf(\"%d%d\", &n, &v);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", arr + i);\n\twhile (true)\n\t{\n\t\tpre[0][len] = pre[1][len] = 0;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t\tpre[i][len] = arr[i] - arr[i - 1] <= v ? pre[i - 1][len] : i - 1;\n\t\tnxt[n + 1][len] = nxt[n][len] = n + 1;\n\t\tfor (int i = n - 1; i >= 1; i--)\n\t\t\tnxt[i][len] = arr[i + 1] - arr[i] <= v ? nxt[i + 1][len] : i + 1;\n\t\tlen++;\n\t\tif (!v)\n\t\t\tbreak;\n\t\tv >>= 1;\n\t}\n\tmemset(dp_r, 0x3f, sizeof(dp_r));\n\tdp_l[0] = 1;\n\tdp_r[0] = n;\n\tfor (int i = 0; i < 1 << len; i++)\n\t{\n\t\tfor (int j = 0; j < len; j++)\n\t\t{\n\t\t\tif (i & (1 << j))\n\t\t\t\tcontinue;\n\t\t\tdp_l[i | (1 << j)] = std::max(dp_l[i | (1 << j)], nxt[dp_l[i]][j]);\n\t\t\tdp_r[i | (1 << j)] = std::min(dp_r[i | (1 << j)], pre[dp_r[i]][j]);\n\t\t}\n\t}\n\tif (dp_l[(1 << len) - 1] <= n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor (int l = 1; l <= n; l = nxt[l][0])\n\t{\n\t\tbool flg = false;\n\t\tfor (int i = 0; i < 1 << len && !flg; i++)\n\t\t{\n\t\t\tif (i & 1)\n\t\t\t\tcontinue;\n\t\t\tif (l <= dp_l[i] && dp_r[(1 << len) - 1 ^ i ^ 1] <= nxt[l][0])\n\t\t\t\tflg = true;\n\t\t}\n\t\tfor (int i = l; i < nxt[l][0]; i++)\n\t\t\tputs(flg ? \"Possible\" : \"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define re register\n#define ull usigned ll\nusing namespace std;\ninline int read(){\n\tint s=0,t=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')t=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+(ch^48),ch=getchar();\n\treturn s*t;\n}\nconst int N=(1<<19);\nint n,m,U,Num,s[19],p[N];\nint L[19][N],R[19][N],dl[N],dr[N];\nint Calc(int m){\n\tint lim=0;\n\twhile(m)s[lim++]=m,m>>=1;\n\treturn ++lim;\n}\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tn=read(),m=Calc(read()),U=(1<<m)-1;\n\tfor(int i=1;i<=n;i++)p[i]=read();\n\tfor(int k=0;k<m;k++){\n\t\tfor(int i=1,j=0;i<=n;){\n\t\t\tfor(j=i;j<n&&p[j+1]-p[j]<=s[k];j++);\n\t\t\tfor(;i<=j;i++)R[k][i]=j;\n\t\t}\n\t\tfor(int i=n,j=0;i>=1;){\n\t\t\tfor(j=i;j>1&&p[j]-p[j-1]<=s[k];j--);\n\t\t\tfor(;i>=j;i--)L[k][i]=j;\n\t\t}\t\t\n\t}\n\t\n\tfor(int S=0;S<=U;S++)dl[S]=0,dr[S]=n+1;\n\tfor(int S=0;S<=U;S++){\n\t\tfor(int i=0;i<m;i++)\n\t\tif(!(S>>i&1)){\n\t\t\tint T=S|(1<<i);\n\t\t\tdl[T]=max(dl[T],min(n,R[i][dl[S]+1]));\n\t\t\tdr[T]=min(dr[T],max(1,L[i][dr[S]-1]));\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i=R[0][i]+1)Num++;\n\tif(Num>m){for(int i=1;i<=n;i++)puts(\"Impossible\");return 0;}\n\tfor(int i=1;i<=n;i=R[0][i]+1){\n\t\tint l=i,r=R[0][i],t=0;\n\t\tfor(int S=0;S<=U;S++)\n\t\tif((S&U-1)==S){if(dl[S]>=l-1&&dr[U-1^S]<=r+1)t=1;}\n\t\tfor(int j=l;j<=r;j++)puts(t?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define repd(i,n) for ((i)=(n);(i)>=1;(i)--)\nusing namespace std;\n\nint n,m;\nint i,j;\nint a[200005],d[200005],lim[25];\nint tor[200005][25],tol[200005][25];\nint dppre[1<<19],dpsuf[1<<19];\n\nvoid calc(int x){\n\tint i;\n\trep(i,n){\n\t\ttor[i][x]=tor[i-1][x];\n\t\tif(tor[i][x]<i){\n\t\t\ttor[i][x]=i;\n\t\t\twhile(tor[i][x]<n&&d[tor[i][x]]<=lim[x]){\n\t\t\t\ttor[i][x]++;\n\t\t\t}\n\t\t}\n\t}\n\ttol[n+1][x]=n+1;\n\trepd(i,n){\n\t\ttol[i][x]=tol[i+1][x];\n\t\tif(tol[i][x]>i){\n\t\t\ttol[i][x]=i;\n\t\t\twhile(tol[i][x]>1&&d[tol[i][x]-1]<=lim[x]){\n\t\t\t\ttol[i][x]--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>n>>lim[m=1];\n\trep(i,n) cin>>a[i];\n\trep(i,n-1) d[i]=a[i+1]-a[i];\n\twhile(lim[m]>0){\n\t\tm++;\n\t\tlim[m]=lim[m-1]/2;\n\t}\n\trep(i,m){\n\t\tcalc(i);\n\t}\n\tint c=0;\n\tfor(i=1;i<=n;i=tor[i][1]+1)c++;\n\tif(c>m+1){\n\t\trep(i,n){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(i=0;i<(1<<(m-1));i++){\n\t\tdppre[i]=0;dpsuf[i]=n+1;\n\t\tfor(j=0;j<(m-1);j++)if((i>>j)&1){\n\t\t\tdppre[i]=max(dppre[i],tor[dppre[i^(1<<j)]+1][j+2]);\n\t\t\tdpsuf[i]=min(dpsuf[i],tol[dpsuf[i^(1<<j)]-1][j+2]);\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=n;i=tor[i][1]+1){\n\t\tint f=0;\n\t\tfor(j=0;j<(1<<(m-1));j++){\n\t\t\tf|=(dppre[j]>=i-1&&dpsuf[((1<<m-1)-1)^j]<=tor[i][1]+1);\n\t\t}\n\t\tif(f){\n\t\t\trep(j,tor[i][1]-i+1) puts(\"Possible\");\n\t\t}\n\t\telse{\n\t\t\trep(j,tor[i][1]-i+1) puts(\"Impossible\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nint pre[200005][25], nxt[200005][25], dp_l[800005], dp_r[800005], arr[200005];\nint main()\n{\n\t// freopen(\"AGC012-F.in\", \"r\", stdin);\n\tint n, v, len = 0;\n\tscanf(\"%d%d\", &n, &v);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", arr + i);\n\twhile (true)\n\t{\n\t\tpre[0][len] = pre[1][len] = 0;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t\tpre[i][len] = arr[i] - arr[i - 1] <= v ? pre[i - 1][len] : i - 1;\n\t\tnxt[n + 1][len] = nxt[n][len] = n + 1;\n\t\tfor (int i = n - 1; i >= 1; i--)\n\t\t\tnxt[i][len] = arr[i + 1] - arr[i] <= v ? nxt[i + 1][len] : i + 1;\n\t\tlen++;\n\t\tif (!v)\n\t\t\tbreak;\n\t\tv >>= 1;\n\t}\n\tfor (int i = 0; i < 1 << len; i++)\n\t{\n\t\tdp_l[i] = 1;\n\t\tdp_r[i] = n;\n\t}\n\tfor (int i = 0; i < 1 << len; i++)\n\t{\n\t\tfor (int j = 0; j < len; j++)\n\t\t{\n\t\t\tif (i & (1 << j))\n\t\t\t\tcontinue;\n\t\t\tdp_l[i | (1 << j)] = std::max(dp_l[i | (1 << j)], nxt[dp_l[i]][j]);\n\t\t\tdp_r[i | (1 << j)] = std::min(dp_r[i | (1 << j)], pre[dp_r[i]][j]);\n\t\t}\n\t}\n\tif (dp_l[(1 << len) - 1] <= n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor (int l = 1; l <= n; l = nxt[l][0])\n\t{\n\t\tbool flg = false;\n\t\tfor (int i = 0; i < 1 << len && !flg; i++)\n\t\t{\n\t\t\tif (i & 1)\n\t\t\t\tcontinue;\n\t\t\tif (l <= dp_l[i] && dp_r[(1 << len) - 1 ^ i ^ 1] <= nxt[l][0])\n\t\t\t\tflg = true;\n\t\t}\n\t\tfor (int i = l; i < nxt[l][0]; i++)\n\t\t\tputs(flg ? \"Possible\" : \"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint dpl[200100],dpr[200100];\nint val[200100];\nint nex[200100][20],las[200100][20];\nint a[200100];\nint b[20],k=-1;\nint f[200100];\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n\tint n,v;\n\tscanf(\"%d%d\",&n,&v);\n\twhile(v){\n\t\tb[++k]=v;\n\t\tv/=2;\n\t}\n\tb[++k]=0;\n\tfor(int i=0;i<=k;i++)\n\t\tif(i<k-i)\n\t\t\tswap(b[i],b[k-i]);\n\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int j=0;j<=k;j++)\n\t{\n\t\tnex[n][j]=n;\n\t\tnex[n+1][j]=n;\n\t\tlas[1][j]=1;\n\t\tlas[0][j]=1;\n\t}\n\tfor(int i=n-1;i>=1;i--)\n\t\tfor(int j=0;j<=k;j++)\n\t\t{\n\t\t\tif(a[i+1]-a[i]<=b[j])\n\t\t\t\tnex[i][j]=nex[i+1][j];\n\t\t\telse\n\t\t\t\tnex[i][j]=i;\n\t\t}\n\tfor(int i=2;i<=n;i++)\n\t\tfor(int j=0;j<=k;j++)\n\t\t{\n\t\t\tif(a[i]-a[i-1]<=b[j])\n\t\t\t\tlas[i][j]=las[i-1][j];\n\t\t\telse\n\t\t\t\tlas[i][j]=i;\n\t\t}\n\n\n\tfor(int i=0;i<(1<<k);i++){\n\t\tfor(int j=0;j<k;j++){\n\t\t\tif(i&(1<<j)) continue;\n\t\t\tif(nex[dpl[i]+1][j]>dpl[i|(1<<j)])\n\t\t\t\tdpl[i|(1<<j)]=nex[dpl[i]+1][j];\n\t\t}\n\t}\n\n\tfor(int i=0;i<(1<<k);i++)\n\t\tdpr[i]=n+1;\n\tfor(int i=0;i<(1<<k);i++){\n\t\tfor(int j=0;j<k;j++){\n\t\t\tif(i&(1<<j)) continue;\n\t\t\tif(las[dpr[i]-1][j]<dpr[i|(1<<j)])\n\t\t\t\tdpr[i|(1<<j)]=las[dpr[i]-1][j];\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;i++)\n\t\tf[i]=n+1;\n\tfor(int i=0;i<(1<<k);i++)\n\t\tif(dpr[((1<<k)-1)^i]-1<f[dpl[i]+1])\n\t\t\tf[dpl[i]+1]=dpr[((1<<k)-1)^i]-1;\n\n\tint r,mn;\n\tfor(int i=1;i<=n;i=r+1){\n\t\tr=nex[i][k],mn=n+1;\n\t\tfor(int j=i;j<=r;j++)\n\t\t\tif(f[j]<mn) mn=f[j];\n\t\tif(mn<=r){\n\t\t\tfor(int j=i;j<=r;j++)\n\t\t\t\tprintf(\"Possible\\n\");\n\t\t}\n\t\telse{\n\t\t\tfor(int j=i;j<=r;j++)\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\n#define DEBUGNO\n\nsigned main() {\n\tINIT;\n\t\n\tstd::ifstream ifs(\"test.in\");\n\n#ifndef DEBUG\n\tVAR(int, n, V);\n#else\n\tint n, V;\n\tifs >> n >> V;\n#endif\n\n\tif(false){\n\t\tstd::random_device rnd;\n\t\tstd::mt19937 mt(rnd());\n\t\tstd::uniform_int_distribution<> rand(/* min */-1000000000, /* max */1000000000);\n\t\tstd::set<int> set;\n\t\twhile (set.size() < n) set.insert(rand(mt));\n\t\tOUT(n)SP OUT(V)BR;\n\t\tfor (auto x : set) {\n\t\t\tOUT(x)SP;\n\t\t}BR;\n\n\t\treturn 0;\n\t}\n\t\n#ifndef DEBUG\n\tVEC(int, x, n);\n#else\n\tstd::vector<int> x(n);\n\tREP(i, n) ifs >> x[i];\n#endif\n\n\n\tint height = 0;\n\twhile (V >= (1 << height)) ++height;\n\theight += 2;\n\tstd::vector<std::vector<int>> right(height);\n\tint vv = V;\n\tright[0].emplace_back(x[n - 1]);\n\tFOR(h, 1, height) {\n\t\tint r = n - 1;\n\t\tRREP(i, n - 1) {\n\t\t\tif (x[i + 1] - x[i] > vv || i == 0) {\n\t\t\t\tright[h].emplace_back(x[r]);\n\t\t\t\tr = i;\n\t\t\t}\n\t\t}\n\t\tif (x[1] - x[0] > vv) right[h].emplace_back(x[0]);\n\t\tstd::sort(ALL(right[h]));\n\t\tvv /= 2;\n\t}\n\tstd::vector<int> c(height + 1, 0);\n\tREP(i, height) c[i] = right[i].size();\n\tREP(i, height - 1) c[i + 1] += c[i];\n\tstd::rotate(c.rbegin(), c.rbegin() + 1, c.rend());\n\n\tstd::vector<std::vector<int>> g(1);\n\tg.reserve(n*height);\n\tint p = 0;\n\tFOR(h, 1, height) {\n\t\tfor (auto v : right[h]) {\n\t\t\t++p;\n\t\t\tauto it = std::lower_bound(ALL(right[h - 1]), v);\n\t\t\tint par = std::distance(right[h-1].begin(), it) + c[h-1];\n\t\t\tg.emplace_back(std::vector<int>{});\n\t\t\t//g[s].emplace_back(t);\n\t\t\tg[par].emplace_back(p);\n\t\t}\n\t}\n\n\t/*SHOWVECTOR2(right);\n\n\tREP(i, g.size()) {\n\t\tfor (auto to : g[i]) {\n\t\t\tOUT(i)SP OUT(to)BR;\n\t\t}\n\t}*/\n\n\tstd::vector<int> v0;\n\tfor (auto v : g[0]) v0.emplace_back(v);\n\tstd::function<bool(std::vector<int>&, int, int)> check = [&](std::vector<int>& a, int pos, int rest) {\n\t\t//SHOWVECTOR(a);\n\t\tif (rest == 0) return true;\n\t\tif (a.empty()) return true;\n\t\tstd::vector<int> c;\n\t\tint asz = a.size();\n\t\tREP(i, asz) {\n\t\t\tauto& v = g[a[i]];\n\t\t\tREP(j, v.size()) {\n\t\t\t\tif (a[i] > v[j]) continue;\n\t\t\t\tc.emplace_back(v[j]);\n\t\t\t}\n\t\t}\n\t\tint csz = c.size();\n\t\t//std::sort(ALL(c));\n\t\tfor(auto v : a) {\n\t\t\tif (pos != -1) v = pos;\n\t\t\tif (csz - g[v].size() > rest - 1) continue;\n\t\t\tauto ts(c);\n\t\t\tfor (auto& to : g[v]) {\n\t\t\t\tif (v > to) continue;\n\t\t\t\tts.erase(std::find(ALL(ts), to));\n\t\t\t}\n\t\t\tts.shrink_to_fit();\n\t\t\tif (check(ts, -1, rest - 1)) return true;\n\t\t\tif (pos != -1) break;\n\t\t}\n\t\treturn false;\n\t};\n\n\tstd::vector<PAIR> ok;\n\tp = 0;\n\tfor (auto& v : v0) {\n\t\tbool t = check(v0, v, height - 1);\n\t\tok.emplace_back(PAIR(right[1][p++], t));\n\t}\n\t//SHOWPAIRVECTOR(ok);\n\n\tp = 0;\n\tREP(i, n) {\n\t\tif (x[i] <= ok[p].first) {\n#ifndef DEBUG\n\t\t\tOUT(((ok[p].second) ? \"Possible\" : \"Impossible\"))BR;\n#endif\n\t\t}\n\t\tif (x[i] == ok[p].first) ++p;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(),v.end()\n\nconst int maxn = 2e5 + 100, maxlg = 20;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, v, vols[maxlg], volCount, nxt[maxlg][maxn], dp[(1 << maxlg)];\nll x[maxn], a[maxn];\nbool ans[maxn];\nset<int> counter;\n\nvoid printAnsAndExit() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << (ans[i] ? \"Possible\" : \"Impossible\") << endl;\n\t}\n\texit(0);\n}\n\nvoid solve(int l, int r) {\n\tmemset(dp, 0, sizeof(dp));\n\tfor (int mask = 0; mask < (1 << (volCount - 1)); mask++) {\n\t\tfor (int bit = 0; bit < volCount - 1; bit++) {\n\t\t\tif (!((mask >> bit) & 1)) {\n\t\t\t\tint val = nxt[bit][dp[mask]] + 1;\n\t\t\t\tif (l <= val && val <= r) {\n\t\t\t\t\tval = r + 1;\n\t\t\t\t}\n\t\t\t\tdp[mask | (1 << bit)] = max(dp[mask | (1 << bit)], val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mx = *max_element(dp, dp + (1 << maxlg));\n\tif (mx == n) {\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tans[i] = true;\n\t\t}\n\t}\n}\n\nvoid solveAll() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcounter.insert(nxt[volCount - 1][i]);\n\t}\n\tif (counter.size() > volCount) {\n\t\tprintAnsAndExit();\n\t}\n\t\n\tint l = 0, r = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (nxt[volCount - 1][r] == nxt[volCount - 1][i]) {\n\t\t\tr++;\n\t\t}\n\t\telse {\n\t\t\tsolve(l, r);\n\t\t\tr++;\n\t\t\tl = r;\n\t\t}\n\t}\n\tsolve(l, r);\n}\n\n\nvoid calcVols(int v) {\n\tint count = 0, tmp = v;\n\twhile (tmp) {\n\t\ttmp /= 2;\n\t\tcount++;\n\t}\n\tvolCount = ++count;\n\twhile (count) {\n\t\tvols[--count] = v;\n\t\tv /= 2;\n\t}\n}\n\nvoid calcNxt() {\n\tfor (int vol = 0; vol < volCount; vol++) {\n\t\tint l = 0, r = 0;\n\t\twhile (r < n - 1) {\n\t\t\tif (x[r + 1] - x[r] <= vols[vol]) {\n\t\t\t\tr++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (l <= r) {\n\t\t\t\t\tnxt[vol][l] = r;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\twhile (l <= r) {\n\t\t\tnxt[vol][l] = r;\n\t\t\tl++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t\ta[i] = x[i];\n\t}\n\n\tcalcVols(v);\n\tcalcNxt();\n\tsolveAll();\n\tprintAnsAndExit();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\ninline void swap(int &a,int &b){return (void) (a^=b^=a^=b);}\nconst int MaN=200005,MaP=20*200000+5;\nstruct edge{int to,ne;}e[MaP];\nint h[MaP],cnt;\nvoid add(int a,int b){\n\te[++cnt]=(edge){b,h[a]};\n\th[a]=cnt; return ;\n}\nint ncnt,fcnt,sz[MaP],chu[MaP];\nint num[20];\n//int f[20][1048576];\n\nint n,v,loc[MaN];\nstd::map <int,int> locs;\n\nint ls[20],lscon;\nbool work(int step,int bn){\n\tif(lscon<2) return true;\n\tif(step==fcnt+1) return true;\n\tint lsn[20],lsncon=0;\n\tfor(int u=0;u<lscon;u++){\n\t\tif(ls[u]==bn) continue;\n\t\tint x=ls[u];\n\t\tfor(int i=h[x];i;i=e[i].ne){\n\t\t\tif(lsncon>fcnt-step) return false;\n\t\t\tlsn[lsncon++]=e[i].to;\n\t\t}\n\t}\n\tswap(lscon,lsncon); for(int i=0;i<20;i++) swap(lsn[i],ls[i]);\n\tfor(int i=0;i<lscon;i++)\n\t\tif(work(step+1,ls[i])) return true;\n\tswap(lscon,lsncon); for(int i=0;i<20;i++) swap(lsn[i],ls[i]);\n\treturn false;\n}\n\nint main(){\n//\tfreopen(\"jump.in\",\"r\",stdin);\n//\tfreopen(\"jump.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&loc[i]);\n\tloc[n+1]=0x3f3f3f3f; locs[n]=0;\n\t\n\twhile(true){\n\t\t++fcnt;\n\t\tint last=1;\n\t\tint begin=++ncnt;\n\t\tfor(int i=2;i<=n+1;i++){\n\t\t\tif(loc[i]-loc[i-1]>v){\n\t\t\t\tsz[ncnt]=i-last; last=i;\n\t\t\t\tstd::map<int,int>::iterator it=locs.lower_bound(i-1);\n\t\t\t\tadd(it->second,ncnt);\n\t\t\t\tchu[it->second]++;\n\t\t\t\tif(i!=n+1) ncnt++;\n\t\t\t}\n\t\t}\n\t\tint sum=0;\n\t\tfor(int i=begin;i<=ncnt;i++){\n\t\t\tsum+=sz[i]; locs[sum]=i;\n\t\t}\n\t\tnum[fcnt]=ncnt-begin+1;\n\t\tif(!v) break; v>>=1;\n//\t\tlastBegin=lastEnd+1;\n\t}\n\tif(num[1]>fcnt){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint sum=0,last;\n\tfor(int i=1;i<=num[1];i++){\n\t\tlast=sum;\n\t\tsum+=sz[i];\n\t\tlscon=num[1];\n\t\tfor(int j=0;j<num[1];j++) ls[j]=j+1;\n\t\tif(work(2,i)) for(int i=last+1;i<=sum;i++) printf(\"Possible\\n\");\n\t\telse for(int i=last+1;i<=sum;i++) printf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\n\nint kano()\n{\n\tchar ch=getchar();int w=0,u=1;\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')u=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())w=w*10+ch-'0';\n\treturn w*u;\n}\nint n,v,o,u,mx;\nint a[200005];\nint p[21][200005],r[21][200005];\nint f[2][262145];\nbool bo[200005];\nint main()\n{\n\tn=kano();v=kano();\n\tfor(int i=1;i<=n;i++)a[i]=kano();\n\tfor(o=v,u=0;o>0;o=o>>1,u++)\n\t{\n\t\tint la=1;p[u][1]=1;r[u][1]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]-a[i-1]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tmx=1<<u;mx--; \n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tf[0][i|j]=max(f[0][i|j],p[l][r[l][f[0][i]+1]]);\n\t\t}\n\t}\n\tfor(o=v>>1,u=1;o>0;o=o>>1,u++)\n\t{\n\t\tint la=n;p[u][n]=n;r[u][n]=n;\n\t\tfor(int i=n-1;i>=1;i--)\n\t\t{\n\t\t\tif(a[i+1]-a[i]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tfor(int i=0;i<=mx;i++)f[1][i]=n;\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tf[1][i|j]=min(f[1][i|j],p[l][r[l][f[1][i]-1]]);\n\t\t}\n\t}\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tint j=~i&mx;\n\t\tif(r[0][f[0][i]+1]==r[0][f[1][j]-1])bo[r[0][f[0][i]+1]]=1;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(bo[r[0][i]])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 233333;\nint n,v,a[N],len,bh[20][N],num;Vi e[N*20];\nstruct Seg{\n\tint r[N];\n\tvoid init(int x){\n\t\tper(i,n,1){r[i]=i;if(i+1<=n&&a[i+1]-a[i]<=x)r[i]=r[i+1];}\n\t\t\n\t}\n}b[20];\nmap<Vi,bool>Map[20];\nbool ck(int dep, Vi c){\n\tif(SZ(c)>len-dep+1)return 0;if(dep==len||!SZ(c))return 1;\n\tif(Map[dep].count(c))return Map[dep][c];\n\tbool ok=0;\n\trep(i,0,SZ(c)-1){\n\t\tVi d;rep(j,0,SZ(c)-1)if(i!=j)rep(k,0,SZ(e[c[j]])-1)d.pb(e[c[j]][k]);\n\t\tif(ck(dep+1,d)){ok=1;break;}\n\t}\n\treturn Map[dep][c]=ok;\n}\nint main() {\n\tread(n);read(v);rep(i,1,n)read(a[i]);\n\twhile(1){b[++len].init(v);if(!v)break;v/=2;}\n\trep(i,1,len)rep(j,1,n)if(b[i].r[j]!=b[i].r[j-1])bh[i][j]=++num;\n\trep(i,1,len-1)rep(j,1,n)if(bh[i][j]){\n\t\tfor(int k=j;k<=b[i].r[j];k=b[i+1].r[k]+1)\n\t\t\te[bh[i][j]].pb(bh[i+1][k]);\n\t}\n\tVi top;rep(i,1,n)if(bh[1][i])top.pb(bh[1][i]);\n\tif(SZ(top)>=20){\n\t\trep(i,1,n)puts(\"Impossible\");return 0;\n\t}\n\tfor(int i=1;i<=n;i=b[1].r[i]+1){\n\t\tVi c;rep(j,0,SZ(top)-1)if(top[j]!=bh[1][i])rep(k,0,SZ(e[top[j]])-1)c.pb(e[top[j]][k]);\n\t\tbool ok=ck(2,c);\n\t\trep(j,i,b[1].r[i])printf(\"%s\\n\",ok?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\nconst int mod = 1e9 + 7;\n\nint n, m, a[200005];\nint lvl[200005];\nint l[1<<19], r[1<<19];\n\nvector<int> dv;\nint prv[19][200005], nxt[19][200005];\n\nvoid solve(int *ans, int nxt[19][200005]){\n\tfor(int i=0; i<n-1; i++){\n\t\tlvl[i] = lower_bound(dv.begin(), dv.end(), a[i+1] - a[i]) - dv.begin();\n\t}\n\tfor(int i=0; i<m; i++){\n\t\tnxt[i][n-1] = n-1;\n\t\tfor(int j=n-2; j>=0; j--){\n\t\t\tif(lvl[j] > i) nxt[i][j] = j;\n\t\t\telse nxt[i][j] = nxt[i][j+1];\n\t\t}\n\t}\n\tfor(int i=0; i<(1<<m); i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif((i >> j) & 1) continue;\n\t\t\tint cur = nxt[j][min(n-1, ans[i] + 1)];\n\t\t\tans[i | (1<<j)] = max(ans[i | (1<<j)], cur);\n\t\t}\n\t}\n}\n\nint dx[200005];\n\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\tdv.push_back(m);\n\twhile(dv.back() >= 1){\n\t\tdv.push_back(dv.back() / 2);\n\t}\n\tsort(dv.begin(), dv.end());\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tm = dv.size();\n\tsolve(l, nxt);\n\tint s = 0;\n\tvector<pi> v;\n\tfor(int i=0; i+1<n; i++){\n\t\tif(lvl[i] == dv.size()){\n\t\t\tv.push_back(pi(s, i));\n\t\t\ts = i+1;\n\t\t}\n\t}\n\tv.push_back(pi(s, n-1));\n\tif(v.size() > 20){\n\t\twhile(n--) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=0; i<n; i++) a[i] *= -1;\n\treverse(a, a+n);\n\tsolve(r, prv);\t\n\tfor(int i=0; i<(1<<m); i++){\n\t\tr[i] = n - 1 - r[i];\n\t}\n\tfor(int i=0; i<m; i++){\n\t\tfor(int j=0; j<=n-1; j++){\n\t\t\tprv[i][j] = n-1-prv[i][j];\n\t\t}\n\t\treverse(prv[i], prv[i] + n);\n\t//\tfor(int j=0; j<n; j++) printf(\"%d %d %d %d\\n\",i,j,prv[i][j],nxt[i][j]);\n\t}\n\tfor(auto &i : v){\n\t//\tprintf(\"%d %d\\n\", i.first, i.second);\n\t\tfor(int j=0; j<(1<<(m-1)); j++){\n\t\t\tint p = (1 << (m-1)) - j - 1;\n\t\t\tif(l[j] >= i.first - 1 && r[p] <= i.second + 1){\n\t\t\t\tdx[i.first]++;\n\t\t\t\tdx[i.second+1]--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++){\t\n\n\t\tif(i) dx[i] += dx[i-1];\n\t\tif(dx[i]>0) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,v;\n  cin>>n>>v;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n\n  vector<Int> dp;\n  vector<vector<Int> > ps;\n  while(v){\n    vector<Int> dp2(n,0);\n    for(Int i=1;i<n;i++)\n      dp2[i]=dp2[i-1]+(x[i]-x[i-1]>v);\n    if(dp.empty()) dp=dp2;\n\n    vector<Int> ps2;\n    ps2.emplace_back(0);\n    for(Int i=1;i<n;i++)\n      if(dp2[i]!=dp2[i-1]) ps2.emplace_back(i);\n    ps2.emplace_back(n);\n    ps.emplace_back(ps2);\n    v>>=1;\n  }\n  \n  {\n    vector<Int> ps2(n+1,0);\n    iota(ps2.begin(),ps2.end(),0);\n    ps.emplace_back(ps2);\n  }\n  \n  if(dp.back()>20){\n    for(Int i=0;i<n;i++)\n      cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n\n  using P = pair<Int, Int>;\n  Int flg;\n  function<void(Int,set<P>)> dfs=\n    [&](Int d,set<P> sp){\n      {\n\tauto latte=sp.begin();\n\tInt res=latte->first==0;\n\twhile(latte!=sp.end()){\n\t  auto malta=latte;\n\t  if(++malta==sp.end()) break;;\n\t  res&=latte->second==malta->first;\n\t  latte=malta;\n\t}\n\tres&=latte->second==n;\n\tflg|=res;\n      }\n      \n      if(d==(Int)ps.size()) return;\n      vector<Int> &v=ps[d];\n      Int cnt=0;\n      auto latte=v.begin();\n      for(auto &p:sp){\n\tcnt+=lower_bound(latte,v.end(),p.first)-latte;\n\tlatte=lower_bound(latte,v.end(),p.second);\n      }\n      cnt+=v.end()-latte;\n\n      if(0){\n\tcout<<d<<\":\"<<cnt<<endl;\n\tfor(auto p:sp) cout<<p.first<<\" \"<<p.second<<endl;\n\tcout<<endl;\n      }\n      \n      if(cnt>20) return;\n      Int k=0;\n      set<P> nsp=sp;\n      for(auto &p:sp){\n\twhile(v[k]<p.first){\n\t  nsp.emplace(v[k],v[k+1]);\n\t  dfs(d+1,nsp);\n\t  nsp.erase(P(v[k],v[k+1]));\n\t  k++;\n\t}\n\tif(flg) return;\n\tk=lower_bound(v.begin(),v.end(),p.second)-v.begin();\n      }\n      while(k+1<(Int)v.size()){\n\tnsp.emplace(v[k],v[k+1]);\n\tdfs(d+1,nsp);\n\tnsp.erase(P(v[k],v[k+1]));\n\tk++;\n      }\n    };\n  \n  for(Int i=0;i<n;){\n    Int l=i,r=*upper_bound(ps[0].begin(),ps[0].end(),l);\n    set<P> sp;\n    sp.emplace(l,r);\n    flg=0;\n    //cout<<l<<\" \"<<r<<endl;\n    dfs(1,sp);\n    string ans=flg?\"Possible\":\"Impossible\";\n    Int p=i;\n    while(i<n&&dp[p]==dp[i]){\n      cout<<ans<<endl;\n      i++;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 2e5 + 5;\nconst int MAXL = 19;\nconst int MAXS = (1 << MAXL) + 5;\n\nint N, V;\nint A[MAXN];\n\nvoid input()\n{\n    read(N); read(V);\n    for (int i = 1; i <= N; ++i) {\n        read(A[i]);\n    }\n}\n\nint L;\nvector<Pii> interval[MAXL];\n\nvoid solve()\n{\n    for (int v = V; ; v >>= 1) {\n        int st = 1;\n        for (int i = 1; i <= N; ++i) {\n            if (i == N || A[i+1] - A[i] > v) {\n                interval[L].push_back(MP(st, i));\n                st = i + 1;\n            }\n        }\n        ++L;\n        if (!v)\n            break;\n    }\n\n    static int rbnd[MAXL][MAXN], lbnd[MAXL][MAXN];\n\n    for (int i = 0; i < L; ++i) {\n        rbnd[i][N+1] = N;\n        lbnd[i][0] = 1;\n        for (auto x: interval[i]) {\n            for (int j = x.x; j <= x.y; ++j) {\n                rbnd[i][j] = x.y;\n                lbnd[i][j] = x.x;\n            }\n        }\n    }\n\n    static int f[MAXS], g[MAXS];\n    int sbnd = 1 << (L - 1);\n\n    f[0] = 1; g[0] = N;\n    for (int s = 1; s < sbnd; ++s) {\n        f[s] = 1; g[s] = N;\n        for (int i = 1; i < L; ++i) {\n            if (s >> (i - 1) & 1) {\n                chkmax(f[s], rbnd[i][f[s^(1<<(i-1))]+1]);\n                chkmin(g[s], lbnd[i][g[s^(1<<(i-1))]-1]);\n            }\n        }\n    }\n\n    vector<Pii> cover;\n\n    for (int s = 0; s < sbnd; ++s) {\n        cover.push_back(MP(f[s], g[(sbnd - 1) ^ s]));\n        if (f[s] + 1 >= g[(sbnd - 1) ^ s]) {\n            for (int i = 1; i <= N; ++i) {\n                puts(\"Possible\");\n            }\n            return;\n        }\n    }\n    std::sort(ALL(cover));\n\n    // for (auto x: cover) {\n    //     printf(\"%d %d\\n\", x.x, x.y);\n    // }\n\n    static Pii q[MAXN];\n    int front = 0, rear = 0;\n\n    for (int i = 1, j = 0; i <= N; ++i) {\n        int l = lbnd[0][i], r = rbnd[0][i];\n        for (; j < SZ(cover) && cover[j].x < r; ++j) {\n            while (front < rear && q[rear-1].y >= cover[j].y) --rear;\n            q[rear++] = cover[j];\n        }\n        while (front < rear && q[front].x + 1 < l) ++front;\n        if (front < rear && q[front].y - 1 <= r)\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n    }\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"E.in\", \"r\", stdin);\n    freopen(\"E.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 时光只解催人老，不信多情，长恨离亭，泪滴春衫酒易醒。\n//     -- 晏殊《采桑子·时光只解催人老》\n"
  },
  {
    "language": "C++",
    "code": "//2018-1-18\n//miaomiao\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define Set(a, v) memset(a, v, sizeof(a))\n#define For(i, a, b) for(int i = (a); i <= (int)(b); ++i)\n\n#define M 18\n#define N (100000+5)\n\nint n, m, dn, pos[N], dis[M], nxt[N][M], beg[N], endd[N];\nint f[1<<M];\n\nbool Solve(int l, int r){\n\tif(l == 1 && r == n) return true;\n\n\tf[0] = 0;\n\t\n\tint tmp;\n\tFor(i, 1, (1<<dn)-1){\n\t\tf[i] = 0;\n\t\tFor(j, 1, dn) if(i & (1<<(j-1))){\n\t\t\ttmp = f[i ^ (1<<(j-1))] + 1;\n\t\t\tif(tmp >= l && tmp <= r) tmp = r+1;\n\n\t\t\tf[i] = max(f[i], nxt[tmp][j]);\n\t\t\tif(f[i]+1 >= l && f[i]+1 <= r) f[i] = r;\n\t\t}\n\t\tif(f[i] >= n) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tFor(i, 1, n) scanf(\"%d\", &pos[i]);\n\t\n\tint st, ed, cnt = 0;\n\tfor(int d = m; d >= 0; d >>= 1){\n\t\tst = 1; if(d != m) dis[++dn] = d;\n\n\t\twhile(st <= n){\n\t\t\ted = st;\n\t\t\twhile(ed < n && pos[ed+1]-pos[ed] <= d) ++ed;\n\t\t\tFor(i, st, ed) nxt[i][dn] = ed;\n\t\t\t\n\t\t\tif(d == m){\n\t\t\t\tbeg[++cnt] = st; endd[cnt] = ed;\n\t\t\t}\n\t\t\tst = ed+1;\n\t\t}\n\n\t\tif(!d) break;\n\t}\n\n\tFor(i, 1, dn) nxt[n+1][i] = n+1;\n//\tFor(i, 1, n) For(j, 1, dn) printf(\"nxt[%d][%d] = %d\\n\", i, j, nxt[i][j]);\n\n\tif(cnt > dn+1){\n\t\tFor(i, 1, n) puts(\"Impossible\"); return 0;\n\t}\n\n\tFor(si, 1, cnt){\n\t//\tprintf(\"%d -> %d free\\n\", beg[si], end[si]);\n\t\tif(Solve(beg[si], endd[si])){\n\t\t\tFor(i, beg[si], endd[si]) puts(\"Possible\");\n\t\t}else{\n\t\t\tFor(i, beg[si], endd[si]) puts(\"Impossible\"); \n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define F(i,j,n) for(register int i=j;i<=n;i++)\n#define D(i,j,n) for(register int i=j;i>=n;i--)\n#define ll long long\n#define N 200010\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;int f;\n\tchar gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void gi(I&x){\n\t\tfor(f=1,c=gc();c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n};\nusing io::gi;\nusing io::gc;\nint f[N],s[N],nxt[20][N],x[N],n,m,h,v,d,p;\nvector<int>g;\nvoid pre(int v){\n\tif(!v)return;pre(v/2);\n\th=0;d++;\n\tF(i,1,m)\n\t\tif(x[f[i]]>v)f[++h]=f[i];\n\t\telse nxt[d][f[i-1]]=f[i];\n\tm=h;\n//\tF(i,1,m)printf(\"%d \",f[i]);puts(\"\");\n}\nint dfs(int d,vector<int>f){\n\tif(f.empty())return 1;\n\tvector<int>g;int m=f.size(),h=0;\n//\tF(i,1,m)printf(\"%d \",f[i-1]);puts(\"\");\n\tF(i,1,m)for(int j=f[i-1];j;j=nxt[d][j]){\n\t\tg.push_back(j);\n\t\th++;if(h>d)return 0;\n\t}\n\tf=g;\n\tF(i,1,h){\n\t\tg.clear();\n\t\tF(j,1,h)if(j!=i)g.push_back(f[j-1]);\n\t\tif(dfs(d-1,g))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tgi(n);gi(v);\n\tF(i,1,n)gi(x[i]);\n\tD(i,n,2)x[i]-=x[i-1];\n\tx[1]=v+1;F(i,1,n)f[++m]=i;\n\tpre(v);f[m+1]=n+1;\n//\tprintf(\"%d\\n\",d);\n//\tF(i,1,d){F(j,1,n)printf(\"%d \",nxt[i][j]);puts(\"\");}puts(\"\");\n\tif(m>d+1){F(i,1,n)puts(\"Impossible\");return 0;}\n\tF(i,1,m){\n\t\tg.clear();\n\t\tF(j,1,m)if(j!=i)g.push_back(f[j]);\n\t\tp=dfs(d,g);F(j,f[i],f[i+1]-1)puts(p?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nvoid solve(\n    const vector<int>& x, const vector<int>& v,\n    vector<vector<int> >& next, vector<int>& dp)\n{\n    int n = x.size();\n    int m = v.size();\n\n    next.assign(n+1, vector<int>(m, n));\n    for(int i=0; i<m; ++i){\n        int k = 0;\n        for(int j=0; j<n; ++j){\n            if(k < j)\n                k = j;\n            while(k + 1 < n && abs(x[k+1] - x[k]) <= v[i])\n                ++ k;\n            next[j][i] = k + 1;\n        }\n    }\n\n    dp.assign(1<<m, 0);\n    for(int i=0; i<(1<<m); ++i){\n        bitset<32> bs(i);\n        for(int j=0; j<m; ++j){\n            if(bs[j])\n                continue;\n            bitset<32> bs2 = bs;\n            bs2[j] = true;\n            dp[bs2.to_ulong()] = max(dp[bs2.to_ulong()], next[dp[i]][j]);\n        }\n    }\n}\n\nint main()\n{\n    int n, v0;\n    cin >> n >> v0;\n    vector<int> x(n);\n    for(int i=0; i<n; ++i)\n        cin >> x[i];\n\n    vector<int> v(1, v0);\n    while(v.back() > 0)\n        v.push_back(v.back() / 2);\n    int m = v.size();\n\n    vector<vector<int> > rightNext, leftNext;\n    vector<int> rightDp, leftDp;\n    solve(x, v, rightNext, rightDp);\n    reverse(x.begin(), x.end());\n    solve(x, v, leftNext, leftDp);\n\n    vector<int> ans(n+1, 0);\n    for(int i=0; i<(1<<m); ++i){\n        if(i & 1)\n            continue;\n\n        int j = ((1<<m) - 1) ^ i ^ 1;\n        if(rightNext[rightDp[i]][0] + leftDp[j] >= n){\n            ++ ans[rightDp[i]];\n            -- ans[rightNext[rightDp[i]][0]];\n        }\n    }\n    for(int i=0; i<n; ++i)\n        ans[i+1] += ans[i];\n\n    for(int i=0; i<n; ++i){\n        if(ans[i] > 0)\n            cout << \"Possible\" << endl;\n        else\n            cout << \"Impossible\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define Re return\n#define In inline\n#define St static\n#define inc(l, i, r) for(i=l;   i<r;  ++i)\n#define dec(l, i, r) for(i=l-1; i>=l; --i)\n\nconst int mxn=1<<18;\n\nint n, m, v[20], a[mxn], bel[mxn][20], be[mxn][20], en[mxn][20], ans[mxn];\n//char f[mxn][mxn], g[mxn][mxn];\n\nint cnt[20], bit[mxn];\n\nIn void add(int i, int x)\n{if(i) for(;i<=n; i+=i&-i) bit[i]+=x;}\n\nIn int sum(int i)\n{\n    St int r;\n    for(r=0; i>0; i-=i&-i) r+=bit[i];\n    Re r;\n}\n\nchar DFS(int d, int x)\n{\n    int i, r=0;\n//    printf(\"%d %d %d\\n\", d, x, cnt[m]);\n    if(cnt[d]==1) Re 1;\n    inc(d+1, i, m) cnt[i]-=bel[en[x][d]][i]-bel[be[x][d]][i]+1;\n    cnt[m]-=en[x][d]-be[x][d]+1;\n    if(d==m-1 && cnt[m]==1)\n    {\n        inc(d+1, i, m) cnt[i]+=bel[en[x][d]][i]-bel[be[x][d]][i]+1;\n        cnt[m]+=en[x][d]-be[x][d]+1;\n        Re 1;\n    }\n    if(cnt[d+1]>m-d)\n    {\n        inc(d+1, i, m) cnt[i]+=bel[en[x][d]][i]-bel[be[x][d]][i]+1;\n        cnt[m]+=en[x][d]-be[x][d]+1;\n        Re 0;\n    }\n    add(en[x][d]+1, 1), add(be[x][d], -1);\n    inc(0, i, bel[n-1][d+1])\n        if(sum(en[i][d+1]+1)-sum(be[i][d+1])==0)\n            r|=DFS(d+1, i);\n    add(en[x][d]+1, -1), add(be[x][d], 1);\n    inc(d+1, i, m) cnt[i]+=bel[en[x][d]][i]-bel[be[x][d]][i]+1;\n    cnt[m]+=en[x][d]-be[x][d]+1;\n    Re r;\n}\n\nint main()\n{\n    int i, j, k;\n    scanf(\"%d%d\", &n, v);\n    for(i=1; v[i-1]/2; ++i) v[i]=v[i-1]>>1;\n    m=i;\n    inc(0, i, n) scanf(\"%d\", a+i);\n    \n    inc(1, i, n)\n        inc(0, j, m)\n        if(a[i]-a[i-1]<=v[j])\n            bel[i][j]=bel[i-1][j];\n        else bel[i][j]=bel[i-1][j]+1;\n    inc(0, j, m)\n    {\n        be[0][j]=0;\n        inc(0, i, n-1)\n            if(bel[i][j]!=bel[i+1][j])\n                en[bel[i][j]][j]=i, be[bel[i+1][j]][j]=i+1;\n        en[bel[n-1][j]][j]=n-1;\n        cnt[j]=bel[n-1][j]+1;\n    }\n    cnt[m]=n;\n    \n    inc(0, i, bel[n-1][0]+1)\n        if(DFS(0, i))\n            inc(be[i][0], j, en[i][0]+1)\n                ans[j]=1;\n    inc(0, i, n)\n        puts(ans[i]? \"Possible\": \"Impossible\");\n/*    inc(1, j, 1<<13) f[0][j]=1;\n    inc(0, i, n-1)\n        inc(1, j, 1<<13)\n        if(f[i][j])\n            for(k=~j&(1<<13)-1; k; k-=k&-k)\n                f[b[i][__builtin_ctz(k)]][j|k&-k]=1;\n\n    inc(1, j, 1<<13) g[n-1][j]=1;\n    dec(1, i, n)\n        inc(1, j, 1<<13)\n        if(g[i][j])\n            for(k=~j&(1<<13)-1; k; k-=k&-k)\n            f[c[i][__builtin_ctz(k)]][]*/\n    Re 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define Re return\n#define In inline\n#define St static\n#define inc(l, i, r) for(i=l;   i<r;  ++i)\n#define dec(l, i, r) for(i=r-1; i>=l; --i)\ntypedef pair<int, int> pint;\n#define fst first\n#define snd second\n#define mP make_pair\n\nconst int mxn=1<<20;\n\nint n, m, v[20], a[mxn], ans[mxn],  pre[mxn][20], nxt[mxn][20], f[mxn], g[mxn];\n\npint pr[mxn], que[mxn];\n\nIn void mxe(int& a, int b){a<b? a=b: 0;}\nIn void mne(int& a, int b){a>b? a=b: 0;}\n\nint main()\n{\n    int i, j, k, l;\n    scanf(\"%d%d\", &n, v);\n    for(i=1; v[i-1]/2; ++i)\n        v[i]=v[i-1]>>1;\n    m=i+1;\n    inc(1, i, n+1)\n        scanf(\"%d\", a+i);\n\n    inc(0, j, m) pre[1][j]=1;\n    inc(2, i, n+1)\n        inc(0, j, m)\n    {\n        if(a[i]-a[i-1]>v[j])\n            pre[i][j]=i;\n        else\n            pre[i][j]=pre[i-1][j];\n//        printf(\"%d %d:%d\\n\", i, j, pre[i][j]);\n    }\n    \n\n    inc(0, j, m) nxt[n][j]=n;\n    dec(1, i, n)\n        inc(0, j, m)\n        if(a[i+1]-a[i]>v[j])\n            nxt[i][j]=i;\n        else\n            nxt[i][j]=nxt[i+1][j];\n\n//    inc(0, i, m) printf(\"%d \", nxt[1][i]);puts(\"\");\n    \n    inc(0, i, 1<<m)\n        inc(0, j, m)\n        if(~i&1<<j)\n            if(f[i]<n) mxe(f[i|1<<j], nxt[f[i]+1][j]);\n            else mxe(f[i|1<<j], n);\n\n    inc(0, i, 1<<m) g[i]=n+1;\n    inc(0, i, 1<<m)\n        inc(0, j, m)\n        if(~i&1<<j)\n            if(g[i]>1) mne(g[i|1<<j], pre[g[i]-1][j]);\n            else mne(g[i|1<<j], 1);\n\n    inc(j=0, i, 1<<m-1)\n        pr[i]=mP(g[i<<1], i<<1);\n    inc(1, i, n+1)\n        if(pre[i][0]==i)\n            que[j++]=mP(i, nxt[i][0]);\n\n    sort(pr, pr+(1<<m-1)), sort(que, que+j);\n\n//    inc(0, i, 1<<m) printf(\"%d %d\\n\", f[i], g[i]);\n//    inc(0, i, 1<<m-1) printf(\"%d %d\")\n\n    inc(k=0, i, j)\n    {\n//        printf(\"%d -- %d\\n\", que[i].fst, que[i].snd);\n        for(;k<1<<m-1 && f[(1<<m)-2-pr[k].snd]<que[i].fst-1; ++k);\n        if(k==1<<m-1 || pr[k].fst>que[i].snd+1) continue;\n//        printf(\"%d !! %d\\n\", f[(1<<m)-2-pr[k].snd], pr[k].fst);\n        inc(que[i].fst, l, que[i].snd+1) ans[l]=1;\n    }\n\n    inc(1, i, n+1) puts(ans[i]? \"Possible\": \"Impossible\");\n    \n    Re 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nint x[200010],dv[200010],m,L[200010],R[200010],c[200010];\nstd::vector<int>P[200010];\nint fl[200010],fr[200010];\nint main(){\n#ifdef XZZSB\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),V=gi();\n\tfor(int i=1;i<=n;++i)x[i]=gi();\n\tfor(int i=V,j=0;~i;i>>=1,++j){\n\t\tdv[j]=i;P[m=j].push_back(0);\n\t\tfor(int l=1,r;l<=n;l=r+1){\n\t\t\tr=l;while(r<n&&x[r+1]-x[r]<=i)++r;\n\t\t\tP[j].push_back(r);\n\t\t\tif(!j)for(int o=l;o<=r;++o)L[o]=l,R[o]=r;\n\t\t}\n\t\tif(!i)break;\n\t}\n\tfor(int i=0;i<1<<m;++i){\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tif((i>>j-1)&1)continue;\n\t\t\tint p;\n\t\t\tif(fl[i]==n)p=n;\n\t\t\telse p=*std::upper_bound(P[j].begin(),P[j].end(),fl[i]);\n\t\t\tfl[i|(1<<j-1)]=std::max(fl[i|(1<<j-1)],p);\n\t\t}\n\t}\n\tfor(int i=0;i<1<<m;++i)fr[i]=n+1;\n\tfor(int i=0;i<1<<m;++i){\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tif((i>>j-1)&1)continue;\n\t\t\tint p;\n\t\t\tif(fr[i]==1)p=1;\n\t\t\telse p=*--std::lower_bound(P[j].begin(),P[j].end(),fr[i]-1)+1;\n\t\t\tfr[i|(1<<j-1)]=std::min(fr[i|(1<<j-1)],p);\n\t\t}\n\t}\n\tfor(int i=0;i<1<<m;++i){\n\t\tint l=fl[i]+1,r=fr[((1<<m)-1)^i]-1;\n\t\tif(l>r)++c[1];\n\t\telse if(*std::lower_bound(P[0].begin(),P[0].end(),l)>=r)++c[l],--c[r+1];\n\t}\n\tfor(int i=1;i<=n;++i)c[i]+=c[i-1];\n\tfor(int i=1;i<=n;++i)puts(c[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#pragma GCC target(\"sse4,tune=native\")\n#pragma GCC optimize(\"O3\",\"unroll-loops\")\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\nconst string FILENAME = \"input\";\nconst int MAXN = 200228;\n\n\nint n, v;\nint x[MAXN];\nint add[MAXN];\nint jumpl[20][MAXN], jumpr[20][MAXN];\nint dpl[1 << 18], dpr[1 << 18];\nint suff[1 << 18];\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t//read(FILENAME);\n\tcin >> n >> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t}\n\tvector<int> st;\n\twhile (v > 0) {\n\t\tst.pb(v);\n\t\tv /= 2;\n\t}\n\tst.pb(0);\n\treverse(all(st));\n\tfor (int j = 0; j < sz(st); j++) {\n\t//\tcout << st[j] << ' ' << j + 1 << endl;\n\t\tint uk = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (uk < i) {\n\t\t\t\tuk = i;\n\t\t\t}\n\t\t\twhile (uk + 1 < n && x[uk + 1] - x[uk] <= st[j]) {\n\t\t\t\t//cout << x[uk + 1] - x[uk] << ' ' << st[j] << endl;\n\t\t\t\tuk++;\n\t\t\t}\n\t\t\t//cout << uk << ' ' << j + 1 << endl;\n\t\t\tjumpl[j][i] = uk;\n\t\t}\n\t\tuk = n - 1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (uk > i) {\n\t\t\t\tuk = i;\n\t\t\t}\n\t\t\twhile (uk > 0 && x[uk] - x[uk - 1] <= st[j]) {\n\t\t\t\tuk--;\n\t\t\t}\n\t\t\tjumpr[j][i] = uk;\n\t\t}\n\t}\n\t//cout << jumpl[0][1] << endl;\n\tst.pop_back();\n\tfor (int mask = 0; mask < (1 << sz(st)); mask++) {\n\t\tif (mask == 0) {\n\t\t\tdpl[mask] = -1;\n\t\t\tdpr[mask] = n;\n\t\t} else {\n\t\t\tdpr[mask] = n;\n\t\t\tdpl[mask] = -1;\n\t\t\tfor (int i = 0; i < sz(st); i++) {\n\t\t\t\tif (mask & (1 << i)) {\n\t\t\t\t\tif (dpl[mask ^ (1 << i)] == n - 1) {\n\t\t\t\t\t\tdpl[mask] = n - 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchkmax(dpl[mask], jumpl[i][dpl[mask ^ (1 << i)] + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < sz(st); i++) {\n\t\t\t\tif (mask & (1 << i)) {\n\t\t\t\t\tif (dpr[mask ^ (1 << i)]  == 0) {\n\t\t\t\t\t\tdpr[mask] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchkmin(dpr[mask], jumpr[i][dpr[mask ^ (1 << i)] - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\t//cout << dpl[13] << endl;\n\t//cout << dpr[1] << endl;\n\tdpl[0] = 0;\n\tdpr[0] = n - 1;\n\tvector<pair<int, int> > p;\n\tfor (int mask = 0; mask < (1 << sz(st)); mask++) {\n\t\tint l = dpl[mask];\n\t\tint r = dpr[mask ^ ((1 << sz(st)) - 1)];\n\t\tp.pb({l, r});\n\t}\n\tsort(all(p));\n\tfor (int j = sz(p) - 1; j >= 0; j--) {\n\t\t//cout << p[j].first << ' ' << p[j].second << endl;\n\t\tsuff[j] = p[j].second;\n\t\tif (j < sz(p) - 1) {\n\t\t\tchkmin(suff[j], suff[j + 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint ll = jumpr[sz(st)][i];\n\t\tint rr = jumpl[sz(st)][i];\n\t//\tcout << ll << ' ' << rr << endl;\n\t\tint pos = lower_bound(all(p), make_pair(ll - 1, 0)) - p.begin();\t\n\t//\tcout << suff[pos] << ' ' << p[pos].first << endl;\n\t\tif (pos < sz(p) && suff[pos] <= rr + 1) {\n\t\t\tcout << \"Possible\\n\";\n\t\t} else {\n\t\t\tcout << \"Impossible\\n\";\n\t\t}\n\t}\n\treturn 0;\t\t\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 200005\n#define YXQAK printf(\"Possible\\n\")\n#define XFZBL printf(\"Impossible\\n\");\nusing namespace std;\n\nint a[M]={0},n,m,v,l[20][M]={0},r[20][M]={0};\nint f[M]={0},g[M]={0},p[M]={0};\n\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",a+i);\n\tsort(a+1,a+n+1); \n\tfor(int j=0,V=v;V;j++,V>>=1){\n\t\tm=max(m,j);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint I=i+1;\n\t\t\twhile(I<=n&&a[I]-a[I-1]<=V) I++;\n\t\t\tI--;\n\t\t\tfor(int ii=i;ii<=I;ii++) \n\t\t\tl[j][ii]=i,r[j][ii]=I;\n\t\t\ti=I;\n\t\t}\n\t}\n\tm++; \n\tfor(int i=1;i<=n;i++) l[m][i]=r[m][i]=i;\n\tfor(int i=0;i<(1<<m);i++) g[i]=n; f[0]=1;\n\tfor(int i=1;i<(1<<m);i++){\n\t\tint now=1;\n\t\tfor(int j=m-1;~j;j--)\n\t\tif((1<<j)&i)\n\t\tf[i]=max(f[i],r[j+1][f[i^(1<<j)]]+1);\n\t\t\n\t\tnow=n;\n\t\tfor(int j=m-1;~j;j--)\n\t\tif((1<<j)&i)\n\t\tg[i]=min(g[i],l[j+1][g[i^(1<<j)]]-1);\n\t}\n\t\n\tfor(int i=0;i<(1<<m);i++){\n\t\tif(r[0][f[i]]+1>=l[0][g[(1<<m)-i-1]])\n\t\tp[l[0][g[(1<<m)-i-1]]]++,p[r[0][f[i]]+1]--;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tp[i]+=p[i-1];\n\t\tif(p[i]) YXQAK;\n\t\telse XFZBL;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1009LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> ii;\ntypedef pair<ii, ii> i4;\n \nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n\n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nconst int N = 200005;\nint n, arr[N], sz, V, next_right[20][N], next_left[20][N];\nint DP_left[1<<20], DP_right[1<<20];\nvector<int> steps;\n\nint dp_left(int mask){\n    int &ans = DP_left[mask];\n    if(ans != -1)   return ans;\n    ans = 1;\n    for(int i=0;i<sz;i++)\n        if((mask >> i) & 1)\n            ans = max(ans, next_right[i][dp_left(mask^(1<<i))+1]);\n    return ans;\n}\n\nint dp_right(int mask){\n    int &ans = DP_right[mask];\n    if(ans != -1)   return ans;\n    ans = n;\n    for(int i=0;i<sz;i++)\n        if((mask >> i) & 1)\n            ans = min(ans, next_left[i][dp_right(mask^(1<<i))-1]);\n    return ans;\n}\n\n\n\nbool possible(int l, int r){\n    int mask = (1<<sz)-2; \n    for(int i=mask;i>=0;i=(i-1)&mask){\n// cout<<i<<\" \"<<(mask^i)<<\" \"<<mask<<\" \"<<dp_left(i)<<\" \"<<dp_right(mask^i)<<endl;\n        if((dp_left(i) >= l-1) && (dp_right(mask^i) <= r+1))    return true;\n        if(i == 0)  break;\n    }\n    return false;\n}\n\n\nint main(){\n \n    // ios_base::sync_with_stdio(0);\n    // cin.tie(0);\n\n    scanf(\"%d%d\", &n, &V);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\", &arr[i]);\n\n    while(V){\n        steps.pb(V);\n        V /= 2;\n    }\n    steps.pb(0);\n    sz = (int)steps.size();\n\n    for(int k=0;k<sz;k++){\n\n        next_right[k][n+1] = n+1;\n        next_right[k][n] = n;\n        for(int i=n-1;i>=1;i--)\n            if(arr[i+1]-arr[i] <= steps[k])\n                next_right[k][i] = next_right[k][i+1];\n            else\n                next_right[k][i] = i;\n        next_right[k][0] = next_right[k][1];\n\n        next_left[k][0] = 0;\n        next_left[k][1] = 1;\n        for(int i=2;i<=n;i++)\n            if(arr[i]-arr[i-1] <= steps[k])\n                next_left[k][i] = next_left[k][i-1];\n            else\n                next_left[k][i] = i;\n        next_left[k][n+1] = next_left[k][n];\n    }\n\n    int comps = 0, curr = 1;\n    while(curr <= n){\n        comps++;\n        curr = next_right[0][curr] + 1;\n    }\n\n    if(comps > sz+2){\n        for(int i=1;i<=n;i++)\n            printf(\"Impossible\\n\");\n        return 0;\n    }\n\n// cout<<\"steps: \";for(auto it : steps)    cout<<it<<\" \";cout<<endl;\n// cout<<\"next_right:\\n\";\n// for(int i=1;i<=n;i++){\n//     cout<<i<<\": \";for(int j=0;j<sz;j++) cout<<next_right[j][i]<<\" \";cout<<endl;\n// }cout<<endl;\n// cout<<\"next_left:\\n\";\n// for(int i=1;i<=n;i++){\n//     cout<<i<<\": \";for(int j=0;j<sz;j++) cout<<next_left[j][i]<<\" \";cout<<endl;\n// }cout<<endl;\n\n\n    memset(DP_left, -1, sizeof(DP_left));\n    memset(DP_right, -1, sizeof(DP_right));\n    curr = 1;\n    while(curr <= n){\n        if(possible(curr, next_right[0][curr])){\n            for(int i=curr;i<=next_right[0][curr];i++)\n                printf(\"Possible\\n\");\n        }\n        else{\n            for(int i=curr;i<=next_right[0][curr];i++)\n                printf(\"Impossible\\n\");\n        }\n        curr = next_right[0][curr]+1;\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <map>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int maxn = 550005;\nint x[maxn],l[maxn][19],r[maxn][19],n,V;\nint dpl[maxn],dpr[maxn],pos[maxn];\nbool upd(int &x,int y) {x>y?x=y:0;}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"agc012e.in\",\"r\",stdin);\n\t\tfreopen(\"agc012e.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d %d\",&n,&V);\n\tint k=0;while (V>>k) ++k;++k;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=0;j<k;j++) {\n\t\tif (i==1||x[i]-x[i-1]>(V>>j)) l[i][j]=i;\n\t\telse l[i][j]=l[i-1][j];\n\t}\n\tfor (int i=n;i>=1;i--)\n\tfor (int j=0;j<k;j++) {\n\t\tif (i==n||x[i+1]-x[i]>(V>>j)) r[i][j]=i;\n\t\telse r[i][j]=r[i+1][j];\n\t}\n\t\n\tint S=((1<<k)-1)^1;\n\tfor (int i=1;i<(1<<k);i+=2) {\n\t\tdpl[i]=0;dpr[i]=n+1;\n\t\tfor (int j=1;j<k;j++)\n\t\tif (i>>j&1) {\n\t\t\tdpl[i]=max(dpl[i],r[dpl[i^(1<<j)]+1][j]);\n\t\t\tdpr[i]=min(dpr[i],l[dpr[i^(1<<j)]-1][j]);\n\t\t}\n\t}\n\tfor (int i=1;i<=n+1;i++) pos[i]=n+1;\n\tfor (int i=1;i<(1<<k);i+=2)\n\t\tupd(pos[dpl[i]+1],dpr[S^i]-1);\n\tfor (int i=n;i>=1;i--) upd(pos[i],pos[i+1]);\n\t\n\tfor (int i=1;i<=n;i++)\n\t\tprintf(\"%s\\n\",pos[l[i][0]]<=r[i][0]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\t\n\tstd::ifstream ifs(\"test.in\");\n\n\tVAR(int, n, V);\n\t//int n, V;\n\t//ifs >> n >> V;\n\n\t//{\n\t//\tstd::random_device rnd;\n\t//\tstd::mt19937 mt(rnd());\n\t//\tstd::uniform_int_distribution<> rand(/* min */-1000000000, /* max */1000000000);\n\t//\tstd::set<int> set;\n\t//\twhile (set.size() < n) set.insert(rand(mt));\n\t//\tOUT(n)SP OUT(V)BR;\n\t//\tfor (auto x : set) {\n\t//\t\tOUT(x)SP;\n\t//\t}BR;\n\n\t//\treturn 0;\n\t//}\n\t\n\tVEC(int, x, n);\n\t//std::vector<int> x(n);\n\t//REP(i, n) ifs >> x[i];\n\n\n\n\tint height = 0;\n\twhile (V >= (1 << height)) ++height;\n\theight += 2;\n\tstd::vector<std::vector<int>> right(height);\n\tint vv = V;\n\tright[0].emplace_back(x[n - 1]);\n\tFOR(h, 1, height) {\n\t\tint r = n - 1;\n\t\tRREP(i, n - 1) {\n\t\t\tif (x[i + 1] - x[i] > vv || i == 0) {\n\t\t\t\tright[h].emplace_back(x[r]);\n\t\t\t\tr = i;\n\t\t\t}\n\t\t}\n\t\tif (x[1] - x[0] > vv) right[h].emplace_back(x[0]);\n\t\tstd::sort(ALL(right[h]));\n\t\tvv /= 2;\n\t}\n\n\tstd::vector<std::vector<int>> g(1);\n\tstd::map<PAIR, int> id;\n\tg.emplace_back(id[PAIR(0, x[n - 1])]);\n\tint p = 1;\n\tFOR(h, 1, height) {\n\t\tfor (auto v : right[h]) {\n\t\t\tint s = id[PAIR(h, v)] = p++;\n\t\t\tauto it = std::lower_bound(ALL(right[h - 1]), v);\n\t\t\tint par = *it;\n\t\t\tint t = id[PAIR(h - 1, par)];\n\t\t\tg.emplace_back(std::vector<int>{});\n\t\t\tg[s].emplace_back(t);\n\t\t\tg[t].emplace_back(s);\n\t\t}\n\t}\n\n\t/*SHOWVECTOR2(right);\n\n\tREP(i, g.size()) {\n\t\tfor (auto to : g[i]) {\n\t\t\tOUT(i)SP OUT(to)BR;\n\t\t}\n\t}*/\n\n\tstd::vector<int> v0;\n\tfor (auto v : g[0]) v0.emplace_back(v);\n\tstd::function<bool(std::vector<int>&, int, int)> check = [&](std::vector<int>& a, int pos, int rest) {\n\t\t//SHOWVECTOR(a);\n\t\tif (rest == 0) return true;\n\t\tif (a.empty()) return true;\n\t\tstd::vector<int> c;\n\t\tc.reserve(20);\n\t\tfor(auto v : a) {\n\t\t\tfor (auto to : g[v]) {\n\t\t\t\tif (v > to) continue;\n\t\t\t\tc.emplace_back(to);\n\t\t\t}\n\t\t}\n\t\tstd::sort(ALL(c));\n\t\tfor(auto v : a) {\n\t\t\tif (pos != -1) v = pos;\n\t\t\tif (c.size() - g[v].size() + 1 > rest - 1) continue;\n\t\t\tauto ts(c);\n\t\t\tfor (auto to : g[v]) {\n\t\t\t\tif (v > to) continue;\n\t\t\t\tts.erase(std::find(ALL(ts), to));\n\t\t\t}\n\t\t\tif (check(ts, -1, rest - 1)) return true;\n\t\t\tif (pos != -1) break;\n\t\t}\n\t\treturn false;\n\t};\n\n\tstd::vector<PAIR> ok;\n\tp = 0;\n\tfor (auto v : v0) {\n\t\tbool t = check(v0, v, height - 1);\n\t\tok.emplace_back(PAIR(right[1][p++], t));\n\t}\n\t//SHOWPAIRVECTOR(ok);\n\n\tp = 0;\n\tREP(i, n) {\n\t\tif (x[i] <= ok[p].first) {\n\t\t\tOUT(((ok[p].second) ? \"Possible\" : \"Impossible\"))BR;\n\t\t}\n\t\tif (x[i] == ok[p].first) ++p;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nint a[211111];\nvector<ii> interval[19];\nint pre[(1<<19)+11];\nint suf[(1<<19)+11];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,v; cin>>n>>v;\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tint cur=v;\n\tint id=0;\n\twhile(cur)\n\t{\n\t\tint curl=0;\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tif(a[i]-a[i-1]>cur)\n\t\t\t{\n\t\t\t\tinterval[id].pb(mp(curl,i-1));\n\t\t\t\tcurl=i;\n\t\t\t}\n\t\t}\n\t\tinterval[id].pb(mp(curl,n-1));\n\t\tcur>>=1; id++;\n\t}\n\tfor(int i=0;i<n;i++) interval[id].pb(mp(i,i));\n\tid++;\n\tpre[0] = -1; suf[0]=n;\n\tfor(int i=1;i<(1<<id);i++)\n\t{\n\t\tpre[i]=-1; suf[i]=n;\n\t\tfor(int j=0;j<id;j++)\n\t\t{\n\t\t\tif(i&(1<<j))\n\t\t\t{\n\t\t\t\tint mx = pre[i^(1<<j)];\n\t\t\t\tint tmp=upper_bound(interval[j].begin(),interval[j].end(),mp(mx+2,-1))-interval[j].begin();\n\t\t\t\ttmp--;\n\t\t\t\tif(tmp>=0&&tmp<interval[j].size())\n\t\t\t\t{\n\t\t\t\t\tint r=interval[j][tmp].se;\n\t\t\t\t\tpre[i]=max(pre[i],r);\n\t\t\t\t}\n\t\t\t\tint mn = suf[i^(1<<j)];\n\t\t\t\ttmp=lower_bound(interval[j].begin(),interval[j].end(),mp(mn,-1))-interval[j].begin();\n\t\t\t\ttmp--;\n\t\t\t\tif(tmp>=0&&tmp<interval[j].size())\n\t\t\t\t{\n\t\t\t\t\tint l=interval[j][tmp].fi; \n\t\t\t\t\tsuf[i]=min(suf[i],l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(interval[0].size()>20)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcout<<\"Impossible\\n\";\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<interval[0].size();i++)\n\t{\n\t\tint l=interval[0][i].fi; int r=interval[0][i].se;\n\t\tbool pos=0;\n\t\tfor(int j=0;j<(1<<id);j+=2)\n\t\t{\n\t\t\tint tot=(1<<id)-1; tot^=1;\n\t\t\tif(pre[j]>=l-1&&suf[tot^j]<=r+1)\n\t\t\t{\n\t\t\t\tfor(int k=l;k<=r;k++) cout<<\"Possible\\n\";\n\t\t\t\tpos=1; break;\n\t\t\t}\n\t\t}\n\t\tif(!pos)\n\t\t{\n\t\t\tfor(int k=l;k<=r;k++) cout<<\"Impossible\\n\";\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 400010;\nconst int M = 21;\n\nint a[N], v[N], dppre[1 << M], dpsuf[1 << M], pre[M][N], suf[N][M], ans[N];\nint n, V, m;\n\nint main(){\n\tscanf(\"%d%d\", &n, &V);\n\tv[0] = V;\n\tfor (int i = 1; ; ++ i){\n\t\tv[i] = v[i - 1] >> 1;\n\t\tif (!v[i]){\n\t\t\tm = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++ i){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 0; i < m; ++ i){\n\t\tpre[i][n - 1] = n - 1;\n\t\tfor (int j = n - 2; j >= 0; -- j){\n\t\t\tif (a[j + 1] - a[j] <= v[i]){\n\t\t\t\tpre[i][j] = pre[i][j + 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpre[i][j] = j;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; ++ i){\n\t\tsuf[i][0] = 0;\n\t\tfor (int j = 0; j < n - 1; ++ j){\n\t\t\tif (a[j + 1] - a[j] <= v[i]){\n\t\t\t\tsuf[i][j + 1] = suf[i][j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsuf[i][j + 1] = j + 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dppre, -1, sizeof(dppre));\n\tfor (int i = 0; i < 1 << m; ++ i){\n\t\tdpsuf[i] = n;\n\t}\n\tfor (int i = 0; i < 1 << m - 1; ++ i){\n\t\tint x = dppre[i];\n\t\tfor (int j = 0; j < m - 1; ++ j){\n\t\t\tif (i >> j & 1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint &y = dppre[i | 1 << j];\n\t\t\tif (x == n - 1){\n\t\t\t\ty = n - 1;\n\t\t\t}\n\t\t\ty = std::max(y, pre[j + 1][x + 1]);\n\t\t}\n\t\tx = dpsuf[i];\n\t\tfor (int j = 0; j < m - 1; ++ j){\n\t\t\tif (i >> j & 1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint &y = dpsuf[i | 1 << j];\n\t\t\tif (!x){\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t\ty = std::min(y, suf[j + 1][x - 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < 1 << m - 1; ++ i){\n\t\tint j = (1 << m - 1) - i - 1;\n\t\tint x = dppre[i] + 1, y = dpsuf[j] - 1;\n\t\tif (x >= y){\n\t\t\t++ ans[0];\n\t\t\t-- ans[n];\n\t\t}\n\t\tif (pre[0][x] >= y){\n\t\t\t++ ans[suf[0][x]];\n\t\t\t-- ans[pre[0][y] + 1];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++ i){\n\t\tans[i + 1] += ans[i];\n\t\tprintf(ans[i] ? \"Possible\\n\" : \"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nHanit Banga\n*/\n\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 2e5 + 10, M = log2(N) + 10;\nconst ll inf = 1e15;\n\nll x[N];\nint v[N] = {0}, dp_lt[2 * N] = {0}, dp_rt[2 * N] = {0}, lt[N][M] = {0}, rt[N][M] = {0};\n\nint main()\n{\n\tint n, val;\n\tcin >> n >> val;\n\tx[0] = -inf;\n\tx[n + 1] = inf;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcin >> x[i];\n\n\tint temp = val, m = 0;\n\tfor (int j = 0; temp > 0; ++j, temp /= 2, ++m)\n\t\tv[j] = temp;\n\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t{\n\t\t\tlt[i][j] = 1;\n\t\t\tif (x[i] - x[i - 1] <= v[j])\n\t\t\t\tlt[i][j] += lt[i - 1][j];\n\t\t}\n\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t{\n\t\t\trt[n - i + 1][j] = 1;\n\t\t\tif (x[n - i + 2] - x[n - i + 1] <= v[j])\n\t\t\t\trt[n - i + 1][j] += rt[n - i + 2][j];\n\t\t}\n\t}\n\n\tint subsets = (1 << m);\n\tfor (int i = 1; i < subsets; ++i)\n\t{\n\t\tfor (int j = 0; j < m; ++j)\n\t\t{\n\t\t\tif (i & (1 << j))\n\t\t\t{\n\t\t\t\ttemp = dp_lt[i - (1 << j)];\n\t\t\t\tdp_lt[i] = max(dp_lt[i], temp + rt[temp + 1][j + 1]);\n\t\t\t\t\n\t\t\t\ttemp = dp_rt[i - (1 << j)];\n\t\t\t\tdp_rt[i] = max(dp_rt[i], temp + lt[n - temp][j + 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tint l = lt[i][0], r = rt[i][0];\n\t\tl = i + 1 - l;\n\t\tr = r + i - 1;\n\n\t\tif (dp_lt[subsets - 1] >= l - 1 and dp_rt[subsets - 1] >= n - r)\n\t\t\tcout << \"Possible\\n\";\n\t\telse\n\t\t\tcout << \"Impossible\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, V;\n\nconst int maxn = 200010;\nint f[1<<20], g[1<<20];\nint x[maxn], l[maxn][20], r[maxn][20];\n\nint val[20];\nint m, mask;\n\nint main() {\n\tscanf(\"%d%d\", &N, &V);\n\tfor(int i = 0; i < N; ++i) scanf(\"%d\", &x[i]);\n\tfor(int v = V; v; v /= 2) val[m++] = v;\n\tval[m++] = 0;\n\tmask = (1 << m) - 2;\n\n\tfor(int i = 0; i < N; ++i) {\n\t\tfor(int j = 0; j < m; ++j) {\n\t\t\tl[i][j] = i;\n\t\t\tif(i && x[i] - x[i-1] <= val[j]) l[i][j] = l[i-1][j];\n\t\t}\n\t}\n\n\tfor(int i = N - 1; i >= 0; --i) {\n\t\tfor(int j = 0; j < m; ++j) {\n\t\t\tr[i][j] = i;\n\t\t\tif(i + 1 < N && x[i+1] - x[i] <= val[j]) r[i][j] = r[i+1][j];\n\t\t}\n\t}\n\n\tf[0] = 0;\n\tfor(int i = 0; i < 1<<m; ++i)\n\t\tfor(int j = 0; j < m; ++j) if((~i) >> j & 1) \n\t\t\tf[i | (1<<j)] = max(f[i | (1<<j)], f[i]==N?N:r[f[i]][j] + 1);\n\n\tmemset(g, 0x3f, sizeof(g));\n\tg[0] = N - 1;\n\tfor(int i = 0; i < 1<<m; ++i)\n\t\tfor(int j = 0; j < m; ++j) if((~i) >> j & 1) \n\t\t\tg[i | (1<<j)] = min(g[i | (1<<j)], g[i]==-1?-1:l[g[i]][j] - 1);\n\n\tfor(int i = 0; i < N; i = r[i][0] + 1) {\n\t\tbool flag = false;\n\t\tfor(int k = 0; k < 1<<m; k += 2) {\n\t\t\tif(f[k] >= i && g[k ^ mask] <= r[i][0]) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t}\n\t\tif(flag) for(int j = i; j <= r[i][0]; ++j) puts(\"Possible\");\n\t\telse for(int j = i; j <= r[i][0]; ++j) puts(\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint n,m,k,a[200100],l[200100][20],r[200100][20],f[270000],g[270000],ans[200100];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()) && ch!='-');\n    bool flag=ch=='-';\n    if (flag)\n        ch=getchar();\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return flag?-x:x;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    repu(i,1,n)\n        a[i]=getint();\n    for (k=0; m>>k; ++k);\n    a[0]=a[1]-m-1,a[n+1]=a[n]+m+1;\n    repu(i,0,k)\n        r[n+1][i]=n;\n    repu(i,1,n)\n        repu(j,0,k)\n        {\n            l[i][j]=a[i]-a[i-1]>m>>j?i:l[i-1][j];\n            for (r[i][j]=max(r[i-1][j],i); a[r[i][j]+1]-a[r[i][j]]<=m>>j; ++r[i][j]);\n        }\n    repu(i,0,(1<<k)-1)\n        g[i]=n+1;\n    repu(i,0,(1<<k)-1)\n        repu(j,1,k)\n            if (!(i&(1<<(j-1))))\n            {\n                int t=i|(1<<(j-1));\n                f[t]=max(f[t],r[f[i]+1][j]);\n                g[t]=min(g[t],l[g[i]-1][j]);\n            }\n    repu(i,0,(1<<k)-1)\n    {\n        int x=f[i],y=g[(1<<k)-1-i];\n        if (x+1>=y)\n            ++ans[1];\n        else\n            if (r[x+1][0]+1>=y)\n                ++ans[l[x+1][0]],--ans[r[x+1][0]+1];\n    }\n    repu(i,1,n)\n        puts((ans[i]+=ans[i-1])?\"Possible\":\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define CIN_ONLY if(1)\nstruct cww{cww(){\n    CIN_ONLY{\n        ios::sync_with_stdio(false);cin.tie(0);\n    }\n}}star;\n#define fin \"\\n\"\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define DEBUG if(0)\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l,T r)\n{bool a=l>r;if(a)l=r;return a;}\ntemplate <typename T>inline bool chmax(T &l,T r)\n{bool a=l<r;if(a)l=r;return a;}\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\n\nint T[5123456];\nint B[5123456];\nint E=0;\nint M=1;\ntypedef vector<int> V;\ntypedef vector<V> VV;\nint n,v;\nVV g;\nvector<LL> x;\nV build_graph(int vv,bool addedge=false){\n    vector<int> ret;\n    if(vv!=0)\n    build_graph(vv/2,true);\n    ret.pb(0);\n    FOR(i,1,n){\n        if(x[i]-x[i-1]>vv){\n            if(addedge){\n                T[E]=i;\n                B[E]=M;\n                g[ret.back()].pb(E++);\n                //cout<<ret.back()<<\" \"<<T[E-1]<<\" \"<<B[E-1]<<endl;\n            }\n            ret.pb(i);\n            \n        }\n    }\n    if(addedge){\n        T[E]=n;\n        B[E]=M;\n        g[ret.back()].pb(E++);\n        //cout<<ret.back()<<\" \"<<T[E-1]<<\" \"<<B[E-1]<<endl;\n\n        M++;\n    }\n    return ret;\n}\nint main(){\n    cin>>n>>v;\n    x.resize(n);\n    g.resize(n+1);\n    cin>>x;\n    auto CC=build_graph(v);\n    if(CC.size()>20){\n        REP(i,n)cout<<\"Impossible\"<<fin;\n    }\n    else{\n        CC.pb(n);\n        REP(i,CC.size()-1){\n            T[E]=CC[i+1];\n            B[E]=0;\n            g[CC[i]].pb(E);\n            //cout<<CC[i]<<\" \"<<CC[i+1]<<\" \"<<B[E]<<endl;\n\n            int top=0;\n            vector<int> dp(1<<M,0);\n            REP(bit,(1<<M)){\n                chmax(top,dp[bit]);\n                for(auto &e:g[dp[bit]]){\n                    int nxtbit=bit|(1<<B[e]);\n                    int cxtbit=bit^(1<<B[e]);\n                    if(nxtbit==cxtbit)\n                        chmax(dp[nxtbit],T[e]);\n                }\n            }\n            g[CC[i]].pop_back();\n            string res=\"Impossible\";\n            if(top==n)res=\"Possible\";\n            FOR(j,CC[i],CC[i+1])cout<<res<<fin;\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N,V, co;\nvi x;\nint nex[MX][20], pre[MX][20];\nint NEX[1<<19], PRE[1<<19];\n\nint main() {\n    setIO(); re(N,V); x.resz(N); re(x);\n    while (V>>co) co ++; // co <= 18 \n    co ++;\n    F0R(i,co) {\n        int sz = V>>i;\n        nex[N][i] = nex[N-1][i] = N;\n        F0Rd(j,N-1) {\n            if (x[j+1]-x[j] <= sz) nex[j][i] = nex[j+1][i];\n            else nex[j][i] = j+1;\n        }\n        pre[0][i] = pre[1][i] = 0;\n        FOR(j,2,N+1) {\n            if (x[j-1]-x[j-2] <= sz) pre[j][i] = pre[j-1][i];\n            else pre[j][i] = j-1;\n        }\n    }\n    // ps(co);\n    F0R(i,1<<co) PRE[i] = N;\n    F0R(i,1<<co) F0R(j,co) if (!(i&(1<<j))) {\n        ckmax(NEX[i^(1<<j)],nex[NEX[i]][j]);\n        ckmin(PRE[i^(1<<j)],pre[PRE[i]][j]);\n    }\n    if (NEX[(1<<co)-1] != N) {\n        F0R(i,N) ps(\"Impossible\");\n        exit(0);\n    }\n    for (int i = 0; i < N; i = nex[i][0]) {\n        // ps(\"HA\",i);\n        // i to nex[i][0]-1 \n        bool ok = 0;\n        for (int j = 0; j < (1<<co); j += 2) {\n            if (NEX[j] >= i && PRE[((1<<co)-2)^j] <= nex[i][0]) ok = 1;\n        }\n        FOR(k,i,nex[i][0]) ps(ok?\"Possible\":\"Impossible\");\n    }\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define chmax(a,b) a=max(a,b);\n#define N (1<<19)\n#define M 19\nll n,v;\nclass Alpha{\n public:\n ll f[N];\n P g[N][M];\n void setg(ll a[]){\n     for(int k=0;k<M;k++){\n         ll bef=-1e18,pnt=0; a[n]=1e18;\n         for(int i=0;i<=n;i++){\n          if(abs(a[i]-bef)>(v>>k)){\n           for(int j=pnt;j<i;j++)g[j][k]=make_pair(pnt,i-1);\n           pnt=i;   \n          }\n          bef=a[i];\n         }\n         if((v>>k)==0)break;\n     }\n }\n void main(ll a[]){\n  setg(a);   \n  for(int i=0;i<N;i++)f[i]=-1;\n  for(int i=0;i<N;i++){\n      for(int j=1;j<M;j++){\n          if(i&(1<<j))continue;\n          chmax(f[i+(1<<j)],g[f[i]+1][j].second);\n      }\n  }\n }\n};Alpha L,R;\n\nclass Solve{\n  public:\n  unordered_map<ll,bool> mas;\n  bool main(ll l,ll r){\n      if(mas.size()>M)return 0;\n      if(mas.find(l)!=mas.end()){\n       return mas[l];   \n      }\n      bool res=0;\n      for(int i=0;i<N;i++){\n       int ls=i,rs=N-1-i;\n       if(l-1<=L.f[ls]&&n-1-R.f[rs]<=r+1)res=1;\n      }\n      mas[l]=res;\n      return res;\n  }\n};Solve sv;\n\nll a[N];\nint main(){\n    cin>>n>>v;\n    for(int i=0;i<n;i++)cin>>a[i];\n    L.main(a);\n    for(int i=0;i<n/2;i++)swap(a[i],a[n-i-1]);\n    R.main(a);\n    for(int i=0;i<n;i++){\n     bool ans=sv.main(L.g[i][0].first,L.g[i][0].second);   \n     cout<<(ans?\"Possible\":\"Impossible\")<<endl;\n    }\n return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint x[252521];\nint ne[252521][20],rne[252521][20];\nint dp[(1<<20)+10],rdp[(1<<20)+10];\nvector<int> v;\nint main()\n{\n\tint n,V;\n\tcin>>n>>V;\n\trep(i,n) cin>>x[i];\n\twhile(V>0){\n\t\tv.pb(V);V/=2;\n\t}\n\tv.pb(0);int m=v.size();\n\trep(i,n) rep(j,m){\n\t\trne[i][j]=i;\n\t\tif(i>0 && x[i]-x[i-1]<=v[j]) rne[i][j]=rne[i-1][j];\n\t}\n\tfor(int i=n-1;i>=0;i--) rep(j,m){\n\t\tne[i][j]=i;\n\t\tif(i<n-1 && x[i+1]-x[i]<=v[j]) ne[i][j]=ne[i+1][j];\n\t}\n\tmemset(dp,0,sizeof(dp));\n\trep(i,(1<<20)+5) rdp[i]=n-1;\n\trep(i,(1<<m)) rep(j,m){\n\t\tif((i&(1<<j))>0) continue;\n\t\tdp[i+(1<<j)]=max(dp[i+(1<<j)],ne[dp[i]][j]+1);\n\t\trdp[i+(1<<j)]=min(rdp[i+(1<<j)],rne[rdp[i]][j]-1);\n\t}\n\t//rep(i,(1<<m)) cout<<i<<' '<<dp[i]<<' '<<rdp[i]<<endl;\n\tif(dp[(1<<m)-1]<n && rdp[(1<<m)-1]>=0){\n\t\tassert(dp[(1<<m)-1]<n && rdp[(1<<m)-1]>=0);\n\t\trep(i,n) cout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tint now=0;\n\twhile(now<n){\n\t\tint f=0;\n\t\trep(i,(1<<(m-1))){\n\t\t\tif(dp[(1<<m)-2-(i<<1)]>=now && rdp[(i<<1)]<=ne[now][0]) f=1;\n\t\t}\n\t\tREP(i,now,ne[now][0]+1){\n\t\t\tif(f>0) cout<<\"Possible\"<<endl;\n\t\t\telse cout<<\"Impossible\"<<endl;\n\t\t}\n\t\tnow=ne[now][0]+1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define chmax(a,b) a=max(a,b);\n#define N (1<<18)\n#define M 19\nll n,v;\nclass Alpha{\n public:\n ll f[N];\n P g[N][M];\n void setg(ll a[]){\n     for(int k=0;k<M;k++){\n         ll bef=-1e18,pnt=0; a[n]=1e18;\n         for(int i=0;i<=n;i++){\n          if(abs(a[i]-bef)>(v>>k)){\n           for(int j=pnt;j<i;j++)g[j][k]=make_pair(pnt,i-1);\n           pnt=i;   \n          }\n          bef=a[i];\n         }\n         if((v>>k)==0)break;\n     }\n }\n void main(ll a[]){\n  setg(a);   \n  for(int i=0;i<N;i++)f[i]=-1;\n  for(int i=0;i<N;i++){\n      for(int j=0;j<M-1;j++){\n          if(i&(1<<j))continue;\n          chmax(f[i+(1<<j)],g[f[i]+1][j+1].second);\n      }\n  }\n }\n};Alpha L,R;\n\nclass Solve{\n  public:\n  unordered_map<ll,bool> mas;\n  bool main(ll l,ll r){\n      if(mas.size()>30)return 0;\n      if(mas.find(l)!=mas.end()){\n       return mas[l];   \n      }\n      bool res=0;\n      for(int i=0;i<N;i++){\n       int ls=i,rs=N-1-i;\n       if(l-1<=L.f[ls]&&n-1-R.f[rs]<=r+1)res=1;\n      }\n      mas[l]=res;\n      return res;\n  }\n};Solve sv;\n\nll a[N];\nint main(){\n    cin>>n>>v;\n    for(int i=0;i<n;i++)cin>>a[i];\n    L.main(a);\n    for(int i=0;i<n/2;i++)swap(a[i],a[n-i-1]);\n    R.main(a);\n    for(int i=0;i<n;i++){\n     bool ans=sv.main(L.g[i][0].first,L.g[i][0].second);   \n     cout<<(ans?\"Possible\":\"Impossible\")<<endl;\n    }\n return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define bi(x) (1<<(x-1))\n#define rep(i,j,k) for (i=j;i<=k;i++)\n#define down(i,j,k) for (i=j;i>=k;i--)\nusing namespace std;\nconst int N=2e5+5,K=20,Sn=1<<18;\nint n,sn,V,v,k,i,j,lef,rig;\nint a[N],c[N],l[N],r[N];\nint rr[N][K],ls[Sn],rs[Sn];\nvoid work(int *r,int *rs)\n{\n\tint i,j,v=V;\n\trep(j,1,k)\n\t{\n\t\trr[n][j]=n;\n\t\tdown(i,n-1,1)\n\t\t\tif (abs(a[i+1]-a[i])<=v) rr[i][j]=rr[i+1][j];\n\t\t\telse rr[i][j]=i;\n\t\tv>>=1;\n\t}\n\trep(i,1,n) r[i]=rr[i][1];\n\trep(i,0,sn) rs[i]=0;\n\trep(i,0,sn-1)\n\t{\n\t\trep(j,2,k)\n\t\t\tif (!(i&bi(j)))\n\t\t\t\trs[i^bi(j)]=max(rs[i^bi(j)],rr[rs[i]+1][j]);\n\t}\t\n}\nint main()\n{\n//\tfreopen(\"camel.in\",\"r\",stdin);\n//\tfreopen(\"camel.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&V);\n\trep(i,1,n) scanf(\"%d\",&a[i]);\t\n\tfor (k=1,v=V;v>0;v>>=1) k++;\n\t\n\tsn=(1<<k)-1;\n\twork(r,rs);\n\treverse(a+1,a+1+n);\n\twork(l,ls);\n\t\n\trep(i,1,n) l[i]=n-l[i]+1;\n\treverse(l+1,l+1+n);\n\t\n\trep(i,0,sn) {\n\t\tlef=rs[i]; rig=n-ls[sn^i]+1;\n\t\tif (rig-lef<=1) c[1]++;\n\t\telse if (r[lef+1]>=rig-1) {\n\t\t\tc[l[lef+1]]++; c[r[lef+1]+1]--;\n\t\t}\n\t}\n\trep(i,1,n) {\n\t\tc[i]+=c[i-1];\n\t\tif (c[i]>0) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// a.cpp\n\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < __typeof(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < ll >\n# define pb push_back\n# define pdd pair < db , db >\ninline int readChar();\ntemplate <class T = int> inline T readInt();\ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x );\ninline void writeWord( const char *s );\n\n/** Read */\n\nstatic const int buf_size = 4096;\n\ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len)\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    if (pos == len)\n        return -1;\n    return buf[pos++];\n}\n\ninline int readChar() {\n    int c = getChar();\n    while (c <= 32)\n        c = getChar();\n    return c;\n}\n\ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n\n/** Write */\n\nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n\ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n\ntemplate <class T>\ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n\n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n\ninline void writeWord( const char *s ) {\n    while (*s)\n        writeChar(*s++);\n}\n\nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int RMQ[20][1 << 20];\n    static int Dp1[20][1 << 19];\n    static int Dp2[20][1 << 19];\n    int n,k;\n    n = readInt();\n    k = readInt();\n    static int s[1 << 20];\n    for (int i = 1;i <= n;++i)\n        s[i] = readInt();\n    int ok = 1;\n    for (int i = 1;i < n;++i)\n        ok &= s[i + 1] - s[i] <= k;\n    if (ok)\n    {\n        assert(0);\n        for (int i = 1;i <= n;++i)\n            PP;\n        return 0;\n    }\n    for (int i = 1;i < n;++i)\n        RMQ[0][i] = s[i + 1] - s[i];\n    for (int t = 1;n >> t;++t)\n        for (int i = 1;i + (1 << t) <= n;++i)\n            RMQ[t][i] = max(RMQ[t - 1][i],RMQ[t - 1][i + (1 << (t - 1))]);\n    static int Log[1 << 20];\n    for (int i = 2;i < (1 << 20);++i)\n        Log[i] = Log[i / 2] + 1;\n    auto get = [&](int l,int r)\n    {\n        int lg = Log[r - l + 1];\n        return max(RMQ[lg][l],RMQ[lg][r - (1 << lg) + 1]);\n    };\n    static int D1[1 << 20];\n    static int D2[1 << 20];\n    int lg = Log[k] + 2;\n    const int N = 1 << lg;\n    for (int t = 0;t < lg;++t)\n    {\n        Dp1[t][1] = 0;\n        for (int i = 2;i <= n;++i)\n            if (s[i] - s[i - 1] <= (k >> t))\n                Dp1[t][i] = Dp1[t][i - 1];\n            else\n                Dp1[t][i] = i - 1;\n        Dp2[t][n] = Dp2[t][n + 1] = n + 1;\n        for (int i = n - 1;i;--i)\n            if (s[i + 1] - s[i] <= (k >> t))\n                Dp2[t][i] = Dp2[t][i + 1];\n            else\n                Dp2[t][i] = i + 1;\n    }\n    D1[0] = 0;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            if ((mask >> i) & 1)\n                smax(D1[mask],Dp2[i][D1[mask ^ (1 << i)] + 1] - 1);\n    for (int mask = 0;mask < N;++mask)\n        D2[mask] = n + 1;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            smin(D2[mask],Dp1[i][D2[mask ^ (1 << i)] - 1] + 1);\n    static int answer[1 << 20];\n    for (int mask1 = 0;mask1 < N;++mask1)\n        if (!(mask1 & 1))\n        {\n            int mask2 = (N - 1) ^ 1 ^ mask1;\n            const int l = D1[mask1];\n            const int r = D2[mask2];\n            if (l + 1 > r - 1)\n                answer[1]++,--answer[n + 1];\n            else\n            if (l + 1 == r - 1 || get(l + 1,r - 2) <= k)\n                ++answer[l + 1],--answer[r];\n        }\n    for (int i = 1;i <= n;++i)\n        answer[i] += answer[i - 1];\n    for (int i = 1;i <= n;++i)\n        if (answer[i])\n            PP;\n        else\n            II;\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<stdlib.h>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nint p[210000];\nint q[210000];\nint c[210000];\nint L[1<<18];\nint R[1<<18];\nvector<int>en[18];\nvector<int>ee;\nlong long sum[210000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",p+i);\n\t\tif(i)q[i]=p[i]-p[i-1];\n\n\t}\n\tint tt=b;\n\tfor(int i=0;i<a;i++){\n\t\tif(tt<q[i])ee.push_back(i);\n\t}\n\tint BI=0;\n\tee.push_back(a);\n\tfor(int i=0;i<18;i++){\n\t\tif(tt==0)break;\n\t\tBI++;\n\t\ttt/=2;\n\t\tc[i]=tt;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(c[i]<q[j])en[i].push_back(j);\n\t\t}\n\t\ten[i].push_back(a);\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t\tint at=L[i];\n\t\tint tmp=b;\n\t\tfor(int j=0;j<BI;j++){\n\t\t//\ttmp/=2;\n\t\t\tif(i&(1<<j))continue;\n\t\t\tif(at==a){\n\t\t\t\tL[i+(1<<j)]=a;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to=upper_bound(en[j].begin(),en[j].end(),at)-en[j].begin();\n\n\t//\t\tprintf(\"%d %d %d %d %d\\n\",i,j,at,to,(int)(en[j].size()));\n\t\t\tL[i+(1<<j)]=max(L[i+(1<<j)],en[j][to]);\n\t\t//\tif(tmp==0)break;\n\t\t}\n\t}\n\t//return 0;\n\treverse(p,p+a);\n\tfor(int i=0;i<a;i++){\n\t\tif(i)q[i]=p[i-1]-p[i];\n\t}\n\tfor(int i=0;i<BI;i++)en[i].clear();\n\tfor(int i=0;i<BI;i++){\n\t\tif(c[i]){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(c[i]<q[j])en[i].push_back(j);\n\t\t\t}\n\t\t\ten[i].push_back(a);\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t\tint at=R[i];\n\t\tint tmp=b;\n\t\tfor(int j=0;j<BI;j++){\n\t\t//\ttmp/=2;\n\t\t\tif(i&(1<<j))continue;\n\t\t\tif(R[i]==a){\n\t\t\t\tR[i+(1<<j)]=a;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to=upper_bound(en[j].begin(),en[j].end(),at)-en[j].begin();\n\t//\t\tprintf(\"%d %d %d %d %d\\n\",i,j,at,to,(int)(en[j].size()));\n\t\t\tR[i+(1<<j)]=max(R[i+(1<<j)],en[j][to]);\n\t\t//\tif(tmp==0)break;\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t//\tif(i>=(1<<2))continue;\n\t//\tprintf(\"%d: %d %d\\n\",i,L[i],R[i]);\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t\tint left=L[i];\n\t\tint right=a-R[(1<<BI)-1-i];\n\t\tleft++;\n\t\tif(lower_bound(ee.begin(),ee.end(),right)-lower_bound(ee.begin(),ee.end(),left)<=0){\n\t\t\tsum[left]++;\n\t\t\tsum[right+1]--;\n\t//\t\tprintf(\"%d %d\\n\",left-1,right);\n\t\t}\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tsum[i+1]+=sum[i];\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tsum[i+1]+=sum[i];\n\t}\n\t//for(int i=0;i<=a;i++)printf(\"%lld \",sum[i]);printf(\"\\n\");\n\tfor(int i=0;i<a;i++){\n\t\tint left,right;\n\t\tint ind=upper_bound(ee.begin(),ee.end(),i)-ee.begin();\n\t\tif(ind==0)left=0;\n\t\telse left=ee[ind-1];\n\t\tind=upper_bound(ee.begin(),ee.end(),i)-ee.begin();\n\t\tright=ee[ind];\n//\t\tprintf(\"%d: %d %d\\n\",i,left,right);\n\t\tif(sum[left]==sum[right])printf(\"Impossible\\n\");\n\t\telse printf(\"Possible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, V;\nint X[200011];\n\n\nVI vs;\nint m;\n\nVI G[200011];\nint H[22];\nvoid calc(int dp[1<<20]) {\n    G[0].push_back(0);\n    REP (i, N) {\n\tREP (j, m) H[j] = -1;\n\twhile (!G[i].empty()) {\n\t    int s = G[i].back(); G[i].pop_back();\n\t    if (dp[s] != i) continue;\n\n\t    REP (j, m) if (~s>>j&1) {\n\t\tint right;\n\t\tif (i == 0 || X[i]-X[i-1] > vs[j]) {\n\t\t    if (H[j] == -1) {\n\t\t\tright = i+1;\n\t\t\twhile (right < N && X[right]-X[right-1] <= vs[j]) right++;\n\t\t\tH[j] = right;\n\t\t    } else {\n\t\t\tright = H[j];\n\t\t    }\n\t\t} else {\n\t\t    continue;\n\t\t}\n\t\tif (dp[s|(1<<j)] < right) {\n\t\t    dp[s|(1<<j)] = right;\n\t\t    G[right].push_back(s|(1<<j));\n\t\t}\n\t    }\n\t}\n    }\n//    rprintf(\"%d\", dp, dp+(1<<m));\n}\nint L[1<<20], R[1<<20];\n\nint Z[200011];\n\nvoid MAIN() {\n#ifdef LOCAL\n    N = 200000;\n    V = 100000;\n    REP (i, N) X[i] = i * 10;\n#else\n    scanf(\"%d%d\", &N, &V);\n    REP (i, N) scanf(\"%d\", X+i);\n#endif\n    m = V;\n    while (1) {\n\tvs.push_back(m);\n\tif (m == 0) break;\n\tm/=2;\n    }\n    m = vs.size();\n\n    calc(L);\n    reverse(X, X+N);\n    REP (i, N) X[i] = -X[i];\n    calc(R);\n    reverse(X, X+N);\n    REP (i, N) X[i] = -X[i];\n\n    memset(Z, 0xc0, sizeof Z);\n    REP (s, 1<<m) if (~s&1) {\n\tint t = ((1<<m)-1) ^ s ^ 1;\n\tamax(Z[N-R[t]], L[s]);\n    }\n\n    int ma = Z[0];\n    for (int i=0; i<N; ) {\n\tint j = i;\n\twhile (j < N && (j == i || X[j] - X[j-1] <= V)) {\n\t    j++;\n\t    amax(ma, Z[j]);\n\t}\n\n\tfor (int k=i; k<j; k++) {\n\t    puts(i<=ma? \"Possible\": \"Impossible\");\n\t}\n\t//eprintf(\"%d\\n\", ma);\n\ti = j;\n    }\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 2e5 + 5;\nconst int K = 20;\nint n;\nint v[K];\nint k;\nint arr[N];\nint nxt[K][N];\nint prv[K][N];\nint dp1[1 << K];\nint dp2[1 << K];\nint pre(int mask){\n\tif(dp1[mask] != -1){\n\t\treturn dp1[mask];\n\t}\n\tint res = 1;\n\tfor(int i = 1 ; i < k ; ++i){\n\t\tif((mask >> i) & 1){\n\t\t\tint tmp = pre(mask ^ (1 << i));\n\t\t\tres = max(res , nxt[i][tmp + 1] - 1);\n\t\t}\n\t}\n\treturn dp1[mask] = res;\n}\nint suf(int mask){\n\tif(dp2[mask] != -1){\n\t\treturn dp2[mask];\n\t}\n\tint res = n;\n\tfor(int i = 1 ; i < k ; ++i){\n\t\tif((mask >> i) & 1){\n\t\t\tint tmp = suf(mask ^ (1 << i));\n\t\t\tres = min(res , prv[i][tmp - 1] + 1);\n\t\t}\n\t}\n\treturn dp2[mask] = res;\n}\nbool solve(int lft , int rgt){\n\tint mask = (1 << k) - 2;\n\tfor(int i = mask ; i ; i = (i - 1) & mask){\n\t\tif(pre(i) >= lft && suf(mask ^ i) <= rgt){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn pre(0) >= lft && suf(mask) <= rgt;\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tscanf(\"%d\" , &v[0]);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tscanf(\"%d\" , arr + i);\n\t}\n\tk = 1;\n\tfor(int i = 1 ; i < K ; ++i){\n\t\tv[i] = v[i - 1] >> 1;\n\t\tif(v[i]){\n\t\t\tk = i + 1;\n\t\t}\n\t}\n\tv[k++] = 0;\n\tfor(int i = 0 ; i < k ; ++i){\n\t\tnxt[i][n] = n + 1;\n\t\tnxt[i][n + 1] = n + 1;\n\t\tfor(int j = n - 1 ; j >= 1 ; --j){\n\t\t\tif(arr[j + 1] - arr[j] <= v[i]){\n\t\t\t\tnxt[i][j] = nxt[i][j + 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnxt[i][j] = j + 1;\n\t\t\t}\n\t\t}\n\t\tprv[i][1] = 0;\n\t\tprv[i][0] = 0;\n\t\tint steps = 1;\n\t\tfor(int j = 2 ; j <= n ; ++j){\n\t\t\tif(arr[j] - arr[j - 1] <= v[i]){\n\t\t\t\tprv[i][j] = prv[i][j - 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++steps;\n\t\t\t\tprv[i][j] = j - 1;\n\t\t\t}\n\t\t}\n\t\tif(!i && steps > k + 5){\n\t\t\tfor(int i = 1 ; i <= n ; ++i){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmemset(dp1 , -1 , sizeof(dp1));\n\tmemset(dp2 , -1 , sizeof(dp1));\n\tfor(int i = 1 ; i <= n ; i = nxt[0][i]){\n\t\tbool ans = solve(prv[0][i] , nxt[0][i]);\n\t\tfor(int j = i ; j < nxt[0][i] ; ++j){\n\t\t\tputs(ans ? \"Possible\" : \"Impossible\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 200010\n#define LG 25\nint R[LG][MAXN],L[LG][MAXN],fl[4194304],fr[4194304];\nint V[LG],cnt,X[MAXN],lg,tot,n,x[MAXN];\nvoid Min(int &x,int y)\n{\n\tif(x>y) x=y;\n}\nvoid Max(int &x,int y)\n{\n\tif(x<y) x=y;\n}\nint main()\n{\n\t\n\tscanf(\"%d%d\",&n,&V[0]);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\twhile(V[lg])\n\t\tV[++lg]=V[lg-1]/2;\n\tfor(int i=0;i<=lg;i++)\n\t{\n\t\tint ls=0;\n\t\tfor(int j=2;j<=n+1;j++)\n\t\t\tif(x[j]-x[j-1]>V[i]||j==n+1)\n\t\t\t{\n\t\t\t\tfor(int k=ls;k<j-1;k++)\n\t\t\t\t\tL[i][k]=j-1;\n\t\t\t\tfor(int k=ls+2;k<=j;k++)\n\t\t\t\t\tR[i][k]=ls+1;\n\t\t\t\tls=j-1;\n\t\t\t\tif(i==0) X[++cnt]=j-1;\n\t\t\t}\n\t}\n\tif(cnt>lg+1)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\ttot=1<<(lg+1);\n\tfor(int i=0;i<tot;i+=2)\n\t\tfr[i]=n+1;\n\tfor(int i=0;i<tot;i+=2)\n\t\tfor(int j=1;j<=lg;j++)\n\t\t\tif((i&(1<<j))==0)\n\t\t\t{\n\t\t\t\tMax(fl[i|(1<<j)],L[j][fl[i]]);\n\t\t\t\tMin(fr[i|(1<<j)],R[j][fr[i]]);\n\t\t\t}\n\tfor(int i=1;i<=cnt;i++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int j=0;j<tot;j+=2)\n\t\t\tif(fl[j]>=X[i-1]&&fr[tot-j-2]<=X[i]+1)\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(int j=X[i-1]+1;j<=X[i];j++)\n\t\t\tif(flag) printf(\"Possible\\n\");\n\t\t\telse printf(\"Impossible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n\n#define MAXN 200005\n#define MAXB 21\n\nusing namespace std;\n\nconst int INF = 1e9 + 2e6;\nint v[MAXN], n, m;\nint d[MAXN], up[MAXN][MAXB], down[MAXN][MAXB], pre[1 << MAXB], suf[1 << MAXB];\nint visit[MAXN];\n\nint read() {\n    char c = getchar();\n    int x = 0, s = 1;\n    while (!isdigit(c)) {\n        if (c == '-')\n            s = -1;\n        c = getchar();\n    }\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x * s;\n}\n\nvoid init() {\n    while (v[++m] >= 1)\n        v[m + 1] = v[m] >> 1;\n    d[0] = -INF;\n    d[n + 1] = INF;\n    for (int j = 1; j <= m; ++j) {\n        up[1][j] = 1;\n        down[n][j] = n;\n        for (int i = 2; i <= n; ++i)\n            if (d[i] - d[i - 1] <= v[j])\n                up[i][j] = up[i - 1][j];\n            else\n                up[i][j] = i;\n        for (int i = n - 1; i >= 1; --i)\n            if (d[i + 1] - d[i] <= v[j])\n                down[i][j] = down[i + 1][j];\n            else\n                down[i][j] = i;\n    }\n}\n\nvoid solve() {\n    memset(suf, 0x3f, sizeof(suf));\n    memset(pre, -0x3f, sizeof(pre));\n    suf[0] = n + 1;\n    pre[0] = 0;\n    int limit = (1 << m) - 1;\n    for (int s = 0; s <= limit; ++s) {\n        for (int i = 1; i <= m; ++i) {\n            if (s >> (i - 1) & 1)\n                continue;\n            int t = s | (1 << (i - 1));\n            if (pre[s] >= 0)\n                pre[t] = max(pre[t], down[pre[s] + 1][i]);\n            if (suf[s] <= n + 1)\n                suf[t] = min(suf[t], up[suf[s] - 1][i]);\n        }\n    }\n    for (int s = 0; s <= limit; ++s) {\n        if (s & 1)\n            continue;\n        int t = limit ^ s;\n        int a = up[suf[t] - 1][1], b = down[pre[s] + 1][1];\n        if (a <= b) {\n            ++visit[a];\n            --visit[b + 1];\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n        visit[i] = visit[i - 1] + visit[i];\n    for (int i = 1; i <= n; ++i)\n        if (visit[i])\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n}\n\nint main() {\n    n = read();\n    v[1] = read();\n    for (int i = 1; i <= n; ++i)\n        d[i] = read();\n    init();\n    solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 200005\n#define MAXM 18\n#define MAXK (1<<MAXM)\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\n#define prev daksiisaas\n#define next aijdkjsaod\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\nint N,V,x[MAXN];\nvector<int> v;\nint prev[MAXN][MAXM],next[MAXN][MAXM];\nint predp[MAXK],sufdp[MAXK];\nint ans[MAXN];\nint mini[MAXN];\nint main()\n{\n    scanf(\"%d%d\",&N,&V);\n    for(int i=1;i<=N;i++) scanf(\"%d\",&x[i]);\n    int dummy=V;\n    while(dummy)\n    {\n        v.push_back(dummy);\n        dummy/=2;\n    }\n    v.push_back(0);\n    reverse(v.begin(),v.end());\n    int sz=(int)v.size();\n    for(int i=(int)v.size()-1;i>=0;i--) next[N][i]=N;\n    for(int i=N-1;i>=0;i--)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i+1]-x[i]>v[j]) next[i][j]=i; else next[i][j]=next[i+1][j];\n    for(int i=(int)v.size()-1;i>=0;i--) prev[1][i]=1;\n    for(int i=2;i<=N;i++)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i]-x[i-1]>v[j]) prev[i][j]=i; else prev[i][j]=prev[i-1][j];\n    //for(int i=1;i<=N;i++) printf(\"%d %d %d %d\\n\",prev[i][1],prev[i][2],next[i][1],next[i][2]);\n    memset(predp,0,sizeof(predp));\n    predp[0]=1;\n    for(int mask=0;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            predp[mask^(1<<j)]=max(predp[mask^(1<<j)],next[min(predp[mask]+1,N)][j]);\n        }\n    }\n    for(int mask=0;mask<(1<<sz);mask++) sufdp[mask]=N;\n    sufdp[0]=N;\n    for(int mask=0;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            sufdp[mask^(1<<j)]=min(sufdp[mask^(1<<j)],prev[max(sufdp[mask]-1,1)][j]);\n        }\n    }\n    for(int i=0;i<=N+1;i++) mini[i]=N+2; \n    for(int mask=0;mask<(1<<(sz-1));mask++)\n    {\n        int dmask=(1<<(sz-1))-1-mask;\n        int l,r;\n        if(mask==0) l=0; else l=predp[mask];\n        if(dmask==0) r=N+1; else r=sufdp[dmask];\n        //printf(\"%d %d %d %d\\n\",mask,dmask,l,r);\n        mini[l]=min(mini[l],r);\n    }\n    for(int i=N;i>=0;i--) mini[i]=min(mini[i],mini[i+1]);\n    for(int i=1;i<=N;i++)\n    {\n        int l=prev[i][sz-1],r=next[i][sz-1];\n        if(l==1&&r==N) {puts(\"Possible\"); continue;}\n        //printf(\"%d %d\\n\",l,r);\n        if(mini[l-1]<=r+1) puts(\"Possible\"); else puts(\"Impossible\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\ninline int rnd(int x){\n\treturn rand()%x;\n}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=18,N=200005,inf=1e9+3e5;\nint n,v,gao,f[1<<M],g[1<<M],x[N],lst[M][N],nxt[M][N],tong[N];\nint main(){\n\tn=read(); v=read(); x[0]=-inf; x[n+1]=inf;\n\tfor(int i=1;i<=n;i++)x[i]=read();\n\tfor(int i=0;;i++){\n\t\tint dali=v>>i; gao=i; nxt[i][n+1]=n+1; lst[i][0]=0;\n\t\tfor(int j=1;j<=n;j++)if(x[j]-x[j-1]<=dali)lst[i][j]=lst[i][j-1]; else lst[i][j]=j;\n\t\tfor(int j=n;j;j--)if(x[j+1]-x[j]<=dali)nxt[i][j]=nxt[i][j+1]; else nxt[i][j]=j;\n\t\tif((v>>i)==0)break;\n\t}\n\tf[0]=0; g[0]=n+1; \n\tfor(int i=1;i<(1<<gao);i++){\n\t\tf[i]=0; g[i]=n+1;\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)f[i]=max(f[i],nxt[j+1][f[i^(1<<j)]+1]);\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)g[i]=min(g[i],lst[j+1][g[i^(1<<j)]-1]);\n\t}\n\tfor(int i=0;i<=n+1;i++)tong[i]=-1;\n\tfor(int i=0;i<(1<<gao);i++){\n\t\tint l=f[i],r=g[((1<<gao)-1)^i];\n\t\ttong[r]=max(tong[r],l);\n\t}\n\tfor(int i=1;i<=n;i++)tong[i]=max(tong[i],tong[i-1]);\n\tfor(int i=1;i<=n;i++){\n\t\tint l=lst[0][i],r=nxt[0][i];\n\t\tputs(tong[r+1]>=l-1?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 200010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;if(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\n\nint b[40],sz,a[N],c[N];\nint dp[1<<18],f[1<<18],l[N][20],r[N][20];\nint main(){\n    //freopen(\"A.in\",\"r\",stdin);\n    //freopen(\"A.out\",\"w\",stdout);\n    //cout<<setprecision(9)<<fixed;\n    //cerr<<setprecision(9)<<fixed;\n    int T,i,j,k,ca=0,m,K,n;\n    scanf(\"%d%d\",&n,&m);\n    K=m;sz=0;\n    while(K)b[sz++]=K,K>>=1;\n    b[sz++]=0;\n    swap(b[0],b[sz-1]);\n    rep(i,0,n)scanf(\"%d\",&a[i]);\n    rep(k,0,sz){\n        K=b[k];\n        //cerr<<k<<\" \"<<K<<\"\\n\";\n        l[0][k]=0;\n        rep(i,1,n){\n            if(K>=a[i]-a[i-1])l[i][k]=l[i-1][k];\n            else l[i][k]=i;\n        }\n        r[n-1][k]=n-1;\n        per(i,0,n-1){\n            if(K>=a[i+1]-a[i])r[i][k]=r[i+1][k];\n            else r[i][k]=i;\n        }\n    }\n    sz--;\n    memset(dp,-1,sizeof(dp));\n    dp[0]=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Max(dp[i|1<<j],x);\n            if(x+1<n)Max(dp[i|1<<j],r[x+1][j]);\n        }\n    }\n    per(i,0,(1<<sz))f[i]=n;\n    f[0]=n-1;\n    rep(i,0,(1<<sz)){\n        int x=f[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Min(f[i|1<<j],x);\n            if(x)Min(f[i|1<<j],l[x-1][j]);\n        }\n    }\n    int mask=(1<<sz)-1,flag=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i],y=f[mask^i];\n        if(y<=x+1){\n            flag=1;break;\n        }\n        k=r[x+1][sz];\n        j=l[y-1][sz];\n        if(j<=x+1&&k>=y-1)c[j]++,c[k+1]--;\n    }\n    /*\n    if(flag){\n        rep(i,0,n)puts(\"Possible\");\n    }\n    else\n    {\n        rep(i,1,n)c[i]+=c[i-1];\n        rep(i,0,n){\n            if(c[i])puts(\"Possible\");\n            else puts(\"Impossible\");\n        }\n    }//*/\n    \n    rep(i,0,n){\n        int x=l[i][sz],y=r[i][sz],ok=0;\n        //cerr<<i<<\" \"<<x<<\" \"<<y<<\"\\n\";\n        rep(j,0,(1<<sz)){\n            k=mask^j;\n            //cerr<<j<<\" \"<<dp[j]<<\",\"<<k<<\" \"<<f[k]<<\"\\n\";\n            if(dp[j]>=x-1&&f[k]<=y+1){ok=1;break;}\n        }\n        puts(ok?\"Y\":\"N\");\n    }//*/\n    //cerr<<clock()*1./CLOCKS_PER_SEC<<\"ms\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define go(x, i, v) for (int i = hd[x], v = to[i]; i; v = to[i = nx[i]])\nLL read() {\n  long long x = 0, w = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) w = ch == '-' ? -1 : 1, ch = getchar();\n  while (isdigit(ch)) {\n    x = (x << 3) + (x << 1) + ch - '0';\n    ch = getchar();\n  }\n  return x * w;\n}\nconst int Max_n = 2e5 + 5;\nint n, v;\nint a[Max_n];\nint cntl, l[Max_n][18], r[Max_n][18];\nint f[Max_n], g[Max_n], h[Max_n];\nvoid Max(int &a, int b) { a = a < b ? b : a; }\nvoid Min(int &a, int b) { a = a < b ? a : b; }\nint main() {\n  n = read(), v = read();\n  for (int i = 1; i <= n; i++) a[i] = read(), h[i] = n + 2;\n  h[0] = h[n + 1] = n + 2;\n  v <<= 1;\n  do {\n    cntl++, v >>= 1;\n    l[1][cntl] = l[0][cntl] = 1;\n    for (int i = 2; i <= n; i++) {\n      l[i][cntl] = i;\n      if (a[i] - a[i - 1] <= v)\n        l[i][cntl] = l[i - 1][cntl];\n    }\n    r[n][cntl] = r[n + 1][cntl] = n;\n    for (int i = n - 1; i; i--) {\n      r[i][cntl] = i;\n      if (a[i + 1] - a[i] <= v)\n        r[i][cntl] = r[i + 1][cntl];\n    }\n    //cout << v << endl;\n    //for (int i = 1; i <= n; i++)\n    //  cout << l[i][cntl] << \" \" << r[i][cntl] << endl;\n    //cout << endl;\n  } while (v);\n  for (int s = 0; s < (1 << cntl); s++) g[s] = n + 1;\n  for (int s = 0; s < (1 << cntl); s++) {\n    if (s & 1) continue;\n    for (int i = 2; i <= cntl; i++)\n      if (!((1 << i - 1) & s)) {\n        Max(f[s | (1 << i - 1)], r[f[s] + 1][i]);\n        Min(g[s | (1 << i - 1)], l[g[s] - 1][i]);\n      }\n  }\n  for (int s = 0; s < (1 << cntl); s++) {\n    if (s & 1) continue;\n    //cout << s << \" \" << f[s] << \" \" << (1 << cntl) - 2 - s << \" \" << g[(1 << cntl) - 2 - s] << endl;\n    Min(h[f[s]], g[(1 << cntl) - 2 - s]);\n  }\n  //for (int i = 1; i <= n; i++)\n  //  cout << h[i] << \" \";\n  //cout << endl;\n  //for (int i = n; i >= 1; i--) Min(h[i], h[i + 1]);\n  for (int i = 1; i <= n; i++)\n    if (h[l[i][1] - 1] <= r[i][1] + 1)\n      printf(\"Possible\\n\");\n    else\n      printf(\"Impossible\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nconst int N=2e5+7,LOG=20;\nint x[N],v[N],L[LOG][N],R[LOG][N],val[N],Lf[N],Rf[N],n,k,tot;\nint main(){\n    read(n);\n    read(v[0]);\n    while(v[k]) v[k+1]=v[k]>>1,k++;\n    tot=(1<<k)-1;\n    for(int i=1;i<=n;i++)\n        read(x[i]);\n    for(int i=0;i<=k;i++){\n        L[i][1]=1;\n        for(int j=2;j<=n;j++) \n            if(x[j]-x[j-1]<=v[i]) \n                L[i][j]=L[i][j-1];\n            else L[i][j]=j;\n        R[i][n]=n;\n        for(int j=n-1;j>=0;j--) \n            if(x[j+1]-x[j]<=v[i]) \n                R[i][j]=R[i][j+1];\n            else R[i][j]=j;\n    }\n    for(int i=1;i<=tot;i++) \n        Lf[i]=1,Rf[i]=n;\n    Lf[0]=0,Rf[0]=n+1;\n    for(int i=0;i<=tot;i++)\n        for(int j=1;j<=k;j++) \n            if(!((i>>(j-1))&1)) {\n                Lf[i|(1<<(j-1))]=max(Lf[i|(1<<(j-1))],R[j][Lf[i]+1]);\n                Rf[i|(1<<(j-1))]=min(Rf[i|(1<<(j-1))],L[j][Rf[i]-1]);\n            }\n    for(int i=0;i<=n+1;i++) \n        val[i]=2*n;\n    for(int i=0;i<=tot;i++) \n        val[Lf[i]]=min(val[Lf[i]],Rf[tot^i]);\n    for(int i=n;i;i--) \n        val[i]=min(val[i],val[i+1]);\n    for(int i=1;i<=n;i++) \n        printf(val[L[0][i]-1]<=R[0][i]+1?\"Possible\\n\":\"Impossible\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ninline int read() {\n\tint ret, cc, sign = 1;\n\twhile (!isdigit(cc = getchar()))\n\t\tsign = cc == '-' ? -1 : sign;\n\tret = cc - 48;\n\twhile ( isdigit(cc = getchar()))\n\t\tret = cc - 48 + ret * 10;\n\treturn ret * sign;\n}\n\nconst int MAXN = 300010;\nint val[MAXN];\nint pos[MAXN];\nint left[30][MAXN];\nint right[30][MAXN];\nint dp[2][MAXN];\nint tot, n, V;\n\nint main() {\n#ifdef ARK\n\tfreopen(\"test.in\", \"r\", stdin);\n#endif\n\tn = read(), V = read();\n\tfor (int i = 1; i <= n; ++i)\n\t\tpos[i] = read();\n\n\tval[0] = V / 2;\n\twhile (val[tot]) \n\t\tval[tot + 1] = val[tot] / 2, ++tot;\n\n\tfor (int i = 0; i <= tot; ++i) {\n\t\tright[i][n + 1] = n + 1, right[i][n] = n;\n\t\tfor (int j = n - 1; j >= 1; --j) \n\t\t\tif (pos[j + 1] - pos[j] <= val[i])\n\t\t\t\tright[i][j] = right[i][j + 1];\n\t\t\telse\n\t\t\t\tright[i][j] = j;\n\n\t\tleft[i][1] = 1;\n\t\tfor (int j = 2; j <= n; ++j)\n\t\t\tif (pos[j] - pos[j - 1] <= val[i])\n\t\t\t\tleft[i][j] = left[i][j - 1];\n\t\t\telse\n\t\t\t\tleft[i][j] = j;\n\t}\n\n\tint U = (1 << (tot + 1)) - 1;\n\tdp[0][0] = 0, dp[1][0] = n + 1;\n\tfor (int S = 1; S <= U; ++S) {\n\t\tdp[1][S] = n + 1;\n\t\tfor (int j = 0; j <= tot; ++j) \n\t\t\tif (S >> j & 1) {\n\t\t\t\tdp[0][S] = std::max(right[j][dp[0][S ^ (1 << j)] + 1], dp[0][S]);\n\t\t\t\tdp[1][S] = std::min(left[j][dp[1][S ^ (1 << j)] - 1], dp[1][S]);\n\t\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint r = i;\n\t\twhile (r < n && pos[r + 1] - pos[r] <= V) r++;\n\t\tbool flag = 0;\n\t\tfor (int S = 0; S <= U; ++S) \n\t\t\tif (dp[0][S] >= i - 1 && dp[1][U ^ S] <= r + 1) {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor (int j = i; j <= r; ++j) \n\t\t\tputs(flag ? \"Possible\" : \"Impossible\");\n\t\ti = r;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 998244353\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,m1,v,i,j,k,x,a[200005],b[25],bz1[200005][25],bz2[200005][25];\nint r[200005][25],l[200005][25],f[400005],g[400005],book[200005],flag;\nint minn(int u,int v){\n\treturn u<v?u:v;\n}\nint maxx(int u,int v){\n\treturn u>v?u:v;\n}\nint main(){\n\tn=read();v=read();\n\tx=v;\n\tfor(i=0;x!=0;i++){\n\t\tb[i]=x;\n\t\tx>>=1;\n\t}\n\tm=i;\n\tfor(i=1;i<=n;i++)\n\t\ta[i]=read();\n\tfor(i=1;i<n;i++)\n\t\tbz1[i][0]=a[i+1]-a[i];\n\tfor(i=2;i<=n;i++)\n\t\tbz2[i][0]=a[i]-a[i-1];\n\tfor(j=1;(1<<j)<n;j++)\n\t\tfor(i=1;i+(1<<j)<=n;i++)\n\t\t\tbz1[i][j]=maxx(bz1[i][j-1],bz1[i+(1<<(j-1))][j-1]);\n\tm1=j-1;\n\tfor(j=1;(1<<j)<n;j++)\n\t\tfor(i=(1<<j)+1;i<=n;i++)\n\t\t\tbz2[i][j]=maxx(bz2[i][j-1],bz2[i-(1<<(j-1))][j-1]);\n\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=0;j<m;j++){\n\t\t\tx=i;\n\t\t\tfor(k=m1;k>=0;k--)\n\t\t\t\tif(x+(1<<k)<=n){\n\t\t\t\t\tif(bz1[x][k]<=b[j])\n\t\t\t\t\t\tx+=(1<<k);\n\t\t\t\t}\n\t\t\tr[i][j]=x;\n\t\t\t\n\t\t\tx=i;\n\t\t\tfor(k=m1;k>=0;k--)\n\t\t\t\tif(x-(1<<k)>=1){\n\t\t\t\t\tif(bz2[x][k]<=b[j])\n\t\t\t\t\t\tx-=(1<<k);\n\t\t\t\t}\n\t\t\tl[i][j]=x;\n\t\t}\n\t}\n\tf[0]=1;\n\tg[0]=n;\n\tfor(i=1;i<(1<<m);i++){\n\t\tf[i]=1;\n\t\tg[i]=n;\n\t\tfor(j=0;j<m;j++)\n\t\t\tif(i&(1<<j)){\n\t\t\t\tif(f[i^(1<<j)]==n)\n\t\t\t\t\tf[i]=n;\n\t\t\t\telse\n\t\t\t\t\tf[i]=maxx(f[i],j!=0?r[f[i^(1<<j)]+1][j]:f[i^(1<<j)]+1);\n\t\t\t\tif(g[i^(1<<j)]==1)\n\t\t\t\t\tg[i]=1;\n\t\t\t\telse\n\t\t\t\t\tg[i]=minn(g[i],j!=0?l[g[i^(1<<j)]-1][j]:g[i^(1<<j)]-1);\n\t\t\t}\n\t}\n\tx=1;\n\ti=0;\n\twhile(x<=n){\n\t\ti++;\n\t\tif(i>=20){\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tflag=0;\n\t\tfor(j=0;j<(1<<m);j++)\n\t\t\tif(f[j]+1>=x&&g[((1<<m)-1)^j]-1<=r[x][0])\n\t\t\t\tflag=1;\n\t\tfor(j=x;j<=r[x][0];j++)\n\t\t\tbook[j]=flag;\n\t\tx=r[x][0]+1;\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tif(book[i]==1)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int N = 200005;\n\ninline void gi(int &x){\n\tint f = 1; x = 0; char c = getchar();\n\twhile(c < '0' || c > '9'){\n\t\tif(c == '-')f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9'){\n\t\tx = x * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tx *= f;\n}\nint n, v, a[N], vis[N], ans[N];\nint walk(int st, int vv){\n\tint i, j; vis[st] = j = 1;\n\tfor(i = st; i > 1 && !vis[i - 1] && a[i] - a[i - 1] <= vv; vis[-- i] = 1, j ++);\n\tfor(i = st; i < n && !vis[i + 1] && a[i + 1] - a[i] <= vv; vis[++ i] = 1, j ++);\n\treturn j;\n}\nbool check(int st){\n\tint i, j, k, tv = v, id, las;\n\tfor(i = 1; i <= n; i ++)\n\t\tvis[i] = 0;\n\tk = walk(st, v), las = v, tv >>= 1;\n\twhile(1){\n\t\tfor(i = 1, j = 0; i < n; i ++)\n\t\t\tif(!vis[i] && !vis[i + 1] && a[i + 1] - a[i] <= tv)\n\t\t\t\tif(a[i + 1] - a[i] > j)\n\t\t\t\t\tid = i, j = a[i + 1] - a[i];\n\t\tif(j == 0){tv = las; break;}\n\t\tlas = tv, tv >>= 1, k += walk(id, las);\n\t}\n\tif(k == n || (1 << n - k - 1) <= las)\n\t\treturn 1;\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k = 0; gi(n), gi(v);\n\tfor(i = 1; i <= n; i ++)gi(a[i]);\n\tfor(i = 1; i <= n; i = j + 1){\n\t\tk ++;\n\t\t//int flag = ans[i] = check(i);\n\t\tfor(j = i; j < n && a[j + 1] - a[j] <= v; j ++);\n\t\t\t//ans[++ j] = flag;\n\t}\n\tif((1 << k - 2) <= v){\n\t\tfor(i = 1; i <= n; i = j + 1){\n\t\t\tint flag = ans[i] = check(i);\n\t\t\tfor(j = i; j < n && a[j + 1] - a[j] <= v; )\n\t\t\t\tans[++ j] = flag;\n\t\t}\n\t}\t\n\tfor(i = 1; i <= n; i ++)\n\t\tputs(ans[i] ? \"Possible\" : \"Impossible\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<cmath>\n#include<functional>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nvoid sort(int &a,int &b)\n{\n\tif(a>b)\n\t\tswap(a,b);\n}\nvoid open(const char *s)\n{\n#ifndef ONLINE_JUDGE\n\tchar str[100];\n\tsprintf(str,\"%s.in\",s);\n\tfreopen(str,\"r\",stdin);\n\tsprintf(str,\"%s.out\",s);\n\tfreopen(str,\"w\",stdout);\n#endif\n}\nint rd()\n{\n\tint s=0,c;\n\twhile((c=getchar())<'0'||c>'9');\n\tdo\n\t{\n\t\ts=s*10+c-'0';\n\t}\n\twhile((c=getchar())>='0'&&c<='9');\n\treturn s;\n}\nint upmin(int &a,int b)\n{\n\tif(b<a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint upmax(int &a,int b)\n{\n\tif(b>a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint v[200010];\nint f[1<<21];\nint g[1<<21];\nint l[30][200010];\nint r[30][200020];\nint a[200010];\nint b[200010];\nint main()\n{\n//\topen(\"agc012e\");\n\tint n;\n\tscanf(\"%d%d\",&n,&v[1]);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tint t=1;\n\twhile(1)\n\t{\n\t\tv[t+1]=v[t]/2;\n\t\tt++;\n\t\tif(!v[t])\n\t\t\tbreak;\n\t}\n\tfor(i=1;i<=t;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j==1||a[j]-a[j-1]>v[i])\n\t\t\t\tl[i][j]=j;\n\t\t\telse\n\t\t\t\tl[i][j]=l[i][j-1];\n\t\tfor(j=n;j>=1;j--)\n\t\t\tif(j==n||a[j+1]-a[j]>v[i])\n\t\t\t\tr[i][j]=j;\n\t\t\telse\n\t\t\t\tr[i][j]=r[i][j+1];\n\t}\n\tmemset(f,0,sizeof f);\n\tint all=1<<t;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(f[i]==n)\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],f[i]);\n\t\t\t\telse\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],r[j][f[i]+1]);\n\t\t\t}\n\tfor(i=0;i<all;i++)\n\t\tg[i]=n+1;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(g[i]==1)\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],g[i]);\n\t\t\t\telse\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],l[j][g[i]-1]);\n\t\t\t}\n\tif(f[all-2]>=n)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t\tprintf(\"Possible\\n\");\n\t\treturn 0;\n\t}\n\tfor(i=0;i<all;i++)\n\t\tif(!(i&1)&&(f[i]+r[1][f[i]+1]>=n||g[(all-1)^i^1]<=f[i]+r[1][f[i]+1]+1))\n\t\t\tb[f[i]+1]=1;\n\tint last=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(b[i])\n\t\t\tlast=i;\n\t\tif(l[1][i]<=last||(i<=r[1][1]&&r[1][1]>=g[all-2]-1))\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\n\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n\n#define gi(x) ((x) = F())\n#define gii(x, y) (gi(x), gi(y))\n#define giii(x, y, z) (gii(x, y), gi(z))\n\nint F()\n{\n\tchar ch;\n\tint x, a;\n\twhile (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');\n\tif (ch == '-') ch = getchar(), a = -1;\n\telse a = 1;\n\tx = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9')\n\t\tx = (x << 1) + (x << 3) + ch - '0';\n\treturn a * x;\n}\n\nconst int N = 1 << 20;\n\nint n, v, x[200010];\n\nint l[22][200010], r[22][200010];\n\nint val[22], cnt, f[N], g[N];\n\nvector<PII> t;\n\nint main()\n{\n\tgii(n, v);\n\tfor (int i = 1; i <= n; ++i) gi(x[i]);\n\tfor (int i = v; ; i = i >> 1)\n\t{\n\t\tval[++cnt] = i;\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t{\n\t\t\tint k = j;\n\t\t\twhile (k < n && x[k + 1] - x[k] <= i) ++k;\n\t\t\tfor (int p = j; p <= k; ++p) l[cnt][p] = j, r[cnt][p] = k;\n\t\t\tif (cnt == 1) t.pb(mp(j, k));\n\t\t\tj = k;\n\t\t}\n\t\tif (!i) break;\n\t}\n\tint all = cnt - 1;\n\tfor (int i = 0; i < (1 << all); ++i) g[i] = n + 1;\n\tfor (int i = 1; i < (1 << all); ++i)\n\t{\n\t\tfor (int j = 0; j < all; ++j)\n\t\t\tif (i & (1 << j))\n\t\t\t{\n\t\t\t\tint t = f[i ^ (1 << j)];\n\t\t\t\tf[i] = max(f[i], r[j + 2][t + 1]);\n\t\t\t\tt = g[i ^ (1 << j)];\n\t\t\t\tg[i] = min(g[i], l[j + 2][t - 1]);\n\t\t\t}\n\t}\n\tfor (auto v : t)\n\t{\n\t\tbool flag = 0;\n\t\tint s = (1 << all) - 1;\n\t\tfor (int i = 0; i < (1 << all); ++i)\n\t\t{\n\t\t\tif (f[i] >= v.fi - 1 && v.se + 1 >= g[s ^ i])\n\t\t\t\tflag = 1;\n\t\t}\n\t\tfor (int i = v.fi; i <= v.se; ++i)\n\t\t\tputs(flag ? \"Possible\" : \"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 2e5 + 10;\n\nint n, v, m, ans[N];\nint a[N], b[N], L[N][20], R[N][20], f[N], g[N];\n\nint main()\n{\n    n = read(), v = read();\n    for (int i = 1; i <= n; i++) a[i] = read();\n    b[0] = v;\n    for (int i = 1; i <= 50; i++) b[i] = b[i - 1] >> 1;\n    for (int i = 0; b[i]; i++) m = i;\n    m += 2;\n    for (int i = 0; i < m; i++)\n        for (int j = 1; j <= n; )\n        {\n            int k;\n            for (k = j + 1; k <= n; k++)\n                if (a[k] - a[k - 1] > b[i])\n                    break;\n            for (int l = j; l < k; l++)\n                L[l][i] = j, R[l][i] = k - 1;\n            j = k;\n        }\n    for (int i = 0; i < (1 << m); i++) g[i] = n + 1;\n    for (int i = 0; i < (1 << m); i++)\n        for (int j = 0; j < m; j++)\n            if (!(i >> j & 1))\n            {\n                f[i | (1 << j)] = max(f[i | (1 << j)], R[f[i] + 1][j]);\n                g[i | (1 << j)] = min(g[i | (1 << j)], L[g[i] - 1][j]);\n            }\n    int S = (1 << m) - 2;\n    for (int i = 0; i < (1 << m); i++)\n        if (i % 2 == 0)\n        {\n            int j = S - i;\n            if (R[f[i] + 1][0] >= g[j] - 1)\n            {\n                if (f[i] + 1 > g[j] - 1)\n                    ans[1]++;\n                else\n                {\n                    ans[f[i] + 1]++;\n                    ans[g[j]]--;\n                }\n            }\n        }\n    for (int i = 1; i <= n; i++) ans[i] += ans[i - 1];\n    for (int i = 1; i <= n; i++)\n        puts(ans[i] ? \"Possible\" : \"Impossible\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 21;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n, a[N], dp[(1 << LOG) + 10], R[N][LOG], L[N][LOG], V[LOG], DP[(1 << LOG) + 10], ps[N];\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> V[LOG - 1];\n\tfor (int i = LOG - 2; i >= 0; i--) V[i] = V[i + 1] / 2;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\ta[0] = -INF * 2, a[n + 1] = INF * 2;\n\tfor (int i = 0; i < LOG; i++) R[n + 1][i] = n + 1;\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = 0; j < LOG; j++){\n\t\t\tif (abs(a[i] - a[i - 1]) <= V[j]) L[i][j] = L[i - 1][j];\n\t\t\telse L[i][j] = i;\n\t\t//\tif (j >= 15) cout << i << ' ' << j << ' ' << L[i][j] << '\\n';\n\t\t}\n\t}\n\tfor (int i = n; i >= 1; i--){\n\t\tfor (int j = 0; j < LOG; j++){\n\t\t\tif (abs(a[i] - a[i + 1]) <= V[j]) R[i][j] = R[i + 1][j];\n\t\t\telse R[i][j] = i;\n\t\t\t//if (j >= 15) cout << i << ' ' << j << ' ' << R[i][j] << '\\n';\n\t\t}\n\t}\n\tdp[0] = 0;\n\tfor (int mask = 1; mask < (1 << LOG); mask++){\n\t\tfor (int j = 0; j < LOG; j++){\n\t\t\tif (j != LOG - 1 && V[j + 1] == 0) continue;\n\t\t\tif (mask & (1 << j)) dp[mask] = max(dp[mask], R[dp[mask ^ (1 << j)] + 1][j]);\n\t\t}\n\t}\n\tDP[0] = n + 1;\n\tfor (int mask = 1; mask < (1 << LOG); mask++){\n\t\tDP[mask] = n + 1;\n\t\tfor (int j = 0; j < LOG; j++){\n\t\t\tif (j != LOG - 1 && V[j + 1] == 0) continue;\n\t\t\t//cout << j << '\\n';\n\t\t\tif (mask & (1 << j)) DP[mask] = min(DP[mask], L[DP[mask ^ (1<<j)] - 1][j]);\n\t\t}\n\t}\n\tfor (int mask = 0; mask < (1 << (LOG - 1)); mask++){\n\t\tint mask2 = ((1 << (LOG - 1)) - 1) ^ mask;\n\t\tif (dp[mask] >= DP[mask2] - 1){\n\t\t\t//cout << \"Fuck\\n\";\n\t\t\t\n\t\t\tps[1] ++;\n\t\t}else{\n\t\t\tif (R[dp[mask] + 1][LOG - 1] >= DP[mask2] - 1){\n\t\t\t\tps[L[dp[mask] + 1][LOG - 1]]++;\n\t\t\t\tps[R[dp[mask] + 1][LOG - 1] + 1]--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++){\n\t\tps[i] += ps[i - 1];\n\t\tcout << (ps[i] > 0?\"Possible\\n\":\"Impossible\\n\");\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int L = 20, N = 201010;\n\nint n, V, x[N], fa[L][N], siz[L][N], ans[N], lt[1 << L], rt[1 << L];\nvector<int> v[N];\n\nint Find(int k, int x) {\n  return fa[k][x] == x ? x : fa[k][x] = Find(k, fa[k][x]);\n}\n\nvoid Merge(int k, int x, int y) {\n  x = Find(k, x), y = Find(k, y);\n  fa[k][y] = x;\n  siz[k][x] += siz[k][y];\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &V);\n  for(int i = 1; i <= n; i++)\n    scanf(\"%d\", &x[i]);\n  int now = V, m;\n  for(int o = L - 1; ; now >>= 1, o = (o + 1) % L) {\n    for(int i = 1; i <= n; i++)\n      fa[o][i] = i, siz[o][i] = 1;\n    for(int i = 1; i <= n; i++) {\n      int j = i;\n      while(j < n && x[j + 1] - x[j] <= now) j++;\n      for(int k = i + 1; k <= j; k++)\n\tMerge(o, i, k);\n      i = j;\n    }\n    if(now == 0) { m = o + 1; break; }\n  }\n\n  for(int i = 0; i < (1 << m); i++)\n    rt[i] = n + 1;\n  for(int i = 0; i < (1 << m); i++) {\n    for(int j = 0; j < m; j++)\n      if(~i >> j & 1) {\n\tlt[i | (1 << j)] = max(lt[i | (1 << j)], lt[i] + siz[j][lt[i] + 1]);\n\trt[i | (1 << j)] = min(rt[i | (1 << j)], rt[i] - siz[j][Find(j, rt[i] - 1)]);\n      }\n  }\n  // cerr << lt[27]  <<\" \" << rt[4] << endl;\n\n  int all = (1 << m) - 1; \n  for(int i = 0; i < (1 << m); i++) {\n    v[lt[i]].push_back(rt[all ^ i]);\n    //    cerr << lt[i] << \" \" << rt[all ^ i] << endl;\n  }\n\n  int mi = n + 2;\n  for(int i = 0; i < v[n].size(); i++)\n    mi = min(v[n][i], mi);\n  \n  for(int i = n; i >= 1; i--) {\n    for(int j = 0; j < v[i - 1].size(); j++)\n      mi = min(v[i - 1][j], mi);\n    if(fa[L - 1][i] != i) continue;\n    //cerr << i + siz[L - 1][i] << endl;\n    ans[i] = mi <= i + siz[L - 1][i];\n  }\n  \n  for(int i = 1; i <= n; i++)\n    puts(ans[Find(L - 1, i)] ? \"Possible\" : \"Impossible\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define fr first\n#define se second\n#define pr pair<int,int>\n#define mp make_pair\n#define N 300000\nint n,m,i,j,mask,a[N],l[20][N],r[20][N],k,f[N],g[N],id;\npr b[N<<1];\nbool c[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&a[i]);int psz=0,jj=-1;\n\tfor (j=m;j!=jj;jj=j,j>>=1){\n\t\tint lst=1;\n\t\tfor (i=2;i<=n;i++) if (a[i]-a[i-1]>j){\n\t\t\tfor (k=lst;k<i;k++) l[psz][k]=lst,r[psz][k]=i-1;\n\t\t\tlst=i;\n\t\t}\n\t\tfor (k=lst;k<=n;k++) l[psz][k]=lst,r[psz][k]=n;\n\t\tpsz++;\n\t}\n\tfor (mask=0;mask<(1<<psz);mask++)\n\tfor (i=0;i<psz;i++) if (!(mask&(1<<i))) f[mask|(1<<i)]=max(f[mask|(1<<i)],r[i][f[mask]+1]);\n\tfor (mask=0;mask<(1<<psz);mask++) g[mask]=n+1;\n\tfor (mask=0;mask<(1<<psz);mask++)\n\tfor (i=0;i<psz;i++) if (!(mask&(1<<i))) g[mask|(1<<i)]=min(g[mask|(1<<i)],l[i][g[mask]-1]);\n\tfor (mask=0;mask<(1<<psz);mask++) if (!(mask&1)) b[++id]=mp(g[mask],mask);\n\tfor (i=1;i<=n;i++) b[++id]=mp(r[0][i]+1,i+(1<<psz));\n\tsort(b+1,b+id+1);int wtf=-1;\n\tfor (i=1;i<=id;i++) if (b[i].se>(1<<psz)){\n\t\tb[i].se-=(1<<psz);\n\t\tif (wtf>=l[0][b[i].se]-1) c[b[i].se]=true;\n\t}else wtf=max(wtf,f[b[i].se^((1<<psz)-2)]);\n\tfor (i=1;i<=n;i++) if (c[i]) puts(\"Possible\");else puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=1e6+5;\nint n,m;\nint v,x[maxn],rj[maxn][25],lj[maxn][25];\nint lx[maxn],rx[maxn];\nint mn[maxn];\nint main(){\n\tread(n);read(v);\n\trep(i,1,n)read(x[i]);\n\twhile((1<<m)<=V)m++;m++;\n\trep2(i,0,m){\n\t\tlj[0][i]=1;\n\t\trep(j,1,n)lj[j][i]=(x[j]-x[j-1]<=(V>>i))?lj[j-1][i]:j;\n\t\trj[n+1][i]=n;\n\t\tper(j,n,1)rj[j][i]=(x[j+1]-x[j]<=(V>>i))?rj[j+1][i]:j;\n\t}\n\trep2(i,0,1<<m)rx[i]=n+1;\n\trep2(i,0,1<<m)rep2(j,0,m)if(!(i&(1<<j))){\n\t\tlx[i|(1<<j)]=max(lx[i|(1<<j)],rj[lx[i]+1][j]);\n\t\trx[i|(1<<j)]=min(rx[i|(1<<j)],lj[rx[i]-1][j]);\n\t}\n\trep(i,0,n)mn[i]=n+2;\n\trep2(i,0,1<<m)if(!(i&1))mn[lx[i]]=min(mn[lx[i]],rx[((1<<m)-1)^i^1]);\n\tper(i,n-1,0)mn[i]=min(mn[i],mn[i+1]);\n\trep(i,1,n){\n\t\tif(mn[lj[i][0]-1]<=rj[i][0]+1)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int INF=0x3f3f3f3f;\nconst int MAXN=1000005;\n\nint n,m,x[MAXN],cnt[20];\nint l[20][MAXN],r[20][MAXN],f1[MAXN*2],f2[MAXN*2];\nbool ans[MAXN];\n\nint uf(int id,int pos){\n\tpos++;\n\tint p=upper_bound(l[id]+1,l[id]+cnt[id]+1,pos)-l[id]-1;\n\tif(p<=0) return pos;\n\treturn max(r[id][p],pos-1);\n}\n\nint lf(int id,int pos){\n\tpos--;\n\tint p=lower_bound(r[id]+1,r[id]+cnt[id]+1,pos)-r[id];\n\tif(p>=cnt[id]+1) return pos;\n\treturn min(l[id][p],pos+1);\n}\n\nint main(){\n\n\tmemset(f2,0x3f,sizeof f2);\n\tscanf(\"%d%d\",&n,&m);\n\tint tot=0;\n\tfor(tot=0;(1<<tot)<=m;tot++);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tx[0]=-INF; x[n+1]=INF;\n\tfor(int log=0;log<=tot;log++){\n\t\tint d=m>>log;\n\t\tcnt[log]=1;\n\t\tl[log][1]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tr[log][cnt[log]]=i;\n\t\t\tif(x[i+1]-x[i]>d){\n\t\t\t\tcnt[log]++;\n\t\t\t\tl[log][cnt[log]]=i+1;\n\t\t\t}\n\t\t}\n\t\tcnt[log]--;\n\t}\n\tif(cnt[0]>tot+1){\n\t\tfor(int i=1;i<=n;i++) printf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint sum=(1<<(tot+1));\n\tf1[0]=0,f2[0]=n+1;\n\tfor(int s=0;s<sum;s+=2)\n\t\tfor(int i=0;i<=tot;i++){\n\t\t\tif(!(s&(1<<i))) continue;\n\t\t\tf1[s]=max(f1[s],uf(i,f1[s-(1<<i)]));\n\t\t\tf2[s]=min(f2[s],lf(i,f2[s-(1<<i)]));\n\t\t}\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tint ln=l[0][i],rn=r[0][i];\n\t\tfor(int s1=0;s1<sum;s1+=2){\n\t\t\tint s2=sum-1-s1-1;\n\t\t\tint lpos=f1[s1];\n\t\t\tint rpos=f2[s2];\n\t\t\tif(lpos>=ln-1&&rpos<=rn+1){\n\t\t\t\tans[i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint pos=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(ans[pos]) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t\tif(x[i+1]-x[i]>m) pos++;\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, v;\nconst int N = 600000;\nint ai[N];\nint L[20][N], R[20][N], cnt[N];\nint Ld[N], Rd[N];\nint main()\n{\n    scanf(\"%d%d\", &n, &v);\n    for (int i = 1; i <= n; ++ i) scanf(\"%d\", &ai[i]);\n    int c = 0;\n    for (int i = 0, vv = v; vv != -1; ++ i, vv == 0? vv = -1: vv /= 2)\n    {\n        c ++;\n        R[i][n] = n;\n        for (int j = n - 1; j >= 1; -- j)\n            if (ai[j + 1] - ai[j] <= vv)\n                R[i][j] = R[i][j + 1];\n            else\n                R[i][j] = j;\n        L[i][1] = 1;\n        for (int j = 2; j <= n; ++ j)\n            if (ai[j] - ai[j - 1] <= vv)\n                L[i][j] = L[i][j - 1];\n            else\n                L[i][j] = j;\n    }\n    for (int i = 0; i < (1 << c); ++ i)\n        Ld[i] = n + 1;\n    for (int i = 0; i < (1 << c); ++ i)\n        for (int j = 0; j <= c; ++ j)\n            if (!(i & (1 << j)))\n                Rd[i | (1 << j)] = max(Rd[i | (1 << j)], R[j][Rd[i] + 1]),\n                Ld[i | (1 << j)] = min(Ld[i | (1 << j)], L[j][Ld[i] - 1]);\n    for (int i = 0; i < (1 << c); ++ i) if (!(i & 1))\n        if (R[0][Rd[i] + 1] + 1 >= Ld[((1 << c) - 2) ^ i])\n        {\n            cnt[L[0][Rd[i] + 1]] ++;\n            cnt[R[0][Rd[i] + 1] + 1] --;\n        }\n    for (int i = 1; i <= n; ++ i) cnt[i] += cnt[i - 1];\n    for (int i = 1; i <= n; ++ i) if (cnt[i]) puts(\"Possible\"); else puts(\"Impossible\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pb2 pop_back\n#define pf push_front\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define rep(k,i,j) for(int k = (int)i;k<(int) j;k++)\n#define repd(k,i,j) for(int k = i;k>=(int)j;k--)\n#define ll long long\n#define pq priority_queue\n\nint dirx[8] = {0,1,0,-1,1,1,-1,-1};\nint diry[8] = {1,0,-1,0,1,-1,1,-1};\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e16;\nconst double EPS = 1e-6;\n\nusing namespace std;\n\nconst int maxn = 2e5+5;\n\nint n,v;\nint loc[maxn];\n\nint jump[maxn][20],m;\n\nint dp[maxn];\n\nint ch[maxn];\n\nint in_q[maxn];\nint solve(){\n\tmemset(dp,-1,sizeof dp);\n\tmemset(in_q,0,sizeof in_q);\n\t\n\tqueue<int> q;\n\t\n\tq.push(1);\n\tdp[1] = 0;\n\tin_q[1] = 1;\n\t\n\twhile(q.size()){\n\t\tint mask = q.front();\n\t\tint a = ch[dp[mask]];\n\t\t\n\t\tq.pop();\n\t\tin_q[mask] = 0;\n\t\t\n\t\tif(a==n)return 1;\n\t\trep(k,0,m)if(((1<<k)&mask)==0){\n\t\t\tint b = ch[jump[a][k]];\n\t\t\tint maskb = (mask|(1<<k));\n\t\t\t\n\t\t\tif(dp[maskb]<b){\n\t\t\t\tdp[maskb] = b;\n\t\t\t\tif(!in_q[maskb])q.push(maskb),in_q[maskb] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\t\n\trep(k,0,n)scanf(\"%d\",&loc[k]);\n\t\n\t\n\tfor(;v>=0;v/=2){\n\t\trep(k,0,n){\n\t\t\tint i = k;\n\t\t\twhile(i<n){\n\t\t\t\tif(i<n-1 && loc[i+1]-loc[i]<=v){\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\twhile(k<=i)jump[k++][m] = i+1;\n\t\t\tk = i;\n\t\t}\n\t\t\n\t\tm++;\n\t\tif(v==0)break;\n\t}\n\t\n\trep(k,0,m){\n\t\t//rep(i,0,n)printf(\"%d \",jump[i][k]);line;\n\t\t\n\t}\n\trep(k,0,maxn)ch[k] = k;\n\t\n\tint hit = 0;\n\trep(k,0,n){\n\t\tif(hit>18){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint nxt = jump[k][0];\n\t\t\n\t\thit++;\n\t\tch[k] = nxt;\n\t\tint ret = solve();\n\t\tch[k] = k;\n\t\t\n\t\twhile(k<nxt)printf(\"%s\\n\",ret?\"Possible\":\"Impossible\"),k++;\n\t\tk = nxt-1;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MN 200005\nusing namespace std;\nint n,v,len,tt,a[MN],l[25][MN],r[25][MN],f[1<<18],g[1<<18];\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\twhile(v>>len)len++;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=0;i<=len;i++){\n\t\tl[i][1]=1;r[i][n]=n;\n\t\tfor(int j=2;j<=n;j++)if(a[j]-a[j-1]<=(v>>i))l[i][j]=l[i][j-1];else l[i][j]=j;\n\t\tfor(int j=n-1;j>=1;j--)if(a[j+1]-a[j]<=(v>>i))r[i][j]=r[i][j+1];else r[i][j]=j;\n\t}g[0]=n+1;\n\tfor(int i=0;i<(1<<len);i++){\n\t\tg[i]=n+1;\n\t\tfor(int j=0;j<len;j++)if(i&(1<<j)){\n\t\t\tf[i]=max(f[i],r[len-j][min(f[i-(1<<j)]+1,n)]);\n\t\t\tg[i]=min(g[i],l[len-j][max(g[i-(1<<j)]-1,1)]);\n\t\t}\n\t}bool pd=false;\n\tfor(int i=1;i<=n;i++)if(l[0][i]!=l[0][i-1])tt++;\n\tif(tt>20){for(int i=1;i<=n;i++)puts(\"Impossible\");return 0;}\n\tfor(int i=1,j;i<=n;i++){\n\t\tif(l[0][i]!=l[0][i-1]){\n\t\t\tfor(j=0;j<(1<<len);j++)if(f[j]>=l[0][i]-1&&g[(1<<len)-j-1]<=r[0][i]+1){pd=true;break;}\n\t\t\tif(j==(1<<len))pd=false;\n\t\t}printf(\"%s\\n\",pd?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AT 2365\n// DeP\n#include <cctype>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nnamespace IO {\n    const int MAXSIZE = 1 << 18 | 1;\n    char buf[MAXSIZE], *p1, *p2;\n\n    inline int Gc() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2)? EOF: *p1++; }\n    template<class T> void read(T& x) {\n        x = 0; int f = 0, ch = Gc();\n        while (!isdigit(ch)) f |= ch == '-', ch = Gc();\n        while (isdigit(ch)) x = x * 10 + ch - '0', ch = Gc();\n        if (f) x = -x;\n    }\n}\nusing IO::read;\n\ntypedef pair<int, int> Pii;\nconst int MAXN = 2e5+5, LOG = 21, INF = 0x3f3f3f3f;\n\nint n, V;\nint X[MAXN], f[MAXN], g[MAXN];\nint L[LOG][MAXN], R[LOG][MAXN];\nbool Ans[MAXN];\nPii segs[MAXN];\n\nint main() {\n#ifndef ONLINE_JUDGE\n    freopen(\"input.in\", \"r\", stdin);\n#endif\n    // input\n    read(n); read(V);\n    for (int i = 1; i <= n; ++i) read(X[i]);\n    X[0] = -INF; X[n+1] = INF;\n    // solve\n    int log = 0;\n    for (int v = V; v >= 0; v /= 2, ++log) {\n        R[log][n+1] = n+1;\n        for (int i = 1; i <= n; ++i) L[log][i] = X[i] - X[i-1] <= v? L[log][i-1]: i;\n        for (int i = n; i >= 1; --i) R[log][i] = X[i+1] - X[i] <= v? R[log][i+1]: i;\n        if (!v) { ++log; break; }\n    }\n    for (int i = 1; i <= n; ++i) segs[i] = make_pair(L[0][i], R[0][i]);\n    int tot = unique(segs+1, segs+1+n) - segs - 1;\n    if (tot > log) {\n        for (int i = 1; i <= n; ++i) puts(\"Impossible\");\n        return 0;\n    }\n    for (int S = 0; S < (1 << log); ++S) f[S] = n+1;\n    for (int S = 0; S < (1 << log); S += 2) {\n        for (int i = 0; i < log; ++i) if ((S >> i) & 1) {\n            f[S] = min(f[S], L[i][f[S ^ (1 << i)] - 1]);\n            g[S] = max(g[S], R[i][g[S ^ (1 << i)] + 1]);\n        }\n    }\n    for (int i = 1; i <= tot; ++i)\n        for (int S = 0; S < (1 << log); S += 2)\n            if (g[S] >= segs[i].first-1 && segs[i].second+1 >= f[((1<<log)-1)-(S+1)]) {\n                for (int k = segs[i].first; k <= segs[i].second; ++k) Ans[k] = true;\n                break;\n            }\n    // output\n    for (int i = 1; i <= n; ++i) puts(Ans[i]? \"Possible\": \"Impossible\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define N 131072\n#define ll long long\nusing namespace std;\nint n,m,cnt,a[N],b[20],l[20][N],r[20][N],f[N],g[N];\nstruct node{ int x,y; node(){} node(int a,int b){ x=a,y=b; } }c[N];\nconst bool cmp(const node &x,const node &y){ return x.y<y.y; }\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (; m; m>>=1) b[++cnt]=m; b[++cnt]=0;\n\trep (i,1,cnt>>1) swap(b[i],b[cnt-i+1]);\n\tm=1<<cnt-1;\n\trep (i,1,n) scanf(\"%d\",&a[i]);\n\trep (i,1,cnt){//预处理l[i][j]和r[i][j]表示第i层第j个点所在线段的左右端点\n\t\tl[i][1]=1; r[i][n]=n;\n\t\trep (j,2,n) l[i][j]=a[j]-a[j-1]<=b[i]?l[i][j-1]:j;\n\t\tper (j,n-1,1) r[i][j]=a[j+1]-a[j]<=b[i]?r[i][j+1]:j;\n\t}\n\trep (i,0,m-1) g[i]=n+1,f[i]=0;//f[i]表示状态为i，从1开始延伸出去的最远长度；g[i]表示从n开始延伸的最远长度\n\t//状态s的意思是，如果某位为1则表示当前层选了线段\n\trep (i,1,m-1) rep (j,1,cnt-1) if ((i>>j-1)&1){\n\t\tint k=i^1<<j-1;//f[k]->f[i]\n\t\tf[i]=max(f[i],f[k]<n?r[j][f[k]+1]:n);\n\t\tg[i]=min(g[i],g[k]>1?l[j][g[k]-1]:1);\n\t}\n\trep (i,0,m-1)\n\t\tif (f[i]+1<g[m-1^i]-1) c[i+1]=node(f[i]+1,g[m-1^i]-1);\n\t\telse{\n\t\t\trep(j,1,n) puts(\"Possible\"); return 0;\n\t\t}\n\tsort(c+1,c+1+m,cmp);\n\t//rep (i,1,m) printf(\"%d %d\\n\",c[i].x,c[i].y);\n\tfor (int i=1,j=1,k=0; i<=n; i++){\n\t\twhile (j<=m && c[j].y<=r[cnt][i]){\n\t\t\tj++; k=max(k,c[j].x);\n\t\t}\n\t\t//printf(\"%d\\n\",k);\n\t\tif (k>=l[cnt][i]) puts(\"Possible\"); else puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<math.h>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst long long int INF=99999999999999,inf=199999;\nconst long long int mod=1000000007;\n\n\n\nlong long int tmp,n,canmove[25]={},v,x[200005],leftdp[800000]={},rightdp[800000]={};\nlong long int leftnext[25][800005]={},rightnext[25][800005]={},two[30]={1};\nlong long int leftmemo[800005]={},rightmemo[800005]={};\nlong long int cou=0,k;\n\nvoid leftsolve(){\n    long long int count=0;\n    queue<long long int>que,memoque;\n    que.push(0);\n    leftdp[0]=1;\n    while(1){\n        while(!que.empty()){\n            for(int i=0;i<k;i++){\n                if((que.front()/two[i]%2)==0){\n                    leftdp[que.front()+two[i]]=max(leftdp[que.front()+two[i]],leftnext[i][leftdp[que.front()]]);\n                    //次のループで被りが出ないように\n                    if(leftmemo[que.front()+two[i]]==0){\n                        memoque.push(que.front()+two[i]);\n                        leftmemo[que.front()+two[i]]=1;\n                    }\n                }\n            }\n            que.pop();\n        }\n        while(!memoque.empty()){\n            que.push(memoque.front());\n            memoque.pop();\n        }\n        if(que.front()==two[k]-1){\n            break;\n        }\n    }\n}\n\nvoid rightsolve(){\n    long long int count=0;\n    queue<long long int>que,memoque;\n    que.push(0);\n    \n    while(1){\n        while(!que.empty()){\n            for(int i=0;i<k;i++){\n                if((que.front()/two[i])%2==0){\n                    rightdp[que.front()+two[i]]=min(rightdp[que.front()+two[i]],rightnext[i][rightdp[que.front()]]);\n                   //次のループで被りが出ないように\n                    if(rightmemo[que.front()+two[i]]==0){\n                        memoque.push(que.front()+two[i]);\n                        rightmemo[que.front()+two[i]]=1;\n                    }\n                    //cout<<que.front()<<\" \"<<two[i]<<\" \"<<endl;\n                    //cout<<que.front()+two[i]<<\" \"<<rightdp[que.front()+two[i]]<<endl;\n                }\n            }\n            que.pop();\n        }\n        while(!memoque.empty()){\n            que.push(memoque.front());\n            memoque.pop();\n        }\n        if(que.front()==two[k]-1){\n            break;\n        }\n    }\n}\n\n\nint main() {\n    int count=0;\n    map<long long int,long long int>mp;\n\tcout << fixed << setprecision(10);\n    cin>>n>>v;\n    \n    for(int i=1;i<=26;i++){\n        two[i]=2*two[i-1];\n    }\n\n\n        for(int j=0;j<=799995;j++){\n            rightdp[j]=n;\n        }\n    \n\n    tmp=v;\n    while(tmp!=0){\n        canmove[cou]=tmp;\n        cou++;\n        tmp/=2;\n    }\n    k=cou+1;\n    \n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n    }\n    x[0]=-INF;\n    x[n+1]=INF;\n\n    for(int i=0;i<k;i++){\n        tmp=0;\n        for(int j=1;j<=n+1;j++){\n            if(x[j]-x[j-1]>canmove[i]){\n                for(int p=tmp;p<j;p++){\n                    leftnext[i][p]=j;\n                }\n                tmp=j;\n            }\n        }\n\n        tmp=n;\n        for(int j=n;j>=0;j--){\n            if(x[j+1]-x[j]>canmove[i]){\n                for(int p=tmp;p>j;p--){\n                    rightnext[i][p]=j;\n                }\n                tmp=j;\n            }\n        }\n    }\n    \n    leftsolve();\n    rightsolve();\n    \n    for(int i=1;i<=n;i++){\n        //cout<<rightnext[0][i]<<\" \"<<canmove[0]<<endl;\n    }\n    \n\n\n    \n    for(int i=1;i<=n;i=leftnext[0][i]){\n        bool key=true;\n        //cout<<\"........................\"<<endl;\n        for(int j=0;j<two[k];j+=2){\n            //cout<<j<<\" \"<<(j^(two[k]-2))<<\" \"<<leftdp[j]<<\" \"<<rightnext[0][i]<<\" \"<<rightdp[(j^(two[k]-2))]<<\" \"<<leftnext[0][i]<<endl;\n            if(leftdp[j]>rightnext[0][i]&&rightdp[(j^(two[k]-2))]<leftnext[0][i]){\n                for(int p=rightnext[0][i]+1;p<=leftnext[0][i]-1;p++){\n                    \n                    //cout<<j<<\" \"<<(j^(two[k]-2))<<\" \"<<leftdp[j]<<\" \"<<rightnext[0][i]<<\" \"<<rightdp[(j^(two[k]-2))]<<\" \"<<leftnext[0][i]<<endl;\n                    cout<<\"Possible\"<<endl;\n                    count++;\n                }\n                key=false;\n                break;\n            }\n        }\n        if(key){\n            \n           \n            for(int p=rightnext[0][i]+1;p<=leftnext[0][i]-1;p++){\n                        cout<<\"Impossible\"<<endl;\n                        count++;\n            }\n        }\n    }\n    cout<<count;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define ll      long long\n\nint x[202020];\nint l[202020][20], r[202020][20];\nint dpl[1 << 20], dpr[1 << 20];\n\nvoid solve() {\n        int n, v;\n        cin >> n >> v;\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        int p;\n        for (int i = 0; ; i ++) if ((1 << i) > v) {\n                p = i + 1;\n                break;\n        }\n        for (int i = 0; i < n; i ++) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == 0 || x[i] - x[i - 1] > vv) l[i][j] = i;\n                        else l[i][j] = l[i - 1][j];\n                        vv /= 2;\n                }    \n        }\n        for (int i = n - 1; i >= 0; i --) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == n - 1 || x[i + 1] - x[i] > vv) r[i][j] = i;\n                        else r[i][j] = r[i + 1][j];\n                        vv /= 2;\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpr[i] == n) dpr[i | (1 << j)] = n;\n                        else dpr[i | (1 << j)] = max(dpr[i | (1 << j)], r[dpr[i]][j] + 1);\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) dpl[i] = n - 1;\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpl[i] == -1) dpl[i | (1 << j)] = -1;\n                        else dpl[i | (1 << j)] = min(dpl[i | (1 << j)], l[dpl[i]][j] - 1);\n                }\n        }\n        bool ok = false;\n        for (int i = 0; i < n; i ++) {\n                if (l[i][0] == i) {\n                        int c = 0;\n                        for (int j = 0; j < (1 << p); j ++) {\n                                c ++;\n                                if (j & 1) continue;\n                                if (i > 0 && dpr[j] < i) continue;\n                                if (r[i][0] < n - 1 && dpl[(1 << p) - 2 - j] > r[i][0]) continue;\n                                break;\n                        }\n                        if (c < (1 << p)) ok = true;\n                        else ok = false;\n                }\n                if (ok) cout << \"Possible\" << endl;\n                else cout << \"Impossible\" << endl;\n        }\n        return;\n}\n\nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        solve();\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 200005\n#define MAXM 18\n#define MAXK (1<<MAXM)\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\n#define prev daksiisaas\n#define next aijdkjsaod\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\nint N,V,x[MAXN];\nvector<int> v;\nint prev[MAXN][MAXM],next[MAXN][MAXM];\nint predp[MAXK],sufdp[MAXK];\nint mini[MAXN];\nint main()\n{\n    scanf(\"%d%d\",&N,&V);\n    for(int i=1;i<=N;i++) scanf(\"%d\",&x[i]);\n    int dummy=V;\n    while(dummy)\n    {\n        v.push_back(dummy);\n        dummy/=2;\n    }\n    v.push_back(0);\n    reverse(v.begin(),v.end());\n    int sz=(int)v.size();\n    for(int i=(int)v.size()-1;i>=0;i--) next[N][i]=N;\n    for(int i=N-1;i>=0;i--)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i+1]-x[i]>v[j]) next[i][j]=i; else next[i][j]=next[i+1][j];\n    for(int i=(int)v.size()-1;i>=0;i--) prev[1][i]=1;\n    for(int i=2;i<=N;i++)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i]-x[i-1]>v[j]) prev[i][j]=i; else prev[i][j]=prev[i-1][j];\n    //for(int i=1;i<=N;i++) printf(\"%d %d %d %d\\n\",prev[i][1],prev[i][2],next[i][1],next[i][2]);\n    memset(predp,0,sizeof(predp));\n    predp[1]=1;\n    for(int i=0;i<sz;i++) predp[(1<<i)]=next[1][i];\n    for(int mask=1;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            predp[mask^(1<<j)]=max(predp[mask^(1<<j)],next[min(predp[mask]+1,N)][j]);\n        }\n    }\n    for(int mask=1;mask<(1<<sz);mask++) sufdp[mask]=N;\n    for(int i=0;i<sz;i++) sufdp[(1<<i)]=prev[N][i];\n    for(int mask=1;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            sufdp[mask^(1<<j)]=min(sufdp[mask^(1<<j)],prev[max(sufdp[mask]-1,1)][j]);\n        }\n    }\n    for(int i=0;i<=N+1;i++) mini[i]=N+2; \n    for(int mask=0;mask<(1<<(sz-1));mask++)\n    {\n        int dmask=(1<<(sz-1))-1-mask;\n        int l,r;\n        if(mask==0) l=0; else l=predp[mask];\n        if(dmask==0) r=N+1; else r=sufdp[dmask];\n        mini[l]=min(mini[l],r);\n    }\n    for(int i=N;i>=0;i--) mini[i]=min(mini[i],mini[i+1]);\n    for(int i=1;i<=N;i++)\n    {\n        int l=prev[i][sz-1],r=next[i][sz-1];\n        if(l==1&&r==N) {puts(\"Possible\"); continue;}\n        //printf(\"%d %d\\n\",l,r);\n        if(mini[l-1]<=r+1) puts(\"Possible\"); else puts(\"Impossible\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1012345678;\n\nint A[200005];\n\nint S[20];\nint sizeS = 0;\n\nint R[20][200005];\nint L[20][200005];\nbool boleh[200005];\nint minPos[200005]; // for each dpL[something] = i, the smallest possible value of dpR[not of the something]\n// 'something' is a bitmask\n\nint minPos2[200005]; // for each dpL[something] >= i, the smallest possible value of dpR[not of the something]\n// 'something' is a bitmask\n\n/* dpL[i] = maximum index from the beginning that can be covered by the intervals\ncorresponding to a subset i of intervals from S\ndpR[i] is defined similarly, just that the prefix becomes the suffix.\n*/\nint dpL[(1<<19)+5];\nint dpR[(1<<19)+5];\n\n\nint N, V;\nint main(){\n    scanf(\"%d%d\", &N, &V);\n\n    for(int i = 1; i <= N; i ++){\n        scanf(\"%d\", &A[i]);\n    }\n\n    int temp = V;\n    while(true){\n        S[sizeS ++] = temp;\n        if(temp == 0){break;}\n        temp >>= 1;\n    }\n    reverse(S, S+sizeS);\n    for(int i = 0; i < sizeS; i++){\n        //printf(\"S[%d]=%d\\n\", i, S[i]);\n    }\n\n    // S is sorted in decreasing order\n\n    // R[i][j] is the 1-indexed right-most position reachable using move distances <= S[i] from position j\n    for(int i = 0; i < sizeS; i ++){\n        R[i][N] = N;\n        L[i][1] = 1;\n        for(int j = 2; j <= N; j ++){\n            if(A[j]-A[j-1] <= S[i]){\n                L[i][j] = L[i][j-1];\n            }else{\n                L[i][j] = j;\n            }\n        }\n\n        for(int j = N-1; j >= 1; j --){\n            if(A[j+1]-A[j] <= S[i]){\n                // can reach j+1, hence can reach positions up to R[i][j+1]\n                R[i][j] = R[i][j+1];\n            }else{\n                // j and j+1 disconnected\n                R[i][j] = j;\n            }\n        }\n    }\n\n    for(int i = 0; i < (1<<sizeS); i ++){\n        dpL[i] = 0;\n        dpR[i] = N+1;\n\n        // Consider the last S[j] used to construct the interval\n        for(int j = 0; j < sizeS; j ++){\n            if(i&(1<<j)){\n                // Bit j is set in i.\n                int k = i^(1<<j);\n\n                // clearing bit results in an index lesser than the original index => already processed\n                dpL[i] = max(dpL[i], R[j][min(dpL[k]+1, N)]);\n                // dpL[k]+1 is first index impossible to be covered by all the previous intervals\n\n                dpR[i] = min(dpR[i], L[j][max(dpR[k]-1, 1)]);\n            }\n        }\n    }\n\n    for(int i = 0; i <= N; i ++){\n        minPos[i] = INF;\n    }\n\n    // Now check whether it is possible to reach all the oases.\n    for(int i = 0; i < (1<<(sizeS-1)); i ++){\n        int j = (1<<(sizeS-1))-1-i;\n\n        int l = dpL[i];\n        int r = dpR[j];\n        //printf(\"dpL[%d]=%d; dpR[%d]=%d\\n\", i, l, j, r);\n        minPos[l] = min(minPos[l], r);\n    }\n\n    minPos2[N] = minPos[N];\n    for(int i = N-1; i >= 0; i --){\n        minPos2[i] = min(minPos2[i+1], minPos[i]);\n        //printf(\"minPos[%d]=%d\\n\", i, minPos[i]);\n    }\n\n    //init();\n    for(int i = 1; i <= N; i ++){\n        int l = L[sizeS-1][i];\n        int r = R[sizeS-1][i];\n\n        //printf(\"i=%d l=%d r=%d\\n\", i, l, r);\n\n        boleh[i] = minPos2[l-1] <= r+1;\n        if(boleh[i]){\n            printf(\"Possible\\n\");\n        }else{\n            printf(\"Impossible\\n\");\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300005;\n\nint dpL[N], dpR[N];\nint R[20][N], L[20][N];\nint d[N];\nint S[20];\nint a[N];\nint sum[N];\nint n,v;\nint p;\nint id[N];\nint main(){\n    scanf(\"%d%d\",&n,&v);\n    for (int i = 1; i <= n; i++) scanf(\"%d\",&a[i]);\n    for (int i = 1; i < n; i++){\n        d[i] = a[i+1]-a[i];\n        if (d[i] > v) id[i]++;\n    }\n    for (int i = 1; i < n; i++){\n        id[i] += id[i-1];\n    }\n    /*for (int i = 1; i < n; i++){\n        printf(\"%d \",d[i]);\n    }\n    printf(\"\\n\");\n    for (int i = 1; i < n; i++){\n        printf(\"%d \",id[i]);\n    }\n    printf(\"\\n\");*/\n    S[0] = v;\n    for (int i = 1; i <= 18; i++){\n        S[i] = S[i-1]/2;\n        if (S[i] == 0) { p= i+1; break;}\n    }\n    //printf(\"%d \",p);\n    reverse(S,S+p);\n    for (int i = 0; i < p; i++){\n        //printf(\"%d \",S[i]);\n    }\n    for (int i = 0; i < p; i++){\n        R[i][n] = n;\n        for (int j = n-1; j >= 1; j--){\n            R[i][j] = a[j+1]-a[j] <= S[i] ? R[i][j+1] : j;\n        }\n\n        L[i][1] = 1;\n        for (int j = 2; j <= n; j++ ){\n            L[i][j] = a[j]-a[j-1] <= S[i] ? L[i][j-1] : j;\n        }\n        /*printf(\"cur step %d = %d:\\n\",i,S[i]);\n        for (int j = 1; j <= n; j++){\n            printf(\"%d \",R[i][j]);\n        }\n        printf(\"\\n\");\n        for (int j = 1; j <= n; j++){\n            printf(\"%d \",L[i][j]);\n        }\n        printf(\"\\n\");*/\n    }\n    int LIM = (1<<(p-1))-1;\n    for (int i = 0; i <= LIM; i++){\n        dpR[i] = n+1;\n        for (int j = 0; j < p; j++){\n            if (i>>j&1){\n                dpL[i] = max(dpL[i],R[j][dpL[i^(1<<j)]+1]);\n                dpR[i] = min(dpR[i],L[j][dpR[i^(1<<j)]-1]);\n            }\n        }\n        //printf(\"dp of %d : %d %d\\n\",i,dpL[i],dpR[i]);\n    }\n\n    for (int i = 0; i <= LIM; i++){\n        int LL = dpL[i];\n        int RR = dpR[LIM^i];\n        if (RR <= LL){\n            for (int i = 1; i <= n; i++) printf(\"Possible\\n\");\n            return 0;\n        }\n        //printf(\"mask %d: left (%d) %d, right (%d) %d\\n\",i,i,LL,LIM^i,RR);\n        //printf(\"ids = %d %d\\n\",id[LL+1],id[RR-2]);\n        if (id[RR-2] == id[LL]) {\n            //printf(\"%d - %d can\\n\",LL+1,RR-1);\n            sum[LL+1]++;\n            sum[RR]--;\n        }\n    }\n    for (int i = 1; i <= n; i++){\n        sum[i] += sum[i-1];\n        //printf(\"%d \",sum[i]);\n        if (sum[i] > 0){\n            printf(\"Possible\\n\");\n        }\n        else{\n            printf(\"Impossible\\n\");\n        }\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2019/11/16] 15:47:41\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing uint = unsigned int;\nusing usize = std::size_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\n\ntemplate<typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename... Args>\nauto read(const usize size, Args... args)\n{\n    std::vector<decltype(read<T>(args...))> ans(size);\n    for (usize i = 0; i < size; i++) { ans[i] = read<T>(args...); }\n    return ans;\n}\ntemplate<typename... Types>\nauto reads() { return std::tuple<std::decay_t<Types>...>{read<Types>()...}; }\n#    define SHOW(...) static_cast<void>(0)\n\ntemplate<typename T>\nstd::vector<T> make_v(const usize size, const T v) { return std::vector<T>(size, v); }\ntemplate<typename... Args>\nauto make_v(const usize size, Args... args) { return std::vector<decltype(make_v(args...))>(size, make_v(args...)); }\nint main()\n{\n    const auto n = read<int>(), v = read<int>();\n    const auto x = read<ll>(n);\n    std::vector<int> vs{v};\n    for (; vs.back() > 0;) { vs.push_back(vs.back() / 2); }\n    SHOW(vs);\n    const int jump = vs.size();\n    SHOW(jump);\n    auto right = make_v(jump, n, n - 1);\n    for (int i = 0; i < jump; i++) {\n        for (int j = (int)n - 2; j >= 0; j--) {\n            const ll dx = x[j + 1] - x[j];\n            right[i][j] = (dx <= vs[i] ? right[i][j + 1] : j);\n        }\n    }\n    SHOW(right);\n    auto left = make_v(jump, n, 0);\n    for (int i = 0; i < jump; i++) {\n        for (int j = 1; j < n; j++) {\n            const ll dx = x[j] - x[j - 1];\n            left[i][j]  = (dx <= vs[i] ? left[i][j - 1] : j);\n        }\n    }\n    SHOW(left);\n    const int mask = 1 << jump;\n    std::vector<int> rdp(mask, -1);\n    for (int m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const int pos = rdp[m] + 1;\n        for (int i = 1; i < jump; i++) {\n            if (btest(m, i)) { continue; }\n            if (rdp[m] == n - 1) {\n                chmax(rdp[m | (1 << i)], rdp[m]);\n                continue;\n            }\n            const int r = right[i][pos];\n            chmax(rdp[m | (1 << i)], r);\n        }\n    }\n    std::vector<int> ldp(mask, n);\n    for (int m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const int pos = ldp[m] - 1;\n        for (int i = 1; i < jump; i++) {\n            if (btest(m, i)) { continue; }\n            if (ldp[m] == 0) {\n                chmin(ldp[m | (1 << i)], ldp[m]);\n                continue;\n            }\n            const int l = left[i][pos];\n            chmin(ldp[m | (1 << i)], l);\n        }\n    }\n    SHOW(ldp, rdp);\n    std::vector<int> ok(n, 0);\n    for (int m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const int l = rdp[m];\n        const int r = ldp[(mask - 2) - m];\n        SHOW(m, l, r);\n        if (l + 1 >= r) {\n            std::fill(ok.begin(), ok.end(), 1);\n            break;\n        }\n        const int r2 = right[0][l + 1 == n ? n - 1 : l + 1];\n        const int l2 = left[0][r2];\n        if (r2 + 1 >= r) {\n            if (r2 + 1 < n) { ok[r2 + 1]--; }\n            ok[l2]++;\n        }\n    }\n    SHOW(ok);\n    for (int i = 1; i < n; i++) { ok[i] += ok[i - 1]; }\n    for (int i = 0; i < n; i++) { std::cout << (ok[i] > 0 ? \"Possible\" : \"Impossible\") << std::endl; }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200200, lg = 21;\nint vi[lg], tol[lg][maxn], tor[lg][maxn], a[maxn];\nint n, v, stk;\nint dpl[lg][maxn], dpr[lg][maxn];\nint main(){\n\tcin >> n >> v;\n\twhile(v){\n\t\tvi[stk++] = v;\n\t\tv /= 2;\n\t}\n\tvi[stk++] = 0;\n\treverse(vi, vi + stk);\n\tfor(int i = 1; i <= n; i++) cin >> a[i];\n\tfor(int j = 0; j < stk; j++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i == 1 || a[i] - a[i - 1] > vi[j]) tol[j][i] = i;\n\t\t\telse tol[j][i] = tol[j][i-1];\n\t\t}\n\t\tfor(int i = n; i >= 1; i--){\n\t\t\tif(i == n || a[i + 1] - a[i] > vi[j]) tor[j][i] = i;\n\t\t\telse tor[j][i] = tor[j][i+1];\n\t\t}\n\t}\n\tconst int full = (1<<30) - 1;\n\tauto merge = [&](int a, int b){\n\t\tif(__builtin_popcount(a) + __builtin_popcount(b) > stk) return full;\n\t\twhile(a & b) b <<= 1;\n\t\treturn a | b;\n\t};\n\tauto combine = [&](int a, int b){\n\t\tif(__builtin_popcount(a) + __builtin_popcount(b) > stk) return full;\n\t\twhile(b){\n\t\t\tint l = b & - b;\n\t\t\ta = merge(a, l);\n\t\t\tb ^= l;\n\t\t}\n\t\treturn a;\n\t};\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < stk; j++) dpl[j][i] = full;\n\t\tfor(int j = 0; j < stk; j++){\n\t\t\tfor(int k = 0; k < stk; k++){\n\t\t\t\tint q = merge(dpl[k][tol[j][i]-1], 1<<j);\n\t\t\t\tint cn = min(lg - 1, __builtin_popcount(q));\n\t\t\t\tdpl[cn][i] = min(dpl[cn][i], q);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = n; i >= 1; i--){\n\t\tfor(int j = 0; j < stk; j++) dpr[j][i] = full;\n\t\tfor(int j = 0; j < stk; j++){\n\t\t\tfor(int k = 0; k < stk; k++){\n\t\t\t\tint q = merge(dpr[k][tor[j][i]+1], 1<<j);\n\t\t\t\tint cn = min(lg - 1, __builtin_popcount(q));\n\t\t\t\tdpr[cn][i] = min(dpr[cn][i], q);\n\t\t\t}\t\n\t\t}\n\t}\n\tfor(int i = 1, j = 1; i <= n; i = j){\n\t\twhile(j + 1 <= n && a[j + 1] - a[j] <= vi[stk - 1]) j++;\n\t\tbool possible = false;\n\t\tfor(int k0 = 0; k0 < stk; k0++){\n\t\t\tfor(int k1 = 0; k1 < stk; k1++){\t\n\t\t\t\tint a = dpl[k0][i - 1], b = dpr[k1][j + 1];\n\t\t\t\ta = min(combine(a, b), combine(b, a));\n\t\t\t\tpossible |= __builtin_popcount(a) < stk && a < (1<<(stk - 1));\n\t\t\t}\n\t\t}\n\t\tfor(int k = i; k <= j; k++){\n\t\t\tif(possible) cout << \"Possible\\n\";\n\t\t\telse cout << \"Impossible\\n\";\n\t\t}\n\t\tj++;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=200005;\n\nint a[N],L[25][N],R[25][N],f[N],g[N],S[N];\n\nint main()\n{\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tios::sync_with_stdio(false);\n\tint n,m,k,cnt=0;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tcin>>a[i];\n\t\tif(i!=1&&a[i]-a[i-1]>m) ++cnt;\n\t}\n\tk=log2(m)+2;\n//\tcout<<k<<endl;\n\tif(cnt>k)\n\t{\n\t\tfor(int i=1;i<=n;i++) cout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tint s=m;\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tL[i][1]=1;\n\t\tR[i][n]=n;\n\t\tfor(int j=2;j<=n;j++)\n\t\t{\n\t\t\tif(a[j]-a[j-1]>s) L[i][j]=j;\n\t\t\telse L[i][j]=L[i][j-1];\n\t\t}\n\t\tfor(int j=n-1;j>=1;j--)\n\t\t{\n\t\t\tif(a[j+1]-a[j]>s) R[i][j]=j;\n\t\t\telse R[i][j]=R[i][j+1];\n\t\t}\n\t\ts/=2;\n\t}\n\t/*for(int i=0;i<k;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++) cout<<L[i][j]<<\" \";\n\t\tcout<<endl;\n\t\tfor(int j=1;j<=n;j++) cout<<R[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\tcout<<endl;*/\n\tfor(int i=0;i<(1<<k);i++)\n\t{\n\t\tf[i]=0;\n\t\tg[i]=n+1;\n\t}\n\tfor(int i=0;i<(1<<(k-1));i++)\n\t{\n\t\tfor(int j=1;j<k;j++)\n\t\t{\n\t\t\tif(!(i&(1<<(j-1))))\n\t\t\t{\n\t\t\t\tif(f[i]==n) f[i|(1<<(j-1))]=n;\n\t\t\t\telse f[i|(1<<(j-1))]=max(f[i|(1<<(j-1))],R[j][f[i]+1]);\n\t\t\t\tif(g[i]==1) g[i|(1<<(j-1))]=1;\n\t\t\t\telse g[i|(1<<(j-1))]=min(g[i|(1<<(j-1))],L[j][g[i]-1]);\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=0;i<(1<<(k-1));i++) cout<<f[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<(1<<(k-1));i++) cout<<g[i]<<\" \";\n\tcout<<endl;*/\n\tfor(int i=0;i<=n;i++) S[i]=0x7f7f7f7f;\n\tfor(int i=0;i<(1<<(k-1));i++) \n\t{\n\t//\tcout<<i<<\" \"<<(1<<(k-1))<<\" \"<<((1<<(k-1))^i)<<endl;\n\t\tS[f[i]]=min(S[f[i]],g[((1<<(k-1))-1)^i]);\n\t}\n//\tfor(int i=0;i<=n;i++) cout<<S[i]<<\" \";\n//\tcout<<endl;\n\tfor(int i=n-1;i>=0;i--) S[i]=min(S[i],S[i+1]);\n//\tfor(int i=0;i<=n;i++) cout<<S[i]<<\" \";\n//\tcout<<endl;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(S[L[0][i]-1]<=R[0][i]+1) cout<<\"Possible\"<<endl;\n\t\telse cout<<\"Impossible\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || '9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch && ch<='9')x=x*10+(ch^48),ch=getchar();\n\treturn x*f;\n}\n\ninline void chkmax(int &a,int b){if(a<b)a=b;}\ninline void chkmin(int &a,int b){if(a>b)a=b;}\n\n#define guo cerr<<\"guo\"<<endl\nconst int N=2e5+9;\nconst int K=21;\n\nint n,m,v;\nint x[N];\nint vs[N],vtop;\nint pre[K][N],suf[K][N];\nint pr[N],su[N],mp[N];\n\nint main()\n{\n\tif(fopen(\"vj.in\",\"r\"))\n\t{\n\t\tfreopen(\"vj.in\",\"r\",stdin);\n\t\tfreopen(\"vj.out\",\"w\",stdout);\n\t}\n\n\tn=read();v=read();\n\tfor(int i=1;i<=n;i++)\n\t\tx[i]=read();\n\tfor(int a=v>>1;vs[vtop++]=a;a>>=1);\n\tm=1<<vtop;vs[vtop]=v;\n\n\tfor(int k=0;k<=vtop;k++)\n\t{\n\t\tpre[k][0]=0,suf[k][n+1]=n+1;\n\t\tfor(int i=1,j=1;i<=n;i=j+1)\n\t\t{\n\t\t\tfor(j=i;j+1<=n && x[j+1]-x[j]<=vs[k];j++);\n\t\t\tfor(int l=i;l<=j;l++)\n\t\t\t\tpre[k][l]=i,suf[k][l]=j;\n\t\t}\n\t}\n\n\tfor(int i=0;i<m;i++)\n\t\tsu[i]=n+1;\n\tfor(int i=1;i<m;i++)\n\t\tfor(int j=0;j<vtop;j++)\n\t\t\tif(i&(1<<j))\n\t\t\t{\n\t\t\t\tchkmin(su[i],pre[j][su[i^(1<<j)]-1]);\n\t\t\t\tchkmax(pr[i],suf[j][pr[i^(1<<j)]+1]);\n\t\t\t}\n\n\tfor(int i=0;i<m;i++)\n\t\tchkmax(mp[su[m-1-i]-1],pr[i]+1);\n\tfor(int i=0;i<=n;i++)\n\t\tchkmax(mp[i+1],mp[i]);\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(mp[suf[vtop][i]]>=pre[vtop][i])\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n\t}\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, b) for (int i = a; i <= b; ++i)\n#define PER(i, a, b) for (int i = a; i >= b; --i)\n#define RVC(i, S) for (int i = 0; i < S.size(); ++i)\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef vector<int> VI;\n \ninline int read(){\n    int x = 0, ch = getchar(), f = 1;\n    while (!isdigit(ch)){if (ch == '-') f = -1; ch = getchar();}\n    while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n    return x * f;\n}\n\nconst int N = 200005;\nint n, V, vi[20], pos[N], col[20][N], lb[20][N], rb[20][N];\nint dpL[N], dpR[N], vis[N];\n\nint main(){\n\tn = read(), V = read();\n\tREP(i, 1, n) pos[i] = read();\n\tfor (int i = V; i; i >>= 1)\n\t\tvi[++vi[0]] = i;\n\tvi[++vi[0]] = 0;\n\tREP(i, 1, vi[0]){\n\t\tint idx = 1;\n\t\tlb[i][1] = col[i][1] = 1;\n\t\tREP(j, 2, n){\n\t\t\tif (pos[j] - pos[j - 1] > vi[i]){\n\t\t\t\trb[i][idx] = j - 1;\n\t\t\t\tlb[i][++idx] = j;\n\t\t\t}\n\t\t\tcol[i][j] = idx;\n\t\t}\n\t\trb[i][idx] = n;\n\t\tif (idx == 1){\n\t\t\tREP(i, 1, n) printf(\"Possible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint U = (1 << vi[0]) - 1;\n\t\n\tdpL[0] = 0;\n\tREP(i, 1, U) REP(j, 0, vi[0] - 1)\n\t\tif (i & (1 << j))\n\t\t\tdpL[i] = max(dpL[i], rb[j + 1][col[j + 1][dpL[i ^ (1 << j)] + 1]]);\n\t\n\tdpR[0] = n + 1;\n\tREP(i, 1, U) REP(j, 0, vi[0] - 1)\n\t\tif (i & (1 << j))\n\t\t\tdpR[i] = max(dpR[i], lb[j + 1][col[j + 1][dpR[i ^ (1 << j)] - 1]]);\n\n\tfor (int i = U - 1; i; i = (i - 1) & (U - 1)){\n\t\tint j = U - 1 - i;\n\t\tif (col[1][dpL[i] + 1] == col[1][dpR[j] - 1])\n\t\t\t\tvis[col[1][dpL[i] + 1]] = 1;\n\t\tswap(i, j);\n\t\tif (col[1][dpL[i] + 1] == col[1][dpR[j] - 1])\n\t\t\t\tvis[col[1][dpL[i] + 1]] = 1;\n\t\tswap(i, j);\n\t}\n\n\tREP(i, 1, n) if (vis[col[1][i]]) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (1050000)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,m,p[N],cnt,ri[N],le[N];\nvector<int> seg[22];\nvoid spj(){\n\tif(seg[cnt].size()<=cnt+2)return;\n\tfor(int i=1;i<=n;i++)puts(\"Impossible\");exit(0);\n}\nint main(){\n\tread(n),read(m);\n\tfor(int i=1;i<=n;i++)read(p[i]); p[n+1]=inf,p[0]=-inf;\n\tfor(cnt=0;(m>>cnt)>0;cnt++);\n\tfor(int i=0;i<=cnt;i++)\n\tfor(int j=0;j<=n;j++)\n\tif(p[j+1]-p[j]>(m>>i))seg[cnt-i].push_back(j);\n//\tcout<<cnt+1<<endl;\n//\tfor(int i=0;i<=cnt;i++){\n//\t\tprintf(\"#%d(%d):\",i,m>>(cnt-i));\n//\t\tfor(int j=0;j<seg[i].size();j++)printf(\"%d \",seg[i][j]); puts(\"\");\n//\t}\n\tspj();\n\tfor(int i=0;i<(1<<cnt);i++)le[i]=n+1,ri[i]=0;\n\tfor(int i=0;i<(1<<cnt);i++)\n\tfor(int j=cnt-1;~j;j--)\n\tif(!(i&(1<<j))){\n\t\tint v=i|(1<<j);\n\t\tri[v]=max(ri[v],*(upper_bound(seg[j].begin(),seg[j].end(),ri[i])));\n\t\tle[v]=min(le[v],*(lower_bound(seg[j].begin(),seg[j].end(),le[i]-1)-1)+1);\n\t}\n//\tfor(int i=0;i<(1<<cnt);i++)\n//\tprintf(\"%d %d %d\\n\",i,le[i],ri[i]);\n\tfor(int i=0;i<seg[cnt].size()-1;i++){\n\t\tbool fl=0;\n\t\tfor(int j=0;j<(1<<cnt);j++)\n\t\tif(ri[j]>=seg[cnt][i]&&le[((1<<cnt)-1)^j]<=seg[cnt][i+1]+1){fl=1;break;}\n\t\tfor(int tt=seg[cnt][i]+1;tt<=seg[cnt][i+1];tt++)\n\t\tif(!fl)puts(\"Impossible\");else puts(\"Possible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk make_pair\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,t,v,len[20],p[MAXN],Fl[1<<18],Fr[1<<18],S,a[MAXN];\nvector<int>L[20],R[20];\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),v=read(),t=log2(v)+1,S=(1<<t)-1;\n\tRep(i,1,n)p[i]=read();\n\tRep(i,0,t){\n\t\tlen[i]=i?len[i-1]/2:v;\n\t\tfor(int l=1,r;l<=n;l=r+1){\n\t\t\tfor(r=l;r<n&&p[r+1]-p[r]<=len[i];r++);\n\t\t\tL[i].pb(l),R[i].pb(r);\n\t\t}\n\t}\n\tRep(sta,0,S)Fr[sta]=n+1,Fl[sta]=0;\n\tRep(i,1,t)Fl[1<<i-1]=(*R[i].begin()),Fr[1<<i-1]=(*--L[i].end());\n\tRep(sta,1,S)Rep(j,1,t)if(~sta>>(j-1)&1){\n\t\tint t=sta|(1<<j-1),pos;\n\t\tpos=upper_bound(L[j].begin(),L[j].end(),Fl[sta]+1)-L[j].begin()-1;\n\t\tassert(pos>=0&&pos<R[j].size()),Fl[t]=max(Fl[t],R[j][pos]);\n\t\tpos=lower_bound(R[j].begin(),R[j].end(),Fr[sta]-1)-R[j].begin();\n\t\tassert(pos>=0&&pos<L[j].size()),Fr[t]=min(Fr[t],L[j][pos]);\n\t}\n\tRep(s,0,S){\n\t\tint ed=upper_bound(L[0].begin(),L[0].end(),Fl[s]+1)-L[0].begin()-1,st=lower_bound(R[0].begin(),R[0].end(),Fr[S^s]-1)-R[0].begin();\n\t\tif(st<=ed)a[st]++,a[ed+1]--;\n\t}\n\tfor(int i=0;i<L[0].size();i++){\n\t\ta[i]+=a[i-1];\n\t\tRep(j,L[0][i],R[0][i])puts(a[i]?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, b) for (int i = a; i <= b; ++i)\n#define PER(i, a, b) for (int i = a; i >= b; --i)\n#define RVC(i, S) for (int i = 0; i < S.size(); ++i)\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef vector<int> VI;\n \ninline int read(){\n    int x = 0, ch = getchar(), f = 1;\n    while (!isdigit(ch)){if (ch == '-') f = -1; ch = getchar();}\n    while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n    return x * f;\n}\n\nconst int N = 200005;\nint n, V, vi[20], pos[N], col[20][N], lb[20][N], rb[20][N];\nint dpL[N], dpR[N], vis[N];\n\nint main(){\n\tn = read(), V = read();\n\tREP(i, 1, n) pos[i] = read();\n\tfor (int i = V; i; i >>= 1)\n\t\tvi[++vi[0]] = i;\n\tvi[++vi[0]] = 0;\n\tREP(i, 1, vi[0]){\n\t\tint idx = 1;\n\t\tlb[i][1] = col[i][1] = 1;\n\t\tREP(j, 2, n){\n\t\t\tif (pos[j] - pos[j - 1] > vi[i]){\n\t\t\t\trb[i][idx] = j - 1;\n\t\t\t\tlb[i][++idx] = j;\n\t\t\t}\n\t\t\tcol[i][j] = idx;\n\t\t}\n\t\trb[i][idx] = n;\n\t\t// REP(j, 1, idx) debug(\"%d %d = [%d, %d]\\n\", vi[i], idx, lb[i][j], rb[i][j]);\n\t}\n\tint U = (1 << vi[0]) - 1;\n\t\n\tdpL[0] = 0;\n\tREP(i, 1, U) REP(j, 0, vi[0] - 1)\n\t\tif (i & (1 << j))\n\t\t\tdpL[i] = max(dpL[i], rb[j + 1][col[j + 1][dpL[i ^ (1 << j)] + 1]]);\n\n\tdpR[0] = n + 1;\n\tREP(i, 1, U){\n\t\tdpR[i] = n + 1;\n\t\tREP(j, 0, vi[0] - 1)\n\t\t\tif (i & (1 << j))\n\t\t\t\tdpR[i] = min(dpR[i], lb[j + 1][col[j + 1][dpR[i ^ (1 << j)] - 1]]);\n\t\t// debug(\"dpR[%d]= %d\\n\", i, dpR[i]);\n\t}\n\n\tfor (int i = U - 1; i; i = (i - 1) & (U - 1)){\n\t\tint j = U - 1 - i;\n\t\t// cerr << dpL[i] << ' ' << dpR[j] << endl;\n\t\tif (col[1][dpL[i] + 1] == col[1][dpR[j] - 1])\n\t\t\t\tvis[col[1][dpL[i] + 1]] = 1;\n\t\tswap(i, j);\n\n\t\t// cerr << dpL[i] << ' ' << dpR[j] << endl;\n\t\tif (col[1][dpL[i] + 1] == col[1][dpR[j] - 1])\n\t\t\t\tvis[col[1][dpL[i] + 1]] = 1;\n\t\tswap(i, j);\n\t}\n\n\tREP(i, 1, n) if (vis[col[1][i]]) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define fir first\n#define sec second\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int maxN = 2e5 + 2;\n\ninline bool Chkmax(int& x, int y)\n{ return x < y ? x = y, true : false; }\n\ninline bool Chkmin(int& x, int y)\n{ return x > y ? x = y, true : false; }\n\nint n, v, cnt;\nint SUC[maxN], ans[maxN];\nint x[maxN], f[maxN << 1], g[maxN << 1];\nvector<pii> line[20];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n    cin >> n >> v;\n    for (int i = 1; i <= n; ++i)\n        cin >> x[i];\n    do\n    {\n        int l = 1, r = 1; // attenion that l = 0\n        for (int j = 2; j <= n; ++j)\n        {\n            if (x[j] - (v >> cnt) > x[r])\n            {\n                line[cnt].emplace_back(l, r);\n                l = j;\n            }\n            r = j;\n        }\n        line[cnt].emplace_back(l, r);\n    } while (v >> cnt++);\n    // cout << cnt << endl;\n    --cnt;\n//    for (int i = 0; i < cnt; ++i)\n//        for (auto j : line[i])\n//            cout << j.fir << ' ' << j.sec << endl;\n    fill(f, f + (1 << cnt), -1);\n    fill(g, g + (1 << cnt), n + 2);\n    f[0] = 0, g[0] = n + 1;\n    for (int i = 0; i < cnt; ++i)\n        f[1 << i] = line[i + 1].begin()->sec, g[1 << i] = line[i + 1].rbegin()->fir;\n    for (int i = 1; i < 1 << cnt; ++i) if (~f[i])\n        for (int j = 1; j <= cnt; ++j)\n            if (!(i >> (j - 1) & 1))\n            {\n                auto pos = lower_bound(line[j].begin(), line[j].end(), pii(f[i] + 2, 0)) - 1;\n                Chkmax(f[i | 1 << (j - 1)], pos->sec);\n            }\n    for (int i = 1; i < 1 << cnt; ++i) if (g[i] != n + 2)\n        for (int j = 1; j <= cnt; ++j)\n            if (!(i >> (j - 1) & 1))\n            {\n                auto pos = lower_bound(line[j].begin(), line[j].end(), pii(g[i], 0));\n                if (pos != line[j].begin())\n                    Chkmin(g[i | 1 << (j - 1)], --pos->fir);\n            }\n    fill(SUC, SUC + n + 1, n + 2);\n    // cout << f[1] << ' ' << g[1] << endl;\n    for (int i = 0, all = (1 << cnt) - 1; i <= all; ++i)\n        Chkmin(SUC[f[i]], g[all ^ i]);\n    for (int i = n; i; --i)\n        Chkmin(SUC[i - 1], SUC[i]);\n    //for (int i = 0; i <= n; ++i)\n    //    cout << SUC[i] << ' ';\n    //cout << endl;\n    for (auto i : line[0])\n    {\n        // cout << i.fir << ' ' << i.sec << endl;\n        int flag = SUC[i.fir - 1] <= i.sec + 1;\n        for (int j = i.fir; j <= i.sec; ++j)\n            cout << (flag ? \"Possible\" : \"Impossible\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <set>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cassert>\n#define rep(i,m,n) for(i=m;i<=n;i++)\n#define mod 1000000007\n#define inf 0x3f3f3f3f\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define ll long long\n#define pi acos(-1.0)\n#define pii pair<int,int>\n#define sys system(\"pause\")\nconst int maxn=2e5+10;\nconst int N=2e5+10;\nusing namespace std;\nint id(int l,int r){return l+r|l!=r;}\nll gcd(ll p,ll q){return q==0?p:gcd(q,p%q);}\nll qpow(ll p,ll q){ll f=1;while(q){if(q&1)f=f*p%mod;p=p*p%mod;q>>=1;}return f;}\nint n,m,k,t,v,x[maxn],d[20],ret[maxn],l[20][maxn],r[20][maxn],dpl[1<<20],dpr[1<<20],tot;\nint main()\n{\n    int i,j;\n    scanf(\"%d%d\",&n,&v);\n    rep(i,1,n)scanf(\"%d\",&x[i]);\n    while(v)\n    {\n        d[tot++]=v;\n        v/=2;\n    }\n    d[tot++]=0;\n    rep(i,0,tot-1)\n    {\n        rep(j,1,n)\n        {\n            if(j>1&&x[j]-x[j-1]<=d[i])l[i][j]=l[i][j-1];\n            else l[i][j]=j;\n        }\n        for(j=n;j>=1;j--)\n        {\n            if(j<n&&x[j+1]-x[j]<=d[i])r[i][j]=r[i][j+1];\n            else r[i][j]=j;\n        }\n    }\n    rep(i,0,(1<<tot)-1)dpr[i]=n+1;\n    rep(i,0,(1<<tot)-1)\n    {\n        rep(j,0,tot-1)\n        {\n            if(~i&(1<<j))\n            {\n                if(dpl[i]+1<=n)dpl[i^(1<<j)]=max(dpl[i^(1<<j)],r[j][dpl[i]+1]);\n                if(dpr[i]-1>=1)dpr[i^(1<<j)]=min(dpr[i^(1<<j)],l[j][dpr[i]-1]);\n            }\n        }\n    }\n    rep(i,0,(1<<tot)-1)\n    {\n        if(i&1)continue;\n        if(dpl[i]>=dpr[(i^((1<<tot)-1))-1])\n        {\n            ret[1]++;\n            ret[n+1]--;\n        }\n        else\n        {\n            if(r[0][dpl[i]+1]>=dpr[(i^((1<<tot)-1))-1]-1)\n            {\n                int x=dpl[i]+1;\n                ret[l[0][x]]++;\n                ret[r[0][x]+1]--;\n            }\n        }\n    }\n    rep(i,1,n)\n    {\n        ret[i]+=ret[i-1];\n        puts(ret[i]?\"Possible\":\"Impossible\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 233333;\nint n,v,a[N],len,bh[20][N],num;Vi e[N*20];\nstruct Seg{\n\tint r[N];\n\tvoid init(int x){\n\t\tper(i,n,1){r[i]=i;if(i+1<=n&&a[i+1]-a[i]<=x)r[i]=r[i+1];}\n\t}\n}b[20];\nmap<Vi,bool>Map[20];\nbool ck(int dep, Vi c){\n\tif(SZ(c)>len-dep+1)return 0;if(dep==len||!SZ(c))return 1;\n\tsort(c.begin(),c.end());\n\tif(Map[dep].count(c))return Map[dep][c];\n\tbool ok=0;\n\trep(i,0,SZ(c)-1){\n\t\tVi d;rep(j,0,SZ(c)-1)if(i!=j)rep(k,0,SZ(e[c[j]])-1)d.pb(e[c[j]][k]);\n\t\tif(ck(dep+1,d)){ok=1;break;}\n\t}\n\treturn Map[dep][c]=ok;\n}\nint main() {\n\tread(n);read(v);rep(i,1,n)read(a[i]);\n\twhile(1){b[++len].init(v);if(!v)break;v/=2;}\n\trep(i,1,len)rep(j,1,n)if(b[i].r[j]!=b[i].r[j-1])bh[i][j]=++num;\n\trep(i,1,len-1)rep(j,1,n)if(bh[i][j]){\n\t\tfor(int k=j;k<=b[i].r[j];k=b[i+1].r[k]+1)\n\t\t\te[bh[i][j]].pb(bh[i+1][k]);\n\t}\n\tVi top;rep(i,1,n)if(bh[1][i])top.pb(bh[1][i]);\n\tif(SZ(top)>=20){\n\t\trep(i,1,n)puts(\"Impossible\");return 0;\n\t}\n\tfor(int i=1;i<=n;i=b[1].r[i]+1){\n\t\tVi c;rep(j,0,SZ(top)-1)if(top[j]!=bh[1][i])rep(k,0,SZ(e[top[j]])-1)c.pb(e[top[j]][k]);\n\t\tbool ok=ck(2,c);\n\t\trep(j,i,b[1].r[i])printf(\"%s\\n\",ok?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][30],tmp[30][30];\n\n#include<ext/pb_ds/assoc_container.hpp>\n//::unordered_map<uint,bool>hs;\n__gnu_pbds::cc_hash_table<uint,bool>hs;\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\tuint hash=dep;\n\tfo0(i,cnt)hash=hash*2337+s[i];\n\tif(hs.find(hash)!=hs.end())return hs[hash];\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>=dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\tr[i]=t[i];\n\t}\n\treturn hs[hash]=0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<cmath>\n#include<functional>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nvoid sort(int &a,int &b)\n{\n\tif(a>b)\n\t\tswap(a,b);\n}\nvoid open(const char *s)\n{\n#ifndef ONLINE_JUDGE\n\tchar str[100];\n\tsprintf(str,\"%s.in\",s);\n\tfreopen(str,\"r\",stdin);\n\tsprintf(str,\"%s.out\",s);\n\tfreopen(str,\"w\",stdout);\n#endif\n}\nint rd()\n{\n\tint s=0,c;\n\twhile((c=getchar())<'0'||c>'9');\n\tdo\n\t{\n\t\ts=s*10+c-'0';\n\t}\n\twhile((c=getchar())>='0'&&c<='9');\n\treturn s;\n}\nint upmin(int &a,int b)\n{\n\tif(b<a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint upmax(int &a,int b)\n{\n\tif(b>a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint v[200010];\nint f[1<<21];\nint g[1<<21];\nint l[30][200010];\nint r[30][200020];\nint a[200010];\nint b[200010];\nint main()\n{\n//\topen(\"agc012e\");\n\tint n;\n\tscanf(\"%d%d\",&n,&v[1]);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tint t=1;\n\twhile(1)\n\t{\n\t\tv[t+1]=v[t]/2;\n\t\tt++;\n\t\tif(!v[t])\n\t\t\tbreak;\n\t}\n\tfor(i=1;i<=t;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j==1||a[j]-a[j-1]>v[i])\n\t\t\t\tl[i][j]=j;\n\t\t\telse\n\t\t\t\tl[i][j]=l[i][j-1];\n\t\tfor(j=n;j>=1;j--)\n\t\t\tif(j==n||a[j+1]-a[j]>v[i])\n\t\t\t\tr[i][j]=j;\n\t\t\telse\n\t\t\t\tr[i][j]=r[i][j+1];\n\t}\n\tmemset(f,0,sizeof f);\n\tint all=1<<t;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(f[i]==n)\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],f[i]);\n\t\t\t\telse\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],r[j][f[i]+1]);\n\t\t\t}\n\tfor(i=0;i<all;i++)\n\t\tg[i]=n+1;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(g[i]==1)\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],g[i]);\n\t\t\t\telse\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],l[j][g[i]-1]);\n\t\t\t}\n\tif(f[all-2]>=n)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t\tprintf(\"Possible\\n\");\n\t\treturn 0;\n\t}\n\tfor(i=0;i<all;i++)\n\t\tif(!(i&1)&&(f[i]+r[1][f[i]+1]>=n||g[(all-1)^i^1]<=r[1][f[i]+1]+1))\n\t\t\tb[l[1][f[i]+1]+1]=1;\n\tint last=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(b[i])\n\t\t\tlast=i;\n\t\tif(l[1][i]<=last||(i<=r[1][1]&&r[1][1]>=g[all-2]-1))\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, V, K;\nint X[200010], L[20][200010], R[20][200010];\nvector<int> P;\n\nint cc1[1 << 20];\nint dp1(int mask) {\n    if(mask == 0) return -1;\n    int &ret = cc1[mask];\n    if(ret != -1) return ret;\n    if(mask == 0) return ret = 0;\n\n    ret = -1;\n    for(int i = 0; i < K; i++) {\n        if(mask & (1 << i)) {\n            ret = max(ret, (dp1(mask - (1 << i)) == N - 1? N - 1 : R[i][ dp1(mask - (1 << i)) + 1 ]));\n        }\n    }\n    return ret;\n}\nint cc2[1 << 20];\nint dp2(int mask) {\n    if(mask == 0) return N;\n    int &ret = cc2[mask];\n    if(ret != -1) return ret;\n\n    ret = N;\n    for(int i = 0; i < K; i++) {\n        if(mask & (1 << i)) {\n            ret = min(ret, (dp2(mask - (1 << i)) == 0? 0 : L[i][ dp2(mask - (1 << i)) - 1 ]));\n        }\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &V);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    P.push_back(V);\n    while(P.back()) {\n        int t = P.back() / 2;\n        P.push_back(t);\n    }\n    reverse(P.begin(), P.end());\n\n    K = P.size();\n\n    for(int i = 0; i < K; i++) {\n        int pos = 0;\n        for(int j = 0; j < N; j++) {\n            if(pos < j) pos = j;\n            while(pos < N - 1 && X[pos + 1] - X[pos] <= P[i]) pos++;\n            R[i][j] = pos;\n        }\n        pos = N - 1;\n        for(int j = N - 1; j >= 0; j--) {\n            if(pos > j) pos = j;\n            while(pos >= 1 && X[pos] - X[pos - 1] <= P[i]) pos--;\n            L[i][j] = pos;\n        }\n    }\n\n    memset(cc1, -1, sizeof(cc1));\n    memset(cc2, -1, sizeof(cc2));\n\n    if(dp1((1 << K) - 1) != N - 1) {\n        for(int i = 0; i < N; i++) {\n            printf(\"Impossible\\n\");\n        }\n        return 0;\n    }\n\n    int pos = 0;\n    while(pos < N) {\n        int nxt = R[K - 1][pos];\n\n        bool ok = false;\n        for(int i = 0; i < (1 << (K - 1)); i++) {\n            if(pos - 1 <= dp1(i) && dp2((1 << (K - 1)) - 1 - i) <= nxt + 1) {\n                ok = true;\n                break;\n            }\n        }\n        if(ok) {\n            for(int i = pos; i <= nxt; i++) {\n                printf(\"Possible\\n\");\n            }\n        }\n        else {\n            for(int i = pos; i <= nxt; i++) {\n                printf(\"Impossible\\n\");\n            }\n        }\n        pos = nxt + 1;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint n,m,k,a[200100],l[200100][20],r[200100][20],f[270000],g[270000],ans[200100];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()) && ch!='-');\n    bool flag=ch=='-';\n    if (flag)\n        ch=getchar();\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return flag?-x:x;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    repu(i,1,n)\n        a[i]=getint();\n    for (k=0; m>>k; ++k);\n    a[0]=-2e9,a[n+1]=2e9;\n    repu(i,0,k)\n        r[n+1][i]=n;\n    repu(i,1,n)\n        repu(j,0,k)\n        {\n            l[i][j]=a[i]-a[i-1]>m>>j?i:l[i-1][j];\n            for (r[i][j]=max(r[i-1][j],i); a[r[i][j]+1]-a[r[i][j]]<=m>>j; ++r[i][j]);\n        }\n    repu(i,0,(1<<k)-1)\n        g[i]=n+1;\n    repu(i,0,(1<<k)-1)\n        repu(j,1,k)\n            if (!(i&(1<<(j-1))))\n            {\n                int t=i|(1<<(j-1));\n                f[t]=max(f[t],r[f[i]+1][j]);\n                g[t]=min(g[t],l[g[i]-1][j]);\n            }\n    repu(i,0,(1<<k)-1)\n    {\n        int x=f[i],y=g[(1<<k)-1-i];\n        if (x+1>=y)\n            ++ans[1];\n        else\n            if (r[x+1][0]+1>=y)\n                ++ans[l[x+1][0]],--ans[r[x+1][0]+1];\n    }\n    repu(i,1,n)\n        puts((ans[i]+=ans[i-1])?\"Possible\":\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n首先跳跃次数最多是 logV ，每次跳跃后，可以通过普通的移动走尽可能多的点。\n那么按照 V 分 logV 层，每层 [1, n] 被拆分为若干线段，\n每个线段 [l, r] 表示在该层内从这个区间任一点开始可以遍历整个区间。\n那么问题转换为钦定第一层线段，求是否能从其他层中每层拿一个线段使得所有线段的并为 [1, n] 。\n\n由于层数很少，可以状压 DP 出 exl[S] 表示选 S 集合内的线段覆盖 [1, k] 的最大 k ，\n类似的有 exr[S] 表示覆盖 [k, n] 的最小 k 。\n转移通过 l[k][i]/r[k][i] 表示 k 层第 i 个点的左/右端点即可。\n\n统计答案时，枚举第一层的所有线段 [l, r]，\n并判断是否存在集合 S 使得 [1, exl[S]], [l, r], [exr[S], n] 的并为 [1, n] 即可。\n而如果第一层线段的数量如果超过总层数说明所有点都不会合法。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 800005, maxk = 20;\nint x[maxn];\nint exl[maxn], exr[maxn];\nint l[maxk][maxn], r[maxk][maxn];\nint len[maxk];\n\nint main() {\n\tint n = read, v = read;\n\tfor(int i = 1; i <= n; i ++)\n\t\tread(x[i]);\n\n\tint d = 0;\n\twhile(v) {\n\t\tlen[d ++] = v;\n\t\tv >>= 1;\n\t}\n\t++ d;\n\n\tfor(int k = 0; k < d; k ++) {\n\t\tl[k][1] = 1;\n\t\tfor(int i = 2; i <= n; i ++)\n\t\t\tif(x[i - 1] + len[k] >= x[i])\n\t\t\t\tl[k][i] = l[k][i - 1];\n\t\t\telse\n\t\t\t\tl[k][i] = i;\n\n\t\tr[k][n] = n;\n\t\tfor(int i = n - 1; i; i --)\n\t\t\tif(x[i] + len[k] >= x[i + 1])\n\t\t\t\tr[k][i] = r[k][i + 1];\n\t\t\telse\n\t\t\t\tr[k][i] = i;\n\t}\n\n\tfor(int S = 0; S < (1 << d); S ++) {\n\t\texl[S] = 0;\n\t\texr[S] = n + 1;\n\t\tfor(int k = 0; k < d; k ++)\n\t\t\tif(S >> k & 1) {\n\t\t\t\tint T = S ^ (1 << k);\n\t\t\t\texl[S] = std::max(exl[S], r[k][exl[T] + 1]);\n\t\t\t\texr[S] = std::min(exr[S], l[k][exr[T] - 1]);\n\t\t\t}\n\t\t/* debug(\"%d: %d %d\\n\", S, exl[S], exr[S]); */\n\t}\n\n\tint tot = 0;\n\tfor(int i = 1; i <= n; i = r[0][i] + 1)\n\t\t++ tot;\n\n\tif(tot > d) {\n\t\tfor(int i = 1; i <= n; i ++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\n\tfor(int i = 1; i <= n; i = r[0][i] + 1) {\n\t\tbool ok = 0;\n\t\tfor(int S = 0; S < (1 << d); S += 2) {\n\t\t\tint T = ((1 << d) - 2) ^ S ;\n\t\t\t/* if(exl[S] + 1 >= exr[T] or (exl[S] + 1 >= i and r[0][i] + 1 >= exr[T])) { */\n\t\t\tif(exl[S] + 1 >= i and r[0][i] + 1 >= exr[T]) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j = i; j <= r[0][i]; j ++)\n\t\t\tif(ok)\n\t\t\t\tputs(\"Possible\");\n\t\t\telse\n\t\t\t\tputs(\"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#define rep(i,st,ed) for (int i=st;i<=ed;++i)\n#define fill(x,t) memset(x,t,sizeof(x))\n\nconst int N=400005;\n\nint f[N],g[N],p[N],L[N],R[N],ans[N];\nint left[25][N],righ[25][N],bel[N];\nint n,V,tot;\n\nint read() {\n\tint x=0,v=1; char ch=getchar();\n\tfor (;ch<'0'||ch>'9';v=(ch=='-')?(-1):(v),ch=getchar());\n\tfor (;ch<='9'&&ch>='0';x=x*10+ch-'0',ch=getchar());\n\treturn x*v;\n}\n\nvoid pre(int v,int id) {\n\tfor (int i=1,j;i<=n;i=j+1) {\n\t\tfor (j=i;j<n&&p[j+1]-p[j]<=v;) j++;\n\t\trep(k,i,j) left[id][i]=j,righ[id][j]=i;\n\t}\n}\n\nvoid solve() {\n\tfor (int i=0,lim=(1<<tot);i<lim;++i) {\n\t\tg[i]=n+1;\n\t}\n\tfor (int i=0,lim=(1<<tot);i<lim;++i) {\n\t\trep(j,0,tot-1) if ((i>>j)&1) {\n\t\t\tf[i]=std:: max(f[i],left[j][f[i-(1<<j)]+1]);\n\t\t\tg[i]=std:: min(g[i],righ[j][g[i-(1<<j)]-1]);\n\t\t}\n\t}\n\tfor (int i=0,lim=(1<<tot);i<lim;++i) {\n\t\tint j=lim-i-1;\n\t\tif (f[i]+1>=L[bel[f[i]+1]]&&g[j]-1<=R[bel[f[i]+1]]) {\n\t\t\tans[bel[f[i]+1]]=1;\n\t\t}\n\t}\n}\n\nint main(void) {\n\tfill(righ,63);\n\tn=read(),V=read();\n\trep(i,1,n) p[i]=read();\n\tfor (int v=V/2;;v>>=1) {\n\t\tpre(v,tot++);\n\t\tif (!v) break;\n\t}\n\tfor (int i=1,j;i<=n;i=j+1) {\n\t\tbel[i]=++bel[0];\n\t\tfor (j=i;j<n&&p[j+1]-p[j]<=V;) bel[++j]=bel[0];\n\t\tL[bel[0]]=i,R[bel[0]]=j;\n\t}\n\tsolve();\n\trep(i,1,n) if (ans[bel[i]]) puts(\"Possible\");\n\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n首先跳跃次数最多是 logV ，每次跳跃后，可以通过普通的移动走尽可能多的点。\n那么按照 V 分 logV 层，每层 [1, n] 被拆分为若干线段，\n每个线段 [l, r] 表示在该层内从这个区间任一点开始可以遍历整个区间。\n那么问题转换为钦定第一层线段，求是否能从其他层中每层拿一个线段使得所有线段的并为 [1, n] 。\n\n由于层数很少，可以状压 DP 出 exl[S] 表示选 S 集合内的线段覆盖 [1, k] 的最大 k ，\n类似的有 exr[S] 表示覆盖 [k, n] 的最小 k 。\n转移通过 l[k][i]/r[k][i] 表示 k 层第 i 个点的左/右端点即可。\n\n统计答案时，枚举第一层的所有线段 [l, r]，\n并判断是否存在集合 S 使得 [1, exl[S]], [l, r], [exr[S], n] 的并为 [1, n] 即可。\n而如果第一层线段的数量如果超过总层数说明所有点都不会合法。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 400005, maxk = 20;\nint x[maxn];\nint exl[maxn], exr[maxn];\nint l[maxk][maxn], r[maxk][maxn];\nint len[maxk];\n\nint main() {\n\tint n = read, v = read;\n\tfor(int i = 1; i <= n; i ++)\n\t\tread(x[i]);\n\n\tint d = 0;\n\twhile(v) {\n\t\tlen[d ++] = v;\n\t\tv >>= 1;\n\t}\n\t++ d;\n\n\tfor(int k = 0; k < d; k ++) {\n\t\tl[k][1] = 1;\n\t\tfor(int i = 2; i <= n; i ++)\n\t\t\tif(x[i - 1] + len[k] >= x[i])\n\t\t\t\tl[k][i] = l[k][i - 1];\n\t\t\telse\n\t\t\t\tl[k][i] = i;\n\n\t\tr[k][n] = n;\n\t\tfor(int i = n - 1; i; i --)\n\t\t\tif(x[i] + len[k] >= x[i + 1])\n\t\t\t\tr[k][i] = r[k][i + 1];\n\t\t\telse\n\t\t\t\tr[k][i] = i;\n\t}\n\n\tfor(int S = 0; S < (1 << d); S ++) {\n\t\texl[S] = 0;\n\t\texr[S] = n + 1;\n\t\tfor(int k = 0; k < d; k ++)\n\t\t\tif(S >> k & 1) {\n\t\t\t\tint T = S ^ (1 << k);\n\t\t\t\texl[S] = std::max(exl[S], r[k][exl[T] + 1]);\n\t\t\t\texr[S] = std::min(exr[S], l[k][exr[T] - 1]);\n\t\t\t}\n\t\t/* debug(\"%d: %d %d\\n\", S, exl[S], exr[S]); */\n\t}\n\n\tint tot = 0;\n\tfor(int i = 1; i <= n; i = r[0][i] + 1)\n\t\t++ tot;\n\tif(tot > d) {\n\t\tfor(int i = 1; i <= n; i ++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\n\tfor(int i = 1; i <= n; i = r[0][i] + 1) {\n\t\tbool ok = 0;\n\t\tfor(int S = 0; S < (1 << d); S += 2) {\n\t\t\tint T = ((1 << d) - 2) ^ S ;\n\t\t\tif(exl[S] + 1 >= exr[T] or (exl[S] + 1 >= i and r[0][i] + 1 >= exr[T])) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j = i; j <= r[0][i]; j ++)\n\t\t\tif(ok)\n\t\t\t\tputs(\"Possible\");\n\t\t\telse\n\t\t\t\tputs(\"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,v;\n  cin>>n>>v;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n\n  vector<Int> dp;\n  vector<vector<Int> > ps;\n  while(v){\n    vector<Int> dp2(n,0);\n    for(Int i=1;i<n;i++)\n      dp2[i]=dp2[i-1]+(x[i]-x[i-1]>v);\n    if(dp.empty()) dp=dp2;\n\n    vector<Int> ps2;\n    ps2.emplace_back(0);\n    for(Int i=1;i<n;i++)\n      if(dp2[i]!=dp2[i-1]) ps2.emplace_back(i);\n    ps2.emplace_back(n);\n    ps.emplace_back(ps2);\n    v>>=1;\n  }\n  \n  {\n    vector<Int> ps2(n+1,0);\n    iota(ps2.begin(),ps2.end(),0);\n    ps.emplace_back(ps2);\n  }\n\n  vector<vector<Int> > memo(ps.size(),vector<Int>(n,-1));\n  function<Int(Int,Int)> calc=\n    [&](Int d,Int k)->Int{\n      if(d+1==(Int)ps.size()) return 1;\n      Int &res=memo[d][k];\n      if(~res) return res;\n      res=0;\n      vector<Int> &v=ps[d];\n      vector<Int> &u=ps[d+1];\n      Int x=lower_bound(u.begin(),u.end(),v[k])-u.begin();\n      Int tmp=0;\n      while(u[x]<v[k+1]){\n\tres+=calc(d+1,x);\n\tchmax(tmp,calc(d+1,x)-1);\n\tx++;\n      }\n      res-=tmp;\n      return res;\n    };\n  \n  using P = pair<Int, Int>;\n  Int flg;\n  function<void(Int,const set<P>&)> dfs=\n    [&](Int d,const set<P> &sp){\n      if(d==(Int)ps.size()) return;\n      \n      Int cnt=0;\n      vector<Int> &v=ps[d];\n      {\n\tauto latte=v.begin();\n\tfor(auto &p:sp){\n\t  cnt+=lower_bound(latte,v.end(),p.first)-latte;\n\t  latte=lower_bound(latte,v.end(),p.second);\n\t}\n\tcnt+=v.end()-latte-1;\n      }\n      \n      flg|=(cnt<=1);\n      if(flg) return;\n      \n      if(0){\n\tcout<<d<<\":\"<<cnt<<\"::\"<<(Int)ps.size()<<endl;\n\tfor(auto p:sp) cout<<p.first<<\" \"<<p.second<<endl;\n\tcout<<endl;\n      }\n      \n      if(d+cnt>(Int)ps.size()) return;\n      \n      Int ncnt=0;\n      {\n\tInt k=0;\n\tfor(auto &p:sp){\n\t  while(v[k]<p.first){\n\t    ncnt+=calc(d,k);\n\t    k++;\n\t  }\n\t  k=lower_bound(v.begin(),v.end(),p.second)-v.begin();\n\t}\n\twhile(k+1<(Int)v.size()){\n\t  ncnt+=calc(d,k);\n\t  k++;\n\t}\n      }\n      //cout<<d<<\":\"<<cnt<<\":\"<<ncnt<<endl;\n\n      set<P> nsp=sp;\n      {\n\tInt k=0;\n\tfor(auto &p:sp){\n\t  while(v[k]<p.first){\n\t    if(d+ncnt-calc(d,k)<=(Int)ps.size()){\n\t      nsp.emplace(v[k],v[k+1]);\n\t      dfs(d+1,nsp);\n\t      nsp.erase(P(v[k],v[k+1]));\n\t      if(flg) return;\n\t    }\n\t    k++;\n\t  }\n\t  k=lower_bound(v.begin(),v.end(),p.second)-v.begin();\n\t}\n\twhile(k+1<(Int)v.size()){\n\t  if(d+ncnt-calc(d,k)<=(Int)ps.size()){\n\t    nsp.emplace(v[k],v[k+1]);\n\t    dfs(d+1,nsp);\n\t    nsp.erase(P(v[k],v[k+1]));\n\t    if(flg) return;\n\t  }\n\t  k++;\n\t}\n      }\n      \n    };\n  \n  for(Int i=0;i<n;){\n    Int l=i,r=*upper_bound(ps[0].begin(),ps[0].end(),l);\n    set<P> sp;\n    sp.emplace(l,r);\n    flg=0;\n    dfs(1,sp);\n    string ans=(flg?\"Possible\":\"Impossible\");\n    Int p=i;\n    while(i<n&&dp[p]==dp[i]){\n      cout<<ans<<endl;\n      i++;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<complex>\n#include<numeric>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt n;\nInt nxt[20][220000];\n\nvector<Int> calc(vector<Int> &a, Int v){\n    Int jump = 0;\n    for(;;){\n        Int last = 0;\n        for(Int j = 0;j < n;j++){\n            if(j == n-1 || abs(a[j+1] - a[j]) > v){\n                for(Int k = last;k <= j;k++)\n                    nxt[jump][k] = j+1;\n                last = j+1;\n            }\n        }\n        jump++;\n        if(v == 0)break;\n        v/=2;\n    }\n    vector<Int> dp(1 << jump, 0);\n    for(Int i = 0;i < (1 << jump);i++){\n        for(Int j = 0;j < jump;j++){\n            if((1 << j) & i)continue;\n            dp[(1 << j) | i] = max(dp[(1 << j) | i], nxt[j][dp[i]]);\n        }\n    }\n    return dp;\n}\n\nInt ok[1 << 20];\n\nint main(){\n    Int v;\n    cin >> n >> v;\n   \n    vector<Int> a(n);\n    for(auto &x:a)cin >> x;\n    reverse(a.begin(), a.end());\n    auto rev_dp = calc(a, v);\n    reverse(a.begin(), a.end());\n    auto dp = calc(a, v);\n\n    Int not_zero = dp.size() - 2;\n    for(Int l = 0;l <= not_zero;l += 2){\n        Int r = not_zero - l;\n        if(nxt[0][dp[l]] + rev_dp[r] >= n){\n            ok[dp[l]]++;\n            ok[nxt[0][dp[l]]]--;\n        }\n    }\n    for(Int i = 1;i < n;i++)ok[i] += ok[i-1];\n    for(Int i = 0;i < n;i++){\n        if(ok[i])cout << \"Possible\" << endl;\n        else cout << \"Impossible\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\ninline int rnd(int x){\n\treturn rand()%x;\n}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=19,N=200005,inf=1e9+3e5;\nint n,v,gao,f[1<<M],g[1<<M],x[N],lst[M][N],nxt[M][N],tong[N];\nint main(){\n\tn=read(); v=read(); x[0]=-inf; x[n+1]=inf;\n\tfor(int i=1;i<=n;i++)x[i]=read();\n\tfor(int i=0;;i++){\n\t\tint dali=v>>i; gao=i; nxt[i][n+1]=n; lst[i][0]=1;\n\t\tfor(int j=1;j<=n;j++)if(x[j]-x[j-1]<=dali)lst[i][j]=lst[i][j-1]; else lst[i][j]=j;\n\t\tfor(int j=n;j;j--)if(x[j+1]-x[j]<=dali)nxt[i][j]=nxt[i][j+1]; else nxt[i][j]=j;\n\t\tif((v>>i)==0)break;\n\t}\n\tf[0]=0; g[0]=n+1; \n\tfor(int i=1;i<(1<<gao);i++){\n\t\tf[i]=0; g[i]=n+1;\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)f[i]=max(f[i],nxt[j+1][f[i^(1<<j)]+1]);\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)g[i]=min(g[i],lst[j+1][g[i^(1<<j)]-1]);\n\t}\n\tfor(int i=0;i<=n+1;i++)tong[i]=-1;\n\tfor(int i=0;i<(1<<gao);i++){\n\t\tint l=f[i],r=g[((1<<gao)-1)^i];\n\t\ttong[r]=max(tong[r],l);\n\t}\n\tfor(int i=1;i<=n;i++)tong[i]=max(tong[i],tong[i-1]);\n\tfor(int i=1;i<=n;i++){\n\t\tint l=lst[0][i],r=nxt[0][i];\n\t\tputs(tong[r+1]>=l-1?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\n#define DEBUGNO\n\nsigned main() {\n\tINIT;\n\t\n\tstd::ifstream ifs(\"test.in\");\n\n#ifndef DEBUG\n\tVAR(int, n, V);\n#else\n\tint n, V;\n\tifs >> n >> V;\n#endif\n\n\tif(false){\n\t\tstd::random_device rnd;\n\t\tstd::mt19937 mt(rnd());\n\t\tstd::uniform_int_distribution<> rand(/* min */-1000000000, /* max */1000000000);\n\t\tstd::set<int> set;\n\t\twhile (set.size() < n) set.insert(rand(mt));\n\t\tOUT(n)SP OUT(V)BR;\n\t\tfor (auto x : set) {\n\t\t\tOUT(x)SP;\n\t\t}BR;\n\n\t\treturn 0;\n\t}\n\t\n#ifndef DEBUG\n\tVEC(int, x, n);\n#else\n\tstd::vector<int> x(n);\n\tREP(i, n) ifs >> x[i];\n#endif\n\n\n\tint height = 0;\n\twhile (V >= (1 << height)) ++height;\n\theight += 2;\n\tstd::vector<std::vector<int>> right(height);\n\tint vv = V;\n\tright[0].emplace_back(x[n - 1]);\n\tFOR(h, 1, height) {\n\t\tint r = n - 1;\n\t\tRREP(i, n - 1) {\n\t\t\tif (x[i + 1] - x[i] > vv || i == 0) {\n\t\t\t\tright[h].emplace_back(x[r]);\n\t\t\t\tr = i;\n\t\t\t}\n\t\t}\n\t\tif (x[1] - x[0] > vv) right[h].emplace_back(x[0]);\n\t\tstd::sort(ALL(right[h]));\n\t\tvv /= 2;\n\t}\n\n\tstd::vector<std::vector<int>> g(1);\n\tstd::map<PAIR, int> id;\n\tg.emplace_back(id[PAIR(0, x[n - 1])]);\n\tint p = 1;\n\tFOR(h, 1, height) {\n\t\tfor (auto v : right[h]) {\n\t\t\tint s = id[PAIR(h, v)] = p++;\n\t\t\tauto it = std::lower_bound(ALL(right[h - 1]), v);\n\t\t\tint par = *it;\n\t\t\tint t = id[PAIR(h - 1, par)];\n\t\t\tg.emplace_back(std::vector<int>{});\n\t\t\tg[s].emplace_back(t);\n\t\t\tg[t].emplace_back(s);\n\t\t}\n\t}\n\n\t/*SHOWVECTOR2(right);\n\n\tREP(i, g.size()) {\n\t\tfor (auto to : g[i]) {\n\t\t\tOUT(i)SP OUT(to)BR;\n\t\t}\n\t}*/\n\n\tstd::vector<int> v0;\n\tfor (auto v : g[0]) v0.emplace_back(v);\n\tstd::function<bool(std::vector<int>&, int, int)> check = [&](std::vector<int>& a, int pos, int rest) {\n\t\t//SHOWVECTOR(a);\n\t\tif (rest == 0) return true;\n\t\tif (a.empty()) return true;\n\t\tstd::vector<int> c;\n\t\tc.reserve(1000);\n\t\tint asz = a.size();\n\t\tREP(i, asz) {\n\t\t\tauto& v = g[a[i]];\n\t\t\tREP(j, v.size()) {\n\t\t\t\tif (a[i] > v[j]) continue;\n\t\t\t\tc.emplace_back(v[j]);\n\t\t\t}\n\t\t}\n\t\tint csz = c.size();\n\t\t//std::sort(ALL(c));\n\t\tfor(auto v : a) {\n\t\t\tif (pos != -1) v = pos;\n\t\t\tif (csz - g[v].size() + 1 > rest - 1) continue;\n\t\t\tauto ts(c);\n\t\t\tfor (auto& to : g[v]) {\n\t\t\t\tif (v > to) continue;\n\t\t\t\tts.erase(std::find(ALL(ts), to));\n\t\t\t}\n\t\t\tif (check(ts, -1, rest - 1)) return true;\n\t\t\tif (pos != -1) break;\n\t\t}\n\t\treturn false;\n\t};\n\n\tstd::vector<PAIR> ok;\n\tp = 0;\n\tfor (auto& v : v0) {\n\t\tbool t = check(v0, v, height - 1);\n\t\tok.emplace_back(PAIR(right[1][p++], t));\n\t}\n\t//SHOWPAIRVECTOR(ok);\n\n\tp = 0;\n\tREP(i, n) {\n\t\tif (x[i] <= ok[p].first) {\n#ifndef DEBUG\n\t\t\tOUT(((ok[p].second) ? \"Possible\" : \"Impossible\"))BR;\n#endif\n\t\t}\n\t\tif (x[i] == ok[p].first) ++p;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 2e5+5;\nint n, k, V, i, a[Nmax], lg[Nmax], dp1[Nmax], go1[22][Nmax], dp2[Nmax], go2[22][Nmax], nr[Nmax];\n\nvoid compute()\n{\n    int l, i, j, ind;\n    for(l=0; l<k; ++l)\n    {\n        go1[l][n+1] = n;\n        go2[l][0] = 1;\n\n        for(i=1; i<=n; ++i)\n        {\n            for(j = i; j+1<=n && a[j+1] - a[j] <= lg[l]; ++j);\n            for(ind = i; ind <= j; ++ind)\n                go1[l][ind] = j;\n\n            i = j;\n        }\n\n        for(i=n; i; --i)\n        {\n            for(j = i; j-1>=1 && a[j] - a[j-1] <= lg[l]; --j);\n            for(ind = i; ind >= j; --ind)\n                go2[l][ind] = j;\n\n            i = j;\n        }\n    }\n}\n\nvoid dinamique()\n{\n    int i, j;\n    dp1[0] = 0, dp2[0] = n+1;\n    for(i=1; i<(1<<k); ++i)\n    {\n        dp1[i] = 1;\n        dp2[i] = n;\n\n        for(j=0; j<k; ++j)\n            if(i&(1<<j))\n            {\n                dp1[i] = max(dp1[i], go1[j][ dp1[i^(1<<j)] + 1 ]);\n                dp2[i] = min(dp2[i], go2[j][ dp2[i^(1<<j)] - 1 ]);\n            }\n    }\n}\n\nvoid solve()\n{\n    int i, j, ind, mask = (1<<k) - 1;\n    bool ok;\n\n    for(i=0; i<=n+1; ++i) nr[i] = -1;\n\n    for(i=0; i<=mask; ++i)\n        nr[dp2[i]] = max(nr[dp2[i]], dp1[mask^i]);\n\n    for(i=1; i<=n+1; ++i)\n        nr[i] = max(nr[i], nr[i-1]);\n\n    for(i=1; i<=n; ++i)\n    {\n        for(j = i; j+1<=n && a[j+1] - a[j] <= V; ++j);\n        ok = (nr[j+1] >= i-1);\n\n        for(ind = i; ind <= j; ++ind)\n            printf(\"%s\\n\", ok ? \"Possible\" : \"Impossible\");\n\n        i = j;\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &V);\n    for(i=1; i<=n; ++i) scanf(\"%d\", &a[i]);\n\n    lg[0] = V/2;\n    for(i=1; lg[i-1]; ++i) lg[i] = lg[i-1] / 2;\n    k = i;\n\n    compute();\n    dinamique();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<unordered_map>\n//#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define chmax(a,b) a=max(a,b);\n#define N (1<<18)\n#define M 19\nll n,v;\nclass Alpha{\n public:\n ll f[N];\n P g[N][M];\n void setg(ll a[]){\n     for(int k=0;k<M;k++){\n         for(int i=0;i<n;i++)g[i][k]=make_pair(i,i);\n         ll bef=1e18,pnt=0; a[n]=1e18;\n         for(int i=0;i<=n;i++){\n          if(abs(a[i]-bef)>(v>>k)){\n           for(int j=pnt;j<i;j++)g[j][k]=make_pair(pnt,i-1);\n           pnt=i;   \n          }\n          bef=a[i];\n         }\n         if((v>>k)==0)break;\n     }\n }\n void main(ll a[]){\n  setg(a);   \n  for(int i=0;i<N;i++)f[i]=-1;\n  for(int i=0;i<N;i++){\n      for(int j=0;j<M-1;j++){\n          if(i&(1<<j))continue;\n          chmax(f[i+(1<<j)],g[f[i]+1][j+1].second);\n      }\n  }\n }\n};Alpha L,R;\n\nclass Solve{\n  public:\n  unordered_map<ll,bool> mas;\n  bool main(ll l,ll r){\n      if(mas.size()>M)return 0;\n      if(mas.find(l)!=mas.end()){\n       return mas[l];   \n      }\n      bool res=0;\n      int who=1; for(int x=v;x;x>>=1)who*=2;\n      for(int i=0;i<who;i++){\n       int ls=i,rs=who-1-i;\n       if(l-1<=L.f[ls]&&n-1-R.f[rs]<=r+1)res=1;\n      }\n      mas[l]=res;\n      return res;\n  }\n};Solve sv;\n\nll a[N];\nint main(){\n    cin>>n>>v;\n    for(int i=0;i<n;i++)cin>>a[i];\n    L.main(a);\n    for(int i=0;i<n/2;i++)swap(a[i],a[n-i-1]);\n    R.main(a);\n    for(int i=0;i<n;i++){\n     bool ans=sv.main(L.g[i][0].first,L.g[i][0].second);   \n     cout<<(ans?\"Possible\":\"Impossible\")<<endl;\n    }\n return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define K 20\nint n,m,v,a[N],l[N][K],r[N][K],f[N],g[N],h[N];\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();v=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n\twhile (true){\n\t\tl[1][m]=1;r[n][m]=n;\n\t\tl[0][m]=1;r[n+1][m]=n;\n\t\tfor (int i=2;i<=n;i++)\n\t\t\tl[i][m]=(a[i]-a[i-1]<=v)?l[i-1][m]:i;\n\t\tfor (int i=n-1;i>=1;i--)\n\t\t\tr[i][m]=(a[i+1]-a[i]<=v)?r[i+1][m]:i;\n\t\tm++;if (!v) break;v/=2;\n\t}\n\tfill(g,g+(1<<m),n+1);\n\tfor (int i=2;i<(1<<m);i+=2){\n\t\tfor (int j=1;j<m;j++)\n\t\t\tif (i&(1<<j))\n\t\t\tf[i]=max(f[i],r[f[i-(1<<j)]+1][j]),\n\t\t\tg[i]=min(g[i],l[g[i-(1<<j)]-1][j]);\n\tfill(h,h+n+1,0x3fffffff);\n\tfor (int i=0;i<(1<<m);i+=2)\n\t\th[f[i]]=min(h[f[i]],g[(1<<m)-2-i]);\n\tfor (int i=n-1;i>=0;i--)\n\t\th[i]=min(h[i],h[i+1]);\n\tfor (int i=1;i<=n;i++)\n\t\tprintf((h[l[i][0]-1]<=r[i][0]+1)?\"Possible\\n\":\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=600005;\n\nint a[N],L[25][N],R[25][N],f[N],g[N],S[N];\n\nint main()\n{\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tios::sync_with_stdio(false);\n\tint n,m,k,cnt=0;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tcin>>a[i];\n\t\tif(i!=1&&a[i]-a[i-1]>m) ++cnt;\n\t}\n\tk=log2(m)+2;\n//\tcout<<k<<endl;\n\tif(cnt>k)\n\t{\n\t\tfor(int i=1;i<=n;i++) cout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tint s=m;\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tL[i][1]=1;\n\t\tR[i][n]=n;\n\t\tfor(int j=2;j<=n;j++)\n\t\t{\n\t\t\tif(a[j]-a[j-1]>s) L[i][j]=j;\n\t\t\telse L[i][j]=L[i][j-1];\n\t\t}\n\t\tfor(int j=n-1;j>=1;j--)\n\t\t{\n\t\t\tif(a[j+1]-a[j]>s) R[i][j]=j;\n\t\t\telse R[i][j]=R[i][j+1];\n\t\t}\n\t\ts/=2;\n\t}\n\t/*for(int i=0;i<k;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++) cout<<L[i][j]<<\" \";\n\t\tcout<<endl;\n\t\tfor(int j=1;j<=n;j++) cout<<R[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\tcout<<endl;*/\n\tfor(int i=0;i<(1<<k);i++)\n\t{\n\t\tf[i]=0;\n\t\tg[i]=n+1;\n\t}\n\tfor(int i=0;i<(1<<(k-1));i++)\n\t{\n\t\tfor(int j=1;j<k;j++)\n\t\t{\n\t\t\tif(!(i&(1<<(j-1))))\n\t\t\t{\n\t\t\t\tif(f[i]==n) f[i|(1<<(j-1))]=n;\n\t\t\t\telse f[i|(1<<(j-1))]=max(f[i|(1<<(j-1))],R[j][f[i]+1]);\n\t\t\t\tif(g[i]==1) g[i|(1<<(j-1))]=1;\n\t\t\t\telse g[i|(1<<(j-1))]=min(g[i|(1<<(j-1))],L[j][g[i]-1]);\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=0;i<(1<<(k-1));i++) cout<<f[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<(1<<(k-1));i++) cout<<g[i]<<\" \";\n\tcout<<endl;*/\n\tfor(int i=0;i<=n;i++) S[i]=0x7f7f7f7f;\n\tfor(int i=0;i<(1<<(k-1));i++) \n\t{\n\t//\tcout<<i<<\" \"<<(1<<(k-1))<<\" \"<<((1<<(k-1))^i)<<endl;\n\t\tS[f[i]]=min(S[f[i]],g[((1<<(k-1))-1)^i]);\n\t}\n//\tfor(int i=0;i<=n;i++) cout<<S[i]<<\" \";\n//\tcout<<endl;\n\tfor(int i=n-1;i>=0;i--) S[i]=min(S[i],S[i+1]);\n//\tfor(int i=0;i<=n;i++) cout<<S[i]<<\" \";\n//\tcout<<endl;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(S[L[0][i]-1]<=R[0][i]+1) cout<<\"Possible\"<<endl;\n\t\telse cout<<\"Impossible\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint x[252521];\nint ne[252521][20],rne[252521][20];\nint dp[(1<<20)+10],rdp[(1<<20)+10];\nvector<int> v;\nint main()\n{\n\tint n,V;\n\tcin>>n>>V;\n\trep(i,n) cin>>x[i];\n\twhile(V>0){\n\t\tv.pb(V);V/=2;\n\t}\n\tv.pb(0);int m=v.size();\n\trep(i,n) rep(j,m){\n\t\trne[i][j]=i;\n\t\tif(i>0 && x[i]-x[i-1]<=v[j]) rne[i][j]=rne[i-1][j];\n\t}\n\tfor(int i=n-1;i>=0;i--) rep(j,m){\n\t\tne[i][j]=i;\n\t\tif(i<n-1 && x[i+1]-x[i]<=v[j]) ne[i][j]=ne[i+1][j];\n\t}\n\tmemset(dp,0,sizeof(dp));\n\trep(i,(1<<20)+5) rdp[i]=n-1;\n\trep(i,(1<<m)) rep(j,m){\n\t\tif((i&(1<<j))>0) continue;\n\t\tdp[i+(1<<j)]=max(dp[i+(1<<j)],ne[dp[i]][j]+1);\n\t\trdp[i+(1<<j)]=min(rdp[i+(1<<j)],rne[rdp[i]][j]-1);\n\t}\n\t//rep(i,(1<<m)) cout<<i<<' '<<dp[i]<<' '<<rdp[i]<<endl;\n\tif(dp[(1<<m)-1]<n){\n\t\t//assert(dp[(1<<m)-1]<n && rdp[(1<<m)-1]>=0);\n\t\trep(i,n) cout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tint now=0;\n\twhile(now<n){\n\t\tint f=0;\n\t\trep(i,(1<<(m-1))){\n\t\t\tif(dp[(1<<m)-2-(i<<1)]>=now && rdp[(i<<1)]<=ne[now][0]) f=1;\n\t\t}\n\t\tREP(i,now,ne[now][0]+1){\n\t\t\tif(f>0) cout<<\"Possible\"<<endl;\n\t\t\telse cout<<\"Impossible\"<<endl;\n\t\t}\n\t\tnow=ne[now][0]+1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 800005\n#define upd(x,y,z) x=z((x),(y))\nusing namespace std;\nint n,V,a[N],b[N],ly,s[N][20],p[N][20],f[N],g[N],Ans[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&V);\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\twhile(V>=1)\n\t{\n\t\tb[++ly]=V;V=V/2;\n\t}\n\tb[++ly]=0;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tfor (int j=1;j<=ly;j++)\n\t\t{\n\t\t\tif (i==n||a[i+1]-a[i]>b[j]) s[i][j]=i;\n\t\t\telse s[i][j]=s[i+1][j];\n\t\t}\n\t}\n\tf[0]=0;\n\tfor (int i=0;i<(1<<ly);i++)\n\t{\n\t\t//cout<<i<<' '<<f[i]<<endl;\n\t\tfor (int j=1;j<=ly;j++)\n\t\t\tif (!(i&(1<<j-1)))\n\t\t\t\tupd(f[i^(1<<j-1)],s[f[i]+1][j],max);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=ly;j++)\n\t\t{\n\t\t\tif (i==1||a[i]-a[i-1]>b[j]) p[i][j]=i;\n\t\t\telse p[i][j]=p[i-1][j];\n\t\t}\n\t}\n\tfor (int i=1;i<=n+1;i++)\n\t\tAns[i]=n+5;\n\tfor (int i=0;i<(1<<ly);i++)\n\t\tg[i]=n+1;\n\t\n\tfor (int i=0;i<(1<<ly);i++)\n\t{\n\t\t//cout<<i<<' '<<g[i]<<endl;\n\t\tfor (int j=1;j<=ly;j++)\n\t\t\tif (!(i&(1<<j-1)))\n\t\t\t\tupd(g[i^(1<<j-1)],p[g[i]-1][j],min);\n\t}\n\tfor (int i=0;i<(1<<ly);i++)\n\tif ((i&1)==0)\n\t{\n\t\t//cout<<i<<' '<<(((1<<ly)-1)^i^1)<<endl;\n\t\tupd(Ans[f[i]+1],g[((1<<ly)-1)^i^1],min);\n\t}\n\tfor (int i=n-1;i>=1;i--)\n\t\tupd(Ans[i],Ans[i+1],min);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\t//cout<<s[i][1]<<' '<<Ans[i]<<endl;\n\t\tif (i!=1&&s[i][1]==s[i-1][1])Ans[i]=Ans[i-1];\n\t\tputs(s[i][1]<Ans[i]-1?\"Impossible\":\"Possible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=2e5+5,M=(1<<19)+5;\nint x[N],li[19][N],ri[19][N],sl[M],sr[M],mr[N],val[19];\nint n,v,t,lim;\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfp(i,1,n)scanf(\"%d\",&x[i]);\n\tval[0]=v;while(v)val[++t]=(v>>=1);\n\tlim=(1<<t);\n\tfp(j,0,t){\n\t\tli[j][1]=1,ri[j][n]=n;\n\t\tfp(i,2,n)li[j][i]=(x[i]-x[i-1]<=val[j]?li[j][i-1]:i);\n\t\tfd(i,n-1,1)ri[j][i]=(x[i+1]-x[i]<=val[j]?ri[j][i+1]:i);\n\t}\n\tsl[0]=0,sr[0]=n+1;\n\tfp(i,1,lim-1)sl[i]=1,sr[i]=n;\n\tfp(i,0,lim-1)fp(j,1,t)if(i>>(j-1)&1^1){\n\t\tcmax(sl[i|(1<<(j-1))],ri[j][sl[i]+1]);\n\t\tcmin(sr[i|(1<<(j-1))],li[j][sr[i]-1]);\n\t}\n\tfp(i,0,n+1)mr[i]=2333333;\n\tfp(i,0,lim-1)cmin(mr[sl[i]],sr[(lim-1)^i]);\n\tfd(i,n,0)cmin(mr[i],mr[i+1]);\n\tfp(i,1,n)puts(mr[li[0][i]-1]<=ri[0][i]+1?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b; ++ i) \nconst int M = 18, N = 2e5 + 5 ;\nusing namespace std ;\n\nint n, v[M + 5], x[N], L[M + 1][N], R[M + 1][N], dpl[N], dpr[N], bit[N], m ;\n\nint main() {\n\tscanf(\"%d%d\", &n, &v[0]) ;\n\trep(i, 1, n) scanf(\"%d\", &x[i]) ;\n\tfor (m = 1; ; m ++) {\n\t\tv[m] = v[m - 1] / 2 ;\n\t\tif (!v[m]) break ;\n\t}\n\trep(j, 0, m) {\n\t\tL[j][1] = L[j][0] = 1 ;\n\t\trep(i, 2, n) L[j][i] = (x[i] - x[i - 1] <= v[j] ? L[j][i - 1] : i) ;\n\t\tR[j][n] = R[j][n + 1] = n ;\n\t\tfor (int i = n - 1; i; -- i) R[j][i] = (x[i + 1] - x[i] <= v[j] ? R[j][i + 1] : i) ;\n\t}\n\tint st = (1 << m) - 1 ;\n\tdpl[0] = 0, dpr[0] = n + 1 ;\n\trep(i, 1, st) {\n\t\tdpl[i] = 0, dpr[i] = n + 1 ;\n\t\trep(j, 1, m) if ((i >> (j - 1)) & 1) {\n\t\t\tdpl[i] = max(dpl[i], R[j][dpl[i ^ (1 << (j - 1))] + 1]) ;\n\t\t\tdpr[i] = min(dpr[i], L[j][dpr[i ^ (1 << (j - 1))] - 1]) ;\n\t\t}\n\t}\n\trep(i, 0, n + 1) bit[i] = - n ;\n\trep(i, 0, st) bit[dpr[i]] = max(bit[dpr[i]], dpl[st ^ i]) ;\n\trep(i, 1, n + 1) bit[i] = max(bit[i], bit[i - 1]) ;\n\trep(i, 1, n) puts((bit[R[0][i] + 1] >= L[0][i] - 1) ? \"Possible\" : \"Impossible\") ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int L = 20;\nconst int MAX = 2 * 1000 * 100 + 47;\n\nint V[L];\nint sz = 0;\nint N[L][MAX];\nint P[L][MAX];\nint X[MAX];\nint dpL[1 << L];\nint dpR[1 << L];\nint ANS[MAX];\nset<PII> S;\nint M[MAX];\n\nvoid print(int mask)\n{\n\twhile (mask)\n\t{\n\t\tif (mask & 1)\n\t\t{\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << \" \";\n\t\t}\n\n\t\tmask >>= 1;\n\t}\n}\n\n//#define DEBUG\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tint n, v;\n\tcin >> n >> v;\n\tFOR(i, 0, n) cin >> X[i];\n\n\tV[0] = v;\n\tFOR(i, 1, L)\n\t{\n\t\tV[i] = V[i - 1] / 2;\n\t\tif (V[i] == 0)\n\t\t{\n\t\t\tsz = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treverse(V, V + sz);\n\tFOR(k, 0, sz)\n\t{\n\t\tint v = V[k];\n\t\tN[k][n - 1] = n;\n\n\t\tRFOR(i, n - 1, 0)\n\t\t{\n\t\t\tif (abs(X[i + 1] - X[i]) > v)\n\t\t\t{\n\t\t\t\tN[k][i] = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tN[k][i] = N[k][i + 1];\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"N=\" << endl;\n\tFOR(k, 0, sz)\n\t{\n\t\tcout << V[k] << \": \";\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tcout << N[k][i] << \" \";\n\t\t}\n\n\t\tcout << endl;\n\t}\n#endif\n\n\tFOR(k, 0, sz)\n\t{\n\t\tint v = V[k];\n\t\tP[k][0] = -1;\n\t\tFOR(i, 1, n)\n\t\t{\n\t\t\tif (abs(X[i] - X[i - 1]) > v)\n\t\t\t{\n\t\t\t\tP[k][i] = i - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tP[k][i] = P[k][i - 1];\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"P=\" << endl;\n\tFOR(k, 0, sz)\n\t{\n\t\tcout << V[k] << \": \";\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tcout << P[k][i] << \" \";\n\t\t}\n\n\t\tcout << endl;\n\t}\n#endif\n\n\tsz--;\n\n\tdpL[0] = 0;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tint x = dpL[mask];\n\t\tFOR(k, 0, sz)\n\t\t{\n\t\t\tif (mask & (1 << k)) continue;\n\n\t\t\tdpL[mask | (1 << k)] = max(dpL[mask | (1 << k)], N[k][x]);\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"dpL\" << endl;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tprint(mask);\n\t\tcout << \" :\";\n\t\tcout << dpL[mask] << endl;\n\t}\n#endif\n\n\tFOR(i, 0, 1 << sz) dpR[i] = 10 + n;\n\tdpR[0] = n - 1;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tint x = dpR[mask];\n\t\tFOR(k, 0, sz)\n\t\t{\n\t\t\tif (mask & (1 << k)) continue;\n\n\t\t\tdpR[mask | (1 << k)] = min(dpR[mask | (1 << k)], P[k][x]);\n\t\t}\n\t}\n\n\n#ifdef DEBUG\n\tcout << \"dpR\" << endl;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tprint(mask);\n\t\tcout << \" :\";\n\t\tcout << dpR[mask] << endl;\n\t}\n#endif\n\n\tFOR(i, 0, n) M[i] = INF;\n\tint tmp = INF;\n\tFOR(maskL, 0, 1 << sz)\n\t{\n\t\tint maskR = ((1 << sz) - 1) ^ maskL;\n\t\tint l = dpL[maskL] - 1;\n\t\tint r = dpR[maskR] + 1;\n#ifdef DEBUG\n\t\tcout << \"!!\" << l << \" \" << r << endl;\n#endif\n\t\tif (l != -1) M[l] = min(M[l], r);\n\n\t\tif (l == -1) tmp = min(tmp, r);\n\t}\n\n#ifdef DEBUG\n\tcout << \"M=\" << endl;\n\tFOR(i, 0, n)\n\t{\n\t\tcout << M[i] << \" \";\n\t}\n\n\tcout << endl;\n#endif\n\n\tRFOR(i, n - 1, 0) M[i] = min(M[i + 1], M[i]);\n\t\n\tFOR(i, 0, n)\n\t{\n\t\tint l = P[sz][i] + 1;\n\t\tint r = N[sz][i] - 1;\n\t\tif (S.find(MP(l, r)) != S.end()) continue;\n\t\tS.insert(MP(l, r));\n\n\t\tint val = M[max(l - 1, 0)];\n\t\tif (l - 1 == -1)\n\t\t{\n\t\t\tval = min(val, tmp);\n\t\t}\n\n\t\tif (val <= r + 1)\n\t\t{\n\t\t\tFOR(k, l, r + 1) ANS[k] = 1;\n\t\t}\n\t}\n\n\tFOR(i, 0, n)\n\t{\n\t\tif (ANS[i])\n\t\t{\n\t\t\tcout << \"Possible\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcout << \"Impossible\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<cmath>\n#include<functional>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nvoid sort(int &a,int &b)\n{\n\tif(a>b)\n\t\tswap(a,b);\n}\nvoid open(const char *s)\n{\n#ifndef ONLINE_JUDGE\n\tchar str[100];\n\tsprintf(str,\"%s.in\",s);\n\tfreopen(str,\"r\",stdin);\n\tsprintf(str,\"%s.out\",s);\n\tfreopen(str,\"w\",stdout);\n#endif\n}\nint rd()\n{\n\tint s=0,c;\n\twhile((c=getchar())<'0'||c>'9');\n\tdo\n\t{\n\t\ts=s*10+c-'0';\n\t}\n\twhile((c=getchar())>='0'&&c<='9');\n\treturn s;\n}\nint upmin(int &a,int b)\n{\n\tif(b<a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint upmax(int &a,int b)\n{\n\tif(b>a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint v[200010];\nint f[1<<21];\nint g[1<<21];\nint l[30][200010];\nint r[30][200020];\nint a[200010];\nint b[200010];\nint main()\n{\n//\topen(\"agc012e\");\n\tint n;\n\tscanf(\"%d%d\",&n,&v[1]);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tint t=1;\n\twhile(1)\n\t{\n\t\tv[t+1]=v[t]/2;\n\t\tt++;\n\t\tif(!v[t])\n\t\t\tbreak;\n\t}\n\tfor(i=1;i<=t;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j==1||a[j]-a[j-1]>v[i])\n\t\t\t\tl[i][j]=j;\n\t\t\telse\n\t\t\t\tl[i][j]=l[i][j-1];\n\t\tfor(j=n;j>=1;j--)\n\t\t\tif(j==n||a[j+1]-a[j]>v[i])\n\t\t\t\tr[i][j]=j;\n\t\t\telse\n\t\t\t\tr[i][j]=r[i][j+1];\n\t}\n\tmemset(f,0,sizeof f);\n\tint all=1<<t;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(f[i]==n)\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],f[i]);\n\t\t\t\telse\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],r[j][f[i]+1]);\n\t\t\t}\n\tfor(i=0;i<all;i++)\n\t\tg[i]=n+1;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(g[i]==1)\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],g[i]);\n\t\t\t\telse\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],l[j][g[i]-1]);\n\t\t\t}\n\tif(f[all-2]>=n)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t\tprintf(\"Possible\\n\");\n\t\treturn 0;\n\t}\n\tfor(i=0;i<all;i++)\n\t\tif(!(i&1)&&(r[1][f[i]+1]>=n||g[(all-1)^i^1]<=r[1][f[i]+1]+1))\n\t\t\tb[l[1][f[i]+1]]=1;\n\tint last=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(b[i])\n\t\t\tlast=i;\n\t\tif(l[1][i]<=last||(i<=r[1][1]&&r[1][1]>=g[all-2]-1))\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=1e6+5;\nint n,m;\nint V,x[maxn],R[maxn][25],L[maxn][25];\nint S1[maxn],S2[maxn];\nint minL[maxn];\nint main(){\n\tread(n);read(V);\n\trep(i,1,n)read(x[i]);\n\twhile((1<<m)<=V)m++;m++;\n\trep2(i,0,m){\n\t\tR[n+1][i]=n;\n\t\tper(j,n,1)\n\t\t\tif(x[j+1]-x[j]<=(V>>i))R[j][i]=R[j+1][i];\n\t\t\telse R[j][i]=j;\n\t\tL[0][i]=1;\n\t\trep(j,1,n)\n\t\t\tif(x[j]-x[j-1]<=(V>>i))L[j][i]=L[j-1][i];\n\t\t\telse L[j][i]=j;\n\t}\n\trep2(i,0,1<<m)S2[i]=n+1;\n\trep2(i,0,1<<m)rep2(j,0,m)if(!(i&(1<<j))){\n\t\tS1[i|(1<<j)]=max(S1[i|(1<<j)],R[S1[i]+1][j]);\n\t\tS2[i|(1<<j)]=min(S2[i|(1<<j)],L[S2[i]-1][j]);\n\t}\n\trep(i,0,n)minL[i]=n+2;\n\trep2(i,0,1<<m)if(!(i&1))minL[S1[i]]=min(minL[S1[i]],S2[((1<<m)-1)^i^1]);\n\tper(i,n-1,0)minL[i]=min(minL[i],minL[i+1]);\n\trep(i,1,n){\n\t\tif(minL[L[i][0]-1]<=R[i][0]+1)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][30],tmp[30][30];\n\nstruct hh\n{\n\tinline size_t operator()(ull x)const\n\t{\n\t\treturn x&19260817;\n\t}\n};\n\nstd::unordered_map<ull,bool,hh>hs;\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\tull hash=dep;\n\tfo0(i,cnt)hash=hash*2337+s[i];\n\tif(hs.count(hash))return hs[hash];\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>=dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\tr[i]=t[i];\n\t}\n\treturn hs[hash]=0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <fstream>\n\ntypedef long long LL;\ntypedef unsigned long long uLL;\n\n#define SZ(x) ((int)x.size())\n#define ALL(x) (x).begin(), (x).end()\n#define MP(x, y) std::make_pair(x, y)\n#define DE(x) cerr << x << endl;\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define GO cerr << \"GO\" << endl;\n#define rep(i, a, b) for (register int (i) = (a); (i) <= (b); ++(i))\n\nusing namespace std;\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\ninline int read() \n{\n\tregister int x = 0; register int f = 1; register char c;\n\twhile (!isdigit(c = getchar())) if (c == '-') f = -1;\n\twhile (x = (x << 1) + (x << 3) + (c xor 48), isdigit(c = getchar()));\n\treturn x * f;\n}\ntemplate<class T> inline void write(T x) \n{\n\tstatic char stk[30]; static int top = 0;\n\tif (x < 0) { x = -x, putchar('-'); }\n\twhile (stk[++top] = x % 10 xor 48, x /= 10, x);\n\twhile (putchar(stk[top--]), top);\n}\ntemplate<typename T> inline bool chkmin(T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\n\nconst int maxN = (int) 2e5, LOG = 20;\n\nbool ans[maxN + 2];\nint f[1 << LOG], g[1 << LOG], x[maxN + 2], n, V, Floor;\n\nstruct Seg\n{\n\tint l, r;\n\n\tSeg() { }\n\n\tSeg(int l, int r) : l(l), r(r) { }\n\n\tbool operator < (Seg B) const\n\t{ return r < B.r; }\n} ;\nvector<Seg> seg[LOG + 1], rev_seg[LOG + 1];\n\nvoid Input()\n{\n\tn = read(), V = read();\n\tfor (int i = 1; i <= n; ++i) x[i] = read();\n}\n\nvoid Init()\n{\n\tfor (int t = 0; (V * 2) >> t; ++t)\n\t{\n\t\t//debug(\"%d\\n\", V * 2 >> t);\n\t\tFloor = t;\n\t\tint last = 1, d = V >> t;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif (x[i + 1] - x[i] > d)\n\t\t\t{\n\t\t\t\tseg[t].push_back(Seg(last, i));\n\t\t\t\trev_seg[t].push_back(Seg(n - i + 1, n - last + 1));\n\t\t\t\tlast = i + 1;\n\t\t\t}\n\t\t}\n\t\tseg[t].push_back(Seg(last, n));\n\t\t//for (Seg s : seg[t])\n\t\t//\tcout << s.l << ' ' << s.r << endl;\n\t\t//cout << \"_______________\" << endl;\n\t\trev_seg[t].push_back(Seg(1, n - last + 1));\n\n\t\treverse(rev_seg[t].begin(), rev_seg[t].end());\n\t}\n}\n\nvoid Solve()\n{\n\tfor (int S = 0; S < 1 << Floor + 1; S += 2)\n\t{\n\t\tfor (int i = 1; i <= Floor; ++i)\n\t\t\tif (!(S >> i & 1))\n\t\t\t{\n\t\t\t\tint p = upper_bound(seg[i].begin(), seg[i].end(), Seg(0, f[S])) - seg[i].begin();\n\t\t\t\tif (p != (int)seg[i].size()) \n\t\t\t\t\tchkmax(f[S | (1 << i)], seg[i][p].r);\n\t\t\t}\n\t}\n\t//cout << \"F\" << endl;\n\t//cout << f[2] << endl;\n\t//cout << f[4] << endl;\n\t//cout << f[6] << endl;\n\n\tfor (int S = 0; S < 1 << Floor + 1; S += 2)\n\t{\n\t\tfor (int i = 1; i <= Floor; ++i)\n\t\t\tif (!(S >> i & 1))\n\t\t\t{\n\t\t\t\tint p = upper_bound(rev_seg[i].begin(), rev_seg[i].end(), Seg(0, g[S])) - rev_seg[i].begin();\n\t\t\t\tif (p != (int)rev_seg[i].size()) \n\t\t\t\t\tchkmax(g[S | (1 << i)], rev_seg[i][p].r);\n\t\t\t}\n\t}\n\t//cout << \"G\" << endl;\n\t//cout << g[2] << endl;\n\t//cout << g[4] << endl;\n\t//cout << g[6] << endl;\n\n\tfor (auto s : seg[0])\n\t{\n\t\tbool ok = 0;\n\t\tfor (int S = 0; S < 1 << Floor + 1; S += 2)\n\t\t{\n\t\t\tint T = ((1 << Floor + 1) - 1) ^ 1 ^ S;\n\t//\tif (s.l == 3)\n\t//\t{\n\t//\t\tcout << S << ' ' << T << endl;\n\t//\t\tcout << \"F , G \" << f[S] << ' ' << g[T] << endl;\n\t//\t}\n\t\t\tif (f[S] >= s.l - 1 and g[T] >= (n - s.r + 1) - 1)\n\t\t\t{\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok)\n\t\t\tfor (int i = s.l; i <= s.r; ++i)\n\t\t\t\tans[i] = 1;\n\t}\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (ans[i])\n\t\t\tputs(\"Possible\");\n\t\telse \n\t\t\tputs(\"Impossible\");\n}\n\nint main() \n{ \n\n\tInput();\n\n\tInit();\n\n\tSolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define stt static\n#define rg register\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n#define y1 substitute_of_y1\n#define DEBUG(x) cerr<<#x\" = \"<<x<<endl;\nusing namespace std;\n\ntemplate<typename T> il T rd(){\n\tT nmb=0;int sgn=0;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-')sgn=1;chr=getchar();}\n\twhile(isdigit(chr)){nmb=(nmb<<3)+(nmb<<1)+chr-'0';chr=getchar();}\n\treturn sgn?-nmb:nmb;\n}\ntemplate<typename T> void wt(T nmb){\n\tif(nmb>9)wt(nmb/10);\n\tputchar(nmb%10+'0');\n}\ntemplate<typename T> il void cmax(T &x,T y){x=x>y?x:y;}\ntemplate<typename T> il void cmin(T &x,T y){x=x<y?x:y;}\ninline void proc_status(){\n\tifstream t (\"/proc/self/status\");\n\tcerr<<string(istreambuf_iterator<char>(t),istreambuf_iterator<char>())<<endl;\n\t/*freopen(\"/proc/self/status\",\"r\",stdin);\n\tchar ch[100];\n\twhile(scanf(\"%s\",ch)!=EOF)cerr<<ch<<endl;*/\n}\n\nconst int N=2e5+10,L=20;\n\nint a[N];\n\nvector<pii>vec[L];\n\n#define lowbit(x) (x&(-x))\n\nint f[N<<1],g[N<<1];\n\nint ans[N],b[N];\n\nint main(){\n\tint n=rd<int>(),p=rd<int>();\n\tfor(int i=1;i<=n;++i)a[i]=rd<int>();\n\tint lev=1;\n\tint Flg=0;\n\tfor(int k=p;!Flg;k>>=1,++lev){\n\t\tif(!k)Flg=1;\n\t\tfor(int l=1,r=1;l<=n;l=r+1){\n\t\t\tr=l;\n\t\t\twhile(r<n&&a[r+1]-a[r]<=k)++r;\n\t\t\tvec[lev].pb(mp(l,r));\n\t\t}\n\t}\n\tlev-=2;\n\tint k=(1<<lev)-1;\n\tfor(int S=0;S<=k;++S)f[S]=0,g[S]=n+1;\n\tfor(int S=0;S<=k;++S){\n\t\tfor(int T=S;T;T^=lowbit(T)){\n\t\t\tint t=(int)log2(lowbit(T))+2;\n\t\t\tint U=S^lowbit(T);\n\t\t\tint pos=upper_bound(vec[t].begin(),vec[t].end(),mp(f[U]+1,n+1))-vec[t].begin()-1;\n\t\t\tif(pos>=0)cmax(f[S],vec[t][pos].snd);\n\t\t\tpos=upper_bound(vec[t].begin(),vec[t].end(),mp(g[U]-1,n+1))-vec[t].begin()-1;\n\t\t\tif(pos>=0&&vec[t][pos].snd>=g[U]-1)cmin(g[S],vec[t][pos].fst);\n\t\t}\n\t}\n\tfor(int S=0;S<=k;++S){\n\t\tint l=f[S],r=g[k^S];\n\t\tint pos1=upper_bound(vec[1].begin(),vec[1].end(),mp(l+1,n+1))-vec[1].begin()-1;\n\t\tint pos2=upper_bound(vec[1].begin(),vec[1].end(),mp(r-1,n+1))-vec[1].begin()-1;\n\t\tif(vec[1][pos2].snd<r-1)++pos2;\n\t\tif(pos1>=0&&pos2>=0&&pos1==pos2)b[pos1]=1;\n\t}\n\tfor(int i=0;i<(int)vec[1].size();++i)\n\t\tfor(int t=vec[1][i].fst;t<=vec[1][i].snd;++t)\n\t\t\tans[t]=b[i];\n\tfor(int i=1;i<=n;++i)\n\t\tif(ans[i])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 400010\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint n,v,p[N],lgl[N][20],lgr[N][20];\nint Fl[N],Fr[N],sc,XD[N];\nint main()\n{\n\tn=read(); v=read(); \n\tfor(int i=1;i<=n;i++)\n\t\tp[i]=read();\n\tfor(int t=v,_=0;t;t>>=1,_++)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint j=i;\n\t\t\twhile(p[j+1]-p[j]<=t&&j+1<=n) j++;\n\t\t\tfor(int x=i;x<=j;x++)\n\t\t\t\tlgl[x][_]=j,lgr[x][_]=i;\n\t\t\ti=j;\n\t\t} sc=max(sc,_);\n\t} sc++;\n\tfor(int i=1;i<=n;i++) lgl[i][sc]=lgr[i][sc]=i;\n\tmemset(XD,0x3f,sizeof XD);\n\tmemset(Fr,0x3f,sizeof Fr); Fr[0]=n+1;\n\tfor(int i=0;i<(1<<sc);i++) \n\t{\n\t\tfor(int k=1;k<=sc;k++) if(!(i&(1<<(k-1))))\n\t\t{\n\t\t\tFl[i|(1<<(k-1))]=max(Fl[i|(1<<(k-1))],lgl[Fl[i]+1][k]);\n\t\t\tFr[i|(1<<(k-1))]=min(Fr[i|(1<<(k-1))],lgr[Fr[i]-1][k]);\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<sc);i++) XD[Fl[i]]=min(XD[Fl[i]],Fr[((1<<sc)-1)^i]);\n\tfor(int i=n;i>=1;i--) XD[i]=min(XD[i],XD[i+1]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(lgl[i][0]==n&&lgr[i][0]==1) puts(\"Possible\");\n\t\telse \n\t\t{\n\t\t\tif(XD[lgr[i][0]-1]<=lgl[i][0]+1) puts(\"Possible\");\n\t\t\telse puts(\"Impossible\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pb2 pop_back\n#define pf push_front\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define rep(k,i,j) for(int k = (int)i;k<(int) j;k++)\n#define repd(k,i,j) for(int k = i;k>=(int)j;k--)\n#define ll long long\n#define pq priority_queue\n\nint dirx[8] = {0,1,0,-1,1,1,-1,-1};\nint diry[8] = {1,0,-1,0,1,-1,1,-1};\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e16;\nconst double EPS = 1e-6;\n\nusing namespace std;\n\nconst int maxn = 5e5+5;\n\nint n,v;\nint loc[maxn];\n\nint jump[maxn][20],m;\n\nint dp[maxn];\n\nint ch[maxn];\n\nint in_q[maxn];\n\nqueue<int> q;\nint solve(){\n\twhile(q.size())q.pop();\n\tmemset(dp,-1,sizeof dp);\n\tmemset(in_q,0,sizeof in_q);\n\t\n\tq.push(1);\n\tdp[1] = ch[0];\n\tin_q[1] = 1;\n\t\n\t\n\twhile(q.size()){\n\t\tint mask = q.front();\n\t\tint a = dp[mask];\n\t\t\n\t\tq.pop();\n\t\tin_q[mask] = 0;\n\t\t\n\t\tif(a==n)return 1;\n\t\trep(k,0,m)if(((1<<k)&mask)==0){\n\t\t\tint b = ch[jump[a][k]];\n\t\t\tint maskb = (mask|(1<<k));\n\t\t\t\n\t\t\tif(dp[maskb]<b){\n\t\t\t\tdp[maskb] = b;\n\t\t\t\tif(!in_q[maskb])q.push(maskb),in_q[maskb] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\t\n\trep(k,0,n)scanf(\"%d\",&loc[k]);\n\t\n\t\n\tfor(;v>=0;v/=2){\n\t\trep(k,0,n){\n\t\t\tint i = k;\n\t\t\twhile(i<n){\n\t\t\t\tif(i<n-1 && loc[i+1]-loc[i]<=v){\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\twhile(k<=i)jump[k++][m] = i+1;\n\t\t\tk = i;\n\t\t}\n\t\t//printf(\"%d \\n\",v);\n\t\tm++;\n\t\tif(v==0)break;\n\t}\n\t\n\tif(m>=20)return 0;\n\t\n\trep(k,0,maxn)ch[k] = k;\n\t\n\tint hit = 0;\n\trep(k,0,n){\n\t\tif(hit>18){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint nxt = jump[k][0];\n\t\t\n\t\thit++;\n\t\tch[k] = nxt;\n\t\tint ret = solve();\n\t\tch[k] = k;\n\t\t\n\t\twhile(k<nxt)printf(\"%s\\n\",ret?\"Possible\":\"Impossible\"),k++;\n\t\tk = nxt-1;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL \t\t\t\t\tlong long\n#define ULL \t\t\t\tunsigned long long\n#define pii \t\t\t\tpair<int,int>\n#define fi \t\t\t\t\tfirst\n#define se \t\t\t\t\tsecond\n#define mp \t\t\t\t\tmake_pair\n#define vi \t\t\t\t\tvector<int>\n#define psb \t\t\t\tpush_back\n#define ppb \t\t\t\tpop_back\n#define all(x)\t\t\t \t(x).begin(),(x).end()\n#define sz \t\t\t\t\tsize()\n#define endln \t\t\t\tprintf(\"\\n\")\n#define gc\t\t\t\t\tgetchar_unlocked\n#define setmin(x)\t\t\tmemset((x), -1, sizeof((x)))\n#define setnul(x)\t\t\tmemset((x), 0, sizeof((x)))\n#ifndef getchar_unlocked\n#define getchar_unlocked \tgetchar\n#endif\n\nvoid gi( int &ret ) {\n\tret = 0; char inp=gc(); int kl=1;\n\twhile (inp<'0' || inp>'9') {if (inp=='-') kl=-1; inp=gc();}\n\twhile ('0'<=inp && inp<='9') ret=(ret<<3)+(ret<<1)+(int)(inp-'0'), inp=gc();\n\tif (kl<1) ret=-ret;\n}\n\nconst int MAXN = 2e5 + 5;\nconst int MAXLOGN = 20;\nconst int MAXBIT = (1<<20);\n\nint n, v, x[MAXN], nx[MAXLOGN][MAXN], dst[MAXBIT], skip, aft, no = 0;\n\nbool bfs () {\n\tqueue < int > q;\n\tq.push(1);\n\tmemset(dst,-1,sizeof(dst));\n\tdst[1] = 1;\n\twhile (!q.empty()) {\n\t\tint bit = q.front(), now = dst[bit]; q.pop();\n\t\tif (now==skip) now = aft;\n\t\tif (now>n) return 1;\n\t\tfor (int i=0; i<=no; i++) \n\t\t\tif (!(bit&(1<<i))) {\n\t\t\t\tint nexbit = bit | (1<<i);\n\t\t\t\tif (dst[nexbit]<0) q.push(nexbit);\n\t\t\t\tdst[nexbit] = max(dst[nexbit], nx[i][now]);\n\t\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tgi(n); gi(v);\n\tfor (int i=1; i<=n; i++) gi(x[i]);\n\tvi sg;\n\twhile (v) {\n\t\tint aw = 1, lst = 1;\n\t\twhile (lst<=n) {\n\t\t\tif (!no) sg.psb(lst);\n\t\t\twhile (aw<n && (x[aw+1]-x[aw])<=v) aw++;\n\t\t\taw++;\n\t\t\twhile (lst<aw) nx[no][lst++] = aw;\n\t\t}\n\t\tno++;\n\t\tv >>= 1;\n\t}\n\tfor (int i=1; i<=n; i++) nx[no][i] = i+1;\n\tif (sg.sz > MAXLOGN) {\n\t\tfor (int i=1; i<=n; i++) printf (\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tfor (auto aw : sg) {\n\t\tskip = aw; aft = nx[0][aw];\n\t\tif (bfs()) {\n\t\t\twhile (aw++ < aft) printf (\"Possible\\n\"); \n\t\t} else {\n\t\t\twhile (aw++ < aft) printf (\"Impossible\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, V;\n\nconst int maxn = 200010;\n\nint x[maxn];\n\nint cnt = 0;\nint dep;\n\nvector<int> g[maxn * 20];\n\nvector<int> divide(int l,int r,int v) {\n\tvector<int> ret;\n\tif(r - l == 1 || v == 0) return ret;\n\tfor(int i = l, j; i < r; i = j) {\n\t\tret.push_back(++cnt); \n\t\tfor(j = i + 1; j < r && x[j] - x[j-1] <= v; ++j);\n\t\tg[*ret.rbegin()] = divide(i, j, v / 2);\n\t}\n\treturn ret;\n}\n\nbool ans[maxn];\n\nbool solve(const vector<int> &vec,int dep) {\n\t//cout << \"solve: \" ;\n\t//for(auto x: vec) cout << x << ' '; cout << endl;\n\t//cout << \"dep = \" << dep << endl;\n\tvector<int> nxt;\n\tfor(auto x: vec) \n\t\tif(g[x].empty()) nxt.push_back(x);\n\t\telse nxt.insert(nxt.end(), g[x].begin(), g[x].end());\n\t//cout << \"next: \" ;\n\t//for(auto x: nxt) cout << x << ' ';\n\t//cout << endl;\n\t//cout << endl;\n\n\tif(nxt.size() > dep) return false;\n\tif(nxt.size() == 1) return true;\n\tint last = *(nxt.end() - 1), sz = nxt.size();\n\tnxt.erase(nxt.end() - 1);\n\tfor(int i = sz - 1; i >= 0; --i) {\n\t\tif(solve(nxt, dep - 1)) return true;\n\t\tif(i) swap(nxt[i-1], last);\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &V);\n\tfor(int i = 0; i < N; ++i) scanf(\"%d\", &x[i]);\n\tg[0] = divide(0, N, V);\n\tfor(int x = V; x; x = x >> 1) ++dep;\n\tif(g[0].size() > dep + 1) {\n\t\tfor(int i = 0; i < N; ++i) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tif(g[0].size() == 1) {\n\t\tfor(int i = 0; i < N; ++i) puts(\"Possible\");\n\t\treturn 0;\n\t}\n//\tfor(int i = 0; i <= cnt; ++i) {\n//\t\tcout << \"[\" << i << \"]: \";\n//\t\tfor(auto x: g[i]) cout << x << ' ';\n//\t\tcout << endl;\n//\t}\n\tfor(int i = 0; i < g[0].size(); ++i) {\n\t\tvector<int> cur = g[0];\n\t\tcur.erase(cur.begin() + i);\n\t\tans[i] = solve(cur, dep);\n\t}\n\tint curb = 0;\n\tfor(int i = 0; i < N; ++i) {\n\t\tif(i && x[i] - x[i-1] > V) ++curb;\n\t\tputs(ans[curb] ? \"Possible\" : \"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,b,e) for(int i=(b); i <= (e); ++i)\n#define FORD(i,b,e) for(int i=(b); i >= (e); --i)\n#define REP(i,n) for(int i=0; i < (n); ++i)\n#define SIZE(c) (int) (c).size()\n#define ALL(c) (c).begin(), (c).end()\n#define PB push_back\n#define MP make_pair\n#define ST first\n#define ND second\n#define FWD(i,a,b) for (int i=(a); i<(b); ++i)\n#define BCK(i,a,b) for (int i=(a); i>(b); --i)\n#define PI 3.14159265358979311600\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\ntypedef vector < int > VI;\ntypedef vector<ll> VL;\n\ntypedef long double K;\n\n#define int long long\n\nconst int N = 200005;\nconst int M = 1<<22;\nconst int inf = 1000*1000*1000 + 7;\n\nint n, v, cnt, bound;\nint a[N], f[M], g[M];\nint goLeft[N][23], goRight[N][23];\nvector<int> b;\n\nstruct SegTree {\n\tint n;\n\tvector<int> tree;\n\n\tSegTree(int n): n(n), tree(4*n, inf) {}\n\n\tvoid update(int pos, int val) {\n\t\tupdate(1, 0, n - 1, pos, val);\n\t}\n\n\tint go(int l, int r) {\n\t\treturn go(1, 0, n - 1, l, r);\n\t}\n\n\tvoid update(int v, int tl, int tr, int pos, int val) {\n\t\tif (tl == tr) {\n\t\t\ttree[v] = min(tree[v], val);\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) / 2;\n\t\tif (pos <= tm) {\n\t\t\tupdate(2*v, tl, tm, pos, val); \n\t\t} else {\t\n\t\t\tupdate(2*v+1, tm+1, tr, pos, val);\n\t\t}\n\t\ttree[v] = min(tree[2*v], tree[2*v+1]);\n\t}\n\n\tint go(int v, int tl, int tr, int l, int r) {\n\t\tif (l > tr || r < tl) return inf;\n\t\tif (l <= tl && r >= tr) return tree[v];\n\t\tint tm = (tl + tr) / 2;\n\t\treturn min(go(2*v, tl, tm, l, r), go(2*v+1, tm+1, tr, l, r));\n\t}\n};\n\nvoid calc() {\n\tREP(i, cnt) {\n\t\tREP(j, n) {\n\t\t\tgoLeft[i][j] = j;\n\t\t\tif (j > 0 && a[j] - a[j - 1] <= b[i]) {\n\t\t\t\tgoLeft[i][j] = goLeft[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tgoRight[i][j] = j;\n\t\t\tif (j < n - 1 && a[j + 1] - a[j] <= b[i]) {\n\t\t\t\tgoRight[i][j] = goRight[i][j + 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint go(int pos, int x, int side) {\n\tif (side < 0) {\n\t\treturn pos >= 0 ? goLeft[x][pos] : pos;\n\t} \n\treturn pos < n ? goRight[x][pos] : pos;\n}\n\nmain() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\tREP(i, n) {\n\t\tcin >> a[i];\n\t}\n\n\twhile (v > 0) {\n\t\tb.push_back(v);\n\t\tv /= 2;\n\t}\n\tb.push_back(0);\n\tcnt = (int)b.size();\n\tbound = (1 << cnt);\n\n\tcalc();\n\n\tREP(i, bound) f[i] = 0, g[i] = n - 1;\n\tf[0] = 0;\n\tg[0] = n - 1;\n\n\tREP(i, bound) {\n\t\tREP(j, cnt) if (~i & (1 << j)) {\n\t\t\tif (f[i] != -inf) {\n\t\t\t\tf[i ^ (1 << j)] = max(f[i ^ (1 << j)], min(go(f[i], j, +1) + 1, n - 1));\n\t\t\t}\n\t\t\tif (g[i] != inf) {\n\t\t\t\tg[i ^ (1 << j)] = min(g[i ^ (1 << j)], max(go(g[i], j, -1) - 1, 0LL));\n\t\t\t}\n\t\t}\n\t}\n\n\tint all = 0;\n\n\tSegTree tree(n);\n\n\tREP(mask, bound) {\n\t\tint comp = (bound - 1) ^ mask;\n\t\tint a = (mask & 1) ? (mask ^ 1) : mask;\n\t\tint b = (comp & 1) ? (comp ^ 1) : comp;\n\t\tif (f[a] != -inf && g[b] != inf) {\n\t\t\tif (f[a] > g[b]) {\n\t\t\t\tall = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttree.update(f[a], g[b]);\n\t\t}\n\t}\n\n\tREP(i, n) {\n\t\tif (all) {\n\t\t\tcout << \"Possible\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tint lb = go(i, 0, -1);\n\t\tint rb = go(i, 0, +1);\n\t\tif (tree.go(lb, rb) <= rb) {\n\t\t\tcout << \"Possible\\n\";\n\t\t} else {\n\t\t\tcout << \"Impossible\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 202020\n#define lgN 19\nvoid build(){\n\n}\nint p[ lgN ][ N ] , l[ lgN ][ N ] , r[ lgN ][ N ];\nint f( int k , int x ){\n  return p[ k ][ x ] == x ? x :\n         p[ k ][ x ] = f( k , p[ k ][ x ] );\n}\nvoid uni( int k , int x , int y ){\n  x = f( k , x );\n  y = f( k , y );\n  l[ k ][ y ] = min( l[ k ][ y ] , l[ k ][ x ] );\n  r[ k ][ y ] = max( r[ k ][ y ] , r[ k ][ x ] );\n  p[ k ][ x ] = y;\n}\nint n , v[ lgN ] , x[ N ] , vv;\nvoid init(){\n  n = getint();\n  v[ 0 ] = getint();\n  for( int i = 1 ; i <= n ; i ++ )\n    x[ i ] = getint();\n  vv = 1;\n  for( int i = 1 ; i < lgN ; i ++ ){\n    v[ i ] = v[ i - 1 ] / 2;\n    vv ++;\n    if( v[ i ] == 0 ) break;\n  }\n  for( int i = 0 ; i < vv ; i ++ ){\n    for( int j = 1 ; j <= n ; j ++ )\n      p[ i ][ j ] = l[ i ][ j ] = r[ i ][ j ] = j;\n    for( int j = 2 ; j <= n ; j ++ )\n      if( x[ j ] - x[ j - 1 ] <= v[ i ] )\n        uni( i , j - 1 , j );\n    for( int j = 1 ; j <= n ; j ++ )\n      f( i , j );\n  }\n}\nvector< pair<int,int> > inter;\nint cc , rat[ N ] , lat[ N ];\nbool okl[ lgN ][ 1 << lgN ];\nbool okr[ lgN ][ 1 << lgN ];\nbool ans[ N ];\nvoid solve(){\n  {\n    int lft = 1;\n    while( lft <= n ){\n      int rgt = r[ 0 ][ p[ 0 ][ lft ] ];\n      inter.push_back( { lft , rgt } );\n      lat[ lft ] = rat[ rgt ] = ++ cc;\n      lft = rgt + 1;\n    }\n  }\n  if( cc > vv ){\n    for( int i = 1 ; i <= n ; i ++ )\n      puts( \"Impossible\" );\n    Bye;\n  }\n  if( cc == 1 ){\n    for( int i = 1 ; i <= n ; i ++ )\n      puts( \"Possible\" );\n    Bye;\n  }\n  {\n    queue< pair<int,int> > Q;\n    set< pair<int,int> > inq;\n    Q.push( { 0 , 0 } );\n    while( Q.size() ){\n      auto tp = Q.front(); Q.pop();\n      int rgt = tp.first , msk = tp.second;\n      if( rgt == n ) continue;\n      for( int i = 1 ; i < vv ; i ++ ){\n        if( ( msk >> ( i - 1 ) ) & 1 ) continue;\n        int nxt = r[ i ][ p[ i ][ rgt + 1 ] ];\n        int nmsk = msk | ( 1 << ( i - 1 ) );\n        if( rat[ nxt ] ) okl[ rat[ nxt ] - 1 ][ nmsk ] = true;\n        if( inq.count( { nxt , nmsk } ) ) continue;\n        inq.insert( { nxt , nmsk } );\n        Q.push( { nxt , nmsk } );\n      }\n    }\n  }\n  {\n    queue< pair<int,int> > Q;\n    set< pair<int,int> > inq;\n    Q.push( { n + 1 , 0 } );\n    while( Q.size() ){\n      auto tp = Q.front(); Q.pop();\n      int lft = tp.first , msk = tp.second;\n      if( lft == 1 ) continue;\n      for( int i = 1 ; i < vv ; i ++ ){\n        if( ( msk >> ( i - 1 ) ) & 1 ) continue;\n        int nxt = l[ i ][ p[ i ][ lft - 1 ] ];\n        int nmsk = msk | ( 1 << ( i - 1 ) );\n        if( lat[ nxt ] ) okr[ lat[ nxt ] - 1 ][ nmsk ] = true;\n        if( inq.count( { nxt , nmsk } ) ) continue;\n        inq.insert( { nxt , nmsk } );\n        Q.push( { nxt , nmsk } );\n      }\n    }\n  }\n  for( int i = 0 ; i < cc ; i ++ )\n    for( int j = 0 ; j + 1 < vv ; j ++ )\n      for( int msk = 0 ; msk < ( 1 << ( vv - 1 ) ) ; msk ++ )\n        if( ( msk >> j ) & 1 ){\n          okl[ i ][ msk ] |= okl[ i ][ msk ^ ( 1 << j ) ];\n          okr[ i ][ msk ] |= okr[ i ][ msk ^ ( 1 << j ) ];\n        }\n  for( int i = 0 ; i < cc ; i ++ ){\n    bool good = false;\n    if( i == 0 )\n      good = okr[ i + 1 ][ ( 1 << ( vv - 1 ) ) - 1 ];\n    else if( i + 1 == cc )\n      good = okl[ i - 1 ][ ( 1 << ( vv - 1 ) ) - 1 ];\n    else{\n      for( int msk = 0 ; msk < ( 1 << ( vv - 1 ) ) ; msk ++ )\n        if( okl[ i - 1 ][ msk ] and\n            okr[ i + 1 ][ ( 1 << ( vv - 1 ) ) - 1 - msk ] ){\n          good = true;\n          break;\n        }\n    }\n    if( not good ) continue;\n    for( int j = inter[ i ].first ; j <= inter[ i ].second ; j ++ )\n      ans[ j ] = true;\n  }\n  for( int i = 1 ; i <= n ; i ++ )\n    puts( ans[ i ] ? \"Possible\" : \"Impossible\" );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// tzl ak IOI! \n \n#include<bits/stdc++.h>\n \n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n#define FILL(a, b) memset((a), (b), sizeof((a)))\n#define MCPY(a, b) memcpy((a), (b), sizeof((b)))\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n \nconst int iinf = 1e9 + 7;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n \ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f = 0; x = 0; char c = getchar();\n\twhile((c < '0' || c > '9') && c != '-') c = getchar();\n\tif(c == '-') { f = 1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\n\tif(f) x = -x; return;\n}\n \ntemplate <typename T1, typename T2>\nvoid scf(T1 &x, T2 &y) { scf(x); return scf(y); }\n \ntemplate <typename T1, typename T2, typename T3>\nvoid scf(T1 &x, T2 &y, T3 &z) { scf(x); scf(y); return scf(z); }\n \ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid scf(T1 &x, T2 &y, T3 &z, T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n \ninline char mygetchar(){ char c = getchar(); while(c == ' ' || c == '\\n') c = getchar(); return c; }\n \ntemplate <typename T>\nvoid chkmax(T &x, const T &y){ if(y > x) x = y; return; }\n \ntemplate <typename T>\nvoid chkmin(T &x, const T &y){ if(y < x) x = y; return; }\n \n#ifdef ONLINE_JUDGE\n#define debug(x,c) ;\n#else\n#define DEBUG\n#define debug(x,c) cerr<<#x<<\"=\"<<x<<c;\n#endif\n \nvoid TZL();\n \nvoid RANK1();\n \n#define tzl int\n#define ak main\n#define IOI ()\ntzl ak IOI\n{\n#undef tzl\n#undef ak\n#undef IOI\n \n\tTZL();\n\tRANK1();\n \n#define tzl return\n#define caisi 0\n#define myy ;\n\ttzl caisi myy\n#undef tzl\n#undef caisi\n#undef myy\n}\n \n//---------------------------head----------------------------\n \nconst int N = 2e5 + 100;\nconst int lgN = 20;\n \nint n, V, m;\nint x[N];\nint lb[lgN][N], rb[lgN][N];\nvii seg[lgN];\nint dpl[1048576], dpr[1048576];\n \nvoid get_seg()\n{\n\tfor(int i = 1, j; i <= n; i = j)\n\t{\n\t\tj = i + 1;\n\t\twhile(j <= n && x[j] - x[j - 1] <= V) ++j;\n\t\tseg[m].pb({i, j - 1});\n\t}\n\tfor(auto x: seg[m])\n\t{\n\t\tint l = x.X, r = x.Y;\n\t\tforn(i, l, r) lb[m][i] = l, rb[m][i] = r;\n\t}\n\t++m;\n\treturn;\n}\n \nvoid TZL()\n{\n\tscf(n, V);\n\tforn(i, 1, n) scf(x[i]);\n\twhile(V)\n\t{\n\t\tget_seg();\n\t\tV >>= 1;\n\t}\n\tforn(i, 1, n) lb[m][i] = i, rb[m][i] = i;\n\t++m;\n\treturn;\n}\n \nvoid DPL()\n{\n\tforn(msk, 1, (1 << m) - 1)\n\t{\n\t\trep(i, m) if((msk >> i) & 1)\n\t\t{\n\t\t\tchkmax(dpl[msk], dpl[msk ^ (1 << i)]);\n\t\t\tchkmax(dpl[msk], rb[i][dpl[msk ^ (1 << i)] + 1]);\n\t\t}\n\t}\n\treturn;\n}\n \nvoid DPR()\n{\n\tdpr[0] = n + 1;\n\tforn(msk, 1, (1 << m) - 1)\n\t{\n\t\tdpr[msk] = n + 1;\n\t\trep(i, m) if((msk >> i) & 1)\n\t\t{\n\t\t\tchkmin(dpr[msk], dpr[msk ^ (1 << i)]);\n\t\t\tchkmin(dpr[msk], lb[i][dpr[msk ^ (1 << i)] - 1]);\n\t\t}\n\t}\n\treturn;\n}\n \nvii all;\nbool ans[N];\nint TOT;\n \nvoid check(int l, int r)\n{\n\tfor(int msk = 0; msk < (1 << m); msk += 2)\n\t{\n\t\tint lb = dpl[msk], rb = dpr[TOT ^ msk];\n\t\tif(l <= lb + 1 && r >= rb - 1)\n\t\t{\n\t\t\tforn(i, l, r) ans[i] = 1;\n\t\t\treturn;\n\t\t}\n\t}\n\treturn;\n}\n \nvoid RANK1()\n{\n\tif(SZ(seg[0]) <= m)\n\t{\n\t\tDPL(); DPR();\n\t\tTOT = (1 << m) - 2;\n\t\tfor(auto x: seg[0]) check(x.X, x.Y);\n\t}\n\tforn(i, 1, n) puts(ans[i] ? \"Possible\" : \"Impossible\");\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 12345678\nusing namespace std;\ninline int read()\n{int x=0,f=0;\nchar c=getchar();\nwhile (c<'0'||c>'9') \n{if (c=='-') f=1;\nc=getchar();\n}\nwhile (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\nif (f) x=-x;\nreturn x;\n}\ninline int max(int a,int b)\n{return a>b?a:b;}\ninline int min(int a,int b)\n{return a<b?a:b;}\nint l[21][200005],r[21][200005];\nint a[200005],n,v,p[21],cnt=0;\nint fl[262145],fr[262145],tot[21];\ninline int calc(int pos)\n{int lp=l[cnt+1][pos]-1,rp=r[cnt+1][pos]+1;\nfor (int i=0;i<(1<<cnt);i++)\n{if (fl[i]>=lp&&fr[(1<<cnt)-1-i]<=rp) return 1;\n}\nreturn 0;\n}\nint main (){\n\tfreopen (\"ernd.in\",\"r\",stdin);\n\tfreopen (\"ernd.out\",\"w\",stdout);\n\tint i,j;\n\tn=read();v=read();\n\tfor (i=1;i<=n;i++)\n\t{a[i]=read();}\n\twhile (v) {p[++cnt]=v;v>>=1;}\n\tp[++cnt]=0;\n\treverse(p+1,p+cnt+1);\n\tfor (j=1;j<=cnt;j++)\n\t{int pos=1;\n\twhile (pos<=n)\n\t{int sta=pos;\n\twhile (pos<=n&&a[pos+1]-a[pos]<=p[j]) pos++;\n\tfor (i=sta;i<=pos;i++) \n\t{l[j][i]=sta;r[j][i]=pos;}\n\tpos++;tot[j]++;\n\t}\n\tl[j][n+1]=n+1;r[j][n+1]=n+1;\n\tl[j][0]=0;r[j][0]=0;\n\t}\n\tif (tot[cnt]>cnt)\n\t{for (i=1;i<=n;i++)\n\t{puts(\"Impossible\");}\n\treturn 0;\n\t}\n\tcnt--;\n\tfor (i=0;i<(1<<cnt);i++)\n\t{fl[i]=0;fr[i]=n+1;\n\tfor (j=1;j<=cnt;j++)\n\t{if (!((1<<(j-1))&i)) continue;\n\tfl[i]=max(fl[i],r[j][fl[(i^(1<<(j-1)))]+1]);\n\tfr[i]=min(fr[i],l[j][fr[(i^(1<<(j-1)))]-1]);\n\t}\n\t}\n\tint las;\n\tfor (i=1;i<=n;i++)\n\t{if (l[cnt+1][i]==i) las=calc(i);\n\tputs(las?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n#define pb push_back\n\n#define error(x) cout << #x << \" = \" << x << endl\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nconst int N = 5e5 + 20;\nint n, a[N], b[N], mx[N];\nstring s;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n\tcin >> s;\n\n\tn = _sz(s);\n\n\tfor (int i = 0; i < n; i++) a[i] = s[i] - '0';\n\n/*\n\tbool fin = 0;\n\n\twhile (!fin)\n\t{\n\t\tfin = 1;\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tif (a[i] <= a[i + 1]) continue;\n\t\t\tfin = 0;\n\t\t\n\t\t\tint y = (a[i] - a[i + 1] + 10) / 11;\n\n\t\t\ta[i] -= y;\n\t\t\ta[i + 1] += 10 * y;\n\t\t}\n\t}\n\n\tcout << '\\t' << a[n - 1] << ' ' << a[n - 2] << '\\n';\n\n\tcout << (a[n - 1] + 8) / 9 << '\\n';;\n*/\n\n\tint low = 0, high = N;\n\n\twhile (high - low > 1)\n\t{\n\t\tfor (int i = 0; i < n; i++) b[i] = a[i];\n\n\t\tint mid = (low + high) / 2;\n\n\t\tbool ok = 1;\n\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (i == n - 1) mx[i] = 9 * mid;\n\t\t\telse mx[i] = mx[i + 1];\n\n\t\t\tint k = (mx[i] % 10 + 10) % 10;\n\t\t\tk = mx[i] - k;\n\t\t\tk += (a[i] % 10 + 10) % 10;\n\n\t\t\tif (k > mx[i]) k -= 10;\n\n\t\t\tmx[i] = k;\n\n\t\t\tassert((mx[i] - a[i]) % 10 == 0);\n\n\t\t\tif (mx[i] < a[i])\n\t\t\t{\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ta[i - 1] -= (mx[i] - a[i]) / 10;\n\t\t\ta[i] = mx[i];\n\t\t}\n\n\t\tif (ok) high = mid;\n\t\telse low = mid;\n\n\t\tfor (int i = 0; i < n; i++) a[i] = b[i];\n\t}\n\n\tcout << high << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong long x[210000];\nint sa[210000];\nint nx_L[19][210000];\nint nx_R[19][210000];\n\nint d[20];\nint L[1<<19];\nint R[1<<19];\npair<int,int>p[1<<19];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lld\",x+i);\n\t}\n\td[0]=b;\n\tint n=1;\n\tfor(int i=0;d[i];i++){\n\t\td[i+1]=d[i]/2;\n\t\tn=i+2;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tint to=a;\n\t\tfor(int j=a-1;j>=0;j--){\n\t\t\tnx_L[i][j]=to;\n\t\t\tif(j&&x[j]-x[j-1]>d[i])to=j;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tint to=a;\n\t\tfor(int j=a-1;j>=0;j--){\n\t\t\tnx_R[i][j]=to;\n\t\t\tif(j&&x[a-j]-x[a-1-j]>d[i])to=j;\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<n);i++){\n\t\tint at=L[i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i&(1<<j))continue;\n\t\t\tint to=nx_L[j][at];\n\t\t\tL[i+(1<<j)]=max(L[i+(1<<j)],to);\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<n);i++){\n\t\tint at=R[i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i&(1<<j))continue;\n\t\t\tint to=nx_R[j][at];\n\t\t\tR[i+(1<<j)]=max(R[i+(1<<j)],to);\n\t\t}\n\t}\n\tint sz=0;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tif(i&1);\n\t\telse{\n\t\t\tp[sz++]=make_pair(L[i],i);\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tprintf(\"%d: \",d[i]);\n\t\tfor(int j=0;j<a;j++)printf(\"%d \",nx_L[i][j]);\n\t\t\tprintf(\"\\n\");\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%d: \",d[i]);\n\t\tfor(int j=0;j<a;j++)printf(\"%d \",nx_R[i][j]);\n\t\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tstd::sort(p,p+sz);\n\tset<pair<int,int> >S;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tif(i&1);\n\t\telse{\n\t\t\tS.insert(make_pair(R[i],i));\n\t\t}\n\t}\n\tint at=0;\n\tfor(int i=0;i<a;i++){\n\t\tint lq=a-nx_R[0][a-1-i];\n\t\tint rq=a-nx_L[0][i];\n\t\twhile(at<sz&&p[at].first<lq){\n\t\t\tS.erase(make_pair(R[p[at].second],p[at].second));\n\t\t\tat++;\n\t\t}\n\t\t//printf(\"%d %d\\n\",lq,rq);\n\t\tif(S.size()){\n\t\t\tpair<int,int> tp=*(S.rbegin());\n\t\t\tif(tp.first>=rq)printf(\"Possible\\n\");\n\t\t\telse printf(\"Impossible\\n\");\n\t\t}else{\n\t\t\tif(at<sz&&rq==0)printf(\"Possible\\n\");\n\t\t\telse printf(\"Impossible\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nvector<int> f(int N, int M, vector<int> dx) {\n\tvector<vector<int> > nxt(N + 1, vector<int>(M));\n\trep(j, M) nxt[N][j] = nxt[N - 1][j] = N;\n\tfor (int i = N - 2; i >= 0; i--) {\n\t\tnxt[i] = nxt[i + 1];\n\t\tfor (int j = dx[i]; j < M; j++) nxt[i][j] = i + 1;\n\t}\n\tvector<int> dp(1<<M);\n\trep(S, 1<<M)\n\t\trep(j, M) if (!(S>>j & 1)) {\n\t\t\tint _S = S | 1<<j;\n\t\t\tdp[_S] = max(dp[_S], nxt[dp[S]][j]);\n\t\t}\n\treturn dp;\n}\n\nvector<int> solve() {\n\tint N, V; cin >> N >> V;\n\tvector<int> x(N);\n\trep(i, N) scanf(\"%d\", &x[i]);\n\tvector<int> dx(N - 1);\n\trep(i, N - 1) dx[i] = x[i + 1] - x[i];\n\tbool ok = true;\n\trep(i, N - 1) if (dx[i] > V) ok = false;\n\tif (ok) return vector<int>(N, true);\n\tvector<int> v;\n\tfor (int _V = V; _V; _V /= 2) v.pb(_V);\n\tv.pb(0);\n\tint M = v.size();\n\trep(i, N - 1) {\n\t\tint k;\n\t\tfor (k = 0; dx[i] <= v[k]; k++);\n\t\tdx[i] = k;\n\t}\n\tunion_find uf(N);\n\trep(i, N - 1) if (dx[i]) uf.unite(i, i + 1);\n\tvector<int> dp1 = f(N, M, dx);\n\treverse(dx.begin(), dx.end());\n\tvector<int> dp2 = f(N, M, dx);\n\tvector<bool> ok(N);\n\trep(S, 1<<(M - 1)) {\n\t\tint S1 = S<<1, S2 = (((1<<(M - 1)) - 1) - S)<<1;\n\t\tint i = min(dp1[S1], N - 1), j = max(0, N - 1 - dp2[S2]);\n\t\tif (uf.same(i, j)) ok[uf.find(i)] = true;\n\t}\n\tvector<int> ans(N);\n\trep(i, N) ans[i] = ok[uf.find(i)];\n\treturn ans;\n}\n\nint main() {\n\tvector<int> ans = solve();\n\tfor (int z: ans) if (z) printf(\"Possible\\n\"); else printf(\"Impossible\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define x first\n#define y second\n\ntemplate<typename T>inline void check_min(T a,T &b){if(a<b)b=a;}\ntemplate<typename T>inline void check_max(T a,T &b){if(a>b)b=a;}\n\nnamespace yy\n{\n\tconst int N=201000,M=N*20;\n\n\tstruct bit\n\t{\n\t\tbool s[N];\n\t\tinline int lowbit(int x){return x&(-x);}\n\t\tvoid init(){memset(s,0,sizeof(s));}\n\t\tvoid inc(int p){p++;for(;p<N;p+=lowbit(p))s[p]=1;}\n\t\tbool query(int p){p++;bool ret=0;for(;p;p-=lowbit(p))ret|=s[p];return ret;}\n\t}T;\n\n\tstruct node\n\t{\n\t\tint L,R,ty;\n\t\tnode(int a=0,int b=0,int c=0):L(a),R(b),ty(c){}\n\t\tbool operator < (const node &h) const {return L==h.L?R==h.R?ty>h.ty:R<h.R:L>h.L;}\n\t};\n\n\tnode s[M];\n\n\tint begin[N],next[M*2],to[M*2],w[M*2];\n\tint pos[N];\n\tint n,m,e,tot,cnt,S;\n\n\tvoid add(int x,int y,int z,bool k=1)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t\tw[e]=z;\n\t\tif(k)add(y,x,z,0);\n\t}\n\n\tvoid work(int dis,int dep)\n\t{\n//\t\tprintf(\"dep %d : \",dep);\n\t\tfor(int L=1,R;L<=n;L=R+1)\n\t\t{\n\t\t\tfor(R=L;R<n && pos[R+1]-pos[R]<=dis;R++);\n//\t\t\tprintf(\"%2d--%2d \",L,R);\n\t\t\tif(dep>1)add(L,R,dep-1);\n\t\t\telse s[++tot]=node(L,R,1);\n\t\t}\n//\t\tprintf(\"\\n\");\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tscanf(\"%d\",pos+i);\n\t\ttot=0,cnt=1;\n\t\tfor(int tmp=m;;tmp/=2,cnt++)\n\t\t{\n\t\t\twork(tmp,cnt);\n\t\t\tif(!tmp)break;\n//\t\t\tprintf(\"e = %d\\n\",e);\n\t\t}\n//\t\tprintf(\"cnt = %d\\n\",cnt);\n\t\tS=1<<(cnt-1);\n//\t\tprintf(\"S = %d\\n\",S);\n\t}\n\n\tinline int ins(int k,int i){return k|(1<<(i-1));}\n\tint f[N*4],g[N*4];\n\n\tvoid dp()\n\t{\n\t\tfor(int i=0;i<S;i++)\n\t\t\tf[i]=0,g[i]=n+1;\n\t\tfor(int k=0;k<S;k++)\n\t\t{\n\t\t\tint p=f[k]+1;\n\t\t\tfor(int i=begin[p];i;i=next[i])\n\t\t\t\tif(!(k&(1<<(w[i]-1))))\n\t\t\t\t\tcheck_max(to[i],f[ins(k,w[i])]);\n\t\t\tp=g[k]-1;\n\t\t\tfor(int i=begin[p];i;i=next[i])\n\t\t\t\tif(!(k&(1<<(w[i]-1))))\n\t\t\t\t\tcheck_min(to[i],g[ins(k,w[i])]);\n\t\t}\n\t}\n\n\tbool ans[N];\n\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tdp();\n\t\t\n\t\tfor(int k=0;k<S;k++)\n\t\t\ts[++tot]=node(f[k]+1,g[S-k-1]-1,0);\n\t\tstd::sort(s+1,s+tot+1);\n\t\tT.init();\n\n\t\tfor(int i=1;i<=tot;i++)\n\t\t{\n\t\t\tif(!s[i].ty)T.inc(s[i].R);\n\t\t\telse if(T.query(s[i].R))\n\t\t\t{\n\t\t\t\tfor(int j=s[i].L;j<=s[i].R;j++)\n\t\t\t\t\tans[j]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"%s\\n\",ans[i]?\"Possible\":\"Impossible\");\n\t}\n}\n\nint main()\n{\n\tyy::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ctz __builtin_ctz\n\ntypedef std::pair <int, int> pr;\nconst int N = 200054, LN = 20, LN2 = 262154;\n\nint n, V, ALL, cnt = 0;\nint x[N];\nint L[LN][N], R[LN][N];\nint f[LN2], g[LN2];\npr seg[LN2], qry[LN2];\n\ninline void up(int &x, const int y) {x < y ? x = y : 0;}\ninline void down(int &x, const int y) {x > y ? x = y : 0;}\n\nint main() {\n\tint i, j, S, layer;\n\tscanf(\"%d%d\", &n, &V);\n\tfor (i = 0; i < n; ++i) scanf(\"%d\", x + i);\n\tfor (layer = 0; ; V >>= 1, ++layer) {\n\t\tint *l = L[layer], *r = R[layer];\n\t\tfor (*l = 0, i = 1; i < n; ++i) l[i] = (x[i] <= x[i - 1] + V ? l[i - 1] : i);\n\t\tfor (--i, r[i] = i; --i >= 0; ) r[i] = (x[i] >= x[i + 1] - V ? r[i + 1] : i);\n\t\tif (!V) break;\n\t}\n\tALL = ~(-1 << layer);\n\tstd::fill(g, g + (ALL + 1), n - 1);\n\tfor (i = 0; i <= ALL; ++i)\n\t\tfor (S = ALL ^ i; S; S &= S - 1)\n\t\t\tj = ctz(S),\n\t\t\tup(f[i | 1 << j], f[i] == n ? n : R[j + 1][f[i]] + 1),\n\t\t\tdown(g[i | 1 << j], (~g[i] ? L[j + 1][g[i]] : 0) - 1);\n\tfor (i = 0; i <= ALL; ++i) seg[i] = pr(g[i], -f[ALL ^ i]);\n\tstd::sort(seg, seg + (ALL + 1));\n\tqry[cnt++] = pr(seg->first, -seg->second);\n\tfor (i = 1; i <= ALL; ++i)\n\t\tif (seg[i].second < seg[i - 1].second) qry[cnt++] = pr(seg[i].first, -seg[i].second);\n\tfor (i = 0; i < n; ) {\n\t\tj = R[0][i], S = std::lower_bound(qry, qry + cnt, pr(j, INT_MAX)) - qry - 1;\n\t\tif (S >= 0 && i <= qry[S].second)\n\t\t\tfor (; i <= j; ++i) puts(\"Possible\");\n\t\telse\n\t\t\tfor (; i <= j; ++i) puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 100, LOG = 20, M = 1 << LOG;\n\nint n, v, x[N], dp_l[M], dp_r[M], go_l[N][LOG], go_r[N][LOG];\nvector<int> vec;\n\nvoid input() {\n\tcin >> n >> v;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i];\n\tfor (int i = 0; (v >> i); i++)\n\t\tvec.push_back(v >> i);\n\tvec.push_back(0);\n\treverse(vec.begin(), vec.end());\n}\n\nvoid ready() {\n\tfor (int j = 0; j < vec.size(); j++) {\n\t\tgo_r[n - 1][j] = n - 1;\n\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t\tif ((x[i + 1] - x[i]) > vec[j])\n\t\t\t\tgo_r[i][j] = i;\n\t\t\telse\n\t\t\t\tgo_r[i][j] = go_r[i + 1][j];\n\n\t\tgo_l[0][j] = 0;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tif ((x[i] - x[i - 1]) > vec[j])\n\t\t\t\tgo_l[i][j] = i;\n\t\t\telse\n\t\t\t\tgo_l[i][j] = go_l[i - 1][j];\n\t}\n}\n\nvoid calc_dp() {\n\tfor (int mask = 1; mask < (1 << vec.size()); mask++) {\n\t\tdp_l[mask] = 1;\n\t\tfor (int i = 0; i < vec.size(); i++)\n\t\t\tif (mask & (1 << i)) {\n\t\t\t\tint prev = mask ^ (1 << i);\n\t\t\t\tif (dp_l[prev] == n)\n\t\t\t\t\tdp_l[mask] = n;\n\t\t\t\telse\n\t\t\t\t\tdp_l[mask] = max(dp_l[mask], go_r[dp_l[prev]][i] + 1);\n\t\t\t}\n\t}\n\t\n\tfor (int mask = 1; mask < (1 << vec.size()); mask++) {\n\t\tdp_r[mask] = 1;\n\t\tfor (int i = 0; i < vec.size(); i++)\n\t\t\tif (mask & (1 << i)) {\n\t\t\t\tint prev = mask ^ (1 << i);\n\t\t\t\tif (dp_r[prev] == n)\n\t\t\t\t\tdp_r[mask] = n;\n\t\t\t\telse\n\t\t\t\t\tdp_r[mask] = max(dp_r[mask], n - go_l[n - dp_r[prev] - 1][i]);\n\t\t\t}\n\t}\n}\n\nset<int> st;\nvoid solve() {\n\tfor (int i = 0; i < n; i++)\n\t\tst.insert(i);\n\tfor (int mask = 0; mask < (1 << (vec.size() - 1)); mask++) {\n\t\tint a = mask, b = ((1 << (vec.size() - 1)) - 1) ^ a;\n\t\tif ((dp_l[a] + dp_r[b]) >= n) {\n\t\t\tst.clear();\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint l = dp_l[a], r = n - dp_r[b] - 1; // [)\n\t\tif (go_r[l][vec.size() - 1] < r || go_l[r][vec.size() - 1] > l)\n\t\t\tcontinue;\n\t\tl = go_l[l][vec.size() - 1], r = go_r[r][vec.size() - 1];\n\t\t\n\t\twhile (true) {\n\t\t\tauto it = st.lower_bound(l);\n\t\t\tif (it != st.end() && *it <= r)\n\t\t\t\tst.erase(it);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t\tif (st.find(i) != st.end())\n\t\t\tcout << \"Impossible\\n\";\n\t\telse\n\t\t\tcout << \"Possible\\n\";\n}\n\nint main() {\n\tinput();\n\tready();\n\tcalc_dp();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR (i, 0, n)\n#define _ << \" _ \" <<\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define debug\n#define TRACE(x)\n\nusing namespace std;\n\ntypedef long long llint;\n\nconst int MAXN = 200010;\nconst int MAXLG = 20;\n\nint n, maxv, x[MAXN], r[MAXN][MAXLG], l[MAXN][MAXLG];\nint dpL[MAXN], dpR[MAXN], p[MAXN];\n\nint main(void) {\n  scanf(\"%d %d\",&n,&maxv);\n  REP(i, n) scanf(\"%d\",&x[i]);\n\n  int lg = 0;\n  for (int v = maxv; v >= 0; v /= 2, ++lg) {\n    for (int i = n - 1; i >= 0; --i) {\n      r[i][lg] = i;\n      if (i < n - 1 && x[i+1] - x[i] <= v)\n\tr[i][lg] = r[i+1][lg];\n    }\n    for (int i = 0; i < n; ++i) {\n      l[i][lg] = i;\n      if (i > 0 && x[i] - x[i-1] <= v)\n\tl[i][lg] = l[i-1][lg];\n    }\n\n    REP(i, n)\n      TRACE(i _ lg _ l[i][lg] _ r[i][lg]);\n    if (v == 0) break;\n  }\n\n  REP(mask, (1 << (lg + 1)) - 1) {\n    if (mask & 1) continue;\n\n    dpL[mask] = -1;\n    dpR[mask] = n;\n\n    REP(j, lg + 1)\n      if (mask & (1 << j)) {\n\tTRACE(j _ dpL[mask & ~(1 << j)]);\n\tif (dpL[mask & ~(1 << j)] == n - 1)\n\t  dpL[mask] = n - 1;\n\telse\n\t  dpL[mask] = max(dpL[mask], r[dpL[mask & ~(1 << j)] + 1][j]);\n\n\tif (dpR[mask & ~(1 << j)] == 0)\n\t  dpR[mask] = 0;\n\telse\n\t  dpR[mask] = min(dpR[mask], l[dpR[mask & ~(1 << j)] - 1][j]);\n      }\n  }\n\n  REP(mask1, (1 << (lg + 1)) - 1) {\n    if (mask1 & 1) continue;\n    int mask2 = ((1 << (lg + 1)) - 1) ^ mask1;\n    if (mask2 & 1) mask2 ^= 1;\n    \n    TRACE(mask1 _ mask2 _ dpL[mask1] _ dpR[mask2]);\n\n    int lo = dpL[mask1] + 1;\n    int hi = dpR[mask2] - 1;\n    if (lo > hi) {\n      ++p[0];\n      --p[n];\n      continue;\n    }\n    if (r[lo][0] < hi) continue;\n    ++p[lo];\n    --p[r[lo][0] + 1];\n  }\n\n  int curr = 0;\n  REP(i, n) {\n    curr += p[i];\n    if (curr > 0)\n      printf(\"Possible\\n\");\n    else\n      printf(\"Impossible\\n\");\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 2e5 + 5;\nconst int K = 19;\nint n;\nint v[K];\nint k;\nint arr[N];\nint nxt[K][N];\nint prv[K][N];\nint dp1[1 << K];\nint dp2[1 << K];\nint pre(int mask){\n\tif(dp1[mask] != -1){\n\t\treturn dp1[mask];\n\t}\n\tint res = 1;\n\tfor(int i = 1 ; i < k ; ++i){\n\t\tif((mask >> i) & 1){\n\t\t\tint tmp = pre(mask ^ (1 << i));\n\t\t\tres = max(res , nxt[i][tmp + 1] - 1);\n\t\t}\n\t}\n\treturn dp1[mask] = res;\n}\nint suf(int mask){\n\tif(dp2[mask] != -1){\n\t\treturn dp2[mask];\n\t}\n\tint res = n;\n\tfor(int i = 1 ; i < k ; ++i){\n\t\tif((mask >> i) & 1){\n\t\t\tint tmp = suf(mask ^ (1 << i));\n\t\t\tres = min(res , prv[i][tmp - 1] + 1);\n\t\t}\n\t}\n\treturn dp2[mask] = res;\n}\nbool solve(int lft , int rgt){\n\tint mask = (1 << k) - 2;\n\tfor(int i = mask ; i ; i = (i - 1) & mask){\n\t\tif(pre(i) >= lft && suf(mask ^ i) <= rgt){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn pre(0) >= lft && suf(mask) <= rgt;\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tscanf(\"%d\" , &v[0]);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tscanf(\"%d\" , arr + i);\n\t}\n\tk = 1;\n\tfor(int i = 1 ; i < K ; ++i){\n\t\tv[i] = v[i - 1] >> 1;\n\t\tif(v[i]){\n\t\t\tk = i + 1;\n\t\t}\n\t}\n\tv[k++] = 0;\n\tfor(int i = 0 ; i < k ; ++i){\n\t\tnxt[i][n] = n + 1;\n\t\tfor(int j = n - 1 ; j >= 1 ; --j){\n\t\t\tif(arr[j + 1] - arr[j] <= v[i]){\n\t\t\t\tnxt[i][j] = nxt[i][j + 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnxt[i][j] = j + 1;\n\t\t\t}\n\t\t}\n\t\tprv[i][1] = 0;\n\t\tint steps = 1;\n\t\tfor(int j = 2 ; j <= n ; ++j){\n\t\t\tif(arr[j] - arr[j - 1] <= v[i]){\n\t\t\t\tprv[i][j] = prv[i][j - 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++steps;\n\t\t\t\tprv[i][j] = j - 1;\n\t\t\t}\n\t\t}\n\t\tif(!i && steps > k + 5){\n\t\t\tfor(int i = 1 ; i <= n ; ++i){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmemset(dp1 , -1 , sizeof(dp1));\n\tmemset(dp2 , -1 , sizeof(dp1));\n\tfor(int i = 1 ; i <= n ; i = nxt[0][i]){\n\t\tbool ans = solve(prv[0][i] , nxt[0][i]);\n\t\tfor(int j = i ; j < nxt[0][i] ; ++j){\n\t\t\tputs(ans ? \"Possible\" : \"Impossible\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<cmath>\n#include<functional>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nvoid sort(int &a,int &b)\n{\n\tif(a>b)\n\t\tswap(a,b);\n}\nvoid open(const char *s)\n{\n#ifndef ONLINE_JUDGE\n\tchar str[100];\n\tsprintf(str,\"%s.in\",s);\n\tfreopen(str,\"r\",stdin);\n\tsprintf(str,\"%s.out\",s);\n\tfreopen(str,\"w\",stdout);\n#endif\n}\nint rd()\n{\n\tint s=0,c;\n\twhile((c=getchar())<'0'||c>'9');\n\tdo\n\t{\n\t\ts=s*10+c-'0';\n\t}\n\twhile((c=getchar())>='0'&&c<='9');\n\treturn s;\n}\nint upmin(int &a,int b)\n{\n\tif(b<a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint upmax(int &a,int b)\n{\n\tif(b>a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint v[200010];\nint f[1<<20];\nint g[1<<20];\nint l[20][200010];\nint r[20][200020];\nint a[200010];\nint b[200010];\nint main()\n{\n//\topen(\"agc012e\");\n\tint n;\n\tscanf(\"%d%d\",&n,&v[1]);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tint t=1;\n\twhile(1)\n\t{\n\t\tv[t+1]=v[t]/2;\n\t\tt++;\n\t\tif(!v[t])\n\t\t\tbreak;\n\t}\n\tfor(i=1;i<=t;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j==1||a[j]-a[j-1]>v[i])\n\t\t\t\tl[i][j]=j;\n\t\t\telse\n\t\t\t\tl[i][j]=l[i][j-1];\n\t\tfor(j=n;j>=1;j--)\n\t\t\tif(j==n||a[j+1]-a[j]>v[i])\n\t\t\t\tr[i][j]=j;\n\t\t\telse\n\t\t\t\tr[i][j]=r[i][j+1];\n\t}\n\tmemset(f,0,sizeof f);\n\tint all=1<<t;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(f[i]==n)\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],f[i]);\n\t\t\t\telse\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],r[j][f[i]+1]);\n\t\t\t}\n\tfor(i=0;i<all;i++)\n\t\tg[i]=n+1;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(g[i]==1)\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],g[i]);\n\t\t\t\telse\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],l[j][g[i]-1]);\n\t\t\t}\n\tif(f[all-2]>=n)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t\tprintf(\"Possible\\n\");\n\t\treturn 0;\n\t}\n\tfor(i=0;i<all;i++)\n\t\tif(!(i&1)&&(f[i]+r[1][f[i]+1]>=n||g[(all-1)^i^1]<=f[i]+r[1][f[i]+1]))\n\t\t\tb[f[i]+1]=1;\n\tint last=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(b[i])\n\t\t\tlast=i;\n\t\tif(l[1][i]<=last||(i<=r[1][1]&&r[1][1]>g[all-2]))\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> vals;\nint rt[200005][30];\nint lt[200005][30];\nint n,v;\nint pos[200005];\nint memo1[300005];\nint memo2[300005];\nint something[200005];\n\nint dpL(int bitmask){\n    if (memo1[bitmask]!=-1) return memo1[bitmask];\n    if (bitmask==0) return memo1[bitmask] = -1;\n    int ans = 0;\n    for (int x = 0; x<vals.size(); x++){\n        if (bitmask&(1<<x)){\n            ans = max(ans,dpL(bitmask^(1<<x)));\n            ans = max(ans,rt[dpL(bitmask^(1<<x))+1][x]);\n        }\n    }\n    return memo1[bitmask] = ans;\n}\n\nint dpR(int bitmask){\n    if (memo2[bitmask]!=-1) return memo2[bitmask];\n    if (bitmask==0) return memo2[bitmask] = n;\n    int ans = n-1;\n    for (int x = 0; x<vals.size(); x++){\n        if (bitmask&(1<<x)){\n            ans = min(ans,dpR(bitmask^(1<<x)));\n            ans = min(ans,lt[dpR(bitmask^(1<<x))-1][x]);\n        }\n    }\n    return memo2[bitmask] = ans;\n}\n\nint main(){\n    memset(memo1,-1,sizeof(memo1));\n    memset(memo2,-1,sizeof(memo2));\n    scanf(\"%d%d\",&n,&v);\n    for (int x = 0; x<n; x++){\n        scanf(\"%d\",&pos[x]);\n    }\n    int t = v;\n    while (t>0){\n        vals.push_back(t);\n        t/=2;\n    }\n    vals.push_back(0);\n    for (int i = 0; i<vals.size(); i++){\n        rt[n-1][i] = n-1;\n        for (int x = n-2; x>=0; x--){\n            rt[x][i] = pos[x+1]-pos[x]<=vals[i]?rt[x+1][i]:x;\n        }\n        lt[0][i] = 0;\n        for (int x = 1; x<n; x++){\n            lt[x][i] = pos[x]-pos[x-1]<=vals[i]?lt[x-1][i]:x;\n        }\n    }\n    for (int x = 0; x<n; x++){\n        something[x] = n+1;\n    }\n    for (int x = 0; x<(1<<(vals.size())); x+=2){\n        int other = ((1<<(vals.size()))-2)^x;\n        something[dpL(x)] = min(something[dpL(x)],dpR(other));\n    }\n    for (int x = n-2; x>=0; x--){\n        something[x] = min(something[x],something[x+1]);\n    }\n    for (int x = 0; x<n; x++){\n        int L = lt[x][0];\n        int R = rt[x][0];\n        //printf(\"something %d %d\\n\",x,something[x]);\n        //printf(\"L:%d,R:%d\\n\",L,R);\n        printf(something[max(0,L-1)]<=R+1?\"Possible\\n\":\"Impossible\\n\");\n    }\n    //printf(\"%d\\n\",dpL(6));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,b,e) for(int i=(b); i <= (e); ++i)\n#define FORD(i,b,e) for(int i=(b); i >= (e); --i)\n#define REP(i,n) for(int i=0; i < (n); ++i)\n#define SIZE(c) (int) (c).size()\n#define ALL(c) (c).begin(), (c).end()\n#define PB push_back\n#define MP make_pair\n#define ST first\n#define ND second\n#define FWD(i,a,b) for (int i=(a); i<(b); ++i)\n#define BCK(i,a,b) for (int i=(a); i>(b); --i)\n#define PI 3.14159265358979311600\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\ntypedef vector < int > VI;\ntypedef vector<ll> VL;\n\ntypedef long double K;\n\n#define int long long\n\nconst int N = 200005;\nconst int M = 1<<22;\nconst int inf = 1e18;\n\nint n, v, cnt, bound;\nint a[N], f[M], g[M];\nint goLeft[23][N], goRight[23][N];\nvector<int> b;\n\nstruct SegTree {\n\tint n;\n\tvector<int> tree;\n\n\tSegTree(int n): n(n), tree(4*n, inf) {}\n\n\tvoid update(int pos, int val) {\n\t\tupdate(1, 0, n - 1, pos, val);\n\t}\n\n\tint go(int l, int r) {\n\t\treturn go(1, 0, n - 1, l, r);\n\t}\n\n\tvoid update(int v, int tl, int tr, int pos, int val) {\n\t\tif (tl == tr) {\n\t\t\ttree[v] = min(tree[v], val);\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) / 2;\n\t\tif (pos <= tm) {\n\t\t\tupdate(2*v, tl, tm, pos, val); \n\t\t} else {\t\n\t\t\tupdate(2*v+1, tm+1, tr, pos, val);\n\t\t}\n\t\ttree[v] = min(tree[2*v], tree[2*v+1]);\n\t}\n\n\tint go(int v, int tl, int tr, int l, int r) {\n\t\tif (l > tr || r < tl) return inf;\n\t\tif (l <= tl && r >= tr) return tree[v];\n\t\tint tm = (tl + tr) / 2;\n\t\treturn min(go(2*v, tl, tm, l, r), go(2*v+1, tm+1, tr, l, r));\n\t}\n};\n\nvoid calc() {\n\tREP(i, cnt) {\n\t\tREP(j, n) {\n\t\t\tgoLeft[i][j] = j;\n\t\t\tif (j > 0 && a[j] - a[j - 1] <= b[i]) {\n\t\t\t\tgoLeft[i][j] = goLeft[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tgoRight[i][j] = j;\n\t\t\tif (j < n - 1 && a[j + 1] - a[j] <= b[i]) {\n\t\t\t\tgoRight[i][j] = goRight[i][j + 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint go(int pos, int x, int side) {\n\tif (side < 0) {\n\t\treturn goLeft[x][pos];\n\t} \n\treturn goRight[x][pos];\n}\n\nmain() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\tREP(i, n) {\n\t\tcin >> a[i];\n\t}\n\n\tsort(a, a + n);\n\n\twhile (v > 0) {\n\t\tb.push_back(v);\n\t\tv /= 2;\n\t}\n\n\tb.push_back(0);\n\tcnt = (int)b.size();\n\tbound = (1 << cnt);\n\n\tcalc();\n\n\tREP(i, bound) f[i] = 0, g[i] = n - 1;\n\n\tREP(i, bound) {\n\t\tREP(j, cnt) if (~i & (1 << j)) {\n\t\t\tf[i ^ (1 << j)] = max(f[i ^ (1 << j)], min(go(f[i], j, +1) + 1, n - 1));\n\t\t\tg[i ^ (1 << j)] = min(g[i ^ (1 << j)], max(go(g[i], j, -1) - 1, 0LL));\n\t\t}\n\t}\n\n\tint all = 0;\n\n\tSegTree tree(n);\n\n\tREP(mask, bound) {\n\t\tint comp = (bound - 1) ^ mask;\n\t\tint a = (mask & 1) ? (mask ^ 1) : mask;\n\t\tint b = (comp & 1) ? (comp ^ 1) : comp;\n\t\tif (f[a] > g[b]) {\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\t}\n\t\ttree.update(f[a], g[b]);\n\t}\n\n\tREP(i, n) {\n\t\tif (all) {\n\t\t\tcout << \"Possible\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tint lb = go(i, 0, -1);\n\t\tint rb = go(i, 0, +1);\n\t\tif (tree.go(lb, rb) <= rb) {\n\t\t\tcout << \"Possible\\n\";\n\t\t} else {\n\t\t\tcout << \"Impossible\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define N 300010\nusing namespace std;\nint num[N],val[64];\nint l[32][N],r[32][N];\nint f[1<<22],g[1<<22];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&num[i]);\n\tint tot=0,res=m;\n\twhile(res)\n\t{\n\t\tval[tot++]=res>>1;\n\t\tres>>=1;\n\t}\n\tval[tot]=m;\n\tfor(int i=0;i<=tot;i++)\n\t{\n\t\tl[i][1]=1;\n\t\tfor(int j=2;j<=n;j++)\n\t\t{\n\t\t\tif(num[j]-num[j-1]<=val[i]) l[i][j]=l[i][j-1];\n\t\t\telse l[i][j]=j;\n\t\t}\n\t}\n\tint sum=0;\n\tfor(int i=0;i<=tot;i++)\n\t{\n\t\tr[i][n]=n;\n\t\tfor(int j=n-1;j>=1;j--)\n\t\t{\n\t\t\tif(num[j+1]-num[j]<=val[i]) r[i][j]=r[i][j+1];\n\t\t\telse\n\t\t\t{\n\t\t\t\tr[i][j]=j;\n\t\t\t\tif(i==tot) sum++;\n\t\t\t}\n\t\t}\n\t}\n\tif(sum>tot){for(int i=1;i<=n;i++)puts(\"Impossible\");return 0;}\n\tint p=1<<tot;\n    for(int s=0;s<p;s++) g[s]=n+1;\n\tfor(int s=0;s<p;s++)\n        for(int i=0;i<=tot;i++)\n            if(!((s>>i)&1))\n            {\n                f[s|(1<<i)]=max(f[s|(1<<i)],r[i][f[s]+1]);\n                g[s|(1<<i)]=min(g[s|(1<<i)],l[i][g[s]-1]);\n\t\t\t}\n\tfor(int i=1;i<=n;i=r[tot][i]+1)\n    {\n        bool ok=false;\n        for(int s=0;s<p && !ok;s++) if(f[s]>=i-1 && g[(p-1)-s]<=r[tot][i]+1) ok=true;\n        for (int j=i;j<=r[tot][i];j++)\n        {\n            if(ok) puts(\"Possible\");\n            else puts(\"Impossible\");\n        }\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=1e6+5;\nint n,m;\nint v,x[maxn],rj[maxn][25],lj[maxn][25];\nint lx[maxn],rx[maxn];\nint mn[maxn];\nint main(){\n\tread(n);read(v);\n\trep(i,1,n)read(x[i]);\n\twhile((1<<m)<=v)m++;m++;\n\trep2(i,0,m){\n\t\tlj[0][i]=1;\n\t\trep(j,1,n)lj[j][i]=(x[j]-x[j-1]<=(v>>i))?lj[j-1][i]:j;\n\t\trj[n+1][i]=n;\n\t\tper(j,n,1)rj[j][i]=(x[j+1]-x[j]<=(v>>i))?rj[j+1][i]:j;\n\t}\n\trep2(i,0,1<<m)rx[i]=n+1;\n\trep2(i,0,1<<m)rep2(j,0,m)if(!(i&(1<<j))){\n\t\tlx[i|(1<<j)]=max(lx[i|(1<<j)],rj[lx[i]+1][j]);\n\t\trx[i|(1<<j)]=min(rx[i|(1<<j)],lj[rx[i]-1][j]);\n\t}\n\trep(i,0,n)mn[i]=n+2;\n\trep2(i,0,1<<m)if(!(i&1))mn[lx[i]]=min(mn[lx[i]],rx[((1<<m)-1)^i^1]);\n\tper(i,n-1,0)mn[i]=min(mn[i],mn[i+1]);\n\trep(i,1,n){\n\t\tif(mn[lj[i][0]-1]<=rj[i][0]+1)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define x first\n#define y second\n\ntemplate<typename T>inline void check_min(T a,T &b){if(a<b)b=a;}\ntemplate<typename T>inline void check_max(T a,T &b){if(a>b)b=a;}\n\nnamespace yy\n{\n\tconst int N=201000,M=N*20;\n\n\tstruct bit\n\t{\n\t\tbool s[N];\n\t\tinline int lowbit(int x){return x&(-x);}\n\t\tvoid init(){memset(s,0,sizeof(s));}\n\t\tvoid inc(int p){p++;for(;p<N;p+=lowbit(p))s[p]=1;}\n\t\tbool query(int p){p++;bool ret=0;for(;p;p-=lowbit(p))ret|=s[p];return ret;}\n\t}T;\n\n\tstruct node\n\t{\n\t\tint L,R,ty;\n\t\tnode(int a=0,int b=0,int c=0):L(a),R(b),ty(c){}\n\t\tbool operator < (const node &h) const {return L==h.L?R==h.R?ty<h.ty:R<h.R:L>h.L;}\n\t};\n\n\tnode s[M];\n\n\tint begin[N],next[M*2],to[M*2],w[M*2];\n\tint pos[N];\n\tint n,m,e,tot,cnt,S;\n\n\tvoid add(int x,int y,int z,bool k=1)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t\tw[e]=z;\n\t\tif(k)add(y,x,z,0);\n\t}\n\n\tvoid work(int dis,int dep)\n\t{\n\t\tfor(int L=1,R;L<=n;L=R+1)\n\t\t{\n\t\t\tfor(R=L;R<n && pos[R+1]-pos[R]<=dis;R++);\n\t\t\tif(dep>1)add(L,R,dep-1);\n\t\t\telse s[++tot]=node(L,R,1);\n\t\t}\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tscanf(\"%d\",pos+i);\n\t\ttot=0,cnt=1;\n\t\tfor(int tmp=m;;tmp/=2,cnt++)\n\t\t{\n\t\t\twork(tmp,cnt);\n\t\t\tif(!tmp)break;\n\t\t}\n\t\tS=1<<(cnt-1);\n\t}\n\n\tinline int ins(int k,int i){return k|(1<<(i-1));}\n\tint f[N*4],g[N*4];\n\n\tvoid dp()\n\t{\n\t\tfor(int i=0;i<S;i++)\n\t\t\tf[i]=0,g[i]=n+1;\n\t\tfor(int k=0;k<S;k++)\n\t\t{\n\t\t\tint p=f[k]+1;\n\t\t\tfor(int i=begin[p];i;i=next[i])\n\t\t\t\tif(!(k&(1<<(w[i]-1))))\n\t\t\t\t\tcheck_max(to[i],f[ins(k,w[i])]);\n\t\t\tp=g[k]-1;\n\t\t\tfor(int i=begin[p];i;i=next[i])\n\t\t\t\tif(!(k&(1<<(w[i]-1))))\n\t\t\t\t\tcheck_min(to[i],g[ins(k,w[i])]);\n\t\t}\n\t}\n\n\tbool ans[N];\n\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tdp();\n\t\t\n\t\tfor(int k=0;k<S;k++)\n\t\t\ts[++tot]=node(f[k]+1,g[S-k-1]-1,0);\n\t\tstd::sort(s+1,s+tot+1);\n\t\tT.init();\n\n\t\tfor(int i=1;i<=tot;i++)\n\t\t{\n\t\t\tif(!s[i].ty)T.inc(s[i].R);\n\t\t\telse if(T.query(s[i].R))\n\t\t\t{\n\t\t\t\tfor(int j=s[i].L;j<=s[i].R;j++)\n\t\t\t\t\tans[j]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"%s\\n\",ans[i]?\"Possible\":\"Impossible\");\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"E.in\",\"r\",stdin);\n//\tfreopen(\"E.out\",\"w\",stdout);\n\tyy::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp make_pair\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint n,lv;\n\nint c[19][200005];\n\nbool dfs(int mask, int cur, int target){\n  if(cur == target) return true;\n  // dbg(mask,cur,target);\n  rep(i,1,lv) if((mask>>i)%2==0 && c[i][(cur-1+n)%n] != c[i][cur]){\n    if(dfs(mask + (1<<i), (c[i][cur]+1)%n, target)) return true;\n  }\n  return false;\n}\n\nint main(){\n  int v;\n  cin>>n>>v;\n  vector<int> a(n);\n  rep(i,n) cin>>a[i];\n\n  lv = 33 - __builtin_clz(v);\n\n  for(int i=0, tv=v; i<lv; i++, tv/=2){\n    int p = n-1;\n    c[i][n-1] = n-1;\n    for(int j = n-2; j>=0; j--){\n      if(a[j+1] - a[j] > tv) p = j;\n      c[i][j] = p;\n    }\n  }\n\n  set<int> x;\n  rep(i,n) x.insert(c[0][i]);\n  if(x.size() > lv){\n    rep(i,n) cout << \"Impossible\\n\";\n    return 0;\n  }\n\n  rep(i,n){\n    bool res = dfs(1, (c[0][i]+1)%n, i);\n    rep(j,i,c[0][i]+1) cout << (res ? \"Possible\" : \"Impossible\") << \"\\n\";\n    i = c[0][i];\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MAXN = 200010;\n\nconst int LG = 22;\nint x[MAXN], p[MAXN][LG], f[MAXN * 3], v[MAXN], vs = 0;\nint f2[MAXN * 3],  p2[MAXN][LG];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d%d\", &n, v);\n\tvs = 0;\n\twhile (v[vs] > 0)\n\t{\n\t\tv[vs + 1] = v[vs] / 2;\n\t\tvs++;\n\t}\n\tvs++;\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", x + i);\n\n\tfor (int i = 0; i < vs; i++)\n\t{\n\t\tp[n][i] = p[n - 1][i] = n;\n\t\tfor (int j = n - 2; j >= 0; j--)\n\t\t{\n\t\t\tif (x[j + 1] - x[j] > v[i]) p[j][i] = j + 1;\n\t\t\telse p[j][i] = p[j + 1][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < vs; i++)\n\t{\n\t\tp2[0][i] = p2[1][i] = 0;\n\t\tfor (int j = 2; j <= n; j++)\n\t\t{\n\t\t\tif (x[j - 1] - x[j - 2] > v[i]) p2[j][i] = j - 1;\n\t\t\telse p2[j][i] = p2[j - 1][i];\n\t\t}\n\t}\n\tmemset(f, 0, sizeof(f));\n\tfor (int i = 0; i < (1 << vs); i++)\n\t\tfor (int j = 0; j < vs; j++)\n\t\t{\n\t\t\tif (i & (1 << j)) continue;\n\t\t\tint nv = i + (1 << j);\n\t\t\tf[nv] = max(f[nv], p[f[i]][j]);\n\t\t}\n\tfor (int i = 0; i < (1 << vs); i++) f2[i] = n;\n\tfor (int i = 0; i < (1 << vs); i++)\n\t\tfor (int j = 0; j < vs; j++)\n\t\t{\n\t\t\tif (i & (1 << j)) continue;\n\t\t\tint nv = i + (1 << j);\n\t\t\tf2[nv] = min(f2[nv], p2[f2[i]][j]);\n\n\t\t}\n\tint msk = (1 << vs) - 1;\n\t\n\tint l, r;\n\tfor (l = 0; l != n; l = r)\n\t{\n\t\tr = p[l][0];\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < (1 << vs); i++)\n\t\t{\n\t\t\tif (i & 1) continue;\n\t\t\tif ((f[i] >= l) && (f2[msk - 1 - i] <= r))\n\t\t\t\tok = true;\n\t\t}\n\t\tfor (int i = l; i < r; i++)\n\t\t\tif (!ok) printf(\"Impossible\\n\");\n\t\t\telse printf(\"Possible\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<stdlib.h>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nint p[210000];\nint q[210000];\nint c[210000];\nint L[1<<18];\nint R[1<<18];\nvector<int>en[18];\nvector<int>ee;\nlong long sum[210000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",p+i);\n\t\tif(i)q[i]=p[i]-p[i-1];\n\n\t}\n\tint tt=b;\n\tfor(int i=0;i<a;i++){\n\t\tif(tt<q[i])ee.push_back(i);\n\t}\n\tint BI=0;\n\tee.push_back(a);\n\tfor(int i=0;i<18;i++){\n\t\tif(tt==0)break;\n\t\tBI++;\n\t\ttt/=2;\n\t\tc[i]=tt;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(c[i]<q[j])en[i].push_back(j);\n\t\t}\n\t\ten[i].push_back(a);\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t\tint at=L[i];\n\t\tint tmp=b;\n\t\tfor(int j=0;j<BI;j++){\n\t\t//\ttmp/=2;\n\t\t\tif(i&(1<<j))continue;\n\t\t\tif(at==a){\n\t\t\t\tL[i+(1<<j)]=a;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to=upper_bound(en[j].begin(),en[j].end(),at)-en[j].begin();\n\n\t//\t\tprintf(\"%d %d %d %d %d\\n\",i,j,at,to,(int)(en[j].size()));\n\t\t\tL[i+(1<<j)]=max(L[i+(1<<j)],en[j][to]);\n\t\t//\tif(tmp==0)break;\n\t\t}\n\t}\n\t//return 0;\n\treverse(p,p+a);\n\tfor(int i=0;i<a;i++){\n\t\tif(i)q[i]=p[i-1]-p[i];\n\t}\n\tfor(int i=0;i<BI;i++)en[i].clear();\n\tfor(int i=0;i<BI;i++){\n\t\tif(c[i]){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(c[i]<q[j])en[i].push_back(j);\n\t\t\t}\n\t\t\ten[i].push_back(a);\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t\tint at=R[i];\n\t\tint tmp=b;\n\t\tfor(int j=0;j<BI;j++){\n\t\t//\ttmp/=2;\n\t\t\tif(i&(1<<j))continue;\n\t\t\tif(R[i]==a){\n\t\t\t\tR[i+(1<<j)]=a;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to=upper_bound(en[j].begin(),en[j].end(),at)-en[j].begin();\n\t//\t\tprintf(\"%d %d %d %d %d\\n\",i,j,at,to,(int)(en[j].size()));\n\t\t\tR[i+(1<<j)]=max(R[i+(1<<j)],en[j][to]);\n\t\t//\tif(tmp==0)break;\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t//\tif(i>=(1<<2))continue;\n\t//\tprintf(\"%d: %d %d\\n\",i,L[i],R[i]);\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t\tint left=L[i];\n\t\tint right=a-R[(1<<BI)-1-i];\n\t\tleft++;\n\t\tif(upper_bound(ee.begin(),ee.end(),right)-lower_bound(ee.begin(),ee.end(),left)<=0){\n\t\t\tsum[left]++;\n\t\t\tsum[right+1]--;\n\t//\t\tprintf(\"%d %d\\n\",left-1,right);\n\t\t}\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tsum[i+1]+=sum[i];\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tsum[i+1]+=sum[i];\n\t}\n\t//for(int i=0;i<=a;i++)printf(\"%lld \",sum[i]);printf(\"\\n\");\n\tfor(int i=0;i<a;i++){\n\t\tint left,right;\n\t\tint ind=upper_bound(ee.begin(),ee.end(),i)-ee.begin();\n\t\tif(ind==0)left=0;\n\t\telse left=ee[ind-1];\n\t\tind=upper_bound(ee.begin(),ee.end(),i)-ee.begin();\n\t\tright=ee[ind];\n//\t\tprintf(\"%d: %d %d\\n\",i,left,right);\n\t\tif(sum[left]==sum[right])printf(\"Impossible\\n\");\n\t\telse printf(\"Possible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<math.h>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst long long int INF=99999999999999,inf=199999;\nconst long long int mod=1000000007;\n\n\n\nlong long int tmp,n,canmove[25]={},v,x[200005],leftdp[800000]={},rightdp[800000]={};\nlong long int leftnext[25][800005]={},rightnext[25][800005]={},two[30]={1};\nlong long int leftmemo[800005]={},rightmemo[800005]={};\nlong long int cou=0,k;\n\nvoid leftsolve(){\n    long long int count=0;\n    queue<long long int>que,memoque;\n    que.push(0);\n    leftdp[0]=1;\n    while(1){\n        while(!que.empty()){\n            for(int i=0;i<k;i++){\n                if((que.front()/two[i]%2)==0){\n                    leftdp[que.front()+two[i]]=max(leftdp[que.front()+two[i]],leftnext[i][leftdp[que.front()]]);\n                    //次のループで被りが出ないように\n                    if(leftmemo[que.front()+two[i]]==0){\n                        memoque.push(que.front()+two[i]);\n                        leftmemo[que.front()+two[i]]=1;\n                    }\n                }\n            }\n            que.pop();\n        }\n        while(!memoque.empty()){\n            que.push(memoque.front());\n            memoque.pop();\n        }\n        if(que.front()==two[k]-1){\n            break;\n        }\n    }\n}\n\nvoid rightsolve(){\n    long long int count=0;\n    queue<long long int>que,memoque;\n    que.push(0);\n    \n    while(1){\n        while(!que.empty()){\n            for(int i=0;i<k;i++){\n                if((que.front()/two[i])%2==0){\n                    rightdp[que.front()+two[i]]=min(rightdp[que.front()+two[i]],rightnext[i][rightdp[que.front()]]);\n                   //次のループで被りが出ないように\n                    if(rightmemo[que.front()+two[i]]==0){\n                        memoque.push(que.front()+two[i]);\n                        rightmemo[que.front()+two[i]]=1;\n                    }\n                    //cout<<que.front()<<\" \"<<two[i]<<\" \"<<endl;\n                    //cout<<que.front()+two[i]<<\" \"<<rightdp[que.front()+two[i]]<<endl;\n                }\n            }\n            que.pop();\n        }\n        while(!memoque.empty()){\n            que.push(memoque.front());\n            memoque.pop();\n        }\n        if(que.front()==two[k]-1){\n            break;\n        }\n    }\n}\n\n\nint main() {\n    \n    map<long long int,long long int>mp;\n\tcout << fixed << setprecision(10);\n    cin>>n>>v;\n    \n    for(int i=1;i<=26;i++){\n        two[i]=2*two[i-1];\n    }\n\n\n        for(int j=0;j<=199995;j++){\n            rightdp[j]=n;\n        }\n    \n\n    tmp=v;\n    while(tmp!=0){\n        canmove[cou]=tmp;\n        cou++;\n        tmp/=2;\n    }\n    k=cou+1;\n    \n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n    }\n    x[0]=INF;\n    x[n+1]=INF;\n\n    for(int i=0;i<k;i++){\n        tmp=0;\n        for(int j=2;j<=n+1;j++){\n            if(x[j]-x[j-1]>canmove[i]){\n                for(int p=tmp;p<j;p++){\n                    leftnext[i][p]=j;\n                }\n                tmp=j;\n            }\n        }\n\n        tmp=n;\n        for(int j=n-1;j>=0;j--){\n            if(x[j+1]-x[j]>canmove[i]){\n                for(int p=tmp;p>j;p--){\n                    rightnext[i][p]=j;\n                }\n                tmp=j;\n            }\n        }\n    }\n    \n    leftsolve();\n    rightsolve();\n    \n    for(int i=1;i<=n;i++){\n        //cout<<rightnext[0][i]<<\" \"<<canmove[0]<<endl;\n    }\n\n    for(int i=1;i<=n;i=leftnext[0][i]){\n        bool key=true;\n        for(int j=0;j<two[k];j+=2){\n            //cout<<j<<\" \"<<(j^(two[k]-2))<<\" \"<<leftdp[j]<<\" \"<<rightnext[0][i]<<\" \"<<rightdp[(j^(two[k]-2))]<<\" \"<<leftnext[0][i]<<endl;\n            if(leftdp[j]>rightnext[0][i]&&rightdp[(j^(two[k]-2))]<leftnext[0][i]){\n                for(int p=rightnext[0][i]+1;p<=leftnext[0][i]-1;p++){\n                    cout<<\"Possible\"<<endl;\n                }\n                key=false;\n                break;\n            }\n        }\n        if(key){\n            for(int p=rightnext[0][i]+1;p<=leftnext[0][i]-1;p++){\n                        cout<<\"Impossible\"<<endl;\n            }\n        }\n    }\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=262244,M=22,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ntemplate<class T> inline void read(T &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ntemplate<class T> inline void print(T x){\n\tif(!x){puts(\"0\");return;}\n\tif(x<0){putchar('-');x=-x;}\n\tint a[20],m=0;\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');puts(\"\");\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,a[N],v[20],l[20][N],r[20][N],f[N],g[N];\n\n\nvoid solve(int x){\n\tfor(int i=1;i<=n;i++){\n\t\tint t=i;\n\t\twhile(t<n&&a[t+1]-a[t]<=v[x]) t++;\n\t\tfor(int j=i;j<=t;j++)\n\t\t\tl[x][j]=t+1,r[x][j]=i-1;\n\t\ti=t;\n\t}\n\tl[x][n+1]=n+1;\n\tr[x][0]=0;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tsrand(time(0));\n#endif\n\tios::sync_with_stdio(0);\n\tread(n);read(v[0]);\n\tfor(int i=1;i<=n;i++) read(a[i]);\n\tfor(int j=1;v[j-1];j++,m=j) v[j]=v[j-1]>>1;\n\tfor(int i=0;i<m;i++) solve(i);\n\tdebug(m);\n\tf[0]=1;g[0]=n;\n\tfor(int i=1;i<(1<<m-1);i++){\n\t\tf[i]=1,g[i]=n;\n\t\tfor(int j=1;j<m;j++)\n\t\t\tif(i&(1<<j-1)) gmax(f[i],l[j][f[i^(1<<j-1)]]),gmin(g[i],r[j][g[i^(1<<j-1)]]);\n\t\t}\n\tint u=(1<<m-1)-1;\n\tfor(int i=1;i<=n;i++){\n\t\tint r=i,isok=0;\n\t\twhile(r<n&&a[r+1]-a[r]<=v[0]) r++;\n\t\tfor(int j=0;j<(1<<m-1);j++)\n\t\t\tif(f[j]>=i&&g[u^j]<=r) isok=1;\n\t\tfor(int j=i;j<=r;j++)\n\t\t\tif(isok) puts(\"Possible\"); else puts(\"Impossible\");\n\t\ti=r;\n\t}\n#ifdef rqgao2014\n\ttime_tester(1);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 524289;\nint n, V, xs[MAXN];\nint ls[MAXN], rs[MAXN], bak;\nint L[32][MAXN], R[32][MAXN];\nint pre[MAXN], suc[MAXN];\nvoid getmax(int & x, int y) { x < y ? x = y : 0; }\nvoid getmin(int & x, int y) { x > y ? x = y : 0; }\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> V;\n\txs[n + 1] = std::numeric_limits<int>::max();\n\tfor (int i = 1; i <= n; ++i) std::cin >> xs[i];\n\tint T = 0;\n\tfor (; ; ++T, V >>= 1) {\n\t\tint lst = 1;\n\t\tfor (int i = 2; i <= n + 1; ++i)\n\t\t\tif (xs[i] - xs[i - 1] > V) {\n\t\t\t\tint l = lst, r = i - 1;\n\t\t\t\tif (!T) ls[++bak] = l, rs[bak] = r;\n\t\t\t\telse for (int j = l; j <= r; ++j)\n\t\t\t\t\tL[T - 1][j] = l, R[T - 1][j] = r;\n\t\t\t\tlst = i;\n\t\t\t}\n\t\tif (!V) break;\n\t}\n\tconst int U = 1 << T;\n\tfor (int i = 0; i != U; ++i) suc[i] = n + 1;\n\tfor (int i = 0; i != U; ++i)\n\t\tfor (int j = 0; j != T; ++j)\n\t\t\tif (~i >> j & 1) {\n\t\t\t\tgetmax(pre[i | 1 << j], R[j][pre[i] + 1]);\n\t\t\t\tgetmin(suc[i | 1 << j], L[j][suc[i] - 1]);\n\t\t\t}\n\tfor (int i = 1; i <= bak; ++i) {\n\t\tbool can = false;\n\t\tif (bak <= 40) {\n\t\t\tfor (int j = 0; j != U; ++j)\n\t\t\t\tif (pre[j] >= ls[i] - 1 && suc[U - j - 1] <= rs[i] + 1) {\n\t\t\t\t\tcan = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tfor (int j = ls[i]; j <= rs[i]; ++j)\n\t\t\tstd::cout << (can ? \"Possible\\n\" : \"Impossible\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define repd(i,n) for ((i)=(n);(i)>=1;(i)--)\nusing namespace std;\n\nint n,m;\nint i,j;\nint a[200005],d[200005],lim[25];\nint tor[200005][25],tol[200005][25];\nint dppre[1<<19],dpsuf[1<<19];\n\nvoid calc(int x){\n\tint i;\n\trep(i,n){\n\t\ttor[i][x]=tor[i-1][x];\n\t\tif(tor[i][x]<i){\n\t\t\ttor[i][x]=i;\n\t\t\twhile(tor[i][x]<n&&d[tor[i][x]]<=lim[x]){\n\t\t\t\ttor[i][x]++;\n\t\t\t}\n\t\t}\n\t}\n\ttol[n+1][x]=n+1;\n\trepd(i,n){\n\t\ttol[i][x]=tol[i+1][x];\n\t\tif(tol[i][x]>i){\n\t\t\ttol[i][x]=i;\n\t\t\twhile(tol[i][x]>1&&d[tol[i][x]-1]<=lim[x]){\n\t\t\t\ttol[i][x]--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>n>>lim[m=1];\n\trep(i,n) cin>>a[i];\n\trep(i,n-1) d[i]=a[i+1]-a[i];\n\twhile(lim[m]>0){\n\t\tm++;\n\t\tlim[m]=lim[m-1]/2;\n\t}\n\trep(i,m){\n\t\tcalc(i);\n\t}\n\tint c=0;\n\tfor(i=1;i<=n;i=tor[i][1]+1)c++;\n\tif(c>m+1){\n\t\trep(i,n){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(i=0;i<(1<<(m-1));i++){\n\t\tdppre[i]=0;dpsuf[i]=n+1;\n\t\tfor(j=0;j<(m-1);j++)if((i>>j)&1){\n\t\t\tdppre[i]=max(dppre[i],tor[dppre[i^(1<<j)]+1][j+2]);\n\t\t\tdpsuf[i]=min(dpsuf[i],tol[dpsuf[i^(1<<j)]-1][j+2]);\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=n;i=tor[i][1]+1){\n\t\tint f=0;\n\t\tfor(j=0;j<(1<<(m-1));j++){\n\t\t\tf|=(dppre[j]>=i-1&&dpsuf[((1<<m-1)-1)^j]<=tor[i][1]+1);\n\t\t}\n\t\tif(f){\n\t\t\trep(j,tor[i][1]-i+1) puts(\"Possible\");\n\t\t}\n\t\telse{\n\t\t\trep(j,tor[i][1]-i+1) puts(\"Impossible\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <array>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef array<lli,3> ar;\n\nlli n,v;\nvll x;\nmat dp;\nmap<ar,lli> memo;\nlli dfs(lli k,lli s,lli t){\n    if(memo.find({k,s,t}) != memo.end()) return memo[{k,s,t}];\n    if(s == t){\n        return memo[{k,s,t}] = 0;\n    }\n    if(k >= dp.size()) return memo[{k,s,t}] = 1ll << 60;\n    lli ret = 1ll << 60;\n    for(lli i = s;i < t;i = dp[k][i]+1){\n        lli r,l;\n        r = dfs(k+1,s,i);l = dfs(k+r+1,dp[k][i]+1,t);\n        ret = min(ret,r+l);\n        l = dfs(k+1,dp[k][i]+1,t);r = dfs(k+l+1,s,i);\n        ret = min(ret,r+l);\n    }\n    return memo[{k,s,t}] = ret+1;\n}\nvoid solve(){\n    for(lli i = 0,d = v;d;d >>= 1,i++){\n        dp.push_back(vll(n));\n        dp.back()[n-1] = n-1;\n        for(lli j = n-1;j > 0;j--) dp.back()[j-1] = (x[j] - x[j-1] > d ? j-1 : dp.back()[j]);\n    }\n    dp.push_back(vll(n));\n    for(lli i = 0;i < n;i++) dp.back()[i] = i;\n    /*\n    for(lli i = 0;i < dp.size();i++){\n        for(lli j = 0;j < dp[i].size();j++){\n            cout << dp[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n    dfs(0,0,n);\n    for(lli i = 0;i < n;i = dp[0][i]+1){\n        if(dfs(1,0,i) + dfs(1,dp[0][i]+1,n) <= dp.size()){\n            for(lli j = i;j <= dp[0][i];j++) cout << \"Possible\" << endl;\n        }else{\n            for(lli j = i;j <= dp[0][i];j++) cout << \"Impossible\" << endl;\n        }\n    }\n\n\n\n\n}\nvoid input(){\n    cin >> n >> v;\n    x = vll(n);\n    for(lli i = 0;i < n;i++) cin >> x[i];\n}\n\nint main(){\n    input();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#define ll long long\n#define FOR(i,a) for(ll i=0;i<(ll)a.size();i++)\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=4e5+100;\nconst ll mod=1e9+7;\nconst ll logg=20;\n\nvector<ll> E;\nll logG(ll v,ll ww){\n\tif(E.empty()){\n\t\twhile(v){\n\t\t\tE.pb(v);\n\t\t\tv/=2;\n\t\t}\n\t\tE.pb(0);\n\t\treverse(E.begin(),E.end());\n\t}\n\treturn lower_bound(E.begin(),E.end(),ww)-E.begin();\n}\nll ta_koj_jelo[maxn][logg];\nll ta_koj_agha[maxn][logg];\n\nll x[maxn];\nll fas[maxn];\nll pri[maxn];\nll saf[maxn];\n\n\nll cnt[maxn];\n\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n\tll n,v;\n\tcin>>n>>v;\n\tfor(ll i=1;i<=n;i++){\n\t\tcin>>x[i];\n\t}\n\tfor(ll i=1;i+1<=n;i++){\n\t\tfas[i]=logG(v,x[i+1]-x[i]);\n\t//\tcout<<(ll)fas[i]<<\"* \";\n\t}\n\t//cout<<endl;\n\tfor(ll i=0;i<logg;i++){\n\t\tta_koj_jelo[n][i]=n;\n\t\tta_koj_jelo[n+1][i]=n;\n\t\tta_koj_agha[1][i]=1;\n\t\tta_koj_agha[0][i]=1;\n\t}\n\tfor(ll i=n-1;i>=0;i--){\n\t\tfor(ll j=0;j<logg;j++){\n\t\t\tif(fas[i]<=j){\n\t\t\t\tta_koj_jelo[i][j]=ta_koj_jelo[i+1][j];\n\t\t\t}else{\n\t\t\t\tta_koj_jelo[i][j]=i;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=2;i<=n;i++){\n\t\tfor(ll j=0;j<logg;j++){\n\t\t\tif(fas[i-1]<=j){\n\t\t\t\tta_koj_agha[i][j]=ta_koj_agha[i-1][j];\n\t\t\t}else{\n\t\t\t\tta_koj_agha[i][j]=i;\n\t\t\t}\n\t\t}\n\t}\n\n\tll M=(ll)(E.size());\n\tpri[0]=0;\n\tfor(ll i=1;i<(1<<M);i++){\n\t\tpri[i]=0;\n\t\tfor(ll j=0;j<M;j++){\n\t\t\tif((i>>j)&1){\n\t\t\t\tpri[i]=max(pri[i],ta_koj_jelo[pri[i^(1<<j)]+1][j]);\n\t\t\t}\n\t\t}\n\t\tpri[i]=min(pri[i],n);\n\t}\n\tsaf[0]=n+1;\n\tfor(ll i=1;i<(1<<M);i++){\n\t\tsaf[i]=n+1;\n\t\tfor(ll j=0;j<M;j++){\n\t\t\tif((i>>j)&1 ){\n\t\t\t\tsaf[i]=min(saf[i],ta_koj_agha[saf[i^(1<<j)]-1][j]);\n\t\t\t}\n\t\t}\n\t\tsaf[i]=max(saf[i],(ll)1);\n\t}\n\tfor(ll i=0;i<(1<<M);i++){\n\t//\tcout<<pri[i]<<' '<<saf[i]<<endl;\n\t}\n\tll H=((1<<M)/2)-1;\n\tif(saf[H]==1){\n\t\tcnt[0]=1;\n\t}else{\n\t\tfor(ll i=0;i<=H;i++){\n\t\t\tll ras=saf[i];\n\t\t\tll chap=pri[H^i];\n\n\t\t\tll R=ta_koj_jelo[chap+1][M-1]; \n\t\t\tll L=ta_koj_agha[ras-1][M-1];\n\n\t\t\tif(ras-1<=R){\n\t\t\t\tcnt[L]++;\n\t\t\t\tcnt[R+1]--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=1;i<=n;i++){\n\t\tcnt[i]+=cnt[i-1];\n\t\tif(cnt[i]){\n\t\t\tcout<<\"Possible\\n\";\n\t\t}else{\n\t\t\tcout<<\"Impossible\\n\";\n\t\t}\n\t}\n}\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 200010;\n\nint N, V;\nint X[MN], prec1[20][MN], prec2[20][MN];\nvector<int> P;\n\nint cc1[1 << 20];\nint dp1(int mask) {\n    int &ret = cc1[mask];\n    if(ret != -1) return ret;\n\n    ret = 0;\n    for(int i = 0; i < 20; i++) {\n        if(mask & (1 << i)) {\n            int t = dp1(mask ^ (1 << i));\n            if(t == N) return ret = N;\n            ret = max(ret, t + prec1[i][t]);\n        }\n    }\n    return ret;\n}\n\nint cc2[1 << 20];\nint dp2(int mask) {\n    int &ret = cc2[mask];\n    if(ret != -1) return ret;\n\n    ret = 0;\n    for(int i = 0; i < 20; i++) {\n        if(mask & (1 << i)) {\n            int t = dp2(mask ^ (1 << i));\n            if(t == N) return ret = N;\n            ret = max(ret, t + prec2[i][N - 1 - t]);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &V);\n    while(1) {\n        P.push_back(V);\n        if(!V) break;\n        V /= 2;\n    }\n    reverse(P.begin(), P.end());\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    for(int i = 0; i < P.size(); i++) {\n        for(int j = N - 1; j >= 0; j--) {\n            prec1[i][j] = 1;\n            if(j != N - 1 && X[j + 1] - X[j] <= P[i]) prec1[i][j] += prec1[i][j + 1];\n        }\n        for(int j = 0; j < N; j++) {\n            prec2[i][j] = 1;\n            if(j && X[j] - X[j - 1] <= P[i]) prec2[i][j] += prec2[i][j - 1];\n        }\n    }\n\n    memset(cc1, -1, sizeof(cc1));\n    memset(cc2, -1, sizeof(cc2));\n    int b = P.size();\n\n    if(dp1((1 << b) - 1) < N) {\n        for(int i = 0; i < N; i++) {\n            printf(\"Impossible\\n\");\n        }\n        return 0;\n    }\n\n    int pos = 0;\n    while(pos < N) {\n        int nxt = pos + prec1[b - 1][pos];\n\n        bool ok = false;\n        for(int mask = 0; mask < (1 << (b - 1)); mask++) {\n            if(dp1(mask) >= pos && dp2(((1 << (b - 1)) - 1) ^ mask) >= N - nxt) {\n                ok = true;\n                break;\n            }\n        }\n\n        //cout << pos << ' ' << nxt << endl;\n\n        for(int i = pos; i < nxt; i++) {\n            if(ok) printf(\"Possible\\n\");\n            else printf(\"Impossible\\n\");\n        }\n        pos = nxt;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = (int) 2e5 + 10;\nint a[maxn];\nint n, V;\n\nint read() {\n  if (scanf(\"%d%d\", &n, &V) < 2) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  return 1;\n}\n\nconst int maxl = 19;\nint vals[maxl + 1];\nint precs[maxl + 1][maxn];\n\nint dp[2][1 << maxl];\n\nint go[2][maxn];\n\nint froml[maxn];\n\nvoid solve() {\n  sort(a, a + n);\n\n\n  int lg = 0;\n  for (int x = V / 2; x; x /= 2) {\n    vals[lg++] = x;\n  }\n  vals[lg++] = 0;\n  assert(lg <= maxl);\n  vals[lg] = V;\n\n\n  for (int iter = 0; iter < 2; ++iter) {\n    for (int it = 0; it <= lg; ++it) {\n      auto &prec = precs[it];\n\n      int r = n - 1;\n      for (int i = n - 1; i >= 0; --i) {\n        auto &cur = prec[i];\n        cur = r;\n        if (i && a[i] - a[i - 1] > vals[it]) {\n          r = i - 1;\n        }\n      }\n    }\n\n    for (int i = 0; i < n; ++i) {\n      int s = i;\n      int t = precs[lg][s];\n      if (iter) {\n        s = n - 1 - s, t = n - 1 - t;\n      }\n      go[iter][s] = t;\n    }\n\n    auto &d = dp[iter];\n    for (int i = 0; i < (1 << lg); ++i) {\n      d[i] = 0;\n    }\n\n    for (int mask = 0; mask < (1 << lg); ++mask) {\n      int cur = d[mask];\n      //eprintf(\"d[mask = %d] = %d\\n\", mask, cur);\n      for (int it = 0; it < lg; ++it) {\n        if (mask & (1 << it)) {\n          continue;\n        }\n\n        int nval = cur;\n        if (nval < n) {\n          nval = precs[it][nval] + 1;\n        }\n        auto &toup = d[mask ^ (1 << it)];\n        toup = max(toup, nval);\n      }\n    }\n\n\n    reverse(a, a + n);\n    for (int i = 0; i < n; ++i) {\n      a[i] = -a[i];\n    }\n  }\n\n  for (int i = 0; i <= n; ++i) {\n    froml[i] = -1;\n  }\n\n  for (int mask = 0; mask < (1 << lg); ++mask) {\n    int cntl = dp[0][mask];\n    int cntr = dp[1][((1 << lg) - 1) ^ mask];\n\n    froml[cntl] = max(froml[cntl], cntr);\n  }\n\n  for (int i = n - 1; i >= 0; --i) {\n    froml[i] = max(froml[i], froml[i + 1]);\n  }\n\n  for (int i = 0; i < n; ++i) {\n    int r = go[0][i], l = go[1][i];\n    //eprintf(\"l = %d, r = %d\\n\", l, r);\n    if (froml[l] >= n - r - 1) {\n      printf(\"Possible\\n\");\n    } else {\n      printf(\"Impossible\\n\");\n    }\n  }\n  //exit(0);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nconst int N=200005,M=20,L=266666;\n \nint n,m,x[N],U,dp1[L],dp2[L];\nint nex[M][N],pre[M][N],sz[M],k;\nint mx[N];\n \nvoid make(int V,int*nx,int*pr){\n\tnx[n]=n;\n\tfor(int i=n-1;i>=1;i--)if(x[i+1]-x[i]>V)nx[i]=i;else nx[i]=nx[i+1];\n\tpr[1]=1;\n\tfor(int i=2;i<=n;i++)if(x[i]-x[i-1]>V)pr[i]=i;else pr[i]=pr[i-1];\n}\n \nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&x[i]);\n\tfor(int i=m>>1;i>=1;i>>=1)sz[k++]=i;sz[k++]=0;\n\tsz[k]=m;\n\tfor(int i=0;i<=k;i++)make(sz[i],nex[i],pre[i]);\n\tU=1<<k;\n\tfor(int i=0;i<U;i++)dp1[i]=0,dp2[i]=n+1;\n\tfor(int i=0;i<U;i++)for(int j=0;j<k;j++)\n\t\tif(~i>>j&1){\n\t\t\tif(dp1[i]==n)dp1[i|1<<j]=n;\n\t\t\telse dp1[i|1<<j]=max(dp1[i|1<<j],nex[j][dp1[i]+1]);\n\t\t\tif(dp2[i]==1)dp2[i|1<<j]=1;\n\t\t\telse dp2[i|1<<j]=min(dp2[i|1<<j],pre[j][dp2[i]-1]);\n\t\t}\n\tmemset(mx,-1,sizeof(mx));\n\tfor(int i=0;i<U;i++){\n\t\tmx[dp2[i]]=max(mx[dp2[i]],dp1[(U-1)^i]);\n\t}\n\tfor(int i=1;i<=n+1;i++)\n\t\tmx[i]=max(mx[i],mx[i-1]);\n\tfor(int i=1;i<=n;i++){\n\t\tif(mx[nex[k][i]+1]>=pre[k][i]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010;\nint a[N],cnt,n,v,b[N],f[1<<18];\nset<int> s[20];\nset<int>::iterator it,it2;\nbool ans[N];\ninline void Max(int &x,int y){if(y>x)x=y;}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i =1;i<=n;i++)scanf(\"%d\",a+i);\n\tsort(a+1,a+n+1);\n\tfor(int i = 2;i<=n;i++){\n\t\tif(a[i]>a[i-1]+v) \n\t\t\ts[0].insert(i-1);\n\t} \n\ts[0].insert(n);\n\tif(s[0].size()>18){\n\t\tfor(int i =1;i<=n;i++) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\t//cout<<\"YY\"<<endl;\n\tfor(it=s[0].begin();it!=s[0].end();it++){\n\t\tint tmp = v;\n\t\tcnt = 0;\n\t\tint m = 0,start;\n\t\tbool pd = false;\n\t\tit2 = it;\n\t\tif(it2!=s[0].begin()){\n\t\t\tit2--;\n\t\t\tstart = *it2+1;\n\t\t} else start = 1;\n\t\n\t\tfor(int i =1;i<start;i++) b[++m] = a[i];\n\t\tfor(int i =*it+1;i<=n;i++) b[++m] = a[i];\n\t\tdo{\n\t\t\tcnt++;\n\t\t\ts[cnt].clear();\n\t\t\ttmp>>=1;\n\t\t\n\t\t\tfor(int i = 2;i<=m;i++){\n\t\t\t\tif(b[i]>b[i-1]+tmp) \n\t\t\t\t\ts[cnt].insert(i-1);\n\t\t\t} \n\t\t\ts[cnt].insert(m);\n\t\t} while(tmp>0);\n\t\t//cout<<start<<' '<<*it<<endl;\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(int k = 0;k<1<<cnt;k++){\n\t\t\tif(f[k] == m) {\n\t\t\t\tpd =true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j = 1;j<=cnt;j++) if(!(k>>j-1&1)){\n\t\t\t\tMax(f[k+(1<<j-1)],*s[j].upper_bound(f[k]));\n\t\t\t}\n\t\t}\n\t\tfor(int i =start ;i<=*it;i++) ans[i] = pd;\n\t}\n\tfor(int i=1;i<=n;i++) \n\t\tif(ans[i]) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,v;\n  cin>>n>>v;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n\n  vector<Int> dp;\n  vector<vector<Int> > ps;\n  while(v){\n    vector<Int> dp2(n,0);\n    for(Int i=1;i<n;i++)\n      dp2[i]=dp2[i-1]+(x[i]-x[i-1]>v);\n    if(dp.empty()) dp=dp2;\n\n    vector<Int> ps2;\n    ps2.emplace_back(0);\n    for(Int i=1;i<n;i++)\n      if(dp2[i]!=dp2[i-1]) ps2.emplace_back(i);\n    ps2.emplace_back(n);\n    ps.emplace_back(ps2);\n    v>>=1;\n  }\n  \n  {\n    vector<Int> ps2(n+1,0);\n    iota(ps2.begin(),ps2.end(),0);\n    ps.emplace_back(ps2);\n  }\n\n  using P = pair<Int, Int>;\n  Int flg;\n  function<void(Int,set<P>)> dfs=\n    [&](Int d,set<P> sp){\n      {\n\tauto latte=sp.begin();\n\tInt res=latte->first==0;\n\twhile(latte!=sp.end()){\n\t  auto malta=latte;\n\t  if(++malta==sp.end()) break;;\n\t  res&=latte->second==malta->first;\n\t  latte=malta;\n\t}\n\tres&=latte->second==n;\n\tflg|=res;\n      }\n      \n      if(d==(Int)ps.size()) return;\n      \n      vector<Int> &v=ps[d];\n      Int cnt=0,ncnt=0;\n      auto latte=v.begin();\n      for(auto &p:sp){\n\tcnt+=lower_bound(latte,v.end(),p.first)-latte;\n\tif(d+1<(Int)ps.size()){\n\t  vector<Int> &u=ps[d+1];\n\t  ncnt+=lower_bound(u.begin(),u.end(),p.first)\n\t    -lower_bound(u.begin(),u.end(),*latte);\n\t}\n\tlatte=lower_bound(latte,v.end(),p.second);\n      }\n      cnt+=v.end()-latte;\n      if(d+1<(Int)ps.size()){\n\tvector<Int> &u=ps[d+1];\n\tncnt+=u.end()-lower_bound(u.begin(),u.end(),*latte);\n      }\n      \n      if(d+cnt-1>(Int)ps.size()) return;\n      \n      Int k=0;\n      set<P> nsp=sp;\n      for(auto &p:sp){\n\tInt nk=0;\n\twhile(v[k]<p.first){\n\t  if(d+1<(Int)ps.size()){\n\t    vector<Int> &u=ps[d+1];\n\t    nk=lower_bound(u.begin(),u.end(),v[k+1])\n\t      -lower_bound(u.begin(),u.end(),v[k]);\n\t  }\n\t  nsp.emplace(v[k],v[k+1]);\n\t  if(d+ncnt-nk<=(Int)ps.size()) dfs(d+1,nsp);\n\t  nsp.erase(P(v[k],v[k+1]));\n\t  k++;\n\t  if(flg) return;\n\t}\n\tk=lower_bound(v.begin(),v.end(),p.second)-v.begin();\n      }\n      \n      Int nk=0;\n      while(k+1<(Int)v.size()){\n\tif(d+1<(Int)ps.size()){\n\t  vector<Int> &u=ps[d+1];\n\t  nk=lower_bound(u.begin(),u.end(),v[k+1])\n\t    -lower_bound(u.begin(),u.end(),v[k]);\n\t}\n\tnsp.emplace(v[k],v[k+1]);\n\tif(d+ncnt-nk<=(Int)ps.size()) dfs(d+1,nsp);\n\tnsp.erase(P(v[k],v[k+1]));\n\tk++;\n\tif(flg) return;\n      }\n    };\n  \n  for(Int i=0;i<n;){\n    Int l=i,r=*upper_bound(ps[0].begin(),ps[0].end(),l);\n    set<P> sp;\n    sp.emplace(l,r);\n    flg=0;\n    //cout<<l<<\" \"<<r<<endl;\n    dfs(1,sp);\n    string ans=flg?\"Possible\":\"Impossible\";\n    Int p=i;\n    while(i<n&&dp[p]==dp[i]){\n      cout<<ans<<endl;\n      i++;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define endl '\\n'\n \ntypedef long long int64;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n \nconst int oo = 0x3f3f3f3f;\nconst double eps = 1e-9;\n \nconst int maxn = 200010;\nconst int mlog = 20;\n \nint pos[ maxn ];\nint vsize[ mlog ], len;\n \nint mr[ maxn ][ mlog ], ml[ maxn ][ mlog ];\nint dppref[ 1 << mlog ], dpsuff[ 1 << mlog ];\n \nint bestcover[ maxn ];\n \nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n \n#ifdef MARX\n    freopen(\"data.in\", \"r\", stdin);\n#endif\n \n    int n, V;\n    cin >> n >> V;\n \n    int v = V >> 1;\n \n    for (int i = 0; i < n; ++i)\n        cin >> pos[i];\n \n    for (len = 0; vsize[len++] = v; v >>= 1);\n    vsize[ len ] = V;\n \n    for (int i = 0; i <= len; ++i){\n        mr[ n - 1 ][i] = n - 1;\n        ml[ 0 ][i] = 0;\n    }\n \n    for (int i = 1; i < n; ++i){\n        for (int j = 0; j <= len; ++j){\n            if (pos[i] - pos[i - 1] <= vsize[j])\n                ml[i][j] = ml[i - 1][j];\n            else\n                ml[i][j] = i;\n        }\n    }\n \n    for (int i = n - 2; i >= 0; --i){\n        for (int j = 0; j <= len; ++j){\n            if (pos[i + 1] - pos[i] <= vsize[j])\n                mr[i][j] = mr[i + 1][j];\n            else\n                mr[i][j] = i;\n        }\n    }\n \n    dppref[0] = -1;\n    dpsuff[0] = n;\n \n    int mask = (1 << len);\n \n    for (int i = 1; i < mask; ++i){\n        dppref[i] = 0;\n        dpsuff[i] = n - 1;\n \n        for (int j = 0; j < len; ++j){\n            if (i >> j & 1){\n                int m = i ^ (1 << j);\n \n                // prefix\n \n                if (dppref[m] == n - 1)\n                    dppref[i] = n - 1;\n                else\n                    dppref[i] = max(dppref[i], mr[ dppref[m] + 1 ][j]);\n \n                // suffix\n \n                if (dpsuff[m] == 0)\n                    dpsuff[i] = 0;\n                else\n                    dpsuff[i] = min( dpsuff[i], ml[ dpsuff[m] - 1 ][j]);\n            }\n        }\n    }\n \n    mask--;\n \n    for (int i = 0; i < n; ++i)\n        bestcover[i] = oo;\n \n    for (int i = 0; i <= mask; ++i){\n        int comp = mask ^ i;\n        \n        int pA = dppref[ i ], pB = dpsuff[ comp ];\n\n        if (pA >= 0)\n        \tbestcover[ pA ] = min( bestcover[ pA ], pB );\n    }\n \n    for (int i = n - 2; i >= 0; --i)\n        bestcover[i] = min( bestcover[i], bestcover[i + 1] );\n \n    for (int i = 0; i < n; ++i){\n        int pA = ml[i][len], pB = mr[i][len];\n \n        bool ok = false;\n \n        if (pA == 0){\n            if (dpsuff[ mask ] <= pB + 1)\n                ok = true;\n        }\n        else\n            ok = bestcover[pA - 1] <= pB + 1;\n \n        cout << (ok ? \"Possible\" : \"Impossible\") << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 210000, maxk = 20;\nint x[maxn];\nvi w;\nint fw[maxn][maxk], fb[maxn][maxk];\nint jfw[1 << maxk], jfb[1 << maxk];\nint dans[maxn];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, v;\n    cin >> n >> v;\n    forn(i, n) cin >> x[i];\n    w.pb(v);\n    while (w.back()) {\n        int z = w.back();\n        w.pb(z / 2);\n    }\n    reverse(all(w));\n    int k = w.size();\n    ford(i, n) forn(j, k) {\n        if (i + 1 < n && x[i + 1] - x[i] <= w[j]) fw[i][j] = fw[i + 1][j];\n        else fw[i][j] = i;\n    }\n\n    forn(i, n) forn(j, k) {\n        if (i && x[i] - x[i - 1] <= w[j]) fb[i][j] = fb[i - 1][j];\n        else fb[i][j] = i;\n    }\n\n    forn(i, 1 << k) jfw[i] = -1, jfb[i] = n;\n    jfw[0] = 0;\n    jfb[0] = n - 1;\n    forn(i, 1 << k) {\n        forn(j, k) {\n            if ((i >> j) & 1) continue;\n            if (jfw[i] < n) uax(jfw[i | (1 << j)], fw[jfw[i]][j] + 1);\n            if (jfb[i] >= 0) uin(jfb[i | (1 << j)], fb[jfb[i]][j] - 1);\n        }\n    }\n\n    forn(i, 1 << (k - 1)) {\n        int l = jfw[i], r = jfb[(1 << (k - 1)) - i - 1];\n        if (l + 1 >= r) {\n            ++dans[0];\n        } else if (fw[l][k - 1] >= r) {\n            cerr << i << ' ' << l << ' ' << r << '\\n';\n            ++dans[l];\n            --dans[r + 1];\n        }\n    }\n    forn(i, n - 1) dans[i + 1] += dans[i];\n    forn(i, n) cout << (dans[i] ? \"Possible\" : \"Impossible\") << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nint n, v, lg;\ntypedef std::pair<int, int> pr;\nint g0[1 << 18], g1[1 << 18];\nint x[maxn], ans[maxn];\nstd::vector<pr> vec[233];\ninline void init(std::vector<pr> & v,int d) {\n\tint l = 1;\n\tfor(int i = 2;i <= n;++i) if(x[i] - x[i - 1] > d)\n\t\tv.emplace_back(l, i - 1), l = i;\n\tv.emplace_back(l, n);\n}\ninline void up(int & x,int y) { if(x < y) x = y; }\ninline void down(int & x,int y) { if(x > y) x = y; }\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> v;\n\trep(i, 1, n) cin >> x[i];\n\tfor(;v >> lg;++lg) if(v >> lg) init(vec[lg], v >> lg);\n\tinit(vec[lg++], 0);\n\tif(vec[0].size() < 20) {\n\t\tstd::fill(g1, g1 + (1 << lg), n + 1);\n\t\trep(i, 0, (1 << lg) - 1) {\n\t\t\trep(j, 1, lg - 1) if((i >> j & 1) == 0){\n\t\t\t\tint l = 0, r = vec[j].size();\n\t\t\t\tfor(;l + 1 != r;) (vec[j][l + r >> 1].first <= g0[i] + 1 ? l : r) = l + r >> 1;\n\t\t\t\tup(g0[i | 1 << j], vec[j][l].second), l = -1, r = vec[j].size() - 1;\n\t\t\t\tfor(;l + 1 != r;) (vec[j][l + r >> 1].second >= g1[i] - 1 ? r : l) = l + r >> 1;\n\t\t\t\tdown(g1[i | 1 << j], vec[j][r].first);\n\t\t\t}\n\t\t}\n\t\tfor(pr i : *vec) {\n\t\t\tfor(int j = 0;j < 1 << lg;j += 2) {\n\t\t\t\tif(g0[j] >= i.first - 1 && i.second + 1 >= g1[~j & (1 << lg) - 1 & -2]){\n\t\t\t\t\tstd::fill(ans + i.first, ans + i.second + 1, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 1, n) {\n\t\tcout << (ans[i] ? \"Possible\" : \"Impossible\") << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define F(i,j,n) for(register int i=j;i<=n;i++)\n#define D(i,j,n) for(register int i=j;i>=n;i--)\n#define ll long long\n#define N 200010\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;int f;\n\tchar gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void gi(I&x){\n\t\tfor(f=1,c=gc();c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n};\nusing io::gi;\nusing io::gc;\nint f[N],s[N],nxt[20][N],g[20][N],x[N],n,m,h,v,d,p;\nvoid pre(int v){\n\tif(!v)return;pre(v/2);\n\th=0;d++;\n\tF(i,1,m)\n\t\tif(x[f[i]]>v)f[++h]=f[i];\n\t\telse nxt[d][f[i-1]]=f[i];\n\tm=h;\n//\tF(i,1,m)printf(\"%d \",f[i]);puts(\"\");\n}\nint dfs(int d,int m){\n\tif(!m)return 1;int h=0;\n//\tF(i,1,m)printf(\"%d \",g[d][i]);puts(\"\");\n\tF(i,1,m)for(int j=g[d][i];j;j=nxt[d][j]){\n\t\ts[++h]=j;\n\t\tif(h>d)return 0;\n\t}\n//\tF(i,1,h)printf(\"%d \",s[i]);puts(\"\\n\");\n\tif(h==1)return 1;\n\tF(i,1,h)g[d][i]=s[i];\n\tF(i,1,h){\n\t\tm=0;\n\t\tF(j,1,h)if(j!=i)g[d-1][++m]=g[d][j];\n\t\tif(dfs(d-1,m))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tgi(n);gi(v);\n\tF(i,1,n)gi(x[i]);\n\tD(i,n,2)x[i]-=x[i-1];\n\tx[1]=v+1;F(i,1,n)f[++m]=i;\n\tpre(v);f[m+1]=n+1;\n//\tprintf(\"%d\\n\",d);\n//\tF(i,1,d){F(j,1,n)printf(\"%d \",nxt[i][j]);puts(\"\");}puts(\"\");\n\tif(m>d+1){F(i,1,n)puts(\"Impossible\");return 0;}\n\tF(i,1,m){\n\t\th=0;\n\t\tF(j,1,m)if(j!=i)g[d][++h]=f[j];\n\t\tp=dfs(d,h);\n\t\tF(j,f[i],f[i+1]-1)puts(p?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> vals;\nint rt[200005][30];\nint lt[200005][30];\nint n,v;\nint pos[200005];\nint memo1[600005];\nint memo2[600005];\nint something[200005];\n\nint dpL(int bitmask){\n    if (memo1[bitmask]!=-1) return memo1[bitmask];\n    if (bitmask==0) return memo1[bitmask] = -1;\n    int ans = 0;\n    for (int x = 0; x<vals.size(); x++){\n        if (bitmask&(1<<x)){\n            ans = max(ans,dpL(bitmask^(1<<x)));\n            ans = max(ans,rt[dpL(bitmask^(1<<x))+1][x]);\n        }\n    }\n    return memo1[bitmask] = ans;\n}\n\nint dpR(int bitmask){\n    if (memo2[bitmask]!=-1) return memo2[bitmask];\n    if (bitmask==0) return memo2[bitmask] = n;\n    int ans = n-1;\n    for (int x = 0; x<vals.size(); x++){\n        if (bitmask&(1<<x)){\n            ans = min(ans,dpR(bitmask^(1<<x)));\n            if (ans==0) break;\n            ans = min(ans,lt[dpR(bitmask^(1<<x))-1][x]);\n        }\n    }\n    return memo2[bitmask] = ans;\n}\n\nint main(){\n    memset(memo1,-1,sizeof(memo1));\n    memset(memo2,-1,sizeof(memo2));\n    scanf(\"%d%d\",&n,&v);\n\n    int t = v;\n    while (t>0){\n        vals.push_back(t);\n        t/=2;\n    }\n    vals.push_back(0);\n    for (int x = 0; x<n; x++){\n        scanf(\"%d\",&pos[x]);\n    }\n    for (int i = 0; i<vals.size(); i++){\n        rt[n-1][i] = n-1;\n        for (int x = n-2; x>=0; x--){\n            rt[x][i] = pos[x+1]-pos[x]<=vals[i]?rt[x+1][i]:x;\n        }\n        lt[0][i] = 0;\n        for (int x = 1; x<n; x++){\n            lt[x][i] = pos[x]-pos[x-1]<=vals[i]?lt[x-1][i]:x;\n        }\n    }\n    for (int x = 0; x<n; x++){\n        something[x] = n+1;\n    }\n    for (int x = 0; x<(1<<(vals.size())); x+=2){\n        int other = ((1<<(vals.size()))-2)^x;\n        if (dpL(x)==-1) continue;\n        something[dpL(x)] = min(something[dpL(x)],dpR(other));\n    }\n    for (int x = n-2; x>=0; x--){\n        something[x] = min(something[x],something[x+1]);\n    }\n    for (int x = 0; x<n; x++){\n        int L = lt[x][0];\n        int R = rt[x][0];\n        //printf(\"something %d %d\\n\",x,something[x]);\n        //printf(\"L:%d,R:%d\\n\",L,R);\n        printf(something[max(0,L-1)]<=R+1?\"Possible\\n\":\"Impossible\\n\");\n    }\n    //printf(\"%d\\n\",dpL(6));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline void ri(int &x){\n\tx=0; static char c; bool t=0;\n\twhile(c=getchar(),c<'0'||c>'9') if(c=='-') t=1; else t=0;\n\tdo x=x*10+c-'0'; while(c=getchar(),c>='0'&&c<='9');\n\tif(t) x=-x;\n}\nconst int N=200024;\nint val[35],tot;\nint a[N],f[N],nf[N];\nint l[N],r[N],L[N],R[N],gs;\nint nl[N],nr[N],nL[N],nR[N],ngs;\nint ans[N];\npair<int,int> b[N];\nint main(){\n\tint i,j,n,v; ri(n); ri(v);\n\tfor(i=1;i<=n;++i) ri(a[i]);\n\twhile(v){\n\t\tval[++tot]=v;\n\t\tv>>=1;\n\t}\n\tfor(i=1;i<=n;++i) f[i]=1,l[i]=r[i]=a[i],L[i]=i,R[i]=i; gs=n;\n\tfor(i=tot;i;--i){\n\t\tngs=0;\n\t\tfor(j=1;j<=gs;){\n\t\t\tint h=j+1,s=f[j],mn=f[j];\n\t\t\twhile(h<=gs&&l[h]-r[h-1]<=val[i]){\n\t\t\t\ts+=f[h]; mn=min(mn,f[h]);\n\t\t\t\t++h;\n\t\t\t}\n\t\t\tnl[++ngs]=l[j]; nr[ngs]=r[h-1]; nf[ngs]=s-mn+1;\n\t\t\tnL[ngs]=L[j]; nR[ngs]=R[h-1];\n\t\t\tj=h;\n\t\t}\n\t\tgs=ngs;\n\t\tfor(j=1;j<=gs;++j){\n\t\t\tl[j]=nl[j]; r[j]=nr[j]; f[j]=nf[j];\n\t\t\tL[j]=nL[j]; R[j]=nR[j];\n\t\t}\n\t}\n\tint s=0;\n\tfor(i=1;i<=gs;++i) s+=f[i];\n\tfor(i=1;i<=gs;++i)\n\tif(s-f[i]+1<=tot+1)\n\tfor(j=L[i];j<=R[i];++j) ans[j]=1;\n\tfor(i=1;i<=n;++i)\n\tif(ans[i]) puts(\"Possible\");\n\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// a.cpp\n\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < __typeof(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < ll >\n# define pb push_back\n# define pdd pair < db , db >\ninline int readChar();\ntemplate <class T = int> inline T readInt();\ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x );\ninline void writeWord( const char *s );\n\n/** Read */\n\nstatic const int buf_size = 4096;\n\ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len)\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    if (pos == len)\n        return -1;\n    return buf[pos++];\n}\n\ninline int readChar() {\n    int c = getChar();\n    while (c <= 32)\n        c = getChar();\n    return c;\n}\n\ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n\n/** Write */\n\nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n\ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n\ntemplate <class T>\ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n\n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n\ninline void writeWord( const char *s ) {\n    while (*s)\n        writeChar(*s++);\n}\n\nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int RMQ[20][1 << 20];\n    int n,k;\n    n = readInt();\n    k = readInt();\n    static int s[1 << 20];\n    for (int i = 1;i <= n;++i)\n        s[i] = readInt();\n    for (int i = 1;i < n;++i)\n        RMQ[0][i] = s[i + 1] - s[i];\n    for (int t = 1;n >> t;++t)\n        for (int i = 1;i + (1 << t) <= n + 1;++i)\n            RMQ[t][i] = max(RMQ[t - 1][i],RMQ[t - 1][i + (1 << (t - 1))]);\n    static int Log[1 << 20];\n    for (int i = 2;i <= (1 << 19);++i)\n        Log[i] = Log[i / 2] + 1;\n    auto get = [&](int l,int r)\n    {\n        int lg = Log[r - l + 1];\n        return max(RMQ[lg][l],RMQ[lg][r - (1 << lg) + 1]);\n    };\n    static int D1[1 << 20];\n    static int D2[1 << 20];\n    int lg = Log[k] + 2;\n    const int N = 1 << lg;\n    D1[0] = 0;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            if ((mask >> i) & 1)\n            {\n                int number = (k >> i);\n                int ans = D1[mask ^ (1 << i)] + 1;\n                int was = ans;\n                for (int t = 1 << Log[ans];t;t /= 2)\n                    if (ans + t <= n && get(was,ans + t - 1) <= number)\n                        ans += t;\n                smax(D1[mask],ans);\n            }\n    D2[0] = n + 1;\n    for (int mask = 1;mask < N;++mask)\n        D2[mask] = n + 1;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            if ((mask >> i) & 1)\n            {\n                int number = (k >> i);\n                int ans = D2[mask ^ (1 << i)] - 1;\n                int was = ans;\n                for (int t = 1 << Log[n - ans + 1];t;t /= 2)\n                    if (ans > t && get(ans - t,was - 1) <= number)\n                        ans -= t;\n                smin(D2[mask],ans);\n            }\n    static int answer[1 << 20];\n    for (int mask1 = 0;mask1 < N;++mask1)\n        if (!(mask1 & 1))\n        {\n            int mask2 = (N - 1) ^ 1 ^ mask1;\n            const int l = D1[mask1];\n            const int r = D2[mask2];\n            if (l + 1 > r - 1)\n                answer[1]++,--answer[n + 1];\n            else\n            if (l + 1 == r - 1 || get(l + 1,r - 2) <= k)\n                ++answer[l + 1],--answer[r];\n        }\n    for (int i = 1;i <= n;++i)\n        answer[i] += answer[i - 1];\n    for (int i = 1;i <= n;++i)\n        if (answer[i])\n            PP;\n        else\n            II;\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for (int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T sqr(const T &a) { return a * a; }\ntypedef long long LL;\ntypedef long double LD;\nvoid procStatus() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\nLL read() {\n\tLL x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (;!isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n\tfor (;isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\treturn x * flag;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 4e5 + 9;\nint n, V, a[Maxn];\n\nvoid Init() {\n\tn = read(), V = read();\n\trep (i, 1, n) a[i] = read();\n}\n\nint pon[20][Maxn];\nint len[Maxn], lef[Maxn], rig[Maxn];\n\nint uppfind(int pos, int step) {\n\tint l = 1, r = len[step], ans = pon[step][r];\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (pon[step][mid] > pos) ans = pon[step][mid], r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\treturn ans;\n}\n\nint lowfind(int pos, int step) {\n\tint l = 1, r = len[step], ans = pon[step][l];\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (pon[step][mid]< pos) ans = pon[step][mid], l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\treturn ans + 1;\n}\n\nvoid Solve() {\n\tint cnt = 0;\n\twhile ((1 << cnt) <= V) ++cnt;\n\trep (i, 0, cnt) {\n\t\tlen[i] = 1;\n\t\trep (j, 1, n) {\n\t\t\tpon[i][len[i]] = j;\n\t\t\tif (j != n && a[j + 1] - a[j] > (V >> i)) ++len[i];\n\t\t}\n\t\tprintf(\"In %d\\n\", i);\n\t\trep (j, 1, len[i])\n\t\t\tprintf(\"%d \", pon[i][j]);\n\t\tputs(\"\");\n\t\tpon[i][len[i] + 1] = n + 1;\n\t}\n\tif (len[0] > cnt + 1) {\n\t\trep (i, 1, n) puts(\"Impossible\");\n\t\treturn ;\n\t}\n\trep (i, 0, (1 << cnt) - 1) lef[i] = 0, rig[i] = n + 1;\n\trep (i, 0, (1 << cnt) - 1) {\n\t\trep (j, 0, cnt - 1) {\n\t\t\tif ((i >> j) & 1) continue;\n\t\t\tchkmax(lef[i ^ (1 << j)], uppfind(lef[i], j + 1)); // find a pointer bigger exclusively than f[i]\n\t\t\tchkmin(rig[i ^ (1 << j)], lowfind(rig[i] - 1, j + 1)); // find a pointer lower exclusively than f[i]\n\t\t}\n\t\tprintf(\"%d: %d %d\\n\", i, lef[i], rig[i]);\n\t}\n\trep (i, 1, len[0]) {\n\t\tint l = pon[0][i - 1] + 1, r = pon[0][i];\n\t\tint flag = 0;\n\t\trep (j, 0, (1 << cnt) - 1) \n\t\t\tif (lef[j] >= l - 1 && rig[(1 << cnt) - 1 - j] <= r + 1) {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\trep (j, l, r) puts(flag ? \"Possible\" : \"Impossible\");\n\t}\n}\n\nint main() {\n//\tfreopen(\"bosky.in\", \"r\", stdin);\n//\tfreopen(\"bosky.out\", \"w\", stdout);\n\n\tInit();\n\tSolve();\t\n\n#ifdef Qrsikno\n//\tprocStatus();\n\tdebug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define maxn 200005\n#define D 20\n#define INF 2147483647\nusing namespace std;\nint n,v,x[maxn],vis[maxn],maxv[maxn],cnt[D],l[D][maxn],r[D][maxn],f1[maxn*5],f2[maxn*5],ans[maxn];\nint upfind(int i,int pos)\n{\n\tpos++;\n\tint p=upper_bound(l[i]+1,l[i]+cnt[i]+1,pos)-l[i]-1;\n\tif(p<=0) return pos;\n\treturn max(r[i][p],pos-1);\n}\nint lowfind(int i,int pos)\n{\n\tpos--;\n\tint p=lower_bound(r[i]+1,r[i]+cnt[i]+1,pos)-r[i];\n\tif(p>cnt[i]) return pos;\n\treturn min(l[i][p],pos+1);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tx[0]=-INF,x[n+1]=INF;\n\tint log2;\n\tfor(log2=0;(1<<log2)<=v;log2++);\n\tfor(int lg=0;lg<=log2;lg++)\n\t{\n\t\tint d=v/(1<<lg);\n\t\tcnt[lg]=l[lg][1]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tr[lg][cnt[lg]]=i;\n\t\t\tif(x[i+1]-x[i]>d) l[lg][++cnt[lg]]=i+1;\n\t\t}\n\t\tcnt[lg]--;\n\t}\n\tif(cnt[0]>log2+1)\n\t{\n\t\tfor(int i=1;i<=n;i++) printf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint S=(1<<(log2+1));\n\tfor(int s=0;s<S;s++) f1[s]=0,f2[s]=INF;\n\tf2[0]=n+1;\n\tfor(int s=0;s<S;s+=2)\n\t\tfor(int i=0;i<=log2;i++)\n\t\t{\n\t\t\tif(!(s&(1<<i))) continue;\n\t\t\tf1[s]=max(f1[s],upfind(i,f1[s-(1<<i)]));\n\t\t\tf2[s]=min(f2[s],lowfind(i,f2[s-(1<<i)]));\n\t\t}\n\tfor(int i=1;i<=cnt[0];i++)\n\t{\n\t\tint ln=l[0][i],rn=r[0][i];\n\t\tfor(int s1=0;s1<S;s1+=2)\n\t\t{\n\t\t\tint s2=S-s1-2;\n\t\t\tint lp=f1[s1],rp=f2[s2];\n\t\t\tif(lp>=ln-1&&rp<=rn+1) { ans[i]=true; break; }\n\t\t}\n\t}\n\tfor(int i=1,pos=1;i<=n;i++)\n\t{\n\t\tprintf(\"%s\\n\",ans[pos]?\"Possible\":\"Impossible\");\n\t\tif(x[i+1]-x[i]>v) pos++;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint n,v,x[N];\nint dp1[(1<<20)+3],dp2[(1<<20)+3];\nint tor[19][N],tol[19][N],len[19],dep;\nvoid maxn(int &x,int y){y>x? x=y:0;}\nint mxr[N];//左侧覆盖i，右侧最多覆盖多少个城市\nint main(){\n    scanf(\"%d%d\",&n,&v);x[0]=-2e9,x[n+1]=2e9;\n    for(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n    for(len[0]=v;len[dep]!=0;dep++) len[dep+1]=len[dep]/2;\n    dep++;\n    for(int d=0;d<dep;d++){\n        tol[d][0]=n,tor[d][n+1]=n;\n        for(int i=1;i<=n;i++) tol[d][i]=(x[i]-x[i-1]<=len[d])? tol[d][i-1]:n+1-i;\n        for(int i=n;i>=1;i--) tor[d][i]=(x[i+1]-x[i]<=len[d])? tor[d][i+1]:i;\n    }\n    \n    for(int i=0;i<(1<<dep);i+=2)\n        for(int j=1;j<dep;j++)\n            if((i&(1<<j))==0)\n                maxn( dp1[i|(1<<j)], tor[j][dp1[i]+1] ),\n                maxn( dp2[i|(1<<j)], tol[j][n-dp2[i]] );\n    \n    memset(mxr,0xc0,sizeof(mxr));\n    for(int i=0,j=((1<<dep)-1)^1;j>=0;i+=2,j-=2)\n        maxn( mxr[dp1[i]], dp2[j] );\n    for(int i=n;i>=1;i--) maxn( mxr[i], mxr[i+1] );\n    for(int i=1;i<=n;i++)\n        if(mxr[n-tol[0][i]] + tor[0][i] >= n) puts(\"Possible\");\n        else puts(\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=2E5+5;\n\nint N,M,V;\nint a[Maxn];\nint F[Maxn],G[Maxn];\nint L[20][Maxn],R[20][Maxn];\nint nxt[Maxn];\n\ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n\nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tsort(a+1,a+N+1);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N; R[i][N+1]=N+1;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1) MAX(F[i],R[M-j][F[i-(1<<j)]+1]);\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1) MIN(G[i],L[M-j][G[i-(1<<j)]-1]);\n\t}\n\tfor(int i=0;i<(1<<M);++i)\n\t\tMAX(nxt[L[0][max(G[((1<<M)-1)^i]-1,0)]],R[0][F[i]+1]);\n\tfor(int i=1;i<=N;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[i]>=i)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<cmath>\n#include<functional>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nvoid sort(int &a,int &b)\n{\n\tif(a>b)\n\t\tswap(a,b);\n}\nvoid open(const char *s)\n{\n#ifndef ONLINE_JUDGE\n\tchar str[100];\n\tsprintf(str,\"%s.in\",s);\n\tfreopen(str,\"r\",stdin);\n\tsprintf(str,\"%s.out\",s);\n\tfreopen(str,\"w\",stdout);\n#endif\n}\nint rd()\n{\n\tint s=0,c;\n\twhile((c=getchar())<'0'||c>'9');\n\tdo\n\t{\n\t\ts=s*10+c-'0';\n\t}\n\twhile((c=getchar())>='0'&&c<='9');\n\treturn s;\n}\nint upmin(int &a,int b)\n{\n\tif(b<a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint upmax(int &a,int b)\n{\n\tif(b>a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint v[200010];\nint f[1<<20];\nint g[1<<20];\nint l[20][200010];\nint r[20][200020];\nint a[200010];\nint b[200010];\nint main()\n{\n//\topen(\"agc012e\");\n\tint n;\n\tscanf(\"%d%d\",&n,&v[1]);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tint t=1;\n\twhile(1)\n\t{\n\t\tv[t+1]=v[t]/2;\n\t\tt++;\n\t\tif(!v[t])\n\t\t\tbreak;\n\t}\n\tfor(i=1;i<=t;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j==1||a[j]-a[j-1]>v[i])\n\t\t\t\tl[i][j]=j;\n\t\t\telse\n\t\t\t\tl[i][j]=l[i][j-1];\n\t\tfor(j=n;j>=1;j--)\n\t\t\tif(j==n||a[j+1]-a[j]>v[i])\n\t\t\t\tr[i][j]=j;\n\t\t\telse\n\t\t\t\tr[i][j]=r[i][j+1];\n\t}\n\tmemset(f,0,sizeof f);\n\tint all=1<<t;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(f[i]==n)\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],f[i]);\n\t\t\t\telse\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],r[j][f[i]+1]);\n\t\t\t}\n\tfor(i=0;i<all;i++)\n\t\tg[i]=n+1;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(g[i]==1)\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],g[i]);\n\t\t\t\telse\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],l[j][g[i]-1]);\n\t\t\t}\n\tif(f[all-2]>=n)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t\tprintf(\"Possible\\n\");\n\t\treturn 0;\n\t}\n\tfor(i=0;i<all;i++)\n\t\tif(!(i&1)&&(f[i]+r[1][f[i]+1]>=n||g[(all-1)^i^1]<=f[i]+r[1][f[i]+1]+1))\n\t\t\tb[f[i]+1]=1;\n\tint last=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(b[i])\n\t\t\tlast=i;\n\t\tif(l[1][i]<=last||(i<=r[1][1]&&r[1][1]>g[all-2]))\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n \n#define iter(i, n) forw(i, 1, n)\n#define iter0(i, n) for (int i = 0; i < n; ++i)\n#define iter_r(i, n) for (int i = n; i >= 1; --i)\n#define forw(i, a, b) for (int i = a; i <= b; ++i)\n \n#define NR 201000\n \nbool mark[NR];\nint n, V, x[NR], v[20], pre[NR][20], suc[NR][20], l, f[301000], g[301000];\n \nint main() {\n\tscanf(\"%d%d\", &n, &V);\n\tfor (; V > 0; V = V / 2) v[l++] = V; v[l++] = 0;\n\titer(i, n) scanf(\"%d\", &x[i]);\n\t\n\titer0(i, l) suc[n][i] = n, pre[1][i] = 1;\n\tforw(i, 2, n) iter0(k, l) pre[i][k] = (x[i] - x[i - 1] <= v[k] ? pre[i - 1][k] : i);\n\titer_r(i, n - 1) iter0(k, l) suc[i][k] = (x[i + 1] - x[i] <= v[k] ? suc[i + 1][k] : i);\n \n \n \n\tint M = 1 << l;\n\titer0(s, M) g[s] = n + 1;\n\titer0(s, M) {\n\t\t//printf(\": %d %d %d\\n\", s, f[s], g[s]);\n\t\titer0(i, l) if (!(s >> i & 1)) {\n\t\t\tf[s ^ (1 << i)] = max(f[s ^ (1 << i)], f[s] == n ? n : suc[f[s] + 1][i]);\n\t\t\tg[s ^ (1 << i)] = min(g[s ^ (1 << i)], g[s] == 1 ? 1 : pre[g[s] - 1][i]);\n\t\t}\n\t}\n \n\tbool all = false;\n\titer0(s, M) if (!(s & 1)) {\n\t\tint t = M - 1 - s - 1;\n\t\tint l = f[s], r = g[t];\n\t\t//printf(\"!%d %d %d\\n\", l, r, suc[l+1][0]);\n \n\t\tif (l + 1 >= r) all = true;\n\t\telse if (suc[l + 1][0] >= r - 1) mark[l + 1] = true;\n\t}\n \n\tif (all) iter(i, n) mark[i] = true;\n \n\tint r = 0;\n\titer(i, n) {\n\t\tif (mark[i]) r = suc[i][0];\n\t\tputs(i <= r ? \"Possible\" : \"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define dep(i,a,b) for(int i=a;i>=b;i--)\n#define ll long long\n#define mem(x,num) memset(x,num,sizeof x)\n#define reg(x) for(int i=last[x];i;i=e[i].next)\nusing namespace std;\ninline ll read(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n//**********head by yjjr**********\nconst int maxn=2e5+6;\nint n,v,tot=-1,bin[26],R[26][maxn],num[26],f1[maxn<<2],f2[maxn<<2],a[maxn];\nint main()\n{\n\tn=read(),v=read();bin[0]=1;\n\trep(i,1,20)bin[i]=bin[i-1]<<1;\n\trep(i,1,n)a[i]=read();int x=v*2;\n\twhile(x){\n\t\tx>>=1,tot++;\n\t\trep(i,1,n-1){\n\t\t\tif(a[i+1]-a[i]<=x)continue;\n\t\t\tR[tot][++num[tot]]=i;\n\t\t}\n\t\tR[tot][++num[tot]]=n;\n\t}\n\tif(num[0]>tot+1){\n\t\trep(i,1,n)puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\trep(s,0,bin[tot]-1)f2[s]=n+1;\n\trep(s,0,bin[tot]-1)\n        rep(i,1,tot){\n            if(s&bin[i-1])continue;\n            f1[s|bin[i-1]]=max(f1[s|bin[i-1]],*upper_bound(R[i]+1,R[i]+num[i]+1,f1[s]));\n            f2[s|bin[i-1]]=min(f2[s|bin[i-1]],R[i][lower_bound(R[i]+1,R[i]+num[i]+1,f2[s]-1)-R[i]-1]+1);\n        }\n\trep(i,1,num[0]){\n        bool flag=0;\n        rep(s,0,bin[tot]-1)\n            if(f1[s]>=R[0][i-1]&&f2[bin[tot]-1-s]<=R[0][i]+1){flag=1;break;}\n        rep(j,R[0][i-1]+1,R[0][i]){\n\t\t\tif(flag)puts(\"Possible\");else puts(\"Impossible\");\n\t\t}\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define ins insert\n#define pii pair<int,int>\n#define fs first\n#define sc second\n#define mpr make_pair\n#define iter iterator\n#define all(X) X.begin(),X.end()\n#define sau(X) sort(all(X)),X.resize(unique(all(X))-X.begin())\n#define exist(X,ele) binary_search(all(X),ele)\n\ntemplate<typename T1,typename T2>\nostream& operator << (ostream& out,const pair<T1,T2>& X)\n{\n\tout<<\"{\"<<X.fs<<\",\"<<X.sc<<\"}\";\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& out,const vector<T>& X)\n{\n\tfor(auto i:X) out<<i<<\" \";\n\treturn out;\n}\n\ninline void cmin(int& x,int y)\n{\n\tx=min(x,y);\n}\n\ninline void cmax(int& x,int y)\n{\n\tx=max(x,y);\n}\n\nconst int inf=5000000000000000ll;\n\nint N,V;\nvector<int> a;\nint p[20][200010];\nint nxt[20][200010][2];\nbool ans[200010];\nint cnt=0;\n\ninline string t(int x)\n{\n\tstring res=\"\";\n\tfor(int i=0;i<=5;i++)\n\t{\n\t\tres+=(bool)(x&(1<<i))+'0';\n\t}\n\treturn res;\n}\n\nvector<int> dpL,dpR;\n\ninline void solveL()\n{\n\tint U=(1<<(cnt+1))-2;\n\tdpL.resize(U+1,-1);\n\tdpL[0]=0;\n\tfor(int msk=0;msk<=U;msk++)\n\t{\n\t\tif(dpL[msk]==-1) continue;\n\t\tfor(int j=0;j<=cnt;j++)\n\t\t{\n\t\t\tif(!(msk&(1<<j)))\n\t\t\t{\n\t\t\t\tcmax(dpL[msk|(1<<j)],dpL[msk]);\n\t\t\t\tcmax(dpL[msk|(1<<j)],nxt[j][dpL[msk]][0]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void solveR()\n{\n\tint U=(1<<(cnt+1))-2;\n\tdpR.resize(U+1,-1);\n\tdpR[0]=N-1;\n\tfor(int msk=0;msk<=U;msk++)\n\t{\n\t\tif(dpR[msk]==-1) continue;\n\t\tfor(int j=0;j<=cnt;j++)\n\t\t{\n\t\t\tif(!(msk&(1<<j)))\n\t\t\t{\n\t\t\t\tcmin(dpR[msk|(1<<j)],dpR[msk]);\n\t\t\t\tcmin(dpR[msk|(1<<j)],nxt[j][dpL[msk]][1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline bool getL(int R,int U)\n{\n\treturn dpL[U]>R;\n}\n\ninline bool getR(int L,int U)\n{\n\treturn dpR[U]<L;\n}\n\nmain()\n{\n\tios::sync_with_stdio(false);\n\t\n\tcin>>N>>V;\n\tfor(int i=0,x;i<N;i++)\n\t{\n\t\tcin>>x;\n\t\ta.pb(x);\n\t}\n\tfor(int i=0,v=V,lv=-1;v!=lv;i++,lv=v,v/=2)\n\t{\n\t\tfor(int j=1;j<N;j++)\n\t\t{\n\t\t\tp[i][j]=p[i][j-1];\n\t\t\tif(a[j]-a[j-1]>v) p[i][j]++;\n\t\t}\n\t\tcnt++;\n\t}\n\tfor(int i=0,v=V,lv=-1;v!=lv;i++,lv=v,v/=2)\n\t{\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(j && p[i][j]==p[i][j-1])\n\t\t\t{\n\t\t\t\tnxt[i][j][0]=nxt[i][j-1][0];\n\t\t\t\tnxt[i][j][1]=nxt[i][j-1][1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int k=j;k<=N;k++)\n\t\t\t{\n\t\t\t\tif(k==N || p[i][k]!=p[i][j])\n\t\t\t\t{\n\t\t\t\t\tnxt[i][j][0]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=j;k>=-1;k--)\n\t\t\t{\n\t\t\t\tif(k==-1 || p[i][k]!=p[i][j])\n\t\t\t\t{\n\t\t\t\t\tnxt[i][j][1]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tnxt[i][j][0]=(upper_bound(p[i],p[i]+N,p[i][j])-p[i]);   // [j, )\n//\t\t\tnxt[i][j][1]=(lower_bound(p[i],p[i]+N,p[i][j])-p[i])-1; // ( ,j]\n\t\t}\n//\t\tcout<<\"D=\"<<i<<endl;\n//\t\tfor(int j=0;j<N;j++) cout<<nxt[i][j][0]<<\" \"; cout<<endl;\n//\t\tfor(int j=0;j<N;j++) cout<<nxt[i][j][1]<<\" \"; cout<<endl;\n\t}\n\tsolveL();\n\tsolveR();\n\tfor(int i=0;i<N;i++)\n\t{\n//\t\tcout<<\"StartPos=\"<<i<<endl;\n\t\tif(i!=0 && nxt[0][i][0]==nxt[0][i-1][0])\n\t\t{\n\t\t\tans[i]=ans[i-1];\n\t\t\tcontinue;\n\t\t}\n\t\tans[i]=false;\n\t\tint U=(1<<(cnt+1))-2; \n\t\tfor(int mskL=0;mskL<=U;mskL+=2)\n\t\t{\n\t\t\tint mskR=U^mskL;\n\t\t\tif(nxt[0][i][1]<0 && mskL) continue;\n\t\t\tif(nxt[0][i][0]>=N && mskR) continue;\n\t\t\tif(nxt[0][i][1]>=0 && nxt[0][i][0]<N && ((!mskL)||(!mskR)) ) continue;\n\t\t\tbool ok=true;\n\t\t\tif(nxt[0][i][1]>=0) ok&=getL(nxt[0][i][1],mskL);\n\t\t\tif(nxt[0][i][0]<N) ok&=getR(nxt[0][i][0],mskR);\n\t\t\tans[i]|=ok;\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(ans[i]) cout<<\"Possible\"<<endl;\n\t\telse cout<<\"Impossible\"<<endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 200010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,V,cnt;\n\nint x[maxn];\n\nint v[20];\n\nint l[20][maxn],r[20][maxn];\n\nint mn[1<<20],mx[1<<20];\n\nint f[maxn];\n\nvoid Work(){\n\tREP(j,1,cnt){\n\t\tl[j][0]=1;r[j][n+1]=n;\n\t\tl[j][1]=1;REP(i,2,n)l[j][i]=x[i]-x[i-1]<=v[j]?l[j][i-1]:i;\n\t\tr[j][n]=n;RREP(i,n-1,1)r[j][i]=x[i+1]-x[i]<=v[j]?r[j][i+1]:i;\n\t}\n\tREP(sta,0,(1<<cnt)-1)mn[sta]=n+1;\n\tREP(sta,1,(1<<cnt)-1)\n\t\tREP(i,0,cnt-1)if((sta>>i)&1){\n\t\t\tmx[sta]=max(mx[sta],r[i+1][mx[sta^(1<<i)]+1]);\n\t\t\tmn[sta]=min(mn[sta],l[i+1][mn[sta^(1<<i)]-1]);\n\t\t}\n\tREP(i,0,n+1)f[i]=n+2;\n//\tREP(sta,0,(1<<cnt)-1)cout<<sta<<' '<<mx[sta]<<' '<<mn[((1<<cnt)-2)^sta]<<endl;\n\tREP(sta,0,(1<<cnt)-1)if(!(sta&1))f[mx[sta]]=min(f[mx[sta]],mn[((1<<cnt)-2)^sta]);\n//\tREP(i,0,n)cout<<f[i]<<' ';cout<<endl;\n\tRREP(i,n,0)f[i]=min(f[i],f[i+1]);\n\tREP(i,1,n){\n\t\tif(f[l[1][i]-1]<=r[1][i]+1)puts(\"Possible\");else puts(\"Impossible\");\n\t}\n}\n\nvoid Init(){\n\tread(n,V);\n\tREP(i,1,n)read(x[i]);\n\tfor(;;){\n\t\tv[++cnt]=V;\n\t\tif(!V)break;\n\t\tV>>=1;\n\t}\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk make_pair\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=1e5+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,t,v,len[20],p[MAXN],Fl[1<<17],Fr[1<<17],pl[20][MAXN],pr[20][MAXN],S,a[MAXN];\nvector<int>L[20],R[20];\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),v=read(),t=log2(v)+1,S=(1<<t)-1;\n\tRep(i,1,n)p[i]=read();\n\tRep(i,0,t){\n\t\tif(i)len[i]=len[i-1]/2;else len[i]=v;\n\t\tfor(int l=1,r;l<=n;l=r+1){\n\t\t\tr=l;for(;r<n&&p[r+1]-p[r]<=len[i];r++);\n\t\t\tRep(j,l,r)pl[i][j]=l,pr[i][j]=r;L[i].pb(l),R[i].pb(r);\n\t\t}\n\t}\n\tRep(sta,0,S)Fr[sta]=n+1;\n\tRep(i,1,t)Fl[1<<i-1]=(*R[i].begin()),Fr[1<<i-1]=(*--L[i].end());\n\tRep(sta,1,S)Rep(j,1,t)if(~sta>>(j-1)&1){\n\t\tint t=sta|(1<<j-1),pos=upper_bound(L[j].begin(),L[j].end(),Fl[sta]+1)-L[j].begin()-1;\n\t\tFl[t]=max(Fl[t],R[j][pos]);\n\t\tpos=lower_bound(R[j].begin(),R[j].end(),Fr[sta]-1)-R[j].begin();\n\t\tFr[t]=min(Fr[t],L[j][pos]);\n\t}\n\tRep(s,0,S){\n\t\tint ed=upper_bound(L[0].begin(),L[0].end(),Fl[s]+1)-L[0].begin()-1,st=lower_bound(R[0].begin(),R[0].end(),Fr[S^s]-1)-R[0].begin();\n\t\tif(st<=ed)a[st]++,a[ed+1]--;\n\t}\n\tfor(int i=0;i<L[0].size();i++){\n\t\ta[i]+=a[i-1];\n\t\tRep(j,L[0][i],R[0][i])puts(a[i]?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=200000;\nconst int MAXLG=17;\n\nint n,initcap;\nint x[MAXN];\nint prv[MAXN][MAXLG+2];\nint nxt[MAXN][MAXLG+2];\n\nint dpr[1<<(MAXLG+2)];\nint dpl[1<<(MAXLG+2)];\nint d[MAXN+1];\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&initcap);\n\tREP(i,n) scanf(\"%d\",&x[i]);\n\n\tint nstep=1; while((initcap>>(nstep-1))!=0) ++nstep;\n\n\tREP(k,nstep) {\n\t\tfor(int at=0,to=at;at<n;at=to) {\n\t\t\twhile(to<n&&(at==to||x[to]-x[to-1]<=(initcap>>k))) ++to;\n\t\t\tFOR(i,at,to) nxt[i][k]=to;\n\t\t}\n\t\tfor(int at=n-1,to=at;at>=0;at=to) {\n\t\t\twhile(to>=0&&(at==to||x[to+1]-x[to]<=(initcap>>k))) --to;\n\t\t\tFORE(i,to+1,at) prv[i][k]=to;\n\t\t}\n\t}\n\tmemset(dpr,0,sizeof(dpr));\n\tREP(i,1<<nstep) REP(j,nstep) if((i&(1<<j))==0) dpr[i|(1<<j)]=max(dpr[i|(1<<j)],dpr[i]==n?n:nxt[dpr[i]][j]);\n\tREP(i,1<<nstep) dpl[i]=n-1;\n\tREP(i,1<<nstep) REP(j,nstep) if((i&(1<<j))==0) dpl[i|(1<<j)]=min(dpl[i|(1<<j)],dpl[i]==-1?-1:prv[dpl[i]][j]);\n\n\t//REP(i,1<<nstep) printf(\"r%x = %d\\n\",i,dpr[i]);\n\t//REP(i,1<<nstep) printf(\"l%x = %d\\n\",i,dpl[i]);\n\n\tREPE(i,n) d[i]=0;\n\tREP(i,1<<nstep) {\n\t\tif(i&1) continue;\n\t\tint l=dpr[i],r=dpl[(1<<nstep)-1-i-(1<<0)]+1;\n\t\tif(l==n) { d[0]++; d[n]--; }\n\t\telse if(nxt[l][0]>=r) { d[prv[l][0]+1]++; d[nxt[l][0]]--; }\n\t}\n\tREP(i,n) d[i+1]+=d[i];\n\tREP(i,n) printf(\"%s\\n\",d[i]>0?\"Possible\":\"Impossible\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define P(x) cout << x << endl\n#define D(x) P(#x << \": \" << x)\n#define F(i,n) for (int i=0; i<(int)(n); i++)\n#define DEC(i,n) for (int i=(int)(n); --i>=0;)\n#define pb push_back\n#define all(v) v.begin(), v.end()\nusing namespace std;\nvoid MI(int &a, int v) {a = min(a,v);}\nvoid MA(int &a, int v) {a = max(a,v);}\nconst int N=2e5, L=18, PL=1<<L;\n\nint l,n,v,pl;\ndeque<int> len;\n\nvoid gen(int x[], int nxt[][N], int reach[]) {\n    F(k,l) {\n        int cur=0;\n        F(i,n+1) {\n            if (i == n || (i-1 >= 0 && abs(x[i] - x[i-1]) > len[k])) {\n                while (cur < i) {\n                    nxt[k][cur] = i;\n                    cur++;\n                }\n            }\n        }\n    }\n    F(mask,pl) {\n        reach[mask] = 0;\n        F(k,l) if (mask & 1<<k)\n            MA(reach[mask], nxt[k][reach[mask-(1<<k)]]);\n    }\n}\n\nvoid print(int nxt[][N]) {\n    F(k,l) {\n        cout<<len[k]<<\": \";\n        F(i,n) cout<<nxt[k][i]<<\" \\n\"[i==n-1];\n    }\n}\n\nint x[N], rev[N];\nint nxt[L][N], pre[L][N], rLeft[PL], rRight[PL];\nbool ok[N];\n\nsigned main() {\n    cin>>n>>v;\n    F(i,n) cin>>x[i], rev[n-1-i] = x[i], ok[i] = false;\n    len = {v};\n    int cur = v;\n    while (cur) cur/=2, len.push_front(cur);\n    l = len.size();\n    pl = 1<<l;\n    gen(x, nxt, rLeft);\n    gen(rev, pre, rRight);\n    //P(\"nxt:\"); print(nxt);\n    //P(\"pre:\"); print(pre);\n    //F(k,pl) cout<<bitset<3>(k)<<\":\"<<rLeft[k]<<\" \\n\"[k==pl-1];\n    int start = pl/2;\n    int cnt[n+1];\n    F(i,n+1) cnt[i] = 0;\n    F(mleft,start) {\n        int le = rLeft[mleft], ri = n - rRight[start-1-mleft];\n        int ll = n-pre[l-1][n-ri], rr = nxt[l-1][le];\n        if (ll < rr) {\n            cnt[ll]++;\n            cnt[rr]--;\n        }\n    }\n    cur = 0;\n    F(i,n) {\n        cur += cnt[i];\n        P((cur > 0 ? \"Possible\" : \"Impossible\"));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<vector>\n#define N 220005\nusing namespace std;\nvector<int> G[N];\nint n,m,v,a[N],r[21][N],f[1<<21],g[1<<21],ufs[21][N];\nint find(int op,int x){ return ufs[op][x] ? ufs[op][x]=find(op,ufs[op][x]) : x;}\nint main()\n{\n\tint i,j,x,p,y,T;\n\tscanf(\"%d %d\",&n,&v);\n\tfor(i=v,m=0;i;i>>=1,m++);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(i=0;i<=m;i++){\n\t\tfor(j=1;j<=n;j++) r[i][j]=j;\n\t\tfor(j=1;j<n;j++)\n\t\t\tif(a[j+1]-a[j]<=(v>>i))\n\t\t\t\tx=find(i,j),ufs[i][j+1]=x,r[i][x]=j+1;\n\t  }\n\tfor(i=1;i<(1<<m);i++)\n\t\tfor(j=0;j<m;j++)\n\t\t\tif((i>>j)&1){\n\t\t\t\tx=r[j+1][find(j+1,f[i^(1<<j)]+1)];\n\t\t\t\tf[i]=max(f[i],x);\n\t\t\t  }\n\tfor(i=0;i<(1<<m);i++) g[i]=n+1;\n\tfor(i=1;i<(1<<m);i++)\n\t\tfor(j=0;j<m;j++)\n\t\t\tif((i>>j)&1){\n\t\t\t\tx=find(j+1,g[i^(1<<j)]-1);\n\t\t\t\tg[i]=min(g[i],x);\n\t\t\t  }\n\tT=(1<<m)-1,p=0,y=-100;\n\tfor(i=0;i<=T;i++)\n\t\tG[g[T^i]].push_back(f[i]);\n\tfor(i=1;i<=n;i++){\n\t\tx=find(0,i);\n\t\twhile(p<=r[0][x]+1){\n\t\t\tfor(j=0;j<G[p].size();j++)\n\t\t\t\ty=max(y,G[p][j]);\n\t\t\tp++;\n\t\t  }\n\t\tif(y<x-1) printf(\"Impossible\\n\");\n\t\telse printf(\"Possible\\n\");\n\t  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int L = 20, N = 201010;\n\nint n, V, x[N], fa[L][N], siz[L][N], ans[N], lt[1 << L], rt[1 << L];\nvector<int> v[N];\n\nint Find(int k, int x) {\n  return fa[k][x] == x ? x : fa[k][x] = Find(k, fa[k][x]);\n}\n\nvoid Merge(int k, int x, int y) {\n  x = Find(k, x), y = Find(k, y);\n  fa[k][y] = x;\n  siz[k][x] += siz[k][y];\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &V);\n  for(int i = 1; i <= n; i++)\n    scanf(\"%d\", &x[i]);\n  int now = V, m;\n  for(int o = L - 1; ; now >>= 1, o = (o + 1) % L) {\n    for(int i = 1; i <= n; i++)\n      fa[o][i] = i, siz[o][i] = 1;\n    for(int i = 1; i <= n; i++) {\n      int j = i;\n      while(j < n && x[j + 1] - x[j] <= now) j++;\n      for(int k = i + 1; k <= j; k++)\n\tMerge(o, i, k);\n      i = j;\n    }\n    if(now == 0) { m = o + 1; break; }\n  }\n\n  for(int i = 0; i < (1 << m); i++)\n    rt[i] = n + 1;\n  for(int i = 0; i < (1 << m); i++) {\n    for(int j = 0; j < m; j++)\n      if(~i >> j & 1) {\n\tlt[i | (1 << j)] = max(lt[i | (1 << j)], lt[i] + siz[j][lt[i] + 1]);\n\trt[i | (1 << j)] = min(rt[i | (1 << j)], Find(j, rt[i] - 1));\n      }\n  }\n  // cerr << lt[27]  <<\" \" << rt[4] << endl;\n\n  int all = (1 << m) - 1; \n  for(int i = 0; i < (1 << m); i++) {\n    v[lt[i]].push_back(rt[all ^ i]);\n    //    cerr << lt[i] << \" \" << rt[all ^ i] << endl;\n  }\n\n  int mi = n + 2;\n  for(int i = 0; i < v[n].size(); i++)\n    mi = min(v[n][i], mi);\n  \n  for(int i = n; i >= 1; i--) {\n    for(int j = 0; j < v[i - 1].size(); j++)\n      mi = min(v[i - 1][j], mi);\n    if(fa[L - 1][i] != i) continue;\n    //cerr << i + siz[L - 1][i] << endl;\n    ans[i] = mi <= i + siz[L - 1][i];\n  }\n  \n  for(int i = 1; i <= n; i++)\n    puts(ans[Find(L - 1, i)] ? \"Possible\" : \"Impossible\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pb2 pop_back\n#define pf push_front\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define rep(k,i,j) for(int k = (int)i;k<(int) j;k++)\n#define repd(k,i,j) for(int k = i;k>=(int)j;k--)\n#define ll long long\n#define pq priority_queue\n\nint dirx[8] = {0,1,0,-1,1,1,-1,-1};\nint diry[8] = {1,0,-1,0,1,-1,1,-1};\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e16;\nconst double EPS = 1e-6;\n\nusing namespace std;\n\nconst int maxn = 3e5+5;\n\nint n,v;\nint loc[maxn];\n\nint jump[maxn][20],m;\n\nint dp[maxn];\n\nint ch[maxn];\n\nint in_q[maxn];\n\nqueue<int> q;\nint solve(){\n\tmemset(dp,-1,sizeof dp);\n\tmemset(in_q,0,sizeof in_q);\n\t\n\tq.push(1);\n\tdp[1] = 0;\n\tin_q[1] = 1;\n\t\n\twhile(q.size()){\n\t\tint mask = q.front();\n\t\tint a = ch[dp[mask]];\n\t\t\n\t\tq.pop();\n\t\tin_q[mask] = 0;\n\t\t\n\t\tif(a==n)return 1;\n\t\trep(k,0,m)if(((1<<k)&mask)==0){\n\t\t\tint b = ch[jump[a][k]];\n\t\t\tint maskb = (mask|(1<<k));\n\t\t\t\n\t\t\tif(dp[maskb]<b){\n\t\t\t\tdp[maskb] = b;\n\t\t\t\tif(!in_q[maskb])q.push(maskb),in_q[maskb] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\t\n\trep(k,0,n)scanf(\"%d\",&loc[k]);\n\t\n\t\n\tfor(;v>=0;v/=2){\n\t\trep(k,0,n){\n\t\t\tint i = k;\n\t\t\twhile(i<n){\n\t\t\t\tif(i<n-1 && loc[i+1]-loc[i]<=v){\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\twhile(k<=i)jump[k++][m] = i+1;\n\t\t\tk = i;\n\t\t}\n\t\t\n\t\tm++;\n\t\tif(v==0)break;\n\t}\n\t\n\trep(k,0,m){\n\t\t//rep(i,0,n)printf(\"%d \",jump[i][k]);line;\n\t\t\n\t}\n\trep(k,0,maxn)ch[k] = k;\n\t\n\tint hit = 0;\n\trep(k,0,n){\n\t\tif(hit>18){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint nxt = jump[k][0];\n\t\t\n\t\thit++;\n\t\tch[k] = nxt;\n\t\tint ret = solve();\n\t\tch[k] = k;\n\t\t\n\t\twhile(k<nxt)printf(\"%s\\n\",ret?\"Possible\":\"Impossible\"),k++;\n\t\tk = nxt-1;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200005,M=20;\nint cnt,ans[N],n,m,x[N],a[M],tot,le[M][N],ri[M][N],dp1[1<<M],dp2[1<<M];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&x[i]);\n\twhile (m){\n\t\ta[++tot]=m;\n\t\tm/=2;\n\t}\n\treverse(a+1,a+tot+1);\n\tfor (int i=0;i<=tot;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (j==1||x[j]-x[j-1]>a[i])le[i][j]=j;\n\t\t\telse le[i][j]=le[i][j-1];\n\tfor (int i=0;i<=tot;i++)\n\t\tfor (int j=n;j;j--)\n\t\t\tif (j==n||x[j+1]-x[j]>a[i])ri[i][j]=j;\n\t\t\telse ri[i][j]=ri[i][j+1];\n\tfor (int i=1;i<1<<tot;i++)\n\t\tfor (int j=0;j<tot;j++)\n\t\t\tif (i&(1<<j)){\n\t\t\t\tint t=dp1[i^(1<<j)];\n\t\t\t\tif (t==n)dp1[i]=n;\n\t\t\t\telse dp1[i]=max(dp1[i],ri[j][t+1]);\n\t\t\t}\n\tfor (int i=0;i<1<<tot;i++)dp2[i]=n+1;\n\tfor (int i=1;i<1<<tot;i++)\n\t\tfor (int j=0;j<tot;j++)\n\t\t\tif (i&(1<<j)){\n\t\t\t\tint t=dp2[i^(1<<j)];\n\t\t\t\tif (t==1)dp2[i]=1;\n\t\t\t\telse dp2[i]=min(dp2[i],le[j][t-1]);\n\t\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (ans[le[tot][i]]){\n\t\t\tif (ans[le[tot][i]]==1)puts(\"Possible\");\n\t\t\telse puts(\"Impossible\");\n\t\t}\n\t\telse {\n\t\t\tcnt++;\n\t\t\tif (cnt>20){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[le[tot][i]]=2;\n\t\t\tfor (int j=0;j<1<<tot;j++)\n\t\t\t\tif (dp1[j]>=le[tot][i]-1&&dp2[((1<<tot)-1)^j]<=ri[tot][i]+1)ans[le[tot][i]]=1;\n\t\t\tif (ans[le[tot][i]]==1)puts(\"Possible\");\n\t\t\telse puts(\"Impossible\");\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][20],tmp[30][20];\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return 1;\n\t\tr[i]=t[i];\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define stt static\n#define rg register\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n#define y1 substitute_of_y1\n#define DEBUG(x) cerr<<#x\" = \"<<x<<endl;\nusing namespace std;\n\ntemplate<typename T> il T rd(){\n\tT nmb=0;int sgn=0;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-')sgn=1;chr=getchar();}\n\twhile(isdigit(chr)){nmb=(nmb<<3)+(nmb<<1)+chr-'0';chr=getchar();}\n\treturn sgn?-nmb:nmb;\n}\ntemplate<typename T> void wt(T nmb){\n\tif(nmb>9)wt(nmb/10);\n\tputchar(nmb%10+'0');\n}\ntemplate<typename T> il void cmax(T &x,T y){x=x>y?x:y;}\ntemplate<typename T> il void cmin(T &x,T y){x=x<y?x:y;}\ninline void proc_status(){\n\tifstream t (\"/proc/self/status\");\n\tcerr<<string(istreambuf_iterator<char>(t),istreambuf_iterator<char>())<<endl;\n\t/*freopen(\"/proc/self/status\",\"r\",stdin);\n\tchar ch[100];\n\twhile(scanf(\"%s\",ch)!=EOF)cerr<<ch<<endl;*/\n}\n\nconst int N=2e5+10,L=20;\n\nint a[N];\n\nvector<pii>vec[L];\n\n#define lowbit(x) (x&(-x))\n\nint f[N],g[N];\n\nint ans[N],b[N];\n\nint main(){\n\tint n=rd<int>(),p=rd<int>();\n\tfor(int i=1;i<=n;++i)a[i]=rd<int>();\n\tint lev=1;\n\tint Flg=0;\n\tfor(int k=p;!Flg;k>>=1,++lev){\n\t\tif(!k)Flg=1;\n\t\tfor(int l=1,r=1;l<=n;l=r+1){\n\t\t\tr=l;\n\t\t\twhile(r<n&&a[r+1]-a[r]<=k)++r;\n\t\t\tvec[lev].pb(mp(l,r));\n\t\t}\n\t}\n\tlev-=2;\n\tint k=(1<<lev)-1;\n\tfor(int S=0;S<=k;++S)f[S]=0,g[S]=n+1;\n\tfor(int S=0;S<=k;++S){\n\t\tfor(int T=S;T;T^=lowbit(T)){\n\t\t\tint t=(int)log2(lowbit(T))+2;\n\t\t\tint U=S^lowbit(T);\n\t\t\tint pos=upper_bound(vec[t].begin(),vec[t].end(),mp(f[U]+1,n+1))-vec[t].begin()-1;\n\t\t\tcmax(f[S],f[U]);\n\t\t\tif(pos>=0)cmax(f[S],vec[t][pos].snd);\n\t\t\tpos=upper_bound(vec[t].begin(),vec[t].end(),mp(g[U]-1,n+1))-vec[t].begin()-1;\n\t\t\tcmin(g[S],g[U]);\n\t\t\tif(pos>=0&&vec[t][pos].snd>=g[U]-1)cmin(g[S],vec[t][pos].fst);\n\t\t}\n\t}\n\tfor(int S=0;S<=k;++S){\n\t\tint l=f[S],r=g[k^S];\n\t\tif(l>=r){\n\t\t\tfor(int i=1;i<=n;++i)puts(\"Possible\");\n\t\t\treturn 0;\n\t\t}\n\t\tint pos1=upper_bound(vec[1].begin(),vec[1].end(),mp(l+1,n+1))-vec[1].begin()-1;\n\t\tint pos2=upper_bound(vec[1].begin(),vec[1].end(),mp(r-1,n+1))-vec[1].begin()-1;\n\t\tif(vec[1][pos2].snd<r-1)++pos2;\n\t\tif(pos1==pos2)b[pos1]=1;\n\t}\n\tfor(int i=0;i<(int)vec[1].size();++i)\n\t\tfor(int t=vec[1][i].fst;t<=vec[1][i].snd;++t)\n\t\t\tans[t]=b[i];\n\tfor(int i=1;i<=n;++i)\n\t\tif(ans[i])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\n\nint kano()\n{\n\tchar ch=getchar();int w=0,u=1;\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')u=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())w=w*10+ch-'0';\n\treturn w*u;\n}\nint n,v,o,u,mx;\nint a[200005];\nint p[21][200005],r[21][200005];\nint f[2][262145];\nbool bo[200005];\nint main()\n{\n\tn=kano();v=kano();\n\tfor(int i=1;i<=n;i++)a[i]=kano();\n\tfor(o=v,u=0;o>0;o=o>>1,u++)\n\t{\n\t\tint la=1;p[u][1]=1;r[u][1]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]-a[i-1]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tmx=1<<u;mx--; \n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tif(f[0][i]>n)f[0][i]=n;\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tf[0][i|j]=max(f[0][i|j],p[l][r[l][f[0][i]+1]]);\n\t\t}\n\t}\n\tfor(o=v>>1,u=1;o>0;o=o>>1,u++)\n\t{\n\t\tint la=n;p[u][n]=n;r[u][n]=n;\n\t\tfor(int i=n-1;i>=1;i--)\n\t\t{\n\t\t\tif(a[i+1]-a[i]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tfor(int i=0;i<=mx;i++)f[1][i]=n+1;\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tif(f[1][i]<1)f[1][i]=1;\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tf[1][i|j]=min(f[1][i|j],p[l][r[l][f[1][i]-1]]);\n\n\t\t}\n\t}\n\tr[0][0]=r[0][1];\n\tr[0][n+1]=r[0][n];\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tint j=~i&mx;\n\t\tif(r[0][f[0][i]+1]==r[0][f[1][j]-1])bo[r[0][f[0][i]+1]]=1;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(bo[r[0][i]])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\nint maxL[20][200005], maxR[20][200005];\nint p_L, p_R;\nint dpL[(1<<20)], dpR[(1<<20)]; // dpL prefix, dpR suffix\nint N, V;\nll x[200005];\nint BIT[200005]; // indexes are reversed\nint parts[200005];\nvector <pii> dp_range;\n\nint calc_dpL(int mask) {\n\tif (mask == 0) return 0;\n\tint &ret = dpL[mask];\n\tint tmp;\n\tif (ret != -1) return ret;\n\tret = 0;\n\tfor (int i=0;i<20;++i) {\n\t\tif (mask&(1<<i)) {\n\t\t\tif (calc_dpL(mask - (1<<i)) == N) ret = N;\n\t\t\telse {\n\t\t\t\ttmp = calc_dpL(mask-(1<<i));\n\t\t\t\ttmp = maxR[i][tmp] - tmp + 1;\n\t\t\t\tret = max(ret,tmp + calc_dpL(mask-(1<<i)));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint calc_dpR(int mask) {\n\t//cout << mask << endl;\n\tif (mask == 0) return 0;\n\tint &ret = dpR[mask];\n\tint tmp;\n\tif (ret != -1) return ret;\n\tret = 0;\n\tfor (int i=0;i<20;++i) {\n\t\tif (mask&(1<<i)) {\n\t\t\tif (calc_dpR(mask - (1<<i)) == N) ret = N;\n\t\t\telse {\n\t\t\t\ttmp = (N-1) - calc_dpR(mask-(1<<i));\n\t\t\t\ttmp = tmp - maxL[i][tmp] + 1;\n\t\t\t\tret = max(ret,tmp + calc_dpR(mask-(1<<i)));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool cmp(pii a, pii b) {\n\treturn a.se < b.se;\n}\n\nint BIT_q(int u) {\n\t++u;\n\tint ret = -1;\n\twhile (u) {\n\t\tret=max(ret,BIT[u]);\n\t\tu-=u&(-u);\n\t}\n\treturn ret;\n}\n\nvoid BIT_u(int u,int val) {\n\t++u;\n\tfor (;u<200005;u+=u&(-u)) BIT[u]=max(BIT[u],val);\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tmemset(dpL,-1,sizeof(dpL));\n\tmemset(dpR,-1,sizeof(dpR));\n\tmemset(BIT,-1,sizeof(BIT));\n\tparts[0]=1;\n\tfor (int i=1;i<200005;++i) {\n\t\tparts[i] = 1+parts[i>>1];\n\t}\n\tcin >> N >> V;\n\tfor (int i=0;i<N;++i)\n\t\tcin >> x[i];\n\tfor (int i=0;i<20;++i) {\n\t\tfor (int j=N;j>=0;--j) {\n\t\t\tmaxR[i][j]=j;\n\t\t\tif ( j+1 < N && x[j+1]-x[j] <= (V>>i) ) maxR[i][j] = maxR[i][j+1];\n\t\t}\n\t}\n\tfor (int i=0;i<20;++i) {\n\t\tfor (int j=0;j<=N;++j) {\n\t\t\tmaxL[i][j]=j;\n\t\t\tif ( j-1 >= 0 && x[j]-x[j-1] <= (V>>i) ) maxL[i][j] = maxL[i][j-1];\n\t\t}\n\t}\n\tint mask_r;\n\tfor (int mask_l=0;mask_l<(1<<parts[V]);mask_l+=2) {\n\t\tmask_r = ((1<<parts[V]) - 1) - mask_l - 1;\n\t\tdp_range.push_back(make_pair(calc_dpL(mask_l),calc_dpR(mask_r)));\n\t}\n\tsort(dp_range.begin(), dp_range.end(), cmp);\n\tfor (int i=0;i<(int)dp_range.size();++i) {\n\t\tBIT_u(N - dp_range[i].fi,dp_range[i].se);\n\t}\n\tfor (int i=0;i<N;++i) {\n\t\tp_L = maxL[0][i];\n\t\tp_R = maxR[0][i];\n\t\tif (BIT_q(N - p_L) >= N-(p_R+1)) cout << \"Possible\\n\";\n\t\telse cout << \"Impossible\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=200010,SH=19,SN=1<<SH,INF=0x7f7f7f7f;\nint tol[N][SH],tor[N][SH];\nint fl[SN],fr[SN];\nint x[N],v[N];\nint ext[N];\nint main(){\n\tint n=ni,vs=0;\n\tv[0]=ni;\n\tfor(int &i=vs;v[i];i++){\n\t\tv[i+1]=v[i]>>1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tx[i]=ni;\n\t}\n\tfor(int j=0;j<=vs;j++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ttol[i][j]=i>1&&x[i]-x[i-1]<=v[j]?tol[i-1][j]:i;\n\t\t}\n\t\tfor(int i=n;i>=1;i--){\n\t\t\ttor[i][j]=i<n&&x[i+1]-x[i]<=v[j]?tor[i+1][j]:i;\n\t\t}\n\t}\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tfl[s]=0;\n\t\tfor(int i=1;i<=vs;i++){\n\t\t\tif((s>>(i-1))&1){\n\t\t\t\tapmax(fl[s],tor[fl[s^(1<<(i-1))]+1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tfr[s]=n+1;\n\t\tfor(int i=1;i<=vs;i++){\n\t\t\tif((s>>(i-1))&1){\n\t\t\t\tapmin(fr[s],tol[fr[s^(1<<(i-1))]-1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(ext,127,sizeof(ext));\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tapmin(ext[fl[s]],fr[s^(ts-1)]);\n\t}\n\tfor(int i=n;i>=1;i--){\n\t\tapmin(ext[i-1],ext[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tputs(ext[tol[i][0]-1]<=tor[i][0]+1?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,v;\nint x[100010];\nvector<pair<int,int> >tot;\nvector<pair<int,int> >seg[20];\nint fl[1<<20],fr[1<<20];\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint j=i;\n\t\twhile(j+1<=n && x[j+1]-x[j]<=v)j++;\n\t\ttot.push_back(make_pair(i,j));\n\t\ti=j;\n\t}\n\tif((int)tot.size()>20)\n\t{\n\t\tfor(int i=1;i<=n;i++)puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tv/=2;\n\tint k;\n\tfor(k=0;;k++,v/=2)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint j=i;\n\t\t\twhile(j+1<=n && x[j+1]-x[j]<=v)j++;\n\t\t\tseg[k].push_back(make_pair(i,j));\n\t\t\ti=j;\n\t\t}\n\t\tsort(seg[k].begin(),seg[k].end());\n\t\tif(!v)break;\n\t}\n\tk++;\n\tfor(int i=0;i<(1<<k);i++)fr[i]=n+1;\n\tfor(int i=0;i<(1<<k);i++)\n\t{\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tif(i>>j&1)continue;\n\t\t\tint pl=lower_bound(seg[j].begin(),seg[j].end(),make_pair(fl[i]+2,0))-seg[j].begin();\n\t\t\tfl[i|(1<<j)]=max(fl[i|(1<<j)],fl[i]);\n\t\t\tif(pl)fl[i|(1<<j)]=max(fl[i|(1<<j)],seg[j][pl-1].second);\n\t\t\tint pr=lower_bound(seg[j].begin(),seg[j].end(),make_pair(fr[i],0))-seg[j].begin();\n\t\t\tfr[i|(1<<j)]=min(fr[i|(1<<j)],fr[i]);\n\t\t\tif(pr)fr[i|(1<<j)]=min(fr[i|(1<<j)],seg[j][pr-1].first);\n\t\t}\n\t}\n\tfor(int i=0;i<(int)tot.size();i++)\n\t{\n\t\tbool ok=false;\n\t\tfor(int j=0;j<(1<<k);j++)\n\t\t{\n\t\t\tif(fl[j]>=tot[i].first-1 && fr[((1<<k)-1)^j]<=tot[i].second+1)\n\t\t\t{\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=tot[i].first;j<=tot[i].second;j++)puts(ok?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ntemplate <class T>\ninline void relax(T &a, const T &b)\n{\n\tif (b > a)\n\t\ta = b;\n}\ntemplate <class T>\ninline void tense(T &a, const T &b)\n{\n\tif (b < a)\n\t\ta = b;\n}\n\nconst int MaxN = 200000;\nconst int MaxM = 200000;\nconst int MaxNF = 18;\n\nint n, m;\nint a[MaxN + 1];\n\nint nF = 0;\nint d[MaxNF + 1];\n\nint f[1 << MaxNF], vl[MaxN + 1][MaxNF + 1];\nint g[1 << MaxNF], vr[MaxN + 1][MaxNF + 1];\n\nint h[MaxN + 1];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcin >> a[i];\n\n\twhile (1 << nF <= m)\n\t\t++nF;\n\tfor (int i = nF; i >= 0; --i)\n\t\td[i] = m, m >>= 1;\n\n\tfor (int i = 0; i <= nF; ++i)\n\t\tvl[0][i] = 0, vr[n + 1][i] = n + 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j <= nF; ++j)\n\t\t\tvl[i][j] = a[i] - a[i - 1] <= d[j] ? vl[i - 1][j] : i - 1;\n\tfor (int i = n; i; --i)\n\t\tfor (int j = 0; j <= nF; ++j)\n\t\t\tvr[i][j] = a[i + 1] - a[i] <= d[j] ? vr[i + 1][j] : i + 1;\n\n\tfor (int s = 0; s < 1 << nF; ++s)\n\t{\n\t\tf[s] = 1, g[s] = n;\n\t\tfor (int i = 0; i < nF; ++i)\n\t\t{\n\t\t\tif (~s >> i & 1)\n\t\t\t\tcontinue;\n\t\t\trelax(f[s], vr[f[s ^ 1 << i]][i]);\n\t\t\ttense(g[s], vl[g[s ^ 1 << i]][i]);\n\t\t}\n\t}\n\n\tfor (int s = 0; s < 1 << nF; ++s)\n\t\trelax(h[g[s]], f[s ^ ((1 << nF) - 1)]);\n\tfor (int i = 1; i <= n; ++i)\n\t\trelax(h[i], h[i - 1]);\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tputs(h[vr[i][nF] - 1] > vl[i][nF] ? \"Possible\" : \"Impossible\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 200200;\nconst int MAXK = 20;\n\nint a[MAX];\nint l[MAX][MAXK], r[MAX][MAXK];\nint fl[1 << MAXK], fr[1 << MAXK];\n\nint main(void) {\n  ios_base::sync_with_stdio(false);\n\n  int N, V;\n  cin >> N >> V;\n  REP(i, N) cin >> a[i];\n\n  int K = 0;\n  int v[MAXK];\n  while (V > 0) {\n    v[K++] = V;\n    V /= 2;\n  }\n  v[K++] = 0;\n\n  REP(i, N) {\n    REP(j, K) {\n      if (i > 0 && a[i] - a[i - 1] <= v[j]) {\n        l[i][j] = l[i - 1][j];\n      } else {\n        l[i][j] = i;\n      }\n    }\n  }\n\n  for (int i = N - 1; i >= 0; --i) {\n    REP(j, K) {\n      if (i < N - 1 && a[i + 1] - a[i] <= v[j]) {\n        r[i][j] = r[i + 1][j];\n      } else {\n        r[i][j] = i;\n      }\n    }\n  }\n\n  REP(s, 1 << K) fl[s] = 0, fr[s] = N - 1;\n  REP(s, 1 << K) {\n    REP(j, K) {\n      if (!(s & (1 << j))) {\n        int ns = s | (1 << j);\n        int nfl = fl[s] == N ? N : r[fl[s]][j] + 1;\n        fl[ns] = max(fl[ns], nfl);\n        int nfr = fr[s] == -1 ? -1 : l[fr[s]][j] - 1;\n        fr[ns] = min(fr[ns], nfr);\n      }\n    }\n  }\n\n  REP(i, N) {\n    bool can = false;\n\n    int all = (1 << K) - 1 - 1;\n    REP(s, 1 << K) {\n      if ((s & all) == s) {\n        if (fl[s] >= l[i][0] && fr[all ^ s] <= r[i][0]) {\n          can = true;\n          break;\n        }\n      }\n    }\n    if (can) {\n      cout << \"Possible\\n\";\n    } else {\n      cout << \"Impossible\\n\";\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 400010;\nconst int M = 21;\n\nint a[N], v[N], dppre[1 << M], dpsuf[1 << M], pre[M][N], suf[M][N], ans[N];\nint n, V, m;\n\nint main(){\n\tscanf(\"%d%d\", &n, &V);\n\tv[0] = V;\n\tfor (int i = 1; ; ++ i){\n\t\tv[i] = v[i - 1] >> 1;\n\t\tif (!v[i]){\n\t\t\tm = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++ i){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 0; i < m; ++ i){\n\t\tpre[i][n - 1] = n - 1;\n\t\tfor (int j = n - 2; j >= 0; -- j){\n\t\t\tif (a[j + 1] - a[j] <= v[i]){\n\t\t\t\tpre[i][j] = pre[i][j + 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpre[i][j] = j;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; ++ i){\n\t\tsuf[i][0] = 0;\n\t\tfor (int j = 0; j < n - 1; ++ j){\n\t\t\tif (a[j + 1] - a[j] <= v[i]){\n\t\t\t\tsuf[i][j + 1] = suf[i][j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsuf[i][j + 1] = j + 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dppre, -1, sizeof(dppre));\n\tfor (int i = 0; i < 1 << m; ++ i){\n\t\tdpsuf[i] = n;\n\t}\n\tfor (int i = 0; i < 1 << m - 1; ++ i){\n\t\tint x = dppre[i];\n\t\tfor (int j = 0; j < m - 1; ++ j){\n\t\t\tif (i >> j & 1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint &y = dppre[i | 1 << j];\n\t\t\tif (x == n - 1){\n\t\t\t\ty = n - 1;\n\t\t\t}\n\t\t\ty = std::max(y, pre[j + 1][x + 1]);\n\t\t}\n\t\tx = dpsuf[i];\n\t\tfor (int j = 0; j < m - 1; ++ j){\n\t\t\tif (i >> j & 1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint &y = dpsuf[i | 1 << j];\n\t\t\tif (!x){\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t\ty = std::min(y, suf[j + 1][x - 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < 1 << m - 1; ++ i){\n\t\tint j = (1 << m - 1) - i - 1;\n\t\tint x = dppre[i] + 1, y = dpsuf[j] - 1;\n\t\tif (x >= y){\n\t\t\t++ ans[0];\n\t\t\t-- ans[n];\n\t\t}\n\t\tif (pre[0][x] >= y){\n\t\t\t++ ans[suf[0][x]];\n\t\t\t-- ans[pre[0][y] + 1];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++ i){\n\t\tans[i + 1] += ans[i];\n\t\tprintf(ans[i] ? \"Possible\\n\" : \"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define stt static\n#define rg register\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n#define y1 substitute_of_y1\n#define DEBUG(x) cerr<<#x\" = \"<<x<<endl;\nusing namespace std;\n\ntemplate<typename T> il T rd(){\n\tT nmb=0;int sgn=0;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-')sgn=1;chr=getchar();}\n\twhile(isdigit(chr)){nmb=(nmb<<3)+(nmb<<1)+chr-'0';chr=getchar();}\n\treturn sgn?-nmb:nmb;\n}\ntemplate<typename T> void wt(T nmb){\n\tif(nmb>9)wt(nmb/10);\n\tputchar(nmb%10+'0');\n}\ntemplate<typename T> il void cmax(T &x,T y){x=x>y?x:y;}\ntemplate<typename T> il void cmin(T &x,T y){x=x<y?x:y;}\ninline void proc_status(){\n\tifstream t (\"/proc/self/status\");\n\tcerr<<string(istreambuf_iterator<char>(t),istreambuf_iterator<char>())<<endl;\n\t/*freopen(\"/proc/self/status\",\"r\",stdin);\n\tchar ch[100];\n\twhile(scanf(\"%s\",ch)!=EOF)cerr<<ch<<endl;*/\n}\n\nconst int N=2e5+10,L=20;\n\nint a[N];\n\nvector<pii>vec[L];\n\n#define lowbit(x) (x&(-x))\n\nint f[N],g[N];\n\nint ans[N],b[N];\n\nint main(){\n\tint n=rd<int>(),p=rd<int>();\n\tfor(int i=1;i<=n;++i)a[i]=rd<int>();\n\tint lev=1;\n\tint Flg=0;\n\tfor(int k=p;!Flg;k>>=1,++lev){\n\t\tif(!k)Flg=1;\n\t\tfor(int l=1,r=1;l<=n;l=r+1){\n\t\t\tr=l;\n\t\t\twhile(r<n&&a[r+1]-a[r]<=k)++r;\n\t\t\tvec[lev].pb(mp(l,r));\n\t\t}\n\t}\n\tlev-=2;\n\tint k=(1<<lev)-1;\n\tfor(int S=0;S<=k;++S)f[S]=0,g[S]=n+1;\n\tfor(int S=0;S<=k;++S){\n\t\tfor(int T=S;T;T^=lowbit(T)){\n\t\t\tint t=(int)log2(lowbit(T))+2;\n\t\t\tint U=S^lowbit(T);\n\t\t\tint pos=upper_bound(vec[t].begin(),vec[t].end(),mp(f[U]+1,n+1))-vec[t].begin()-1;\n\t\t\tcmax(f[S],f[U]);\n\t\t\tif(pos>=0)cmax(f[S],vec[t][pos].snd);\n\t\t\tpos=upper_bound(vec[t].begin(),vec[t].end(),mp(g[U]-1,n+1))-vec[t].begin()-1;\n\t\t\tcmin(g[S],g[U]);\n\t\t\tif(pos>=0&&vec[t][pos].snd>=g[U]-1)cmin(g[S],vec[t][pos].fst);\n\t\t}\n\t}\n\tfor(int S=0;S<=k;++S){\n\t\tint l=f[S],r=g[k^S];\n\t\tint pos1=upper_bound(vec[1].begin(),vec[1].end(),mp(l+1,n+1))-vec[1].begin()-1;\n\t\tint pos2=upper_bound(vec[1].begin(),vec[1].end(),mp(r-1,n+1))-vec[1].begin()-1;\n\t\tif(vec[1][pos2].snd<r-1)++pos2;\n\t\tif(pos1>=0&&pos2>=0&&pos1==pos2)b[pos1]=1;\n\t}\n\tfor(int i=0;i<(int)vec[1].size();++i)\n\t\tfor(int t=vec[1][i].fst;t<=vec[1][i].snd;++t)\n\t\t\tans[t]=b[i];\n\tfor(int i=1;i<=n;++i)\n\t\tif(ans[i])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define K 20\nint n,m,v,a[N],l[N][K],r[N][K],f[N],g[N],h[N];\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();v=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n\twhile (true){\n\t\tl[1][m]=1;r[n][m]=n;\n\t\tl[0][m]=1;r[n+1][m]=n;\n\t\tfor (int i=2;i<=n;i++)\n\t\t\tl[i][m]=(a[i]-a[i-1]<=v)?l[i-1][m]:i;\n\t\tfor (int i=n-1;i>=1;i--)\n\t\t\tr[i][m]=(a[i+1]-a[i]<=v)?r[i+1][m]:i;\n\t\tm++;if (!v) break;v/=2;\n\t}\n\tfill(g,g+(1<<m),n+1);\n\tfor (int i=2;i<(1<<m);i+=2)\n\t\tfor (int j=1;j<m;j++)\n\t\t\tif (i&(1<<j))\n\t\t\tf[i]=max(f[i],r[f[i-(1<<j)]+1][j]),\n\t\t\tg[i]=min(g[i],l[g[i-(1<<j)]-1][j]);\n\tfill(h,h+n+1,0x3fffffff);\n\tfor (int i=0;i<(1<<m);i+=2)\n\t\th[f[i]]=min(h[f[i]],g[(1<<m)-2-i]);\n\tfor (int i=n-1;i>=0;i--)\n\t\th[i]=min(h[i],h[i+1]);\n\tfor (int i=1;i<=n;i++)\n\t\tprintf((h[l[i][0]-1]<=r[i][0]+1)?\"Possible\\n\":\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int K = 19;\nconst int N = 1 << (K - 1);\nint n, m;\n\nstruct Item\n{\n    int l, r;\n    int lx, rx;\n\n    Item() : l(), r(), lx(), rx() {}\n    Item(int _l, int _r, int _lx, int _rx) : l(_l), r(_r), lx(_lx), rx(_rx) {}\n};\n\nvector<Item> a[K];\npii b[N];\nvector<vector<int> > dpMasks[K];\nbool dp[N];\nvector<int> pref[N], suf[N];\nbool ans[N];\n\nvoid solve(int k, int p)\n{\n    if (k == 0)\n    {\n        dpMasks[k][p].push_back(1);\n        return;\n    }\n    if (a[k][p].r - a[k][p].l >= k + 1)\n    {\n        dpMasks[k][p].push_back(1 << k);\n        return;\n    }\n    for (int mask = 0; mask < (1 << k); mask++)\n        dp[mask] = 1;\n    for (int id = a[k][p].l; id <= a[k][p].r; id++)\n    {\n        vector<int> cur;\n        for (int mask = 0; mask < (1 << k); mask++)\n        {\n            if (!dp[mask]) continue;\n            bool good = true;\n            for (int i = 0; i < k; i++)\n            {\n                if (((mask >> i) & 1) && dp[mask ^ (1 << i)])\n                {\n                    good = false;\n                    break;\n                }\n            }\n            if (good)\n                cur.push_back(mask);\n        }\n        for (int mask = 0; mask < (1 << k); mask++)\n            dp[mask] = 0;\n        solve(k - 1, id);\n        for (int mask1 : cur)\n            for (int mask2 : dpMasks[k - 1][id])\n                if ((mask1 & mask2) == 0)\n                    dp[mask1 | mask2] = 1;\n        for (int mask = 0; mask < (1 << k); mask++)\n        {\n            if (!dp[mask]) continue;\n            for (int i = 0; i < k; i++)\n                dp[mask | (1 << i)] = 1;\n        }\n    }\n    dpMasks[k][p].push_back(1 << k);\n    for (int mask = 0; mask < (1 << k); mask++)\n    {\n        if (!dp[mask]) continue;\n        bool good = true;\n        for (int i = 0; i < k; i++)\n        {\n            if (((mask >> i) & 1) && dp[mask ^ (1 << i)])\n            {\n                good = false;\n                break;\n            }\n        }\n        if (good)\n            dpMasks[k][p].push_back(mask);\n    }\n    return;\n}\n\nvoid markGood(int k, int p)\n{\n    if (k == 0)\n    {\n        ans[b[p].second] = 1;\n        return;\n    }\n    for (int i = a[k][p].l; i <= a[k][p].r; i++)\n        markGood(k - 1, i);\n    return;\n}\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &b[i].first);\n        b[i].second = i;\n    }\n    sort(b, b + n);\n    for (int i = 0; i < n; i++)\n        a[0].push_back(Item(-1, -1, b[i].first, b[i].first));\n    for (int k = 0; k < K - 1; k++)\n    {\n        int len = m >> (K - 2 - k);\n        int l = 0;\n        while(l < (int)a[k].size())\n        {\n            int r = l + 1;\n            while(r < (int)a[k].size() && a[k][r - 1].rx + len >= a[k][r].lx) r++;\n            a[k + 1].push_back(Item(l, r - 1, a[k][l].lx, a[k][r - 1].rx));\n            l = r;\n        }\n    }\n\n    if (a[K - 1].size() > K)\n    {\n        for (int i = 0; i < n; i++)\n            printf(\"Impossible\\n\");\n        return 0;\n    }\n\n    for (int k = 0; k < K; k++)\n    {\n        dpMasks[k].resize(a[k].size());\n        for (int i = 0; i < (int)dpMasks[k].size(); i++)\n            dpMasks[k][i] = vector<int>();\n    }\n\n    for (int i = 0; i < (int)a[K - 1].size(); i++)\n        solve(K - 1, i);\n\n    //cerr << \"here\" << endl;\n\n    pref[0].push_back(0);\n    for (int p = 0; p < (int)a[K - 1].size(); p++)\n    {\n        for (int mask = 0; mask < (1 << (K - 1)); mask++)\n            dp[mask] = 0;\n        for (int mask1 : pref[p])\n            for (int mask2 : dpMasks[K - 1][p])\n            {\n                if ((mask1 & mask2) == 0 && (mask1 | mask2) < (1 << (K - 1)))\n                    dp[mask1 | mask2] = 1;\n            }\n        for (int mask = 0; mask < (1 << (K - 1)); mask++)\n        {\n            if (!dp[mask]) continue;\n            for (int i = 0; i < K - 1; i++)\n                dp[mask | (1 << i)] = 1;\n        }\n        for (int mask = 0; mask < (1 << (K - 1)); mask++)\n        {\n            if (!dp[mask]) continue;\n            bool good = 1;\n            for (int i = 0; i < K - 1; i++)\n            {\n                if (((mask >> i) & 1) && dp[mask ^ (1 << i)])\n                {\n                    good = false;\n                    break;\n                }\n            }\n            if (good)\n                pref[p + 1].push_back(mask);\n        }\n    }\n    suf[(int)a[K - 1].size()].push_back(0);\n    for (int p = (int)a[K - 1].size() - 1; p >= 0; p--)\n    {\n        for (int mask = 0; mask < (1 << (K - 1)); mask++)\n            dp[mask] = 0;\n        for (int mask1 : suf[p + 1])\n            for (int mask2 : dpMasks[K - 1][p])\n            {\n                if ((mask1 & mask2) == 0 && (mask1 | mask2) < (1 << (K - 1)))\n                    dp[mask1 | mask2] = 1;\n            }\n        for (int mask = 0; mask < (1 << (K - 1)); mask++)\n        {\n            if (!dp[mask]) continue;\n            for (int i = 0; i < K - 1; i++)\n                dp[mask | (1 << i)] = 1;\n        }\n        for (int mask = 0; mask < (1 << (K - 1)); mask++)\n        {\n            if (!dp[mask]) continue;\n            bool good = 1;\n            for (int i = 0; i < K - 1; i++)\n            {\n                if (((mask >> i) & 1) && dp[mask ^ (1 << i)])\n                {\n                    good = false;\n                    break;\n                }\n            }\n            if (good)\n                suf[p].push_back(mask);\n        }\n    }\n\n    for (int p = 0; p < (int)a[K - 1].size(); p++)\n    {\n        bool good = false;\n        for (int mask1 : pref[p])\n            for (int mask2 : suf[p + 1])\n                if ((mask1 & mask2) == 0)\n                    good = true;\n        if (good)\n            markGood(K - 1, p);\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        if (ans[i])\n            printf(\"Possible\\n\");\n        else\n            printf(\"Impossible\\n\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long \n#define  maxn 300005\n#define pb push_back\n#define forup(i,a,b) for(int i=(a);i<=(b);i++)  \n#define fordown(i,a,b) for(int i=(a);i>=(b);i--)\n#define INF 1000000007\nint N;\nint V[30],Rmost[maxn][30],Lmost[maxn][30];\nint dpL[1<<20],dpR[1<<20];\nint arr[maxn];\nint dp[maxn];\nint main()\n{  cin>>N; cin>>V[0];\n  forup(i,1,N) scanf(\"%d\",&arr[i]);\n int M=1;\n while(V[M-1])\n   { V[M]=V[M-1]/2;\n     M++; \n   }\n  for(int i=0;i<M;i++)\n   { int v=V[i];\n     int j=1;\n      while(j<=N)\n       { int k=j+1; \n         while(k<=N&&arr[k]-arr[k-1]<=v)  k++;\n         for(int x=j;x<k;x++) Rmost[x][i]=k-1;\n       j=k;\n       }\n   j=N;\n     while(j>=1)\n      {int k=j-1;\n      while(k>=1&&arr[k+1]-arr[k]<=v) k--;\n      for(int x=j;x>k;x--)  Lmost[x][i]=k+1; \n      j=k;\n      }\n    }\n    for(int i=0;i<(1<<M);i++) dpR[i]=N+1;\n    for(int i=1;i<(1<<M);i++)\n     {  for(int j=0;j<M;j++)\n         if(i&(1<<j))\n         {int L=dpL[i^(1<<j)];\n          dpL[i]=max(dpL[i],Rmost[L+1][j]);\n\n          int R=dpR[i^(1<<j)];\n          dpR[i]=min(dpR[i],Lmost[R-1][j]); \n         } \n     } \n    forup(i,0,N+1)  dp[i]=-INF;\n    for(int i=0;i<(1<<M);i+=2)\n      {int j=((1<<M)-1)^i^1;\n        dp[dpR[j]]=max(dp[dpR[j]],dpL[i]);\n      }\n     forup(i,1,N+1)\n      dp[i]=max(dp[i],dp[i-1]);\n     forup(i,1,N)\n     {int L=Lmost[i][0],R=Rmost[i][0];\n      int det=dp[R+1];\n      if(det>=L-1)   puts(\"Possible\");\n      else           puts(\"Impossible\");\n     }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MN 200005\n#define MM (1<<18)\n#define ML 18\nusing namespace std;\ninline int in(){\n    int x=0;bool f=0; char c;\n    for (;(c=getchar())<'0'||c>'9';f=c=='-');\n    for (x=c-'0';(c=getchar())>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0');\n    return f?-x:x;\n}\nint L[ML][MN],R[ML][MN],f[MM],g[MM],x[MN];\nbool vis[MM];\nint n,v,j,val;\nint main()\n{\n\tn=in();v=in();\n\tfor (int i=1;i<=n;++i) x[i]=in();\n\tfor (j=0,val=v;;val>>=1,++j){\n\t\tL[j][0]=L[j][1]=1;\n\t\tR[j][n]=R[j][n+1]=n;\n\t\tfor (int i=2;i<=n;++i)\n\t\tif (x[i]-x[i-1]>val) L[j][i]=i;else L[j][i]=L[j][i-1];\n\t\tfor (int i=n-1;i;--i)\n\t\tif (x[i+1]-x[i]>val) R[j][i]=i;else R[j][i]=R[j][i+1];\n\t\tif (!val) break;\n\t}for (int i=0;i<(1<<j);++i) f[i]=0,g[i]=n+1;\n\tfor (int i=0;i<(1<<j);++i){\n\t\tfor (int k=0;k<j;++k) if (!(i&(1<<k))){\n\t\t\tf[(i|(1<<k))]=max(f[i|(1<<k)],R[k+1][f[i]+1]);\n\t\t\tg[(i|(1<<k))]=min(g[i|(1<<k)],L[k+1][g[i]-1]);\n\t\t}\n\t}\n\tfor (int i=0;i<(1<<j);++i)\n\tif (R[0][f[i]+1]>=g[((1<<j)-1)^i]-1) vis[R[0][f[i]+1]]=1;\n\tfor (int i=1;i<=n;++i) puts(vis[R[0][i]]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n    using namespace std;\n\n    const int Nmax = 1e6;\n    int n, k, V, i, a[Nmax], lg[Nmax], dp1[Nmax], go1[22][Nmax], dp2[Nmax], go2[22][Nmax], nr[Nmax];\n\n    void compute()\n    {\n        int l, i, j, ind;\n        for(l=0; l<k; ++l)\n        {\n            go1[l][n+1] = n;\n            go2[l][0] = 1;\n\n            for(i=1; i<=n; ++i)\n            {\n                for(j = i; j+1<=n && a[j+1] - a[j] <= lg[l]; ++j);\n                for(ind = i; ind <= j; ++ind)\n                    go1[l][ind] = j;\n\n                i = j;\n            }\n\n            for(i=n; i; --i)\n            {\n                for(j = i; j-1>=1 && a[j] - a[j-1] <= lg[l]; --j);\n                for(ind = i; ind >= j; --ind)\n                    go2[l][ind] = j;\n\n                i = j;\n            }\n        }\n    }\n\n    void dinamique()\n    {\n        int i, j;\n        dp1[0] = 0, dp2[0] = n+1;\n        for(i=1; i<(1<<k); ++i)\n        {\n            dp1[i] = 1;\n            dp2[i] = n;\n\n            for(j=0; j<k; ++j)\n                if(i&(1<<j))\n                {\n                    dp1[i] = max(dp1[i], go1[j][ dp1[i^(1<<j)] + 1 ]);\n                    dp2[i] = min(dp2[i], go2[j][ dp2[i^(1<<j)] - 1 ]);\n                }\n        }\n    }\n\n    void solve()\n    {\n        int i, j, ind, mask = (1<<k) - 1;\n        bool ok;\n\n        for(i=0; i<=n+1; ++i) nr[i] = -1;\n\n        for(i=0; i<=mask; ++i)\n            nr[dp2[i]] = max(nr[dp2[i]], dp1[mask^i]);\n\n        for(i=1; i<=n+1; ++i)\n            nr[i] = max(nr[i], nr[i-1]);\n\n        for(i=1; i<=n; ++i)\n        {\n            for(j = i; j+1<=n && a[j+1] - a[j] <= V; ++j);\n            ok = (nr[j+1] >= i-1);\n\n            for(ind = i; ind <= j; ++ind)\n                printf(\"%s\\n\", ok ? \"Possible\" : \"Impossible\");\n\n            i = j;\n        }\n    }\n\n    int main()\n    {\n        scanf(\"%d%d\", &n, &V);\n        for(i=1; i<=n; ++i) scanf(\"%d\", &a[i]);\n\n        lg[0] = V/2;\n        for(i=1; lg[i-1]; ++i) lg[i] = lg[i-1] / 2;\n        k = i;\n\n        compute();\n        dinamique();\n        solve();\n\n        return 0;\n    }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nint n,v,m,a[200005],len[25],L[200005][25],R[200005][25],f[1000005],g[1000005];\npriority_queue<int> q;\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\twhile(v) len[m++]=v,v>>=1;len[m++]=0;\n\tfor(int i=0;i<m/2;i++) swap(len[i],len[m-i-1]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tL[i][p]=L[i-1][p];\n\t\t\tif(i==1||a[i]-a[i-1]>len[p]) L[i][p]=i;\n\t\t}\n\t}\n\tfor(int i=n;i;i--){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tR[i][p]=R[i+1][p];\n\t\t\tif(i==n||a[i+1]-a[i]>len[p]) R[i][p]=i;\n\t\t}\n\t}\n\tf[0]=0;g[0]=n+1;\n\tfor(int i=1;i<(1<<m);i++){\n\t\tg[i]=n+1;\n\t\tfor(int p=0;p<m;p++) if(i&(1<<p)){\n\t\t\tf[i]=max(f[i],R[f[i^(1<<p)]+1][p]);\n\t\t\tg[i]=min(g[i],L[g[i^(1<<p)]-1][p]);\n\t\t}\n\t}\n\tfor(int i=1;i<(1<<m);i++) f[i]=max(f[i],f[i-1]),g[i]=min(g[i],g[i-1]);\n\tint S=(1<<m-1)-1;\n\tfor(int i=1,pos=0;i<=n;i++){\n\t\twhile(f[pos]>=L[i][m-1]-1&&pos<=S) q.push(S^pos),pos++;\n\t\twhile(!q.empty()&&f[S^q.top()]<L[i][m-1]-1) q.pop();\n\t\tif(q.empty()){\n\t\t\tputs(\"Impossible\");continue;\n\t\t}\n\t\tif(g[q.top()]>R[i][m-1]+1) puts(\"Impossible\");\n\t\telse puts(\"Possible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint x[200000];\nint l[200000][20];\nint r[200000][20];\nint dp1[1 << 20];\nint dp2[1 << 20];\n\nint main() {\n    int n, v, p = 0, c = 0, f = 0, i, j;\n    \n    scanf(\"%d %d\", &n, &v);\n    \n    for (i = 0; i < n; i++) scanf(\"%d\", &x[i]);\n    \n    for (i = 0; ; i++) {\n        if ((1 << i) > v) {\n            p = i + 1;\n            \n            break;\n        }\n    }\n    \n    for (i = 0; i < n; i++) {\n        int nv = v;\n        \n        for (j = 0; j < p; j++) {\n            if (i == 0 || x[i] - x[i - 1] > nv) {\n                l[i][j] = i;\n            } else {\n                l[i][j] = l[i - 1][j];\n            }\n            \n            nv /= 2;\n        }\n    }\n    \n    for (i = n - 1; i >= 0; i--) {\n        int nv = v;\n        \n        for (j = 0; j < p; j++) {\n            if (i == n - 1 || x[i + 1] - x[i] > nv) {\n                r[i][j] = i;\n            } else {\n                r[i][j] = r[i + 1][j];\n            }\n            \n            nv /= 2;\n        }\n    }\n    \n    for (i = 0; i < (1 << p); i++) {\n        if (i & 1) continue;\n        \n        for (j = 1; j < p; j++) {\n            if ((i >> j) & 1) continue;\n            \n            if (dp1[i] == n) {\n                dp1[i | (1 << j)] = n;\n            } else {\n                dp1[i | (1 << j)] = max(dp1[i | (1 << j)], r[dp1[i]][j] + 1);\n            }\n        }\n    }\n    \n    for (i = 0; i < (1 << p); i++) dp2[i] = n - 1;\n    \n    for (i = 0; i < (1 << p); i++) {\n        if (i & 1) continue;\n        \n        for (j = 1; j < p; j++) {\n            if ((i >> j) & 1) continue;\n            \n            if (dp2[i] == -1) {\n                dp2[i | (1 << j)] = -1;\n            } else {\n                dp2[i | (1 << j)] = min(dp2[i | (1 << j)], l[dp2[i]][j] - 1);\n            }\n        }\n    }\n    \n    for (i = 0; i < n; i++) {\n        if (l[i][0] == i) c++;\n    }\n    \n    if (c > p) {\n        for (i = 0; i < n; i++) puts(\"Impossible\");\n        \n        return 0;\n    }\n    \n    for (i = 0; i < n; i++) {\n        if (l[i][0] == i) {\n            for (j = 0; j < (1 << p); j++) {\n                if (j & 1) continue;\n                \n                if (i > 0 && dp1[j] < i) continue;\n                if (r[i][0] < n - 1 && dp2[(1 << p) - 2 - j] > r[i][0]) continue;\n                \n                break;\n            }\n            \n            if (j < (1 << p)) {\n                f = 1;\n            } else {\n                f = 0;\n            }\n        }\n        \n        if (f == 1) {\n            puts(\"Possible\");\n        } else {\n            puts(\"Impossible\");\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e5 + 100;\nconst int Maxm = 20 + 5;\nconst int Maxs = (1 << 20) + 100;\n\nint N, V, Log;\nint A[Maxn];\n\nint L[Maxm][Maxn], R[Maxm][Maxn];\nint Next[Maxn];\n\ninline void get_seg ()\n{\n\tfor (int i = 0; i <= Log; ++i)\n\t{\n\t\tint v = V >> i;\n//\t\tDEBUG (v);\n\t\tfor (int j = N; j >= 1; --j)\n\t\t{\n\t\t\tint p = upper_bound (A + 1, A + N + 1, A[j] + v) - A - 1;\n\t\t\tNext[j] = 0;\n\t\t\tNext[j] = max (Next[p], j);\n\t\t}\n\t\tfor (int l = 1, r = 0; l <= N; l = r + 1)\n\t\t{\n\t\t\tr = Next[l];\n\t\t\tL[i][++L[i][0]] = l, R[i][++R[i][0]] = r;\n//\t\t\tcout << l << ' ' << r << endl;\n\t\t}\n\t}\n}\n\nint f[Maxs], g[Maxs];\n\ninline void get_f ()\n{\n\tint ALL = (1 << Log) - 1;\n\tf[0] = 1;\n\tfor (int i = 0; i <= ALL; ++i)\n\t{\n\t\tif (!f[i]) continue;\n\t\tint preR = f[i];\n\t\tfor (int j = 1; j <= Log; ++j)\n\t\t{\n\t\t\tif (i & (1 << (j - 1))) continue;\n\t\t\tint x = upper_bound (L[j] + 1, L[j] + L[j][0] + 1, preR + 1) - L[j] - 1;\n\t\t\tint nowR = max (preR, R[j][x]);\n\t\t\tChkmax (f[i | (1 << (j - 1))], nowR);\n\t\t}\n\t}\n}\n\ninline void get_g ()\n{\n\tint ALL = (1 << Log) - 1;\n\tfor (int i = 0; i <= ALL; ++i) g[i] = N + 1;\n\tg[0] = N;\n\tfor (int i = 0; i <= ALL; ++i)\n\t{\n\t\tif (g[i] == N + 1) continue;\n//\t\tcout << i << ' ' << g[i] << endl;\n\t\tint preL = g[i];\n\t\tfor (int j = 1; j <= Log; ++j)\n\t\t{\n\t\t\tif (i & (1 << (j - 1))) continue;\n\t\t\tint x = lower_bound (R[j] + 1, R[j] + R[j][0] + 1, preL - 1) - R[j];\n//\t\t\tfor (int k = 1; k <= R[j][0]; ++k) cout << R[j][k] << ' '; puts(\"\");\n\t\t\tint nowL = min (preL, L[j][x]);\n//\t\t\tcout << nowL << endl;\n//\t\t\tcout << (i | (1 << (j - 1))) << endl;\n\t\t\tChkmin (g[i | (1 << (j - 1))], nowL);\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tget_seg ();\n\tget_f ();\n\tget_g ();\n\n\tif (L[0][0] > Log + 3)\n\t{\n\t\tfor (int i = 1; i <= N; ++i) puts(\"Impossible\");\n\t\treturn ;\n\t}\n\n\tint ALL = (1 << Log) - 1;\n\tfor (int i = 1; i <= L[0][0]; ++i)\n\t{\n\t\tint l = L[0][i], r = R[0][i], fl = 0;\n//\t\tDEBUG (i);\n//\t\tcout << l << ' ' << r << endl;\n\t\tfor (int j = 0; j <= ALL; ++j)\n\t\t\tif (l - 1 <= f[j] && g[ALL ^ j] <= r + 1)\n\t\t\t{\n//\t\t\t\tcout << j << ' ' << f[j] << ' '<< g[ALL ^ j] << endl;\n\t\t\t\tfl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (fl) for (int j = l; j <= r; ++j) puts(\"Possible\");\n\t\telse for (int j = l; j <= r; ++j) puts(\"Impossible\");\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), V = read<int>(), Log = log2(V + 1);\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define MAXN 200010\n#define MAXM 262144\nbool dp[80][MAXM];\nint x[MAXN];\nvoid dfs(int l,int r,int v,int id,int f)\n{\n\tfor(int i=1;i<f;i++)\n\t\tdp[id][i]=0;\n\tif(l==r||v==0)\n\t{\n\t\twhile(f)\n\t\t{\n\t\t\tdp[id][f]=1;\n\t\t\tf>>=1;\n\t\t}\n\t\treturn;\n\t}\n\tint v1=v/2,ls=l,first=1;\n\tfor(int i=l+1;i<=r+1;i++)\n\t\tif(x[i]-x[i-1]>v1||i==r+1)\n\t\t{\n\t\t\tint ed=f>>1;\n\t\t\tdfs(ls,i-1,v1,id+1,ed);\n\t\t\tif(first)\n\t\t\t{\n\t\t\t\tfor(int j=1;j<=ed;j++)\n\t\t\t\t\tif(dp[id+1][j])\n\t\t\t\t\t\tdp[id][j]=1;\n\t\t\t\tfirst=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int j=f-1;j;j--)\n\t\t\t\t\tif(dp[id][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=1;k<=ed;k++)\n\t\t\t\t\t\t\tif(dp[id+1][k]&&(j&k)==0)\n\t\t\t\t\t\t\t\tdp[id][k|j]=1;\n\t\t\t\t\t\tdp[id][j]=0;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tls=i;\n\t\t}\n\tdp[id][f]=1;\n}\nint n,V,tot,flag=1,mx;\nint st[100],se[100];\nbool check(int id)\n{\n\tmemset(dp[tot+1],0,sizeof dp[tot+1]);\n\tbool first=1,ch=0;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tif(i==id) continue;\n\t\tch=0;\n\t\tif(first)\n\t\t{\n\t\t\tfor(int j=1;j<mx;j++)\n\t\t\t\tif(dp[i][j])\n\t\t\t\t\tdp[tot+1][j]=1,ch=1;\n\t\t\tfirst=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=mx-1;j;j--)\n\t\t\t\tif(dp[tot+1][j])\n\t\t\t\t{\n\t\t\t\t\tfor(int k=1;k<mx;k++)\n\t\t\t\t\t\tif(dp[i][k]&&(j&k)==0)\n\t\t\t\t\t\t\tdp[tot+1][j|k]=1,ch=1;\n\t\t\t\t\tdp[tot+1][j]=0;\n\t\t\t\t}\n\t\t}\n\t\tif(ch==0) return 0;\n\t}\n\treturn ch;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&V);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tint tmp=V,cnt=0,ls=1;\n\twhile(tmp)\n\t{\n\t\ttmp>>=1;\n\t\tcnt++;\n\t}\n\tmx=1<<cnt;\n\tx[n+1]=x[n]+V+1;\n\tfor(int i=2;i<=n+1;i++)\n\t\tif(x[i]-x[i-1]>V)\n\t\t{\n\t\t\tdfs(ls,i-1,V,++tot,mx);\n\t\t\tif(tot>cnt+1)\n\t\t\t{\n\t\t\t\tflag=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tst[tot]=ls,se[tot]=i-1;\n\t\t\tls=i;\n\t\t}\n\tif(!flag)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=tot;i++)\n\t\tif(check(i))\n\t\t{\n\t\t\tfor(int j=st[i];j<=se[i];j++)\n\t\t\t\tprintf(\"Possible\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=st[i];j<=se[i];j++)\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define M 20\n#define N 200010\nvector<int> g[M][N];\nll n, V, m;\nll x[N];\n//set<vector<int>> dp[M];\nmap<set<int>, bool> dp[M];\n\nvoid rec(int d, int l, int r){\n\tint l2 = l;\n\t//g[d][l].pb(l);\n\tll V2 = V>>d;\n\tif(V2==0){\n\t\treturn;\n\t}\n\tfor(int u = l; u < r-1; u++){\n\t\tif(x[u+1]-x[u]>V2){\n\t\t\trec(d+1, l, u+1);\n\t\t\tl = u+1;\n\t\t\tg[d][l2].pb(l);\n\t\t}\n\t}\n\trec(d+1, l, r);\n}\n\nbool rec2(int d, set<int> &st){\n\t//cerr<<\"d \"<<d<<\" \"<<(V>>d)<<endl;\n\t//cerr<<\"st\"<<endl;\n\t//for(auto u: st) cerr<<u<<\" \"; cerr<<endl;\n\tif(dp[d].count(st)) return dp[d][st];\n\tif(st.empty()) return true;\n\t//cerr<<st.size()<<\" \"<<m<<\" \"<<d<<endl;\n\tif((int)st.size()>m-d) return false;\n\t/*for(auto u: st){\n\t\tset<int> st2;\n\t\tfor(auto v: st){\n\t\t\tst2.insert(g[d+1][v].begin(), g[d+1][v].end());\n\t\t\tif(rec2(d+1, st2)) return dp[d][st] = true;\n\t\t}\n\t}*/\n\tset<int> st2;\n\tfor(auto v: st){\n\t\tst2.insert(g[d+1][v].begin(), g[d+1][v].end());\n\t\tst2.insert(v);\n\t}\n\t//cerr<<\"st2\"<<endl;\n\t//for(auto v: st2) cerr<<v<<\" \"; cerr<<endl;\n\tif(st2.size()>M) return dp[d][st] = false;\n\tfor(auto u: st2){\n\t\tset<int> st3;\n\t\tfor(auto v: st2){\n\t\t\tif(u!=v) st3.insert(v);\n\t\t}\n\t\tif(rec2(d+1, st3)) return dp[d][st] = true;\n\t}\n\treturn dp[d][st] = false;\n}\n\nint main(){\n\tcin>>n>>V;\n\t{\n\t\tll V2 = V;\n\t\twhile(V2){\n\t\t\tm++;\n\t\t\tV2 /= 2;\n\t\t}\n\t}\n\trep(i, n) cin>>x[i];\n\trec(0, 0, n);\n\tset<int> st;\n\tst.insert(0);\n\tfor(auto u: g[0][0]){\n\t\tst.insert(u);\n\t\t//cerr<<u<<endl;\n\t}\n\tst.insert(n);\n\tfor(auto u: st){\n\t\tif(u==n) break;\n\t\tset<int> st2(st);\n\t\tauto it = st2.upper_bound(u);\n\t\tint u2 = *it;\n\t\t--it;\n\t\tst2.erase(it);\n\t\tit = st2.end();\n\t\t--it;\n\t\tst2.erase(it);\n\t\tbool res = rec2(0, st2);\n\t\trep(i, u2-u) cout<<(res?\"Possible\":\"Impossible\")<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint l[25][530000],r[25][530000],f[500010],g[530000],mi[530000],x[530000];\nint main()\n{\n\tint n,v,lim=0;scanf(\"%d%d\",&n,&v);while (v>>(lim+1)) lim++;lim++;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor (int p=0;p<=lim;p++)\n\t{\n\t\tl[p][0]=1;for (int i=1;i<=n;i++) l[p][i]=(x[i]-x[i-1]<=(v>>p))?l[p][i-1]:i;\n\t\tr[p][n+1]=n;for (int i=n;i>=1;i--) r[p][i]=(x[i+1]-x[i]<=(v>>p))?r[p][i+1]:i;\n\t}\n\tfor (int s=0;s<(1<<(lim+1));s++) g[s]=n+1;\n\tfor (int s=0;s<(1<<(lim+1));s++)\n\tfor (int i=0;i<=lim;i++) if (!(s&(1<<i)))\n\t{\n\t\tf[s|(1<<i)]=max(f[s|(1<<i)],r[i][f[s]+1]);\n\t\tg[s|(1<<i)]=min(g[s|(1<<i)],l[i][g[s]-1]);\n\t}\n\tfor (int i=0;i<=n;i++) mi[i]=n+2;\n\tfor (int i=0;i<(1<<(lim+1));i+=2) mi[f[i]]=min(mi[f[i]],g[(1<<(lim+1))-2-i]);\n\tfor (int i=1;i<=n;i++) puts((mi[l[0][i]-1]<=r[0][i]+1)?\"Possible\":\"Impossible\");\n\t//for (int i=1;i<=n;i++) printf(\"%d %d %d\\n\",l[0][i],r[0][i],mi[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//Camel and Oases\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint const N=2e5+10;\nint const S=1<<18;\nint n,V;\nint d[N];\nint logV,a[20][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n    }\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nvoid type(int s)\n{\n    for(int i=logV;i>=1;i--) printf(\"%d\",(s>>(i-1))%2);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%d\",&d[i]),d[i-1]=d[i]-d[i-1];\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    /*for(int i=1;i<=logV;i++)\n    {\n    \tprintf(\"%d-%d \",1,a[i][1]);\n        for(int j=2;j<=a[i][0];j++) printf(\"%d-%d \",a[i][j-1]+1,a[i][j]);\n        printf(\"\\n\");\n    }*/\n    if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++) puts(\"Impossible\");\n        return 0;\n    }\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=0,f2[s]=n+1;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    /*for(int s=0;s<=U;s+=2)\n        type(s),printf(\"   1-%2d  %2d-%2d\\n\",f1[s],f2[U-s-1],n);*/\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1 && f2[U-s-1]-1<=to) f=true;\n        if(f) for(int j=fr;j<=to;j++) puts(\"Possible\");\n        else for(int j=fr;j<=to;j++) puts(\"Impossible\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std ;\n\n#define l first\n#define r second\n\nconst int M = 40 ;\nconst int N = 400010 ;\nconst int MAX = 1001000001 ;\n\nint dep ;\nint maxn ;\nint ans[N] ;\nint n, m, k ;\nint base[N] ;\nint L[M][N] ;\nint R[M][N] ;\nint farfrl[N] ;\nint farfrr[N] ;\npair<int, int> rg[N] ;\n\nvoid Init_dp(){\n\tfor (int j = m ; j >= 0 ; j >>= 1){\n        R[++ dep][n + 1] = n + 1 ;\n        for (int i = 1 ; i <= n ; ++ i)\n            L[dep][i] = (base[i] - base[i - 1] > j) ? i : L[dep][i - 1] ;\n        for (int i = n ; i >= 1 ; -- i)\n            R[dep][i] = (base[i + 1] - base[i] > j) ? i : R[dep][i + 1] ;\n        if (!j) break ;\n    }\n\treturn ;\n}\nvoid Auxiliary_dp(){\n    for (int i = 0 ; i <= maxn ; i += 2)\n        for (int j = 1 ; j <= dep ; ++ j)\n            if (1 << (j - 1) & i){\n                farfrl[i] = max(farfrl[i], R[j][ farfrl[i ^ (1 << (j - 1))] + 1]) ;\n                farfrr[i] = min(farfrr[i], L[j][ farfrr[i ^ (1 << (j - 1))] - 1]) ;\n            }\n\treturn ;\n}\nint main(){\n    cin >> n >> m ;\n    base[0] = -MAX ;\n    base[n + 1] = MAX ; k = -1 ;\n    for (int i = 1 ; i <= n ; ++ i)\n        scanf(\"%d\", &base[i]) ; Init_dp() ;\n    for (int i = 1 ; i <= n ; ++ i)\n        rg[i].l = L[1][i], rg[i].r = R[1][i] ;\n    sort(rg + 1, rg + n + 1) ; maxn = (1 << dep) - 1 ;\n\tfor (int i = 0 ; i <= maxn ; ++ i) farfrr[i] = n + 1 ;\n    k += unique(rg + 1, rg + n + 1) - rg ; Auxiliary_dp() ;\n    for (int i = 1 ; i <= k ; ++ i)\n        for (int j = 0 ; j <= maxn ; j += 2)\n            if (farfrl[j] + 1 >= rg[i].l && farfrr[(maxn ^ j) ^ 1] - 1 <= rg[i].r)\n                { for (int o = rg[i].l ; o <= rg[i].r ; ++ o) ans[o] = 1 ; break ; }\n    for (int i = 1 ; i <= n ; ++ i) puts(ans[i] ? \"Possible\" : \"Impossible\") ; return 0 ;\n}\n/*\n0 8\n0 8\n1 7\n0 8\n1 7\n0 8\n2 6\n0 8\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nint n,v,m,a[200005],len[25],L[200005][25],R[200005][25],f[500005],g[500005];\npriority_queue<int> q;\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\twhile(v) len[m++]=v,v>>=1;len[m++]=0;\n\tfor(int i=0;i<m/2;i++) swap(len[i],len[m-i-1]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tL[i][p]=L[i-1][p];\n\t\t\tif(i==1||a[i]-a[i-1]>len[p]) L[i][p]=i;\n\t\t}\n\t}\n\tfor(int i=n;i;i--){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tR[i][p]=R[i+1][p];\n\t\t\tif(i==n||a[i+1]-a[i]>len[p]) R[i][p]=i;\n\t\t}\n\t}\n\tf[0]=0;g[0]=n+1;\n\tfor(int i=1;i<(1<<m);i++){\n\t\tg[i]=n+1;\n\t\tfor(int p=0;p<m;p++) if(i&(1<<p)){\n\t\t\tf[i]=max(f[i],R[f[i^(1<<p)]+1][p]);\n\t\t\tg[i]=min(g[i],L[g[i^(1<<p)]-1][p]);\n\t\t}\n\t}\n\tint S=(1<<m-1)-1;\n\tfor(int i=1,pos=1;i<=n;i++){\n\t\twhile(f[pos]>=L[i][m-1]-1&&pos<=S) q.push(S^pos),pos++;\n\t\twhile(!q.empty()&&f[S^q.top()]<L[i][m-1]-1) q.pop();\n\t\tif(q.empty()){\n\t\t\tputs(\"Impossible\");continue;\n\t\t}\n\t\tif(g[q.top()]>R[i][m-1]+1) puts(\"Impossible\");\n\t\telse puts(\"Possible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Camel and Oases\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\nint const N=2e5+10;\nint const S=1<<19;\nint n,V;\nlint d[N];\nint logV,a[25][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n    }\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&d[i]),d[i-1]=d[i]-d[i-1];\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++) printf(\"Impossible\\n\");\n        return 0;\n    }\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=0,f2[s]=n+1;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1 && f2[U-s-1]-1<=to) f=true;\n        if(f) for(int j=fr;j<=to;j++) printf(\"Possible\\n\");\n        else for(int j=fr;j<=to;j++) printf(\"Impossible\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1009LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> ii;\ntypedef pair<ii, ii> i4;\n \nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n\n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nconst int N = 200005;\nint n, arr[N], sz, V, next_right[20][N], next_left[20][N];\nint DP_left[1<<20], DP_right[1<<20];\nvector<int> steps;\n\nint dp_left(int mask){\n    int &ans = DP_left[mask];\n    if(ans != -1)   return ans;\n    ans = 1;\n    for(int i=0;i<sz;i++)\n        if((mask >> i) & 1)\n            ans = max(ans, next_right[i][dp_left(mask^(1<<i))+1]);\n    return ans;\n}\n\nint dp_right(int mask){\n    int &ans = DP_right[mask];\n    if(ans != -1)   return ans;\n    ans = n+1;\n    for(int i=0;i<sz;i++)\n        if((mask >> i) & 1)\n            ans = min(ans, next_left[i][dp_right(mask^(1<<i))-1]);\n    return ans;\n}\n\n\n\nbool possible(int l, int r){\n    int mask = (1<<sz)-2; \n    for(int i=mask;i>=0;i=(i-1)&mask){\n// cout<<i<<\" \"<<(mask^i)<<\" \"<<mask<<\" \"<<dp_left(i)<<\" \"<<dp_right(mask^i)<<endl;\n        if((l==1 || dp_left(i) >= l-1) && (r==n || dp_right(mask^i) <= r+1))    return true;\n        if(i == 0)  break;\n    }\n    return false;\n}\n\n\nint main(){\n \n    // ios_base::sync_with_stdio(0);\n    // cin.tie(0);\n\n    scanf(\"%d%d\", &n, &V);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\", &arr[i]);\n\n    while(V){\n        steps.pb(V);\n        V /= 2;\n    }\n    steps.pb(0);\n    sz = (int)steps.size();\n\n    for(int k=0;k<sz;k++){\n\n        next_right[k][n+1] = n+1;\n        next_right[k][n] = n;\n        for(int i=n-1;i>=1;i--)\n            if(arr[i+1]-arr[i] <= steps[k])\n                next_right[k][i] = next_right[k][i+1];\n            else\n                next_right[k][i] = i;\n\n        next_left[k][0] = 0;\n        next_left[k][1] = 1;\n        for(int i=2;i<=n;i++)\n            if(arr[i]-arr[i-1] <= steps[k])\n                next_left[k][i] = next_left[k][i-1];\n            else\n                next_left[k][i] = i;\n    }\n\n    int comps = 0, curr = 1;\n    while(curr <= n){\n        comps++;\n        curr = next_right[0][curr] + 1;\n    }\n\n    if(comps > sz){\n        for(int i=1;i<=n;i++)\n            printf(\"Impossible\\n\");\n        return 0;\n    }\n\n// cout<<\"steps: \";for(auto it : steps)    cout<<it<<\" \";cout<<endl;\n// cout<<\"next_right:\\n\";\n// for(int i=1;i<=n;i++){\n//     cout<<i<<\": \";for(int j=0;j<sz;j++) cout<<next_right[j][i]<<\" \";cout<<endl;\n// }cout<<endl;\n// cout<<\"next_left:\\n\";\n// for(int i=1;i<=n;i++){\n//     cout<<i<<\": \";for(int j=0;j<sz;j++) cout<<next_left[j][i]<<\" \";cout<<endl;\n// }cout<<endl;\n\n\n    memset(DP_left, -1, sizeof(DP_left));\n    memset(DP_right, -1, sizeof(DP_right));\n    curr = 1;\n    while(curr <= n){\n        if(possible(curr, next_right[0][curr])){\n            for(int i=curr;i<=next_right[0][curr];i++)\n                printf(\"Possible\\n\");\n        }\n        else{\n            for(int i=curr;i<=next_right[0][curr];i++)\n                printf(\"Impossible\\n\");\n        }\n        curr = next_right[0][curr]+1;\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int N = 200050;\n\nint n, v, x[N];\nint dp1[(1 << 19) + 3], dp2[(1 << 19) + 3];\nint tor[20][N], tol[20][N], len[20], dep, mxr[N];\ninline void gi(int &x){\n\tint f = 1; x = 0; char c = getchar();\n\twhile(c < '0' || c > '9'){\n\t\tif(c == '-')f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9'){\n\t\tx = x * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tx *= f;\n}\nint main()\n{\n\nint i, j, d;\n    gi(n), gi(v), x[0] = -2e9, x[n+1] = 2e9;\n    for(len[0] = v; len[dep] != 0; dep ++)\n\t\tlen[dep + 1] = len[dep] >> 1;\n    for(dep ++, i = 1; i <= n; i ++)gi(x[i]);\n    for(d = 0; d < dep; d ++){\n        tol[d][0] = n, tor[d][n + 1] = n;\n        for(i = 1; i <= n; i ++)tol[d][i] = (x[i] - x[i - 1] <= len[d]) ? tol[d][i - 1] : n + 1 - i;\n        for(i = n; i >= 1; i --)tor[d][i] = (x[i + 1] - x[i] <= len[d]) ? tor[d][i + 1] : i;\n    }\n    for(i = 0; i < (1 << dep); i += 2){\n        for(j = 1; j < dep; j ++){\n            if((i & (1 << j)) == 0){\n                dp1[i | (1 << j)] = max(dp1[i | (1 << j)], tor[j][dp1[i] + 1]);\n                dp2[i | (1 << j)] = max(dp2[i | (1 << j)], tol[j][n - dp2[i]]);\n            }\n        }\n    }\n    memset(mxr, 0xc0, sizeof(mxr));\n    for(i = 0, j = ((1 << dep) - 1) ^ 1; j >= 0; i += 2, j -= 2)\n        mxr[dp1[i]] = max(mxr[dp1[i]], dp2[j]);\n    for(i = 1; i <= n; i ++){\n        if(mxr[n - tol[0][i]] + tor[0][i] >= n)puts(\"Possible\");\n        else puts(\"Impossible\");\n    }\n\t    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n\ntypedef long long int64;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nconst int oo = 0x3f3f3f3f;\nconst double eps = 1e-9;\n\nconst int maxn = 200010;\nconst int mlog = 20;\n\nint pos[ maxn ];\nint vsize[ mlog ], len;\n\nint mr[ maxn ][ mlog ], ml[ maxn ][ mlog ];\nint dppref[ 1 << mlog ], dpsuff[ 1 << mlog ];\n\nint bestcover[ maxn ];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n#ifdef MARX\n    freopen(\"test.in\", \"r\", stdin);\n#endif\n\n    int n, V;\n    cin >> n >> V;\n\n    int v = V >> 1;\n\n    for (int i = 0; i < n; ++i)\n        cin >> pos[i];\n\n    for (len = 0; vsize[len++] = v; v >>= 1);\n    vsize[ len ] = V;\n\n    for (int i = 0; i <= len; ++i){\n        mr[ n - 1 ][i] = n - 1;\n        ml[ 0 ][i] = 0;\n    }\n\n    for (int i = 1; i < n; ++i){\n        for (int j = 0; j <= len; ++j){\n            if (pos[i] - pos[i - 1] <= vsize[j])\n                ml[i][j] = ml[i - 1][j];\n            else\n                ml[i][j] = i;\n        }\n    }\n\n    for (int i = n - 2; i >= 0; --i){\n        for (int j = 0; j <= len; ++j){\n            if (pos[i + 1] - pos[i] <= vsize[j])\n                mr[i][j] = mr[i + 1][j];\n            else\n                mr[i][j] = i;\n        }\n    }\n\n    dppref[0] = -1;\n    dpsuff[0] = n;\n\n    int mask = (1 << len);\n\n    for (int i = 1; i < mask; ++i){\n        dppref[i] = 0;\n        dpsuff[i] = n - 1;\n\n        for (int j = 0; j < len; ++j){\n            if (i >> j & 1){\n                int m = i ^ (1 << j);\n\n                // prefix\n\n                if (dppref[m] == n - 1)\n                    dppref[i] = n - 1;\n                else\n                    dppref[i] = max(dppref[i], mr[ dppref[m] + 1 ][j]);\n\n                // suffix\n\n                if (dpsuff[m] == 0)\n                    dpsuff[i] = 0;\n                else\n                    dpsuff[i] = min( dpsuff[i], ml[ dpsuff[m] - 1 ][j]);\n            }\n        }\n    }\n\n    mask--;\n\n    for (int i = 0; i < n; ++i)\n        bestcover[i] = oo;\n\n    for (int i = 0; i <= mask; ++i){\n        int comp = mask ^ i;\n        int pA = dppref[i], pB = dpsuff[i];\n        bestcover[ pA ] = min( bestcover[ pA ], pB );\n    }\n\n    for (int i = n - 2; i >= 0; --i)\n        bestcover[i] = min( bestcover[i], bestcover[i + 1] );\n\n    for (int i = 0; i < n; ++i){\n        int pA = ml[i][len], pB = mr[i][len];\n\n        bool ok = false;\n\n        if (pA == 0){\n            if (dpsuff[ mask ] <= pB + 1)\n                ok = true;\n        }\n        else\n            ok = bestcover[pA - 1] <= pB + 1;\n\n        cout << (ok ? \"Possible\" : \"Impossible\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define bi(x) (1<<(x-1))\n#define rep(i,j,k) for (i=j;i<=k;i++)\n#define down(i,j,k) for (i=j;i>=k;i--)\nusing namespace std;\nconst int N=2e5+5,K=20,Sn=1<<19;\nint n,sn,V,v,k,i,j,lef,rig;\nint a[N],c[N],l[N],r[N];\nint rr[N][K],ls[Sn],rs[Sn];\nvoid work(int *r,int *rs)\n{\n\tint i,j,v=V;\n\trep(j,1,k)\n\t{\n\t\trr[n][j]=n;\n\t\tdown(i,n-1,1)\n\t\t\tif (abs(a[i+1]-a[i])<=v) rr[i][j]=rr[i+1][j];\n\t\t\telse rr[i][j]=i;\n\t\tv>>=1;\n\t}\n\trep(i,1,n) r[i]=rr[i][1];\n\trep(i,0,sn) rs[i]=0;\n\trep(i,0,sn-1)\n\t{\n\t\trep(j,2,k)\n\t\t\tif (!(i&bi(j)))\n\t\t\t\trs[i^bi(j)]=max(rs[i^bi(j)],rr[rs[i]+1][j]);\n\t}\t\n}\nint main()\n{\n//\tfreopen(\"camel.in\",\"r\",stdin);\n//\tfreopen(\"camel.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&V);\n\trep(i,1,n) scanf(\"%d\",&a[i]);\t\n\tfor (k=1,v=V;v>0;v>>=1) k++;\n\t\n\tsn=(1<<k)-1;\n\twork(r,rs);\n\treverse(a+1,a+1+n);\n\twork(l,ls);\n\t\n\trep(i,1,n) l[i]=n-l[i]+1;\n\treverse(l+1,l+1+n);\n\t\n\trep(i,0,sn) {\n\t\tlef=rs[i]; rig=n-ls[sn^i]+1;\n\t\tif (rig-lef<=1) c[1]++;\n\t\telse if (r[lef+1]>=rig-1) {\n\t\t\tc[l[lef+1]]++; c[r[lef+1]+1]--;\n\t\t}\n\t}\n\trep(i,1,n) {\n\t\tc[i]+=c[i-1];\n\t\tif (c[i]>0) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint x[202020];\nint l[202020][20], r[202020][20];\nint dpl[1 << 20], dpr[1 << 20];\n\nvoid solve() {\n        int n, v;\n        cin >> n >> v;\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        int p;\n        for (int i = 0; ; i ++) if ((1 << i) > v) {\n                p = i + 1;\n                break;\n        }\n        for (int i = 0; i < n; i ++) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == 0 || x[i] - x[i - 1] > vv) l[i][j] = i;\n                        else l[i][j] = l[i - 1][j];\n                        vv /= 2;\n                }    \n        }\n        for (int i = n - 1; i >= 0; i --) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == n - 1 || x[i + 1] - x[i] > vv) r[i][j] = i;\n                        else r[i][j] = r[i + 1][j];\n                        vv /= 2;\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpr[i] == n) dpr[i | (1 << j)] = n;\n                        else dpr[i | (1 << j)] = max(dpr[i | (1 << j)], r[dpr[i]][j] + 1);\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) dpl[i] = n - 1;\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpl[i] == -1) dpl[i | (1 << j)] = -1;\n                        else dpl[i | (1 << j)] = min(dpl[i | (1 << j)], l[dpl[i]][j] - 1);\n                }\n        }\n        bool ok = false;\n        for (int i = 0; i < n; i ++) {\n                if (l[i][0] == i) {\n                        int c = 0;\n                        for (int j = 0; j < (1 << p); j ++) {\n                                c ++;\n                                if (j & 1) continue; \n                                if (i > 0 && dpr[j] < i) continue;\n                                if (r[i][0] < n - 1 && dpl[((1 << p) - 1 - j) - 1] > r[i][0]) continue;\n                                break;\n                        }\n                        if (c < (1 << p)) ok = true;\n                        else ok = false;\n                }\n                if (ok) cout << \"Possible\" << endl;\n                else cout << \"Impossible\" << endl;\n        }\n        return;\n}\n\nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        solve();\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int L = 20;\nconst int MAX = 2 * 1000 * 100 + 47;\n\nint V[L];\nint sz = 0;\nint N[L][MAX];\nint P[L][MAX];\nint X[MAX];\nint dpL[1 << L];\nint dpR[1 << L];\nint ANS[MAX];\nset<PII> S;\nint M[MAX];\n\nvoid print(int mask)\n{\n\twhile (mask)\n\t{\n\t\tif (mask & 1)\n\t\t{\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << \" \";\n\t\t}\n\n\t\tmask >>= 1;\n\t}\n}\n\n//#define DEBUG\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tint n, v;\n\tcin >> n >> v;\n\tFOR(i, 0, n) cin >> X[i];\n\n\tV[0] = v;\n\tFOR(i, 1, L)\n\t{\n\t\tV[i] = V[i - 1] / 2;\n\t\tif (V[i] == 0)\n\t\t{\n\t\t\tsz = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treverse(V, V + sz);\n\tFOR(k, 0, sz)\n\t{\n\t\tint v = V[k];\n\t\tN[k][n - 1] = n;\n\n\t\tRFOR(i, n - 1, 0)\n\t\t{\n\t\t\tif (abs(X[i + 1] - X[i]) > v)\n\t\t\t{\n\t\t\t\tN[k][i] = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tN[k][i] = N[k][i + 1];\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"N=\" << endl;\n\tFOR(k, 0, sz)\n\t{\n\t\tcout << V[k] << \": \";\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tcout << N[k][i] << \" \";\n\t\t}\n\n\t\tcout << endl;\n\t}\n#endif\n\n\tFOR(k, 0, sz)\n\t{\n\t\tint v = V[k];\n\t\tP[k][0] = -1;\n\t\tFOR(i, 1, n)\n\t\t{\n\t\t\tif (abs(X[i] - X[i - 1]) > v)\n\t\t\t{\n\t\t\t\tP[k][i] = i - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tP[k][i] = P[k][i - 1];\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"P=\" << endl;\n\tFOR(k, 0, sz)\n\t{\n\t\tcout << V[k] << \": \";\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tcout << P[k][i] << \" \";\n\t\t}\n\n\t\tcout << endl;\n\t}\n#endif\n\n\tsz--;\n\n\tdpL[0] = 0;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tint x = dpL[mask];\n\t\tFOR(k, 0, sz)\n\t\t{\n\t\t\tif (mask & (1 << k)) continue;\n\n\t\t\tdpL[mask | (1 << k)] = max(dpL[mask | (1 << k)], N[k][x]);\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"dpL\" << endl;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tprint(mask);\n\t\tcout << \" :\";\n\t\tcout << dpL[mask] << endl;\n\t}\n#endif\n\n\tFOR(i, 0, 1 << sz) dpR[i] = 10 + n;\n\tdpR[0] = n - 1;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tint x = dpR[mask];\n\t\tFOR(k, 0, sz)\n\t\t{\n\t\t\tif (mask & (1 << k)) continue;\n\n\t\t\tdpR[mask | (1 << k)] = min(dpR[mask | (1 << k)], P[k][x]);\n\t\t}\n\t}\n\n\n#ifdef DEBUG\n\tcout << \"dpR\" << endl;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tprint(mask);\n\t\tcout << \" :\";\n\t\tcout << dpR[mask] << endl;\n\t}\n#endif\n\n\tFOR(i, 0, n) M[i] = INF;\n\tint tmp = INF;\n\tFOR(maskL, 0, 1 << sz)\n\t{\n\t\tint maskR = ((1 << sz) - 1) ^ maskL;\n\t\tint l = dpL[maskL] - 1;\n\t\tint r = dpR[maskR] + 1;\n#ifdef DEBUG\n\t\tcout << \"!!\" << l << \" \" << r << endl;\n#endif\n\t\tif (l != -1) M[l] = min(M[l], r);\n\n\t\tif (l == -1) tmp = min(tmp, r);\n\t}\n\n#ifdef DEBUG\n\tcout << \"M=\" << endl;\n\tFOR(i, 0, n)\n\t{\n\t\tcout << M[i] << \" \";\n\t}\n\n\tcout << endl;\n#endif\n\n\tRFOR(i, n - 1, 0) M[i] = min(M[i + 1], M[i]);\n\t\n\tFOR(i, 0, n)\n\t{\n\t\tint l = P[sz][i] + 1;\n\t\tint r = N[sz][i] - 1;\n\t\tif (S.find(MP(l, r)) != S.end()) continue;\n\t\tS.insert(MP(l, r));\n\n\t\tint val = M[max(l - 1, 0)];\n\t\tif (l - 1 == -1)\n\t\t{\n\t\t\tval = min(val, tmp);\n\t\t}\n\n\t\tif (val <= r + 1)\n\t\t{\n\t\t\tFOR(k, l, r + 1) ANS[k] = 1;\n\t\t}\n\t}\n\n\tFOR(i, 0, n)\n\t{\n\t\tif (ANS[i])\n\t\t{\n\t\t\tcout << \"Possible\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcout << \"Impossible\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=2e5+5;\nint n,m;\nint V[25],x[maxn],R[maxn][25],L[maxn][25];\nint S1[maxn],S2[maxn];\nint minL[maxn];\nint main(){\n\tread(n);read(V[0]);\n\trep(i,1,n)read(x[i]);\n\twhile(V[m])V[m+1]=V[m]/2,m++;\n\tm++;\n\trep2(i,0,m){\n\t\tR[n+1][i]=n;\n\t\tR[n][i]=n;\n\t\tper(j,n-1,1)\n\t\t\tif(x[j+1]-x[j]<=V[i])R[j][i]=R[j+1][i];\n\t\t\telse R[j][i]=j;\n\t\tL[0][i]=1;\n\t\tL[1][i]=1;\n\t\trep(j,2,n)\n\t\t\tif(x[j]-x[j-1]<=V[i])L[j][i]=L[j-1][i];\n\t\t\telse L[j][i]=j;\n\t}\n\trep2(i,0,1<<m)S2[i]=n+1;\n\trep2(i,1,1<<m){\n\t\trep2(j,0,m)if(i>>j&1){\n\t\t\tint last=S1[i^(1<<j)];\n\t\t\tS1[i]=max(S1[i],R[last+1][j]);\n\t\t}\n\t\trep2(j,0,m)if(i>>j&1){\n\t\t\tint last=S2[i^(1<<j)];\n\t\t\tS2[i]=min(S2[i],L[last-1][j]);\n\t\t}\n\t}\n\trep(i,0,n)minL[i]=n+2;\n\trep2(i,0,1<<m){\n\t\tif(i>>0&1)continue;\n\t\tint R=S1[i],L=S2[((1<<m)-1)^i^(1<<0)];\n\t\tminL[R]=min(minL[R],L);\n\t}\n\tper(i,n-1,0)minL[i]=min(minL[i],minL[i+1]);\n\trep(i,1,n){\n\t\tint rL=L[i][0],rR=R[i][0];\n\t\tif(minL[rL-1]<=rR+1)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\n# define REP(i, a, b) for(int i = a; i <= b; ++ i)\n# define REPD(i, a, b) for(int i = a; i >= b; -- i)\n# define CLR(i, a) memset(i, a, sizeof(i))\n# define REPG(i, h, x) for(int i = h[x]; ~i; i = edge[i].next)\n\nconst int N = 2e5 + 5, N_ = 19, S_ = (1 << 19) - 1;\n\nint r[N_ + 3][N], cnt[N_ + 3];\nint f1[S_ + 5], f2[S_ + 5];\nint n, v, len = -1;\nint d[N], S;\n\nint main() {\n\tscanf(\"%d%d\", &n, &v);\n\tREP(i, 1, n) scanf(\"%d\", &d[i]);\n\tint x = v << 1;\n    while(x) {\n        x >>= 1, ++ len;\n        REP(i, 1, n - 1) {\n            if(d[i + 1] - d[i] <= x) continue;\n            r[len][++ cnt[len]] = i;\n        } r[len][++ cnt[len]] = n;\n    }\n\tS = (1 << len) - 1;\n\tif(cnt[0] > len + 1){\n        REP(i, 1, n) puts(\"Impossible\"), exit(0);\n    }\n\tREP(i, 0, S) f2[i] = n + 1;\n\tREP(i, 0, S) {\n\t\tREP(j, 1, len) if(i & (1 << j - 1)) {\t\t\n\t\t\tf1[i] = max(f1[i], *upper_bound(r[j] + 1, r[j] + cnt[j] + 1, f1[i ^ (1 << j - 1)]));\n\t\t\tf2[i] = min(f2[i], r[j][lower_bound(r[j] + 1, r[j] + cnt[j] + 1, f2[i ^ (1 << j - 1)] - 1) - r[j] - 1] + 1);\n\t\t}\n\t}\n\tREP(i, 1, cnt[0]) {\n\t\tbool okay = 0;\n\t\tREP(s, 0, S) {\n\t\t\tif(f1[s] >= r[0][i - 1] && f2[S - s] <= r[0][i] + 1) { okay = 1; break; }\n\t\t}\n\t\tREP(j, r[0][i - 1] + 1, r[0][i]) puts(okay ? \"Possible\" : \"Impossible\");\n\t} \n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <chrono>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing namespace std::chrono;\n\ninline bool is_bit(int mask, int b) {\n  return (mask >> b) & 1;\n}\n\nint get_max_power(int v) {\n  int res = 1;\n  while (v > 0) {\n    v >>= 1;\n    ++res;\n  }\n  return res;\n}\n\nvoid fill_to_left(const vector<int>& vp, vector<int>& to_left, int v) {\n  const int n = vp.size();\n\n  for (int r = n - 1, l = n - 1; r >= 0;) {\n    l = r;\n    while (l - 1 >= 0 && vp[l] - vp[l - 1] <= v)\n      --l;\n    for (int i = l; i <= r; ++i)\n      to_left[i] = l;\n    r = l - 1;\n  }\n}\n\nvoid fill_to_right(const vector<int>& vp, vector<int>& to_right, int v) {\n  const int n = vp.size();\n\n  for (int l = 0, r = 0; l < n;) {\n    r = l;\n    while (r + 1 < n && vp[r + 1] - vp[r] <= v)\n      ++r;\n    for (int i = l; i <= r; ++i)\n      to_right[i] = r;\n    l = r + 1;\n  }\n}\n\nint main() {\n  auto start = high_resolution_clock::now();\n\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, v;\n  cin >> n >> v;\n  vector<int> vp(n);\n  for (int i = 0; i < n; ++i)\n    cin >> vp[i];\n\n  int max_pw = get_max_power(v);\n\n  vector<vector<int>> to_left(max_pw, vector<int>(n, n)), to_right(max_pw, vector<int>(n, -1));\n  for (int pw = 0; pw < max_pw; ++pw) {\n    fill_to_left(vp, to_left[pw], v >> (max_pw - pw - 1));\n    fill_to_right(vp, to_right[pw], v >> (max_pw - pw - 1));\n  }\n\n  const int max_mask = 1 << (max_pw - 1);\n  vector<int> from_left(max_mask, -1), from_right(max_mask, n);\n\n  for (int mask = 0; mask < max_mask; ++mask) {\n    int cpos = from_left[mask];\n    for (int b = 0; b < max_pw - 1; ++b) {\n      if (!is_bit(mask, b)) {\n        const int new_mask = mask | (1 << b);\n        const int new_pos = cpos + 1 < n ? to_right[b][cpos + 1] : cpos;\n        from_left[new_mask] = max(from_left[new_mask], new_pos);\n      }\n    }\n  }\n\n  for (int mask = 0; mask < max_mask; ++mask) {\n    int cpos = from_right[mask];\n    for (int b = 0; b < max_pw - 1; ++b) {\n      if (!is_bit(mask, b)) {\n        const int new_mask = mask | (1 << b);\n        const int new_pos = cpos - 1 >= 0 ? to_left[b][cpos - 1] : cpos;\n        from_right[new_mask] = min(from_right[new_mask], new_pos);\n      }\n    }\n  }\n\n  vector<int> ans(n + 1, 0);\n  for (int mask = 0; mask < max_mask; ++mask) {\n    int left_mask = mask;\n    int right_mask = 0;\n    do {\n      int l = from_left[left_mask];\n      int r = from_right[right_mask];\n\n      if (l >= r) {\n        ++ans[0];\n        --ans[n];\n      } else {\n        int mr = l + 1 < n ? to_right[max_pw - 1][l + 1] : l;\n        int ml = mr >= 0 ? to_left[max_pw - 1][mr] : mr;\n\n        if (ml <= l + 1 && mr >= r - 1) {\n          ++ans[ml];\n          --ans[mr + 1];\n        }\n      }\n\n      if (left_mask == 0)\n        break;\n      left_mask = mask & (left_mask - 1);\n      right_mask = mask - left_mask;\n    } while (true);\n  }\n\n  for (int i = 0; i < n; ++i) {\n    cout << (ans[i] == 0 ? \"Impossible\" : \"Possible\") << '\\n';\n    ans[i + 1] += ans[i];\n  }\n\n  cerr << \"Total execution time : \" << duration_cast<milliseconds>(high_resolution_clock::now() - start).count() << \" ms\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std ;\n\n#define l first\n#define r second\n\nconst int M = 40 ;\nconst int N = 1200010 ;\nconst int MAX = 1001000001 ;\n\nint dep ;\nint maxn ;\nint ans[N] ;\nint n, m, k ;\nint base[N] ;\nint L[M][N] ;\nint R[M][N] ;\nint farfrl[N] ;\nint farfrr[N] ;\npair<int, int> rg[N] ;\n\nvoid Init_dp(){\n    for (int j = m ; j >= 0 ; j >>= 1){\n        R[++ dep][n + 1] = n + 1 ;\n        for (int i = 1 ; i <= n ; ++ i)\n            L[dep][i] = (base[i] - base[i - 1] > j) ? i : L[dep][i - 1] ;\n        for (int i = n ; i >= 1 ; -- i)\n            R[dep][i] = (base[i + 1] - base[i] > j) ? i : R[dep][i + 1] ;\n        if (!j) break ;\n    }\n    return ;\n}\nvoid Auxiliary_dp(){\n    for (int i = 0 ; i <= maxn ; i += 2)\n        for (int j = 1 ; j <= dep ; ++ j)\n            if (1 << (j - 1) & i){\n                farfrl[i] = max(farfrl[i], R[j][ farfrl[i ^ (1 << (j - 1))] + 1]) ;\n                farfrr[i] = min(farfrr[i], L[j][ farfrr[i ^ (1 << (j - 1))] - 1]) ;\n            }\n    return ;\n}\nint main(){\n    cin >> n >> m ;\n    base[0] = -MAX ;\n    base[n + 1] = MAX ; k = -1 ;\n    for (int i = 1 ; i <= n ; ++ i)\n        scanf(\"%d\", &base[i]) ; Init_dp() ;\n    for (int i = 1 ; i <= n ; ++ i)\n        rg[i].l = L[1][i], rg[i].r = R[1][i] ;\n    sort(rg + 1, rg + n + 1) ; maxn = (1 << dep) - 1 ;\n    for (int i = 0 ; i <= maxn ; ++ i) farfrr[i] = n + 1 ;\n    k += unique(rg + 1, rg + n + 1) - rg ; Auxiliary_dp() ;\n    for (int i = 1 ; i <= k ; ++ i)\n        for (int j = 0 ; j <= maxn ; j += 2)\n            if (farfrl[j] + 1 >= rg[i].l && farfrr[(maxn ^ j) ^ 1] - 1 <= rg[i].r)\n                { for (int o = rg[i].l ; o <= rg[i].r ; ++ o) ans[o] = 1 ; break ; }\n    for (int i = 1 ; i <= n ; ++ i) puts(ans[i] ? \"Possible\" : \"Impossible\") ; return 0 ;\n}\n/*\n0 8\n0 8\n1 7\n0 8\n1 7\n0 8\n2 6\n0 8\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 200000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nint n,V,x[MN+5],s,nxt[20][MN+5],lst[20][MN+5],res[MN+5],f[1<<18],g[1<<18];\ninline void R(int&x,int y){y>x?x=y:0;}\ninline void L(int&x,int y){y<x?x=y:0;}\nvoid Dp()\n{\n    memset(f,200,sizeof(f));f[0]=1;\n    for(int i=0;i<1<<s;++i)\n        for(int j=1;j<=s;++j) if(!(i&(1<<j-1)))\n            R(f[i|(1<<j-1)],nxt[j][f[i]]);\n    memset(g,63,sizeof(g));g[0]=n;\n    for(int i=0;i<1<<s;++i)\n        for(int j=1;j<=s;++j) if(!(i&(1<<j-1)))\n            L(g[i|(1<<j-1)],lst[j][g[i]]);\n}\nvoid Solve(int l,int r)\n{\n    bool flag=0;\n    for(int i=0;i<1<<s;++i)\n        if(f[i]>=l&&g[(1<<s)-1-i]<=r) {flag=1;break;}\n    if(flag)for(int i=l;i<=r;++i) res[i]=1;\n}\nint main()\n{\n    n=read();V=read();\n    for(int i=1;i<=n;++i) x[i]=read();\n    for(int t=V;;t>>=1,++s)\n    {\n        nxt[s][n]=nxt[s][n+1]=n+1;\n        lst[s][0]=lst[s][1]=0;\n        for(int i=2;i<=n;++i) lst[s][i]=x[i]-x[i-1]>t?i-1:lst[s][i-1];\n        for(int i=n-1;i;--i)  nxt[s][i]=x[i+1]-x[i]>t?i+1:nxt[s][i+1];\n        if(!t) break;\n    }\n    int tot=0;Dp();\n    for(int i=1;i<=n;i=nxt[0][i],++tot);\n    if(tot<=s+1) for(int b=1;b<=n;b=nxt[0][b],++tot) Solve(b,nxt[0][b]-1);\n    for(int i=1;i<=n;++i) puts(res[i]?\"Possible\":\"Impossible\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nvoid fmax(int&a,int b){\n\tif(b>a)a=b;\n}\nvoid fmin(int&a,int b){\n\tif(b<a)a=b;\n}\nint x[200010],l[20][200010],r[20][200010],n;\nvoid pre(int p,int d){\n\tint*l=::l[p],*r=::r[p],i;\n\tl[1]=1;\n\tfor(i=2;i<=n;i++)l[i]=x[i]-x[i-1]>d?i:l[i-1];\n\tr[n]=n;\n\tfor(i=n-1;i>0;i--)r[i]=x[i+1]-x[i]>d?i:r[i+1];\n\tl[0]=1;\n\tr[n+1]=n;\n}\nint fl[262144],fr[262144],s[200010];\nvoid gao(int l,int r){\n\tif(l<=r){\n\t\ts[l]++;\n\t\ts[r+1]--;\n\t}\n}\nint main(){\n\tint V,M,i,j;\n\tscanf(\"%d%d\",&n,&V);\n\tfor(i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tfor(M=0;V;V>>=1)pre(M++,V);\n\tpre(M,0);\n\tfr[0]=n+1;\n\tfor(i=1;i<1<<M;i++){\n\t\tfr[i]=n;\n\t\tfor(j=0;j<M;j++){\n\t\t\tif(i>>j&1){\n\t\t\t\tfmax(fl[i],r[j+1][fl[i^(1<<j)]+1]);\n\t\t\t\tfmin(fr[i],l[j+1][fr[i^(1<<j)]-1]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<1<<M;i++){\n\t\tgao(l[0][fr[((1<<M)-1)^i]-1],r[0][fl[i]+1]);\n\t}\n\tfor(i=1;i<=n;i++){\n\t\ts[i]+=s[i-1];\n\t\tputs(s[i]?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=262444,M=22,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ntemplate<class T> inline void read(T &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ntemplate<class T> inline void print(T x){\n\tif(!x){puts(\"0\");return;}\n\tif(x<0){putchar('-');x=-x;}\n\tint a[20],m=0;\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');puts(\"\");\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,a[N],v[20],cnt[20],L[20][N],R[20][N],bel[N],si[N],ans[N];\nmap<pii,bool> dp[20][N];\n\n\nvoid dfs(int x,int l,int r){\n//\tprintf(\"%d %d %d\\n\",x,l,r);\n\tif(x==m) return;\n\tfor(int i=l;i<=r;i++){\n\t\tint t=i;\n\t\twhile(t<r&&a[t+1]-a[t]<=v[x]) t++;\n\t\tL[x][++cnt[x]]=cnt[x+1]+1;\n\t\tdfs(x+1,i,t);\n\t\tR[x][cnt[x]]=cnt[x+1];\n\t\tif(!x){\n\t\t\tfor(int j=i;j<=t;j++)\n\t\t\t\tbel[j]=cnt[x];\n\t\t}i=t;\n\t}\n}\nbool get(int x,int l,int r,int st){\n//\tprintf(\"%d %d %d %d\\n\",x,l,r,st);\n\tif(l>r) return 1;\n\tif(si[st]<=r-l||x==m) return 0;\n\tif(!(st&(1<<x))) return get(x+1,l,r,st);\n\tif(dp[x][st].count(mp(l,r))) return dp[x][st][mp(l,r)];\n\tbool ans=0;\n\tfor(int i=l;i<=r;i++){\n\t\tint u=st^(1<<x);\n\t\tfor(int j=u;j;j=(j-1)&u)\n\t\t\tif(get(x+1,L[x][l],R[x][i-1],j)&&get(x+1,L[x][i+1],R[x][r],u^j)){ans=1;break;}\n\t\tif(get(x+1,L[x][l],R[x][i-1],0)&&get(x+1,L[x][i+1],R[x][r],u)) ans=1;\n\t\tif(ans) break;\n\t}\n\tdp[x][st][mp(l,r)]=ans;\n\treturn ans;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tsrand(time(0));\n#endif\n\tios::sync_with_stdio(0);\n\tread(n);read(v[0]);\n\tfor(int i=1;i<=n;i++) read(a[i]);\n\tfor(int j=1;v[j-1];j++,m=j) v[j]=v[j-1]>>1;\n\tdfs(0,1,n);\n//\tdebuge;\n\tif(cnt[0]>m){\n\t\tfor(int i=1;i<=n;i++) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<m;i++)\n\t\tL[i][cnt[i]+1]=R[i][cnt[i]+1]=cnt[i+1]+1;\n\tfor(int i=1;i<(1<<m);i++) si[i]=si[i^(i&-i)]+1;\n//\tdebug(cnt[1]);\n//\tdebug(cnt[0]);\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tint u=(1<<m)-2;\n\t\tfor(int j=0;j<(1<<m);j+=2)\n\t\t\tif(get(1,L[0][1],R[0][i-1],j)&&get(1,L[0][i+1],R[0][cnt[0]],u^j)){ans[i]=1;break;}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(ans[bel[i]])puts(\"Possible\"); else puts(\"Impossible\");\n#ifdef rqgao2014\n\ttime_tester(1);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define P(x) cout << x << endl\n#define D(x) P(#x << \": \" << x)\n#define F(i,n) for (int i=0; i<(int)(n); i++)\n#define DEC(i,n) for (int i=(int)(n); --i>=0;)\n#define pb push_back\n#define all(v) v.begin(), v.end()\nusing namespace std;\nvoid MI(int &a, int v) {a = min(a,v);}\nvoid MA(int &a, int v) {a = max(a,v);}\nconst int N=2e5, L=18, PL=1<<L;\n\nint l,n,v,pl;\ndeque<int> len;\n\nvoid gen(int x[], int nxt[][N], int reach[]) {\n    F(k,l) {\n        int cur=0;\n        F(i,n+1) {\n            if (i == n || (i-1 >= 0 && abs(x[i] - x[i-1]) > len[k])) {\n                while (cur < i) {\n                    nxt[k][cur] = i;\n                    cur++;\n                }\n            }\n        }\n    }\n    F(mask,pl) {\n        reach[mask] = 0;\n        F(k,l) if (mask & 1<<k)\n            MA(reach[mask], nxt[k][reach[mask-(1<<k)]]);\n    }\n}\n\nvoid print(int nxt[][N]) {\n    F(k,l) {\n        cout<<len[k]<<\": \";\n        F(i,n) cout<<nxt[k][i]<<\" \\n\"[i==n-1];\n    }\n}\n\nint x[N], rev[N];\nint nxt[L][N], pre[L][N], rLeft[PL], rRight[PL];\nbool ok[N];\n\nsigned main() {\n    cin>>n>>v;\n    F(i,n) cin>>x[i], rev[n-1-i] = x[i], ok[i] = false;\n    len = {v};\n    int cur = v;\n    while (cur) cur/=2, len.push_front(cur);\n    l = len.size();\n    pl = 1<<l;\n    gen(x, nxt, rLeft);\n    gen(rev, pre, rRight);\n    //P(\"nxt:\"); print(nxt);\n    //P(\"pre:\"); print(pre);\n    //F(k,pl) cout<<bitset<3>(k)<<\":\"<<rLeft[k]<<\" \\n\"[k==pl-1];\n    int start = pl/2;\n    int offer[n+1]; // if you finish at >= i, we can accept a start <= offer[i]\n    F(i,n+1) offer[i] = -1;\n    F(mleft,start) {\n        int le = rLeft[mleft], ri = n - rRight[start-1-mleft];\n        //P(le<<\" \"<<ri);\n        MA(offer[ri], le);\n    }\n    int best = -1;\n    cur = 0;\n    while (cur < n) {\n        int lim = nxt[l-1][cur];\n        for (int i=cur; i<=lim; i++)\n            MA(best, offer[i]);\n        for (int i=cur; i<lim; i++)\n            P((cur <= best ? \"Possible\" : \"Impossible\"));\n        cur = lim;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<math.h>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst long long int INF=99999999999999,inf=199999;\nconst long long int mod=1000000007;\n\n\n\nlong long int tmp,n,canmove[25]={},v,x[200005],leftdp[800000]={},rightdp[800000]={};\nlong long int leftnext[25][800005]={},rightnext[25][800005]={},two[30]={1};\nlong long int leftmemo[800005]={},rightmemo[800005]={};\nlong long int cou=0,k;\n\nvoid leftsolve(){\n    long long int count=0;\n    queue<long long int>que,memoque;\n    que.push(0);\n    leftdp[0]=1;\n    while(1){\n        while(!que.empty()){\n            for(int i=0;i<k;i++){\n                if((que.front()/two[i]%2)==0){\n                    leftdp[que.front()+two[i]]=max(leftdp[que.front()+two[i]],leftnext[i][leftdp[que.front()]]);\n                    //次のループで被りが出ないように\n                    if(leftmemo[que.front()+two[i]]==0){\n                        memoque.push(que.front()+two[i]);\n                        leftmemo[que.front()+two[i]]=1;\n                    }\n                }\n            }\n            que.pop();\n        }\n        while(!memoque.empty()){\n            que.push(memoque.front());\n            memoque.pop();\n        }\n        if(que.front()==two[k]-1){\n            break;\n        }\n    }\n}\n\nvoid rightsolve(){\n    long long int count=0;\n    queue<long long int>que,memoque;\n    que.push(0);\n    \n    while(1){\n        while(!que.empty()){\n            for(int i=0;i<k;i++){\n                if((que.front()/two[i])%2==0){\n                    rightdp[que.front()+two[i]]=min(rightdp[que.front()+two[i]],rightnext[i][rightdp[que.front()]]);\n                   //次のループで被りが出ないように\n                    if(rightmemo[que.front()+two[i]]==0){\n                        memoque.push(que.front()+two[i]);\n                        rightmemo[que.front()+two[i]]=1;\n                    }\n                    //cout<<que.front()<<\" \"<<two[i]<<\" \"<<endl;\n                    //cout<<que.front()+two[i]<<\" \"<<rightdp[que.front()+two[i]]<<endl;\n                }\n            }\n            que.pop();\n        }\n        while(!memoque.empty()){\n            que.push(memoque.front());\n            memoque.pop();\n        }\n        if(que.front()==two[k]-1){\n            break;\n        }\n    }\n}\n\n\nint main() {\n    int count=0;\n    map<long long int,long long int>mp;\n\tcout << fixed << setprecision(10);\n    cin>>n>>v;\n    \n    for(int i=1;i<=26;i++){\n        two[i]=2*two[i-1];\n    }\n\n\n        for(int j=0;j<=799995;j++){\n            rightdp[j]=n;\n        }\n    \n\n    tmp=v;\n    while(tmp!=0){\n        canmove[cou]=tmp;\n        cou++;\n        tmp/=2;\n    }\n    k=cou+1;\n    \n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n    }\n    x[0]=-INF;\n    x[n+1]=INF;\n\n    for(int i=0;i<k;i++){\n        tmp=0;\n        for(int j=1;j<=n+1;j++){\n            if(x[j]-x[j-1]>canmove[i]){\n                for(int p=tmp;p<j;p++){\n                    leftnext[i][p]=j;\n                }\n                tmp=j;\n            }\n        }\n\n        tmp=n;\n        for(int j=n;j>=0;j--){\n            if(x[j+1]-x[j]>canmove[i]){\n                for(int p=tmp;p>j;p--){\n                    rightnext[i][p]=j;\n                }\n                tmp=j;\n            }\n        }\n    }\n    \n    leftsolve();\n    rightsolve();\n    \n    for(int i=1;i<=n;i++){\n        //cout<<rightnext[0][i]<<\" \"<<canmove[0]<<endl;\n    }\n    \n\n\n    \n    for(int i=1;i<=n;i=leftnext[0][i]){\n        bool key=true;\n        //cout<<\"........................\"<<endl;\n        for(int j=0;j<two[k];j+=2){\n            //cout<<j<<\" \"<<(j^(two[k]-2))<<\" \"<<leftdp[j]<<\" \"<<rightnext[0][i]<<\" \"<<rightdp[(j^(two[k]-2))]<<\" \"<<leftnext[0][i]<<endl;\n            if(leftdp[j]>rightnext[0][i]&&rightdp[(j^(two[k]-2))]<leftnext[0][i]){\n                for(int p=rightnext[0][i]+1;p<=leftnext[0][i]-1;p++){\n                    \n                    //cout<<j<<\" \"<<(j^(two[k]-2))<<\" \"<<leftdp[j]<<\" \"<<rightnext[0][i]<<\" \"<<rightdp[(j^(two[k]-2))]<<\" \"<<leftnext[0][i]<<endl;\n                    cout<<\"Possible\"<<endl;\n                    count++;\n                }\n                key=false;\n                break;\n            }\n        }\n        if(key){\n            \n           \n            for(int p=rightnext[0][i]+1;p<=leftnext[0][i]-1;p++){\n                        cout<<\"Impossible\"<<endl;\n                        count++;\n            }\n        }\n    }\n    //cout<<count;\n} \n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nvector<int> f(int N, int M, vector<int> dx) {\n\tvector<vector<int> > nxt(N + 1, vector<int>(M));\n\trep(j, M) nxt[N][j] = nxt[N - 1][j] = N;\n\tfor (int i = N - 2; i >= 0; i--) {\n\t\tnxt[i] = nxt[i + 1];\n\t\tfor (int j = dx[i]; j < M; j++) nxt[i][j] = i + 1;\n\t}\n\tvector<int> dp(1<<M);\n\trep(S, 1<<M)\n\t\trep(j, M) if (!(S>>j & 1)) {\n\t\t\tint _S = S | 1<<j;\n\t\t\tdp[_S] = max(dp[_S], nxt[dp[S]][j]);\n\t\t}\n\treturn dp;\n}\n\nvector<int> solve() {\n\tint N, V; cin >> N >> V;\n\tvector<int> x(N);\n\trep(i, N) scanf(\"%d\", &x[i]);\n\tvector<int> dx(N - 1);\n\trep(i, N - 1) dx[i] = x[i + 1] - x[i];\n\tbool ok2 = true;\n\trep(i, N - 1) if (dx[i] > V) ok2 = false;\n\tif (ok2) return vector<int>(N, true);\n\tvector<int> v;\n\tfor (int _V = V; _V; _V /= 2) v.pb(_V);\n\tv.pb(0);\n\tint M = v.size();\n\trep(i, N - 1) {\n\t\tint k;\n\t\tfor (k = 0; dx[i] <= v[k]; k++);\n\t\tdx[i] = k;\n\t}\n\tunion_find uf(N);\n\trep(i, N - 1) if (dx[i]) uf.unite(i, i + 1);\n\tvector<int> dp1 = f(N, M, dx);\n\treverse(dx.begin(), dx.end());\n\tvector<int> dp2 = f(N, M, dx);\n\tvector<bool> ok(N);\n\trep(S, 1<<(M - 1)) {\n\t\tint S1 = S<<1, S2 = (((1<<(M - 1)) - 1) - S)<<1;\n\t\tint i = min(dp1[S1], N - 1), j = max(0, N - 1 - dp2[S2]);\n\t\tif (i > j || uf.same(i, j)) ok[uf.find(i)] = true;\n\t}\n\tvector<int> ans(N);\n\trep(i, N) ans[i] = ok[uf.find(i)];\n\treturn ans;\n}\n\nint main() {\n\tvector<int> ans = solve();\n\tfor (int z: ans) if (z) printf(\"Possible\\n\"); else printf(\"Impossible\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#define rep(i,st,ed) for (int i=st;i<=ed;++i)\n#define fill(x,t) memset(x,t,sizeof(x))\n\nconst int N=200005;\n\nint f[N],g[N],p[N],L[N],R[N],ans[N];\nint left[25][N],righ[25][N];\nint n,V,tot;\n\nint read() {\n\tint x=0,v=1; char ch=getchar();\n\tfor (;ch<'0'||ch>'9';v=(ch=='-')?(-1):(v),ch=getchar());\n\tfor (;ch<='9'&&ch>='0';x=x*10+ch-'0',ch=getchar());\n\treturn x*v;\n}\n\nvoid pre(int v,int id) {\n\tfor (int i=1,j;i<=n;i=j+1) {\n\t\tfor (j=i;j<n&&p[j+1]-p[j]<=v;) j++;\n\t\trep(k,i,j) left[id][i]=j,righ[id][j]=i;\n\t}\n}\n\nvoid solve() {\n\tfor (int i=0,lim=(1<<tot);i<lim;++i) {\n\t\tg[i]=n+1;\n\t}\n\tfor (int i=0,lim=(1<<tot);i<lim;++i) {\n\t\trep(j,0,tot-1) if ((i>>j)&1) {\n\t\t\tf[i]=std:: max(f[i],left[j][f[i-(1<<j)]+1]);\n\t\t\tg[i]=std:: min(g[i],righ[j][g[i-(1<<j)]-1]);\n\t\t}\n\t}\n\tfor (int i=0,lim=(1<<tot);i<lim;++i) {\n\t\tint j=lim-i-1;\n\t\trep(k,1,n) if (f[i]+1>=L[k]&&g[j]<=R[k]+1) {\n\t\t\tans[k]=1;\n\t\t}\n\t}\n}\n\nint main(void) {\n\tn=read(),V=read();\n\trep(i,1,n) p[i]=read();\n\tfor (int v=V/2;;v>>=1) {\n\t\tpre(v,tot++);\n\t\tif (!v) break;\n\t}\n\tfor (int i=1,j;i<=n;i=j+1) {\n\t\tfor (j=i;j<n&&p[j+1]-p[j]<=V;) j++;\n\t\trep(k,i,j) L[k]=i,R[k]=j;\n\t}\n\tsolve();\n\trep(i,1,n) if (ans[i]) puts(\"Possible\");\n\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp make_pair\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint n,lv;\n\nint c[19][200005];\n\nbool dfs(int mask, int cur, int target){\n  if(cur == target) return true;\n  // dbg(mask,cur,target);\n  rep(i,1,lv) if((mask>>i)%2==0){\n    if(dfs(mask + (1<<i), (c[i][cur]+1)%n, target)) return true;\n  }\n  return false;\n}\n\n\nint main(){\n  int v;\n  cin>>n>>v;\n  vector<int> a(n);\n  rep(i,n) cin>>a[i];\n\n  lv = 33 - __builtin_clz(v);\n\n  for(int i=0, tv=v; i<lv; i++, tv/=2){\n    int p = n-1;\n    c[i][n-1] = n-1;\n    for(int j = n-2; j>=0; j--){\n      if(a[j+1] - a[j] > tv) p = j;\n      c[i][j] = p;\n    }\n  }\n\n  rep(i,n){\n    bool res = dfs(1, (c[0][i]+1)%n, i);\n    rep(j,i,c[0][i]+1) cout << (res ? \"Possible\" : \"Impossible\") << endl;\n    i = c[0][i];\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int L = 20;\nconst int MAX = 2 * 1000 * 100 + 47;\n\nint V[L];\nint sz = 0;\nint N[L][MAX];\nint P[L][MAX];\nint X[MAX];\nint dpL[1 << L];\nint dpR[1 << L];\nint ANS[MAX];\nset<PII> S;\nint M[MAX];\n\nvoid print(int mask)\n{\n\twhile (mask)\n\t{\n\t\tif (mask & 1)\n\t\t{\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << \" \";\n\t\t}\n\n\t\tmask >>= 1;\n\t}\n}\n\n//#define DEBUG\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tint n, v;\n\tcin >> n >> v;\n\tFOR(i, 0, n) cin >> X[i];\n\n\tV[0] = v;\n\tFOR(i, 1, L)\n\t{\n\t\tV[i] = V[i - 1] / 2;\n\t\tif (V[i] == 0)\n\t\t{\n\t\t\tsz = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treverse(V, V + sz);\n\tFOR(k, 0, L)\n\t{\n\t\tint v = V[k];\n\t\tN[k][n - 1] = n;\n\n\t\tRFOR(i, n - 1, 0)\n\t\t{\n\t\t\tif (abs(X[i + 1] - X[i]) > v)\n\t\t\t{\n\t\t\t\tN[k][i] = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tN[k][i] = N[k][i + 1];\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"N=\" << endl;\n\tFOR(k, 0, sz)\n\t{\n\t\tcout << V[k] << \": \";\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tcout << N[k][i] << \" \";\n\t\t}\n\n\t\tcout << endl;\n\t}\n#endif\n\n\tFOR(k, 0, L)\n\t{\n\t\tint v = V[k];\n\t\tP[k][0] = -1;\n\t\tFOR(i, 1, n)\n\t\t{\n\t\t\tif (abs(X[i] - X[i - 1]) > v)\n\t\t\t{\n\t\t\t\tP[k][i] = i - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tP[k][i] = P[k][i - 1];\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"P=\" << endl;\n\tFOR(k, 0, sz)\n\t{\n\t\tcout << V[k] << \": \";\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tcout << P[k][i] << \" \";\n\t\t}\n\n\t\tcout << endl;\n\t}\n#endif\n\n\tsz--;\n\n\tdpL[0] = 0;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tint x = dpL[mask];\n\t\tFOR(k, 0, sz)\n\t\t{\n\t\t\tif (mask & (1 << k)) continue;\n\n\t\t\tdpL[mask | (1 << k)] = max(dpL[mask | (1 << k)], N[k][x]);\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"dpL\" << endl;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tprint(mask);\n\t\tcout << \" :\";\n\t\tcout << dpL[mask] << endl;\n\t}\n#endif\n\n\tFOR(i, 0, 1 << sz) dpR[i] = n;\n\tdpR[0] = n - 1;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tint x = dpR[mask];\n\t\tFOR(k, 0, sz)\n\t\t{\n\t\t\tif (mask & (1 << k)) continue;\n\n\t\t\tdpR[mask | (1 << k)] = min(dpR[mask | (1 << k)], P[k][x]);\n\t\t}\n\t}\n\n\n#ifdef DEBUG\n\tcout << \"dpR\" << endl;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tprint(mask);\n\t\tcout << \" :\";\n\t\tcout << dpR[mask] << endl;\n\t}\n#endif\n\n\tFOR(i, 0, n) M[i] = INF;\n\tFOR(maskL, 0, 1 << sz)\n\t{\n\t\tint maskR = ((1 << sz) - 1) ^ maskL;\n\t\tint l = dpL[maskL] - 1;\n\t\tint r = dpR[maskR] + 1;\n#ifdef DEBUG\n\t\tcout << \"!!\" << l << \" \" << r << endl;\n#endif\n\t\tif (l != -1) M[l] = min(M[l], r);\n\t}\n\n#ifdef DEBUG\n\tcout << \"M=\" << endl;\n\tFOR(i, 0, n)\n\t{\n\t\tcout << M[i] << \" \";\n\t}\n\n\tcout << endl;\n#endif\n\n\tRFOR(i, n - 1, 0) M[i] = min(M[i + 1], M[i]);\n\t\n\tFOR(i, 0, n)\n\t{\n\t\tint l = P[sz][i] + 1;\n\t\tint r = N[sz][i] - 1;\n\t\tif (S.find(MP(l, r)) != S.end()) continue;\n\n\t\tif (M[max(l - 1, 0)] <= r + 1)\n\t\t{\n\t\t\tFOR(k, l, r + 1) ANS[k] = 1;\n\t\t}\n\t}\n\n\tFOR(i, 0, n)\n\t{\n\t\tif (ANS[i])\n\t\t{\n\t\t\tcout << \"Possible\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcout << \"Impossible\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200200, lg = 19;\nint vi[lg], seg[lg][maxn], tol[lg][maxn], tor[lg][maxn], sl[lg][maxn], sr[lg][maxn], a[maxn];\nint n, v, stk;\nlong long dpl[30][maxn], dpr[30][maxn];\nint main(){\n\tcin >> n >> v;\n\twhile(v){\n\t\tvi[stk++] = v;\n\t\tv /= 2;\n\t}\n\tvi[stk++] = 0;\n\treverse(vi, vi + stk);\n\tfor(int i = 1; i <= n; i++) cin >> a[i];\n\tfor(int j = 0; j < stk; j++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i == 1 || a[i] - a[i - 1] > vi[j]) tol[j][i] = i, sl[j][i] = sl[j][i-1] + 1;\n\t\t\telse tol[j][i] = tol[j][i-1], sl[j][i] = sl[j][i-1];\n\t\t}\n\t\tfor(int i = n; i >= 1; i--){\n\t\t\tif(i == n || a[i + 1] - a[i] > vi[j]) tor[j][i] = i, sr[j][i] = sr[j][i+1] + 1;\n\t\t\telse tor[j][i] = tor[j][i+1], sr[j][i] = sr[j][i+1];\n\t\t}\n\t}\n\tif(sr[0][n] > lg){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcout << \"Impossible\\n\";\n\t\t}\n\t\treturn 0;\n\t}\n\tconst long long full = (1ll<<30) - 1;\n\tauto merge = [&](long long a, long long b){\n\t\twhile(a & b) b <<= 1;\n\t\treturn a | b;\n\t};\n\tauto combine = [&](long long a, long long b){\n\t\twhile(b){\n\t\t\tlong long l = b & - b;\n\t\t\ta = merge(a, l);\n\t\t\tb ^= l;\n\t\t}\n\t\treturn a;\n\t};\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < 30; j++) dpl[j][i] = full;\n\t\tfor(int j = 0; j < stk; j++){\n\t\t\tfor(int k = 0; k < 30; k++){\n\t\t\t\tlong long q = merge(dpl[k][tol[j][i]-1], 1<<j);\n\t\t\t\tint cn = min(29, __builtin_popcountll(q));\n\t\t\t\tdpl[cn][i] = min(dpl[cn][i], q);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = n; i >= 1; i--){\n\t\tfor(int j = 0; j < 30; j++) dpr[j][i] = full;\n\t\tfor(int j = 0; j < stk; j++){\n\t\t\tfor(int k = 0; k < 30; k++){\n\t\t\t\tlong long q = merge(dpr[k][tor[j][i]+1], 1<<j);\n\t\t\t\tint cn = min(29, __builtin_popcountll(q));\n\t\t\t\tdpr[cn][i] = min(dpr[cn][i], q);\n\t\t\t}\t\n\t\t}\n\t}\n\tfor(int i = 1, j = 1; i <= n; i = j){\n\t\twhile(j + 1 <= n && a[j + 1] - a[j] <= vi[stk - 1]) j++;\n\t\tbool possible = false;\n\t\tfor(int k0 = 0; k0 < 30; k0++){\n\t\t\tfor(int k1 = 0; k1 < 30; k1++){\t\n\t\t\t\tlong long a = dpl[k0][i - 1], b = dpr[k1][j + 1];\n\t\t\t\ta = min(combine(a, b), combine(b, a));\n\t\t\t\tpossible |= __builtin_popcountll(a) < stk && a < (1<<(stk - 1));\n\t\t\t}\n\t\t}\n\t\tfor(int k = i; k <= j; k++){\n\t\t\tif(possible) cout << \"Possible\\n\";\n\t\t\telse cout << \"Impossible\\n\";\n\t\t}\n\t\tj++;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nconst int NMAX = 300000;\nconst int LOGN = 20;\nint V[LOGN];\nint Lmost[NMAX][LOGN], Rmost[NMAX][LOGN];\n \nint dpL[1<<LOGN], dpR[1<<LOGN];\nint arr[NMAX+1];\nint dp[NMAX+2];\n \nint main(){\n    int N; scanf(\"%d%d\",&N,&V[0]);\n    for(int i=1;i<=N;i++) scanf(\"%d\",arr+i);\n \n    int M = 1;\n    while(V[M-1]){\n        V[M] = V[M-1]/2;\n        M++;\n    }\n \n    for(int i=0;i<M;i++){\n        int v = V[i];\n        int j = 1;\n        while(j<=N){\n            int k = j+1;\n            while(k<=N && arr[k]-arr[k-1] <= v) k++;\n            for(int x=j;x<k;x++) Rmost[x][i] = k-1;\n            j = k;\n        }\n        j = N;\n        while(j>=1){\n            int k = j-1;\n            while(k>=1 && arr[k+1]-arr[k] <= v) k--;\n            for(int x=j;x>k;x--) Lmost[x][i] = k+1;\n            j = k;\n        }\n    }\n \n    for(int i=0;i<(1<<M);i++) dpR[i] = N+1;\n    for(int i=1;i<(1<<M);i++){\n        for(int j=0;j<M;j++) if(i&(1<<j)){\n            // use V[j]\n            int L = dpL[i^(1<<j)];\n            dpL[i] = max(dpL[i], Rmost[L+1][j]);\n \n            int R = dpR[i^(1<<j)];\n            dpR[i] = min(dpR[i], Lmost[R-1][j]);\n        }\n    }\n \n    for(int i=0;i<=N+1;i++) dp[i] = -0x3fFFffFF;\n \n    for(int i=0;i<(1<<M);i+=2){\n        int j = ((1<<M)-1)^i^1;\n        dp[dpR[j]] = max(dp[dpR[j]], dpL[i]);\n    }\n \n    for(int i=1;i<=N+1;i++)\n        dp[i] = max(dp[i], dp[i-1]);\n \n    for(int i=1;i<=N;i++){\n        int L = Lmost[i][0], R = Rmost[i][0];\n        int det = dp[R+1];\n        if(det>=L-1) printf(\"Possible\\n\");\n        else printf(\"Impossible\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nconst int L=20;\nvi sub(vi x,int v){\n\tint n=x.size();\n\tvi res(1<<L);\n\tvi r[L];\n\trep(k,L){\n\t\tr[k].resize(n+1);\n\t\tif(((v<<1)>>k)==0)continue;\n\t\tr[k][n]=n;\n\t\tper(i,n){\n\t\t\tint j=i+1;\n\t\t\tif(j<n&&x[j]-x[i]<=(v>>k))\n\t\t\t\tj=r[k][j];\n\t\t\tr[k][i]=j;\n\t\t}\n\t}\n\trep(bit,1<<L){\n\t\trep(i,L)if(!(bit&1<<i)){\n\t\t\tchmax(res[bit^1<<i],r[i][res[bit]]);\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,v;cin>>n>>v;\n\tvi x=readvi(n);\n\t\n\tvi len[2];\n\trep(k,2){\n\t\tlen[k]=sub(x,v);\n\t\trep(i,n)x[i]=-x[i];\n\t\treverse(all(x));\n\t}\n\tdmp(len[1][1]);\n\t\n\tvc<string> ans(n,\"Impossible\");\n\tif(len[0][(1<<L)-1]==n){\n\t\trep(i,n){\n\t\t\tif(i&&x[i]-x[i-1]<=v)\n\t\t\t\tans[i]=ans[i-1];\n\t\t\telse{\n\t\t\t\tint j=i+1;\n\t\t\t\twhile(j<n&&x[j]-x[j-1]<=v)j++;\n\t\t\t\trep(bit,1<<(L-1)){\n\t\t\t\t\tint a=bit<<1;\n\t\t\t\t\tint y=(mask(L-1)^bit)<<1;\n\t\t\t\t\tif(len[0][a]>=i&&len[1][y]>=n-j){\n\t\t\t\t\t\tans[i]=\"Possible\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(auto w:ans)\n\t\tcout<<w<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define MAX 200200\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nvoid cmax(int &x,int y){if(x<y)x=y;}\nvoid cmin(int &x,int y){if(x>y)x=y;}\nint n,V[25],x[MAX],t;\nint L[20][MAX],R[20][MAX],mr[MAX];\nint sl[1<<19],sr[1<<19];\nint main()\n{\n\tn=read();V[0]=read();\n\tfor(int i=1;i<=n;++i)x[i]=read();\n\twhile(V[t])V[t+1]=V[t]>>1,++t;int S=1<<t;\n\tfor(int i=0;i<=t;++i)\n\t{\n\t\tL[i][1]=1;R[i][n]=n;\n\t\tfor(int j=2;j<=n;++j)\n\t\t\tif(x[j]-x[j-1]<=V[i])L[i][j]=L[i][j-1];\n\t\t\telse L[i][j]=j;\n\t\tfor(int j=n-1;~j;--j)\n\t\t\tif(x[j+1]-x[j]<=V[i])R[i][j]=R[i][j+1];\n\t\t\telse R[i][j]=j;\n\t}\n\tfor(int i=1;i<S;++i)sl[i]=1,sr[i]=n;\n\tsl[0]=0;sr[0]=n+1;\n\tfor(int i=0;i<S;++i)\n\t\tfor(int j=1;j<=t;++j)\n\t\t\tif(!(i&(1<<(j-1))))\n\t\t\t{\n\t\t\t\tcmax(sl[i|(1<<(j-1))],R[j][sl[i]+1]);\n\t\t\t\tcmin(sr[i|(1<<(j-1))],L[j][sr[i]-1]);\n\t\t\t}\n\tmemset(mr,63,sizeof(mr));\n\tfor(int j=0;j<S;++j)cmin(mr[sl[j]],sr[(S-1)^j]);\n\tfor(int i=n;~i;--i)mr[i]=min(mr[i],mr[i+1]);\n\tfor(int i=1;i<=n;++i)puts(mr[L[0][i]-1]<=R[0][i]+1?\"Possible\":\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\n#include<ctime>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==' '||c=='\\n')c=_buff.get();return c;}\nint n,V,v[20],vn,a[200111];\nint go[20][200111];\nint dp[1<<20],dpl[1<<20],dpr[1<<20];\nint gol[20][200111],gor[20][200111];\n\nvoid solve()\n{\n\tmemset(dp,0,sizeof(dp));\n\tfor(int i=0;i<=vn;i++)\n\t{\n\t\tgo[i][n]=go[i][n+1]=n;\n\t\tfor(int j=n-1;j>=1;j--)\n\t\t{\n\t\t\tif(a[j+1]-a[j]<=v[i])go[i][j]=go[i][j+1];\n\t\t\telse go[i][j]=j;\n\t\t}\n\t}\n\tfor(int i=1;i<(1<<vn);i++)\n\t{\n\t\tfor(int j=0;j<vn;j++)\n\t\t{\n\t\t\tif((i>>j)&1)\n\t\t\t{\n\t\t\t\tint t=i&~(1<<j);\n\t\t\t\tdp[i]=max(dp[i],go[j][dp[t]+1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint mx[200111];\nint main()\n{\n\tgetii(n,V);\n\tint tV=V;\n\twhile(tV)tV>>=1,v[vn++]=tV;\n//\tfor(int i=0;i<vn;i++)cerr<<v[i]<<\" \";cerr<<endl;\n\tv[vn]=V;\n\tfor(int i=1;i<=n;i++)geti(a[i]);\n\tsolve();\n\treverse(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)a[i]=-a[i];\n\tfor(int i=0;i<1<<vn;i++)dpl[i]=dp[i];\n\tfor(int i=0;i<=vn;i++)for(int j=1;j<=n;j++)gor[i][j]=go[i][j];\n\tsolve();\n//\treverse(a+1,a+n+1);\n\n\tfor(int i=0;i<1<<vn;i++)dpr[i]=dp[i];\n\tfor(int i=0;i<=vn;i++)for(int j=1;j<=n;j++)gol[i][n-j+1]=n-go[i][j]+1;\n\tmemset(dp,0,sizeof(dp));\n\t\n\tmemset(mx,-1,sizeof(mx));\n\tint msk=(1<<vn)-1;\n\tfor(int i=0;i<1<<vn;i++)\n\t{\n//\t\tcerr<<dpl[i]<<\" \"<<dpr[msk-i]<<endl;\n\t\tmx[dpl[i]]=max(mx[dpl[i]],dpr[msk-i]);\n\t}\n\tfor(int i=n;i>=0;i--)mx[i]=max(mx[i],mx[i+1]);\n/*\tfor(int i=0;i<vn;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcerr<<gor[i][j]<<\" \";\n\t\t}cerr<<endl;\n\t}*/\n\tfor(int i=1;i<=n;i++)\n\t{\n//\t\tcerr<<gol[vn][i]<<\" \"<<gor[vn][i]<<\" \"<<mx[gol[vn][i]-1]<<endl;\n\t\tif(mx[gol[vn][i]-1]>=n-gor[vn][i])\n\t\t{\n\t\t\tputs(\"Possible\");\n\t\t}\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// a.cpp\n\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < __typeof(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < ll >\n# define pb push_back\n# define pdd pair < db , db >\ninline int readChar();\ntemplate <class T = int> inline T readInt();\ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x );\ninline void writeWord( const char *s );\n\n/** Read */\n\nstatic const int buf_size = 4096;\n\ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len)\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    if (pos == len)\n        return -1;\n    return buf[pos++];\n}\n\ninline int readChar() {\n    int c = getChar();\n    while (c <= 32)\n        c = getChar();\n    return c;\n}\n\ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n\n/** Write */\n\nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n\ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n\ntemplate <class T>\ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n\n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n\ninline void writeWord( const char *s ) {\n    while (*s)\n        writeChar(*s++);\n}\n\nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int RMQ[20][1 << 19];\n    static int Dp1[20][1 << 19];\n    static int Dp2[20][1 << 19];\n    int n,k;\n    n = readInt();\n    k = readInt();\n    static int s[1 << 20];\n    for (int i = 1;i <= n;++i)\n        s[i] = readInt();\n    for (int i = 1;i < n;++i)\n        RMQ[0][i] = s[i + 1] - s[i];\n    for (int t = 1;n >> t;++t)\n        for (int i = 1;i + (1 << t) <= n + 1;++i)\n            RMQ[t][i] = max(RMQ[t - 1][i],RMQ[t - 1][i + (1 << (t - 1))]);\n    static int Log[1 << 20];\n    for (int i = 2;i <= (1 << 19);++i)\n        Log[i] = Log[i / 2] + 1;\n    auto get = [&](int l,int r)\n    {\n        int lg = Log[r - l + 1];\n        return max(RMQ[lg][l],RMQ[lg][r - (1 << lg) + 1]);\n    };\n    static int D1[1 << 20];\n    static int D2[1 << 20];\n    int lg = Log[k] + 2;\n    const int N = 1 << lg;\n    for (int t = 0;t < lg;++t)\n    {\n        Dp1[t][1] = 0;\n        for (int i = 2;i <= n;++i)\n            if (s[i] - s[i - 1] <= (k >> t))\n                Dp1[t][i] = Dp1[t][i - 1];\n            else\n                Dp1[t][i] = i - 1;\n        Dp2[t][n] = Dp2[t][n + 1] = n + 1;\n        for (int i = n - 1;i;--i)\n            if (s[i + 1] - s[i] <= (k >> t))\n                Dp2[t][i] = Dp2[t][i + 1];\n            else\n                Dp2[t][i] = i + 1;\n    }\n    D1[0] = 0;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            if ((mask >> i) & 1)\n                smax(D1[mask],Dp2[i][D1[mask ^ (1 << i)] + 1] - 1);\n    for (int mask = 0;mask < N;++mask)\n        D2[mask] = n + 1;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            smin(D2[mask],Dp1[i][D2[mask ^ (1 << i)] - 1] + 1);\n    static int answer[1 << 20];\n    for (int mask1 = 0;mask1 < N;++mask1)\n        if (!(mask1 & 1))\n        {\n            int mask2 = (N - 1) ^ 1 ^ mask1;\n            const int l = D1[mask1];\n            const int r = D2[mask2];\n            if (l + 1 > r - 1)\n                answer[1]++,--answer[n + 1];\n            else\n            if (l + 1 == r - 1 || get(l + 1,r - 2) <= k)\n                ++answer[l + 1],--answer[r];\n        }\n    for (int i = 1;i <= n;++i)\n        answer[i] += answer[i - 1];\n    for (int i = 1;i <= n;++i)\n        if (answer[i])\n            PP;\n        else\n            II;\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nint goR[200005][20];\nint goL[200005][20];\nint a[200005];\nint n,v;\nint R(int x,int k,int v){\n    if(x==n+1)return n;\n    if(goR[x][k]!=-1)return goR[x][k];\n    if(a[x+1]-a[x]>(v>>k))return goR[x][k]=x;\n    return goR[x][k]=R(x+1,k,v);\n}\nint L(int x,int k,int v){\n    if(x==0)return 1;\n    if(goL[x][k]!=-1)return goL[x][k];\n    if(a[x]-a[x-1]>(v>>k))return goL[x][k]=x;\n    return goL[x][k]=L(x-1,k,v);\n}\nint dpR[1<<20];\nint dpL[1<<20];\n\nint DPR(int x){\n    if(x==0)return 0;\n    if(dpR[x]!=-1)return dpR[x];\n    dpR[x]=0;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpR[x]=max(dpR[x],R(DPR(x-(1<<i))+1,i,v));\n        }\n    }\n    return dpR[x];\n}\nint DPL(int x){\n    if(x==0)return n+1;\n    if(dpL[x]!=-1)return dpL[x];\n    dpL[x]=1e9+1;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpL[x]=min(dpL[x],L(DPL(x-(1<<i))-1,i,v));\n        }\n    }\n    return dpL[x];\n}\nint main(){ \n    MEMS(goR);MEMS(goL);MEMS(dpR);MEMS(dpL);\n    scanf(\"%d %d\",&n,&v);\n    for(int i = 1;i<=n;i++)\n        //a[i]=-1e9+2e5*i;\n        scanf(\"%d\",&a[i]);\n    a[0]=-1e9-1e8;\n    a[n+1]=1e9+1e8;\n    int Max=1;\n    for(int i = 1;;i++){\n        Max=i+1;\n        if(!(v>>i))break;\n    }\n\n    if(DPR((1<<Max)-1)<n){\n        for(int i = 1;i<=n;i++){\n            printf(\"Impossible\\n\");\n        }\n        return 0;\n    }\n    for(int i = 1;i<=n;){\n        int l=i,r=R(i,0,v);\n       // printf(\"%d %d\\n\",l,r);\n        int ok=0;\n        for(int j=0;j<(1<<Max);j++){\n            int a=j,b=(1<<Max)-j;\n            if(a&1)a--;\n            if(b&1)b--;\n            if(DPR(a)>=l-1&&DPL(b)<=r+1){\n                ok=1;\n                break;\n            }\n        }\n        if(ok){\n            for(int i=l;i<=r;i++)printf(\"Possible\\n\");\n        }\n        else{\n            for(int i = l;i<=r;i++)printf(\"Impossible\\n\");\n        }\n        i=r+1;\n    }\n}\n/*\n2 2 1\n3 2 3\n4 2 4 4 7\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstatic const int NMAX = 200000;\nstatic const int MMAX = 18;\n\nstatic int N, M, X[NMAX];\nstatic int A[1 << (1 + MMAX)];\nstatic int B[1 << (1 + MMAX)];\nstatic int Y[NMAX + 1][1 + MMAX];\n\nstatic void solve(int *C) {\n\tfor(int m = 0; m <= M; m++) Y[N][m] = N;\n\tfor(int i = N; --i > 0; ) {\n\t\tfor(int m = 0; m <= M; m++) Y[i][m] = (m < X[i] ? i : Y[i + 1][m]);\n\t}\n\tfor(int mask = 1; mask < (1 << (1 + M)); mask++) {\n\t\tint ret = 0;\n\t\tfor(int i = 0; i <= M; i++) {\n\t\t\tif((mask & (1 << i)) == 0) continue;\n\t\t\tauto tmp = C[mask ^ (1 << i)];\n\t\t\tif(tmp == N) {\n\t\t\t\tret = N;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp = Y[tmp + 1][i];\n\t\t\tif(tmp > ret) {\n\t\t\t\tret = tmp;\n\t\t\t\tif(ret == N) break;\n\t\t\t}\n\t\t}\n\t\tC[mask] = ret;\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i = 0; i < N; i++) scanf(\"%d\", X + i);\n\n\t{\n\t\tvector<int> v;\n\t\tfor(; ; M >>= 1) {\n\t\t\tv.push_back(M);\n\t\t\tif(M == 0) break;\n\t\t}\n\t\tM = v.size() - 1;\n\t\treverse(begin(v), end(v));\n\t\tfor(int i = N; --i > 0; ) {\n\t\t\tX[i] = lower_bound(begin(v), end(v), X[i] - X[i - 1]) - begin(v);\n\t\t}\n\t}\n\n\tsolve(A);\n\tif(A[(1 << (1 + M)) - 1] != N) {\n\t\tfor(int i = 0; i < N; i++) puts(\"Impossible\");\n\t} else {\n\t\tvector<int> v;\n\t\tfor(int i = 0; i < N; ) {\n\t\t\tauto j = Y[i + 1][M];\n\t\t\tv.push_back(j - i);\n\t\t\ti = j;\n\t\t}\n\t\treverse(X + 1, X + N);\n\t\tsolve(B);\n\t\tint l = 0;\n\t\tfor(auto s : v) {\n\t\t\tauto z = false;\n\t\t\tfor(int i = 0; i < (1 << M); i++) {\n\t\t\t\tif(A[i] < l) continue;\n\t\t\t\tauto j = ((1 << M) - 1) ^ i;\n\t\t\t\tif(B[j] >= N - (l + s)) {\n\t\t\t\t\tz = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < s; i++) puts(z ? \"Possible\" : \"Impossible\");\n\t\t\tl += s;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 200010;\nconst int M = 19;\n\nint a[N], v[N], dppre[1 << M], dpsuf[1 << M], pre[M][N], suf[N][M], ans[N];\nint n, V, m;\n\nint main(){\n\tscanf(\"%d%d\", &n, &V);\n\tv[0] = V;\n\tfor (int i = 1; ; ++ i){\n\t\tv[i] = v[i - 1] >> 1;\n\t\tif (!v[i]){\n\t\t\tm = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++ i){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 0; i < m; ++ i){\n\t\tpre[i][n - 1] = n - 1;\n\t\tfor (int j = n - 2; j >= 0; -- j){\n\t\t\tif (a[j + 1] - a[j] <= v[i]){\n\t\t\t\tpre[i][j] = pre[i][j + 1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpre[i][j] = j;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; ++ i){\n\t\tsuf[i][0] = 0;\n\t\tfor (int j = 0; j < n - 1; ++ j){\n\t\t\tif (a[j + 1] - a[j] <= v[i]){\n\t\t\t\tsuf[i][j + 1] = suf[i][j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsuf[i][j + 1] = j + 1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dppre, -1, sizeof(dppre));\n\tfor (int i = 0; i < 1 << m; ++ i){\n\t\tdpsuf[i] = n;\n\t}\n\tfor (int i = 0; i < 1 << m - 1; ++ i){\n\t\tint x = dppre[i];\n\t\tfor (int j = 0; j < m - 1; ++ j){\n\t\t\tif (i >> j & 1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint &y = dppre[i | 1 << j];\n\t\t\tif (x == n - 1){\n\t\t\t\ty = n - 1;\n\t\t\t}\n\t\t\ty = std::max(y, pre[j + 1][x + 1]);\n\t\t}\n\t\tx = dpsuf[i];\n\t\tfor (int j = 0; j < m - 1; ++ j){\n\t\t\tif (i >> j & 1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint &y = dpsuf[i | 1 << j];\n\t\t\tif (!x){\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t\ty = std::min(y, suf[j + 1][x - 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < 1 << m - 1; ++ i){\n\t\tint j = (1 << m - 1) - i - 1;\n\t\tint x = dppre[i] + 1, y = dpsuf[j] - 1;\n\t\tif (x >= y){\n\t\t\t++ ans[0];\n\t\t\t-- ans[n];\n\t\t}\n\t\tif (pre[0][x] >= y){\n\t\t\t++ ans[suf[0][x]];\n\t\t\t-- ans[pre[0][y] + 1];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++ i){\n\t\tans[i + 1] += ans[i];\n\t\tprintf(ans[i] ? \"Possible\\n\" : \"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <sstream>\n#include <stack>\n#include <time.h>\n#include <vector>\n#include <complex>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <math.h>\n#include <stdlib.h>\n#include <list>\n#include <utility>\n#include <memory>\n#include <cstring>\n#include <fstream>\n#include <numeric>\n#include <assert.h>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\nint N,M,Q;\nvector <int> g[100004];\nint col[100004];\nint dist[100004];\nvoid bfs(int v,int d,int c){\n\tfill (dist,dist+100004,1e7);\n\tqueue <int> q;\n\tdist[v]=0;\n\tq.push(v);  \n\twhile(!q.empty()){\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tif (dist[x]==d) break;\n\t\tfor (int i=0;i<g[x].size();i++){\n\t\t\tint n=g[x][i];\n\t\t\tif (dist[n]>dist[x]+1){\n\t\t\t\tdist[n]=dist[x]+1;\n\t\t\t\tq.push(n);  \n\t\t\t\tif (dist[n]<=d) col[x]=1;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tmemset (col,0,sizeof(col));\n\tcin>>N>>M;\n\tfor (int i=0;i<M;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tcin>>Q;\n\tfor (int i=0;i<Q;i++){\n\t\tint v,d,c;\n\t\tcin>>v>>d>>c;\n\t\tbfs(v,d,c);\n\t}\n\tfor (int i=1;i<=N;i++)\n\t\tcout<<col[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 4e05 + 10;\nconst int MAXL = 20 + 5;\n\nint N, V, lgv = 0;\nint a[MAXN];\nint sec[MAXN]= {0};\n\nint extl[MAXN][MAXL]= {0}, extr[MAXN][MAXL]= {0};\nint f[2][MAXN]= {0};\nbool answer[MAXN]= {false};\nvoid work (int p, int l, int r) {\n\tint n = lgv - 1;\n\tint limit = (1 << n) - 1;\n\tf[p][0] = l - 1;\n\tfor (int state = 1; state <= limit; state ++) {\n\t\tf[p][state] = l - 1;\n\t\tfor (int j = 1; j <= n; j ++)\n\t\t\tif (state & (1 << (j - 1))) {\n\t\t\t\tint pre = f[p][state ^ (1 << (j - 1))];\n\t\t\t\tf[p][state] = max (f[p][state], f[p][state ^ (1 << (j - 1))]);\n\t\t\t\tf[p][state] = max (f[p][state], extr[pre + 1][j]);\n\t\t\t}\n\t}\n}\nvoid solve () {\n\tint n = lgv - 1;\n\tint cnt = 0;\n\tfor (int i = 1; i <= N; i ++) {\n\t\tif (extl[i][lgv] == extl[i - 1][lgv] && extr[i][lgv] == extr[i - 1][lgv]) {\n\t\t\tanswer[i] = answer[i - 1];\n\t\t\tcontinue;\n\t\t}\n\t\tcnt ++;\n\t\tif (cnt > lgv) {\n\t\t\tfor (int j = 1; j <= N; j ++) answer[j] = false;\n\t\t\treturn ;\n\t\t}\n\t\tint pl = extl[i][lgv], pr = extr[i][lgv];\n\t\tif (pl != 1) work (0, 1, pl - 1);\n\t\tif (pr != N) work (1, pr + 1, N);\n\t\tint limit = (1 << n) - 1;\n\t\tif (pl == 1 && pr == N) answer[i] = true;\n\t\telse if (pl == 1) answer[i] = f[1][limit] >= N;\n\t\telse if (pr == N) answer[i] = f[0][limit] >= pl - 1;\n\t\telse {\n\t\t\tfor (int state = 1; state <= limit; state ++)\n\t\t\t\tif (f[0][state] >= pl - 1 && f[1][limit ^ state] >= N) {\n\t\t\t\t\tanswer[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint getnum () {\n\tint num = 0;\n\tchar ch = getchar ();\n\tbool isneg = false;\n\n\twhile (! isdigit (ch)) {\n\t\tif (ch == '-') isneg = true;\n\t\tch = getchar ();\n\t}\n\twhile (isdigit (ch))\n\t\tnum = (num << 3) + (num << 1) + ch - '0', ch = getchar ();\n\n\treturn isneg ? - num : num;\n}\n\nint main () {\n\t// freopen (\"Input.txt\", \"r\", stdin);\n\t// freopen (\"Output.txt\", \"w\", stdout);\n\n\tN = getnum (), V = getnum ();\n\tfor (int i = 1; i <= N; i ++)\n\t\ta[i] = getnum ();\n\tfor (int s = V; s > 0; s >>= 1)\n\t\tsec[++ lgv] = s;\n\tsec[++ lgv] = 0;\n\treverse (sec + 1, sec + lgv + 1);\n\tfor (int l = 1; l <= lgv; l ++) {\n\t\tfor (int i = 1; i <= N; i ++) {\n\t\t\tif (i == 1) extl[i][l] = 1;\n\t\t\telse extl[i][l] = a[i] - a[i - 1] <= sec[l] ? extl[i - 1][l] : i;\n\t\t}\n\t\tfor (int i = N; i >= 1; i --) {\n\t\t\tif (i == N) extr[i][l] = N;\n\t\t\telse extr[i][l] = a[i + 1] - a[i] <= sec[l] ? extr[i + 1][l] : i;\n\t\t}\n\t}\n\t/*for (int l = 1; l <= lgv; l ++) {\n\t\tcout << \"now: \" << sec[l] << endl;\n\t\tfor (int i = 1; i <= N; i ++)\n\t\t\tcout << extl[i][l] << ' ' << extr[i][l] << endl;\n\t}*/\n\tsolve ();\n\tfor (int i = 1; i <= N; i ++)\n\t\tanswer[i] ? puts (\"Possible\") : puts (\"Impossible\");\n\n\treturn 0;\n}\n\n/*\n3 2\n1 3 6\n*/\n\n/*\n7 2\n-10 -4 -2 0 2 4 10\n*/\n\n/*\n16 19\n-49 -48 -33 -30 -21 -14 0 15 19 23 44 52 80 81 82 84\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nint goR[200005][20];\nint goL[200005][20];\nint a[200005];\nint R(int x,int k,int v){\n    if(goR[x][k]!=-1)return goR[x][k];\n    if(a[x+1]-a[x]>(v>>k))return goR[x][k]=x;\n    return goR[x][k]=R(x+1,k,v);\n}\nint L(int x,int k,int v){\n    if(goL[x][k]!=-1)return goL[x][k];\n    if(a[x]-a[x-1]>(v>>k))return goL[x][k]=x;\n    return goL[x][k]=L(x-1,k,v);\n}\nint dpR[1<<20];\nint dpL[1<<20];\nint n,v;\nint DPR(int x){\n    if(x==0)return 0;\n    if(dpR[x]!=-1)return dpR[x];\n    dpR[x]=0;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpR[x]=max(dpR[x],R(DPR(x-(1<<i))+1,i,v));\n        }\n    }\n    return dpR[x];\n}\nint DPL(int x){\n    if(x==0)return n+1;\n    if(dpL[x]!=-1)return dpL[x];\n    dpL[x]=1e9+1;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpL[x]=min(dpL[x],L(DPL(x-(1<<i))-1,i,v));\n        }\n    }\n    return dpL[x];\n}\nint main(){ \n    MEMS(goR);MEMS(goL);MEMS(dpR);MEMS(dpL);\n    scanf(\"%d %d\",&n,&v);\n    for(int i = 1;i<=n;i++)\n        //a[i]=-1e9+2e5*i;\n        scanf(\"%d\",&a[i]);\n    a[0]=-1e9-1e8;\n    a[n+1]=1e9+1e8;\n    int Max=1;\n    for(int i = 1;;i++){\n        Max=i+1;\n        if(!(v>>i))break;\n    }\n\n    if(DPR((1<<Max)-1)!=n){\n        for(int i = 1;i<=n;i++){\n            printf(\"Impossible\\n\");\n        }\n        return 0;\n    }\n    for(int i = 1;i<=n;){\n        int l=i,r=R(i,0,v);\n       // printf(\"%d %d\\n\",l,r);\n        int ok=0;\n        for(int j=0;j<(1<<Max);j++){\n            int a=j,b=(1<<Max)-j;\n            if(a&1)a--;\n            if(b&1)b--;\n            if(DPR(a)>=l-1&&DPL(b)<=r+1){\n                ok=1;\n                break;\n            }\n        }\n        if(ok){\n            for(int i=l;i<=r;i++)printf(\"Possible\\n\");\n        }\n        else{\n            for(int i = l;i<=r;i++)printf(\"Impossible\\n\");\n        }\n        i=r+1;\n    }\n}\n/*\n2 2 1\n3 2 3\n4 2 4 4 7\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)\n#define trav(it, v) for(typeof((v).begin()) it = (v).begin(); it != (v).end(); ++it)\n#define all(v) (v).begin(), (v).end()\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n\ntypedef double fl;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\t\nint N, V;\nint x[200005];\nint nodeInd;\n\nstruct Node{\n\tint l, r;\n\tint v;\n\tvector<Node> children;\n\tint ind;\n\n\tNode(int _l, int _r, int _v){\n\t\tind=nodeInd++;\n\t\tl=_l;\n\t\tr=_r;\n\t\tv=_v;\n\t\tif(!v)\n\t\t\treturn;\n\t\tint L=l;\n\t\trep(i,l+1,r){\n\t\t\tif(x[i] > x[i-1]+v){\n\t\t\t\tchildren.push_back(Node(L, i, v/2));\n\t\t\t\tL=i;\n\t\t\t}\n\t\t}\n\t\tchildren.push_back(Node(L, r, v/2));\n\t}\n};\n\nbool ans[200005];\nmap<vector<int>, bool> cache;\nvector<Node*> deleted;\n\nbool rec(vector<Node*> nodes, int stepsLeft, bool init){\n\tvector<int> key;\n\trep(i,0,nodes.size()){\n\t\tkey.push_back(nodes[i]->ind);\n\t}\n\tif(cache.count(key))\n\t\treturn cache[key];\n\tif(nodes.empty())\n\t\treturn true;\n\tif(nodes[0]->v == 0)\n\t\treturn nodes.size() == 1;\n\tvector<Node*> newNodes;\n\trep(i,0,nodes.size()){\n\t\tif(newNodes.size()+nodes[i]->children.size() > stepsLeft)\n\t\t\treturn 0;\n\t\trep(j,0,nodes[i]->children.size())\n\t\t\tnewNodes.push_back(&(nodes[i]->children[j]));\n\t}\n\t/*bool hasUrgent=false;\n\trep(i,0,newNodes.size())\n\t\tif(newNodes[i]->children.size() > 1)\n\t\t\thasUrgent = true;*/\n\trep(i,0,newNodes.size()){\n\t\tvector<Node*> newNewNodes = newNodes;\n\t\tnewNewNodes.erase(newNewNodes.begin()+i);\n\t\tdeleted.push_back(newNodes[i]);\n\t\tif(rec(newNewNodes, stepsLeft-1, 0)){\n\t\t\tif(init){\n\t\t\t\trep(j,newNodes[i]->l,newNodes[i]->r)\n\t\t\t\t\tans[j]=true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcache[key]=true;\n\t\t\t\tdeleted.pop_back();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tdeleted.pop_back();\n\t}\n\tcache[key]=false;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\", &N, &V);\n\trep(i,0,N)\n\t\tscanf(\"%d\", x+i);\n\tNode start(0, N, V);\n\tvector<Node*> v;\n\tv.push_back(&start);\n\tint stepsLeft=20;\n\trec(v,stepsLeft,1);\n\trep(i,0,N){\n\t\tputs(ans[i]?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=2E5+5;\n\nint N,M,V;\nint a[Maxn];\nint F[Maxn],G[Maxn];\nint L[20][Maxn],R[20][Maxn];\nint nxt[Maxn];\n\ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n\nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tsort(a+1,a+N+1);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N; R[i][N+1]=N+1;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1) MAX(F[i],R[M-j][F[i-(1<<j)]+1]);\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1) MIN(G[i],L[M-j][G[i-(1<<j)]-1]);\n\t}\n\tfor(int i=0;i<(1<<M);++i)\n\t\tMAX(nxt[L[0][G[((1<<M)-1)^i]-1]],R[0][F[i]+1]);\n\tfor(int i=1;i<=N;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[i]>=i)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \nint gi() { \n\tint res = 0, w = 1; \n\tchar ch = getchar(); \n\twhile (ch != '-' && !isdigit(ch)) ch = getchar(); \n\tif (ch == '-') w = -1, ch = getchar(); \n\twhile (isdigit(ch)) res = res * 10 + ch - '0', ch = getchar(); \n\treturn res * w; \n} \nconst int MAX_N = 2e5 + 5; \nint N, V[20], t; \nint x[MAX_N], L[20][MAX_N], R[20][MAX_N]; \nint sl[1 << 19], sr[1 << 19], cr[MAX_N]; \nvoid chkmax(int &x, int y) { if (x < y) x = y; } \nvoid chkmin(int &x, int y) { if (x > y) x = y; } \nint main () { \n#ifndef ONLINE_JUDGE \n    freopen(\"cpp.in\", \"r\", stdin); \n#endif \n\tN = gi(), V[0] = gi(); \n\tfor (int i = 1; i <= N; i++) x[i] = gi(); \n\twhile (V[t]) V[t + 1] = V[t] >> 1, ++t; \n\tfor (int i = 0; i <= t; i++) { \n\t\tL[i][1] = 1, R[i][N] = N; \n\t\tfor (int j = 2; j <= N; j++) \n\t\t\tif (x[j] - x[j - 1] <= V[i]) L[i][j] = L[i][j - 1]; \n\t\t\telse L[i][j] = j; \n\t\tfor (int j = N - 1; ~j; j--) \n\t\t\tif (x[j + 1] - x[j] <= V[i]) R[i][j] = R[i][j + 1]; \n\t\t\telse R[i][j] = j; \n\t}\n\tfor (int i = 1; i < 1 << t; i++) sl[i] = 1, sr[i] = N; \n\tsl[0] = 0, sr[0] = N + 1; \n\tfor (int s = 0; s < 1 << t; s++) { \n\t\tfor (int i = 1; i <= t; i++) \n\t\t\tif (!(s >> (i - 1) & 1)) { \n\t\t\t\tchkmax(sl[s | 1 << (i - 1)], R[i][sl[s] + 1]); \n\t\t\t\tchkmin(sr[s | 1 << (i - 1)], L[i][sr[s] - 1]); \n\t\t\t} \n\t} \n\tfor (int i = 0; i <= N; i++) cr[i] = 1e9; \n\tint S = (1 << t) - 1; \n\tfor (int i = 0; i < 1 << t; i++) chkmin(cr[sl[i]], sr[S ^ i]); \n\tfor (int i = N - 1; ~i; i--) chkmin(cr[i], cr[i + 1]); \n\tfor (int i = 1; i <= N; i++) puts(cr[L[0][i] - 1] <= R[0][i] + 1 ? \"Possible\" : \"Impossible\"); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pb2 pop_back\n#define pf push_front\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define rep(k,i,j) for(int k = (int)i;k<(int) j;k++)\n#define repd(k,i,j) for(int k = i;k>=(int)j;k--)\n#define ll long long\n#define pq priority_queue\n\nint dirx[8] = {0,1,0,-1,1,1,-1,-1};\nint diry[8] = {1,0,-1,0,1,-1,1,-1};\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e16;\nconst double EPS = 1e-6;\n\nusing namespace std;\n\nconst int maxn = 3e5+5;\n\nint n,v;\nint loc[maxn];\n\nint jump[maxn][20],m;\n\nint dp[maxn];\n\nint ch[maxn];\n\nint in_q[maxn];\n\nqueue<int> q;\nint solve(){\n\tmemset(dp,-1,sizeof dp);\n\tmemset(in_q,0,sizeof in_q);\n\t\n\tq.push(1);\n\tdp[1] = ch[0];\n\tin_q[1] = 1;\n\t\n\twhile(q.size()){\n\t\tint mask = q.front();\n\t\tint a = dp[mask];\n\t\t\n\t\tq.pop();\n\t\tin_q[mask] = 0;\n\t\t\n\t\tif(a==n)return 1;\n\t\trep(k,0,m)if(((1<<k)&mask)==0){\n\t\t\tint b = ch[jump[a][k]];\n\t\t\tint maskb = (mask|(1<<k));\n\t\t\t\n\t\t\tif(dp[maskb]<b){\n\t\t\t\tdp[maskb] = b;\n\t\t\t\tif(!in_q[maskb])q.push(maskb),in_q[maskb] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\t\n\trep(k,0,n)scanf(\"%d\",&loc[k]);\n\t\n\t\n\tfor(;v>=0;v/=2){\n\t\trep(k,0,n){\n\t\t\tint i = k;\n\t\t\twhile(i<n){\n\t\t\t\tif(i<n-1 && loc[i+1]-loc[i]<=v){\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\twhile(k<=i)jump[k++][m] = i+1;\n\t\t\tk = i;\n\t\t}\n\t\t//printf(\"%d \\n\",v);\n\t\tm++;\n\t\tif(v==0)break;\n\t}\n\t\n\tif(m>=20)return 0;\n\t\n\trep(k,0,maxn)ch[k] = k;\n\t\n\tint hit = 0;\n\trep(k,0,n){\n\t\tif(hit>18){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint nxt = jump[k][0];\n\t\t\n\t\thit++;\n\t\tch[k] = nxt;\n\t\tint ret = solve();\n\t\tch[k] = k;\n\t\t\n\t\twhile(k<nxt)printf(\"%s\\n\",ret?\"Possible\":\"Impossible\"),k++;\n\t\tk = nxt-1;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 2e5 + 10;\n\nint n, v, m, ans[N];\nint a[N], b[N], L[N][22], R[N][22], f[N], g[N];\n\nbool ask(int u)\n{\n    return ans[L[u][0] - 1] <= R[u][0] + 1;\n}\n\nint main()\n{\n    n = read(), v = read();\n    for (int i = 1; i <= n; i++) a[i] = read();\n    b[0] = v;\n    for (int i = 1; i <= 50; i++) b[i] = b[i - 1] >> 1;\n    for (int i = 0; b[i]; i++) m = i;\n    m++;\n    for (int i = 0; i <= m; i++)\n    {\n        L[0][i] = L[1][i] = 1;\n        for (int j = 2; j <= n; j++)\n            L[j][i] = a[j] - a[j - 1] <= b[i] ? L[j - 1][i] : j;\n        R[n + 1][i] = R[n][i] = n;\n        for (int j = n - 1; j >= 1; j--)\n            R[j][i] = a[j + 1] - a[j] <= b[i] ? R[j + 1][i] : j;\n    }\n    for (int i = 0; i < (1 << m); i++) g[i] = n + 1;\n    for (int i = 0; i < (1 << m); i++)\n        for (int j = 0; j < m; j++)\n            if (!(i >> j & 1))\n            {\n                f[i | (1 << j)] = max(f[i | (1 << j)], R[f[i] + 1][j + 1]);\n                g[i | (1 << j)] = min(g[i | (1 << j)], L[g[i] - 1][j + 1]);\n            }\n    for (int i = 0; i <= n; i++) ans[i] = 2e9;\n    for (int i = 0; i < (1 << m); i++)\n        ans[f[i]] = min(ans[f[i]], g[((1 << m) - 1) ^ i]);\n    for (int i = n - 1; i >= 1; i--)\n        ans[i] = min(ans[i], ans[i + 1]);\n    for (int i = 1; i <= n; i++) puts(ask(i) ? \"Possible\" : \"Impossible\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=200005;\nint l[N][20],r[N][20],dpl[1<<18],dpr[1<<18],f[N],x[N],a[N];\nint main(){\n\tint n,v,m=0;\n\tscanf(\"%d%d\",&n,&v);\n\tfor (;1<<m<=v;m++);\n\tfor (int i=m;i;i--,v>>=1) a[i]=v;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor (int i=0;i<=m;i++) l[0][i]=0,r[n+1][i]=n+1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=m;j++)\n\t\tif (x[i]-x[i-1]<=a[j]) l[i][j]=l[i-1][j];\n\t\t\telse l[i][j]=i-1;\n\tfor (int i=n;i;i--)\n\t\tfor (int j=0;j<=m;j++)\n\t\tif (x[i+1]-x[i]<=a[j]) r[i][j]=r[i+1][j];\n\t\t\telse r[i][j]=i+1;\n\tint L=1<<m;\n\tfor (int i=0;i<L;i++){\n\t\tdpl[i]=1;dpr[i]=n;\n\t\tfor (int j=0;j<m;j++)\n\t\tif ((i>>j)&1){\n\t\t\tdpl[i]=max(dpl[i],r[dpl[i^1<<j]][j]);\n\t\t\tdpr[i]=min(dpr[i],l[dpr[i^1<<j]][j]);\n\t\t}\n\t}\n\tfor (int i=0;i<L;i++)\n\t\tf[dpr[i]]=max(f[dpr[i]],dpl[(L-1)^i]);\n\tfor (int i=1;i<=n;i++) f[i]=max(f[i],f[i-1]);\n\tfor (int i=1;i<=n;i++)\n\t\tif (f[r[i][m]-1]>l[i][m]) printf(\"Possible\\n\");\n\t\t\telse printf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 200011\n#define maxLog 19\n\nint n, i, j, pos, V, k, limit, id, conf, new_conf, mini;\nint x[maxN];\nvector<int> v;\nint l[maxLog][maxN], r[maxLog][maxN];\n\nint dpL[1 << maxLog], dpR[1 << maxLog];\nvector< pair<int, int> > ord, que;\n\nbool ans[maxN];\n\nint main()\n{\n  //  freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d%d\", &n, &V);\n    for (i = 1; i <= n; i++) scanf(\"%d\", &x[i]);\n    v = {V / 2};\n    while (v.back() != 0) v.pb(v.back() / 2);\n    k = v.size();\n\n    for (i = 0; i < k; i++) {\n        l[i][1] = 1;\n        for (pos = 2; pos <= n; pos++) {\n            if (x[pos] - x[pos - 1] <= v[i])\n                l[i][pos] = l[i][pos - 1];\n            else\n                l[i][pos] = pos;\n        }\n\n        r[i][n] = n;\n        for (pos = n - 1; pos > 0; pos--) {\n            if (x[pos + 1] - x[pos] <= v[i])\n                r[i][pos] = r[i][pos + 1];\n            else\n                r[i][pos] = pos;\n        }\n    }\n\n    limit = 1 << k;\n    for (i = 0; i < limit; i++) {\n        dpL[i] = 0;\n        dpR[i] = n + 1;\n    }\n\n    for (conf = 0; conf < limit; conf++) {\n        for (id = 0; id < k; id++) {\n            if (conf & (1 << id)) continue;\n            new_conf = conf | (1 << id);\n\n            dpL[new_conf] = max(dpL[new_conf], min(n, r[id][ dpL[conf] + 1 ]));\n            dpR[new_conf] = min(dpR[new_conf], max(1, l[id][ dpR[conf] - 1 ]));\n        }\n    }\n\n    for (conf = 0; conf < limit; conf++)\n        ord.pb(mp(dpL[conf], dpR[(limit - 1) ^ conf]));\n\n    sort(ord.begin(), ord.end());\n    reverse(ord.begin(), ord.end());\n\n    for (i = 1; i <= n; i = j) {\n        for (j = i + 1; j <= n && x[j] - x[j - 1] <= V; j++);\n        que.pb(mp(i, j - 1));\n    }\n\n    reverse(que.begin(), que.end());\n\n    pos = 0;\n    mini = n + 2;\n\n    for (auto e : que) {\n        while (pos < ord.size()) {\n            if (ord[pos].first + 1 < e.first) break;\n            mini = min(mini, ord[pos].second);\n            pos++;\n        }\n\n        if (mini <= e.second + 1) {\n            for (i = e.first; i <= e.second; i++)\n                ans[i] = true;\n        }\n    }\n\n    for (i = 1; i <= n; i++) {\n        if (ans[i])\n            printf(\"Possible\\n\");\n        else\n            printf(\"Impossible\\n\");\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,b,e) for(int i=(b); i <= (e); ++i)\n#define FORD(i,b,e) for(int i=(b); i >= (e); --i)\n#define REP(i,n) for(int i=0; i < (n); ++i)\n#define SIZE(c) (int) (c).size()\n#define ALL(c) (c).begin(), (c).end()\n#define PB push_back\n#define MP make_pair\n#define ST first\n#define ND second\n#define FWD(i,a,b) for (int i=(a); i<(b); ++i)\n#define BCK(i,a,b) for (int i=(a); i>(b); --i)\n#define PI 3.14159265358979311600\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\ntypedef vector < int > VI;\ntypedef vector<ll> VL;\n\ntypedef long double K;\n\nconst int N = 200005;\nconst int M = 1<<20;\nconst int inf = 1000*1000*1000 + 7;\n\nint n, v, cnt, bound;\nint a[N], f[M], g[M];\nint goLeft[N][21], goRight[N][21];\nvector<int> b;\n\nstruct SegTree {\n\tint n;\n\tvector<int> tree;\n\n\tSegTree(int n): n(n), tree(4*n, inf) {}\n\n\tvoid update(int pos, int val) {\n\t\tupdate(1, 0, n - 1, pos, val);\n\t}\n\n\tint go(int l, int r) {\n\t\treturn go(1, 0, n - 1, l, r);\n\t}\n\n\tvoid update(int v, int tl, int tr, int pos, int val) {\n\t\tif (tl == tr) {\n\t\t\ttree[v] = min(tree[v], val);\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) / 2;\n\t\tif (pos <= tm) {\n\t\t\tupdate(2*v, tl, tm, pos, val); \n\t\t} else {\t\n\t\t\tupdate(2*v+1, tm+1, tr, pos, val);\n\t\t}\n\t\ttree[v] = min(tree[2*v], tree[2*v+1]);\n\t}\n\n\tint go(int v, int tl, int tr, int l, int r) {\n\t\tif (l > tr || r < tl) return inf;\n\t\tif (l <= tl && r >= tr) return tree[v];\n\t\tint tm = (tl + tr) / 2;\n\t\treturn min(go(2*v, tl, tm, l, r), go(2*v+1, tm+1, tr, l, r));\n\t}\n};\n\nvoid calc() {\n\tREP(i, cnt) {\n\t\tREP(j, n) {\n\t\t\tgoLeft[i][j] = j;\n\t\t\tif (j > 0 && a[j] - a[j - 1] <= b[i]) {\n\t\t\t\tgoLeft[i][j] = goLeft[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tgoRight[i][j] = j;\n\t\t\tif (j < n - 1 && a[j + 1] - a[j] <= b[i]) {\n\t\t\t\tgoRight[i][j] = goRight[i][j + 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint go(int pos, int x, int side) {\n\tif (side < 0) {\n\t\treturn pos < n ? goLeft[x][pos] : pos;\n\t} \n\treturn pos >= 0 ? goRight[x][pos] : pos;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\tREP(i, n) {\n\t\tcin >> a[i];\n\t}\n\n\twhile (v > 0) {\n\t\tb.push_back(v);\n\t\tv /= 2;\n\t}\n\tb.push_back(0);\n\tcnt = (int)b.size();\n\tbound = (1 << cnt);\n\n\tcalc();\n\n\tREP(i, bound) f[i] = -inf, g[i] = inf;\n\tf[0] = 0;\n\tg[0] = n - 1;\n\n\tREP(i, bound) {\n\t\tREP(j, cnt) if (~i & (1 << j)) {\n\t\t\tif (f[i] != -inf) {\n\t\t\t\tf[i ^ (1 << j)] = max(f[i ^ (1 << j)], go(f[i], j, +1) + 1);\n\t\t\t}\n\t\t\tif (g[i] != inf) {\n\t\t\t\tg[i ^ (1 << j)] = min(g[i ^ (1 << j)], go(g[i], j, -1) - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tint all = 0;\n\n\tSegTree tree(n);\n\n\tREP(mask, bound) {\n\t\tint comp = (bound - 1) ^ mask;\n\t\tint a = (mask & 1) ? (mask ^ 1) : mask;\n\t\tint b = (comp & 1) ? (comp ^ 1) : comp;\n\t\tif (f[a] != -inf && g[b] != inf) {\n\t\t\tif (f[a] > g[b]) {\n\t\t\t\tall = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttree.update(f[a], g[b]);\n\t\t}\n\t}\n\n\tREP(i, n) {\n\t\tif (all) {\n\t\t\tcout << \"Possible\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tint lb = go(i, 0, -1);\n\t\tint rb = go(i, 0, +1);\n\t\tif (tree.go(lb, rb) <= rb) {\n\t\t\tcout << \"Possible\\n\";\n\t\t} else {\n\t\t\tcout << \"Impossible\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint x[252521];\nint ne[252521][20],rne[252521][20];\nint dp[(1<<20)+10],rdp[(1<<20)+10];\nvector<int> v;\nint main()\n{\n\tint n,V;\n\tcin>>n>>V;\n\trep(i,n) cin>>x[i];\n\twhile(V>0){\n\t\tv.pb(V);V/=2;\n\t}\n\tv.pb(0);int m=v.size();\n\trep(i,n) rep(j,m){\n\t\trne[i][j]=i;\n\t\tif(i>0 && x[i]-x[i-1]<=v[j]) rne[i][j]=rne[i-1][j];\n\t}\n\tfor(int i=n-1;i>=0;i--) rep(j,m){\n\t\tne[i][j]=i;\n\t\tif(i<n-1 && x[i+1]-x[i]<=v[j]) ne[i][j]=ne[i+1][j];\n\t}\n\tmemset(dp,0,sizeof(dp));\n\trep(i,(1<<20)+5) rdp[i]=n-1;\n\trep(i,(1<<m)) rep(j,m){\n\t\tif((i&(1<<j))>0) continue;\n\t\tdp[i+(1<<j)]=max(dp[i+(1<<j)],dp[i]>=n?n:ne[dp[i]][j]+1);\n\t\trdp[i+(1<<j)]=min(rdp[i+(1<<j)],rdp[i]<0?-1:rne[rdp[i]][j]-1);\n\t}\n\t//rep(i,(1<<m)) cout<<i<<' '<<dp[i]<<' '<<rdp[i]<<endl;\n\tif(dp[(1<<m)-1]<n){\n\t\t//assert(dp[(1<<m)-1]<n && rdp[(1<<m)-1]>=0);\n\t\trep(i,n) cout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tint now=0;\n\twhile(now<n){\n\t\tint f=0;\n\t\trep(i,(1<<(m-1))){\n\t\t\tif(dp[(1<<m)-2-(i<<1)]>=now && rdp[(i<<1)]<=ne[now][0]) f=1;\n\t\t}\n\t\tREP(i,now,ne[now][0]+1){\n\t\t\tif(f>0) cout<<\"Possible\"<<endl;\n\t\t\telse cout<<\"Impossible\"<<endl;\n\t\t}\n\t\tnow=ne[now][0]+1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int L = 20;\nconst int MAX = 2 * 1000 * 100 + 47;\n\nint V[L];\nint sz = 0;\nint N[L][MAX];\nint P[L][MAX];\nint X[MAX];\nint dpL[1 << L];\nint dpR[1 << L];\nint ANS[MAX];\nset<PII> S;\nint M[MAX];\n\nvoid print(int mask)\n{\n\twhile (mask)\n\t{\n\t\tif (mask & 1)\n\t\t{\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << \" \";\n\t\t}\n\n\t\tmask >>= 1;\n\t}\n}\n\n//#define DEBUG\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tint n, v;\n\tcin >> n >> v;\n\tFOR(i, 0, n) cin >> X[i];\n\n\tV[0] = v;\n\tFOR(i, 1, L)\n\t{\n\t\tV[i] = V[i - 1] / 2;\n\t\tif (V[i] == 0)\n\t\t{\n\t\t\tsz = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treverse(V, V + sz);\n\tFOR(k, 0, sz)\n\t{\n\t\tint v = V[k];\n\t\tN[k][n - 1] = n;\n\n\t\tRFOR(i, n - 1, 0)\n\t\t{\n\t\t\tif (abs(X[i + 1] - X[i]) > v)\n\t\t\t{\n\t\t\t\tN[k][i] = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tN[k][i] = N[k][i + 1];\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"N=\" << endl;\n\tFOR(k, 0, sz)\n\t{\n\t\tcout << V[k] << \": \";\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tcout << N[k][i] << \" \";\n\t\t}\n\n\t\tcout << endl;\n\t}\n#endif\n\n\tFOR(k, 0, sz)\n\t{\n\t\tint v = V[k];\n\t\tP[k][0] = -1;\n\t\tFOR(i, 1, n)\n\t\t{\n\t\t\tif (abs(X[i] - X[i - 1]) > v)\n\t\t\t{\n\t\t\t\tP[k][i] = i - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tP[k][i] = P[k][i - 1];\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"P=\" << endl;\n\tFOR(k, 0, sz)\n\t{\n\t\tcout << V[k] << \": \";\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tcout << P[k][i] << \" \";\n\t\t}\n\n\t\tcout << endl;\n\t}\n#endif\n\n\tsz--;\n\n\tdpL[0] = 0;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tint x = dpL[mask];\n\t\tFOR(k, 0, sz)\n\t\t{\n\t\t\tif (mask & (1 << k)) continue;\n\n\t\t\tdpL[mask | (1 << k)] = max(dpL[mask | (1 << k)], N[k][x]);\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"dpL\" << endl;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tprint(mask);\n\t\tcout << \" :\";\n\t\tcout << dpL[mask] << endl;\n\t}\n#endif\n\n\tFOR(i, 0, 1 << sz) dpR[i] = 10 + n;\n\tdpR[0] = n - 1;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tint x = dpR[mask];\n\t\tFOR(k, 0, sz)\n\t\t{\n\t\t\tif (mask & (1 << k)) continue;\n\n\t\t\tdpR[mask | (1 << k)] = min(dpR[mask | (1 << k)], P[k][x]);\n\t\t}\n\t}\n\n\n#ifdef DEBUG\n\tcout << \"dpR\" << endl;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tprint(mask);\n\t\tcout << \" :\";\n\t\tcout << dpR[mask] << endl;\n\t}\n#endif\n\n\tFOR(i, 0, n) M[i] = INF;\n\tFOR(maskL, 0, 1 << sz)\n\t{\n\t\tint maskR = ((1 << sz) - 1) ^ maskL;\n\t\tint l = dpL[maskL] - 1;\n\t\tint r = dpR[maskR] + 1;\n#ifdef DEBUG\n\t\tcout << \"!!\" << l << \" \" << r << endl;\n#endif\n\t\tif (l != -1) M[l] = min(M[l], r);\n\t}\n\n#ifdef DEBUG\n\tcout << \"M=\" << endl;\n\tFOR(i, 0, n)\n\t{\n\t\tcout << M[i] << \" \";\n\t}\n\n\tcout << endl;\n#endif\n\n\tRFOR(i, n - 1, 0) M[i] = min(M[i + 1], M[i]);\n\t\n\tFOR(i, 0, n)\n\t{\n\t\tint l = P[sz][i] + 1;\n\t\tint r = N[sz][i] - 1;\n\t\tif (S.find(MP(l, r)) != S.end()) continue;\n\t\tS.insert(MP(l, r));\n\n\t\tif (M[max(l - 1, 0)] <= r + 1)\n\t\t{\n\t\t\tFOR(k, l, r + 1) ANS[k] = 1;\n\t\t}\n\t}\n\n\tFOR(i, 0, n)\n\t{\n\t\tif (ANS[i])\n\t\t{\n\t\t\tcout << \"Possible\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcout << \"Impossible\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> vals;\nint rt[200005][30];\nint lt[200005][30];\nint n,v;\nint pos[200005];\nint memo1[300005];\nint memo2[300005];\nint something[200005];\n\nint dpL(int bitmask){\n    if (memo1[bitmask]!=-1) return memo1[bitmask];\n    if (bitmask==0) return memo1[bitmask] = -1;\n    int ans = 0;\n    for (int x = 0; x<vals.size(); x++){\n        if (bitmask&(1<<x)){\n            ans = max(ans,dpL(bitmask^(1<<x)));\n            ans = max(ans,rt[dpL(bitmask^(1<<x))+1][x]);\n        }\n    }\n    return memo1[bitmask] = ans;\n}\n\nint dpR(int bitmask){\n    if (memo2[bitmask]!=-1) return memo2[bitmask];\n    if (bitmask==0) return memo2[bitmask] = n;\n    int ans = n-1;\n    for (int x = 0; x<vals.size(); x++){\n        if (bitmask&(1<<x)){\n            ans = min(ans,dpR(bitmask^(1<<x)));\n            ans = min(ans,lt[dpR(bitmask^(1<<x))-1][x]);\n        }\n    }\n    return memo2[bitmask] = ans;\n}\n\nint main(){\n    memset(memo1,-1,sizeof(memo1));\n    memset(memo2,-1,sizeof(memo2));\n    scanf(\"%d%d\",&n,&v);\n    for (int x = 0; x<n; x++){\n        scanf(\"%d\",&pos[x]);\n    }\n    int t = v;\n    while (t>0){\n        vals.push_back(t);\n        t/=2;\n    }\n    vals.push_back(0);\n    for (int i = 0; i<vals.size(); i++){\n        rt[n-1][i] = n-1;\n        for (int x = n-2; x>=0; x--){\n            rt[x][i] = pos[x+1]-pos[x]<=vals[i]?rt[x+1][i]:x;\n        }\n        lt[0][i] = 0;\n        for (int x = 1; x<n; x++){\n            lt[x][i] = pos[x]-pos[x-1]<=vals[i]?lt[x-1][i]:x;\n        }\n    }\n    for (int x = 0; x<n; x++){\n        something[x] = n+1;\n    }\n    for (int x = 0; x<(1<<(vals.size())); x+=2){\n        int other = ((1<<(vals.size()))-2)^x;\n        if (dpL(x)==-1) continue;\n        something[dpL(x)] = min(something[dpL(x)],dpR(other));\n    }\n    for (int x = n-2; x>=0; x--){\n        something[x] = min(something[x],something[x+1]);\n    }\n    for (int x = 0; x<n; x++){\n        int L = lt[x][0];\n        int R = rt[x][0];\n        //printf(\"something %d %d\\n\",x,something[x]);\n        //printf(\"L:%d,R:%d\\n\",L,R);\n        printf(something[max(0,L-1)]<=R+1?\"Possible\\n\":\"Impossible\\n\");\n    }\n    //printf(\"%d\\n\",dpL(6));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=1<<18;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nint L[N],R[N],x[N];\nint p[18][N],q[N];\nint ans[N];\ninline void umin(int &x,int y) { y<x?x=y:0; }\ninline void umax(int &x,int y) { x<y?x=y:0; }\nint main()\n{\n\tint n=gi()-1,v=gi(),i,j,k=v,m=0,u[20]={},s;\n\twhile (k) u[m++]=k>>=1;\n\n\tfor (i=0;i<=n;i++) x[i]=gi();\n\tfor (i=n;i;i--) x[i]-=x[i-1];\n\n\tfor (i=0;i<m;i++) {\n\t\tp[i][n+1]=n+1;\n\t\tfor (j=n;j;j--)\n\t\t\tp[i][j]=x[j]<=u[i]?p[i][j+1]:j;\n\t}\n\tfor (s=0;s<1<<m;s++)\n\t\tfor (i=0;i<m;i++)\n\t\t\tif (!(s>>i&1))\n\t\t\t\tumax(L[s|1<<i],p[i][L[s]+1]);\n\n\tfor (i=0;i<m;i++)\n\t\tfor (j=1;j<=n;j++)\n\t\t\tp[i][j]=x[j]<=u[i]?p[i][j-1]:j;\n\tfor (s=0;s<1<<m;s++) R[s]=n+1;\n\tfor (s=0;s<1<<m;s++)\n\t\tfor (i=0;i<m;i++)\n\t\t\tif (!(s>>i&1))\n\t\t\t\tumin(R[s|1<<i],R[s|1<<i]?p[i][R[s]-1]:0);\n\n\tmemset(ans,0x3f,sizeof(ans));\n\tfor (s=0;s<1<<m;s++)\n\t\tumin(ans[L[s]],R[((1<<m)-1)^s]);\n\tfor (i=1;i<=n;i++) umin(ans[i-1],ans[i]);\n\n\tfor (i=n,q[n+1]=n+1;i;i--)\n\t\tq[i]=x[i]>v?i:q[i+1];\n\tfor (i=0;i<=n;i++) {\n\t\tif (!i||x[i]>v) k=i;\n\t\tputs(ans[k]<=q[i+1]?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n#define pb push_back\n\n#define error(x) cout << #x << \" = \" << x << endl\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nconst int N = 2e5 + 20, LG = 20, MASK = (1 << LG);\nint n, v, m, a[N];\nint dpL[MASK], dpR[MASK];\nint L[N][LG], R[N][LG];\nvector <int> vec;\n\nint sum[N];\nbool flag;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n\tcin >> n >> v;\n\t\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\n\twhile (v) {\n\t\tvec.pb(v);\n\t\tv /= 2;\n\t}\n\tvec.pb(0);\n\n\treverse(vec.begin(), vec.end());\n\n\tm = _sz(vec);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (i && a[i] - a[i - 1] <= vec[j]) L[i][j] = L[i - 1][j];\n\t\t\telse L[i][j] = i;\n\t\t}\n\t}\n\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (i < n - 1 && a[i + 1] - a[i] <= vec[j]) R[i][j] = R[i + 1][j];\n\t\t\telse R[i][j] = i;\n\t\t}\n\t}\n\n\tfor (int mask = 0; mask < (1 << m); mask++)\n\t\tdpL[mask] = 0, dpR[mask] = n - 1;\n\n\tfor (int mask = 0; mask < (1 << m); mask++)\n\t{\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tif (mask >> i & 1) continue;\n\n\t\t\tint nmask = mask | (1 << i);\n\n\t\t\tif (dpL[mask] == n) dpL[nmask] = n;\n\t\t\telse \n\t\t\t{\n\t\t\t\tint k = dpL[mask];\n\t\t\t\tk = R[k][i] + 1;\n\n\t\t\t\tdpL[nmask] = max(dpL[nmask], k);\n\t\t\t}\n\n\t\t\tif (dpR[mask] == -1) dpR[nmask] = -1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint k = dpR[mask];\n\t\t\t\tk = L[k][i] - 1;\n\n\t\t\t\tdpR[nmask] = min(dpR[nmask], k);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int mask = 0; mask < (1 << (m - 1)); mask++)\n\t{\n\t\tint m1 = mask, m2 = ((1 << (m - 1)) - 1) ^ m1;\n\n\t\tint l = dpL[m1], r = dpR[m2];\n\n\t\tif (r < l) flag = 1;\n\t\telse if (R[l][m - 1] >= r) sum[l]++, sum[r + 1]--;\n\t}\n\n\tfor (int i = 1; i < n; i++) sum[i] += sum[i - 1];\n\n\tfor (int i = 0; i < n; i++)\n\t\tcout << (flag || sum[i]? \"Possible\" : \"Impossible\") << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MN=300000+5;\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T>inline T&IN(T&in){\n\tin=0;char c=getchar();int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1;c=getchar();}\n\twhile(isdigit(c))in=in*10+c-'0',c=getchar();\n\treturn in*=f;\n}\nint n,V;\nint l[20][MN],r[20][MN];\nint x[MN],fr[MN],fl[MN],s[MN];\nvoid input(){\n\tIN(n),IN(V);\n\tfor(int i=1;i<=n;++i)IN(x[i]);\n\tint k;//x[0]=INT_MIN/10,x[n+1]=INT_MAX/10;\n\tfor(k=0;V;++k,V>>=1){\n\t\tl[k][1]=1;\n\t\tfor(int i=2;i<=n;++i)l[k][i]=x[i]-x[i-1]>V?i:l[k][i-1];\n\t\tr[k][n]=n;\n\t\tfor(int i=n-1;i>=1;--i)r[k][i]=x[i+1]-x[i]>V?i:r[k][i+1];\n\t\tl[k][0]=1,r[k][n+1]=n;\n\t}\n\tl[k][1]=1;\n\tfor(int i=2;i<=n;++i)l[k][i]=x[i]-x[i-1]>V?i:l[k][i-1];\n\tr[k][n]=n;\n\tfor(int i=n-1;i>=1;--i)r[k][i]=x[i+1]-x[i]>V?i:r[k][i+1];\n\tl[k][0]=1,r[k][n+1]=n;\n\tfr[0]=n+1;\n\tfor(int st=1;st<(1<<k);++st){\n\t\tfr[st]=n;\n\t\tfor(int i=0;i<k;++i)if(st>>i&1){\n\t\t\tfl[st]=max(fl[st],r[i+1][fl[st^(1<<i)]+1]);\n\t\t\tfr[st]=min(fr[st],l[i+1][fr[st^(1<<i)]-1]);\n\t\t}\n\t}\n\tfor(int st=0;st<(1<<k);++st){\n\t\tint L=l[0][fr[((1<<k)-1)^st]-1],R=r[0][fl[st]+1];\n\t\tif(L<=R)s[L]++,s[R+1]--;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\ts[i]+=s[i-1];\n\t\tputs(s[i]?\"Possible\":\"Impossible\");\n\t}\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for (int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T sqr(const T &a) { return a * a; }\ntypedef long long LL;\ntypedef long double LD;\nvoid procStatus() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\nLL read() {\n\tLL x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (;!isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n\tfor (;isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\treturn x * flag;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 4e5 + 9;\nint n, V, a[Maxn];\n\nvoid Init() {\n\tn = read(), V = read();\n\trep (i, 1, n) a[i] = read();\n}\n\nint pon[20][Maxn];\nint len[Maxn], lef[Maxn], rig[Maxn];\n\nint uppfind(int pos, int step) {\n\tint l = 1, r = len[step], ans = pon[step][r];\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (pon[step][mid] > pos) ans = pon[step][mid], r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\treturn ans;\n}\n\nint lowfind(int pos, int step) {\n\tint l = 1, r = len[step], ans = pon[step][l];\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (pon[step][mid]< pos) ans = pon[step][mid], l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\treturn ans + 1;\n}\n\nvoid Solve() {\n\tint cnt = 0;\n\twhile ((1 << cnt) <= V) ++cnt;\n\trep (i, 0, cnt) {\n\t\tlen[i] = 1;\n\t\trep (j, 1, n) {\n\t\t\tpon[i][len[i]] = j;\n\t\t\tif (j != n && a[j + 1] - a[j] > (V >> i)) ++len[i];\n\t\t}\n\t\tpon[i][len[i] + 1] = n + 1;\n\t}\n\tif (len[0] > cnt + 1) {\n\t\trep (i, 1, n) puts(\"Impossible\");\n\t\treturn ;\n\t}\n\trep (i, 0, (1 << cnt) - 1) lef[i] = 0, rig[i] = n + 1;\n\trep (i, 0, (1 << cnt) - 1) {\n\t\trep (j, 0, cnt - 1) {\n\t\t\tif ((i >> j) & 1) continue;\n\t\t\tchkmax(lef[i ^ (1 << j)], uppfind(lef[i], j + 1)); // find a pointer bigger exclusively than f[i]\n\t\t\tchkmin(rig[i ^ (1 << j)], lowfind(rig[i] - 1, j + 1)); // find a pointer lower exclusively than f[i]\n\t\t}\n\t}\n\trep (i, 1, len[0]) {\n\t\tint l = pon[0][i - 1] + 1, r = pon[0][i];\n\t\tint flag = 0;\n\t\trep (j, 0, (1 << cnt) - 1) \n\t\t\tif (lef[j] >= l - 1 && rig[(1 << cnt) - 1 - j] <= r + 1) {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\trep (j, l, r) puts(flag ? \"Possible\" : \"Impossible\");\n\t}\n}\n\nint main() {\n//\tfreopen(\"bosky.in\", \"r\", stdin);\n//\tfreopen(\"bosky.out\", \"w\", stdout);\n\n\tInit();\n\tSolve();\t\n\n#ifdef Qrsikno\n//\tprocStatus();\n\tdebug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#define ll long long\n#define FOR(i,a) for(ll i=0;i<(ll)a.size();i++)\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=4e5+100;\nconst ll mod=1e9+7;\nconst ll logg=20;\n\nvector<ll> E;\nchar logG(ll v,ll ww){\n\tif(E.empty()){\n\t\twhile(v){\n\t\t\tE.pb(v);\n\t\t\tv/=2;\n\t\t}\n\t\tE.pb(0);\n\t\treverse(E.begin(),E.end());\n\t}\n\treturn lower_bound(E.begin(),E.end(),ww)-E.begin();\n}\nll ta_koj_jelo[maxn][logg];\nll ta_koj_agha[maxn][logg];\n\nll x[maxn];\nchar fas[maxn];\nll pri[maxn];\nll saf[maxn];\n\n\nll cnt[maxn];\n\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n\tll n,v;\n\tcin>>n>>v;\n\tfor(ll i=1;i<=n;i++){\n\t\tcin>>x[i];\n\t}\n\tfor(ll i=1;i+1<=n;i++){\n\t\tfas[i]=logG(v,x[i+1]-x[i]);\n\t//\tcout<<(ll)fas[i]<<\"* \";\n\t}\n\t//cout<<endl;\n\tfor(ll i=0;i<logg;i++){\n\t\tta_koj_jelo[n][i]=n;\n\t\tta_koj_jelo[n+1][i]=n;\n\t\tta_koj_agha[1][i]=1;\n\t\tta_koj_agha[0][i]=1;\n\t}\n\tfor(ll i=n-1;i>=0;i--){\n\t\tfor(ll j=0;j<logg;j++){\n\t\t\tif(fas[i]<=j){\n\t\t\t\tta_koj_jelo[i][j]=ta_koj_jelo[i+1][j];\n\t\t\t}else{\n\t\t\t\tta_koj_jelo[i][j]=i;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=2;i<=n;i++){\n\t\tfor(ll j=0;j<logg;j++){\n\t\t\tif(fas[i-1]<=j){\n\t\t\t\tta_koj_agha[i][j]=ta_koj_agha[i-1][j];\n\t\t\t}else{\n\t\t\t\tta_koj_agha[i][j]=i;\n\t\t\t}\n\t\t}\n\t}\n\n\tll M=(ll)(E.size());\n\tpri[0]=0;\n\tfor(ll i=1;i<(1<<M);i++){\n\t\tpri[i]=0;\n\t\tfor(ll j=0;j<M;j++){\n\t\t\tif((i>>j)&1){\n\t\t\t\tpri[i]=max(pri[i],ta_koj_jelo[pri[i^(1<<j)]+1][j]);\n\t\t\t}\n\t\t}\n\t\tpri[i]=min(pri[i],n);\n\t}\n\tsaf[0]=n+1;\n\tfor(ll i=1;i<(1<<M);i++){\n\t\tsaf[i]=n+1;\n\t\tfor(ll j=0;j<M;j++){\n\t\t\tif((i>>j)&1 ){\n\t\t\t\tsaf[i]=min(saf[i],ta_koj_agha[saf[i^(1<<j)]-1][j]);\n\t\t\t}\n\t\t}\n\t\tsaf[i]=max(saf[i],(ll)1);\n\t}\n\tfor(ll i=0;i<(1<<M);i++){\n\t//\tcout<<pri[i]<<' '<<saf[i]<<endl;\n\t}\n\tll H=((1<<M)/2)-1;\n\tif(saf[H]==1){\n\t\tcnt[0]=1;\n\t}else{\n\t\tfor(ll i=0;i<=H;i++){\n\t\t\tll ras=saf[i];\n\t\t\tll chap=pri[H^i];\n\n\t\t\tll R=ta_koj_jelo[chap+1][M-1]; \n\t\t\tll L=ta_koj_agha[ras-1][M-1];\n\n\t\t\tif(ras-1<=R){\n\t\t\t\tcnt[L]++;\n\t\t\t\tcnt[R+1]--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=1;i<=n;i++){\n\t\tcnt[i]+=cnt[i-1];\n\t\tif(cnt[i]){\n\t\t\tcout<<\"Possible\\n\";\n\t\t}else{\n\t\t\tcout<<\"Impossible\\n\";\n\t\t}\n\t}\n}\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, v;\n  cin >> n >> v;\n  vector <int> x(n);\n  for (int i = 0; i < n; ++i) cin >> x[i];\n  vector <int> l, r;\n  vector <vector <int>> g;\n  vector <int> id;\n  vector <int> have;\n  {\n    int cur = v;\n    while (true) {\n      have.push_back(cur);\n      if (cur == 0) break;\n      cur /= 2;\n    }\n    reverse(have.begin(), have.end());\n  }\n  int uk = 0;\n  for (int go : have) {\n    vector <int> nid;\n    int lst = 0;\n    int j = 0;\n    for (int i = 1; i <= n; ++i) {\n      if (i == n || x[i] - x[i - 1] > go) {\n        l.push_back(lst);\n        r.push_back(i - 1);\n        g.push_back(vector <int> ());\n        nid.push_back(uk);\n        while (j < (int)id.size() && r[id[j]] <= r[uk]) {\n          g[uk].push_back(id[j++]);\n        }\n        uk++;\n        lst = i;\n      }\n    }\n    id = nid;\n  }\n  if ((int)id.size() > 18) {\n    for (int i = 0; i < n; ++i) {\n      cout << \"Impossible\\n\";\n    }\n    return 0;\n  }\n  map <vector <int>, bool> vis;\n  function <bool(vector <int>, int)> rec = [&] (vector <int> ids, int cnt) {\n    if (!vis.count(ids)) {\n      bool good = false;\n      if (ids.empty()) {\n        good = true;\n      } else {\n        if (cnt == 0) {\n          good = false;\n        } else {\n          int nxt = 0;\n          for (int i : ids) nxt += (int)g[i].size();\n          for (int i : ids) {\n            if (nxt - (int)g[i].size() <= cnt - 1) {\n              vector <int> nids;\n              for (int j : ids) {\n                if (j != i) {\n                  for (int k : g[j]) nids.push_back(k);\n                }\n              }\n              if (rec(nids, cnt - 1)) {\n                good = true;\n                break;\n              }\n            }\n          }\n        }\n      }\n      vis[ids] = good;\n    }\n    return vis[ids];\n  };\n  for (int i : id) {\n    vector <int> go;\n    for (int j : id) {\n      if (j != i) {\n        for (int k : g[j]) {\n          go.push_back(k);\n        }\n      } \n    }\n    bool good = (go.size() <= (int)have.size() - 1 ? rec(go, (int)have.size() - 1) : false);\n    for (int j = l[i]; j <= r[i]; ++j) {\n      cout << (good ? \"Possible\" : \"Impossible\") << '\\n';\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=300100,M=20;\n\nint a[N],dp[N],dq[N],b[M],V,n,le[M][N],ri[M][N],c[N];\nint m;\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>V;\n\tfor(int i=1;i<=n;++i)cin>>a[i];\n\tfor(;V>>m;++m)b[m]=V>>m;\n\tfor(int i=0;i<=m;++i){\n\t\tri[i][n]=n;ri[i][n+1]=n+1;\n\t\tfor(int j=n-1;j;--j)\n\t\t\tri[i][j]=(a[j+1]-a[j]<=b[i]?ri[i][j+1]:j);\n\t\tle[i][0]=0;le[i][1]=1;\n\t\tfor(int j=2;j<=n;++j)\n\t\t\tle[i][j]=(a[j]-a[j-1]<=b[i]?le[i][j-1]:j);\n\t}\n\tfill(dq,dq+N,n+1);\n\tfor(int i=1;i<(1<<m);++i)\n\t\tfor(int j=0;j<m;++j)\n\t\t\tif(i>>j&1){\n\t\t\t\tdp[i]=max(dp[i],ri[j+1][dp[i-(1<<j)]+1]);\n\t\t\t\tdq[i]=min(dq[i],le[j+1][dq[i-(1<<j)]-1]);\n\t\t\t\tdp[i]=min(dp[i],n);\n\t\t\t\tdq[i]=max(dq[i],1);\n\t\t\t}\n\tfor(int i=0;i<(1<<m);++i){\n\t\tint l=dp[i]+1,r=dq[(1<<m)-1-i]-1;\n\t\tif(r<=ri[0][l]){\n\t\t\tif(l>r)++c[1];\n\t\t\telse ++c[l],--c[r+1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tc[i]+=c[i-1];\n\t\tcout<<(c[i]?\"Possible\\n\":\"Impossible\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N =  2e+5+5;\n\nint n,V;\nint a[N];\nint lef[N][20],rig[N][20];\nint val[20],k;\nint f[N*2],g[N*2];\nstruct point{\n\tint x,y,id;\n\tpoint(const int x_=0,const int y_=0,const int id_=0){x=x_;y=y_;id=id_;}\n\tfriend bool operator < (point a,point b){\n\t\tif (a.x!=b.x)return a.x>b.x;\n\t\tif (a.y!=b.y)return a.y<b.y;\n\t\treturn a.id<b.id;\n\t}\n}p[N*4];\nint m;\nbool ans[N];\n\nint main(){\n\tn=get();V=get();\n\tfo(i,1,n)a[i]=get();\n\tval[0]=V;\n\tk=0;\n\tfor(;val[k];k++)val[k+1]=val[k]/2;\n\tfo(i,1,n)\n\t\tfo(j,0,k){\n\t\t\tlef[i][j]=i;\n\t\t\tif (i>1&&a[i]-a[i-1]<=val[j])lef[i][j]=lef[i-1][j];\n\t\t}\n\tfd(i,n,1)\n\t\tfo(j,0,k){\n\t\t\trig[i][j]=i;\n\t\t\tif (i<n&&a[i+1]-a[i]<=val[j])rig[i][j]=rig[i+1][j];\n\t\t}\n\tfo(i,0,(1<<k)-1)g[i]=1e+9;\n\tf[0]=0;g[0]=n+1;\n\tfo(i,1,k){\n\t\tf[1<<(i-1)]=rig[1][i];\n\t\tg[1<<(i-1)]=lef[n][i];\n\t}\n\tfo(i,1,(1<<k)-1){\n\t\tfo(x,1,k)\n\t\tif (((1<<(x-1))&i)==0){\n\t\t\tif (f[i]==n)f[i|(1<<(x-1))]=n;\n\t\t\telse f[i|(1<<(x-1))]=max(f[i|(1<<(x-1))],rig[f[i]+1][x]);\n\t\t\tif (g[i]==1)g[i|(1<<(x-1))]=1;\n\t\t\telse g[i|(1<<(x-1))]=min(g[i|(1<<(x-1))],lef[g[i]-1][x]);\n\t\t}\n\t}\n\tfo(i,1,n)p[++m]=point(lef[i][0],rig[i][0],i);\n\tfo(i,0,(1<<k)-1)p[++m]=point(f[i]+1,g[((1<<k)-1)^i]-1,0);\n\tsort(p+1,p+1+m);\n\tint lim=1e+9;\n\tfo(i,1,m)\n\tif (p[i].id==0)lim=min(lim,p[i].y);\n\telse ans[p[i].id]=(lim<=p[i].y);\n\tfo(i,1,n)\n\tif (ans[i])printf(\"Possible\\n\");else printf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n首先跳跃次数最多是 logV ，每次跳跃后，可以通过普通的移动走尽可能多的点。\n那么按照 V 分 logV 层，每层 [1, n] 被拆分为若干线段，\n每个线段 [l, r] 表示在该层内从这个区间任一点开始可以遍历整个区间。\n那么问题转换为钦定第一层线段，求是否能从其他层中每层拿一个线段使得所有线段的并为 [1, n] 。\n\n由于层数很少，可以状压 DP 出 exl[S] 表示选 S 集合内的线段覆盖 [1, k] 的最大 k ，\n类似的有 exr[S] 表示覆盖 [k, n] 的最小 k 。\n转移通过 l[k][i]/r[k][i] 表示 k 层第 i 个点的左/右端点即可。\n\n统计答案时，枚举第一层的所有线段 [l, r]，\n并判断是否存在集合 S 使得 [1, exl[S]], [l, r], [exr[S], n] 的并为 [1, n] 即可。\n而如果第一层线段的数量如果超过总层数说明所有点都不会合法。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 400005, maxk = 20;\nint x[maxn];\nint exl[maxn], exr[maxn];\nint l[maxk][maxn], r[maxk][maxn];\nint len[maxk];\n\nint main() {\n\tint n = read, v = read;\n\tfor(int i = 1; i <= n; i ++)\n\t\tread(x[i]);\n\n\tint d = 0;\n\twhile(v) {\n\t\tlen[d ++] = v;\n\t\tv >>= 1;\n\t}\n\t++ d;\n\n\tfor(int k = 0; k < d; k ++) {\n\t\tl[k][1] = 1;\n\t\tfor(int i = 2; i <= n; i ++)\n\t\t\tif(x[i - 1] + len[k] >= x[i])\n\t\t\t\tl[k][i] = l[k][i - 1];\n\t\t\telse\n\t\t\t\tl[k][i] = i;\n\n\t\tr[k][n] = n;\n\t\tfor(int i = n - 1; i; i --)\n\t\t\tif(x[i] + len[k] >= x[i + 1])\n\t\t\t\tr[k][i] = r[k][i + 1];\n\t\t\telse\n\t\t\t\tr[k][i] = i;\n\t}\n\n\tfor(int S = 0; S < (1 << d); S ++) {\n\t\texl[S] = 0;\n\t\texr[S] = n + 1;\n\t\tfor(int k = 0; k < d; k ++)\n\t\t\tif(S >> k & 1) {\n\t\t\t\tint T = S ^ (1 << k);\n\t\t\t\texl[S] = std::max(exl[S], r[k][exl[T] + 1]);\n\t\t\t\texr[S] = std::min(exr[S], l[k][exr[T] - 1]);\n\t\t\t}\n\t\t/* debug(\"%d: %d %d\\n\", S, exl[S], exr[S]); */\n\t}\n\n\tint tot = 0;\n\tfor(int i = 1; i <= n; i = r[0][i] + 1)\n\t\t++ tot;\n\tif(tot > d) {\n\t\tfor(int i = 1; i <= n; i ++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\n\tfor(int i = 1; i <= n; i = r[0][i] + 1) {\n\t\tbool ok = 0;\n\t\tfor(int S = 0; S < (1 << d); S += 2) {\n\t\t\tint T = ((1 << d) - 2) ^ S ;\n\t\t\t/* if(exl[S] + 1 >= exr[T] or (exl[S] + 1 >= i and r[0][i] + 1 >= exr[T])) { */\n\t\t\tif(exl[S] + 1 >= i and r[0][i] + 1 >= exr[T]) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j = i; j <= r[0][i]; j ++)\n\t\t\tif(ok)\n\t\t\t\tputs(\"Possible\");\n\t\t\telse\n\t\t\t\tputs(\"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FR first\n#define SE second\nusing namespace std;\n\ntypedef pair<int,int> pii;\nconst int N=200010;\nint n,V,X[N],dep;\nint L[20][N],R[20][N];\nint exL[N<<2],exR[N<<2];\npii seg[N];\nbool ans[N];\n\nint findr(int d,int p){return R[d][upper_bound(L[d]+1,L[d]+1+n,p)-L[d]-1];}\nint findl(int d,int p){return L[d][lower_bound(R[d]+1,R[d]+1+n,p)-R[d]];}\n\nint main()\n{\n    //freopen(\"B.in\",\"r\",stdin);\n    //freopen(\"B.out\",\"w\",stdout);\n    scanf(\"%d%d\",&n,&V);\n    for(int i=1;i<=n;i++) scanf(\"%d\",X+i);\n    for(int v=V;v>=0;v>>=1,dep++)\n    {\n        L[dep][1]=1;R[dep][n]=n;\n        for(int i=2;i<=n;i++) L[dep][i]=(X[i]-X[i-1]<=v)?L[dep][i-1]:i;\n        for(int i=n-1;i>=1;i--) R[dep][i]=(X[i+1]-X[i]<=v)?R[dep][i+1]:i;\n        if(v==0){dep++;break;}\n    }\n    for(int i=1;i<=n;i++) seg[i]=pii(L[0][i],R[0][i]);\n    int cnt=unique(seg+1,seg+1+n)-(seg+1);\n    memset(exL,0,sizeof(exL));\n    memset(exR,0x3f,sizeof(exR));\n    exL[0]=0;exR[0]=n;\n    for(int s=0;s<(1<<dep);s++)\n        for(int i=0;i<dep;i++)\n        {\n            if(!(s&(1<<i))) continue;\n            exL[s]=max(exL[s],findr(i,exL[s^(1<<i)]));\n            exR[s]=min(exR[s],findl(i,exR[s^(1<<i)]));\n        }\n    if(cnt>dep) goto output;\n    for(int i=1;i<=cnt;i++)\n    {\n        for(int s=0;s<(1<<dep);s+=2)\n            if(exL[s]>=seg[i].FR-1&&exR[s]<=seg[i].SE+1)\n            {\n                for(int j=seg[i].FR;j<=seg[i].SE;j++) ans[j]=1;\n                goto finished;\n            }\n        finished: ;\n    }\n    output: for(int i=1;i<=n;i++) puts(ans[i]?\"Possible\":\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n \ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n \nconst int INF = 1e9;\nconst int N = 2e5 + 10;\nconst int L = 22;\n\nint n,v,x[N],fwd[L][N], bak[L][N];\nint pref[1<<L], suf[1<<L];\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> v;\n    x[0] = -INF-N; x[n+1] = INF+N;\n    for (int i = 1; i <= n; i++) cin >> x[i];\n\n    int l = 0;\n    while (true) {\n        fwd[l][n+1] = n+1;\n        for (int i = n; i >= 1; i--) \n            fwd[l][i] = x[i+1]-x[i] <= v ? fwd[l][i+1] : i+1;\n\n        bak[l][0] = 0;\n        for (int i = 1; i <= n; i++)\n            bak[l][i] = x[i]-x[i-1] <= v ? bak[l][i-1] : i-1;\n\n        l++;\n        if (v == 0) break;\n        v /= 2;\n    }\n\n    vector<pii> seg;\n    for (int i = 1; i <= n; i = fwd[0][i]) {\n        int j = fwd[0][i];\n        seg.eb(i,j);\n    }\n\n    if (si(seg) >= l+2) {\n        forn(i,n) cout << \"Impossible\\n\";\n        return 0;\n    }\n\n    //forn(lev, l) { forsn(i,1,n+1) cerr << fwd[lev][i] << ' '; cerr << endl; }\n    //forn(lev, l) { forsn(i,1,n+1) cerr << bak[lev][i] << ' '; cerr << endl; }\n\n    for (int mask = 0; mask < (1<<l); mask++) {\n        pref[mask] = 1;\n        suf[mask] = n;\n        forn(i,l) if ((mask>>i)&1) {\n            pref[mask] = max(\n                pref[mask], \n                fwd[i][pref[mask - (1<<i)]]\n            );\n            \n            suf[mask] = min(\n                suf[mask],\n                bak[i][suf[mask - (1<<i)]]\n            );\n        }\n    }\n\n    //forn(mask, (1<<l)) {\n    //    cerr << mask << ' ' << pref[mask] << ' ' << suf[mask] << endl;\n    //}\n\n    auto ALL = (1<<l)-2;\n    for (auto lr : seg) {\n        int l,r; tie(l,r) = lr;\n        bool can_do = false;\n        for (int mask = 0; mask <= ALL; mask += 2) {\n            int other = ALL - mask;\n            if (l <= pref[mask] && suf[other] < r) {\n                can_do = true;\n                break;\n            }\n        }\n        forn(_,r-l) cout << (can_do ? \"Possible\\n\" : \"Impossible\\n\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MN=100000+5;\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T>inline T&IN(T&in){\n\tin=0;char c=getchar();int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1;c=getchar();}\n\twhile(isdigit(c))in=in*10+c-'0',c=getchar();\n\treturn in*=f;\n}\nint n,V;\nint l[20][MN],r[20][MN];\nint x[MN],fr[MN],fl[MN],s[MN];\nvoid input(){\n\tIN(n),IN(V);\n\tfor(int i=1;i<=n;++i)IN(x[i]);\n\tint k;x[0]=INT_MIN/10,x[n+1]=INT_MAX/10;\n\tfor(k=0;V;++k,V>>=1){\n\t\tfor(int i=1;i<=n;++i)l[k][i]=x[i]-x[i-1]>V?i:l[k][i-1];\n\t\tfor(int i=n;i>=1;--i)r[k][i]=x[i+1]-x[i]>V?i:r[k][i+1];\n\t}\n\tfor(int i=1;i<=n;++i)l[k][i]=x[i]-x[i-1]>V?i:l[k][i-1];\n\tfor(int i=n;i>=1;--i)r[k][i]=x[i+1]-x[i]>V?i:r[k][i+1];\n\tfor(int st=0;st<(1<<k);++st){\n\t\tfr[st]=n+1;\n\t\tfor(int i=0;i<k;++i)if(st>>i&1){\n\t\t\tfl[st]=max(fl[st],r[i+1][fl[st^(1<<i)]+1]);\n\t\t\tfr[st]=min(fr[st],l[i+1][fr[st^(1<<i)]-1]);\n\t\t}\n\t}\n\tfor(int st=0;st<(1<<k);++st){\n\t\tint L=l[0][fr[((1<<k)-1)^st]-1],R=r[0][fl[st]+1];\n\t\tif(L<=R)s[L]++,s[R+1]--;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\ts[i]+=s[i-1];\n\t\tputs(s[i]?\"Possible\":\"Impossible\");\n\t}\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Indomie, Mie dari Indonesia\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <queue>\n#include <cstring>\nusing namespace std;\n#define pb push_back\nconst int LogN=18;\nconst int MAXN=200000;\nint n,air,jarak[(1<<(LogN))+5],terkanan[LogN+5][MAXN+5],terkiri[LogN+5][MAXN+5];\nint pos[MAXN+5],l,r,komponen;\nbool ans[MAXN+5];\nvector <int> daftarair;\nvoid isiair(int air){\n\twhile(air>0)\n\t\tdaftarair.pb(air),air/=2;\n\tdaftarair.pb(0);\n\tassert(daftarair.size()<=LogN);\n}\nvoid isiterkanan(int jenis){\n\tint last=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(pos[i]-pos[i-1]>daftarair[jenis])\n\t\t{\n\t\t\twhile(last!=i)\n\t\t\t{\n\t\t\t\tterkanan[jenis][last]=i-1;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t}\n\t}\n\twhile(last!=n+1)\n\t{\n\t\tterkanan[jenis][last]=n;\n\t\tlast++;\n\t}\n}\nvoid isiterkiri(int jenis){\n\tint last=n;\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tif(pos[i+1]-pos[i]>daftarair[jenis])\n\t\t{\n\t\t\twhile(last!=i)\n\t\t\t{\n\t\t\t\tterkiri[jenis][last]=i+1;\n\t\t\t\tlast--;\n\t\t\t}\n\t\t}\n\t}\n\twhile(last!=0)\n\t{\n\t\tterkiri[jenis][last]=1;\n\t\tlast--;\n\t}\n}\nvoid isiterkanan(){\n\tfor(int i=0;i<daftarair.size();i++)\n\t\tisiterkanan(i);\n}\nvoid isiterkiri(){\n\tfor(int i=0;i<daftarair.size();i++)\n\t\tisiterkiri(i);\n}\nint totalkomponen(){\n\tint ret=0;\n\tint now=1;\n\twhile(now<=n)\n\t{\n\t\tret++;\n\t\tnow=terkanan[0][now];\n\t\tnow++;\n\t}\n\treturn ret;\n}\nbool bfs(){\n\tqueue <int> cari;\n\tmemset(jarak,-1,sizeof(jarak));\n\tjarak[0]=1;\n\tif(l<=jarak[0]&&jarak[0]<=r)\n\t\tjarak[0]=r+1;\n\tcari.push(0);\n\twhile(!cari.empty())\n\t{\n\t\t//cout<<\"bfs\"<<endl;\n\t\tint u=cari.front();\n\t\tif(jarak[u]>n)\n\t\t{\n\t\t\t//cout<<\"terkanannya \"<<jarak[u]<<endl;\n\t\t\treturn true;\n\t\t}\n\t\tcari.pop();\n\t\t//cout<<u<<endl;\n\t\tfor(int i=1;i<daftarair.size();i++)\n\t\t{\n\t\t\tif(u&(1<<(i-1)))\n\t\t\t\tcontinue;\n\t\t\tint v=(u|(1<<(i-1)));\n\t\t\tint nextpos=terkanan[i][jarak[u]]+1;\n\t\t\tif(l<=nextpos&&nextpos<=r)\n\t\t\t\tnextpos=r+1;\n\t\t\tif(jarak[v]==-1)\n\t\t\t{\n\t\t\t\tjarak[v]=nextpos;\n\t\t\t\tcari.push(v);\n\t\t\t}\n\t\t\telse\n\t\t\t\tjarak[v]=max(jarak[v],nextpos);\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&air);\n\tisiair(air);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&pos[i]);\n\tisiterkanan();\n\tisiterkiri();\n\tkomponen=totalkomponen();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\t//cout<<\"loop \"<<i<<endl;\n\t\tif(komponen>daftarair.size())\n\t\t{\n\t\t\tans[i]=false;\n\t\t}\n\t\telse if(i!=1&&terkanan[0][i]==terkanan[0][i-1])\t\t\t//in the same komponen\n\t\t{\n\t\t\tans[i]=ans[i-1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl=terkiri[0][i];\n\t\t\tr=terkanan[0][i];\n\t\t\tif(bfs())\n\t\t\t\tans[i]=true;\n\t\t\telse\n\t\t\t\tans[i]=false;\n\t\t}\n\t\tif(ans[i])\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200005;\n\nint n, v[20];\nint a[MAXN];\nint f[20][MAXN], g[20][MAXN];\n\nint fl[1<<20|1], fr[1<<20|1];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &v[0]);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tint lev = 0;\n\tfor (int i = 0; ; i++) {\n\t\tlev = i;\n\t\tf[i][n+1] = n+1;\n\t\tg[i][0] = 0;\n\t\tfor (int j = n; j >= 1; j--) {\n\t\t\tf[i][j] = j;\n\t\t\tif (j < n && a[j+1]-a[j] <= v[i])\n\t\t\t\tf[i][j] = f[i][j+1];\n\t\t}\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tg[i][j] = j;\n\t\t\tif (j > 1 && a[j]-a[j-1] <= v[i])\n\t\t\t\tg[i][j] = g[i][j-1];\n\t\t}\n\t\tif (v[i] == 0) break;\n\t\tv[i+1] = v[i]>>1;\n\t}\n\tfl[0] = 0, fr[0] = n+1;\n\tfor (int i = 1; i < 1<<(lev+1); i++) {\n\t\tfl[i] = 1, fr[i] = n;\n\t\tfor (int k = 0; k <= lev; k++)\n\t\t\tif (i>>k&1) {\n\t\t\t\tfl[i] = max(fl[i], f[k][fl[(i^(1<<k))]+1]);\n\t\t\t\tfr[i] = min(fr[i], g[k][fr[(i^(1<<k))]-1]);\n\t\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (f[0][i] != f[0][i-1])\n\t\t\tcnt++;\n\t}\n\t// cerr << cnt << \" \" << lev+1 << endl;\n\tif (cnt > lev+1) {\n\t\tfor (int i = 1; i <= n; i++) puts(\"Impossible\");\n\t} else {\n\t\tint last = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (f[0][i] != f[0][i-1]) {\n\t\t\t\t// cerr << i << endl;\n\t\t\t\tint tot = (1<<(lev+1))-1-1;\n\t\t\t\tlast = 0;\n\t\t\t\tfor (int j = tot; j >= 0; j = (j-1)&tot) {\n\t\t\t\t\t// cerr << j << \" \" << (tot^j) << \" \" << fl[j] << \" \" << fr[tot^j] << endl;\n\t\t\t\t\tif (fl[j] >= i-1 && fr[tot^j] <= f[0][i]+1) {\n\t\t\t\t\t\tlast = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (j == 0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (last == 0) puts(\"Impossible\");\n\t\t\telse puts(\"Possible\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nint V;\nint xs[214514];\nint vs[20];\nint dp1[1145141];\nint dp2[1145141];\nint dp3[1145141];\nvector<int> segs[20];\n\nint main() {\n  scanf(\"%d%d\", &N, &V);\n  for (int i=0; i<N; i++) {\n    scanf(\"%d\", &xs[i]);\n  }\n\n  int v = V;\n  int cnt = 0;\n  while (v >= 0) {\n    vs[cnt++] = v;\n    if (v == 0) break;\n    v /= 2;\n  }\n\n  for (int i=0; i<cnt; i++) {\n    int v = vs[i];\n    segs[i].emplace_back(0);\n    for (int idx=1; idx<N; idx++) {\n      if (xs[idx]-xs[idx-1] > v) segs[i].emplace_back(idx);\n    }\n    segs[i].emplace_back(N);\n  }\n\n  int lim = 1 << cnt;\n  fill(dp1, dp1+lim, -1);\n  dp1[0] = 0;\n  for (int st=0; st<lim; st++) {\n    for (int i=0; i<cnt; i++) {\n      if (st >> i & 1) continue;\n      int nst = st | (1 << i);\n      int g = *upper_bound(segs[i].begin(), segs[i].end(), dp1[st]);\n      dp1[nst] = max(dp1[nst], g);\n    }\n  }\n\n  fill(dp2, dp2+lim, N);\n  dp2[0] = N-1;\n  for (int st=0; st<lim; st++) {\n    for (int i=0; i<cnt; i++) {\n      if (st >> i & 1) continue;\n      int nst = st | (1 << i);\n      auto itr = upper_bound(segs[i].begin(), segs[i].end(), dp2[st]);\n      itr--;\n      dp2[nst] = min(dp2[nst], *itr-1);\n    }\n  }\n\n  /*fill(dp3, dp3+lim, -1);\n  dp3[0] = 1;\n  for (int st=0; st<lim; st++) {\n    for (int i=0; i<cnt; i++) {\n      if (st >> i & 1) continue;\n      int nst = st | (1 << i);\n      int g = *upper_bound(segs[i].begin(), segs[i].end(), dp3[st]);\n      dp3[nst] = max(dp3[nst], g);\n    }\n  }\n\n  fill(dp4, dp4+lim, N);\n  dp4[0] = N-2;\n  for (int st=0; st<lim; st++) {\n    for (int i=0; i<cnt; i++) {\n      if (st >> i & 1) continue;\n      int nst = st | (1 << i);\n      auto itr = upper_bound(segs[i].begin(), segs[i].end(), dp4[st]);\n      itr--;\n      dp4[nst] = min(dp4[nst], *itr-1);\n    }\n  }*/\n\n  fill(dp3, dp3+N+10, N+1);\n  for (int st=0; st<lim; st++) {\n    if (st & 1) continue;\n    int cst = (lim-1) & (~st) & ~1;\n    assert(dp1[st] >= 0);\n    dp3[dp1[st]] = min(dp3[dp1[st]], dp2[cst]);\n  }\n\n  for (int i=N; i>=0; i--) {\n    dp3[i] = min(dp3[i], dp3[i+1]);\n  }\n\n  for (int i=0; i<N; i++) {\n    auto itr = upper_bound(segs[0].begin(), segs[0].end(), i);\n    int b = *itr;\n    itr--;\n    int a = *itr-1;\n    bool ok = false;\n    if (dp3[a+1] < b) puts(\"Possible\");\n    else puts(\"Impossible\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int N = 200005;\n\ninline void gi(int &x){\n\tint f = 1; x = 0; char c = getchar();\n\twhile(c < '0' || c > '9'){\n\t\tif(c == '-')f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9'){\n\t\tx = x * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tx *= f;\n}\nint n, v, a[N], vis[N], ans[N];\nint walk(int st, int vv){\n\tint i, j; vis[st] = j = 1;\n\tfor(i = st; i > 1 && !vis[i - 1] && a[i] - a[i - 1] <= vv; vis[-- i] = 1, j ++);\n\tfor(i = st; i < n && !vis[i + 1] && a[i + 1] - a[i] <= vv; vis[++ i] = 1, j ++);\n\treturn j;\n}\nbool check(int st){\n\tint i, j, k, tv = v, id, las;\n\tfor(i = 1; i <= n; i ++)\n\t\tvis[i] = 0;\n\tk = walk(st, v), las = v, tv >>= 1;\n\twhile(1){\n\t\tfor(i = 1, j = 0; i < n; i ++)\n\t\t\tif(!vis[i] && !vis[i + 1] && a[i + 1] - a[i] <= tv)\n\t\t\t\tif(a[i + 1] - a[i] > j)\n\t\t\t\t\tid = i, j = a[i + 1] - a[i];\n\t\tif(j == 0){tv = las; break;}\n\t\tlas = tv, tv >>= 1, k += walk(id, las);\n\t}\n\tif(k == n || (1 << n - k - 1) <= las)\n\t\treturn 1;\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k = 0; gi(n), gi(v);\n\tfor(i = 1; i <= n; i ++)gi(a[i]);\n\tfor(i = 1; i <= n; i ++)\n\t\tans[i] = check(i);\n\tfor(i = 1; i <= n; i ++)\n\t\tputs(ans[i] ? \"Possible\" : \"Impossible\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FR first\n#define SE second\nusing namespace std;\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0,fg=1;char c=Get();\n    while(!isdigit(c)&&c!='-') c=Get();\n    if(c=='-') fg=-1,c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x*fg;\n}\ntypedef pair<int,int> pii;\nconst int INF=0x3f3f3f3f;\nconst int N=200010;\nint n,V,X[N],dep=0;\nint L[20][N],R[20][N];\nint exL[N<<4],exR[N<<4];\npii seg[N];\nbool ans[N];\nint main()\n{\n    n=read();V=read();\n    for(int i=1;i<=n;i++) X[i]=read();\n    X[0]=-INF-V-1;X[n+1]=INF+V+1;\n    for(int v=V;v>=0;v>>=1,dep++)\n    {\n        R[dep][n+1]=n+1;\n        for(int i=1;i<=n;i++) L[dep][i]=(X[i]-X[i-1]<=v)?L[dep][i-1]:i;\n        for(int i=n;i>=1;i--) R[dep][i]=(X[i+1]-X[i]<=v)?R[dep][i+1]:i;\n        if(v==0){dep++;break;}\n    }\n    for(int i=1;i<=n;i++) seg[i]=pii(L[0][i],R[0][i]);\n    int cnt=unique(seg+1,seg+1+n)-(seg+1);\n    for(int i=0;i<(1<<dep);i++) exR[i]=n+1;\n    for(int s=0;s<(1<<dep);s+=2)\n        for(int i=0;i<dep;i++)\n        {\n            if(!(s&(1<<i))) continue;\n            exL[s]=max(exL[s],R[i][exL[s^(1<<i)]+1]);\n            exR[s]=min(exR[s],L[i][exR[s^(1<<i)]-1]);\n        }\n    if(cnt>dep) goto output;\n    for(int i=1;i<=cnt;i++)\n        for(int s=0;s<(1<<dep);s+=2)\n            if(exL[s]>=seg[i].FR-1&&exR[(1<<dep)-1-s-1]<=seg[i].SE+1)\n            {\n                for(int j=seg[i].FR;j<=seg[i].SE;j++) ans[j]=1;\n                break;\n            }\n    output: for(int i=1;i<=n;i++) puts(ans[i]?\"Possible\":\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL \t\t\t\t\tlong long\n#define ULL \t\t\t\tunsigned long long\n#define pii \t\t\t\tpair<int,int>\n#define fi \t\t\t\t\tfirst\n#define se \t\t\t\t\tsecond\n#define mp \t\t\t\t\tmake_pair\n#define vi \t\t\t\t\tvector<int>\n#define psb \t\t\t\tpush_back\n#define ppb \t\t\t\tpop_back\n#define all(x)\t\t\t \t(x).begin(),(x).end()\n#define sz \t\t\t\t\tsize()\n#define endln \t\t\t\tprintf(\"\\n\")\n#define gc\t\t\t\t\tgetchar_unlocked\n#define setmin(x)\t\t\tmemset((x), -1, sizeof((x)))\n#define setnul(x)\t\t\tmemset((x), 0, sizeof((x)))\n#ifndef getchar_unlocked\n#define getchar_unlocked \tgetchar\n#endif\n\nvoid gi( int &ret ) {\n\tret = 0; char inp=gc(); int kl=1;\n\twhile (inp<'0' || inp>'9') {if (inp=='-') kl=-1; inp=gc();}\n\twhile ('0'<=inp && inp<='9') ret=(ret<<3)+(ret<<1)+(int)(inp-'0'), inp=gc();\n\tif (kl<1) ret=-ret;\n}\n\nconst int MAXN = 2e5 + 5;\nconst int MAXLOGN = 18;\nconst int MAXBIT = (1<<18);\n\nint n, v, x[MAXN], nx[MAXLOGN][MAXN], dst[MAXBIT], skip, aft, no = 0;\n\nbool bfs () {\n\tqueue < int > q;\n\tq.push(1);\n\tmemset(dst,-1,sizeof(dst));\n\tdst[1] = 1;\n\twhile (!q.empty()) {\n\t\tint bit = q.front(), now = dst[bit]; q.pop();\n\t\tif (now==skip) now = aft;\n\t\tif (now>n) return 1;\n\t\tfor (int i=0; i<=no; i++) \n\t\t\tif (!(bit&(1<<i))) {\n\t\t\t\tint nexbit = bit | (1<<i);\n\t\t\t\tif (dst[nexbit]<0) q.push(nexbit);\n\t\t\t\tdst[nexbit] = max(dst[nexbit], nx[i][now]);\n\t\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tgi(n); gi(v);\n\tfor (int i=1; i<=n; i++) gi(x[i]);\n\tvi sg;\n\twhile (v) {\n\t\tint aw = 1, lst = 1;\n\t\twhile (lst<=n) {\n\t\t\tif (!no) sg.psb(lst);\n\t\t\twhile (aw<n && (x[aw+1]-x[aw])<=v) aw++;\n\t\t\taw++;\n\t\t\twhile (lst<aw) nx[no][lst++] = aw;\n\t\t}\n\t\tno++;\n\t\tv >>= 1;\n\t}\n\tfor (int i=1; i<=n; i++) nx[no][i] = i+1;\n\tif (sg.sz > MAXLOGN) {\n\t\tfor (int i=1; i<=n; i++) printf (\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tfor (auto aw : sg) {\n\t\tskip = aw; aft = nx[0][aw];\n\t\tif (bfs()) {\n\t\t\twhile (aw++ < aft) printf (\"Possible\\n\"); \n\t\t} else {\n\t\t\twhile (aw++ < aft) printf (\"Impossible\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memset( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\nconst int MAXN = 200020;\nconst int INF = 0x3f3f3f3f;\n\nint n, m, v[22], tot, a[MAXN], d[MAXN];\nint f[MAXN][22], g[MAXN][22];\nint dpl[MAXN << 2], dpr[MAXN << 2], ans[MAXN];\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tscanf( \"%d%d\", &n, &m );\n\tfor( int i = 1 ; i <= n ; i++ ) scanf( \"%d\", &a[ i ] );\n\twhile( m ) v[ tot++ ] = m, m >>= 1;\n\tv[ tot++ ] = 0;\n\td[ 1 ] = d[ n + 1 ] = INF;\n\tfor( int i = 2 ; i <= n ; i++ ) d[ i ] = a[ i ] - a[ i - 1 ];\n\tfor( int j = 0 ; j < tot ; j++ )\n\t{\n\t\tfor( int i = 1 ; i <= n ; i++ )\n\t\t\tif( d[ i ] > v[ j ] ) f[ i ][ j ] = i;\n\t\t\telse f[ i ][ j ] = f[ i - 1 ][ j ];\n\t\tfor( int i = n ; i ; i-- )\n\t\t\tif( d[ i + 1 ] > v[ j ] ) g[ i ][ j ] = i;\n\t\t\telse g[ i ][ j ] = g[ i + 1 ][ j ];\n\t}\n\tfill( dpr, 0x3f );\n\tdpr[ 0 ] = n + 1;\n\tfor( int i = 0 ; i < ( 1 << tot ) ; i++ )\n\t\tfor( int j = 0 ; j < tot ; j++ ) if( !( i >> j & 1 ) )\n\t\t{\n\t\t\tif( dpl[ i ] >= n ) dpl[ i | ( 1 << j ) ] = n;\n\t\t\telse dpl[ i | ( 1 << j ) ] = max( dpl[ i | ( 1 << j ) ], g[ dpl[ i ] + 1 ][ j ] );\n\t\t\tif( dpr[ i ] <= 1 ) dpr[ i | ( 1 << j ) ] = 1;\n\t\t\telse dpr[ i | ( 1 << j ) ] = min( dpr[ i | ( 1 << j ) ], f[ dpr[ i ] - 1 ][ j ] );\n\t\t}\n\tfor( int i = 0 ; i < ( 1 << tot ) ; i++ )\n\t{\n\t\tif( i & 1 ) continue;\n\t\tint l = dpl[ i ], r = dpr[ ( 1 << tot ) - 1 - i - 1 ];\n\t\tif( l + 1 >= r ) ans[ 1 ]++;\n\t\telse\n\t\t{\n\t\t\tint L = f[ l + 1 ][ 0 ], R = g[ l + 1 ][ 0 ];\n\t\t\tif( R + 1 >= r )\n\t\t\t{\n\t\t\t\tif( L > R )\n\t\t\t\t{\n\t\t\t\t\tint c[ ( l + 1 ) * 1000 ];\n\t\t\t\t\tfill( c, 0 );\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tans[ L ]++, ans[ R + 1 ]--;\n\t\t\t}\n\t\t}\n\t}\n\tfor( int i = 1, cur = 0 ; i <= n ; i++ )\n\t{\n\t\tcur += ans[ i ];\n\t\tif( cur ) puts( \"Possible\" );\n\t\telse puts( \"Impossible\" );\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/// a.cpp\n\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < __typeof(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < ll >\n# define pb push_back\n# define pdd pair < db , db >\ninline int readChar();\ntemplate <class T = int> inline T readInt();\ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x );\ninline void writeWord( const char *s );\n\n/** Read */\n\nstatic const int buf_size = 4096;\n\ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len)\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    if (pos == len)\n        return -1;\n    return buf[pos++];\n}\n\ninline int readChar() {\n    int c = getChar();\n    while (c <= 32)\n        c = getChar();\n    return c;\n}\n\ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n\n/** Write */\n\nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n\ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n\ntemplate <class T>\ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n\n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n\ninline void writeWord( const char *s ) {\n    while (*s)\n        writeChar(*s++);\n}\n\nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int Dp1[20][1 << 20];\n    static int Dp2[20][1 << 20];\n    int n,k;\n    n = readInt();\n    k = readInt();\n    vi ss;\n    ss.pb(k / 2);\n    while (ss.back()) ss.pb(ss.back() / 2);\n    static int s[1 << 20];\n    for (int i = 1;i <= n;++i)\n        s[i] = readInt();\n    static int D1[1 << 20];\n    static int D2[1 << 20];\n    const int lg = ss.size();\n    const int N = 1 << lg;\n    for (int t = 0;t < lg;++t)\n    {\n        Dp1[t][1] = 0;\n        for (int i = 2;i <= n;++i)\n            if (s[i] - s[i - 1] <= ss[t])\n                Dp1[t][i] = Dp1[t][i - 1];\n            else\n                Dp1[t][i] = i - 1;\n        Dp2[t][n] = Dp2[t][n + 1] = n + 1;\n        for (int i = n - 1;i;--i)\n            if (s[i + 1] - s[i] <= ss[t])\n                Dp2[t][i] = Dp2[t][i + 1];\n            else\n                Dp2[t][i] = i + 1;\n    }\n    D1[0] = 0;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            if ((mask >> i) & 1)\n                smax(D1[mask],Dp2[i][D1[mask ^ (1 << i)] + 1] - 1);\n    for (int mask = 0;mask < N;++mask)\n        D2[mask] = n + 1;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            smin(D2[mask],Dp1[i][D2[mask ^ (1 << i)] - 1] + 1);\n    static int answer[1 << 20];\n    static int tt[1 << 20];\n    tt[1] = 1;\n    for (int i = 2;i <= n;++i)\n        if (s[i] - s[i - 1] <= k)\n            tt[i] = tt[i - 1];\n        else\n            tt[i] = i;\n    for (int mask = 0;mask < N;++mask)\n    {\n        const int l = D1[mask] + 1;\n        const int r = D2[(N - 1) ^ mask] - 1;\n        if (l > r)\n            assert(0),++answer[1],--answer[n + 1];\n        if (tt[r] <= l)\n            ++answer[l],--answer[r + 1];\n    }\n    for (int i = 1;i <= n;++i)\n        answer[i] += answer[i - 1];\n    for (int i = 1;i <= n;++i)\n        if (answer[i])\n            PP;\n        else\n            II;\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=200010;\nint n, v, m;\nint a[maxn];\nint f[maxn], g[maxn];\nint Next[maxn][20], pre[maxn][20];\n\nvoid chkmax(int& x,int y){ if(x<y) x=y; }\nvoid chkmin(int& x,int y){ if(x>y) x=y; }\n\nint Log[maxn];\nvoid init(){\n\tfor(int i=2;i<maxn;i++) Log[i]=Log[i>>1]+1;\n}\n\nint fa[maxn];\nint find(int x){ return x==fa[x] ? x : fa[x]=find(fa[x]); }\n\nint ans[maxn], b[maxn];\n\nint main(){\n\n\tinit();\n\tscanf(\"%d%d\", &n, &v);\n\tint t=v; b[++m]=t;\n\twhile(t){\n\t\tb[++m]=t/2;\n\t\tt/=2;\n\t}\n\t// printf(\"m = %d\\n\", m);\n\t// for(int i=1;i<=m;i++) printf(\"%d \", b[i]); puts(\"\");\n\tfor(int i=1;i<=n;i++) scanf(\"%d\", &a[i]);\n\tfor(int j=1;j<=m;j++){\n\t\tfor(int i=1;i<=n;i++) fa[i]=i;\n\t\tfor(int i=1;i<n;i++) if(a[i+1]-a[i]<=b[j]) fa[find(i)]=find(i+1);\n\t\tfor(int i=1;i<=n;i++) Next[i][j]=find(i);\n\t\t\n\t\tfor(int i=1;i<=n;i++) fa[i]=i;\n\t\tfor(int i=1;i<n;i++) if(a[i+1]-a[i]<=b[j]) fa[find(i+1)]=find(i);\n\t\tfor(int i=1;i<=n;i++) pre[i][j]=find(i);\n\t\t// for(int i=1;i<=n;i++) printf(\"%d \", Next[i][j]); puts(\"\");\n\t}\n\tfor(int i=0;i<(1<<m);i++) for(int j=1;j<=m;j++) if(!(i & (1<<(j-1)))){\n\t\tchkmax(f[i | (1<<(j-1))], Next[ f[i]+1 ][j]);\n\t}\n\n\tfor(int i=0;i<(1<<m);i++) g[i]=n+1;\n\tfor(int i=0;i<(1<<m);i++) for(int j=1;j<=m;j++) if(!(i & (1<<(j-1))))\n\t\tchkmin(g[i | (1<<(j-1))], pre[ g[i]-1 ][j]);\n\tfor(int i=0;i<(1<<m);i++){ \n\t\tif((i & 1)) continue;\n\t\tint j=((1<<m)-1) ^ i ^ 1;\n\t\tint l=1, r=Next[l][1];\n\t\twhile(l<=n){\n\t\t\tif(f[i]>=l-1 && g[j]<=r+1) for(int k=l;k<=r;k++) ans[k]=1;\n\t\t\tl=r+1, r=Next[l][1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) printf(\"%s\\n\", ans[i] ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXMASK=(1<<19);\nconst int MAXN=20;\nconst int MAXM=200005;\nint a[MAXM],n,V,mx;\nvector<pii> vec[MAXN];\nint L[MAXN][MAXM],R[MAXN][MAXM],cnt;\nvoid work(int x,int o)\n{\n\tfor(int i=1,nxt;i<=n;i=nxt+1)\n\t{\n\t\tnxt=i;while(nxt+1<=n&&a[nxt+1]-a[nxt]<=x)++nxt;\n\t\tfor(int j=i;j<=nxt;j++)L[o][j]=i,R[o][j]=nxt;\n\t\tif(!o)++cnt;\n\t}\n}\nint f[MAXMASK],g[MAXMASK],num[MAXN][MAXMASK],bin[25];\nint main()\n{\n\tbin[1]=1;for(int i=2;i<=20;i++)bin[i]=bin[i-1]<<1;\n\tn=read();V=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tint temp=V;while(temp)work(temp,mx++),temp>>=1;\n\tif(cnt>mx+1){for(int i=1;i<=n;i++)puts(\"Impossible\");return 0;}\n\tfor(int i=1;i<=n;i++)L[mx][i]=R[mx][i]=i;\n\tmemset(g,63,sizeof(g));g[0]=n+1;\n\tfor(int i=1;i<bin[mx+1];i++)for(int j=1;j<=mx;j++)if(i&bin[j])\n\t{\n\t\tint pre=f[i^bin[j]];\n\t\tf[i]=max(f[i],R[j][pre+1]);\n\t\tif(pre==n)f[i]=n;\n\t\tpre=g[i^bin[j]];\n\t\tg[i]=min(g[i],L[j][pre-1]);\n\t\tif(pre==1)g[i]=1;\n\t}\n\tfor(int i=1;i<=n;i=R[0][i]+1)\n\t{\n\t\tbool tf=false;\n\t\tfor(int j=0;j<bin[mx+1];j++)\n\t\t{\n\t\t\tint lim1=L[0][i],lim2=R[0][i];\n\t\t\tif(f[j]>=lim1-1&&g[(bin[mx+1]-1)^j]<=lim2+1){tf=true;break;}\n\t\t}\n\t\tif(tf)for(int j=i;j<=R[0][i];j++)puts(\"Possible\");\n\t\telse for(int j=i;j<=R[0][i];j++)puts(\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nint n,v,a[200111],nxt[20][200111],pre[20][200111],k,v2[20],dp1[1<<20],dp2[1<<20];\nbool ans[200111];\n\nint main()\n{\n\tget2(n,v);\n\tint tmp=v;\n\twhile(tmp)\n\t{\n\t\tv2[k++]=tmp;\n\t\ttmp>>=1;\n\t}\n\tv2[k++]=0;reverse(v2,v2+k);\n\tfor(int i=1;i<=n;i++)get1(a[i]);\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tnxt[i][n+1]=n+1;pre[i][0]=0;\n\t\tfor(int j=1,j2;j<=n;j=j2)\n\t\t{\n\t\t\tj2=j+1;\n\t\t\twhile(j2<=n&&a[j2]-a[j2-1]<=v2[i])j2++;\n\t\t\tfor(int t=j;t<j2;t++)\n\t\t\t{\n\t\t\t\tnxt[i][t]=j2;\n\t\t\t\tpre[i][t]=j-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<(1<<k-1);i++)\n\t{\n\t\tdp1[i]=1;\n\t\tdp2[i]=n;\n\t}\n\tfor(int i=0;i<(1<<k-1);i++)\n\t{\n\t\tfor(int j=0;j<k-1;j++)if(((i>>j)&1)==0)\n\t\t{\n\t\t\tdp1[i^(1<<j)]=max(dp1[i^(1<<j)],nxt[j][dp1[i]]);\n\t\t\tdp2[i^(1<<j)]=min(dp2[i^(1<<j)],pre[j][dp2[i]]);\n\t\t}\n\t}\n\tif(dp1[(1<<k-1)-1]==n+1)\n\t{\n\t\tfor(int i=1;i<=n;i++)puts(\"Possible\");\n\t\treturn 0;\n\t}\n\tint all=(1<<k-1)-1;\n\tfor(int i=0;i<(1<<k-1);i++)if(dp2[all^i]<nxt[k-1][dp1[i]])ans[dp1[i]]=1;\n\tfor(int i=1;i<=n;i=nxt[k-1][i])\n\t{\n\t\tfor(int j=i;j<nxt[k-1][i];j++)\n\t\t{\n\t\t\tif(ans[i])puts(\"Possible\");\n\t\t\telse puts(\"Impossible\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i != -1; i = edge[i].next)\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\nconst int N = 524288;\n\nint x[N], ll[20][N], rr[20][N], f[N], g[N], sg[N];\n\nbool vv[N];\n\nint main()\n{\n\t//freopen(\"snake7.in\", \"r\", stdin);\n\t//freopen(\"s.out\", \"w\", stdout);\n\t\n\tint n, v;\n\tscanf(\"%d%d\", &n, &v);\n\tRep(i, n) scanf(\"%d\", &x[i]);\n\t\n\tint k = 0;\n\twhile (true) {\n\t\trr[k][n + 1] = rr[k][n] = n;\n\t\tfor (int i = n - 1; i; i --) {\n\t\t\tif (x[i] + v >= x[i + 1]) rr[k][i] = rr[k][i + 1];\n\t\t\telse rr[k][i] = i;\n\t\t}\n\t\tll[k][0] = ll[k][1] = 1;\n\t\tfor (int i = 2; i <= n; i ++) {\n\t\t\tif (x[i - 1] + v >= x[i]) ll[k][i] = ll[k][i - 1];\n\t\t\telse ll[k][i] = i;\n\t\t}\n\t\tk ++;\n\t\tif (!v) break;\n\t\tv /= 2;\n\t}\n\t\n\tRep0(s, (1 << k) - 1) f[s] = 0;\n\tRep0(s, (1 << k) - 1) g[s] = n + 1;\n\t\n\tRep0(s, (1 << k) - 1){\n\t\t//printf(\"%d %d %d\\n\", s, f[s], g[s]);\n\t\tRep0(i, k - 1) if (!(s & (1 << i))) {\t\n\t\t\tf[s ^ (1 << i)] = max(f[s ^ (1 << i)], rr[i][f[s] + 1]);\n\t\t\tg[s ^ (1 << i)] = min(g[s ^ (1 << i)], ll[i][g[s] - 1]);\n\t\t}\n\t}\n\t\n\tRep0(s, (1 << k) - 1) {\n\t\tsg[s] = g[s];\n\t\tRep0(i, k - 1) if (s & (1 << i)) sg[s] = min(sg[s], sg[s ^ (1 << i)]);\n\t}\n\tbool flag = false;\n\tRep0(s, (1 << k) - 1) if (!(s & 1)) {\n\t\tint ss = (((1 << k) - 1) ^ 1) ^ s;\n\t\t//printf(\"%d %d %d %d\\n\", s, ss, f[s], sg[ss]);\n\t\tif (sg[ss] <= f[s] + 1){ flag = true; break;}\n\t\telse if (ll[0][f[s] + 1] == ll[0][sg[ss] - 1]){ vv[ll[0][f[s] + 1]] = true; }\n\t}\n\t\n\tif (flag) Rep(i, n) printf(\"Possible\\n\");\n\telse Rep(i, n){\n\t\tif (vv[ll[0][i]]) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 10;\nint N, V;\nint X[MAXN];\nint v[MAXN], vn;\nint l[19][MAXN], r[19][MAXN];\nint f[MAXN], g[MAXN], h[MAXN];\n\nint main() {\n\tregister int s, i, j;\n\tscanf(\"%d%d\", &N, &V);\n\tfor(i = 1; i <= N; ++i)\n\t\tscanf(\"%d\", X + i);\n\tv[0] = V; V >>= 1;\n\twhile(V)\n\t\tv[++vn] = V, V >>= 1;\n\tv[++vn] = 0;\n\treverse(v, v + vn + 1);\n\tfor(i = 0; i <= vn; ++i) {\n\t\tl[i][1] = 1;\n\t\tfor(j = 2; j <= N; ++j)\n\t\t\tl[i][j] = X[j] - X[j - 1] <= v[i] ? l[i][j - 1] : j;\n\t\tr[i][N] = N;\n\t\tfor(j = N - 1; j; --j)\n\t\t\tr[i][j] = X[j + 1] - X[j] <= v[i] ? r[i][j + 1] : j;\n\t}\n\tf[0] = 0; g[0] = N + 1;\n\tfor(s = 1; s <= (1 << (vn + 1)) - 1; ++s) {\n\t\tf[s] = 0; g[s] = N + 1;\n\t\tfor(i = 0; i <= vn; ++i)\n\t\t\tif(s & (1 << i)) {\n\t\t\t\tint x = s ^ (1 << i);\n\t\t\t\tf[s] = max(f[s], f[x] == N ? N : r[i][f[x] + 1]);\n\t\t\t\tg[s] = min(g[s], g[x] == 1 ? 1 : l[i][g[x] - 1]);\n\t\t\t}\n\t}\n\tfor(i = 0; i <= N; ++i)\n\t\th[i] = N + 2;\n\tfor(i = 0; i <= (1 << vn) - 1; ++i)\n\t\th[f[i]] = min(h[f[i]], g[((1 << vn) - 1) ^ i]);\n\tfor(i = N - 1; i >= 0; --i)\n\t\th[i] = min(h[i], h[i + 1]);\n\tfor(i = 1; i <= N; ++i)\n\t\tputs(h[l[vn][i] - 1] <= r[vn][i] + 1 ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nHanit Banga\n*/\n\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 2e5 + 10, M = log2(N) + 10;\nconst ll inf = 1e15;\n\nll x[N];\nint v[N], dp_lt[2 * N], dp_rt[2 * N], lt[N][M], rt[N][M], max_r[N];\n\nint main()\n{\n\tint n, val;\n\tcin >> n >> val;\n\tx[0] = -inf;\n\tx[n + 1] = inf;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcin >> x[i];\n\n\tint m = 0;\n\tfor (int j = 0; val > 0; ++j, val /= 2, ++m)\n\t\tv[j] = val;\n\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t{\n\t\t\tlt[i][j] = 1;\n\t\t\tif (x[i] - x[i - 1] <= v[j])\n\t\t\t\tlt[i][j] += lt[i - 1][j];\n\t\t}\n\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t{\n\t\t\trt[n - i + 1][j] = 1;\n\t\t\tif (x[n - i + 2] - x[n - i + 1] <= v[j])\n\t\t\t\trt[n - i + 1][j] += rt[n - i + 2][j];\n\t\t}\n\t}\n\n\tint subsets = (1 << m);\n\tfor (int i = 1; i < subsets; ++i)\n\t{\n\t\tfor (int j = 0; j < m; ++j)\n\t\t{\n\t\t\tif (i & (1 << j))\n\t\t\t{\n\t\t\t\tint temp = dp_lt[i - (1 << j)];\n\t\t\t\tdp_lt[i] = max(dp_lt[i], temp + rt[temp + 1][j + 1]);\n\t\t\t\t\n\t\t\t\ttemp = dp_rt[i - (1 << j)];\n\t\t\t\tdp_rt[i] = max(dp_rt[i], temp + lt[n - temp][j + 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; ++i)\n\t\tmax_r[i] = -1;\n\n\tfor (int i = 0; i < subsets; ++i)\n\t\tmax_r[dp_lt[i]] = max(max_r[dp_lt[i]], dp_rt[subsets - 1 - i]);\n\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tmax_r[i] = max(max_r[i], max_r[i + 1]);\n\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tint l = lt[i][0], r = rt[i][0];\n\t\tl = i + 1 - l;\n\t\tr = r + i - 1;\n\n\t\tif (max_r[l - 1] >= n - r)\n\t\t\tcout << \"Possible\\n\";\n\t\telse\n\t\t\tcout << \"Impossible\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define iter(i, n) forw(i, 1, n)\n#define iter0(i, n) for (int i = 0; i < n; ++i)\n#define iter_r(i, n) for (int i = n; i >= 1; --i)\n#define forw(i, a, b) for (int i = a; i <= b; ++i)\n\n#define NR 201000\n\nbool mark[NR];\nint n, V, x[NR], v[20], pre[NR][20], suc[NR][20], l, f[301000], g[301000];\n\nint main() {\n\tscanf(\"%d%d\", &n, &V);\n\tfor (; V > 0; V = V / 2) v[l++] = V; v[l++] = 0;\n\titer(i, n) scanf(\"%d\", &x[i]);\n\t\n\titer0(i, l) suc[n][i] = n, pre[1][i] = 1;\n\tforw(i, 2, n) iter0(k, l) pre[i][k] = (x[i] - x[i - 1] <= v[k] ? pre[i - 1][k] : i);\n\titer_r(i, n - 1) iter0(k, l) suc[i][k] = (x[i + 1] - x[i] <= v[k] ? suc[i + 1][k] : i);\n\n\n\n\tint M = 1 << l;\n\titer0(s, M) g[s] = n + 1;\n\titer0(s, M) {\n\t\t//printf(\": %d %d %d\\n\", s, f[s], g[s]);\n\t\titer0(i, l) if (!(s >> i & 1)) {\n\t\t\tf[s ^ (1 << i)] = max(f[s ^ (1 << i)], f[s] == n ? n : suc[f[s] + 1][i]);\n\t\t\tg[s ^ (1 << i)] = min(g[s ^ (1 << i)], g[s] == 1 ? 1 : pre[g[s] - 1][i]);\n\t\t}\n\t}\n\n\tbool all = false;\n\titer0(s, M) if (!(s & 1)) {\n\t\tint t = M - 1 - s - 1;\n\t\tint l = f[s], r = g[t];\n\t\t//printf(\"!%d %d %d\\n\", l, r, suc[l+1][0]);\n\n\t\tif (l > r) all = true;\n\t\telse if (suc[l + 1][0] >= r - 1) mark[l + 1] = true;\n\t}\n\n\tif (all) iter(i, n) mark[i] = true;\n\n\tint r = 0;\n\titer(i, n) {\n\t\tif (mark[i]) r = suc[i][0];\n\t\tputs(i <= r ? \"Possible\" : \"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=2e5+5;\nint n,m,a[N],l[N][25],r[N][25],v[25],cnt=0,L[1<<25],R[1<<25],ans[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tint V=m;\n\twhile(V){V>>=1;v[cnt++]=V;}v[cnt]=m;\n//\tfor(int i=1;i<=cnt;i++) printf(\"%d \",v[i]);\n\tfor(int i=0;i<=cnt;i++)\n\t{\n\t\tl[i][1]=1;\n\t\tr[i][n]=n;\n\t\tfor(int j=2;j<=n;j++) l[i][j]=(a[j]-a[j-1]<=v[i])?l[i][j-1]:j;\n\t\tfor(int j=n-1;j>=1;j--) r[i][j]=(a[j+1]-a[j]<=v[i])?r[i][j+1]:j;\n\t}\n\t/*for(int i=0;i<=cnt;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++) printf(\"%d \",l[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n//\tL[0]=1,R[0]=n;\n\tfor(int i=0;i<(1<<cnt);i++) R[i]=n+1;\n\tfor(int i=0;i<(1<<cnt);i++)\n\t\tfor(int j=0;j<=cnt;j++)\n\t\t\tif(((1<<j)&i)==0)\n\t\t\t\tL[(1<<j)|i]=max(L[(1<<j)|i],r[j][L[i]+1]),\n\t\t\t\tR[(1<<j)|i]=min(R[(1<<j)|i],l[j][R[i]-1]);\n//\tfor(int i=0;i<(1<<cnt);i++) printf(\"%d %d\\n\",L[i],R[i]);\n\t/*for(int i=0;i<(1<<cnt);i++)\n\t{\n\t\tprintf(\"!! %d %d\\n\",i,((1<<cnt)-1)^i);\n\t\tif(L[i]>=R[((1<<cnt)-1)^i]) s[R[((1<<cnt)-1)^i]]++,s[L[i]+1]--,printf(\"%d %d\\n\",R[((1<<cnt)-1)^i],L[i]);\n\t}\n\tint sum=0;\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tsum+=s[i];\n\t\tif(sum>0) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}*/ \n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int j=0;j<(1<<cnt);j++)\n\t\t{\n\t\t\tint ss=((1<<cnt)-1)^j;\n\t\t\tif(L[j]>=i-1&&R[ss]<=r[cnt][i]+1){flag=1;break;}\n\t\t}\n\t\tfor(int j=i;j<=r[cnt][i];j++)\n\t\t{\n\t\t\tif(flag) ans[j]=1;\n\t\t\telse ans[j]=0;\n\t\t}\n\t\ti=r[cnt][i];\n\t}\n\tfor(int i=1;i<=n;i++) puts(ans[i]==0?\"Impossible\":\"Possible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\nstruct part {\n\tll maxd; //最大距離\n\tvi member; //メンバ\n\tbool operator<(const part& another) const {\n\t\treturn maxd > another.maxd;\n\t}\n};\n\nstruct dat {\n\tint distance; //距離区間\n\tvector<part> p;\n};\n\nint main() {\n\tint n, v; cin >> n >> v;\n\tvll x(n); Loop(i, n) cin >> x[i];\n\tvector<dat> dats;\n\twhile (1) {\n\t\tpart buf = { 0,{0} };\n\t\tdats.push_back({ v,{buf} });\n\t\tLoop1(i, n - 1) {\n\t\t\tif (x[i] - x[i - 1] <= v) {\n\t\t\t\tdats.back().p.back().member.push_back(i);\n\t\t\t\tdats.back().p.back().maxd = max(dats.back().p.back().maxd, x[i] - x[i - 1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdats.back().p.push_back({ 0,{i} });\n\t\t\t}\n\t\t}\n\t\tsort(dats.back().p.begin(), dats.back().p.end());\n\t\tif (v == 0) break;\n\t\tv /= 2;\n\t}\n\t//逆引き\n\tvvi table(n, vi(dats.size()));\n\tLoop(i, dats.size()) {\n\t\tLoop(j, dats[i].p.size()) {\n\t\t\tLoop(k, dats[i].p[j].member.size()) {\n\t\t\t\ttable[dats[i].p[j].member[k]][i] = j;\n\t\t\t}\n\t\t}\n\t}\n\tLoop(i, n) {\n\t\tvector<bool> done(n, false);\n\t\tint index = table[i][0];\n\t\tLoop(j, dats.size()) {\n\t\t\tLoop(k, dats[j].p[index].member.size()) {\n\t\t\t\tdone[dats[j].p[index].member[k]] = true;\n\t\t\t}\n\t\t\tif (j == dats.size() - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLoop(k, dats[j + 1].p.size()) {\n\t\t\t\t\tif (done[dats[j + 1].p[k].member[0]]) continue;\n\t\t\t\t\telse {\n\t\t\t\t\t\tindex = k;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = true;\n\t\tLoop(i, n) {\n\t\t\tif (!done[i]) {\n\t\t\t\tans = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ans) cout << \"Possible\" << endl;\n\t\telse cout << \"Impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)\n#define trav(it, v) for(typeof((v).begin()) it = (v).begin(); it != (v).end(); ++it)\n#define all(v) (v).begin(), (v).end()\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n\ntypedef double fl;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\t\nint N, V;\nint x[200005];\nint nodeInd;\n\nstruct Node{\n\tint l, r;\n\tint v;\n\tvector<Node> children;\n\tint ind;\n\n\tNode(int _l, int _r, int _v){\n\t\tind=nodeInd++;\n\t\tl=_l;\n\t\tr=_r;\n\t\tv=_v;\n\t\tif(!v)\n\t\t\treturn;\n\t\tint L=l;\n\t\trep(i,l+1,r){\n\t\t\tif(x[i] > x[i-1]+v){\n\t\t\t\tchildren.push_back(Node(L, i, v/2));\n\t\t\t\tL=i;\n\t\t\t}\n\t\t}\n\t\tchildren.push_back(Node(L, r, v/2));\n\t}\n};\n\nbool ans[200005];\nmap<vector<int>, bool> cache;\n\nbool rec(vector<Node*> nodes, int stepsLeft, bool init){\n\tvector<int> key;\n\trep(i,0,nodes.size()){\n\t\tkey.push_back(nodes[i]->ind);\n\t}\n\tif(cache.count(key))\n\t\treturn cache[key];\n\tif(nodes.empty())\n\t\treturn true;\n\tif(nodes[0]->v == 0)\n\t\treturn nodes.size() == 1;\n\tvector<Node*> newNodes;\n\trep(i,0,nodes.size()){\n\t\tif(newNodes.size()+nodes[i]->children.size() > stepsLeft)\n\t\t\treturn 0;\n\t\trep(j,0,nodes[i]->children.size())\n\t\t\tnewNodes.push_back(&(nodes[i]->children[j]));\n\t}\n\t/*bool hasUrgent=false;\n\trep(i,0,newNodes.size())\n\t\tif(newNodes[i]->children.size() > 1)\n\t\t\thasUrgent = true;*/\n\trep(i,0,newNodes.size()){\n\t\tvector<Node*> newNewNodes = newNodes;\n\t\tnewNewNodes.erase(newNewNodes.begin()+i);\n\t\tif(rec(newNewNodes, stepsLeft-1, 0)){\n\t\t\tif(init){\n\t\t\t\trep(j,newNodes[i]->l,newNodes[i]->r)\n\t\t\t\t\tans[j]=true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcache[key]=true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tcache[key]=false;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\", &N, &V);\n\trep(i,0,N)\n\t\tscanf(\"%d\", x+i);\n\tNode start(0, N, V);\n\tvector<Node*> v;\n\tv.push_back(&start);\n\tint stepsLeft=19;\n\trec(v,stepsLeft,1);\n\trep(i,0,N){\n\t\tputs(ans[i]?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=2E5+5;\n\nint N,M,V;\nint a[Maxn];\nint F[Maxn],G[Maxn];\nint L[20][Maxn],R[20][Maxn];\nint nxt[Maxn];\n\ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n\nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1)\n\t\t\t\tMAX(F[i],R[M-j][min(F[i-(1<<j)]+1,N)]),\n\t\t\t\tMIN(G[i],L[M-j][max(G[i-(1<<j)]-1,1)]);\n\t}\n\tfor(int i=0;i<(1<<M);++i) MAX(nxt[G[(1<<M)-i-1]],F[i]);\n\tfor(int i=1;i<=N+1;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[R[0][i]+1]>=L[0][i]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <deque>\n#include <utility>\n#include <chrono>\n#include <sstream>\n#include <iomanip>\n#define INF 1 << 30\n#define MOD 1000000007;\n#define pi 3.14159265358979\n#define rep(i, n) for (int (i) = 0; (i) < (int)(n); (i)++)\n#define reu(i, l, r) for (int (i) = (int)(l); (i) < (int)(r); (i)++)\n#define D(x) cout << x << endl\n#define d(x) cout << x\n#define all(x) (x).begin(), (x).end()\n#define pub(x) push_back(x)\n#define pob() pop_back()\n#define puf(x) push_front(x)\n#define pof() pop_front()\n#define mp(x, y) make_pair((x), (y))\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if (x < y) x = y; }\nstatic const int dx[] = {0, 0, 1, -1};\nstatic const int dy[] = {-1, 1, 0, 0};\n\n#define int long long\n\nsigned main() { \n  int n, v;\n  cin >> n >> v;\n  vi x(n);\n  vi dis(n + 1);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i];\n    if (i > 0) {\n      dis[i] = x[i] - x[i - 1];\n    }\n  }\n  dis[0] = INF;\n  dis[n] = INF;\n\n  //for (int i = 0; i < dis.size(); i++) {\n  //  d(dis[i] << \" \");\n  //}\n  //D(\"\");\n\n  vi vv;\n  while (v > 0) {\n    vv.pub(v);\n    v /= 2;\n  }\n  vv.pub(0);\n\n  //for (int i = 0; i < vv.size(); i++) {\n  //  d(vv[i] << ' ');\n  //}\n  //D(\"\");\n\n  vector<vector<bool>> wall(vv.size(), vector<bool> (n + 1, false));\n\n  for (int i = 0; i < vv.size(); i++) {\n    for (int j = 0; j < n + 1; j++) {\n      if (dis[j] > vv[i]) {\n        wall[i][j] = true;\n      }\n    }\n  }\n\n  //for (int i = 0; i < vv.size(); i++) {\n  //  for (int j = 0; j < n  + 1; j++) {\n  //    d(wall[i][j] << \" \");\n  //  }\n  //  D(\"\");\n  //}\n  \n  vs ans;\n\n  int i = 0;\n  while (i < n) {\n    int cnt = 0;\n\n    vector<bool> done(n);\n    for (int u = 0; u < n; u++) {\n      done[u] = false;\n    }\n\n    while (!wall[0][i + 1]) {\n      done[i] = true;\n      i++;\n      cnt++;\n    }\n    done[i] = true;\n    i++;\n    cnt++;\n\n    //D(i << \" --------------------\");\n    //for (int u = 0; u < n; u++) {\n    //  d(done[u] << ' ');\n    //}\n    //D(\"\");\n\n    for (int j = 1; j < vv.size(); j++) {\n      int maxd = -1;\n      int maxk = -1;\n      for (int k = 0; k < n; k++) {\n        if (!wall[j][k] && !done[k]) {\n          if (maxd < dis[k]) {\n            maxd = dis[k];\n            maxk = k;\n          }\n        }\n      }\n\n      //D(maxd << \" \" << maxk);\n\n      bool flag = false;\n      if (maxk == -1) {\n        for (int k = 0; k < n; k++) {\n          if (!done[k]) {\n            done[k] = true;\n            flag = true;\n            break;\n          }\n        }\n      }\n\n      //D(\"----done---\");\n      //for (int u = 0; u < n; u++) {\n      //  d(done[u] << \" \");\n      //}\n      //D(\"\");\n\n      if (flag) {\n        continue;\n      }\n\n      if (!flag && maxk == -1) {\n        break;\n      }\n\n      //D(\"FJLDKJ\");\n      //D(maxk);\n     \n           \n      int kpf = maxk;\n      while (!wall[j][kpf] && kpf < n) {\n        done[kpf] = true;\n        kpf++;\n      }\n      int kpb = maxk - 1;\n      while (!wall[j][kpb] && kpb >= 0) {\n        done[kpb] = true;\n        kpb--;\n      }\n      done[kpb] = true;\n    }\n    \n    bool end = true;\n    for (int p = 0; p < n; p++) {\n      if (!done[p]) {\n        end = false;\n      }\n    }\n    \n    for (int j = 0; j < cnt; j++) {\n      if (end) {\n        ans.pub(\"Possible\");\n      } else {\n        ans.pub(\"Impossible\");\n      }\n    }\n  }\n\n  for (int z = 0; z < ans.size(); z++) {\n    D(ans[z]);\n  }\n\n  //for (int i = 0; i < dis.size(); i++) {\n  //  d(setw(3) << dis[i] << \" \" );\n  //}\n  //D(\"\");     \n  //for (int i = 0; i < vv.size(); i++) {\n  //  for (int j = 0; j < n - 1; j++) {\n  //    d(setw(3) << wall[i][j] << \" \");\n  //  }\n  //  D(\"\");\n  //}\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N_ 201000\nusing namespace std;\nint n, V, w[N_], m;\nint C[20][N_], L[20], PP[30];\nint BE[20][N_], ED[20][N_];\nint D1[1048576], D2[1048576];\nint main(){\n    int i, j;\n    scanf(\"%d%d\",&n,&V);\n    for(i=1;i<=n;i++)scanf(\"%d\",&w[i]);\n    L[0] = V;\n    for(i=1;;i++){\n        L[i]=L[i-1]/2;\n        if(!L[i])break;\n    }\n    m = i+1;\n    for(i=0;i<m;i++){\n        int c = 0;\n        for(j=1;j<=n;j++){\n            if(j==1 || w[j]-w[j-1] > L[i])c++;\n            C[i][j] = c;\n        }\n        for(j=1;j<=c;j++)BE[i][j]=1e9,ED[i][j]=0;\n        for(j=1;j<=n;j++){\n            BE[i][C[i][j]] = min(BE[i][C[i][j]],j);\n            ED[i][C[i][j]] = max(ED[i][C[i][j]],j);\n        }\n    }\n    if(C[0][n] > m){\n        for(i=1;i<=n;i++)puts(\"Impossible\");\n        return 0;\n    }\n    for(i=0;i<(1<<m);i++)D2[i] = n+1;\n    for(i=0;i<(1<<m);i++){\n        for(j=0;j<m;j++){\n            if(i&(1<<j))continue;\n            if(D1[i]!=n)D1[i|(1<<j)] = max(D1[i|(1<<j)], ED[j][C[j][D1[i]+1]]);\n            else D1[i|(1<<j)] = n;\n            if(D2[i]!=1)D2[i|(1<<j)] = min(D2[i|(1<<j)], BE[j][C[j][D2[i]-1]]);\n            else D2[i] = 1;\n        }\n    }\n    for(i=1;i<=C[0][n];i++){\n        int b = BE[0][i], e = ED[0][i];\n        for(j=0;j<(1<<m);j++){\n            if(j&1)continue;\n            int t = (1<<m) - 2 - j;\n            if(D1[j] + 1 >= b && D2[t] - 1 <= e)PP[i] = 1;\n        }\n    }\n    for(i=1;i<=n;i++){\n        if(PP[C[0][i]])puts(\"Possible\");\n        else puts(\"Impossible\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nint n,v,m,a[200005],len[25],L[200005][25],R[200005][25],f[500005],g[500005];\npriority_queue<int> q;\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\twhile(v) len[m++]=v,v>>=1;len[m++]=0;\n\tfor(int i=0;i<m/2;i++) swap(len[i],len[m-i-1]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tL[i][p]=L[i-1][p];\n\t\t\tif(i==1||a[i]-a[i-1]>len[p]) L[i][p]=i;\n\t\t}\n\t}\n\tfor(int i=n;i;i--){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tR[i][p]=R[i+1][p];\n\t\t\tif(i==n||a[i+1]-a[i]>len[p]) R[i][p]=i;\n\t\t}\n\t}\n\tf[0]=0;g[0]=n+1;\n\tfor(int i=1;i<(1<<m);i++){\n\t\tg[i]=n+1;\n\t\tfor(int p=0;p<m;p++) if(i&(1<<p)){\n\t\t\tf[i]=max(f[i],R[f[i^(1<<p)]+1][p]);\n\t\t\tg[i]=min(g[i],L[g[i^(1<<p)]-1][p]);\n\t\t}\n\t}\n\tint S=(1<<m-1)-1;\n\tfor(int i=1,pos=0;i<=n;i++){\n\t\twhile(f[pos]>=L[i][m-1]-1&&pos<=S) q.push(S^pos),pos++;\n\t\twhile(!q.empty()&&f[S^q.top()]<L[i][m-1]-1) q.pop();\n\t\tif(q.empty()){\n\t\t\tputs(\"Impossible\");continue;\n\t\t}\n\t\tif(g[q.top()]>R[i][m-1]+1) puts(\"Impossible\");\n\t\telse puts(\"Possible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <set>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cassert>\n#define rep(i,m,n) for(i=m;i<=n;i++)\n#define mod 1000000007\n#define inf 0x3f3f3f3f\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define ll long long\n#define pi acos(-1.0)\n#define pii pair<int,int>\n#define sys system(\"pause\")\nconst int maxn=2e5+10;\nconst int N=2e5+10;\nusing namespace std;\nint id(int l,int r){return l+r|l!=r;}\nll gcd(ll p,ll q){return q==0?p:gcd(q,p%q);}\nll qpow(ll p,ll q){ll f=1;while(q){if(q&1)f=f*p%mod;p=p*p%mod;q>>=1;}return f;}\nint n,m,k,t,v,x[maxn],d[20],ret[maxn],l[20][maxn],r[20][maxn],dpl[1<<20],dpr[1<<20],tot;\nint main()\n{\n    int i,j;\n    scanf(\"%d%d\",&n,&v);\n    rep(i,1,n)scanf(\"%d\",&x[i]);\n    while(v)\n    {\n        d[tot++]=v;\n        v/=2;\n    }\n    d[tot++]=0;\n    rep(i,0,tot-1)\n    {\n        rep(j,1,n)\n        {\n            if(j>1&&x[j]-x[j-1]<=d[i])l[i][j]=l[i][j-1];\n            else l[i][j]=j;\n        }\n        for(j=n;j>=1;j--)\n        {\n            if(j<n&&x[j+1]-x[j]<=d[i])r[i][j]=r[i][j+1];\n            else r[i][j]=j;\n        }\n    }\n    memset(dpr,inf,sizeof(dpr));\n    dpl[0]=0,dpr[0]=n+1;\n    rep(i,0,(1<<tot)-1)\n    {\n        rep(j,0,tot-1)\n        {\n            if(~i&(1<<j))\n            {\n                if(dpl[i]+1<=n)dpl[i^(1<<j)]=max(dpl[i^(1<<j)],r[j][dpl[i]+1]);\n                if(dpr[i]-1>=1)dpr[i^(1<<j)]=min(dpr[i^(1<<j)],l[j][dpr[i]-1]);\n            }\n        }\n    }\n    rep(i,0,(1<<tot)-1)\n    {\n        if(i&1)continue;\n        if(dpl[i]>=dpr[(i^((1<<tot)-1))-1])\n        {\n            ret[1]++;\n            ret[n+1]--;\n        }\n        else\n        {\n            if(r[0][dpl[i]+1]>=dpr[(i^((1<<tot)-1))-1]-1)\n            {\n                int x=dpl[i]+1;\n                ret[l[0][x]]++;\n                ret[r[0][x]+1]--;\n            }\n        }\n    }\n    rep(i,1,n)\n    {\n        ret[i]+=ret[i-1];\n        puts(ret[i]?\"Possible\":\"Impossible\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define fr first\n#define se second\n#define pr pair<int,int>\n#define mp make_pair\n#define N 300000\nint n,m,i,j,mask,a[N],l[20][N],r[20][N],k,f[N<<1],g[N<<1],id;\npr b[N<<1];\nbool c[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&a[i]);int psz=0,jj=-1;\n\tfor (j=m;j!=jj;jj=j,j>>=1){\n\t\tint lst=1;\n\t\tfor (i=2;i<=n;i++) if (a[i]-a[i-1]>j){\n\t\t\tfor (k=lst;k<i;k++) l[psz][k]=lst,r[psz][k]=i-1;\n\t\t\tlst=i;\n\t\t}\n\t\tfor (k=lst;k<=n;k++) l[psz][k]=lst,r[psz][k]=n;\n\t\tpsz++;\n\t}\n\tfor (mask=0;mask<(1<<psz);mask++)\n\tfor (i=0;i<psz;i++) if (!(mask&(1<<i))) f[mask|(1<<i)]=max(f[mask|(1<<i)],r[i][f[mask]+1]);\n\tfor (mask=0;mask<(1<<psz);mask++) g[mask]=n+1;\n\tfor (mask=0;mask<(1<<psz);mask++)\n\tfor (i=0;i<psz;i++) if (!(mask&(1<<i))) g[mask|(1<<i)]=min(g[mask|(1<<i)],l[i][g[mask]-1]);\n\tfor (mask=0;mask<(1<<psz);mask++) if (!(mask&1)) b[++id]=mp(g[mask],mask);\n\tfor (i=1;i<=n;i++) b[++id]=mp(r[0][i]+1,i+(1<<psz));\n\tsort(b+1,b+id+1);int wtf=-1;\n\tfor (i=1;i<=id;i++) if (b[i].se>(1<<psz)){\n\t\tb[i].se-=(1<<psz);\n\t\tif (wtf>=l[0][b[i].se]-1) c[b[i].se]=true;\n\t}else wtf=max(wtf,f[b[i].se^((1<<psz)-2)]);\n\tfor (i=1;i<=n;i++) if (c[i]) puts(\"Possible\");else puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp make_pair\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint n,lv;\n\nint c[19][200005];\n\nvector<int> blk[200005];\n\nvoid dfs1(int mask, int cur, int target){\n  if(cur == target) blk[target-1].pb(mask);\n  else {\n    rep(i,1,lv) if((mask>>i)%2==0 && (cur==0 || c[i][cur-1]!=c[i][cur])){\n      dfs1(mask + (1<<i), c[i][cur]+1, target);\n    }\n  }\n}\n\nbool dfs(int mask, int cur, int target){\n  if(cur == target) return true;\n  for(auto nm : blk[c[0][cur]]) if((mask&nm)==0){\n    if(dfs(mask|nm, (c[0][cur]+1)%n, target)) return true;\n  }\n  return false;\n}\n\nint main(){\n  int v;\n  cin>>n>>v;\n  vector<int> a(n);\n  rep(i,n) cin>>a[i];\n\n  lv = 33 - __builtin_clz(v);\n\n  for(int i=0, tv=v; i<lv; i++, tv/=2){\n    int p = n-1;\n    c[i][n-1] = n-1;\n    for(int j = n-2; j>=0; j--){\n      if(a[j+1] - a[j] > tv) p = j;\n      c[i][j] = p;\n    }\n  }\n\n  set<int> x;\n  rep(i,n) x.insert(c[0][i]);\n  if(x.size() > lv){\n    rep(i,n) cout << \"Impossible\\n\";\n    return 0;\n  }\n\n  rep(i,n){\n    dfs1(0, i, c[0][i]+1);\n    i = c[0][i];\n  }\n\n  rep(i,n){\n    bool res = dfs(1, (c[0][i]+1)%n, i);\n    rep(j,i,c[0][i]+1) cout << (res ? \"Possible\" : \"Impossible\") << \"\\n\";\n    i = c[0][i];\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define N 1048576\n#define ll long long\nusing namespace std;\nint n,m,cnt,a[N],b[109],l[20][N],r[20][N],f[N],g[N];\nstruct node{ int x,y; node(){} node(int a,int b){ x=a,y=b; } }c[N];\nconst bool cmp(const node &x,const node &y){ return x.y<y.y; }\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (; m; m>>=1) b[++cnt]=m; b[++cnt]=0;\n\trep (i,1,cnt>>1) swap(b[i],b[cnt-i+1]);\n\tm=1<<cnt-1;\n\trep (i,1,n) scanf(\"%d\",&a[i]);\n\trep (i,1,cnt){//预处理l[i][j]和r[i][j]表示第i层第j个点所在线段的左右端点\n\t\tl[i][1]=1; r[i][n]=n;\n\t\trep (j,2,n) l[i][j]=a[j]-a[j-1]<=b[i]?l[i][j-1]:j;\n\t\tper (j,n-1,1) r[i][j]=a[j+1]-a[j]<=b[i]?r[i][j+1]:j;\n\t}\n\trep (i,0,m-1) g[i]=n+1,f[i]=0;//f[i]表示状态为i，从1开始延伸出去的最远长度；g[i]表示从n开始延伸的最远长度\n\t//状态s的意思是，如果某位为1则表示当前层选了线段\n\trep (i,1,m-1) rep (j,1,cnt-1) if ((i>>j-1)&1){\n\t\tint k=i^1<<j-1;//f[k]->f[i]\n\t\tf[i]=max(f[i],f[k]<n?r[j][f[k]+1]:n);\n\t\tg[i]=min(g[i],g[k]>1?l[j][g[k]-1]:1);\n\t}\n\trep (i,0,m-1)\n\t\tif (f[i]+1<g[m-1^i]) c[i+1]=node(f[i]+1,g[m-1^i]-1);\n\t\telse{\n\t\t\trep(j,1,n) puts(\"Possible\"); return 0;\n\t\t}\n\tsort(c+1,c+1+m,cmp);\n\tfor (int i=1,j=1,k=0; i<=n; i++){\n\t\twhile (j<=m && c[j].y<=r[cnt][i]){\n\t\t\tj++; k=max(k,c[j].x);\n\t\t}\n\t\tif (k>=l[cnt][i]) puts(\"Possible\"); else puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define dis(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2e5+233;\nint L[20][maxn],R[20][maxn];\nint f[maxn],g[maxn];\nint ans[maxn]; \nint n,V,tmp,x[maxn],v[21];\nint main(){\n\tn = rd(),V = tmp = rd();\n\tRep(i,1,n) x[i] = rd();\n\ttmp /= 2;\n\twhile(tmp){\n\t\tv[++v[0]] = tmp;\n\t\ttmp /= 2;\n\t}\n\tv[++v[0]] = 0;\n\tRep(d,1,v[0]){\n\t\tfor(int i=1,j=-1;i<=n;i=j+1){\n\t\t\tfor(j=i+1;j<=n && x[j]-x[j-1]<=v[d];j++);j--;\n//\t\t\tprintf(\"[%d %d]\\n\",i,j);\n\t\t\tRep(k,i,j){\n\t\t\t\tL[d][k] = i;\n\t\t\t\tR[d][k] = j;\n\t\t\t}\n\t\t}R[d][n+1] = n;L[d][0] = 1;\n\t}\n\t\n\tfor(int i=1,j=-1;i<=n;i=j+1){\n\t\tfor(j=i+1;j<=n && x[j]-x[j-1]<=V;j++);j--;\n//\t\tprintf(\"[%d %d][%d %d]\\n\",i,j,x[j]-x[i],x[j+1]-x[i]);\n\t\tRep(k,i,j){\n\t\t\tL[0][k] = i;\n\t\t\tR[0][k] = j;\n//\t\t\tprintf(\"L[%d][%d] = %d\\n\",V,k,L[0][k]);\n\t\t}\n\t}R[0][n+1] = n;L[0][0] = 1;\n\trep(i,0,1<<v[0]) f[i] = 0;\n\trep(i,0,1<<v[0]){\n\t\tfor(int j=1;j<=v[0];++j){\n\t\t\tif(i>>(j-1)&1^1){\n\t\t\t\tf[i|(1<<(j-1))] = max(f[i|(1<<(j-1))],R[j][f[i]+1]);\n\t\t\t}//如果不包括，那么可以选择 \n\t\t}\n\t}\n\trep(i,0,1<<v[0]) g[i] = n+1;\n\trep(i,0,1<<v[0]){\n\t\tfor(int j=1;j<=v[0];++j){\n\t\t\tif(i>>(j-1)&1^1){\n\t\t\t\tg[i|(1<<(j-1))] = min(g[i|(1<<(j-1))],L[j][g[i]-1]);\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,0,1<<v[0]){\n//\t\tprintf(\"[%d%d%d%d%d] : %d,%d\\n\",i/16%2,i/8%2,i/4%2,i/2%2,i%2,f[i],g[i]);\n//\t}\n\trep(i,0,1<<v[0]){\n\t\tint j=((1<<v[0])-1)^i;\n//\t\tprintf(\"[%d %d]\\n\",i,j);\n\t\tint pos = f[i]+1;\n\t//\tprintf(\"[%d %d]\\n\",f[i],g[j]);\n//\t\tif(f[i]+1 >= g[j]){\n//\t\t\tprintf(\"[%d %d]\\n\",f[i],g[j]);\n//\t\t} else\n\t\tassert(f[i]+1 <= g[j]);\n\t\tif(L[0][pos] <= f[i]+1 && g[j]-1 <= R[0][pos]){\n\t\t\tans[L[0][pos]]++;\n\t\t\tans[R[0][pos]+1]--;\n\t\t}//区间可行 \n\t}\n\tRep(i,1,n) ans[i] += ans[i-1];\n\tRep(i,1,n){\n//\t\tprintf(\"{%d %d}\\n\",L[0][i],R[0][i]);\n\t\tif(ans[i]) puts(\"Possible\");\n\t\t\t  else puts(\"Impossible\");\n\t}\n\treturn 0;\n}\n/*\n5 3\n-4 0 1 2 6\n\n11 12\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define P(x) cout << x << endl\n#define D(x) P(#x << \": \" << x)\n#define F(i,n) for (int i=0; i<(int)(n); i++)\n#define DEC(i,n) for (int i=(int)(n); --i>=0;)\n#define pb push_back\n#define all(v) v.begin(), v.end()\nusing namespace std;\nvoid MI(int &a, int v) {a = min(a,v);}\nvoid MA(int &a, int v) {a = max(a,v);}\nconst int N=2e5, L=18, PL=1<<L;\n\nint l,n,v,pl;\ndeque<int> len;\n\nvoid gen(int x[], int nxt[][N], int reach[]) {\n    F(k,l) {\n        int cur=0;\n        F(i,n+1) {\n            if (i == n || (i-1 >= 0 && abs(x[i] - x[i-1]) > len[k])) {\n                while (cur < i) {\n                    nxt[k][cur] = i;\n                    cur++;\n                }\n            }\n        }\n    }\n    F(mask,pl) {\n        reach[mask] = 0;\n        F(k,l) if (mask & 1<<k)\n            MA(reach[mask], nxt[k][reach[mask-(1<<k)]]);\n    }\n}\n\nvoid print(int nxt[][N]) {\n    F(k,l) {\n        cout<<len[k]<<\": \";\n        F(i,n) cout<<nxt[k][i]<<\" \\n\"[i==n-1];\n    }\n}\n\nint x[N], rev[N];\nint nxt[L][N], pre[L][N], rLeft[PL], rRight[PL];\nbool ok[N];\n\nsigned main() {\n    cin>>n>>v;\n    F(i,n) cin>>x[i], rev[n-1-i] = x[i], ok[i] = false;\n    len = {v};\n    int cur = v;\n    while (cur) cur/=2, len.push_front(cur);\n    l = len.size();\n    pl = 1<<l;\n    gen(x, nxt, rLeft);\n    gen(rev, pre, rRight);\n    //P(\"nxt:\"); print(nxt);\n    //P(\"pre:\"); print(pre);\n    //F(k,pl) cout<<bitset<3>(k)<<\":\"<<rLeft[k]<<\" \\n\"[k==pl-1];\n    int start = pl/2;\n    int cnt[n+1];\n    bool all_ok=false;\n    F(i,n+1) cnt[i] = 0;\n    F(mleft,start) {\n        int le = rLeft[mleft], ri = n - rRight[start-1-mleft];\n        //D(le), D(ri);\n        if (le >= ri) {\n            all_ok = true;\n            //P(\"ALL OK\");\n        }\n        else {\n            int ll = (le == n ? n : n-pre[l-1][n-1-le]), rr = (ri == 0 ? 0 : nxt[l-1][ri-1]);\n            //printf(\"[%lld,%lld)\\n\", ll, rr);\n            if (nxt[l-1][ll] == rr) {\n                //P(ll<<\" to \"<<rr);\n                cnt[ll]++;\n                cnt[rr]--;\n            }\n        }\n        //P(\"\");\n    }\n    //F(i,n) cout<<cnt[i]<<\" \\n\"[i==n-1];\n    cur = 0;\n    F(i,n) {\n        cur += cnt[i];\n        P((all_ok || cur > 0 ? \"Possible\" : \"Impossible\"));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=1e6+5;\nint n,m;\nint V,x[maxn],R[maxn][25],L[maxn][25];\nint S1[maxn],S2[maxn];\nint minL[maxn];\nint main(){\n\tread(n);read(V);\n\tif(n>2e5)assert(0);\n\trep(i,1,n)read(x[i]);\n\twhile((1<<m)<=V)m++;m++;\n\trep2(i,0,m){\n\t\tR[n+1][i]=n;\n\t\tper(j,n,1)\n\t\t\tif(x[j+1]-x[j]<=(V>>i))R[j][i]=R[j+1][i];\n\t\t\telse R[j][i]=j;\n\t\tL[0][i]=1;\n\t\trep(j,1,n)\n\t\t\tif(x[j]-x[j-1]<=(V>>i))L[j][i]=L[j-1][i];\n\t\t\telse L[j][i]=j;\n\t}\n\trep2(i,0,1<<m)S2[i]=n+1;\n\trep2(i,0,1<<m)rep2(j,0,m)if(!(i&(1<<j))){\n\t\tS1[i|(1<<j)]=max(S1[i|(1<<j)],R[S1[i]+1][j]);\n\t\tS2[i|(1<<j)]=min(S2[i|(1<<j)],L[S2[i]-1][j]);\n\t}\n\trep(i,0,n)minL[i]=n+2;\n\trep2(i,0,1<<m)if(!(i&1))minL[S1[i]]=min(minL[S1[i]],S2[((1<<m)-1)^i^1]);\n\tper(i,n-1,0)minL[i]=min(minL[i],minL[i+1]);\n\trep(i,1,n){\n\t\tif(minL[L[i][0]-1]<=R[i][0]+1)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define stt static\n#define rg register\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n#define y1 substitute_of_y1\n#define DEBUG(x) cerr<<#x\" = \"<<x<<endl;\nusing namespace std;\n\ntemplate<typename T> il T rd(){\n\tT nmb=0;int sgn=0;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-')sgn=1;chr=getchar();}\n\twhile(isdigit(chr)){nmb=(nmb<<3)+(nmb<<1)+chr-'0';chr=getchar();}\n\treturn sgn?-nmb:nmb;\n}\ntemplate<typename T> void wt(T nmb){\n\tif(nmb>9)wt(nmb/10);\n\tputchar(nmb%10+'0');\n}\ntemplate<typename T> il void cmax(T &x,T y){x=x>y?x:y;}\ntemplate<typename T> il void cmin(T &x,T y){x=x<y?x:y;}\ninline void proc_status(){\n\tifstream t (\"/proc/self/status\");\n\tcerr<<string(istreambuf_iterator<char>(t),istreambuf_iterator<char>())<<endl;\n\t/*freopen(\"/proc/self/status\",\"r\",stdin);\n\tchar ch[100];\n\twhile(scanf(\"%s\",ch)!=EOF)cerr<<ch<<endl;*/\n}\n\nconst int N=2e5+10,L=20;\n\nint a[N];\n\nvector<pii>vec[L];\n\n#define lowbit(x) (x&(-x))\n\nint f[N<<1],g[N<<1];\n\nint ans[N],b[N];\n\nint main(){\n\tint n=rd<int>(),p=rd<int>();\n\tfor(int i=1;i<=n;++i)a[i]=rd<int>();\n\tint lev=1;\n\tint Flg=0;\n\tfor(int k=p;!Flg;k>>=1,++lev){\n\t\tif(!k)Flg=1;\n\t\tfor(int l=1,r=1;l<=n;l=r+1){\n\t\t\tr=l;\n\t\t\twhile(r<n&&a[r+1]-a[r]<=k)++r;\n\t\t\tvec[lev].pb(mp(l,r));\n\t\t}\n\t}\n\tlev-=2;\n\tint k=(1<<lev)-1;\n\tfor(int S=0;S<=k;++S)f[S]=0,g[S]=n+1;\n\tfor(int S=0;S<=k;++S){\n\t\tfor(int T=S;T;T^=lowbit(T)){\n\t\t\tint t=(int)log2(lowbit(T))+2;\n\t\t\tint U=S^lowbit(T);\n\t\t\tint pos=upper_bound(vec[t].begin(),vec[t].end(),mp(f[U]+1,n+1))-vec[t].begin()-1;\n\t\t\tif(pos>=0)cmax(f[S],vec[t][pos].snd);\n\t\t\tpos=upper_bound(vec[t].begin(),vec[t].end(),mp(g[U]-1,n+1))-vec[t].begin()-1;\n\t\t\tif(pos>=0&&vec[t][pos].snd>=g[U]-1)cmin(g[S],vec[t][pos].fst);\n\t\t}\n\t}\n\tfor(int S=0;S<=k;++S){\n\t\tint l=f[S],r=g[k^S];\n\t\tint pos1=upper_bound(vec[1].begin(),vec[1].end(),mp(l+1,n+1))-vec[1].begin()-1;\n\t\tint pos2=upper_bound(vec[1].begin(),vec[1].end(),mp(r-1,n+1))-vec[1].begin()-1;\n\t\tif(vec[1][pos2].snd<r-1)++pos2;\n\t\tif(pos1>=0&&pos2>=0&&pos1>pos2){\n\t\t\tfor(int i=1;i<=n;++i)puts(\"Possible\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(pos1>=0&&pos2>=0&&pos1==pos2)b[pos1]=1;\n\t}\n\tfor(int i=0;i<(int)vec[1].size();++i)\n\t\tfor(int t=vec[1][i].fst;t<=vec[1][i].snd;++t)\n\t\t\tans[t]=b[i];\n\tfor(int i=1;i<=n;++i)\n\t\tif(ans[i])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\n#include <cstdlib>\n\nusing std::pair;\ntypedef pair<int,int> pii;\nconst int N = 200010;\nconst int M = 18;\nint _w;\n\nint max( int a, int b ) {\n\treturn a > b ? a : b;\n}\n\nint n, v, x[N], m;\n\nint ans[N];\nvoid answer() {\n\tfor( int i = 1; i <= n; ++i )\n\t\tputs( ans[i] ? \"Possible\" : \"Impossible\" );\n\texit(0);\n}\n\nint R[M][N];\nvoid prelude() {\n\tint t = v;\n\tfor( m = 0; ; ++m, t >>= 1 ) {\n\t\tR[m][n] = R[m][n+1] = n;\n\t\tfor( int j = n-1; j >= 1; --j )\n\t\t\tif( x[j+1] - x[j] > t )\n\t\t\t\tR[m][j] = j;\n\t\t\telse R[m][j] = R[m][j+1];\n\t\tif( !t ) break;\n\t}\n\t++m;\n}\n\nint f[1<<M];\nbool check( int l, int r ) {\n\tif( l == 1 && r == n ) return true;\n\tmemset(f, 0, sizeof f);\n\tfor( int i = 0; i < (1<<m); ++i )\n\t\tfor( int j = 1; j < m; ++j )\n\t\t\tif( (i&(1<<j)) == 0 ) {\n\t\t\t\tint k = i|(1<<j);\n\t\t\t\tf[k] = max( f[k], R[j][f[i]+1] );\n\t\t\t\tif( f[k] >= l-1 && f[k] <= r )\n\t\t\t\t\tf[k] = r;\n\t\t\t}\n\treturn f[(1<<m)-2] == n;\n}\n\nvoid solve() {\n\tstatic pii tmp[N];\n\tstatic int tn;\n\tfor( int i = 1; i <= n; i = R[0][i]+1 )\n\t\ttmp[tn++] = pii(i, R[0][i]);\n\tif( tn > m ) answer();\n\tfor( int i = 0; i < tn; ++i )\n\t\tif( check(tmp[i].first, tmp[i].second) ) {\n\t\t\tfor( int j = tmp[i].first; j <= tmp[i].second; ++j )\n\t\t\t\tans[j] = 1;\n\t\t}\n\tanswer();\n}\n\nint main() {\n\t_w = scanf( \"%d%d\", &n, &v );\n\tfor( int i = 1; i <= n; ++i )\n\t\t_w = scanf( \"%d\", x+i );\n\tprelude(), solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctype.h>\n#include <algorithm>\n#define mp make_pair\n#define l first\n#define r second\n#define BIT(x) (__builtin_popcount(x))\n#define Debug(...) fprintf(stdout, __VA_ARGS__)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<int, LL> pil;\n\nconst int MAXN = 3e5 + 7;\nconst int LogV = 19;\n\ntemplate<typename T> inline T read() {\n\tT res = 0, flag = 1; char in = getchar();\n\twhile(!isdigit(in)) { if(in == '-') flag = -1; in = getchar(); }\n\twhile(isdigit(in)) { res = (res << 1) + (res << 3) + in - '0'; in = getchar(); }\n\treturn res * flag;\n}\n\ntemplate<typename T> inline void chkmax(T &a, T b) { if(a < b) a = b; }\ntemplate<typename T> inline void chkmin(T &a, T b) { if(a > b) a = b; }\n\nint n, v, cnt;\nint p[MAXN];\nint suf[MAXN], pre[MAXN];\nint nst[MAXN];\nchar str[2][100] = {\"Possible\", \"Impossible\"};\n\nstruct Floor {\n\tpii seg[MAXN];\n\tint tot;\n\n\tinline void GetSeg(int len) {\n\t\tint lst = 1, pos = 1;\n\t\twhile(lst <= n) {\n\t\t\twhile(pos + 1 <= n && (p[pos + 1] - p[pos]) <= len) ++pos;\n\t\t\tseg[++tot] = mp(lst, pos);\n\t\t\t++pos; lst = pos;\n\t\t}\n\t}\n}fl[LogV];\n\ninline void GetTrans() {\n\tint All = 1 << cnt;\n\n\tfor(int i = 1; i <= cnt; ++i) {\n\t\tpre[1 << (i - 1)] = fl[i].seg[1].r;\n//\t\tprintf(\"FF %d\\n\", fl[i].tot);\n\t}\n\tfor(int sta = 1; sta < All; ++sta) {\n\t\tfor(int i = 1; i <= cnt; ++i) {\n\t\t\tif((sta >> (i - 1)) & 1) continue;\n\t\t\tint l = 1, r = fl[i].tot;\n\t\t\tint nxt = sta | (1 << (i - 1));\n\t\t\twhile(l <= r) {\n\t\t\t\tint mid = l + r >> 1;\n\t\t\t\tif(fl[i].seg[mid].l <= pre[sta] + 1) {\n\t\t\t\t\tchkmax(pre[nxt], fl[i].seg[mid].r), l = mid + 1;\n\t\t\t\t}\n\t\t\t\telse r = mid - 1;\n\t\t\t}\n//\t\t\tprintf(\"%d\\n\", pre[sta]);\n//\t\t\texit(0);\n\t\t}\n\t}\n\n\tmemset(suf, 0x3f, sizeof suf);\n\tfor(int i = 1; i <= cnt; ++i)\n\t\tsuf[1 << (i - 1)] = fl[i].seg[fl[i].tot].l;\n\n\tfor(int sta = 1; sta < All; ++sta) {\n\t\tfor(int i = 1; i <= cnt; ++i) {\n\t\t\tif((sta >> (i - 1)) & 1) continue;\n\t\t\tint l = 1, r = fl[i].tot;\n\t\t\tint nxt = sta | (1 << (i - 1));\n\t\t\twhile(l <= r) {\n\t\t\t\tint mid = l + r >> 1;\n\t\t\t\tif(suf[sta] - 1 <= fl[i].seg[mid].r) {\n\t\t\t\t\tchkmin(suf[nxt], fl[i].seg[mid].l), r = mid - 1;\n\t\t\t\t}\n\t\t\t\telse l = mid + 1;\n\t\t\t}\n\t\t}\n\t}\n\n//\tfor(int i = 1; i < All; ++i) {\n//\t\tprintf(\"GG\");\n//\t\tfor(int j = 1; j <= cnt; ++j) {\n//\t\t\tprintf(\"%d\", (i >> (j - 1)) & 1);\n//\t\t}\n//\t\tprintf(\" | %d\\n\", pre[i]);\n//\t}\n}\n\ninline void init() {\n\tn = read<int>(); v = read<int>();\n\tfor(int i = 1; i <= n; ++i) p[i] = read<int>();\n\n\tint len = v;\n\twhile(len) {\n\t\tfl[cnt++].GetSeg(len);\n\t\tlen /= 2;\n\t}\n\tfl[cnt++].GetSeg(len);\n\t--cnt;\n\tGetTrans();\n}\n\ninline void solve() {\n\tmemset(nst, 0x3f, sizeof nst);\n\tint All = (1 << cnt) - 1;\n\tpre[0] = 0; suf[0] = n + 1;\n\n\tfor(int i = 0; i <= All; ++i) {\n\t\tchkmin(nst[pre[i]], suf[All ^ i]);\n\t}\n\n\tfor(int i = MAXN - 1; i > 1; --i)\n\t\tchkmin(nst[i - 1], nst[i]);\n\n//\tfor(int i = 0; i <= All; ++i) {\n//\t\tprintf(\"%d %d\\n\", pre[i], suf[All ^ i]);\n//\t}\n\n\tint tp = fl[0].tot;\n\tfor(int i = 1; i <= tp; ++i) {\n\t\tint opt = 0;\n\t\tif(fl[0].seg[i].r + 1 < nst[fl[0].seg[i].l - 1]) opt = 1;\n\t\tfor(int j = fl[0].seg[i].l; j <= fl[0].seg[i].r; ++j) {\n\t\t\tprintf(\"%s\\n\", str[opt]);\n\t\t}\n\t}\n}\n\nint main() {\n\n\tinit();\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=4E5+5;\n\nint N,M,K,V;\nint a[Maxn];\nint F[Maxn],G[Maxn];\nint L[25][Maxn],R[25][Maxn];\nchar Ans[50],_1[50]={\"Possible\"},_2[50]={\"Impossible\"};\n//int nxt[Maxn];\n\ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n\nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1)\n\t\t\t\tMAX(F[i],R[M-j][min(F[i-(1<<j)]+1,N)]),\n\t\t\t\tMIN(G[i],L[M-j][max(G[i-(1<<j)]-1,1)]);\n\t}\n\tfor(int i=1;i<=N;++i)\n\t\tK+=(L[0][i]!=L[0][i-1]);\n\tif(K>20){\n\t\tfor(int i=1;i<=N;++i)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=1,j;i<=N;++i)\n\t\tif(L[0][i]!=L[0][i-1]){\n\t\t\tfor(j=0;j<(1<<M);++j)\n\t\t\t\tif(F[j]>=L[0][i]-1 && G[(1<<M)-1-j]<=R[0][i]+1)\n\t\t\t\t\t{memcpy(Ans,_1,sizeof(_1)); break ;}\n\t\t\tif(j==1<<M) memcpy(Ans,_2,sizeof(_2));\n\t\t\tprintf(\"%s\\n\",Ans);\n\t\t}else printf(\"%s\\n\",Ans);\n/*\tmemset(nxt,-1,sizeof(nxt));\n\tfor(int i=0;i<(1<<M);++i) MAX(nxt[G[(1<<M)-1-i]],F[i]);\n\tfor(int i=1;i<=N+1;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[R[0][i]+1]>=L[0][i]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define MN 266666\n\nint n, v;\nint a[MN];\nint f[MN], g[MN];\nint b[MN];\nint nxt[20][MN];\nint lst[20][MN];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &v);\n\tfor(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tint x = v;\n\tint m = 0;\n\twhile(x) {b[m++] = x / 2; x /= 2;}\n\tb[m] = v;\n\t\n\tfor(int i = 0; i <= m; i++)\n\t{\n\t\tlst[i][1] = 1;\n\t\tfor(int j = 2; j <= n; j++)\n\t\t{\n\t\t\tif(a[j] - a[j - 1] <= b[i]) lst[i][j] = lst[i][j - 1];\n\t\t\telse lst[i][j] = j;\n\t\t}\n\t}\n\t\n\tint tot = 0;\n\tfor(int i = 0; i <= m; i++)\n\t{\n\t\tnxt[i][n] = n;\n\t\tfor(int j = n - 1; j >= 1; j--)\n\t\t{\n\t\t\tif(a[j + 1] - a[j] <= b[i]) nxt[i][j] = nxt[i][j + 1];\n\t\t\telse {nxt[i][j] = j; if(i == m) tot++;}\n\t\t}\n\t}\n\t\n\tif(m < tot) \n\t{\n\t\tfor(int i = 1; i <= n; i++) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tfor(int S = 0; S < (1 << m); S++) g[S] = n + 1; \n\tfor(int S = 0; S < (1 << m); S++)\n\t{\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tif(!((S >> i) & 1))\n\t\t\t{\n\t\t\t\tf[S | (1 << i)] = std::max(f[S | (1 << i)], nxt[i][f[S] + 1]);\n\t\t\t\tg[S | (1 << i)] = std::min(g[S | (1 << i)], lst[i][g[S] - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tbool ok = 0;\n\t\tfor(int S = 0; S < (1 << m); S++)\n\t\t{\n\t\t\tint T = ((1 << m) - 1) ^ S;\n\t\t\tif(f[S] >= i - 1 && g[T] <= nxt[m][i] + 1) {ok = 1; break;}\n\t\t}\n\t\tfor(int j = i; j <= nxt[m][i]; j++)\n\t\t{\n\t\t\tif(ok) puts(\"Possible\");\n\t\t\telse puts(\"Impossible\");\n\t\t}\n\t\ti = nxt[m][i];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\nint const N=2e5+10;\nint const S=1<<19;\nint n,V;\nlint d[N];\nint logV,a[25][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n\t}\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&d[i]),d[i-1]=d[i]-d[i-1];\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++) puts(\"Impossible\\n\");\n        return 0;\n    }\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=0,f2[s]=n+1;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1&&f2[U-s-1]-1<=to) f=true;\n        if(f) for(int j=fr;j<=to;j++) puts(\"Possible\\n\");\n        else for(int j=fr;j<=to;j++) puts(\"Impossible\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nint goR[200005][20];\nint goL[200005][20];\nint a[200005];\nint R(int x,int k,int v){\n    if(goR[x][k]!=-1)return goR[x][k];\n    if(a[x+1]-a[x]>(v>>k))return goR[x][k]=x;\n    return goR[x][k]=R(x+1,k,v);\n}\nint L(int x,int k,int v){\n    if(goL[x][k]!=-1)return goL[x][k];\n    if(a[x]-a[x-1]>(v>>k))return goL[x][k]=x;\n    return goL[x][k]=L(x-1,k,v);\n}\nint dpR[1<<20];\nint dpL[1<<20];\nint n,v;\nint DPR(int x){\n    if(x==0)return 0;\n    if(dpR[x]!=-1)return dpR[x];\n    dpR[x]=0;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpR[x]=max(dpR[x],R(DPR(x-(1<<i))+1,i,v));\n        }\n    }\n    return dpR[x];\n}\nint DPL(int x){\n    if(x==0)return n+1;\n    if(dpL[x]!=-1)return dpL[x];\n    dpL[x]=1e9+1;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpL[x]=min(dpL[x],L(DPL(x-(1<<i))-1,i,v));\n        }\n    }\n    return dpL[x];\n}\nint main(){ \n    MEMS(goR);MEMS(goL);MEMS(dpR);MEMS(dpL);\n    scanf(\"%d %d\",&n,&v);\n    for(int i = 1;i<=n;i++)\n        //a[i]=-1e9+2e5*i;\n        scanf(\"%d\",&a[i]);\n    a[0]=-1e9-1e8;\n    a[n+1]=1e9+1e8;\n    int Max=1;\n    for(int i = 1;;i++){\n        Max=i+1;\n        if(!(v>>i))break;\n    }\n    if(DPL((1<<Max)-1)!=n){\n        for(int i = 1;i<=n;i++){\n            printf(\"Impossible\\n\");\n        }\n        return 0;\n    }\n    for(int i = 1;i<=n;){\n        int l=i,r=R(i,0,v);\n       // printf(\"%d %d\\n\",l,r);\n        int ok=0;\n        for(int j=0;j<(1<<Max);j++){\n            int a=j,b=(1<<Max)-j;\n            if(a&1)a--;\n            if(b&1)b--;\n            if(DPR(a)>=l-1&&DPL(b)<=r+1){\n                ok=1;\n                break;\n            }\n        }\n        if(ok){\n            for(int i=l;i<=r;i++)printf(\"Possible\\n\");\n        }\n        else{\n            for(int i = l;i<=r;i++)printf(\"Impossible\\n\");\n        }\n        i=r+1;\n    }\n}\n/*\n2 2 1\n3 2 3\n4 2 4 4 7\n\n*/"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=2E5+5;\n\nint N,M,V;\nint a[Maxn];\nint F[Maxn],G[Maxn];\nint L[20][Maxn],R[20][Maxn];\nint nxt[Maxn];\n\ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"ernd.in\",\"r\",stdin),\n\tfreopen(\"ernd.out\",\"w\",stdout);\n\t#endif\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tsort(a+1,a+N+1);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N; R[i][N+1]=N+1;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1) MAX(F[i],R[M-j][F[i-(1<<j)]+1]);\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1) MIN(G[i],L[M-j][G[i-(1<<j)]-1]);\n\t}\n\tfor(int i=0;i<(1<<M);++i)\n\t\tMAX(nxt[L[0][G[((1<<M)-1)^i]-1]],R[0][F[i]+1]);\n\tfor(int i=1;i<=N;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[i]>=i)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\n\nint kano()\n{\n\tchar ch=getchar();int w=0,u=1;\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')u=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())w=w*10+ch-'0';\n\treturn w*u;\n}\nint n,v,o,u,mx;\nint a[200005];\nint p[21][200005],r[21][200005];\nint f[2][262145];\nbool bo[200005];\nint main()\n{\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tn=kano();v=kano();\n\tfor(int i=1;i<=n;i++)a[i]=kano();\n\tfor(o=v,u=0;o>0;o=o>>1,u++)\n\t{\n\t\tint la=1;p[u][1]=1;r[u][1]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]-a[i-1]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\t\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tmx=1<<u;mx--; \n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tif(f[0][i]>n)f[0][i]=n;\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tif(f[0][i]!=n)f[0][i|j]=max(f[0][i|j],p[l][r[l][f[0][i]+1]]);\n\t\t\telse f[0][i|j]=n;\n\t\t}\n\t}\n\tfor(o=v>>1,u=1;o>0;o=o>>1,u++)\n\t{\n\t\tint la=n;p[u][n]=n;r[u][n]=n;\n\t\tfor(int i=n-1;i>=1;i--)\n\t\t{\n\t\t\tif(a[i+1]-a[i]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tfor(int i=0;i<=mx;i++)f[1][i]=n+1;\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tif(f[1][i]<1)f[1][i]=1;\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tif(f[1][i]!=1)f[1][i|j]=min(f[1][i|j],p[l][r[l][f[1][i]-1]]);\n\t\t\telse f[1][i|j]=1;\n\t\t}\n\t}\n\tr[0][0]=r[0][1];\n\tr[0][n+1]=r[0][n];\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tint j=~i&mx;\n\t\tif(r[0][f[0][i]+1]==r[0][f[1][j]-1])bo[r[0][f[0][i]+1]]=1;\n\t\telse if(r[0][f[0][i]+1]>r[0][f[1][j]-1])\n\t\t{\n\t\t\tbo[0]=1;\n\t\t\tbreak;\n\t\t} \n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(bo[0]||bo[r[0][i]])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fst first\n#define Snd second\n#define RG register\n#define mp make_pair\n#define mem(a,b) memset(a,b,sizeof(a))\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned int UI;\ntypedef unsigned long long ULL;\ntemplate<typename T> inline void read(T& x) {\n\tchar c = getchar();\n\tbool f = false;\n\tfor (x = 0; !isdigit(c); c = getchar()) {\n\t\tif (c == '-') {\n\t\t\tf = true;\n\t\t}\n\t}\n\tfor (; isdigit(c); c = getchar()) {\n\t\tx = x * 10 + c - '0';\n\t}\n\tif (f) {\n\t\tx = -x;\n\t}\n}\ntemplate<typename T, typename... U> inline void read(T& x, U& ... y) {\n\tread(x), read(y...);\n}\nconst int N=2e5+10;\nint n,V;\nint A[N],L[20][N],R[20][N],Fl[1<<20],Fr[1<<20],G[N];\nvoid Calc(int m,int d) {\n  R[m][n]=n;\n  for(int i=n-1;i;--i) {\n    if(A[i+1]-A[i]<=d) R[m][i]=R[m][i+1];\n    else R[m][i]=i;\n  }\n  L[m][1]=1;\n  for(int i=2;i<=n;++i) {\n    if(A[i]-A[i-1]<=d) L[m][i]=L[m][i-1];\n    else L[m][i]=i;\n  }\n}\n//#define rua\nint main() {\n//\tios::sync_with_stdio(false);\n#ifdef rua\n\tfreopen(\"GG.in\",\"r\",stdin);\n#endif\n  read(n,V);\n  for(int i=1;i<=n;++i) read(A[i]);\n  int mlog=0;\n  while(V) Calc(mlog++,V),V>>=1;\n  Calc(mlog,V);\n  Fr[0]=n+1;\n  for(int i=1;i<1<<mlog;++i) {\n    Fr[i]=n;\n    for(int j=0;j<mlog;++j) {\n      if(i>>j&1) {\n        Fl[i]=max(Fl[i],R[j+1][Fl[i^(1<<j)]+1]);\n        Fr[i]=min(Fr[i],L[j+1][Fr[i^(1<<j)]-1]);\n      }\n    }\n  }\n  for(int i=0;i<1<<mlog;++i) {\n    int l=Fl[i],r=Fr[((1<<mlog)-1)^i];\n    int a=L[0][r-1],b=R[0][l+1];\n    if(a<=b) ++G[a],--G[b+1];\n  }\n  for(int i=1;i<=n;++i) {\n    G[i]+=G[i-1];\n    puts(G[i]?\"Possible\":\"Impossible\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 200005\n#define MAXM 18\n#define MAXK (1<<MAXM)\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\n#define prev daksiisaas\n#define next aijdkjsaod\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\nint N,V,x[MAXN];\nvector<int> v;\nint prev[MAXN][MAXM],next[MAXN][MAXM];\nint predp[MAXK],sufdp[MAXK];\nint mini[MAXN];\nint main()\n{\n    scanf(\"%d%d\",&N,&V);\n    for(int i=1;i<=N;i++) scanf(\"%d\",&x[i]);\n    int dummy=V;\n    while(dummy)\n    {\n        v.push_back(dummy);\n        dummy/=2;\n    }\n    v.push_back(0);\n    reverse(v.begin(),v.end());\n    int sz=(int)v.size();\n    for(int i=(int)v.size()-1;i>=0;i--) next[N][i]=N;\n    for(int i=N-1;i>=0;i--)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i+1]-x[i]>v[j]) next[i][j]=i; else next[i][j]=next[i+1][j];\n    for(int i=(int)v.size()-1;i>=0;i--) prev[1][i]=1;\n    for(int i=2;i<=N;i++)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i]-x[i-1]>v[j]) prev[i][j]=i; else prev[i][j]=prev[i-1][j];\n    //for(int i=1;i<=N;i++) printf(\"%d %d %d %d\\n\",prev[i][1],prev[i][2],next[i][1],next[i][2]);\n    memset(predp,0,sizeof(predp));\n    for(int mask=0;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            predp[mask^(1<<j)]=max(predp[mask^(1<<j)],next[min(predp[mask]+1,N)][j]);\n        }\n    }\n    for(int mask=0;mask<(1<<sz);mask++) sufdp[mask]=N+1;\n    for(int mask=0;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            sufdp[mask^(1<<j)]=min(sufdp[mask^(1<<j)],prev[max(sufdp[mask]-1,1)][j]);\n        }\n    }\n    for(int i=0;i<=N+1;i++) mini[i]=N+2; \n    for(int mask=0;mask<(1<<(sz-1));mask++)\n    {\n        int dmask=(1<<(sz-1))-1-mask;\n        int l=predp[mask],r=sufdp[dmask];\n        mini[l]=min(mini[l],r);\n    }\n    for(int i=N;i>=0;i--) mini[i]=min(mini[i],mini[i+1]);\n    for(int i=1;i<=N;i++)\n    {\n        int l=prev[i][sz-1],r=next[i][sz-1];\n        if(l==1&&r==N) {puts(\"Possible\"); continue;}\n        //printf(\"%d %d\\n\",l,r);\n        if(mini[l-1]<=r+1) puts(\"Possible\"); else puts(\"Impossible\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 1000008\n#define lg 21\nint n;\nint pos[nn];\nstruct afd{\n\tint bel[nn];\n\tint l[nn],r[nn];\n\tvoid init(int v)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(i==1 or pos[i]-pos[i-1]>v) bel[i]=i,l[i]=r[i]=i;\n\t\t\telse bel[i]=bel[i-1],r[bel[i]]=i; \n\t\t}\n\t}\n}v2[lg];\nint l=0;\nint v;\n\nvoid fuckoff()\n{\n\twhile(n--) puts(\"Impossible\");\n\texit(0);\n}\nint fl[nn],fr[nn];\nvoid chkmin(int &x,int y) {x=min(x,y);}\nvoid chkmax(int &x,int y) {x=max(x,y);}\n\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&pos[i]);\n\twhile(v) v2[l++].init(v),v/=2;\n\tv2[l++].init(v),v/=2;\n\t\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(v2[0].bel[i]==i)\n\t\t\tcnt++;\n\tif(cnt>1+l) fuckoff();\n\t\n\tfor(int ii=1;ii<=n;ii++)\n\t{\n\t\tif(v2[0].bel[ii]==ii)\n\t\t{\n\t\t\tint el=v2[0].l[ii],er=v2[0].r[ii];\n\t\t\t\n\t\t\tmemset(fl,0x3f,sizeof fl);\n\t\t\tmemset(fr,0,sizeof fr);\n\t\t\t\n\t\t\tfl[1]=el;fr[1]=er;\n\t\t\t\n\t\t\tfor(int mask=1;mask<(1<<l);mask++)\n\t\t\t{\n\t\t\t\tif(!(mask&1) or fl[mask]>n) continue;\n\t\t\t\tfor(int i=1;i<l;i++)\n\t\t\t\t{\n\t\t\t\t\tif(mask&(1<<i)) continue;\n\t\t\t\t\tint x=v2[i].bel[fl[mask]-1];\n\n\t\t\t\t\tif(!x) chkmin(fl[mask|(1<<i)],fl[mask]);\n\t\t\t\t\telse chkmin(fl[mask|(1<<i)],v2[i].l[x]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int mask=1;mask<(1<<l);mask++)\n\t\t\t{\n\t\t\t\tif(!(mask&1) or !fr[mask]) continue;\n\t\t\t\tfor(int i=1;i<l;i++)\n\t\t\t\t{\n\t\t\t\t\tif(mask&(1<<i)) continue;\n\t\t\t\t\tint x=v2[i].bel[fr[mask]+1];\n\t\t\t\t\t\n\t\t\t\t\tif(!x) chkmax(fr[mask|(1<<i)],fr[mask]);\n\t\t\t\t\telse chkmax(fr[mask|(1<<i)],v2[i].r[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tint flag=0;\n\t\t\tfor(int mask=0;mask<(1<<l);mask++)\n\t\t\tif(mask&1)\n\t\t\t\tif(fl[mask]<=1 and fr[(((1<<l)-1)^mask)|1]>=n)\n\t\t\t\t\tflag=1;\n\t\t\t\t\t\t\n\t\t\tif(flag)\n\t\t\t\tfor(int i=el;i<=er;i++) puts(\"Possible\");\n\t\t\telse\n\t\t\t\tfor(int i=el;i<=er;i++) puts(\"Impossible\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,v;\n  cin>>n>>v;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n\n  vector<Int> dp;\n  vector<vector<Int> > ps;\n  while(v){\n    vector<Int> dp2(n,0);\n    for(Int i=1;i<n;i++)\n      dp2[i]=dp2[i-1]+(x[i]-x[i-1]>v);\n    if(dp.empty()) dp=dp2;\n\n    vector<Int> ps2;\n    ps2.emplace_back(0);\n    for(Int i=1;i<n;i++)\n      if(dp2[i]!=dp2[i-1]) ps2.emplace_back(i);\n    ps2.emplace_back(n);\n    ps.emplace_back(ps2);\n    v>>=1;\n  }\n  \n  {\n    vector<Int> ps2(n+1,0);\n    iota(ps2.begin(),ps2.end(),0);\n    ps.emplace_back(ps2);\n  }\n  int sz=ps.size();\n\n  vector<vector<Int> > memo(ps.size(),vector<Int>(n,-1));\n  auto calc=\n    [&](Int d,Int k)->Int{\n      if(d+1==sz) return 1;\n      Int &res=memo[d][k];\n      if(~res) return res;\n      res=0;\n      vector<Int> &v=ps[d];\n      vector<Int> &u=ps[d+1];\n      res=lower_bound(u.begin(),u.end(),v[k+1])\n\t-lower_bound(u.begin(),u.end(),v[k]);\n      return res;\n    };\n  \n  using P = pair<Int, Int>;\n  Int flg;\n  function<void(Int,const set<P>&)> dfs=\n    [&](Int d,const set<P> &sp){\n      if(d==sz) return;\n      \n      Int cnt=0;\n      vector<Int> &v=ps[d];\n      {\n\tauto latte=v.begin();\n\tfor(auto &p:sp){\n\t  cnt+=lower_bound(latte,v.end(),p.first)-latte;\n\t  latte=lower_bound(latte,v.end(),p.second);\n\t}\n\tcnt+=v.end()-latte-1;\n      }\n      \n      flg|=(cnt<=1);\n      if(flg) return;\n      \n      if(d+cnt>sz) return;\n\n      vector<int> &u=ps[d+1];\n      int ncnt=u.size()-1;\n      for(auto &p:sp){\n\tncnt-=lower_bound(u.begin(),u.end(),p.second)\n\t  -lower_bound(u.begin(),u.end(),p.first);\n      }\n      \n      set<P> nsp=sp;\n      {\n\tInt k=0;\n\tfor(auto &p:sp){\n\t  while(v[k]<p.first){\n\t    if(d+ncnt-calc(d,k)<=sz){\n\t      nsp.emplace(v[k],v[k+1]);\n\t      dfs(d+1,nsp);\n\t      nsp.erase(P(v[k],v[k+1]));\n\t      if(flg) return;\n\t    }\n\t    k++;\n\t  }\n\t  k=lower_bound(v.begin(),v.end(),p.second)-v.begin();\n\t}\n\twhile(k+1<(Int)v.size()){\n\t  if(d+ncnt-calc(d,k)<=sz){\n\t    nsp.emplace(v[k],v[k+1]);\n\t    dfs(d+1,nsp);\n\t    nsp.erase(P(v[k],v[k+1]));\n\t    if(flg) return;\n\t  }\n\t  k++;\n\t}\n      }\n      \n    };\n  \n  for(Int i=0;i<n;){\n    Int l=i,r=*upper_bound(ps[0].begin(),ps[0].end(),l);\n    set<P> sp;\n    sp.emplace(l,r);\n    flg=0;\n    dfs(1,sp);\n    string ans=(flg?\"Possible\":\"Impossible\");\n    Int p=i;\n    while(i<n&&dp[p]==dp[i]){\n      cout<<ans<<endl;\n      i++;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\n\nint kano()\n{\n\tchar ch=getchar();int w=0,u=1;\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')u=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())w=w*10+ch-'0';\n\treturn w*u;\n}\nint n,v,o,u,mx;\nint a[200005];\nint p[21][200005],r[21][200005];\nint f[2][262145];\nbool bo[200005];\nint main()\n{\n\tn=kano();v=kano();\n\tfor(int i=1;i<=n;i++)a[i]=kano();\n\tfor(o=v,u=0;o>0;o=o>>1,u++)\n\t{\n\t\tint la=1;p[u][1]=1;r[u][1]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]-a[i-1]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tmx=1<<u;mx--; \n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tf[0][i|j]=max(f[0][i|j],p[l][r[l][f[0][i]+1]]);\n\t\t}\n\t}\n\tfor(o=v>>1,u=1;o>0;o=o>>1,u++)\n\t{\n\t\tint la=n;p[u][n]=n;r[u][n]=n;\n\t\tfor(int i=n-1;i>=1;i--)\n\t\t{\n\t\t\tif(a[i+1]-a[i]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tfor(int i=0;i<=mx;i++)f[1][i]=n+1;\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tf[1][i|j]=min(f[1][i|j],p[l][r[l][f[1][i]-1]]);\n\t\t}\n\t}\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tint j=~i&mx;\n\t\tif(r[0][f[0][i]+1]==r[0][f[1][j]-1])bo[r[0][f[0][i]+1]]=1;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(bo[r[0][i]])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define ll      long long\n\nint x[202020];\nint l[202020][20], r[202020][20];\nint dpl[1 << 20], dpr[1 << 20];\n\nvoid solve() {\n        int n, v;\n        cin >> n >> v;\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        int p;\n        for (int i = 0; ; i ++) if ((1 << i) > v) {\n                p = i + 1;\n                break;\n        }\n        for (int i = 0; i < n; i ++) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == 0 || x[i] - x[i - 1] > vv) l[i][j] = i;\n                        else l[i][j] = l[i - 1][j];\n                        vv /= 2;\n                }    \n        }\n        for (int i = n - 1; i >= 0; i --) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == n - 1 || x[i + 1] - x[i] > vv) r[i][j] = i;\n                        else r[i][j] = r[i + 1][j];\n                        vv /= 2;\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpr[i] == n) dpr[i | (1 << j)] = n;\n                        else dpr[i | (1 << j)] = max(dpr[i | (1 << j)], r[dpr[i]][j] + 1);\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) dpl[i] = n - 1;\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpl[i] == -1) dpl[i | (1 << j)] = -1;\n                        else dpl[i | (1 << j)] = min(dpl[i | (1 << j)], l[dpl[i]][j] - 1);\n                }\n        }\n        bool ok = false;\n        for (int i = 0; i < n; i ++) {\n                if (l[i][0] == i) {\n                        int c = 0;\n                        for (int j = 0; j < (1 << p); j ++) {\n                                c ++;\n                                if (j & 1) continue;\n                                if (i > 0 && dpr[j] < i) continue;\n                                if (r[i][0] < n - 1 && dpl[(1 << p) - 2 - j] > r[i][0]) continue;\n                                break;\n                        }\n                        if (c < (1 << p)) ok = true;\n                        else ok = false;\n                }\n                if (ok) cout << \"Possible\" << endl;\n                else cout << \"Impossible\" << endl;\n        }\n        return;\n}\n\nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        solve();\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int inf=1e9;\nconst ll Inf=1e18;\nconst int N=1e6+10;\nconst int mod=0;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ntemplate<typename T> bool chkmax(T &a,T b) { return a<b?a=b,1:0; };\ntemplate<typename T> bool chkmin(T &a,T b) { return a>b?a=b,1:0; };\nint add(int a,int b) { return a+b>=mod?a+b-mod:a+b; }\nint sub(int a,int b) { return a-b<0?a-b+mod:a-b; }\nvoid inc(int &a,int b) { a=(a+b>=mod?a+b-mod:a+b); }\nvoid dec(int &a,int b) { a=(a-b<0?a-b+mod:a-b); }\nint n,v,x[N],st[N],l[N][20],r[N][20],f[N],g[N],mn[N],top=0;\nint main() {\n    cin>>n>>v;\n    for(int i=1;i<=n;i++) x[i]=gi();\n    while(v) st[++top]=v,v>>=1;\n    st[++top]=0;\n    reverse(st+1,st+top+1);\n    for(int j=1;j<=top;j++) {\n        l[1][j]=1;\n        for(int i=2;i<=n;i++) l[i][j]=(x[i]-x[i-1]<=st[j])?l[i-1][j]:i;\n        r[n][j]=n;\n        for(int i=n-1;i;i--) r[i][j]=(x[i+1]-x[i]<=st[j])?r[i+1][j]:i;\n    }\n    f[0]=0;g[0]=n+1;\n    for(int i=1;i<(1<<top);i++) {\n        f[i]=0,g[i]=n+1;\n        for(int j=1;j<=top;j++)\n            if(i>>(j-1)&1) {\n                chkmax(f[i],(f[i^(1<<(j-1))]==n)?n:r[f[i^(1<<(j-1))]+1][j]);\n                chkmin(g[i],(g[i^(1<<(j-1))]==1)?1:l[g[i^(1<<(j-1))]-1][j]);\n            }\n    }\n    memset(mn,0x3f,sizeof(mn));\n    for(int i=0;i<(1<<(top-1));i++) chkmin(mn[f[i]],g[((1<<(top-1))-1)^i]);\n    for(int i=n-1;i;i--) chkmin(mn[i],mn[i+1]);\n    for(int i=1;i<=n;i++) puts(mn[l[i][top]-1]<=r[i][top]+1?\"Possible\":\"Impossible\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 220000\ninline char gc(){\n\tstatic char now[1<<16],*S,*T;\n\tif (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}\n\treturn *S++;\n}\n#define S 1<<19\ninline int read(){\n\tint x=0,f=1;char ch=gc();\n\twhile (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}\n\twhile (ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=gc();}\n\treturn x*f;\n}\nint f1[S],f2[S],n,num,bin[20],st[N],a[N],right[N][20],left[N][20],v;\nint main(){\n//\tfreopen(\"agc.in\",\"r\",stdin);\n\tn=read();v=read();int Log=0;\n\tfor (int i=1;i<=n;++i) a[i]=read();\n\twhile ((1<<Log)<=v) Log++;Log++;\n\tfor (int i=0;i<=Log+1;++i) bin[i]=1<<i;\n\tnum=1;for (int i=2;i<=n;++i) if (a[i]-a[i-1]>v) num++;\n\tfor (int j=0;j<Log;++j){\n\t\tleft[1][j]=1;right[n][j]=n;\n\t\tfor (int i=2;i<=n;++i) if (a[i]-a[i-1]>(v>>j)) left[i][j]=i;else left[i][j]=left[i-1][j];\n\t\tfor (int i=n-1;i>=1;--i) if (a[i+1]-a[i]>(v>>j)) right[i][j]=i;else right[i][j]=right[i+1][j];\n\t}\t\n\t/*for (int j=0;j<Log;++j){\n\t\tfor (int i=1;i<=n;++i) printf(\"%d \",right[i][j]);printf(\"\\n\");\n\t\tfor (int i=n;i>=1;--i) printf(\"%d \",left[i][j]);printf(\"\\n\");\n\t}*/\n\tif (num>Log){\n\t\tfor (int i=1;i<=n;++i) printf(\"Impossible\\n\");return 0;\n\t}\n\tfor (int s=0;s<=bin[Log]-1;++s) {f1[s]=0,f2[s]=n+1;}\n\tfor (int s=0;s<=bin[Log]-1;++s){\n\t\tfor (int i=0;i<Log;++i){\n\t\t\tif (s&bin[i])continue;\n\t\t\tif (f1[s]==n) f1[s|bin[i]]=n;else f1[s|bin[i]]=max(f1[s|bin[i]],right[f1[s]+1][Log-i-1]);\n\t\t\tif (f2[s]==1) f2[s|bin[i]]=1;else f2[s|bin[i]]=min(f2[s|bin[i]],left[f2[s]-1][Log-i-1]);\n\t\t}\n\t}for (int i=0;i<=n;++i) st[i]=n+2;\n\tfor (int s=0;s<=bin[Log-1]-1;++s){\n\t\tint s1=(bin[Log-1]-1)^s;\n\t\tst[f1[s]]=min(st[f1[s]],f2[s1]);\n\t} for (int i=n-1;i>=0;--i) st[i]=min(st[i],st[i+1]);\n\t//for (int i=0;i<=n;++i) printf(\"%d \",st[i]);printf(\"\\n\");\n\tfor (int i=1;i<=n;++i){\n\t\tint l=left[i][0],r=right[i][0];\n\t\tif (st[l-1]<=r+1) printf(\"Possible\\n\");else printf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*====Corycle====*/\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<map>\n#define ll long long\n#define pii pair<int,int>\n#define fst first\n#define scd second\n#define mp make_pair\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int Maxn=(1<<21)+5;\nconst int N=2e5+5;\nconst int M=22;\nint read(){\n\tint s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}\n\treturn s*f;\n}\npii P[N];\nint n,V,cnt,tot,Sta,a[N],L[N][M],R[N][M],Ans[N],FL[Maxn],FR[Maxn];\nint main(){\n//\tfreopen(\"_.in\",\"r\",stdin);\n//\tfreopen(\"_.out\",\"w\",stdout);\n\tn=read();V=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();a[0]=-inf;a[n+1]=inf;\n\tfor(int v=V;;v>>=1){\n\t\ttot++;L[tot][0]=0;R[tot][n+1]=n+1;\n\t\tfor(int i=1;i<=n;i++)L[tot][i]=(a[i]-a[i-1]<=v?L[tot][i-1]:i);\n\t\tfor(int i=n;i>=1;i--)R[tot][i]=(a[i+1]-a[i]<=v?R[tot][i+1]:i);\n\t\tif(v==0)break;\n\t}\n\tSta=(1<<tot)-1;\n\tfor(int i=1;i<=n;i++)P[i]=mp(L[1][i],R[1][i]);\n\tsort(P+1,P+n+1);cnt=unique(P+1,P+n+1)-P-1;\n\tfor(int S=0;S<=Sta;S++){FL[S]=0;FR[S]=n+1;}\n\tfor(int S=0;S<=Sta;S++){\n\t\tfor(int i=1;i<=tot;i++){\n\t\t\tif(!((S>>(i-1))&1))continue;\n\t\t\tFL[S]=max(FL[S],R[i][FL[S^(1<<(i-1))]+1]);\n\t\t\tFR[S]=min(FR[S],L[i][FR[S^(1<<(i-1))]-1]);\n\t\t}\n\t}\n\tif(cnt>tot){for(int i=1;i<=tot;i++)puts(\"Impossible\");return 0;}\n\tfor(int i=1;i<=cnt;i++){\n\t\tfor(int S=0;S<=Sta;S+=2){\n\t\t\tif(FL[S]>=P[i].fst-1&&FR[Sta^S^1]<=P[i].scd+1){\n\t\t\t\tfor(int j=P[i].fst;j<=P[i].scd;j++)Ans[j]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)puts(Ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=200010,SH=18,SN=1<<SH,INF=0x7f7f7f7f;\nint tol[N][SH],tor[N][SH];\nint fl[SN],fr[SN];\nint x[N],v[N];\nint ext[N];\nint main(){\n\tint n=ni,vs=0;\n\tv[0]=ni;\n\tfor(int &i=vs;v[i];i++){\n\t\tv[i+1]=v[i]>>1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tx[i]=ni;\n\t}\n\tfor(int j=0;j<=vs;j++){\n\t\tx[0]=-INF;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ttol[i][j]=x[i]-x[i-1]<=v[j]?tol[i-1][j]:i;\n\t\t}\n\t\tx[n+1]=INF;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\ttor[i][j]=x[i+1]-x[i]<=v[j]?tor[i+1][j]:i;\n\t\t}\n\t}\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tfl[s]=0;\n\t\tfor(int i=1;i<=vs;i++){\n\t\t\tif((s>>(i-1))&1){\n\t\t\t\tapmax(fl[s],tor[fl[s^(1<<(i-1))]+1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tfr[s]=n+1;\n\t\tfor(int i=1;i<=vs;i++){\n\t\t\tif((s>>(i-1))&1){\n\t\t\t\tapmin(fr[s],tol[fr[s^(1<<(i-1))]-1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(ext,127,sizeof(ext));\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tapmin(ext[fl[s]],fr[s^(ts-1)]);\n\t}\n\tfor(int i=n;i>=1;i--){\n\t\tapmin(ext[i-1],ext[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tputs(ext[tol[i][0]-1]<=tor[i][0]+1?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\n#define MAX 200002\n\nint n;\nint v;\n\nvector<int> vv;\n\nint dp[MAX][20];\nint val[MAX];\n\n\n\nmap<int, vector<int> > mp;\n\nvector<vector<int> > V;\n\n\nvector<int> VV;\n\nint mx = 0;\n\nint D[1 << 18];\nbool ok(){\n\tif (VV.size() == 0){\n\t\treturn true;\n\t}\n\tint N = VV.size();\n\tfor (int i = 1; i <= mx; i++){\n\t\tdp[N - 1][i] = N - 1;\n\t}\n\tfor (int i = N - 2; i >= 0; i--){\n\t\tlong long int d = VV[i + 1] - VV[i];\n\t\tfor (int j = 1; j <= mx; j++){\n\t\t\tif (d <= val[j]){\n\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i][j] = i;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(D, 0, sizeof(D));\n\tfor (int i = 0; i < (1 << mx); i++){\n\t\tif (D[i] >= N){\n\t\t\treturn true;\n\t\t}\n\t\tfor (int j = 1; j <= mx; j++){\n\t\t\tif ((i >> (j - 1)) & 1)continue;\n\t\t\tint go = i | (1 << (j - 1));\n\t\t\tD[go] = max(D[go], dp[D[i]][j]+1);\n\t\t}\n\t}\n\treturn false;\n}\nbool ans[MAX];\n\nint main(){\n\tcin >> n >> v;\n\tfor (int i = 0; i < n; i++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tvv.push_back(x);\n\t}\n\t\n\tval[0] = v;\n\tfor (mx = 1; v / 2 >= 0; mx++){\n\t\tv /= 2;\n\t\tval[mx] = v;\n\t\tif (v == 0)break;\n\t}\n\tfor (int i = 0; i <= mx; i++){\n\t\tdp[n - 1][i] = n-1;\n\t}\n\tfor (int i = n - 2; i >= 0; i--){\n\t\tlong long int d = vv[i + 1] - vv[i];\n\t\tfor (int j = 0; j <= mx; j++){\n\t\t\tif (d <= val[j]){\n\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i][j] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tmp[dp[i][0]].push_back(i);\n\t}\n\tif (mp.size()>mx+1){\n\t\t\n\t}\n\telse{\n\t\tfor (auto it = mp.begin(); it != mp.end(); it++){\n\t\t\tVV.clear();\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (i < (*it).second[0] || (*it).second.back() < i){\n\t\t\t\t\tVV.push_back(vv[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok()){\n\t\t\t\tvector<int> &vvv = (*it).second;\n\t\t\t\tfor (int j = 0; j < vvv.size(); j++){\n\t\t\t\t\tans[vvv[j]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tif (ans[i] == true){\n\t\t\tputs(\"Possible\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"Impossible\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,v,k,a[20],x[200005],f[200005][20],L[200005][20],R[200005][20],dpl[262222],dpr[262222],dp[200005];\nvoid upda(int &x,int y){if(y>x)x=y;}\nvoid updi(int &x,int y){if(y<x)x=y;}\nint main(){\n    scanf(\"%d%d\",&n,&v);\n    for(int i=1;i<=n;++i)scanf(\"%d\",x+i);\n    for(int i=1;i<n;++i)x[i]=x[i+1]-x[i];\n    a[0]=v/2;\n    while(a[k])a[k+1]=a[k]/2,++k;\n    a[++k]=v;\n    for(int i=1;i<n;++i)f[i][0]=x[i];\n    for(int j=0;j<17;++j){\n        for(int i=1;i<=n-(2<<j);++i)f[i][j+1]=max(f[i][j],f[i+(1<<j)][j]);\n    }\n    for(int i=1;i<=n;++i){\n        for(int j=0;j<=k;++j){\n            int o=i;\n            for(int _=17;_>=0;--_)if(o>(1<<_)&&f[o-(1<<_)][_]<=a[j])o-=(1<<_);\n            L[i][j]=o;\n            o=i;\n            for(int _=17;_>=0;--_)if(o+(1<<_)<=n&&f[o][_]<=a[j])o+=(1<<_);\n            R[i][j]=o;\n        }\n    }\n    for(int _=0;_<(1<<k);++_){\n        int d=min(dpl[_]+1,n);\n        for(int i=0;i<k;++i){\n            if(_&(1<<i)) continue;\n            upda(dpl[_|(1<<i)],R[d][i]);\n        }\n        dpr[_]=n+1;\n    }\n    memset(dp,-1,sizeof(dp));\n    for(int _=0;_<(1<<k);++_){\n        int d=max(dpr[_]-1,0);\n        for(int i=0;i<k;++i){\n            if(_&(1<<i)) continue;\n            updi(dpr[_|(1<<i)],L[d][i]);\n        }\n        upda(dp[dpr[_]],dpl[((1<<k)-1)^_]);\n    }\n    for(int i=2;i<=n+1;++i)upda(dp[i],dp[i-1]);\n    for(int i=1;i<=n;++i){\n        if(dp[R[i][k]+1]>=L[i][k]-1)puts(\"Possible\");\n        else puts(\"Impossible\");\n    }\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<stdlib.h>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nint p[210000];\nint q[210000];\nint c[210000];\nint L[1<<18];\nint R[1<<18];\nvector<int>en[18];\nvector<int>ee;\nlong long sum[210000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",p+i);\n\t\tif(i)q[i]=p[i]-p[i-1];\n\n\t}\n\tint tt=b;\n\tfor(int i=0;i<a;i++){\n\t\tif(tt<q[i])ee.push_back(i);\n\t}\n\tint BI=0;\n\tee.push_back(a);\n\tfor(int i=0;i<18;i++){\n\t\tif(tt==0)break;\n\t\tBI++;\n\t\ttt/=2;\n\t\tc[i]=tt;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(c[i]<q[j])en[i].push_back(j);\n\t\t}\n\t\ten[i].push_back(a);\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t\tint at=L[i];\n\t\tint tmp=b;\n\t\tfor(int j=0;j<BI;j++){\n\t\t//\ttmp/=2;\n\t\t\tif(i&(1<<j))continue;\n\t\t\tif(at==a){\n\t\t\t\tL[i+(1<<j)]=a;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to=upper_bound(en[j].begin(),en[j].end(),at)-en[j].begin();\n\n\t//\t\tprintf(\"%d %d %d %d %d\\n\",i,j,at,to,(int)(en[j].size()));\n\t\t\tL[i+(1<<j)]=max(L[i+(1<<j)],en[j][to]);\n\t\t//\tif(tmp==0)break;\n\t\t}\n\t}\n\t//return 0;\n\treverse(p,p+a);\n\tfor(int i=0;i<a;i++){\n\t\tif(i)q[i]=p[i-1]-p[i];\n\t}\n\tfor(int i=0;i<BI;i++)en[i].clear();\n\tfor(int i=0;i<BI;i++){\n\t\tif(c[i]){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(c[i]<q[j])en[i].push_back(j);\n\t\t\t}\n\t\t\ten[i].push_back(a);\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t\tint at=R[i];\n\t\tint tmp=b;\n\t\tfor(int j=0;j<BI;j++){\n\t\t//\ttmp/=2;\n\t\t\tif(i&(1<<j))continue;\n\t\t\tif(R[i]==a){\n\t\t\t\tR[i+(1<<j)]=a;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to=upper_bound(en[j].begin(),en[j].end(),at)-en[j].begin();\n\t//\t\tprintf(\"%d %d %d %d %d\\n\",i,j,at,to,(int)(en[j].size()));\n\t\t\tR[i+(1<<j)]=max(R[i+(1<<j)],en[j][to]);\n\t\t//\tif(tmp==0)break;\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t//\tif(i>=(1<<2))continue;\n\t//\tprintf(\"%d: %d %d\\n\",i,L[i],R[i]);\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t\tint left=L[i];\n\t\tint right=a-R[(1<<BI)-1-i];\n\t\tleft++;\n\t\tif(lower_bound(ee.begin(),ee.end(),right)-upper_bound(ee.begin(),ee.end(),left)<=0){\n\t\t\tsum[left]++;\n\t\t\tsum[right+1]--;\n\t//\t\tprintf(\"%d %d\\n\",left-1,right);\n\t\t}\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tsum[i+1]+=sum[i];\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tsum[i+1]+=sum[i];\n\t}\n\t//for(int i=0;i<=a;i++)printf(\"%lld \",sum[i]);printf(\"\\n\");\n\tfor(int i=0;i<a;i++){\n\t\tint left,right;\n\t\tint ind=upper_bound(ee.begin(),ee.end(),i)-ee.begin();\n\t\tif(ind==0)left=0;\n\t\telse left=ee[ind-1];\n\t\tind=upper_bound(ee.begin(),ee.end(),i)-ee.begin();\n\t\tright=ee[ind];\n//\t\tprintf(\"%d: %d %d\\n\",i,left,right);\n\t\tif(sum[left]==sum[right])printf(\"Impossible\\n\");\n\t\telse printf(\"Possible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" :: \" << x << endl\n#define _ << \" \" <<\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(),(x).end()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for (int i=(a);i>=(b);--i)\n\nconst int mxN = 2e5+5;\nconst int lgN = 19;\nint N, V, X[mxN];\nvector<int> S;\nint M, dpL[(1<<lgN)], dpR[(1<<lgN)], r[lgN][mxN], l[lgN][mxN];\nint bestR[mxN], bestL[mxN];\n\nstruct SparseTable {\n    int *V, A[mxN][lgN];\n    void init(int* _V) {\n        V = _V;\n        FOR(i,0,N) A[i][0] = i;\n        FOR(k,1,lgN-1){\n            FOR(i,0,N-(1<<k)+1){\n                int x = A[i][k-1], y = A[i+(1<<(k-1))][k-1];\n                A[i][k] = (V[x] < V[y] ? x : y);\n            }\n        }\n    }\n    int qval(int l, int r) {\n        int k = floor(log2(r-l+1));\n        int i = A[l][k], j = A[r-(1<<k)+1][k];\n        return min(V[i],V[j]);\n    }\n} st;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> N >> V;\n    FOR(i,1,N){\n        cin >> X[i];\n    }\n    for (int x = V; x; x >>= 1) S.push_back(x);\n    S.push_back(0);\n    reverse(ALL(S));\n    M = SZ(S);\n    FOR(i,0,M-1){\n        r[i][N] = N;\n        RFOR(j,N-1,1){\n            r[i][j] = j;\n            if (X[j+1]-X[j] <= S[i]) r[i][j] = max(r[i][j],r[i][j+1]);\n        }\n        l[i][1] = 1;\n        FOR(j,2,N){\n            l[i][j] = j;\n            if (X[j]-X[j-1] <= S[i]) l[i][j] = min(l[i][j],l[i][j-1]);\n        }\n    }\n    dpL[0] = 0;\n    FOR(x,1,(1<<(M-1))-1){\n        dpL[x] = 1;\n        int y = x;\n        while (y) {\n            int b = y&-y, c = __builtin_ctz(b);\n            y ^= b;\n            dpL[x] = (dpL[x^b] == N ? N : max(dpL[x],r[c][dpL[x^b]+1]));\n        }\n    }\n    dpR[0] = N+1;\n    FOR(x,1,(1<<(M-1))-1){\n        dpR[x] = N;\n        int y = x;\n        while (y) {\n            int b = y&-y, c = __builtin_ctz(b);\n            y ^= b;\n            dpR[x] = (dpR[x^b] == 1 ? 1 : min(dpR[x],l[c][dpR[x^b]-1]));\n        }\n    }\n    fill(bestR,bestR+1+N,N+2);\n    FOR(x,0,(1<<(M-1))-1){\n        int y = ((1<<(M-1))-1) ^ x;\n        bestR[dpL[x]] = min(bestR[dpL[x]],dpR[y]);\n    }\n    st.init(bestR);\n    //FOR(i,0,N){ cout << bestR[i] << ' '; } cout << endl;\n\n    FOR(i,1,N){\n        int rcov = st.qval(l[M-1][i]-1,r[M-1][i]);\n        cout << (r[M-1][i]+1 >= rcov ? \"Possible\" : \"Impossible\") << '\\n';\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(),v.end()\n\nconst int maxn = 2e5 + 100, maxlg = 18;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, v, vols[maxlg], volCount, nxt[maxlg][maxn], dp[(1 << maxlg)];\nll x[maxn], a[maxn];\nbool ans[maxn];\nset<int> counter;\n\nvoid printAnsAndExit() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << (ans[i] ? \"Possible\" : \"Impossible\") << endl;\n\t}\n\texit(0);\n}\n\nvoid solve(int l, int r) {\n\tmemset(dp, 0, sizeof(dp));\n\tfor (int mask = 0; mask < (1 << (volCount - 1)); mask++) {\n\t\tfor (int bit = 0; bit < volCount - 1; bit++) {\n\t\t\tif (!((mask >> bit) & 1)) {\n\t\t\t\tint val = nxt[bit][dp[mask]] + 1;\n\t\t\t\tif (l <= val && val <= r) {\n\t\t\t\t\tval = r + 1;\n\t\t\t\t}\n\t\t\t\tdp[mask | (1 << bit)] = max(dp[mask | (1 << bit)], val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mx = *max_element(dp, dp + (1 << maxlg));\n\tif (mx == n) {\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tans[i] = true;\n\t\t}\n\t}\n}\n\nvoid solveAll() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcounter.insert(nxt[volCount - 1][i]);\n\t}\n\tif (counter.size() > volCount) {\n\t\tprintAnsAndExit();\n\t}\n\t\n\tint l = 0, r = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (nxt[volCount - 1][r] == nxt[volCount - 1][i]) {\n\t\t\tr++;\n\t\t}\n\t\telse {\n\t\t\tsolve(l, r);\n\t\t\tr++;\n\t\t\tl = r;\n\t\t}\n\t}\n\tsolve(l, r);\n}\n\n\nvoid calcVols(int v) {\n\tint count = 0, tmp = v;\n\twhile (tmp) {\n\t\ttmp /= 2;\n\t\tcount++;\n\t}\n\tvolCount = ++count;\n\twhile (count) {\n\t\tvols[--count] = v;\n\t\tv /= 2;\n\t}\n}\n\nvoid calcNxt() {\n\tfor (int vol = 0; vol < volCount; vol++) {\n\t\tint l = 0, r = 0;\n\t\twhile (r < n - 1) {\n\t\t\tif (x[r + 1] - x[r] <= vols[vol]) {\n\t\t\t\tr++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (l <= r) {\n\t\t\t\t\tnxt[vol][l] = r;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\twhile (l <= r) {\n\t\t\tnxt[vol][l] = r;\n\t\t\tl++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t\ta[i] = x[i];\n\t}\n\n\tcalcVols(v);\n\tcalcNxt();\n\tsolveAll();\n\tprintAnsAndExit();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Camel and Oases\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\nint const N=2e5+10;\nint const S=1<<19;\nint n,V;\nlint d[N];\nint logV,a[25][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n    }\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nvoid type(int s)\n{\n    for(int i=logV;i>=1;i--) printf(\"%d\",(s>>(i-1))%2);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&d[i]),d[i-1]=d[i]-d[i-1];\n    //for(int i=1;i<=n;i++) printf(\"%lld \",d[i]);\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    /*for(int i=1;i<=logV;i++)\n    {\n    \tprintf(\"%d-%d \",1,a[i][1]);\n        for(int j=2;j<=a[i][0];j++) printf(\"%d-%d \",a[i][j-1]+1,a[i][j]);\n        printf(\"\\n\");\n    }*/\n    /*if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++)\n            if(i==1) printf(\"Impossible-\");\n            else printf(\"\\nImpossible-\");\n        return 0;\n    }*/\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=0,f2[s]=n+1;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    /*for(int s=0;s<=U;s+=2)\n        type(s),printf(\"   1-%2d  %2d-%2d\\n\",f1[s],f2[U-s-1],n);*/\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1 && f2[U-s-1]-1<=to) f=true;\n        if(f) for(int j=fr;j<=to;j++)\n            if(j==1) printf(\"Possible\");\n            else printf(\"\\nPossible\");\n        else for(int j=fr;j<=to;j++)\n            if(j==1) printf(\"Impossible\");\n            else printf(\"\\nImpossible\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n#include<ext/pb_ds/priority_queue.hpp>\nusing namespace std;\n\nconst int N = 20;\nconst int maxn = 2E5 + 20;\n\nint n,v,Max,p[maxn],Min[maxn],Left[maxn][N],Right[maxn][N],f[1 << N],g[1 << N];\n\nvoid Pre_Work(int k,int now)\n{\n\tLeft[1][k] = 1; Right[n][k] = n;\n\tfor (int i = 2; i <= n; i++)\n\t\tLeft[i][k] = p[i] - p[i - 1] <= now ? Left[i - 1][k] : i;\n\tfor (int i = n - 1; i; i--)\n\t\tRight[i][k] = p[i + 1] - p[i] <= now ? Right[i + 1][k] : i;\n}\n\nint main()\n{\n\t#ifdef DMC\n\t\tfreopen(\"DMC.txt\",\"r\",stdin);\n\t#endif\n\t\n\tcin >> n >> v;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\",&p[i]);\n\tfor (int x = v; ; x >>= 1)\n\t{\n\t\tPre_Work(Max++,x);\n\t\tif (!x) break;\n\t}\n\tfor (int i = 0; i <= n; i++) Min[i] = maxn; g[0] = n + 1;\n\tfor (int o = 1; o < (1 << Max); o++)\n\t{\n\t\tg[o] = n + 1;\n\t\tfor (int i = 0; i < Max; i++)\n\t\t{\n\t\t\tif (!(o & (1 << i))) continue;\n\t\t\tint op = o ^ (1 << i);\n\t\t\tf[o] = f[op] == n ? n : max(f[o],Right[f[op] + 1][i]);\n\t\t\tg[o] = g[op] == 1 ? 1 : min(g[o],Left[g[op] - 1][i]);\n\t\t}\n\t}\n\tfor (int o = 0; o < (1 << Max); o++)\n\t{\n\t\tint A = o,B = ((1 << Max) - 1) ^ o;\n\t\tif (A & 1) A ^= 1; if (B & 1) B ^= 1;\n\t\tMin[f[A]] = min(Min[f[A]],g[B]);\n\t}\n\tfor (int i = n - 1; i >= 0; i--) Min[i] = min(Min[i],Min[i + 1]);\n\tfor (int i = 1; i <= n; i++)\n\t\tputs(Min[Left[i][0] - 1] <= Right[i][0] + 1 ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,v,x[200005];\nint go[200005][20],go2[200005][20];\nint dp[(1<<20)],dp2[(1<<20)];\nint used[200005];\nP p[200005];\n\nint main(){\n\tcin>>n>>v;\n\trepn(i,n)cin>>x[i];\n\tvector<int>vi;\n\twhile(1){\n\t\tvi.pb(v);\n\t\tif(v == 0) break;\n\t\tv/=2;\n\t}\n\trep(j,vi.size()){\n\t\tvector<int>vec;\n\t\trepn(i,n-1){\n\t\t\tif(x[i+1]-x[i] > vi[j]){\n\t\t\t\tvec.pb(i);\n\t\t\t}\n\t\t}\n\t\tvec.pb(n);\n\t\trepn(i,n){\n\t\t\tint e = vec[POSL(vec,i)];\n\t\t\tgo[i][j] = e;\n\t\t\tif(j==0) p[i].sc = e;\n\t\t}\n\t}\n\trep(j,vi.size()){\n\t\tvector<int>vec;\n\t\tvec.pb(1);\n\t\trepn(i,n-1){\n\t\t\tif(x[i+1]-x[i] > vi[j]){\n\t\t\t\tvec.pb(i+1);\n\t\t\t}\n\t\t}\n\t\trepn(i,n){\n\t\t\tint e = vec[POSU(vec,i)-1];\n\t\t\tgo2[i][j] = e;\n\t\t\tif(j==0) p[i].fi = e;\n\t\t}\n\t}\n\t//repn(i,n)cout<<p[i].fi<<\" \"<<p[i].sc<<endl;\n\trep(i,(1<<20)) dp[i] = -INF;\n\tdp[0] = 1;\n\tint z = vi.size();\n\tfor(int mask=0;mask<(1<<z);mask++){\n\t\tif(dp[mask] <= 0) continue;\n\t\tfor(int i=0;i<z;i++){\n\t\t\tif(((mask>>i)&1)) continue;\n\t\t\tint NXT = go[dp[mask]+1][i];\n\t\t\tif(dp[mask]==n) NXT=n;\n\t\t\tdp[mask+(1<<i)] = max(dp[mask+(1<<i)],NXT);\n\t\t}\n\t}\n\trep(i,(1<<20)) dp2[i] = INF;\n\tdp2[0] = n;\n\t//int z = vi.size();\n\tfor(int mask=0;mask<(1<<z);mask++){\n\t\tif(dp2[mask] > n) continue;\n\t\tfor(int i=0;i<z;i++){\n\t\t\tif(((mask>>i)&1)) continue;\n\t\t\tint NXT = go2[dp2[mask]-1][i];\n\t\t\tif(dp2[mask]==1) NXT=1;\n\t\t\tdp2[mask+(1<<i)] = min(dp2[mask+(1<<i)],NXT);\n\t\t}\n\t}\n\tvector<P>L;\n//\tbool allok = 0;\n\tfor(int mask=0;mask<(1<<z);mask++){\n\t\tif(mask%2 == 1) continue;\n\t\tint mask2 = (1<<z)-2-mask;\n\t\tint x = dp[mask];\n\t\tint y = dp2[mask2];\n\t\t//cout<<x<<y<<endl;\n\t\tif(x+1>y-1) used[1] += 1;\n\t\telse{\n\t\t\tint L = p[x+1].fi;\n\t\t\tint R = p[x+1].sc;\n\t\t\tif(L<=x+1 && y-1<=R){\n\t\t\t\tused[L]++;\n\t\t\t\tused[R+1]--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++) used[i]+=used[i-1];\n\tfor(int i=1;i<=n;i++){\n\t\tputs(used[i]?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define MAX 200200\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nvoid cmax(int &x,int y){if(x<y)x=y;}\nvoid cmin(int &x,int y){if(x>y)x=y;}\nint n,V[25],x[MAX],t;\nint L[20][MAX],R[20][MAX],mr[MAX];\nint sl[1<<19],sr[1<<19];\nint main()\n{\n\tn=read();V[0]=read();\n\tfor(int i=1;i<=n;++i)x[i]=read();\n\twhile(V[t])V[t+1]=V[t]>>1,++t;int S=1<<t;\n\tfor(int i=0;i<=t;++i)\n\t{\n\t\tL[i][1]=1;R[i][n]=n;\n\t\tfor(int j=2;j<=n;++j)\n\t\t\tif(x[j]-x[j-1]<=V[i])L[i][j]=L[i][j-1];\n\t\t\telse L[i][j]=j;\n\t\tfor(int j=n-1;~j;--j)\n\t\t\tif(x[j+1]-x[j]<=V[i])R[i][j]=R[i][j+1];\n\t\t\telse R[i][j]=j;\n\t}\n\tfor(int i=1;i<S;++i)sl[i]=1,sr[i]=n;\n\tsl[0]=0;sr[0]=n+1;\n\tfor(int i=0;i<S;++i)\n\t\tfor(int j=1;j<=t;++j)\n\t\t\tif(!(i&(1<<(j-1))))\n\t\t\t{\n\t\t\t\tcmax(sl[i|(1<<(j-1))],R[j][sl[i]+1]);\n\t\t\t\tcmin(sr[i|(1<<(j-1))],L[j][sr[i]-1]);\n\t\t\t}\n\tmemset(mr,63,sizeof(mr));\n\tfor(int i=0;i<=n+1;++i)\n\t\tfor(int j=0;j<S;++j)\n\t\t\tcmin(mr[sl[j]],sr[(S-1)^j]);\n\tfor(int i=n;~i;--i)mr[i]=min(mr[i],mr[i+1]);\n\tfor(int i=1;i<=n;++i)puts(mr[L[0][i]-1]<=R[0][i]+1?\"Possible\":\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 200010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;if(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\n\nint b[40],sz,a[N],c[N];\nint dp[1<<18],f[1<<18],l[N][20],r[N][20];\nint main(){\n    //freopen(\"A.in\",\"r\",stdin);\n    //freopen(\"A.out\",\"w\",stdout);\n    //cout<<setprecision(9)<<fixed;\n    //cerr<<setprecision(9)<<fixed;\n    int T,i,j,k,ca=0,m,K,n;\n    scanf(\"%d%d\",&n,&m);\n    K=m;sz=0;\n    while(K)b[sz++]=K,K>>=1;\n    b[sz++]=0;\n    swap(b[0],b[sz-1]);\n    rep(i,0,n)scanf(\"%d\",&a[i]);\n    rep(k,0,sz){\n        K=b[k];\n        //cerr<<k<<\" \"<<K<<\"\\n\";\n        l[0][k]=0;\n        rep(i,1,n){\n            if(K>=a[i]-a[i-1])l[i][k]=l[i-1][k];\n            else l[i][k]=i;\n        }\n        r[n-1][k]=n-1;\n        per(i,0,n-1){\n            if(K>=a[i+1]-a[i])r[i][k]=r[i+1][k];\n            else r[i][k]=i;\n        }\n    }\n    sz--;\n    memset(dp,-1,sizeof(dp));\n    dp[0]=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Max(dp[i|1<<j],x);\n            if(x+1<n)Max(dp[i|1<<j],r[x+1][j]);\n        }\n    }\n    per(i,0,(1<<sz))f[i]=n;\n    f[0]=n-1;\n    rep(i,0,(1<<sz)){\n        int x=f[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Min(f[i|1<<j],x);\n            if(x)Min(f[i|1<<j],l[x-1][j]);\n        }\n    }\n    int mask=(1<<sz)-1,flag=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i],y=f[mask^i];\n        k=r[x+1][sz];\n        j=l[y-1][sz];\n        if(j<=x+1&&k>=y-1)c[j]++,c[k+1]--;\n    }\n    {\n        rep(i,1,n)c[i]+=c[i-1];\n        rep(i,0,n){\n            if(c[i])puts(\"Possible\");\n            else puts(\"Impossible\");\n        }\n    }\n    /*\n    rep(i,0,n)if(i==n-5){\n        int x=l[i][sz],y=r[i][sz],ok=0;\n        cerr<<i<<\" \"<<x<<\" \"<<y<<\"\\n\";\n        rep(j,0,(1<<sz)){\n            k=mask^j;\n            cerr<<j<<\" \"<<dp[j]<<\",\"<<k<<\" \"<<f[k]<<\"\\n\";\n            if(dp[j]>=x-1&&f[k]<=y+1){ok=1;break;}\n        }\n        puts(ok?\"Y\":\"N\");\n    }//*/\n    //cerr<<clock()*1./CLOCKS_PER_SEC<<\"ms\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, b) for (int i = a; i <= b; ++i)\n#define PER(i, a, b) for (int i = a; i >= b; --i)\n#define RVC(i, S) for (int i = 0; i < S.size(); ++i)\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef vector<int> VI;\n \ninline int read(){\n    int x = 0, ch = getchar(), f = 1;\n    while (!isdigit(ch)){if (ch == '-') f = -1; ch = getchar();}\n    while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n    return x * f;\n}\n\nconst int N = 200005;\nint n, V, vi[20], pos[N], col[20][N], lb[20][N], rb[20][N];\nint dpL[N], dpR[N], vis[N];\n\nint main(){\n\tn = read(), V = read();\n\tREP(i, 1, n) pos[i] = read();\n\tfor (int i = V; i; i >>= 1)\n\t\tvi[++vi[0]] = i;\n\tvi[++vi[0]] = 0;\n\tREP(i, 1, vi[0]){\n\t\tint idx = 1;\n\t\tlb[i][1] = col[i][1] = 1;\n\t\tREP(j, 2, n){\n\t\t\tif (pos[j] - pos[j - 1] > vi[i]){\n\t\t\t\trb[i][idx] = j - 1;\n\t\t\t\tlb[i][++idx] = j;\n\t\t\t}\n\t\t\tcol[i][j] = idx;\n\t\t}\n\t\trb[i][idx] = n;\n\t\t// REP(j, 1, idx) debug(\"%d %d = [%d, %d]\\n\", vi[i], idx, lb[i][j], rb[i][j]);\n\t}\n\tint U = (1 << vi[0]) - 1;\n\t\n\tdpL[0] = 0;\n\tREP(i, 1, U) REP(j, 0, vi[0] - 1)\n\t\tif (i & (1 << j))\n\t\t\tdpL[i] = max(dpL[i], rb[j + 1][col[j + 1][dpL[i ^ (1 << j)] + 1]]);\n\n\tdpR[0] = n + 1;\n\tREP(i, 1, U){\n\t\tdpR[i] = n + 1;\n\t\tREP(j, 0, vi[0] - 1)\n\t\t\tif (i & (1 << j))\n\t\t\t\tdpR[i] = min(dpR[i], lb[j + 1][col[j + 1][dpR[i ^ (1 << j)] - 1]]);\n\t\t// debug(\"dpR[%d]= %d\\n\", i, dpR[i]);\n\t}\n\n\tREP(i, 1, U) if (dpL[i] == n){\n\t\tREP(i, 1, n) printf(\"Possible\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (int i = U - 1; i; i = (i - 1) & (U - 1)){\n\t\tint j = U - 1 - i;\n\t\t// cerr << dpL[i] << ' ' << dpR[j] << endl;\n\t\tif (col[1][dpL[i] + 1] == col[1][dpR[j] - 1])\n\t\t\t\tvis[col[1][dpL[i] + 1]] = 1;\n\t\tswap(i, j);\n\n\t\t// cerr << dpL[i] << ' ' << dpR[j] << endl;\n\t\tif (col[1][dpL[i] + 1] == col[1][dpR[j] - 1])\n\t\t\t\tvis[col[1][dpL[i] + 1]] = 1;\n\t\tswap(i, j);\n\t}\n\n\tREP(i, 1, n) if (vis[col[1][i]]) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int L = 20;\nconst int MAX = 2 * 1000 * 100 + 47;\n\nint V[L];\nint sz = 0;\nint N[L][MAX];\nint P[L][MAX];\nint X[MAX];\nint dpL[1 << L];\nint dpR[1 << L];\nint ANS[MAX];\nset<PII> S;\nint M[MAX];\n\nvoid print(int mask)\n{\n\twhile (mask)\n\t{\n\t\tif (mask & 1)\n\t\t{\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << \" \";\n\t\t}\n\n\t\tmask >>= 1;\n\t}\n}\n\n//#define DEBUG\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tint n, v;\n\tcin >> n >> v;\n\tFOR(i, 0, n) cin >> X[i];\n\n\tV[0] = v;\n\tFOR(i, 1, L)\n\t{\n\t\tV[i] = V[i - 1] / 2;\n\t\tif (V[i] == 0)\n\t\t{\n\t\t\tsz = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treverse(V, V + sz);\n\tFOR(k, 0, sz)\n\t{\n\t\tint v = V[k];\n\t\tN[k][n - 1] = n;\n\n\t\tRFOR(i, n - 1, 0)\n\t\t{\n\t\t\tif (abs(X[i + 1] - X[i]) > v)\n\t\t\t{\n\t\t\t\tN[k][i] = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tN[k][i] = N[k][i + 1];\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"N=\" << endl;\n\tFOR(k, 0, sz)\n\t{\n\t\tcout << V[k] << \": \";\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tcout << N[k][i] << \" \";\n\t\t}\n\n\t\tcout << endl;\n\t}\n#endif\n\n\tFOR(k, 0, sz)\n\t{\n\t\tint v = V[k];\n\t\tP[k][0] = -1;\n\t\tFOR(i, 1, n)\n\t\t{\n\t\t\tif (abs(X[i] - X[i - 1]) > v)\n\t\t\t{\n\t\t\t\tP[k][i] = i - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tP[k][i] = P[k][i - 1];\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"P=\" << endl;\n\tFOR(k, 0, sz)\n\t{\n\t\tcout << V[k] << \": \";\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tcout << P[k][i] << \" \";\n\t\t}\n\n\t\tcout << endl;\n\t}\n#endif\n\n\tsz--;\n\n\tdpL[0] = 0;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tint x = dpL[mask];\n\t\tFOR(k, 0, sz)\n\t\t{\n\t\t\tif (mask & (1 << k)) continue;\n\n\t\t\tdpL[mask | (1 << k)] = max(dpL[mask | (1 << k)], N[k][x]);\n\t\t}\n\t}\n\n#ifdef DEBUG\n\tcout << \"dpL\" << endl;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tprint(mask);\n\t\tcout << \" :\";\n\t\tcout << dpL[mask] << endl;\n\t}\n#endif\n\n\tFOR(i, 0, 1 << sz) dpR[i] = n;\n\tdpR[0] = n - 1;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tint x = dpR[mask];\n\t\tFOR(k, 0, sz)\n\t\t{\n\t\t\tif (mask & (1 << k)) continue;\n\n\t\t\tdpR[mask | (1 << k)] = min(dpR[mask | (1 << k)], P[k][x]);\n\t\t}\n\t}\n\n\n#ifdef DEBUG\n\tcout << \"dpR\" << endl;\n\tFOR(mask, 0, 1 << sz)\n\t{\n\t\tprint(mask);\n\t\tcout << \" :\";\n\t\tcout << dpR[mask] << endl;\n\t}\n#endif\n\n\tFOR(i, 0, n) M[i] = INF;\n\tFOR(maskL, 0, 1 << sz)\n\t{\n\t\tint maskR = ((1 << sz) - 1) ^ maskL;\n\t\tint l = dpL[maskL] - 1;\n\t\tint r = dpR[maskR] + 1;\n#ifdef DEBUG\n\t\tcout << \"!!\" << l << \" \" << r << endl;\n#endif\n\t\tif (l != -1) M[l] = min(M[l], r);\n\t}\n\n#ifdef DEBUG\n\tcout << \"M=\" << endl;\n\tFOR(i, 0, n)\n\t{\n\t\tcout << M[i] << \" \";\n\t}\n\n\tcout << endl;\n#endif\n\n\tRFOR(i, n - 1, 0) M[i] = min(M[i + 1], M[i]);\n\t\n\tFOR(i, 0, n)\n\t{\n\t\tint l = P[sz][i] + 1;\n\t\tint r = N[sz][i] - 1;\n\t\tif (S.find(MP(l, r)) != S.end()) continue;\n\t\tS.insert(MP(l, r));\n\n\t\tif (M[max(l - 1, 0)] <= r + 1)\n\t\t{\n\t\t\tFOR(k, l, r + 1) ANS[k] = 1;\n\t\t}\n\t}\n\n\tFOR(i, 0, n)\n\t{\n\t\tif (ANS[i])\n\t\t{\n\t\t\tcout << \"Possible\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcout << \"Impossible\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\nint const N=2e5+10;\nint const S=1<<19;\nint n,V;\nlint d[N];\nint logV,a[25][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n    }\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&d[i]),d[i-1]=d[i]-d[i-1];\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++) printf(\"Impossible\\n\");\n        return 0;\n    }\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=0,f2[s]=n+1;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1 && f2[U-s-1]-1<=to) f=true;\n        if(f) for(int j=fr;j<=to;j++) printf(\"Possible\\n\");\n        else for(int j=fr;j<=to;j++) printf(\"Impossible\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=2e5+5;\nint n,m;\nint V,x[maxn],R[maxn][25],L[maxn][25];\nint S1[maxn],S2[maxn];\nint minL[maxn];\nint main(){\n\tread(n);read(V);\n\trep(i,1,n)read(x[i]);\n\twhile((1<<m)<=V)m++;m++;\n\trep2(i,0,m){\n\t\tR[n+1][i]=n;\n\t\tper(j,n,1)\n\t\t\tif(x[j+1]-x[j]<=(V>>i))R[j][i]=R[j+1][i];\n\t\t\telse R[j][i]=j;\n\t\tL[0][i]=1;\n\t\trep(j,1,n)\n\t\t\tif(x[j]-x[j-1]<=(V>>i))L[j][i]=L[j-1][i];\n\t\t\telse L[j][i]=j;\n\t}\n\trep2(i,0,1<<m)S2[i]=n+1;\n\trep2(i,1,1<<m)rep2(j,0,m)if(i>>j&1){\n\t\tS1[i]=max(S1[i],R[S1[i^(1<<j)]+1][j]);\n\t\tS2[i]=min(S2[i],L[S2[i^(1<<j)]-1][j]);\n\t}\n\trep(i,0,n)minL[i]=n+2;\n\trep2(i,0,1<<m)if(!(i&1))minL[S1[i]]=min(minL[S1[i]],S2[((1<<m)-1)^i^1]);\n\tper(i,n-1,0)minL[i]=min(minL[i],minL[i+1]);\n\trep(i,1,n){\n\t\tif(minL[L[i][0]-1]<=R[i][0]+1)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint nxt[20][202020];\nint bef[20][202020];\nint dp1[402020], dp2[402020];\nint d[202020];\nint ans[202020];\nint main()\n{\n\tint num, gen;\n\tscanf(\"%d%d\", &num, &gen);\n\td[0] = -1010101010, d[num + 1] = 1010101010;\n\tfor (int i = 1; i <= num; i++)scanf(\"%d\", &d[i]);\n\tint pt = 0;\n\tfor (;;)\n\t{\n\t\tint now = 0;\n\t\tfor (int i = 1; i <= num + 1; i++)\n\t\t{\n\t\t\tif (d[i] - d[i - 1] > gen)now = i - 1;\n\t\t\tbef[pt][i] = now;\n\t\t}\n\t\tbef[pt][0] = 0;\n\t\tnow = num + 1;\n\t\tfor (int i = num; i >= 0; i--)\n\t\t{\n\t\t\tif (d[i + 1] - d[i] > gen)now = i + 1;\n\t\t\tnxt[pt][i] = now;\n\t\t}\n\t\tnxt[pt][num + 1] = num + 1;\n\t\tpt++;\n\t\tif (gen == 0)break;\n\t\tgen /= 2;\n\t}\n\t//for (int i = 0; i <= num + 1; i++)printf(\"%d %d\\n\", nxt[0][i], bef[0][i]);\n\tfill(dp1, dp1 + (1 << pt), 1);\n\tfor (int p = 0; p < (1 << pt); p++)\n\t{\n\t\tfor (int i = 0; i < pt; i++)\n\t\t{\n\t\t\tif (p&(1 << i))continue;\n\t\t\tdp1[p + (1 << i)] = max(dp1[p + (1 << i)], nxt[i][dp1[p]]);\n\t\t}\n\t}\n\tfill(dp2, dp2 + (1 << pt), num);\n\tfor (int p = 0; p < (1 << pt); p++)\n\t{\n\t\tfor (int i = 0; i < pt; i++)\n\t\t{\n\t\t\tif (p&(1 << i))continue;\n\t\t\tdp2[p + (1 << i)] = min(dp2[p + (1 << i)], bef[i][dp2[p]]);\n\t\t}\n\t}\n\t//for (int i = 0; i < (1 << pt); i++)printf(\"%d %d\\n\", dp1[i], dp2[i]);\n\tfor (int p = 0; p < (1 << pt); p+=2)\n\t{\n\t\tint q = (1 << pt) - 2 - p;\n\t\tif (nxt[0][dp1[p]]>dp2[q])ans[dp1[p]] = 1;\n\t}\n\tint t = 0;\n\tfor (;;)\n\t{\n\t\tif (ans[t])\n\t\t{\n\t\t\tfor (int j = t; j < nxt[0][t]; j++)ans[j] = 1;\n\t\t\tt = nxt[0][t];\n\t\t}\n\t\telse t++;\n\t\tif (t == num + 1)break;\n\t}\n\tt = num + 1;\n\tfor (;;)\n\t{\n\t\tif (ans[t])\n\t\t{\n\t\t\tfor (int j = t; j > bef[0][t]; j--)ans[j] = 1;\n\t\t\tt = bef[0][t];\n\t\t}\n\t\telse t--;\n\t\tif (t == 0)break;\n\t}\n\tfor (int i = 1; i <= num; i++)printf(ans[i] ? \"Possible\\n\" : \"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define x first\n#define y second\n\nint n, v;\n\nint x[200010];\n\nint hn;\nint h[20];\nint gl[20][200010];\nint gr[20][200010];\n\nvoid in(){\n\tread(n, v);\n\tfor(int i=1; i<=n; ++i) read(x[i]);\n}\n\nvoid build(){\n\tint V = v;\n\tfor(;;++hn, V/=2){\n\t\th[hn] = V;\n\t\tfor(int i=1; i<=n;){\n\t\t\tint j;\n\t\t\tfor(j=i+1; j<=n && x[j]-x[j-1] <= V; ++j);\n \t\t\tfor(int k=i; k<j; ++k){\n\t\t\t\tgl[hn][k]=i;\n\t\t\t\tgr[hn][k]=j-1;\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t\tif(V == 0) break;\n\t}\n}\n\nint dpL[524288];\nint dpR[524288];\n\nvoid do_dp(){\n\tint M = (1<<hn);\n\tfor(int i=0; i<M; ++i){\n\t\tdpL[i] = 0;\n\t\tdpR[i] = n+1;\n\t\tfor(int j=1; j<=hn; ++j){\n\t\t\tint key = (1 << (j-1));\n\t\t\tif(i & key){\n\t\t\t\tint bl=dpL[i^key], br=dpR[i^key];\n\t\t\t\tdpL[i] = max(dpL[i], bl == n ? n : gr[j][bl+1]);\n\t\t\t\tdpR[i] = min(dpR[i], br == 1 ? 1 : gl[j][br-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool all_yes;\nbool yes[200010];\nvoid apply_gugan(int a, int b){\n\tif(a > b){\n\t\tall_yes = true;\n\t} else {\n\t\tif(gl[0][a] == gl[0][b]){\n\t\t\tyes[gl[0][a]]=1;\n\t\t}\n\t}\n}\n\nvoid Fill(){\n\tint M = (1<<hn);\n\tfor(int i=1; i<M; ++i){\n\t\tdpL[i] = max(dpL[i], dpL[i&(i-1)]);\n\t\tdpR[i] = min(dpR[i], dpR[i&(i-1)]);\n\t}\n\tfor(int i=0; i<M; ++i){\n\t\tint l=dpL[i]+1;\n\t\tint r=dpR[(M-1)^i]-1;\n\t\tapply_gugan(l, r);\n\t}\n}\n\nint main()\n{\n\tin(); build(); do_dp(); Fill();\n\tfor(int i=1; i<=n; ++i){\n\t\tputs(yes[gl[0][i]]?\"Possible\":\"Impossible\");\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 200010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;if(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\n\nint b[40],sz,a[N],c[N];\nint dp[1<<17],f[1<<17],l[N][20],r[N][20];\nint main(){\n    //freopen(\"A.in\",\"r\",stdin);\n    //freopen(\"A.out\",\"w\",stdout);\n    //cout<<setprecision(9)<<fixed;\n    //cerr<<setprecision(9)<<fixed;\n    int T,i,j,k,ca=0,m,K,n;\n    scanf(\"%d%d\",&n,&m);\n    K=m;sz=0;\n    while(K)b[sz++]=K,K>>=1;\n    b[sz++]=0;\n    swap(b[0],b[sz-1]);\n    rep(i,0,n)scanf(\"%d\",&a[i]);\n    rep(k,0,sz){\n        K=b[k];\n        //cerr<<k<<\" \"<<K<<\"\\n\";\n        l[0][k]=0;\n        rep(i,1,n){\n            if(K>=a[i]-a[i-1])l[i][k]=l[i-1][k];\n            else l[i][k]=i;\n        }\n        r[n-1][k]=n-1;\n        per(i,0,n-1){\n            if(K>=a[i+1]-a[i])r[i][k]=r[i+1][k];\n            else r[i][k]=i;\n        }\n    }\n    sz--;\n    memset(dp,-1,sizeof(dp));\n    dp[0]=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Max(dp[i|1<<j],x);\n            if(x+1<n)Max(dp[i|1<<j],r[x+1][j]);\n        }\n    }\n    per(i,0,(1<<sz))f[i]=n;\n    f[0]=n-1;\n    rep(i,0,(1<<sz)){\n        int x=f[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Min(f[i|1<<j],x);\n            if(x)Min(f[i|1<<j],l[x-1][j]);\n        }\n    }\n    int mask=(1<<sz)-1,flag=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i],y=f[mask^i];\n        if(x<0||y>=n)continue;\n        k=r[x+1][sz];\n        j=l[y-1][sz];\n        if(j<=x+1&&k>=y-1)c[j]++,c[k+1]--;\n    }\n    {\n        rep(i,1,n)c[i]+=c[i-1];\n        rep(i,0,n){\n            if(c[i])puts(\"Possible\");\n            else puts(\"Impossible\");\n        }\n    }\n    /*\n    rep(i,0,n)if(i==n-5){\n        int x=l[i][sz],y=r[i][sz],ok=0;\n        cerr<<i<<\" \"<<x<<\" \"<<y<<\"\\n\";\n        rep(j,0,(1<<sz)){\n            k=mask^j;\n            cerr<<j<<\" \"<<dp[j]<<\",\"<<k<<\" \"<<f[k]<<\"\\n\";\n            if(dp[j]>=x-1&&f[k]<=y+1){ok=1;break;}\n        }\n        puts(ok?\"Y\":\"N\");\n    }//*/\n    //cerr<<clock()*1./CLOCKS_PER_SEC<<\"ms\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define F(i,j,n) for(register int i=j;i<=n;i++)\n#define D(i,j,n) for(register int i=j;i>=n;i--)\n#define ll long long\n#define N 200010\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;int f;\n\tchar gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void gi(I&x){\n\t\tfor(f=1,c=gc();c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n};\nusing io::gi;\nusing io::gc;\nint f[N],s[20],r[20][N],l[20][N],x[N],p[1<<20],q[1<<20],n,v,d,m,ans[N];\nint main(){\n\tgi(n);gi(v);\n\tF(i,1,n)gi(x[i]);\n\tD(i,n,2)x[i]-=x[i-1];\n\tx[1]=v+1;x[n+1]=v+1;\n\tfor(d=0;v;d++,v/=2){\n\t\tD(i,n,1)r[d][i]=(x[i+1]>v)?i:r[d][i+1];\n\t\tF(i,1,n)l[d][i]=(x[i]>v)?i:l[d][i-1];\n\t}\n\tm=(1<<d)-1;d--;\n\tF(i,0,m){\n\t\tq[i]=n;p[i]=1; \n\t\tF(j,0,d)if((i>>j)&1)p[i]=max(p[i],r[j][min(n,p[i^(1<<j)]+1)]);\n\t\tF(j,0,d)if((i>>j)&1)q[i]=min(q[i],l[j][max(1,q[i^(1<<j)]-1)]);\n\t}\n//\tF(i,0,m)printf(\"%d %d\\n\",p[i],q[i]);\n\tm--;\n\tF(i,1,n)if(l[0][i]==i){\n\t\tfor(int j=m;j;j=m&(j-1))if(p[j]>=i-1&&q[m^j]<=r[0][i]+1)ans[i]=1;\n\t\tif(p[0]>=i-1&&q[m]<=r[0][i]+1)ans[i]=1;\n\t}\n\telse ans[i]=ans[l[0][i]];\n\tF(i,1,n)puts(ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pb2 pop_back\n#define pf push_front\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define rep(k,i,j) for(int k = (int)i;k<(int) j;k++)\n#define repd(k,i,j) for(int k = i;k>=(int)j;k--)\n#define ll long long\n#define pq priority_queue\n\nint dirx[8] = {0,1,0,-1,1,1,-1,-1};\nint diry[8] = {1,0,-1,0,1,-1,1,-1};\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e16;\nconst double EPS = 1e-6;\n\nusing namespace std;\n\nconst int maxn = 3e5+5;\n\nint n,v;\nint loc[maxn];\n\nint jump[maxn][20],m;\n\nint dp[maxn];\n\nint ch[maxn];\n\nint in_q[maxn];\n\nqueue<int> q;\nint solve(){\n\tmemset(dp,-1,sizeof dp);\n\tmemset(in_q,0,sizeof in_q);\n\t\n\tq.push(1);\n\tdp[1] = 0;\n\tin_q[1] = 1;\n\t\n\twhile(q.size()){\n\t\tint mask = q.front();\n\t\tint a = ch[dp[mask]];\n\t\t\n\t\tq.pop();\n\t\tin_q[mask] = 0;\n\t\t\n\t\tif(a==n)return 1;\n\t\trep(k,0,m)if(((1<<k)&mask)==0){\n\t\t\tint b = ch[jump[a][k]];\n\t\t\tint maskb = (mask|(1<<k));\n\t\t\t\n\t\t\tif(dp[maskb]<b){\n\t\t\t\tdp[maskb] = b;\n\t\t\t\tif(!in_q[maskb])q.push(maskb),in_q[maskb] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\t\n\trep(k,0,n)scanf(\"%d\",&loc[k]);\n\t\n\t\n\tfor(;v>=0;v/=2){\n\t\trep(k,0,n){\n\t\t\tint i = k;\n\t\t\twhile(i<n){\n\t\t\t\tif(i<n-1 && loc[i+1]-loc[i]<=v){\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\twhile(k<=i)jump[k++][m] = i+1;\n\t\t\tk = i;\n\t\t}\n\t\tprintf(\"%d \\n\",v);\n\t\tm++;\n\t\tif(v==0)break;\n\t}\n\t\n\tif(m>=20)return 0;\n\trep(k,0,m){\n\t\t//rep(i,0,n)printf(\"%d \",jump[i][k]);line;\n\t\t\n\t}\n\trep(k,0,maxn)ch[k] = k;\n\t\n\tint hit = 0;\n\trep(k,0,n){\n\t\tif(hit>18){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint nxt = jump[k][0];\n\t\t\n\t\thit++;\n\t\tch[k] = nxt;\n\t\tint ret = solve();\n\t\tch[k] = k;\n\t\t\n\t\twhile(k<nxt)printf(\"%s\\n\",ret?\"Possible\":\"Impossible\"),k++;\n\t\tk = nxt-1;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\nint b[20][200005];\nint n;\nint a[200005];\nint v,vt[20],len[20];\nvector<int> child[20][200005];\npair<int,int> bj[20][200005];\nmap<vector<int>,bool> m[20];  \nvector<int> tv;int p;\nstring ans[200005];\nvector<int> cl(vector<int> state,int bh,int cs){\n\tvector<int> re;re.clear();re.push_back(0);\n\tfor(int i=1;i<state.size();i++){\n\t\tif(i!=bh){\n\t\t\tfor(int j=0;j<child[cs][state[i]].size();j++){\n\t\t\t\tre.push_back(child[cs][state[i]][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn re;\n}\nbool dfs(int e,vector<int> state){\n\tif(state.size()==1)return 1;\n\tif(state.size()>p-e+2)return 0;\n\tif(e==p)return 1;\n\tif(m[e].count(state))return m[e][state];\n\tfor(int i=1;i<state.size();i++){\n\t\tif(e==0){\n\t\t\tif(dfs(e+1,cl(state,i,e))){\n\t\t\t\tans[i]=\"Possible\";\n\t\t\t}else ans[i]=\"Impossible\";\n\t\t}else{\n\t\t\tif(dfs(e+1,cl(state,i,e))){\n\t\t\t\treturn m[e][state]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn m[e][state]=0;\n}\nint main(){\n\tcin>>n>>v;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tvt[0]=v;\n\ttv.push_back(0);\n\tfor(int i=1;vt[i-1]!=0;i++){\n\t\tvt[i]=(vt[i-1]>>1);\n\t\tp=i;\n\t}\n\tfor(int i=0;i<=p;i++){\n\t\tb[i][1]=1;\n\t\tbj[i][1].F=1;\n\t\tfor(int j=2;j<=n;j++){\n\t\t\tif(a[j]-a[j-1]>vt[i]){\n\t\t\t\tb[i][j]=b[i][j-1]+1;\n\t\t\t\tbj[i][b[i][j-1]].S=j-1;\n\t\t\t\tbj[i][b[i][j]].F=j;\n\t\t\t}else b[i][j]=b[i][j-1];\n\t\t}\n\t\tlen[i]=b[i][n];\n\t\tbj[i][len[i]].S=n;\n\t}\n\tfor(int i=0;i<p;i++){\n\t\tint qd=1;\n\t\tfor(int j=1;j<=len[i];j++){\n\t\t\twhile(qd<=len[i+1]&&bj[i][j].F<=bj[i+1][qd].F&&bj[i][j].S>=bj[i+1][qd].S){\n\t\t\t\tchild[i][j].push_back(qd);qd++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=len[0];i++)tv.push_back(i);\n\tdfs(0,tv);\n\tfor(int i=1;i<=n;i++){\n\t\tcout<<ans[b[0][i]]<<'\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 2e5 + 10 , LG = 19;\nint n , V , x[N] , toR[LG][N] , toL[LG][N] , len;\nint fL[1<<LG] , fR[1<<LG];\n\nvoid prepare(int toR[][N] , int *fL , const vi&x) {\n  int V = ::V;\n  len = 0;\n  while(V >= 0) {\n    toR[len][n]=toR[len][n+1]=n;\n    per(i,1,n) toR[len][i]=abs(x[i]-x[i+1])<=V?toR[len][i+1]:i;\n    len++;\n    if(V==0) break;\n    V >>= 1;\n  }\n  rep(i,0,1<<len) fL[i]=0;\n  rep(i,0,1<<len) {\n    rep(j,0,len) if(~i>>j&1)\n      fL[i|1<<j]=max(fL[i|1<<j],toR[j][fL[i]+1]);\n  }\n}\n\nint main(){\n  scanf(\"%d%d\",&n,&V);\n  rep(i,1,n+1) scanf(\"%d\",x+i);\n  vi v(x,x+1+n);\n  prepare(toR , fL , v);\n  reverse(v.begin()+1,v.begin()+1+n);\n  prepare(toL , fR , v);\n  vector<pii> seg;\n  int full=(1<<len)-1-1;\n  rep(i,0,1<<len) if(~i&1) {\n    seg.pb(mp(-fR[i],fL[full^i]));\n  }\n  sort(all(seg));\n  int cur=0,leftmost=-1;\n  rep(i,1,n+1) {\n    int left=n+1-toL[0][n+1-i];\n    int right=toR[0][i];\n    while(cur<sz(seg)&&-seg[cur].fi+right>=n) {\n      leftmost=max(leftmost,seg[cur].se);\n      cur++;\n    }\n    if(leftmost+1>=left) puts(\"Possible\");\n    else puts(\"Impossible\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 200005\n#define MAXM 18\n#define MAXK (1<<MAXM)\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\n#define prev daksiisaas\n#define next aijdkjsaod\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\nint N,V,x[MAXN];\nvector<int> v;\nint prev[MAXN][MAXM],next[MAXN][MAXM];\nint predp[MAXK],sufdp[MAXK];\nint mini[MAXN];\nint main()\n{\n    scanf(\"%d%d\",&N,&V);\n    for(int i=1;i<=N;i++) scanf(\"%d\",&x[i]);\n    int dummy=V;\n    while(dummy)\n    {\n        v.push_back(dummy);\n        dummy/=2;\n    }\n    v.push_back(0);\n    reverse(v.begin(),v.end());\n    int sz=(int)v.size();\n    for(int i=(int)v.size()-1;i>=0;i--) next[N][i]=N;\n    for(int i=N-1;i>=0;i--)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i+1]-x[i]>v[j]) next[i][j]=i; else next[i][j]=next[i+1][j];\n    for(int i=(int)v.size()-1;i>=0;i--) prev[1][i]=1;\n    for(int i=2;i<=N;i++)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i]-x[i-1]>v[j]) prev[i][j]=i; else prev[i][j]=prev[i-1][j];\n    //for(int i=1;i<=N;i++) printf(\"%d %d %d %d\\n\",prev[i][1],prev[i][2],next[i][1],next[i][2]);\n    memset(predp,0,sizeof(predp));\n    for(int i=0;i<sz;i++) predp[(1<<i)]=next[1][i];\n    for(int mask=1;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            predp[mask^(1<<j)]=max(predp[mask^(1<<j)],next[min(predp[mask]+1,N)][j]);\n        }\n    }\n    for(int mask=1;mask<(1<<sz);mask++) sufdp[mask]=N;\n    for(int i=0;i<sz;i++) sufdp[(1<<i)]=prev[N][i];\n    for(int mask=1;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            sufdp[mask^(1<<j)]=min(sufdp[mask^(1<<j)],prev[max(sufdp[mask]-1,1)][j]);\n        }\n    }\n    for(int i=0;i<=N+1;i++) mini[i]=N+2; \n    for(int mask=0;mask<(1<<(sz-1));mask++)\n    {\n        int dmask=(1<<(sz-1))-1-mask;\n        int l,r;\n        if(mask==0) l=0; else l=predp[mask];\n        if(dmask==0) r=N+1; else r=sufdp[dmask];\n        mini[l]=min(mini[l],r);\n    }\n    for(int i=N;i>=0;i--) mini[i]=min(mini[i],mini[i+1]);\n    for(int i=1;i<=N;i++)\n    {\n        int l=prev[i][sz-1],r=next[i][sz-1];\n        if(l==1&&r==N) {puts(\"Possible\"); continue;}\n        //printf(\"%d %d\\n\",l,r);\n        if(mini[l-1]<=r+1) puts(\"Possible\"); else puts(\"Impossible\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,v;\n  cin>>n>>v;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n\n  vector<vector<Int> > dpl,dpr;\n  while(1){\n    {\n      vector<Int> dp(n);\n      dp.back()=n;\n      for(Int i=n-2;i>=0;i--){\n\tif(x[i+1]-x[i]<=v) dp[i]=dp[i+1];\n\telse dp[i]=i+1;\n      }\n      dpl.emplace_back(dp);\n    }\n    {\n      vector<Int> dp(n);\n      dp.front()=-1;\n      for(Int i=1;i<n;i++){\n\tif(x[i]-x[i-1]<=v) dp[i]=dp[i-1];\n\telse dp[i]=i-1;\n      }\n      dpr.emplace_back(dp);\n    }\n    if(!v) break;\n    v>>=1;\n  }\n\n  Int k=dpl.size();\n  vector<Int> dp(1<<k,0);\n  vector<Int> pd(1<<k,n-1);\n  \n  for(Int b=0;b<(1<<k);b++){\n    for(Int i=0;i<k;i++){\n      if((b>>i)&1) continue;\n      chmax(dp[b|(1<<i)],(dp[b]<n?dpl[i][dp[b]]:n));\n      chmin(pd[b|(1<<i)],(~pd[b]?dpr[i][pd[b]]:-1));\n    }\n  }\n\n  vector<Int> ans(n+1);\n  \n  \n  for(Int b=0;b<(1<<k);b+=2){\n    Int a=((1<<k)-2)^b;\n    Int c=dp[a]<n?dpl[0][dp[a]]:n;\n    if(pd[b]>=c) continue;\n    ans[dp[a]]++;\n    ans[c]--;\n    continue;\n    cout<<a<<\" \"<<b<<endl;\n    cout<<dp[a]<<\" \"<<pd[b]<<\" \"<<c<<endl;\n    cout<<endl;\n  }\n  \n  \n  for(Int i=0;i<n;i++){\n    cout<<(ans[i]?\"Possible\":\"Impossible\")<<endl;\n    ans[i+1]+=ans[i];\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 200010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;if(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\n\nint b[40],sz,a[N],c[N];\nint dp[1<<18],f[1<<18],l[N][20],r[N][20];\nint main(){\n    //freopen(\"A.in\",\"r\",stdin);\n    //freopen(\"A.out\",\"w\",stdout);\n    //cout<<setprecision(9)<<fixed;\n    //cerr<<setprecision(9)<<fixed;\n    int T,i,j,k,ca=0,m,K,n;\n    scanf(\"%d%d\",&n,&m);\n    K=m;sz=0;\n    while(K)b[sz++]=K,K>>=1;\n    DBG(sz)\n    b[sz++]=0;\n    swap(b[0],b[sz-1]);\n    rep(i,0,n)scanf(\"%d\",&a[i]);\n    rep(k,0,sz){\n        K=b[k];\n        //cerr<<k<<\" \"<<K<<\"\\n\";\n        l[0][k]=0;\n        rep(i,1,n){\n            if(K>=a[i]-a[i-1])l[i][k]=l[i-1][k];\n            else l[i][k]=i;\n        }\n        r[n-1][k]=n-1;\n        per(i,0,n-1){\n            if(K>=a[i+1]-a[i])r[i][k]=r[i+1][k];\n            else r[i][k]=i;\n        }\n    }\n    sz--;\n    memset(dp,-1,sizeof(dp));\n    rep(i,0,(1<<sz)){\n        int x=dp[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Max(dp[i|1<<j],x);\n            if(x+1<n)Max(dp[i|1<<j],r[x+1][j]);\n        }\n    }\n    per(i,0,(1<<sz))f[i]=n;\n    rep(i,0,(1<<sz)){\n        int x=f[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Min(f[i|1<<j],x);\n            if(x)Min(f[i|1<<j],l[x-1][j]);\n        }\n    }\n    int mask=(1<<sz)-1,flag=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i],y=f[mask^i];\n        if(y<=x+1){\n            flag=1;break;\n        }\n        k=r[x+1][sz];\n        j=l[y-1][sz];\n        if(j<=x+1&&k>=y-1)c[j]++,c[k+1]--;\n    }\n    \n    if(flag){\n        rep(i,0,n)puts(\"Possible\");\n    }\n    else\n    {\n        rep(i,1,n)c[i]+=c[i-1];\n        rep(i,0,n){\n            if(c[i])puts(\"Possible\");\n            else puts(\"Impossible\");\n        }\n    }//*/\n    /*\n    rep(i,0,n){\n        int x=l[i][sz],y=r[i][sz],ok=0;\n        //cerr<<i<<\" \"<<x<<\" \"<<y<<\"\\n\";\n        rep(j,0,(1<<sz)){\n            k=mask^j;\n            //cerr<<j<<\" \"<<dp[j]<<\",\"<<k<<\" \"<<f[k]<<\"\\n\";\n            if(dp[j]>=x-1&&f[k]<=y+1){ok=1;break;}\n        }\n        puts(ok?\"Possible\":\"Impossible\");\n    }//*/\n    //cerr<<clock()*1./CLOCKS_PER_SEC<<\"ms\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing std::max;\ninline void umx(int &a,int b){a=max(a,b);}\nusing std::min;\ninline void umn(int &a,int b){a=min(a,b);}\nconst int MAXN=2e5+5,MAXS=3e5+5;\n \nint n,V,K,v[MAXN];int na[MAXN];\nint L[MAXN][20],R[MAXN][20];\nint f[MAXS],g[MAXS];\nint seq[MAXN];\n \nint main()\n{\n\tint i,k,x;scanf(\"%d%d\",&n,&V);\n\tfor(i=1;i<=n;i++) scanf(\"%d\",na+i);\n \n\tv[0]=V;while(v[K]) v[++K]=v[K-1]>>1;\n \n\tfor(k=0;k<=K;k++)\n\t{\n\t\tfor(i=x=1;i<=n;i++)\n\t\t\tL[i][k]=x=(i>1&&na[i]-na[i-1]>v[k])?i:x;\n\t\tfor(i=x=n;i;i--)\n\t\t\tR[i][k]=x=(i<n&&na[i+1]-na[i]>v[k])?i:x;\n\t\tR[n+1][k]=n+1;\n\t}\n \n\tstd::fill(g,g+(1<<K),n+1);\n\tfor(int S=1;S<1<<K;S++)\n\t\tfor(i=1;i<=K;i++)\n\t\t\tif((S>>i-1)&1)\n\t\t\t\tumx(f[S],R[f[S^(1<<i-1)]+1][i]),\n\t\t\t\tumn(g[S],L[g[S^(1<<i-1)]-1][i]);\n \n\tfor(int S=0,msk=(1<<K)-1;S<1<<K;S++)\n\t{\n\t\tint l=L[g[S]-1][0],r=R[f[msk^S]+1][0];\n\t\tif(l<=r) seq[l]++,seq[r+1]--;\n\t}\n \n\tfor(i=1;i<=n;i++) seq[i]+=seq[i-1];\n\tfor(i=1;i<=n;i++) puts(seq[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\ninline int rnd(int x){\n\treturn rand()%x;\n}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=20,N=1<<M,inf=1e9+3e5;\nint n,v,gao,f[1<<M],g[1<<M],x[N],lst[M][N],nxt[M][N],tong[N];\nint main(){\n\tn=read(); v=read(); x[0]=-inf; x[n+1]=inf;\n\tfor(int i=1;i<=n;i++)x[i]=read();\n\tfor(int i=0;;i++){\n\t\tint dali=v>>i; gao=i; nxt[i][n+1]=n; lst[i][0]=1;\n\t\tfor(int j=1;j<=n;j++)if(x[j]-x[j-1]<=dali)lst[i][j]=lst[i][j-1]; else lst[i][j]=j;\n\t\tfor(int j=n;j;j--)if(x[j+1]-x[j]<=dali)nxt[i][j]=nxt[i][j+1]; else nxt[i][j]=j;\n\t\tif((v>>i)==0)break;\n\t}\n\tf[0]=0; g[0]=n+1; \n\tfor(int i=1;i<(1<<gao);i++){\n\t\tf[i]=0; g[i]=n+1;\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)f[i]=max(f[i],nxt[j+1][f[i^(1<<j)]+1]);\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)g[i]=min(g[i],lst[j+1][g[i^(1<<j)]-1]);\n\t}\n\tfor(int i=0;i<=n+1;i++)tong[i]=-1;\n\tfor(int i=0;i<(1<<gao);i++){\n\t\tint l=f[i],r=g[((1<<gao)-1)^i];\n\t\ttong[r]=max(tong[r],l);\n\t}\n\tfor(int i=1;i<=n;i++)tong[i]=max(tong[i],tong[i-1]);\n\tfor(int i=1;i<=n;i++){\n\t\tint l=lst[0][i],r=nxt[0][i];\n\t\tputs(tong[r+1]>=l-1?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 4e05 + 10;\nconst int MAXL = 20 + 5;\n\nint N, V, lgv = 0;\nint a[MAXN];\nint sec[MAXN]= {0};\n\nint extl[MAXN][MAXL]= {0}, extr[MAXN][MAXL]= {0};\nint f[2][MAXN]= {0};\nbool answer[MAXN]= {false};\nvoid work (int p, int l, int r) {\n\tint n = lgv - 1;\n\tint limit = (1 << n) - 1;\n\tf[p][0] = l - 1;\n\tfor (int state = 1; state <= limit; state ++) {\n\t\tf[p][state] = l - 1;\n\t\tfor (int j = 1; j <= n; j ++)\n\t\t\tif (state & (1 << (j - 1))) {\n\t\t\t\tint pre = f[p][state ^ (1 << (j - 1))];\n\t\t\t\tf[p][state] = max (f[p][state], f[p][state ^ (1 << (j - 1))]);\n\t\t\t\tf[p][state] = max (f[p][state], extr[pre + 1][j]);\n\t\t\t}\n\t}\n}\nvoid solve () {\n\tint n = lgv - 1;\n\tint cnt = 0;\n\tfor (int i = 1; i <= N; i ++) {\n\t\tif (extl[i][lgv] == extl[i - 1][lgv] && extr[i][lgv] == extr[i - 1][lgv]) {\n\t\t\tanswer[i] = answer[i - 1];\n\t\t\tcontinue;\n\t\t}\n\t\tcnt ++;\n\t\tif (cnt > lgv) {\n\t\t\tfor (int j = 1; j <= N; j ++) answer[j] = false;\n\t\t\treturn ;\n\t\t}\n\t\tint pl = extl[i][lgv], pr = extr[i][lgv];\n\t\tif (pl != 1) work (0, 1, pl - 1);\n\t\tif (pr != N) work (1, pr + 1, N);\n\t\tint limit = (1 << n) - 1;\n\t\tif (pl == 1 && pr == N) answer[i] = true;\n\t\telse if (pl == 1) answer[i] = f[1][limit] >= N;\n\t\telse if (pr == N) answer[i] = f[0][limit] >= pl - 1;\n\t\telse {\n\t\t\tfor (int state = 1; state <= limit; state ++)\n\t\t\t\tif (f[0][state] >= pl - 1 && f[1][limit ^ state] >= N) {\n\t\t\t\t\tanswer[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint getnum () {\n\tint num = 0;\n\tchar ch = getchar ();\n\tbool isneg = false;\n\n\twhile (! isdigit (ch)) {\n\t\tif (ch == '-') isneg = true;\n\t\tch = getchar ();\n\t}\n\twhile (isdigit (ch))\n\t\tnum = (num << 3) + (num << 1) + ch - '0', ch = getchar ();\n\n\treturn isneg ? - num : num;\n}\n\nint main () {\n\t// freopen (\"Input.txt\", \"r\", stdin);\n\t// freopen (\"Output.txt\", \"w\", stdout);\n\n\tN = getnum (), V = getnum ();\n\tfor (int i = 1; i <= N; i ++)\n\t\ta[i] = getnum ();\n\tfor (int s = V; s > 0; s >>= 1)\n\t\tsec[++ lgv] = s;\n\tsec[++ lgv] = 0;\n\treverse (sec + 1, sec + lgv + 1);\n\tfor (int l = 1; l <= lgv; l ++) {\n\t\tfor (int i = 1; i <= N; i ++) {\n\t\t\tif (i == 1) extl[i][l] = 1;\n\t\t\telse extl[i][l] = a[i] - a[i - 1] <= sec[l] ? extl[i - 1][l] : i;\n\t\t}\n\t\tfor (int i = N; i >= 1; i --) {\n\t\t\tif (i == N) extr[i][l] = N;\n\t\t\telse extr[i][l] = a[i + 1] - a[i] <= sec[l] ? extr[i + 1][l] : i;\n\t\t}\n\t}\n\t/*for (int l = 1; l <= lgv; l ++) {\n\t\tcout << \"now: \" << sec[l] << endl;\n\t\tfor (int i = 1; i <= N; i ++)\n\t\t\tcout << extl[i][l] << ' ' << extr[i][l] << endl;\n\t}*/\n\tsolve ();\n\tfor (int i = 1; i <= N; i ++)\n\t\tanswer[i] ? puts (\"Possible\") : puts (\"Impossible\");\n\n\treturn 0;\n}\n\n/*\n3 2\n1 3 6\n*/\n\n/*\n7 2\n-10 -4 -2 0 2 4 10\n*/\n\n/*\n16 19\n-49 -48 -33 -30 -21 -14 0 15 19 23 44 52 80 81 82 84\n*/"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1009LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> ii;\ntypedef pair<ii, ii> i4;\n \nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n\n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nconst int N = 200005;\nint n, arr[N], sz, V, next_right[20][N], next_left[20][N];\nint DP_left[1<<20], DP_right[1<<20];\nvector<int> steps;\n\nint dp_left(int mask){\n    int &ans = DP_left[mask];\n    if(ans != -1)   return ans;\n    ans = 1;\n    for(int i=0;i<sz;i++)\n        if((mask >> i) & 1)\n            ans = max(ans, next_right[i][dp_left(mask^(1<<i))+1]);\n    return ans;\n}\n\nint dp_right(int mask){\n    int &ans = DP_right[mask];\n    if(ans != -1)   return ans;\n    ans = n+1;\n    for(int i=0;i<sz;i++)\n        if((mask >> i) & 1)\n            ans = min(ans, next_left[i][dp_right(mask^(1<<i))-1]);\n    return ans;\n}\n\n\n\nbool possible(int l, int r){\n    int mask = (1<<sz)-2; \n    for(int i=mask;i>=0;i=(i-1)&mask){\n// cout<<i<<\" \"<<(mask^i)<<\" \"<<mask<<\" \"<<dp_left(i)<<\" \"<<dp_right(mask^i)<<endl;\n        if((dp_left(i) >= l-1) && (dp_right(mask^i) <= r+1))    return true;\n        if(i == 0)  break;\n    }\n    return false;\n}\n\n\nint main(){\n \n    // ios_base::sync_with_stdio(0);\n    // cin.tie(0);\n\n    scanf(\"%d%d\", &n, &V);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\", &arr[i]);\n\n    while(V){\n        steps.pb(V);\n        V /= 2;\n    }\n    steps.pb(0);\n    sz = (int)steps.size();\n\n    for(int k=0;k<sz;k++){\n\n        next_right[k][n+1] = n+1;\n        next_right[k][n] = n;\n        for(int i=n-1;i>=1;i--)\n            if(arr[i+1]-arr[i] <= steps[k])\n                next_right[k][i] = next_right[k][i+1];\n            else\n                next_right[k][i] = i;\n        next_right[k][0] = next_right[k][1];\n\n        next_left[k][0] = 0;\n        next_left[k][1] = 1;\n        for(int i=2;i<=n;i++)\n            if(arr[i]-arr[i-1] <= steps[k])\n                next_left[k][i] = next_left[k][i-1];\n            else\n                next_left[k][i] = i;\n        next_left[k][n+1] = next_left[k][n];\n    }\n\n    int comps = 0, curr = 1;\n    while(curr <= n){\n        comps++;\n        curr = next_right[0][curr] + 1;\n    }\n\n    if(comps > sz+2){\n        for(int i=1;i<=n;i++)\n            printf(\"Impossible\\n\");\n        return 0;\n    }\n\n// cout<<\"steps: \";for(auto it : steps)    cout<<it<<\" \";cout<<endl;\n// cout<<\"next_right:\\n\";\n// for(int i=1;i<=n;i++){\n//     cout<<i<<\": \";for(int j=0;j<sz;j++) cout<<next_right[j][i]<<\" \";cout<<endl;\n// }cout<<endl;\n// cout<<\"next_left:\\n\";\n// for(int i=1;i<=n;i++){\n//     cout<<i<<\": \";for(int j=0;j<sz;j++) cout<<next_left[j][i]<<\" \";cout<<endl;\n// }cout<<endl;\n\n\n    memset(DP_left, -1, sizeof(DP_left));\n    memset(DP_right, -1, sizeof(DP_right));\n    curr = 1;\n    while(curr <= n){\n        if(possible(curr, next_right[0][curr])){\n            for(int i=curr;i<=next_right[0][curr];i++)\n                printf(\"Possible\\n\");\n        }\n        else{\n            for(int i=curr;i<=next_right[0][curr];i++)\n                printf(\"Impossible\\n\");\n        }\n        curr = next_right[0][curr]+1;\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/// a.cpp\n\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < __typeof(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < ll >\n# define pb push_back\n# define pdd pair < db , db >\ninline int readChar();\ntemplate <class T = int> inline T readInt();\ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x );\ninline void writeWord( const char *s );\n\n/** Read */\n\nstatic const int buf_size = 4096;\n\ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len)\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    if (pos == len)\n        return -1;\n    return buf[pos++];\n}\n\ninline int readChar() {\n    int c = getChar();\n    while (c <= 32)\n        c = getChar();\n    return c;\n}\n\ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n\n/** Write */\n\nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n\ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n\ntemplate <class T>\ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n\n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n\ninline void writeWord( const char *s ) {\n    while (*s)\n        writeChar(*s++);\n}\n\nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int RMQ[20][1 << 20];\n    static int Dp1[20][1 << 19];\n    static int Dp2[20][1 << 19];\n    int n,k;\n    n = readInt();\n    k = readInt();\n    static int s[1 << 20];\n    for (int i = 1;i <= n;++i)\n        s[i] = readInt();\n    for (int i = 1;i < n;++i)\n        RMQ[0][i] = s[i + 1] - s[i];\n    for (int t = 1;n >> t;++t)\n        for (int i = 1;i + (1 << t) <= n;++i)\n            RMQ[t][i] = max(RMQ[t - 1][i],RMQ[t - 1][i + (1 << (t - 1))]);\n    static int Log[1 << 20];\n    for (int i = 2;i < (1 << 20);++i)\n        Log[i] = Log[i / 2] + 1;\n    auto get = [&](int l,int r)\n    {\n        int lg = Log[r - l + 1];\n        return max(RMQ[lg][l],RMQ[lg][r - (1 << lg) + 1]);\n    };\n    static int D1[1 << 20];\n    static int D2[1 << 20];\n    int lg = Log[k] + 2;\n    const int N = 1 << lg;\n    for (int t = 0;t < lg;++t)\n    {\n        Dp1[t][1] = 0;\n        for (int i = 2;i <= n;++i)\n            if (s[i] - s[i - 1] <= (k >> t))\n                Dp1[t][i] = Dp1[t][i - 1];\n            else\n                Dp1[t][i] = i - 1;\n        Dp2[t][n] = Dp2[t][n + 1] = n + 1;\n        for (int i = n - 1;i;--i)\n            if (s[i + 1] - s[i] <= (k >> t))\n                Dp2[t][i] = Dp2[t][i + 1];\n            else\n                Dp2[t][i] = i + 1;\n    }\n    D1[0] = 0;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            if ((mask >> i) & 1)\n                smax(D1[mask],Dp2[i][D1[mask ^ (1 << i)] + 1] - 1);\n    for (int mask = 0;mask < N;++mask)\n        D2[mask] = n + 1;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            smin(D2[mask],Dp1[i][D2[mask ^ (1 << i)] - 1] + 1);\n    static int answer[1 << 20];\n    for (int mask1 = 0;mask1 < N;++mask1)\n        if (!(mask1 & 1))\n        {\n            int mask2 = (N - 1) ^ 1 ^ mask1;\n            const int l = D1[mask1];\n            const int r = D2[mask2];\n            if (l + 1 > r - 1)\n                answer[1]++,--answer[n + 1];\n            else\n            if (l + 1 == r - 1 || get(l + 1,r - 2) <= k)\n                ++answer[l + 1],--answer[r];\n        }\n    for (int i = 1;i <= n;++i)\n        answer[i] += answer[i - 1];\n    for (int i = 1;i <= n;++i)\n        if (answer[i])\n            PP;\n        else\n            II;\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, V, K;\nint X[200010], L[18][200010], R[18][200010];\nvector<int> P;\n\nint cc1[1 << 18];\nint dp1(int mask) {\n    if(mask == 0) return -1;\n    int &ret = cc1[mask];\n    if(ret != -1) return ret;\n    if(mask == 0) return ret = 0;\n\n    ret = -1;\n    for(int i = 0; i < K; i++) {\n        if(mask & (1 << i)) {\n            ret = max(ret, R[i][ dp1(mask - (1 << i)) + 1 ]);\n        }\n    }\n    return ret;\n}\nint cc2[1 << 18];\nint dp2(int mask) {\n    if(mask == 0) return N;\n    int &ret = cc2[mask];\n    if(ret != -1) return ret;\n\n    ret = N;\n    for(int i = 0; i < K; i++) {\n        if(mask & (1 << i)) {\n            ret = min(ret, L[i][ dp2(mask - (1 << i)) - 1 ]);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &V);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    P.push_back(V);\n    while(P.back()) {\n        int t = P.back() / 2;\n        P.push_back(t);\n    }\n    reverse(P.begin(), P.end());\n\n    K = P.size();\n\n    for(int i = 0; i < K; i++) {\n        int pos = 0;\n        for(int j = 0; j < N; j++) {\n            if(pos < j) pos = j;\n            while(pos < N - 1 && X[pos + 1] - X[pos] <= P[i]) pos++;\n            R[i][j] = pos;\n        }\n        pos = N - 1;\n        for(int j = N - 1; j >= 0; j--) {\n            if(pos > j) pos = j;\n            while(pos >= 1 && X[pos] - X[pos - 1] <= P[i]) pos--;\n            L[i][j] = pos;\n        }\n    }\n\n    memset(cc1, -1, sizeof(cc1));\n    memset(cc2, -1, sizeof(cc2));\n\n    if(dp1((1 << K) - 1) != N - 1) {\n        for(int i = 0; i < N; i++) {\n            printf(\"Impossible\\n\");\n        }\n        return 0;\n    }\n\n    int pos = 0;\n    while(pos < N) {\n        int nxt = R[K - 1][pos];\n\n        bool ok = false;\n        for(int i = 0; i < (1 << (K - 1)); i++) {\n            if(pos - 1 <= dp1(i) && dp2((1 << (K - 1)) - i) <= nxt + 1) {\n                ok = true;\n                break;\n            }\n        }\n        if(ok) {\n            for(int i = pos; i <= nxt; i++) {\n                printf(\"Possible\\n\");\n            }\n        }\n        else {\n            for(int i = pos; i <= nxt; i++) {\n                printf(\"Impossible\\n\");\n            }\n        }\n        pos = nxt + 1;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "const bool submit = 1;\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) if(!submit) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nbool B(int x,int i){return (x>>i)&1;}\nint N,V;\nconst int MN=200000;\nconst int MD=20;\nint D;\nint x_[MN];\nint d[MN-1];\nint xv2id[MN][MD];\n\nconst int MX=MN*MD;\nint id2v[MX];\nint id2l[MX];\nint id2r[MX];\nint I;\n\n\nbool ans[MN];\n\nint dp[1<<20];\nint main(){\n\tcin>>N>>V;\n\trep(i,N) cin>>x_[i];\n\trep(i,N-1) d[i]=x_[i+1]-x_[i];\n\trep(v,MD){\n\t\tint l=0;\n\t\trep(x,N){\n\t\t\tif(x==N-1 || d[x]>V){\n\t\t\t\tfor(int i=l;i<=x;i++) xv2id[i][v]=I;\n\t\t\t\tid2v[I]=v;\n\t\t\t\tid2l[I]=l;\n\t\t\t\tid2r[I]=x+1;\n\n\t\t\t\t// show(I);\n\t\t\t\t// show(v);\n\t\t\t\t// printf(\"(%d,%d]\\n\",l,x+1);\n\t\t\t\t// puts(\"\");\n\t\t\t\tI++;\n\t\t\t\tl=x+1;\n\t\t\t}\n\t\t}\n\t\tif(V==0){\n\t\t\tD=v+1;\n\t\t\tbreak;\n\t\t}\n\t\tV/=2;\n\t}\n\tint K = xv2id[N-1][0]+1;\n\n\tif(K>D){\n\t\trep(i,N){\n\t\t\tputs(\"Impossible\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\tshow(D);\n\tshow(K);\n\trep(elim,K){\n\t\trep(b,1<<D) dp[b]=0;\n\t\tbool ok=0;\n\t\trep(b,1<<D){\n\t\t\tint x = dp[b];\n\t\t\tif(x==N){\n\t\t\t\tok=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,D) if(!B(b,i)){\n\t\t\t\tint id = xv2id[x][i];\n\t\t\t\tif(i==0&&id!=elim) continue;\n\t\t\t\tint nx=max(x,id2r[id]);\n\t\t\t\tchmax(dp[b|(1<<i)],nx);\n\t\t\t}\n//\t\t\tprintf(\"dp[%d]=%d\\n\",b,dp[b]);\n\t\t}\n\t\tint l = id2l[elim];\n\t\tint r = id2r[elim];\n\t\tfor(int x=l;x<r;x++) ans[x]=ok;\n\t}\n\trep(i,N){\n\t\tif(ans[i]) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, V, K;\nint X[200010], L[22][200010], R[22][200010];\nvector<int> P;\n\nint cc1[1 << 22];\nint dp1(int mask) {\n    if(mask == 0) return -1;\n    int &ret = cc1[mask];\n    if(ret != -1) return ret;\n    if(mask == 0) return ret = 0;\n\n    ret = -1;\n    for(int i = 0; i < K; i++) {\n        if(mask & (1 << i)) {\n            ret = max(ret, (dp1(mask - (1 << i)) == N - 1? N - 1 : R[i][ dp1(mask - (1 << i)) + 1 ]));\n        }\n    }\n    return ret;\n}\nint cc2[1 << 22];\nint dp2(int mask) {\n    if(mask == 0) return N;\n    int &ret = cc2[mask];\n    if(ret != -1) return ret;\n\n    ret = N;\n    for(int i = 0; i < K; i++) {\n        if(mask & (1 << i)) {\n            ret = min(ret, (dp2(mask - (1 << i)) == 0? 0 : L[i][ dp2(mask - (1 << i)) - 1 ]));\n        }\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &V);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    P.push_back(V);\n    while(P.back()) {\n        int t = P.back() / 2;\n        P.push_back(t);\n    }\n    reverse(P.begin(), P.end());\n\n    K = P.size();\n\n    for(int i = 0; i < K; i++) {\n        int pos = 0;\n        for(int j = 0; j < N; j++) {\n            if(pos < j) pos = j;\n            while(pos < N - 1 && X[pos + 1] - X[pos] <= P[i]) pos++;\n            R[i][j] = pos;\n        }\n        pos = N - 1;\n        for(int j = N - 1; j >= 0; j--) {\n            if(pos > j) pos = j;\n            while(pos >= 1 && X[pos] - X[pos - 1] <= P[i]) pos--;\n            L[i][j] = pos;\n        }\n    }\n\n    memset(cc1, -1, sizeof(cc1));\n    memset(cc2, -1, sizeof(cc2));\n\n    if(dp1((1 << K) - 1) != N - 1) {\n        for(int i = 0; i < N; i++) {\n            printf(\"Impossible\\n\");\n        }\n        return 0;\n    }\n\n    int pos = 0;\n    while(pos < N) {\n        int nxt = R[K - 1][pos];\n\n        bool ok = false;\n        for(int i = 0; i < (1 << (K - 1)); i++) {\n            if(pos - 1 <= dp1(i) && dp2((1 << (K - 1)) - i) <= nxt + 1) {\n                ok = true;\n                break;\n            }\n        }\n        if(ok) {\n            for(int i = pos; i <= nxt; i++) {\n                printf(\"Possible\\n\");\n            }\n        }\n        else {\n            for(int i = pos; i <= nxt; i++) {\n                printf(\"Impossible\\n\");\n            }\n        }\n        pos = nxt + 1;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 262150\n#define inf 2147483647\nusing namespace std;\nstruct pos1{int l, r;}pos[N][19];\nint n, m, k, w[N], now, dp_l[N], dp_r[N], bin[19], x, ff;\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tbin[0]=1; for(int i=1; i<=18; i++)bin[i]=bin[i-1]<<1;\n\tfor(int i=1; i<=n; i++)scanf(\"%d\", &w[i]); w[0]=w[1]-m-1; w[n+1]=w[n]+m+1;\n\tk=-1; x=m<<1;\n\twhile(x){\n\t\tk++; x>>=1; now=0;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(w[i]-w[i-1]>x)now=i;\n\t\t\tpos[i][k].l=now;\n\t\t}\n\t\tnow=n+1;\n\t\tfor(int i=n; i; i--){\n\t\t\tif(w[i+1]-w[i]>x)now=i;\n\t\t\tpos[i][k].r=now;\n\t\t}\n\t}\n\tdp_l[0]=0; dp_r[0]=n+1;\n\tfor(int i=1; i<=bin[k]-1; i++){\n\t\tdp_l[i]=0; dp_r[i]=n+1;\n\t\tfor(int j=1; j<=k; j++)if(i&bin[j-1]){\n\t\t\tdp_l[i]=max(dp_l[i], pos[dp_l[i-bin[j-1]]+1][j].r);\n\t\t\tdp_r[i]=min(dp_r[i], pos[dp_r[i-bin[j-1]]-1][j].l);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++)if(pos[i][0].l==i){\n\t\tff=0;\n\t\tfor(int j=0; j<=bin[k]-1; j++)if(dp_l[j]>=pos[i][0].l-1&&dp_r[bin[k]-1-j]<=pos[i][0].r+1){ff=1; break;}\n\t\tfor(int j=pos[i][0].l; j<=pos[i][0].r; j++)if(ff)printf(\"Possible\\n\"); else printf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1000000007;\nconst llint big=(llint)(2.19e16)+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nusing pli=pair<llint,int>;\nusing daic=priority_queue<pli,vector<pli>,greater<pli>>;\nint main(void){\n\tint n,v,i,j,k;cin>>n>>v;\n\tint mae,ju=0;cin>>mae;\n\tvector<int>sa(n-1);\n\tfor(i=0;i<n-1;i++){\n\t\tint x;cin>>x;\n\t\tsa[i]=x-mae;\n\t\tif(x-mae>v){ju++;}\n\t\tmae=x;\n\t}\n\tk=v;\n\tvector<int>kobu;\n\twhile(k>0){\n\t\tk/=2;\n\t\tkobu.pub(k);\n\t}\n\tint ks=kobu.size();//vは特別\n\tif(kobu.size()+2<ju){\n\t\t//不可能であることが確定する枝刈り\n\t\tfor(i=0;i<n;i++){cout<<\"Impossible\"<<endl;}\n\t\tRE;\n\t}\n\tvector<vector<int>>made(ks,vector<int>(n)) ;//0~ どこまで\n\tvector<vector<int>>hade(ks,vector<int>(n)) ;//どこまで~n-1\n\tfor(k=0;k<ks;k++){\n\t\tint gen=0;hade[k][0]=0;\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tif(kobu[k]<sa[i]){gen=i+1;}\n\t\t\thade[k][i+1]=gen;\n\t\t}\n\t\tgen=n-1;made[k][n-1]=n-1;\n\t\tfor(i=n-2;i>=0;i--){\n\t\t\tif(kobu[k]<sa[i]){gen=i;}\n\t\t\tmade[k][i]=gen;\n\t\t}\n\t}\n\tvector<int>mdp(1<<ks,  -1);\n\tvector<int>hdp(1<<ks,n);\n\tfor(int bi=0;bi<(1<<ks);bi++){\n\t\tfor(int i=0;i<ks;i++){\n\t\t\tif((bi&(1<<i))==0){continue;}\n\t\t\t\n\t\t\tif(mdp[bi-(1<<i)]==n-1){mdp[bi]=n-1;}\n\t\t\telse{maxeq(mdp[bi],made[i][mdp[bi-(1<<i)]+1]);}\n\t\t\t\n\t\t\tif(hdp[bi-(1<<i)]==0){hdp[bi]=0;}\n\t\t\telse{mineq(hdp[bi],hade[i][hdp[bi-(1<<i)]-1]);}\n\t\t}\n\t}\n\t//点を見つける\n\tmae=0;int cha=0;\n\tfor(i=0;i<n;i++){\n\t\tcha++;\n\t\tif(i==n-1||sa[i]>v){\n\t\t\tstring ret=\"Impossible\";\n\t\t\tfor(int bi=0;bi<(1<<ks);bi++){\n\t\t\t\tif(mae<=mdp[bi]+1&&hdp[(1<<ks)-1-bi]-1<=i){ret=\"Possible\";break;}\n\t\t\t}\n\t\t\twhile(cha>0){cout<<ret<<endl;cha--;}\n\t\t\tmae=i+1;\n\t\t}\n\t}RE;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=1e5+5;\nint n,m;\nint V[20],x[maxn],R[maxn][20],L[maxn][20];\nint S1[maxn],S2[maxn];\nint minL[maxn];\nint main(){\n\tread(n);read(V[0]);\n\trep(i,1,n)read(x[i]);\n\twhile(V[m])V[m+1]=V[m]/2,m++;\n\tm++;\n\trep2(i,0,m){\n\t\tR[n+1][i]=n;\n\t\tR[n][i]=n;\n\t\tper(j,n-1,1)\n\t\t\tif(x[j+1]-x[j]<=V[i])R[j][i]=R[j+1][i];\n\t\t\telse R[j][i]=j;\n\t\tL[0][i]=1;\n\t\tL[1][i]=1;\n\t\trep(j,2,n)\n\t\t\tif(x[j]-x[j-1]<=V[i])L[j][i]=L[j-1][i];\n\t\t\telse L[j][i]=j;\n\t}\n\trep2(i,0,1<<m)S2[i]=n+1,S1[i]=0;\n\trep2(i,1,1<<m){\n\t\trep2(j,0,m)if(i>>j&1){\n\t\t\tint last=S1[i^(1<<j)];\n\t\t\tS1[i]=max(S1[i],R[last+1][j]);\n\t\t}\n\t\trep2(j,0,m)if(i>>j&1){\n\t\t\tint last=S2[i^(1<<j)];\n\t\t\tS2[i]=min(S2[i],L[last-1][j]);\n\t\t}\n\t}\n\trep(i,0,n)minL[i]=n+2;\n\trep2(i,0,1<<m){\n\t\tif(i>>0&1)continue;\n\t\tint R=S1[i],L=S2[((1<<m)-1)^i^(1<<0)];\n\t\tminL[R]=min(minL[R],L);\n\t}\n\tper(i,n-1,0)minL[i]=min(minL[i],minL[i+1]);\n\trep(i,1,n){\n\t\tint rL=L[i][0],rR=R[i][0];\n\t\tif(minL[rL-1]<=rR+1)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// a.cpp\n\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < __typeof(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < ll >\n# define pb push_back\n# define pdd pair < db , db >\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int RMQ[20][1 << 20];\n    int n,k;\n    IOS;\n    fi>>n>>k;\n    static int s[1 << 20];\n    for (int i = 1;i <= n;++i)\n        fi>>s[i];\n    for (int i = 1;i < n;++i)\n        RMQ[0][i] = s[i + 1] - s[i];\n    for (int t = 1;n >> t;++t)\n        for (int i = 1;i + (1 << t) <= n + 1;++i)\n            RMQ[t][i] = max(RMQ[t - 1][i],RMQ[t - 1][i + (1 << (t - 1))]);\n    static int Log[1 << 20];\n    for (int i = 2;i <= (1 << 19);++i)\n        Log[i] = Log[i / 2] + 1;\n    auto get = [&](int l,int r)\n    {\n        int lg = Log[r - l + 1];\n        return max(RMQ[lg][l],RMQ[lg][r - (1 << lg) + 1]);\n    };\n    static int D1[1 << 20];\n    static int D2[1 << 20];\n    int lg = Log[k] + 2;\n    const int N = 1 << lg;\n    D1[0] = 0;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            if ((mask >> i) & 1)\n            {\n                int number = (k >> i);\n                int ans = D1[mask ^ (1 << i)] + 1;\n                int was = ans;\n                for (int t = 1 << (lg - 1);t;t /= 2)\n                    if (ans + t <= n && get(was,ans + t - 1) <= number)\n                        ans += t;\n                smax(D1[mask],ans);\n            }\n    D2[0] = n + 1;\n    for (int mask = 1;mask < N;++mask)\n        D2[mask] = n + 1;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            if ((mask >> i) & 1)\n            {\n                int number = (k >> i);\n                int ans = D2[mask ^ (1 << i)] - 1;\n                int was = ans;\n                for (int t = 1 << (lg - 1);t;t /= 2)\n                    if (ans > t && get(ans - t,was - 1) <= number)\n                        ans -= t;\n                smin(D2[mask],ans);\n            }\n    static int answer[1 << 20];\n    for (int mask1 = 0;mask1 < N;++mask1)\n        if (!(mask1 & 1))\n        {\n            int mask2 = (N - 1) ^ 1 ^ mask1;\n            const int l = D1[mask1];\n            const int r = D2[mask2];\n            if (l + 1 > r - 1)\n                answer[1]++,--answer[n + 1];\n            else\n            if (l + 1 == r - 1 || get(l + 1,r - 2) <= k)\n                ++answer[l + 1],--answer[r];\n        }\n    for (int i = 1;i <= n;++i)\n        answer[i] += answer[i - 1];\n    for (int i = 1;i <= n;++i)\n        if (answer[i])\n            PP;\n        else\n            II;\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <algorithm>\n\nint const nmax = 200000;\nint const lgmax = 20;\nint v[5 + nmax];\nstd::vector<int> phases;\nint st[1 + lgmax][5 + nmax], dr[1 + lgmax][5 + nmax];\nint pref[(1 << lgmax)], suff[(1 << lgmax)];\nint reach[5 + nmax];\nint sol[5 + nmax];\n\nint main() {\n  int n, lim;\n  std::cin >> n >> lim;\n  for(int i = 1;i <= n; i++)\n    std::cin >> v[i];\n  while(0 < lim) {\n    phases.push_back(lim);\n    lim /= 2;\n  }\n  phases.push_back(0);\n\n  std::reverse(phases.begin(), phases.end());\n  for(int h = 0; h < phases.size(); h++){\n    st[h][1] = 1;\n    for(int i = 2;i <= n; i++) {\n      if(v[i] - v[i - 1] <= phases[h])\n        st[h][i] = st[h][i - 1];\n      else\n        st[h][i] = i;\n    }\n    dr[h][n] = n;\n    for(int i = n - 1; 1 <= i; i--){\n      if(v[i + 1] - v[i] <= phases[h])\n        dr[h][i] = dr[h][i + 1];\n      else\n        dr[h][i] = i;\n    }\n  }\n  int bits = phases.size() - 1;\n  for(int mask = 0; mask < (1 << bits); mask++) {\n    pref[mask] = 0;\n    suff[mask] = n + 1;\n  }\n\n  for(int mask = 1; mask < (1 << bits); mask++)\n    for(int i = 0; i < bits; i++)\n      if(0 < (mask & (1 << i))) {\n        int mask2 = (mask ^ (1 << i));\n        if(pref[mask2] == n)\n          pref[mask] = n;\n        else\n          pref[mask] = std::max(pref[mask], dr[i][pref[mask2] + 1]);\n        if(suff[mask2] == 1)\n          suff[mask] = 1;\n        else\n          suff[mask] = std::min(suff[mask], st[i][suff[mask2] - 1]);\n      }\n  for(int i = 0;i <= n; i++)\n    reach[i] = n + 10;\n  for(int mask = 0; mask < (1 << bits); mask++) {\n    reach[pref[mask]] = std::min(reach[pref[mask]], suff[((1 << bits) - 1) ^ mask]);\n  }\n\n  for(int i = n - 1; 0 <= i; i--)\n    reach[i] = std::min(reach[i + 1], reach[i]);\n  for(int i = 1; i <= n; i++) {\n    int x = st[bits][i], y = dr[bits][i];\n   \n    if(reach[x - 1] <= y + 1)\n      std::cout << \"Possible\\n\";\n    else\n      std::cout << \"Impossible\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 401000\nusing namespace std;\n\nint mark[maxn];\nint lb[maxn][20], rb[maxn][20];\nint L[maxn], R[maxn], fa[maxn], p[maxn];\nint x[maxn];\nint v[20];\nint fl[maxn], fr[maxn];\nint tp;\nint n, m;\n\nint find(int a) {\n\treturn (fa[a] == a ? a : (fa[a] = find(fa[a])));\n}\n\nbool cmp(int a, int b) {\n\treturn (x[a + 1] - x[a] < x[b + 1] - x[b]);\n}\n\nint main() {\n\tscanf(\"%d %d\",&n,&m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\",&x[i]);\n\ttp = 0;\n\tfor (; m; m >>= 1) v[tp++] = m;\n\tv[tp++] = 0;\n\tfor (int i = 1; i <= n; i++) L[i] = R[i] = fa[i] = i;\n\tfor (int i = 1; i < n; i++) p[i] = i;\n\tint q = 1;\n\tsort(p + 1, p + n, cmp);\t\n\tfor (int t = tp - 1; t >= 0; t--) {\n\t\twhile (q < n && x[p[q] + 1] - x[p[q]] <= v[t]) {\n\t\t\tint a = p[q], b = p[q] + 1;\n\t\t\ta = find(a); b = find(b);\n\t\t\tR[fa[a]] = R[fa[b]];\n\t\t\tfa[fa[b]] = fa[a];\n\t\t\tq++;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tlb[i][t] = L[find(i)];\n\t\t\trb[i][t] = R[find(i)];\n\t\t}\n\t}\n\n\tfor (int u = 0; u < tp; u++) {\n\t\tlb[n + 1][u] = n;\n\t\trb[0][u] = 1;\n\t}\n\n\tfor (int st = 0; st < (1 << tp); st++) {\n\t\tfr[st] = n + 1;\n\t\tfor (int u = 0; u < tp; u++) {\n\t\t\tif (!(st >> u & 1)) continue;\n\t\t\tfl[st] = max(fl[st], rb[fl[st ^ (1 << u)] + 1][u]);\n\t\t\tfr[st] = min(fr[st], lb[fr[st ^ (1 << u)] - 1][u]);\n\t\t}\n\t}\n\n\tfor (int st = 0; st < (1 << tp); st++) {\n\t\tif (st & 1) continue;\n\t\tint l = fl[st];\n\t\tint r = fr[((1 << tp) - 1) ^ 1 ^ st];\n\t\tif (l >= r - 1) { mark[1]++; continue; }\n\t\tif (rb[l + 1][0] >= r - 1) {\n\t\t\tmark[lb[l + 1][0]]++;\n\t\t\tmark[rb[l + 1][0] + 1]--;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tmark[i] += mark[i - 1];\n\t\tif (mark[i] > 0) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=200010;\nint n,m,v[20],x[N],f[N][20],g[N][20],F[1<<20],G[1<<20],ans[1<<20];\n\nvoid work()\n{\n\tscanf(\"%d %d\",&n,&v[0]);\n\tfor (int i=1; i<=n; i++)  scanf(\"%d\",&x[i]);\n\tfor (int t=v[0]; (v[++m]=t/=2); );\n\tx[0]=-int(2e9),x[n+1]=-x[0];\n\tfor (int i=n; i; i--)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tif (x[i+1]-x[i]<=v[j])  f[i][j]=f[i+1][j];\n\t\t\telse  f[i][j]=i;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tif (x[i]-x[i-1]<=v[j])  g[i][j]=g[i-1][j];\n\t\t\telse  g[i][j]=i;\n\tfor (int i=0; i<(1<<m); i++)  G[i]=n+1;\n\tfor (int i=1; i<(1<<m); i++)\n\t\tfor (int j=1,k; j<=m; j++)\n\t\t\tif (i&(1<<(j-1)))\n\t\t\t\tk=i-(1<<(j-1)),F[i]=max(F[i],f[F[k]+1][j]),G[i]=min(G[i],g[G[k]-1][j]);\n\tfor (int i=0; i<=n; i++)  ans[i]=n+2;\n\tfor (int i=0; i<(1<<m); i++)  ans[F[i]]=min(ans[F[i]],G[(1<<m)-1-i]);\n\tfor (int i=n-1; i>=0; i--)  ans[i]=min(ans[i],ans[i+1]);\n\tfor (int l,r=1; r<=n; r++)\n\t\t{\n\t\t\tl=r;\n\t\t\twhile ((r<n)&&(x[r+1]-x[r]<=v[0]))  r++;\n\t\t\tfor (int i=l; i<=r; i++)\n\t\t\t\tputs(ans[l-1]<=r+1?\"Possible\":\"Impossible\");\n\t\t}\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define stt static\n#define rg register\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n#define y1 substitute_of_y1\n#define DEBUG(x) cerr<<#x\" = \"<<x<<endl;\nusing namespace std;\n\ntemplate<typename T> il T rd(){\n\tT nmb=0;int sgn=0;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-')sgn=1;chr=getchar();}\n\twhile(isdigit(chr)){nmb=(nmb<<3)+(nmb<<1)+chr-'0';chr=getchar();}\n\treturn sgn?-nmb:nmb;\n}\ntemplate<typename T> void wt(T nmb){\n\tif(nmb>9)wt(nmb/10);\n\tputchar(nmb%10+'0');\n}\ntemplate<typename T> il void cmax(T &x,T y){x=x>y?x:y;}\ntemplate<typename T> il void cmin(T &x,T y){x=x<y?x:y;}\ninline void proc_status(){\n\tifstream t (\"/proc/self/status\");\n\tcerr<<string(istreambuf_iterator<char>(t),istreambuf_iterator<char>())<<endl;\n\t/*freopen(\"/proc/self/status\",\"r\",stdin);\n\tchar ch[100];\n\twhile(scanf(\"%s\",ch)!=EOF)cerr<<ch<<endl;*/\n}\n\nconst int N=2e5+10,L=20;\n\nint a[N];\n\nvector<pii>vec[L];\n\n#define lowbit(x) (x&(-x))\n\nint f[N<<1],g[N<<1];\n\nint ans[N],b[N];\n\nint main(){\n\tint n=rd<int>(),p=rd<int>();\n\tfor(int i=1;i<=n;++i)a[i]=rd<int>();\n\tint lev=1;\n\tint Flg=0;\n\tfor(int k=p;!Flg;k>>=1,++lev){\n\t\tif(!k)Flg=1;\n\t\tfor(int l=1,r=1;l<=n;l=r+1){\n\t\t\tr=l;\n\t\t\twhile(r<n&&a[r+1]-a[r]<=k)++r;\n\t\t\tvec[lev].pb(mp(l,r));\n\t\t}\n\t}\n\tlev-=2;\n\tint k=(1<<lev)-1;\n\tfor(int S=0;S<=k;++S)f[S]=0,g[S]=n+1;\n\tfor(int S=0;S<=k;++S){\n\t\tfor(int T=S;T;T^=lowbit(T)){\n\t\t\tint t=(int)log2(lowbit(T))+2;\n\t\t\tint U=S^lowbit(T);\n\t\t\tint pos=upper_bound(vec[t].begin(),vec[t].end(),mp(f[U]+1,n+1))-vec[t].begin()-1;\n\t\t\tcmax(f[S],f[U]);\n\t\t\tif(pos>=0)cmax(f[S],vec[t][pos].snd);\n\t\t\tpos=upper_bound(vec[t].begin(),vec[t].end(),mp(g[U]-1,n+1))-vec[t].begin()-1;\n\t\t\tcmin(g[S],g[U]);\n\t\t\tif(pos>=0&&vec[t][pos].snd>=g[U]-1)cmin(g[S],vec[t][pos].fst);\n\t\t}\n\t}\n\tfor(int S=0;S<=k;++S){\n\t\tint l=f[S],r=g[k^S];\n\t\tint pos1=upper_bound(vec[1].begin(),vec[1].end(),mp(l+1,n+1))-vec[1].begin()-1;\n\t\tint pos2=upper_bound(vec[1].begin(),vec[1].end(),mp(r-1,n+1))-vec[1].begin()-1;\n\t\tif(vec[1][pos2].snd<r-1)++pos2;\n\t\tif(pos1>=0&&pos2>=0&&pos1==pos2)b[pos1]=1;\n\t}\n\tfor(int i=0;i<(int)vec[1].size();++i)\n\t\tfor(int t=vec[1][i].fst;t<=vec[1][i].snd;++t)\n\t\t\tans[t]=b[i];\n\tfor(int i=1;i<=n;++i)\n\t\tif(ans[i])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 2e5 + 10;\nint n , V , x[N] , toR[18][N] , toL[18][N] , len;\nint fL[1<<18] , fR[1<<18];\n\nvoid prepare(int toR[][N] , int *fL , const vi&x) {\n  int V = ::V;\n  len = 0;\n  while(V >= 0) {\n    toR[len][n]=toR[len][n+1]=n;\n    per(i,1,n) toR[len][i]=abs(x[i]-x[i+1])<=V?toR[len][i+1]:i;\n    len++;\n    if(V==0) break;\n    V >>= 1;\n  }\n  rep(i,0,1<<len) fL[i]=0;\n  rep(i,0,1<<len) {\n    rep(j,0,len) if(~i>>j&1)\n      fL[i|1<<j]=max(fL[i|1<<j],toR[j][fL[i]+1]);\n  }\n}\n\nint main(){\n  scanf(\"%d%d\",&n,&V);\n  rep(i,1,n+1) scanf(\"%d\",x+i);\n  vi v(x,x+1+n);\n  prepare(toR , fL , v);\n  reverse(v.begin()+1,v.begin()+1+n);\n  prepare(toL , fR , v);\n  vector<pii> seg;\n  int full=(1<<len)-1-1;\n  rep(i,0,1<<len) if(~i&1) {\n    seg.pb(mp(-fR[i],fL[full^i]));\n  }\n  sort(all(seg));\n  int cur=0,leftmost=-1;\n  rep(i,1,n+1) {\n    int left=n+1-toL[0][n+1-i];\n    int right=toR[0][i];\n    while(cur<sz(seg)&&-seg[cur].fi+right>=n) {\n      leftmost=max(leftmost,seg[cur].se);\n      cur++;\n    }\n    if(leftmost+1>=left) puts(\"Possible\");\n    else puts(\"Impossible\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 2e5+5;\nint n, k, V, i, a[Nmax], lg[Nmax], dp1[Nmax], go1[20][Nmax], dp2[Nmax], go2[20][Nmax], nr[Nmax];\n\nvoid compute()\n{\n    int l, j, ind;\n    for(l=1; l<k; ++l)\n    {\n        go1[l][n+1] = n;\n        go2[l][0] = 1;\n\n        for(i=1; i<=n; ++i)\n        {\n            j = i;\n            for(; j+1<=n && a[j+1] - a[j] <= lg[l]; ++j);\n            for(ind = i; ind <= j; ++ind)\n                go1[l][ind] = j;\n\n            i = j;\n        }\n\n        for(i=n; i; --i)\n        {\n            j = i;\n            for(; j-1 && a[j] - a[j-1] <= lg[l]; --j);\n            for(ind = i; ind >= j; --ind)\n                go2[l][ind] = j;\n\n            i = j;\n        }\n    }\n}\n\nvoid dinamique()\n{\n    int i, j;\n    dp1[0] = 0, dp2[0] = n+1;\n    for(i=2; i<(1<<k); i+=2)\n    {\n        dp1[i] = 1;\n        dp2[i] = n;\n\n        for(j=1; j<k; ++j)\n            if(i&(1<<j))\n            {\n                dp1[i] = max(dp1[i], go1[j][ dp1[i^(1<<j)] + 1 ]);\n                dp2[i] = min(dp2[i], go2[j][ dp2[i^(1<<j)] - 1 ]);\n            }\n    }\n}\n\nvoid solve()\n{\n    int i, j, ind, mask = (1<<k) - 2;\n    bool ok;\n\n    for(i=0; i<=n+1; ++i)\n        nr[i] = -1;\n\n    for(i=0; i<=mask; i+=2)\n        nr[dp2[i]] = max(nr[dp2[i]], dp1[mask^i]);\n\n    for(i=1; i<=n+1; ++i)\n        nr[i] = max(nr[i], nr[i-1]);\n\n    for(i=1; i<=n; ++i)\n    {\n        for(j=i; j+1<=n && a[j+1] - a[j] <= V; ++j);\n        ok = (nr[j+1] >= i-1);\n\n        for(ind = i; ind <= j; ++ind)\n            printf(\"%s\\n\", ok ? \"Possible\" : \"Impossible\");\n\n        i = j;\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &V);\n    for(i=1; i<=n; ++i) scanf(\"%d\", &a[i]);\n\n    lg[0] = V;\n    for(i=1; lg[i-1]; ++i) lg[i] = lg[i-1]/2;\n    k = i;\n\n    compute();\n    dinamique();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong long x[210000];\nint sa[210000];\nint nx_L[19][210000];\nint nx_R[19][210000];\n\nint d[20];\nint L[1<<19];\nint R[1<<19];\npair<int,int>p[1<<19];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lld\",x+i);\n\t}\n\td[0]=b;\n\tint n=0;\n\tfor(int i=0;d[i];i++){\n\t\td[i+1]=d[i]/2;\n\t\tn=i+2;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tint to=a;\n\t\tfor(int j=a-1;j>=0;j--){\n\t\t\tnx_L[i][j]=to;\n\t\t\tif(j&&x[j]-x[j-1]>d[i])to=j;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tint to=a;\n\t\tfor(int j=a-1;j>=0;j--){\n\t\t\tnx_R[i][j]=to;\n\t\t\tif(j&&x[a-j]-x[a-1-j]>d[i])to=j;\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<n);i++){\n\t\tint at=L[i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i&(1<<j))continue;\n\t\t\tint to=nx_L[j][at];\n\t\t\tL[i+(1<<j)]=max(L[i+(1<<j)],to);\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<n);i++){\n\t\tint at=R[i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i&(1<<j))continue;\n\t\t\tint to=nx_R[j][at];\n\t\t\tR[i+(1<<j)]=max(R[i+(1<<j)],to);\n\t\t}\n\t}\n\tint sz=0;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tif(i&1);\n\t\telse{\n\t\t\tp[sz++]=make_pair(L[i],i);\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tprintf(\"%d: \",d[i]);\n\t\tfor(int j=0;j<a;j++)printf(\"%d \",nx_L[i][j]);\n\t\t\tprintf(\"\\n\");\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%d: \",d[i]);\n\t\tfor(int j=0;j<a;j++)printf(\"%d \",nx_R[i][j]);\n\t\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tstd::sort(p,p+sz);\n\tset<pair<int,int> >S;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tif(i&1);\n\t\telse{\n\t\t\tS.insert(make_pair(R[i],i));\n\t\t}\n\t}\n\tint at=0;\n\tfor(int i=0;i<a;i++){\n\t\tint lq=a-nx_R[0][a-1-i];\n\t\tint rq=a-nx_L[0][i];\n\t\twhile(at<sz&&p[at].first<lq){\n\t\t\tS.erase(make_pair(R[p[at].second],p[at].second));\n\t\t\tat++;\n\t\t}\n\t\t//printf(\"%d %d\\n\",lq,rq);\n\t\tif(S.size()){\n\t\t\tpair<int,int> tp=*(S.rbegin());\n\t\t\tif(tp.first>=rq)printf(\"Possible\\n\");\n\t\t\telse printf(\"Impossible\\n\");\n\t\t}else{\n\t\t\tif(at<sz&&rq==0)printf(\"Possible\\n\");\n\t\t\telse printf(\"Impossible\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n \nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n \nconst int Maxn=2E5+5;\n \nint N,M,K,V;\nint a[Maxn];\nint F[Maxn<<1],G[Maxn<<1];\nint L[25][Maxn],R[25][Maxn];\nchar Ans[50],_1[50]={\"Possible\"},_2[50]={\"Impossible\"};\n//int nxt[Maxn];\n \ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n \nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n                        else L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n                        else R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1)\n\t\t\t\tMAX(F[i],R[M-j][min(F[i-(1<<j)]+1,N)]),\n\t\t\t\tMIN(G[i],L[M-j][max(G[i-(1<<j)]-1,1)]);\n\t}\n\tfor(int i=1;i<=N;++i)\n\t\tK+=(L[0][i]!=L[0][i-1]);\n\tif(K>20){\n\t\tfor(int i=1;i<=N;++i)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=1,j;i<=N;++i)\n\t\tif(L[0][i]!=L[0][i-1]){\n\t\t\tfor(j=0;j<(1<<M);++j)\n\t\t\t\tif(F[j]>=L[0][i]-1 && G[(1<<M)-1-j]<=R[0][i]+1)\n\t\t\t\t\t{memcpy(Ans,_1,sizeof(_1)); break ;}\n\t\t\tif(j==1<<M) memcpy(Ans,_2,sizeof(_2));\n\t\t\tprintf(\"%s\\n\",Ans);\n\t\t}else printf(\"%s\\n\",Ans);\n/*\tmemset(nxt,-1,sizeof(nxt));\n\tfor(int i=0;i<(1<<M);++i) MAX(nxt[G[(1<<M)-1-i]],F[i]);\n\tfor(int i=1;i<=N+1;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[R[0][i]+1]>=L[0][i]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N, V;\nint M, SM;\n\nint T[22][MAX_N];\nint nex[22][MAX_N];\n\nint dp[(1 << 22)], rdp[(1 << 22)];\nint ok[MAX_N];\n\nvector<ll> v;\nll A[MAX_N];\n\nvoid pre(int dp[MAX_N]) {\n\trep(i, 0, M) {\n\t\trep(j, 0, N - 1) {\n\t\t\tT[0][j] = (abs(A[j + 1] - A[j]) > v[i]) ? j : (j + 1);\n\t\t}\n\t\tT[0][N - 1] = N - 1;\n\t\trep(q, 0, 20) {\n\t\t\trep(j, 0, N) {\n\t\t\t\tT[q + 1][j] = T[q][T[q][j]];\n\t\t\t}\n\t\t}\n\t\trep(j, 0, N) {\n\t\t\tnex[i][j] = T[20][j];\n\t\t}\n\t}\n\tfill(dp, dp + (1 << SM), -1);\n\trep(bit, 0, (1 << SM)) {\n\t\tif(dp[bit] == N - 1) continue;\n\t\trep(i, 0, SM) {\n\t\t\tif(bit & (1 << i)) continue;\n\t\t\tMAX(dp[bit | (1 << i)], nex[i][dp[bit] + 1]);\n\t\t}\n\t}\n\trep(bit, 0, (1 << SM)) {\n\t\tif(dp[bit] == N - 1) continue;\n\t\tdp[bit] = nex[SM][dp[bit] + 1];\n\t}\n}\n\nvoid solve() {\n\tcin >> N >> V;\n\trep(i, 0, N) cin >> A[i];\n\twhile(V >= 1) {\n\t\tv.pb(V);\n\t\tV /= 2;\n\t}\n\tv.pb(0);\n\tM = sz(v);\n\tSM = M - 1;\n\n\treverse(all(v));\n\t\n\tpre(dp);\n\n\treverse(A, A + N);\n\tpre(rdp);\n\n\trep(bit, 0, (1 << SM)) rdp[bit] = N - 1 - rdp[bit];\n\n\trep(bit, 0, (1 << SM)) {\n\t\tint rbit = (1 << SM) - 1 - bit;\n\t\tint l = dp[bit], r = rdp[rbit];\n\t\tl++;\n\t\tif(l > r) {\n\t\t\tok[l]--;\n\t\t\tok[r]++;\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\tok[i + 1] += ok[i];\n\t\tif(ok[i]) cout << \"Possible\\n\";\n\t\telse cout << \"Impossible\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nconst int NMAX = 200000;\nconst int LOGN = 20;\nint V[LOGN];\nint Lmost[NMAX][LOGN], Rmost[NMAX][LOGN];\n\nint dpL[1<<LOGN], dpR[1<<LOGN];\nint arr[NMAX+1];\nint dp[NMAX+2];\n\nint main(){\n    int N; scanf(\"%d%d\",&N,&V[0]);\n    for(int i=1;i<=N;i++) scanf(\"%d\",arr+i);\n\n    int M = 1;\n    while(V[M-1]){\n        V[M] = V[M-1]/2;\n        M++;\n    }\n\n    for(int i=0;i<M;i++){\n        int v = V[i];\n        int j = 1;\n        while(j<=N){\n            int k = j+1;\n            while(k<=N && arr[k]-arr[k-1] <= v) k++;\n            for(int x=j;x<k;x++) Rmost[x][i] = k-1;\n            j = k;\n        }\n        j = N;\n        while(j>=1){\n            int k = j-1;\n            while(k>=1 && arr[k+1]-arr[k] <= v) k--;\n            for(int x=j;x>k;x--) Lmost[x][i] = k+1;\n            j = k;\n        }\n    }\n\n    for(int i=0;i<(1<<M);i++) dpR[i] = N+1;\n    for(int i=1;i<(1<<M);i++){\n        for(int j=0;j<M;j++) if(i&(1<<j)){\n            // use V[j]\n            int L = dpL[i^(1<<j)];\n            dpL[i] = max(dpL[i], Rmost[L+1][j]);\n\n            int R = dpR[i^(1<<j)];\n            dpR[i] = min(dpR[i], Lmost[R-1][j]);\n        }\n    }\n\n    for(int i=0;i<=N+1;i++) dp[i] = -1;\n\n    for(int i=2;i<(1<<M);i+=2){\n        int j = ((1<<M)-1)^i^1;\n        dp[dpR[j]] = max(dp[dpR[j]], dpL[i]);\n    }\n\n    for(int i=1;i<=N+1;i++)\n        dp[i] = max(dp[i], dp[i-1]);\n\n    for(int i=1;i<=N;i++){\n        int L = Lmost[i][0], R = Rmost[i][0];\n        int det = dp[R+1];\n        if(det>=L-1) printf(\"Possible\\n\");\n        else printf(\"Impossible\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <assert.h>\n#include <algorithm>\nusing namespace std;\nstruct P{\n\tint S,w;\n\tP(){}\n\tP(int a,int b){S=a;w=b;}\n}G[1000005];\nint n,v,m,a[200005],len[25],L[200005][25],R[200005][25],f[1000005],g[1000005];\npriority_queue<P> q;\nbool cmp(P a,P b){\n\treturn a.w<b.w;\n}\nbool operator <(P a,P b){\n\treturn a.w<b.w;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\twhile(v) len[m++]=v,v>>=1;len[m++]=0;\n\tfor(int i=0;i<m/2;i++) swap(len[i],len[m-i-1]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tL[i][p]=L[i-1][p];\n\t\t\tif(i==1||a[i]-a[i-1]>len[p]) L[i][p]=i;\n\t\t}\n\t}\n\tfor(int i=n;i;i--){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tR[i][p]=R[i+1][p];\n\t\t\tif(i==n||a[i+1]-a[i]>len[p]) R[i][p]=i;\n\t\t}\n\t}\n\tf[0]=0;g[0]=n+1;\n\tfor(int i=1;i<(1<<m);i++){\n\t\tg[i]=n+1;\n\t\tfor(int p=0;p<m;p++) if(i&(1<<p)){\n\t\t\tf[i]=max(f[i],f[i^(1<<p)]);\n\t\t\tf[i]=max(f[i],R[f[i^(1<<p)]+1][p]);\n\t\t\tg[i]=min(g[i],L[g[i^(1<<p)]-1][p]);\n\t\t}\n\t}\n\tint S=(1<<m-1)-1;\n\tfor(int i=0;i<=S;i++) G[i]=P(i,g[i]);\n\tsort(G,G+S+1,cmp);\n\tfor(int i=1,pos=0;i<=n;i++){\n\t\twhile(G[pos].w<=R[i][m-1]+1&&pos<=S) q.push(P(S^G[pos].S,f[S^G[pos].S])),pos++;\n\t\tif(q.empty()||q.top().w<L[i][m-1]-1) puts(\"Impossible\");\n\t\telse puts(\"Possible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Camel and Oases\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\nint const N=2e5+10;\nint const S=1<<18;\nint n,V;\nlint d[N];\nint logV,a[20][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n    }\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nvoid type(int s)\n{\n    for(int i=logV;i>=1;i--) printf(\"%d\",(s>>(i-1))%2);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&d[i]),d[i-1]=d[i]-d[i-1];\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    /*for(int i=1;i<=logV;i++)\n    {\n    \tprintf(\"%d-%d \",1,a[i][1]);\n        for(int j=2;j<=a[i][0];j++) printf(\"%d-%d \",a[i][j-1]+1,a[i][j]);\n        printf(\"\\n\");\n    }*/\n    if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++) puts(\"Impossible\");\n        return 0;\n    }\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=0,f2[s]=n+1;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    /*for(int s=0;s<=U;s+=2)\n        type(s),printf(\"   1-%2d  %2d-%2d\\n\",f1[s],f2[U-s-1],n);*/\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1 && f2[U-s-1]-1<=to) f=true;\n        if(f) for(int j=fr;j<=to;j++)\n            if(j==1) printf(\"Possible\");\n            else printf(\"\\nPossible\");\n        else for(int j=fr;j<=to;j++)\n            if(j==1) printf(\"Impossible\");\n            else printf(\"\\nImpossible\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define N 420000\nusing namespace std;\nint f[N][24],g[N][24];\nint tot,sum[N],n,v,a[N],b[N];\nint l[N],r[N];\nint check(int x,int y){\n\tx++;\n\tif(f[x][tot]<y-1)return 0;\n\ty=f[x][tot];\n\tx=g[y][tot];\n\tsum[x]++;\n\tsum[y+1]--;\n}\nint cal(){\n\tmemset(r,0x7f,sizeof(r));\n\tmemset(l,0,sizeof(l));\n\tr[0]=n;\n\tfor(int i=0;i<1<<tot;i++){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(i&(1<<(j-1)))continue;\n\t\t\tl[i|(1<<(j-1))]=max(l[i|(1<<(j-1))],f[l[i]+1][j]);\n\t\t\tr[i|(1<<(j-1))]=min(r[i|(1<<(j-1))],g[r[i]-1][j]);\t\n\t\t}\n\t}\n\tint o=(1<<(tot-1))-1;\n\tfor(int i=0;i<=o;i++){\n\t\tcheck(l[i],r[o^i]);\n\t}\n\tfor(int i=1;i<=n;i++)sum[i]+=sum[i-1];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\twhile(v)b[++tot]=v,v/=2;\n\tb[++tot]=v;\n\tsort(b+1,b+1+tot);\n\tfor(int i=1;i<=tot;i++)f[n][i]=n;\n\tfor(int i=n-1;i>=1;i--){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(a[i+1]-a[i]<=b[j])f[i][j]=f[i+1][j];\n\t\t\telse f[i][j]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot;i++)g[1][i]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(a[i]-a[i-1]<=b[j])g[i][j]=g[i-1][j];\n\t\t\telse g[i][j]=i;\n\t\t}\n\t}\n\tcal();\n\tfor(int i=1;i<=n;i++){\n\t\tif(sum[i]>0)printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define inf 0x3f3f3f3f\n#define N 200010\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint n,v,tot=-1,bin[20],R[20][N],num[20],f1[N],f2[N],a[N];//R[i][k],第i层的第k条线段的右端点 \n//num[i],第i层的线段条数 f1[s],选择s状态的层数,左边从1开始最远能覆盖到哪里 \nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tn=read();v=read();bin[0]=1;\n\tfor(int i=1;i<=20;++i) bin[i]=bin[i-1]<<1;\n\tfor(int i=1;i<=n;++i) a[i]=read();int x=v*2;\n\twhile(x){\n\t\tx/=2;tot++;\n\t\tfor(int i=1;i<=n-1;++i){\n\t\t\tif(a[i+1]-a[i]<=x) continue;\n\t\t\tR[tot][++num[tot]]=i;\n\t\t}R[tot][++num[tot]]=n;\n\t}if(num[0]>tot+1){\n\t\tfor(int i=1;i<=n;++i) puts(\"Impossible\");return 0;\n\t}\n\tfor(int s=0;s<=bin[tot]-1;++s) f2[s]=n+1;\n\tfor(int s=0;s<=bin[tot]-1;++s)\n\t\tfor(int i=1;i<=tot;++i){\n\t\t\tif(s&bin[i-1]) continue;\n\t\t\tf1[s|bin[i-1]]=max(f1[s|bin[i-1]],*upper_bound(R[i]+1,R[i]+num[i]+1,f1[s]));\n\t\t\tf2[s|bin[i-1]]=min(f2[s|bin[i-1]],R[i][lower_bound(R[i]+1,R[i]+num[i]+1,f2[s]-1)-R[i]-1]+1);\n\t\t}\n\tfor(int i=1;i<=num[0];++i){\n\t\tbool flag=0;\n\t\tfor(int s=0;s<=bin[tot]-1;++s)\n\t\t\tif(f1[s]>=R[0][i-1]&&f2[bin[tot]-1-s]<=R[0][i]+1){flag=1;break;}\n\t\tfor(int j=R[0][i-1]+1;j<=R[0][i];++j) puts(flag?\"Possible\":\"Impossible\");\n\t}return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define N 200010\nint n,v,lg,d[N],a[30][N],f1[1<<20],f2[1<<20];\nint g1(int *a,int x){\n\tint l=1,r=a[0];\n\twhile(l+1<r){\n\t\tint md=(l+r)/2;\n\t\tif(a[md]<=x)l=md+1;\n\t\telse r=md;\n\t}\n\tif(a[l]>x)return a[l];\n\treturn a[r];\n}\nint g2(int *a,int x){\n\tint l=1,r=a[0];\n\twhile(l+1<r){\n\t\tint md=(l+r)/2;\n\t\tif(a[md]<x)l=md;\n\t\telse r=md-1;\n\t}\n\tif(a[r]<x)return a[r]+1;\n\treturn a[l]+1;\n}\nsigned main(){\n\tcin>>n>>v;\n\twhile((1<<lg)<=v)lg++;\n\tlg++;\n\tfor(int i=1;i<=n;i++)cin>>d[i];\n\tfor(int i=1;i<=n;i++)\n\t\td[i-1]=d[i]-d[i-1];\n\tfor(int i=1;i<=lg;i++){\n\t\ta[i][0]=1;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\ta[i][a[i][0]]=j;\n\t\t\tif(d[j]>(v>>(i-1)))a[i][0]++;\n\t\t}\n\t}\n\tif(a[1][0]>lg){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<(1<<lg);i++)\n\t\tf2[i]=n+1;\n\tfor(int i=0;i<(1<<lg);i+=2)\n\t\tfor(int j=2;j<=lg;j++)\n\t\t\tif(!(i&(1<<(j-1)))){\n\t\t\t\tf1[i+(1<<(j-1))]=max(f1[i+(1<<(j-1))],g1(a[j],f1[i]));\n\t\t\t\tf2[i+(1<<(j-1))]=min(f2[i+(1<<(j-1))],g2(a[j],f2[i]-1));\n\t\t\t}\n\tfor(int i=1;i<=a[1][0];i++){\n\t\tint ok=0;\n\t\tint l=a[1][i-1]+1,r=a[1][i];\n\t\tif(i==1)l=1;\n\t\tfor(int s=0;s<(1<<lg);s+=2)\n\t\t\tif(l<=f1[s]+1&&f2[(1<<lg)-s-2]<=r+1)ok=1;\n\t\tif(ok)for(int j=l;j<=r;j++)puts(\"Possible\");\n\t\telse for(int j=l;j<=r;j++)puts(\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid debug(vector<vector<int>> &v) {\n\tcout << \"!!\" << endl;\n\trep(i, v.size())rep(j, v[i].size()) {\n\t\tcout << i << \" \" << j << \" \" << v[i][j] << endl;\n\t}\n}\n\nint x[1 << 18];\nint depth[1 << 18];\n\nint merge(int a, int b) {\n\tint res = 0;\n\tint c = 0;\n\trep(i, 20) {\n\t\tif (a&(1 << i))c++;\n\t\tif (b&(1 << i))c++;\n\t\tif (c > 0) {\n\t\t\tres += (1 << i); c--;\n\t\t}\n\t}\n\treturn res;\n}\n\nbool isg(int a, int b) {\n\tint le = 0, ri = 0;\n\tper(i,20) {\n\t\tif (a&(1 << i))le++;\n\t\tif (b&(1 << i))ri++;\n\t\tif (le > ri)return false;\n\t}\n\treturn true;\n}\nvoid add(vector<int> &v, int a) {\n\tbool valid = true;\n\trep(i, v.size()) {\n\t\tif (isg(v[i], a)) {\n\t\t\tvalid = false; break;\n\t\t}\n\t}\n\tif (!valid)return;\n\tvector<int> res;\n\trep(i, v.size()) {\n\t\tif (!isg(a,v[i]))res.push_back(v[i]);\n\t}\n\tres.push_back(a);\n\tswap(v, res);\n}\nvector<vector<int>> merge(vector<vector<int>> &a, vector<vector<int>> &b) {\n\tvector<vector<int>> res(a.size());\n\trep(i, a.size()) {\n\t\trep(j, b.size()) {\n\t\t\tint k = i + j + 1;\n\t\t\tif (k >= a.size())continue;\n\t\t\trep(x, a[i].size()) {\n\t\t\t\trep(y, b[j].size()) {\n\t\t\t\t\tint u = merge(a[i][x], b[j][y]);\n\t\t\t\t\tadd(res[k], u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<vector<int>> dfs(int l, int r, int v) {\n\tif (v == 0) {\n\t\treturn{ {1} };\n\t}\n\t//cout << l << \" \" << r << \" \" << v << endl;\n\tvector<int> nex;\n\tRep1(i, l, r) {\n\t\tint le = i;\n\t\twhile (i + 1 <= r&&x[i + 1] - x[i] <= v/2)i++;\n\t\tnex.push_back(le);\n\t}\n\tnex.push_back(r+1);\n\tint len = nex.size() - 1;\n\t//cout << len << endl;\n\tif (len == 1) {\n\t\tvector<vector<int>> ch = dfs(l, r, v / 2);\n\t\tch.resize(depth[v] + 1);\n\t\treturn ch;\n\t}\n\tvector<vector<int>> res(depth[v] + 1);\n\t//res[0].push_back((1 << depth[v]));\n\tif (len > depth[v]+1) {\n\t\tres[0].push_back(1 << depth[v]);\n\t\treturn res;\n\t}\n\tbool upd = false;\n\trep(i, len) {\n\t\tint le = nex[i], ri = nex[i + 1] - 1;\n\t\tvector<vector<int>> ch = dfs(le, ri, v / 2);\n\t\tif (!upd) {\n\t\t\tres = ch; res.push_back({});\n\t\t\tupd = true;\n\t\t}\n\t\telse res = merge(res, ch);\n\t}\n\t//cout << l << \" \" << r << \" \" << v << endl;\n\t//debug(res);\n\tadd(res[0], (1 << depth[v]));\n\treturn res;\n}\n\nvoid solve() {\n\tint n, v;\n\tcin >> n >> v;\n\trep(i, n)cin >> x[i];\n\tvector<int> z;\n\tint cop = v;\n\twhile (cop > 0) {\n\t\tz.push_back(cop); cop >>= 1;\n\t}\n\tz.push_back(0);\n\treverse(all(z));\n\trep(i, z.size()) {\n\t\tdepth[z[i]] = i;\n\t}\n\n\t/*cout << \"start\" << endl;\n\tvector<vector<int>> ex = dfs(12, 15, 9); \n\tcout << \"end\" << endl;\n\tdebug(ex);\n\tex = dfs(12, 15, 4); debug(ex);*/\n\n\n\tvector<int> nex;\n\trep(i, n) {\n\t\tnex.push_back(i);\n\t\twhile (i + 1 < n&&x[i + 1] - x[i] <= v)i++;\n\t}\n\tnex.push_back(n);\n\tint len = nex.size() - 1;\n\tif (len > depth[v]+1) {\n\t\trep(i, n) {\n\t\t\tcout << \"impossible\" << endl;\n\t\t}\n\t\treturn;\n\t}\n\tif (len == 1) {\n\t\trep(i, n) {\n\t\t\tcout << \"Possible\" << endl;\n\t\t}\n\t\treturn;\n\t}\n\tvector<vector<vector<int>>> memo;\n\n\trep(i, len) {\n\t\tint le = nex[i], ri = nex[i + 1] - 1;\n\t\tvector<vector<int>> ch = dfs(le, ri, v);\n\t\tmemo.push_back(ch);\n\t}\n\tvector<vector<vector<int>>> le(len+1), ri(len+1);\n\tle[0].resize(depth[v] + 1);\n\tri[len].resize(depth[v] + 1);\n\tle[1] = memo[0];\n\trep1(i, len-1) {\n\t\tle[i + 1] = merge(le[i], memo[i]);\n\t}\n\tri[len - 1] = memo[len - 1];\n\tper(i, len-1) {\n\t\tri[i] = merge(ri[i + 1], memo[i]);\n\t}\n\tvector<bool> ans(n);\n\trep(i, len) {\n\t\tvector<vector<int>> m;\n\t\tif (i == 0)m = ri[1];\n\t\telse if (i == len - 1)m = le[i];\n\t\telse m = merge(le[i], ri[i + 1]);\n\n\t\tbool f = false;\n\t\t//cout << \"hello \"<<i << endl;\n\t\trep(j, m.size()) {\n\t\t\trep(k, m[j].size()) {\n\t\t\t\t//cout << j << \" \" << k << \" \" << m[j][k] << endl;\n\t\t\t\tif (m[j][k] & (1 << depth[v]))continue;\n\t\t\t\tf = true;\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tRep(j, nex[i], nex[i + 1])ans[j] = true;\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (ans[i])cout << \"Possible\" << endl;\n\t\telse cout << \"Impossible\" << endl;\n\t}\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define P(x) cout << x << endl\n#define D(x) P(#x << \": \" << x)\n#define F(i,n) for (int i=0; i<(int)(n); i++)\n#define DEC(i,n) for (int i=(int)(n); --i>=0;)\n#define pb push_back\n#define all(v) v.begin(), v.end()\nusing namespace std;\nvoid MI(int &a, int v) {a = min(a,v);}\nvoid MA(int &a, int v) {a = max(a,v);}\nconst int N=2e5, L=20, PL=1<<L;\n\nint l,n,v,pl;\ndeque<int> len;\n\nvoid gen(int x[], int nxt[][N], int reach[]) {\n    F(k,l) {\n        int cur=0;\n        F(i,n+1) {\n            if (i == n || (i-1 >= 0 && abs(x[i] - x[i-1]) > len[k])) {\n                while (cur < i) {\n                    nxt[k][cur] = i;\n                    cur++;\n                }\n            }\n        }\n    }\n    F(mask,pl) {\n        reach[mask] = 0;\n        F(k,l) if (mask & 1<<k)\n            MA(reach[mask], nxt[k][reach[mask-(1<<k)]]);\n    }\n}\n\nvoid print(int nxt[][N]) {\n    F(k,l) {\n        cout<<len[k]<<\": \";\n        F(i,n) cout<<nxt[k][i]<<\" \\n\"[i==n-1];\n    }\n}\n\nint x[N], rev[N];\nint nxt[L][N], pre[L][N], rLeft[PL], rRight[PL];\n\nsigned main() {\n    cin>>n>>v;\n    F(i,n) cin>>x[i], rev[n-1-i] = x[i];\n    len = {v};\n    int cur = v;\n    while (cur) cur/=2, len.push_front(cur);\n    l = len.size();\n    pl = 1<<l;\n    gen(x, nxt, rLeft);\n    gen(rev, pre, rRight);\n    //P(\"nxt:\"); print(nxt);\n    //P(\"pre:\"); print(pre);\n    //F(k,pl) cout<<bitset<3>(k)<<\":\"<<rLeft[k]<<\" \\n\"[k==pl-1];\n    int start = pl/2;\n    int offer[n+1]; // if you finish at >= i, we can accept a start <= offer[i]\n    F(i,n+1) offer[i] = -1;\n    F(mleft,start) {\n        int le = rLeft[mleft], ri = n - rRight[start-1-mleft];\n        //P(le<<\" \"<<ri);\n        MA(offer[ri], le);\n    }\n    int best = -1;\n    cur = 0;\n    while (cur < n) {\n        int lim = nxt[l-1][cur];\n        for (int i=cur; i<=lim; i++)\n            MA(best, offer[i]);\n        for (int i=cur; i<lim; i++)\n            P((cur <= best ? \"Possible\" : \"Impossible\"));\n        cur = lim;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][30],tmp[30][30];\n\nconst int H=19260817;\nstruct hash_map\n{\n\tuint x[H];\n\tbool y[H];\n\tinline int get(uint v)\n\t{\n\t\tuint g=v%H;\n\t\tfor(;x[g]&&x[g]!=v;++g==H?g=0:0);\n\t\treturn x[g]==v?y[g]:2;\n\t}\n\tinline bool&operator[](uint v)\n\t{\n\t\tuint g=v%H;\n\t\tfor(;x[g]&&x[g]!=v;++g==H?g=0:0);\n\t\tx[g]=v;return y[g];\n\t}\n}hs;\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\tuint hash=dep;\n\tfo0(i,cnt)hash=hash*2337+s[i];\n\t{int tmp=hs.get(hash);if(tmp!=2)return tmp;}\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>=dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tif(dep<16)\n\t{\n\t\tfo0(i,uc)\n\t\t{\n\t\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\t\tr[i]=t[i];\n\t\t}\n\t\treturn hs[hash]=0;\n\t}\n\tint time=clock();\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\tr[i]=t[i];\n\t\tif((clock()-time)*10>7*CLOCKS_PER_SEC)return hs[hash]=0;\n\t}\n\treturn hs[hash]=0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200005;\nconst int M=(1<<18)+5;\nint a[N],b[N],n,m,v;\nint pl[19][N],pr[19][N];\nint fl[M],fr[M];\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor (int i=0;i<=18;i++){\n\t\tpl[i][1]=pl[i][0]=1;\n\t\tpr[i][n]=pr[i][n+1]=n;\n\t\tfor (int j=2;j<=n;j++)\n\t\t\tpl[i][j]=(a[j]-a[j-1]<=v?pl[i][j-1]:j);\n\t\tfor (int j=n-1;j;j--)\n\t\t\tpr[i][j]=(a[j+1]-a[j]<=v?pr[i][j+1]:j);\n\t\tif (!v){\n\t\t\tm=i; break;\n\t\t}\n\t\tv>>=1;\n\t}\n\tfor (int i=0;i<1<<m;i++)\n\t\tfl[i]=0,fr[i]=n+1;\n\tfor (int i=0;i<1<<m;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t\tif (!((i>>(j-1))&1)){\n\t\t\t\tint I=i|(1<<(j-1));\n\t\t\t\tfl[I]=max(fl[I],pr[j][fl[i]+1]);\n\t\t\t\tfr[I]=min(fr[I],pl[j][fr[i]-1]);\n\t\t\t}\n\tfor (int i=0;i<1<<m;i++)\n\t\tif (pr[0][fl[i]+1]>=fr[((1<<m)-1)^i]-1)\n\t\t\tb[pr[0][fl[i]+1]]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (b[pr[0][i]])\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define N 820000\nusing namespace std;\nint f[N][32],g[N][32];\nint tot,sum[N],n,v,a[N],b[N];\nint l[N],r[N];\nint check(int x,int y){\n\tx++;\n\tif(f[x][tot]<y-1)return 0;\n\ty=f[x][tot];\n\tx=g[y][tot];\n\tsum[x]++;\n\tsum[y+1]--;\n}\nint cal(){\n\tmemset(r,0x7f,sizeof(r));\n\tmemset(l,0,sizeof(l));\n\tr[0]=n;\n\tfor(int i=0;i<1<<tot;i++){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(i&(1<<(j-1)))continue;\n\t\t\tl[i|(1<<(j-1))]=max(l[i|(1<<(j-1))],f[l[i]+1][j]);\n\t\t\tr[i|(1<<(j-1))]=min(r[i|(1<<(j-1))],g[r[i]-1][j]);\n\t\t\tif(l[i]==n)l[i|(1<<(j-1))]=n;\n\t\t\tif(r[i]==1)r[i|(1<<(j-1))]=1;\n\t\t}\n\t}\n\tint o=(1<<(tot-1))-1;\n\tfor(int i=0;i<=o;i++){\n\t\tcheck(l[i],r[o^i]);\n\t}\n\tfor(int i=0;i<=n;i++)sum[i]+=sum[i-1];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\twhile(v)b[++tot]=v,v/=2;\n\tb[++tot]=v;\n\tsort(b+1,b+1+tot);\n\tfor(int i=1;i<=tot;i++)f[n][i]=n;\n\tfor(int i=n-1;i>=1;i--){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(a[i+1]-a[i]<=b[j])f[i][j]=f[i+1][j];\n\t\t\telse f[i][j]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot;i++)f[n+1][i]=n;\n\tfor(int i=1;i<=tot;i++)g[1][i]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(a[i]-a[i-1]<=b[j])g[i][j]=g[i-1][j];\n\t\t\telse g[i][j]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot;i++)g[0][i]=1;\n\tcal();\n\tfor(int i=1;i<=n;i++){\n\t\tif(sum[i]>0)printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst int mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst double pi = 3.141592653589793;\n\nint n,v,m;\nint a[200000+5];\nint nxl[200000+5][20],nxr[200000+5][20];\nint ok[200000+5]={};\nint dpl[1000000];\nint dpr[1000000];\nint pre,now,nx;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> v;\n    rep(i,n) cin >> a[i];\n    m=0;\n    int vv=v;\n    while (vv>0){\n        vv/=2;\n        m+=1;\n    }\n    m+=1;\n    rep(j,m){\n        nxl[n-1][j]=n-1;\n        nxr[0][j]=0;\n    }\n    rep(j,m){\n        now=0;\n        pre=0;\n        while (now<n-1){\n            while (now<n-1){\n                nx=now+1;\n                if (a[nx]-a[now]>v/pow(2,j)) break;\n                now=nx;\n            }\n            rep2(i,pre,nx) nxl[i][j]=now;\n            pre=nx;\n            now=nx;\n        }\n    }\n    rep(j,m){\n        now=n-1;\n        pre=n-1;\n        while (now>0){\n            while (now>0){\n                nx=now-1;\n                if (a[now]-a[nx]>v/pow(2,j)) break;\n                now=nx;\n            }\n            rrep2(i,pre,nx) nxr[i][j]=now;\n            pre=nx;\n            now=nx;\n        }\n    }\n    fill(dpr,dpr+(1<<m),n-1);\n    rep(i,1<<m)rep(j,m){\n            if (!(i>>j&1)){\n                int L=nxl[dpl[i]][j];\n                int R=nxr[dpr[i]][j];\n                if (L==n-1) L-=1;\n                if (R==0) R+=1;\n                dpl[i|(1<<j)]=max(dpl[i|(1<<j)],L+1);\n                dpr[i|(1<<j)]=min(dpr[i|(1<<j)],R-1);\n            }\n    }\n    bool f=false;\n    rep(i,1<<m){\n        int tmp=i;\n        if (tmp&1) tmp=tmp^1;\n        int left=dpl[tmp];\n        int nokori=((1<<m)-1)^tmp;\n        nokori-=1;\n        int right=dpr[nokori];\n        if (left<right){\n            if (nxl[left][0]>=right){\n                ok[left]+=1;\n                ok[right+1]-=1;\n            }\n        }\n        else{\n            f=true;\n            break;\n        }\n    }\n    if (f){\n        rep(i,n) cout << \"Possible\" << endl;\n    }\n    else{\n        rep(i,n) ok[i+1]+=ok[i];\n        rep(i,n){\n            if (ok[i]>0) cout << \"Possible\" << endl;\n            else cout << \"Impossible\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <deque>\n#include <utility>\n#include <chrono>\n#include <sstream>\n#include <iomanip>\n#define INF 1 << 30\n#define MOD 1000000007;\n#define pi 3.14159265358979\n#define rep(i, n) for (int (i) = 0; (i) < (int)(n); (i)++)\n#define reu(i, l, r) for (int (i) = (int)(l); (i) < (int)(r); (i)++)\n#define D(x) cout << x << endl\n#define d(x) cout << x\n#define all(x) (x).begin(), (x).end()\n#define pub(x) push_back(x)\n#define pob() pop_back()\n#define puf(x) push_front(x)\n#define pof() pop_front()\n#define mp(x, y) make_pair((x), (y))\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if (x < y) x = y; }\nstatic const int dx[] = {0, 0, 1, -1};\nstatic const int dy[] = {-1, 1, 0, 0};\n\nint main() { \n  int n, v;\n  cin >> n >> v;\n  vi x(n);\n  vi dis(n + 1);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i];\n    if (i > 0) {\n      dis[i] = x[i] - x[i - 1];\n    }\n  }\n  dis[0] = INF;\n  dis[n] = INF;\n\n  //for (int i = 0; i < dis.size(); i++) {\n  //  d(dis[i] << \" \");\n  //}\n  //D(\"\");\n\n  vi vv;\n  while (v > 0) {\n    vv.pub(v);\n    v /= 2;\n  }\n  vv.pub(0);\n\n  //for (int i = 0; i < vv.size(); i++) {\n  //  d(vv[i] << ' ');\n  //}\n  //D(\"\");\n\n  vector<vector<bool>> wall(vv.size(), vector<bool> (n + 1, false));\n\n  for (int i = 0; i < vv.size(); i++) {\n    for (int j = 0; j < n + 1; j++) {\n      if (dis[j] > vv[i]) {\n        wall[i][j] = true;\n      }\n    }\n  }\n\n  //for (int i = 0; i < vv.size(); i++) {\n  //  for (int j = 0; j < n  + 1; j++) {\n  //    d(wall[i][j] << \" \");\n  //  }\n  //  D(\"\");\n  //}\n  \n  vs ans;\n\n  int i = 0;\n  while (i < n) {\n    int cnt = 0;\n\n    vector<bool> done(n);\n    for (int u = 0; u < n; u++) {\n      done[u] = false;\n    }\n\n    while (!wall[0][i + 1]) {\n      done[i] = true;\n      i++;\n      cnt++;\n    }\n    done[i] = true;\n    i++;\n    cnt++;\n\n    //D(i << \" --------------------\");\n    //for (int u = 0; u < n; u++) {\n    //  d(done[u] << ' ');\n    //}\n    //D(\"\");\n\n    for (int j = 1; j < vv.size(); j++) {\n      int maxd = -1;\n      int maxk = -1;\n      for (int k = 0; k < n; k++) {\n        if (!wall[j][k] && !done[k]) {\n          if (maxd < dis[k]) {\n            maxd = dis[k];\n            maxk = k;\n          }\n        }\n      }\n\n      //D(maxd << \" \" << maxk);\n\n      bool flag = false;\n      if (maxk == -1) {\n        for (int k = 0; k < n; k++) {\n          if (!done[k]) {\n            done[k] = true;\n            flag = true;\n            break;\n          }\n        }\n      }\n\n      //for (int u = 0; u < n; u++) {\n      //  d(done[u] << \" \");\n      //}\n      //D(\"\");\n\n      if (flag) {\n        continue;\n      }\n\n      if (!flag && maxk == -1) {\n        break;\n      }\n\n      //D(\"FJLDKJ\");\n      //D(maxk);\n           \n      int kpf = maxk;\n      while (!wall[j][kpf] && kpf < n) {\n        done[kpf] = true;\n        kpf++;\n      }\n      int kpb = maxk - 1;\n      while (!wall[j][kpb] && kpb > 0) {\n        done[kpb] = true;\n        kpb--;\n      }\n      done[kpb] = true;\n    }\n    \n    bool end = true;\n    for (int p = 0; p < n; p++) {\n      if (!done[p]) {\n        end = false;\n      }\n    }\n    \n    for (int j = 0; j < cnt; j++) {\n      if (end) {\n        ans.pub(\"Possible\");\n      } else {\n        ans.pub(\"Impossible\");\n      }\n    }\n  }\n\n  for (int z = 0; z < ans.size(); z++) {\n    D(ans[z]);\n  }\n\n  //for (int i = 0; i < dis.size(); i++) {\n  //  d(setw(3) << dis[i] << \" \" );\n  //}\n  //D(\"\");     \n  //for (int i = 0; i < vv.size(); i++) {\n  //  for (int j = 0; j < n - 1; j++) {\n  //    d(setw(3) << wall[i][j] << \" \");\n  //  }\n  //  D(\"\");\n  //}\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Author       : Sun YaoFeng\n//============================================================================\n\n//#pragma \tcomment(linker, \"/STACK:100240000,100240000\")\n//#include\t<cstdio>\n//#include\t<cstdlib>\n//#include\t<cstring>\n//#include\t<algorithm>\n\n#include\t<bits/stdc++.h>\n\nusing\tnamespace\tstd;\n\n#define DB\t\tdouble\n#define\tlf\t\telse if\n#define I64\t\tlong long\n#define unt\t\tunsigned int\n#define\tRd()\t(rand()<<15|rand())\n#define For(i,a,b)\tfor(int i=(int)(a);i<=(int)(b);i++)\n#define Rep(i,a,b)\tfor(int i=(int)(a);i>=(int)(b);i--)\n\n#define\tfi\tfirst\n#define se\tsecond\n#define MK\tmake_pair\n#define pb\tpush_back\n#define PA\tpair<int, int>\n\n//#define\tmin(a,b)\t((a)<(b)?(a):(b))\n//#define\tmax(a,b)\t((a)<(b)?(b):(a))\n\n#define\tCH\t(ch=getchar())\nint\t\tIN()\t{\n\t\tint x= 0, f= 0, ch;\n\t\tfor\t(; CH < '0' || ch > '9';)\tf= (ch == '-');\n\t\tfor\t(; ch >= '0' && ch <= '9'; CH)\tx= x*10 + ch -'0';\n\t\treturn\tf? -x : x;\n}\n\n#define m\t20\n#define n\t200005\n\nint\t\tN, M, C, U;\n\nint\t\tA[n], B[m];\n\nint\t\tL[m][n], R[m][n];\n\nint\t\tF[1 << m], G[1 << m];\n\nint\t\tmain(int argc, char* argv[]){\n\t\tN= IN();\n\t\tM= IN();\n\t\tFor(i, 1, N)\tA[i]= IN();\n\t\t\n\t\tB[C= 1]= M;\n\t\tfor (; B[C]; )\tC++, B[C]= B[C-1] >> 1;\n\t\t\n\t\tFor(i, 1, C)\t{\n\t\t\tL[i][1]= 1;\n\t\t\tFor(j, 2, N)\tif\t(A[j] - A[j-1] <= B[i])\tL[i][j]= L[i][j-1];\n\t\t\t\telse\tL[i][j]= j;\n\t\t\t\t\n\t\t\tR[i][N]= N;\n\t\t\tRep(j, N-1, 1)\tif\t(A[j+1] - A[j] <= B[i])\tR[i][j]= R[i][j+1];\n\t\t\t\telse\tR[i][j]= j;\n\t\t}\n\t\t\n\t\tU= (1 << C) - 1;\n\t\t\n\t\tFor(s, 0, U)\t{\n\t\t\tint x= F[s] + 1;\n\t\t\t\n\t\t\tFor(i, 1, C)\tif\t(! ((1 << (i-1)) & s))\t{\n\t\t\t\tint t= (1 << (i-1)) ^ s;\n\t\t\t\t\n\t\t\t\tF[t]= max(F[t], F[s]);\n\t\t\t\tif\t(x <= N)\tF[t]= max(F[t], R[i][x]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tFor(s, 0, U)\tG[s]= N + 1;\n\n\t\tFor(s, 0, U)\t{\n\t\t\tint x= G[s]-1;\n\t\t\t\n\t\t\tFor(i, 1, C)\tif\t(! ((1 << (i-1)) & s))\t{\n\t\t\t\tint t= (1 << (i-1)) ^ s;\n\t\t\t\t\n\t\t\t\tG[t]= min(G[t], G[s]);\n\t\t\t\tif\t(x >= 1)\tG[t]= min(G[t], L[i][x]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tFor(i, 1, N)\t{\n\t\t\tint l= L[1][i], r= R[1][i];\n\t\t\t\n\t\t\tint\tflag= 0;\n\t\t\tFor(s, 0, U)\tif\t(! (s & 1)){\n\t\t\t\tint t= U ^ 1 ^ s;\n\t\t\t\t\n\t\t\t\tif\t(F[s] >= l-1 && G[t] <= r+1)\tflag= 1;\n\t\t\t}\n\t\t\t\n\t\t\tputs(flag ? \"Possible\" : \"Impossible\");\n\t\t}\n\n\t\treturn\t0;\n}"
  },
  {
    "language": "C++",
    "code": "const bool submit = 1;\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) if(!submit) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint N,V;\nconst int MN=200000;\nconst int MD=18;\nint D;\nint x_[MN];\nint d[MN-1];\nint xv2id[MN][MD];\n\nconst int MX=MN*MD;\nint id2v[MX];\nint id2l[MX];\nint id2r[MX];\nint I;\n\n\ntypedef vector<int> VI;\n\nVI getnext(int pid,int lim){\n\tint v = id2v[pid];\n\tint l = id2l[pid];\n\tint r = id2r[pid];\t//[l,r)\n\tv++;\n\tVI ret;\n\tint id=xv2id[l][v];\n\twhile(true){\n\t\tret.pb(id);\n\t\tif(id2r[id]==r) break;\n\t\tid++;\n\t\tif(ret.size()>lim) return {-1};\n\t}\n\treturn ret;\n}\n\n\nmap<VI,bool> memo;\n\nbool anstmp[MN];\n\nbool can(VI vi,int v){\n\tshow(vi);\n\tshow(v);\n\tif(vi.empty()) return 1;\n\tif(vi.size()>D-v) return 0;\n\tint K = vi.size();\n\tint lim = D-v;\n\tVI vs[K];\n\tint sz[K];\n\tint sum=0;\n\trep(i,K){\n\t\tvs[i]=getnext(vi[i],lim);\n\t\tshow(vs[i]);\n\t\tsz[i]=vs[i].size();\n\t\tif(vs[i].front()==-1) sz[i]=100;\n\t\tsum+=sz[i];\n\t}\n\trep(i,K){\n//\t\tshow(sum-sz[i]);\n\t\tif(sum-sz[i]>lim) continue;\n\t\tVI nvi;\n\t\trep(j,K) if(j!=i){\n\t\t\tfor(int u:vs[j]) nvi.pb(u);\n\t\t}\n\t\tif(can(nvi,v+1)){\n\t\t\tmemo[vi]=1;\n\t\t\tif(v==0){\n\t\t\t\tanstmp[i]=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\tmemo[vi]=0;\n\treturn 0;\n}\n\nbool ans[MN];\n\nint main(){\n\tcin>>N>>V;\n\trep(i,N) cin>>x_[i];\n\trep(i,N-1) d[i]=x_[i+1]-x_[i];\n\trep(v,MD){\n\t\tint l=0;\n\t\trep(x,N){\n\t\t\tif(x==N-1 || d[x]>V){\n\t\t\t\tfor(int i=l;i<=x;i++) xv2id[i][v]=I;\n\t\t\t\tid2v[I]=v;\n\t\t\t\tid2l[I]=l;\n\t\t\t\tid2r[I]=x+1;\n\n\t\t\t\t// show(I);\n\t\t\t\t// show(v);\n\t\t\t\t// printf(\"(%d,%d]\\n\",l,x+1);\n\t\t\t\t// puts(\"\");\n\t\t\t\tI++;\n\t\t\t\tl=x+1;\n\t\t\t}\n\t\t}\n\t\tV/=2;\n\t\tif(V==0){\n\t\t\tD=v+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint K = xv2id[N-1][0]+1;\n\n\tif(K>D){\n\t\trep(i,N){\n\t\t\tputs(\"Impossible\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvector<int> be;\n\trep(i,K) be.pb(i);\n\n\tcan(be,0);\n\trep(i,K){\n\t\tint l = id2l[i];\n\t\tint r = id2r[i];\n\t\tbool tmp = anstmp[i];\n\t\tfor(int x=l;x<r;x++) ans[x]=tmp;\n\t}\n\trep(i,N){\n\t\tif(ans[i]) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint x[252521];\nint ne[252521][20],rne[252521][20];\nint dp[(1<<20)+10],rdp[(1<<20)+10];\nvector<int> v;\nint main()\n{\n\tint n,V;\n\tcin>>n>>V;\n\trep(i,n) cin>>x[i];\n\twhile(V>0){\n\t\tv.pb(V);V/=2;\n\t}\n\tv.pb(0);int m=v.size();\n\trep(i,n) rep(j,m){\n\t\trne[i][j]=i;\n\t\tif(i>0 && x[i]-x[i-1]<=v[j]) rne[i][j]=rne[i-1][j];\n\t}\n\tfor(int i=n-1;i>=0;i--) rep(j,m){\n\t\tne[i][j]=i;\n\t\tif(i<n-1 && x[i+1]-x[i]<=v[j]) ne[i][j]=ne[i+1][j];\n\t}\n\tmemset(dp,0,sizeof(dp));\n\trep(i,(1<<20)+5) rdp[i]=n-1;\n\trep(i,(1<<m)) rep(j,m){\n\t\tif((i&(1<<j))>0 || dp[i]>=n || rdp[i]<0) continue;\n\t\tdp[i+(1<<j)]=max(dp[i+(1<<j)],ne[dp[i]][j]+1);\n\t\trdp[i+(1<<j)]=min(rdp[i+(1<<j)],rne[rdp[i]][j]-1);\n\t}\n\t//rep(i,(1<<m)) cout<<i<<' '<<dp[i]<<' '<<rdp[i]<<endl;\n\tif(dp[(1<<m)-1]<n){\n\t\t//assert(dp[(1<<m)-1]<n && rdp[(1<<m)-1]>=0);\n\t\trep(i,n) cout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tint now=0;\n\twhile(now<n){\n\t\tint f=0;\n\t\trep(i,(1<<(m-1))){\n\t\t\tif(dp[(1<<m)-2-(i<<1)]>=now && rdp[(i<<1)]<=ne[now][0]) f=1;\n\t\t}\n\t\tREP(i,now,ne[now][0]+1){\n\t\t\tif(f>0) cout<<\"Possible\"<<endl;\n\t\t\telse cout<<\"Impossible\"<<endl;\n\t\t}\n\t\tnow=ne[now][0]+1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=200200,D=20;\nint i,j,k,n,m,nm,mm,ch,ff;\nint x[N],pre[1<<D],suf[1<<D],ans[N];\nvector<int> X[D];\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nint find1(int i,int x) {\n\tint l=0,r=X[i].size()-1,mid;\n\twhile (l<r) {\n\t\tmid=(l+r+1)>>1;\n\t\tif (X[i][mid]>x) r=mid-1;\n\t\telse l=mid;\n\t}\n\treturn l;\n}\nint find2(int i,int x) {\n\tint l=0,r=X[i].size()-1,mid;\n\twhile (l<r) {\n\t\tmid=(l+r-1)>>1;\n\t\tif (X[i][mid]<x) l=mid+1;\n\t\telse r=mid;\n\t}\n\treturn l;\n}\nvoid Max(int &x,int y) {\n\tif (y>x) x=y;\n}\nvoid Min(int &x,int y) {\n\tif (y<x) x=y;\n}\nint main() {\n\tR(n);R(m);\n\tfor (i=1;i<=n;i++) R(x[i]);\n\tk=m;\n\twhile (1) {\n\t\tX[nm].push_back(1);\n\t\tfor (i=1;i<n;i++) if (x[i]+k<x[i+1]) X[nm].push_back(i+1);\n\t\tX[nm].push_back(n+1);\n\t\tnm++;\n\t\tif (!k) break;\n\t\tk>>=1;\n\t}\n\tmm=1<<nm;\n\tfor (i=0;i<mm;i++) suf[i]=n+1;\n\tfor (i=0;i<mm;i+=2)\n\t\tfor (j=1;j<nm;j++) if (!(i&1<<j)) {\n\t\t\tMax(pre[i|1<<j],X[j][find1(j,pre[i]+1)+1]-1);\n\t\t\tMin(suf[i|1<<j],X[j][find2(j,suf[i])-1]);\n\t\t}\n\tif (X[0].size()>mm+1) {\n\t\tfor (i=0;i<n;i++) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor (i=1;i<X[0].size();i++) {\n\t\tint l=X[0][i-1],r=X[0][i]-1,fg=0;\n\t\tfor (j=0;j<mm;j+=2) if (pre[j]+1>=l && suf[(mm-2)^j]-1<=r) {\n\t\t\tfg=1;\n\t\t\tbreak;\n\t\t}\n\t\tfor (j=l;j<=r;j++) ans[j]=fg;\n\t}\n\tfor (i=1;i<=n;i++) {\n\t\tif (ans[i]) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 262144+5;\nint n, m, v, p[N], l[20][N], r[20][N];\nint d[N], f[N], g[N];\nvoid func(int v, int *l, int *r)\n{\n    l[1] = 1, r[n] = n;\n    for(int i = 2; i <= n; ++i) l[i] = p[i]-p[i-1] <= v?l[i-1]:i;\n    for(int i = n-1; i; --i) r[i] = p[i+1]-p[i] <= v?r[i+1]:i; \n    l[0] = 1, r[n+1] = n; \n}\nvoid pusha(int l, int r) { if(l <= r) ++d[l], --d[r+1]; }\nint main()\n{\n    n = read(), v = read();\n    for(int i = 1; i <= n; ++i) p[i] = read();\n    for( ; v; ++m, v >>= 1) func(v, l[m], r[m]); func(0, l[m], r[m]);\n    g[0] = n+1;\n    for(int s = 1; s < 1<<m; ++s)\n    {\n        g[s] = n;\n        for(int i = 0; i < m; ++i)\n            if(s>>i&1) f[s] = max(f[s], r[i+1][f[s^(1<<i)]+1]), g[s] = min(g[s], l[i+1][g[s^(1<<i)]-1]);\n    }\n    for(int s = 0; s < 1<<m; ++s) pusha(l[0][g[s^((1<<m)-1)]-1], r[0][f[s]+1]);\n    for(int i = 1; i <= n; ++i) d[i] += d[i-1], puts(d[i]?\"Possible\":\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 9;\nint n, v, l[N][20], r[N][20], x[N], p, f[1 << 20], g[1 << 20], dp[N];\n\nvoid Max (int &x, int y) { if (x < y) x = y; }\nvoid Min (int &x, int y) { if (x > y) x = y; }\n\nbool Judge (int x) {\n\treturn dp[l[x][0] - 1] <= r[x][0] + 1;\n}\n\nint main () {\n\tscanf(\"%d%d\", &n, &v);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &x[i]);\n\tfor (p = 0; v; v >>= 1, ++p) {\n\t\tl[0][p] = l[1][p] = 1; for (int j = 2; j <= n; ++j) l[j][p] = x[j] - x[j - 1] <= v ? l[j - 1][p] : j;\n\t\tr[n + 1][p] = r[n][p] = n; for (int j = n - 1; j; --j) r[j][p] = x[j + 1] - x[j] <= v ? r[j + 1][p] : j;\n\t}\n\tfor (int i = 1; i <= n; ++i) l[i][p] = r[i][p] = i;\n\tg[0] = n + 1;\n\tfor (int i = 1; i < (1 << p); ++i) {\n\t\tg[i] = 0x3f3f3f3f;\n\t\tfor (int j = 0; j < p; ++j) if (i >> j & 1) {\n\t\t\tMax(f[i], r[f[i ^ (1 << j)] + 1][j + 1]);\n\t\t\tMin(g[i], l[g[i ^ (1 << j)] - 1][j + 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; ++i) dp[i] = 0x3f3f3f3f;\n\tfor (int i = 0; i < (1 << p); ++i) Min(dp[f[i]], g[((1 << p) - 1) ^ i]);\n\tfor (int i = n - 1; i; --i) Min(dp[i], dp[i + 1]);\n\tfor (int i = 1; i <= n; ++i) puts(Judge(i) ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e5 + 100;\nconst int Maxm = 20 + 5;\nconst int Maxs = (1 << 20) + 100;\n\nint N, V, Log;\nint A[Maxn];\n\nint L[Maxm][Maxn], R[Maxm][Maxn];\nint Next[Maxn];\n\ninline void get_seg ()\n{\n\tfor (int i = 0; i <= Log; ++i)\n\t{\n\t\tint v = V >> i;\n//\t\tDEBUG (v);\n\t\tfor (int j = N; j >= 1; --j)\n\t\t{\n\t\t\tint p = upper_bound (A + 1, A + N + 1, A[j] + v) - A - 1;\n\t\t\tNext[j] = 0;\n\t\t\tNext[j] = max (Next[p], j);\n\t\t}\n\t\tfor (int l = 1, r = 0; l <= N; l = r + 1)\n\t\t{\n\t\t\tr = Next[l];\n\t\t\tL[i][++L[i][0]] = l, R[i][++R[i][0]] = r;\n//\t\t\tcout << l << ' ' << r << endl;\n\t\t}\n\t}\n}\n\nint f[Maxs], g[Maxs];\n\ninline void get_f ()\n{\n\tint ALL = (1 << Log) - 1;\n\tf[0] = 1;\n\tfor (int i = 0; i <= ALL; ++i)\n\t{\n\t\tif (!f[i]) continue;\n\t\tint preR = f[i];\n\t\tfor (int j = 1; j <= Log; ++j)\n\t\t{\n\t\t\tif (i & (1 << (j - 1))) continue;\n\t\t\tint x = upper_bound (L[j] + 1, L[j] + L[j][0] + 1, preR + 1) - L[j] - 1;\n\t\t\tint nowR = max (preR, R[j][x]);\n\t\t\tChkmax (f[i | (1 << (j - 1))], nowR);\n\t\t}\n\t}\n}\n\ninline void get_g ()\n{\n\tint ALL = (1 << Log) - 1;\n\tfor (int i = 0; i <= ALL; ++i) g[i] = N + 1;\n\tg[0] = N;\n\tfor (int i = 0; i <= ALL; ++i)\n\t{\n\t\tif (g[i] == N + 1) continue;\n//\t\tcout << i << ' ' << g[i] << endl;\n\t\tint preL = g[i];\n\t\tfor (int j = 1; j <= Log; ++j)\n\t\t{\n\t\t\tif (i & (1 << (j - 1))) continue;\n\t\t\tint x = lower_bound (R[j] + 1, R[j] + R[j][0] + 1, preL - 1) - R[j];\n//\t\t\tfor (int k = 1; k <= R[j][0]; ++k) cout << R[j][k] << ' '; puts(\"\");\n\t\t\tint nowL = min (preL, L[j][x]);\n//\t\t\tcout << nowL << endl;\n//\t\t\tcout << (i | (1 << (j - 1))) << endl;\n\t\t\tChkmin (g[i | (1 << (j - 1))], nowL);\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tget_seg ();\n\tget_f ();\n\tget_g ();\n\n\tint ALL = (1 << Log) - 1;\n\tfor (int i = 1; i <= L[0][0]; ++i)\n\t{\n\t\tint l = L[0][i], r = R[0][i], fl = 0;\n//\t\tDEBUG (i);\n//\t\tcout << l << ' ' << r << endl;\n\t\tfor (int j = 0; j <= ALL; ++j)\n\t\t\tif (l - 1 <= f[j] && g[ALL ^ j] <= r + 1)\n\t\t\t{\n//\t\t\t\tcout << j << ' ' << f[j] << ' '<< g[ALL ^ j] << endl;\n\t\t\t\tfl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (fl) for (int j = l; j <= r; ++j) puts(\"Possible\");\n\t\telse for (int j = l; j <= r; ++j) puts(\"Impossible\");\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), V = read<int>(), Log = log2(V) + 1;\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M, H;\nint A[200000];\nvector<int> L[20];\nvector<int> V[20];  // 頂点番号\nvector<int> G[200000 * 20];\n\nmap<vector<int>, bool> memo[20];\nbool rec(const vector<int>& vs, int depth) {\n  if (vs.size() <= 1) return true;\n  if (depth == H - 1) return false;\n  auto it = memo[depth].find(vs);\n  if (it != memo[depth].end()) return it->second;\n  \n  int sum = 0;\n  for (int from : vs) {\n    sum += G[from].size();\n  }\n  \n  for (int i = 0; i < vs.size(); ++i) {\n    if (sum - G[vs[i]].size() > H - depth) continue;\n    vector<int> nvs;\n    for (int j = 0; j < vs.size(); ++j) {\n      if (j == i) continue;\n      int from = vs[j];\n      for (int nv : G[from]) {\n        nvs.push_back(nv);\n      }\n    }\n    if (rec(nvs, depth + 1)) return memo[depth][vs] = true;\n  }\n  return memo[depth][vs] = false;\n}\n\nvoid create() {\n  V[0] = {0};\n  int nv = 1;\n  for (int k = 1; k < H; ++k) {\n    int ni = 0;\n    for (int i = 1; i < L[k - 1].size(); ++i) {\n      int l = L[k - 1][i - 1];\n      int r = L[k - 1][i];\n      int v = V[k - 1][i - 1];\n      while (ni < L[k].size() && L[k][ni] < r) {\n        G[v].push_back(nv);\n        V[k].push_back(nv);\n        ++nv;\n        ++ni;\n      }\n    }\n  }\n}\n\nvoid pre() {\n  L[0] = {0, N};\n  int s = M;\n  int k = 1;\n  while (true) {\n    L[k].push_back(0);\n    for (int i = 1; i < N; ++i) {\n      if (A[i] - A[i - 1] > s) {\n        L[k].push_back(i);\n      }\n    }\n    L[k].push_back(N);\n    if (s == 0) break;\n    s /= 2;\n    ++k;\n  }\n  H = k + 1;\n}\n\nint main() {\n  cin >> N >> M;\n  for (int i = 0; i < N; ++i) cin >> A[i];\n  pre();\n  create();\n  \n  int P = V[1].size();\n  for (int i = 1; i <= P; ++i) {\n    vector<int> vs;\n    for (int j = 1; j <= P; ++j) {\n      if (j == i) continue;\n      for (int v : G[j]) {\n        vs.push_back(v);\n      }\n    }\n    \n    bool ans = rec(vs, 2);\n    for (int z = L[1][i - 1]; z < L[1][i]; ++z) {\n      cout << (ans ? \"Possible\" : \"Impossible\") << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define inf 0x3f3f3f3f\n#define N 200010\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint n,v,tot=-1,bin[22],R[22][N],num[22],f1[N<<3],f2[N<<3],a[N];//R[i][k],第i层的第k条线段的右端点 \n//num[i],第i层的线段条数 f1[s],选择s状态的层数,左边从1开始最远能覆盖到哪里 \nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tn=read();v=read();bin[0]=1;\n\tfor(int i=1;i<=20;++i) bin[i]=bin[i-1]<<1;\n\tfor(int i=1;i<=n;++i) a[i]=read();int x=v*2;\n\twhile(x){\n\t\tx/=2;tot++;\n\t\tfor(int i=1;i<=n-1;++i){\n\t\t\tif(a[i+1]-a[i]<=x) continue;\n\t\t\tR[tot][++num[tot]]=i;\n\t\t}R[tot][++num[tot]]=n;\n\t}if(num[0]>tot+1){\n\t\tfor(int i=1;i<=n;++i) puts(\"Impossible\");return 0;\n\t}\n\tfor(int s=0;s<=bin[tot]-1;++s) f2[s]=n+1;\n\tfor(int s=0;s<=bin[tot]-1;++s)\n\t\tfor(int i=1;i<=tot;++i){\n\t\t\tif(s&bin[i-1]) continue;\n\t\t\tf1[s|bin[i-1]]=max(f1[s|bin[i-1]],*upper_bound(R[i]+1,R[i]+num[i]+1,f1[s]));\n\t\t\tf2[s|bin[i-1]]=min(f2[s|bin[i-1]],R[i][lower_bound(R[i]+1,R[i]+num[i]+1,f2[s]-1)-R[i]-1]+1);\n\t\t}\n\tfor(int i=1;i<=num[0];++i){\n\t\tbool flag=0;\n\t\tfor(int s=0;s<=bin[tot]-1;++s)\n\t\t\tif(f1[s]>=R[0][i-1]&&f2[bin[tot]-1-s]<=R[0][i]+1){flag=1;break;}\n\t\tfor(int j=R[0][i-1]+1;j<=R[0][i];++j) puts(flag?\"Possible\":\"Impossible\");\n\t}return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(),v.end()\n\nconst int maxn = 2e5 + 100, maxlg = 20;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, v, vols[maxlg], volCount, nxt[maxlg][maxn], dp[(1 << maxlg)];\nll x[maxn], a[maxn];\nbool ans[maxn];\nset<int> counter;\n\nvoid printAnsAndExit() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << (ans[i] ? \"Possible\" : \"Impossible\") << endl;\n\t}\n\texit(0);\n}\n\nvoid solve(int l, int r) {\n\tmemset(dp, 0, sizeof(dp));\n\tif (l == 0) {\n\t\tdp[0] = r + 1;\n\t}\n\tfor (int mask = 0; mask < (1 << (volCount - 1)); mask++) {\n\t\tfor (int bit = 0; bit < volCount - 1; bit++) {\n\t\t\tif (!((mask >> bit) & 1)) {\n\t\t\t\tint val = nxt[bit][dp[mask]] + 1;\n\t\t\t\tif (l <= val && val <= r) {\n\t\t\t\t\tval = r + 1;\n\t\t\t\t}\n\t\t\t\tdp[mask | (1 << bit)] = max(dp[mask | (1 << bit)], val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mx = *max_element(dp, dp + (1 << maxlg));\n\tif (mx == n) {\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tans[i] = true;\n\t\t}\n\t}\n}\n\nvoid solveAll() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcounter.insert(nxt[volCount - 1][i]);\n\t}\n\tif (counter.size() > volCount) {\n\t\tprintAnsAndExit();\n\t}\n\t\n\tint l = 0, r = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (nxt[volCount - 1][r] == nxt[volCount - 1][i]) {\n\t\t\tr++;\n\t\t}\n\t\telse {\n\t\t\tsolve(l, r);\n\t\t\tr++;\n\t\t\tl = r;\n\t\t}\n\t}\n\tsolve(l, r);\n}\n\n\nvoid calcVols(int v) {\n\tint count = 0, tmp = v;\n\twhile (tmp) {\n\t\ttmp /= 2;\n\t\tcount++;\n\t}\n\tvolCount = ++count;\n\twhile (count) {\n\t\tvols[--count] = v;\n\t\tv /= 2;\n\t}\n}\n\nvoid calcNxt() {\n\tfor (int vol = 0; vol < volCount; vol++) {\n\t\tint l = 0, r = 0;\n\t\twhile (r < n - 1) {\n\t\t\tif (x[r + 1] - x[r] <= vols[vol]) {\n\t\t\t\tr++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (l <= r) {\n\t\t\t\t\tnxt[vol][l] = r;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\twhile (l <= r) {\n\t\t\tnxt[vol][l] = r;\n\t\t\tl++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t\ta[i] = x[i];\n\t}\n\n\tcalcVols(v);\n\tcalcNxt();\n\tsolveAll();\n\tprintAnsAndExit();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 233333;\nint n,v,a[N],len,f[1<<19|3],g[1<<19|3];\nstruct Seg{\n\tint l[N],r[N];\n\tvoid init(int x){\n\t\tper(i,n,1){r[i]=i;if(i+1<=n&&a[i+1]-a[i]<=x)r[i]=r[i+1];}\n\t\trep(i,1,n){l[i]=i;if(i-1>=1&&a[i]-a[i-1]<=x)l[i]=l[i-1];}\n\t\tl[0]=0;r[n+1]=n+1;\n\t}\n}b[20];\nint main() {//freopen(\"57.txt\",\"r\",stdin);freopen(\"1.out\",\"w\",stdout);\n\tread(n);read(v);rep(i,1,n)read(a[i]);\n\twhile(1){b[++len].init(v);if(!v)break;v/=2;}\n\tint all=(1<<len-1)-1;//2..len(0..len-2) merge 1\n\trep(i,0,all)g[i]=n+1;\n\trep(i,0,all)rep(j,2,len)if(!(i>>j-2&1))umax(f[i|(1<<j-2)],f[i]+1>n?n:b[j].r[f[i]+1]);\n\trep(i,0,all)rep(j,2,len)if(!(i>>j-2&1))umin(g[i|(1<<j-2)],g[i]-1<1?1:b[j].l[g[i]-1]);\n\tint cnt=0;\n\tfor(int i=1;i<=n;i=b[1].r[i]+1)cnt++;\n\tif(cnt>len){\n\t\trep(i,1,n)puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i=b[1].r[i]+1){\n\t\tint l=i,r=b[1].r[i];bool ok=0;\n\t\trep(s,0,all)ok|=f[s]>=l-1&&g[s^all]<=r+1;\n\t//\tprintf(\"solve %d %d\\n\",l,r);\n\t\trep(j,l,r)printf(\"%s\\n\",ok?\"Possible\":\"Impossible\");\n\t}\n//\tcerr<<len<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N,V;\nint x[MAXN],d[30],tot,r[30][MAXN],l[30][MAXN];\nint dp[2][(1 << 19) + 5];\nvoid Solve() {\n    read(N);read(V);\n    for(int i = 1 ; i <= N ; ++i) read(x[i]);\n    d[0] = V / 2;\n    while(d[tot]) {\n\t++tot;\n\td[tot] = d[tot - 1] / 2;\n    }\n    for(int j = 0 ; j <= tot ; ++j) {\n\tr[j][N] = N;r[j][N + 1] = N + 1;\n\tfor(int i = N - 1 ; i >= 1 ; --i) {\n\t    r[j][i] = i;\n\t    if(x[i + 1] - x[i] <= d[j]) r[j][i] = r[j][i + 1];\n\t}\n\tl[j][1] = 1;\n\tfor(int i = 2 ; i <= N ; ++i) {\n\t    l[j][i] = i;\n\t    if(x[i] - x[i - 1] <= d[j]) l[j][i] = l[j][i - 1];\n\t}\n    }\n    dp[0][0] = 0;dp[1][0] = N + 1;\n    for(int S = 1 ; S < (1 << (tot + 1)) ; ++S) {\n\tdp[1][S] = N + 1;\n\tfor(int j = 0 ; j <= tot ; ++j) {\n\t    if(S >> j & 1) {\n\t\tdp[0][S] = max(r[j][dp[0][S ^ (1 << j)] + 1],dp[0][S]);\n\t\tdp[1][S] = min(l[j][dp[1][S ^ (1 << j)] - 1],dp[1][S]);\n\t    }\n\t}\n    }\n    int cnt = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n\tint l = i,r = i;\n\twhile(r < N && x[r + 1] - x[r] <= V) ++r;\n\ti = r;\n\t++cnt;\n    }\n    if(cnt - 1 > tot + 1) {\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    puts(\"Impossible\");\n\t}\n\treturn;\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n\tint l = i,r = i;\n\twhile(r < N && x[r + 1] - x[r] <= V) ++r;\n\tint A = (1 << tot + 1) - 1;\n\tbool f = 0;\n\tfor(int S = 0 ; S < (1 << tot + 1) ; ++S) {\n\t    if(dp[0][S] >= l - 1 && dp[1][A ^ S] <= r + 1) {f = 1;break;}\n\t}\n\tfor(int i = l ; i <= r ; ++i) {\n\t    if(f) puts(\"Possible\");\n\t    else puts(\"Impossible\");\n\t}\n\ti = r;\n    }\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <deque>\n#include <utility>\n#include <chrono>\n#include <sstream>\n#include <iomanip>\n#define INF 1 << 30\n#define MOD 1000000007;\n#define pi 3.14159265358979\n#define rep(i, n) for (int (i) = 0; (i) < (int)(n); (i)++)\n#define reu(i, l, r) for (int (i) = (int)(l); (i) < (int)(r); (i)++)\n#define D(x) cout << x << endl\n#define d(x) cout << x\n#define all(x) (x).begin(), (x).end()\n#define pub(x) push_back(x)\n#define pob() pop_back()\n#define puf(x) push_front(x)\n#define pof() pop_front()\n#define mp(x, y) make_pair((x), (y))\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if (x < y) x = y; }\nstatic const int dx[] = {0, 0, 1, -1};\nstatic const int dy[] = {-1, 1, 0, 0};\n\nint main() { \n  int n, v;\n  cin >> n >> v;\n  vi x(n);\n  vi dis(n - 1);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i];\n    if (i != 0) {\n      dis[i - 1] = x[i] - x[i - 1];\n    }\n  }\n  vi vv;\n  while (v > 0) {\n    vv.pub(v);\n    v /= 2;\n  }\n  vv.pub(0);\n\n  vector<vector<bool>> wall(vv.size(), vector<bool> (n, false));\n\n  for (int i = 0; i < vv.size(); i++) {\n    for (int j = 0; j < n  - 1; j++) {\n      if (dis[j] > vv[i]) {\n        wall[i][j] = true;\n      }\n    }\n    wall[i][n - 1] = true;\n  }\n  \n  vector<string> ans;\n\n  int i = 0;\n  while (i < n) {\n    int cnt = 0;\n    vector<bool> done(n);\n\n    while (!wall[0][i]) {\n      done[i] = true;\n      i++;\n      cnt++;\n    }\n    done[i] = true;\n    i++;\n    cnt++;\n\n    for (int j = 1; j < vv.size(); j++) {\n      int maxd = -1;\n      int maxk = -1;\n      for (int k = 0; k < n; k++) {\n        if (!wall[j][k] && !done[k]) {\n          if (maxd < dis[k]) {\n            maxd = dis[k];\n            maxk = k;\n          }\n        }\n      }\n\n      if (maxk == -1) {\n        break;\n      }\n      \n      int kpf = maxk + 1;\n      while (!wall[j][kpf] && kpf < n) {\n        done[kpf] = true;\n        kpf++;\n      }\n      int kpb = maxk;\n      while (!wall[j][kpb] && kpb > 0) {\n        done[kpb] = true;\n        kpb--;\n      }\n    }\n    \n    bool end = true;\n    for (int p = 0; p < n; p++) {\n      if (!done[i]) {\n        end = false;\n      }\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      if (end) {\n        ans.pub(\"Possible\");\n      } else {\n        ans.pub(\"Impossible\");\n      }\n    }\n  }\n\n  for (int i = 0; i < ans.size(); i++) {\n    D(ans[i]);\n  }\n\n  //for (int i = 0; i < dis.size(); i++) {\n  //  d(setw(3) << dis[i] << \" \" );\n  //}\n  //D(\"\");     \n  //for (int i = 0; i < vv.size(); i++) {\n  //  for (int j = 0; j < n - 1; j++) {\n  //    d(setw(3) << wall[i][j] << \" \");\n  //  }\n  //  D(\"\");\n  //}\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst int N=200005;\n\nint n,v,tot,cnt;\nint x[N],R[22][N],L[22][N],b[22],id[N],p1[N],p2[N],f[N],g[N],ans[N];\n\nvoid init(){\n\tint i,j,k,l;\n\tmemset(L,0x3f,sizeof(L));\n\tfor (i=0;i<tot;i++){\n\t\tfor (j=1;j<=n;j=k+1){\n\t\t\tk=j;\n\t\t\twhile (k<n&&x[k+1]-x[k]<=b[i]) k++;\n\t\t\tfor (l=j;l<=k;l++){\n\t\t\t\tL[i][l]=j; R[i][l]=k;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i=1;i<=n;i=k+1){\n\t\tk=i; cnt++;\n\t\twhile (k<n&&x[k+1]-x[k]<=b[tot]) k++;\n\t\tfor (l=i;l<=k;l++){\n\t\t\tid[l]=cnt;\n\t\t\tp1[cnt]=i; p2[cnt]=k;\n\t\t} \n\t}\n}\n\nvoid work(){\n\tint i,j,sz,s,ss,l,r;\n\tsz=(1<<tot)-1;\n\tfor (i=0;i<=sz;i++) f[i]=n+1;\n\tfor (s=0;s<=sz;s++){\n\t\tfor (j=0;j<tot;j++)\n\t\t\tif (!((s>>j)&1)){\n\t\t\t\tss=s|(1<<j);\n\t\t\t\tf[ss]=min(f[ss],L[j][f[s]-1]);\n\t\t\t\tg[ss]=max(g[ss],R[j][g[s]+1]);\n\t\t\t}\n\t}\n\tfor (s=0;s<=sz;s++){\n\t\tl=g[s]; r=f[sz^s];\n\t\tif (l+1>=r){\n\t\t\tfor (i=1;i<=n;i++) ans[i]=1;\n\t\t\treturn;\n\t\t}\n\t\tif (p1[id[l+1]]<=l+1&&p2[id[l+1]]>=r-1) ans[id[l+1]]=1;\n\t}\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d%d\",&n,&v);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tb[0]=0;\n\twhile (v){\n\t\tb[++tot]=v;\n\t\tv/=2;\n\t}\n\tsort(b,b+tot+1);\n\tinit();\n\twork();\n\tfor (i=1;i<=n;i++)\n\t\tif (ans[id[i]]) printf(\"Possible\\n\");\n\telse printf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N, V;\nint M, SM;\n\nint T[21][MAX_N];\nint nex[21][MAX_N];\n\nint dp[(1 << 22)], rdp[(1 << 22)];\nint ok[MAX_N];\n\nvector<ll> v;\nll A[MAX_N];\n\nvoid pre(int dp[MAX_N]) {\n\trep(i, 0, M) {\n\t\trep(j, 0, N - 1) {\n\t\t\tT[0][j] = (abs(A[j + 1] - A[j]) > v[i]) ? j : (j + 1);\n\t\t}\n\t\tT[0][N - 1] = N - 1;\n\t\trep(q, 0, 20) {\n\t\t\trep(j, 0, N) {\n\t\t\t\tT[q + 1][j] = T[q][T[q][j]];\n\t\t\t}\n\t\t}\n\t\trep(j, 0, N) {\n\t\t\tnex[i][j] = T[20][j];\n\t\t}\n\t}\n\trep(bit, 0, (1 << SM)) {\n\t\tif(dp[bit] == N - 1) continue;\n\t\trep(i, 0, N) {\n\t\t\tif(bit & (1 << i)) continue;\n\t\t\tMAX(dp[bit | (1 << i)], nex[i][dp[bit] + 1]);\n\t\t}\n\t}\n\trep(bit, 0, (1 << SM)) {\n\t\tif(dp[bit] == N - 1) continue;\n\t\tdp[bit] = nex[SM][dp[bit] + 1];\n\t}\n}\n\nvoid solve() {\n\tcin >> N >> V;\n\trep(i, 0, N) cin >> A[i];\n\twhile(V >= 1) {\n\t\tv.pb(V);\n\t\tV /= 2;\n\t}\n\tv.pb(0);\n\tM = sz(v);\n\tSM = M - 1;\n\n\treverse(all(v));\n\t\n\tpre(dp);\n\n\treverse(A, A + N);\n\tpre(rdp);\n\n\trep(bit, 0, (1 << SM)) rdp[bit] = N - 1 - rdp[bit];\n\n\trep(bit, 0, (1 << SM)) {\n\t\tint rbit = (1 << SM) - 1 - bit;\n\t\tint l = dp[bit], r = rdp[rbit];\n\t\tl++;\n\t\tif(l > r) {\n\t\t\tok[l]--;\n\t\t\tok[r]++;\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\tok[i + 1] += ok[i];\n\t\tif(ok[i]) cout << \"Possible\\n\";\n\t\telse cout << \"Impossible\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int inf=1e9;\nconst ll Inf=1e18;\nconst int N=5e5+10;\nconst int mod=0;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ntemplate<typename T> bool chkmax(T &a,T b) { return a<b?a=b,1:0; };\ntemplate<typename T> bool chkmin(T &a,T b) { return a>b?a=b,1:0; };\nint add(int a,int b) { return a+b>=mod?a+b-mod:a+b; }\nint sub(int a,int b) { return a-b<0?a-b+mod:a-b; }\nvoid inc(int &a,int b) { a=(a+b>=mod?a+b-mod:a+b); }\nvoid dec(int &a,int b) { a=(a-b<0?a-b+mod:a-b); }\nint n,v,x[N],st[N],l[N][20],r[N][20],f[N],g[N],mn[N],top=0;\nint main() {\n    cin>>n>>v;\n    for(int i=1;i<=n;i++) x[i]=gi();\n    while(v) st[++top]=v,v>>=1;\n    st[++top]=0;\n    reverse(st+1,st+top+1);\n    for(int j=1;j<=top;j++) {\n        l[1][j]=1;\n        for(int i=2;i<=n;i++) l[i][j]=(x[i]-x[i-1]<=st[j])?l[i-1][j]:i;\n        r[n][j]=n;\n        for(int i=n-1;i;i--) r[i][j]=(x[i+1]-x[i]<=st[j])?r[i+1][j]:i;\n    }\n    f[0]=0;g[0]=n+1;\n    for(int i=1;i<(1<<top);i++) {\n        f[i]=0,g[i]=n+1;\n        for(int j=1;j<=top;j++)\n            if(i>>(j-1)&1) {\n                chkmax(f[i],(f[i^(1<<(j-1))]==n)?n:r[f[i^(1<<(j-1))]+1][j]);\n                chkmin(g[i],(g[i^(1<<(j-1))]==1)?1:l[g[i^(1<<(j-1))]-1][j]);\n            }\n    }\n    memset(mn,0x3f,sizeof(mn));\n    for(int i=0;i<(1<<(top-1));i++) chkmin(mn[f[i]],g[((1<<(top-1))-1)^i]);\n    for(int i=n-1;i;i--) chkmin(mn[i],mn[i+1]);\n    for(int i=1;i<=n;i++) puts(mn[l[i][top]-1]<=r[i][top]+1?\"Possible\":\"Impossible\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define go(x, i, v) for (int i = hd[x], v = to[i]; i; v = to[i = nx[i]])\nLL read() {\n  long long x = 0, w = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) w = ch == '-' ? -1 : 1, ch = getchar();\n  while (isdigit(ch)) {\n    x = (x << 3) + (x << 1) + ch - '0';\n    ch = getchar();\n  }\n  return x * w;\n}\nconst int Max_n = 2e5 + 5;\nint n, v;\nint a[Max_n];\nint cntl, l[Max_n][18], r[Max_n][18];\nint f[Max_n], g[Max_n], h[Max_n];\nvoid Max(int &a, int b) { a = a < b ? b : a; }\nvoid Min(int &a, int b) { a = a < b ? a : b; }\nint main() {\n  n = read(), v = read();\n  for (int i = 1; i <= n; i++) a[i] = read(), h[i] = n + 2;\n  h[0] = h[n + 1] = n + 2;\n  v <<= 1;\n  do {\n    cntl++, v >>= 1;\n    l[1][cntl] = l[0][cntl] = 1;\n    for (int i = 2; i <= n; i++) {\n      l[i][cntl] = i;\n      if (a[i] - a[i - 1] <= v)\n        l[i][cntl] = l[i - 1][cntl];\n    }\n    r[n][cntl] = r[n + 1][cntl] = n;\n    for (int i = n - 1; i; i--) {\n      r[i][cntl] = i;\n      if (a[i + 1] - a[i] <= v)\n        r[i][cntl] = r[i + 1][cntl];\n    }\n  } while (v);\n  for (int s = 0; s < (1 << cntl); s++) g[s] = n + 1;\n  for (int s = 0; s < (1 << cntl); s++) {\n    if (s & 1) continue;\n    for (int i = 2; i <= cntl; i++)\n      if (!((1 << i - 1) & s)) {\n        Max(f[s | (1 << i - 1)], r[f[s] + 1][i]);\n        Min(g[s | (1 << i - 1)], l[g[s] - 1][i]);\n      }\n  }\n  for (int s = 0; s < (1 << cntl); s++) {\n    if (s & 1) continue;\n    Min(h[f[s]], g[(1 << cntl) - 2 - s]);\n  }\n  for (int i = 1; i <= n; i++)\n    if (h[l[i][1] - 1] <= r[i][1] + 1)\n      printf(\"Possible\\n\");\n    else\n      printf(\"Impossible\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<math.h>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst long long int INF=99999999999999,inf=199999;\nconst long long int mod=1000000007;\n\n\n\nlong long int tmp,n,canmove[25]={},v,x[200005],leftdp[800000]={},rightdp[800000]={};\nlong long int leftnext[25][800005]={},rightnext[25][800005]={},two[30]={1};\nlong long int leftmemo[800005]={},rightmemo[800005]={};\nlong long int cou=0,k;\n\nvoid leftsolve(){\n    long long int count=0;\n    queue<long long int>que,memoque;\n    que.push(0);\n    \n    while(1){\n        while(!que.empty()){\n            for(int i=0;i<k;i++){\n                if((que.front()/two[i]%2)==0){\n                    leftdp[que.front()+two[i]]=max(leftdp[que.front()+two[i]],leftnext[i][leftdp[que.front()]]);\n                    //次のループで被りが出ないように\n                    if(leftmemo[que.front()+two[i]]==0){\n                        memoque.push(que.front()+two[i]);\n                        leftmemo[que.front()+two[i]]=1;\n                    }\n                }\n            }\n            que.pop();\n        }\n        while(!memoque.empty()){\n            que.push(memoque.front());\n            memoque.pop();\n        }\n        if(que.front()==two[k]-1){\n            break;\n        }\n    }\n}\n\nvoid rightsolve(){\n    long long int count=0;\n    queue<long long int>que,memoque;\n    que.push(0);\n    \n    while(1){\n        while(!que.empty()){\n            for(int i=0;i<k;i++){\n                if((que.front()/two[i])%2==0){\n                    rightdp[que.front()+two[i]]=min(rightdp[que.front()+two[i]],rightnext[i][rightdp[que.front()]]);\n                   //次のループで被りが出ないように\n                    if(rightmemo[que.front()+two[i]]==0){\n                        memoque.push(que.front()+two[i]);\n                        rightmemo[que.front()+two[i]]=1;\n                    }\n                    //cout<<que.front()<<\" \"<<two[i]<<\" \"<<endl;\n                    //cout<<que.front()+two[i]<<\" \"<<rightdp[que.front()+two[i]]<<endl;\n                }\n            }\n            que.pop();\n        }\n        while(!memoque.empty()){\n            que.push(memoque.front());\n            memoque.pop();\n        }\n        if(que.front()==two[k]-1){\n            break;\n        }\n    }\n}\n\n\nint main() {\n    \n    map<long long int,long long int>mp;\n\tcout << fixed << setprecision(10);\n    cin>>n>>v;\n    \n    for(int i=1;i<=26;i++){\n        two[i]=2*two[i-1];\n    }\n\n\n        for(int j=0;j<=199995;j++){\n            rightdp[j]=n;\n        }\n    \n\n    tmp=v;\n    while(tmp!=0){\n        canmove[cou]=tmp;\n        cou++;\n        tmp/=2;\n    }\n    k=cou+1;\n    \n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n    }\n    x[0]=INF;\n    x[n+1]=INF;\n\n    for(int i=0;i<k;i++){\n        tmp=0;\n        for(int j=2;j<=n+1;j++){\n            if(x[j]-x[j-1]>canmove[i]){\n                for(int p=tmp;p<j;p++){\n                    leftnext[i][p]=j;\n                }\n                tmp=j;\n            }\n        }\n\n        tmp=n;\n        for(int j=n-1;j>=0;j--){\n            if(x[j+1]-x[j]>canmove[i]){\n                for(int p=tmp;p>j;p--){\n                    rightnext[i][p]=j;\n                }\n                tmp=j;\n            }\n        }\n    }\n    \n    leftsolve();\n    rightsolve();\n    \n    for(int i=1;i<=n;i++){\n        //cout<<rightnext[0][i]<<\" \"<<canmove[0]<<endl;\n    }\n\n    for(int i=1;i<=n;i=leftnext[0][i]){\n        bool key=true;\n        for(int j=0;j<two[k];j+=2){\n            //cout<<leftdp[j]<<\" \"<<rightnext[0][i]<<\" \"<<rightdp[(j^(two[k]-2))]<<leftnext[0][i]<<endl;\n            if(leftdp[j]>rightnext[0][i]&&rightdp[(j^(two[k]-2))]<leftnext[0][i]){\n                for(int p=rightnext[0][i]+1;p<=leftnext[0][i]-1;p++){\n                    cout<<\"Possible\"<<endl;\n                }\n                key=false;\n                break;\n            }\n        }\n        if(key){\n            for(int p=rightnext[0][i]+1;p<=leftnext[0][i]-1;p++){\n                        cout<<\"Impossible\"<<endl;\n            }\n        }\n    }\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#define rep(i,st,ed) for (int i=st;i<=ed;++i)\n#define fill(x,t) memset(x,t,sizeof(x))\n\nconst int N=400005;\n\nint f[N],g[N],p[N],L[N],R[N],ans[N];\nint left[25][N],righ[25][N];\nint n,V,tot;\n\nint read() {\n\tint x=0,v=1; char ch=getchar();\n\tfor (;ch<'0'||ch>'9';v=(ch=='-')?(-1):(v),ch=getchar());\n\tfor (;ch<='9'&&ch>='0';x=x*10+ch-'0',ch=getchar());\n\treturn x*v;\n}\n\nvoid pre(int v,int id) {\n\tfor (int i=1,j;i<=n;i=j+1) {\n\t\tfor (j=i;j<n&&p[j+1]-p[j]<=v;) j++;\n\t\trep(k,i,j) left[id][i]=j,righ[id][j]=i;\n\t}\n}\n\nvoid solve() {\n\tfor (int i=0,lim=(1<<tot);i<lim;++i) {\n\t\tg[i]=n+1;\n\t}\n\tfor (int i=0,lim=(1<<tot);i<lim;++i) {\n\t\trep(j,0,tot-1) if ((i>>j)&1) {\n\t\t\tf[i]=std:: max(f[i],left[j][f[i-(1<<j)]+1]);\n\t\t\tg[i]=std:: min(g[i],righ[j][g[i-(1<<j)]-1]);\n\t\t}\n\t}\n\tfor (int i=0,lim=(1<<tot);i<lim;++i) {\n\t\tint j=lim-i-1;\n\t\trep(k,1,n) if (f[i]+1>=L[k]&&g[j]<=R[k]+1) {\n\t\t\tans[k]=1;\n\t\t}\n\t}\n}\n\nint main(void) {\n\tfill(righ,63);\n\tn=read(),V=read();\n\trep(i,1,n) p[i]=read();\n\tfor (int v=V/2;;v>>=1) {\n\t\tpre(v,tot++);\n\t\tif (!v) break;\n\t}\n\tfor (int i=1,j;i<=n;i=j+1) {\n\t\tfor (j=i;j<n&&p[j+1]-p[j]<=V;) j++;\n\t\trep(k,i,j) L[k]=i,R[k]=j;\n\t}\n\tsolve();\n\trep(i,1,n) if (ans[i]) puts(\"Possible\");\n\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<vector>\n#define N 200005\nusing namespace std;\nvector<int> G[N];\nint n,m,v,a[N],r[20][N],f[1<<20],g[1<<20],ufs[20][N];\nint find(int op,int x){ return ufs[op][x] ? ufs[op][x]=find(op,ufs[op][x]) : x;}\nint main()\n{\n\tint i,j,x,p,y,T;\n\tscanf(\"%d %d\",&n,&v);\n\tfor(i=v,m=0;i;i>>=1,m++);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(i=0;i<=m;i++){\n\t\tfor(j=1;j<=n;j++) r[i][j]=j;\n\t\tfor(j=1;j<n;j++)\n\t\t\tif(a[j+1]-a[j]<=(v>>i))\n\t\t\t\tx=find(i,j),ufs[i][j+1]=x,r[i][x]=j+1;\n\t  }\n\tfor(i=1;i<(1<<m);i++)\n\t\tfor(j=0;j<m;j++)\n\t\t\tif((i>>j)&1){\n\t\t\t\tx=r[j+1][find(j+1,f[i^(1<<j)]+1)];\n\t\t\t\tf[i]=max(f[i],x);\n\t\t\t  }\n\tfor(i=0;i<(1<<m);i++) g[i]=n+1;\n\tfor(i=1;i<(1<<m);i++)\n\t\tfor(j=0;j<m;j++)\n\t\t\tif((i>>j)&1){\n\t\t\t\tx=find(j+1,g[i^(1<<j)]-1);\n\t\t\t\tg[i]=min(g[i],x);\n\t\t\t  }\n\tT=(1<<m)-1,p=0,y=-100;\n\tfor(i=0;i<=T;i++)\n\t\tG[g[T^i]].push_back(f[i]);\n\tfor(i=1;i<=n;i++){\n\t\tx=find(0,i);\n\t\twhile(p<=r[0][x]+1){\n\t\t\tfor(j=0;j<G[p].size();j++)\n\t\t\t\ty=max(y,G[p][j]);\n\t\t\tp++;\n\t\t  }\n\t\tif(y<x-1) printf(\"Impossible\\n\");\n\t\telse printf(\"Possible\\n\");\n\t  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,V;\nint X[202020],id[202020];\npair<ll,int> P[202020];\nint ret[202020],imos[202020];\n\nint ML;\nint L[202020][20],R[202020][20];\nint Ldp[1<<20];\nint Rdp[1<<20];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>V;\n\tFOR(i,N) cin>>x, P[i]={x,i};\n\tsort(P,P+N);\n\tFOR(i,N) id[P[i].second]=i, X[i]=P[i].first;\n\t\n\twhile(1<<ML <= V) ML++;\n\tML++;\n\t\n\tFOR(i,20) {\n\t\tFOR(x,N) {\n\t\t\tif(x && X[x]-X[x-1]<=V>>i) L[x][i]=L[x-1][i];\n\t\t\telse L[x][i]=x;\n\t\t}\n\t\tfor(x=N-1;x>=0;x--) {\n\t\t\tif(x<N-1 && X[x+1]-X[x]<=V>>i) R[x][i]=R[x+1][i];\n\t\t\telse R[x][i]=x;\n\t\t}\n\t}\n\t\n\tMINUS(Ldp);\n\tFOR(i,1<<ML) Ldp[i]=-2,Rdp[i]=N+1;\n\tLdp[0]=-1;\n\tRdp[0]=N;\n\t\n\tfor(int mask=0;mask<1<<ML;mask++) {\n\t\tFOR(i,ML) if((mask & (1<<i))==0) {\n\t\t\tif(Ldp[mask]==N-1) Ldp[mask | (1<<i)] = N-1;\n\t\t\telse if(Ldp[mask]>=-1) Ldp[mask | (1<<i)] = max(Ldp[mask | (1<<i)], R[Ldp[mask]+1][i]);\n\t\t\tif(Rdp[mask]==0) Rdp[mask | (1<<i)] = 0;\n\t\t\telse if(Rdp[mask]<=N) Rdp[mask | (1<<i)] = min(Rdp[mask | (1<<i)], L[Rdp[mask]-1][i]);\n\t\t}\n\t}\n\t\n\tfor(int mask=0;mask<1<<ML;mask+=2) {\n\t\tint mask2=((1<<ML)-2)^mask;\n\t\t//_P(\"%x %x : %d %d\\n\",mask,mask2,Ldp[mask],Rdp[mask2]);\n\t\tif(Ldp[mask]+1>=Rdp[mask2]) {\n\t\t\tFOR(i,N) ret[i]=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(R[Ldp[mask]+1][0]+1>=Rdp[mask2]) {\n\t\t\timos[Ldp[mask]+1]++;\n\t\t\timos[R[Ldp[mask]+1][0]+1]--;\n\t\t}\n\t}\n\t\n\tFOR(i,N) {\n\t\timos[i+1]+=imos[i];\n\t\tret[i] |= imos[i];\n\t\tif(ret[id[i]]) cout<<\"Possible\"<<endl;\n\t\telse cout<<\"Impossible\"<<endl;\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <assert.h>\nusing namespace std;\nint n,v,m,a[200005],len[25],L[200005][25],R[200005][25],f[1000005],g[1000005];\npriority_queue<int> q;\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\twhile(v) len[m++]=v,v>>=1;len[m++]=0;\n\tfor(int i=0;i<m/2;i++) swap(len[i],len[m-i-1]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tL[i][p]=L[i-1][p];\n\t\t\tif(i==1||a[i]-a[i-1]>len[p]) L[i][p]=i;\n\t\t}\n\t}\n\tfor(int i=n;i;i--){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tR[i][p]=R[i+1][p];\n\t\t\tif(i==n||a[i+1]-a[i]>len[p]) R[i][p]=i;\n\t\t}\n\t}\n\tf[0]=0;g[0]=n+1;\n\tfor(int i=1;i<(1<<m);i++){\n\t\tg[i]=n+1;\n\t\tfor(int p=0;p<m;p++) if(i&(1<<p)){\n\t\t\tf[i]=max(f[i],f[i^(1<<p)]);\n\t\t\tf[i]=max(f[i],R[f[i^(1<<p)]+1][p]);\n\t\t\tg[i]=min(g[i],L[g[i^(1<<p)]-1][p]);\n\t\t}\n\t}\n\tfor(int i=1;i<(1<<m);i++){\n\t\tassert(f[i]<f[i-1]);\n\t\tassert(g[i]>g[i-1]);\n\t}\n\tfor(int i=1;i<(1<<m);i++) f[i]=max(f[i],f[i-1]),g[i]=min(g[i],g[i-1]);\n\tint S=(1<<m-1)-1;\n\tfor(int i=1,pos=0;i<=n;i++){\n\t\twhile(f[pos]>=L[i][m-1]-1&&pos<=S) q.push(S^pos),pos++;\n\t\twhile(!q.empty()&&f[S^q.top()]<L[i][m-1]-1) q.pop();\n\t\tif(q.empty()){\n\t\t\tputs(\"Impossible\");continue;\n\t\t}\n\t\tif(g[q.top()]>R[i][m-1]+1) puts(\"Impossible\");\n\t\telse puts(\"Possible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][30],tmp[30][30];\n\nstd::unordered_map<ull,bool>hs;\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\tull hash=dep;\n\tfo0(i,cnt)hash=hash*2337+s[i];\n\tif(hs.count(hash))return hs[hash];\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>=dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\tr[i]=t[i];\n\t}\n\treturn hs[hash]=0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *                             UM.\n *                            J@B@1                                                                    iO@1\n *                           Y@@@B@BB.                                                              7B@B@B@\n *                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n *                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n *                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n *                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n *                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n *                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n *                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n *                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n *                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n *                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n *                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n *                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n *                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n *                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n *                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n *                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n *                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n *                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n *                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n *                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n *               ZB@B.                                              ,v.                                        @B@L\n *              LB@B,                         Y7                    @B@Bu                                      7@B@\n *   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n *    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n *         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n *            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n *            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n *           2@B@                                                                                               ,O@B@B@B@B\n *           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n *           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n *           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n *           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n *           @B@                         @B@B@@@i                       rL7.                                    B@BM\n *           B@B7.:                       NB@@M.                                                               .@B@.\n *  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n *@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n *7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n *            @@@U                                                                                           B@BJ.YO@B@B@i\n *            r@B@                                                                                         :B@Bk     .k@B@\n *             B@B@                                                                                       LB@@k        2i\n *              B@BM                                      .7jXEGqF7:                                     OB@@L\n *              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n *               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n *                 B@@@S                                                                           ,MB@B@,\n *                  v@@@BF                                                                      .1B@B@Br\n *                    2@@B@BL                                                                ,FB@@@B8,\n *                      r@B@B@BF,                                                        :YBB@B@B@B\n *                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n *                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n *                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n *                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n *                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n *                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n *                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n *                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n *                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n *                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n *                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n *                          i@@@@                     0@B@u          B@@B.                       vB@B\n *                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n *                          vNi                          S@@B@B@B@B@BM:                            MB@N\n *                                                          758BMqJ,\n *\n *                   .  YO.               vq                            :G       Z:\n *          SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n *          B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n *              iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n *         vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n *         N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n *              r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n *              7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n *         ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n *         E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n *              7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n *              LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n *          .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n *          MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n *                            .ll                                           rB.                     :\n                 .::                                                       ,,         .:                    :,         :.\n          :LuqL  5B@   :v             77L21F5F5F5F1F5S15Uv7,              :@B         0@U                  .B@        L@P\n B@B@@@B@B@B@@B  L@B   B@B@,          @BB2XSPSPkPXPkPXPF2B@B     .@B@B@B@B@@@B@B@B@B@@@B@B@B@B@B@ :@@@@BBMOB@BGM@B@BME@@@EMB@B@B@r\n ,Yi:  @B2       iB@     2@@@7        B@,                8Bq      vriii:.:0@@:ii::,:::B@B::iiii77 ,E1uJuJJ7GB@7LUk2ULvB@B7LjJjjSq:\n       B@7        @B       i7         @B@B@B@B@B@B@B@B@B@B@k          @B  .BZ    u@.   :                   ,@N        7B2\n0EqEqX2@B@1N0Z0ZSqB@qX0ZNPUYLSZ8      B@                 NBP          :@B       1@BMX0uj2EEZN15,    8@B@B@@@GGB@7 5@B@BOM@B@B@B.\n@B@B@B@@@B@B@B@B@B@B@B@B@B@B@B@B      @B@B@B@B@B@B@B@B@B@B@q      @B@B@B@B@@@u S@B2qOOMOMM@BMB@L              @@7            B@.\n       @Bv        @@v       .         B@:                k@v      :i;.,...q5::B@k            @Bi     8@@B@B@B@B@v  BB@B@B@B@@@B.\n       B@L   .,7  0B@     SB@S   :5jj7vi::iiiii:..,:iii::;77LY25   B@     @B u@20B@B@B@B@N   @@:     B@       .:   B@        ::\n .:v28P@B@@@B@B@, ,@@   u@B@.    YB@B@ME0OB@B@@@B@BMB@B@BBOBB@B@.  L@@   OBS    B@:    JB@   @B.    v@BLuXP0qXvL: 1@B7ukXE00SYvL\n@@@B@B@B@Z.        B@kLB@B:            7Ei      @@;                 @B:  B@     @B     .@O   B@      LO1i   , @B0  ;BX7.  ,..P@B\n       @Bu         1B@B5     ::       :@B       B@@@B@B@@@B@B@      7@@ U@u     B@i,::.PB@   @B      .7OBGu   Z@v   rNBOFi   7B8\n       B@5      7B@B@B@      B@B     i@B@7      @BN.::i:i:i:ii       17 @B      @B@B@B@MMY   B@          u@OBUMBi      :@BNBYv@F\n       @B0  u@B@B@L  kB@;    @@;    0@B.J@@O:   B@i               ,:ii7@B@B@@@u SZ          i@B    LB@@@B@5Y, B@, 5@@@B@GFY: ZBu\n :5rr:5B@J  MBM:      iB@@k:@@@  ,NB@E    k@@B@B@B@qEZMMBM@MBB@Br @B@B@OY77:,      :MSUjuukB@Br    iBvUr.   .8@B  i5::r     YB@\n .B@B@BZ:                0B@B8   @BO         .:i:77uU5uFSkFkFXXq                    B@B@@@GU.         ,@B@B@BM:       B@B@B@B7\n          .:7kq  ;@B,   ,                   @B.    i@M                .B@,      N@@       .BO       :,.            .:..\n LB@@@B@B@B@B@@  :B@,  EB@O,                B@i    U@@                 ,q@BX    1@B    ,q@B0:      ,B@B@B@B@B@B@1  @B@B@B@B@B@B@\n  kri. M@@        @B:    u@B@J    @B@B@B@B@@@Bi    J@@@B@B@B@B@B   irrvi:u@BjLJ7@B@7YYLB@Bj::rir              @Bj            i@B\n       EBO        @@:      :1     iiii:i::,:B@:    uB@.::i:i:iii   @B@qquvrLu1127rrUU5Uvrrv5q@B@.    .,iiiii::B@L   .,:iiiii:E@@\nYLLvv7iB@Bi7YLYL7r@@ErLLL7r::iYU            @@i    Y@@             B@k      . .     ...       @B,    B@B@B@B@B@BF   @B@B@B@B@@@B\n@@B@B@B@B@@@B@B@B@B@B@B@B@B@B@B@.           B@i    uB@             r7. ,B@MMMBMBMBMBMBMMG@B@  7v    r@M            LB8\n       E@O        PBM       .     vB@B@B@@@B@Bi    J@B@B@B@B@@@7       .@B               P@8        @BX.::i:i:     B@2,:::i:i.  .\n       Z@M     ;  ;@B     i@@@    ,ULYLJLL77@@i    uB@ivLYLJLJu:       ,B@B@B@B@B@B@B@B@B@B@        BOEOB@B@B@B@q  BZNO@B@B@B@B@@\n  ,:i7JB@B@B@B@@u  B@:  :B@Bv               @Bi    J@B                  2J      uB@      :u:         @@r      @BL  7@X:       8BZ\nB@B@B@B@B@,i.      kBBi@B@L                 B@i    j@@               uYjvJ2kSk1jM@@u2kFS1uLuJUi      iu@B@O   B@i  .iNB@Bj    B@u\n .     Z@M         :@B@Mi     :  rEXqXXXPS5U@Bi    Y@Bj1XXqkXXN07    B@Bq088OOGk@B@SE8OZZNq5@B@          i7:, @@,       ::i2r @B7\n       MB@      ,8B@B@B      kB@ Y@@B@B@BBOGB@i    uB@EMB@B@B@B@j    @Bi        7@B         G@8    ukBB@@@B@P B@  .75BB@@@B@: B@:\n       O@B  7u@B@BO, v@@v    B@G            @Bi    J@B               B@Y        uB@    7:,.i@BS   ,B@B1:     .@B  N@@BL       @B.\n  5ri:r@B@  k@BL.     ,@B@q:5@B             B@r    1@@               @B7        F@B    @B@B@Or        .i.,,:1@B8       r,:::u@B@\n  @B@B@B1               .q@B@B:             @Br    L@B                          5B@                   kB@B@@@5.       r@@@@B@Z;\n           ,ijN   B@L   .             B@5                          .:...,:,:,.     ,,:.......                  ... .\n :@B@B@@@B@B@@@i  @B1  j@B@.         .@B      .B@B@B@@@B@B@B@B@B   G@B@B@B@B@B@B  .B@B@B@@@B@B@v    7;L7ri. @@@B@B@@ B@B@B@@@B@B@@\n  NLrr:0B@        B@2    YB@@N       UBB       ... .      .@B@Bi              B@             @Br    B@BBB@8 B@   JBE         :B@\n       :@B        BBk      .O:   E@B@B@B@B@B@P          .M@BS        ..,:,:,.7@@    ,.:,:::.,B@i    @B  :BS BB   B@           @B\n:L77rr:E@@ir7vvvr:B@B:rv7ri:::rJ :7ij@Biir:@BM        :@B@i         v@B@@@B@B@@@   UB@B@B@B@B@BL    B@  i@5 M@  S@v  UB@B@@M  B@\n8B@B@B@B@B@B@B@B@B@@@B@B@@@B@B@@L   JBM    @@i        5B@           @B.            @@               @B  ;@F BB  @B   O@L .@B  @B\n       7B@        i@B               @@,    @B         L@B          ,B@..,:,,..    :@B..,,:,:.  .    B@  i@5 M@ .B@   NB.  B@  @@\n       ;@B     ,,  B@      @@B.    U@B    0BE @B@B@B@B@B@B@B@B@B@  LBEOB@@@B@B@B  UO0G@B@B@B@B@Bi   @B  rBS MB. :@@  X@,  @B  @B\n    ,;7B@@B@B@B@B  @B5   MB@q      @B7    B@          Y@B           :@5.      B@   OOv        @@    B@  i@5 M@.  jB5 kB.  B@  B@\n7B@B@B@B@@1r:      ;@B.Z@@O        iB@@r B@j          vB@           ,1@B@B;  :@B   i0B@B@     @B    @B  ,BF MB.   @B 2@5i7@B  @B\n ::    7B@          B@B@u             7@B@B           Y@@                j , r@@        i :0 ,B@    B@LLG@F M@    @@ 0@@B@MZ  B@\n       L@B       v@B@@@:     :@B:      B@B@B1.        jB@         :LLkBB@B@B 7@B  :7L0@B@@@B :@@    @@MO@BO BB2B@B@7 Y@       @@\n       7B@  .7B@B@B7 :B@u    qB@    .@B@  .@B@:       7@B         O@@B7,     BBO  B@BMi      SB@    B@   :  B@.:i:            B@\n  u::.,B@B  LB@Gi     .B@B2.:B@i  uB@B7         rL::,:@B@             :.   ,P@@:      :,  .:uB@r            @B.         .:.  U@@\n  B@B@BBS                5B@BM:   MB            v@@@@@Mv              @@B@B@Bv        B@@@B@Bu              M@          .@B@B@X\n*/\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> pll;\n#define IN inline\n#define RE register\n#define F first\n#define S second\n#define N 400005\n#define mod 998244353\n#define INF 0x3f3f3f3f\nint n,v,x[N],vl[22],k=0,pf[22][N],pb[22][N],dpf[N],dpb[N],lf[N];\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=v;i;i>>=1) vl[k++]=i;\n\tvl[k]=0;\n\treverse(vl,vl+k+1);\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",x+i);\n\tfor(int i=0;i<=k;++i){\n\t\tpf[i][1]=1;\n\t\tfor(int j=2;j<=n;++j){\n\t\t\tif(x[j]-x[j-1]<=vl[i]) pf[i][j]=pf[i][j-1];\n\t\t\telse pf[i][j]=j;\n\t\t}\n\t\tpf[i][n+1]=n;\n\t\tpb[i][n]=n;\n\t\tfor(int j=n-1;j;--j){\n\t\t\tif(x[j+1]-x[j]<=vl[i]) pb[i][j]=pb[i][j+1];\n\t\t\telse pb[i][j]=j;\n\t\t}\n\t\tpb[i][0]=1;\n\t}\n\t/*\n\tfor(int i=0;i<=k;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tprintf(\"(%d,%d) \",pf[i][j],pb[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\t*/\n\tdpf[0]=0;\n\tmemset(dpb,63,sizeof(dpb));\n\tdpb[0]=n+1;\n\tfor(int msk=0;msk<(1<<k);++msk){\n\t\tfor(int i=0;i<k;++i){\n\t\t\tif(!(msk&1<<i)){\n\t\t\t\tdpf[msk|1<<i]=max(dpf[msk|1<<i],pb[i][dpf[msk]+1]);\n\t\t\t\tdpb[msk|1<<i]=min(dpb[msk|1<<i],pf[i][dpb[msk]-1]);\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d:%d,%d\\n\",msk,dpf[msk],dpb[msk]);\n\t}\n\tfor(int msk=0,dmsk=(1<<k)-1;dmsk>=0;++msk,--dmsk){\n\t\tlf[dpb[dmsk]-1]=max(lf[dpb[dmsk]-1],dpf[msk]+1);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tlf[i]=max(lf[i],lf[i-1]);\n\t\t//printf(\"%d \",lf[i]);\n\t}\n\t//puts(\"\");\n\tfor(int i=1;i<=n;++i){\n\t\tif(lf[pb[k][i]]>=pf[k][i]) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*====Corycle====*/\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<map>\n#define ll long long\n#define pii pair<int,int>\n#define fst first\n#define scd second\n#define mp make_pair\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int Maxn=(1<<19)+5;\nconst int N=2e5+5;\nconst int M=20;\nint read(){\n\tint s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}\n\treturn s*f;\n}\npii P[N];\nint n,V,cnt,tot,Sta,a[N],L[N][M],R[N][M],Ans[N],FL[Maxn],FR[Maxn];\nint main(){\n//\tfreopen(\"_.in\",\"r\",stdin);\n//\tfreopen(\"_.out\",\"w\",stdout);\n\tn=read();V=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();a[0]=-inf-V-1;a[n+1]=inf+V+1;\n\tfor(int v=V;;v>>=1){\n\t\ttot++;L[tot][0]=0;R[tot][n+1]=n+1;\n\t\tfor(int i=1;i<=n;i++)L[tot][i]=(a[i]-a[i-1]<=v?L[tot][i-1]:i);\n\t\tfor(int i=n;i>=1;i--)R[tot][i]=(a[i+1]-a[i]<=v?R[tot][i+1]:i);\n\t\tif(v==0)break;\n\t}\n\tSta=(1<<tot)-1;\n\tfor(int i=1;i<=n;i++)P[i]=mp(L[1][i],R[1][i]);\n\tsort(P+1,P+n+1);cnt=unique(P+1,P+n+1)-P-1;\n\tfor(int S=0;S<=Sta;S++){FL[S]=0;FR[S]=n+1;}\n\tfor(int S=0;S<=Sta;S+=2){\n\t\tfor(int i=1;i<=tot;i++){\n\t\t\tif(!((S>>(i-1))&1))continue;\n\t\t\tFL[S]=max(FL[S],R[i][FL[S^(1<<(i-1))]+1]);\n\t\t\tFR[S]=min(FR[S],L[i][FR[S^(1<<(i-1))]-1]);\n\t\t}\n\t}\n\tif(cnt>tot){for(int i=1;i<=tot;i++)puts(\"Impossible\");return 0;}\n\tfor(int i=1;i<=cnt;i++){\n\t\tfor(int S=0;S<=Sta;S+=2){\n\t\t\tif(FL[S]>=P[i].fst-1&&FR[Sta^S^1]<=P[i].scd+1){\n\t\t\t\tfor(int j=P[i].fst;j<=P[i].scd;j++)Ans[j]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)puts(Ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10;\nint n,x[N],d[20],id,dep;\nstruct array{\n\tint L[N],R[N],l[N],r[N],cnt;\n\tvoid init(int dep);\n}a[20];\nvoid array::init(int dep){\n\tint dis=d[dep];\n\tcnt++;L[1]=R[1]=x[1];\n\tfor (int i=2;i<=n;i++){\n\t\tif (x[i]<=R[cnt]+dis) R[cnt]=x[i];else\n\t\tcnt++,L[cnt]=R[cnt]=x[i];\n\t}\n\tint m=a[dep+1].cnt,*ll=a[dep+1].L,*rr=a[dep+1].R;\n\tl[0]=r[0]=1;\n\tfor (int i=1;i<=cnt;i++){\n\t\tfor (l[i]=l[i-1];l[i]<m&&rr[l[i]]<L[i];l[i]++);\n\t\tfor (r[i]=r[i-1];r[i]<m&&ll[r[i]+1]<=R[i];r[i]++);\n\t}\n}\nint q[20][N],size[20];\ninline void push(int h,int v){\n\tfor (int i=a[h].l[v];i<=a[h].r[v];i++) q[h+1][++size[h+1]]=i;\n}\nbool check(int h){\n\tif (!size[h]) return 1;\n\tif (size[h]>dep-h+1) return 0;\n\tfor (int i=1;i<=size[h];i++){\n\t\tsize[h+1]=0;\n\t\tfor (int j=1;j<=size[h];j++)\n\t\tif (i!=j) push(h,q[h][j]);\n\t\tif (check(h+1)) return 1;\n\t}\n\treturn 0;\n}\nbool ans[N],ok[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&d[0]);\n\twhile (d[dep]) d[dep+1]=d[dep]>>1,dep++;\n\ta[dep].cnt=n;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]),a[dep].L[i]=a[dep].R[i]=x[i];\n\tfor (int i=dep-1;i>=0;i--) a[i].init(i);\n\tfor (int i=1;i<=a[0].cnt;i++){\n\t\tsize[1]=0;\n\t\tfor (int j=1;j<=a[0].cnt;j++)\n\t\tif (i!=j) push(0,j);\n\t\tok[i]=check(1);\n\t}\n\tfor (int i=1,p=1;i<=n;i++){\n\t\twhile (x[i]>a[0].R[p]) p++;\n\t\tputs(ok[p]?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint n,v,x[N];\nint dp1[(1<<21)+3],dp2[(1<<21)+3];\nint tor[21][N],tol[21][N],len[21],dep;\nvoid maxn(int &x,int y){y>x? x=y:0;}\nint mxr[N];//左侧覆盖i，右侧最多覆盖多少个城市\nint main(){\n    scanf(\"%d%d\",&n,&v);x[0]=-2e9,x[n+1]=2e9;\n    for(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n    for(len[0]=v;len[dep]!=0;dep++) len[dep+1]=len[dep]/2;\n    dep++;\n    for(int d=0;d<dep;d++){\n        tol[d][0]=n,tor[d][n+1]=n;\n        for(int i=1;i<=n;i++) tol[d][i]=(x[i]-x[i-1]<=len[d])? tol[d][i-1]:n+1-i;\n        for(int i=n;i>=1;i--) tor[d][i]=(x[i+1]-x[i]<=len[d])? tor[d][i+1]:i;\n    }\n    \n    for(int i=0;i<(1<<dep);i+=2)\n        for(int j=1;j<dep;j++)\n            if((i&(1<<j))==0)\n                maxn( dp1[i|(1<<j)], tor[j][dp1[i]+1] ),\n                maxn( dp2[i|(1<<j)], tol[j][n-dp2[i]] );\n    \n    memset(mxr,0xc0,sizeof(mxr));\n    for(int i=0,j=((1<<dep)-1)^1;j>=0;i+=2,j-=2)\n        maxn( mxr[dp1[i]], dp2[j] );\n    for(int i=n;i>=1;i--) maxn( mxr[i], mxr[i+1] );\n    for(int i=1;i<=n;i++)\n        if(mxr[n-tol[0][i]] + tor[0][i] >= n) puts(\"Possible\");\n        else puts(\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1009LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> ii;\ntypedef pair<ii, ii> i4;\n \nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n\n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nconst int N = 200005;\nint n, arr[N], sz, V, next_right[20][N], next_left[20][N];\nint DP_left[1<<20], DP_right[1<<20];\nvector<int> steps;\n\nint dp_left(int mask){\n    int &ans = DP_left[mask];\n    if(ans != -1)   return ans;\n    ans = 1;\n    for(int i=0;i<sz;i++)\n        if((mask >> i) & 1)\n            ans = max(ans, next_right[i][dp_left(mask^(1<<i))+1]);\n    return ans;\n}\n\nint dp_right(int mask){\n    int &ans = DP_right[mask];\n    if(ans != -1)   return ans;\n    ans = n+1;\n    for(int i=0;i<sz;i++)\n        if((mask >> i) & 1)\n            ans = min(ans, next_left[i][dp_right(mask^(1<<i))-1]);\n    return ans;\n}\n\n\n\nbool possible(int l, int r){\n    int mask = (1<<sz)-2; \n    for(int i=mask;i>=0;i=(i-1)&mask){\n// cout<<i<<\" \"<<(mask^i)<<\" \"<<mask<<\" \"<<dp_left(i)<<\" \"<<dp_right(mask^i)<<endl;\n        if((l==1 || dp_left(i) >= l-1) && (r==n || dp_right(mask^i) <= r+1))    return true;\n        if(i == 0)  break;\n    }\n    return false;\n}\n\n\nint main(){\n \n    // ios_base::sync_with_stdio(0);\n    // cin.tie(0);\n\n    scanf(\"%d%d\", &n, &V);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\", &arr[i]);\n\n    while(V){\n        steps.pb(V);\n        V /= 2;\n    }\n    steps.pb(0);\n    sz = (int)steps.size();\n\n    for(int k=0;k<sz;k++){\n\n        next_right[k][n+1] = n+1;\n        next_right[k][n] = n;\n        for(int i=n-1;i>=1;i--)\n            if(arr[i+1]-arr[i] <= steps[k])\n                next_right[k][i] = next_right[k][i+1];\n            else\n                next_right[k][i] = i;\n\n        next_left[k][0] = 0;\n        next_left[k][1] = 1;\n        for(int i=2;i<=n;i++)\n            if(arr[i]-arr[i-1] <= steps[k])\n                next_left[k][i] = next_left[k][i-1];\n            else\n                next_left[k][i] = i;\n    }\n\n    int comps = 0, curr = 1;\n    while(curr <= n){\n        comps++;\n        curr = next_right[0][curr] + 1;\n    }\n\n    if(comps > sz+2){\n        for(int i=1;i<=n;i++)\n            printf(\"Impossible\\n\");\n        return 0;\n    }\n\n// cout<<\"steps: \";for(auto it : steps)    cout<<it<<\" \";cout<<endl;\n// cout<<\"next_right:\\n\";\n// for(int i=1;i<=n;i++){\n//     cout<<i<<\": \";for(int j=0;j<sz;j++) cout<<next_right[j][i]<<\" \";cout<<endl;\n// }cout<<endl;\n// cout<<\"next_left:\\n\";\n// for(int i=1;i<=n;i++){\n//     cout<<i<<\": \";for(int j=0;j<sz;j++) cout<<next_left[j][i]<<\" \";cout<<endl;\n// }cout<<endl;\n\n\n    memset(DP_left, -1, sizeof(DP_left));\n    memset(DP_right, -1, sizeof(DP_right));\n    curr = 1;\n    while(curr <= n){\n        if(possible(curr, next_right[0][curr])){\n            for(int i=curr;i<=next_right[0][curr];i++)\n                printf(\"Possible\\n\");\n        }\n        else{\n            for(int i=curr;i<=next_right[0][curr];i++)\n                printf(\"Impossible\\n\");\n        }\n        curr = next_right[0][curr]+1;\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=4E5+5;\n\nint N,M,K,V;\nint a[Maxn];\nint F[Maxn],G[Maxn];\nint L[25][Maxn],R[25][Maxn];\nchar Ans[50],_1[50]={\"Possible\"},_2[50]={\"Impossible\"};\n//int nxt[Maxn];\n\ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n\nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1)\n\t\t\t\tMAX(F[i],R[M-j][min(F[i-(1<<j)]+1,N)]),\n\t\t\t\tMIN(G[i],L[M-j][max(G[i-(1<<j)]-1,1)]);\n\t}\n/*\tfor(int i=1;i<=N;++i)\n\t\tK+=(L[0][i]!=L[0][i-1]);\n\tif(K>20){\n\t\tfor(int i=1;i<=N;++i)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=1,j;i<=N;++i)\n\t\tif(L[0][i]!=L[0][i-1]){\n\t\t\tfor(j=0;j<(1<<M);++j)\n\t\t\t\tif(F[j]>=L[0][i]-1 && G[(1<<M)-1-j]<=R[0][i]+1)\n\t\t\t\t\t{memcpy(Ans,_1,sizeof(_1)); break ;}\n\t\t\tif(j==1<<M) memcpy(Ans,_2,sizeof(_2));\n\t\t\tprintf(\"%s\\n\",Ans);\n\t\t}else printf(\"%s\\n\",Ans);*/\n\tmemset(nxt,-1,sizeof(nxt));\n\tfor(int i=0;i<(1<<M);++i) MAX(nxt[G[(1<<M)-1-i]],F[i]);\n\tfor(int i=1;i<=N+1;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[R[0][i]+1]>=L[0][i]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<math.h>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst long long int INF=99999999999999,inf=199999;\nconst long long int mod=1000000007;\n\n\n\nlong long int tmp,n,canmove[25]={},v,x[200005],leftdp[400000]={},rightdp[400000]={};\nlong long int leftnext[25][400005]={},rightnext[25][400005]={},two[30]={1};\nlong long int leftmemo[400005]={},rightmemo[400005]={};\nlong long int cou=0,k;\n\nvoid leftsolve(){\n    long long int count=0;\n    queue<long long int>que,memoque;\n    que.push(0);\n    \n    while(1){\n        while(!que.empty()){\n            for(int i=0;i<k;i++){\n                if((que.front()/two[i]%2)==0){\n                    leftdp[que.front()+two[i]]=max(leftdp[que.front()+two[i]],leftnext[i][leftdp[que.front()]]);\n                    //次のループで被りが出ないように\n                    if(leftmemo[que.front()+two[i]]==0){\n                        memoque.push(que.front()+two[i]);\n                        leftmemo[que.front()+two[i]]=1;\n                    }\n                }\n            }\n            que.pop();\n        }\n        while(!memoque.empty()){\n            que.push(memoque.front());\n            memoque.pop();\n        }\n        if(que.front()==two[k]-1){\n            break;\n        }\n    }\n}\n\nvoid rightsolve(){\n    long long int count=0;\n    queue<long long int>que,memoque;\n    que.push(0);\n    \n    while(1){\n        while(!que.empty()){\n            for(int i=0;i<k;i++){\n                if((que.front()/two[i])%2==0){\n                    rightdp[que.front()+two[i]]=min(rightdp[que.front()+two[i]],rightnext[i][rightdp[que.front()]]);\n                   //次のループで被りが出ないように\n                    if(rightmemo[que.front()+two[i]]==0){\n                        memoque.push(que.front()+two[i]);\n                        rightmemo[que.front()+two[i]]=1;\n                    }\n                    //cout<<que.front()<<\" \"<<two[i]<<\" \"<<endl;\n                    //cout<<que.front()+two[i]<<\" \"<<rightdp[que.front()+two[i]]<<endl;\n                }\n            }\n            que.pop();\n        }\n        while(!memoque.empty()){\n            que.push(memoque.front());\n            memoque.pop();\n        }\n        if(que.front()==two[k]-1){\n            break;\n        }\n    }\n}\n\n\nint main() {\n    \n    map<long long int,long long int>mp;\n\tcout << fixed << setprecision(10);\n    cin>>n>>v;\n    \n    for(int i=1;i<=26;i++){\n        two[i]=2*two[i-1];\n    }\n\n\n        for(int j=0;j<=199995;j++){\n            rightdp[j]=n;\n        }\n    \n\n    tmp=v;\n    while(tmp!=0){\n        canmove[cou]=tmp;\n        cou++;\n        tmp/=2;\n    }\n    k=cou+1;\n\n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n    }\n    x[0]=INF;\n    x[n+1]=INF;\n\n    for(int i=0;i<k;i++){\n        tmp=0;\n        for(int j=2;j<=n+1;j++){\n            if(x[j]-x[j-1]>canmove[i]){\n                for(int p=tmp;p<j;p++){\n                    leftnext[i][p]=j;\n                }\n                tmp=j;\n            }\n        }\n\n        tmp=n;\n        for(int j=n-1;j>=0;j--){\n            if(x[j+1]-x[j]>canmove[i]){\n                for(int p=tmp;p>j;p--){\n                    rightnext[i][p]=j;\n                }\n                tmp=j;\n            }\n        }\n    }\n\n    leftsolve();\n    rightsolve();\n\n    for(int i=1;i<=n;i++){\n        //cout<<rightnext[0][i]<<\" \"<<canmove[0]<<endl;\n    }\n\n    for(int i=1;i<=n;i=leftnext[0][i]){\n        bool key=true;\n        for(int j=0;j<two[k];j+=2){\n            //cout<<leftdp[j]<<\" \"<<rightnext[0][i]<<\" \"<<rightdp[(j^(two[k]-2))]<<leftnext[0][i]<<endl;\n            if(leftdp[j]>rightnext[0][i]&&rightdp[(j^(two[k]-2))]<leftnext[0][i]){\n                for(int p=rightnext[0][i]+1;p<=leftnext[0][i]-1;p++){\n                    cout<<\"Possible\"<<endl;\n                }\n                key=false;\n                break;\n            }\n        }\n        if(key){\n            for(int p=rightnext[0][i]+1;p<=leftnext[0][i]-1;p++){\n                        cout<<\"Impossible\"<<endl;\n            }\n        }\n    }\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define chmax(a,b) a=max(a,b);\n#define N (1<<18)\n#define M 19\nll n,v;\nclass Alpha{\n public:\n ll f[N];\n P g[N][M];\n void setg(ll a[]){\n     for(int k=0;k<M;k++){\n         ll bef=-1e18,pnt=0; a[n]=1e18;\n         for(int i=0;i<=n;i++){\n          if(abs(a[i]-bef)>(v>>k)){\n           for(int j=pnt;j<i;j++)g[j][k]=make_pair(pnt,i-1);\n           pnt=i;   \n          }\n          bef=a[i];\n         }\n         if((v>>k)==0)break;\n     }\n }\n void main(ll a[]){\n  setg(a);   \n  for(int i=0;i<N;i++)f[i]=-1;\n  for(int i=0;i<N;i++){\n      for(int j=0;j<M-1;j++){\n          if(i&(1<<j))continue;\n          chmax(f[i+(1<<j)],g[f[i]+1][j+1].second);\n      }\n  }\n }\n};Alpha L,R;\n\nclass Solve{\n  public:\n  unordered_map<ll,bool> mas;\n  bool main(ll l,ll r){\n      if(mas.size()>M)return 0;\n      if(mas.find(l)!=mas.end()){\n       return mas[l];   \n      }\n      bool res=0;\n      for(int i=0;i<N;i++){\n       int ls=i,rs=N-1-i;\n       if(l-1<=L.f[ls]&&n-1-R.f[rs]<=r+1)res=1;\n      }\n      mas[l]=res;\n      return res;\n  }\n};Solve sv;\n\nll a[N];\nint main(){\n    cin>>n>>v;\n    for(int i=0;i<n;i++)cin>>a[i];\n    L.main(a);\n    for(int i=0;i<n/2;i++)swap(a[i],a[n-i-1]);\n    R.main(a);\n    for(int i=0;i<n;i++){\n     bool ans=sv.main(L.g[i][0].first,L.g[i][0].second);   \n     cout<<(ans?\"Possible\":\"Impossible\")<<endl;\n    }\n return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\nint N, V;\nint p[200005], d[200005];\nint K, v[25];\nint rgt[200005];\nint bst[200005];\nbool can[200005];\n\nclass Solver\n{\npublic:\n    int dst[200005];\n    int lgt[200005][20];\n    int dp[200005];\n\n    Solver()\n    {\n        memset(dst, 0, sizeof(dst));\n        memset(lgt, 0, sizeof(lgt));\n        for(int i = 1; i < N; i++)  dst[i] = d[i];\n    }\n\n    void precalc()\n    {\n        for(int i = N; i >= 1; i--)\n            for(int j = 0; j <= K; j++)\n            {\n                if(dst[i] <= v[j])  lgt[i][j] = lgt[i + 1][j] + 1;\n                else    lgt[i][j] = 1;\n            }\n        for(int msk = 1; msk < (1 << K); msk++)\n        {\n            for(int b = 0; b < K; b++)\n                if( (1 << b) & msk )\n                {\n                    int mmsk = msk ^ (1 << b);\n                    int pos = dp[mmsk];\n                    dp[msk] = max(dp[msk], pos + lgt[pos + 1][b]);\n                }\n        }\n    }\n};\n\nvoid possible() {printf(\"Possible\\n\");}\nvoid impossible() {printf(\"Impossible\\n\");}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    scanf(\"%d%d\", &N, &V);\n    for(int i = 1; i <= N; i++) scanf(\"%d\", &p[i]);\n    for(int i = 1; i < N; i++)  d[i] = p[i + 1] - p[i];\n\n    K = -1;\n    int aux = V;\n    while(aux)\n    {\n        aux /= 2;\n        v[++K] = aux;\n    }\n    reverse(v, v + K + 1);\n    v[++K] = V;\n\n    Solver pfx;\n    reverse(d + 1, d + N);\n    Solver sfx;\n    reverse(d + 1, d + N);\n\n    pfx.precalc();\n    sfx.precalc();\n\n    int mskmax = (1 << K) - 1;\n    for(int msk = mskmax; msk >= 0; msk--)\n    {\n        can[ pfx.dp[msk] ] = 1;\n        bst[msk] = max(bst[msk], sfx.dp[msk ^ mskmax]);\n        int st = pfx.dp[msk];\n        int dr = bst[msk];\n        rgt[st] = max(rgt[st], dr);\n    }\n\n    for(int i = N - 1; i >= 0; i--) rgt[i] = max(rgt[i], rgt[i + 1]);\n\n    for(int i = 1; i <= N; i++)\n    {\n        int st = i - 1;\n        int dr = N - rgt[st] + 1;\n        int posmax = i + pfx.lgt[i][K] - 1;\n        if(dr - 1 <= posmax && can[st])\n            for(int j = 1; j <= pfx.lgt[i][K]; j++)  possible();\n        else\n            for(int j = 1; j <= pfx.lgt[i][K]; j++)  impossible();\n        i = posmax;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<complex>\n#include<numeric>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt n;\nInt nxt[20][220000];\n\nvector<Int> calc(vector<Int> &a, Int v){\n    Int jump = 0;\n    for(;;){\n        Int last = 0;\n        for(Int j = 0;j < n;j++){\n            if(j == n-1 || abs(a[j+1] - a[j]) > v){\n                for(Int k = last;k <= j;k++)\n                    nxt[jump][k] = j+1;\n                last = j+1;\n            }\n        }\n        jump++;\n        if(v == 0)break;\n        v/=2;\n    }\n    vector<Int> dp(1 << jump, 0);\n    for(Int i = 0;i < (1 << jump);i++){\n        for(Int j = 0;j < jump;j++){\n            if((1 << j) & i)continue;\n            dp[(1 << j) | i] = max(dp[(1 << j) | i], nxt[j][dp[i]]);\n        }\n    }\n    return dp;\n}\n\nInt ok[1 << 20];\n\nint main(){\n    Int v;\n    cin >> n >> v;\n   \n    vector<Int> a(n);\n    for(auto &x:a)cin >> x;\n    reverse(a.begin(), a.end());\n    auto rev_dp = calc(a, v);\n    reverse(a.begin(), a.end());\n    auto dp = calc(a, v);\n\n    Int not_zero = dp.size() - 2;\n    for(Int l = 0;l <= not_zero;l += 2){\n        Int r = not_zero - l;\n        if(nxt[0][dp[l]] + rev_dp[r] >= n){\n            ok[dp[l]]++;\n            ok[nxt[0][dp[l]]]--;\n        }\n    }\n    for(Int i = 1;i < n;i++)ok[i] += ok[i-1];\n    for(Int i = n-2;i >= 0;i--){\n        if(ok[i+1] && abs(a[i+1] - a[i]) <= v)ok[i] = true;\n    }\n    for(Int i = 0;i < n;i++){\n        if(ok[i])cout << \"Possible\" << endl;\n        else cout << \"Impossible\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Camel and Oases\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint const N=1e5+10;\nint const S=1<<17;\nint n,V;\nint d[N];\nint logV,a[20][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n    }\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%d\",&d[i]),d[i-1]=d[i]-d[i-1];\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++) printf(\"Impossible\\n\");\n        return 0;\n    }\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=1,f2[s]=n;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1 && f2[U-s-1]-1<=to) f=true;\n        if(f) for(int j=fr;j<=to;j++) printf(\"Possible\\n\");\n        else for(int j=fr;j<=to;j++) printf(\"Impossible\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 500008\n#define lg 21\nint n;\nint pos[nn];\nstruct afd{\n\tint bel[nn];\n\tint l[nn],r[nn];\n\tvoid init(int v)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(i==1 or pos[i]-pos[i-1]>v) bel[i]=i,l[i]=r[i]=i;\n\t\t\telse bel[i]=bel[i-1],r[bel[i]]=i; \n\t\t}\n\t\t\n\t}\n\t\n\t\n}v2[lg];\nint l=0;\nint v;\n\nvoid fuckoff()\n{\n\twhile(n--) puts(\"Impossible\");\n\texit(0);\n}\nint fl[nn],fr[nn];\nvoid chkmin(int &x,int y)\n{\n\tx=min(x,y);\n}\n\nvoid chkmax(int &x,int y)\n{\n\tx=max(x,y);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&pos[i]);\n\twhile(v) v2[l++].init(v),v/=2;\n\tv2[l++].init(v),v/=2;\n\t\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(v2[0].bel[i]==i)\n\t\t\tcnt++;\n\tif(cnt>lg) fuckoff();\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(v2[0].bel[i]==i)\n\t\t{\n\t\t\tint el=v2[0].l[i],er=v2[0].r[i];\n\t\t\t\n\t\t\tmemset(fl,0x3f,sizeof fl);\n\t\t\tmemset(fr,0,sizeof fr);\n\t\t\t\n\t\t\tfl[1]=el;fr[1]=er;int flag=0;\n\t\t\t\n\t\t\tfor(int mask=1;mask<(1<<l);mask++)\n\t\t\t{\n\t\t\t\tif(!(mask&1) or fl[mask]>n) continue;\n\t\t\t\tfor(int i=1;i<l;i++)\n\t\t\t\t{\n\t\t\t\t\tif(mask&(1<<i)) continue;\n\t\t\t\t\tint x=v2[i].bel[fl[mask]-1];\n\n\t\t\t\t\tif(!x) chkmin(fl[mask|(1<<i)],fl[mask]);\n\t\t\t\t\telse chkmin(fl[mask|(1<<i)],v2[i].l[x]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int mask=1;mask<(1<<l);mask++)\n\t\t\t{\n\t\t\t\tif(!(mask&1) or !fr[mask]) continue;\n\t\t\t\tfor(int i=1;i<l;i++)\n\t\t\t\t{\n\t\t\t\t\tif(mask&(1<<i)) continue;\n\t\t\t\t\tint x=v2[i].bel[fr[mask]+1];\n\t\t\t\t\t\n\t\t\t\t\tif(!x) chkmax(fr[mask|(1<<i)],fr[mask]);\n\t\t\t\t\tchkmax(fr[mask|(1<<i)],v2[i].r[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int mask=0;mask<(1<<l);mask++)\n\t\t\t\tif(fl[mask]<=1 and fr[(((1<<l)-1)^mask)|1]>=n)\n\t\t\t\t\tflag=1;\n\t\t\t\t\t\t\n\t\t\tif(flag)\n\t\t\t\tfor(int i=el;i<=er;i++) puts(\"Possible\");\n\t\t\telse\n\t\t\t\tfor(int i=el;i<=er;i++) puts(\"Impossible\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\n#ifdef _DEBUG\n#define dbg(x) cerr << #x << \":\" << x << endl;\n#else\n#define dbg(x) while(false){}\n#endif\n\n#define fi(a, b) for(int i=a;i<b;++i)\n#define fj(a, b) for(int j=a;j<b;++j)\n\n////////\n\nint const M = 20;\nint const N = (1<<M);\nstring const YES = \"Possible\";\nstring const NO = \"Impossible\";\n\nint n, v, x[N];\nint le[N][M], ri[N][M];\nint cnt;\nstring ans[N];\n\nvoid setAns(string val, int l, int r){\n\tfi(l, r+1) ans[i] = val;\n}\n\nvoid print(){\n\tfi(1, n+1) printf(\"%s\\n\", ans[i].c_str());\n\texit(0);\n}\n\nvoid check(){\n\tint cn = cnt + 1;\n\tint v = 1;\n\twhile(v <= n){\n\t\tv = ri[v][0] + 1;\n\t\t--cn;\n\t}\n\tif(cn < 0){\n\t\tsetAns(NO, 1, n);\n\t\tprint();\n\t}\n}\n\nvoid build(){\n\tint vi = v;\n\tfi(0, M){\n\t\tcnt = i;\n\t\tle[1][i] = x[1];\n\t\tfj(2, n+1){\n\t\t\tif(x[j] - x[j-1] <= vi) le[j][i] = le[j-1][i];\n\t\t\telse le[j][i] = j;\n\t\t}\n\t\tri[n][i] = n;\n\t\tfor(int j=n-1;j>0;--j){\n\t\t\tif(x[j+1] - x[j] <= vi) ri[j][i] = ri[j+1][i];\n\t\t\telse ri[j][i] = j;\n\t\t}\n\t\tif(vi == 0) break;\n\t\tvi /= 2;\n\t}\n}\n\nint dl[N], dr[N];\n\nvoid remax(int &a, int b){\n\ta = max(a, b);\n}\n\nvoid remin(int &a, int b){\n\ta = min(a, b);\n}\n\nvoid calcDp(){\n\tdl[0] = 0;\n\tfi(0, (1<<cnt)){\n\t\tfj(0, cnt){\n\t\t\tif((1<<j)&i) continue;\n\t\t\tremax(dl[((1<<j)^i)], ri[dl[i]+1][j+1]);\n\t\t}\n\t}\n\tfi(0, (1<<cnt)) dr[i] = n+1;\n\tfi(0, (1<<cnt)){\n\t\tfj(0, cnt){ \n\t\t\tif((1<<j)&i) continue;\n\t\t\tif(dr[((1<<j)^i)] == 1) continue;\n\t\t\tremin(dr[(1<<j)^i], le[dr[i]-1][j+1]);\n\t\t}\n\t}\n}\n\nvoid findAnswers(){\n\tint v, nxt;\n\tv = 1;\n\twhile(v <= n){\n\t\tnxt = ri[v][0];\n\t\tbool can = false;\n\t\tfi(0, (1<<(cnt))){\n\t\t\tint maskL = i;\n\t\t\tint maskR = ( ((1<<(cnt))-1) ^ maskL );\n\t\t\tint lb = max(dl[maskL], 1);\n\t\t\tint rb = min(dr[maskR], n);\n\t\t\tif(lb+1 >= v && rb-1 <= nxt){\n\t\t\t\tcan = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(can){\n\t\t\tsetAns(YES, v, nxt);\n\t\t}else{\n\t\t\tsetAns(NO, v, nxt);\n\t\t}\n\t\tv = nxt + 1;\n\t}\n}\n\nvoid solve(){\n\tscanf(\"%d %d\",&n,&v);\n\tfi(1, n+1) scanf(\"%d\",&x[i]);\n\n\tbuild();\n\tdbg(cnt);\n\tcheck();\n\tcalcDp();\n\tfindAnswers();\n\tprint();\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 1000000\n#define INF 2000000000\nusing namespace std;\nint n,V,x[MAXN+5];\nint cnt[25];\nint l[25][MAXN+5],r[25][MAXN+5];\nint f1[MAXN*5+5],f2[MAXN*5+5];\nbool ans[MAXN+5];\nvoid Init()\n{\n\tfor(int i=0;i<=MAXN*5+3;i++)\n\t\tf1[i]=0,f2[i]=INF;\n}\nint UpFind(int id,int pos)\n{\n//\tif(cnt[id]==0)\n//\t\treturn pos;\n\tpos++;\n\tint p=upper_bound(l[id]+1,l[id]+cnt[id]+1,pos)-l[id];\n\tp--;\n\tif(p<=0)\n\t\treturn pos;\n\treturn max(r[id][p],pos-1);\n}\nint LowFind(int id,int pos)\n{\n//\tif(cnt[id]==0)\n//\t\treturn pos;\n\tpos--;\n\tint p=lower_bound(r[id]+1,r[id]+cnt[id]+1,pos)-r[id];\n\tif(p>=cnt[id]+1)\n\t\treturn pos;\n\treturn min(l[id][p],pos+1);\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d %d\",&n,&V);\n\tint logV=0;\n\tfor(logV=0;(1<<logV)<=V;logV++);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tx[n+1]=INF;\n\tx[0]=-INF;\n\tfor(int LG=0;LG<=logV;LG++)\n\t{\n\t\tint d=V/(1<<LG);\n\t\tcnt[LG]=1;\n\t\tl[LG][1]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tr[LG][cnt[LG]]=i;\n\t\t\tif(x[i+1]-x[i]>d)\n\t\t\t{\n\t\t\t\tcnt[LG]++;\n\t\t\t\tl[LG][cnt[LG]]=i+1;\n\t\t\t}\n\t\t}\n\t\tcnt[LG]--;\n\t}\n\tif(cnt[0]>logV)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint all=(1<<(logV+1));\n\tf1[0]=0,f2[0]=n+1;\n\tfor(int s=0;s<all;s+=2)\n\t\tfor(int i=0;i<=logV;i++)\n\t\t{\n\t\t\tif(!(s&(1<<i)))\n\t\t\t\tcontinue;\n\t\t\tf1[s]=max(f1[s],UpFind(i,f1[s-(1<<i)]));\n\t\t\tf2[s]=min(f2[s],LowFind(i,f2[s-(1<<i)]));\n\t\t}\n\tfor(int i=1;i<=cnt[0];i++)\n\t{\n\t\tint ln=l[0][i],rn=r[0][i];\n\t\tfor(int s1=0;s1<all;s1+=2)\n\t\t{\n\t\t\tint s2=all-1-s1-1;\n\t\t\tint lpos=f1[s1];\n\t\t\tint rpos=f2[s2];\n\t\t\tif(lpos>=ln-1&&rpos<=rn+1)\n\t\t\t{\n\t\t\t\tans[i]=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint pos=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(ans[pos]==true)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t\tif(x[i+1]-x[i]>V)\n\t\t\tpos++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, V;\nint X[200011];\n\n\nVI vs;\nint m;\n\nvoid calc(int dp[1<<20]) {\n    REP (i, N) REP (j, m) {\n\tint right = 0;\n\tif (i == 0 || X[i]-X[i-1] > vs[j]) {\n\t    right = i+1;\n\t    while (right < N && X[right]-X[right-1] <= vs[j]) right++;\n\t} else {\n\t    continue;\n\t}\n\tREP (s, 1<<m) if (~s>>j&1) {\n\t    if (dp[s] == i) amax(dp[s|(1<<j)], right);\n\t}\n    }\n//    rprintf(\"%d\", dp, dp+(1<<m));\n}\nint L[1<<20], R[1<<20];\n\nint Z[200011];\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &V);\n    REP (i, N) scanf(\"%d\", X+i);\n    m = V;\n    while (1) {\n\tvs.push_back(m);\n\tif (m == 0) break;\n\tm/=2;\n    }\n    m = vs.size();\n\n    calc(L);\n    reverse(X, X+N);\n    REP (i, N) X[i] = -X[i];\n    calc(R);\n    reverse(X, X+N);\n    REP (i, N) X[i] = -X[i];\n\n    memset(Z, 0xc0, sizeof Z);\n    REP (s, 1<<m) if (~s&1) {\n\tint t = ((1<<m)-1) ^ s ^ 1;\n\tamax(Z[N-R[t]], L[s]);\n    }\n\n    int ma = Z[0];\n    for (int i=0; i<N; ) {\n\tint j = i;\n\twhile (j < N && (j == i || X[j] - X[j-1] <= V)) {\n\t    j++;\n\t    amax(ma, Z[j]);\n\t}\n\n\tfor (int k=i; k<j; k++) {\n\t    puts(i<=ma? \"Possible\": \"Impossible\");\n\t}\n\t//eprintf(\"%d\\n\", ma);\n\ti = j;\n    }\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (1050000)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,m,p[N],cnt,ri[N],le[N];\nvector<int> seg[22];\nvoid spj(){\n\tif(seg[cnt].size()<=cnt+2)return;\n\tfor(int i=1;i<=n;i++)puts(\"Impossible\");exit(0);\n}\nint main(){\n\tread(n),read(m);\n\tfor(int i=1;i<=n;i++)read(p[i]); p[n+1]=inf,p[0]=-inf;\n//\tcout<<inf<<endl;\n\tfor(cnt=0;(m>>cnt)>0;cnt++);\n\tfor(int i=0;i<=cnt;i++)\n\tfor(int j=0;j<=n;j++)\n\tif(p[j+1]-p[j]>(m>>i))seg[cnt-i].push_back(j);\n//\tcout<<cnt+1<<endl;\n//\tfor(int i=0;i<=cnt;i++){\n//\t\tprintf(\"#%d(%d):\",i,m>>(cnt-i));\n//\t\tfor(int j=0;j<seg[i].size();j++)printf(\"%d \",seg[i][j]); puts(\"\");\n//\t}\n\tspj();\n\tfor(int i=0;i<(1<<cnt);i++)le[i]=n+1,ri[i]=0;\n\tfor(int i=0;i<(1<<cnt);i++)\n\tfor(int j=cnt-1;~j;j--)\n\tif(!(i&(1<<j))){\n\t\tint v=i|(1<<j);\n\t\tif(ri[v]!=n+1)ri[v]=max(ri[v],*(upper_bound(seg[j].begin(),seg[j].end(),ri[i])));\n\t\tif(le[v]!=1)le[v]=min(le[v],*(lower_bound(seg[j].begin(),seg[j].end(),le[i]-1)-1)+1);\n\t}\n//\tfor(int i=0;i<(1<<cnt);i++)\n//\tprintf(\"%d %d %d\\n\",i,le[i],ri[i]);\n\tfor(int i=0;i<seg[cnt].size()-1;i++){\n\t\tbool fl=0;\n\t\tfor(int j=0;j<(1<<cnt);j++)\n\t\tif(ri[j]>=seg[cnt][i]&&le[((1<<cnt)-1)^j]<=seg[cnt][i+1]+1){fl=1;break;}\n\t\tfor(int tt=seg[cnt][i]+1;tt<=seg[cnt][i+1];tt++)\n\t\tif(!fl)puts(\"Impossible\");else puts(\"Possible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x,f=1;char c;\n\twhile((c=getchar())<'0'||c>'9')if(c=='-')f=0;\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn f?x:-x;\n}\n#define MN 200000\n#define MK 19\nint x[MN+5],a[MK+1],an,l[MK+1][MN+5],r[MK+1][MN+5],lf[1<<MK],rf[1<<MK],c[MN+5];\nint main()\n{\n\tint n,v,i,j;\n\tn=read();v=read();\n\tfor(i=1;i<=n;++i)x[i]=read();\n\tfor(;;v>>=1){a[++an]=v;if(!v)break;}swap(a[1],a[an]);\n\tfor(i=1;i<=an;++i)\n\t{\n\t\tfor(l[i][n+1]=j=n;j;--j)l[i][j]=x[j+1]-x[j]<=a[i]?l[i][j+1]:j;\n\t\tfor(r[i][0]=j=1;j<=n;++j)r[i][j]=x[j]-x[j-1]<=a[i]?r[i][j-1]:j;\n\t}\n\tfor(i=0;i<1<<an-1;++i)rf[i]=n+1;\n\tfor(i=0;i<1<<an-1;++i)for(j=1;j<an;++j)if(!(i&(1<<j-1)))\n\t\tlf[i|(1<<j-1)]=max(lf[i|(1<<j-1)],l[j][lf[i]+1]),\n\t\trf[i|(1<<j-1)]=min(rf[i|(1<<j-1)],r[j][rf[i]-1]);\n\tfor(i=0;i<1<<an-1;++i)if(l[an][lf[i]+1]>=rf[i^((1<<an-1)-1)]-1)\n\t\t++c[r[an][lf[i]+1]],--c[l[an][lf[i]+1]+1];\n\tfor(i=1;i<=n;++i)puts((c[i]+=c[i-1])?\"Possible\":\"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); ++i)\n#define per(i,a,b) for (int i=(a); i>=(b); --i)\nusing namespace std;\n\nconst int maxn = 400005;\nint f[maxn][20], g[maxn][20], pre[1<<19], suf[1<<19];\nint x[maxn], ans[maxn], d[20], n, m, v;\n\nint main() {\n\tscanf(\"%d%d\", &n, &v); d[0] = v;\n\twhile (v) d[++m] = v/2, v /= 2;\n\trep (i, 1, n) scanf(\"%d\", &x[i]);\n\trep (i, 1, n) rep (j, 0, m)\n\t\tif (i >= 2 && x[i] - x[i-1] <= d[j]) f[i][j] = f[i-1][j];\n\t\telse f[i][j] = i;\n\tper (i, n, 1) rep (j, 0, m)\n\t\tif (i <= n-1 && x[i+1] - x[i] <= d[j]) g[i][j] = g[i+1][j];\n\t\telse g[i][j] = i;\n\tmemset(pre, 0xc0, sizeof pre);\n\tmemset(suf, 0x3f, sizeof suf);\n\tpre[0] = 1; suf[0] = n;\n\tint ALL = (1<<m)-1;\n\trep (i, 0, ALL) rep (j, 0, m-1) if (!(i>>j&1)) {\n\t\tif (pre[i] == n) pre[i|1<<j] = n;\n\t\telse pre[i|1<<j] = max(pre[i|1<<j], g[pre[i]+1][j+1]);\n\t\tif (suf[i] == 1) suf[i|1<<j] = 1;\n\t\telse suf[i|1<<j] = min(suf[i|1<<j], f[suf[i]-1][j+1]);\n\t}\n\tint l = 1, r, tot = 0, flag;\n\twhile (l <= n) {\n\t\tr = l; if (++tot > m) break;\n\t\twhile (r + 1 <= n && x[r+1] - x[r] <= d[0]) r++;\n\t\tflag = 0;\n\t\trep (i, 0, ALL) {\n\t\t\tif (pre[i] >= l-1 && suf[(~i)&ALL] <= r+1) {\n\t\t\t\tflag = 1; break;\n\t\t\t}\n\t\t}\n\t\trep (i, l, r) ans[i] = flag;\n\t\tl = r + 1;\n\t}\n\trep (i, 1, n) puts(ans[i] ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" :: \" << x << endl\n#define _ << \" \" <<\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(),(x).end()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for (int i=(a);i>=(b);--i)\n\nconst int mxN = 2e5+5;\nconst int lgN = 18;\nint N, V, X[mxN];\nvector<int> S;\nint M, dpL[mxN], dpR[mxN], r[lgN][mxN], l[lgN][mxN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> N >> V;\n    FOR(i,1,N){\n        cin >> X[i];\n    }\n    for (int x = V; x; x >>= 1) S.push_back(x);\n    S.push_back(0);\n    reverse(ALL(S));\n    M = SZ(S);\n    FOR(i,0,M-1){\n        r[i][N] = N;\n        RFOR(j,N-1,1){\n            r[i][j] = j;\n            if (X[j+1]-X[j] <= S[i]) r[i][j] = max(r[i][j],r[i][j+1]);\n        }\n        l[i][1] = 1;\n        FOR(j,2,N){\n            l[i][j] = j;\n            if (X[j]-X[j-1] <= S[i]) l[i][j] = min(l[i][j],l[i][j-1]);\n        }\n    }\n    dpL[0] = 0;\n    FOR(x,1,(1<<(M-1))-1){\n        dpL[x] = 1;\n        int y = x;\n        while (y) {\n            int b = y&-y, c = __builtin_ctz(b);\n            y ^= b;\n            dpL[x] = max(dpL[x],r[c][dpL[x^b]+1]);\n        }\n    }\n    dpR[0] = N+1;\n    FOR(x,1,(1<<(M-1))-1){\n        dpR[x] = N;\n        int y = x;\n        while (y) {\n            int b = y&-y, c = __builtin_ctz(b);\n            y ^= b;\n            dpR[x] = min(dpR[x],l[c][dpR[x^b]-1]);\n        }\n    }\n    FOR(i,1,N){\n        bool ok = 0;\n        FOR(x,0,(1<<(M-1))-1){\n            int y = ((1<<(M-1))-1) ^ x;\n            int p = dpL[x];\n            if (p+1 >= l[M-1][i]) p = max(p,r[M-1][i]);\n            if (p+1 >= dpR[y]) ok = 1;\n            //TRACE(i _ x _ y _ \":\" _ dpL[x] _ l[M-1][i] _ r[M-1][i] _ dpR[y]);\n        }\n        cout << (ok ? \"Possible\" : \"Impossible\") << '\\n';\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, V, K;\nint X[200010], L[20][200010], R[20][200010];\nvector<int> P;\n\nint cc1[1 << 20];\nint dp1(int mask) {\n    if(mask == 0) return -1;\n    int &ret = cc1[mask];\n    if(ret != -1) return ret;\n    if(mask == 0) return ret = 0;\n\n    ret = -1;\n    for(int i = 0; i < K; i++) {\n        if(mask & (1 << i)) {\n            ret = max(ret, (dp1(mask - (1 << i)) == N - 1? N - 1 : R[i][ dp1(mask - (1 << i)) + 1 ]));\n        }\n    }\n    return ret;\n}\nint cc2[1 << 20];\nint dp2(int mask) {\n    if(mask == 0) return N;\n    int &ret = cc2[mask];\n    if(ret != -1) return ret;\n\n    ret = N;\n    for(int i = 0; i < K; i++) {\n        if(mask & (1 << i)) {\n            ret = min(ret, (dp2(mask - (1 << i)) == 0? 0 : L[i][ dp2(mask - (1 << i)) - 1 ]));\n        }\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &V);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    P.push_back(V);\n    while(P.back()) {\n        int t = P.back() / 2;\n        P.push_back(t);\n    }\n    reverse(P.begin(), P.end());\n\n    K = P.size();\n\n    for(int i = 0; i < K; i++) {\n        int pos = 0;\n        for(int j = 0; j < N; j++) {\n            if(pos < j) pos = j;\n            while(pos < N - 1 && X[pos + 1] - X[pos] <= P[i]) pos++;\n            R[i][j] = pos;\n        }\n        pos = N - 1;\n        for(int j = N - 1; j >= 0; j--) {\n            if(pos > j) pos = j;\n            while(pos >= 1 && X[pos] - X[pos - 1] <= P[i]) pos--;\n            L[i][j] = pos;\n        }\n    }\n\n    memset(cc1, -1, sizeof(cc1));\n    memset(cc2, -1, sizeof(cc2));\n\n    if(dp1((1 << K) - 1) != N - 1) {\n        for(int i = 0; i < N; i++) {\n            printf(\"Impossible\\n\");\n        }\n        return 0;\n    }\n\n    int pos = 0;\n    while(pos < N) {\n        int nxt = R[K - 1][pos];\n\n        bool ok = false;\n        for(int i = 0; i < (1 << (K - 1)); i++) {\n            if(pos - 1 <= dp1(i) && dp2((1 << (K - 1)) - i) <= nxt + 1) {\n                ok = true;\n                break;\n            }\n        }\n        if(ok) {\n            for(int i = pos; i <= nxt; i++) {\n                printf(\"Possible\\n\");\n            }\n        }\n        else {\n            for(int i = pos; i <= nxt; i++) {\n                printf(\"Impossible\\n\");\n            }\n        }\n        pos = nxt + 1;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 998244353\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,m1,v,i,j,k,x,a[400005],b[25],bz1[400005][25],bz2[400005][25];\nint r[400005][25],l[400005][25],f[400005],g[400005],book[400005],flag;\nint minn(int u,int v){\n\treturn u<v?u:v;\n}\nint maxx(int u,int v){\n\treturn u>v?u:v;\n}\nint main(){\n\tn=read();v=read();\n\tx=v;\n\tfor(i=0;x!=0;i++){\n\t\tb[i]=x;\n\t\tx>>=1;\n\t}\n\tm=i;\n\tfor(i=1;i<=n;i++)\n\t\ta[i]=read();\n\tfor(i=1;i<n;i++)\n\t\tbz1[i][0]=a[i+1]-a[i];\n\tfor(i=2;i<=n;i++)\n\t\tbz2[i][0]=a[i]-a[i-1];\n\tfor(j=1;(1<<j)<n;j++)\n\t\tfor(i=1;i+(1<<j)<=n;i++)\n\t\t\tbz1[i][j]=maxx(bz1[i][j-1],bz1[i+(1<<(j-1))][j-1]);\n\tm1=j-1;\n\tfor(j=1;(1<<j)<n;j++)\n\t\tfor(i=(1<<j)+1;i<=n;i++)\n\t\t\tbz2[i][j]=maxx(bz2[i][j-1],bz2[i-(1<<(j-1))][j-1]);\n\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=0;j<m;j++){\n\t\t\tx=i;\n\t\t\tfor(k=m1;k>=0;k--)\n\t\t\t\tif(x+(1<<k)<=n){\n\t\t\t\t\tif(bz1[x][k]<=b[j])\n\t\t\t\t\t\tx+=(1<<k);\n\t\t\t\t}\n\t\t\tr[i][j]=x;\n\t\t\t\n\t\t\tx=i;\n\t\t\tfor(k=m1;k>=0;k--)\n\t\t\t\tif(x-(1<<k)>=1){\n\t\t\t\t\tif(bz2[x][k]<=b[j])\n\t\t\t\t\t\tx-=(1<<k);\n\t\t\t\t}\n\t\t\tl[i][j]=x;\n\t\t}\n\t}\n\tf[0]=0;\n\tg[0]=n+1;\n\tfor(i=1;i<(1<<m);i++){\n\t\tf[i]=0;\n\t\tg[i]=n+1;\n\t\tfor(j=0;j<m;j++)\n\t\t\tif(i&(1<<j)){\n\t\t\t\tif(f[i^(1<<j)]==n)\n\t\t\t\t\tf[i]=n;\n\t\t\t\telse\n\t\t\t\t\tf[i]=maxx(f[i],j!=0?r[f[i^(1<<j)]+1][j]:f[i^(1<<j)]+1);\n\t\t\t\tif(g[i^(1<<j)]==1)\n\t\t\t\t\tg[i]=1;\n\t\t\t\telse\n\t\t\t\t\tg[i]=minn(g[i],j!=0?l[g[i^(1<<j)]-1][j]:g[i^(1<<j)]-1);\n\t\t\t}\n\t}\n\tx=1;\n\ti=0;\n\twhile(x<=n){\n\t\ti++;\n\t\tif(i>=30){\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tflag=0;\n\t\tfor(j=0;j<(1<<m);j++)\n\t\t\tif(f[j]+1>=x&&g[((1<<m)-1)^j]-1<=r[x][0])\n\t\t\t\tflag=1;\n\t\tfor(j=x;j<=r[x][0];j++)\n\t\t\tbook[j]=flag;\n\t\tx=r[x][0]+1;\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tif(book[i]==1)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint L[20][222222],R[20][222222];\n\nint N,V;\nint X[222222];\n\n\nint dp1[1<<18];\nint dp2[1<<18];\n\n\nint acc[222222];\n\nsigned main(){\n    cin>>N>>V;\n    rep(i,N)cin>>X[i];\n    rep(k,20){\n        rep(i,N){\n            L[k][i]=i;\n            if(i&&X[i]-X[i-1]<=(V>>k))L[k][i]=L[k][i-1];\n        }\n        for(int i=N-1;i>=0;i--){\n            R[k][i]=i;\n            if(i+1!=N&&X[i+1]-X[i]<=(V>>k))R[k][i]=R[k][i+1];\n        }\n    }\n\n    rep(i,1<<18){\n        rep(j,18){\n            if(i>>j&1)continue;\n            if((V>>j)==0)chmax(dp1[i|(1<<j)],dp1[i]);\n            else if(dp1[i]==N)dp1[i|(1<<j)]=N;\n            else chmax(dp1[i|(1<<j)],R[j+1][dp1[i]]+1);\n        }\n    }\n\n    rep(i,1<<18)dp2[i]=N-1;\n    rep(i,1<<18){\n        rep(j,18){\n            if(i>>j&1)continue;\n            if((V>>j)==0)chmin(dp2[i|(1<<j)],dp2[i]);\n            else if(dp2[i]==-1)dp2[i|(1<<j)]=-1;\n            else chmin(dp2[i|(1<<j)],L[j+1][dp2[i]]-1);\n        }\n    }\n\n    rep(i,1<<18){\n        int j=(1<<18)-1-i;\n\n        if(dp1[i]>dp2[j]){\n            acc[0]++;\n            continue;\n        }\n\n\n        if(R[0][dp1[i]]>=dp2[j]){\n            acc[L[0][dp1[i]]]++;\n            acc[R[0][dp1[i]]+1]--;\n        }\n    }\n\n    rep(i,N){\n        acc[i+1]+=acc[i];\n        if(acc[i]){\n            puts(\"Possible\");\n        }\n        else{\n            puts(\"Impossible\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = (int) 2e5 + 5;\nconst int mod = (int) 1e9 + 7;\n\nint n, V, a[N], dpl[1 << 18], dpr[1 << 18], l[18][N], r[18][N], get_right[N];\nvector<int> v;\n\ninline void solve () {\n        scanf (\"%d%d\", &n, &V);\n        for (int i = 1; i <= n; i++) {\n                scanf (\"%d\", &a[i]);\n        }\n        a[0] = a[1]; a[n + 1] = a[n];\n        v.emplace_back (V >> 1);\n        while (v.back () >> 1) {\n                v.emplace_back (v.back () >> 1);\n        }\n        v.emplace_back (0);\n        for (int i = 0; i < v.size (); i++) {\n                r[i][n] = n;\n                for (int j = n - 1; j >= 1; j--) {\n                        if (a[j + 1] - a[j] > v[i]) {\n                                r[i][j] = j;\n                        } else {\n                                r[i][j] = r[i][j + 1];\n                        }\n                }\n                l[i][1] = 1;\n                for (int j = 2; j <= n; j++) {\n                        if (a[j] - a[j - 1] > v[i]) {\n                                l[i][j] = j;\n                        } else {\n                                l[i][j] = l[i][j - 1];\n                        }\n                }\n        }\n        dpr[0] = n + 1;\n        for (int i = 1; i < (1 << v.size ()); i++) {\n                dpr[i] = n + 1;\n                for (int j = 0; j < v.size (); j++) {\n                        if ((i >> j) & 1) {\n                                dpl[i] = max (dpl[i], r[j][dpl[i ^ (1 << j)] + 1]);\n                                dpr[i] = min (dpr[i], l[j][dpr[i ^ (1 << j)] - 1]);\n                        }\n                }\n        }\n//        for (int i = 0; i < (1 << v.size ()); i++) {\n//                printf (\"%d %d %d\\n\", i, dpl[i], dpr[i]);\n//        }\n        memset (get_right, 63, sizeof get_right);\n        for (int i = 0; i < (1 << v.size ()); i++) {\n                int rev = ((1 << v.size ()) - 1) ^ i;\n                get_right[dpl[i]] = min (get_right[dpl[i]], dpr[rev]);\n        }\n        for (int i = n; i >= 0; i--) {\n                get_right[i] = min (get_right[i], get_right[i + 1]);\n        }\n//        for (int i = 0; i <= n + 1; i++) {\n//                printf (\"%d \", get_right[i]);\n//        }\n//        puts (\"\");\n        int l = 0, r = 2;\n        for (int i = 1; i <= n; i++) {\n                r = max (r, i + 1);\n                while (r <= n && a[r] - a[r - 1] <= V) {\n                        r++;\n                }\n                if (a[i] - a[i - 1] > V) {\n                        l = i - 1;\n                }\n//                printf (\"%d %d\\n\", l, r);\n                puts (get_right[l] <= r ? \"Possible\" : \"Impossible\");\n        }\n}\n\nint tests = 1;\n\nint main () {\n//        freopen (\".in\", \"r\", stdin);\n//        freopen (\".out\", \"w\", stdout);\n//        scanf (\"%d\", &tests);\n        while (tests--) {\n                solve ();\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 2e5 + 10;\n\nint n, v, m, ans[N];\nint a[N], b[N], L[N][22], R[N][22], f[N], g[N];\n\nbool ask(int u)\n{\n    return ans[L[u][0] - 1] <= R[u][0] + 1;\n}\n\nint main()\n{\n    n = read(), v = read();\n    for (int i = 1; i <= n; i++) a[i] = read();\n    for (m = 0; v; v >>= 1, m++)\n    {\n        L[0][m] = L[1][m] = 1;\n        for (int j = 2; j <= n; j++)\n            L[j][m] = a[j] - a[j - 1] <= v ? L[j - 1][m] : j;\n        R[n + 1][m] = R[n][m] = n;\n        for (int j = n - 1; j >= 1; j--)\n            R[j][m] = a[j + 1] - a[j] <= v ? R[j + 1][m] : j;\n    }\n    for (int i = 1; i <= n; i++) L[i][m] = R[i][m] = i;\n    for (int i = 0; i < (1 << m); i++) g[i] = n + 1;\n    for (int i = 0; i < (1 << m); i++)\n        for (int j = 0; j < m; j++)\n            if (!(i >> j & 1))\n            {\n                f[i | (1 << j)] = max(f[i | (1 << j)], R[f[i] + 1][j + 1]);\n                g[i | (1 << j)] = min(g[i | (1 << j)], L[g[i] - 1][j + 1]);\n            }\n    for (int i = 0; i <= n; i++) ans[i] = 2e9;\n    for (int i = 0; i < (1 << m); i++)\n        ans[f[i]] = min(ans[f[i]], g[((1 << m) - 1) ^ i]);\n    for (int i = n - 1; i >= 1; i--)\n        ans[i] = min(ans[i], ans[i + 1]);\n    for (int i = 1; i <= n; i++) puts(ask(i) ? \"Possible\" : \"Impossible\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\n#ifdef _DEBUG\n#define dbg(x) cerr << #x << \":\" << x << endl;\n#else\n#define dbg(x) while(false){}\n#endif\n\n#define fi(a, b) for(int i=a;i<b;++i)\n#define fj(a, b) for(int j=a;j<b;++j)\n\n////////\n\nint const M = 20;\nint const N = (1<<M);\nstring const YES = \"Possible\";\nstring const NO = \"Impossible\";\n\nint n, v, x[N];\nint le[N][M], ri[N][M];\nint cnt;\nstring ans[N];\n\nvoid setAns(string val, int l, int r){\n\tfi(l, r+1) ans[i] = val;\n}\n\nvoid print(){\n\tfi(1, n+1) printf(\"%s\\n\", ans[i].c_str());\n\texit(0);\n}\n\nvoid check(){\n\tint cn = cnt + 1;\n\tint v = 1;\n\twhile(v <= n){\n\t\tv = ri[v][0] + 1;\n\t\t--cn;\n\t}\n\tif(cn < 0){\n\t\tsetAns(NO, 1, n);\n\t\tprint();\n\t}\n}\n\nvoid build(){\n\tint vi = v;\n\tfi(0, M){\n\t\tcnt = i;\n\t\tle[1][i] = 1;\n\t\tfj(2, n+1){\n\t\t\tif(x[j] - x[j-1] <= vi) le[j][i] = le[j-1][i];\n\t\t\telse le[j][i] = j;\n\t\t}\n\t\tri[n][i] = n;\n\t\tfor(int j=n-1;j>0;--j){\n\t\t\tif(x[j+1] - x[j] <= vi) ri[j][i] = ri[j+1][i];\n\t\t\telse ri[j][i] = j;\n\t\t}\n\t\tif(vi == 0) break;\n\t\tvi /= 2;\n\t}\n}\n\nint dl[N], dr[N];\n\nvoid remax(int &a, int b){\n\ta = max(a, b);\n}\n\nvoid remin(int &a, int b){\n\ta = min(a, b);\n}\n\nvoid calcDp(){\n\tdl[0] = 0;\n\tfi(0, (1<<cnt)){\n\t\tfj(0, cnt){\n\t\t\tif((1<<j)&i) continue;\n\t\t\tint nval = dl[i];\n\t\t\tif(nval != n){\n\t\t\t\tnval = ri[dl[i]+1][j+1];\n\t\t\t}\n\t\t\tremax(dl[((1<<j)^i)], nval);\n\t\t}\n\t}\n\tfi(0, (1<<cnt)) dr[i] = n+1;\n\tfi(0, (1<<cnt)){\n\t\tfj(0, cnt){ \n\t\t\tif((1<<j)&i) continue;\n\t\t\tint nval = dr[i];\n\t\t\tif(nval != 1){\n\t\t\t\tnval = le[dr[i]-1][j+1];\n\t\t\t}\n\t\t\tremin(dr[((1<<j)^i)], nval);\n\t\t}\n\t}\n}\n\nvoid findAnswers(){\n\tint v, nxt;\n\tv = 1;\n\twhile(v <= n){\n\t\tnxt = ri[v][0];\n\t\tbool can = false;\n\t\tfi(0, (1<<(cnt))){\n\t\t\tint maskL = i;\n\t\t\tint maskR = ( ((1<<(cnt))-1) ^ maskL );\n\t\t\tint lb = max(dl[maskL], 1);\n\t\t\tint rb = min(dr[maskR], n);\n\t\t\tif(lb+1 >= v && rb-1 <= nxt){\n\t\t\t\tcan = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(can){\n\t\t\tsetAns(YES, v, nxt);\n\t\t}else{\n\t\t\tsetAns(NO, v, nxt);\n\t\t}\n\t\tv = nxt + 1;\n\t}\n}\n\nvoid solve(){\n\tscanf(\"%d %d\",&n,&v);\n\tfi(1, n+1) scanf(\"%d\",&x[i]);\n\n\tbuild();\n\tdbg(cnt);\n\tcheck();\n\tcalcDp();\n\tfindAnswers();\n\tprint();\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\ninline int rnd(int x){\n\treturn rand()%x;\n}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=19,N=200005;\nint n,v,gao,f[N],g[N],x[N],lst[M][N],nxt[M][N],dp[1<<M],tong[N];\nint main(){\n\tn=read(); v=read(); x[0]=-1e9; x[n+1]=1e9;\n\tfor(int i=1;i<=n;i++)x[i]=read();\n\tfor(int i=0;;i++){\n\t\tint dali=v>>i; gao=i;\n\t\tfor(int j=1;j<=n;j++)if(x[j]-x[j-1]<=dali)lst[i][j]=lst[i][j-1]; else lst[i][j]=j;\n\t\tfor(int j=n;j;j--)if(x[j+1]-x[j]<=dali)nxt[i][j]=nxt[i][j+1]; else nxt[i][j]=j;\n\t\tif((v>>i)==0)break;\n\t}\n\tf[0]=0; g[0]=n+1; \n\tfor(int i=1;i<(1<<gao);i++){\n\t\tf[i]=0; g[i]=n+1;\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)f[i]=max(f[i],nxt[j+1][f[i^(1<<j)]+1]);\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)g[i]=min(g[i],lst[j+1][g[i^(1<<j)]-1]);\n\t\tdp[i]=min(dp[i],n);\n\t}\n\tfor(int i=0;i<=n+1;i++)tong[i]=-1;\n\tfor(int i=0;i<(1<<gao);i++){\n\t\tint l=f[i],r=g[((1<<gao)-1)^i];\n\t\ttong[r]=max(tong[r],l);\n\t}\n\tfor(int i=1;i<=n;i++)tong[i]=max(tong[i],tong[i-1]);\n\tfor(int i=1;i<=n;i++){\n\t\tint l=lst[0][i],r=nxt[0][i];\n\t\tputs(tong[r+1]>=l-1?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, V;\n\nconst int maxn = 200010;\nbool f[maxn][1<<20];\nbool g[maxn][1<<20];\nint x[maxn], l[maxn][20], r[maxn][20];\n\nint val[20];\nint m, mask;\n\nint main() {\n\tscanf(\"%d%d\", &N, &V);\n\tfor(int i = 0; i < N; ++i) scanf(\"%d\", &x[i]);\n\tfor(int v = V; v; v /= 2) val[m++] = v;\n\tmask = (1 << m) - 1;\n\n\tfor(int i = 0; i < N; ++i) {\n\t\tfor(int j = 0; j < m; ++j) {\n\t\t\tl[i][j] = i;\n\t\t\tif(i && x[i] - x[i-1] <= val[j]) l[i][j] = l[i-1][j];\n\t\t}\n\t}\n\n\tfor(int i = N - 1; i >= 0; ++i) {\n\t\tfor(int j = 0; j < m; ++j) {\n\t\t\tr[i][j] = i;\n\t\t\tif(i + 1 < N && x[i] - x[i-1] <= val[j]) r[i][j] = r[i+1][j];\n\t\t}\n\t}\n\n\tfor(int j = 0; j < 1<<m; ++j) {\n\t\tf[0][j] = true;\n\t}\n\n\tfor(int i = 1; i < N; ++i) {\n\t\tfor(int j = 0; j < 1<<m; ++j) {\n\t\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1) {\n\t\t\t\tf[i][j] |= f[max(0, l[i][k] - 1)][j ^ (1<<k)];\n\t\t\t\tif(f[i][j]) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tg[N][0] = true;\n\tfor(int i = N - 1; i >= 0; --i) {\n\t\tfor(int j = 0; j < 1<m; ++j) {\n\t\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1) {\n\t\t\t\tg[i][j] |= g[r[i][k] + 1][j ^ (1<<k)];\n\t\t\t\tif(g[i][j]) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0, j; i < N; i = j) {\n\t\tfor(j = i + 1; j < N && x[j] - x[j-1] <= V; ++j);\n\t\tbool flag = false;\n\t\tfor(int k = 0; k < 1<<m; ++k) \n\t\t\tif(f[i][k] && g[j][k ^ mask]) { flag = true; break; }\n\t\tif(flag) {\n\t\t\tfor(int k = i; k < j; ++k) puts(\"Possible\");\n\t\t} else {\n\t\t\tfor(int k = i; k < j; ++k) puts(\"Impossible\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 200010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;if(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\n\nint b[40],sz,a[N],c[N];\nint dp[1<<18],f[1<<18],l[N][20],r[N][20];\nint main(){\n    //freopen(\"A.in\",\"r\",stdin);\n    //freopen(\"A.out\",\"w\",stdout);\n    //cout<<setprecision(9)<<fixed;\n    //cerr<<setprecision(9)<<fixed;\n    int T,i,j,k,ca=0,m,K,n;\n    scanf(\"%d%d\",&n,&m);\n    K=m;sz=0;\n    while(K)b[sz++]=K,K>>=1;\n    b[sz++]=0;\n    swap(b[0],b[sz-1]);\n    rep(i,0,n)scanf(\"%d\",&a[i]);\n    rep(k,0,sz){\n        K=b[k];\n        //cerr<<k<<\" \"<<K<<\"\\n\";\n        l[0][k]=0;\n        rep(i,1,n){\n            if(K>=a[i]-a[i-1])l[i][k]=l[i-1][k];\n            else l[i][k]=i;\n        }\n        r[n-1][k]=n-1;\n        per(i,0,n-1){\n            if(K>=a[i+1]-a[i])r[i][k]=r[i+1][k];\n            else r[i][k]=i;\n        }\n    }\n    sz--;\n    memset(dp,-1,sizeof(dp));\n    dp[0]=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Max(dp[i|1<<j],x);\n            if(x+1<n)Max(dp[i|1<<j],r[x+1][j]);\n        }\n    }\n    per(i,0,(1<<sz))f[i]=n;\n    f[0]=n-1;\n    rep(i,0,(1<<sz)){\n        int x=f[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Min(f[i|1<<j],x);\n            if(x)Min(f[i|1<<j],l[x-1][j]);\n        }\n    }\n    int mask=(1<<sz)-1,flag=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i],y=f[mask^i];\n        if(y<=x+1){\n            flag=1;break;\n        }\n        k=r[x+1][sz];\n        j=l[y-1][sz];\n        if(j<=x+1&&k>=y-1)c[j]++,c[k+1]--;\n    }\n    /*\n    if(flag){\n        rep(i,0,n)puts(\"Possible\");\n    }\n    else\n    {\n        rep(i,1,n)c[i]+=c[i-1];\n        rep(i,0,n){\n            if(c[i])puts(\"Possible\");\n            else puts(\"Impossible\");\n        }\n    }//*/\n    \n    rep(i,0,n){\n        int x=l[i][sz],y=r[i][sz],ok=0;\n        //cerr<<i<<\" \"<<x<<\" \"<<y<<\"\\n\";\n        rep(j,0,(1<<sz)){\n            k=mask^j;\n            //cerr<<j<<\" \"<<dp[j]<<\",\"<<k<<\" \"<<f[k]<<\"\\n\";\n            if(dp[j]>=x-1&&f[k]<=y+1){ok=1;break;}\n        }\n        puts(ok?\"Possible\":\"Impossible\");\n    }//*/\n    //cerr<<clock()*1./CLOCKS_PER_SEC<<\"ms\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][30],tmp[30][30];\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>=dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return 1;\n\t\tr[i]=t[i];\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,V;\nint X[200005];\nbool res[200005];\n\nvector<vector<int>> split_v(int ps,int tv,int &nps,vector<vector<int>>& xs){\n  int n = xs.size();\n  vector<vector<int>> vs;\n\n  int maxi_nc = 0;\n  nps = 0;\n  for(int i=0;i<n;i++){\n    if( i == ps ) continue;\n    int pv = -2*1000000000;\n    vector<int> v;\n    int nc = 1;\n    for(int x : xs[i]){\n      if( abs( x - ps ) <= tv ) {\n        v.emplace_back( x );\n      } else {\n        vs.emplace_back( v );\n        v.emplace_back( x );\n        nc++;\n      }\n    }\n    if( maxi_nc < nps ) {\n      maxi_nc = max(maxi_nc, nc);\n      nps = i;\n    }\n  }\n  return vs;\n}\n\nbool F[200005];\nbool solve(int ps, vector<vector<int>> xs){\n  int nps;\n  int tv = V;\n  memset( F,0, sizeof(F) );\n  for( int v : xs[ps] ) F[v] = true;\n  xs = split_v(ps,V/2,nps,xs);\n  while( tv > 0 ) {\n    tv/=2;\n    split_v(-1,tv/2,nps,xs);\n    ps = nps;\n    for(int v : xs[ps] )\n      F[v] = true;\n    xs = split_v(ps,tv/2,nps,xs);\n  }\n\n  for(int i=0;i<N;i++)\n    if( !F[i] ) return false;\n  return true;\n}\n\n\nint main() {\n  cin >> N >> V;\n  vector<vector<int>> xs;\n  vector<int> x;\n  int pv = -2*1000000000;\n  for(int i=0;i<N;i++){\n    cin >> X[i];\n    if( abs( X[i] - pv ) <= V ){\n      x.emplace_back( X[i] );\n    } else {\n      xs.emplace_back( x );\n      x.emplace_back( X[i] );\n    }\n    pv = X[i];\n  }\n  xs.emplace_back( x );\n\n  int jc = 0;\n  int tv = V;\n  while( tv > 0 ) {\n    tv/=2; jc++;\n  }\n\n  if( jc + 1 < xs.size() ) {\n    for(int i=0;i<N;i++)\n      cout << \"Impossible\" << endl;\n  } else {\n    for(int i=0;i<N;i++){\n      if( solve(i,xs) )\n        for( int v : xs[i] )\n          res[v] = true;\n    }\n    for(int i=0;i<N;i++)\n      if( res[i] ) cout << \"Possible\" << endl;\n      else cout << \"Impossible\" << endl;\n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define mp(x,y) make_pair(x,y)\n#define ft first\n#define sd second\n#define rep(i,l,r) for (int i=l;i<=r;++i)\n#define P pair<int ,int >\nusing namespace std;\nconst int N =2e5+10;\nvoid read(int &x)\n{\n\tx=0;\n\tchar ch=getchar();int f=1;\n\twhile (ch<'0'||ch>'9') ch=='-'?f=-1:0,ch=getchar();\n\twhile ('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx*=f;\n}\nint n,bo[N],tot,m,a[N],top,v[233],l[N][20],r[N][20],f[1<<20],g[1<<20],cnt,tmp;\nP b[N<<1];\nvoid _mx(int &x,int y)\n{\n\tx=max(x,y);\n}\n\nvoid _mn(int &x,int y)\n{\n\tx=min(x,y);\n}\n\nint main()\n{\n\tread(n);read(m);\n\trep(i,1,n) read(a[i]);\n\tfor (;v[top++]=m;m>>=1);\n\trep(i,0,top) \n\t{\n\t\tint lst=1;\n\t\trep(j,2,n) if (a[j]-a[j-1]>v[i]) \n\t\t{\n\t\t\trep(k,lst,j-1) l[k][i]=lst,r[k][i]=j-1;\n\t\t\tlst=j;\n\t\t}\n\t\trep(k,lst,n) l[k][i]=lst,r[k][i]=n;\n\t}\n\ttot=1<<top;--tot;rep(i,0,tot) g[i]=n+1;\n\trep(i,0,tot) rep(j,0,top) \n\tif (!(i&1<<j)) _mx(f[i|1<<j] ,r[f[i]+1][j]),_mn(g[i|1<<j] ,l[g[i]-1][j]);\n\trep(i,0,tot) if (!(i&1)) b[++cnt]=mp(g[i],i);\n\trep(i,1,n) b[++cnt]=mp(r[i][0]+1,(1<<top)+i);\n\tsort(b+1,b+1+cnt);tmp=-1;\n\trep(i,1,cnt) if (b[i].sd>(1<<top))\n\t{\n\t\tb[i].sd-=(1<<top);\n\t\tif (tmp>=l[b[i].sd][0]-1) bo[b[i].sd]=1;\n\t}else _mx(tmp,f[((1<<top)-2)^b[i].sd]);\n\trep(i,1,n) printf(\"%s\\n\",bo[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 200000 + 1000;\nconst int MAXM = 1048576;\nconst int MAXK = 20;\n\n\nint n, m, V;\nint a[MAXN], v[MAXK];\nint f[MAXM], g[MAXM];\nint next[MAXN][MAXK], prev[MAXN][MAXK];\nint ans[MAXN];\n\nvoid yes()\n{\n\tcout << \"Possible\" << endl;\n}\n\nvoid no()\n{\n\tcout << \"Impossible\" << endl;\n}\n\nvoid init()\n{\n\tfor(m = 0; V; V /= 2, m++)\n\t\tv[m] = V;\n\tv[m++] = 0;\n\n\tfor(int i = 0; i <= m - 1; i++)\n\t\tnext[n + 1][i] = next[n][i] = n;\n\tfor(int i = n - 1; i >= 1; i--)\n\t\tfor(int j = 0; j <= m - 1; j++)\n\t\t\tnext[i][j] = (a[i + 1] - a[i] <= v[j] ? next[i + 1][j] : i);\n\n\tfor(int i = 0; i <= m - 1; i++)\n\t\tprev[0][i] = prev[1][i] = 1;\n\tfor(int i = 2; i <= n; i++)\n\t\tfor(int j = 0; j <= m - 1; j++)\n\t\t\tprev[i][j] = (a[i] - a[i - 1] <= v[j] ? prev[i - 1][j] : i);\n}\n\nvoid work()\n{\n\tf[0] = 0;\n\tfor(int i = 1; i < (1 << m); i++)\n\t{\n\t\tf[i] = 0;\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tif((i >> j) & 1)\n\t\t\t\tf[i] = max(f[i], next[f[i ^ (1 << j)] + 1][j]);\n\t}\n\tg[0] = n + 1;\n\tfor(int i = 1; i < (1 << m); i++)\n\t{\n\t\tg[i] = n + 1;\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tif((i >> j) & 1)\n\t\t\t\tg[i] = min(g[i], prev[g[i ^ (1 << j)] - 1][j]);\n\t}\n\n\tfor(int i = 0; i < (1 << m); i++)\n\t{\n\t\tint s1 = i, s2 = ((1 << m) - 1) ^ i;\n\t\ts1 = s1 & ~1, s2 = s2 & ~1;\n\t\tint p = f[s1], q = g[s2];\n\t\tif(p + 1 > q - 1)\n\t\t{\n\t\t\tfor(int j = 1; j <= n; j++)\n\t\t\t\tyes();\n\t\t\treturn ;\n\t\t}\n\t\tif(next[p + 1][0] >= q - 1)\n\t\t\tans[p + 1] += 1, ans[q - 1 + 1] -= 1;\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tans[i] += ans[i - 1];\n\tfor(int i = 1; i <= n; i++)\n\t\tans[i] > 0 ? yes() : no();\n\t// for(int i = 1; i <= n; i++)\n\t// \tcerr << ans[i] << endl;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n >> V;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\n\tinit();\n\twork();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Camel and Oases\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint const N=2e5+10;\nint const S=1<<17;\nint n,V;\nint d[N];\nint logV,a[20][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n    }\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nvoid type(int s)\n{\n    for(int i=logV;i>=1;i--) printf(\"%d\",(s>>(i-1))%2);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%d\",&d[i]),d[i-1]=d[i]-d[i-1];\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    /*for(int i=1;i<=logV;i++)\n    {\n    \tprintf(\"%d-%d \",1,a[i][1]);\n        for(int j=2;j<=a[i][0];j++) printf(\"%d-%d \",a[i][j-1]+1,a[i][j]);\n        printf(\"\\n\");\n    }*/\n    if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++) puts(\"Impossible\");\n        return 0;\n    }\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=1,f2[s]=n;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    /*for(int s=0;s<=U;s+=2)\n        type(s),printf(\"   1-%2d  %2d-%2d\\n\",f1[s],f2[U-s-1],n);*/\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1 && f2[U-s-1]-1<=to) f=true;\n        printf(\"%d-%d\\n\",fr,to);\n        if(f) for(int j=fr;j<=to;j++) puts(\"Possible\");\n        else for(int j=fr;j<=to;j++) puts(\"Impossible\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nint n,v,m,a[200005],len[25],L[200005][25],R[200005][25],f[1000005],g[1000005];\npriority_queue<int> q;\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\twhile(v) len[m++]=v,v>>=1;len[m++]=0;\n\tfor(int i=0;i<m/2;i++) swap(len[i],len[m-i-1]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tL[i][p]=L[i-1][p];\n\t\t\tif(i==1||a[i]-a[i-1]>len[p]) L[i][p]=i;\n\t\t}\n\t}\n\tfor(int i=n;i;i--){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tR[i][p]=R[i+1][p];\n\t\t\tif(i==n||a[i+1]-a[i]>len[p]) R[i][p]=i;\n\t\t}\n\t}\n\tf[0]=0;g[0]=n+1;\n\tfor(int i=1;i<(1<<m);i++){\n\t\tg[i]=n+1;\n\t\tfor(int p=0;p<m;p++) if(i&(1<<p)){\n\t\t\tf[i]=max(f[i],R[f[i^(1<<p)]+1][p]);\n\t\t\tg[i]=min(g[i],L[g[i^(1<<p)]-1][p]);\n\t\t}\n\t}\n\tfor(int i=1;i<(1<<m);i++) f[i]=max(f[i],f[i-1]),g[i]=min(g[i],g[i-1]);\n\tint S=(1<<m-1)-1;\n\tfor(int i=1,pos=0;i<=n;i++){\n\t\twhile(f[pos]>=L[i][m-1]-1&&pos<=S) q.push(S^pos),pos++;\n\t\twhile(!q.empty()&&f[S^q.top()]<L[i][m-1]-1) q.pop();\n\t\tif(q.empty()){\n\t\t\tputs(\"Impossible\");continue;\n\t\t}\n\t\tif(g[q.top()]>R[i][m-1]+1) puts(\"Impossible\");\n\t\telse puts(\"Possible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][30],tmp[30][30];\n\nstruct hh\n{\n\tinline size_t operator()(ull x)const\n\t{\n\t\treturn x%19260817;\n\t}\n};\n\nstd::unordered_map<ull,bool,hh>hs;\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\tull hash=dep;\n\tfo0(i,cnt)hash=hash*2337+s[i];\n\tif(hs.count(hash))return hs[hash];\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>=dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\tr[i]=t[i];\n\t}\n\treturn hs[hash]=0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2019/11/16] 15:47:41\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing uint = unsigned int;\nusing usize = std::size_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\n\ntemplate<typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename... Args>\nauto read(const usize size, Args... args)\n{\n    std::vector<decltype(read<T>(args...))> ans(size);\n    for (usize i = 0; i < size; i++) { ans[i] = read<T>(args...); }\n    return ans;\n}\ntemplate<typename... Types>\nauto reads() { return std::tuple<std::decay_t<Types>...>{read<Types>()...}; }\n#    define SHOW(...) static_cast<void>(0)\n\ntemplate<typename T>\nstd::vector<T> make_v(const usize size, const T v) { return std::vector<T>(size, v); }\ntemplate<typename... Args>\nauto make_v(const usize size, Args... args) { return std::vector<decltype(make_v(args...))>(size, make_v(args...)); }\nint main()\n{\n    const auto n = read<int>(), v = read<int>();\n    const auto x = read<ll>(n);\n    std::vector<int> vs{v};\n    for (; vs.back() > 0;) { vs.push_back(vs.back() / 2); }\n    SHOW(vs);\n    const int jump = vs.size();\n    SHOW(jump);\n    auto right = make_v(jump, n, n);\n    for (int i = 0; i < jump; i++) {\n        for (int j = (int)n - 2; j >= 0; j--) {\n            const ll dx = x[j + 1] - x[j];\n            right[i][j] = (dx <= vs[i] ? right[i][j + 1] : j);\n        }\n    }\n    SHOW(right);\n    auto left = make_v(jump, n, -1);\n    for (int i = 0; i < jump; i++) {\n        for (int j = 1; j < n; j++) {\n            const ll dx = x[j] - x[j - 1];\n            left[i][j]  = (dx <= vs[i] ? left[i][j - 1] : j);\n        }\n    }\n    SHOW(left);\n    const int mask = 1 << jump;\n    std::vector<int> rdp(mask, -1);\n    for (int m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const int pos = rdp[m] + 1;\n        for (int i = 1; i < jump; i++) {\n            if (btest(m, i)) { continue; }\n            if (rdp[m] == n - 1) {\n                chmax(rdp[m | (1 << i)], rdp[m]);\n                continue;\n            }\n            const int r = right[i][pos];\n            chmax(rdp[m | (1 << i)], r);\n        }\n    }\n    std::vector<int> ldp(mask, n);\n    for (int m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const int pos = ldp[m] - 1;\n        for (int i = 1; i < jump; i++) {\n            if (btest(m, i)) { continue; }\n            if (ldp[m] == 0) {\n                chmin(ldp[m | (1 << i)], ldp[m]);\n                continue;\n            }\n            const int l = left[i][pos];\n            chmin(ldp[m | (1 << i)], l);\n        }\n    }\n    SHOW(ldp, rdp);\n    std::vector<int> ok(n, 0);\n    for (int m = 0; m < mask; m++) {\n        if (m != 0 and btest(m, 0)) { continue; }\n        const int l = rdp[m];\n        const int r = ldp[(mask - 2) - m];\n        SHOW(m, l, r);\n        if (l + 1 >= r) {\n            std::fill(ok.begin(), ok.end(), 1);\n            break;\n        }\n        const int r2 = right[0][l + 1 == n ? n - 1 : l + 1];\n        const int l2 = left[0][r2];\n        if (r2 + 1 >= r) {\n            if (r2 + 1 < n) { ok[r2 + 1]--; }\n            if (l2 + 1 < n) { ok[l2 + 1]++; }\n        }\n    }\n    SHOW(ok);\n    for (int i = 1; i < n; i++) { ok[i] += ok[i - 1]; }\n    for (int i = 0; i < n; i++) { std::cout << (ok[i] > 0 ? \"Possible\" : \"Impossible\") << std::endl; }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint N, V, LOG, a[200001], LE[18][200001], RE[18][200001], F[262144], G[262144], OK[200001];\nint main()\n{\n\tscanf(\"%d%d\", &N, &V);\n\twhile (1 << LOG <= V)\n\t\tLOG++;\n\tfor (int i = 1; i <= N; i++)\n\t\tscanf(\"%d\", a + i);\n\tfor (int i = 0; i <= LOG; i++)\n\t{\n\t\tint *le = LE[i], *re = RE[i];\n\t\tle[1] = 1;\n\t\tfor (int j = 2; j <= N; j++)\n\t\t\tle[j] = a[j] - a[j - 1] <= V >> i ? le[j - 1] : j;\n\t\tre[N] = N;\n\t\tfor (int j = N - 1; j; j--)\n\t\t\tre[j] = a[j + 1] - a[j] <= V >> i ? re[j + 1] : j;\n\t}\n\tfor (int i = 0; i < 1 << LOG; i++)\n\t{\n\t\tF[i] = 0;\n\t\tG[i] = N + 1;\n\t\tfor (int j = 1; j <= LOG; j++)\n\t\t\tif (i >> j - 1 & 1)\n\t\t\t{\n\t\t\t\tF[i] = std::max(F[i], F[i - (1 << j - 1)] == N ? N : RE[j][F[i - (1 << j - 1)] + 1]);\n\t\t\t\tG[i] = std::min(G[i], G[i - (1 << j - 1)] == 1 ? 1 : LE[j][G[i - (1 << j - 1)] - 1]);\n\t\t\t}\n\t}\n\tfor (int i = 0; i < 1 << LOG; i++)\n\t\tif (F[i] + 1 >= G[(1 << LOG) - 1 - i])\n\t\t{\n\t\t\tfor (int j = N; j--; )\n\t\t\t\tputs(\"Possible\");\n\t\t\treturn 0;\n\t\t}\n\tfor (int i = 0; i < 1 << LOG; i++)\n\t\tif (RE[0][F[i] + 1] + 1 >= G[(1 << LOG) - 1 - i])\n\t\t{\n\t\t\tint R = RE[0][F[i] + 1], L = LE[0][R];\n\t\t\tif (!OK[L])\n\t\t\t\tstd::fill(OK + L, OK + R + 1, 1);\n\t\t}\n\tfor (int i = 1; i <= N; i++)\n\t\tputs(OK[i] ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long i64;\n\ntemplate<class T>\nvoid selectMin(T & x, const T & y)\n{\n\tif (x > y)\n\t\tx = y;\n}\ntemplate<class T>\nvoid selectMax(T & x, const T & y)\n{\n\tif (x < y)\n\t\tx = y;\n}\n\nconst int MAXN = 2e5 + 10;\nconst int MAXLOG = 20 + 5;\nconst int PINF = 0x3F3F3F3F;\n\nconst char NSOL[] = \"Impossible\";\nconst char FSOL[] = \"Possible\";\n\nint N, V;\nint lg2 = -1;\nint exp_2[MAXLOG];\nint R[MAXLOG][MAXN];\nint cnt[MAXLOG];\nint dp1[MAXN << 3], dp2[MAXN << 3];\nint A[MAXN];\n\nvoid prepare()\n{\n\texp_2[0] = 1;\n\tfor (int i = 1; i < MAXLOG; i++)\n\t\texp_2[i] = exp_2[i - 1] * 2;\n}\n\nint main()\n{\n\tprepare();\n\tcin >> N >> V;\n\tfor (int i = 1; i <= N; i++)\n\t\tcin >> A[i];\n\n\tint x = V * 2;\n\twhile (x)\n\t{\n\t\tx /= 2, lg2++;\n\n\t\t// Split segments\n\t\tfor (int i = 1; i < N; i++)\n\t\t{\n\t\t\tif (A[i + 1] - A[i] <= x)\n\t\t\t\tcontinue;\n\t\t\tR[lg2][++cnt[lg2]] = i;\n\t\t}\n\t\tR[lg2][++cnt[lg2]] = N;\n\t}\n\n\tif (cnt[0] > lg2 + 1)\n\t{\n\t\tfor (int i = 1; i <= N; i++)\n\t\t\tputs(NSOL);\n\t\treturn 0;\n\t}\n\n\tfor (int s = 0; s < exp_2[lg2]; s++)\n\t\tdp2[s] = N + 1;\n\tfor (int s = 0; s < exp_2[lg2]; s++)\n\t\tfor (int i = 1; i <= lg2; i++)\n\t\t{\n\t\t\tif (s & exp_2[i - 1])\n\t\t\t\tcontinue;\n\t\t\tselectMax(dp1[s | exp_2[i - 1]],\n\t\t\t\t\t*upper_bound(R[i] + 1, R[i] + cnt[i] + 1, dp1[s]));\n\t\t\tselectMin(dp2[s | exp_2[i - 1]],\n\t\t\t\t\tR[i][lower_bound(R[i] + 1, R[i] + cnt[i] + 1, dp2[s] - 1)\n\t\t\t\t\t\t\t- R[i] - 1] + 1);\n\t\t}\n\n\tfor (int i = 1; i <= cnt[0]; i++)\n\t{\n\t\tbool solution = false;\n\t\tfor (int s = 0; s < exp_2[lg2]; s++)\n\t\t\tif (dp1[s] >= R[0][i - 1] && dp2[exp_2[lg2] - s - 1] <= R[0][i] + 1)\n\t\t\t{\n\t\t\t\tsolution = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tfor (int j = R[0][i - 1] + 1; j <= R[0][i]; j++)\n\t\t\tputs(solution ? FSOL : NSOL);\n\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3e5+10;\nint n,v[20],x[N],dep,dpl[N],dpr[N];\nint blo[20][N],L[20][N],R[20][N];\nvoid init(int dep){\n\tint cnt=0;\n\tblo[dep][1]=L[dep][1]=R[dep][1]=cnt=1;\n\tfor (int i=2;i<=n;i++){\n\t\tif (x[i-1]+v[dep]>=x[i]) blo[dep][i]=cnt,R[dep][cnt]++;else\n\t\tblo[dep][i]=++cnt,L[dep][cnt]=R[dep][cnt]=i;\n\t}\n\tL[dep][0]=1;R[dep][0]=n;\n}\nbool ans[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&v[0]);\n\twhile (v[dep]) v[dep+1]=v[dep]>>1,dep++;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor (int i=0;i<=dep;i++) init(i);\n\tint U=(1<<dep)-1;\n\tfor (int S=1;S<=U;S++)\n\tfor (int i=0;i<dep;i++)\n\tif (S>>i&1) dpl[S]=max(dpl[S],R[i+1][blo[i+1][dpl[S^(1<<i)]+1]]);\n\tfor (int S=0;S<=U;S++) dpr[S]=n+1;\n\tfor (int S=1;S<=U;S++)\n\tfor (int i=0;i<dep;i++)\n\tif (S>>i&1) dpr[S]=min(dpr[S],L[i+1][blo[i+1][dpr[S^(1<<i)]-1]]);\n\tif (blo[0][n]<=20){\n\t\tfor (int i=1;i<=blo[0][n];i++){\n\t\t\tint l=L[0][i],r=R[0][i];bool ok=0;\n\t\t\tfor (int S=0;S<=U;S++)\n\t\t\tif (dpl[S]>=l-1&&dpr[U^S]<=r+1) ok=1;\n\t\t\tif (!ok) continue;\n\t\t\tfor (int j=l;j<=r;j++) ans[j]=1;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) puts(ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<math.h>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst long long int INF=99999999999999,inf=199999;\nconst long long int mod=1000000007;\n\n\n\nlong long int tmp,n,canmove[25]={},v,x[200005],leftdp[400000]={},rightdp[400000]={};\nlong long int leftnext[20][400005]={},rightnext[20][400005]={},two[30]={1};\nlong long int leftmemo[400005]={},rightmemo[400005]={};\nlong long int cou=0,k;\n\nvoid leftsolve(){\n    long long int count=0;\n    queue<long long int>que,memoque;\n    que.push(0);\n    \n    while(1){\n        while(!que.empty()){\n            for(int i=0;i<k;i++){\n                if((que.front()/two[i]%2)==0){\n                    leftdp[que.front()+two[i]]=max(leftdp[que.front()+two[i]],leftnext[i][leftdp[que.front()]]);\n                    //次のループで被りが出ないように\n                    if(leftmemo[que.front()+two[i]]==0){\n                        memoque.push(que.front()+two[i]);\n                        leftmemo[que.front()+two[i]]=1;\n                    }\n                }\n            }\n            que.pop();\n        }\n        while(!memoque.empty()){\n            que.push(memoque.front());\n            memoque.pop();\n        }\n        if(que.front()==two[k]-1){\n            break;\n        }\n    }\n}\n\nvoid rightsolve(){\n    long long int count=0;\n    queue<long long int>que,memoque;\n    que.push(0);\n    \n    while(1){\n        while(!que.empty()){\n            for(int i=0;i<k;i++){\n                if((que.front()/two[i])%2==0){\n                    rightdp[que.front()+two[i]]=min(rightdp[que.front()+two[i]],rightnext[i][rightdp[que.front()]]);\n                   //次のループで被りが出ないように\n                    if(rightmemo[que.front()+two[i]]==0){\n                        memoque.push(que.front()+two[i]);\n                        rightmemo[que.front()+two[i]]=1;\n                    }\n                    //cout<<que.front()<<\" \"<<two[i]<<\" \"<<endl;\n                    //cout<<que.front()+two[i]<<\" \"<<rightdp[que.front()+two[i]]<<endl;\n                }\n            }\n            que.pop();\n        }\n        while(!memoque.empty()){\n            que.push(memoque.front());\n            memoque.pop();\n        }\n        if(que.front()==two[k]-1){\n            break;\n        }\n    }\n}\n\n\nint main() {\n    \n    map<long long int,long long int>mp;\n\tcout << fixed << setprecision(10);\n    cin>>n>>v;\n    \n    for(int i=1;i<=26;i++){\n        two[i]=2*two[i-1];\n    }\n\n\n        for(int j=0;j<=199995;j++){\n            rightdp[j]=n;\n        }\n    \n\n    tmp=v;\n    while(tmp!=0){\n        canmove[cou]=tmp;\n        cou++;\n        tmp/=2;\n    }\n    k=cou+1;\n\n    for(int i=1;i<=n;i++){\n        cin>>x[i];\n    }\n    x[0]=INF;\n    x[n+1]=INF;\n\n    for(int i=0;i<k;i++){\n        tmp=0;\n        for(int j=2;j<=n+1;j++){\n            if(x[j]-x[j-1]>canmove[i]){\n                for(int p=tmp;p<j;p++){\n                    leftnext[i][p]=j;\n                }\n                tmp=j;\n            }\n        }\n\n        tmp=n;\n        for(int j=n-1;j>=0;j--){\n            if(x[j+1]-x[j]>canmove[i]){\n                for(int p=tmp;p>j;p--){\n                    rightnext[i][p]=j;\n                }\n                tmp=j;\n            }\n        }\n    }\n\n    leftsolve();\n    rightsolve();\n\n    for(int i=1;i<=n;i++){\n        //cout<<rightnext[0][i]<<\" \"<<canmove[0]<<endl;\n    }\n\n    for(int i=1;i<=n;i=leftnext[0][i]){\n        bool key=true;\n        for(int j=0;j<two[k];j+=2){\n            //cout<<leftdp[j]<<\" \"<<rightnext[0][i]<<\" \"<<rightdp[(j^(two[k]-2))]<<leftnext[0][i]<<endl;\n            if(leftdp[j]>rightnext[0][i]&&rightdp[(j^(two[k]-2))]<leftnext[0][i]){\n                for(int p=rightnext[0][i]+1;p<=leftnext[0][i]-1;p++){\n                    cout<<\"Possible\"<<endl;\n                }\n                key=false;\n                break;\n            }\n        }\n        if(key){\n            for(int p=rightnext[0][i]+1;p<=leftnext[0][i]-1;p++){\n                        cout<<\"Impossible\"<<endl;\n            }\n        }\n    }\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 18;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n, a[N], dp[(1 << LOG) + 10], R[N][LOG], L[N][LOG], V[LOG], DP[(1 << LOG) + 10], ps[N];\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> V[LOG - 1];\n\tfor (int i = LOG - 2; i >= 0; i--) V[i] = V[i + 1] / 2;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\ta[0] = -INF * 2, a[n + 1] = INF * 2;\n\tfor (int i = 0; i < LOG; i++) R[n + 1][i] = n + 1;\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = 0; j < LOG; j++){\n\t\t\tif (abs(a[i] - a[i - 1]) <= V[j]) L[i][j] = L[i - 1][j];\n\t\t\telse L[i][j] = i;\n\t\t//\tif (j >= 15) cout << i << ' ' << j << ' ' << L[i][j] << '\\n';\n\t\t}\n\t}\n\tfor (int i = n; i >= 1; i--){\n\t\tfor (int j = 0; j < LOG; j++){\n\t\t\tif (abs(a[i] - a[i + 1]) <= V[j]) R[i][j] = R[i + 1][j];\n\t\t\telse R[i][j] = i;\n\t\t\t//if (j >= 15) cout << i << ' ' << j << ' ' << R[i][j] << '\\n';\n\t\t}\n\t}\n\tdp[0] = 0;\n\tfor (int mask = 1; mask < (1 << LOG); mask++){\n\t\tfor (int j = 0; j < LOG; j++){\n\t\t\tif (j != LOG - 1 && V[j + 1] == 0) continue;\n\t\t\tif (mask & (1 << j)) dp[mask] = max(dp[mask], R[dp[mask ^ (1 << j)] + 1][j]);\n\t\t}\n\t}\n\tDP[0] = n + 1;\n\tfor (int mask = 1; mask < (1 << LOG); mask++){\n\t\tDP[mask] = n + 1;\n\t\tfor (int j = 0; j < LOG; j++){\n\t\t\tif (j != LOG - 1 && V[j + 1] == 0) continue;\n\t\t\t//cout << j << '\\n';\n\t\t\tif (mask & (1 << j)) DP[mask] = min(DP[mask], L[DP[mask ^ (1<<j)] - 1][j]);\n\t\t}\n\t}\n\tfor (int mask = 0; mask < (1 << (LOG - 1)); mask++){\n\t\tint mask2 = ((1 << (LOG - 1)) - 1) ^ mask;\n\t\tif (dp[mask] >= DP[mask2] - 1){\n\t\t\t//cout << \"Fuck\\n\";\n\t\t\t\n\t\t\tps[1] ++;\n\t\t}else{\n\t\t\tif (R[dp[mask] + 1][LOG - 1] >= DP[mask2] - 1){\n\t\t\t\tps[L[dp[mask] + 1][LOG - 1]]++;\n\t\t\t\tps[R[dp[mask] + 1][LOG - 1] + 1]--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++){\n\t\tps[i] += ps[i - 1];\n\t\tcout << (ps[i] > 0?\"Possible\\n\":\"Impossible\\n\");\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FR first\n#define SE second\nusing namespace std;\n\ntypedef pair<int,int> pii;\nconst int INF=0x3f3f3f3f;\nconst int N=200010;\nint n,V,X[N],dep=0;\nint L[20][N],R[20][N];\nint exL[N<<4],exR[N<<4];\npii seg[N];\nbool ans[N];\n\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    for(int i=1;i<=n;i++) scanf(\"%d\",X+i);\n    X[0]=-INF-V-1;X[n+1]=INF+V+1;\n    for(int v=V;v>=0;v>>=1,dep++)\n    {\n        R[dep][n+1]=n+1;\n        for(int i=1;i<=n;i++) L[dep][i]=(X[i]-X[i-1]<=v)?L[dep][i-1]:i;\n        for(int i=n;i>=1;i--) R[dep][i]=(X[i+1]-X[i]<=v)?R[dep][i+1]:i;\n        if(v==0){dep++;break;}\n    }\n    for(int i=1;i<=n;i++) seg[i]=pii(L[0][i],R[0][i]);\n    int cnt=unique(seg+1,seg+1+n)-(seg+1);\n    for(int i=0;i<(1<<dep);i++) exR[i]=n+1;\n    for(int s=0;s<(1<<dep);s+=2)\n        for(int i=0;i<dep;i++)\n        {\n            if(!(s&(1<<i))) continue;\n            exL[s]=max(exL[s],R[i][exL[s^(1<<i)]+1]);\n            exR[s]=min(exR[s],L[i][exR[s^(1<<i)]-1]);\n        }\n    if(cnt>dep) goto output;\n    for(int i=1;i<=cnt;i++)\n        for(int s=0;s<(1<<dep);s+=2)\n            if(exL[s]>=seg[i].FR-1&&exR[(1<<dep)-1-s-1]<=seg[i].SE+1)\n            {\n                for(int j=seg[i].FR;j<=seg[i].SE;j++) ans[j]=1;\n                break;\n            }\n    output: for(int i=1;i<=n;i++) puts(ans[i]?\"Possible\":\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n \n//INSERT ABOVE HERE\nsigned main(){\n  Int n,v;\n  cin>>n>>v;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n \n  vector<vector<Int> > dpl,dpr;\n  while(1){\n    {\n      vector<Int> dp(n);\n      dp.back()=n;\n      for(Int i=n-2;i>=0;i--){\n\tif(x[i+1]-x[i]<=v) dp[i]=dp[i+1];\n\telse dp[i]=i+1;\n      }\n      dpl.emplace_back(dp);\n    }\n    {\n      vector<Int> dp(n);\n      dp.front()=-1;\n      for(Int i=1;i<n;i++){\n\tif(x[i]-x[i-1]<=v) dp[i]=dp[i-1];\n\telse dp[i]=i-1;\n      }\n      dpr.emplace_back(dp);\n    }\n    if(!v) break;\n    v>>=1;\n  }\n \n  Int k=dpl.size();\n  vector<Int> dp(1<<k,0);\n  vector<Int> pd(1<<k,n-1);\n  \n  for(Int b=0;b<(1<<k);b++){\n    for(Int i=0;i<k;i++){\n      if((b>>i)&1) continue;\n      chmax(dp[b|(1<<i)],(dp[b]<n?dpl[i][dp[b]]:n));\n      chmin(pd[b|(1<<i)],(~pd[b]?dpr[i][pd[b]]:-1));\n    }\n  }\n \n  vector<Int> ans(n+1);\n  \n  \n  for(Int b=0;b<(1<<k);b+=2){\n    Int a=((1<<k)-2)^b;\n    Int c=dp[a]<n?dpl[0][dp[a]]:n;\n    if(pd[b]>=c) continue;\n    ans[dp[a]]++;\n    ans[c]--;\n    continue;\n    cout<<a<<\" \"<<b<<endl;\n    cout<<dp[a]<<\" \"<<pd[b]<<\" \"<<c<<endl;\n    cout<<endl;\n  }\n  \n  \n  for(Int i=0;i<n;i++){\n    cout<<(ans[i]?\"Possible\":\"Impossible\")<<endl;\n    ans[i+1]+=ans[i];\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint n,v,x[N];\nint dp1[(1<<20)+3],dp2[(1<<20)+3];\nint tor[20][N],tol[20][N],len[20],dep;\nvoid maxn(int &x,int y){y>x? x=y:0;}\nint mxr[N];//左侧覆盖i，右侧最多覆盖多少个城市\nint main(){\n    scanf(\"%d%d\",&n,&v);x[0]=-2e9,x[n+1]=2e9;\n    for(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n    for(len[0]=v;len[dep]!=0;dep++) len[dep+1]=len[dep]/2;\n    dep++;\n    for(int d=0;d<dep;d++){\n        tol[d][0]=n,tor[d][n+1]=n;\n        for(int i=1;i<=n;i++) tol[d][i]=(x[i]-x[i-1]<=len[d])? tol[d][i-1]:n+1-i;\n        for(int i=n;i>=1;i--) tor[d][i]=(x[i+1]-x[i]<=len[d])? tor[d][i+1]:i;\n    }\n    \n    for(int i=0;i<(1<<dep);i+=2)\n        for(int j=1;j<dep;j++)\n            if((i&(1<<j))==0)\n                maxn( dp1[i|(1<<j)], tor[j][dp1[i]+1] ),\n                maxn( dp2[i|(1<<j)], tol[j][n-dp2[i]] );\n    \n    memset(mxr,0xc0,sizeof(mxr));\n    for(int i=0,j=((1<<dep)-1)^1;j>=0;i+=2,j-=2)\n        maxn( mxr[dp1[i]], dp2[j] );\n    for(int i=n;i>=1;i--) maxn( mxr[i], mxr[i+1] );\n    for(int i=1;i<=n;i++)\n        if(mxr[n-tol[0][i]] + tor[0][i] >= n) puts(\"Possible\");\n        else puts(\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int INF=0x3f3f3f3f;\nconst int MAXN=1000005;\n\nint n,m,x[MAXN],cnt[20];\nint l[20][MAXN],r[20][MAXN],f1[MAXN*2],f2[MAXN*2];\nbool ans[MAXN];\n\nint uf(int id,int pos){\n\tpos++;\n\tint p=upper_bound(l[id]+1,l[id]+cnt[id]+1,pos)-l[id]-1;\n\tif(p<=0) return pos;\n\treturn max(r[id][p],pos-1);\n}\n\nint lf(int id,int pos){\n\tpos--;\n\tint p=lower_bound(r[id]+1,r[id]+cnt[id]+1,pos)-r[id];\n\tif(p>=cnt[id]+1) return pos;\n\treturn min(l[id][p],pos+1);\n}\n\nint main(){\n\n\tmemset(f2,0x3f,sizeof f2);\n\tscanf(\"%d%d\",&n,&m);\n\tint tot=0;\n\tfor(tot=0;(1<<tot)<=m;tot++);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tx[0]=-INF; x[n+1]=INF;\n\tfor(int log=0;log<=tot;log++){\n\t\tint d=m>>log;\n\t\tcnt[log]=1;\n\t\tl[log][1]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tr[log][cnt[log]]=i;\n\t\t\tif(x[i+1]-x[i]>d){\n\t\t\t\tcnt[log]++;\n\t\t\t\tl[log][cnt[log]]=i+1;\n\t\t\t}\n\t\t}\n\t\tcnt[log]--;\n\t}\n\tif(cnt[0]>tot+1){\n\t\tfor(int i=1;i<=n;i++) printf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint sum=(1<<(tot+1));\n\tf1[0]=0,f2[0]=n+1;\n\tfor(int s=0;s<sum;s+=2)\n\t\tfor(int i=0;i<=tot;i++){\n\t\t\tif(!(s&(1<<i))) continue;\n\t\t\tf1[s]=max(f1[s],uf(i,f1[s-(1<<i)]));\n\t\t\tf2[s]=min(f2[s],lf(i,f2[s-(1<<i)]));\n\t\t}\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tint ln=l[0][i],rn=r[0][i];\n\t\tfor(int s1=0;s1<sum;s1+=2){\n\t\t\tint s2=sum-1-s1-1;\n\t\t\tint lpos=f1[s1];\n\t\t\tint rpos=f2[s2];\n\t\t\tif(lpos>=ln-1&&rpos<=rn+1){\n\t\t\t\tans[i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint pos=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(ans[pos]) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t\tif(x[i+1]-x[i]>m) pos++;\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define N 200010\nint n,v,lg,d[N],a[30][N],f1[1<<20],f2[1<<20];\nint g1(int *a,int x){\n\tint l=1,r=a[0];\n\twhile(l+1<r){\n\t\tint md=(l+r)/2;\n\t\tif(a[md]<=x)l=md+1;\n\t\telse r=md;\n\t}\n\tif(a[l]>x)return a[l];\n\treturn a[r];\n}\nint g2(int *a,int x){\n\tint l=1,r=a[0];\n\twhile(l+1<r){\n\t\tint md=(l+r)/2;\n\t\tif(a[md]<x)l=md;\n\t\telse r=md-1;\n\t}\n\tif(a[r]<x)return a[r]+1;\n\treturn a[l]+1;\n}\nsigned main(){\n\tcin>>n>>v;\n\twhile((1<<lg)<=v)lg++;\n\tlg++;\n\tfor(int i=1;i<=n;i++)cin>>d[i];\n\td[n]=0;\n\tfor(int i=1;i<=n;i++)\n\t\td[i-1]=d[i]-d[i-1];\n\tfor(int i=1;i<=lg;i++){\n\t\ta[i][0]=1;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\ta[i][a[i][0]]=j;\n\t\t\tif(d[j]>(v>>(i-1)))a[i][0]++;\n\t\t}\n\t}\n\tif(a[1][0]>lg){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<(1<<lg);i++)\n\t\tf2[i]=n+1;\n\tfor(int i=0;i<(1<<lg);i+=2)\n\t\tfor(int j=2;j<=lg;j++)\n\t\t\tif(!(i&(1<<(j-1)))){\n\t\t\t\tf1[i+(1<<(j-1))]=max(f1[i+(1<<(j-1))],g1(a[j],f1[i]));\n\t\t\t\tf2[i+(1<<(j-1))]=min(f2[i+(1<<(j-1))],g2(a[j],f2[i]-1));\n\t\t\t}\n\tfor(int i=1;i<=a[1][0];i++){\n\t\tint ok=0;\n\t\tint l=a[1][i-1]+1,r=a[1][i];\n\t\tif(i==1)l=1;\n\t\tfor(int s=0;s<(1<<lg);s+=2)\n\t\t\tif(l<=f1[s]+1&&f2[(1<<lg)-s-2]<=r+1)ok=1;\n\t\tif(ok)for(int j=l;j<=r;j++)puts(\"Possible\");\n\t\telse for(int j=l;j<=r;j++)puts(\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(),v.end()\n\nconst int maxn = 2e5 + 100, maxlg = 20;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, v, vols[maxlg], volCount, nxt[maxlg][maxn], dp[(1 << maxlg)];\nll x[maxn], a[maxn];\nbool ans[maxn];\nset<int> counter;\n\nvoid printAnsAndExit() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << (ans[i] ? \"Possible\" : \"Impossible\") << endl;\n\t}\n\texit(0);\n}\n\nvoid solve(int l, int r) {\n\tif (l == 0 && r == n - 1) {\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tans[i] = true;\n\t\t}\n\t\treturn;\n\t}\n\n\tmemset(dp, 0, sizeof(dp));\n\tfor (int mask = 0; mask < (1 << (volCount - 1)); mask++) {\n\t\tfor (int bit = 0; bit < volCount - 1; bit++) {\n\t\t\tif (!((mask >> bit) & 1)) {\n\t\t\t\tint val = nxt[bit][dp[mask]] + 1;\n\t\t\t\tif (l <= val && val <= r) {\n\t\t\t\t\tval = r + 1;\n\t\t\t\t}\n\t\t\t\tdp[mask | (1 << bit)] = max(dp[mask | (1 << bit)], val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mx = *max_element(dp, dp + (1 << maxlg));\n\tif (mx == n) {\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tans[i] = true;\n\t\t}\n\t}\n}\n\nvoid solveAll() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcounter.insert(nxt[volCount - 1][i]);\n\t}\n\tif (counter.size() > volCount) {\n\t\tprintAnsAndExit();\n\t}\n\t\n\tint l = 0, r = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (nxt[volCount - 1][r] == nxt[volCount - 1][i]) {\n\t\t\tr++;\n\t\t}\n\t\telse {\n\t\t\tsolve(l, r);\n\t\t\tr++;\n\t\t\tl = r;\n\t\t}\n\t}\n\tsolve(l, r);\n}\n\n\nvoid calcVols(int v) {\n\tint count = 0, tmp = v;\n\twhile (tmp) {\n\t\ttmp /= 2;\n\t\tcount++;\n\t}\n\tvolCount = ++count;\n\twhile (count) {\n\t\tvols[--count] = v;\n\t\tv /= 2;\n\t}\n}\n\nvoid calcNxt() {\n\tfor (int vol = 0; vol < volCount; vol++) {\n\t\tint l = 0, r = 0;\n\t\twhile (r < n - 1) {\n\t\t\tif (x[r + 1] - x[r] <= vols[vol]) {\n\t\t\t\tr++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (l <= r) {\n\t\t\t\t\tnxt[vol][l] = r;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\twhile (l <= r) {\n\t\t\tnxt[vol][l] = r;\n\t\t\tl++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t\ta[i] = x[i];\n\t}\n\n\tcalcVols(v);\n\tcalcNxt();\n\tsolveAll();\n\tprintAnsAndExit();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, V;\n\nconst int maxn = 200010;\n\nint x[maxn];\n\nint cnt = 0;\nint dep;\n\nvector<int> g[maxn * 20];\n\nvector<int> divide(int l,int r,int v) {\n\tvector<int> ret;\n\tif(r - l == 1 || v == 0) return ret;\n\tfor(int i = l, j; i < r; i = j) {\n\t\tret.push_back(++cnt); \n\t\tfor(j = i + 1; j < r && x[j] - x[j-1] <= v; ++j);\n\t\tg[*ret.rbegin()] = divide(i, j, v / 2);\n\t}\n\treturn ret;\n}\n\nbool ans[maxn];\n\nvector<int> _vec[22];\nbool solve(int dep) {\n\tvector<int> &nxt = _vec[dep];\n\tvector<int> &vec = _vec[dep + 1];\n\tnxt.clear();\n\tfor(auto x: vec) \n\t\tif(g[x].empty()) nxt.push_back(x);\n\t\telse nxt.insert(nxt.end(), g[x].begin(), g[x].end());\n\tif(nxt.size() > dep) return false;\n\tif(nxt.size() == 1) return true;\n\tint last = *(nxt.end() - 1), sz = nxt.size();\n\tnxt.erase(nxt.end() - 1);\n\tfor(int i = sz - 1; i >= 0; --i) {\n\t\tif(solve(dep - 1)) return true;\n\t\tif(i) swap(nxt[i-1], last);\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &V);\n\tfor(int i = 0; i < N; ++i) scanf(\"%d\", &x[i]);\n\tg[0] = divide(0, N, V);\n\tfor(int x = V; x; x = x >> 1) ++dep;\n\tif(g[0].size() > dep + 1) {\n\t\tfor(int i = 0; i < N; ++i) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tif(g[0].size() == 1) {\n\t\tfor(int i = 0; i < N; ++i) puts(\"Possible\");\n\t\treturn 0;\n\t}\n\tfor(int i = 0; i < g[0].size(); ++i) {\n\t\tvector<int> &cur = _vec[dep + 1];\n\t\tcur = g[0];\n\t\tcur.erase(cur.begin() + i);\n\t\tans[i] = true;\n\t\tans[i] = solve(dep);\n\t}\n\tint curb = 0;\n\tfor(int i = 0; i < N; ++i) {\n\t\tif(i && x[i] - x[i-1] > V) ++curb;\n\t\tputs(ans[curb] ? \"Possible\" : \"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nint goR[200005][20];\nint goL[200005][20];\nint a[200005];\nint n,v;\nint R(int x,int k,int v){\n    if(x>=n)return n;\n    if(goR[x][k]!=-1)return goR[x][k];\n    if(a[x+1]-a[x]>(v>>k))return goR[x][k]=x;\n    return goR[x][k]=R(x+1,k,v);\n}\nint L(int x,int k,int v){\n    if(x<=1)return 1;\n    if(goL[x][k]!=-1)return goL[x][k];\n    if(a[x]-a[x-1]>(v>>k))return goL[x][k]=x;\n    return goL[x][k]=L(x-1,k,v);\n}\nint dpR[1<<20];\nint dpL[1<<20];\n \nint DPR(int x){\n    if(x==0)return 0;\n    if(dpR[x]!=-1)return dpR[x];\n    dpR[x]=0;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpR[x]=max(dpR[x],R(DPR(x-(1<<i))+1,i,v));\n        }\n    }\n    return dpR[x];\n}\nint DPL(int x){\n    if(x==0)return n+1;\n    if(dpL[x]!=-1)return dpL[x];\n    dpL[x]=1e9+1;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpL[x]=min(dpL[x],L(DPL(x-(1<<i))-1,i,v));\n        }\n    }\n    return dpL[x];\n}\nint main(){ \n    MEMS(goR);MEMS(goL);MEMS(dpR);MEMS(dpL);\n    scanf(\"%d %d\",&n,&v);\n    for(int i = 1;i<=n;i++)\n        //a[i]=-1e9+2e5*i;\n        scanf(\"%d\",&a[i]);\n    a[0]=-1e9-1e8;\n    a[n+1]=1e9+1e8;\n    int Max=1;\n    for(int i = 1;;i++){\n        Max=i+1;\n        if(!(v>>i))break;\n    }\n \n    if(DPR((1<<Max)-1)<n){\n        for(int i = 1;i<=n;i++){\n            printf(\"Impossible\\n\");\n        }\n        return 0;\n    }\n    for(int i = 1;i<=n;){\n        int l=i,r=R(i,0,v);\n       // printf(\"%d %d\\n\",l,r);\n        int ok=0;\n        for(int j=0;j<(1<<Max);j++){\n            int a=j,b=(1<<Max)-j;\n            if(a&1)a--;\n            if(b&1)b--;\n            if(DPR(a)>=l-1&&DPL(b)<=r+1){\n                ok=1;\n                break;\n            }\n        }\n        if(ok){\n            for(int i=l;i<=r;i++)printf(\"Possible\\n\");\n        }\n        else{\n            for(int i = l;i<=r;i++)printf(\"Impossible\\n\");\n        }\n        i=r+1;\n    }\n}\n/*\n2 2 1\n3 2 3\n4 2 4 4 7\n \n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MN=300000+5;\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T>inline T&IN(T&in){\n\tin=0;char c=getchar();int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1;c=getchar();}\n\twhile(isdigit(c))in=in*10+c-'0',c=getchar();\n\treturn in*=f;\n}\nint n,V;\nint l[20][MN],r[20][MN];\nint fr[MN],fl[MN],s[MN];ll x[MN];\nvoid input(){\n\tIN(n),IN(V);\n\tfor(int i=1;i<=n;++i)IN(x[i]);\n\tint k;x[0]=LLONG_MIN/10,x[n+1]=LLONG_MAX/10;\n\tfor(k=0;V;++k,V>>=1){\n\t\tfor(int i=1;i<=n;++i)l[k][i]=x[i]-x[i-1]>V?i:l[k][i-1];\n\t\tfor(int i=n;i>=1;--i)r[k][i]=x[i+1]-x[i]>V?i:r[k][i+1];\n\t}\n\tfor(int i=1;i<=n;++i)l[k][i]=x[i]-x[i-1]>V?i:l[k][i-1];\n\tfor(int i=n;i>=1;--i)r[k][i]=x[i+1]-x[i]>V?i:r[k][i+1];\n\tfor(int st=0;st<(1<<k);++st){\n\t\tfr[st]=n+1;\n\t\tfor(int i=0;i<k;++i)if(st>>i&1){\n\t\t\tfl[st]=max(fl[st],r[i+1][fl[st^(1<<i)]+1]);\n\t\t\tfr[st]=min(fr[st],l[i+1][fr[st^(1<<i)]-1]);\n\t\t}\n\t}\n\tfor(int st=0;st<(1<<k);++st){\n\t\tint L=l[0][fr[((1<<k)-1)^st]-1],R=r[0][fl[st]+1];\n\t\tif(L<=R)s[L]++,s[R+1]--;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\ts[i]+=s[i-1];\n\t\tputs(s[i]?\"Possible\":\"Impossible\");\n\t}\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst int N=800005;\n\nint n,v,tot,cnt;\nint x[N],R[22][N],L[22][N],b[22],id[N],p1[N],p2[N],f[N],g[N],ans[N];\n\nvoid init(){\n\tint i,j,k,l;\n\tmemset(L,0x3f,sizeof(L));\n\tfor (i=0;i<tot;i++){\n\t\tfor (j=1;j<=n;j=k+1){\n\t\t\tk=j;\n\t\t\twhile (k<n&&x[k+1]-x[k]<=b[i]) k++;\n\t\t\tfor (l=j;l<=k;l++){\n\t\t\t\tL[i][l]=j; R[i][l]=k;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i=1;i<=n;i=k+1){\n\t\tk=i; cnt++;\n\t\twhile (k<n&&x[k+1]-x[k]<=b[tot]) k++;\n\t\tfor (l=i;l<=k;l++){\n\t\t\tid[l]=cnt;\n\t\t\tp1[cnt]=i; p2[cnt]=k;\n\t\t} \n\t}\n}\n\nvoid work(){\n\tint i,j,sz,s,ss,l,r;\n\tsz=(1<<tot)-1;\n\tfor (i=0;i<=sz;i++) f[i]=n+1;\n\tfor (s=0;s<=sz;s++){\n\t\tfor (j=0;j<tot;j++)\n\t\t\tif (!((s>>j)&1)){\n\t\t\t\tss=s|(1<<j);\n\t\t\t\tf[ss]=min(f[ss],L[j][f[s]-1]);\n\t\t\t\tg[ss]=max(g[ss],R[j][g[s]+1]);\n\t\t\t}\n\t}\n\tfor (s=0;s<=sz;s++){\n\t\tl=g[s]; r=f[sz^s];\n\t\tif (l+1>=r){\n\t\t\tfor (i=1;i<=n;i++) ans[i]=1;\n\t\t\treturn;\n\t\t}\n\t\tif (p1[id[l+1]]<=l+1&&p2[id[l+1]]>=r-1) ans[id[l+1]]=1;\n\t}\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d%d\",&n,&v);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tb[0]=0;\n\twhile (v){\n\t\tb[++tot]=v;\n\t\tv/=2;\n\t}\n\tsort(b,b+tot+1);\n\tinit();\n\twork();\n\tfor (i=1;i<=n;i++)\n\t\tif (ans[id[i]]) printf(\"Possible\\n\");\n\telse printf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100,M=20;\nll nxt[N][M],pre[N][M];\nll dp[(1<<M)],pd[(1<<M)];\nll a[N];\nint32_t main(){\n    sync;\n    ll n,v;\n    cin >> n >> v ;\n    for (int i=1;i<=n;i++){\n        cin >> a[i];\n    }\n    ll z=v*2;\n    ll p1=0;\n    ll t=0;\n    while(z/2>=0){\n        z/=2;\n        nxt[n][p1]=n;\n        for (int i=n-1;i;i--){\n            if (a[i+1]-a[i]<=z) nxt[i][p1]=nxt[i+1][p1];\n            else nxt[i][p1]=i;\n        }\n        pre[1][p1]=1;\n        for (int i=2;i<=n;i++){\n            if (a[i]-a[i-1]<=z) pre[i][p1]=pre[i-1][p1];\n            else pre[i][p1]=i;\n        }\n        p1++;\n        if (z==0) break;\n    }\n    for (int i=1;i<=n;i++){\n        if (nxt[i][0]==i) t++;\n    }\n    if (t>M){\n        for (int i=1;i<=n;i++){\n            cout << \"Impossible\" << endl;\n        }\n        return 0;\n    }\n    pd[0]=n+1;\n    for (int mask=1;mask<(1<<p1);mask++){\n        for (int i=0;i<p1;i++){\n            if (((1<<i)&mask)){\n                ll z=dp[(mask ^ (1<<i))];\n                dp[mask]=max(dp[mask],z);\n                if (z!=n){\n                    z++;\n                    z=nxt[z][i];\n                    dp[mask]=max(dp[mask],z);\n                }\n            }\n        }\n        pd[mask]=n+1;\n    }\n\n    for (int mask=1;mask<(1<<p1);mask++){\n        for (int i=0;i<p1;i++){\n            if (((1<<i)&mask)){\n                ll z=pd[(mask ^ (1<<i))];\n                pd[mask]=min(pd[mask],z);\n                if (z!=1){\n                    z--;\n                    z=pre[z][i];\n                    pd[mask]=min(pd[mask],z);\n                }\n            }\n        }\n    }\n    for (int i=1;i<=n;i++){\n        ll r=nxt[i][0];\n      //  cout << i << \" \" << r << \" \" << p1 << \" \" << pd[6] << endl;\n        ll p2=0;\n        for (int mask=0;mask<(1<<p1);mask++){\n        //    cout << \" \" << mask << endl;\n            ll sam=(1<<p1)-1-mask;\n            if (sam%2==1) sam--;\n            ll z=mask;\n            if (mask%2==1) z--;\n          //  if (mask==4) cout << sam << endl;\n            if (dp[z]>=i-1 && pd[sam]<=r+1) p2=1;\n        }\n        if (p2){\n            for (int j=i;j<=r;j++) cout << \"Possible\" << endl;\n        }\n        else for (int j=i;j<=r;j++) cout << \"Impossible\" << endl;\n        i=r;\n    }\n\n}\n//0110010111000\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 100000\n#define INF 2000000000\nusing namespace std;\nint n,V,x[MAXN+5];\nint cnt[25];\nint l[25][MAXN+5],r[25][MAXN+5];\nint f1[MAXN*5+5],f2[MAXN*5+5];\nbool ans[MAXN+5];\nvoid Init()\n{\n\tfor(int i=0;i<=MAXN*2+3;i++)\n\t\tf1[i]=0,f2[i]=INF;\n}\nint UpFind(int id,int pos)\n{\n//\tif(cnt[id]==0)\n//\t\treturn pos;\n\tpos++;\n\tint p=upper_bound(l[id]+1,l[id]+cnt[id]+1,pos)-l[id];\n\tp--;\n\tif(p<=0)\n\t\treturn pos;\n\treturn max(r[id][p],pos-1);\n}\nint LowFind(int id,int pos)\n{\n//\tif(cnt[id]==0)\n//\t\treturn pos;\n\tpos--;\n\tint p=lower_bound(r[id]+1,r[id]+cnt[id]+1,pos)-r[id];\n\tif(p>=cnt[id]+1)\n\t\treturn pos;\n\treturn min(l[id][p],pos+1);\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d %d\",&n,&V);\n\tint logV=0;\n\tfor(logV=0;(1<<logV)<=n;logV++);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tx[n+1]=INF;\n\tx[0]=-INF;\n\tfor(int LG=0;LG<=logV;LG++)\n\t{\n\t\tint d=V/(1<<LG);\n\t\tcnt[LG]=1;\n\t\tl[LG][1]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tr[LG][cnt[LG]]=i;\n\t\t\tif(x[i+1]-x[i]>d)\n\t\t\t{\n\t\t\t\tcnt[LG]++;\n\t\t\t\tl[LG][cnt[LG]]=i+1;\n\t\t\t}\n\t\t}\n\t\tcnt[LG]--;\n\t}\n\tif(cnt[0]>logV)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint all=(1<<(logV+1));\n\tf1[0]=0,f2[0]=n+1;\n\tfor(int s=0;s<all;s+=2)\n\t\tfor(int i=0;i<=logV;i++)\n\t\t{\n\t\t\tif(!(s&(1<<i)))\n\t\t\t\tcontinue;\n\t\t\tf1[s]=max(f1[s],UpFind(i,f1[s-(1<<i)]));\n\t\t\tf2[s]=min(f2[s],LowFind(i,f2[s-(1<<i)]));\n\t\t}\n\tfor(int i=1;i<=cnt[0];i++)\n\t{\n\t\tint ln=l[0][i],rn=r[0][i];\n\t\tfor(int s1=0;s1<all;s1+=2)\n\t\t{\n\t\t\tint s2=all-1-s1-1;\n\t\t\tint lpos=f1[s1];\n\t\t\tint rpos=f2[s2];\n\t\t\tif(lpos>=ln-1&&rpos<=rn+1)\n\t\t\t{\n\t\t\t\tans[i]=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint pos=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(ans[pos]==true)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t\tif(x[i+1]-x[i]>V)\n\t\t\tpos++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\ninline int rnd(int x){\n\treturn rand()%x;\n}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=18,N=200005,inf=1e9+3e5;\nint n,v,gao,f[1<<M],g[1<<M],x[N],lst[M][N],nxt[M][N],tong[N];\nint main(){\n\tn=read(); v=read(); x[0]=-inf; x[n+1]=inf;\n\tfor(int i=1;i<=n;i++)x[i]=read();\n\tfor(int i=0;;i++){\n\t\tint dali=v>>i; gao=i; nxt[i][n+1]=n; lst[i][0]=1;\n\t\tfor(int j=1;j<=n;j++)if(x[j]-x[j-1]<=dali)lst[i][j]=lst[i][j-1]; else lst[i][j]=j;\n\t\tfor(int j=n;j;j--)if(x[j+1]-x[j]<=dali)nxt[i][j]=nxt[i][j+1]; else nxt[i][j]=j;\n\t\tif((v>>i)==0)break;\n\t}\n\tf[0]=0; g[0]=n+1; \n\tfor(int i=1;i<(1<<gao);i++){\n\t\tf[i]=0; g[i]=n+1;\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)f[i]=max(f[i],nxt[j+1][f[i^(1<<j)]+1]);\n\t\tfor(int j=0;j<gao;j++)if(i>>j&1)g[i]=min(g[i],lst[j+1][g[i^(1<<j)]-1]);\n\t}\n\tfor(int i=0;i<=n+1;i++)tong[i]=-1;\n\tfor(int i=0;i<(1<<gao);i++){\n\t\tint l=f[i],r=g[((1<<gao)-1)^i];\n\t\ttong[r]=max(tong[r],l);\n\t}\n\tfor(int i=1;i<=n;i++)tong[i]=max(tong[i],tong[i-1]);\n\tfor(int i=1;i<=n;i++){\n\t\tint l=lst[0][i],r=nxt[0][i];\n\t\tputs(tong[r+1]>=l-1?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); ++i)\n#define per(i,a,b) for (int i=(a); i>=(b); --i)\nusing namespace std;\n\nconst int maxn = 400005;\nint f[maxn][20], g[maxn][20], pre[1<<19], suf[1<<19];\nint x[maxn], ans[maxn], d[20], n, m, v;\n\nint main() {\n\tscanf(\"%d%d\", &n, &v); d[0] = v;\n\twhile (v) d[++m] = v/2, v /= 2;\n\trep (i, 1, n) scanf(\"%d\", &x[i]);\n\trep (i, 1, n) rep (j, 0, m)\n\t\tif (i >= 2 && x[i] - x[i-1] <= d[j]) f[i][j] = f[i-1][j];\n\t\telse f[i][j] = i;\n\tper (i, n, 1) rep (j, 0, m)\n\t\tif (i <= n-1 && x[i+1] - x[i] <= d[j]) g[i][j] = g[i+1][j];\n\t\telse g[i][j] = i;\n\tmemset(pre, 0xc0, sizeof pre);\n\tmemset(suf, 0x3f, sizeof suf);\n\tpre[0] = 0; suf[0] = n+1;\n\tint ALL = (1<<m)-1;\n\trep (i, 0, ALL) rep (j, 0, m-1) if (!(i>>j&1)) {\n\t\tif (pre[i] == n) pre[i|1<<j] = n;\n\t\telse pre[i|1<<j] = max(pre[i|1<<j], g[pre[i]+1][j+1]);\n\t\tif (suf[i] == 1) suf[i|1<<j] = 1;\n\t\telse suf[i|1<<j] = min(suf[i|1<<j], f[suf[i]-1][j+1]);\n\t}\n\tint l = 1, r, tot = 0, flag;\n\twhile (l <= n) {\n\t\tr = l; if (tot++ > m) break;\n\t\twhile (r + 1 <= n && x[r+1] - x[r] <= d[0]) r++;\n\t\tflag = 0;\n\t\trep (i, 0, ALL)\n\t\t\tif (pre[i] >= l-1 && suf[(~i)&ALL] <= r+1) {\n\t\t\t\tflag = 1; break;\n\t\t\t}\n\t\trep (i, l, r) ans[i] = flag;\n\t\tl = r + 1;\n\t}\n\trep (i, 1, n) puts(ans[i] ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <algorithm>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n\nusing namespace std;\n\nconst int N = 200010;\n\nint n, p, V, X[N];\nint tor[N][20], tol[N][20];\nint dpl[N], dpr[N], cnt[N];\n\nint main(){\n\tscanf(\"%d%d\", &n, &V);\n\tFor(i, 1, n) scanf(\"%d\", &X[i]);\n\tX[0] = -2e9, X[n + 1] = 2e9;\n\tFor(i, 0, 19){\n\t\tint l = 1;\n\t\tFor(j, 1, n) \n\t\t\tif(X[j + 1] - X[j] > V){\n\t\t\t\tFor(k, l, j) tol[k][i] = l, tor[k][i] = j;\n\t\t\t\tl = j + 1;\n\t\t\t}\n\t\tif(!V){\n\t\t\tp = i;\n\t\t\tbreak;\n\t\t}\n\t\tV >>= 1;\n\t}\n\tint S = (1 << p) - 1;\n\tdpl[0] = 0;\n\tFor(i, 1, S){\n\t\tdpl[i] = 0;\n\t\tFor(j, 1, p) if(i & (1 << (j - 1))) dpl[i] = max(dpl[i], tor[dpl[i ^ (1 << (j - 1))] + 1][j]);\n\t}\n\tdpr[0] = n + 1;\n\tFor(i, 1, S){\n\t\tdpr[i] = n + 1;\n\t\tFor(j, 1, p) if(i & (1 << (j - 1))) dpr[i] = min(dpr[i], tol[dpr[i ^ (1 << (j - 1))] - 1][j]);\n\t}\n\tFor(i, 0, S){\n\t\tint L = dpl[i] + 1, R = dpr[S ^ i] - 1;\n\t\tif(tor[L][0] >= R) cnt[tol[L][0]]++, cnt[tor[R][0] + 1]--;\n\t}\n\tFor(i, 1, n){\n\t\tcnt[i] += cnt[i - 1];\n\t\tif(cnt[i]) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint x[202020];\nint l[202020][20], r[202020][20];\nint dpl[1 << 20], dpr[1 << 20];\n\nvoid solve() {\n        int n, v;\n        cin >> n >> v;\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        int p;\n        for (int i = 0; ; i ++) if ((1 << i) > v) {\n                p = i + 1;\n                break;\n        }\n        for (int i = 0; i < n; i ++) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == 0 || x[i] - x[i - 1] > vv) l[i][j] = i; //その点から移動可能な最も左の点の位置\n                        else l[i][j] = l[i - 1][j];\n                        vv /= 2;\n                }    \n        }\n        for (int i = n - 1; i >= 0; i --) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == n - 1 || x[i + 1] - x[i] > vv) r[i][j] = i; //その点から移動可能な最も右の点の位置\n                        else r[i][j] = r[i + 1][j];\n                        vv /= 2;\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpr[i] == n) dpr[i | (1 << j)] = n;\n                        else dpr[i | (1 << j)] = max(dpr[i | (1 << j)], r[dpr[i]][j] + 1); //集合iを使って左から網羅可能な点の数\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) dpl[i] = n - 1;\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpl[i] == -1) dpl[i | (1 << j)] = -1;\n                        else dpl[i | (1 << j)] = min(dpl[i | (1 << j)], l[dpl[i]][j] - 1); //集合iを使って右から網羅可能な点の数\n                }\n        }\n        bool ok = false;\n        for (int i = 0; i < n; i ++) {\n                if (l[i][0] == i) { //初期位置から移動可能な位置か？\n                        int c = 0;\n                        for (int j = 0; j < (1 << p); j ++) {\n                                c ++;\n                                if (j & 1) continue; \n                                if (i > 0 && dpr[j] < i) continue; //左を網羅できない\n                                if (r[i][0] < n - 1 && dpl[((1 << p) - 1 - j) - 1] > r[i][0]) continue; //右を網羅できない\n                                break;\n                        }\n                        if (c < (1 << p)) ok = true;\n                        else ok = false;\n                }\n                if (ok) cout << \"Possible\" << endl;\n                else cout << \"Impossible\" << endl;\n        }\n        return;\n}\n\nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        solve();\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 200010\n#define M 19\nll x[N];\nll t[2][N][M], dp[2][1<<M];\nll n, V, m;\nbool res[N];\n\nvoid calc(ll t[N][M]){\n\trep(i, M){\n\t\tll V2 = V>>i;\n\t\tll r = n;\n\t\tt[n][i] = n;\n\t\tfor(ll j = n-1; j >= 0; j--){\n\t\t\tt[j][i] = r;\n\t\t\tif(j>0&&x[j]-x[j-1]>V2) r = j;\n\t\t}\n\t\tif(V2==0) return;\n\t}\n}\n\nint main(){\n\tcin>>n>>V;\n\trep(i, n) cin>>x[i];\n\tcalc(t[0]);\n\treverse(x, x+n);\n\trep(i, n) x[i] *= -1;\n\tcalc(t[1]);\n\n\twhile(V>=(1<<m)) m++;\n\tm++;\n\trep(i, 2){\n\t\tll *dp2 = dp[i];\n\t\trep(j, 1<<m){\n\t\t\trep(k, m){\n\t\t\t\tif(1&(j>>k)) continue;\n\t\t\t\tchmax(dp2[j|(1<<k)], t[i][dp2[j]][k]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n){\n\t\tif(t[0][i][0]!=i+1) continue;\n\t\tint i2 = t[1][n-1-i][0];\n\t\t//cerr<<n-i2<<\" \"<<i<<endl;\n\t\trep(j, 1<<m){\n\t\t\tint j2 = (1<<m)-1-j;\n\t\t\tif(dp[0][j&~1]>=n-i2&&dp[1][j2&~1]>=n-i-1) res[i+1] = 1;\n\t\t\t//cerr<<j<<\": \"<<dp[0][j&~1]<<\" \"<<dp[1][j2&~1]<<endl;\n\t\t}\n\t}\n\trep(i, n){\n\t\tcout<<(res[t[0][i][0]]?\"Possible\":\"Impossible\")<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nint goR[100005][20];\nint goL[100005][20];\nint a[100005];\nint R(int x,int k,int v){\n    if(goR[x][k]!=-1)return goR[x][k];\n    if(a[x+1]-a[x]>(v>>k))return goR[x][k]=x;\n    return goR[x][k]=R(x+1,k,v);\n}\nint L(int x,int k,int v){\n    if(goL[x][k]!=-1)return goL[x][k];\n    if(a[x]-a[x-1]>(v>>k))return goL[x][k]=x;\n    return goL[x][k]=L(x-1,k,v);\n}\nint dpR[1<<20];\nint dpL[1<<20];\nint n,v;\nint DPR(int x){\n    if(x==0)return 0;\n    if(dpR[x]!=-1)return dpR[x];\n    dpR[x]=0;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpR[x]=max(dpR[x],R(DPR(x-(1<<i))+1,i,v));\n        }\n    }\n    return dpR[x];\n}\nint DPL(int x){\n    if(x==0)return n+1;\n    if(dpL[x]!=-1)return dpL[x];\n    dpL[x]=1e9+1;\n    for(int i = 0;i<20;i++){\n        if(x&(1<<i)){\n            dpL[x]=min(dpL[x],L(DPL(x-(1<<i))-1,i,v));\n        }\n    }\n    return dpL[x];\n}\nint main(){ \n    MEMS(goR);MEMS(goL);MEMS(dpR);MEMS(dpL);\n    scanf(\"%d %d\",&n,&v);\n    for(int i = 1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    a[0]=-1e9-1e8;\n    a[n+1]=1e9+1e8;\n    int Max=1;\n    for(int i = 1;;i++){\n        Max=i+1;\n        if(!(v>>i))break;\n    }\n    for(int i = 1;i<=n;){\n        int l=i,r=R(i,0,v);\n       // printf(\"%d %d\\n\",l,r);\n        int ok=0;\n        for(int j=0;j<(1<<Max);j++){\n            int a=j,b=(1<<Max)-j;\n            if(a&1)a--;\n            if(b&1)b--;\n            if(DPR(a)>=l-1&&DPL(b)<=r+1){\n                ok=1;\n                break;\n            }\n        }\n        if(ok){\n            for(int i=l;i<=r;i++)printf(\"Possible\\n\");\n        }\n        else{\n            for(int i = l;i<=r;i++)printf(\"Impossible\\n\");\n        }\n        i=r+1;\n    }\n}\n/*\n2 2 1\n3 2 3\n4 2 4 4 7\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nconst int NMAX = 300000;\nconst int LOGN = 20;\nint V[LOGN];\nint Lmost[NMAX][LOGN], Rmost[NMAX][LOGN];\n\nint dpL[1<<LOGN], dpR[1<<LOGN];\nint arr[NMAX+1];\nint dp[NMAX+2];\n\nint main(){\n    int N; scanf(\"%d%d\",&N,&V[0]);\n    for(int i=1;i<=N;i++) scanf(\"%d\",arr+i);\n\n    int M = 1;\n    while(V[M-1]){\n        V[M] = V[M-1]/2;\n        M++;\n    }\n\n    for(int i=0;i<M;i++){\n        int v = V[i];\n        int j = 1;\n        while(j<=N){\n            int k = j+1;\n            while(k<=N && arr[k]-arr[k-1] <= v) k++;\n            for(int x=j;x<k;x++) Rmost[x][i] = k-1;\n            j = k;\n        }\n        j = N;\n        while(j>=1){\n            int k = j-1;\n            while(k>=1 && arr[k+1]-arr[k] <= v) k--;\n            for(int x=j;x>k;x--) Lmost[x][i] = k+1;\n            j = k;\n        }\n    }\n\n    for(int i=0;i<(1<<M);i++) dpR[i] = N+1;\n    for(int i=1;i<(1<<M);i++){\n        for(int j=0;j<M;j++) if(i&(1<<j)){\n            // use V[j]\n            int L = dpL[i^(1<<j)];\n            dpL[i] = max(dpL[i], Rmost[L+1][j]);\n\n            int R = dpR[i^(1<<j)];\n            dpR[i] = min(dpR[i], Lmost[R-1][j]);\n        }\n    }\n\n    for(int i=0;i<=N+1;i++) dp[i] = -1;\n\n    for(int i=2;i<(1<<M);i+=2){\n        int j = ((1<<M)-1)^i^1;\n        dp[dpR[j]] = max(dp[dpR[j]], dpL[i]);\n    }\n\n    for(int i=1;i<=N+1;i++)\n        dp[i] = max(dp[i], dp[i-1]);\n\n    for(int i=1;i<=N;i++){\n        int L = Lmost[i][0], R = Rmost[i][0];\n        int det = dp[R+1];\n        if(det>=L-1) printf(\"Possible\\n\");\n        else printf(\"Impossible\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <fstream>\n\ntypedef long long LL;\ntypedef unsigned long long uLL;\n\n#define SZ(x) ((int)x.size())\n#define ALL(x) (x).begin(), (x).end()\n#define MP(x, y) std::make_pair(x, y)\n#define DE(x) cerr << x << endl;\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define GO cerr << \"GO\" << endl;\n#define rep(i, a, b) for (register int (i) = (a); (i) <= (b); ++(i))\n\nusing namespace std;\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\ninline int read() \n{\n\tregister int x = 0; register int f = 1; register char c;\n\twhile (!isdigit(c = getchar())) if (c == '-') f = -1;\n\twhile (x = (x << 1) + (x << 3) + (c xor 48), isdigit(c = getchar()));\n\treturn x * f;\n}\ntemplate<class T> inline void write(T x) \n{\n\tstatic char stk[30]; static int top = 0;\n\tif (x < 0) { x = -x, putchar('-'); }\n\twhile (stk[++top] = x % 10 xor 48, x /= 10, x);\n\twhile (putchar(stk[top--]), top);\n}\ntemplate<typename T> inline bool chkmin(T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\n\nconst int maxN = (int) 2e5, LOG = 18;\n\nbool ans[maxN + 2];\nint f[maxN + 2], g[maxN + 2], x[maxN + 2], n, V, Floor;\n\nstruct Seg\n{\n\tint l, r;\n\n\tSeg() { }\n\n\tSeg(int l, int r) : l(l), r(r) { }\n\n\tbool operator < (Seg B) const\n\t{ return r < B.r; }\n} ;\nvector<Seg> seg[LOG + 1], rev_seg[LOG + 1];\n\nvoid Input()\n{\n\tn = read(), V = read();\n\tfor (int i = 1; i <= n; ++i) x[i] = read();\n}\n\nvoid Init()\n{\n\tfor (int t = 0; (V * 2) >> t; ++t)\n\t{\n\t\t//debug(\"%d\\n\", V * 2 >> t);\n\t\tFloor = t;\n\t\tint last = 1, d = V >> t;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif (x[i + 1] - x[i] > d)\n\t\t\t{\n\t\t\t\tseg[t].push_back(Seg(last, i));\n\t\t\t\trev_seg[t].push_back(Seg(n - i + 1, n - last + 1));\n\t\t\t\tlast = i + 1;\n\t\t\t}\n\t\t}\n\t\tseg[t].push_back(Seg(last, n));\n\t\t//for (Seg s : seg[t])\n\t\t//\tcout << s.l << ' ' << s.r << endl;\n\t\t//cout << \"_______________\" << endl;\n\t\trev_seg[t].push_back(Seg(1, n - last + 1));\n\n\t\treverse(rev_seg[t].begin(), rev_seg[t].end());\n\t}\n}\n\nvoid Solve()\n{\n\tfor (int S = 0; S < 1 << Floor + 1; S += 2)\n\t{\n\t\tfor (int i = 1; i <= Floor; ++i)\n\t\t\tif (!(S >> i & 1))\n\t\t\t{\n\t\t\t\tint p = upper_bound(seg[i].begin(), seg[i].end(), Seg(0, f[S])) - seg[i].begin();\n\t\t\t\tif (p != (int)seg[i].size()) \n\t\t\t\t\tchkmax(f[S | (1 << i)], seg[i][p].r);\n\t\t\t}\n\t}\n\t//cout << \"F\" << endl;\n\t//cout << f[2] << endl;\n\t//cout << f[4] << endl;\n\t//cout << f[6] << endl;\n\n\tfor (int S = 0; S < 1 << Floor + 1; S += 2)\n\t{\n\t\tfor (int i = 1; i <= Floor; ++i)\n\t\t\tif (!(S >> i & 1))\n\t\t\t{\n\t\t\t\tint p = upper_bound(rev_seg[i].begin(), rev_seg[i].end(), Seg(0, g[S])) - rev_seg[i].begin();\n\t\t\t\tif (p != (int)rev_seg[i].size()) \n\t\t\t\t\tchkmax(g[S | (1 << i)], rev_seg[i][p].r);\n\t\t\t}\n\t}\n\t//cout << \"G\" << endl;\n\t//cout << g[2] << endl;\n\t//cout << g[4] << endl;\n\t//cout << g[6] << endl;\n\n\tfor (auto s : seg[0])\n\t{\n\t\tbool ok = 0;\n\t\tfor (int S = 0; S < 1 << Floor + 1; S += 2)\n\t\t{\n\t\t\tint T = ((1 << Floor + 1) - 1) ^ 1 ^ S;\n\t//\tif (s.l == 3)\n\t//\t{\n\t//\t\tcout << S << ' ' << T << endl;\n\t//\t\tcout << \"F , G \" << f[S] << ' ' << g[T] << endl;\n\t//\t}\n\t\t\tif (f[S] >= s.l - 1 and g[T] >= (n - s.r + 1) - 1)\n\t\t\t{\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok)\n\t\t\tfor (int i = s.l; i <= s.r; ++i)\n\t\t\t\tans[i] = 1;\n\t}\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (ans[i])\n\t\t\tputs(\"Possible\");\n\t\telse \n\t\t\tputs(\"Impossible\");\n}\n\nint main() \n{ \n\n\tInput();\n\n\tInit();\n\n\tSolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\nint n,v;\nconst int N=222222;\nint xi[N];\nint d[N];\n\nint vs[20];int tot=0;\n//0 ~ tot-1   vs[0]=V\n\nint lef[20][N],rig[20][N];\n\nint fromlef[524288],fromrig[524288];\n\n\nint sum[N];\nvoid add(int l,int r){//point [l,r] ok\n\tif(l>r)return;\n\tsum[l]++;\n\tsum[r+1]--;\n}\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);\n\tgn(v);\n\trep(i,1,n+1)gn(xi[i]);\n\td[1]=inf;\n\trep(i,2,n+1)d[i]=xi[i]-xi[i-1];\n\td[n+1]=inf;\n\twhile(v>0){\n\t\tvs[tot++]=v;\n\t\tv>>=1;\n\t}\n\tvs[tot++]=0;\n\trep(d,0,tot){\n\t\trep(i,1,n+2){\n\t\t\tif(::d[i]>vs[d])lef[d][i]=i;\n\t\t\telse lef[d][i]=lef[d][i-1];\n\t\t}\n\t\tper(i,1,n+2){\n\t\t\tif(::d[i]>vs[d])rig[d][i]=i;\n\t\t\telse rig[d][i]=rig[d][i+1];\n\t\t}\n\t}\n\tfil(fromrig,63);\n\tfromlef[0]=0;\n\tfromrig[0]=n+1;\n\n\trep(i,0,pw(tot)){\n\t\trep(j,0,tot)if(!(i&pw(j))){\n\t\t\tif(fromlef[i]>=n)fromlef[i|pw(j)]=n;\n\t\t\telse upmax(fromlef[i|pw(j)],rig[j][fromlef[i]+2]-1);\n\n\t\t\tif(fromrig[i]<=1)fromrig[i|pw(j)]=1;\n\t\t\telse upmin(fromrig[i|pw(j)],lef[j][fromrig[i]-1]);\n\t\t}\n\t}\n\n\trep(i,0,pw(tot)){\n\t\tif(i&pw(0))continue;\n\t\tint l=fromlef[i],r=fromrig[pw(tot)-2-i];\n\t\tif(l+1>=r){\n\t\t\tadd(1,n);\n\t\t}else{\n\t\t\tint st=l+1;\n\t\t\tint le=lef[0][st],ri=rig[0][st+1]-1;\n\t\t\tif(ri+1>=r) add(le,ri);\n\t\t}\n\t}\n\trep(i,1,n+1)sum[i]+=sum[i-1];\n\trep(i,1,n+1)if(sum[i]>0)printf(\"Possible\\n\");else printf(\"Impossible\\n\");\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 200005;\nconst int L = 20;\n\nint n,V;\nint a[N];\nint val[L],k;\nint rig[N][L],lef[N][L];\nint f[N],g[N];\nint ad[N];\nint lm[N];\n\nint main(){\n\t//freopen(\"data.in\",\"r\",stdin);\n\tn=get();V=get();\n\tfo(i,1,n)a[i]=get();\n\tval[k=1]=V;\n\tfor(;val[k];k++)val[k+1]=val[k]/2;\n\tfo(i,1,n){\n\t\tfo(j,1,k)lef[i][j]=i;\n\t\tif (i>1)\n\t\t\tfo(j,1,k)\n\t\t\tif (val[j]>=a[i]-a[i-1])lef[i][j]=lef[i-1][j];\n\t}\n\tfd(i,n,1){\n\t\tfo(j,1,k)rig[i][j]=i;\n\t\tif (i<n)\n\t\t\tfo(j,1,k)\n\t\t\tif (val[j]>=a[i+1]-a[i])rig[i][j]=rig[i+1][j];\n\t}\n\tfo(i,0,(1<<(k-1))-1)f[i]=0,g[i]=n+1;\n\tfo(i,0,(1<<(k-1))-1){\n\t\tfo(j,2,k)\n\t\tif ((i&(1<<(j-2)))==0){\n\t\t\tif (f[i]==n)f[i|(1<<(j-2))]=n;\n\t\t\telse f[i|(1<<(j-2))]=max(f[i|(1<<(j-2))],rig[f[i]+1][j]);\n\t\t\tif (g[i]==1)g[i|(1<<(j-2))]=1;\n\t\t\telse g[i|(1<<(j-2))]=min(g[i|(1<<(j-2))],lef[g[i]-1][j]);\n\t\t}\n\t}\n\tfo(i,0,n+1)lm[i]=1e+9;\n\tfo(i,0,(1<<(k-1))-1)lm[f[i]]=min(lm[f[i]],g[((1<<(k-1))-1)^i]);\n\tfd(i,n-1,0)lm[i]=min(lm[i],lm[i+1]);\n\tfo(i,1,n)ad[i]+=ad[i-1];\n\tfo(i,1,n)\n\tif (lm[lef[i][1]-1]<=rig[i][1]+1)printf(\"Possible\\n\");\n\telse printf(\"Impossbile\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <fstream>\n\ntypedef long long LL;\ntypedef unsigned long long uLL;\n\n#define SZ(x) ((int)x.size())\n#define ALL(x) (x).begin(), (x).end()\n#define MP(x, y) std::make_pair(x, y)\n#define DE(x) cerr << x << endl;\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define GO cerr << \"GO\" << endl;\n#define rep(i, a, b) for (register int (i) = (a); (i) <= (b); ++(i))\n\nusing namespace std;\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\ninline int read() \n{\n\tregister int x = 0; register int f = 1; register char c;\n\twhile (!isdigit(c = getchar())) if (c == '-') f = -1;\n\twhile (x = (x << 1) + (x << 3) + (c xor 48), isdigit(c = getchar()));\n\treturn x * f;\n}\ntemplate<class T> inline void write(T x) \n{\n\tstatic char stk[30]; static int top = 0;\n\tif (x < 0) { x = -x, putchar('-'); }\n\twhile (stk[++top] = x % 10 xor 48, x /= 10, x);\n\twhile (putchar(stk[top--]), top);\n}\ntemplate<typename T> inline bool chkmin(T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\n\nconst int maxN = (int) 2e5, LOG = 18;\n\nbool ans[maxN + 2];\nint f[maxN + 2], g[maxN + 2], x[maxN + 2], n, V, Floor;\n\nstruct Seg\n{\n\tint l, r;\n\n\tSeg() { }\n\n\tSeg(int l, int r) : l(l), r(r) { }\n\n\tbool operator < (Seg B) const\n\t{ return r < B.r; }\n} ;\nvector<Seg> seg[LOG + 1], rev_seg[LOG + 1];\n\nvoid Input()\n{\n\tn = read(), V = read();\n\tfor (int i = 1; i <= n; ++i) x[i] = read();\n}\n\nvoid Init()\n{\n\tfor (int t = 0; (V * 2) >> t; ++t)\n\t{\n\t\t//debug(\"%d\\n\", V * 2 >> t);\n\t\tFloor = t;\n\t\tint last = 1, d = V >> t;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif (x[i + 1] - x[i] > d)\n\t\t\t{\n\t\t\t\tseg[t].push_back(Seg(last, i));\n\t\t\t\trev_seg[t].push_back(Seg(n - i + 1, n - last + 1));\n\t\t\t\tlast = i + 1;\n\t\t\t}\n\t\t}\n\t\tseg[t].push_back(Seg(last, n));\n\t\t//for (Seg s : seg[t])\n\t\t//\tcout << s.l << ' ' << s.r << endl;\n\t\t//cout << \"_______________\" << endl;\n\t\trev_seg[t].push_back(Seg(1, n - last + 1));\n\n\t\treverse(rev_seg[t].begin(), rev_seg[t].end());\n\t}\n}\n\nvoid Solve()\n{\n\tfor (int S = 0; S < 1 << Floor + 1; S += 2)\n\t{\n\t\tfor (int i = 1; i <= Floor; ++i)\n\t\t\tif (!(S >> i & 1))\n\t\t\t{\n\t\t\t\tint p = upper_bound(seg[i].begin(), seg[i].end(), Seg(0, f[S])) - seg[i].begin();\n\t\t\t\tif (p != (int)seg[i].size()) \n\t\t\t\t\tchkmax(f[S | (1 << i)], seg[i][p].r);\n\t\t\t}\n\t}\n\t//cout << \"F\" << endl;\n\t//cout << f[2] << endl;\n\t//cout << f[4] << endl;\n\t//cout << f[6] << endl;\n\n\tfor (int S = 0; S < 1 << Floor + 1; S += 2)\n\t{\n\t\tfor (int i = 1; i <= Floor; ++i)\n\t\t\tif (!(S >> i & 1))\n\t\t\t{\n\t\t\t\tint p = upper_bound(rev_seg[i].begin(), rev_seg[i].end(), Seg(0, g[S])) - rev_seg[i].begin();\n\t\t\t\tif (p != (int)rev_seg[i].size()) \n\t\t\t\t\tchkmax(g[S | (1 << i)], rev_seg[i][p].r);\n\t\t\t}\n\t}\n\t//cout << \"G\" << endl;\n\t//cout << g[2] << endl;\n\t//cout << g[4] << endl;\n\t//cout << g[6] << endl;\n\n\tfor (auto s : seg[0])\n\t{\n\t\tbool ok = 0;\n\t\tfor (int S = 0; S < 1 << Floor + 1; S += 2)\n\t\t{\n\t\t\tint T = ((1 << Floor + 1) - 1) ^ 1 ^ S;\n\t//\tif (s.l == 3)\n\t//\t{\n\t//\t\tcout << S << ' ' << T << endl;\n\t//\t\tcout << \"F , G \" << f[S] << ' ' << g[T] << endl;\n\t//\t}\n\t\t\tif (f[S] >= s.l - 1 and g[T] >= (n - s.r + 1) - 1)\n\t\t\t{\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok)\n\t\t\tfor (int i = s.l; i <= s.r; ++i)\n\t\t\t\tans[i] = 1;\n\t}\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (ans[i])\n\t\t\tputs(\"Possible\");\n\t\telse \n\t\t\tputs(\"Impossible\");\n}\n\nint main() \n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"AGC012E.in\", \"r\", stdin);\n\tfreopen(\"AGC012E.out\", \"w\", stdout);\n#endif\n\n\tInput();\n\n\tInit();\n\n\tSolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 1; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tif(root_i > root_j) root_i ^= root_j, root_j ^= root_i, root_i ^= root_j;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nint N, V;\nint x[200005];\nint v[20], vnum;\nUnionFind uf[20];\nint dp[1<<18];\n\nint main(void)\n{\n\tcin >> N >> V;\n\tfor(int i = 1; i <= N; i++) cin >> x[i];\n\t\n\tint tmp = V;\n\tfor(int i = 0; ; i++){\n\t\tv[i] = tmp;\n\t\tif(tmp == 0){\n\t\t\tvnum = i+1;\n\t\t\tbreak;\n\t\t}\n\t\ttmp /= 2;\n\t}\n\t\n\tfor(int i = 0; i < vnum; i++) uf[i] = UnionFind(N);\n\tfor(int i = 0; i < vnum; i++){\n\t\tfor(int j = 1; j < N; j++){\n\t\t\tif(x[j+1] - x[j] <= v[i]) uf[i].unite(j, j+1);\n\t\t}\n\t}\n\t\n\tset<int> S;\n\tfor(int i = 1; i <= N; i++) S.insert(uf[0].root(i));\n\tif(S.size() > vnum){\n\t\tfor(int i = 1; i <= N; i++) cout << \"Impossible\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int p = 1; p <= N; p++){\n\t\tint l = p, r = uf[0].root(p), n = 1<<(vnum-1);\n\t\tfor(int i = 0; i < n; i++) dp[i] = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(dp[i] == l-1) dp[i] = r;\n\t\t\tif(dp[i] >= N) continue;\n\t\t\tfor(int j = 0; j < vnum-1; j++){\n\t\t\t\tif(i & (1<<j)) continue;\n\t\t\t\tdp[i|(1<<j)] = max(dp[i|(1<<j)], uf[j+1].root(dp[i]+1));\n\t\t\t}\n\t\t}\n\t\tbool ans = false;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(dp[i] >= N){\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = l; i <= r; i++){\n\t\t\tif(ans) cout << \"Possible\" << endl;\n\t\t\telse cout << \"Impossible\" << endl;\n\t\t}\n\t\tp = r;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <algorithm>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n\nusing namespace std;\n\nconst int N = 200010;\n\nint n, p, V, X[N];\nint tor[N][20], tol[N][20];\nint dpl[N], dpr[N], cnt[N];\n\nint main(){\n\tscanf(\"%d%d\", &n, &V);\n\tFor(i, 1, n) scanf(\"%d\", &X[i]);\n\tX[0] = -2e9, X[n + 1] = 2e9;\n\tFor(i, 0, 19){\n\t\tint l = 1;\n\t\tFor(j, 1, n) \n\t\t\tif(1ll * X[j + 1] - X[j] > V){\n\t\t\t\tFor(k, l, j) tol[k][i] = l, tor[k][i] = j;\n\t\t\t\tl = j + 1;\n\t\t\t}\n\t\tif(!V){\n\t\t\tp = i;\n\t\t\tbreak;\n\t\t}\n\t\tV >>= 1;\n\t}\n\tint S = (1 << p) - 1;\n\tdpl[0] = 0;\n\tFor(i, 1, S){\n\t\tdpl[i] = 0;\n\t\tFor(j, 1, p) if(i & (1 << (j - 1))) dpl[i] = max(dpl[i], tor[dpl[i ^ (1 << (j - 1))] + 1][j]);\n\t}\n\tdpr[0] = n + 1;\n\tFor(i, 1, S){\n\t\tdpr[i] = n + 1;\n\t\tFor(j, 1, p) if(i & (1 << (j - 1))) dpr[i] = min(dpr[i], tol[dpr[i ^ (1 << (j - 1))] - 1][j]);\n\t}\n\tFor(i, 0, S){\n\t\tint L = dpl[i] + 1, R = dpr[S ^ i] - 1;\n\t\tif(tor[L][0] >= R) cnt[tol[L][0]]++, cnt[tor[R][0] + 1]--;\n\t}\n\tFor(i, 1, n){\n\t\tcnt[i] += cnt[i - 1];\n\t\tif(cnt[i]) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 262150\n#define inf 2147483647\nusing namespace std;\nstruct pos1{int l, r;}pos[N][19];\nint n, m, k, w[N], now, dp_l[N], dp_r[N], bin[19], x, ff, sum;\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tbin[0]=1; for(int i=1; i<=18; i++)bin[i]=bin[i-1]<<1;\n\tfor(int i=1; i<=n; i++)scanf(\"%d\", &w[i]); w[0]=w[1]-m-1; w[n+1]=w[n]+m+1;\n\tk=-1; x=m<<1;\n\twhile(x){\n\t\tk++; x>>=1; now=0;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(w[i]-w[i-1]>x)now=i;\n\t\t\tpos[i][k].l=now;\n\t\t}\n\t\tnow=n+1;\n\t\tfor(int i=n; i; i--){\n\t\t\tif(w[i+1]-w[i]>x)now=i;\n\t\t\tpos[i][k].r=now;\n\t\t}\n\t}\n\tdp_l[0]=0; dp_r[0]=n+1;\n\tfor(int i=1; i<=bin[k]-1; i++){\n\t\tdp_l[i]=0; dp_r[i]=n+1;\n\t\tfor(int j=1; j<=k; j++)if(i&bin[j-1]){\n\t\t\tdp_l[i]=max(dp_l[i], pos[dp_l[i-bin[j-1]]+1][j].r);\n\t\t\tdp_r[i]=min(dp_r[i], pos[dp_r[i-bin[j-1]]-1][j].l);\n\t\t}\n\t}\n\tsum=0; for(int i=1; i<=n; i++)if(pos[i][0].l==i)sum++;\n\tif(sum>=k+2){for(int i=1; i<=n; i++)printf(\"Impossible\\n\"); return 0;}\n\tfor(int i=1; i<=n; i++)if(pos[i][0].l==i){\n\t\tff=0;\n\t\tfor(int j=0; j<=bin[k]-1; j++)if(dp_l[j]>=pos[i][0].l-1&&dp_r[bin[k]-1-j]<=pos[i][0].r+1){ff=1; break;}\n\t\tfor(int j=pos[i][0].l; j<=pos[i][0].r; j++)if(ff)printf(\"Possible\\n\"); else printf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define N 131072\n#define ll long long\nusing namespace std;\nint n,m,cnt,a[N],b[20],l[20][N],r[20][N],f[N],g[N];\nstruct node{ int x,y; node(){} node(int a,int b){ x=a,y=b; } }c[N];\nconst bool cmp(const node &x,const node &y){ return x.y<y.y; }\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (; m; m>>=1) b[++cnt]=m; b[++cnt]=0;\n\trep (i,1,cnt>>1) swap(b[i],b[cnt-i+1]);\n\tm=1<<cnt-1;\n\trep (i,1,n) scanf(\"%d\",&a[i]);\n\trep (i,1,cnt){//预处理l[i][j]和r[i][j]表示第i层第j个点所在线段的左右端点\n\t\tl[i][1]=1; r[i][n]=n;\n\t\trep (j,2,n) l[i][j]=a[j]-a[j-1]<=b[i]?l[i][j-1]:j;\n\t\tper (j,n-1,1) r[i][j]=a[j+1]-a[j]<=b[i]?r[i][j+1]:j;\n\t}\n\trep (i,0,m-1) g[i]=n+1,f[i]=0;//f[i]表示状态为i，从1开始延伸出去的最远长度；g[i]表示从n开始延伸的最远长度\n\t//状态s的意思是，如果某位为1则表示当前层选了线段\n\trep (i,1,m-1) rep (j,1,cnt-1) if ((i>>j-1)&1){\n\t\tint k=i^1<<j-1;//f[k]->f[i]\n\t\tf[i]=max(f[i],f[k]<n?r[j][f[k]+1]:n);\n\t\tg[i]=min(g[i],g[k]>1?l[j][g[k]-1]:1);\n\t}\n\trep (i,0,m-1)\n\t\tif (f[i]+1<g[m-1^i]) c[i+1]=node(f[i]+1,g[m-1^i]-1);\n\t\telse{\n\t\t\trep(j,1,n) puts(\"Possible\"); return 0;\n\t\t}\n\tsort(c+1,c+1+m,cmp);\n\tfor (int i=1,j=1,k=0; i<=n; i++){\n\t\twhile (j<=m && c[j].y<=r[cnt][i]){\n\t\t\tj++; k=max(k,c[j].x);\n\t\t}\n\t\tif (k>=l[cnt][i]) puts(\"Possible\"); else puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 200010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;if(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\n\nint b[40],sz,a[N],c[N];\nint dp[1<<18],f[1<<18],l[N][20],r[N][20];\nint main(){\n    //freopen(\"A.in\",\"r\",stdin);\n    //freopen(\"A.out\",\"w\",stdout);\n    //cout<<setprecision(9)<<fixed;\n    //cerr<<setprecision(9)<<fixed;\n    int T,i,j,k,ca=0,m,K,n;\n    scanf(\"%d%d\",&n,&m);\n    K=m;sz=0;\n    while(K)b[sz++]=K,K>>=1;\n    b[sz++]=0;\n    swap(b[0],b[sz-1]);\n    rep(i,0,n)scanf(\"%d\",&a[i]);\n    rep(k,0,sz){\n        K=b[k];\n        //cerr<<k<<\" \"<<K<<\"\\n\";\n        l[0][k]=0;\n        rep(i,1,n){\n            if(K>=a[i]-a[i-1])l[i][k]=l[i-1][k];\n            else l[i][k]=i;\n        }\n        r[n-1][k]=n-1;\n        per(i,0,n-1){\n            if(K>=a[i+1]-a[i])r[i][k]=r[i+1][k];\n            else r[i][k]=i;\n        }\n    }\n    sz--;\n    memset(dp,-1,sizeof(dp));\n    dp[0]=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Max(dp[i|1<<j],x);\n            if(x+1<n)Max(dp[i|1<<j],r[x+1][j]);\n        }\n    }\n    per(i,0,(1<<sz))f[i]=n;\n    f[0]=n-1;\n    rep(i,0,(1<<sz)){\n        int x=f[i];\n        rep(j,0,sz)if((i>>j&1)==0){\n            Min(f[i|1<<j],x);\n            if(x)Min(f[i|1<<j],l[x-1][j]);\n        }\n    }\n    int mask=(1<<sz)-1,flag=0;\n    rep(i,0,(1<<sz)){\n        int x=dp[i],y=f[mask^i];\n        k=r[x+1][sz];\n        j=l[y-1][sz];\n        if(j<=x+1&&k>=y-1)c[j]++,c[k+1]--;\n    }\n    {\n        rep(i,1,n)c[i]+=c[i-1];\n        rep(i,0,n){\n            if(c[i])puts(\"Possible\");\n            else puts(\"Impossible\");\n        }\n    }\n    /*\n    rep(i,0,n)if(i==n-5){\n        int x=l[i][sz],y=r[i][sz],ok=0;\n        cerr<<i<<\" \"<<x<<\" \"<<y<<\"\\n\";\n        rep(j,0,(1<<sz)){\n            k=mask^j;\n            cerr<<j<<\" \"<<dp[j]<<\",\"<<k<<\" \"<<f[k]<<\"\\n\";\n            if(dp[j]>=x-1&&f[k]<=y+1){ok=1;break;}\n        }\n        puts(ok?\"Y\":\"N\");\n    }//*/\n    //cerr<<clock()*1./CLOCKS_PER_SEC<<\"ms\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\ninline int Get() {\n\tchar ch;\n\tint Num, Sign = 0;\n\twhile ((ch = getchar()) < '0' || ch > '9')\n\t\tif (ch == '-') Sign ^= 1;\n\tNum = ch - '0';\n\twhile ((ch = getchar()) >= '0' && ch <= '9')\n\t\tNum = (Num << 3) + (Num << 1) + ch - '0';\n\treturn Sign ? -Num : Num;\n}\nconst int N = 2e5 + 5;\nint n, m, pos[N], a[20], len, toL[20][N], toR[20][N];\nint all, preL[1 << 20], preR[1 << 20], flag[N];\ninline int queryL(int x) {\n\tint l = 1, r = n, res = 1;\n\twhile (l <= r) {\n\t\tint mid = l + r >> 1;\n\t\tif (toL[len][mid] <= x) res = mid, l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\treturn res;\n}\ninline int queryR(int x) {\n\tint l = 1, r = n, res = 1;\n\twhile (l <= r) {\n\t\tint mid = l + r >> 1;\n\t\tif (toR[len][mid] >= x) res = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\treturn res;\n}\nint main() {\n\tn = Get(), m = Get();\n\tfor (int i = 1; i <= n; ++i) pos[i] = Get();\n\t\n\tfor (int x = m; x; x >>= 1) a[len++] = x >> 1; a[len] = m;\n\t\n\tfor (int k = 0; k <= len; ++k) {\n\t\ttoL[k][1] = 1; \n\t\tfor (int i = 2; i <= n; ++i) toL[k][i] = (pos[i] - pos[i - 1] <= a[k]) ? toL[k][i - 1] : i;\n\t\t\n\t\ttoR[k][n] = n; \n\t\tfor (int i = n - 1; i; --i) toR[k][i] = (pos[i + 1] - pos[i] <= a[k]) ? toR[k][i + 1] : i;\n\t}\n\t\n\tall = 1 << len;\n\tfor (int opt = 0; opt < all; ++opt) preL[opt] = 0;\n\tfor (int opt = 1; opt < all; ++opt) \n\t\tfor (int k = 0; k < len; ++k)\n\t\t\tif (opt & (1 << k)) {\n\t\t\t\tint nxt = opt ^ (1 << k);\n\t\t\t\tpreL[opt] = std :: max(preL[opt], preL[nxt]);\n\t\t\t\tif (preL[nxt] < n) preL[opt] = std :: max(preL[opt], toR[k][preL[nxt] + 1]);\n\t\t\t}\n\t\t\t\n\tfor (int opt = 0; opt < all; ++opt) preR[opt] = n + 1;\n\tfor (int opt = 1; opt < all; ++opt) \n\t\tfor (int k = 0; k < len; ++k)\n\t\t\tif (opt & (1 << k)) {\n\t\t\t\tint nxt = opt ^ (1 << k);\n\t\t\t\tpreR[opt] = std :: min(preR[opt], preR[nxt]);\n\t\t\t\tif (preR[nxt] > 1) preR[opt] = std :: min(preR[opt], toL[k][preR[nxt] - 1]);\n\t\t\t}\n\t\n\tfor (int opt = 0; opt < all; ++opt) {\n\t\tint x = queryR(preR[(all - 1) ^ opt] - 1), y = queryL(preL[opt] + 1);\n\t\tif (x <= y) ++flag[x], --flag[y + 1];\n\t}\n\t\n\tfor (int i = 1; i <= n; ++i) \n\t\tflag[i] += flag[i - 1], puts(flag[i] ? \"Possible\" : \"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint x[220000],l[20][220000][2],f[220000][2],n,v,p[20][220000],cnt[20],k;\nbool b[20];\nint main(){\n\t\n\tscanf(\"%d%d\",&n,&v);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",x+i);\n\tfor (k=0;v;++k,v>>=1){\n\t\tcnt[k]=1,l[k][1][0]=p[k][0]=p[k][1]=1;\n\t\tfor (int j=2;j<=n;++j) {\n\t\t\tif (x[j-1]+v<x[j]) {\n\t\t\t\tl[k][cnt[k]][1]=j-1,++cnt[k];\n\t\t\t\tl[k][cnt[k]][0]=j;\n\t\t\t}\n\t\t\tp[k][j]=cnt[k];\n\t\t}\n\t\tl[k][cnt[k]][1]=n,p[k][n]=p[k][n+1]=cnt[k];\n\t}\n\tcnt[k]=0;\n\tfor (int i=1;i<=n;++i) ++cnt[k],l[k][cnt[k]][0]=l[k][cnt[k]][1]=i,p[k][i]=i;\n\t++k;\n\tif (cnt[0]>k) {\n\t\tfor (int i=0;i<n;++i) printf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint tp=1<<k;\n\tf[0][0]=0,f[0][1]=n+1;\n\tfor (int i=2;i<tp;i+=2) {\n\t\tf[i][0]=-1,f[i][1]=n<<1;\n\t\tfor (int j=1;j<k;++j) {\n\t\t\tif (i&(1<<j)) {\n\t\t\t\tf[i][0]=max(f[i][0],l[j][p[j][f[i^(1<<j)][0]+1]][1]);\n\t\t\t\tf[i][1]=min(f[i][1],l[j][p[j][f[i^(1<<j)][1]-1]][0]);\n\t\t\t}\n\t\t}\n\t}\n\ttp-=2;\n\tfor (int i=2;i<=tp;i+=2) {\n\t\tfor (int j=1;j<=cnt[1];++j) {\n\t\t\tif (f[i][0]+1>=l[0][j][0]&&f[i^tp][1]-1<=l[0][j][1]) b[j]=1;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\t printf(b[p[0][i]]?\"Possible\\n\":\"Impossible\\n\");\n\t}\n//\tfor (int i=2;i<=tp;i+=2) printf(\"%d %d\\n\",f[i][0],f[i][1]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 220000\ninline char gc(){\n\tstatic char now[1<<16],*S,*T;\n\tif (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}\n\treturn *S++;\n}\n#define S 1<<19\ninline int read(){\n\tint x=0,f=1;char ch=gc();\n\twhile (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}\n\twhile (ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=gc();}\n\treturn x*f;\n}\nint f1[S],f2[S],n,num,bin[20],st[N],a[N],right[N][20],left[N][20],v;\nint main(){\n//\tfreopen(\"agc.in\",\"r\",stdin);\n\tn=read();v=read();int Log=0;\n\tfor (int i=1;i<=n;++i) a[i]=read();\n\twhile ((1<<Log)<=v) Log++;Log++;\n\tfor (int i=0;i<=Log+1;++i) bin[i]=1<<i;\n\tnum=1;for (int i=2;i<=n;++i) if (a[i]-a[i-1]>v) num++;\n\tfor (int j=0;j<Log;++j){\n\t\tleft[1][j]=1;right[n][j]=n;\n\t\tfor (int i=2;i<=n;++i) if (a[i]-a[i-1]>(v>>j)) left[i][j]=i;else left[i][j]=left[i-1][j];\n\t\tfor (int i=n-1;i>=1;--i) if (a[i+1]-a[i]>(v>>j)) right[i][j]=i;else right[i][j]=right[i+1][j];\n\t}\t\n\t/*for (int j=0;j<Log;++j){\n\t\tfor (int i=1;i<=n;++i) printf(\"%d \",right[i][j]);printf(\"\\n\");\n\t\tfor (int i=n;i>=1;--i) printf(\"%d \",left[i][j]);printf(\"\\n\");\n\t}*/\n\tif (num>Log){\n\t\tfor (int i=1;i<=n;++i) printf(\"Impossible\\n\");return 0;\n\t}\n\tfor (int s=0;s<=bin[Log]-1;++s) {f1[s]=0,f2[s]=n+1;}\n\tfor (int s=0;s<=bin[Log]-1;++s){\n\t\tfor (int i=0;i<Log;++i){\n\t\t\tif (s&bin[i])continue;\n\t\t\tif (f1[s]==n) f1[s|bin[i]]=n;else f1[s|bin[i]]=max(f1[s|bin[i]],right[f1[s]+1][Log-i-1]);\n\t\t\tif (f2[s]==1) f2[s|bin[i]]=1;else f2[s|bin[i]]=min(f2[s|bin[i]],left[f2[s]-1][Log-i-1]);\n\t\t}\n\t}for (int i=0;i<=n;++i) st[i]=n+2;\n\tfor (int s=0;s<=bin[Log-1]-1;++s){\n\t\tint s1=(bin[Log-1]-1)^s;\n\t\tst[f1[s]]=min(st[f1[s]],f2[s1]);\n\t} for (int i=n-1;i>=0;--i) st[i]=min(st[i],st[i+1]);\n\t//for (int i=0;i<=n;++i) printf(\"%d \",st[i]);printf(\"\\n\");\n\tfor (int i=1;i<=n;++i){\n\t\tint l=left[i][0],r=right[i][0];\n\t\tif (st[l-1]<=r+1) printf(\"Possible\\n\");else printf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(),v.end()\n\nconst int maxn = 2e5 + 100, maxlg = 16;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, v, vols[maxlg], volCount, nxt[maxlg][maxn], dp[(1 << maxlg)];\nll x[maxn], a[maxn];\nbool ans[maxn];\nset<int> counter;\n\nvoid printAnsAndExit() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << (ans[i] ? \"Possible\" : \"Impossible\") << endl;\n\t}\n\texit(0);\n}\n\nvoid solve(int l, int r) {\n\tmemset(dp, 0, sizeof(dp));\n\tfor (int mask = 0; mask < (1 << (volCount - 1)); mask++) {\n\t\tfor (int bit = 0; bit < volCount - 1; bit++) {\n\t\t\tif (!((mask >> bit) & 1)) {\n\t\t\t\tint val = nxt[bit][dp[mask]] + 1;\n\t\t\t\tif (l <= val && val <= r) {\n\t\t\t\t\tval = r + 1;\n\t\t\t\t}\n\t\t\t\tdp[mask | (1 << bit)] = max(dp[mask | (1 << bit)], val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mx = *max_element(dp, dp + (1 << maxlg));\n\tif (mx == n) {\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tans[i] = true;\n\t\t}\n\t}\n}\n\nvoid solveAll() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcounter.insert(nxt[volCount - 1][i]);\n\t}\n\tif (counter.size() > volCount) {\n\t\tprintAnsAndExit();\n\t}\n\t\n\tint l = 0, r = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (nxt[volCount - 1][r] == nxt[volCount - 1][i]) {\n\t\t\tr++;\n\t\t}\n\t\telse {\n\t\t\tsolve(l, r);\n\t\t\tr++;\n\t\t\tl = r;\n\t\t}\n\t}\n\tsolve(l, r);\n}\n\n\nvoid calcVols(int v) {\n\tint count = 0, tmp = v;\n\twhile (tmp) {\n\t\ttmp /= 2;\n\t\tcount++;\n\t}\n\tvolCount = ++count;\n\twhile (count) {\n\t\tvols[--count] = v;\n\t\tv /= 2;\n\t}\n}\n\nvoid calcNxt() {\n\tfor (int vol = 0; vol < volCount; vol++) {\n\t\tint l = 0, r = 0;\n\t\twhile (r < n - 1) {\n\t\t\tif (x[r + 1] - x[r] <= vols[vol]) {\n\t\t\t\tr++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (l <= r) {\n\t\t\t\t\tnxt[vol][l] = r;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\twhile (l <= r) {\n\t\t\tnxt[vol][l] = r;\n\t\t\tl++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t\ta[i] = x[i];\n\t}\n\n\tcalcVols(v);\n\tcalcNxt();\n\tsolveAll();\n\tprintAnsAndExit();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nconst int N=270000,LOG=20;\nint x[N],v[N],L[LOG][N],R[LOG][N],val[N],Lf[N],Rf[N],n,k,tot;\nint main(){\n    read(n);\n    read(v[0]);\n    for(int i=1;i<=n;i++) \n        puts(\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=1e6+5,M=5e6+5;\nconst int INF=2000000000;\nint n,V;\nint x[N];\nint cnt[25];\nint l[25][N],r[25][N];\nint f1[M],f2[M];\nbool ans[N];\nvoid Init(){\n    for(int i=0;i<M;i++)\n        f1[i]=0,f2[i]=INF;\n}\nint Upfind(int id,int pos){\n    pos++;\n    int p=upper_bound(l[id]+1,l[id]+cnt[id]+1,pos)-l[id]-1;\n    if(p<=0)\n        return pos;\n    return max(r[id][p],pos-1);\n}\nint Lowfind(int id,int pos){\n    pos--;\n    int p=lower_bound(r[id]+1,r[id]+cnt[id]+1,pos)-r[id];\n    if(p>=cnt[id]+1)\n        return pos;\n    return min(l[id][p],pos+1);\n}\nint main()\n{\n    Init();\n    scanf(\"%d%d\",&n,&V);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&x[i]);\n    x[n+1]=INF;\n    x[0]=-INF;\n    int logV=0;\n   while(1<<(logV+1)<=V)\n        logV++;\n    int v=V*2;\n    for(int t=0;t<=logV+1;t++){\n        v>>=1;\n        cnt[t]=1;\n        l[t][1]=1;\n        for(int i=1;i<=n;i++){\n            r[t][cnt[t]]=i;\n            if(x[i+1]-x[i]>v){\n                cnt[t]++;\n                l[t][cnt[t]]=i+1;\n            }\n        }\n        cnt[t]--;\n    }\n    if(cnt[0]>logV+2){\n        for(int i=1;i<=n;i++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n    }\n    int tot=1<<(logV+2);\n    f1[0]=0,f2[0]=n+1;\n    for(int s=0;s<tot;s+=2)\n        for(int i=0;i<=logV+1;i++){\n            if(!(s&(1<<i)))\n                continue;\n            f1[s]=max(f1[s],Upfind(i,f1[s^(1<<i)]));\n            f2[s]=min(f2[s],Lowfind(i,f2[s^(1<<i)]));\n        }\n    for(int i=1;i<=cnt[0];i++){\n        int ln=l[0][i],rn=r[0][i];\n        for(int s1=0;s1<tot;s1+=2){\n            int s2=tot-1-s1-1;\n            int lpos=f1[s1];\n            int rpos=f2[s2];\n            if(lpos>=ln-1&&rpos<=rn+1){\n                ans[i]=true;\n                break;\n            }\n        }\n    }\n    int pos=1;\n    for(int i=1;i<=n;i++){\n        if(ans[pos]==true)\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n        if(x[i+1]-x[i]>V)\n            pos++;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 998244353\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,m1,v,i,j,k,x,a[400005],b[25],bz1[400005][25],bz2[400005][25];\nint r[400005][25],l[400005][25],f[400005],g[400005],book[400005],flag;\nint minn(int u,int v){\n\treturn u<v?u:v;\n}\nint maxx(int u,int v){\n\treturn u>v?u:v;\n}\nint main(){\n\tn=read();v=read();\n\tx=v;\n\tfor(i=0;x!=0;i++){\n\t\tb[i]=x;\n\t\tx>>=1;\n\t}\n\tm=i;\n\tcout<<m<<endl;\n\tfor(i=1;i<=n;i++)\n\t\ta[i]=read();\n\tfor(i=1;i<n;i++)\n\t\tbz1[i][0]=a[i+1]-a[i];\n\tfor(i=2;i<=n;i++)\n\t\tbz2[i][0]=a[i]-a[i-1];\n\tfor(j=1;(1<<j)<n;j++)\n\t\tfor(i=1;i+(1<<j)<=n;i++)\n\t\t\tbz1[i][j]=maxx(bz1[i][j-1],bz1[i+(1<<(j-1))][j-1]);\n\tm1=j-1;\n\tfor(j=1;(1<<j)<n;j++)\n\t\tfor(i=(1<<j)+1;i<=n;i++)\n\t\t\tbz2[i][j]=maxx(bz2[i][j-1],bz2[i-(1<<(j-1))][j-1]);\n\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=0;j<m;j++){\n\t\t\tx=i;\n\t\t\tfor(k=m1;k>=0;k--)\n\t\t\t\tif(x+(1<<k)<=n){\n\t\t\t\t\tif(bz1[x][k]<=b[j])\n\t\t\t\t\t\tx+=(1<<k);\n\t\t\t\t}\n\t\t\tr[i][j]=x;\n\t\t\t\n\t\t\tx=i;\n\t\t\tfor(k=m1;k>=0;k--)\n\t\t\t\tif(x-(1<<k)>=1){\n\t\t\t\t\tif(bz2[x][k]<=b[j])\n\t\t\t\t\t\tx-=(1<<k);\n\t\t\t\t}\n\t\t\tl[i][j]=x;\n\t\t}\n\t}\n\tf[0]=0;\n\tg[0]=n+1;\n\tfor(i=1;i<(1<<m);i++){\n\t\tf[i]=0;\n\t\tg[i]=n+1;\n\t\tfor(j=0;j<m;j++)\n\t\t\tif(i&(1<<j)){\n\t\t\t\tif(f[i^(1<<j)]==n)\n\t\t\t\t\tf[i]=n;\n\t\t\t\telse\n\t\t\t\t\tf[i]=maxx(f[i],j!=0?r[f[i^(1<<j)]+1][j]:f[i^(1<<j)]+1);\n\t\t\t\tif(g[i^(1<<j)]==1)\n\t\t\t\t\tg[i]=1;\n\t\t\t\telse\n\t\t\t\t\tg[i]=minn(g[i],j!=0?l[g[i^(1<<j)]-1][j]:g[i^(1<<j)]-1);\n\t\t\t}\n\t}\n\tx=1;\n\ti=0;\n\twhile(x<=n){\n\t\ti++;\n\t\tif(i>=30){\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tflag=0;\n\t\tfor(j=0;j<(1<<m);j++)\n\t\t\tif(f[j]+1>=x&&g[((1<<m)-1)^j]-1<=r[x][0])\n\t\t\t\tflag=1;\n\t\tfor(j=x;j<=r[x][0];j++)\n\t\t\tbook[j]=flag;\n\t\tx=r[x][0]+1;\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tif(book[i]==1)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define stt static\n#define rg register\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n#define y1 substitute_of_y1\n#define DEBUG(x) cerr<<#x\" = \"<<x<<endl;\nusing namespace std;\n\ntemplate<typename T> il T rd(){\n\tT nmb=0;int sgn=0;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-')sgn=1;chr=getchar();}\n\twhile(isdigit(chr)){nmb=(nmb<<3)+(nmb<<1)+chr-'0';chr=getchar();}\n\treturn sgn?-nmb:nmb;\n}\ntemplate<typename T> void wt(T nmb){\n\tif(nmb>9)wt(nmb/10);\n\tputchar(nmb%10+'0');\n}\ntemplate<typename T> il void cmax(T &x,T y){x=x>y?x:y;}\ntemplate<typename T> il void cmin(T &x,T y){x=x<y?x:y;}\ninline void proc_status(){\n\tifstream t (\"/proc/self/status\");\n\tcerr<<string(istreambuf_iterator<char>(t),istreambuf_iterator<char>())<<endl;\n\t/*freopen(\"/proc/self/status\",\"r\",stdin);\n\tchar ch[100];\n\twhile(scanf(\"%s\",ch)!=EOF)cerr<<ch<<endl;*/\n}\n\nconst int N=2e5+10,L=20;\n\nint a[N];\n\nvector<pii>vec[L];\n\n#define lowbit(x) (x&(-x))\n\nint f[N<<2],g[N<<2];\n\nint ans[N],b[N];\n\nint main(){\n\tint n=rd<int>(),p=rd<int>();\n\tfor(int i=1;i<=n;++i)a[i]=rd<int>();\n\tint lev=1;\n\tint Flg=0;\n\tfor(int k=p;!Flg;k>>=1,++lev){\n\t\tif(!k)Flg=1;\n\t\tfor(int l=1,r=1;l<=n;l=r+1){\n\t\t\tr=l;\n\t\t\twhile(r<n&&a[r+1]-a[r]<=k)++r;\n\t\t\tvec[lev].pb(mp(l,r));\n\t\t}\n\t}\n\tlev-=2;\n\tint k=(1<<lev)-1;\n\tfor(int S=0;S<=k;++S)f[S]=0,g[S]=n+1;\n\tfor(int S=0;S<=k;++S){\n\t\tfor(int T=S;T;T^=lowbit(T)){\n\t\t\tint t=(int)log2(lowbit(T))+2;\n\t\t\tint U=S^lowbit(T);\n\t\t\tint pos=upper_bound(vec[t].begin(),vec[t].end(),mp(f[U]+1,n+1))-vec[t].begin()-1;\n\t\t\tif(pos>=0)cmax(f[S],vec[t][pos].snd);\n\t\t\tpos=upper_bound(vec[t].begin(),vec[t].end(),mp(g[U]-1,n+1))-vec[t].begin()-1;\n\t\t\tif(pos>=0&&vec[t][pos].snd>=g[U]-1)cmin(g[S],vec[t][pos].fst);\n\t\t}\n\t}\n\tfor(int S=0;S<=k;++S){\n\t\tint l=f[S],r=g[k^S];\n\t\tint pos1=upper_bound(vec[1].begin(),vec[1].end(),mp(l+1,n+1))-vec[1].begin()-1;\n\t\tint pos2=upper_bound(vec[1].begin(),vec[1].end(),mp(r-1,n+1))-vec[1].begin()-1;\n\t\tif(vec[1][pos2].snd<r-1)++pos2;\n\t\tif(pos1>=0&&pos2>=0&&pos1==pos2)b[pos1]=1;\n\t}\n\tfor(int i=0;i<(int)vec[1].size();++i)\n\t\tfor(int t=vec[1][i].fst;t<=vec[1][i].snd;++t)\n\t\t\tans[t]=b[i];\n\tfor(int i=1;i<=n;++i)\n\t\tif(ans[i])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).e();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).e();++it,++i)\n#define ALL(c) (c).begin(), (c).e()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).e())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug2(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\nconst int INF=0x3f3f3f3f;\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#eif\n*/\n// }}}\n\n//{{{ Array\ntemplate<class T>\nstruct Array{\n\tint sz;\n\tint l,r;\n\tvector<T> a;\n\tArray(const pair<int,int> &p,const T &d=0):l(p.first),r(p.second){\n\t\tsz = r-l+1;\n\t\ta.assign(sz,d);\n//\t\ta = (T*)malloc(sz*sizeof(T));\n//\t\tfor(int i=0;i<sz;i++)a[i] = d;\n\t}\n\tT& operator[](int i){\n\t\treturn a[i-l];\n\t}\n};\n//}}}\n\n//{{{ Imos\ntemplate<class T>\nstruct Imos{\n\tvector<T> v;\n\tint cur_i;\n\tT cur_sum;\n\tImos(int n){\n\t\tv.assign(n+1,0);\n\t\tcur_i = -1;\n\t\tcur_sum = 0;\n\t}\n\tvoid add(int l,int r,T diff){\n\t\tv[l]+=diff;\n\t\tv[r]-=diff;\n\t}\n\tT get(int i){\n\t\tassert(cur_i<=i);\n\t\tfor(;cur_i<i;cur_i++,cur_sum+=v[cur_i]);\n\t\tassert(cur_i==i);\n\t\treturn cur_sum;\n\t}\n};\n//}}}\n\nint N, V;\nconst int D = 200010;\nvector<Array<int>> rts,lts;\n\nint x[D];\n\nvector<int> dp0,dp1;\n\nint main(){\n\tcin>>N>>V;\n\tREP(i,N)cin>>x[i];\n\tint i;\n\tint v = V;\n\tfor(i=0;;i++,v/=2){\n\t\tArray<int> rt({-1,N},-1),lt({-1,N},N);\n\t\tint j,e;\n\t\tfor(e=j=0;j<N;j++,e=max(e,j)){\n\t\t\twhile(e+1<N and x[e+1]-x[e]<=v){\n\t\t\t\te++;\n\t\t\t}\n\t\t\trt[j] = e+1;\n\t\t}\n\t\tfor(e=j=N-1;j>=0;j--,e=min(e,j)){\n\t\t\twhile(e-1>=0 and x[e]-x[e-1]<=v){\n\t\t\t\te--;\n\t\t\t}\n\t\t\tlt[j] = e-1;\n\t\t}\n\t\trt[N] = N;\n\t\tlt[-1] = -1;\n\t\trts.push_back(rt);\n\t\tlts.push_back(lt);\n\t\tif(v==0)break;\n\t}\n\ti++;\n\tint d = i, B = (1<<d);\n\tdp0.assign(B,-1);\n\tdp1.assign(B,N);\n\tdp0[0] = 0;\n\tdp1[0] = N-1;\n\tfor(int b=0;b<B-1;b++){\n\t\tint head0, head1;\n\t\thead0 = min(dp0[b],N);\n\t\thead1 = max(dp1[b],-1);\n\t\tfor(int i=0;i<d;i++){\n\t\t\tif((b&(1<<i))==0){\n\t\t\t\tint b2 = (b|(1<<i));\n\t\t\t\tdp0[b2] = max(dp0[b2],rts[i][head0]);\n\t\t\t\tdp1[b2] = min(dp1[b2],lts[i][head1]);\n\t\t\t}\n\t\t}\n\t}\n\tImos<int> imos(N);\n\tfor(int b0=0;b0<B-1;b0++){\n\t\tif(b0&(1<<0))continue;\n\t\tint b1 = ((B-1)^1)-b0;\n\t\tint s0 = dp0[b0], s1 = dp1[b1];\n\t\tif(s1+1<=s0){\n\t\t\t// all possible\n\t\t\tREP(i,N){\n\t\t\t\tcout<<\"Possible\"<<endl;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif(rts[0][s0]-1<s1)continue;\n//\t\tcerr<<\"found: \"<<lts[0][s0]+1<<\" \"<<rts[0][s0]-1<<endl;\n//\t\tdump(lts[0][s0]+1);\n\t\timos.add(lts[0][s0]+1,rts[0][s0],1);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(imos.get(i)>0){\n\t\t\tcout<<\"Possible\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*====Corycle====*/\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<map>\n#define ll long long\n#define pii pair<int,int>\n#define fst first\n#define scd second\n#define mp make_pair\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int Maxn=(1<<19)+5;\nconst int N=2e5+5;\nconst int M=20;\nint read(){\n\tint s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}\n\treturn s*f;\n}\npii P[N];\nint n,V,cnt,tot,Sta,a[N],L[M][N],R[M][N],Ans[N],FL[Maxn],FR[Maxn];\nint main(){\n//\tfreopen(\"_.in\",\"r\",stdin);\n//\tfreopen(\"_.out\",\"w\",stdout);\n\tn=read();V=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();a[0]=-inf;a[n+1]=inf;\n\tfor(int v=V;;v>>=1){\n\t\ttot++;L[tot][0]=0;R[tot][n+1]=n+1;\n\t\tfor(int i=1;i<=n;i++)L[tot][i]=(a[i]-a[i-1]<=v?L[tot][i-1]:i);\n\t\tfor(int i=n;i>=1;i--)R[tot][i]=(a[i+1]-a[i]<=v?R[tot][i+1]:i);\n\t\tif(v==0)break;\n\t}\n\tSta=(1<<tot)-1;\n\tfor(int i=1;i<=n;i++)P[i]=mp(L[1][i],R[1][i]);\n\tsort(P+1,P+n+1);cnt=unique(P+1,P+n+1)-P-1;\n\tfor(int S=0;S<=Sta;S++){FL[S]=0;FR[S]=n+1;}\n\tfor(int S=0;S<=Sta;S+=2){\n\t\tfor(int i=1;i<=tot;i++){\n\t\t\tif(!((S>>(i-1))&1))continue;\n\t\t\tFL[S]=max(FL[S],R[i][FL[S^(1<<(i-1))]+1]);\n\t\t\tFR[S]=min(FR[S],L[i][FR[S^(1<<(i-1))]-1]);\n\t\t}\n\t}\n\tif(cnt>tot){for(int i=1;i<=tot;i++)puts(\"Impossible\");return 0;}\n\tfor(int i=1;i<=cnt;i++){\n\t\tfor(int S=0;S<=Sta;S+=2){\n\t\t\tif(FL[S]>=P[i].fst-1&&FR[Sta^S^1]<=P[i].scd+1){\n\t\t\t\tfor(int j=P[i].fst;j<=P[i].scd;j++)Ans[j]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)puts(Ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAXN 200010\n#define MAXS 1000010\nusing namespace std;\n\nint read(){\n\tchar c;\n\twhile(((c=getchar())<'0' || c>'9') && c!='-');\n\tint flag=1;\n\tint res=c-'0';\n\tif(c=='-'){\n\t\tflag=-1;\n\t\tres=0;\n\t}\n\twhile((c=getchar())>='0' && c<='9') res=res*10+c-'0';\n\treturn res*flag;\n}\n\nint n,m,v0,maxs;\nint a[MAXN];\nint lim[MAXN];\nint f1[MAXS],f2[MAXS];\nint p[20][MAXN][2];\nint c[MAXN];\n\nvoid calcP(int l){\n\tint last=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i==n || a[i+1]-a[i]>lim[l]){\n\t\t\tfor(int j=last;j<=i;j++){\n\t\t\t\tp[l][j][0]=last;\n\t\t\t\tp[l][j][1]=i;\n\t\t\t}\n\t\t\tlast=i+1;\n\t\t}\n\t}\n\tp[l][0][0]=1;\n\tp[l][n+1][1]=n;\n}\n\nvoid dp(){\n\tf1[0]=0; f2[0]=n+1;\n\tfor(int s=1;s<maxs;s++){\n\t\tf2[s]=n+1;\n\t\tfor(int i=1,l=1;i<=m;i++,l<<=1)\n\t\t\tif(s&l){\n\t\t\t\tf1[s]=max(f1[s],p[i][f1[s^l]+1][1]);\n\t\t\t\tf2[s]=min(f2[s],p[i][f2[s^l]-1][0]);\n\t\t\t}\n\t}\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"g012e.in\",\"r\",stdin);\n#endif\n\tn=read(); v0=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tlim[0]=v0;\n\twhile(v0) lim[++m]=(v0/=2);\n\tmaxs=1<<m;\n\tfor(int i=0;i<=m;i++) calcP(i);\n\tdp();\n\tmemset(c,-1,sizeof c);\n\tfor(int i=0;i<maxs;i++)\n\t\tc[f2[i]]=max(c[f2[i]],f1[(maxs-1)^i]);\n\tint cur=-1,now=-1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(p[0][i][0]==i){\n\t\t\twhile(cur<p[0][i][1]+1) now=max(now,c[++cur]);\n\t\t\tif(now>=i-1)\n\t\t\t\tfor(int j=p[0][i][0];j<=p[0][i][1];j++)\n\t\t\t\t\tputs(\"Possible\");\n\t\t\telse\n\t\t\t\tfor(int j=p[0][i][0];j<=p[0][i][1];j++)\n\t\t\t\t\tputs(\"Impossible\");\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint x[252521];\nint ne[252521][20],rne[252521][20];\nint dp[(1<<20)+10],rdp[(1<<20)+10];\nvector<int> v;\nint main()\n{\n\tint n,V;\n\tcin>>n>>V;\n\trep(i,n) cin>>x[i];\n\twhile(V>0){\n\t\tv.pb(V);V/=2;\n\t}\n\tv.pb(0);int m=v.size();\n\trep(i,n) rep(j,m){\n\t\trne[i][j]=i;\n\t\tif(i>0 && x[i]-x[i-1]<=v[j]) rne[i][j]=rne[i-1][j];\n\t}\n\tfor(int i=n-1;i>=0;i--) rep(j,m){\n\t\tne[i][j]=i;\n\t\tif(i<n-1 && x[i+1]-x[i]<=v[j]) ne[i][j]=ne[i+1][j];\n\t}\n\tmemset(dp,0,sizeof(dp));\n\trep(i,(1<<20)+5) rdp[i]=n-1;\n\trep(i,(1<<m)) rep(j,m){\n\t\tif((i&(1<<j))>0) continue;\n\t\tdp[i+(1<<j)]=max(dp[i+(1<<j)],ne[dp[i]][j]+1);\n\t\trdp[i+(1<<j)]=min(rdp[i+(1<<j)],rne[rdp[i]][j]-1);\n\t}\n\t//rep(i,(1<<m)) cout<<i<<' '<<dp[i]<<' '<<rdp[i]<<endl;\n\tif(dp[(1<<m)-1]<n){\n\t\trep(i,n) cout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tint now=0;\n\twhile(now<n){\n\t\tint f=0;\n\t\trep(i,(1<<(m-1))){\n\t\t\tif(dp[(1<<m)-2-(i<<1)]>=now && rdp[(i<<1)]<=ne[now][0]) f=1;\n\t\t}\n\t\tREP(i,now,ne[now][0]+1){\n\t\t\tif(f>0) cout<<\"Possible\"<<endl;\n\t\t\telse cout<<\"Impossible\"<<endl;\n\t\t}\n\t\tnow=ne[now][0]+1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 200005\n#define YXQAK printf(\"Possible\\n\")\n#define XFZBL printf(\"Impossible\\n\");\nusing namespace std;\n\nint a[M]={0},n,m,v,l[20][M]={0},r[20][M]={0};\nint f[M]={0},g[M]={0},p[M]={0};\n\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",a+i);\n\tsort(a+1,a+n+1); \n\tfor(int j=0,V=v;V;j++,V>>=1){\n\t\tm=max(m,j);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint I=i+1;\n\t\t\twhile(I<=n&&a[I]-a[I-1]<=V) I++;\n\t\t\tI--;\n\t\t\tfor(int ii=i;ii<=I;ii++) \n\t\t\tl[j][ii]=i,r[j][ii]=I;\n\t\t\ti=I;\n\t\t}\n\t}\n\tm++; \n\tfor(int i=1;i<=n;i++) l[m][i]=r[m][i]=i;\n\tfor(int i=0;i<(1<<m);i++) g[i]=n; f[0]=1;\n\tfor(int i=1;i<(1<<m);i++){\n\t\tint now=1;\n\t\tfor(int j=m-1;~j;j--)\n\t\tif((1<<j)&i)\n\t\tf[i]=max(f[i],r[j+1][f[i^(1<<j)]]+1);\n\t\t\n\t\tnow=n;\n\t\tfor(int j=m-1;~j;j--)\n\t\tif((1<<j)&i)\n\t\tg[i]=min(g[i],l[j+1][g[i^(1<<j)]]-1);\n\t}\n\t\n\tfor(int i=0;i<(1<<m);i++){\n\t\tif(r[0][f[i]]+1>=g[(1<<m)-i-1])\n\t\tp[f[i]]++,p[r[0][f[i]]+1]--;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tp[i]+=p[i-1];\n\t\tif(p[i]) YXQAK;\n\t\telse XFZBL;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define ri register int\nusing namespace std;\n\nconst int N = 2e5 + 50;\n\nint n, v, m;\nint a[N], f[N], g[N];\nint lb[N], rb[N], ans[N];\nint pre[1 << 18 | 5][18], nxt[1 << 18 | 5][18];\n\nint main() {\n  scanf(\"%d%d\", &n, &v);\n  for (int i = 1; i <= n; i ++) scanf(\"%d\", &a[i]);\n  for (int t = v; t; t >>= 1) m ++;\n  for (int j = 0; j < m; j ++)\n    nxt[n + 1][j] = n + 1;\n  lb[0] = 1; rb[n + 1] = n;\n  for (ri i = 1; i <= n; i ++) {\n    lb[i] = (a[i] - a[i - 1] > v) ? i : lb[i - 1];\n    for (ri j = 1; j < m; j ++)\n      pre[i][j] = ((a[i] - a[i - 1]) > (v >> j)) ? i - 1 : pre[i - 1][j];\n  }\n  for (ri i = n; i; i --) {\n    rb[i] = (a[i + 1] - a[i] > v) ? i : rb[i + 1];\n    for (ri j = 1; j < m; j ++)\n      nxt[i][j] = ((a[i + 1] - a[i]) > (v >> j)) ? i + 1 : nxt[i + 1][j];\n  }\n  for (ri i = 0, l, r; i < (1 << m); i += 2) {\n    l = 1; r = n;\n    for (ri j = 1; j < m; j ++)\n      if ((i >> j) & 1) {\n\tl = max(l, nxt[f[i ^ (1 << j)]][j]);\n\tr = min(r, pre[g[i ^ (1 << j)]][j]);\n      }\n    f[i] = l; g[i] = r;\n  }\n  int U = \n  for (ri i = 0; i < (1 << m); i += 2) {\n    \n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define RI register int\nint read() {\n\tint q=0,w=1;char ch=' ';\n\twhile(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n\tif(ch=='-') w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();\n\treturn q*w;\n}\nconst int N=200005,LIM=524290,inf=0x3f3f3f3f;\nint n,V,m;\nint bin[21],x[N],L[N],f[LIM],g[LIM],in[21][N],ans[N],mi[N];\nvector<int> seg[21];\n\nvoid prework() {\n\tseg[m].push_back(0);\n\tfor(RI i=2;i<=n;++i)\n\t\tif(x[i]-x[i-1]>V) seg[m].push_back(i-1);\n\tseg[m].push_back(n);\n\tint now=1;\n\tfor(RI i=1;i<seg[m].size();++i)\n\t\twhile(now<=seg[m][i]) in[m][now]=i,++now;\n}\nvoid work1() {\n\tfor(RI i=0;i<bin[m]-1;++i) {\n\t\tfor(RI j=0;j<m;++j)\n\t\t\tif(!(i&bin[j]))\n\t\t\t\tf[i|bin[j]]=max(f[i|bin[j]],seg[j+1][in[j+1][f[i]+1]]);\n\t}\n}\nvoid work2() {\n\tfor(RI i=0;i<bin[m];++i) g[i]=n+1;\n\tfor(RI i=0;i<bin[m]-1;++i) {\n\t\tfor(RI j=0;j<m;++j)\n\t\t\tif(!(i&bin[j]))\n\t\t\t\tg[i|bin[j]]=min(g[i|bin[j]],seg[j+1][in[j+1][g[i]-1]-1]+1);\n\t}\n}\nvoid work3() {\n\tfor(RI i=0;i<=n;++i) mi[i]=inf;\n\tfor(RI i=0;i<bin[m];++i)\n\t\tmi[f[i]]=min(mi[f[i]],g[(bin[m]-1)^i]);\n\tfor(RI i=n-1;i>=0;--i) mi[i]=min(mi[i],mi[i+1]);\n}\n\nint main()\n{\n\tn=read(),V=read();\n\tbin[0]=1;for(RI i=1;i<=20;++i) bin[i]=bin[i-1]<<1;\n\tfor(RI i=1;i<=n;++i) x[i]=read();\n\tprework();while(V) V>>=1,++m,prework();\n\twork1(),work2(),work3();\n\tfor(RI i=1;i<seg[0].size();++i) {\n\t\tint L=seg[0][i-1]+1,R=seg[0][i];\n\t\tif(mi[L-1]<=R+1) for(RI j=L;j<=R;++j) ans[j]=1;\n\t}\n\tfor(RI i=1;i<=n;++i) puts(ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint x[252521];\nint ne[252521][20],rne[252521][20];\nint dp[(1<<20)+10],rdp[(1<<20)+10];\nvector<int> v;\nint main()\n{\n\tint n,V;\n\tcin>>n>>V;\n\trep(i,n) cin>>x[i];\n\twhile(V>0){\n\t\tv.pb(V);V/=2;\n\t}\n\tv.pb(0);int m=v.size();\n\trep(i,n) rep(j,m){\n\t\trne[i][j]=i;\n\t\tif(i>0 && x[i]-x[i-1]<=v[j]) rne[i][j]=rne[i-1][j];\n\t}\n\tfor(int i=n-1;i>=0;i--) rep(j,m){\n\t\tne[i][j]=i;\n\t\tif(i<n-1 && x[i+1]-x[i]<=v[j]) ne[i][j]=ne[i+1][j];\n\t}\n\tmemset(dp,0,sizeof(dp));\n\trep(i,(1<<20)+5) rdp[i]=n-1;\n\trep(i,(1<<m)) rep(j,m){\n\t\tif((i&(1<<j))>0) continue;\n\t\tdp[i+(1<<j)]=max(dp[i+(1<<j)],ne[dp[i]][j]+1);\n\t\trdp[i+(1<<j)]=min(rdp[i+(1<<j)],rne[rdp[i]][j]-1);\n\t}\n\t//rep(i,(1<<m)) cout<<i<<' '<<dp[i]<<' '<<rdp[i]<<endl;\n\tif(rdp[(1<<m)-1]>=0){\n\t\t//assert(dp[(1<<m)-1]<n && rdp[(1<<m)-1]>=0);\n\t\trep(i,n) cout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tint now=0;\n\twhile(now<n){\n\t\tint f=0;\n\t\trep(i,(1<<(m-1))){\n\t\t\tif(dp[(1<<m)-2-(i<<1)]>=now && rdp[(i<<1)]<=ne[now][0]) f=1;\n\t\t}\n\t\tREP(i,now,ne[now][0]+1){\n\t\t\tif(f>0) cout<<\"Possible\"<<endl;\n\t\t\telse cout<<\"Impossible\"<<endl;\n\t\t}\n\t\tnow=ne[now][0]+1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ld, ld> pdd;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define fastIO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\nconst int N = (int)2e5 + 9;\nconst int K = 20;\n\nint dpL[1 << K];\nint dpR[1 << K];\nint x[N];\n\nint pl[K][N];\nint pr[K][N];\n\nint cnt[N];\n\nvoid update(int cl, int cr){\n    cnt[cl] ++ ;\n    cnt[cr + 1] -- ;\n}\n\nint main(){\n    fastIO;\n    int n, k;\n    cin >> n >> k;\n    for(int i = 1; i <= n; i ++ ){\n        cin >> x[i];\n    }\n    vector<int> vl;\n    while(k > 0){\n        vl.push_back(k);\n        k /= 2;\n    }\n    vl.push_back(0);\n    reverse(vl.begin(), vl.end());\n    int m = vl.size();\n    int z = (1 << m);\n    for(int i = 0 ; i < m ; i ++ ){\n        pl[i][1] = 1;\n        for(int j = 2; j <= n; j ++ ){\n            pl[i][j] = pl[i][j-1];\n            if(x[j] - x[j - 1] > vl[i]){\n                pl[i][j] = j;\n            }\n        }\n        pr[i][n] = n;\n        for(int j = n - 1; j >= 1; j -- ){\n            pr[i][j] = pr[i][j+1];\n            if(x[j + 1] - x[j] > vl[i]){\n                pr[i][j] = j;\n            }\n        }\n    }\n    for(int i = 0 ; i < z; i ++ )\n        dpL[i] = 0, dpR[i] = n + 1;\n    int mask;\n    for(int i = 0 ; i < z; i ++ ){\n        for(int j = 0 ; j < m; j ++ ){\n            if(i & (1 << j)) continue;\n            mask = i | (1 << j);\n            if(dpL[i] == n) dpL[mask] = n;\n            else dpL[mask] = max(dpL[mask], pr[j][dpL[i] + 1]);\n        }\n    }\n    for(int i = 0 ; i < z; i ++ ){\n        for(int j = 0 ; j < m ; j ++ ){\n            if(i & (1 << j)) continue;\n            mask = i | (1 << j);\n            if(dpR[i] == 1) dpR[mask] = 1;\n            else dpR[mask] = min(dpR[mask], pl[j][dpR[i] - 1]);\n        }\n    }\n    int oth;\n    int L, R;\n    for(int i = 0 ; i < (1 << (m - 1)); i ++ ){\n        oth = (1 << (m - 1)) - i - 1; \n        L = dpL[i];\n        R = dpR[oth];\n        if(R-L <= 2){\n            update(1, n);\n        }\n        else{\n            if(pr[m - 1][L + 1] >= R-1){\n                update(pl[m - 1][L + 1], pr[m - 1][L + 1]);\n            }\n        }\n    }\n    for(int i = 1; i <= n; i ++ ){\n        cnt[i] += cnt[i - 1];\n        if(cnt[i] > 0)\n            cout << \"Possible\\n\";\n        else\n            cout << \"Impossible\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FI(i,a,b) for(int i=(a);i<=(b);i++)\n#define FD(i,a,b) for(int i=(a);i>=(b);i--)\n\n#define LL long long\n#define Ldouble long double\n#define PI 3.1415926535897932384626\n\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\nint n, v, s[200005], pt, previous_pt = 1, p;\nint fr[200005][20], dv[20];\n\nvoid gen(int l, int r, int V){\n//\tprintf(\"[%d %d %d]\\n\", l, r, V);\n\tFI(i, l, r){\n\t\tif(V) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n\treturn;\n}\n\nint dp[1111111];\n\nbool res(int X){\n\tFI(i, 0, (1 << p + 1) - 1) dp[i] = -1;\n\tdp[0] = 0;\n\tFI(i, 0, (1 << p + 1) - 1){\n\t\tif(dp[i] == -1) continue;\n\t\tFI(j, 0, p){\n\t\t\tif(i & (1 << j)){}\n\t\t\telse{\n\t\t\t\tif(j == 0 && dp[i] + 1 != X) continue;\n\t\t\t\tif(j != 0 && dp[i] + 1 == X) continue;\n\t\t\t\tdp[i + (1 << j)] = max(dp[i + (1 << j)], fr[dp[i] + 1][j]);\n\t\t\t}\n\t\t}\n\t}\n\tFI(i, 0, (1 << p + 1) - 1) if(dp[i] == n) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &v);\n\tFI(i, 1, n) scanf(\"%d\", &s[i]);\n\tFI(i, 2, n) if(s[i] - s[i - 1] > v) pt++;\n\t\n\tdv[0] = v;\n\twhile(dv[p]){\n\t\tdv[p + 1] = dv[p];\n\t\tdv[++p] /= 2;\n\t}\n\t\n\tFI(i, 0, p){\n\t\tint q = 1;\n\t\tFI(j, 1, n){\n\t\t\tq = max(q, j);\n\t\t\twhile(q < n && s[q + 1] - s[q] <= dv[i]) q++;\n\t\t\tfr[j][i] = q;\n\t\t}\n\t\tfr[n + 1][i] = n;\n\t}\n\t\n\tif(pt >= 20){\n\t\tFI(i, 1, n) printf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tFI(i, 2, n) if(s[i] - s[i - 1] > v){\n\t\tgen(previous_pt, i - 1, res(previous_pt));\n\t\tprevious_pt = i;\n\t}\n\tgen(previous_pt, n, res(previous_pt));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define ins insert\n#define pii pair<int,int>\n#define fs first\n#define sc second\n#define mpr make_pair\n#define iter iterator\n#define all(X) X.begin(),X.end()\n#define sau(X) sort(all(X)),X.resize(unique(all(X))-X.begin())\n#define exist(X,ele) binary_search(all(X),ele)\n\ntemplate<typename T1,typename T2>\nostream& operator << (ostream& out,const pair<T1,T2>& X)\n{\n\tout<<\"{\"<<X.fs<<\",\"<<X.sc<<\"}\";\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& out,const vector<T>& X)\n{\n\tfor(auto i:X) out<<i<<\" \";\n\treturn out;\n}\n\ninline void cmin(int& x,int y)\n{\n\tx=min(x,y);\n}\n\ninline void cmax(int& x,int y)\n{\n\tx=max(x,y);\n}\n\nconst int inf=5000000000000000ll;\n\nint N,V;\nvector<int> a;\nint p[20][200010];\nint nxt[20][200010][2];\nbool ans[200010];\nint cnt=0;\n\ninline string t(int x)\n{\n\tstring res=\"\";\n\tfor(int i=0;i<=5;i++)\n\t{\n\t\tres+=(bool)(x&(1<<i))+'0';\n\t}\n\treturn res;\n}\n\ninline bool solve(int L,int R,int U)\n{\n//\tcout<<\"  Solving \"<<setw(4)<<left<<L<<setw(4)<<left<<R<<t(U)<<endl;\n\t\n\tvector<int> v;\n\tfor(int i=0;i<=cnt;i++)\n\t{\n\t\tif(U&(1<<i)) v.pb(i);\n\t}\n\tint U2=(1<<(int)v.size())-1;\n\tvector<int> dp((1<<(int)v.size()),-1);\n\tdp[0]=L;\n\tfor(int msk=0;msk<=U2;msk++)\n\t{\n\t\tif(dp[msk]==-1) continue;\n\t\tfor(int j=0;j<v.size();j++)\n\t\t{\n\t\t\tif(!(msk&(1<<j)))\n\t\t\t{\n\t\t\t\tcmax(dp[msk|(1<<j)],dp[msk]);\n\t\t\t\tcmax(dp[msk|(1<<j)],nxt[v[j]][dp[msk]][0]);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int msk=0;msk<=U2;msk++)\n//\t{\n//\t\tcout<<\"msk=\"<<t(msk)<<\" dp[msk]=\"<<dp[msk]<<endl;\n//\t}\n//\tcout<<\" Ret : \"<<(dp[U2]>R)<<endl;\n\treturn dp[U2]>R;\n}\n\nmain()\n{\n\tios::sync_with_stdio(false);\n\t\n\tcin>>N>>V;\n\tfor(int i=0,x;i<N;i++)\n\t{\n\t\tcin>>x;\n\t\ta.pb(x);\n\t}\n\tfor(int i=0,v=V,lv=-1;v!=lv;i++,lv=v,v/=2)\n\t{\n\t\tfor(int j=1;j<N;j++)\n\t\t{\n\t\t\tp[i][j]=p[i][j-1];\n\t\t\tif(a[j]-a[j-1]>v) p[i][j]++;\n\t\t}\n\t\tcnt++;\n\t}\n\tfor(int i=0,v=V,lv=-1;v!=lv;i++,lv=v,v/=2)\n\t{\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(j && p[i][j]==p[i][j-1])\n\t\t\t{\n\t\t\t\tnxt[i][j][0]=nxt[i][j-1][0];\n\t\t\t\tnxt[i][j][1]=nxt[i][j-1][1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnxt[i][j][0]=(upper_bound(p[i],p[i]+N,p[i][j])-p[i]);   // [j, )\n\t\t\tnxt[i][j][1]=(lower_bound(p[i],p[i]+N,p[i][j])-p[i])-1; // ( ,j]\n\t\t}\n//\t\tcout<<\"D=\"<<i<<endl;\n//\t\tfor(int j=0;j<N;j++) cout<<nxt[i][j][0]<<\" \"; cout<<endl;\n//\t\tfor(int j=0;j<N;j++) cout<<nxt[i][j][1]<<\" \"; cout<<endl;\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n//\t\tcout<<\"StartPos=\"<<i<<endl;\n\t\tif(i!=0 && nxt[0][i][0]==nxt[0][i-1][0])\n\t\t{\n\t\t\tans[i]=ans[i-1];\n\t\t\tcontinue;\n\t\t}\n\t\tans[i]=false;\n\t\tint U=((1<<(cnt+1))-2); \n\t\tfor(int mskL=0;mskL<=U;mskL++)\n\t\t{\n\t\t\tif(mskL&1) continue;\n\t\t\tint mskR=U^mskL;\n\t\t\tif(nxt[0][i][1]<0 && mskL) continue;\n\t\t\tif(nxt[0][i][0]>=N && mskR) continue;\n\t\t\tif(nxt[0][i][1]>=0 && nxt[0][i][0]<N && ((!mskL)||(!mskR)) ) continue;\n\t\t\tbool ok=true;\n\t\t\tif(nxt[0][i][1]>=0) ok&=solve(0,nxt[0][i][1],mskL);\n\t\t\tif(nxt[0][i][0]<N) ok&=solve(nxt[0][i][0],N-1,mskR);\n\t\t\tans[i]|=ok;\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(ans[i]) cout<<\"Possible\"<<endl;\n\t\telse cout<<\"Impossible\"<<endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n\n#define MAXN 200005\n#define MAXB 21\n\nusing namespace std;\n\nconst int INF = 1e9 + 2e6;\nint v[MAXN], n, m;\nint d[MAXN], up[MAXN][MAXB], down[MAXN][MAXB], pre[1 << MAXB], suf[1 << MAXB];\nint visit[MAXN];\n\nint read() {\n    char c = getchar();\n    int x = 0, s = 1;\n    while (!isdigit(c)) {\n        if (c == '-')\n            s = -1;\n        c = getchar();\n    }\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x * s;\n}\n\nvoid init() {\n    while (v[++m] >= 1)\n        v[m + 1] = v[m] >> 1;\n    d[0] = -INF;\n    d[n + 1] = INF;\n    for (int j = 1; j <= m; ++j) {\n        for (int i = 1; i <= n; ++i)\n            if (d[i] - d[i - 1] <= v[j])\n                up[i][j] = up[i - 1][j];\n            else\n                up[i][j] = i;\n        for (int i = n; i >= 1; --i)\n            if (d[i + 1] - d[i] <= v[j])\n                down[i][j] = down[i + 1][j];\n            else\n                down[i][j] = i;\n    }\n}\n\nvoid solve() {\n    memset(suf, 0x3f, sizeof(suf));\n    memset(pre, -0x3f, sizeof(pre));\n    suf[0] = n + 1;\n    pre[0] = 0;\n    int limit = (1 << m) - 1;\n    for (int s = 0; s <= limit; ++s) {\n        for (int i = 1; i <= m; ++i) {\n            if (s >> (i - 1) & 1)\n                continue;\n            int t = s | (1 << (i - 1));\n            if (pre[s] >= 0)\n                pre[t] = max(pre[t], down[pre[s] + 1][i]);\n            if (suf[s] <= n + 1)\n                suf[t] = min(suf[t], up[suf[s] - 1][i]);\n        }\n    }\n    for (int s = 1; s < limit; ++s) {\n        if (s & 1)\n            continue;\n        int t = limit ^ s ^ 1;\n        int a = up[suf[t] - 1][1], b = down[pre[s] + 1][1];\n        if (a <= b) {\n            ++visit[a];\n            --visit[b + 1];\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n        visit[i] = visit[i - 1] + visit[i];\n    for (int i = 1; i <= n; ++i)\n        if (visit[i])\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n}\n\nint main() {\n    n = read();\n    v[1] = read();\n    for (int i = 1; i <= n; ++i)\n        d[i] = read();\n    init();\n    solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <cstdio>\n#include <iostream>\n#include <cstdlib>\n\nnamespace IO\n{\n//    inline char gc()\n//    {\n//        static char s[1<<20|1]={0},*p1=s,*p2=s;\n//        return (p1==p2)&&(p2=(p1=s)+fread(s,1,1<<20,stdin),p1==p2)?EOF:*(p1++);\n//    }\n\tinline char gc() { return getchar(); }\n\tinline long long read()\n\t{\n\t\tlong long ret=0;bool flag=0;char c=gc();\n\t\twhile ((c<'0')|(c>'9')) flag ^= !(c^'-'),c=gc();\n\t\twhile ((c>='0')&(c<='9')) ret=(ret<<1)+(ret<<3)+(c^'0'),c=gc();\n\t\treturn flag?-ret:ret;\n \t}\n \tchar OutputAns[1<<20|1],*OutputCur = OutputAns;\n \tinline void output()\n \t{\n \t\tOutputCur -= fwrite(OutputAns,1,OutputCur - OutputAns,stdout);\n\t}\n\tinline void print(long long ans)\n\t{\n\t\tchar s[20]={0};\n\t\tif (OutputCur - OutputAns + sprintf(s,\"%lld\",ans) >> 20) output();\n\t\tOutputCur += sprintf(OutputCur,\"%lld\",ans);\n\t}\n\tinline void printc(char c)\n\t{\n\t\tif (OutputCur - OutputAns + 1 >> 20) output();\n\t\t*(OutputCur++) = c;\n\t}\n}\n\nusing IO::read;\nusing IO::print;\nusing IO::printc;\nusing IO::output;\n\nconst int M = 3e5 + 11;\n\nconst int INF = 1e9 + 7;\n\nint End[25][M], Fir[25][M], Dp1[M], Dp2[M], Pos[M], T[25];\n\nint n, lim, top, sumBlock;\n\ninline void Input()\n{\n\tn = read(), lim = read(); for (int i = 1;i <= n; ++i) Pos[i] = read();\n\tint tmp = lim; while (tmp) { T[top++] = tmp >> 1; tmp >>= 1; } T[top] = lim;\n}\n\ninline void Solve()\n{\n\tfor (int i = 0;i <= top; ++i)\n\t{\n\t\tFir[i][1] = 1;\n\t\tfor (int j = 2;j <= n; ++j)\n\t\t{\n\t\t\tif (Pos[j] - Pos[j - 1] <= T[i]) Fir[i][j] = Fir[i][j - 1];\n\t\t\telse Fir[i][j] = j;\n\t\t}\n\t}\n\tfor (int i = 0;i <= top; ++i)\n\t{\n\t\tEnd[i][n] = n;\n\t\tfor (int j = n - 1; j >= 1; --j)\n\t\t{\n\t\t\tif (Pos[j + 1] - Pos[j] <= T[i]) End[i][j] = End[i][j + 1];\n\t\t\telse { End[i][j] = j; if (i == top) ++sumBlock; }\n\t\t}\n\t} \n\tif (sumBlock > top)\n\t{\n\t\tfor (int i = 1;i <= n; ++i) puts(\"Impossible\");\n\t\texit(0);\n\t} int all = (1<<top);\n\tfor (int s = 0;s < all; ++s) Dp2[s] = n + 1;\n\tfor (int S = 0;S < all; ++S)\n\t\tfor (int i = 0;i <= top; ++i)\n\t\t\tif (!((1<<i) & S))\t\n\t\t\t\tDp1[S | (1<<i)] = std::max(Dp1[S | (1<<i)], End[i][Dp1[S] + 1]),\n\t\t\t\tDp2[S | (1<<i)] = std::min(Dp2[S | (1<<i)], Fir[i][Dp2[S] - 1]);\n\tfor (int i = 1;i <= n; ++i)\n\t{\n\t\tbool ok = 0;\n\t\tfor (int S = 0;S < all; ++S)\n\t\t{\n\t\t\tint ss = (all - 1) ^ S;\n\t\t\tif (Dp1[S] >= i - 1 && Dp2[ss] <= End[top][i] + 1) { ok = 1; break; }\n\t\t}\n\t\tfor (int j = i;j <= End[top][i]; ++j)\n\t\t{\n\t\t\tif (ok) puts(\"Possible\");\n\t\t\telse puts(\"Impossible\");\n\t\t} i = End[top][i];\n\t}\n}\n\nint main(void)\n{\n//\tfreopen(\"jump.in\",\"r\",stdin);\n///\tfreopen(\"jump.out\",\"w\",stdout);\n\tInput();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 65536*16\nint xi[nn];int n,v;\nvector<int> all;\nint tol[nn][20],tor[nn][20];\nint dpr[nn],dpl[nn],pre[nn];\nvoid _min(int&x,int y){\n\tx=min(x,y);\n}\nvoid _max(int&x,int y){\n\tx=max(x,y);\n}\nvoid build(){\n\tint u=v/2;while(u) all.push_back(u),u=u/2;all.push_back(0);\n\tfor(int i=0;i<all.size();i++){\n\t\ttol[0][i]=tol[1][i]=1;for(int j=2;j<=n;j++)\n\t\t\tif(all[i]>=xi[j]-xi[j-1]) tol[j][i]=tol[j-1][i];\n\t\t\telse tol[j][i]=j;\n\t\t\t\n\t\ttor[n+1][i]=tor[n][i]=n;for(int j=n-1;j>=1;j--)\n\t\t\tif(all[i]>=xi[j+1]-xi[j]) tor[j][i]=tor[j+1][i];\n\t\t\telse tor[j][i]=j;\n\t}\n\n\tmemset(pre,0x3f,sizeof pre);memset(dpl,0x3f,sizeof dpl);\n\tdpl[0]=n+1,dpr[0]=0;\n\tfor(int i=0;i<(1<<all.size());i++){\n\t\tfor(int j=0;j<all.size();j++) if((1<<j)&i);else{\n\t\t\t_min(dpl[i|(1<<j)],tol[dpl[i]-1][j]);\n\t\t\t_max(dpr[i|(1<<j)],tor[dpr[i]+1][j]);\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<(1<<all.size());i++)\n\t\t_min(pre[dpr[i]],dpl[((1<<all.size())-1)^i]);\n\tfor(int i=n-1;i>=0;i--) _min(pre[i],pre[i+1]);\n}\n\nint lb[nn],rb[nn];int pa[nn];\nint find(int x){\n\tif(pa[x]==x) return x;\n\treturn pa[x]=find(pa[x]);\n}\nvoid link(int x,int y){\n\tx=find(x),y=find(y);\n\tpa[x]=y;_min(lb[y],lb[x]);\n\t_max(rb[y],rb[x]);\n}\nsigned main(){\n\tscanf(\"%d%d\",&n,&v);for(int i=1;i<=n;i++) scanf(\"%d\",&xi[i]);sort(xi+1,xi+n+1);\n\tbuild();\n\t\n\tfor(int i=1;i<=n;i++) pa[i]=i,lb[i]=rb[i]=i;\n\tfor(int i=1;i<n;i++) if(xi[i+1]-xi[i]<=v) link(i,i+1);\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tint l=lb[find(i)],r=rb[find(i)];\n\t\tif(pre[l-1]<=r+1) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e5 + 100;\nconst int Maxm = 20 + 5;\nconst int Maxs = (1 << 20) + 100;\n\nint N, V, Log;\nint A[Maxn];\n\nint L[Maxm][Maxn], R[Maxm][Maxn];\nint Next[Maxn];\n\ninline void get_seg ()\n{\n\tfor (int i = 0; i <= Log; ++i)\n\t{\n\t\tint v = V >> i;\n//\t\tDEBUG (v);\n\t\tfor (int j = N; j >= 1; --j)\n\t\t{\n\t\t\tint p = upper_bound (A + 1, A + N + 1, A[j] + v) - A - 1;\n\t\t\tNext[j] = 0;\n\t\t\tNext[j] = max (Next[p], j);\n\t\t}\n\t\tfor (int l = 1, r = 0; l <= N; l = r + 1)\n\t\t{\n\t\t\tr = Next[l];\n\t\t\tL[i][++L[i][0]] = l, R[i][++R[i][0]] = r;\n\t\t}\n\t}\n}\n\nint f[Maxs], g[Maxs];\n\ninline void get_f ()\n{\n\tint ALL = (1 << Log) - 1;\n\tfor (int i = 0; i <= ALL; ++i)\n\t{\n\t\tint preR = f[i];\n\t\tfor (int j = 1; j <= Log; ++j)\n\t\t{\n\t\t\tif (i & (1 << (j - 1))) continue;\n\t\t\tint x = upper_bound (L[j] + 1, L[j] + L[j][0] + 1, preR + 1) - L[j] - 1;\n\t\t\tint nowR = max (preR, R[j][x]);\n\t\t\tChkmax (f[i | (1 << (j - 1))], nowR);\n\t\t}\n\t}\n}\n\ninline void get_g ()\n{\n\tint ALL = (1 << Log) - 1;\n\tfor (int i = 0; i <= ALL; ++i) g[i] = N + 1;\n\tfor (int i = 0; i <= ALL; ++i)\n\t{\n\t\tint preL = g[i];\n\t\tfor (int j = 1; j <= Log; ++j)\n\t\t{\n\t\t\tif (i & (1 << (j - 1))) continue;\n\t\t\tint x = lower_bound (R[j] + 1, R[j] + R[j][0] + 1, preL - 1) - R[j];\n\t\t\tint nowL = min (preL, L[j][x]);\n\t\t\tChkmin (g[i | (1 << (j - 1))], nowL);\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tget_seg ();\n\tget_f ();\n\tget_g ();\n\n\tif (L[0][0] > Log + 3) { for (int i = 1; i <= N; ++i) puts(\"Impossible\"); return ; }\n\n\tint ALL = (1 << Log) - 1;\n\tfor (int i = 1; i <= L[0][0]; ++i)\n\t{\n\t\tint l = L[0][i], r = R[0][i], fl = 0;\n\t\tfor (int j = 0; j <= ALL; ++j)\n\t\t\tif (l - 1 <= f[j] && g[ALL ^ j] <= r + 1)\n\t\t\t{\n\t\t\t\tfl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (fl) for (int j = l; j <= r; ++j) puts(\"Possible\");\n\t\telse for (int j = l; j <= r; ++j) puts(\"Impossible\");\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), V = read<int>(), Log = log2(V) + 1;\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, V);\n\tVEC(int, x, n);\n\tint height = 0;\n\twhile (V >= (1 << height)) ++height;\n\theight += 2;\n\tstd::vector<std::vector<int>> right(height);\n\tint vv = V;\n\tright[0].emplace_back(x[n - 1]);\n\tFOR(h, 1, height) {\n\t\tint r = n - 1;\n\t\tRREP(i, n - 1) {\n\t\t\tif (x[i + 1] - x[i] > vv || i == 0) {\n\t\t\t\tright[h].emplace_back(x[r]);\n\t\t\t\tr = i;\n\t\t\t}\n\t\t}\n\t\tif (x[1] - x[0] > vv) right[h].emplace_back(x[0]);\n\t\tstd::sort(ALL(right[h]));\n\t\tvv /= 2;\n\t}\n\n\tstd::vector<std::vector<int>> g(1);\n\tstd::map<PAIR, int> id;\n\tg.emplace_back(id[PAIR(0, x[n - 1])]);\n\tint p = 1;\n\tFOR(h, 1, height) {\n\t\tfor (auto v : right[h]) {\n\t\t\tid[PAIR(h, v)] = p++;\n\t\t\tauto it = std::lower_bound(ALL(right[h - 1]), v);\n\t\t\tint par = *it;\n\t\t\tg.emplace_back(std::vector<int>{});\n\t\t\tg[id[PAIR(h - 1, par)]].emplace_back(id[PAIR(h, v)]);\n\t\t\tg[id[PAIR(h, v)]].emplace_back(id[PAIR(h - 1, par)]);\n\t\t}\n\t}\n\n\t/*SHOWVECTOR2(right);\n\n\tREP(i, g.size()) {\n\t\tfor (auto to : g[i]) {\n\t\t\tOUT(i)SP OUT(to)BR;\n\t\t}\n\t}*/\n\n\tstd::set<int> v0;\n\tfor (auto v : g[0]) v0.insert(v);\n\tstd::function<bool(std::set<int>, int, int)> check = [&](std::set<int> a, int pos, int rest) {\n\t\t//SHOWVECTOR(a);\n\t\tif (rest == 0) return true;\n\t\tif (a.empty()) return true;\n\t\tstd::set<int> c;\n\t\tfor(auto v : a) {\n\t\t\tfor (auto to : g[v]) {\n\t\t\t\tif (v > to) continue;\n\t\t\t\tc.insert(to);\n\t\t\t}\n\t\t}\n\t\tfor(auto v : a) {\n\t\t\tif (pos != -1) v = pos;\n\t\t\tif (c.size() - g[v].size() + 1 > rest - 1) continue;\n\t\t\tauto ts(c);\n\t\t\tfor (auto to : g[v]) {\n\t\t\t\tif (v > to) continue;\n\t\t\t\tts.erase(to);\n\t\t\t}\n\t\t\tif (check(ts, -1, rest - 1)) return true;\n\t\t\tif (pos != -1) break;\n\t\t}\n\t\treturn false;\n\t};\n\n\tstd::vector<PAIR> ok;\n\tp = 0;\n\tfor (auto v : v0) {\n\t\tbool t = check(v0, v, height - 1);\n\t\tok.emplace_back(PAIR(right[1][p++], t));\n\t}\n\t//SHOWPAIRVECTOR(ok);\n\n\tp = 0;\n\tREP(i, n) {\n\t\tif (x[i] <= ok[p].first) {\n\t\t\tOUT(((ok[p].second) ? \"Possible\" : \"Impossible\"))BR;\n\t\t}\n\t\tif (x[i] == ok[p].first) ++p;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint l[21][530000],r[21][530000],f[530000],g[530000],mi[530000],x[530000];\nint main()\n{\n\tint n,v,lim=0;scanf(\"%d%d\",&n,&v);while (v>>(lim+1)) lim++;lim++;cerr<<(1<<(lim+1))<<endl;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor (int p=0;p<=lim;p++)\n\t{\n\t\tl[p][0]=1;for (int i=1;i<=n;i++) l[p][i]=(x[i]-x[i-1]<=(v>>p))?l[p][i-1]:i;\n\t\tr[p][n+1]=n;for (int i=n;i>=1;i--) r[p][i]=(x[i+1]-x[i]<=(v>>p))?r[p][i+1]:i;\n\t}\n\tfor (int s=0;s<(1<<(lim+1));s++) g[s]=n+1;\n\tfor (int s=0;s<(1<<(lim+1));s++)\n\tfor (int i=0;i<=lim;i++) if (!(s&(1<<i)))\n\t{\n\t\tf[s|(1<<i)]=max(f[s|(1<<i)],r[i][f[s]+1]);\n\t\tg[s|(1<<i)]=min(g[s|(1<<i)],l[i][g[s]-1]);\n\t}\n\tfor (int i=0;i<=n;i++) mi[i]=n+2;\n\tfor (int i=0;i<(1<<(lim+1));i+=2) mi[f[i]]=min(mi[f[i]],g[(1<<(lim+1))-2-i]);\n\tfor (int i=n-1;i>=0;i--) mi[i]=min(mi[i],mi[i+1]);\n\tfor (int i=1;i<=n;i++) puts((mi[l[0][i]-1]<=r[0][i]+1)?\"Possible\":\"Impossible\");\n\t//for (int i=1;i<=n;i++) printf(\"%d %d %d\\n\",l[0][i],r[0][i],mi[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//Indomie, Mie dari Indonesia\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <queue>\n#include <cstring>\nusing namespace std;\n#define pb push_back\nconst int LogN=18;\nconst int MAXN=200000;\nint n,air,jarak[(1<<(LogN))+5],terkanan[LogN+5][MAXN+5],terkiri[LogN+5][MAXN+5];\nint pos[MAXN+5],l,r,komponen;\nbool ans[MAXN+5];\nvector <int> daftarair;\nvoid isiair(int air){\n\twhile(air>0)\n\t\tdaftarair.pb(air),air/=2;\n\tdaftarair.pb(0);\n\tassert(daftarair.size()-1<=LogN);\n}\nvoid isiterkanan(int jenis){\n\tint last=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(pos[i]-pos[i-1]>daftarair[jenis])\n\t\t{\n\t\t\twhile(last!=i)\n\t\t\t{\n\t\t\t\tterkanan[jenis][last]=i-1;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t}\n\t}\n\twhile(last!=n+1)\n\t{\n\t\tterkanan[jenis][last]=n;\n\t\tlast++;\n\t}\n}\nvoid isiterkiri(int jenis){\n\tint last=n;\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tif(pos[i+1]-pos[i]>daftarair[jenis])\n\t\t{\n\t\t\twhile(last!=i)\n\t\t\t{\n\t\t\t\tterkiri[jenis][last]=i+1;\n\t\t\t\tlast--;\n\t\t\t}\n\t\t}\n\t}\n\twhile(last!=0)\n\t{\n\t\tterkiri[jenis][last]=1;\n\t\tlast--;\n\t}\n}\nvoid isiterkanan(){\n\tfor(int i=0;i<daftarair.size();i++)\n\t\tisiterkanan(i);\n}\nvoid isiterkiri(){\n\tfor(int i=0;i<daftarair.size();i++)\n\t\tisiterkiri(i);\n}\nint totalkomponen(){\n\tint ret=0;\n\tint now=1;\n\twhile(now<=n)\n\t{\n\t\tret++;\n\t\tnow=terkanan[0][now];\n\t\tnow++;\n\t}\n\treturn ret;\n}\nbool bfs(){\n\tqueue <int> cari;\n\tmemset(jarak,-1,sizeof(jarak));\n\tjarak[0]=1;\n\tif(l<=jarak[0]&&jarak[0]<=r)\n\t\tjarak[0]=r+1;\n\tcari.push(0);\n\twhile(!cari.empty())\n\t{\n\t\t//cout<<\"bfs\"<<endl;\n\t\tint u=cari.front();\n\t\tif(jarak[u]>n)\n\t\t{\n\t\t\t//cout<<\"terkanannya \"<<jarak[u]<<endl;\n\t\t\treturn true;\n\t\t}\n\t\tcari.pop();\n\t\t//cout<<u<<endl;\n\t\tfor(int i=1;i<daftarair.size();i++)\n\t\t{\n\t\t\tif(u&(1<<(i-1)))\n\t\t\t\tcontinue;\n\t\t\tint v=(u|(1<<(i-1)));\n\t\t\tint nextpos=terkanan[i][jarak[u]]+1;\n\t\t\tif(l<=nextpos&&nextpos<=r)\n\t\t\t\tnextpos=r+1;\n\t\t\tif(jarak[v]==-1)\n\t\t\t{\n\t\t\t\tjarak[v]=nextpos;\n\t\t\t\tcari.push(v);\n\t\t\t}\n\t\t\telse\n\t\t\t\tjarak[v]=max(jarak[v],nextpos);\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&air);\n\tisiair(air);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&pos[i]);\n\tisiterkanan();\n\tisiterkiri();\n\tkomponen=totalkomponen();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\t//cout<<\"loop \"<<i<<endl;\n\t\tif(komponen>daftarair.size())\n\t\t{\n\t\t\tans[i]=false;\n\t\t}\n\t\telse if(i!=1&&terkanan[0][i]==terkanan[0][i-1])\t\t\t//in the same komponen\n\t\t{\n\t\t\tans[i]=ans[i-1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl=terkiri[0][i];\n\t\t\tr=terkanan[0][i];\n\t\t\tif(bfs())\n\t\t\t\tans[i]=true;\n\t\t\telse\n\t\t\t\tans[i]=false;\n\t\t}\n\t\tif(ans[i])\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint K, N, V, sz[20], x[200009], maxPref[200009], pf[200009], sf[200009], lft[18][200009], rgt[18][200009];\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\", &N, &V);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &x[i]);\nfor (int i=0; (1 << i) <= V; i++)\n    sz[i] = V >> i, K = i;\nsz[++K] = 0;\nfor (int i=0; i<=K; i++)\n{\n    lft[i][1] = 1, lft[i][0] = 0;\n    for (int j=2; j<=N; j++)\n        if (x[j] - x[j - 1] <= sz[i]) lft[i][j] = lft[i][j - 1];\n        else lft[i][j] = j;\n    rgt[i][N] = N, rgt[i][N + 1] = N + 1;\n    for (int j=N - 1; j>=1; j--)\n        if (x[j + 1] - x[j] <= sz[i]) rgt[i][j] = rgt[i][j + 1];\n        else rgt[i][j] = j;\n}\nint lim = 1 << K;\nfor (int i=0; i < lim; i++)\n    sf[i] = N + 1;\nfor (int msk = 0; msk < lim; msk ++)\n    for (int i=0; i<K; i++)\n        if ((msk & (1 << i)) == 0)\n            pf[msk | (1 << i)] = max (pf[msk | (1 << i)], (pf[msk] <= N ? rgt[i + 1][pf[msk] + 1] : N + 1)),\n            sf[msk | (1 << i)] = min (sf[msk | (1 << i)], (sf[msk] >= 1 ? lft[i + 1][sf[msk] - 1] : 0));\nfor (int i=0; i<=N + 1; i++)\n    maxPref[i] = -N;\nfor (int i=0; i<lim; i++)\n    maxPref[sf[i]] = max (maxPref[sf[i]], pf[(lim - 1) ^ i]);\nfor (int i=1; i<=N + 1; i++)\n    maxPref[i] = max (maxPref[i - 1], maxPref[i]);\nfor (int i=1; i<=N; i++)\n    if (maxPref[rgt[0][i] + 1] >= lft[0][i] - 1) printf (\"Possible\\n\");\n    else printf (\"Impossible\\n\");\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)\n#define trav(it, v) for(typeof((v).begin()) it = (v).begin(); it != (v).end(); ++it)\n#define all(v) (v).begin(), (v).end()\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n\ntypedef double fl;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\t\nint N, V;\nint x[200005];\nint nodeInd;\n\nstruct Node{\n\tint l, r;\n\tint v;\n\tvector<Node> children;\n\tint ind;\n\tint stepsUntilSplit;\n\n\tNode(int _l, int _r, int _v){\n\t\tind=nodeInd++;\n\t\tl=_l;\n\t\tr=_r;\n\t\tv=_v;\n\t\tstepsUntilSplit=1000000;\n\t\tif(!v){\n\t\t\treturn;\n\t\t}\n\t\tint L=l;\n\t\trep(i,l+1,r){\n\t\t\tif(x[i] > x[i-1]+v){\n\t\t\t\tchildren.push_back(Node(L, i, v/2));\n\t\t\t\tL=i;\n\t\t\t}\n\t\t}\n\t\tchildren.push_back(Node(L, r, v/2));\n\t\tstepsUntilSplit=min(stepsUntilSplit, children.back().stepsUntilSplit+1);\n\t\tif(children.size() > 1)\n\t\t\tstepsUntilSplit=0;\n\t}\n};\n\nbool ans[200005];\nmap<vector<int>, bool> cache;\nvector<Node*> deleted;\n\nbool rec(vector<Node*> nodes, int stepsLeft, bool init){\n\tif(deleted.size() >= 2){\n\t\tNode* d1 = deleted[deleted.size()-2];\n\t\tNode* d2 = deleted[deleted.size()-1];\n\t\tif(d1->stepsUntilSplit > d2->stepsUntilSplit+1)\n\t\t\treturn false;\n\t\tif(d1->stepsUntilSplit == d2->stepsUntilSplit+1 && d1->l > d2->l)\n\t\t\treturn false;\n\t}\n\tvector<int> key;\n\trep(i,0,nodes.size()){\n\t\tkey.push_back(nodes[i]->ind);\n\t}\n\tif(cache.count(key))\n\t\treturn cache[key];\n\tif(nodes.empty())\n\t\treturn true;\n\tif(nodes[0]->v == 0)\n\t\treturn nodes.size() == 1;\n\tvector<Node*> newNodes;\n\trep(i,0,nodes.size()){\n\t\tif(newNodes.size()+nodes[i]->children.size() > stepsLeft)\n\t\t\treturn 0;\n\t\trep(j,0,nodes[i]->children.size())\n\t\t\tnewNodes.push_back(&(nodes[i]->children[j]));\n\t}\n\t/*bool hasUrgent=false;\n\trep(i,0,newNodes.size())\n\t\tif(newNodes[i]->children.size() > 1)\n\t\t\thasUrgent = true;*/\n\trep(i,0,newNodes.size()){\n\t\tvector<Node*> newNewNodes = newNodes;\n\t\tnewNewNodes.erase(newNewNodes.begin()+i);\n\t\tdeleted.push_back(newNodes[i]);\n\t\tif(rec(newNewNodes, stepsLeft-1, 0)){\n\t\t\tif(init){\n\t\t\t\trep(j,newNodes[i]->l,newNodes[i]->r)\n\t\t\t\t\tans[j]=true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcache[key]=true;\n\t\t\t\tdeleted.pop_back();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tdeleted.pop_back();\n\t}\n\tcache[key]=false;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\", &N, &V);\n\trep(i,0,N)\n\t\tscanf(\"%d\", x+i);\n\tNode start(0, N, V);\n\tvector<Node*> v;\n\tv.push_back(&start);\n\tint stepsLeft=20;\n\trec(v,stepsLeft,1);\n\trep(i,0,N){\n\t\tputs(ans[i]?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 1000000\n#define INF 2000000000\nusing namespace std;\nint n,V,x[MAXN+5];\nint cnt[25];\nint l[25][MAXN+5],r[25][MAXN+5];\nint f1[MAXN*5+5],f2[MAXN*5+5];//如思路中的定义\nbool ans[MAXN+5];//ans记录的是对于某一条线段的答案，不是某个绿洲的答案\nvoid Init()\n{\n\tfor(int i=0;i<=MAXN*5+3;i++)\n\t\tf1[i]=0,f2[i]=INF;\n}\nint UpFind(int id,int pos)//找l在pos+1的左边的线段，也就是能够向右扩展的最靠右的线段\n{\n\tpos++;\n\tint p=upper_bound(l[id]+1,l[id]+cnt[id]+1,pos)-l[id];\n\tp--;\n\tif(p<=0)\n\t\treturn pos;\n\treturn max(r[id][p],pos-1);\n}\nint LowFind(int id,int pos)//找r在pos-1的右边的线段，也就是能够向左扩展的最靠左的线段\n{\n\tpos--;\n\tint p=lower_bound(r[id]+1,r[id]+cnt[id]+1,pos)-r[id];\n\tif(p>=cnt[id]+1)\n\t\treturn pos;\n\treturn min(l[id][p],pos+1);\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d %d\",&n,&V);\n\tint logV=0;\n\tfor(logV=0;(1<<logV)<=V;logV++);//求出来的实际上是logV+1\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tx[n+1]=INF;\n\tx[0]=-INF;//便于操作\n\tfor(int LG=0;LG<=logV;LG++)\n\t{\n\t\tint d=V/(1<<LG);\n\t\tcnt[LG]=1;\n\t\tl[LG][1]=1;\n\t\t//求线段\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tr[LG][cnt[LG]]=i;\n\t\t\tif(x[i+1]-x[i]>d)\n\t\t\t{\n\t\t\t\tcnt[LG]++;\n\t\t\t\tl[LG][cnt[LG]]=i+1;\n\t\t\t}\n\t\t}\n\t\tcnt[LG]--;\n\t}\n\tif(cnt[0]>logV+1)//特判\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint all=(1<<(logV+1));\n\tf1[0]=0,f2[0]=n+1;//预处理两个f数组\n\tfor(int s=0;s<all;s+=2)\n\t\tfor(int i=0;i<=logV;i++)\n\t\t{\n\t\t\tif(!(s&(1<<i)))\n\t\t\t\tcontinue;\n\t\t\tf1[s]=max(f1[s],UpFind(i,f1[s-(1<<i)]));\n\t\t\tf2[s]=min(f2[s],LowFind(i,f2[s-(1<<i)]));\n\t\t}\n\tfor(int i=1;i<=cnt[0];i++)\n\t{\n\t\tint ln=l[0][i],rn=r[0][i];\n\t\tfor(int s1=0;s1<all;s1+=2)\n\t\t{\n\t\t\tint s2=all-1-s1-1;\n\t\t\tint lpos=f1[s1];\n\t\t\tint rpos=f2[s2];\n\t\t\tif(lpos>=ln-1&&rpos<=rn+1)\n\t\t\t{\n\t\t\t\tans[i]=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint pos=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(ans[pos]==true)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t\tif(x[i+1]-x[i]>V)\n\t\t\tpos++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAXN 200010\n#define MAXS 1000010\nusing namespace std;\n\nint read(){\n\tchar c;\n\twhile(((c=getchar())<'0' || c>'9') && c!='-');\n\tint flag=1;\n\tint res=c-'0';\n\tif(c=='-'){\n\t\tflag=-1;\n\t\tres=0;\n\t}\n\twhile((c=getchar())>='0' && c<='9') res=res*10+c-'0';\n\treturn res*flag;\n}\n\nint n,m,v0,maxs;\nint a[MAXN];\nint lim[MAXN];\nint f1[MAXS],f2[MAXS];\nint p[20][MAXN][2];\n\nvoid calcP(int l){\n\tint last=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i==n || a[i+1]-a[i]>lim[l]){\n\t\t\tfor(int j=last;j<=i;j++){\n\t\t\t\tp[l][j][0]=last;\n\t\t\t\tp[l][j][1]=i;\n\t\t\t}\n\t\t\tlast=i+1;\n\t\t}\n\t}\n\tp[l][0][0]=1;\n\tp[l][n+1][1]=n;\n}\n\nvoid dp(){\n\tf1[0]=0; f2[0]=n+1;\n\tfor(int s=1;s<maxs;s++){\n\t\tf2[s]=n+1;\n\t\tfor(int i=1,l=1;i<=m;i++,l<<=1)\n\t\t\tif(s&l){\n\t\t\t\tf1[s]=max(f1[s],p[i][f1[s^l]+1][1]);\n\t\t\t\tf2[s]=min(f2[s],p[i][f2[s^l]-1][0]);\n\t\t\t}\n\t}\n}\n\nnamespace Fenwick{\n\tint c[MAXN];\n\n\tvoid init(){ memset(c,-1,sizeof c); }\n\n\tvoid insert(int x,int y){\n\t\tx++;\n\t\twhile(x<=n+2){\n\t\t\tc[x]=max(c[x],y);\n\t\t\tx+=x&(-x);\n\t\t}\n\t}\n\n\tint getmax(int x){\n\t\tx++;\n\t\tint res=-1;\n\t\twhile(x){\n\t\t\tres=max(res,c[x]);\n\t\t\tx-=x&(-x);\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"g012e.in\",\"r\",stdin);\n#endif\n\tn=read(); v0=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tlim[0]=v0;\n\twhile(v0) lim[++m]=(v0/=2);\n\tmaxs=1<<m;\n\tfor(int i=0;i<=m;i++) calcP(i);\n\tdp();\n\tFenwick::init();\n\tfor(int i=0;i<maxs;i++)\n\t\tFenwick::insert(f2[i],f1[(maxs-1)^i]);\n\tfor(int i=1;i<=n;i++)\n\t\tif(p[0][i][0]==i){\n\t\t\tint res=Fenwick::getmax(p[0][i][1]+1);\n\t\t\tif(res>=i-1)\n\t\t\t\tfor(int j=p[0][i][0];j<=p[0][i][1];j++)\n\t\t\t\t\tputs(\"Possible\");\n\t\t\telse\n\t\t\t\tfor(int j=p[0][i][0];j<=p[0][i][1];j++)\n\t\t\t\t\tputs(\"Impossible\");\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=262444,M=22,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ntemplate<class T> inline void read(T &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ntemplate<class T> inline void print(T x){\n\tif(!x){puts(\"0\");return;}\n\tif(x<0){putchar('-');x=-x;}\n\tint a[20],m=0;\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');puts(\"\");\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,a[N],v[20],cnt[20],L[20][N],R[20][N],bel[N],si[N],ans[N];\nmap<pair<int,pii>,bool> dp[20];\n\n\nvoid dfs(int x,int l,int r){\n//\tprintf(\"%d %d %d\\n\",x,l,r);\n\tif(x==m) return;\n\tfor(int i=l;i<=r;i++){\n\t\tint t=i;\n\t\twhile(t<r&&a[t+1]-a[t]<=v[x]) t++;\n\t\tL[x][++cnt[x]]=cnt[x+1]+1;\n\t\tdfs(x+1,i,t);\n\t\tR[x][cnt[x]]=cnt[x+1];\n\t\tif(!x){\n\t\t\tfor(int j=i;j<=t;j++)\n\t\t\t\tbel[j]=cnt[x];\n\t\t}i=t;\n\t}\n}\nbool get(int x,int l,int r,int st){\n//\tprintf(\"%d %d %d %d\\n\",x,l,r,st);\n\tif(l>r) return 1;\n\tif(si[st]<=r-l||x==m) return 0;\n\tif(!(st&(1<<x))) return get(x+1,l,r,st);\n\tif(dp[x].count(mp(st,mp(l,r)))) return dp[x][mp(st,mp(l,r))];\n\tbool ans=0;\n\tfor(int i=l;i<=r;i++){\n\t\tint u=st^(1<<x);\n\t\tif(R[x][i-1]-L[x][l]+R[x][r]-L[x][i+1]+2>si[u]) continue;\n\t\tfor(int j=u;j;j=(j-1)&u)\n\t\t\tif(get(x+1,L[x][l],R[x][i-1],j)&&get(x+1,L[x][i+1],R[x][r],u^j)){ans=1;break;}\n\t\tif(get(x+1,L[x][l],R[x][i-1],0)&&get(x+1,L[x][i+1],R[x][r],u)) ans=1;\n\t\tif(ans) break;\n\t}\n\tdp[x][mp(st,mp(l,r))]=ans;\n\treturn ans;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tsrand(time(0));\n#endif\n\tios::sync_with_stdio(0);\n\tread(n);read(v[0]);\n\tfor(int i=1;i<=n;i++) read(a[i]);\n\tfor(int j=1;v[j-1];j++,m=j) v[j]=v[j-1]>>1;\n\tdfs(0,1,n);\n//\tdebuge;\n\tif(cnt[0]>m){\n\t\tfor(int i=1;i<=n;i++) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<m;i++)\n\t\tL[i][cnt[i]+1]=R[i][cnt[i]+1]=cnt[i+1]+1;\n\tfor(int i=1;i<(1<<m);i++) si[i]=si[i^(i&-i)]+1;\n//\tdebug(cnt[1]);\n//\tdebug(cnt[0]);\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tint u=(1<<m)-2;\n\t\tfor(int j=0;j<(1<<m);j+=2)\n\t\t\tif(get(1,L[0][1],R[0][i-1],j)&&get(1,L[0][i+1],R[0][cnt[0]],u^j)){ans[i]=1;break;}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(ans[bel[i]])puts(\"Possible\"); else puts(\"Impossible\");\n#ifdef rqgao2014\n\ttime_tester(1);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Camel and Oases\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint const N=1e5+10;\nint const S=1<<17;\nint n,V;\nint d[N];\nint logV,a[20][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n    }\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nint main()\n{\n    freopen(\"e.in\",\"r\",stdin);\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%d\",&d[i]),d[i-1]=d[i]-d[i-1];\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++) printf(\"Impossible\\n\");\n        return 0;\n    }\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=1,f2[s]=n;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1 && f2[U-s-1]-1<=to) f=true;\n        if(f) for(int j=fr;j<=to;j++) printf(\"Possible\\n\");\n        else for(int j=fr;j<=to;j++) printf(\"Impossible\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10;\nint n,v[20],x[N],dep,dpl[N],dpr[N];\nint blo[20][N],L[20][N],R[20][N];\nvoid init(int dep){\n\tint cnt=0;\n\tblo[dep][1]=L[dep][1]=R[dep][1]=cnt=1;\n\tfor (int i=2;i<=n;i++){\n\t\tif (x[i-1]+v[dep]>=x[i]) blo[dep][i]=cnt,R[dep][cnt]++;else\n\t\tblo[dep][i]=++cnt,L[dep][cnt]=R[dep][cnt]=i;\n\t}\n\tL[dep][0]=1;R[dep][0]=n;\n}\nbool ans[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&v[0]);\n\twhile (v[dep]) v[dep+1]=v[dep]>>1,dep++;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor (int i=0;i<=dep;i++) init(i);\n\tint U=(1<<dep)-1;\n\tfor (int S=1;S<=U;S++)\n\tfor (int i=0;i<dep;i++)\n\tif (S>>i&1) dpl[S]=max(dpl[S],R[i+1][blo[i+1][dpl[S^(1<<i)]+1]]);\n\tfor (int S=0;S<=U;S++) dpr[S]=n+1;\n\tfor (int S=1;S<=U;S++)\n\tfor (int i=0;i<dep;i++)\n\tif (S>>i&1) dpr[S]=min(dpr[S],L[i+1][blo[i+1][dpr[S^(1<<i)]-1]]);\n\tif (blo[0][n]<=20){\n\t\tfor (int i=1;i<=blo[0][n];i++){\n\t\t\tint l=L[0][i],r=R[0][i];bool ok=0;\n\t\t\tfor (int S=0;S<=U;S++)\n\t\t\tif (dpl[S]>=l-1&&dpr[U^S]<=r+1) ok=1;\n\t\t\tif (!ok) continue;\n\t\t\tfor (int j=l;j<=r;j++) ans[j]=1;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) puts(ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 4e5 + 5;\nint n, v;\nint x[maxn];\n\nbool read() {\n  if (scanf(\"%d%d\", &n, &v) < 2) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &x[i]);\n  }\n  return true;\n}\n\nconst int maxk = 20;\nint go[maxn][maxk];\nint k;\n\nvoid getDp(int dp[maxn]) {\n  for (int i = 0; i < k; i++) {\n    go[n][k] = n;\n    go[n - 1][k] = n;\n  }\n  for (int i = n - 2; i >= 0; i--) {\n    for (int j = 0; j < k; j++) {\n      int curv = (v >> (j + 1));\n      go[i][j] = (x[i + 1] - x[i] <= curv ? go[i + 1][j] : i + 1);\n    }\n  }\n  for (int i = 0; i < (1 << k); i++) {\n    dp[i] = 0;\n  }\n  for (int i = 0; i < (1 << k); i++) {\n    auto cur = dp[i];\n    for (int j = 0; j < k; j++) {\n      if (!(i & (1 << j))) {\n        dp[i | (1 << j)] = max(dp[i | (1 << j)], go[cur][j]);\n      }\n    }\n  }\n}\n\nint dpl[maxn], dpr[maxn];\nint ans[maxn];\n\nvoid solve() {\n  k = 32 - __builtin_clz(v);\n  getDp(dpl);\n  reverse(x, x + n);\n  for (int i = 0; i < n; i++) {\n    x[i] *= -1;\n  }\n  getDp(dpr);\n  reverse(x, x + n);\n  for (int i = 0; i < n; i++) {\n    x[i] *= -1;\n  }\n  for (int i = 0; i < (1 << k); i++) {\n    dpr[i] = n - dpr[i];\n  }\n  for (int i = 0; i < n; i++) {\n    ans[i] = false;\n  }\n  int cnt = 0;\n  for (int j = 0; j < n;) {\n    int i = j;\n    while (j + 1 < n && x[j + 1] - x[j] <= v) {\n      j++;\n    }\n    j++;\n    cnt++;\n    if (cnt > k + 2) {\n      break;\n    }\n    bool ok = false;\n    for (int msk = 0; msk < (1 << k); msk++) {\n      if (dpl[msk] >= i && dpr[(1 << k) - 1 - msk] <= j) {\n        ok = true;\n        break;\n      }\n    }\n    if (ok) {\n      for (int k = i; k < j; k++) {\n        ans[k] = true;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    printf(ans[i] ? \"Possible\\n\" : \"Impossible\\n\");\n  }\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,v;\n  cin>>n>>v;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n\n  vector<Int> dp;\n  vector<vector<Int> > ps;\n  while(v){\n    vector<Int> dp2(n,0);\n    for(Int i=1;i<n;i++)\n      dp2[i]=dp2[i-1]+(x[i]-x[i-1]>v);\n    if(dp.empty()) dp=dp2;\n\n    vector<Int> ps2;\n    ps2.emplace_back(0);\n    for(Int i=1;i<n;i++)\n      if(dp2[i]!=dp2[i-1]) ps2.emplace_back(i);\n    ps2.emplace_back(n);\n    ps.emplace_back(ps2);\n    v>>=1;\n  }\n  \n  {\n    vector<Int> ps2(n+1,0);\n    iota(ps2.begin(),ps2.end(),0);\n    ps.emplace_back(ps2);\n  }\n\n  using P = pair<Int, Int>;\n  Int flg;\n  function<void(Int,set<P>)> dfs=\n    [&](Int d,set<P> sp){\n      {\n\tauto latte=sp.begin();\n\tInt res=latte->first==0;\n\twhile(latte!=sp.end()){\n\t  auto malta=latte;\n\t  if(++malta==sp.end()) break;;\n\t  res&=latte->second==malta->first;\n\t  latte=malta;\n\t}\n\tres&=latte->second==n;\n\tflg|=res;\n      }\n      \n      if(d==(Int)ps.size()) return;\n      \n      vector<Int> &v=ps[d];\n      Int cnt=0;\n      auto latte=v.begin();\n      for(auto &p:sp){\n\tcnt+=lower_bound(latte,v.end(),p.first)-latte;\n\tlatte=lower_bound(latte,v.end(),p.second);\n      }\n      cnt+=v.end()-latte;\n\n      if(0){\n\tcout<<d<<\":\"<<cnt<<endl;\n\tfor(auto p:sp) cout<<p.first<<\" \"<<p.second<<endl;\n\tcout<<endl;\n      }\n      \n      if(d+cnt-1>(int)ps.size()) return;\n      \n      Int k=0;\n      set<P> nsp=sp;\n      for(auto &p:sp){\n\twhile(v[k]<p.first){\n\t  nsp.emplace(v[k],v[k+1]);\n\t  dfs(d+1,nsp);\n\t  nsp.erase(P(v[k],v[k+1]));\n\t  k++;\n\t  if(flg) return;\n\t}\n\tk=lower_bound(v.begin(),v.end(),p.second)-v.begin();\n      }\n      while(k+1<(Int)v.size()){\n\tnsp.emplace(v[k],v[k+1]);\n\tdfs(d+1,nsp);\n\tnsp.erase(P(v[k],v[k+1]));\n\tk++;\n\tif(flg) return;\n      }\n    };\n  \n  for(Int i=0;i<n;){\n    Int l=i,r=*upper_bound(ps[0].begin(),ps[0].end(),l);\n    set<P> sp;\n    sp.emplace(l,r);\n    flg=0;\n    //cout<<l<<\" \"<<r<<endl;\n    dfs(1,sp);\n    string ans=flg?\"Possible\":\"Impossible\";\n    Int p=i;\n    while(i<n&&dp[p]==dp[i]){\n      cout<<ans<<endl;\n      i++;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define RI register int\nint read() {\n\tint q=0,w=1;char ch=' ';\n\twhile(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n\tif(ch=='-') w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();\n\treturn q*w;\n}\nconst int N=200005,LIM=524290,inf=0x3f3f3f3f;\nint n,V,m;\nint bin[21],x[N],L[N],f[LIM],g[LIM],in[21][N],ans[N],mi[N];\nvector<int> seg[21];\n\nvoid prework() {\n\tseg[m].push_back(0);\n\tfor(RI i=2;i<=n;++i)\n\t\tif(x[i]-x[i-1]>V) seg[m].push_back(i-1);\n\tseg[m].push_back(n);\n\t//cout<<\"V=\"<<V<<endl;\n\t//for(RI i=0;i<seg[m].size();++i) cout<<seg[m][i]<<\" \";\n\t//cout<<endl;\n\tint now=1;\n\tfor(RI i=1;i<seg[m].size();++i)\n\t\twhile(now<=seg[m][i]) in[m][now]=i,++now;\n\t//for(RI i=1;i<=n;++i) cout<<in[m][i]<<\" \";\n\t//cout<<endl;\n\t//cout<<endl;\n}\nvoid work1() {\n\tfor(RI i=0;i<bin[m]-1;++i) {\n\t\t//cout<<i<<\" \"<<f[i]<<endl;\n\t\tfor(RI j=0;j<m;++j)\n\t\t\tif(!(i&bin[j]))\n\t\t\t\tf[i|bin[j]]=max(f[i|bin[j]],seg[j+1][in[j+1][f[i]+1]]);\n\t}\n\t//cout<<bin[m]-1<<\" \"<<f[bin[m]-1]<<endl;\n\t//cout<<endl;\n}\nvoid work2() {\n\tfor(RI i=0;i<bin[m];++i) g[i]=n+1;\n\tfor(RI i=0;i<bin[m]-1;++i) {\n\t\t//cout<<i<<\" \"<<g[i]<<endl;\n\t\tfor(RI j=0;j<m;++j)\n\t\t\tif(!(i&bin[j]))\n\t\t\t\tg[i|bin[j]]=min(g[i|bin[j]],seg[j+1][in[j+1][g[i]-1]-1]+1);\n\t}\n\t//cout<<bin[m]-1<<\" \"<<g[bin[m]-1]<<endl;\n\t//cout<<endl;\n}\nvoid work3() {\n\tfor(RI i=0;i<=n;++i) mi[i]=inf;\n\tfor(RI i=0;i<bin[m];++i)\n\t\tmi[f[i]]=min(mi[f[i]],g[(bin[m]-1)^i]);\n\tfor(RI i=n-1;i>=0;--i) mi[i]=min(mi[i],mi[i+1]);\n\t//for(RI i=0;i<=n;++i) cout<<mi[i]<<\" \";\n\t//cout<<endl;\n}\n\nint main()\n{\n\tn=read(),V=read();\n\tbin[0]=1;for(RI i=1;i<=20;++i) bin[i]=bin[i-1]<<1;\n\tfor(RI i=1;i<=n;++i) x[i]=read();\n\tprework();while(V) V>>=1,++m,prework();\n\twork1(),work2(),work3();\n\tfor(RI i=1;i<seg[0].size();++i) {\n\t\tint L=seg[0][i-1]+1,R=seg[0][i];\n\t\tif(mi[L-1]<=R+1) for(RI j=L;j<=R;++j) ans[j]=1;\n\t}\n\tfor(RI i=1;i<=n;++i) puts(ans[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N, V, C, x[200009], dp[200009][20], rev[200009][20], s1[1 << 20][20], s2[1 << 20], t[200009];\nint val[1 << 20];\n\nint main() {\n\tcin >> N >> V;\n\tfor (int i = 1; i <= N; i++) cin >> x[i];\n\tint s = V;\n\tfor (int i = 0; i < 20; i++) {\n\t\tC = i + 1;\n\t\tvector<int>X;\n\t\tfor (int j = 1; j <= N - 1; j++) {\n\t\t\tif (x[j + 1] - x[j] > V) X.push_back(j);\n\t\t}\n\t\tX.push_back(N);\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tint pos1 = lower_bound(X.begin(), X.end(), j) - X.begin();\n\t\t\tdp[j][i] = X[pos1] + 1;\n\t\t}\n\t\tX.push_back(0); sort(X.begin(), X.end());\n\t\tfor (int j = N; j >= 1; j--) {\n\t\t\tint pos1 = lower_bound(X.begin(), X.end(), j) - X.begin(); pos1--;\n\t\t\trev[j][i] = X[pos1];\n\t\t}\n\t\tif (V == 0) break;\n\t\tV /= 2;\n\t}\n\tfor (int i = 0; i < (1 << C); i++) { for (int j = 0; j < C; j++) s1[i][j] = -1; s2[i] = (1 << 30); }\n\ts1[0][0] = 1;\n\tfor (int i = 0; i < (1 << C); i++) {\n\t\tfor (int k = 0; k < C; k++) {\n\t\t\tif (s1[i][k] == -1) continue;\n\t\t\tfor (int j = 0; j < C; j++) {\n\t\t\t\tif ((i / (1 << j)) % 2 == 1) continue;\n\t\t\t\ts1[i + (1 << j)][j] = max(s1[i + (1 << j)][j], dp[s1[i][k]][j]);\n\t\t\t}\n\t\t}\n\t}\n\ts2[0] = N;\n\tfor (int i = 0; i < (1 << C); i++) {\n\t\tif (s2[i] == (1 << 30)) continue;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tif ((i / (1 << j)) % 2 == 1) continue;\n\t\t\ts2[i + (1 << j)] = min(s2[i + (1 << j)], rev[s2[i]][j]);\n\t\t}\n\t}\n\tvector<pair<int, int>>X, Y;\n\tfor (int i = 0; i < (1 << C); i++) {\n\t\tif (i % 2 == 1) X.push_back(make_pair(s1[i][0], i / 2));\n\t\tif (i % 2 == 0) Y.push_back(make_pair(s2[i], i / 2));\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tfor (int i = 0; i < X.size(); i++) val[X[i].second]++;\n\tint cx = 0, cy = 0; vector<int>B;\n\tfor (int i = 1; i <= N; i++) {\n\t\twhile (cx < X.size() && X[cx].first <= i) { val[X[cx].second]--; cx++; }\n\t\twhile (cy < Y.size() && Y[cy].first <= i) {\n\t\t\tval[Y[cy].second ^ ((1 << (C - 1)) - 1)]++;\n\t\t\tif (val[Y[cy].second ^ ((1 << (C - 1)) - 1)] == 2) B.push_back(Y[cy].second ^ ((1 << (C - 1)) - 1));\n\t\t\tcy++;\n\t\t}\n\t\twhile (B.size() >= 1) {\n\t\t\tif (val[B[B.size() - 1]] < 2) B.pop_back();\n\t\t\telse break;\n\t\t}\n\t\tif (B.size() >= 1) {\n\t\t\tt[rev[i][0] + 1]++;\n\t\t\tt[dp[i][0]]--;\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) t[i] += t[i - 1];\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (t[i] >= 1) cout << \"Possible\" << endl;\n\t\telse cout << \"Impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\n#include <cstdlib>\n\nusing std::pair;\ntypedef pair<int,int> pii;\nconst int N = 200010;\nconst int M = 18;\nint _w;\n\nint max( int a, int b ) {\n\treturn a > b ? a : b;\n}\n\nint n, v, x[N], m;\n\nint ans[N];\nvoid answer() {\n\tfor( int i = 1; i <= n; ++i )\n\t\tputs( ans[i] ? \"Possible\" : \"Impossible\" );\n\texit(0);\n}\n\nint R[M][N];\nvoid prelude() {\n\tint t = v;\n\tfor( m = 0; ; ++m, t >>= 1 ) {\n\t\tR[m][n] = R[m][n+1] = n;\n\t\tfor( int j = n-1; j >= 1; --j )\n\t\t\tif( x[j+1] - x[j] > t )\n\t\t\t\tR[m][j] = j;\n\t\t\telse R[m][j] = R[m][j+1];\n\t\tif( !t ) break;\n\t}\n\t++m;\n}\n\nint f[1<<M];\nbool check( int l, int r ) {\n\tmemset(f, 0, sizeof f);\n\tif( l == 1 ) f[0] = r;\n\tfor( int i = 0; i < (1<<m); ++i )\n\t\tfor( int j = 1; j < m; ++j )\n\t\t\tif( (i&(1<<j)) == 0 ) {\n\t\t\t\tint k = i|(1<<j);\n\t\t\t\tf[k] = max( f[k], R[j][f[i]+1] );\n\t\t\t\tif( f[k] >= l-1 && f[k] <= r )\n\t\t\t\t\tf[k] = r;\n\t\t\t}\n\treturn f[(1<<m)-2] == n;\n}\n\nvoid solve() {\n\tstatic pii tmp[N];\n\tstatic int tn;\n\tfor( int i = 1; i <= n; i = R[0][i]+1 )\n\t\ttmp[tn++] = pii(i, R[0][i]);\n\tif( tn > m ) answer();\n\tfor( int i = 0; i < tn; ++i )\n\t\tif( check(tmp[i].first, tmp[i].second) ) {\n\t\t\tfor( int j = tmp[i].first; j <= tmp[i].second; ++j )\n\t\t\t\tans[j] = 1;\n\t\t}\n\tanswer();\n}\n\nint main() {\n\t_w = scanf( \"%d%d\", &n, &v );\n\tfor( int i = 1; i <= n; ++i )\n\t\t_w = scanf( \"%d\", x+i );\n\tprelude(), solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 500008\n#define lg 21\nint n;\nint pos[nn];\nstruct afd{\n\tint bel[nn];\n\tint l[nn],r[nn];\n\tvoid init(int v)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(i==1 or pos[i]-pos[i-1]>v) bel[i]=i,l[i]=r[i]=i;\n\t\t\telse bel[i]=bel[i-1],r[bel[i]]=i; \n\t\t}\n\t}\n}v2[lg];\nint l=0;\nint v;\n\nvoid fuckoff()\n{\n\twhile(n--) puts(\"Impossible\");\n\texit(0);\n}\nint fl[nn],fr[nn];\nvoid chkmin(int &x,int y) {x=min(x,y);}\nvoid chkmax(int &x,int y) {x=max(x,y);}\n\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&pos[i]);\n\twhile(v) v2[l++].init(v),v/=2;\n\tv2[l++].init(v),v/=2;\n\t\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(v2[0].bel[i]==i)\n\t\t\tcnt++;\n\tif(cnt>l) fuckoff();\n\t\n\tfor(int ii=1;ii<=n;ii++)\n\t{\n\t\tif(v2[0].bel[ii]==ii)\n\t\t{\n\t\t\tint el=v2[0].l[ii],er=v2[0].r[ii];\n\t\t\t\n\t\t\tmemset(fl,0x3f,sizeof fl);\n\t\t\tmemset(fr,0,sizeof fr);\n\t\t\t\n\t\t\tfl[1]=el;fr[1]=er;\n\t\t\t\n\t\t\tfor(int mask=1;mask<(1<<l);mask++)\n\t\t\t{\n\t\t\t\tif(!(mask&1) or fl[mask]>n) continue;\n\t\t\t\tfor(int i=1;i<l;i++)\n\t\t\t\t{\n\t\t\t\t\tif(mask&(1<<i)) continue;\n\t\t\t\t\tint x=v2[i].bel[fl[mask]-1];\n\n\t\t\t\t\tif(!x) chkmin(fl[mask|(1<<i)],fl[mask]);\n\t\t\t\t\telse chkmin(fl[mask|(1<<i)],v2[i].l[x]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int mask=1;mask<(1<<l);mask++)\n\t\t\t{\n\t\t\t\tif(!(mask&1) or !fr[mask]) continue;\n\t\t\t\tfor(int i=1;i<l;i++)\n\t\t\t\t{\n\t\t\t\t\tif(mask&(1<<i)) continue;\n\t\t\t\t\tint x=v2[i].bel[fr[mask]+1];\n\t\t\t\t\t\n\t\t\t\t\tif(!x) chkmax(fr[mask|(1<<i)],fr[mask]);\n\t\t\t\t\telse chkmax(fr[mask|(1<<i)],v2[i].r[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tint flag=0;\n\t\t\tfor(int mask=0;mask<(1<<l);mask++)\n\t\t\tif(mask&1)\n\t\t\t\tif(fl[mask]<=1 and fr[(((1<<l)-1)^mask)|1]>=n)\n\t\t\t\t\tflag=1;\n\t\t\t\t\t\t\n\t\t\tif(flag)\n\t\t\t\tfor(int i=el;i<=er;i++) puts(\"Possible\");\n\t\t\telse\n\t\t\t\tfor(int i=el;i<=er;i++) puts(\"Impossible\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define mp make_pair\n#define squ(x) ((LL)(x) * (x))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\n\ninline int read() {\n\tint sum = 0, fg = 1; char c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') fg = -1;\n\tfor (; isdigit(c); c = getchar()) sum = (sum << 3) + (sum << 1) + (c ^ 0x30);\n\treturn fg * sum;\n}\n\nconst int maxn = 2e5 + 10;\nconst int inf = 0x3f3f3f3f;\n\nvector<pii> S[20];\n\nint n, V, a[maxn];\n\nint main() {\n#ifdef xunzhen\n\tfreopen(\"agc012e.in\", \"r\", stdin);\n\tfreopen(\"agc012e.out\", \"w\", stdout);\n#endif\n\n\tn = read(), V = read();\n\tfor (int i = 1; i <= n; i++) a[i] = read();\n\n\tint N = 0, k = V;\n\twhile (1) {\n\t\tint lst = 1;\n\t\tfor (int j = 2; j <= n; j++)\n\t\t\tif (abs(a[j] - a[j - 1]) > k)\n\t\t\t\tS[N].push_back(mp(lst, j - 1)), lst = j;\n\t\tS[N].push_back(mp(lst, n));\n\t\tif (!k) break; k >>= 1, ++N;\n\t}\n\n\tstatic int F[1 << 18], G[1 << 18];\n\tmemset(F, -0x3f, sizeof F), F[0] = 0;\n\tfor (int s = 0, all = 1 << N; s < all; s++) {\n\t\tif (F[s] == -inf) continue;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((s >> i) & 1) continue;\n\t\t\tint l = 0, r = S[i + 1].size() - 1;\n\t\t\twhile (l <= r) {\n\t\t\t\tint mid = (l + r) >> 1;\n\t\t\t\tif (S[i + 1][mid].fst <= F[s] + 1) l = mid + 1;\n\t\t\t\telse r = mid - 1;\n\t\t\t}\n\t\t\tchkmax(F[s | (1 << i)], max(F[s], S[i + 1][l - 1].snd));\n\t\t}\n\t}\n\n\tmemset(G, 0x3f, sizeof G), G[0] = n + 1;\n\tfor (int s = 0, all = 1 << N; s < all; s++) {\n\t\tif (G[s] == inf) continue;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((s >> i) & 1) continue;\n\t\t\tint l = 0, r = S[i + 1].size() - 1;\n\t\t\twhile (l <= r) {\n\t\t\t\tint mid = (l + r) >> 1;\n\t\t\t\tif (S[i + 1][mid].snd >= G[s] - 1) r = mid - 1;\n\t\t\t\telse l = mid + 1;\n\t\t\t}\n\t\t\tchkmin(G[s | (1 << i)], min(G[s], S[i + 1][r + 1].fst));\n\t\t}\n\t}\n\n\tstatic int c[maxn];\n\tmemset(c, 0x3f, sizeof c);\n\tfor (int s = 0, all = (1 << N) - 1; s <= all; s++)\n\t\tif (F[s] >= 0) chkmin(c[F[s]], G[all ^ s]);\n\tfor (int i = n - 1; ~i; i--) chkmin(c[i], c[i + 1]);\n\n\tstatic bool ans[maxn];\n\tfor (pii t : S[0]) {\n\t\tif (c[t.fst - 1] <= t.snd + 1)\n\t\t\tfor (int i = t.fst; i <= t.snd; i++) ans[i] = 1;\n\t}\n\n\tfor (int i = 1; i <= n; i++) printf(ans[i] ? \"Possible\\n\" : \"Impossible\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define fi first\n#define se second\n#define ll long long\n#define dbg(v) cerr<<#v<<\" = \"<<v<<'\\n'\n#define vi vector<int>\n#define vl vector <ll>\n#define pii pair<int,int>\n#define mp make_pair\n#define db long double\n#define pb push_back\n#define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nconst int N = (int)(1e6) + 5;\nint s[N];\nint D1[20][N];\nint D2[20][N];\nint dp1[1 << 20];\nint dp2[1 << 20];\nint sum[N];\nint main(void)\n{\n    int n,k;\n    cin>>n>>k;\n    int shit = k;\n    int LG = 1;\n    while (shit) ++LG,shit /= 2;\n    for (int i = 1;i <= n;++i)\n        cin>>s[i];\n    for (int t = 0;t < LG;++t)\n        {\n            for (int i = n;i;--i)\n                if (i == n || s[i + 1] - s[i] > (k >> t))\n                    D1[t][i] = i;\n                else\n                    D1[t][i] = D1[t][i + 1];\n            for (int i = 1;i <= n;++i)\n                if (i == 1 || s[i] - s[i - 1] > (k >> t))\n                    D2[t][i] = i;\n                else\n                    D2[t][i] = D2[t][i - 1];\n            D1[t][n + 1] = n;\n            D2[t][0] = 1;\n        }\n    const int N = 1 << LG;\n    for (int mask = 0;mask < N;++mask)\n    {\n        dp1[mask] = 0;\n        dp2[mask] = n + 1;\n    }\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < LG;++i)\n            if ((mask >> i) & 1)\n            {\n                smax(dp1[mask],D1[i][dp1[mask ^ (1 << i)] + 1]);\n                smin(dp2[mask],D2[i][dp2[mask ^ (1 << i)] - 1]);\n            }\n    for (int mask = 0;mask < N;mask += 2)\n    {\n        const int lf = D2[0][dp1[mask] + 1];\n        const int rg = D1[0][dp2[(N - 1) ^ 1 ^ mask] - 1];\n        if (D1[0][dp1[mask] + 1] < D2[0][dp2[(N - 1) ^ 1 ^ mask] - 1])\n            continue;\n        sum[lf] += 1;\n        sum[rg + 1] -= 1;\n    }\n    for (int i = 1;i <= n;++i)\n        sum[i] += sum[i - 1];\n    for (int i = 1;i <= n;++i)\n        if (sum[i])\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,b,e) for(int i=(b); i <= (e); ++i)\n#define FORD(i,b,e) for(int i=(b); i >= (e); --i)\n#define REP(i,n) for(int i=0; i < (n); ++i)\n#define SIZE(c) (int) (c).size()\n#define ALL(c) (c).begin(), (c).end()\n#define PB push_back\n#define MP make_pair\n#define ST first\n#define ND second\n#define FWD(i,a,b) for (int i=(a); i<(b); ++i)\n#define BCK(i,a,b) for (int i=(a); i>(b); --i)\n#define PI 3.14159265358979311600\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\ntypedef vector < int > VI;\ntypedef vector<ll> VL;\n\ntypedef long double K;\n\n#define int long long\n\nconst int N = 200005;\nconst int M = 1<<22;\nconst int inf = 1000*1000*1000 + 7;\n\nint n, v, cnt, bound;\nint a[N], f[M], g[M];\nint goLeft[N][23], goRight[N][23];\nvector<int> b;\n\nstruct SegTree {\n\tint n;\n\tvector<int> tree;\n\n\tSegTree(int n): n(n), tree(4*n, inf) {}\n\n\tvoid update(int pos, int val) {\n\t\tupdate(1, 0, n - 1, pos, val);\n\t}\n\n\tint go(int l, int r) {\n\t\treturn go(1, 0, n - 1, l, r);\n\t}\n\n\tvoid update(int v, int tl, int tr, int pos, int val) {\n\t\tif (tl == tr) {\n\t\t\ttree[v] = min(tree[v], val);\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) / 2;\n\t\tif (pos <= tm) {\n\t\t\tupdate(2*v, tl, tm, pos, val); \n\t\t} else {\t\n\t\t\tupdate(2*v+1, tm+1, tr, pos, val);\n\t\t}\n\t\ttree[v] = min(tree[2*v], tree[2*v+1]);\n\t}\n\n\tint go(int v, int tl, int tr, int l, int r) {\n\t\tif (l > tr || r < tl) return inf;\n\t\tif (l <= tl && r >= tr) return tree[v];\n\t\tint tm = (tl + tr) / 2;\n\t\treturn min(go(2*v, tl, tm, l, r), go(2*v+1, tm+1, tr, l, r));\n\t}\n};\n\nvoid calc() {\n\tREP(i, cnt) {\n\t\tREP(j, n) {\n\t\t\tgoLeft[i][j] = j;\n\t\t\tif (j > 0 && a[j] - a[j - 1] <= b[i]) {\n\t\t\t\tgoLeft[i][j] = goLeft[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tgoRight[i][j] = j;\n\t\t\tif (j < n - 1 && a[j + 1] - a[j] <= b[i]) {\n\t\t\t\tgoRight[i][j] = goRight[i][j + 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint go(int pos, int x, int side) {\n\tif (side < 0) {\n\t\treturn pos >= 0 ? goLeft[x][pos] : pos;\n\t} \n\treturn pos < n ? goRight[x][pos] : pos;\n}\n\nmain() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\tREP(i, n) {\n\t\tcin >> a[i];\n\t}\n\n\twhile (v > 0) {\n\t\tb.push_back(v);\n\t\tv /= 2;\n\t}\n\n\tb.push_back(0);\n\tcnt = (int)b.size();\n\tbound = (1 << cnt);\n\n\tcalc();\n\n\tREP(i, bound) f[i] = 0, g[i] = n - 1;\n\tf[0] = 0;\n\tg[0] = n - 1;\n\n\tREP(i, bound) {\n\t\tREP(j, cnt) if (~i & (1 << j)) {\n\t\t\tif (f[i] != -inf) {\n\t\t\t\tf[i ^ (1 << j)] = max(f[i ^ (1 << j)], min(go(f[i], j, +1) + 1, n - 1));\n\t\t\t}\n\t\t\tif (g[i] != inf) {\n\t\t\t\tg[i ^ (1 << j)] = min(g[i ^ (1 << j)], max(go(g[i], j, -1) - 1, 0LL));\n\t\t\t}\n\t\t}\n\t}\n\n\tint all = 0;\n\n\tSegTree tree(n);\n\n\tREP(mask, bound) {\n\t\tint comp = (bound - 1) ^ mask;\n\t\tint a = (mask & 1) ? (mask ^ 1) : mask;\n\t\tint b = (comp & 1) ? (comp ^ 1) : comp;\n\t\tif (f[a] >= g[b]) {\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\t}\n\t\ttree.update(f[a], g[b]);\n\t}\n\n\tREP(i, n) {\n\t\tif (all) {\n\t\t\tcout << \"Possible\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tint lb = go(i, 0, -1);\n\t\tint rb = go(i, 0, +1);\n\t\tif (tree.go(lb, rb) <= rb) {\n\t\t\tcout << \"Possible\\n\";\n\t\t} else {\n\t\t\tcout << \"Impossible\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 2e5+5;\nint n, k, V, i, a[Nmax], lg[Nmax], dp1[Nmax], go1[22][Nmax], dp2[Nmax], go2[22][Nmax], nr[Nmax];\n\nvoid compute()\n{\n    int l, i, j, ind;\n    for(l=0; l<k; ++l)\n    {\n        //go1[l][n+1] = n;\n        //go2[l][0] = 1;\n\n        for(i=1; i<=n; ++i)\n        {\n            for(j = i; j+1<=n && a[j+1] - a[j] <= lg[l]; ++j);\n            for(ind = i; ind <= j; ++ind)\n                go1[l][ind] = j;\n\n            i = j;\n        }\n\n        for(i=n; i; --i)\n        {\n            for(j = i; j-1>=1 && a[j] - a[j-1] <= lg[l]; --j);\n            for(ind = i; ind >= j; --ind)\n                go2[l][ind] = j;\n\n            i = j;\n        }\n    }\n}\n\nvoid dinamique()\n{\n    int i, j;\n    dp1[0] = 0, dp2[0] = n+1;\n    for(i=1; i<(1<<k); ++i)\n    {\n        dp1[i] = 1;\n        dp2[i] = n;\n\n        for(j=0; j<k; ++j)\n            if(i&(1<<j))\n            {\n                dp1[i] = max(dp1[i], go1[j][ dp1[i^(1<<j)] + 1 ]);\n                dp2[i] = min(dp2[i], go2[j][ dp2[i^(1<<j)] - 1 ]);\n            }\n    }\n}\n\nvoid solve()\n{\n    int i, j, ind, mask = (1<<k) - 2;\n    bool ok;\n\n    for(i=0; i<=n+1; ++i) nr[i] = -1;\n\n    for(i=0; i<=mask; ++i)\n        nr[dp2[i]] = max(nr[dp2[i]], dp1[mask^i]);\n\n    for(i=1; i<=n+1; ++i)\n        nr[i] = max(nr[i], nr[i-1]);\n\n    for(i=1; i<=n; ++i)\n    {\n        for(j = i; j+1<=n && a[j+1] - a[j] <= V; ++j);\n        ok = (nr[j+1] >= i-1);\n\n        for(ind = i; ind <= j; ++ind)\n            printf(\"%s\\n\", ok ? \"Possible\" : \"Impossible\");\n\n        i = j;\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &V);\n    for(i=1; i<=n; ++i) scanf(\"%d\", &a[i]);\n\n    lg[0] = V/2;\n    for(i=1; lg[i-1]; ++i) lg[i] = lg[i-1] / 2;\n    k = i;\n\n    compute();\n    dinamique();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=200010,SH=18,SN=1<<SH,INF=0x7f7f7f7f;\nint tol[N][SH],tor[N][SH];\nint fl[SN],fr[SN];\nint x[N],v[N];\nint ext[N];\nint main(){\n\tint n=ni,vs=0;\n\tv[0]=ni;\n\tfor(int &i=vs;v[i];i++){\n\t\tv[i+1]=v[i]>>1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tx[i]=ni;\n\t}\n\tfor(int j=0;j<=vs;j++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ttol[i][j]=i>1&&x[i]-x[i-1]<=v[j]?tol[i-1][j]:i;\n\t\t}\n\t\tfor(int i=n;i>=1;i--){\n\t\t\ttor[i][j]=i<n&&x[i+1]-x[i]<=v[j]?tor[i+1][j]:i;\n\t\t}\n\t}\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tfl[s]=0;\n\t\tfor(int i=1;i<=vs;i++){\n\t\t\tif((s>>(i-1))&1){\n\t\t\t\tapmax(fl[s],tor[fl[s^(1<<(i-1))]+1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tfr[s]=n+1;\n\t\tfor(int i=1;i<=vs;i++){\n\t\t\tif((s>>(i-1))&1){\n\t\t\t\tapmin(fr[s],tol[fr[s^(1<<(i-1))]-1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(ext,127,sizeof(ext));\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tapmin(ext[fl[s]],fr[s^(ts-1)]);\n\t}\n\tfor(int i=n;i>=1;i--){\n\t\tapmin(ext[i-1],ext[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tputs(ext[tol[i][0]-1]<=tor[i][0]+1?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1012345678;\n\nint A[200005];\n\nint S[20];\nint sizeS = 0;\n\nint R[20][200005];\nint L[20][200005];\nbool boleh[200005];\nint minPos[200005]; // for each dpL[something] = i, the smallest possible value of dpR[not of the something]\n// 'something' is a bitmask\n\nint minPos2[200005]; // for each dpL[something] >= i, the smallest possible value of dpR[not of the something]\n// 'something' is a bitmask\n\n/* dpL[i] = maximum index from the beginning that can be covered by the intervals\ncorresponding to a subset i of intervals from S\ndpR[i] is defined similarly, just that the prefix becomes the suffix.\n*/\nint dpL[(1<<19)+5];\nint dpR[(1<<19)+5];\n\n\nint N, V;\nint main(){\n    scanf(\"%d%d\", &N, &V);\n\n    for(int i = 1; i <= N; i ++){\n        scanf(\"%d\", &A[i]);\n    }\n\n    int temp = V;\n    while(true){\n        S[sizeS ++] = temp;\n        if(temp == 0){break;}\n        temp >>= 1;\n    }\n    reverse(S, S+sizeS);\n    for(int i = 0; i < sizeS; i++){\n        //printf(\"S[%d]=%d\\n\", i, S[i]);\n    }\n\n    // S is sorted in decreasing order\n\n    // R[i][j] is the 1-indexed right-most position reachable using move distances <= S[i] from position j\n    for(int i = 0; i < sizeS; i ++){\n        R[i][N] = N;\n        L[i][1] = 1;\n        for(int j = 2; j <= N; j ++){\n            if(A[j]-A[j-1] <= S[i]){\n                L[i][j] = L[i][j-1];\n            }else{\n                L[i][j] = j;\n            }\n        }\n\n        for(int j = N-1; j >= 1; j --){\n            if(A[j+1]-A[j] <= S[i]){\n                // can reach j+1, hence can reach positions up to R[i][j+1]\n                R[i][j] = R[i][j+1];\n            }else{\n                // j and j+1 disconnected\n                R[i][j] = j;\n            }\n        }\n    }\n\n    for(int i = 0; i < (1<<sizeS); i ++){\n        dpL[i] = 0;\n        dpR[i] = N+1;\n\n        // Consider the last S[j] used to construct the interval\n        for(int j = 0; j < sizeS; j ++){\n            if(i&(1<<j)){\n                // Bit j is set in i.\n                int k = i^(1<<j);\n\n                // clearing bit results in an index lesser than the original index => already processed\n                dpL[i] = max(dpL[i], R[j][min(dpL[k]+1, N)]);\n                // dpL[k]+1 is first index impossible to be covered by all the previous intervals\n\n                dpR[i] = min(dpR[i], L[j][max(dpR[k]-1, 1)]);\n            }\n        }\n    }\n\n    int k = 1;\n    for(int i = 1; i <= N; i ++){\n        minPos[i] = INF;\n    }\n\n    // Now check whether it is possible to reach all the oases.\n    for(int i = 0; i < (1<<(sizeS-1)); i ++){\n        int j = (1<<(sizeS-1))-1-i;\n\n        int l = dpL[i];\n        int r = dpR[j];\n        //printf(\"dpL[%d]=%d; dpR[%d]=%d\\n\", i, l, j, r);\n        minPos[l] = min(minPos[l], r);\n    }\n\n    minPos2[N] = minPos[N];\n    for(int i = N-1; i >= 1; i --){\n        minPos2[i] = min(minPos2[i+1], minPos[i]);\n        //printf(\"minPos[%d]=%d\\n\", i, minPos[i]);\n    }\n\n    //init();\n    for(int i = 1; i <= N; i ++){\n        int l = L[sizeS-1][i];\n        int r = R[sizeS-1][i];\n\n        //printf(\"i=%d l=%d r=%d\\n\", i, l, r);\n\n        boleh[i] = minPos2[max(l-1, 1)] <= r+1;\n        if(boleh[i]){\n            printf(\"Possible\\n\");\n        }else{\n            printf(\"Impossible\\n\");\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 1 << 18;\n\nint n, m, M, v[20], f[maxn + 10], g[maxn + 10], x[maxn + 10], y[maxn + 10], z[maxn + 10], LOG[maxn + 10], ans[maxn + 10], fy[maxn + 10][20], fz[maxn + 10][20];\n\nvoid chkmax(int &x, int y) {\n\t(x < y) && (x = y);\n\treturn;\n}\n\nvoid chkmin(int &x, int y) {\n\t(x > y) && (x = y);\n\treturn;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, v);\n\twhile(v[m]) {\n\t\tv[m + 1] = v[m] >> 1;\n\t\t++m;\n\t}\n\tv[m] = v[0];\n\tv[0] = 0;\n\tM = 1 << m;\n\tfor (int i = 2; i < M; ++i) {\n\t\tLOG[i] = LOG[i >> 1] + 1;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", x + i);\n\t\tz[i] = y[i - 1] = x[i] - x[i - 1];\n\t}\n\tfor (int i = 0; i <= m; ++i) {\n\t\tint lst = n;\n\t\tfy[n][i] = n;\n\t\tfor (int j = n - 1; j; --j) {\n\t\t\tif(y[j] > v[i]) {\n\t\t\t\tlst = j;\n\t\t\t}\n\t\t\tfy[j][i] = lst;\n\t\t}\n\t\tlst = 1;\n\t\tfz[1][i] = 1;\n\t\tfor (int j = 2; j <= n; ++j) {\n\t\t\tif(z[j] > v[i]) {\n\t\t\t\tlst = j;\n\t\t\t}\n\t\t\tfz[j][i] = lst;\n\t\t}\n\t}\n\tfor (int s = 0; s < M; ++s) {\n\t\tg[s] = n + 1;\n\t}\n\tfor (int s = 1; s < M; ++s) {\n\t\tint t = s;\n\t\twhile(t) {\n\t\t\tint x = (t & (-t)), i = LOG[x], y = s ^ x, j = f[y];\n\t\t\tchkmax(f[s], j == n ? n : fy[j + 1][i]);\n\t\t\tj = g[y];\n\t\t\tchkmin(g[s], j == 1 ? 1 : fz[j - 1][i]);\n\t\t\tt ^= x;\n\t\t}\n\t}\n\tfor (int s = 0; s < M; ++s) {\n\t\tint t = M - 1 ^ s;\n\t\tint l = f[s] + 1, r = g[t] - 1;\n\t\tif(l >= r) {\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tputs(\"Possible\");\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint i = fy[l][m];\n\t\tif(i >= r) {\n\t\t\t++ans[l];\n\t\t\t--ans[r + 1];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tans[i] += ans[i - 1];\n\t\tputs(ans[i] ? \"Possible\" : \"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<vector>\n#define N 200005\nusing namespace std;\nvector<int> G[N];\nint n,m,v,a[N],r[20][N],f[1<<20],g[1<<20],ufs[20][N];\nint find(int op,int x){ return ufs[op][x] ? ufs[op][x]=find(op,ufs[op][x]) : x;}\nint main()\n{\n\tint i,j,x,p,y,T;\n\tscanf(\"%d %d\",&n,&v);\n\tfor(i=v,m=0;i;i>>=1,m++);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(i=0;i<=m;i++){\n\t\tfor(j=1;j<=n;j++) r[i][j]=j;\n\t\tfor(j=1;j<n;j++)\n\t\t\tif(a[j+1]-a[j]<=(v>>i))\n\t\t\t\tx=find(i,j),ufs[i][j+1]=x,r[i][x]=j+1;\n\t  }\n\tfor(i=1;i<(1<<m);i++)\n\t\tfor(j=0;j<m;j++)\n\t\t\tif((i>>j)&1){\n\t\t\t\tx=r[j+1][find(j+1,f[i^(1<<j)]+1)];\n\t\t\t\tf[i]=max(f[i],x);\n\t\t\t  }\n\tfor(i=0;i<(1<<m);i++) g[i]=n+1;\n\tfor(i=1;i<(1<<m);i++)\n\t\tfor(j=0;j<m;j++)\n\t\t\tif((i>>j)&1){\n\t\t\t\tx=find(j+1,g[i^(1<<j)]-1);\n\t\t\t\tg[i]=min(g[i],x);\n\t\t\t  }\n\tT=(1<<m)-1,p=y=0;\n\tfor(i=0;i<=T;i++)\n\t\tG[g[T^i]].push_back(f[i]);\n\tfor(i=1;i<=n;i++){\n\t\tx=find(0,i);\n\t\twhile(p<=r[0][x]+1){\n\t\t\tfor(j=0;j<G[p].size();j++)\n\t\t\t\ty=max(y,G[p][j]);\n\t\t\tp++;\n\t\t  }\n\t\tif(y<x-1) printf(\"Impossible\\n\");\n\t\telse printf(\"Possible\\n\");\n\t  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAXN 200010\n#define MAXS 1000010\nusing namespace std;\n\nint read(){\n    char c;\n    while(((c=getchar())<'0' || c>'9') && c!='-');\n    int flag=1;\n    int res=c-'0';\n    if(c=='-'){\n        flag=-1;\n        res=0;\n    }\n    while((c=getchar())>='0' && c<='9') res=res*10+c-'0';\n    return res*flag;\n}\n\nint n,m,v0,maxs;\nint a[MAXN];\nint lim[MAXN];\nint f1[MAXS],f2[MAXS];\nint p[20][MAXN][2];\nint c[MAXN];\n\nvoid calcP(int l){\n    int last=1;\n    for(int i=1;i<=n;i++){\n        if(i==n || a[i+1]-a[i]>lim[l]){\n            for(int j=last;j<=i;j++){\n                p[l][j][0]=last;\n                p[l][j][1]=i;\n            }\n            last=i+1;\n        }\n    }\n    p[l][0][0]=1;\n    p[l][n+1][1]=n;\n}\n\nvoid dp(){\n    f1[0]=0; f2[0]=n+1;\n    for(int s=1;s<maxs;s++){\n        f2[s]=n+1;\n        for(int i=1,l=1;i<=m;i++,l<<=1)\n            if(s&l){\n                f1[s]=max(f1[s],p[i][f1[s^l]+1][1]);\n                f2[s]=min(f2[s],p[i][f2[s^l]-1][0]);\n            }\n    }\n}\n\nint main(){\n#ifdef DEBUG\n    freopen(\"g012e.in\",\"r\",stdin);\n#endif\n    n=read(); v0=read();\n    for(int i=1;i<=n;i++) a[i]=read();\n    lim[0]=v0;\n    while(v0) lim[++m]=(v0/=2);\n    maxs=1<<m;\n    for(int i=0;i<=m;i++) calcP(i);\n    dp();\n    memset(c,-1,sizeof c);\n    for(int i=0;i<maxs;i++)\n        c[f2[i]]=max(c[f2[i]],f1[(maxs-1)^i]);\n    int cur=-1,now=-1;\n    for(int i=1;i<=n;i++)\n        if(p[0][i][0]==i){\n            while(cur<p[0][i][1]+1) now=max(now,c[++cur]);\n            if(now>=i-1)\n                for(int j=p[0][i][0];j<=p[0][i][1];j++)\n                    puts(\"Possible\");\n            else\n                for(int j=p[0][i][0];j<=p[0][i][1];j++)\n                    puts(\"Impossible\");\n        }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define N 820000\nusing namespace std;\nint f[N][32],g[N][32];\nint tot,sum[N],n,v,a[N],b[N];\nint l[N],r[N];\nint check(int x,int y){\n\tx++;\n\tif(f[x][tot]<y-1)return 0;\n\ty=f[x][tot];\n\tx=g[y][tot];\n\tsum[x]++;\n\tsum[y+1]--;\n}\nint cal(){\n\tmemset(r,0x7f,sizeof(r));\n\tmemset(l,0,sizeof(l));\n\tr[0]=n+1;\n\tfor(int i=0;i<1<<tot;i++){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(i&(1<<(j-1)))continue;\n\t\t\tl[i|(1<<(j-1))]=max(l[i|(1<<(j-1))],f[l[i]+1][j]);\n\t\t\tr[i|(1<<(j-1))]=min(r[i|(1<<(j-1))],g[r[i]-1][j]);\n\t\t\tif(l[i]==n)l[i|(1<<(j-1))]=n;\n\t\t\tif(r[i]==1)r[i|(1<<(j-1))]=1;\n\t\t}\n\t}\n\tint o=(1<<(tot-1))-1;\n\tfor(int i=0;i<=o;i++){\n\t\tcheck(l[i],r[o^i]);\n\t}\n\tfor(int i=0;i<=n;i++)sum[i]+=sum[i-1];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\twhile(v)b[++tot]=v,v/=2;\n\tb[++tot]=v;\n\tsort(b+1,b+1+tot);\n\tfor(int i=1;i<=tot;i++)f[n][i]=n;\n\tfor(int i=n-1;i>=1;i--){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(a[i+1]-a[i]<=b[j])f[i][j]=f[i+1][j];\n\t\t\telse f[i][j]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot;i++)f[n+1][i]=n;\n\tfor(int i=1;i<=tot;i++)g[1][i]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(a[i]-a[i-1]<=b[j])g[i][j]=g[i-1][j];\n\t\t\telse g[i][j]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot;i++)g[0][i]=1;\n\tcal();\n\tfor(int i=1;i<=n;i++){\n\t\tif(sum[i]>0)printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\nusing namespace std;\nconst int maxn=200000+10,lgn=20;\nint f[maxn*2],g[maxn*2],mi[maxn],left[maxn][lgn+10],right[maxn][lgn+10],v[lgn+10],x[maxn];\nint i,j,k,l,r,s,t,n,m,tot,top;\nint main(){\n\tscanf(\"%d%d\",&n,&t);\n\tfo(i,1,n) scanf(\"%d\",&x[i]);\n\tv[0]=t;\n\tt/=2;\n\twhile (t){\n\t\tv[++top]=t;\n\t\tt/=2;\n\t}\n\tv[++top]=0;\n\treverse(v,v+top+1);\n\tfo(j,0,top){\n\t\tleft[1][j]=1;\n\t\tfo(i,2,n)\n\t\t\tif (x[i]-x[i-1]<=v[j]) left[i][j]=left[i-1][j];else left[i][j]=i;\n\t\tright[n][j]=n;\n\t\tfd(i,n-1,1)\n\t\t\tif (x[i+1]-x[i]<=v[j]) right[i][j]=right[i+1][j];else right[i][j]=i;\n\t}\n\tf[0]=0;\n\tg[0]=n+1;\n\tfo(s,1,(1<<(top+1))-1){\n\t\tf[s]=0;\n\t\tg[s]=n+1;\n\t\tfo(i,0,top)\n\t\t\tif (s&(1<<i)){\n\t\t\t\tr=s^(1<<i);\n\t\t\t\tif (f[r]==n) f[s]=n;\n\t\t\t\telse f[s]=max(f[s],right[f[r]+1][i]);\n\t\t\t\tif (g[r]==1) g[s]=1;\n\t\t\t\telse g[s]=min(g[s],left[g[r]-1][i]);\n\t\t\t}\n\t}\n\tfo(i,0,n) mi[i]=n+2;\n\tfo(i,0,(1<<top)-1){\n\t\tr=((1<<top)-1)^i;\n\t\tmi[f[i]]=min(mi[f[i]],g[r]);\n\t}\n\tfd(i,n-1,0) mi[i]=min(mi[i],mi[i+1]);\n\tfo(i,1,n){\n\t\tl=left[i][top];r=right[i][top];\n\t\tif (mi[l-1]<=r+1) printf(\"Possible\\n\");else printf(\"Impossible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <cstdio>\n#include <iostream>\n#include <cstdlib>\n\nnamespace IO\n{\n//    inline char gc()\n//    {\n//        static char s[1<<20|1]={0},*p1=s,*p2=s;\n//        return (p1==p2)&&(p2=(p1=s)+fread(s,1,1<<20,stdin),p1==p2)?EOF:*(p1++);\n//    }\n\tinline char gc() { return getchar(); }\n\tinline long long read()\n\t{\n\t\tlong long ret=0;bool flag=0;char c=gc();\n\t\twhile ((c<'0')|(c>'9')) flag ^= !(c^'-'),c=gc();\n\t\twhile ((c>='0')&(c<='9')) ret=(ret<<1)+(ret<<3)+(c^'0'),c=gc();\n\t\treturn flag?-ret:ret;\n \t}\n \tchar OutputAns[1<<20|1],*OutputCur = OutputAns;\n \tinline void output()\n \t{\n \t\tOutputCur -= fwrite(OutputAns,1,OutputCur - OutputAns,stdout);\n\t}\n\tinline void print(long long ans)\n\t{\n\t\tchar s[20]={0};\n\t\tif (OutputCur - OutputAns + sprintf(s,\"%lld\",ans) >> 20) output();\n\t\tOutputCur += sprintf(OutputCur,\"%lld\",ans);\n\t}\n\tinline void printc(char c)\n\t{\n\t\tif (OutputCur - OutputAns + 1 >> 20) output();\n\t\t*(OutputCur++) = c;\n\t}\n}\n\nusing IO::read;\nusing IO::print;\nusing IO::printc;\nusing IO::output;\n\nconst int M = 3e5 + 11;\n\nconst int INF = 1e9 + 7;\n\nint End[25][M], Fir[25][M], Dp1[M], Dp2[M], Pos[M], T[25];\n\nint n, lim, top, sumBlock;\n\ninline void Input()\n{\n\tn = read(), lim = read(); for (int i = 1;i <= n; ++i) Pos[i] = read();\n\tint tmp = lim; while (tmp) { T[top++] = tmp >> 1; tmp >>= 1; } T[top] = lim;\n}\n\ninline void Solve()\n{\n\tfor (int i = 0;i <= top; ++i)\n\t{\n\t\tFir[i][1] = 1;\n\t\tfor (int j = 2;j <= n; ++j)\n\t\t{\n\t\t\tif (Pos[j] - Pos[j - 1] <= T[i]) Fir[i][j] = Fir[i][j - 1];\n\t\t\telse Fir[i][j] = j;\n\t\t}\n\t}\n\tfor (int i = 0;i <= top; ++i)\n\t{\n\t\tEnd[i][n] = n;\n\t\tfor (int j = n - 1; j >= 1; --j)\n\t\t{\n\t\t\tif (Pos[j + 1] - Pos[j] <= T[i]) End[i][j] = End[i][j + 1];\n\t\t\telse { End[i][j] = j; if (i == top) ++sumBlock; }\n\t\t}\n\t} \n\tif (sumBlock > top)\n\t{\n\t\tfor (int i = 1;i <= n; ++i) puts(\"Impossible\");\n\t\texit(0);\n\t} int all = (1<<top);\n\tfor (int s = 0;s < all; ++s) Dp2[s] = n + 1;\n\tfor (int S = 0;S < all; ++S)\n\t\tfor (int i = 0;i <= top; ++i)\n\t\t\tif (!((1<<i) & S))\t\n\t\t\t\tDp1[S | (1<<i)] = std::max(Dp1[S | (1<<i)], End[i][Dp1[S] + 1]),\n\t\t\t\tDp2[S | (1<<i)] = std::min(Dp2[S | (1<<i)], Fir[i][Dp2[S] - 1]);\n\tfor (int i = 1;i <= n; ++i)\n\t{\n\t\tbool ok = 0;\n\t\tfor (int S = 0;S < all; ++S)\n\t\t{\n\t\t\tint ss = (all - 1) ^ S;\n\t\t\tif (Dp1[S] >= i - 1 && Dp2[ss] <= End[top][i] + 1) { ok = 1; break; }\n\t\t}\n\t\tfor (int j = i;j <= End[top][i]; ++j)\n\t\t{\n\t\t\tif (ok) puts(\"Possible\");\n\t\t\telse puts(\"Impossible\");\n\t\t} i = End[top][i];\n\t}\n}\n\nint main(void)\n{\n//\tfreopen(\"jump.in\",\"r\",stdin);\n///\tfreopen(\"jump.out\",\"w\",stdout);\n\tInput();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nconst int N = 200010;\n\nint n, V, X[N], dep = 0;\nint L[20][N], R[20][N];\nint exL[N << 4], exR[N << 4];\npii seg[N];\nbool ans[N];\n\nint main() {\n  scanf(\"%d%d\", &n, &V);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &X[i]);\n  X[0] = -INF - V - 1, X[n + 1] = INF + V + 1;\n  for (int v = V; v >= 0; v >>= 1, dep++) {\n    R[dep][n + 1] = n + 1;\n    for (int i = 1; i <= n; i++)\n      L[dep][i] = (X[i] - X[i - 1] <= v) ? L[dep][i - 1] : i;\n    for (int i = n; i >= 1; i--)\n      R[dep][i] = (X[i + 1] - X[i] <= v) ? R[dep][i + 1] : i;\n    if (v == 0) {\n      dep++;\n      break;\n    }\n  }\n  for (int i = 1; i <= n; i++) seg[i] = pii(L[0][i], R[0][i]);\n  int cnt = unique(seg + 1, seg + 1 + n) - (seg + 1);\n  for (int i = 0; i < (1 << dep); i++) exR[i] = n + 1;\n  for (int s = 0; s < (1 << dep); s += 2)\n    for (int i = 0; i < dep; i++) {\n      if (!(s & (1 << i))) continue;\n      exL[s] = max(exL[s], R[i][exL[s ^ (1 << i)] + 1]);\n      exR[s] = min(exR[s], L[i][exR[s ^ (1 << i)] - 1]);\n    }\n  if (cnt <= dep) {\n    for (int i = 1; i <= cnt; i++)\n      for (int s = 0; s < (1 << dep); s += 2)\n        if (exL[s] >= seg[i].first - 1 &&\n            exR[(1 << dep) - 1 - s - 1] <= seg[i].second + 1) {\n          for (int j = seg[i].second; j <= seg[i].second; j++) ans[j] = 1;\n          break;\n        }\n  }\n  for (int i = 1; i <= n; i++) puts(ans[i] ? \"Possible\" : \"Impossible\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint nxt[21][202020];\nint bef[21][202020];\nint dp1[1102020], dp2[1102020];\nint d[202020];\nint ans[202020];\nint main()\n{\n\tint num, gen;\n\tscanf(\"%d%d\", &num, &gen);\n\td[0] = -1010101010, d[num + 1] = 1010101010;\n\tfor (int i = 1; i <= num; i++)scanf(\"%d\", &d[i]);\n\tint pt = 0;\n\tfor (;;)\n\t{\n\t\tint now = 0;\n\t\tfor (int i = 1; i <= num + 1; i++)\n\t\t{\n\t\t\tif (d[i] - d[i - 1] > gen)now = i - 1;\n\t\t\tbef[pt][i] = now;\n\t\t}\n\t\tbef[pt][0] = 0;\n\t\tnow = num + 1;\n\t\tfor (int i = num; i >= 0; i--)\n\t\t{\n\t\t\tif (d[i + 1] - d[i] > gen)now = i + 1;\n\t\t\tnxt[pt][i] = now;\n\t\t}\n\t\tnxt[pt][num + 1] = num + 1;\n\t\tpt++;\n\t\tif (gen == 0)break;\n\t\tgen /= 2;\n\t}\n\t//for (int i = 0; i <= num + 1; i++)printf(\"%d %d\\n\", nxt[0][i], bef[0][i]);\n\tfill(dp1, dp1 + (1 << pt), 1);\n\tfor (int p = 0; p < (1 << pt); p++)\n\t{\n\t\tfor (int i = 0; i < pt; i++)\n\t\t{\n\t\t\tif (p&(1 << i))continue;\n\t\t\tdp1[p + (1 << i)] = max(dp1[p + (1 << i)], nxt[i][dp1[p]]);\n\t\t}\n\t}\n\tfill(dp2, dp2 + (1 << pt), num);\n\tfor (int p = 0; p < (1 << pt); p++)\n\t{\n\t\tfor (int i = 0; i < pt; i++)\n\t\t{\n\t\t\tif (p&(1 << i))continue;\n\t\t\tdp2[p + (1 << i)] = min(dp2[p + (1 << i)], bef[i][dp2[p]]);\n\t\t}\n\t}\n\t//for (int i = 0; i < (1 << pt); i++)printf(\"%d %d\\n\", dp1[i], dp2[i]);\n\tfor (int p = 0; p < (1 << pt); p+=2)\n\t{\n\t\tint q = (1 << pt) - 2 - p;\n\t\tif (nxt[0][dp1[p]]>dp2[q])ans[dp1[p]] = 1;\n\t}\n\tint t = 0;\n\tfor (;;)\n\t{\n\t\tif (ans[t])\n\t\t{\n\t\t\tfor (int j = t; j < nxt[0][t]; j++)ans[j] = 1;\n\t\t\tt = nxt[0][t];\n\t\t}\n\t\telse t++;\n\t\tif (t == num + 1)break;\n\t}\n\tfor (int i = 1; i <= num; i++)printf(ans[i] ? \"Possible\\n\" : \"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<unordered_map>\n//#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define chmax(a,b) a=max(a,b);\n#define N (1<<18)\n#define M 19\nll n,v;\nclass Alpha{\n public:\n ll f[N];\n P g[N][M];\n void setg(ll a[]){\n     for(int k=0;k<M;k++){\n         for(int i=0;i<n;i++)g[i][k]=make_pair(i,i);\n         ll bef=-1e18,pnt=0; a[n]=1e18;\n         for(int i=0;i<=n;i++){\n          if(abs(a[i]-bef)>(v>>k)){\n           for(int j=pnt;j<i;j++)g[j][k]=make_pair(pnt,i-1);\n           pnt=i;   \n          }\n          bef=a[i];\n         }\n         if((v>>k)==0)break;\n     }\n }\n void main(ll a[]){\n  setg(a);   \n  for(int i=0;i<N;i++)f[i]=-1;\n  for(int i=0;i<N;i++){\n      for(int j=0;j<M-1;j++){\n          if(i&(1<<j))continue;\n          chmax(f[i+(1<<j)],g[f[i]+1][j+1].second);\n      }\n  }\n  //for(int i=0;i<16;i++)cout<<f[i]<<\" \";cout<<endl;\n }\n};Alpha L,R;\n\nclass Solve{\n  public:\n  unordered_map<ll,bool> mas;\n  bool main(ll l,ll r){\n      if(mas.size()>30)return 0;\n      if(mas.find(l)!=mas.end()){\n       return mas[l];   \n      }\n      bool res=0;\n      int cnt=0;\n      for(int x=v;x;x>>=1)cnt++;\n      int who=1;\n      for(int i=0;i<cnt;i++)who*=2;//cout<<who<<endl;\n      for(int i=0;i<who;i++){\n       int ls=i,rs=who-1-i;\n       if(l-1<=L.f[ls]&&n-1-R.f[rs]<=r+1)res=1;\n      }\n      mas[l]=res;\n      return res;\n  }\n};Solve sv;\n\nll a[N];\nint main(){\n    cin>>n>>v;\n    for(int i=0;i<n;i++)cin>>a[i];\n    L.main(a);\n    for(int i=0;i<n/2;i++)swap(a[i],a[n-i-1]);\n    R.main(a);\n    for(int i=0;i<n;i++){\n     bool ans=sv.main(L.g[i][0].first,L.g[i][0].second);   \n     cout<<(ans?\"Possible\":\"Impossible\")<<endl;\n    }\n return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define MAX 200200\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nvoid cmax(int &x,int y){if(x<y)x=y;}\nvoid cmin(int &x,int y){if(x>y)x=y;}\nint n,V[25],x[MAX],t;\nint L[20][MAX],R[20][MAX],mr[MAX];\nint sl[1<<19],sr[1<<19];\nint main()\n{\n\tn=read();V[0]=read();\n\tfor(int i=1;i<=n;++i)x[i]=read();\n\twhile(V[t])V[t+1]=V[t]>>1,++t;int S=1<<t;\n\tfor(int i=0;i<=t;++i)\n\t{\n\t\tL[i][1]=1;R[i][n]=n;\n\t\tfor(int j=2;j<=n;++j)\n\t\t\tif(x[j]-x[j-1]<=V[i])L[i][j]=L[i][j-1];\n\t\t\telse L[i][j]=j;\n\t\tfor(int j=n-1;~j;--j)\n\t\t\tif(x[j+1]-x[j]<=V[i])R[i][j]=R[i][j+1];\n\t\t\telse R[i][j]=j;\n\t}\n\tfor(int i=1;i<S;++i)sl[i]=1,sr[i]=n;\n\tsl[0]=0;sr[0]=n+1;\n\tfor(int i=0;i<S;++i)\n\t\tfor(int j=1;j<=t;++j)\n\t\t\tif(!(i&(1<<(j-1))))\n\t\t\t{\n\t\t\t\tcmax(sl[i|(1<<(j-1))],R[j][sl[i]+1]);\n\t\t\t\tcmin(sr[i|(1<<(j-1))],L[j][sr[i]-1]);\n\t\t\t}\n\tmemset(mr,63,sizeof(mr));\n\tfor(int j=0;j<S;++j)cmin(mr[sl[j]],sr[(S-1)^j]);\n\tfor(int i=n;~i;--i)mr[i]=min(mr[i],mr[i+1]);\n\tfor(int i=1;i<=n;++i)puts(mr[L[0][i]-1]<=R[0][i]+1?\"Possible\":\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint po[1000100];\n\nint mlg;\nvector<int>li[22];\nint mr[22][1000100];\nint ml[22][1000100];\nvoid get_line(int pos,int ma)\n{\n\tli[pos].push_back(0);\n//\tcout<<endl;\n//\tcout<<\"pos: \"<<pos<<\" ma: \"<<ma<<endl;\n\tfor(int i=1;i<=n;++i)\n\t\tif(i==1||po[i]-po[i-1]>ma)\n\t\t\tli[pos].push_back(i);\n\tli[pos].push_back(n+1);\n\tfor(int i=1,p=0;i<=n;++i)\n\t{\n\t\tmr[pos][i]=mr[pos][i-1];\n\t\tif(i==li[pos][p+1])\n\t\t\tp++,mr[pos][i]=li[pos][p+1]-1;\n\t}\n\tmr[pos][n+1]=n;\n\tml[pos][n+1]=n+1;\n\tfor(int i=n,p=li[pos].size()-1;i;--i)\n\t{\n\t\tml[pos][i]=ml[pos][i+1];\n\t\tif(i==li[pos][p]-1)\n\t\t\tp--,ml[pos][i]=li[pos][p];\n\t}\n//\tcout<<\"mr: \";for(int i=1;i<=n;++i)cout<<mr[pos][i]<<\" \";cout<<endl;\n//\tcout<<\"ml: \";for(int i=1;i<=n;++i)cout<<ml[pos][i]<<\" \";cout<<endl;\n}\n\nint pre[1000100],suf[1000100];\nint ans[22];\nvoid out(int ma)\n{\n\tfor(int i=1;i<=ma;++i)\n\t\tfor(int j=li[0][i];j<li[0][i+1];++j)\n\t\t\tputs(ans[i]?\"Possible\":\"Impossible\");\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&po[i]);\n\tfor(int tm=m;tm;mlg++,tm>>=1) get_line(mlg,tm);\n\tget_line(mlg,0);mlg++; \n\tint s=1<<mlg,nxt;\n\tmemset(suf,0x3f,sizeof(suf));\n\tsuf[0]=n+1;\n//\tcout<<\"s: \"<<s<<endl;\n\tfor(int i=0;i<s;++i)\n\t{\n//\t\tcout<<\"i: \"<<i<<\" pre: \"<<pre[i]<<\" suf: \"<<suf[i]<<endl;\n\t\tfor(int j=0;j<mlg;++j)\n\t\t{\n\t\t\tif((i>>j)&1)continue;\n\t\t\tnxt=(i|(1<<j));\n\t\t\tpre[nxt]=max(pre[nxt],mr[j][pre[i]+1]);\n\t\t\tsuf[nxt]=min(suf[nxt],ml[j][suf[i]-1]);\n\t\t}\n\t}\n\tint ma=li[0].size()-2;\n\tif(ma>mlg)\n\t{\n\t\tfor(int i=1;i<=n;++i)puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\ts--;\n\tint ls=(s^1);\n\tfor(int i=1,L,R;i<=ma;++i)\n\t{\n\t\tL=li[0][i];R=li[0][i+1]-1;\n\t\tfor(int j=0;j<=s;++j)\n\t\t{\n\t\t\tif(j&1)continue;\n//\t\t\tcout<<\"j: \"<<j<<\" invj: \"<<((s^j)&ls)<<endl;\n\t\t\tif(pre[j]>=L-1&&suf[(s^j)&ls]<=R+1)\n\t\t\t{\n\t\t\t\tans[i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tout(ma);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/// a.cpp\n\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < __typeof(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < ll >\n# define pb push_back\n# define pdd pair < db , db >\ninline int readChar();\ntemplate <class T = int> inline T readInt();\ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x );\ninline void writeWord( const char *s );\n\n/** Read */\n\nstatic const int buf_size = 4096;\n\ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len)\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    if (pos == len)\n        return -1;\n    return buf[pos++];\n}\n\ninline int readChar() {\n    int c = getChar();\n    while (c <= 32)\n        c = getChar();\n    return c;\n}\n\ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n\n/** Write */\n\nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n\ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n\ntemplate <class T>\ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n\n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n\ninline void writeWord( const char *s ) {\n    while (*s)\n        writeChar(*s++);\n}\n\nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int Dp1[20][1 << 20];\n    static int Dp2[20][1 << 20];\n    int n,k;\n    n = readInt();\n    k = readInt();\n    vi ss;\n    ss.pb(k / 2);\n    while (ss.back()) ss.pb(ss.back() / 2);\n    static int s[1 << 20];\n    for (int i = 1;i <= n;++i)\n        s[i] = readInt();\n    static int D1[1 << 20];\n    static int D2[1 << 20];\n    const int lg = ss.size();\n    const int N = 1 << lg;\n    for (int t = 0;t < lg;++t)\n    {\n        Dp1[t][1] = 0;\n        for (int i = 2;i <= n;++i)\n            if (s[i] - s[i - 1] <= ss[t])\n                Dp1[t][i] = Dp1[t][i - 1];\n            else\n                Dp1[t][i] = i - 1;\n        Dp2[t][n] = Dp2[t][n + 1] = n + 1;\n        for (int i = n - 1;i;--i)\n            if (s[i + 1] - s[i] <= ss[t])\n                Dp2[t][i] = Dp2[t][i + 1];\n            else\n                Dp2[t][i] = i + 1;\n    }\n    D1[0] = 0;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            if ((mask >> i) & 1)\n                smax(D1[mask],Dp2[i][D1[mask ^ (1 << i)] + 1] - 1);\n    for (int mask = 0;mask < N;++mask)\n        D2[mask] = n + 1;\n    for (int mask = 1;mask < N;++mask)\n        for (int i = 0;i < lg;++i)\n            smin(D2[mask],Dp1[i][D2[mask ^ (1 << i)] - 1] + 1);\n    static int answer[1 << 20];\n    static int tt[1 << 20];\n    tt[1] = 1;\n    for (int i = 2;i <= n;++i)\n        if (s[i] - s[i - 1] <= k)\n            tt[i] = tt[i - 1];\n        else\n            tt[i] = i;\n    for (int mask = 0;mask < N;++mask)\n    {\n        const int l = D1[mask] + 1;\n        const int r = D2[(N - 1) ^ mask] - 1;\n        if (l > r)\n            ++answer[1],--answer[n + 1];\n        if (tt[r] <= l)\n            ++answer[l],--answer[r + 1];\n    }\n    for (int i = 1;i <= n;++i)\n        answer[i] += answer[i - 1];\n    for (int i = 1;i <= n;++i)\n        if (answer[i])\n            PP;\n        else\n            II;\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1009LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> ii;\ntypedef pair<ii, ii> i4;\n \nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n\n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nconst int N = 200005;\nint n, arr[N], sz, V, next_right[20][N], next_left[20][N];\nint DP_left[1<<20], DP_right[1<<20];\nvector<int> steps;\n\nint dp_left(int mask){\n    int &ans = DP_left[mask];\n    if(ans != -1)   return ans;\n    ans = 1;\n    for(int i=0;i<sz;i++)\n        if((mask >> i) & 1)\n            ans = max(ans, next_right[i][dp_left(mask^(1<<i))+1]);\n    return ans;\n}\n\nint dp_right(int mask){\n    int &ans = DP_right[mask];\n    if(ans != -1)   return ans;\n    ans = n;\n    for(int i=0;i<sz;i++)\n        if((mask >> i) & 1)\n            ans = min(ans, next_left[i][dp_right(mask^(1<<i))-1]);\n    return ans;\n}\n\n\n\nbool possible(int l, int r){\n    int mask = (1<<sz)-2; \n    for(int i=mask;i>=0;i=(i-1)&mask){\n// cout<<i<<\" \"<<(mask^i)<<\" \"<<mask<<\" \"<<dp_left(i)<<\" \"<<dp_right(mask^i)<<endl;\n        if((l==1 || dp_left(i) >= l-1) && (r==n || dp_right(mask^i) <= r+1))    return true;\n        if(i == 0)  break;\n    }\n    return false;\n}\n\n\nint main(){\n \n    // ios_base::sync_with_stdio(0);\n    // cin.tie(0);\n\n    scanf(\"%d%d\", &n, &V);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\", &arr[i]);\n\n    while(V){\n        steps.pb(V);\n        V /= 2;\n    }\n    steps.pb(0);\n    sz = (int)steps.size();\n\n    for(int k=0;k<sz;k++){\n\n        next_right[k][n+1] = n+1;\n        next_right[k][n] = n;\n        for(int i=n-1;i>=1;i--)\n            if(arr[i+1]-arr[i] <= steps[k])\n                next_right[k][i] = next_right[k][i+1];\n            else\n                next_right[k][i] = i;\n\n        next_left[k][0] = 0;\n        next_left[k][1] = 1;\n        for(int i=2;i<=n;i++)\n            if(arr[i]-arr[i-1] <= steps[k])\n                next_left[k][i] = next_left[k][i-1];\n            else\n                next_left[k][i] = i;\n    }\n\n    int comps = 0, curr = 1;\n    while(curr <= n){\n        comps++;\n        curr = next_right[0][curr] + 1;\n    }\n\n    if(comps > sz+2){\n        for(int i=1;i<=n;i++)\n            printf(\"Impossible\\n\");\n        return 0;\n    }\n\n// cout<<\"steps: \";for(auto it : steps)    cout<<it<<\" \";cout<<endl;\n// cout<<\"next_right:\\n\";\n// for(int i=1;i<=n;i++){\n//     cout<<i<<\": \";for(int j=0;j<sz;j++) cout<<next_right[j][i]<<\" \";cout<<endl;\n// }cout<<endl;\n// cout<<\"next_left:\\n\";\n// for(int i=1;i<=n;i++){\n//     cout<<i<<\": \";for(int j=0;j<sz;j++) cout<<next_left[j][i]<<\" \";cout<<endl;\n// }cout<<endl;\n\n\n    memset(DP_left, -1, sizeof(DP_left));\n    memset(DP_right, -1, sizeof(DP_right));\n    curr = 1;\n    while(curr <= n){\n        if(possible(curr, next_right[0][curr])){\n            for(int i=curr;i<=next_right[0][curr];i++)\n                printf(\"Possible\\n\");\n        }\n        else{\n            for(int i=curr;i<=next_right[0][curr];i++)\n                printf(\"Impossible\\n\");\n        }\n        curr = next_right[0][curr]+1;\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// AT 2365\n// DeP\n#include <cctype>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nnamespace IO {\n    const int MAXSIZE = 1 << 18 | 1;\n    char buf[MAXSIZE], *p1, *p2;\n\n    inline int Gc() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2)? EOF: *p1++; }\n    template<class T> void read(T& x) {\n        x = 0; int f = 0, ch = Gc();\n        while (!isdigit(ch)) f |= ch == '-', ch = Gc();\n        while (isdigit(ch)) x = x * 10 + ch - '0', ch = Gc();\n        if (f) x = -x;\n    }\n}\nusing IO::read;\n\ntypedef pair<int, int> Pii;\nconst int MAXN = 1e6+5, LOG = 21, INF = 0x3f3f3f3f;\n\nint n, V;\nint X[MAXN], f[MAXN], g[MAXN];\nint L[LOG][MAXN], R[LOG][MAXN];\nbool Ans[MAXN];\nPii segs[MAXN];\n\nint main() {\n    // input\n    read(n); read(V);\n    for (int i = 1; i <= n; ++i) read(X[i]);\n    X[0] = -INF; X[n+1] = INF;\n    // solve\n    int log = 0;\n    for (int v = V; v >= 0; v /= 2, ++log) {\n        R[log][n+1] = n+1;\n        for (int i = 1; i <= n; ++i) L[log][i] = X[i] - X[i-1] <= v? L[log][i-1]: i;\n        for (int i = n; i >= 1; --i) R[log][i] = X[i+1] - X[i] <= v? R[log][i+1]: i;\n        if (!v) { ++log; break; }\n    }\n    for (int i = 1; i <= n; ++i) segs[i] = make_pair(L[0][i], R[0][i]);\n    int tot = unique(segs+1, segs+1+n) - segs - 1;\n    if (tot > log) {\n        for (int i = 1; i <= n; ++i) puts(\"Impossible\");\n        return 0;\n    }\n    for (int S = 0; S < (1 << log); ++S) f[S] = n+1;\n    for (int S = 0; S < (1 << log); S += 2) {\n        for (int i = 0; i < log; ++i) if ((S >> i) & 1) {\n            f[S] = min(f[S], L[i][f[S ^ (1 << i)] - 1]);\n            g[S] = max(g[S], R[i][g[S ^ (1 << i)] + 1]);\n        }\n    }\n    for (int i = 1; i <= tot; ++i)\n        for (int S = 0; S < (1 << log); S += 2)\n            if (g[S] >= segs[i].first-1 && segs[i].second+1 >= f[((1<<log)-1)-(S+1)]) {\n                for (int k = segs[i].first; k <= segs[i].second; ++k) Ans[k] = true;\n                break;\n            }\n    // output\n    for (int i = 1; i <= n; ++i) puts(Ans[i]? \"Possible\": \"Impossible\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Have a nice day:)\n#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\ninline int read();\n\ntypedef pair<int,int> pii;\nconst int maxn=2e5+5;\n\nint n, size, depth;\nint p[maxn], d[maxn], fr[1<<20], bk[1<<20], far[maxn], lef[maxn], rig[maxn], pos[maxn];\nvector<pii>v[maxn];\n\nvoid Work()\n{\n    n=read(), size=read();\n    for(int i=1; i<=n; ++i) p[i]=read();\n\n    d[depth=1]=size;\n    while(size) size/=2, d[++depth]=size;\n\n    for(int i=1; i<=n; ++i) v[1].push_back(make_pair(i,i));\n    for(int i=2; i<=depth; ++i)\n    {\n        v[i].push_back(v[i-1][0]);\n        for(int j=1, lim=v[i-1].size()-1; j<=lim; ++j)\n        {\n            if(p[v[i-1][j].first]-p[v[i][v[i].size()-1].second]<=d[depth+1-i])\n                v[i][v[i].size()-1].second=v[i-1][j].second;\n            else v[i].push_back(v[i-1][j]);\n        }\n    //    for(int j=v[i].size()-1; j>=0; --j)\n    //        cout<<\"(\"<<v[i][j].first<<' '<<v[i][j].second<<\")\"<<' ';\n    //    cout<<endl;\n    }\n\n    memset(fr, -1, sizeof(fr)); fr[0]=0;\n    for(int i=0, lim=(1<<(depth-1))-1; i<=lim; ++i)\n    {\n        if(fr[i]==-1) continue;\n        for(int j=1; j<=depth-1; ++j)\n        {\n            if((i>>(j-1))&1) continue;\n            int l=0, r=v[j].size()-1, ans=-1;\n            while(l<=r)\n            {\n                int mid=(l+r)>>1;\n                if(v[j][mid].first<=fr[i]+1) ans=mid, l=mid+1;\n                else r=mid-1;\n            }\n            if(ans==-1) fr[i|(1<<(j-1))]=max(fr[i|(1<<(j-1))], fr[i]);\n            else fr[i|(1<<(j-1))]=max(fr[i|(1<<(j-1))], max(fr[i], v[j][ans].second));\n        }\n    }\n\n    memset(bk, 127, sizeof(bk)); bk[0]=n+1;\n    for(int i=0, lim=(1<<(depth-1))-1; i<=lim; ++i)\n    {\n        if(bk[i]==bk[lim+1]) continue;\n        for(int j=1; j<=depth-1; ++j)\n        {\n            if((i>>(j-1))&1) continue;\n            int l=0, r=v[j].size()-1, ans=-1;\n            while(l<=r)\n            {\n                int mid=(l+r)>>1;\n                if(v[j][mid].second>=bk[i]-1) ans=mid, r=mid-1;\n                else l=mid+1;\n            }\n            if(ans==-1) bk[i|(1<<(j-1))]=min(bk[i|(1<<(j-1))], bk[i]);\n            else bk[i|(1<<(j-1))]=min(bk[i|(1<<(j-1))], min(bk[i], v[j][ans].first));\n        }\n    }\n\n    memset(far, 128, sizeof(far));\n    for(int i=v[depth].size()-1; i>=0; --i) \n    {\n        lef[i]=v[depth][i].first, rig[i]=v[depth][i].second;\n        for(int j=lef[i]; j<=rig[i]; ++j) pos[j]=i;\n    }\n\n    for(int i=(1<<(depth-1))-1; i>=0; --i)\n    {\n    //cout<<i<<' '<<fr[i]<<' '<<bk[i]<<endl;\n        far[bk[i]]=max(far[bk[i]], fr[(1<<(depth-1))-1-i]);\n    }\n    for(int i=1; i<=n; ++i)\n    {\n        far[i]=max(far[i], far[i-1]);\n  //      cout<<i<<' '<<far[i]<<endl;\n    }\n\n    for(int i=1; i<=n; ++i)\n    {\n   //     cout<<far[rig[pos[i]]]<<' '<<lef[pos[i]]<<endl;\n        if(far[rig[pos[i]]+1]+1>=lef[pos[i]]) printf(\"Possible\\n\");\n        else printf(\"Impossible\\n\");\n    }\n}\n\nint main()\n{\n\n    Work();\n\n    return 0;\n}\n\ninline int read()\n{\n    char c; bool type=1;\n    while((c=getchar())<'0' || c>'9')\n        if(c=='-') type=0;\n    int ans=c^48;\n    while((c=getchar())>='0' && c<='9')\n        ans=(ans<<3)+(ans<<1)+(c^48);\n    return type?ans:-ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\n\nint kano()\n{\n\tchar ch=getchar();int w=0,u=1;\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')u=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())w=w*10+ch-'0';\n\treturn w*u;\n}\nint n,v,o,u,mx;\nint a[200005];\nint p[21][200005],r[21][200005];\nint f[2][262145];\nbool bo[200005];\nint main()\n{\n\tn=kano();v=kano();\n\tfor(int i=1;i<=n;i++)a[i]=kano();\n\tfor(o=v,u=0;o>0;o=o>>1,u++)\n\t{\n\t\tint la=1;p[u][1]=1;r[u][1]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]-a[i-1]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tmx=1<<u;mx--; \n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tif(f[0][i]>n)f[0][i]=n;\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tf[0][i|j]=max(f[0][i|j],p[l][r[l][f[0][i]+1]]);\n\t\t}\n\t}\n\tfor(o=v>>1,u=1;o>0;o=o>>1,u++)\n\t{\n\t\tint la=n;p[u][n]=n;r[u][n]=n;\n\t\tfor(int i=n-1;i>=1;i--)\n\t\t{\n\t\t\tif(a[i+1]-a[i]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tfor(int i=0;i<=mx;i++)f[1][i]=n+1;\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tif(f[1][i]<1)f[1][i]=1;\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tf[1][i|j]=min(f[1][i|j],p[l][r[l][f[1][i]-1]]);\n\n\t\t}\n\t}\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tint j=~i&mx;\n\t\tif(r[0][f[0][i]+1]==r[0][f[1][j]-1])bo[r[0][f[0][i]+1]]=1;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(bo[r[0][i]])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, v, lg, a[200005];\n\nstruct oneside {\n\tint rb[19][200005], dt[1<<19];\n\tint solve () {\n\t\tint cv = v;\n\t\tfor(int i=0;i<=lg;i++,cv/=2) {\n\t\t\tint un = 1;\n\t\t\tfor(int j=1;j<n;j++) {\n\t\t\t\tif(a[j+1] - a[j] > cv) {\n\t\t\t\t\tfor(int k=un;k<=j;k++) rb[i][k] = j;\n\t\t\t\t\tun = j+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=un;k<=n;k++) rb[i][k] = n;\n\t\t}\n\t\tfor(int i=0;i<(1<<lg);i++) {\n\t\t\tfor(int j=1;j<=lg;j++) {\n\t\t\t\tint t = (1<<(j-1));\n\t\t\t\tif(i & t) continue;\n\t\t\t\tdt[i|t] = max(dt[i|t], rb[j][min(dt[i]+1, n)]);\n\t\t\t}\n\t\t}\n\t}\n} ls, rs;\n\nstruct segtree {\n\tint val[888888], lim;\n\tvoid init () {\n\t\tfor(lim = 1; lim <= n; lim <<= 1);\n\t}\n\tvoid update (int S, int E, int X) {\n\t\tS += lim; E += lim;\n\t\twhile(S<=E) {\n\t\t\tif(S%2 == 1) val[S] += X, S++;\n\t\t\tif(E%2 == 0) val[E] += X, E--;\n\t\t\tS>>=1; E>>=1;\n\t\t}\n\t}\n\tint query (int P) {\n\t\tP += lim;\n\t\tint ret = 0;\n\t\twhile(P) {\n\t\t\tret += val[P];\n\t\t\tP>>=1;\n\t\t}\n\t\treturn ret;\n\t}\n} seg;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++) {\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=v;i;i/=2,lg++);\n\tls.solve();\n\treverse(a+1, a+1+n);\n\tfor(int i=1;i<=n;i++) a[i] *= -1;\n\trs.solve();\n\tseg.init();\n\tfor(int i=0;i<(1<<lg);i++) {\n\t\tint t = ((1<<lg)-1)^i;\n\t\tif(ls.dt[i] + 1 > n - rs.dt[t]) {\n\t\t\tfor(int j=1;j<=n;j++) puts(\"Possible\");\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tint ss = n - rs.rb[0][min(n, rs.dt[t]+1)] + 1, se = ls.rb[0][min(n, ls.dt[i]+1)];\n\t\t\tif(ss <= se) seg.update(ss, se, 1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tputs(seg.query(i) ? \"Possible\" : \"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=2e5+50;\nint n,v,lg,x[N];\nint len[20], bin[20];\nint mxr[1<<20], mnl[1<<20];\n\nstruct BIT_MAX {\n\tint bit[N];\n\tBIT_MAX() {for(int i=0;i<N;i++) bit[i]=-1e9;}\n\tinline void inc(int p,int v) {\n\t\tfor(int i=p;i<=n+1;i+=(i&(-i))) bit[i]=max(bit[i],v);\n\t}\n\tinline int ask(int p,int v=-1e9) {\n\t\tfor(int i=p;i;i-=(i&(-i))) v=max(v,bit[i]);\n\t\treturn v;\n\t}\n\tinline void init(int lim) {\n\t\tfor(int l=1,r;l<=n;l=r+1) {\n\t\t\tr=l;\n\t\t\twhile(r<n && x[r+1]-x[r]<=lim) ++r;\n\t\t\tinc(l,r);\n\t\t}\n\t}\n} bit_max[21];\n\nstruct BIT_MIN {\n\tint bit[N];\n\tBIT_MIN() {for(int i=0;i<N;i++) bit[i]=1e9;}\n\tinline void inc(int p,int v) {\n\t\tfor(int i=p;i;i-=(i&(-i))) bit[i]=min(bit[i],v);\n\t}\n\tinline int ask(int p,int v=1e9) {\n\t\tif(!p) ++p;\n\t\tfor(int i=p;i<=n;i+=(i&(-i))) v=min(v,bit[i]);\n\t\treturn v;\n\t}\n\tinline void init(int lim) {\n\t\tfor(int l=1,r;l<=n;l=r+1) {\n\t\t\tr=l;\n\t\t\twhile(r<n && x[r+1]-x[r]<=lim) ++r;\n\t\t\tinc(r,l);\n\t\t}\n\t}\n} bit_min[20];\n\nint ok[N];\nint main() {\n\tn=rd(), v=rd();\n\tfor(int i=1;i<=n;i++) x[i]=rd();\n\t\n\tfor(int t=v;;t/=2) {\n\t\tlen[lg++]=t;\n\t\tif(!t) break;\n\t}\n\tfor(int i=0;i<lg;i++) {\n\t\tbin[i]=1<<i;\n\t\tbit_max[i].init(len[i]);\n\t\tbit_min[i].init(len[i]);\n\t} \n\t\n\tmxr[0]=0; mnl[0]=n+1; bin[lg]=1<<lg;\n\tfor(int s=1;s<bin[lg];++s) {\n\t\tif(s&1) continue;\n\t\tint mx=0, mn=n+1;\n\t\tfor(int k=0;k<lg;++k) if(s&bin[k]) {\n\t\t\tmx=max(mx,bit_max[k].ask(mxr[s^bin[k]]+1));\n\t\t\tmn=min(mn,bit_min[k].ask(mnl[s^bin[k]]-1));\n\t\t}\n\t\tmxr[s]=mx; mnl[s]=mn;\n\t}\n\t\n\tfor(int i=0;i<bin[lg];++i) {\n\t\tif(!(i&1)) {\n\t\t\tint s1=i, s2=(bin[lg]-1)^1^i;\n\t\t\tbit_max[20].inc(mnl[s2],mxr[s1]);\n\t\t}\n\t}\n\tfor(int l=1,r;l<=n;l=r+1) {\n\t\tr=l;\n\t\twhile(r<n && x[r+1]-x[r]<=v) ++r;\n\t\tif(bit_max[20].ask(r+1)>=l-1) for(int i=l;i<=r;i++) ok[i]=1;\n\t}\n\tfor(int i=1;i<=n;i++) puts((ok[i]) ? \"Possible\" : \"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 1000000\n#define INF 2000000000\nusing namespace std;\nint n,V,x[MAXN+5];\nint cnt[25];\nint l[25][MAXN+5],r[25][MAXN+5];\nint f1[MAXN*5+5],f2[MAXN*5+5];\nbool ans[MAXN+5];\nvoid Init()\n{\n\tfor(int i=0;i<=MAXN*5+3;i++)\n\t\tf1[i]=0,f2[i]=INF;\n}\nint UpFind(int id,int pos)\n{\n//\tif(cnt[id]==0)\n//\t\treturn pos;\n\tpos++;\n\tint p=upper_bound(l[id]+1,l[id]+cnt[id]+1,pos)-l[id];\n\tp--;\n\tif(p<=0)\n\t\treturn pos;\n\treturn max(r[id][p],pos-1);\n}\nint LowFind(int id,int pos)\n{\n//\tif(cnt[id]==0)\n//\t\treturn pos;\n\tpos--;\n\tint p=lower_bound(r[id]+1,r[id]+cnt[id]+1,pos)-r[id];\n\tif(p>=cnt[id]+1)\n\t\treturn pos;\n\treturn min(l[id][p],pos+1);\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d %d\",&n,&V);\n\tint logV=0;\n\tfor(logV=0;(1<<logV)<=V;logV++);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tx[n+1]=INF;\n\tx[0]=-INF;\n\tfor(int LG=0;LG<=logV;LG++)\n\t{\n\t\tint d=V/(1<<LG);\n\t\tcnt[LG]=1;\n\t\tl[LG][1]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tr[LG][cnt[LG]]=i;\n\t\t\tif(x[i+1]-x[i]>d)\n\t\t\t{\n\t\t\t\tcnt[LG]++;\n\t\t\t\tl[LG][cnt[LG]]=i+1;\n\t\t\t}\n\t\t}\n\t\tcnt[LG]--;\n\t}\n\tif(cnt[0]>logV+1)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint all=(1<<(logV+1));\n\tf1[0]=0,f2[0]=n+1;\n\tfor(int s=0;s<all;s+=2)\n\t\tfor(int i=0;i<=logV;i++)\n\t\t{\n\t\t\tif(!(s&(1<<i)))\n\t\t\t\tcontinue;\n\t\t\tf1[s]=max(f1[s],UpFind(i,f1[s-(1<<i)]));\n\t\t\tf2[s]=min(f2[s],LowFind(i,f2[s-(1<<i)]));\n\t\t}\n\tfor(int i=1;i<=cnt[0];i++)\n\t{\n\t\tint ln=l[0][i],rn=r[0][i];\n\t\tfor(int s1=0;s1<all;s1+=2)\n\t\t{\n\t\t\tint s2=all-1-s1-1;\n\t\t\tint lpos=f1[s1];\n\t\t\tint rpos=f2[s2];\n\t\t\tif(lpos>=ln-1&&rpos<=rn+1)\n\t\t\t{\n\t\t\t\tans[i]=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint pos=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(ans[pos]==true)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t\tif(x[i+1]-x[i]>V)\n\t\t\tpos++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 1000000\n#define INF 2000000000\nusing namespace std;\nint n,V,x[MAXN+5];\nint cnt[25];\nint l[25][MAXN+5],r[25][MAXN+5];\nint f1[MAXN*5+5],f2[MAXN*5+5];\nbool ans[MAXN+5];\nvoid Init()\n{\n\tfor(int i=0;i<=MAXN*2+3;i++)\n\t\tf1[i]=0,f2[i]=INF;\n}\nint UpFind(int id,int pos)\n{\n//\tif(cnt[id]==0)\n//\t\treturn pos;\n\tpos++;\n\tint p=upper_bound(l[id]+1,l[id]+cnt[id]+1,pos)-l[id];\n\tp--;\n\tif(p<=0)\n\t\treturn pos;\n\treturn max(r[id][p],pos-1);\n}\nint LowFind(int id,int pos)\n{\n//\tif(cnt[id]==0)\n//\t\treturn pos;\n\tpos--;\n\tint p=lower_bound(r[id]+1,r[id]+cnt[id]+1,pos)-r[id];\n\tif(p>=cnt[id]+1)\n\t\treturn pos;\n\treturn min(l[id][p],pos+1);\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d %d\",&n,&V);\n\tint logV=0;\n\tfor(logV=0;(1<<logV)<=n;logV++);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tx[n+1]=INF;\n\tx[0]=-INF;\n\tfor(int LG=0;LG<=logV;LG++)\n\t{\n\t\tint d=V/(1<<LG);\n\t\tcnt[LG]=1;\n\t\tl[LG][1]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tr[LG][cnt[LG]]=i;\n\t\t\tif(x[i+1]-x[i]>d)\n\t\t\t{\n\t\t\t\tcnt[LG]++;\n\t\t\t\tl[LG][cnt[LG]]=i+1;\n\t\t\t}\n\t\t}\n\t\tcnt[LG]--;\n\t}\n\tif(cnt[0]>logV)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint all=(1<<(logV+1));\n\tf1[0]=0,f2[0]=n+1;\n\tfor(int s=0;s<all;s+=2)\n\t\tfor(int i=0;i<=logV;i++)\n\t\t{\n\t\t\tif(!(s&(1<<i)))\n\t\t\t\tcontinue;\n\t\t\tf1[s]=max(f1[s],UpFind(i,f1[s-(1<<i)]));\n\t\t\tf2[s]=min(f2[s],LowFind(i,f2[s-(1<<i)]));\n\t\t}\n\tfor(int i=1;i<=cnt[0];i++)\n\t{\n\t\tint ln=l[0][i],rn=r[0][i];\n\t\tfor(int s1=0;s1<all;s1+=2)\n\t\t{\n\t\t\tint s2=all-1-s1-1;\n\t\t\tint lpos=f1[s1];\n\t\t\tint rpos=f2[s2];\n\t\t\tif(lpos>=ln-1&&rpos<=rn+1)\n\t\t\t{\n\t\t\t\tans[i]=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint pos=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(ans[pos]==true)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t\tif(x[i+1]-x[i]>V)\n\t\t\tpos++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,v,x[SZ],a[SZ],k=0;\nvector<int> gu[55];\nint L[1234567],R[1234567],mx[1234567];\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",x+i);\n\tfor(int i=n;i>=2;--i) x[i]-=x[i-1];\n\ta[k++]=v; while(a[k-1]) a[k]=a[k-1]/2,++k;\n\tfor(int i=0;i<k;++i)\n\t{\n\t\tgu[i].pb(1);\n\t\tfor(int j=2;j<=n;++j)\n\t\t\tif(x[j]>a[i]) gu[i].pb(j);\n\t\tgu[i].pb(n+1);\n\t}\n\tfor(int i=2;i<(1<<k);i+=2)\n\t{\n\t\tfor(int r=1;r<k;++r) if(i&(1<<r))\n\t\t{\n\t\t\tint cl=L[i^(1<<r)];\n\t\t\tif(cl!=n) cl=(*lower_bound(\n\t\t\tgu[r].begin(),gu[r].end(),cl+2))-1; \n\t\t\tL[i]=max(L[i],cl);\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<k);i++) R[i]=n+1;\n\tfor(int i=2;i<(1<<k);i+=2)\n\t{\n\t\tfor(int r=1;r<k;++r) if(i&(1<<r))\n\t\t{\n\t\t\tint cr=R[i^(1<<r)];\n\t\t\tif(cr!=1) cr=(*(upper_bound(\n\t\t\tgu[r].begin(),gu[r].end(),cr-1)-1));\n\t\t\tR[i]=min(R[i],cr);\n\t\t}\n\t}\n\tfor(int i=0;i<=n;++i) mx[i]=-1;\n\tfor(int i=0;i<(1<<k);i+=2)\n\t\tmx[R[i]]=max(mx[R[i]],L[((1<<k)-2)^i]);\n\tfor(int i=1;i<=n;++i)\n\t\tmx[i]=max(mx[i],mx[i-1]);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint L=*(upper_bound(gu[0].begin(),gu[0].end(),i)-1),\n\t\tR=(*lower_bound(gu[0].begin(),gu[0].end(),i+1))-1;\n\t\tif(mx[R+1]>=L-1) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n\n#define MAXN 200005\n#define MAXB 21\n\nusing namespace std;\n\nconst int INF = 2e9;\nint v[MAXN], n, m;\nint d[MAXN], up[MAXN][MAXB], down[MAXN][MAXB], pre[1 << MAXB], suf[1 << MAXB];\nint visit[MAXN];\n\nint read() {\n    char c = getchar();\n    int x = 0, s = 1;\n    while (!isdigit(c)) {\n        if (c == '-')\n            s = -1;\n        c = getchar();\n    }\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x * s;\n}\n\nvoid init() {\n    while (v[++m] >= 1)\n        v[m + 1] = v[m] >> 1;\n    d[0] = -INF;\n    d[n + 1] = INF;\n    for (int j = 1; j <= m; ++j) {\n        for (int i = 1; i <= n; ++i)\n            if (d[i] - d[i - 1] <= v[j])\n                up[i][j] = up[i - 1][j];\n            else\n                up[i][j] = i;\n        for (int i = n; i >= 1; --i)\n            if (d[i + 1] - d[i] <= v[j])\n                down[i][j] = down[i + 1][j];\n            else\n                down[i][j] = i;\n    }\n}\n\nvoid solve() {\n    memset(suf, 0x3f, sizeof(suf));\n    memset(pre, -0x3f, sizeof(pre));\n    suf[0] = n + 1;\n    pre[0] = 0;\n    int limit = (1 << m) - 1;\n    for (int s = 0; s <= limit; ++s) {\n        for (int i = 1; i <= m; ++i) {\n            if (s >> (i - 1) & 1)\n                continue;\n            int t = s | (1 << (i - 1));\n            if (pre[s] >= 0)\n                pre[t] = max(pre[t], down[pre[s] + 1][i]);\n            if (suf[s] <= n + 1)\n                suf[t] = min(suf[t], up[suf[s] - 1][i]);\n        }\n    }\n    for (int s = 1; s < limit; ++s) {\n        if (s & 1)\n            continue;\n        int t = limit ^ s;\n        t ^= 1;\n        if (down[pre[s] + 1][1] >= suf[t] - 1) {\n            ++visit[up[pre[s] + 1][1]];\n            --visit[down[pre[s] + 1][1] + 1];\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n        visit[i] = visit[i - 1] + visit[i];\n    for (int i = 1; i <= n; ++i)\n        if (visit[i])\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n}\n\nint main() {\n    n = read();\n    v[1] = read();\n    for (int i = 1; i <= n; ++i)\n        d[i] = read();\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "//2018-1-18\n//miaomiao\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define Set(a, v) memset(a, v, sizeof(a))\n#define For(i, a, b) for(int i = (a); i <= (int)(b); ++i)\n\n#define M 18\n#define N (200000+5)\n\nint n, m, dn, pos[N], dis[M], nxt[N][M], beg[N], endd[N];\nint f[1<<M];\n\nbool Solve(int l, int r){\n\tif(l == 1 && r == n) return true;\n\n\tf[0] = 0;\n\t\n\tint tmp;\n\tFor(i, 1, (1<<dn)-1){\n\t\tf[i] = 0;\n\t\tFor(j, 1, dn) if(i & (1<<(j-1))){\n\t\t\ttmp = f[i ^ (1<<(j-1))] + 1;\n\t\t\tif(tmp >= l && tmp <= r) tmp = r+1;\n\n\t\t\tf[i] = max(f[i], nxt[tmp][j]);\n\t\t\tif(f[i]+1 >= l && f[i]+1 <= r) f[i] = r;\n\t\t}\n\t\tif(f[i] >= n) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tFor(i, 1, n) scanf(\"%d\", &pos[i]);\n\t\n\tint st, ed, cnt = 0;\n\tfor(int d = m; d >= 0; d >>= 1){\n\t\tst = 1; if(d != m) dis[++dn] = d;\n\n\t\twhile(st <= n){\n\t\t\ted = st;\n\t\t\twhile(ed < n && pos[ed+1]-pos[ed] <= d) ++ed;\n\t\t\tFor(i, st, ed) nxt[i][dn] = ed;\n\t\t\t\n\t\t\tif(d == m){\n\t\t\t\tbeg[++cnt] = st; endd[cnt] = ed;\n\t\t\t}\n\t\t\tst = ed+1;\n\t\t}\n\n\t\tif(!d) break;\n\t}\n\n\tFor(i, 1, dn) nxt[n+1][i] = n+1;\n//\tFor(i, 1, n) For(j, 1, dn) printf(\"nxt[%d][%d] = %d\\n\", i, j, nxt[i][j]);\n\n\tif(cnt > dn+1){\n\t\tFor(i, 1, n) puts(\"Impossible\"); return 0;\n\t}\n\n\tFor(si, 1, cnt){\n\t//\tprintf(\"%d -> %d free\\n\", beg[si], end[si]);\n\t\tif(Solve(beg[si], endd[si])){\n\t\t\tFor(i, beg[si], endd[si]) puts(\"Possible\");\n\t\t}else{\n\t\t\tFor(i, beg[si], endd[si]) puts(\"Impossible\"); \n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> pll;\n#define IN inline\n#define RE register\n#define F first\n#define S second\n#define N 400005\n#define mod 998244353\n#define INF 0x3f3f3f3f\nint n,v,x[N],vl[22],k=0,pf[22][N],pb[22][N],dpf[N],dpb[N],lf[N];\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=v;i;i>>=1) vl[k++]=i;\n\tvl[k]=0;\n\treverse(vl,vl+k+1);\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",x+i);\n\tfor(int i=0;i<=k;++i){\n\t\tpf[i][1]=1;\n\t\tfor(int j=2;j<=n;++j){\n\t\t\tif(x[j]-x[j-1]<=vl[i]) pf[i][j]=pf[i][j-1];\n\t\t\telse pf[i][j]=j;\n\t\t}\n\t\tpf[i][n+1]=n;\n\t\tpb[i][n]=n;\n\t\tfor(int j=n-1;j;--j){\n\t\t\tif(x[j+1]-x[j]<=vl[i]) pb[i][j]=pb[i][j+1];\n\t\t\telse pb[i][j]=j;\n\t\t}\n\t\tpb[i][0]=1;\n\t}\n\tdpf[0]=0;\n\tmemset(dpb,63,sizeof(dpb));\n\tdpb[0]=n+1;\n\tfor(int msk=0;msk<(1<<k);++msk){\n\t\tfor(int i=0;i<k;++i) if(!(msk&1<<i)){\n\t\t\tdpf[msk|1<<i]=max(dpf[msk|1<<i],pb[i][dpf[msk]+1]);\n\t\t\tdpb[msk|1<<i]=min(dpb[msk|1<<i],pf[i][dpb[msk]-1]);\n\t\t}\n\t}\n\tfor(int msk=0,dmsk=(1<<k)-1;dmsk>=0;++msk,--dmsk)\n\t\tlf[dpb[dmsk]-1]=max(lf[dpb[dmsk]-1],dpf[msk]+1);\n\tfor(int i=1;i<=n;++i) lf[i]=max(lf[i],lf[i-1]);\n\tfor(int i=1;i<=n;++i){\n\t\tif(lf[pb[k][i]]>=pf[k][i]) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(),v.end()\n\nconst int maxn = 2e5 + 100, maxlg = 20;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, v, vols[maxlg], volCount, nxt[maxlg][maxn], dp[(1 << maxlg)];\nll x[maxn], a[maxn];\nbool ans[maxn];\nset<int> counter;\n\nvoid printAnsAndExit() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << (ans[i] ? \"Possible\" : \"Impossible\") << endl;\n\t}\n\texit(0);\n}\n\nvoid solve(int l, int r) {\n\tmemset(dp, 0, sizeof(dp));\n\tfor (int mask = 0; mask < (1 << (volCount - 1)); mask++) {\n\t\tfor (int bit = 0; bit < volCount - 1; bit++) {\n\t\t\tif (!((mask >> bit) & 1)) {\n\t\t\t\tint val = nxt[bit][dp[mask]] + 1;\n\t\t\t\tif (l <= val && val <= r) {\n\t\t\t\t\tval = r + 1;\n\t\t\t\t}\n\t\t\t\tdp[mask | (1 << bit)] = max(dp[mask | (1 << bit)], val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mx = *max_element(dp, dp + (1 << maxlg));\n\tif (mx == n) {\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tans[i] = true;\n\t\t}\n\t}\n}\n\nvoid solveAll() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcounter.insert(nxt[volCount - 1][i]);\n\t}\n\tif (counter.size() > volCount) {\n\t\tprintAnsAndExit();\n\t}\n\t\n\tint l = 0, r = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (nxt[volCount - 1][r] == nxt[volCount - 1][i]) {\n\t\t\tr++;\n\t\t}\n\t\telse {\n\t\t\tsolve(l, r);\n\t\t\tr++;\n\t\t\tl = r;\n\t\t}\n\t}\n\tsolve(l, r);\n}\n\n\nvoid calcVols(int v) {\n\tint count = 0, tmp = v;\n\twhile (tmp) {\n\t\ttmp /= 2;\n\t\tcount++;\n\t}\n\tvolCount = ++count;\n\twhile (count) {\n\t\tvols[--count] = v;\n\t\tv /= 2;\n\t}\n}\n\nvoid calcNxt() {\n\tfor (int vol = 0; vol < volCount; vol++) {\n\t\tint l = 0, r = 0;\n\t\twhile (r < n - 1) {\n\t\t\tif (x[r + 1] - x[r] <= vols[vol]) {\n\t\t\t\tr++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (l <= r) {\n\t\t\t\t\tnxt[vol][l] = r;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\twhile (l <= r) {\n\t\t\tnxt[vol][l] = r;\n\t\t\tl++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\n\tif (n == 1) {\n\t\tans[0] = true;\n\t\tprintAnsAndExit();\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t\ta[i] = x[i];\n\t}\n\n\tcalcVols(v);\n\tcalcNxt();\n\tsolveAll();\n\tprintAnsAndExit();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t400005\n#define MAXLOG\t20\nint n, k, v[MAXLOG], x[MAXN];\nint l[MAXLOG][MAXN], r[MAXLOG][MAXN];\nint lft[MAXN], rit[MAXN], opt[MAXN];\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint main() {\n\tread(n), read(v[0]);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(x[i]);\n\tfor (k = 1; v[k - 1] != 0; k++)\n\t\tv[k] = v[k - 1] / 2;\n\tk -= 1; int goal = (1 << k) - 1;\n\tfor (int j = 0; j <= k; j++) {\n\t\tl[j][1] = 1;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t\tif (x[i] - x[i - 1] <= v[j]) l[j][i] = l[j][i - 1];\n\t\t\telse l[j][i] = i;\n\t}\n\tfor (int j = 0; j <= k; j++) {\n\t\tr[j][n] = n;\n\t\tfor (int i = n - 1; i >= 1; i--)\n\t\t\tif (x[i + 1] - x[i] <= v[j]) r[j][i] = r[j][i + 1];\n\t\t\telse r[j][i] = i;\n\t}\n\tfor (int curr = 0; curr <= goal; curr++) {\n\t\tlft[curr] = 0;\n\t\trit[curr] = n + 1;\n\t}\n\tfor (int curr = 0; curr < goal; curr++)\n\tfor (int i = 1, j = 1; i <= k; i++, j <<= 1) {\n\t\tif (curr & j) continue;\n\t\tint dest = curr | j;\n\t\tlft[dest] = max(lft[dest], min(r[i][lft[curr] + 1], n));\n\t\trit[dest] = min(rit[dest], max(l[i][rit[curr] - 1], 1));\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\topt[i] = n + 2;\n\tfor (int curr = 0; curr <= goal; curr++)\n\t\topt[lft[curr]] = min(rit[goal ^ curr], opt[lft[curr]]);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\topt[i] = min(opt[i], opt[i + 1]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint lft = l[0][i];\n\t\tint rit = r[0][i];\n\t\tif (opt[lft - 1] <= rit + 1) printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<cmath>\n#include<functional>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nvoid sort(int &a,int &b)\n{\n\tif(a>b)\n\t\tswap(a,b);\n}\nvoid open(const char *s)\n{\n#ifndef ONLINE_JUDGE\n\tchar str[100];\n\tsprintf(str,\"%s.in\",s);\n\tfreopen(str,\"r\",stdin);\n\tsprintf(str,\"%s.out\",s);\n\tfreopen(str,\"w\",stdout);\n#endif\n}\nint rd()\n{\n\tint s=0,c;\n\twhile((c=getchar())<'0'||c>'9');\n\tdo\n\t{\n\t\ts=s*10+c-'0';\n\t}\n\twhile((c=getchar())>='0'&&c<='9');\n\treturn s;\n}\nint upmin(int &a,int b)\n{\n\tif(b<a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint upmax(int &a,int b)\n{\n\tif(b>a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint v[200010];\nint f[1<<20];\nint g[1<<20];\nint l[20][200010];\nint r[20][200020];\nint a[200010];\nint b[200010];\nint main()\n{\n//\topen(\"agc012e\");\n\tint n;\n\tscanf(\"%d%d\",&n,&v[1]);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tint t=1;\n\twhile(1)\n\t{\n\t\tv[t+1]=v[t]/2;\n\t\tt++;\n\t\tif(!v[t])\n\t\t\tbreak;\n\t}\n\tfor(i=1;i<=t;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j==1||a[j]-a[j-1]>v[i])\n\t\t\t\tl[i][j]=j;\n\t\t\telse\n\t\t\t\tl[i][j]=l[i][j-1];\n\t\tfor(j=n;j>=1;j--)\n\t\t\tif(j==n||a[j+1]-a[j]>v[i])\n\t\t\t\tr[i][j]=j;\n\t\t\telse\n\t\t\t\tr[i][j]=r[i][j+1];\n\t}\n\tmemset(f,0,sizeof f);\n\tint all=1<<t;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(f[i]==n)\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],f[i]);\n\t\t\t\telse\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],r[j][f[i]+1]);\n\t\t\t}\n\tfor(i=0;i<all;i++)\n\t\tg[i]=n+1;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(g[i]==1)\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],g[i]);\n\t\t\t\telse\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],l[j][g[i]-1]);\n\t\t\t}\n\tif(f[all-2]>=n)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t\tprintf(\"Possible\\n\");\n\t\treturn 0;\n\t}\n\tfor(i=0;i<all;i++)\n\t\tif(!(i&1)&&(f[i]+r[1][f[i]+1]>=n||g[(all-1)^i^1]<=f[i]+r[1][f[i]+1]+1))\n\t\t\tb[f[i]+1]=1;\n\tint last=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(b[i])\n\t\t\tlast=i;\n\t\tif(l[1][i]<=last||(i<=r[1][1]&&r[1][1]>=g[all-2]-1))\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint l[20][200010],r[20][200010],f[500010],g[500010],mi[200010],x[200010];\nint main()\n{\n\tint n,v,lim=0;scanf(\"%d%d\",&n,&v);while (v>>(lim+1)) lim++;lim++;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor (int p=0;p<=lim;p++)\n\t{\n\t\tl[p][0]=1;for (int i=1;i<=n;i++) l[p][i]=(x[i]-x[i-1]<=(v>>p))?l[p][i-1]:i;\n\t\tr[p][n+1]=n;for (int i=n;i>=1;i--) r[p][i]=(x[i+1]-x[i]<=(v>>p))?r[p][i+1]:i;\n\t}\n\tfor (int s=0;s<(1<<(lim+1));s++) g[s]=n+1;\n\tfor (int s=0;s<(1<<(lim+1));s++)\n\tfor (int i=0;i<=lim;i++) if (!(s&(1<<i)))\n\t{\n\t\tf[s|(1<<i)]=max(f[s|(1<<i)],r[i][f[s]+1]);\n\t\tg[s|(1<<i)]=min(g[s|(1<<i)],l[i][g[s]-1]);\n\t}\n\tfor (int i=0;i<=n;i++) mi[i]=n+2;\n\tfor (int i=0;i<(1<<(lim+1));i+=2) mi[f[i]]=min(mi[f[i]],g[(1<<(lim+1))-2-i]);\n\tfor (int i=1;i<=n;i++) puts((mi[l[0][i]-1]<=r[0][i]+1)?\"Possible\":\"Impossible\");\n\t//for (int i=1;i<=n;i++) printf(\"%d %d %d\\n\",l[0][i],r[0][i],mi[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memset( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\nconst int MAXN = 200020;\nconst int INF = 0x3f3f3f3f;\n\nint n, m, v[22], tot, a[MAXN], d[MAXN];\nint f[MAXN][22], g[MAXN][22];\nint dpl[MAXN << 2], dpr[MAXN << 2], ans[MAXN];\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tscanf( \"%d%d\", &n, &m );\n\tfor( int i = 1 ; i <= n ; i++ ) scanf( \"%d\", &a[ i ] );\n\twhile( m ) v[ tot++ ] = m, m >>= 1;\n\tv[ tot++ ] = 0;\n\td[ 1 ] = d[ n + 1 ] = INF;\n\tfor( int i = 2 ; i <= n ; i++ ) d[ i ] = a[ i ] - a[ i - 1 ];\n\tfor( int j = 0 ; j < tot ; j++ )\n\t{\n\t\tfor( int i = 1 ; i <= n ; i++ )\n\t\t\tif( d[ i ] > v[ j ] ) f[ i ][ j ] = i;\n\t\t\telse f[ i ][ j ] = f[ i - 1 ][ j ];\n\t\tfor( int i = n ; i ; i-- )\n\t\t\tif( d[ i + 1 ] > v[ j ] ) g[ i ][ j ] = i;\n\t\t\telse g[ i ][ j ] = g[ i + 1 ][ j ];\n\t}\n\tfill( dpr, 0x3f );\n\tdpr[ 0 ] = n + 1;\n\tfor( int i = 0 ; i < ( 1 << tot ) ; i++ )\n\t\tfor( int j = 0 ; j < tot ; j++ ) if( !( i >> j & 1 ) )\n\t\t{\n\t\t\tif( dpl[ i ] >= n ) dpl[ i | ( 1 << j ) ] = n;\n\t\t\telse dpl[ i | ( 1 << j ) ] = max( dpl[ i | ( 1 << j ) ], g[ dpl[ i ] + 1 ][ j ] );\n\t\t\tif( dpr[ i ] <= 1 ) dpr[ i | ( 1 << j ) ] = 1;\n\t\t\telse dpr[ i | ( 1 << j ) ] = min( dpr[ i | ( 1 << j ) ], f[ dpr[ i ] - 1 ][ j ] );\n\t\t}\n\tfor( int i = 0 ; i < ( 1 << tot ) ; i++ )\n\t{\n\t\tif( i & 1 ) continue;\n\t\tint l = dpl[ i ], r = dpr[ ( 1 << tot ) - 1 - i - 1 ];\n\t\tif( l + 1 >= r ) ans[ 1 ]++;\n\t\telse\n\t\t{\n\t\t\tint L = f[ l + 1 ][ 0 ], R = g[ l + 1 ][ 0 ];\n\t\t\tif( R + 1 >= r && L <= R ) ans[ L ]++, ans[ R + 1 ]--;\n\t\t}\n\t}\n\tfor( int i = 1, cur = 0 ; i <= n ; i++ )\n\t{\n\t\tcur += ans[ i ];\n\t\tif( cur ) puts( \"Possible\" );\n\t\telse puts( \"Impossible\" );\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 210000, maxk = 20;\nint x[maxn];\nvi w;\nint fw[maxn][maxk], fb[maxn][maxk];\nint jfw[1 << maxk], jfb[1 << maxk];\nint dans[maxn];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, v;\n    cin >> n >> v;\n    forn(i, n) cin >> x[i];\n    w.pb(v);\n    while (w.back()) {\n        int z = w.back();\n        w.pb(z / 2);\n    }\n    reverse(all(w));\n    int k = w.size();\n    ford(i, n) forn(j, k) {\n        if (i + 1 < n && x[i + 1] - x[i] <= w[j]) fw[i][j] = fw[i + 1][j];\n        else fw[i][j] = i;\n    }\n\n    forn(i, n) forn(j, k) {\n        if (i && x[i] - x[i - 1] <= w[j]) fb[i][j] = fb[i - 1][j];\n        else fb[i][j] = i;\n    }\n\n    forn(i, 1 << k) jfw[i] = -1, jfb[i] = n;\n    jfw[0] = 0;\n    jfb[0] = n - 1;\n    forn(i, 1 << k) {\n        forn(j, k) {\n            if ((i >> j) & 1) continue;\n            if (jfw[i] >= 0) {\n                if (jfw[i] < n) uax(jfw[i | (1 << j)], fw[jfw[i]][j] + 1);\n                else jfw[i | (1 << j)] = n;\n                if (jfw[27] >= 0) {\n                    jfw[27] ^= 0;\n                }\n            }\n            if (jfb[i] < n) {\n                if (jfb[i] >= 0) uin(jfb[i | (1 << j)], fb[jfb[i]][j] - 1);\n                else jfb[i | (1 << j)] = -1;\n            }\n        }\n    }\n\n    forn(i, 1 << (k - 1)) {\n        int l = jfw[i], r = jfb[(1 << (k - 1)) - i - 1];\n        if (l > r) {\n//            cerr << i << \"!\\n\";\n            ++dans[0];\n        } else if (fw[l][k - 1] >= r) {\n//            cerr << i << ' ' << l << ' ' << r << '\\n';\n            ++dans[l];\n            --dans[r + 1];\n        }\n    }\n    forn(i, n - 1) dans[i + 1] += dans[i];\n    forn(i, n) cout << (dans[i] ? \"Possible\" : \"Impossible\") << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 100000\n#define INF 2000000000\nusing namespace std;\nint n,V,x[MAXN+5];\nint cnt[20];\nint l[20][MAXN+5],r[20][MAXN+5];\nint f1[MAXN*2+5],f2[MAXN*2+5];\nbool ans[MAXN+5];\nvoid Init()\n{\n\tfor(int i=0;i<=MAXN*2+3;i++)\n\t\tf1[i]=0,f2[i]=INF;\n}\nint UpFind(int id,int pos)\n{\n//\tif(cnt[id]==0)\n//\t\treturn pos;\n\tpos++;\n\tint p=upper_bound(l[id]+1,l[id]+cnt[id]+1,pos)-l[id];\n\tp--;\n\tif(p<=0)\n\t\treturn pos;\n\treturn max(r[id][p],pos-1);\n}\nint LowFind(int id,int pos)\n{\n//\tif(cnt[id]==0)\n//\t\treturn pos;\n\tpos--;\n\tint p=lower_bound(r[id]+1,r[id]+cnt[id]+1,pos)-r[id];\n\tif(p>=cnt[id]+1)\n\t\treturn pos;\n\treturn min(l[id][p],pos+1);\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d %d\",&n,&V);\n\tint logV=0;\n\tfor(logV=0;(1<<logV)<=n;logV++);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\tx[n+1]=INF;\n\tx[0]=-INF;\n\tfor(int LG=0;LG<=logV;LG++)\n\t{\n\t\tint d=V/(1<<LG);\n\t\tcnt[LG]=1;\n\t\tl[LG][1]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tr[LG][cnt[LG]]=i;\n\t\t\tif(x[i+1]-x[i]>d)\n\t\t\t{\n\t\t\t\tcnt[LG]++;\n\t\t\t\tl[LG][cnt[LG]]=i+1;\n\t\t\t}\n\t\t}\n\t\tcnt[LG]--;\n\t}\n\tif(cnt[0]>logV)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint all=(1<<(logV+1));\n\tf1[0]=0,f2[0]=n+1;\n\tfor(int s=0;s<all;s+=2)\n\t\tfor(int i=0;i<=logV;i++)\n\t\t{\n\t\t\tif(!(s&(1<<i)))\n\t\t\t\tcontinue;\n\t\t\tf1[s]=max(f1[s],UpFind(i,f1[s-(1<<i)]));\n\t\t\tf2[s]=min(f2[s],LowFind(i,f2[s-(1<<i)]));\n\t\t}\n\tfor(int i=1;i<=cnt[0];i++)\n\t{\n\t\tint ln=l[0][i],rn=r[0][i];\n\t\tfor(int s1=0;s1<all;s1+=2)\n\t\t{\n\t\t\tint s2=all-1-s1-1;\n\t\t\tint lpos=f1[s1];\n\t\t\tint rpos=f2[s2];\n\t\t\tif(lpos>=ln-1&&rpos<=rn+1)\n\t\t\t{\n\t\t\t\tans[i]=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint pos=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(ans[pos]==true)\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t\tif(x[i+1]-x[i]>V)\n\t\t\tpos++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 2e5 + 10;\n\nint n, v, m, ans[N];\nint a[N], b[N], L[N][22], R[N][22], f[N], g[N];\n\nbool ask(int u)\n{\n    return ans[L[u][0] - 1] <= R[u][0] + 1;\n}\n\nint main()\n{\n    n = read(), v = read();\n    for (int i = 1; i <= n; i++) a[i] = read();\n    b[0] = v;\n    for (int i = 1; i <= 50; i++) b[i] = b[i - 1] >> 1;\n    for (int i = 0; b[i]; i++) m = i;\n    m += 2;\n    for (int i = 0; i < m; i++)\n        for (int j = 1; j <= n; )\n        {\n            int k;\n            for (k = j + 1; k <= n; k++)\n                if (a[k] - a[k - 1] > b[i])\n                    break;\n            for (int l = j; l < k; l++)\n                L[l][i] = j, R[l][i] = k - 1;\n            j = k;\n        }\n    for (int i = 0; i < (1 << m); i++) g[i] = n + 1;\n    for (int i = 0; i < (1 << m); i++)\n        for (int j = 0; j < m; j++)\n            if (!(i >> j & 1))\n            {\n                f[i | (1 << j)] = max(f[i | (1 << j)], R[f[i] + 1][j]);\n                g[i | (1 << j)] = min(g[i | (1 << j)], L[g[i] - 1][j]);\n            }\n    for (int i = 0; i <= n; i++) ans[i] = 2e9;\n    for (int i = 0; i < (1 << m); i++)\n        if (i % 2 == 0)\n            ans[f[i]] = min(ans[f[i]], g[((1 << m) - 2) ^ i]);\n    for (int i = n - 1; i >= 1; i--)\n        ans[i] = min(ans[i], ans[i + 1]);\n    for (int i = 1; i <= n; i++) puts(ask(i) ? \"Possible\" : \"Impossible\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,V,M = 19;\nint A[200010];\nint mem[2][20][2000010];\nint dp[2][2000010];\nint ans[200010];\nint INF = 1001001001;\n\nint unit(int id,int bit)\n{\n    if(!bit)\n    {\n        if(id)return 0;\n        else return N - 1;\n    }\n    if(dp[id][bit] != -1)return dp[id][bit];\n    int res;\n    if(id)res = 0;\n    else res = N - 1;\n    for(int i = 0; i < M; i++)\n    {\n        if(bit & (1 << i))\n        {\n            if(id)res = max(res,mem[id][i][unit(id,bit - (1 << i))] + 1);\n            else res = min(res,mem[id][i][unit(id,bit - (1 << i))] - 1);\n        }\n    }\n    return dp[id][bit] = res;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&N,&V);\n    for(int i = 0; i < N; i++)scanf(\"%d\",A + i);\n\n    int v = V;\n    int cnt = 0;\n    while(V)V /= 2,cnt++;\n\n    M = cnt + 1;\n\n    for(int i = 0; i < 20; i++)\n    {\n        int tmp = 0;\n        for(int j = 0; j < N; j++)\n        {\n            if(j && A[j] - A[j - 1] > v)tmp = j;\n            mem[0][i][j] = tmp;\n        }\n        tmp = N - 1;\n        for(int j = N - 1; j >= 0; j--)\n        {\n            if(j != N - 1 && A[j + 1] - A[j] > v)tmp = j;\n            mem[1][i][j] = tmp;\n        }\n        v /= 2;\n    }\n\n    memset(dp,-1,sizeof(dp));\n\n    for(int i = 0; i < (1 << M - 1); i++)\n    {\n        int l = unit(1,((1 << M - 1) - 1 << 1) - (i << 1));\n        int r = unit(0,(i << 1));\n        if(l > r)\n        {\n            for(int j = 0; j < N; j++)printf(\"Possible\\n\");\n            return 0;\n        }\n        if(mem[1][0][l] >= r)\n        {\n            ans[l]++;\n            ans[r + 1]--;\n        }\n    }\n    for(int i = 1; i < N; i++)ans[i] += ans[i - 1];\n\n    for(int i = 0; i < N; i++)\n    {\n        if(ans[i])printf(\"Possible\\n\");\n        else printf(\"Impossible\\n\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FR first\n#define SE second\nusing namespace std;\n\ntypedef pair<int,int> pii;\nconst int N=200010;\nint n,V,X[N],dep;\nint L[20][N],R[20][N];\nint exL[N],exR[N];\npii seg[N];\nbool ans[N];\n\nint findr(int d,int p)\n{\n    auto x=upper_bound(L[d]+1,L[d]+1+n,p);\n    return upper_bound(L[d]+1,L[d]+1+n,*x)-L[d]-1;\n}\nint findl(int d,int p)\n{\n    auto x=(lower_bound(R[d]+1,R[d]+1+n,p)-1);\n    if(x==R[d]+1+n) return n;\n    return lower_bound(R[d]+1,R[d]+1+n,*x)-R[d];\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    for(int i=1;i<=n;i++) scanf(\"%d\",X+i);\n    for(int v=V;v>=0;v>>=1,dep++)\n    {\n        L[dep][1]=1;R[dep][n]=n;\n        for(int i=2;i<=n;i++) L[dep][i]=(X[i]-X[i-1]<=v)?L[dep][i-1]:i;\n        for(int i=n-1;i>=1;i--) R[dep][i]=(X[i+1]-X[i]<=v)?R[dep][i+1]:i;\n        if(v==0){dep++;break;}\n    }\n    for(int i=1;i<=n;i++) seg[i]=pii(L[0][i],R[0][i]);\n    int cnt=unique(seg+1,seg+1+n)-(seg+1);\n    memset(exL,0,sizeof(exL));\n    memset(exR,0x3f,sizeof(exR));\n    exL[0]=0;exR[0]=n+1;\n    for(int s=0;s<(1<<dep);s++)\n        for(int i=0;i<dep;i++)\n        {\n            if(!(s&(1<<i))) continue;\n            exL[s]=max(exL[s],findr(i,exL[s^(1<<i)]));\n            exR[s]=min(exR[s],findl(i,exR[s^(1<<i)]));\n        }\n    if(cnt>dep) goto output;\n    for(int i=1;i<=cnt;i++)\n    {\n        for(int s=0;s<(1<<dep);s+=2)\n            if(exL[s]>=seg[i].FR-1&&exR[s]<=seg[i].SE+1)\n            {\n                for(int j=seg[i].FR;j<=seg[i].SE;j++) ans[j]=1;\n                goto finished;\n            }\n        finished: ;\n    }\n    output: for(int i=1;i<=n;i++) puts(ans[i]?\"Possible\":\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,v;\nint x[200010];\nvector<pair<int,int> >tot;\nvector<pair<int,int> >seg[20];\nint fl[1<<20],fr[1<<20];\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint j=i;\n\t\twhile(j+1<=n && x[j+1]-x[j]<=v)j++;\n\t\ttot.push_back(make_pair(i,j));\n\t\ti=j;\n\t}\n\tif((int)tot.size()>20)\n\t{\n\t\tfor(int i=1;i<=n;i++)puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tv/=2;\n\tint k;\n\tfor(k=0;;k++,v/=2)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint j=i;\n\t\t\twhile(j+1<=n && x[j+1]-x[j]<=v)j++;\n\t\t\tseg[k].push_back(make_pair(i,j));\n\t\t\ti=j;\n\t\t}\n\t\tsort(seg[k].begin(),seg[k].end());\n\t\tif(!v)break;\n\t}\n\tk++;\n\tfor(int i=0;i<(1<<k);i++)fr[i]=n+1;\n\tfor(int i=0;i<(1<<k);i++)\n\t{\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tif(i>>j&1)continue;\n\t\t\tint pl=lower_bound(seg[j].begin(),seg[j].end(),make_pair(fl[i]+2,0))-seg[j].begin();\n\t\t\tfl[i|(1<<j)]=max(fl[i|(1<<j)],fl[i]);\n\t\t\tif(pl)fl[i|(1<<j)]=max(fl[i|(1<<j)],seg[j][pl-1].second);\n\t\t\tint pr=lower_bound(seg[j].begin(),seg[j].end(),make_pair(fr[i],0))-seg[j].begin();\n\t\t\tfr[i|(1<<j)]=min(fr[i|(1<<j)],fr[i]);\n\t\t\tif(pr)fr[i|(1<<j)]=min(fr[i|(1<<j)],seg[j][pr-1].first);\n\t\t}\n\t}\n\tfor(int i=0;i<(int)tot.size();i++)\n\t{\n\t\tbool ok=false;\n\t\tfor(int j=0;j<(1<<k);j++)\n\t\t{\n\t\t\tif(fl[j]>=tot[i].first-1 && fr[((1<<k)-1)^j]<=tot[i].second+1)\n\t\t\t{\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=tot[i].first;j<=tot[i].second;j++)puts(ok?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <deque>\n#include <utility>\n#include <chrono>\n#include <sstream>\n#include <iomanip>\n#define INF 1 << 30\n#define MOD 1000000007;\n#define pi 3.14159265358979\n#define rep(i, n) for (int (i) = 0; (i) < (int)(n); (i)++)\n#define reu(i, l, r) for (int (i) = (int)(l); (i) < (int)(r); (i)++)\n#define D(x) cout << x << endl\n#define d(x) cout << x\n#define all(x) (x).begin(), (x).end()\n#define pub(x) push_back(x)\n#define pob() pop_back()\n#define puf(x) push_front(x)\n#define pof() pop_front()\n#define mp(x, y) make_pair((x), (y))\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if (x < y) x = y; }\nstatic const int dx[] = {0, 0, 1, -1};\nstatic const int dy[] = {-1, 1, 0, 0};\n\n#define int long long\n\nsigned main() { \n  int n, v;\n  cin >> n >> v;\n  vi x(n);\n  vi dis(n + 1);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i];\n    if (i > 0) {\n      dis[i] = x[i] - x[i - 1];\n    }\n  }\n  dis[0] = INF;\n  dis[n] = INF;\n\n  //for (int i = 0; i < dis.size(); i++) {\n  //  d(dis[i] << \" \");\n  //}\n  //D(\"\");\n\n  vi vv;\n  while (v > 0) {\n    vv.pub(v);\n    v /= 2;\n  }\n  vv.pub(0);\n\n  //for (int i = 0; i < vv.size(); i++) {\n  //  d(vv[i] << ' ');\n  //}\n  //D(\"\");\n\n  vector<vector<bool>> wall(vv.size(), vector<bool> (n + 1, false));\n\n  for (int i = 0; i < vv.size(); i++) {\n    for (int j = 0; j < n + 1; j++) {\n      if (dis[j] > vv[i]) {\n        wall[i][j] = true;\n      }\n    }\n  }\n\n  //for (int i = 0; i < vv.size(); i++) {\n  //  for (int j = 0; j < n  + 1; j++) {\n  //    d(wall[i][j] << \" \");\n  //  }\n  //  D(\"\");\n  //}\n  \n  vs ans;\n\n  int i = 0;\n  while (i < n) {\n    int cnt = 0;\n\n    vector<bool> done(n);\n    for (int u = 0; u < n; u++) {\n      done[u] = false;\n    }\n\n    while (!wall[0][i + 1]) {\n      done[i] = true;\n      i++;\n      cnt++;\n    }\n    done[i] = true;\n    i++;\n    cnt++;\n\n    //D(i << \" --------------------\");\n    //for (int u = 0; u < n; u++) {\n    //  d(done[u] << ' ');\n    //}\n    //D(\"\");\n\n    for (int j = 1; j < vv.size(); j++) {\n      int maxd = -1;\n      int maxk = -1;\n      for (int k = 0; k < n; k++) {\n        if (!wall[j][k] && !done[k]) {\n          if (maxd < dis[k]) {\n            maxd = dis[k];\n            maxk = k;\n          }\n        }\n      }\n\n      //D(maxd << \" \" << maxk);\n\n      bool flag = false;\n      if (maxk == -1) {\n        for (int k = 0; k < n; k++) {\n          if (!done[k]) {\n            done[k] = true;\n            flag = true;\n            break;\n          }\n        }\n      }\n\n      //for (int u = 0; u < n; u++) {\n      //  d(done[u] << \" \");\n      //}\n      //D(\"\");\n\n      if (flag) {\n        continue;\n      }\n\n      if (!flag && maxk == -1) {\n        break;\n      }\n\n      //D(\"FJLDKJ\");\n      //D(maxk);\n           \n      int kpf = maxk;\n      while (!wall[j][kpf] && kpf < n) {\n        done[kpf] = true;\n        kpf++;\n      }\n      int kpb = maxk - 1;\n      while (!wall[j][kpb] && kpb > 0) {\n        done[kpb] = true;\n        kpb--;\n      }\n      done[kpb] = true;\n    }\n    \n    bool end = true;\n    for (int p = 0; p < n; p++) {\n      if (!done[p]) {\n        end = false;\n      }\n    }\n    \n    for (int j = 0; j < cnt; j++) {\n      if (end) {\n        ans.pub(\"Possible\");\n      } else {\n        ans.pub(\"Impossible\");\n      }\n    }\n  }\n\n  for (int z = 0; z < ans.size(); z++) {\n    D(ans[z]);\n  }\n\n  //for (int i = 0; i < dis.size(); i++) {\n  //  d(setw(3) << dis[i] << \" \" );\n  //}\n  //D(\"\");     \n  //for (int i = 0; i < vv.size(); i++) {\n  //  for (int j = 0; j < n - 1; j++) {\n  //    d(setw(3) << wall[i][j] << \" \");\n  //  }\n  //  D(\"\");\n  //}\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#define ll long long\n#define FOR(i,a) for(ll i=0;i<(ll)a.size();i++)\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=8e5+100;\nconst ll mod=1e9+7;\nconst ll logg=25;\n\nvector<ll> E;\nll logG(ll v,ll ww){\n\tif(E.empty()){\n\t\twhile(v){\n\t\t\tE.pb(v);\n\t\t\tv/=2;\n\t\t}\n\t\tE.pb(0);\n\t\treverse(E.begin(),E.end());\n\t}\n\treturn lower_bound(E.begin(),E.end(),ww)-E.begin();\n}\nll ta_koj_jelo[maxn][logg];\nll ta_koj_agha[maxn][logg];\n\nll x[maxn];\nll fas[maxn];\nll pri[maxn];\nll saf[maxn];\n\n\nll cnt[maxn];\n\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n\tll n,v;\n\tcin>>n>>v;\n\tfor(ll i=1;i<=n;i++){\n\t\tcin>>x[i];\n\t}\n\tfor(ll i=1;i+1<=n;i++){\n\t\tfas[i]=logG(v,x[i+1]-x[i]);\n\t//\tcout<<(ll)fas[i]<<\"* \";\n\t}\n\t//cout<<endl;\n\tfor(ll i=0;i<logg;i++){\n\t\tta_koj_jelo[n][i]=n;\n\t\tta_koj_jelo[n+1][i]=n;\n\t\tta_koj_agha[1][i]=1;\n\t\tta_koj_agha[0][i]=1;\n\t}\n\tfor(ll i=n-1;i>=0;i--){\n\t\tfor(ll j=0;j<logg;j++){\n\t\t\tif(fas[i]<=j){\n\t\t\t\tta_koj_jelo[i][j]=ta_koj_jelo[i+1][j];\n\t\t\t}else{\n\t\t\t\tta_koj_jelo[i][j]=i;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=2;i<=n;i++){\n\t\tfor(ll j=0;j<logg;j++){\n\t\t\tif(fas[i-1]<=j){\n\t\t\t\tta_koj_agha[i][j]=ta_koj_agha[i-1][j];\n\t\t\t}else{\n\t\t\t\tta_koj_agha[i][j]=i;\n\t\t\t}\n\t\t}\n\t}\n\n\tll M=(ll)(E.size());\n\tpri[0]=0;\n\tfor(ll i=1;i<(1<<M);i++){\n\t\tpri[i]=0;\n\t\tfor(ll j=0;j<M;j++){\n\t\t\tif((i>>j)&1){\n\t\t\t\tpri[i]=max(pri[i],ta_koj_jelo[pri[i^(1<<j)]+1][j]);\n\t\t\t}\n\t\t}\n\t\tpri[i]=min(pri[i],n);\n\t}\n\tsaf[0]=n+1;\n\tfor(ll i=1;i<(1<<M);i++){\n\t\tsaf[i]=n+1;\n\t\tfor(ll j=0;j<M;j++){\n\t\t\tif((i>>j)&1 ){\n\t\t\t\tsaf[i]=min(saf[i],ta_koj_agha[saf[i^(1<<j)]-1][j]);\n\t\t\t}\n\t\t}\n\t\tsaf[i]=max(saf[i],(ll)1);\n\t}\n\tfor(ll i=0;i<(1<<M);i++){\n\t//\tcout<<pri[i]<<' '<<saf[i]<<endl;\n\t}\n\tll H=((1<<M)/2)-1;\n\tif(saf[H]==1){\n\t\t//cout<<\"SALALM BABA )))))\"<<endl;\n\t\tcnt[0]=1;\n\t}else{\n\t\tfor(ll i=0;i<=H;i++){\n\t\t\tll ras=saf[i];\n\t\t\tll chap=pri[H^i];\n\n\t\t\tll R=ta_koj_jelo[chap+1][M-1]; \n\t\t\tll L=ta_koj_agha[ras-1][M-1];\n\n\t\t\tif(ras-1<=R){\n\t\t\t\tcnt[L]++;\n\t\t\t\tcnt[R+1]--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll i=1;i<=n;i++){\n\t\tcnt[i]+=cnt[i-1];\n\t\tif(cnt[i]){\n\t\t\tcout<<\"Possible\\n\";\n\t\t}else{\n\t\t\tcout<<\"Impossible\\n\";\n\t\t}\n\t}\n}\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define read() Read<int>()\nnamespace pb_ds{   \n    namespace io{\n        const int MaxBuff=1<<15;\n        const int Output=1<<23;\n        char B[MaxBuff],*S=B,*T=B;\n\t\t#define getc() ((S==T)&&(T=(S=B)+fread(B,1,MaxBuff,stdin),S==T)?0:*S++)\n        char Out[Output],*iter=Out;\n        inline void flush(){\n            fwrite(Out,1,iter-Out,stdout);\n            iter=Out;\n        }\n    }\n    template<class Type> inline Type Read(){\n        using namespace io;\n        register char ch;\n        register Type ans=0; \n        register bool neg=0;\n        while(ch=getc(),(ch<'0' || ch>'9') && ch!='-');\n        ch=='-'?neg=1:ans=ch-'0';\n        while(ch=getc(),'0'<= ch && ch<='9') ans=ans*10+ch-'0';\n        return neg?-ans:ans;\n    }\n    template<class Type> inline void Print(register Type x,register char ch='\\n'){\n        using namespace io;\n        if(!x) *iter++='0';\n        else{\n            if(x<0) *iter++='-',x=-x;\n            static int s[100]; \n            register int t=0;\n            while(x) s[++t]=x%10,x/=10;\n            while(t) *iter++='0'+s[t--];\n        }\n        *iter++=ch;\n    }\n}\nusing namespace pb_ds;\nusing namespace std;\ntypedef long long ll;\nconst int N=(1<<21)+5;\nint n,V,tot,now,all;\nint a[N],f[N],g[N];\nint l[20][N],r[20][N];\nint mx[N],vis[N];\ninline void work(int x){\n\tl[tot][1]=now=1;\n\tfor (int i=2;i<=n;++i){\n\t\tif (a[i]-a[i-1]>x)\n\t\t\tl[tot][i]=now=i;\n\t\telse l[tot][i]=now;\n\t}\n\tr[tot][n]=now=n;\n\tfor (int i=n-1;i;--i){\n\t\tif (a[i+1]-a[i]>x)\n\t\t\tr[tot][i]=now=i;\n\t\telse r[tot][i]=now;\n\t}\n}\nint main(){\n\t//freopen(\"d.in\",\"r\",stdin);\n\t//freopen(\"d.out\",\"w\",stdout);\n\tn=read(),V=read();\n\tfor (int i=1;i<=n;++i) a[i]=read();\n\twhile (V) ++tot,work(V),V>>=1; \n\t++tot,work(V);\n\tall=(1<<tot)-1;\n\tfor (int i=0;i<=all;++i)\n\t\tf[i]=0,g[i]=n+1;\n\tfor (int i=0;i<all;++i){\n\t\tfor (int j=2;j<=tot;++j){\n\t\t\tif (i&(1<<(j-1))) continue;\n\t\t\tf[i|(1<<(j-1))]=max(f[i|(1<<(j-1))],r[j][min(f[i]+1,n)]);\n\t\t\tg[i|(1<<(j-1))]=min(g[i|(1<<(j-1))],l[j][max(g[i]-1,1)]);\n\t\t}\n\t}\n\tfor (int i=0;i<=n;++i) mx[i]=n+1;\n\tfor (int i=0;i<=all;++i)\n\t\tmx[f[i]]=min(mx[f[i]],g[all^i]),vis[f[i]]=1;\n\tfor (int i=n-1;~i;--i)\n\t\tf[i]=min(f[i],f[i+1]),vis[i]|=vis[i+1];\n\tfor (int i=1;i<=n;++i){\n\t\tint L=l[1][i]-1,R=r[1][i]+1;\n\t\tif (vis[L] && mx[L]<=R) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 200200;\nconst int MAXK = 20;\n\nint a[MAX];\nint l[MAX][MAXK], r[MAX][MAXK];\nint fl[1 << MAXK], fr[1 << MAXK];\n\nint main(void) {\n  ios_base::sync_with_stdio(false);\n\n  int N, V;\n  cin >> N >> V;\n  REP(i, N) cin >> a[i];\n\n  int K = 0;\n  int v[MAXK];\n  while (V > 0) {\n    v[K++] = V;\n    V /= 2;\n  }\n  v[K++] = 0;\n\n  REP(i, N) {\n    REP(j, K) {\n      if (i > 0 && a[i] - a[i - 1] <= v[j]) {\n        l[i][j] = l[i - 1][j];\n      } else {\n        l[i][j] = i;\n      }\n    }\n  }\n\n  for (int i = N - 1; i >= 0; --i) {\n    REP(j, K) {\n      if (i < N - 1 && a[i + 1] - a[i] <= v[j]) {\n        r[i][j] = r[i + 1][j];\n      } else {\n        r[i][j] = i;\n      }\n    }\n  }\n\n  REP(s, 1 << K) fl[s] = 0, fr[s] = N - 1;\n  REP(s, 1 << K) {\n    REP(j, K) {\n      if (!(s & (1 << j))) {\n        int ns = s | (1 << j);\n        int nfl = fl[s] == N ? N : r[fl[s]][j] + 1;\n        fl[ns] = max(fl[ns], nfl);\n        int nfr = fr[s] == -1 ? -1 : l[fr[s]][j] - 1;\n        fr[ns] = min(fr[ns], nfr);\n      }\n    }\n  }\n\n  REP(i, N) {\n    bool can = false;\n    REP(s, 1 << K) {\n      if (!(s & 1)) {\n        if (fl[s] >= l[i][0] && fr[s] <= r[i][0]) {\n          can = true;\n          break;\n        }\n      }\n    }\n    if (can) {\n      cout << \"Possible\\n\";\n    } else {\n      cout << \"Impossible\\n\";\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, V;\n\nconst int maxn = 200010;\n\nint x[maxn];\n\nint cnt = 0;\nint dep;\n\nvector<int> g[maxn * 20];\n\nvector<int> divide(int l,int r,int v) {\n\tvector<int> ret;\n\tif(r - l == 1 || v == 0) return ret;\n\tfor(int i = l, j; i < r; i = j) {\n\t\tret.push_back(++cnt); \n\t\tfor(j = i + 1; j < r && x[j] - x[j-1] <= v; ++j);\n\t\tg[*ret.rbegin()] = divide(i, j, v / 2);\n\t}\n\treturn ret;\n}\n\nbool ans[maxn];\n\nbool solve(const vector<int> &vec,int dep) {\n\tvector<int> nxt;\n\tfor(auto x: vec) \n\t\tif(g[x].empty()) nxt.push_back(x);\n\t\telse nxt.insert(nxt.end(), g[x].begin(), g[x].end());\n\n\tif(nxt.size() > dep) return false;\n\tif(nxt.size() == 1) return true;\n\tint last = *(nxt.end() - 1), sz = nxt.size();\n\tnxt.erase(nxt.end() - 1);\n\tfor(int i = sz - 1; i >= 0; --i) {\n\t\tif(solve(nxt, dep - 1)) return true;\n\t\tif(i) swap(nxt[i-1], last);\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &V);\n\tfor(int i = 0; i < N; ++i) scanf(\"%d\", &x[i]);\n\tg[0] = divide(0, N, V);\n\tfor(int x = V; x; x = x >> 1) ++dep;\n\tif(g[0].size() > dep + 1) {\n\t\tfor(int i = 0; i < N; ++i) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tif(g[0].size() == 1) {\n\t\tfor(int i = 0; i < N; ++i) puts(\"Possible\");\n\t\treturn 0;\n\t}\n\tfor(int i = 0; i < g[0].size(); ++i) {\n\t\tvector<int> cur = g[0];\n\t\tcur.erase(cur.begin() + i);\n\t\tans[i] = true;\n\t\t//ans[i] = solve(cur, dep);\n\t}\n\tint curb = 0;\n\tfor(int i = 0; i < N; ++i) {\n\t\tif(i && x[i] - x[i-1] > V) ++curb;\n\t\tputs(ans[curb] ? \"Possible\" : \"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint K, N, V, sz[20], x[200009], maxPref[200009], pf[400009], sf[400009], lft[19][200009], rgt[19][200009];\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\", &N, &V);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &x[i]);\nfor (int i=0; (1 << i) <= V; i++)\n    sz[i] = V >> i, K = i;\nsz[++K] = 0;\nfor (int i=0; i<=K; i++)\n{\n    lft[i][1] = 1, lft[i][0] = 0;\n    for (int j=2; j<=N; j++)\n        if (x[j] - x[j - 1] <= sz[i]) lft[i][j] = lft[i][j - 1];\n        else lft[i][j] = j;\n    rgt[i][N] = N, rgt[i][N + 1] = N + 1;\n    for (int j=N - 1; j>=1; j--)\n        if (x[j + 1] - x[j] <= sz[i]) rgt[i][j] = rgt[i][j + 1];\n        else rgt[i][j] = j;\n}\nint lim = 1 << K;\nfor (int i=0; i < lim; i++)\n    sf[i] = N + 1;\nfor (int msk = 0; msk < lim; msk ++)\n    for (int i=0; i<K; i++)\n        if ((msk & (1 << i)) == 0)\n            pf[msk | (1 << i)] = max (pf[msk | (1 << i)], (pf[msk] <= N ? rgt[i + 1][pf[msk] + 1] : N + 1)),\n            sf[msk | (1 << i)] = min (sf[msk | (1 << i)], (sf[msk] >= 1 ? lft[i + 1][sf[msk] - 1] : 0));\nfor (int i=0; i<=N + 1; i++)\n    maxPref[i] = -N;\nfor (int i=0; i<lim; i++)\n    maxPref[sf[i]] = max (maxPref[sf[i]], pf[(lim - 1) ^ i]);\nfor (int i=1; i<=N + 1; i++)\n    maxPref[i] = max (maxPref[i - 1], maxPref[i]);\nfor (int i=1; i<=N; i++)\n    if (maxPref[rgt[0][i] + 1] >= lft[0][i] - 1) printf (\"Possible\\n\");\n    else printf (\"Impossible\\n\");\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,v;\n  cin>>n>>v;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n\n  vector<Int> dp;\n  vector<vector<Int> > ps;\n  while(v){\n    vector<Int> dp2(n,0);\n    for(Int i=1;i<n;i++)\n      dp2[i]=dp2[i-1]+(x[i]-x[i-1]>v);\n    if(dp.empty()) dp=dp2;\n\n    vector<Int> ps2;\n    ps2.emplace_back(0);\n    for(Int i=1;i<n;i++)\n      if(dp2[i]!=dp2[i-1]) ps2.emplace_back(i);\n    ps2.emplace_back(n);\n    ps.emplace_back(ps2);\n    v>>=1;\n  }\n  \n  {\n    vector<Int> ps2(n+1,0);\n    iota(ps2.begin(),ps2.end(),0);\n    ps.emplace_back(ps2);\n  }\n\n  vector<vector<Int> > memo(ps.size(),vector<Int>(n,-1));\n  function<Int(Int,Int)> calc=\n    [&](Int d,Int k)->Int{\n      if(d+1==(Int)ps.size()) return 1;\n      Int &res=memo[d][k];\n      if(~res) return res;\n      res=0;\n      vector<Int> &v=ps[d];\n      vector<Int> &u=ps[d+1];\n      Int x=lower_bound(u.begin(),u.end(),v[k])-u.begin();\n      Int tmp=0;\n      while(u[x]<v[k+1]){\n\tres+=calc(d+1,x);\n\tchmax(tmp,calc(d+1,x));\n\tx++;\n      }\n      res-=tmp-1;\n      return res;\n    };\n  \n  using P = pair<Int, Int>;\n  Int flg;\n  function<void(Int,const set<P>&)> dfs=\n    [&](Int d,const set<P> &sp){\n      {\n\tauto latte=sp.begin();\n\tInt res=latte->first==0;\n\twhile(latte!=sp.end()){\n\t  auto malta=latte;\n\t  if(++malta==sp.end()) break;;\n\t  res&=latte->second==malta->first;\n\t  latte=malta;\n\t}\n\tres&=latte->second==n;\n\tflg|=res;\n      }\n      \n      if(d==(Int)ps.size()) return;\n      \n      Int cnt=0;\n      vector<Int> &v=ps[d];\n      {\n\tauto latte=v.begin();\n\tfor(auto &p:sp){\n\t  cnt+=lower_bound(latte,v.end(),p.first)-latte;\n\t  latte=lower_bound(latte,v.end(),p.second);\n\t}\n\tcnt+=v.end()-latte-1;\n      }\n      \n      if(0){\n\tcout<<d<<\":\"<<cnt<<\"::\"<<(Int)ps.size()<<endl;\n\tfor(auto p:sp) cout<<p.first<<\" \"<<p.second<<endl;\n\tcout<<endl;\n      }\n      \n      if(d+1==(Int)ps.size()){\n\tflg|=(cnt<=1);\n\treturn;\n      }\n      \n      if(d+cnt>(Int)ps.size()) return;\n      \n      Int ncnt=0;\n\n      {\n\tInt k=0;\n\tfor(auto &p:sp){\n\t  while(v[k]<p.first){\n\t    ncnt+=calc(d,k);\n\t    k++;\n\t  }\n\t  k=lower_bound(v.begin(),v.end(),p.second)-v.begin();\n\t}\n\twhile(k+1<(Int)v.size()){\n\t  ncnt+=calc(d,k);\n\t  k++;\n\t}\n      }\n      //cout<<d<<\":\"<<cnt<<\":\"<<ncnt<<endl;\n\n      set<P> nsp=sp;\n      {\n\tInt k=0;\n\tfor(auto &p:sp){\n\t  while(v[k]<p.first){\n\t    if(d+ncnt-calc(d,k)<=(Int)ps.size()){\n\t      nsp.emplace(v[k],v[k+1]);\n\t      dfs(d+1,nsp);\n\t      nsp.erase(P(v[k],v[k+1]));\n\t      if(flg) return;\n\t    }\n\t    k++;\n\t  }\n\t  k=lower_bound(v.begin(),v.end(),p.second)-v.begin();\n\t}\n\twhile(k+1<(Int)v.size()){\n\t  if(d+ncnt-calc(d,k)<=(Int)ps.size()){\n\t    nsp.emplace(v[k],v[k+1]);\n\t    dfs(d+1,nsp);\n\t    nsp.erase(P(v[k],v[k+1]));\n\t    if(flg) return;\n\t  }\n\t  k++;\n\t}\n      }\n      \n    };\n  \n  for(Int i=0;i<n;){\n    Int l=i,r=*upper_bound(ps[0].begin(),ps[0].end(),l);\n    set<P> sp;\n    sp.emplace(l,r);\n    flg=0;\n    dfs(1,sp);\n    string ans=(flg?\"Possible\":\"Impossible\");\n    Int p=i;\n    while(i<n&&dp[p]==dp[i]){\n      cout<<ans<<endl;\n      i++;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR (i, 0, n)\n#define _ << \" _ \" <<\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define debug\n#define TRACE(x)\n\nusing namespace std;\n\ntypedef long long llint;\n\nconst int MAXN = 200010;\nconst int MAXLG = 20;\n\nint n, maxv, x[MAXN], r[MAXN][MAXLG], l[MAXN][MAXLG];\nint dpL[MAXN], dpR[MAXN], p[MAXN];\n\nint main(void) {\n  scanf(\"%d %d\",&n,&maxv);\n  REP(i, n) scanf(\"%d\",&x[i]);\n\n  int lg = 0;\n  for (int v = maxv; v >= 0; v /= 2, ++lg) {\n    for (int i = n - 1; i >= 0; --i) {\n      r[i][lg] = i;\n      if (i < n - 1 && x[i+1] - x[i] <= v)\n\tr[i][lg] = r[i+1][lg];\n    }\n    for (int i = 0; i < n; ++i) {\n      l[i][lg] = i;\n      if (i > 0 && x[i] - x[i-1] <= v)\n\tl[i][lg] = l[i-1][lg];\n    }\n\n    REP(i, n)\n      TRACE(i _ lg _ l[i][lg] _ r[i][lg]);\n    if (v == 0) break;\n  }\n\n  REP(mask, (1 << (lg + 1)) - 1) {\n    if (mask & 1) continue;\n\n    dpL[mask] = -1;\n    dpR[mask] = n;\n\n    REP(j, lg + 1)\n      if (mask & (1 << j)) {\n\tTRACE(j _ dpL[mask & ~(1 << j)]);\n\tif (dpL[mask & ~(1 << j)] == n - 1)\n\t  dpL[mask] = n - 1;\n\telse\n\t  dpL[mask] = max(dpL[mask], r[dpL[mask & ~(1 << j)] + 1][j]);\n\n\tif (dpR[mask & ~(1 << j)] == 0)\n\t  dpR[mask] = 0;\n\telse\n\t  dpR[mask] = min(dpR[mask], l[dpR[mask & ~(1 << j)] - 1][j]);\n      }\n  }\n\n  REP(mask1, (1 << (lg + 1)) - 1) {\n    if (mask1 & 1) continue;\n    int mask2 = ((1 << (lg + 1)) - 1) ^ mask1;\n    if (mask2 & 1) mask2 ^= 1;\n    \n    TRACE(mask1 _ mask2 _ dpL[mask1] _ dpR[mask2]);\n\n    int lo = dpL[mask1] + 1;\n    int hi = dpR[mask2] - 1;\n    if (r[lo][0] < hi) continue;\n    ++p[lo];\n    --p[r[lo][0] + 1];\n  }\n\n  int curr = 0;\n  REP(i, n) {\n    curr += p[i];\n    if (curr > 0)\n      printf(\"Possible\\n\");\n    else\n      printf(\"Impossible\\n\");\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N = 2e5 + 7;\n\nint n, k, a[N], val[19];\nint l[19][N], r[19][N];\nint pref[1 << 19], suf[1 << 19];\n\nint main(){\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n >> k;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t}\n\tint bit = 0, sv = k;\n\twhile(sv > 0){\n\t\tval[bit++] = sv;\n\t\tsv /= 2;\n\t}\n\tval[bit++] = 0;\n\tint pos = 1;\n\tfor(int i = 0; i < bit; i++){\n\t\tpos = 1;\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(pos < j) pos = j;\n\t\t\twhile(pos < n && a[pos + 1] - a[pos] <= val[i]) pos++;\n\t\t\tr[i][j] = pos;\n\t\t}\n\t\tpos = n;\n\t\tfor(int j = n; j >= 1; j--){\n\t\t\tif(pos > j) pos = j;\n\t\t\twhile(pos > 1 && a[pos] - a[pos - 1] <= val[i]) pos--;\n\t\t\tl[i][j] = pos;\n\t\t}\n\t}\n\tfor(int mask = 0; mask < (1 << bit); mask++) suf[mask] = n + 1;\n\tfor(int mask = 0; mask < (1 << bit); mask++){\n\t\tfor(int i = 0; i < bit; i++){\n\t\t\tif((mask & (1 << i))) continue;\n\t\t\tpref[mask ^ (1 << i)] = max(pref[mask ^ (1 << i)], r[i][min(n, pref[mask] + 1)]);\n\t\t\tsuf[mask ^ (1 << i)] = min(suf[mask ^ (1 << i)], l[i][max(1, suf[mask] - 1)]);\n\t\t}\n\t}\n\tint msk = (1 << bit) - 2;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(pref[msk] + 1 >= l[0][i] && suf[msk] - 1 <= r[0][i]) cout << \"Possible\\n\";\n\t\telse cout << \"Impossible\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1012345678;\n\nint A[200005];\n\nint S[20];\nint sizeS = 0;\n\nint R[20][200005];\nint L[20][200005];\nbool boleh[200005];\nint minPos[200005]; // for each dpL[something] = i, the smallest possible value of dpR[not of the something]\n// 'something' is a bitmask\n\nint minPos2[200005]; // for each dpL[something] >= i, the smallest possible value of dpR[not of the something]\n// 'something' is a bitmask\n\n/* dpL[i] = maximum index from the beginning that can be covered by the intervals\ncorresponding to a subset i of intervals from S\ndpR[i] is defined similarly, just that the prefix becomes the suffix.\n*/\nint dpL[(1<<19)+5];\nint dpR[(1<<19)+5];\n\n\nint N, V;\nint main(){\n    scanf(\"%d%d\", &N, &V);\n\n    for(int i = 1; i <= N; i ++){\n        scanf(\"%d\", &A[i]);\n    }\n\n    int temp = V;\n    while(true){\n        S[sizeS ++] = temp;\n        if(temp == 0){break;}\n        temp >>= 1;\n    }\n    reverse(S, S+sizeS);\n    for(int i = 0; i < sizeS; i++){\n        //printf(\"S[%d]=%d\\n\", i, S[i]);\n    }\n\n    // S is sorted in decreasing order\n\n    // R[i][j] is the 1-indexed right-most position reachable using move distances <= S[i] from position j\n    for(int i = 0; i < sizeS; i ++){\n        R[i][N] = N;\n        L[i][1] = 1;\n        for(int j = 2; j <= N; j ++){\n            if(A[j]-A[j-1] <= S[i]){\n                L[i][j] = L[i][j-1];\n            }else{\n                L[i][j] = j;\n            }\n        }\n\n        for(int j = N-1; j >= 1; j --){\n            if(A[j+1]-A[j] <= S[i]){\n                // can reach j+1, hence can reach positions up to R[i][j+1]\n                R[i][j] = R[i][j+1];\n            }else{\n                // j and j+1 disconnected\n                R[i][j] = j;\n            }\n        }\n    }\n\n    for(int i = 0; i < (1<<sizeS); i ++){\n        dpL[i] = 0;\n        dpR[i] = N+1;\n\n        // Consider the last S[j] used to construct the interval\n        for(int j = 0; j < sizeS; j ++){\n            if(i&(1<<j)){\n                // Bit j is set in i.\n                int k = i^(1<<j);\n\n                // clearing bit results in an index lesser than the original index => already processed\n                dpL[i] = max(dpL[i], R[j][min(dpL[k]+1, N)]);\n                // dpL[k]+1 is first index impossible to be covered by all the previous intervals\n\n                dpR[i] = min(dpR[i], L[j][max(dpR[k]-1, 1)]);\n            }\n        }\n    }\n\n    int k = 1;\n    for(int i = 1; i <= N; i ++){\n        minPos[i] = INF;\n    }\n\n    // Now check whether it is possible to reach all the oases.\n    for(int i = 0; i < (1<<(sizeS-1)); i ++){\n        int j = (1<<(sizeS-1))-1-i;\n\n        int l = dpL[i];\n        int r = dpR[j];\n        //printf(\"dpL[%d]=%d; dpR[%d]=%d\\n\", i, l, j, r);\n        minPos[l] = min(minPos[l], r);\n    }\n\n    minPos2[N] = minPos[N];\n    for(int i = N-1; i >= 0; i --){\n        minPos2[i] = min(minPos2[i+1], minPos[i]);\n        //printf(\"minPos[%d]=%d\\n\", i, minPos[i]);\n    }\n\n    //init();\n    for(int i = 1; i <= N; i ++){\n        int l = L[sizeS-1][i];\n        int r = R[sizeS-1][i];\n\n        //printf(\"i=%d l=%d r=%d\\n\", i, l, r);\n\n        boleh[i] = minPos2[l-1] <= r+1;\n        if(boleh[i]){\n            printf(\"Possible\\n\");\n        }else{\n            printf(\"Impossible\\n\");\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 2e05 + 10;\nconst int MAXL = 20 + 5;\n\nint N, V, lgv = 0;\nint a[MAXN];\nint sec[MAXN]= {0};\n\nint extl[MAXN][MAXL]= {0}, extr[MAXN][MAXL]= {0};\nint f[2][MAXN]= {0};\nbool answer[MAXN]= {false};\nvoid work (int p, int l, int r) {\n\tint n = lgv - 1;\n\tint limit = (1 << n) - 1;\n\tf[p][0] = l - 1;\n\tfor (int state = 1; state <= limit; state ++) {\n\t\tf[p][state] = l - 1;\n\t\tfor (int j = 1; j <= n; j ++)\n\t\t\tif (state & (1 << (j - 1))) {\n\t\t\t\tint pre = f[p][state ^ (1 << (j - 1))];\n\t\t\t\tf[p][state] = max (f[p][state], f[p][state ^ (1 << (j - 1))]);\n\t\t\t\tf[p][state] = max (f[p][state], extr[pre + 1][j]);\n\t\t\t}\n\t}\n}\nvoid solve () {\n\tint n = lgv - 1;\n\tint cnt = 0;\n\tfor (int i = 1; i <= N; i ++) {\n\t\tif (extl[i][lgv] == extl[i - 1][lgv] && extr[i][lgv] == extr[i - 1][lgv]) {\n\t\t\tanswer[i] = answer[i - 1];\n\t\t\tcontinue;\n\t\t}\n\t\tcnt ++;\n\t\tif (cnt > lgv + 1) {\n\t\t\tfor (int j = 1; j <= N; j ++) answer[j] = false;\n\t\t\treturn ;\n\t\t}\n\t\tint pl = extl[i][lgv], pr = extr[i][lgv];\n\t\tif (pl != 1) work (0, 1, pl - 1);\n\t\tif (pr != N) work (1, pr + 1, N);\n\t\tint limit = (1 << n) - 1;\n\t\tif (pl == 1 && pr == N) answer[i] = true;\n\t\telse if (pl == 1) answer[i] = f[1][limit] >= N;\n\t\telse if (pr == N) answer[i] = f[0][limit] >= pl - 1;\n\t\telse {\n\t\t\tfor (int state = 1; state <= limit; state ++)\n\t\t\t\tif (f[0][state] >= pl - 1 && f[1][limit ^ state] >= N) {\n\t\t\t\t\tanswer[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint getnum () {\n\tint num = 0;\n\tchar ch = getchar ();\n\tbool isneg = false;\n\n\twhile (! isdigit (ch)) {\n\t\tif (ch == '-') isneg = true;\n\t\tch = getchar ();\n\t}\n\twhile (isdigit (ch))\n\t\tnum = (num << 3) + (num << 1) + ch - '0', ch = getchar ();\n\n\treturn isneg ? - num : num;\n}\n\nint main () {\n\tN = getnum (), V = getnum ();\n\tfor (int i = 1; i <= N; i ++)\n\t\ta[i] = getnum ();\n\tfor (int s = V; s > 0; s >>= 1)\n\t\tsec[++ lgv] = s;\n\tsec[++ lgv] = 0;\n\treverse (sec + 1, sec + lgv + 1);\n\tfor (int l = 1; l <= lgv; l ++) {\n\t\tfor (int i = 1; i <= N; i ++) {\n\t\t\tif (i == 1) extl[i][l] = 1;\n\t\t\telse extl[i][l] = a[i] - a[i - 1] <= sec[l] ? extl[i - 1][l] : i;\n\t\t}\n\t\tfor (int i = N; i >= 1; i --) {\n\t\t\tif (i == N) extr[i][l] = N;\n\t\t\telse extr[i][l] = a[i + 1] - a[i] <= sec[l] ? extr[i + 1][l] : i;\n\t\t}\n\t}\n\t/*for (int l = 1; l <= lgv; l ++) {\n\t\tcout << \"now: \" << sec[l] << endl;\n\t\tfor (int i = 1; i <= N; i ++)\n\t\t\tcout << extl[i][l] << ' ' << extr[i][l] << endl;\n\t}*/\n\tsolve ();\n\tfor (int i = 1; i <= N; i ++)\n\t\tanswer[i] ? puts (\"Possible\") : puts (\"Impossible\");\n\n\treturn 0;\n}\n\n/*\n3 2\n1 3 6\n*/\n\n/*\n7 2\n-10 -4 -2 0 2 4 10\n*/\n\n/*\n16 19\n-49 -48 -33 -30 -21 -14 0 15 19 23 44 52 80 81 82 84\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MAXN = 200010;\n\nconst int LG = 22;\nint x[MAXN], p[MAXN][LG], f[MAXN * 3], v[MAXN], vs = 0;\nint f2[MAXN * 3],  p2[MAXN][LG];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d%d\", &n, v);\n\tvs = 0;\n\twhile (v[vs] > 0)\n\t{\n\t\tv[vs + 1] = v[vs] / 2;\n\t\tvs++;\n\t}\n\tvs++;\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", x + i);\n\n\tfor (int i = 0; i < vs; i++)\n\t{\n\t\tp[n][i] = p[n - 1][i] = n;\n\t\tfor (int j = n - 2; j >= 0; j--)\n\t\t{\n\t\t\tif (x[j + 1] - x[j] > v[i]) p[j][i] = j + 1;\n\t\t\telse p[j][i] = p[j + 1][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < vs; i++)\n\t{\n\t\tp2[0][i] = p2[1][i] = 0;\n\t\tfor (int j = 2; j <= n; j++)\n\t\t{\n\t\t\tif (x[j - 1] - x[j - 2] > v[i]) p2[j][i] = j - 1;\n\t\t\telse p2[j][i] = p2[j - 1][i];\n\t\t}\n\t}\n\tmemset(f, 0, sizeof(f));\n\tfor (int i = 0; i < (1 << vs); i++)\n\t\tfor (int j = 0; j < vs; j++)\n\t\t{\n\t\t\tif (i & (1 << j)) continue;\n\t\t\tint nv = i + (1 << j);\n\t\t\tf[nv] = max(f[nv], p[f[i]][j]);\n\t\t}\n\tfor (int i = 0; i < (1 << vs); i++) f2[i] = n;\n\tfor (int i = 0; i < (1 << vs); i++)\n\t\tfor (int j = 0; j < vs; j++)\n\t\t{\n\t\t\tif (i & (1 << j)) continue;\n\t\t\tint nv = i + (1 << j);\n\t\t\tf2[nv] = min(f2[nv], p2[f2[i]][j]);\n\n\t\t}\n\tint msk = (1 << vs) - 1;\n\tif (f[msk] < n)\n\t{\n\t\tfor (int i = 0; i < n; i++) printf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tint l, r;\n\tfor (l = 0; l != n; l = r)\n\t{\n\t\tr = p[l][0];\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < (1 << vs); i++)\n\t\t{\n\t\t\tif (i & 1) continue;\n\t\t\tif ((f[i] >= l) && (f2[msk - 1 - i] <= r))\n\t\t\t\tok = true;\n\t\t}\n\t\tfor (int i = l; i < r; i++)\n\t\t\tif (!ok) printf(\"Impossible\\n\");\n\t\t\telse printf(\"Possible\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 200000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nint n,V,x[MN+5],s,nxt[20][MN+5],res[MN+5],f[1<<18];\ninline void R(int&x,int y){y>x?x=y:0;}\nvoid Solve(int l,int r)\n{\n    memset(f,200,sizeof(f));f[0]=l==1?r+1:1;\n    for(int i=0;i<1<<s;++i)\n        for(int j=1;j<=s;++j) if(!(i&(1<<j-1)))\n            R(f[i|(1<<j-1)],nxt[j][f[i]]==l?r+1:nxt[j][f[i]]);\n    if(f[(1<<s)-1]>n) for(int i=l;i<=r;++i) res[i]=1;\n}\nint main()\n{\n    n=read();V=read();\n    for(int i=1;i<=n;++i) x[i]=read();\n    for(int t=V;;t>>=1,++s)\n    {\n        nxt[s][n]=nxt[s][n+1]=n+1;\n        for(int i=n-1;i;--i) nxt[s][i]=x[i+1]-x[i]>t?i+1:nxt[s][i+1];\n        if(!t) break;\n    }\n    int tot=0;\n    for(int i=1;i<=n;i=nxt[0][i],++tot);\n    if(tot<=s+1) for(int b=1;b<=n;b=nxt[0][b],++tot) Solve(b,nxt[0][b]-1);\n    for(int i=1;i<=n;++i) puts(res[i]?\"Possible\":\"Impossible\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=200005,M=20,L=266666;\n\nint n,m,x[N],U,dp1[L],dp2[L];\nint nex[M][N],pre[M][N],sz[M],k;\nint mx[N];\n\nvoid make(int V,int*nx,int*pr){\n\tnx[n]=n;\n\tfor(int i=n-1;i>=1;i--)if(x[i+1]-x[i]>V)nx[i]=i;else nx[i]=nx[i+1];\n\tpr[1]=1;\n\tfor(int i=2;i<=n;i++)if(x[i]-x[i-1]>V)pr[i]=i;else pr[i]=pr[i-1];\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&x[i]);\n\tfor(int i=m>>1;i>=1;i>>=1)sz[k++]=i;sz[k++]=0;\n\tsz[k]=m;\n\tfor(int i=0;i<=k;i++)make(sz[i],nex[i],pre[i]);\n\tU=(1<<k)-1;\n\tfor(int i=1;i<=n;i++)dp1[i]=0,dp2[i]=n+1;\n\tdp1[0]=1;\n\tdp2[0]=n;\n\tfor(int i=0;i<U;i++)for(int j=0;j<k;j++)\n\t\tif(~i>>j&1){\n\t\t\tif(dp1[i]==n)dp1[i|1<<j]=n;\n\t\t\telse dp1[i|1<<j]=max(dp1[i|1<<j],nex[j][dp1[i]+1]);\n\t\t\tif(dp2[i]==1)dp2[i|1<<j]=1;\n\t\t\telse dp2[i|1<<j]=min(dp2[i|1<<j],pre[j][dp2[i]-1]);\n\t\t}\n\tmemset(mx,-1,sizeof(mx));\n\tfor(int i=0;i<U;i++)\n\t\tmx[dp2[i]]=max(mx[dp2[i]],dp1[U^i]);\n\tfor(int i=1;i<=n+1;i++)\n\t\tmx[i]=max(mx[i],mx[i-1]);\n\tfor(int i=1;i<=n;i++){\n\t\tif(mx[nex[k][i]+1]>=pre[k][i]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\nvoid read(int &x){ scanf(\"%d\",&x); }\n\nconst int N=5e5+50,K=20,oo=1e9;\n\nint suc[N],n,m,v,a[K],x[N],frw[1<<K],bkw[1<<K],R[K][N],L[K][N]; \n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\tfreopen(\"dat.in\",\"r\",stdin);\n\t//freopen(\"my.out\",\"w\",stdout);\n#endif\n\tread(n),read(v);\n\trep(i,1,n){\n\t\tread(x[i]);  \n\t}\n\t//Range a[0,m]\n\tfor(;v;v>>=1)a[m++]=v;\n\trep(k,0,m){\n\t\tL[k][0]=1,L[k][1]=1;\n\t\trep(i,2,n)L[k][i]=x[i]-x[i-1]<=a[k]?L[k][i-1]:i;\n\t\tR[k][n+1]=n,R[k][n]=n;\n\t\tdec(i,n-1,1)R[k][i]=x[i+1]-x[i]<=a[k]?R[k][i+1]:i;\n\t}\n\tfill(frw,frw+(1<<m),0); \n\tfill(bkw,bkw+(1<<m),n+1); \n\tlop(s,0,(1<<m)){\n\t\tlop(i,0,m)if((s>>i&1)^1){\n\t\t\tcmax(frw[s+(1<<i)],R[i+1][frw[s]+1]);\n\t\t\tcmin(bkw[s+(1<<i)],L[i+1][bkw[s]-1]);\n\t\t}\n\t}\n\tlop(s,0,(1<<m)){\n\t\tint p=((1<<m)-1)^s;\n\t\tint i=frw[s],j=bkw[p];\n\t\tif(R[0][i+1]>=j-1)suc[R[0][i+1]]=true;\n\t}\n\trep(i,1,n)puts(suc[R[0][i]]?\"Possible\":\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\n#ifdef _DEBUG\n#define dbg(x) cerr << #x << \":\" << x << endl;\n#else\n#define dbg(x) while(false){}\n#endif\n\n#define fi(a, b) for(int i=a;i<b;++i)\n#define fj(a, b) for(int j=a;j<b;++j)\n\n////////\n\nint const M = 20;\nint const N = (1<<M);\nstring const YES = \"Possible\";\nstring const NO = \"Impossible\";\n\nint n, v, x[N];\nint le[N][M], ri[N][M];\nint cnt;\nstring ans[N];\n\nvoid setAns(string val, int l, int r){\n\tfi(l, r+1) ans[i] = val;\n}\n\nvoid print(){\n\tfi(1, n+1) printf(\"%s\\n\", ans[i].c_str());\n\texit(0);\n}\n\nvoid check(){\n\tint cn = cnt + 1;\n\tint v = 1;\n\twhile(v <= n){\n\t\tv = ri[v][0] + 1;\n\t\t--cn;\n\t}\n\tif(cn < 0){\n\t\tsetAns(NO, 1, n);\n\t\tprint();\n\t}\n}\n\nvoid build(){\n\tint vi = v;\n\tfi(0, M){\n\t\tcnt = i;\n\t\tle[1][i] = x[1];\n\t\tfj(2, n+1){\n\t\t\tif(x[j] - x[j-1] <= vi) le[j][i] = le[j-1][i];\n\t\t\telse le[j][i] = j;\n\t\t}\n\t\tri[n][i] = n;\n\t\tfor(int j=n-1;j>0;--j){\n\t\t\tif(x[j+1] - x[j] <= vi) ri[j][i] = ri[j+1][i];\n\t\t\telse ri[j][i] = j;\n\t\t}\n\t\tif(vi == 0) break;\n\t\tvi /= 2;\n\t}\n}\n\nint dl[N], dr[N];\n\nvoid remax(int &a, int b){\n\ta = max(a, b);\n}\n\nvoid remin(int &a, int b){\n\ta = min(a, b);\n}\n\nvoid calcDp(){\n\tdl[0] = 0;\n\tfi(0, (1<<cnt)){\n\t\tfj(0, cnt){\n\t\t\tif((1<<j)&i) continue;\n\t\t\tint nval = dl[i];\n\t\t\tif(nval != n){\n\t\t\t\tnval = ri[dl[i]+1][j+1];\n\t\t\t}\n\t\t\tremax(dl[((1<<j)^i)], nval);\n\t\t}\n\t}\n\tfi(0, (1<<cnt)) dr[i] = n+1;\n\tfi(0, (1<<cnt)){\n\t\tfj(0, cnt){ \n\t\t\tif((1<<j)&i) continue;\n\t\t\tint nval = dr[i];\n\t\t\tif(nval != 1){\n\t\t\t\tnval = le[dr[i]-1][j+1];\n\t\t\t}\n\t\t\tremin(dr[((1<<j)^i)], nval);\n\t\t}\n\t}\n}\n\nvoid findAnswers(){\n\tint v, nxt;\n\tv = 1;\n\twhile(v <= n){\n\t\tnxt = ri[v][0];\n\t\tbool can = false;\n\t\tfi(0, (1<<(cnt))){\n\t\t\tint maskL = i;\n\t\t\tint maskR = ( ((1<<(cnt))-1) ^ maskL );\n\t\t\tint lb = max(dl[maskL], 1);\n\t\t\tint rb = min(dr[maskR], n);\n\t\t\tif(lb+1 >= v && rb-1 <= nxt){\n\t\t\t\tcan = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(can){\n\t\t\tsetAns(YES, v, nxt);\n\t\t}else{\n\t\t\tsetAns(NO, v, nxt);\n\t\t}\n\t\tv = nxt + 1;\n\t}\n}\n\nvoid solve(){\n\tscanf(\"%d %d\",&n,&v);\n\tfi(1, n+1) scanf(\"%d\",&x[i]);\n\n\tbuild();\n\tdbg(cnt);\n\tcheck();\n\tcalcDp();\n\tfindAnswers();\n\tprint();\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 2e5 + 10;\n\nint n, v, m, ans[N];\nint a[N], b[N], L[N][22], R[N][22], f[N], g[N];\n\nint main()\n{\n    n = read(), v = read();\n    for (int i = 1; i <= n; i++) a[i] = read();\n    b[0] = v;\n    for (int i = 1; i <= 50; i++) b[i] = b[i - 1] >> 1;\n    for (int i = 0; b[i]; i++) m = i;\n    m += 2;\n    for (int i = 0; i < m; i++)\n        for (int j = 1; j <= n; )\n        {\n            int k;\n            for (k = j + 1; k <= n; k++)\n                if (a[k] - a[k - 1] > b[i])\n                    break;\n            for (int l = j; l < k; l++)\n                L[l][i] = j, R[l][i] = k - 1;\n            j = k;\n        }\n    for (int i = 0; i < (1 << m); i++) g[i] = n + 1;\n    for (int i = 0; i < (1 << m); i++)\n        for (int j = 0; j < m; j++)\n            if (!(i >> j & 1))\n            {\n                f[i | (1 << j)] = max(f[i | (1 << j)], R[f[i] + 1][j]);\n                g[i | (1 << j)] = min(g[i | (1 << j)], L[g[i] - 1][j]);\n            }\n    int S = (1 << m) - 2;\n    for (int i = 0; i < (1 << m); i++)\n        if (i % 2 == 0)\n        {\n            int j = S - i;\n            if (R[f[i] + 1][0] >= g[j] - 1)\n            {\n                if (f[i] + 1 > g[j] - 1)\n                    ans[1]++;\n                else\n                {\n                    int p = L[f[i] + 1][0], q = R[f[i] + 1][0];\n                    ans[p]++;\n                    ans[q + 1]--;\n                }\n            }\n        }\n    for (int i = 1; i <= n; i++) ans[i] += ans[i - 1];\n    for (int i = 1; i <= n; i++)\n        puts(ans[i] ? \"Possible\" : \"Impossible\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nint x[200010],dv[200010],m,L[200010],R[200010],c[200010];\nstd::vector<int>P[200010];\nint fl[262147],fr[262147];\nint main(){\n#ifdef XZZSB\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),V=gi();\n\tfor(int i=1;i<=n;++i)x[i]=gi();\n\tfor(int i=V,j=0;~i;i>>=1,++j){\n\t\tdv[j]=i;P[m=j].push_back(0);\n\t\tfor(int l=1,r;l<=n;l=r+1){\n\t\t\tr=l;while(r<n&&x[r+1]-x[r]<=i)++r;\n\t\t\tP[j].push_back(r);\n\t\t\tif(!j)for(int o=l;o<=r;++o)L[o]=l,R[o]=r;\n\t\t}\n\t\tif(!i)break;\n\t}\n\tfor(int i=0;i<1<<m;++i){\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tif((i>>j-1)&1)continue;\n\t\t\tint p;\n\t\t\tif(fl[i]==n)p=n;\n\t\t\telse p=*std::upper_bound(P[j].begin(),P[j].end(),fl[i]);\n\t\t\tfl[i|(1<<j-1)]=std::max(fl[i|(1<<j-1)],p);\n\t\t}\n\t}\n\tfor(int i=0;i<1<<m;++i)fr[i]=n+1;\n\tfor(int i=0;i<1<<m;++i){\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tif((i>>j-1)&1)continue;\n\t\t\tint p;\n\t\t\tif(fr[i]==1)p=1;\n\t\t\telse p=*--std::lower_bound(P[j].begin(),P[j].end(),fr[i]-1)+1;\n\t\t\tfr[i|(1<<j-1)]=std::min(fr[i|(1<<j-1)],p);\n\t\t}\n\t}\n\tfor(int i=0;i<1<<m;++i){\n\t\tint l=fl[i]+1,r=fr[((1<<m)-1)^i]-1;\n\t\tif(l>r)++c[1];\n\t\telse if(*std::lower_bound(P[0].begin(),P[0].end(),l)>=r)++c[l],--c[r+1];\n\t}\n\tfor(int i=1;i<=n;++i)c[i]+=c[i-1];\n\tfor(int i=1;i<=n;++i)puts(c[i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 200010;\n\nint x[maxn];\nint l[maxn], r[maxn];\nint lb[18][maxn], rb[18][maxn], dpl[1<<18], dpr[1<<18];\nint bound[maxn];\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,v;\n\tcin >> n >> v;\n\tfor(int i=1;i<=n;i++)\n\t\tcin >> x[i];\n\tfor(int i=0;i<=n;i++)\n\t\tbound[i] = 1e9;\n\tl[1] = 1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(x[i] - x[i-1] <= v)\n\t\t\tl[i] = l[i-1];\n\t\telse\n\t\t\tl[i] = i;\n\tr[n] = n;\n\tfor(int i=n-1;i>=1;i--)\n\t\tif(x[i+1] - x[i] <= v)\n\t\t\tr[i] = r[i+1];\n\t\telse\n\t\t\tr[i] = i;\n\tvector<int> cap;\n\t{\n\t\tint z = v/2;\n\t\twhile(z){\n\t\t\tcap.emplace_back(z);\n\t\t\tz/=2;\n\t\t}\n\t\tcap.emplace_back(0);\n\t}\n\tint N = cap.size();\n\tfor(int i=0;i<N;i++){\n\t\tlb[i][0] = lb[i][1] = 1;\n\t\tfor(int j=2;j<=n;j++)\n\t\t\tif(x[j] - x[j-1] <= cap[i])\n\t\t\t\tlb[i][j] = lb[i][j-1];\n\t\t\telse\n\t\t\t\tlb[i][j] = j;\n\t\trb[i][n+1] = rb[i][n] = n;\n\t\tfor(int j=n-1;j>=1;j--)\n\t\t\tif(x[j+1] - x[j] <= cap[i])\n\t\t\t\trb[i][j] = rb[i][j+1];\n\t\t\telse\n\t\t\t\trb[i][j] = j;\n\t}\n\tdpl[0] = 0;\n\tfor(int i=0;i<(1<<N);i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\tif(!((i>>j)&1))\n\t\t\t\tdpl[1<<j|i] = max(dpl[1<<j|i], rb[j][dpl[i]+1]);\n\tfor(int i=0;i<(1<<N);i++)\n\t\tdpr[i] = n+1;\n\tfor(int i=0;i<(1<<N);i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\tif(!((i>>j)&1))\n\t\t\t\tdpr[1<<j|i] = min(dpr[1<<j|i], lb[j][dpr[i]-1]);\n\tfor(int i=0;i<(1<<N);i++)\n\t\tbound[dpl[i]] = min(bound[dpl[i]], dpr[(1<<N) - 1 - i]);\n\tfor(int i=n-1;i>=0;i--)\n\t\tbound[i] = min(bound[i], bound[i+1]);\n\tfor(int i=1;i<=n;i++)\n\t\tif(bound[l[i] - 1] <= r[i] + 1)\n\t\t\tcout << \"Possible\\n\";\n\t\telse\n\t\t\tcout << \"Impossible\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 200200;\nconst int MAXK = 20;\n\nint a[MAX];\nint l[MAX][MAXK], r[MAX][MAXK];\nint fl[1 << MAXK], fr[1 << MAXK];\n\nint main(void) {\n  ios_base::sync_with_stdio(false);\n\n  int N, V;\n  cin >> N >> V;\n  REP(i, N) cin >> a[i];\n\n  int K = 0;\n  int v[MAXK];\n  while (V > 0) {\n    v[K++] = V;\n    V /= 2;\n  }\n  v[K++] = 0;\n\n  REP(i, N) {\n    REP(j, K) {\n      if (i > 0 && a[i] - a[i - 1] <= v[j]) {\n        l[i][j] = l[i - 1][j];\n      } else {\n        l[i][j] = i;\n      }\n    }\n  }\n\n  for (int i = N - 1; i >= 0; --i) {\n    REP(j, K) {\n      if (i < N - 1 && a[i + 1] - a[i] <= v[j]) {\n        r[i][j] = r[i + 1][j];\n      } else {\n        r[i][j] = i;\n      }\n    }\n  }\n\n  REP(s, 1 << K) fl[s] = 0, fr[s] = N - 1;\n  REP(s, 1 << K) {\n    REP(j, K) {\n      if (!(s & (1 << j))) {\n        int ns = s | (1 << j);\n        int nfl = fl[s] == N ? N : r[fl[s]][j] + 1;\n        fl[ns] = max(fl[ns], nfl);\n        int nfr = fr[s] == -1 ? -1 : l[fr[s]][j] - 1;\n        fr[ns] = min(fr[ns], nfr);\n      }\n    }\n  }\n\n  vector<bool> can(N, false);\n\n  int all = (1 << K) - 1 - 1;\n  bool all_can = false;\n  REP(s, 1 << K) {\n    if ((s & all) == s) {\n      int a = fl[s];\n      int b = fr[all ^ s];\n\n      if (a > b) {\n        all_can = true;\n        break;\n      }\n\n      if (r[a][0] >= b) can[l[a][0]] = true;\n    }\n  }\n\n  REP(i, N) {\n    if (can[l[i][0]] || all_can) {\n      cout << \"Possible\\n\";\n    } else {\n      cout << \"Impossible\\n\";\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstdlib>\n\nnamespace IO\n{\n//    inline char gc()\n//    {\n//        static char s[1<<20|1]={0},*p1=s,*p2=s;\n//        return (p1==p2)&&(p2=(p1=s)+fread(s,1,1<<20,stdin),p1==p2)?EOF:*(p1++);\n//    }\n\tinline char gc() { return getchar(); }\n\tinline long long read()\n\t{\n\t\tlong long ret=0;bool flag=0;char c=gc();\n\t\twhile ((c<'0')|(c>'9')) flag ^= !(c^'-'),c=gc();\n\t\twhile ((c>='0')&(c<='9')) ret=(ret<<1)+(ret<<3)+(c^'0'),c=gc();\n\t\treturn flag?-ret:ret;\n \t}\n \tchar OutputAns[1<<20|1],*OutputCur = OutputAns;\n \tinline void output()\n \t{\n \t\tOutputCur -= fwrite(OutputAns,1,OutputCur - OutputAns,stdout);\n\t}\n\tinline void print(long long ans)\n\t{\n\t\tchar s[20]={0};\n\t\tif (OutputCur - OutputAns + sprintf(s,\"%lld\",ans) >> 20) output();\n\t\tOutputCur += sprintf(OutputCur,\"%lld\",ans);\n\t}\n\tinline void printc(char c)\n\t{\n\t\tif (OutputCur - OutputAns + 1 >> 20) output();\n\t\t*(OutputCur++) = c;\n\t}\n}\n\nusing IO::read;\nusing IO::print;\nusing IO::printc;\nusing IO::output;\n\nconst int M = 3e5 + 11;\n\nconst int INF = 1e9 + 7;\n\nint End[25][M], Fir[25][M], Dp1[M], Dp2[M], Pos[M], T[25];\n\nint n, lim, top, sumBlock;\n\ninline void Input()\n{\n\tn = read(), lim = read(); for (int i = 1;i <= n; ++i) Pos[i] = read();\n\tint tmp = lim; while (tmp) { T[top++] = tmp >> 1; tmp >>= 1; } T[top] = lim;\n}\n\ninline void Solve()\n{\n\tfor (int i = 0;i <= top; ++i)\n\t{\n\t\tFir[i][1] = 1;\n\t\tfor (int j = 2;j <= n; ++j)\n\t\t{\n\t\t\tif (Pos[j] - Pos[j - 1] <= T[i]) Fir[i][j] = Fir[i][j - 1];\n\t\t\telse Fir[i][j] = j;\n\t\t}\n\t}\n\tfor (int i = 0;i <= top; ++i)\n\t{\n\t\tEnd[i][n] = n;\n\t\tfor (int j = n - 1; j >= 1; --j)\n\t\t{\n\t\t\tif (Pos[j + 1] - Pos[j] <= T[i]) End[i][j] = End[i][j + 1];\n\t\t\telse { End[i][j] = j; if (i == top) ++sumBlock; }\n\t\t}\n\t} \n\tif (sumBlock > top)\n\t{\n\t\tfor (int i = 1;i <= n; ++i) puts(\"Impossible\");\n\t\texit(0);\n\t} int all = (1<<top);\n\tfor (int s = 0;s < all; ++s) Dp2[s] = n + 1;\n\tfor (int S = 0;S < all; ++S)\n\t\tfor (int i = 0;i <= top; ++i)\n\t\t\tif (!((1<<i) & S))\t\n\t\t\t\tDp1[S | (1<<i)] = std::max(Dp1[S | (1<<i)], End[i][Dp1[S] + 1]),\n\t\t\t\tDp2[S | (1<<i)] = std::min(Dp2[S | (1<<i)], Fir[i][Dp2[S] - 1]);\n\tfor (int i = 1;i <= n; ++i)\n\t{\n\t\tbool ok = 0;\n\t\tfor (int S = 0;S < all; ++S)\n\t\t{\n\t\t\tint ss = (all - 1) ^ S;\n\t\t\tif (Dp1[S] >= i - 1 && Dp2[ss] <= End[top][i] + 1) { ok = 1; break; }\n\t\t}\n\t\tfor (int j = i;j <= End[top][i]; ++j)\n\t\t{\n\t\t\tif (ok) puts(\"Possible\");\n\t\t\telse puts(\"Impossible\");\n\t\t} i = End[top][i];\n\t}\n}\n\nint main(void)\n{\n//\tfreopen(\"jump.in\",\"r\",stdin);\n///\tfreopen(\"jump.out\",\"w\",stdout);\n\tInput();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<pair<int,int> > > vv;\n\nstruct tree{\n\tvector<int> data;\n\tvector<tree> child;\n\tint mind;\n\tint dis;\n\ttree(vector<int> seed,int d){\n\t\tfor(int i = 0;i < seed.size();i++){\n\t\t\tdata.push_back(seed[i]);\n\t\t}\n\t\tdis = d;\n\t}\n\n\tvoid makechild(int d){\n\t\tif(d == 0) return;\n\t\tvector<int> making;\n\t\tfor(int i = 0;i < data.size()-1;i++){\n\t\t\tmaking.push_back(data[i]);\n\t\t\tif(data[i+1]-data[i] > d){//cout << d << endl;\n\t\t\t\tchild.push_back(tree(making,d));\n\t\t\t\tmaking.clear();\n\t\t\t}\n\t\t}\n\t\tmaking.push_back(data[data.size()-1]);\n\t\tchild.push_back(tree(making,d));\n\t\tfor(int i = 0;i < child.size();i++){\n\t\t\tchild[i].makechild(d/2);\n\t\t}\n\t}\n\n\tvoid deep(){\n\t\tif(dis == 0){\n\t\t\tmind = 0;\n\t\t\treturn;\n\t\t}\n\t\tvector<int> minds;\n\t\tfor(int i = 0;i < child.size();i++){\n\t\t\tchild[i].deep();\n\t\t\tminds.push_back(child[i].mind);\n\t\t}\n\t\tsort(minds.begin(),minds.end());\n\t\tint con = -1;\n\t\tfor(int i = 0;i < minds.size();i++){\n\t\t\tcon++;\n\t\t\tif(minds[i] > con) con = minds[i];\n\t\t}\n\t\tmind = con;\n\t\t//cout << mind << endl;\n\t}\n\n\tvoid pri(int d){\n\t\tint cc = 0;\n\t\tfor(cc = 0;d > 0;d/=2)cc++;\n\t\tfor(int i = 0;i < child.size();i++){\n\t\t\tvector<int> minds;\n\t\t\tfor(int j = 0;j < child.size();j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tminds.push_back(child[j].mind);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(minds.begin(),minds.end());\n\t\t\tbool f = true;\n\t\t\tfor(int j = 0;j < minds.size();j++){\n\t\t\t\tif(minds[j] > cc-minds.size()+j) f=false;\n\t\t\t}\n\t\t\tfor(int j = 0;j < child[i].data.size();j++){\n\t\t\t\tif(f) cout << \"Possible\" << endl;\n\t\t\t\telse cout << \"Impossible\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid pri(){\n\t\tfor(int i = 0;i < data.size();i++){\n\t\t\tcout << data[i] << ' ';\n\t\t}cout << endl;\n\t\tfor(int j = 0;j < child.size();j++){\n\t\t\tchild[j].pri();\n\t\t}\n\t}\n};\n\nint main(){\n\tint n,v;\n\tcin >> n >> v;\n\tvector<int> x(n);\n\tfor(int i = 0;i < n;i++) cin >> x[i];\n\ttree root(x,v*4);\n\troot.makechild(v);\n\troot.deep();\n\troot.pri(v);\n\t//root.pri();\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=2E5+5;\n\nint N,M,K,V;\nint a[Maxn];\nint F[Maxn],G[Maxn];\nint L[20][Maxn],R[20][Maxn];\nchar Ans[50],_1[50]={\"Possible\"},_2[50]={\"Impossible\"};\n//int nxt[Maxn];\n\ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n\nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1)\n\t\t\t\tMAX(F[i],R[M-j][min(F[i-(1<<j)]+1,N)]),\n\t\t\t\tMIN(G[i],L[M-j][max(G[i-(1<<j)]-1,1)]);\n\t}\n\tfor(int i=1;i<=N;++i)\n\t\tK+=(L[0][i]!=L[0][i-1]);\n\tif(K>20){\n\t\tfor(int i=1;i<=N;++i)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=1,j;i<=N;++i)\n\t\tif(L[0][i]!=L[0][i-1]){\n\t\t\tfor(j=0;j<(1<<M);++j)\n\t\t\t\tif(F[j]>=L[0][i]-1 && G[(1<<M)-1-i]<=R[0][i]+1)\n\t\t\t\t\t{memcpy(Ans,_1,sizeof(_1)); break ;}\n\t\t\tif(j==1<<M) memcpy(Ans,_2,sizeof(_2));\n\t\t\tprintf(\"%s\\n\",Ans);\n\t\t}else printf(\"%s\\n\",Ans);\n/*\tmemset(nxt,-1,sizeof(nxt));\n\tfor(int i=0;i<(1<<M);++i) MAX(nxt[G[(1<<M)-1-i]],F[i]);\n\tfor(int i=1;i<=N+1;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[R[0][i]+1]>=L[0][i]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nstatic const int MAXN = 2e5 + 4;\nstatic const int LOGN = 19;\ntemplate <typename T> inline void upd_max(T &var, const T val) { if (var < val) var = val; }\ntemplate <typename T> inline void upd_min(T &var, const T val) { if (var > val) var = val; }\n\nint n, v_max, x[MAXN];\nint k, v[LOGN];\nint f_lf[1 << LOGN], f_rg[1 << LOGN];\nint rg_with_lf[MAXN];\n\nvoid calc_dp(int *f)\n{\n    static int next[LOGN][MAXN];\n    for (int i = 0; i < k; ++i) {\n        for (int p = 0, q; p < n; ) {\n            for (q = p + 1; q < n && x[q] - x[q - 1] <= v[i]; ++q) ;\n            for (; p < q; ++p) next[i][p] = q;\n        }\n    }\n\n    for (int i = 0; i < (1 << k); ++i) f[i] = 0;\n    std::vector<int> pc[LOGN];\n    for (int i = 0; i < (1 << k); ++i) pc[__builtin_popcount(i)].push_back(i);\n    for (int i = 0; i < k; ++i) for (int mask : pc[i]) {\n        for (int j = 0; j < k; ++j) if (!(mask & (1 << j))) {\n            upd_max(f[mask | (1 << j)], next[j][f[mask]]);\n        }\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &v_max);\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &x[i]);\n    for (k = 0; v_max > 0; ++k, v_max /= 2) v[k] = v_max;\n    v[k++] = 0;\n\n    calc_dp(f_lf);\n    std::reverse(x, x + n);\n    for (int i = 0; i < n; ++i) x[i] = -x[i];\n    calc_dp(f_rg);\n    std::reverse(x, x + n);\n    for (int i = 0; i < n; ++i) x[i] = -x[i];\n    for (int i = 0; i < (1 << k); ++i) f_rg[i] = n - f_rg[i];\n\n    for (int i = 0; i <= n; ++i) rg_with_lf[i] = MAXN;\n    for (int i = 0; i < (1 << (k - 1)); ++i) upd_min(rg_with_lf[f_lf[i << 1]], f_rg[(((1 << (k - 1)) - 1) ^ i) << 1]);\n    for (int i = n - 1; i >= 0; --i) upd_min(rg_with_lf[i], rg_with_lf[i + 1]);\n\n    for (int i = 0, j; i < n; ) {\n        for (j = i + 1; j < n && x[j] - x[j - 1] <= v[0]; ++j) ;\n        bool possible = (rg_with_lf[i] <= j);\n        for (; i < j; ++i) puts(possible ? \"Possible\" : \"Impossible\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pb2 pop_back\n#define pf push_front\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define rep(k,i,j) for(int k = (int)i;k<(int) j;k++)\n#define repd(k,i,j) for(int k = i;k>=(int)j;k--)\n#define ll long long\n#define pq priority_queue\n\nint dirx[8] = {0,1,0,-1,1,1,-1,-1};\nint diry[8] = {1,0,-1,0,1,-1,1,-1};\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e16;\nconst double EPS = 1e-6;\n\nusing namespace std;\n\nconst int maxn = 3e5+5;\n\nint n,v;\nint loc[maxn];\n\nint jump[maxn][20],m;\n\nint dp[maxn];\n\nint ch[maxn];\n\nint in_q[maxn];\nint solve(){\n\tmemset(dp,-1,sizeof dp);\n\tmemset(in_q,0,sizeof in_q);\n\t\n\tqueue<int> q;\n\t\n\tq.push(1);\n\tdp[1] = 0;\n\tin_q[1] = 1;\n\t\n\twhile(q.size()){\n\t\tint mask = q.front();\n\t\tint a = ch[dp[mask]];\n\t\t\n\t\tq.pop();\n\t\tin_q[mask] = 0;\n\t\t\n\t\tif(a==n)return 1;\n\t\trep(k,0,m)if(((1<<k)&mask)==0){\n\t\t\tint b = ch[jump[a][k]];\n\t\t\tint maskb = (mask|(1<<k));\n\t\t\t\n\t\t\tif(dp[maskb]<b){\n\t\t\t\tdp[maskb] = b;\n\t\t\t\tif(!in_q[maskb])q.push(maskb),in_q[maskb] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\t\n\trep(k,0,n)scanf(\"%d\",&loc[k]);\n\t\n\t\n\tfor(;v>=0;v/=2){\n\t\trep(k,0,n){\n\t\t\tint i = k;\n\t\t\twhile(i<n){\n\t\t\t\tif(i<n-1 && loc[i+1]-loc[i]<=v){\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\twhile(k<=i)jump[k++][m] = i+1;\n\t\t\tk = i;\n\t\t}\n\t\t\n\t\tm++;\n\t\tif(v==0)break;\n\t}\n\t\n\trep(k,0,m){\n\t\t//rep(i,0,n)printf(\"%d \",jump[i][k]);line;\n\t\t\n\t}\n\trep(k,0,maxn)ch[k] = k;\n\t\n\tint hit = 0;\n\trep(k,0,n){\n\t\tif(hit>18){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint nxt = jump[k][0];\n\t\t\n\t\thit++;\n\t\tch[k] = nxt;\n\t\tint ret = solve();\n\t\tch[k] = k;\n\t\t\n\t\twhile(k<nxt)printf(\"%s\\n\",ret?\"Possible\":\"Impossible\"),k++;\n\t\tk = nxt-1;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,m,mx,s,i,j,cnt,sz,la,a[500010],b[500010],c[500010][2],hd[21][200010],\npr[21][200010],f[500010],g[500010],d[500010];\nint main(){\n\tscanf(\"%d%d\",&n,&m);la=m;\n\tfor(i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tm/=2;\n\twhile(1){\n\t\tb[cnt++]=m;\n\t\tif(!m)break;m/=2;\n\t}\n\tmx=1<<cnt;\n\tfor(j=0;j<cnt;j++){\n\t\t//printf(\"%d\\n\",b[j]);\n\t\thd[j][n]=n;hd[j][n+1]=n+1;\n\t\tfor(i=n-1;i;i--){\n\t\t\tif(a[i+1]-a[i]>b[j])hd[j][i]=i;\n\t\t\t else hd[j][i]=hd[j][i+1];\n\t\t}\n\t\tpr[j][1]=1;\n\t\tfor(i=2;i<=n;i++){\n\t\t\tif(a[i]-a[i-1]>b[j])pr[j][i]=i;\n\t\t\t else pr[j][i]=pr[j][i-1];\n\t\t\t//printf(\"%d %d %d\\n\",i,pr[j][i],hd[j][i]);\n\t\t}\n\t\t//puts(\"\");\n\t}\n\tc[sz=1][0]=1;\n\tfor(i=2;i<=n;i++){\n\t\tif(a[i]-a[i-1]>la)c[sz][1]=i-1,c[++sz][0]=i;\n\t}\n\tc[sz][1]=n;\n\t//printf(\"%d\\n\",sz);\n\tif(sz>20){\n\t\tfor(i=1;i<=n;i++)puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tmemset(g,44,sizeof(g));\n\tg[0]=n+1;\n\tfor(s=0;s<mx;s++){\n\t\t//printf(\"%d %d %d\\n\",s,f[s],g[s]);\n\t\tfor(i=0;i<cnt;i++)if(!(s&(1<<i))){\n\t\t\tf[s|(1<<i)]=min(n,max(f[s|(1<<i)],hd[i][f[s]+1]));\n\t\t\tg[s|(1<<i)]=max(1,min(g[s|(1<<i)],pr[i][g[s]-1]));\n\t\t}\n\t}\n\t//memset(g,44,sizeof(g));\n\tfor(i=1;i<=sz;i++)\n\t for(s=0;s<mx;s++)if(f[s]>=c[i][0]-1&&g[(mx-1)^s]<=c[i][1]+1)d[c[i][0]]++,d[c[i][1]+1]--;\n\tfor(i=1;i<=n;i++)d[i]+=d[i-1];\n\tfor(i=1;i<=n;i++)if(d[i])puts(\"Possible\");\n\t else puts(\"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=262244,M=22,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ntemplate<class T> inline void read(T &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ntemplate<class T> inline void print(T x){\n\tif(!x){puts(\"0\");return;}\n\tif(x<0){putchar('-');x=-x;}\n\tint a[20],m=0;\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');puts(\"\");\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,a[N],v[20],l[20][N],r[20][N],f[N],g[N];\n\n\nvoid solve(int x){\n\tfor(int i=1;i<=n;i++){\n\t\tint t=i;\n\t\twhile(t<n&&a[t+1]-a[t]<=v[x]) t++;\n\t\tfor(int j=i;j<=t;j++)\n\t\t\tl[x][j]=t+1,r[x][j]=i-1;\n\t\ti=t;\n\t}\n\tl[x][n+1]=n+1;\n\tr[x][0]=0;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tsrand(time(0));\n#endif\n\tios::sync_with_stdio(0);\n\tread(n);read(v[0]);\n\tfor(int i=1;i<=n;i++) read(a[i]);\n\tfor(int j=1;v[j-1];j++,m=j) v[j]=v[j-1]>>1;\n\tfor(int i=0;i<m;i++) solve(i);\n\tint cnt=0;\n\tfor(int i=1;i<n;i++)\n\t\tif(a[i+1]-a[i]>v[0]) cnt++;\n\tif(cnt>m){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tdebug(m);\n\tf[0]=1;g[0]=n;\n\tfor(int i=1;i<(1<<m-1);i++){\n\t\tf[i]=1,g[i]=n;\n\t\tfor(int j=1;j<m;j++)\n\t\t\tif(i&(1<<j-1)) gmax(f[i],l[j][f[i^(1<<j-1)]]),gmin(g[i],r[j][g[i^(1<<j-1)]]);\n\t\t}\n\tint u=(1<<m-1)-1;\n\tfor(int i=1;i<=n;i++){\n\t\tint r=i,isok=0;\n\t\twhile(r<n&&a[r+1]-a[r]<=v[0]) r++;\n\t\tfor(int j=0;j<(1<<m-1);j++)\n\t\t\tif(f[j]>=i&&g[u^j]<=r) isok=1;\n\t\tfor(int j=i;j<=r;j++)\n\t\t\tif(isok) puts(\"Possible\"); else puts(\"Impossible\");\n\t\ti=r;\n\t}\n#ifdef rqgao2014\n\ttime_tester(1);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,b,e) for(int i=(b); i <= (e); ++i)\n#define FORD(i,b,e) for(int i=(b); i >= (e); --i)\n#define REP(i,n) for(int i=0; i < (n); ++i)\n#define SIZE(c) (int) (c).size()\n#define ALL(c) (c).begin(), (c).end()\n#define PB push_back\n#define MP make_pair\n#define ST first\n#define ND second\n#define FWD(i,a,b) for (int i=(a); i<(b); ++i)\n#define BCK(i,a,b) for (int i=(a); i>(b); --i)\n#define PI 3.14159265358979311600\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\ntypedef vector < int > VI;\ntypedef vector<ll> VL;\n\ntypedef long double K;\n\nconst int N = 200005;\nconst int M = 1<<22;\nconst int inf = 1000*1000*1000 + 7;\n\nint n, v, cnt, bound;\nint a[N], f[M], g[M];\nint goLeft[N][23], goRight[N][23];\nvector<int> b;\n\nstruct SegTree {\n\tint n;\n\tvector<int> tree;\n\n\tSegTree(int n): n(n), tree(4*n, inf) {}\n\n\tvoid update(int pos, int val) {\n\t\tupdate(1, 0, n - 1, pos, val);\n\t}\n\n\tint go(int l, int r) {\n\t\treturn go(1, 0, n - 1, l, r);\n\t}\n\n\tvoid update(int v, int tl, int tr, int pos, int val) {\n\t\tif (tl == tr) {\n\t\t\ttree[v] = min(tree[v], val);\n\t\t\treturn;\n\t\t}\n\t\tint tm = (tl + tr) / 2;\n\t\tif (pos <= tm) {\n\t\t\tupdate(2*v, tl, tm, pos, val); \n\t\t} else {\t\n\t\t\tupdate(2*v+1, tm+1, tr, pos, val);\n\t\t}\n\t\ttree[v] = min(tree[2*v], tree[2*v+1]);\n\t}\n\n\tint go(int v, int tl, int tr, int l, int r) {\n\t\tif (l > tr || r < tl) return inf;\n\t\tif (l <= tl && r >= tr) return tree[v];\n\t\tint tm = (tl + tr) / 2;\n\t\treturn min(go(2*v, tl, tm, l, r), go(2*v+1, tm+1, tr, l, r));\n\t}\n};\n\nvoid calc() {\n\tREP(i, cnt) {\n\t\tREP(j, n) {\n\t\t\tgoLeft[i][j] = j;\n\t\t\tif (j > 0 && a[j] - a[j - 1] <= b[i]) {\n\t\t\t\tgoLeft[i][j] = goLeft[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tgoRight[i][j] = j;\n\t\t\tif (j < n - 1 && a[j + 1] - a[j] <= b[i]) {\n\t\t\t\tgoRight[i][j] = goRight[i][j + 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint go(int pos, int x, int side) {\n\tif (side < 0) {\n\t\treturn pos >= 0 ? goLeft[x][pos] : pos;\n\t} \n\treturn pos < n ? goRight[x][pos] : pos;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> v;\n\tREP(i, n) {\n\t\tcin >> a[i];\n\t}\n\n\twhile (v > 0) {\n\t\tb.push_back(v);\n\t\tv /= 2;\n\t}\n\tb.push_back(0);\n\tcnt = (int)b.size();\n\tbound = (1 << cnt);\n\n\tcalc();\n\n\tREP(i, bound) f[i] = -inf, g[i] = inf;\n\tf[0] = 0;\n\tg[0] = n - 1;\n\n\tREP(i, bound) {\n\t\tREP(j, cnt) if (~i & (1 << j)) {\n\t\t\tif (f[i] != -inf) {\n\t\t\t\tf[i ^ (1 << j)] = max(f[i ^ (1 << j)], go(f[i], j, +1) + 1);\n\t\t\t}\n\t\t\tif (g[i] != inf) {\n\t\t\t\tg[i ^ (1 << j)] = min(g[i ^ (1 << j)], go(g[i], j, -1) - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tint all = 0;\n\n\tSegTree tree(n);\n\n\tREP(mask, bound) {\n\t\tint comp = (bound - 1) ^ mask;\n\t\tint a = (mask & 1) ? (mask ^ 1) : mask;\n\t\tint b = (comp & 1) ? (comp ^ 1) : comp;\n\t\tif (f[a] != -inf && g[b] != inf) {\n\t\t\tif (f[a] > g[b]) {\n\t\t\t\tall = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttree.update(f[a], g[b]);\n\t\t}\n\t}\n\n\tREP(i, n) {\n\t\t/*if (all) {\n\t\t\tcout << \"Possible\\n\";\n\t\t\tcontinue;\n\t\t}*/\n\t\tint lb = go(i, 0, -1);\n\t\tint rb = go(i, 0, +1);\n\t\tif (tree.go(lb, rb) <= rb) {\n\t\t\tcout << \"Possible\\n\";\n\t\t} else {\n\t\t\tcout << \"Impossible\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define stt static\n#define rg register\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n#define y1 substitute_of_y1\n#define DEBUG(x) cerr<<#x\" = \"<<x<<endl;\nusing namespace std;\n\ntemplate<typename T> il T rd(){\n\tT nmb=0;int sgn=0;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-')sgn=1;chr=getchar();}\n\twhile(isdigit(chr)){nmb=(nmb<<3)+(nmb<<1)+chr-'0';chr=getchar();}\n\treturn sgn?-nmb:nmb;\n}\ntemplate<typename T> void wt(T nmb){\n\tif(nmb>9)wt(nmb/10);\n\tputchar(nmb%10+'0');\n}\ntemplate<typename T> il void cmax(T &x,T y){x=x>y?x:y;}\ntemplate<typename T> il void cmin(T &x,T y){x=x<y?x:y;}\ninline void proc_status(){\n\tifstream t (\"/proc/self/status\");\n\tcerr<<string(istreambuf_iterator<char>(t),istreambuf_iterator<char>())<<endl;\n\t/*freopen(\"/proc/self/status\",\"r\",stdin);\n\tchar ch[100];\n\twhile(scanf(\"%s\",ch)!=EOF)cerr<<ch<<endl;*/\n}\n\nconst int N=2e5+10,L=20;\n\nint a[N];\n\nvector<pii>vec[L];\n\n#define lowbit(x) (x&(-x))\n\nint f[N<<1],g[N<<1];\n\nint ans[N],b[N];\n\nint main(){\n\tint n=rd<int>(),p=rd<int>();\n\tfor(int i=1;i<=n;++i)a[i]=rd<int>();\n\tint lev=1;\n\tint Flg=0;\n\tfor(int k=p;!Flg;k>>=1,++lev){\n\t\tif(!k)Flg=1;\n\t\tfor(int l=1,r=1;l<=n;l=r+1){\n\t\t\tr=l;\n\t\t\twhile(r<n&&a[r+1]-a[r]<=k)++r;\n\t\t\tvec[lev].pb(mp(l,r));\n\t\t}\n\t}\n\tlev-=2;\n\tint k=(1<<lev)-1;\n\tfor(int S=0;S<=k;++S)f[S]=0,g[S]=n+1;\n\tfor(int S=0;S<=k;++S){\n\t\tfor(int T=S;T;T^=lowbit(T)){\n\t\t\tint t=(int)log2(lowbit(T))+2;\n\t\t\tint U=S^lowbit(T);\n\t\t\tint pos=upper_bound(vec[t].begin(),vec[t].end(),mp(f[U]+1,n+1))-vec[t].begin()-1;\n\t\t\tif(pos>=0)cmax(f[S],vec[t][pos].snd);\n\t\t\tpos=upper_bound(vec[t].begin(),vec[t].end(),mp(g[U]-1,n+1))-vec[t].begin()-1;\n\t\t\tif(pos>=0&&vec[t][pos].snd>=g[U]-1)cmin(g[S],vec[t][pos].fst);\n\t\t}\n\t}\n\tfor(int S=0;S<=k;++S){\n\t\tint l=f[S],r=g[k^S];\n\t\tint pos1=upper_bound(vec[1].begin(),vec[1].end(),mp(l+1,n+1))-vec[1].begin()-1;\n\t\tint pos2=upper_bound(vec[1].begin(),vec[1].end(),mp(r-1,n+1))-vec[1].begin()-1;\n\t\tif(vec[1][pos2].snd<r-1)++pos2;\n\t\tif(pos1>=0&&pos2>=0&&pos1>pos2){\n\t\t\tfor(int i=1;i<=n;++i)puts(\"Possible\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(pos1>=0&&pos2>=0&&pos1==pos2)b[pos1]=1;\n\t}\n\tfor(int i=0;i<(int)vec[1].size();++i)\n\t\tfor(int t=vec[1][i].fst;t<=vec[1][i].snd;++t)\n\t\t\tans[t]=b[i];\n\tfor(int i=1;i<=n;++i)\n\t\tif(ans[i])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint n,V,x[200001],logv;vector<int> v;bool ans[200001];\nint cal(int x){int ans=0;while(x)x>>=1,++ans;return ans;}\nbool walk(vector<int> &v,int s)\n{\n\tint n=v.size();//printf(\"walk({\");for(int i=0;i<n;++i){printf(\"%d\",v[i]);if(i!=n-1)putchar(',');}printf(\"},%d)\\n\",s);\n\tif(n==1||!n)return true;\n\tint k=cal(s);bool flg=false;int st=0,cnt=1;\n\tfor(int i=1;i<n;++i)if(v[i]-v[i-1]>s)++cnt;if(cnt>k+1)return false;vector<int> tmp=v,tmpp;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tif(v[i]-v[i-1]>s)\n\t\t{\n\t\t\ttmpp.assign(tmp.begin()+st,tmp.begin()+i);tmp.erase(tmp.begin()+st,tmp.begin()+i);\n\t\t\tif(walk(tmp,s>>1))return true;tmp.insert(tmp.begin()+st,tmpp.begin(),tmpp.end());st=i;\n\t\t}\n\t}\n\ttmp.erase(tmp.begin()+st,tmp.end());if(walk(tmp,s>>1))return true;\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&V);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);for(int i=1;i<=n;++i)v.push_back(x[i]);\n\tint st=0,cnt=1,k=cal(V);\n\tfor(int i=1;i<n;++i)if(v[i]-v[i-1]>V)++cnt;if(cnt>k+1){for(int i=1;i<=n;++i)printf(\"Impossible\\n\");return 0;}\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tif(v[i]-v[i-1]>V)\n\t\t{\n\t\t\tvector<int> tmp=v;tmp.erase(tmp.begin()+st,tmp.begin()+i);\n\t\t\tif(walk(tmp,V>>1)){for(int j=st;j<i;++j)ans[j+1]=true;}st=i;\n\t\t}\n\t}\n\tvector<int> tmp=v;tmp.erase(tmp.begin()+st,tmp.end());if(walk(tmp,V>>1)){for(int j=st;j<n;++j)ans[j+1]=true;}\n\tfor(int i=1;i<=n;++i)printf(ans[i]?\"Possible\\n\":\"Impossible\\n\");return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define N 820000\nusing namespace std;\nint f[N][32],g[N][32];\nint tot,sum[N],n,v,a[N],b[N];\nint l[N],r[N];\nint check(int x,int y){\n\tx++;\n\tif(f[x][tot]<y-1)return 0;\n\ty=f[x][tot];\n\tx=g[y][tot];\n\tsum[x]++;\n\tsum[y+1]--;\n}\nint cal(){\n\tmemset(r,0x7f,sizeof(r));\n\tmemset(l,0,sizeof(l));\n\tr[0]=n;\n\tfor(int i=0;i<1<<tot;i++){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(i&(1<<(j-1)))continue;\n\t\t\tl[i|(1<<(j-1))]=max(l[i|(1<<(j-1))],f[l[i]+1][j]);\n\t\t\tr[i|(1<<(j-1))]=min(r[i|(1<<(j-1))],g[r[i]-1][j]);\t\n\t\t}\n\t}\n\tint o=(1<<(tot-1))-1;\n\tfor(int i=0;i<=o;i++){\n\t\tcheck(l[i],r[o^i]);\n\t}\n\tfor(int i=0;i<=n;i++)sum[i]+=sum[i-1];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\twhile(v)b[++tot]=v,v/=2;\n\tb[++tot]=v;\n\tsort(b+1,b+1+tot);\n\tfor(int i=1;i<=tot;i++)f[n][i]=n;\n\tfor(int i=n-1;i>=1;i--){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(a[i+1]-a[i]<=b[j])f[i][j]=f[i+1][j];\n\t\t\telse f[i][j]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot;i++)f[n+1][i]=n;\n\tfor(int i=1;i<=tot;i++)g[1][i]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=1;j<=tot;j++){\n\t\t\tif(a[i]-a[i-1]<=b[j])g[i][j]=g[i-1][j];\n\t\t\telse g[i][j]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=tot;i++)g[0][i]=1;\n\tcal();\n\tfor(int i=1;i<=n;i++){\n\t\tif(sum[i]>0)printf(\"Possible\\n\");\n\t\telse printf(\"Impossible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<stdlib.h>\n#include<string.h>\n#include<queue>\n#define LL long long\n#define NJ !((i>>(j-1))&1)\n#define SJ i^(1<<(j-1))\nusing namespace std;\ninline int read( )\n{\n  int sum=0;char c=getchar( );bool f=0;\n  while(c<'0'||c>'9') {if(c=='-') f=1;c=getchar( );}\n  while(c>='0'&&c<='9') {sum=sum*10+c-'0';c=getchar( );}\n  if(f) return -sum;\n  return sum;\n}\nconst int K=200005;\nconst int N=25;\nconst int M=(1<<19)+5;\nint n,V,X[K],s[N],f[M],g[M];\nint tot,L[K][N],R[K][N],FM[K];\ninline void MX(int &x,int y) {if(y>x) x=y;}\ninline void MN(int &x,int y) {if(y<x) x=y;}\nint main( )\n{\n  int i,j,x,y,t;\n  n=read( );V=read( );\n  for(i=1;i<=n;i++) X[i]=read( );\n  for(j=V;;j>>=1)\n    {\n      s[++tot]=j;\n      for(i=1,t=1;i<=n;i++)\n\t{\n\t  t=max(t,i);\n\t  while(t<n&&X[t+1]-X[t]<=j) t++;\n\t  L[i][tot]=t;\n\t}\n      L[n+1][tot]=n;\n      for(i=n,t=n;i>=1;i--)\n\t{\n\t  t=min(t,i);\n\t  while(t>1&&X[t]-X[t-1]<=j) t--;\n\t  R[i][tot]=t;\n\t}\n      R[0][tot]=1;\n      if(!j) break;\n    }\n  int S=1<<tot;\n  for(i=0;i<S;i++) g[i]=n+1;\n  for(i=0;i<S;i++)\n    for(x=f[i],y=g[i],j=1;j<=tot;j++)\n      if(NJ) MX(f[SJ],L[x+1][j]),MN(g[SJ],R[y-1][j]);\n  int ALL=S-2,MF=-n;\n  for(i=0;i<S;i++) FM[i]=-n;\n  for(j=1,i=0;i<=ALL;i++) \n    if(NJ) x=(!g[i])?0:((g[i]==n+1)?n+1:g[i]),MX(FM[x],f[ALL-i]);\n  for(t=0,i=1;i<=n;i++)\n    {\n      while(t<=n+1&&L[i][1]+1>=t) MX(MF,FM[t]),t++; \n      puts(R[i][1]<=MF+1?\"Possible\":\"Impossible\");\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nint a[211111];\nvector<ii> interval[19];\nint pre[(1<<19)+11];\nint suf[(1<<19)+11];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,v; cin>>n>>v;\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tint cur=v;\n\tint id=0;\n\twhile(cur)\n\t{\n\t\tint curl=0;\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tif(a[i]-a[i-1]>cur)\n\t\t\t{\n\t\t\t\tinterval[id].pb(mp(curl,i-1));\n\t\t\t\tcurl=i;\n\t\t\t}\n\t\t}\n\t\tinterval[id].pb(mp(curl,n-1));\n\t\tcur>>=1; id++;\n\t}\n\tfor(int i=0;i<n;i++) interval[id].pb(mp(i,i));\n\tid++;\n\tpre[0] = -1; suf[0]=n;\n\tfor(int i=1;i<(1<<id);i++)\n\t{\n\t\tpre[i]=-1; suf[i]=n;\n\t\tfor(int j=0;j<id;j++)\n\t\t{\n\t\t\tif(i&(1<<j))\n\t\t\t{\n\t\t\t\tint mx = pre[i^(1<<j)];\n\t\t\t\tint tmp=upper_bound(interval[j].begin(),interval[j].end(),mp(mx+2,-1))-interval[j].begin();\n\t\t\t\ttmp--;\n\t\t\t\tif(tmp>=0&&tmp<interval[j].size())\n\t\t\t\t{\n\t\t\t\t\tint r=interval[j][tmp].se;\n\t\t\t\t\tpre[i]=max(pre[i],r);\n\t\t\t\t}\n\t\t\t\tint mn = suf[i^(1<<j)];\n\t\t\t\ttmp=lower_bound(interval[j].begin(),interval[j].end(),mp(mn,-1))-interval[j].begin();\n\t\t\t\ttmp--;\n\t\t\t\tif(tmp>=0&&tmp<interval[j].size())\n\t\t\t\t{\n\t\t\t\t\tint l=interval[j][tmp].fi; \n\t\t\t\t\tsuf[i]=min(suf[i],l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(interval[0].size()>20)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcout<<\"Impossible\\n\";\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<interval[0].size();i++)\n\t{\n\t\tint l=interval[0][i].fi; int r=interval[0][i].se;\n\t\tbool pos=0;\n\t\tfor(int j=0;j<(1<<id);j+=2)\n\t\t{\n\t\t\tint tot=(1<<id)-1; tot^=1;\n\t\t\tif(pre[j]>=l-1&&suf[tot^j]<=r+1)\n\t\t\t{\n\t\t\t\tfor(int k=l;k<=r;k++) cout<<\"Possible\\n\";\n\t\t\t\tpos=1; break;\n\t\t\t}\n\t\t}\n\t\tif(!pos)\n\t\t{\n\t\t\tfor(int k=l;k<=r;k++) cout<<\"Impossible\\n\";\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){\nfor(;!IS(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf(){llf x;TR}\nI Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)x=-x;\\\nwhile(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}\nI Fw&OP()(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\nint n,m,s[N],id[20][N],idc;\n\ninline void build(int*v,int x)\n{\n\tfo1(i,n)\n\t{\n\t\tif(s[i]-s[i-1]>x)v[i]=++idc;\n\t\telse v[i]=v[i-1];\n\t}\n}\n\nstd::list<int>son[N*20];\n\nint g[30][30],tmp[30][30];\n\nstruct hh\n{\n\tinline size_t operator()(uint x)const\n\t{\n\t\treturn x;//%19260817;\n\t}\n};\n\nstd::unordered_map<uint,bool,hh>hs;\n\nbool solve(int dep,int cnt)\n{\n\tint*s=g[dep],uc=0;\n\tuint hash=dep;\n\tfo0(i,cnt)hash=hash*2337+s[i];\n\tif(hs.count(hash))return hs[hash];\n\t//out,\"solve:\",dep,' ',cnt,'[';\n\t//fo0(i,cnt)printf(\"%d%c\",s[i],i+1==cnt?']':' ');out,'\\n';\n\tfo0(i,cnt)uc+=son[s[i]].size();\n\tif(dep==2)return uc<=1;\n\tif(uc>=dep)return 0;\n\tif(!uc)return 1;\n\tint*r=g[dep-1],*t=tmp[dep];\n\tuc=0;\n\tfo0(i,cnt)foe(j,son[s[i]])\n\t\tt[uc++]=*j;\n\tfo0(i,uc-1)r[i]=t[i+1];\n\tfo0(i,uc)\n\t{\n\t\tif(solve(dep-1,uc-1))return hs[hash]=1;\n\t\tr[i]=t[i];\n\t}\n\treturn hs[hash]=0;\n}\n\nint main()\n{\n\tin,n,m;\n\ts[0]=-2e9;\n\tfo1(i,n)in,s[i];\n\tint cnt=0;\n\tfor(int j=m;;j>>=1)\n\t{\n\t\tbuild(id[cnt++],j);\n\t\tif(!j)break;\n\t}\n\tfor(int i=cnt-1;i;i--)\n\t{\n\t\tfo1(j,n)\n\t\t{\n\t\t\tif(id[i][j]!=id[i][j-1])\n\t\t\t{\n\t\t\t\tson[id[i-1][j]].pb(id[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root=++idc;\n\tfo1(j,n)if(id[0][j]!=id[0][j-1])\n\t\tson[root].pb(id[0][j]);\n\tif(son[root].size()>cnt)\n\t{\n\t\tfo1(i,n)out,\"Impossible\\n\";\n\t\treturn 0;\n\t}\n\t//fo0(i,cnt){fo1(j,n)printf(\"%3d\",id[i][j]);out,'\\n';}\n\tbool ans;\n\tfo1(i,n)\n\t{\n\t\tif(id[0][i]!=id[0][i-1])\n\t\t{\n\t\t\tint u=0;\n\t\t\tfoe(j,son[root])if(*j!=id[0][i])\n\t\t\t\tg[cnt][u++]=*j;\n\t\t\tans=solve(cnt,u);\n\t\t}\n\t\tputs(ans?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 200010\n#define INF 0x3FFFFFFF\nusing namespace std;\nint n,v,logv;\nint x[MAXN];\nint f1[MAXN],f2[MAXN];\nint l[22][MAXN],r[22][MAXN],cnt[22];\nint find_l(int x,int pos){\n\tpos++;\n\tint now=upper_bound(l[x]+1,l[x]+1+cnt[x],pos)-l[x];\n\tnow--;\n\tif(now<=0)\n\t\treturn pos;\n\treturn max(r[x][now],pos-1);\t\n}\nint find_r(int x,int pos){\n\tpos--;\n\tint now=lower_bound(r[x]+1,r[x]+1+cnt[x],pos)-r[x];\n\tif(now>cnt[x])\n\t\treturn pos;\n\treturn min(l[x][now],pos+1);\t\n}\nint ans[MAXN];\nint main(){\n\tmemset(f2,0x3f3f3f3f,sizeof f2);\n\tSF(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++)\n\t\tSF(\"%d\",&x[i]);\t\n\tx[0]=-INF;\n\tx[n+1]=INF;\n\tfor(logv=0;(1<<logv)<=v;logv++);\n\tlogv++;\n\tfor(int i=0;i<logv;i++){\n\t\tint v1=v>>i;\n\t\tcnt[i]=1;\n\t\tl[i][cnt[i]]=1;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(x[j+1]-x[j]>v1){\n\t\t\t\tr[i][cnt[i]]=j;\n\t\t\t\tcnt[i]++;\n\t\t\t\tl[i][cnt[i]]=j+1;\t\n\t\t\t}\n\t\tcnt[i]--;\n\t}\n\tif(cnt[0]>logv){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tPF(\"Impossible\\n\");\n\t\treturn 0;\t\n\t}\n\tf1[0]=0;\n\tf2[0]=n+1;\n\tfor(int mask=0;mask<(1<<logv);mask+=2)\n\t\tfor(int i=1;i<logv;i++)\n\t\t\tif((mask&(1<<i))!=0){\n\t\t\t\tf1[mask]=max(f1[mask],find_l(i,f1[mask^(1<<i)]));\n\t\t\t\tf2[mask]=min(f2[mask],find_r(i,f2[mask^(1<<i)]));\t\n\t\t\t}\n\tfor(int i=1;i<=cnt[0];i++){\n\t\tint lft=l[0][i];\n\t\tint rit=r[0][i];\n\t\tfor(int mask=0;mask<(1<<logv);mask+=2){\n\t\t\tint mask2=((1<<logv)-2)^mask;\n\t\t\tif(f1[mask]>=lft-1&&f2[mask2]<=rit+1){\n\t\t\t\tans[i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint las=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i>r[0][las])\n\t\t\tlas++;\n\t\tif(ans[las]==0)\n\t\t\tPF(\"Impossible\\n\");\n\t\telse\n\t\t\tPF(\"Possible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 200010;\n\nint N, V;\nint X[MN], prec1[17][MN], prec2[17][MN];\nvector<int> P;\n\nint cc1[1 << 17];\nint dp1(int mask) {\n    int &ret = cc1[mask];\n    if(ret != -1) return ret;\n\n    ret = 0;\n    for(int i = 0; i < 17; i++) {\n        if(mask & (1 << i)) {\n            int t = dp1(mask ^ (1 << i));\n            if(t == N) return ret = N;\n            ret = max(ret, t + prec1[i][t]);\n        }\n    }\n    return ret;\n}\n\nint cc2[1 << 17];\nint dp2(int mask) {\n    int &ret = cc2[mask];\n    if(ret != -1) return ret;\n\n    ret = 0;\n    for(int i = 0; i < 17; i++) {\n        if(mask & (1 << i)) {\n            int t = dp2(mask ^ (1 << i));\n            if(t == N) return ret = N;\n            ret = max(ret, t + prec2[i][N - 1 - t]);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &V);\n    while(1) {\n        P.push_back(V);\n        if(!V) break;\n        V /= 2;\n    }\n    reverse(P.begin(), P.end());\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    for(int i = 0; i < P.size(); i++) {\n        for(int j = N - 1; j >= 0; j--) {\n            prec1[i][j] = 1;\n            if(j != N - 1 && X[j + 1] - X[j] <= P[i]) prec1[i][j] += prec1[i][j + 1];\n        }\n        for(int j = 0; j < N; j++) {\n            prec2[i][j] = 1;\n            if(j && X[j] - X[j - 1] <= P[i]) prec2[i][j] += prec2[i][j - 1];\n        }\n    }\n\n    memset(cc1, -1, sizeof(cc1));\n    memset(cc2, -1, sizeof(cc2));\n    int b = P.size();\n\n    if(dp1((1 << b) - 1) < N) {\n        for(int i = 0; i < N; i++) {\n            printf(\"Impossible\\n\");\n        }\n        return 0;\n    }\n\n    int pos = 0;\n    while(pos < N) {\n        int nxt = pos + prec1[b - 1][pos];\n\n        bool ok = false;\n        for(int mask = 0; mask < (1 << (b - 1)); mask++) {\n            if(dp1(mask) >= pos && dp2(((1 << (b - 1)) - 1) ^ mask) >= N - nxt) {\n                ok = true;\n                break;\n            }\n        }\n\n        //cout << pos << ' ' << nxt << endl;\n\n        for(int i = pos; i < nxt; i++) {\n            if(ok) printf(\"Possible\\n\");\n            else printf(\"Impossible\\n\");\n        }\n        pos = nxt;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nvector<int> f(int N, int M, vector<int> dx) {\n\tvector<vector<int> > nxt(N + 1, vector<int>(M));\n\trep(j, M) nxt[N][j] = nxt[N - 1][j] = N;\n\tfor (int i = N - 2; i >= 0; i--) {\n\t\tnxt[i] = nxt[i + 1];\n\t\tfor (int j = dx[i]; j < M; j++) nxt[i][j] = i + 1;\n\t}\n\tvector<int> dp(1<<M);\n\trep(S, 1<<M)\n\t\trep(j, M) if (!(S>>j & 1)) {\n\t\t\tint _S = S | 1<<j;\n\t\t\tdp[_S] = max(dp[_S], nxt[dp[S]][j]);\n\t\t}\n\treturn dp;\n}\n\nvector<int> solve() {\n\tint N, V; cin >> N >> V;\n\tvector<int> x(N);\n\trep(i, N) scanf(\"%d\", &x[i]);\n\tvector<int> dx(N - 1);\n\trep(i, N - 1) dx[i] = x[i + 1] - x[i];\n\t/*\n\tbool ok = true;\n\trep(i, N - 1) if (dx[i] > V) ok = false;\n\tif (ok) return vector<int>(N, true);\n\t*/\n\tvector<int> v;\n\tfor (int _V = V; _V; _V /= 2) v.pb(_V);\n\tv.pb(0);\n\tint M = v.size();\n\trep(i, N - 1) {\n\t\tint k;\n\t\tfor (k = 0; dx[i] <= v[k]; k++);\n\t\tdx[i] = k;\n\t}\n\tunion_find uf(N);\n\trep(i, N - 1) if (dx[i]) uf.unite(i, i + 1);\n\tvector<int> dp1 = f(N, M, dx);\n\treverse(dx.begin(), dx.end());\n\tvector<int> dp2 = f(N, M, dx);\n\tvector<bool> ok(N);\n\trep(S, 1<<(M - 1)) {\n\t\tint S1 = S<<1, S2 = (((1<<(M - 1)) - 1) - S)<<1;\n\t\tint i = min(dp1[S1], N - 1), j = max(0, N - 1 - dp2[S2]);\n\t\tif (uf.same(i, j)) ok[uf.find(i)] = true;\n\t}\n\tvector<int> ans(N);\n\trep(i, N) ans[i] = ok[uf.find(i)];\n\treturn ans;\n}\n\nint main() {\n\tvector<int> ans = solve();\n\tfor (int z: ans) if (z) printf(\"Possible\\n\"); else printf(\"Impossible\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define fir first\n#define sec second\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int maxN = 2e5 + 2;\n\ninline bool Chkmax(int& x, int y)\n{ return x < y ? x = y, true : false; }\n\ninline bool Chkmin(int& x, int y)\n{ return x > y ? x = y, true : false; }\n\nint n, v, cnt;\nint SUC[maxN], ans[maxN];\nint x[maxN], f[maxN << 1], g[maxN << 1];\nvector<pii> line[20];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n    cin >> n >> v;\n    for (int i = 1; i <= n; ++i)\n        cin >> x[i];\n    do\n    {\n        int l = 1, r = 1; // attenion that l = 0\n        for (int j = 2; j <= n; ++j)\n        {\n            if (x[j] - (v >> cnt) > x[r])\n            {\n                line[cnt].emplace_back(l, r);\n                l = j;\n            }\n            r = j;\n        }\n        line[cnt].emplace_back(l, r);\n    } while (v >> cnt++);\n    // cout << cnt << endl;\n    --cnt;\n//    for (int i = 0; i < cnt; ++i)\n//        for (auto j : line[i])\n//            cout << j.fir << ' ' << j.sec << endl;\n    fill(f, f + (1 << cnt), -1);\n    fill(g, g + (1 << cnt), n + 2);\n    f[0] = 0, g[0] = n + 1;\n    for (int i = 0; i < cnt; ++i)\n        f[1 << i] = line[i + 1].begin()->sec, g[1 << i] = line[i + 1].rbegin()->fir;\n    for (int i = 1; i < 1 << cnt; ++i) if (~f[i])\n        for (int j = 1; j <= cnt; ++j)\n            if (!(i >> (j - 1) & 1))\n            {\n                auto pos = lower_bound(line[j].begin(), line[j].end(), pii(f[i] + 2, 0)) - 1;\n                Chkmax(f[i | 1 << (j - 1)], pos->sec);\n            }\n    for (int i = 1; i < 1 << cnt; ++i) if (g[i] != n + 1)\n        for (int j = 1; j <= cnt; ++j)\n            if (!(i >> (j - 1) & 1))\n            {\n                auto pos = lower_bound(line[j].begin(), line[j].end(), pii(g[i], 0));\n                if (pos != line[j].begin())\n                    Chkmin(g[i | 1 << (j - 1)], --pos->fir);\n            }\n    fill(SUC, SUC + n + 1, n + 2);\n    for (int i = 0, all = (1 << cnt) - 1; i <= all; ++i)\n        if (~f[i])\n            Chkmin(SUC[f[i]], g[all ^ i]);\n    for (int i = n; i; --i)\n        Chkmin(SUC[i - 1], SUC[i]);\n    //for (int i = 0; i <= n; ++i)\n    //    cout << SUC[i] << ' ';\n    //cout << endl;\n    for (auto i : line[0])\n    {\n        // cout << i.fir << ' ' << i.sec << endl;\n        int flag = SUC[i.fir - 1] <= i.sec + 1;\n        for (int j = i.fir; j <= i.sec; ++j)\n            cout << (flag ? \"Possible\" : \"Impossible\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=2e5+5;\nint n,m;\nint V,x[maxn],R[maxn][25],L[maxn][25];\nint S1[maxn],S2[maxn];\nint minL[maxn];\nint main(){\n\tread(n);read(V);\n\trep(i,1,n)read(x[i]);\n\twhile((1<<m)<=V)m++;m++;\n\trep2(i,0,m){\n\t\tR[n+1][i]=n;\n\t\tR[n][i]=n;\n\t\tper(j,n-1,1)\n\t\t\tif(x[j+1]-x[j]<=(V>>i))R[j][i]=R[j+1][i];\n\t\t\telse R[j][i]=j;\n\t\tL[0][i]=1;\n\t\tL[1][i]=1;\n\t\trep(j,2,n)\n\t\t\tif(x[j]-x[j-1]<=(V>>i))L[j][i]=L[j-1][i];\n\t\t\telse L[j][i]=j;\n\t}\n\trep2(i,0,1<<m)S2[i]=n+1;\n\trep2(i,1,1<<m){\n\t\trep2(j,0,m)if(i>>j&1){\n\t\t\tint last=S1[i^(1<<j)];\n\t\t\tS1[i]=max(S1[i],R[last+1][j]);\n\t\t}\n\t\trep2(j,0,m)if(i>>j&1){\n\t\t\tint last=S2[i^(1<<j)];\n\t\t\tS2[i]=min(S2[i],L[last-1][j]);\n\t\t}\n\t}\n\trep(i,0,n)minL[i]=n+2;\n\trep2(i,0,1<<m){\n\t\tif(i>>0&1)continue;\n\t\tint R=S1[i],L=S2[((1<<m)-1)^i^(1<<0)];\n\t\tminL[R]=min(minL[R],L);\n\t}\n\tper(i,n-1,0)minL[i]=min(minL[i],minL[i+1]);\n\trep(i,1,n){\n\t\tint rL=L[i][0],rR=R[i][0];\n\t\tif(minL[rL-1]<=rR+1)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\n\nint kano()\n{\n\tchar ch=getchar();int w=0,u=1;\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')u=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())w=w*10+ch-'0';\n\treturn w*u;\n}\nint n,v,o,u,mx;\nint a[200005];\nint p[21][200005],r[21][200005];\nint f[2][262145];\nbool bo[200005];\nint main()\n{\n\tn=kano();v=kano();\n\tfor(int i=1;i<=n;i++)a[i]=kano();\n\tfor(o=v,u=0;o>0;o=o>>1,u++)\n\t{\n\t\tint la=1;p[u][1]=1;r[u][1]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]-a[i-1]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tmx=1<<u;mx--; \n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tf[0][i|j]=max(f[0][i|j],p[l][r[l][f[0][i]+1]]);\n\t\t}\n\t}\n\tfor(o=v>>1,u=1;o>0;o=o>>1,u++)\n\t{\n\t\tint la=n;p[u][n]=n;r[u][n]=n;\n\t\tfor(int i=n-1;i>=1;i--)\n\t\t{\n\t\t\tif(a[i+1]-a[i]<=o)\n\t\t\t{\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tla=i;\n\t\t\t\tp[u][la]=i;\n\t\t\t\tr[u][i]=la;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)p[u][i]=r[u][i]=i;\n\tfor(int i=0;i<=mx;i++)f[1][i]=n+1;\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tfor(int j=1,l=1;j<=mx;j=j<<1,l++)\n\t\t{\n\t\t\tif(i&j)continue;\n\t\t\tf[1][i|j]=min(f[1][i|j],p[l][r[l][f[1][i]-1]]);\n\t\t}\n\t}\n\tfor(int i=0;i<=mx;i++)\n\t{\n\t\tint j=~i&mx;\n\t\tif(r[0][f[0][i]+1]==r[0][f[1][j]-1])bo[r[0][f[0][i]+1]]=1;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(bo[r[0][i]])puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memset( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\nconst int MAXN = 200020;\nconst int INF = 0x3f3f3f3f;\n\nint n, m, v[20], tot, a[MAXN], d[MAXN];\nint f[MAXN][20], g[MAXN][20];\nint dpl[MAXN << 2], dpr[MAXN << 2], ans[MAXN];\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tscanf( \"%d%d\", &n, &m );\n\tfor( int i = 1 ; i <= n ; i++ ) scanf( \"%d\", &a[ i ] );\n\twhile( m ) v[ tot++ ] = m, m >>= 1;\n\tv[ tot++ ] = 0;\n\td[ 1 ] = d[ n + 1 ] = INF;\n\tfor( int i = 2 ; i <= n ; i++ ) d[ i ] = a[ i ] - a[ i - 1 ];\n\tfor( int j = 0 ; j < tot ; j++ )\n\t{\n\t\tfor( int i = 1 ; i <= n ; i++ )\n\t\t\tif( d[ i ] > v[ j ] ) f[ i ][ j ] = i;\n\t\t\telse f[ i ][ j ] = f[ i - 1 ][ j ];\n\t\tfor( int i = n ; i ; i-- )\n\t\t\tif( d[ i + 1 ] > v[ j ] ) g[ i ][ j ] = i;\n\t\t\telse g[ i ][ j ] = g[ i + 1 ][ j ];\n\t}\n\tfill( dpr, 0x3f );\n\tdpr[ 0 ] = n + 1;\n\tfor( int i = 0 ; i < ( 1 << tot ) ; i++ )\n\t\tfor( int j = 0 ; j < tot ; j++ ) if( !( i >> j & 1 ) )\n\t\t{\n\t\t\tif( dpl[ i ] >= n ) dpl[ i | ( 1 << j ) ] = n;\n\t\t\telse dpl[ i | ( 1 << j ) ] = max( dpl[ i | ( 1 << j ) ], g[ dpl[ i ] + 1 ][ j ] );\n\t\t\tif( dpr[ i ] <= 1 ) dpr[ i | ( 1 << j ) ] = 1;\n\t\t\telse dpr[ i | ( 1 << j ) ] = min( dpr[ i | ( 1 << j ) ], f[ dpr[ i ] - 1 ][ j ] );\n\t\t}\n\tfor( int i = 0 ; i < ( 1 << tot ) ; i++ )\n\t{\n\t\tif( i & 1 ) continue;\n\t\tint l = dpl[ i ], r = dpr[ ( 1 << tot ) - 1 - i - 1 ];\n\t\tif( l >= r ) ans[ 1 ]++;\n\t\telse\n\t\t{\n\t\t\tint L = f[ l + 1 ][ 0 ], R = g[ l + 1 ][ 0 ];\n\t\t\tif( R + 1 >= r ) ans[ L ]++, ans[ R + 1 ]--;\n\t\t}\n\t}\n\tfor( int i = 1, cur = 0 ; i <= n ; i++ )\n\t{\n\t\tcur += ans[ i ];\n\t\tif( cur ) puts( \"Possible\" );\n\t\telse puts( \"Impossible\" );\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define mid (l+r>>1)\ntypedef long long ll;\ntemplate<typename T>inline T read(){\n\tT x=0,f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';f=c=='-'?-1:1,c=getchar());\n\tfor(;c>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0',c=getchar());\n\treturn x*f;\n}\nconst int maxs=1<<19,maxn=2e5+5;\nint n,v,lg,s,lt[maxs],rt[maxs],a[20][maxn],cnt[20];\nll x[maxn];\nint S(int opt,int k,int x){\n\tint l=1,r=cnt[k];\n\twhile(r-l>1)\n\t\tif(a[k][mid]<x||(opt&&a[k][mid]==x))l=mid+opt;\n\t\telse r=mid-1+opt;\n\tint r1=opt?l:r,r2=opt?r:l,f=opt?1:-1;\n\tif(a[k][r1]*f>x*f)return a[k][r1]+1-opt;\n\treturn a[k][r2]+1-opt;\n}\nint main(){\n\tn=read<int>();v=read<int>();\n\tlg=ceil(log2(v))+1+(ceil(log2(v))==log2(v));s=(1<<lg)-1;\n\tfor(int i=1;i<=n;i++)x[i]=read<ll>(),x[i-1]=x[i]-x[i-1];x[n]=0;\n\tfor(int i=1;i<=lg;i++){\n\t\tcnt[i]=1;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ta[i][cnt[i]]=j,cnt[i]+=(x[j]>v>>(i-1));\n\t}\n\tif(cnt[1]>lg){for(int i=0;i<n;i++)puts(\"Impossible\");return 0;}\n\tmemset(rt,0,sizeof(rt));\n\tfor(int i=0;i<=s;i++)lt[i]=n+1;\n\tfor(int i=0;i<=s;i+=2)\n\t\tfor(int j=2;j<=lg;j++){\n\t\t\tint s0=1<<j-1;\n\t\t\tif(i&s0)continue;\n\t\t\trt[i|s0]=std::max(rt[i|s0],S(1,j,rt[i]));\n\t\t\tlt[i|s0]=std::min(lt[i|s0],S(0,j,lt[i]-1));\n\t\t}\n\tfor(int i=1;i<=cnt[1];i++){\n\t\tint f=0,b=a[1][i-1]+1,e=a[1][i];\n\t\tif(i==1)b=1;\n\t\tfor(int s0=0;s0<=s&&(!f);s0+=2)f=(b<=rt[s0]+1&&e>=lt[s-s0-1]-1);\n\t\tfor(int j=b;j<=e;j++)puts(f?\"Possible\":\"Impossible\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define ll      long long\n\nint x[202020];\nint l[202020][20], r[202020][20];\nint dpl[1 << 20], dpr[1 << 20];\n\nvoid solve() {\n        int n, v;\n        cin >> n >> v;\n        for (int i = 0; i < n; i ++) cin >> x[i];\n        int p;\n        for (int i = 0; ; i ++) if ((1 << i) > v) {\n                p = i + 1;\n                break;\n        }\n        for (int i = 0; i < n; i ++) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == 0 || x[i] - x[i - 1] > vv) l[i][j] = i;\n                        else l[i][j] = l[i - 1][j];\n                        vv /= 2;\n                }    \n        }\n        for (int i = n - 1; i >= 0; i --) {\n                int vv = v;\n                for (int j = 0; j < p; j ++) {\n                        if (i == n - 1 || x[i + 1] - x[i] > vv) r[i][j] = i;\n                        else r[i][j] = r[i + 1][j];\n                        vv /= 2;\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpr[i] == n) dpr[i | (1 << j)] = n;\n                        else dpr[i | (1 << j)] = max(dpr[i | (1 << j)], r[dpr[i]][j] + 1);\n                }\n        }\n        for (int i = 0; i < (1 << p); i ++) dpl[i] = n - 1;\n        for (int i = 0; i < (1 << p); i ++) {\n                if (i & 1) continue;\n                for (int j = 1; j < p; j ++) {\n                        if ((i >> j) & 1) continue;\n                        if (dpl[i] == -1) dpl[i | (1 << j)] = -1;\n                        else dpl[i | (1 << j)] = min(dpl[i | (1 << j)], l[dpl[i]][j] - 1);\n                }\n        }\n        bool ok = false;\n        for (int i = 0; i < n; i ++) {\n                if (l[i][0] == i) {\n                        int c = 0;\n                        for (int j = 0; j < (1 << p); j ++) {\n                                c ++;\n                                if (j & 1) continue;\n                                if (i > 0 && dpr[j] < i) continue;\n                                if (r[i][0] < n - 1 && dpl[(1 << p) - 2 - j] > r[i][0]) continue;\n                                break;\n                        }\n                        if (c < (1 << p)) ok = true;\n                        else ok = false;\n                }\n                if (ok) cout << \"Possible\" << endl;\n                else cout << \"Impossible\" << endl;\n        }\n        return;\n}\n\nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        solve();\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (1050000)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,m,p[N],cnt,ri[N],le[N];\nvector<int> seg[22];\nvoid spj(){\n\tif(seg[cnt].size()<=cnt+2)return;\n\tfor(int i=1;i<=n;i++)puts(\"Impossible\");exit(0);\n}\nint main(){\n\tread(n),read(m);\n\tfor(int i=1;i<=n;i++)read(p[i]); p[n+1]=inf,p[0]=-inf;\n\tfor(cnt=0;(m>>cnt)>0;cnt++);\n\tfor(int i=0;i<=cnt;i++)\n\tfor(int j=0;j<=n;j++)\n\tif(p[j+1]-p[j]>(m>>i))seg[cnt-i].push_back(j);\n//\tcout<<cnt+1<<endl;\n//\tfor(int i=0;i<=cnt;i++){\n//\t\tprintf(\"#%d(%d):\",i,m>>(cnt-i));\n//\t\tfor(int j=0;j<seg[i].size();j++)printf(\"%d \",seg[i][j]); puts(\"\");\n//\t}\n\tspj();\n\tfor(int i=0;i<(1<<cnt);i++)le[i]=n+1,ri[i]=0;\n\tfor(int i=0;i<(1<<cnt);i++)\n\tfor(int j=0;j<cnt;j++)\n\tif(!(i&(1<<j))){\n\t\tint v=i|(1<<j);\n\t\tri[v]=max(ri[v],*(upper_bound(seg[j].begin(),seg[j].end(),ri[i])));\n\t\tle[v]=min(le[v],*(lower_bound(seg[j].begin(),seg[j].end(),le[i]-1)-1)+1);\n\t}\n//\tfor(int i=0;i<(1<<cnt);i++)\n//\tprintf(\"%d %d %d\\n\",i,le[i],ri[i]);\n\tfor(int i=0;i<seg[cnt].size()-1;i++){\n\t\tbool fl=0;\n\t\tfor(int j=0;j<(1<<cnt);j++)\n\t\tif(ri[j]>=seg[cnt][i]&&le[((1<<cnt)-1)^j]<=seg[cnt][i+1]+1){fl=1;break;}\n\t\tfor(int tt=seg[cnt][i]+1;tt<=seg[cnt][i+1];tt++)\n\t\tif(!fl)puts(\"Impossible\");else puts(\"Possible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "main(){}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <algorithm>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n\nusing namespace std;\n\nconst int N = 400010;\n\nint n, p, V, X[N];\nint tor[N][20], tol[N][20];\nint dpl[N], dpr[N], cnt[N];\n\nint main(){\n\tscanf(\"%d%d\", &n, &V);\n\tFor(i, 1, n) scanf(\"%d\", &X[i]);\n\tX[0] = -2e9, X[n + 1] = 2e9;\n\tFor(i, 0, 19){\n\t\tint l = 1;\n\t\tFor(j, 1, n) \n\t\t\tif(1ll * X[j + 1] - X[j] > V){\n\t\t\t\tFor(k, l, j) tol[k][i] = l, tor[k][i] = j;\n\t\t\t\tl = j + 1;\n\t\t\t}\n\t\ttor[n + 1][i] = tor[0][i] = n + 1;\n\t\ttol[0][i] = tor[n + 1][i] = 0;\n\t\tif(!V){\n\t\t\tp = i;\n\t\t\tbreak;\n\t\t}\n\t\tV >>= 1;\n\t}\n\tint S = (1 << p) - 1;\n\tdpl[0] = 0;\n\tFor(i, 1, S){\n\t\tdpl[i] = 0;\n\t\tFor(j, 1, p) if(i & (1 << (j - 1))) dpl[i] = max(dpl[i], tor[dpl[i ^ (1 << (j - 1))] + 1][j]);\n\t}\n\tdpr[0] = n + 1;\n\tFor(i, 1, S){\n\t\tdpr[i] = n + 1;\n\t\tFor(j, 1, p) if(i & (1 << (j - 1))) dpr[i] = min(dpr[i], tol[dpr[i ^ (1 << (j - 1))] - 1][j]);\n\t}\n\tFor(i, 0, S){\n\t\tint L = dpl[i] + 1, R = dpr[S ^ i] - 1;\n\t\tif(tor[L][0] >= R) cnt[tol[L][0]]++, cnt[tor[R][0] + 1]--;\n\t}\n\tFor(i, 1, n){\n\t\tcnt[i] += cnt[i - 1];\n\t\tif(cnt[i]) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=200200,D=18;\nint i,j,k,n,m,nm,mm,ch,ff;\nint x[N],pre[1<<D],suf[1<<D],ans[N];\nvector<int> X[D];\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nint find1(int i,int x) {\n\tint l=0,r=X[i].size()-1,mid;\n\twhile (l<r) {\n\t\tmid=(l+r+1)>>1;\n\t\tif (X[i][mid]>x) r=mid-1;\n\t\telse l=mid;\n\t}\n\treturn l;\n}\nint find2(int i,int x) {\n\tint l=0,r=X[i].size()-1,mid;\n\twhile (l<r) {\n\t\tmid=(l+r-1)>>1;\n\t\tif (X[i][mid]<x) l=mid+1;\n\t\telse r=mid;\n\t}\n\treturn l;\n}\nvoid Max(int &x,int y) {\n\tif (y>x) x=y;\n}\nvoid Min(int &x,int y) {\n\tif (y<x) x=y;\n}\nint main() {\n\tR(n);R(m);\n\tfor (i=1;i<=n;i++) R(x[i]);\n\tk=m;\n\twhile (1) {\n\t\tX[nm].push_back(1);\n\t\tfor (i=1;i<n;i++) if (x[i]+k<x[i+1]) X[nm].push_back(i+1);\n\t\tX[nm].push_back(n+1);\n\t\tnm++;\n\t\tif (!k) break;\n\t\tk>>=1;\n\t}\n\tmm=1<<nm;\n\tfor (i=0;i<mm;i++) suf[i]=n+1;\n\tfor (i=0;i<mm;i+=2)\n\t\tfor (j=1;j<nm;j++) if (!(i&1<<j)) {\n\t\t\tMax(pre[i|1<<j],X[j][find1(j,pre[i]+1)+1]-1);\n\t\t\tMin(suf[i|1<<j],X[j][find2(j,suf[i])-1]);\n\t\t}\n\tif (X[0].size()>mm+1) {\n\t\tfor (i=0;i<n;i++) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor (i=1;i<X[0].size();i++) {\n\t\tint l=X[0][i-1],r=X[0][i]-1,fg=0;\n\t\tfor (j=0;j<mm;j+=2) if (pre[j]+1>=l && suf[(mm-2)^j]-1<=r) {\n\t\t\tfg=1;\n\t\t\tbreak;\n\t\t}\n\t\tfor (j=l;j<=r;j++) ans[j]=fg;\n\t}\n\tfor (i=1;i<=n;i++) {\n\t\tif (ans[i]) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nconst int N=270000,LOG=20;\nint x[N],v[N],L[LOG][N],R[LOG][N],val[N],Lf[N],Rf[N],n,k,tot;\nint main(){\n    read(n);\n    read(v[0]);\n    while(v[k]) v[k+1]=v[k]>>1,k++;\n    tot=(1<<k)-1;\n    for(int i=1;i<=n;i++)\n        read(x[i]);\n    for(int i=0;i<k;i++){\n        L[i][1]=1;\n        for(int j=2;j<=n;j++) \n            if(x[j]-x[j-1]<=v[i]) \n                L[i][j]=L[i][j-1];\n            else L[i][j]=j;\n        R[i][n]=n;\n        for(int j=n-1;j>=0;j--) \n            if(x[j+1]-x[j]<=v[i]) \n                R[i][j]=R[i][j+1];\n            else R[i][j]=j;\n    }\n    for(int i=1;i<=tot;i++) \n        Lf[i]=1,Rf[i]=n;\n    Lf[0]=0,Rf[0]=n+1;\n    for(int i=0;i<=tot;i++)\n        for(int j=1;j<=k;j++) \n            if(!((i>>(j-1))&1)) {\n                Lf[i|(1<<(j-1))]=max(Lf[i|(1<<(j-1))],R[j][Lf[i]+1]);\n                Rf[i|(1<<(j-1))]=min(Rf[i|(1<<(j-1))],L[j][Rf[i]-1]);\n            }\n    for(int i=0;i<=n+1;i++) \n        val[i]=2*n;\n    for(int i=0;i<=tot;i++) \n        val[Lf[i]]=min(val[Lf[i]],Rf[tot^i]);\n    for(int i=n;i>=0;i--) \n        val[i]=min(val[i],val[i+1]);\n    for(int i=1;i<=n;i++) \n        printf(val[L[0][i]-1]<=R[0][i]+1?\"Possible\\n\":\"Impossible\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define F(i,j,n) for(register int i=j;i<=n;i++)\n#define D(i,j,n) for(register int i=j;i>=n;i--)\n#define ll long long\n#define N 200010\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;int f;\n\tchar gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void gi(I&x){\n\t\tfor(f=1,c=gc();c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n};\nusing io::gi;\nusing io::gc;\nint f[N],s[N],nxt[20][N],x[N],n,m,h,v,d,p;\nvector<int>g;\nvoid pre(int v){\n\tif(!v)return;pre(v/2);\n\th=0;d++;\n\tF(i,1,m)\n\t\tif(x[f[i]]>v)f[++h]=f[i];\n\t\telse nxt[d][f[i-1]]=f[i];\n\tm=h;\n//\tF(i,1,m)printf(\"%d \",f[i]);puts(\"\");\n}\nint dfs(int d,vector<int>f){\n\tif(f.empty())return 1;\n\tvector<int>g;int m=f.size(),h=0;\n//\tF(i,1,m)printf(\"%d \",f[i-1]);puts(\"\");\n\tF(i,1,m)for(int j=f[i-1];j;j=nxt[d][j]){\n\t\tg.push_back(j);\n\t\th++;if(h>d)return 0;\n\t}\n\tf=g;\n\tF(i,1,h){\n\t\tg.clear();\n\t\tF(j,1,h)if(j!=i)g.push_back(f[j-1]);\n\t\tif(dfs(d-1,g))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tgi(n);gi(v);\n\tF(i,1,n)gi(x[i]);\n\tD(i,n,2)x[i]-=x[i-1];\n\tx[1]=v+1;F(i,1,n)f[++m]=i;\n\tpre(v);f[m+1]=n+1;\n//\tprintf(\"%d\\n\",d);\n//\tF(i,1,d){F(j,1,n)printf(\"%d \",nxt[i][j]);puts(\"\");}puts(\"\");\n\tif(m>d+1){F(i,1,n)puts(\"Impossible\");return 0;}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10;\nint n,x[N],d[20],id,dep;\nstruct Array{\n\tint L[N],R[N],l[N],r[N],cnt;\n\tvoid init(int dep);\n}a[20];\nvoid Array::init(int dep){\n\tint dis=d[dep];\n\tcnt++;L[1]=R[1]=x[1];\n\tfor (int i=2;i<=n;i++){\n\t\tif (x[i]<=R[cnt]+dis) R[cnt]=x[i];else\n\t\tcnt++,L[cnt]=R[cnt]=x[i];\n\t}\n\tint m=a[dep+1].cnt,*ll=a[dep+1].L,*rr=a[dep+1].R;\n\tl[0]=r[0]=1;\n\tfor (int i=1;i<=cnt;i++){\n\t\tfor (l[i]=l[i-1];l[i]<m&&rr[l[i]]<L[i];l[i]++);\n\t\tfor (r[i]=r[i-1];r[i]<m&&ll[r[i]+1]<=R[i];r[i]++);\n\t}\n}\nint q[20][N],size[20];\ninline void push(int h,int v){\n\tfor (int i=a[h].l[v];i<=a[h].r[v];i++) q[h+1][++size[h+1]]=i;\n}\nbool check(int h){\n\tif (!size[h]) return 1;\n\tif (size[h]>dep-h+1) return 0;\n\tfor (int i=1;i<=size[h];i++){\n\t\tsize[h+1]=0;\n\t\tfor (int j=1;j<=size[h];j++)\n\t\tif (i!=j) push(h,q[h][j]);\n\t\tif (check(h+1)) return 1;\n\t}\n\treturn 0;\n}\nbool ans[N],ok[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&d[0]);\n\twhile (d[dep]) d[dep+1]=d[dep]>>1,dep++;\n\ta[dep].cnt=n;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x[i]),a[dep].L[i]=a[dep].R[i]=x[i];\n\tfor (int i=dep-1;i>=0;i--) a[i].init(i);\n\tfor (int i=1;i<=a[0].cnt;i++){\n\t\tsize[1]=0;\n\t\tfor (int j=1;j<=a[0].cnt;j++)\n\t\tif (i!=j) push(0,j);\n\t\tok[i]=check(1);\n\t}\n\tfor (int i=1,p=1;i<=n;i++){\n\t\twhile (x[i]>a[0].R[p]) p++;\n\t\tputs(ok[p]?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MN=300000+5;\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T>inline T&IN(T&in){\n\tin=0;char c=getchar();int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1;c=getchar();}\n\twhile(isdigit(c))in=in*10+c-'0',c=getchar();\n\treturn in*=f;\n}\nint n,V;\nint l[20][MN],r[20][MN];\nint fr[MN],fl[MN],s[MN];ll x[MN];\nvoid input(){\n\tIN(n),IN(V);\n\tfor(int i=1;i<=n;++i)IN(x[i]);\n\tint k;x[0]=LLONG_MIN/10,x[n+1]=LLONG_MAX/10;\n\tfor(k=0;V;++k,V>>=1){\n\t\tfor(int i=1;i<=n;++i)l[k][i]=x[i]-x[i-1]>V?i:l[k][i-1];\n\t\tfor(int i=n;i>=1;--i)r[k][i]=x[i+1]-x[i]>V?i:r[k][i+1];\n\t\tl[k][0]=1,r[k][n+1]=n;\n\t}\n\tfor(int i=1;i<=n;++i)l[k][i]=x[i]-x[i-1]>V?i:l[k][i-1];\n\tfor(int i=n;i>=1;--i)r[k][i]=x[i+1]-x[i]>V?i:r[k][i+1];\n\tl[k][0]=1,r[k][n+1]=n;\n\tfr[0]=n+1;\n\tfor(int st=1;st<(1<<k);++st){\n\t\tfr[st]=n;\n\t\tfor(int i=0;i<k;++i)if(st>>i&1){\n\t\t\tfl[st]=max(fl[st],r[i+1][fl[st^(1<<i)]+1]);\n\t\t\tfr[st]=min(fr[st],l[i+1][fr[st^(1<<i)]-1]);\n\t\t}\n\t}\n\tfor(int st=0;st<(1<<k);++st){\n\t\tint L=l[0][fr[((1<<k)-1)^st]-1],R=r[0][fl[st]+1];\n\t\tif(L<=R)s[L]++,s[R+1]--;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\ts[i]+=s[i-1];\n\t\tputs(s[i]?\"Possible\":\"Impossible\");\n\t}\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 200005\n#define MAXM 18\n#define MAXK (1<<MAXM)\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\n#define prev daksiisaas\n#define next aijdkjsaod\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\nint N,V,x[MAXN];\nvector<int> v;\nint prev[MAXN][MAXM],next[MAXN][MAXM];\nint predp[MAXK],sufdp[MAXK];\nint mini[MAXN];\nint main()\n{\n    scanf(\"%d%d\",&N,&V);\n    for(int i=1;i<=N;i++) scanf(\"%d\",&x[i]);\n    int dummy=V;\n    while(dummy)\n    {\n        v.push_back(dummy);\n        dummy/=2;\n    }\n    v.push_back(0);\n    reverse(v.begin(),v.end());\n    int sz=(int)v.size();\n    for(int i=(int)v.size()-1;i>=0;i--) next[N][i]=N;\n    for(int i=N-1;i>=0;i--)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i+1]-x[i]>v[j]) next[i][j]=i; else next[i][j]=next[i+1][j];\n    for(int i=(int)v.size()-1;i>=0;i--) prev[1][i]=1;\n    for(int i=2;i<=N;i++)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i]-x[i-1]>v[j]) prev[i][j]=i; else prev[i][j]=prev[i-1][j];\n    //for(int i=1;i<=N;i++) printf(\"%d %d %d %d\\n\",prev[i][1],prev[i][2],next[i][1],next[i][2]);\n    memset(predp,0,sizeof(predp));\n    for(int i=0;i<sz;i++) predp[(1<<i)]=next[1][i];\n    for(int mask=1;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            predp[mask^(1<<j)]=max(predp[mask^(1<<j)],next[min(predp[mask]+1,N)][j]);\n        }\n    }\n    for(int mask=1;mask<(1<<sz);mask++) sufdp[mask]=N;\n    for(int i=0;i<sz;i++) sufdp[(1<<i)]=prev[N][i];\n    for(int mask=1;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            sufdp[mask^(1<<j)]=min(sufdp[mask^(1<<j)],prev[max(sufdp[mask]-1,1)][j]);\n        }\n    }\n    for(int i=0;i<=N+1;i++) mini[i]=N+1; \n    for(int mask=0;mask<(1<<(sz-1));mask++)\n    {\n        int dmask=(1<<(sz-1))-1-mask;\n        int l,r;\n        if(mask==0) l=0; else l=predp[mask];\n        if(dmask==0) r=N+1; else r=sufdp[dmask];\n        mini[l]=min(mini[l],r);\n    }\n    for(int i=N;i>=0;i--) mini[i]=min(mini[i],mini[i+1]);\n    for(int i=1;i<=N;i++)\n    {\n        int l=prev[i][sz-1],r=next[i][sz-1];\n        if(l==1&&r==N) {puts(\"Possible\"); continue;}\n        //printf(\"%d %d\\n\",l,r);\n        if(mini[l-1]<=r+1) puts(\"Possible\"); else puts(\"Impossible\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (!isdigit(ch)&&ch!='-')\n\t\tch=getchar();\n\tif (ch=='-')\n\t\tf=-1,ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x*f;\n}\nconst int N=1050005;\nint n,v;\nint x[N];\nint R[20][N],L[20][N],mR[N],mL[N];\nint Max[N];\nint main(){\n\tn=read(),v=read();\n\tfor (int i=1;i<=n;i++)\n\t\tx[i]=read();\n\tint d;\n\tfor (d=0;d<20;d++){\n\t\tint k=v>>d;\n\t\tfor (int i=1,j;i<=n;i=j+1){\n\t\t\tfor (j=i;j<n&&x[j+1]-x[j]<=k;j++);\n\t\t\tfor (int k=i;k<=j;k++)\n\t\t\t\tL[d][k]=i,R[d][k]=j;\n\t\t}\n\t\tif (k==0)\n\t\t\tbreak;\n\t}\n\tfor (int i=0;i<=d;i++)\n\t\tR[i][n+1]=n,L[i][0]=1;\n\tfor (int i=0;i<(1<<d);i++)\n\t\tmR[i]=0,mL[i]=n+1;\n\tfor (int i=1;i<(1<<d);i++)\n\t\tfor (int j=0;j<d;j++)\n\t\t\tif (i>>j&1){\n\t\t\t\tmR[i]=max(mR[i],R[j+1][mR[i^(1<<j)]+1]);\n\t\t\t\tmL[i]=min(mL[i],L[j+1][mL[i^(1<<j)]-1]);\n\t\t\t}\n\tint base=(1<<d)-1;\n\tmemset(Max,-1,sizeof Max);\n\tfor (int i=0;i<(1<<d);i++){\n\t\tint x=i,y=i^base;\n\t\tMax[mL[x]]=max(Max[mL[x]],mR[y]);\n\t}\n\tfor (int i=2;i<=n+1;i++)\n\t\tMax[i]=max(Max[i],Max[i-1]);\n\tfor (int i=1;i<=n;i++){\n\t\tint l=L[0][i],r=R[0][i];\n\t\tputs(Max[r+1]>=l-1?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define intl long long\n#define maxn 201000\nusing namespace std;\n\nconst intl Mo = 1000000007LL;\n\nint n, top;\nvector<int> vec[maxn];\nint CNT[maxn], cnt[maxn];\nintl fac[maxn], inv[maxn];\nint x, y;\nintl ans;\n\nintl fpm(intl a, intl b) {\n\tif (!a) return 0LL;\n\tintl ans = 1LL;\n\tfor (; b; b >>= 1){\n\t\tif (b & 1) ans *= a, ans %= Mo;\n\t\ta *= a; a %= Mo;\n\t}\n\treturn ans;\n}\n\nintl C(int a, int b) {\n\treturn fac[a] * inv[b] % Mo * inv[a - b] % Mo;\n}\n\nint main() {\n\tscanf(\"%d %d %d\",&n,&x,&y);\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = fac[i - 1] * (intl) i % Mo;\n\tinv[n] = fpm(fac[n], Mo - 2LL);\n\tfor (int i = n; i >= 1; i--)\n\t\tinv[i - 1] = inv[i] * (intl) i % Mo;\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tint c, w;\n\t\tscanf(\"%d %d\",&c,&w);\n\t\tvec[c].push_back(w);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tsort(vec[i].begin(), vec[i].end());\n\tint just = 1 << 30;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (auto j = vec[i].begin(); j != vec[i].end(); j++)\n\t\t\tif (vec[i][0] + *j <= x || j == vec[i].begin()) cnt[i]++;\n\t\tif (!vec[i].empty()) just = min(just, vec[i][0]); \n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (vec[i].empty()) continue;\n\t\tif (vec[i][0] + just <= y) CNT[++top] = cnt[i];\n\t}\n\tfor (int i = 1; i <= top; i++) CNT[i] += CNT[i - 1];\n\tans = 1LL;\n\tfor (int i = top; i >= 1; i--)\n\t\t(ans *= C(CNT[i], CNT[i - 1])) %= Mo;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=2E5+5;\n\nint N,M,V;\nint a[Maxn];\nint F[Maxn],G[Maxn];\nint L[20][Maxn],R[20][Maxn];\nint nxt[Maxn];\n\ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n\nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1)\n\t\t\t\tMAX(F[i],R[M-j][min(F[i-(1<<j)]+1,N)]),\n\t\t\t\tMIN(G[i],L[M-j][max(G[i-(1<<j)]-1,1)]);\n\t}\n\tmemset(nxt,-1,sizeof(nxt));\n\tfor(int i=0;i<(1<<M);++i) MAX(nxt[G[(1<<M)-1-i]],F[i]);\n\tfor(int i=1;i<=N+1;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[R[0][i]+1]>=L[0][i]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong long x[210000];\nint sa[210000];\nint nx_L[19][210000];\nint nx_R[19][210000];\n\nint d[20];\nint L[1<<19];\nint R[1<<19];\npair<int,int>p[1<<19];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lld\",x+i);\n\t}\n\td[0]=b;\n\tint n=1;\n\tfor(int i=0;d[i];i++){\n\t\td[i+1]=d[i]/2;\n\t\tn=i+2;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tint to=a;\n\t\tnx_L[i][a]=a;\n\t\tfor(int j=a-1;j>=0;j--){\n\t\t\tnx_L[i][j]=to;\n\t\t\tif(j&&x[j]-x[j-1]>d[i])to=j;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tint to=a;\n\t\tnx_R[i][a]=a;\n\t\tfor(int j=a-1;j>=0;j--){\n\t\t\tnx_R[i][j]=to;\n\t\t\tif(j&&x[a-j]-x[a-1-j]>d[i])to=j;\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<n);i++){\n\t\tint at=L[i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i&(1<<j))continue;\n\t\t\tint to=nx_L[j][at];\n\t\t\tL[i+(1<<j)]=max(L[i+(1<<j)],to);\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<n);i++){\n\t\tint at=R[i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i&(1<<j))continue;\n\t\t\tint to=nx_R[j][at];\n\t\t\tR[i+(1<<j)]=max(R[i+(1<<j)],to);\n\t\t}\n\t}\n\tint sz=0;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tif(i&1);\n\t\telse{\n\t\t\tp[sz++]=make_pair(L[i],i);\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tprintf(\"%d: \",d[i]);\n\t\tfor(int j=0;j<a;j++)printf(\"%d \",nx_L[i][j]);\n\t\t\tprintf(\"\\n\");\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%d: \",d[i]);\n\t\tfor(int j=0;j<a;j++)printf(\"%d \",nx_R[i][j]);\n\t\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tstd::sort(p,p+sz);\n\tset<pair<int,int> >S;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tif(i&1);\n\t\telse{\n\t\t\tS.insert(make_pair(R[i],i));\n\t\t}\n\t}\n\tint at=0;\n\tfor(int i=0;i<a;i++){\n\t\tint lq=a-nx_R[0][a-1-i];\n\t\tint rq=a-nx_L[0][i];\n\t\twhile(at<sz&&p[at].first<lq){\n\t\t\tS.erase(make_pair(R[p[at].second],p[at].second));\n\t\t\tat++;\n\t\t}\n\t\t//printf(\"%d %d\\n\",lq,rq);\n\t\tif(S.size()){\n\t\t\tpair<int,int> tp=*(S.rbegin());\n\t\t\tif(tp.first>=rq)printf(\"Possible\\n\");\n\t\t\telse printf(\"Impossible\\n\");\n\t\t}else{\n\t\t\tif(at<sz&&rq==0)printf(\"Possible\\n\");\n\t\t\telse printf(\"Impossible\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int L = 20, N = 201010;\n\nint n, V, x[N], fa[L][N], siz[L][N], ans[N], lt[1 << L], rt[1 << L];\nvector<int> v[N];\n\nint Find(int k, int x) {\n  return fa[k][x] == x ? x : fa[k][x] = Find(k, fa[k][x]);\n}\n\nvoid Merge(int k, int x, int y) {\n  x = Find(k, x), y = Find(k, y);\n  fa[k][y] = x;\n  siz[k][x] += siz[k][y];\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &V);\n  for(int i = 1; i <= n; i++)\n    scanf(\"%d\", &x[i]);\n  int now = V, m;\n  for(int o = L - 1; ; now >>= 1, o = (o + 1) % L) {\n    for(int i = 1; i <= n; i++)\n      fa[o][i] = i, siz[o][i] = 1;\n    for(int i = 1; i <= n; i++) {\n      int j = i;\n      while(j < n && x[j + 1] - x[j] <= now) j++;\n      for(int k = i + 1; k <= j; k++)\n\tMerge(o, i, k);\n      i = j;\n    }\n    if(now == 0) { m = o + 1; break; }\n  }\n\n  lt[0] = 0, rt[0] = n + 1;\n  for(int i = 0; i < (1 << m); i++) {\n    for(int j = 0; j < m; j++)\n      if(~i >> j & 1) {\n\tlt[i | (1 << j)] = max(lt[i | (1 << j)], lt[i] + siz[j][lt[i] + 1]);\n\trt[i | (1 << j)] = max(rt[i | (1 << j)], rt[i] - siz[j][Find(j, rt[i] - 1)]);\n      }\n  }\n  // cerr << lt[27]  <<\" \" << rt[4] << endl;\n\n  int all = (1 << m) - 1; \n  for(int i = 0; i < (1 << m); i++) {\n    v[lt[i]].push_back(rt[all ^ i]);\n    //cerr << lt[i] << \" \" << rt[all ^ i] << endl;\n  }\n\n  int mi = n + 2;\n  for(int i = 0; i < v[n].size(); i++)\n    mi = min(v[n][i], mi);\n  \n  for(int i = n; i >= 1; i--) {\n    for(int j = 0; j < v[i - 1].size(); j++)\n      mi = min(v[i - 1][j], mi);\n    if(fa[L - 1][i] != i) continue;\n    //cerr << i + siz[L - 1][i] << endl;\n    ans[i] = mi <= i + siz[L - 1][i];\n  }\n  \n  for(int i = 1; i <= n; i++)\n    puts(ans[Find(L - 1, i)] ? \"Possible\" : \"Impossible\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint n,V,x[200001],logv;vector<int> v;bool ans[200001];\nint cal(int x){int ans=0;while(x)x>>=1,++ans;return ans;}\nbool walk(vector<int> &v,int s)\n{\n\tint n=v.size();//printf(\"walk({\");for(int i=0;i<n;++i){printf(\"%d\",v[i]);if(i!=n-1)putchar(',');}printf(\"},%d)\\n\",s);\n\tif(n==1||!n)return true;\n\tint k=cal(s);bool flg=false;int st=0,cnt=1;\n\tfor(int i=1;i<n;++i)if(v[i]-v[i-1]>s)++cnt;if(cnt>k+1)return false;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tif(v[i]-v[i-1]>s)\n\t\t{\n\t\t\tvector<int> tmp=v;tmp.erase(tmp.begin()+st,tmp.begin()+i);\n\t\t\tif(walk(tmp,s>>1))return true;st=i;\n\t\t}\n\t}\n\tvector<int> tmp=v;tmp.erase(tmp.begin()+st,tmp.end());if(walk(tmp,s>>1))return true;\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&V);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);for(int i=1;i<=n;++i)v.push_back(x[i]);\n\tint st=0,cnt=1,k=cal(V);\n\tfor(int i=1;i<n;++i)if(v[i]-v[i-1]>V)++cnt;if(cnt>k+1){for(int i=1;i<=n;++i)printf(\"Impossible\\n\");return 0;}\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tif(v[i]-v[i-1]>V)\n\t\t{\n\t\t\tvector<int> tmp=v;tmp.erase(tmp.begin()+st,tmp.begin()+i);\n\t\t\tif(walk(tmp,V>>1)){for(int j=st;j<i;++j)ans[j+1]=true;}st=i;\n\t\t}\n\t}\n\tvector<int> tmp=v;tmp.erase(tmp.begin()+st,tmp.end());if(walk(tmp,V>>1)){for(int j=st;j<n;++j)ans[j+1]=true;}\n\tfor(int i=1;i<=n;++i)printf(ans[i]?\"Possible\\n\":\"Impossible\\n\");return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nint n, v, lg;\ntypedef std::pair<int, int> pr;\nint g0[1 << 19], g1[1 << 19];\nint x[maxn], ans[maxn];\nstd::vector<pr> vec[233];\ninline void init(std::vector<pr> & v,int d) {\n\tint l = 1;\n\tfor(int i = 2;i <= n;++i) if(x[i] - x[i - 1] > d)\n\t\tv.emplace_back(l, i - 1), l = i;\n\tv.emplace_back(l, n);\n}\ninline void up(int & x,int y) { if(x < y) x = y; }\ninline void down(int & x,int y) { if(x > y) x = y; }\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> v;\n\trep(i, 1, n) cin >> x[i];\n\tfor(;v >> lg;++lg) if(v >> lg) init(vec[lg], v >> lg);\n\tinit(vec[lg++], 0);\n\tif(vec[0].size() < 20) {\n\t\tstd::fill(g1, g1 + (1 << lg), n + 1);\n\t\trep(i, 0, (1 << lg) - 1) {\n\t\t\trep(j, 1, lg - 1) if((i >> j & 1) == 0){\n\t\t\t\tint l = 0, r = vec[j].size();\n\t\t\t\tfor(;l + 1 != r;) (vec[j][l + r >> 1].first <= g0[i] + 1 ? l : r) = l + r >> 1;\n\t\t\t\tup(g0[i | 1 << j], vec[j][l].second), l = -1, r = vec[j].size() - 1;\n\t\t\t\tfor(;l + 1 != r;) (vec[j][l + r >> 1].second >= g1[i] - 1 ? r : l) = l + r >> 1;\n\t\t\t\tdown(g1[i | 1 << j], vec[j][r].first);\n\t\t\t}\n\t\t}\n\t\tfor(pr i : *vec) {\n\t\t\tfor(int j = 0;j < 1 << lg;j += 2) {\n\t\t\t\tif(g0[j] >= i.first - 1 && i.second + 1 >= g1[~j & (1 << lg) - 1 & -2]){\n\t\t\t\t\tstd::fill(ans + i.first, ans + i.second + 1, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 1, n) {\n\t\tcout << (ans[i] ? \"Possible\" : \"Impossible\") << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, v;\nconst int N = 600000;\nint ai[N];\nint L[20][N], R[20][N], cnt[N];\nint Ld[N], Rd[N];\nint main()\n{\n    scanf(\"%d%d\", &n, &v);\n    for (int i = 1; i <= n; ++ i) scanf(\"%d\", &ai[i]);\n    int c = 0;\n    for (int i = 0, vv = v; vv != -1; ++ i, vv == 0? vv = -1: vv /= 2)\n    {\n        c ++;\n        R[i][n] = n;\n        for (int j = n - 1; j >= 1; -- j)\n            if (ai[j + 1] - ai[j] <= vv)\n                R[i][j] = R[i][j + 1];\n            else\n                R[i][j] = j;\n        L[i][1] = 1;\n        for (int j = 2; j <= n; ++ j)\n            if (ai[j] - ai[j - 1] <= vv)\n                L[i][j] = L[i][j - 1];\n            else\n                L[i][j] = j;\n    }\n    for (int i = 0; i < (1 << c); ++ i)\n        Ld[i] = n + 1;\n    for (int i = 0; i < (1 << c); ++ i)\n        for (int j = 0; j <= c; ++ j)\n            if (!(i & (1 << j)))\n                Rd[i | (1 << j)] = max(Rd[i | (1 << j)], R[j][Rd[i] + 1]),\n                Ld[i | (1 << j)] = min(Ld[i | (1 << j)], L[j][Ld[i] - 1]);\n    for (int i = 0; i < (1 << c); ++ i) if (!(i & 1))\n        if (R[0][Rd[i] + 1] + 1 >= Ld[((1 << c) - 2) ^ i])\n        {\n            cnt[L[0][Rd[i] + 1]] ++;\n            cnt[R[0][Rd[i] + 1] + 1] --;\n        }\n    for (int i = 1; i <= n; ++ i) cnt[i] += cnt[i - 1];\n    for (int i = 1; i <= n; ++ i) if (cnt[i]) puts(\"Possible\"); else puts(\"Impossible\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <deque>\n#include <utility>\n#include <chrono>\n#include <sstream>\n#include <iomanip>\n#define INF 1 << 30\n#define MOD 1000000007;\n#define pi 3.14159265358979\n#define rep(i, n) for (int (i) = 0; (i) < (int)(n); (i)++)\n#define reu(i, l, r) for (int (i) = (int)(l); (i) < (int)(r); (i)++)\n#define D(x) cout << x << endl\n#define d(x) cout << x\n#define all(x) (x).begin(), (x).end()\n#define pub(x) push_back(x)\n#define pob() pop_back()\n#define puf(x) push_front(x)\n#define pof() pop_front()\n#define mp(x, y) make_pair((x), (y))\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if (x < y) x = y; }\nstatic const int dx[] = {0, 0, 1, -1};\nstatic const int dy[] = {-1, 1, 0, 0};\n\nint main() { \n  int n, v;\n  cin >> n >> v;\n  vi x(n);\n  vi dis(n - 1);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i];\n    if (i != 0) {\n      dis[i - 1] = x[i] - x[i - 1];\n    }\n  }\n  vi vv;\n  while (v > 0) {\n    vv.pub(v);\n    v /= 2;\n  }\n  vv.pub(0);\n\n  vector<vector<bool>> wall(vv.size(), vector<bool> (n, false));\n\n  for (int i = 0; i < vv.size(); i++) {\n    for (int j = 0; j < n  - 1; j++) {\n      if (dis[j] > vv[i]) {\n        wall[i][j] = true;\n      }\n    }\n    wall[i][n - 1] = true;\n  }\n  \n  vector<string> ans;\n\n  int i = 0;\n  while (i < n) {\n    int cnt = 0;\n    vector<bool> done(n);\n\n    while (!wall[0][i]) {\n      done[i] = true;\n      i++;\n      cnt++;\n    }\n    done[i] = true;\n    i++;\n    cnt++;\n\n    D(cnt << ' ' << i);\n\n    for (int j = 1; j < vv.size(); j++) {\n      int maxd = -1;\n      int maxk = -1;\n      for (int k = 0; k < n; k++) {\n        if (!wall[j][k] && !done[k]) {\n          if (maxd < dis[k]) {\n            maxd = dis[k];\n            maxk = k;\n          }\n        }\n      }\n\n      if (maxk == -1) {\n        break;\n      }\n      \n      int kpf = maxk + 1;\n      while (!wall[j][kpf] && kpf < n) {\n        done[kpf] = true;\n        kpf++;\n      }\n      int kpb = maxk;\n      while (!wall[j][kpb] && kpb > 0) {\n        done[kpb] = true;\n        kpb--;\n      }\n    }\n    \n    bool end = true;\n    for (int p = 0; p < n; p++) {\n      if (!done[i]) {\n        end = false;\n      }\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      if (end) {\n        ans.pub(\"Possible\");\n      } else {\n        ans.pub(\"Impossible\");\n      }\n    }\n  }\n\n  for (int i = 0; i < ans.size(); i++) {\n    D(ans[i]);\n  }\n\n  //for (int i = 0; i < dis.size(); i++) {\n  //  d(setw(3) << dis[i] << \" \" );\n  //}\n  //D(\"\");     \n  //for (int i = 0; i < vv.size(); i++) {\n  //  for (int j = 0; j < n - 1; j++) {\n  //    d(setw(3) << wall[i][j] << \" \");\n  //  }\n  //  D(\"\");\n  //}\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=533333;\nint n,V,vs[20],vp=0,mx,xs[N],f1[N],f2[N],ls[20][N],rs[20][N],ml[N];\nvoid maxs(int&a,int b){if(a<b)a=b;}\nvoid mins(int&a,int b){if(a>b)a=b;}\nint main(){\n\tscanf(\"%d%d\",&n,&V);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",xs+i);\n\tfor(int a=V>>1;vs[vp++]=a;a>>=1);\n\tmx=1<<vp,vs[vp]=V;\n\tfor(int z=0;z<=vp;++z){\n\t\trs[z][n+1]=n,ls[z][0]=1;\n\t\tfor(int i=1,j=1,x=vs[z];i<=n;i=j){\n\t\t\tfor(++j;j<=n&&xs[j]-xs[j-1]<=x;++j);\n\t\t\tfor(int k=i;k<j;++k)ls[z][k]=i,rs[z][k]=j-1;\n\t\t}\n\t}\n\tfor(int i=0;i<mx;++i)f2[i]=n+1;\n\tfor(int i=1;i<mx;++i){\n\t\tfor(int j=0;j<vp;++j)if(i>>j&1){\n\t\t\tmaxs(f1[i],rs[j][f1[i-(1<<j)]+1]);\n\t\t\tmins(f2[i],ls[j][f2[i-(1<<j)]-1]);\n\t\t}\n\t}\n\tfor(int i=0;i<mx;++i)maxs(ml[f2[mx-1-i]-1],f1[i]+1);\n\tfor(int i=0;i<=n;++i)maxs(ml[i+1],ml[i]);\n\tfor(int i=1;i<=n;++i)puts(ml[rs[vp][i]]>=ls[vp][i]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint dpl[1<<20],dpr[1<<20],n,v,x[200011],l[21][200001],r[21][200001],q[100001];bool ans[200001];\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n\tint tmp=v;while(tmp)q[++q[0]]=tmp,tmp>>=1;q[++q[0]]=0;for(int i=1;i<=q[0]-i+1;++i)swap(q[i],q[q[0]-i+1]);\n//\tfor(int i=1;i<=q[0];++i)printf(\"%d \",q[i]);putchar(10);\n\tfor(int i=1;i<=q[0];++i)\n\t{\n\t\tint pt=1;\n\t\tfor(int j=1;j<=n;++j){if(x[j]-x[j-1]>q[i])pt=j;l[i][j]=pt;}pt=n;\n\t\tfor(int j=n;j;--j){if(x[j+1]-x[j]>q[i])pt=j;r[i][j]=pt;}\n\t}\n//\tfor(int i=1;i<=n;++i)printf(\"%d %d\\n\",l[q[0]][i],r[q[0]][i]);\n\tfor(int i=0;i<(1<<q[0]);++i)dpl[i]=1,dpr[i]=n;\n\tfor(int i=0;i<(1<<q[0]);++i)\n\t{\n\t\tfor(int j=1;j<=q[0];++j)\n\t\t{\n\t\t\tif(i&(1<<j-1))continue;\n\t\t\tif(dpl[i]>n)dpl[i|(1<<j-1)]=dpl[i];else dpl[i|(1<<j-1)]=max(dpl[i|(1<<j-1)],r[j][dpl[i]]+1);\n\t\t\tif(dpr[i]<1)dpr[i|(1<<j-1)]=dpr[i];else dpr[i|(1<<j-1)]=min(dpr[i|(1<<j-1)],l[j][dpr[i]]-1);\n\t\t}\n\t}\n\tint cnt=0;for(int i=1;i<=n;i=r[q[0]][i]+1)++cnt;if(cnt>q[0]){for(int i=1;i<=n;++i)printf(\"Impossible\\n\");return 0;}\n//\tfor(int i=0;i<(1<<q[0]);++i)printf(\"%d %d %d\\n\",i,dpl[i],dpr[i]);\n\tfor(int i=1;i<=n;i=r[q[0]][i]+1)\n\t{\n\t\tbool flg=false;\n\t\tfor(int j=0;j<(1<<q[0]-1);++j)if(dpl[j]>=l[q[0]][i]&&dpr[((1<<q[0]-1)-1)^j]<=r[q[0]][i]){flg=true;break;}\n\t\tfor(int j=l[q[0]][i];j<=r[q[0]][i];++j)ans[j]=flg;\n\t}\n\tfor(int i=1;i<=n;++i)printf(ans[i]?\"Possible\\n\":\"Impossible\\n\");return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 200000 + 1000;\nconst int MAXM = 1048576;\nconst int MAXK = 20;\n\n#define next __next\n#define prev __prev\n\nint n, m, V;\nint a[MAXN], v[MAXK];\nint f[MAXM], g[MAXM];\nint next[MAXN][MAXK], prev[MAXN][MAXK];\nint ans[MAXN];\n\nvoid yes()\n{\n\tcout << \"Possible\" << endl;\n}\n\nvoid no()\n{\n\tcout << \"Impossible\" << endl;\n}\n\nvoid init()\n{\n\tfor(m = 0; V; V /= 2, m++)\n\t\tv[m] = V;\n\tv[m++] = 0;\n\n\tfor(int i = 0; i <= m - 1; i++)\n\t\tnext[n + 1][i] = next[n][i] = n;\n\tfor(int i = n - 1; i >= 1; i--)\n\t\tfor(int j = 0; j <= m - 1; j++)\n\t\t\tnext[i][j] = (a[i + 1] - a[i] <= v[j] ? next[i + 1][j] : i);\n\n\tfor(int i = 0; i <= m - 1; i++)\n\t\tprev[0][i] = prev[1][i] = 1;\n\tfor(int i = 2; i <= n; i++)\n\t\tfor(int j = 0; j <= m - 1; j++)\n\t\t\tprev[i][j] = (a[i] - a[i - 1] <= v[j] ? prev[i - 1][j] : i);\n}\n\nvoid work()\n{\n\tf[0] = 0;\n\tfor(int i = 1; i < (1 << m); i++)\n\t{\n\t\tf[i] = 0;\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tif((i >> j) & 1)\n\t\t\t\tf[i] = max(f[i], next[f[i ^ (1 << j)] + 1][j]);\n\t}\n\tg[0] = n + 1;\n\tfor(int i = 1; i < (1 << m); i++)\n\t{\n\t\tg[i] = n + 1;\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tif((i >> j) & 1)\n\t\t\t\tg[i] = min(g[i], prev[g[i ^ (1 << j)] - 1][j]);\n\t}\n\n\tfor(int i = 0; i < (1 << m); i++)\n\t{\n\t\tint s1 = i, s2 = ((1 << m) - 1) ^ i;\n\t\ts1 = s1 & ~1, s2 = s2 & ~1;\n\t\tint p = f[s1], q = g[s2];\n\t\tif(p + 1 > q - 1)\n\t\t{\n\t\t\tfor(int j = 1; j <= n; j++)\n\t\t\t\tyes();\n\t\t\treturn ;\n\t\t}\n\t\tif(next[p + 1][0] >= q - 1)\n\t\t\tans[p + 1] += 1, ans[q - 1 + 1] -= 1;\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tans[i] += ans[i - 1];\n\tfor(int i = 1; i <= n; i++)\n\t\tans[i] > 0 ? yes() : no();\n\t// for(int i = 1; i <= n; i++)\n\t// \tcerr << ans[i] << endl;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n >> V;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\n\tinit();\n\twork();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fst first\n#define Snd second\n#define RG register\n#define mp make_pair\n#define mem(a,b) memset(a,b,sizeof(a))\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned int UI;\ntypedef unsigned long long ULL;\ntemplate<typename T> inline void read(T& x) {\n\tchar c = getchar();\n\tbool f = false;\n\tfor (x = 0; !isdigit(c); c = getchar()) {\n\t\tif (c == '-') {\n\t\t\tf = true;\n\t\t}\n\t}\n\tfor (; isdigit(c); c = getchar()) {\n\t\tx = x * 10 + c - '0';\n\t}\n\tif (f) {\n\t\tx = -x;\n\t}\n}\ntemplate<typename T, typename... U> inline void read(T& x, U& ... y) {\n\tread(x), read(y...);\n}\nconst int N=2e5+10;\nint n,V;\nint A[N],L[20][N],R[20][N],Fl[1<<20],Fr[1<<20],G[N];\nvoid Calc(int m,int d) {\n  R[m][n]=n;\n  for(int i=n-1;i;--i) {\n    if(A[i+1]-A[i]<=d) R[m][i]=R[m][i+1];\n    else R[m][i]=i;\n  }\n  L[m][1]=1;\n  for(int i=2;i<=n;++i) {\n    if(A[i]-A[i-1]<=d) L[m][i]=L[m][i-1];\n    else L[m][i]=i;\n  }\n}\n//#define rua\nint main() {\n//\tios::sync_with_stdio(false);\n#ifdef rua\n\tfreopen(\"GG.in\",\"r\",stdin);\n#endif\n  read(n,V);\n  for(int i=1;i<=n;++i) read(A[i]);\n  int mlog=0;\n  while(V) Calc(mlog++,V),V>>=1;\n  Calc(mlog,V);\n  Fr[0]=n+1;\n  for(int i=1;i<1<<mlog;++i) {\n    Fr[i]=n;\n    for(int j=0;j<mlog;++j) {\n      if(i>>j&1) {\n        Fl[i]=max(Fl[i],R[j+1][Fl[i^(1<<j)]+1]);\n        Fr[i]=min(Fr[i],L[j+1][Fr[i^(1<<j)]-1]);\n      }\n    }\n  }\n  for(int i=0;i<1<<mlog;++i) {\n    int l=Fl[i],r=Fr[((1<<mlog)-1)^i];\n    int a=L[0][r-1],b=R[0][l+1];\n    if(a<=b) ++G[a],--G[b+1];\n  }\n  for(int i=1;i<=n;++i) {\n    G[i]+=G[i-1];\n    puts(G[i]?\"Possible\":\"Impossible\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memset( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\nconst int MAXN = 200020;\nconst int INF = 0x3f3f3f3f;\n\nint n, m, v[20], tot, a[MAXN], d[MAXN];\nint f[MAXN][20], g[MAXN][20];\nint dpl[MAXN << 1], dpr[MAXN << 1], ans[MAXN];\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tscanf( \"%d%d\", &n, &m );\n\tfor( int i = 1 ; i <= n ; i++ ) scanf( \"%d\", &a[ i ] );\n\twhile( m ) v[ tot++ ] = m, m >>= 1;\n\tv[ tot++ ] = 0;\n\td[ 1 ] = d[ n + 1 ] = INF;\n\tfor( int i = 2 ; i <= n ; i++ ) d[ i ] = a[ i ] - a[ i - 1 ];\n\tfor( int j = 0 ; j < tot ; j++ )\n\t{\n\t\tfor( int i = 1 ; i <= n ; i++ )\n\t\t\tif( d[ i ] > v[ j ] ) f[ i ][ j ] = i;\n\t\t\telse f[ i ][ j ] = f[ i - 1 ][ j ];\n\t\tfor( int i = n ; i ; i-- )\n\t\t\tif( d[ i + 1 ] > v[ j ] ) g[ i ][ j ] = i;\n\t\t\telse g[ i ][ j ] = g[ i + 1 ][ j ];\n\t}\n\tfill( dpr, 0x3f );\n\tdpr[ 0 ] = n + 1;\n\tfor( int i = 0 ; i < ( 1 << tot ) ; i++ )\n\t\tfor( int j = 0 ; j < tot ; j++ ) if( !( i >> j & 1 ) )\n\t\t{\n\t\t\tif( dpl[ i ] >= n ) dpl[ i | ( 1 << j ) ] = n;\n\t\t\telse dpl[ i | ( 1 << j ) ] = max( dpl[ i | ( 1 << j ) ], g[ dpl[ i ] + 1 ][ j ] );\n\t\t\tif( dpr[ i ] <= 1 ) dpr[ i | ( 1 << j ) ] = 1;\n\t\t\telse dpr[ i | ( 1 << j ) ] = min( dpr[ i | ( 1 << j ) ], f[ dpr[ i ] - 1 ][ j ] );\n\t\t}\n\tfor( int i = 0 ; i < ( 1 << tot ) ; i++ )\n\t{\n\t\tif( i & 1 ) continue;\n\t\tint l = dpl[ i ], r = dpr[ ( 1 << tot ) - 1 - i - 1 ];\n\t\tif( l >= r ) ans[ 1 ]++;\n\t\telse\n\t\t{\n\t\t\tint L = f[ l + 1 ][ 0 ], R = g[ l + 1 ][ 0 ];\n\t\t\tif( R + 1 >= r ) ans[ L ]++, ans[ R + 1 ]--;\n\t\t}\n\t}\n\tfor( int i = 1, cur = 0 ; i <= n ; i++ )\n\t{\n\t\tcur += ans[ i ];\n\t\tif( cur ) puts( \"Possible\" );\n\t\telse puts( \"Impossible\" );\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memset( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\nconst int MAXN = 200020;\nconst int INF = 0x3f3f3f3f;\n\nint n, m, v[20], tot, a[MAXN], d[MAXN];\nint f[MAXN][20], g[MAXN][20];\nint dpl[MAXN << 1], dpr[MAXN << 1], ans[MAXN];\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tscanf( \"%d%d\", &n, &m );\n\tfor( int i = 1 ; i <= n ; i++ ) scanf( \"%d\", &a[ i ] );\n\twhile( m ) v[ tot++ ] = m, m >>= 1;\n\tv[ tot++ ] = 0;\n\td[ 1 ] = d[ n + 1 ] = INF;\n\tfor( int i = 2 ; i <= n ; i++ ) d[ i ] = a[ i ] - a[ i - 1 ];\n\tfor( int j = 0 ; j < tot ; j++ )\n\t{\n\t\tfor( int i = 1 ; i <= n ; i++ )\n\t\t\tif( d[ i ] > v[ j ] ) f[ i ][ j ] = i;\n\t\t\telse f[ i ][ j ] = f[ i - 1 ][ j ];\n\t\tfor( int i = n ; i ; i-- )\n\t\t\tif( d[ i + 1 ] > v[ j ] ) g[ i ][ j ] = i;\n\t\t\telse g[ i ][ j ] = g[ i + 1 ][ j ];\n\t}\n\tfill( dpr, 0x3f );\n\tdpr[ 0 ] = n + 1;\n\tfor( int i = 0 ; i < ( 1 << tot ) ; i++ )\n\t\tfor( int j = 0 ; j < tot ; j++ ) if( !( i >> j & 1 ) )\n\t\t{\n\t\t\tif( dpl[ i ] >= n ) dpl[ i | ( 1 << j ) ] = n;\n\t\t\telse dpl[ i | ( 1 << j ) ] = max( dpl[ i | ( 1 << j ) ], g[ dpl[ i ] + 1 ][ j ] );\n\t\t\tif( dpr[ i ] <= 1 ) dpr[ i | ( 1 << j ) ] = 1;\n\t\t\telse dpr[ i | ( 1 << j ) ] = min( dpr[ i | ( 1 << j ) ], f[ dpr[ i ] - 1 ][ j ] );\n\t\t}\n\tfor( int i = 0 ; i < ( 1 << tot ) ; i++ )\n\t{\n\t\tif( i & 1 ) continue;\n\t\tint l = dpl[ i ], r = dpr[ ( 1 << tot ) - 1 - i - 1 ];\n\t\tif( l >= r ) ans[ 1 ]++;\n\t\telse\n\t\t{\n\t\t\tint L = f[ l + 1 ][ 0 ], R = g[ l + 1 ][ 0 ];\n\t\t\tif( R + 1 >= r ) ans[ L ]++, ans[ R + 1 ]--;\n\t\t}\n\t}\n\tfor( int i = 1, cur = 0 ; i <= n ; i++ )\n\t{\n\t\tcur += ans[ i ];\n\t\tif( cur ) puts( \"Possible\" );\n\t\telse puts( \"Impossible\" );\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\nint b[20][200005];\nint n;\nint a[200005];\nint v,vt[20],len[20];\nvector<int> child[20][200005];\npair<int,int> bj[20][200005];\nmap<vector<int>,bool> m[20];  \nvector<int> tv;int p;\nstring ans[200005];\nvector<int> cl(vector<int> state,int bh,int cs){\n\tvector<int> re;re.clear();re.push_back(0);\n\tfor(int i=1;i<state.size();i++){\n\t\tif(i!=bh){\n\t\t\tfor(int j=0;j<child[cs][state[i]].size();j++){\n\t\t\t\tre.push_back(child[cs][state[i]][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn re;\n}\nbool dfs(int e,vector<int> state){\n\tif(state.size()==1)return 1;\n\tif(state.size()>p-e+2)return 0;\n\tif(e==p)return 1;\n\tif(m[e].count(state))return m[e][state];\n\tfor(int i=1;i<state.size();i++){\n\t\tif(e==0){\n\t\t\tif(dfs(e+1,cl(state,i,e))){\n\t\t\t\tans[i]=\"Possible\";\n\t\t\t}else ans[i]=\"Impossible\";\n\t\t}else{\n\t\t\tif(dfs(e+1,cl(state,i,e))){\n\t\t\t\treturn m[e][state]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn m[e][state]=0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tvt[0]=v;\n\ttv.push_back(0);\n\tfor(int i=1;vt[i-1]!=0;i++){\n\t\tvt[i]=(vt[i-1]>>1);\n\t\tp=i;\n\t}\n\tfor(int i=0;i<=p;i++){\n\t\tb[i][1]=1;\n\t\tbj[i][1].F=1;\n\t\tfor(int j=2;j<=n;j++){\n\t\t\tif(a[j]-a[j-1]>vt[i]){\n\t\t\t\tb[i][j]=b[i][j-1]+1;\n\t\t\t\tbj[i][b[i][j-1]].S=j-1;\n\t\t\t\tbj[i][b[i][j]].F=j;\n\t\t\t}else b[i][j]=b[i][j-1];\n\t\t}\n\t\tlen[i]=b[i][n];\n\t\tbj[i][len[i]].S=n;\n\t}\n\tfor(int i=0;i<p;i++){\n\t\tint qd=1;\n\t\tfor(int j=1;j<=len[i];j++){\n\t\t\twhile(qd<=len[i+1]&&bj[i][j].F<=bj[i+1][qd].F&&bj[i][j].S>=bj[i+1][qd].S){\n\t\t\t\tchild[i][j].push_back(qd);qd++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=len[0];i++)tv.push_back(i);\n\tdfs(0,tv);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<ans[b[0][i]].size();j++)putchar(ans[b[0][i]][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nconst int L=20;\nvi sub(vi x,int v){\n\tint n=x.size();\n\tvi res(1<<L);\n\tvi r[L];\n\trep(k,L){\n\t\tr[k].resize(n+1);\n\t\tif(((v<<1)>>k)==0)continue;\n\t\tr[k][n]=n;\n\t\tper(i,n){\n\t\t\tint j=i+1;\n\t\t\tif(j<n&&x[j]-x[i]<=(v>>k))\n\t\t\t\tj=r[k][j];\n\t\t\tr[k][i]=j;\n\t\t}\n\t}\n\trep(bit,1<<L){\n\t\trep(i,n)if(!(bit&1<<i)){\n\t\t\tchmax(res[bit^1<<i],r[i][res[bit]]);\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,v;cin>>n>>v;\n\tvi x=readvi(n);\n\t\n\tvi len[2];\n\trep(k,2){\n\t\tlen[k]=sub(x,v);\n\t\trep(i,n)x[i]=-x[i];\n\t\treverse(all(x));\n\t}\n\tdmp(len[1][1]);\n\t\n\tvc<string> ans(n,\"Impossible\");\n\tif(len[0][(1<<L)-1]==n){\n\t\trep(i,n){\n\t\t\tif(i&&x[i]-x[i-1]<=v)\n\t\t\t\tans[i]=ans[i-1];\n\t\t\telse{\n\t\t\t\tint j=i+1;\n\t\t\t\twhile(j<n&&x[j]-x[j-1]<=v)j++;\n\t\t\t\trep(bit,1<<(L-1)){\n\t\t\t\t\tint a=bit<<1;\n\t\t\t\t\tint y=(mask(L-1)^bit)<<1;\n\t\t\t\t\tif(len[0][a]>=i&&len[1][y]>=n-j){\n\t\t\t\t\t\tans[i]=\"Possible\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(auto w:ans)\n\t\tcout<<w<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)\n#define trav(it, v) for(typeof((v).begin()) it = (v).begin(); it != (v).end(); ++it)\n#define all(v) (v).begin(), (v).end()\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n\ntypedef double fl;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\t\nint N, V;\nint x[200005];\n\nstruct Node{\n\tint l, r;\n\tint v;\n\tvector<Node> children;\n\n\tNode(int _l, int _r, int _v){\n\t\tl=_l;\n\t\tr=_r;\n\t\tv=_v;\n\t\tif(!v)\n\t\t\treturn;\n\t\tint L=l;\n\t\trep(i,l+1,r){\n\t\t\tif(x[i] > x[i-1]+v){\n\t\t\t\tchildren.push_back(Node(L, i, v/2));\n\t\t\t\tL=i;\n\t\t\t}\n\t\t}\n\t\tchildren.push_back(Node(L, r, v/2));\n\t}\n};\n\nbool ans[200005];\n\nbool rec(vector<Node*> nodes, int stepsLeft, bool init){\n\tif(nodes.empty())\n\t\treturn true;\n\tif(nodes[0]->v == 0)\n\t\treturn nodes.size() == 1;\n\tvector<Node*> newNodes;\n\trep(i,0,nodes.size()){\n\t\tif(newNodes.size()+nodes[i]->children.size() > stepsLeft)\n\t\t\treturn 0;\n\t\trep(j,0,nodes[i]->children.size())\n\t\t\tnewNodes.push_back(&(nodes[i]->children[j]));\n\t}\n\t/*bool hasUrgent=false;\n\trep(i,0,newNodes.size())\n\t\tif(newNodes[i]->children.size() > 1)\n\t\t\thasUrgent = true;*/\n\trep(i,0,newNodes.size()){\n\t\tvector<Node*> newNewNodes = newNodes;\n\t\tnewNewNodes.erase(newNewNodes.begin()+i);\n\t\tif(rec(newNewNodes, stepsLeft-1, 0)){\n\t\t\tif(init){\n\t\t\t\trep(j,newNodes[i]->l,newNodes[i]->r)\n\t\t\t\t\tans[j]=true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\", &N, &V);\n\trep(i,0,N)\n\t\tscanf(\"%d\", x+i);\n\tNode start(0, N, V);\n\tvector<Node*> v;\n\tv.push_back(&start);\n\tint stepsLeft=20;\n\trec(v,stepsLeft,1);\n\trep(i,0,N){\n\t\tputs(ans[i]?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint N, V, LOG, a[200001], LE[19][200001], RE[19][200001], F[262144], G[262144], OK[200001];\nint main()\n{\n\tscanf(\"%d%d\", &N, &V);\n\twhile (1 << LOG <= V)\n\t\tLOG++;\n\tfor (int i = 1; i <= N; i++)\n\t\tscanf(\"%d\", a + i);\n\tfor (int i = 0; i <= LOG; i++)\n\t{\n\t\tint *le = LE[i], *re = RE[i];\n\t\tle[1] = 1;\n\t\tfor (int j = 2; j <= N; j++)\n\t\t\tle[j] = a[j] - a[j - 1] <= V >> i ? le[j - 1] : j;\n\t\tre[N] = N;\n\t\tfor (int j = N - 1; j; j--)\n\t\t\tre[j] = a[j + 1] - a[j] <= V >> i ? re[j + 1] : j;\n\t}\n\tfor (int i = 0; i < 1 << LOG; i++)\n\t{\n\t\tF[i] = 0;\n\t\tG[i] = N + 1;\n\t\tfor (int j = 1; j <= LOG; j++)\n\t\t\tif (i >> j - 1 & 1)\n\t\t\t{\n\t\t\t\tF[i] = std::max(F[i], F[i - (1 << j - 1)] == N ? N : RE[j][F[i - (1 << j - 1)] + 1]);\n\t\t\t\tG[i] = std::min(G[i], G[i - (1 << j - 1)] == 1 ? 1 : LE[j][G[i - (1 << j - 1)] - 1]);\n\t\t\t}\n\t}\n\tfor (int i = 0; i < 1 << LOG; i++)\n\t\tif (F[i] + 1 >= G[(1 << LOG) - 1 - i])\n\t\t{\n\t\t\tfor (int j = N; j--; )\n\t\t\t\tputs(\"Possible\");\n\t\t\treturn 0;\n\t\t}\n\tfor (int i = 0; i < 1 << LOG; i++)\n\t\tif (RE[0][F[i] + 1] + 1 >= G[(1 << LOG) - 1 - i])\n\t\t{\n\t\t\tint R = RE[0][F[i] + 1], L = LE[0][R];\n\t\t\tif (!OK[L])\n\t\t\t\tstd::fill(OK + L, OK + R + 1, 1);\n\t\t}\n\tfor (int i = 1; i <= N; i++)\n\t\tputs(OK[i] ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\nint N, V;\nint p[200005], d[200005];\nint K, v[25];\nint rgt[200005];\nint bst[400005];\nbool can[200005];\n\nclass Solver\n{\npublic:\n    int dst[200005];\n    int lgt[200005][22];\n    int dp[400005];\n\n    Solver()\n    {\n        memset(dst, 0, sizeof(dst));\n        memset(lgt, 0, sizeof(lgt));\n        memset(dp, 0, sizeof(dp));\n        for(int i = 1; i < N; i++)  dst[i] = d[i];\n    }\n\n    void precalc()\n    {\n        for(int i = N; i >= 1; i--)\n            for(int j = 0; j <= K; j++)\n            {\n                if(dst[i] <= v[j])  lgt[i][j] = lgt[i + 1][j] + 1;\n                else    lgt[i][j] = 1;\n            }\n        for(int msk = 1; msk < (1 << K); msk++)\n        {\n            for(int b = 0; b < K; b++)\n                if( (1 << b) & msk )\n                {\n                    int mmsk = msk ^ (1 << b);\n                    int pos = dp[mmsk];\n                    dp[msk] = max(dp[msk], pos + lgt[pos + 1][b]);\n                }\n        }\n    }\n};\n\nvoid possible() {printf(\"Possible\\n\");}\nvoid impossible() {printf(\"Impossible\\n\");}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    scanf(\"%d%d\", &N, &V);\n    for(int i = 1; i <= N; i++) scanf(\"%d\", &p[i]);\n    for(int i = 1; i < N; i++)  d[i] = p[i + 1] - p[i];\n\n    K = -1;\n    int aux = V;\n    while(aux)\n    {\n        aux /= 2;\n        v[++K] = aux;\n    }\n    reverse(v, v + K + 1);\n    v[++K] = V;\n\n    Solver pfx;\n    reverse(d + 1, d + N);\n    Solver sfx;\n    reverse(d + 1, d + N);\n\n    pfx.precalc();\n    sfx.precalc();\n\n    int mskmax = (1 << K) - 1;\n    for(int msk = mskmax; msk >= 0; msk--)\n    {\n        can[ pfx.dp[msk] ] = 1;\n        bst[msk] = max(bst[msk], sfx.dp[msk ^ mskmax]);\n        int st = pfx.dp[msk];\n        int dr = bst[msk];\n        rgt[st] = max(rgt[st], dr);\n    }\n\n    for(int i = N - 1; i >= 0; i--) rgt[i] = max(rgt[i], rgt[i + 1]);\n\n    for(int i = 1; i <= N; i++)\n    {\n        int st = i - 1;\n        int dr = N - rgt[st] + 1;\n        int posmax = i + pfx.lgt[i][K] - 1;\n        if(dr - 1 <= posmax && can[st])\n            for(int j = 1; j <= pfx.lgt[i][K]; j++)  possible();\n        else\n            for(int j = 1; j <= pfx.lgt[i][K]; j++)  impossible();\n        i = posmax;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 200005\n#define MAXM 18\n#define MAXK (1<<MAXM)\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\n#define prev daksiisaas\n#define next aijdkjsaod\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\nint N,V,x[MAXN];\nvector<int> v;\nint prev[MAXN][MAXM],next[MAXN][MAXM];\nint predp[MAXK],sufdp[MAXK];\nint ans[MAXN];\nint mini[MAXN];\nint main()\n{\n    scanf(\"%d%d\",&N,&V);\n    for(int i=1;i<=N;i++) scanf(\"%d\",&x[i]);\n    int dummy=V;\n    while(dummy)\n    {\n        v.push_back(dummy);\n        dummy/=2;\n    }\n    v.push_back(0);\n    reverse(v.begin(),v.end());\n    int sz=(int)v.size();\n    for(int i=(int)v.size()-1;i>=0;i--) next[N][i]=N;\n    for(int i=N-1;i>=0;i--)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i+1]-x[i]>v[j]) next[i][j]=i; else next[i][j]=next[i+1][j];\n    for(int i=(int)v.size()-1;i>=0;i--) prev[1][i]=1;\n    for(int i=2;i<=N;i++)\n        for(int j=(int)v.size()-1;j>=0;j--)\n            if(x[i]-x[i-1]>v[j]) prev[i][j]=i; else prev[i][j]=prev[i-1][j];\n    //for(int i=1;i<=N;i++) printf(\"%d %d %d %d\\n\",prev[i][1],prev[i][2],next[i][1],next[i][2]);\n    memset(predp,0,sizeof(predp));\n    predp[0]=1;\n    for(int mask=0;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            predp[mask^(1<<j)]=max(predp[mask^(1<<j)],next[min(predp[mask]+1,N)][j]);\n        }\n    }\n    for(int mask=0;mask<(1<<sz);mask++) sufdp[mask]=N;\n    sufdp[0]=N;\n    for(int mask=0;mask<(1<<sz);mask++)\n    {\n        for(int j=0;j<sz;j++)\n        {\n            if(mask&(1<<j)) continue;\n            sufdp[mask^(1<<j)]=min(sufdp[mask^(1<<j)],prev[max(sufdp[mask]-1,1)][j]);\n        }\n    }\n    for(int i=0;i<=N+1;i++) mini[i]=N+2; \n    for(int mask=0;mask<(1<<(sz-1));mask++)\n    {\n        int dmask=(1<<(sz-1))-1-mask;\n        int l,r;\n        if(mask==0) l=0; else l=predp[mask];\n        if(dmask==0) r=N+1; else r=sufdp[dmask];\n        //printf(\"%d %d %d %d\\n\",mask,dmask,l,r);\n        mini[l]=min(mini[l],r);\n    }\n    for(int i=N;i>=0;i--) mini[i]=min(mini[i],mini[i+1]);\n    for(int i=1;i<=N;i++)\n    {\n        int l=prev[i][sz-1],r=next[i][sz-1];\n        //printf(\"%d %d\\n\",l,r);\n        if(mini[l-1]<=r+1) puts(\"Possible\"); else puts(\"Impossible\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\n#include <cstdlib>\n\nusing std::pair;\ntypedef pair<int,int> pii;\nconst int N = 200010;\nconst int M = 19;\nint _w;\n\nint max( int a, int b ) {\n\treturn a > b ? a : b;\n}\n\nint n, v, x[N], m;\n\nint ans[N];\nvoid answer() {\n\tfor( int i = 1; i <= n; ++i )\n\t\tputs( ans[i] ? \"Possible\" : \"Impossible\" );\n\texit(0);\n}\n\nint R[M][N];\nvoid prelude() {\n\tint t = v;\n\tfor( m = 0; ; ++m, t >>= 1 ) {\n\t\tR[m][n] = R[m][n+1] = n;\n\t\tfor( int j = n-1; j >= 1; --j )\n\t\t\tif( x[j+1] - x[j] > t )\n\t\t\t\tR[m][j] = j;\n\t\t\telse R[m][j] = R[m][j+1];\n\t\tif( !t ) break;\n\t}\n\t++m;\n}\n\nint f[1<<M];\nbool check( int l, int r ) {\n\tmemset(f, 0, sizeof f);\n\tif( l == 1 ) f[0] = r;\n\tfor( int i = 0; i < (1<<m); ++i )\n\t\tfor( int j = 1; j < m; ++j )\n\t\t\tif( (i&(1<<j)) == 0 ) {\n\t\t\t\tint k = i|(1<<j);\n\t\t\t\tf[k] = max( f[k], R[j][f[i]+1] );\n\t\t\t\tif( f[k] >= l-1 && f[k] <= r )\n\t\t\t\t\tf[k] = r;\n\t\t\t}\n\treturn f[(1<<m)-2] == n;\n}\n\nvoid solve() {\n\tstatic pii tmp[N];\n\tstatic int tn;\n\tfor( int i = 1; i <= n; i = R[0][i]+1 )\n\t\ttmp[tn++] = pii(i, R[0][i]);\n\tif( tn > m ) answer();\n\tfor( int i = 0; i < tn; ++i )\n\t\tif( check(tmp[i].first, tmp[i].second) ) {\n\t\t\tfor( int j = tmp[i].first; j <= tmp[i].second; ++j )\n\t\t\t\tans[j] = 1;\n\t\t}\n\tanswer();\n}\n\nint main() {\n\t_w = scanf( \"%d%d\", &n, &v );\n\tfor( int i = 1; i <= n; ++i )\n\t\t_w = scanf( \"%d\", x+i );\n\tprelude(), solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MN=300000+5;\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T>inline T&IN(T&in){\n\tin=0;char c=getchar();int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1;c=getchar();}\n\twhile(isdigit(c))in=in*10+c-'0',c=getchar();\n\treturn in*=f;\n}\nint n,V;\nint l[20][MN],r[20][MN];\nint fr[MN],fl[MN],s[MN];ll x[MN];\nvoid input(){\n\tIN(n),IN(V);\n\tfor(int i=1;i<=n;++i)IN(x[i]);\n\tint k;x[0]=LLONG_MIN/10,x[n+1]=LLONG_MAX/10;\n\tfor(k=0;V;++k,V>>=1){\n\t\tfor(int i=1;i<=n;++i)l[k][i]=x[i]-x[i-1]>V?i:l[k][i-1];\n\t\tfor(int i=n;i>=1;--i)r[k][i]=x[i+1]-x[i]>V?i:r[k][i+1];\n\t}\n\tfor(int i=1;i<=n;++i)l[k][i]=x[i]-x[i-1]>V?i:l[k][i-1];\n\tfor(int i=n;i>=1;--i)r[k][i]=x[i+1]-x[i]>V?i:r[k][i+1];\n\tfor(int st=0;st<(1<<k);++st){\n\t\tfr[st]=n+1;\n\t\tfor(int i=0;i<k;++i)if(st>>i&1){\n\t\t\tfl[st]=max(fl[st],r[i+1][fl[st^(1<<i)]+1]);\n\t\t\tfr[st]=min(fr[st],l[i+1][fr[st^(1<<i)]-1]);\n\t\t}\n\t}\n\tfor(int st=0;st<(1<<k);++st){\n\t\tint L=l[0][fr[((1<<k)-1)^st]-1],R=r[0][fl[st]+1];\n\t\tif(L<=R)s[L]++,s[R+1]--;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\ts[i]+=s[i-1];\n\t\tputs(s[i]?\"Possible\":\"Impossible\");\n\t}\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 2e05 + 10;\nconst int MAXL = 20 + 5;\n\nint N, V, lgv = 0;\nint a[MAXN];\nint sec[MAXN]= {0};\n\nint extl[MAXN][MAXL]= {0}, extr[MAXN][MAXL]= {0};\nint f[2][MAXN]= {0};\nbool answer[MAXN]= {false};\nvoid work (int p, int l, int r) {\n\tint n = lgv - 1;\n\tint limit = (1 << n) - 1;\n\tf[p][0] = l - 1;\n\tfor (int state = 1; state <= limit; state ++) {\n\t\tf[p][state] = l - 1;\n\t\tfor (int j = 1; j <= n; j ++)\n\t\t\tif (state & (1 << (j - 1))) {\n\t\t\t\tint pre = f[p][state ^ (1 << (j - 1))];\n\t\t\t\tf[p][state] = max (f[p][state], extr[pre + 1][j]);\n\t\t\t}\n\t}\n}\nvoid solve () {\n\tint n = lgv - 1;\n\tint cnt = 0;\n\tfor (int i = 1; i <= N; i ++) {\n\t\tif (extl[i][lgv] == extl[i - 1][lgv] && extr[i][lgv] == extr[i - 1][lgv]) {\n\t\t\tanswer[i] = answer[i - 1];\n\t\t\tcontinue;\n\t\t}\n\t\tcnt ++;\n\t\tif (cnt > lgv) {\n\t\t\tfor (int j = 1; j <= N; j ++) answer[j] = false;\n\t\t\treturn ;\n\t\t}\n\t\tint pl = extl[i][lgv], pr = extr[i][lgv];\n\t\tif (pl != 1) work (0, 1, pl - 1);\n\t\tif (pr != N) work (1, pr + 1, N);\n\t\tint limit = (1 << n) - 1;\n\t\tif (pl == 1) answer[i] = f[1][limit] >= N;\n\t\telse if (pr == N) answer[i] = f[0][limit] >= pl - 1;\n\t\telse {\n\t\t\tfor (int state = 1; state <= limit; state ++)\n\t\t\t\tif (f[0][state] >= pl - 1 && f[1][limit ^ state] >= N) {\n\t\t\t\t\tanswer[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint getnum () {\n\tint num = 0;\n\tchar ch = getchar ();\n\tbool isneg = false;\n\n\twhile (! isdigit (ch)) {\n\t\tif (ch == '-') isneg = true;\n\t\tch = getchar ();\n\t}\n\twhile (isdigit (ch))\n\t\tnum = (num << 3) + (num << 1) + ch - '0', ch = getchar ();\n\n\treturn isneg ? - num : num;\n}\n\nint main () {\n\tN = getnum (), V = getnum ();\n\tfor (int i = 1; i <= N; i ++)\n\t\ta[i] = getnum ();\n\tfor (int s = V; s > 0; s >>= 1)\n\t\tsec[++ lgv] = s;\n\tsec[++ lgv] = 0;\n\treverse (sec + 1, sec + lgv + 1);\n\tfor (int l = 1; l <= lgv; l ++) {\n\t\textl[0][l] = 1, extr[N + 1][l] = N;\n\t\tfor (int i = 1; i <= N; i ++) {\n\t\t\tif (i == 1) extl[i][l] = 1;\n\t\t\telse extl[i][l] = a[i] - a[i - 1] <= sec[l] ? extl[i - 1][l] : i;\n\t\t}\n\t\tfor (int i = N; i >= 1; i --) {\n\t\t\tif (i == N) extr[i][l] = N;\n\t\t\telse extr[i][l] = a[i + 1] - a[i] <= sec[l] ? extr[i + 1][l] : i;\n\t\t}\n\t}\n\t/*for (int l = 1; l <= lgv; l ++) {\n\t\tcout << \"now: \" << sec[l] << endl;\n\t\tfor (int i = 1; i <= N; i ++)\n\t\t\tcout << extl[i][l] << ' ' << extr[i][l] << endl;\n\t}*/\n\tsolve ();\n\tfor (int i = 1; i <= N; i ++)\n\t\tanswer[i] ? puts (\"Possible\") : puts (\"Impossible\");\n\n\treturn 0;\n}\n\n/*\n3 2\n1 3 6\n*/\n\n/*\n7 2\n-10 -4 -2 0 2 4 10\n*/\n\n/*\n16 19\n-49 -48 -33 -30 -21 -14 0 15 19 23 44 52 80 81 82 84\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n\n#define MAXN 200005\n#define MAXB 21\n\nusing namespace std;\n\nconst int INF = 1e9 + 2e6;\nint v[MAXN], n, m;\nint d[MAXN], up[MAXN][MAXB], down[MAXN][MAXB], pre[1 << MAXB], suf[1 << MAXB];\nint visit[MAXN];\n\nint read() {\n    char c = getchar();\n    int x = 0, s = 1;\n    while (!isdigit(c)) {\n        if (c == '-')\n            s = -1;\n        c = getchar();\n    }\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x * s;\n}\n\nvoid init() {\n    while (v[++m] >= 1)\n        v[m + 1] = v[m] >> 1;\n    d[0] = -INF;\n    d[n + 1] = INF;\n    for (int j = 1; j <= m; ++j) {\n        for (int i = 1; i <= n; ++i)\n            if (d[i] - d[i - 1] <= v[j])\n                up[i][j] = up[i - 1][j];\n            else\n                up[i][j] = i;\n        for (int i = n; i >= 1; --i)\n            if (d[i + 1] - d[i] <= v[j])\n                down[i][j] = down[i + 1][j];\n            else\n                down[i][j] = i;\n    }\n}\n\nvoid solve() {\n    memset(suf, 0x3f, sizeof(suf));\n    memset(pre, -0x3f, sizeof(pre));\n    suf[0] = n + 1;\n    pre[0] = 0;\n    int limit = (1 << m) - 1;\n    for (int s = 0; s <= limit; ++s) {\n        for (int i = 1; i <= m; ++i) {\n            if (s >> (i - 1) & 1)\n                continue;\n            int t = s | (1 << (i - 1));\n            if (pre[s] >= 0)\n                pre[t] = max(pre[t], down[pre[s] + 1][i]);\n            if (suf[s] <= n + 1)\n                suf[t] = min(suf[t], up[suf[s] - 1][i]);\n        }\n    }\n    for (int s = 1; s < limit; ++s) {\n        if (s & 1)\n            continue;\n        int t = limit ^ s;\n        t ^= 1;\n        if (suf[t] - pre[s] <= 2) {\n            ++visit[1];\n            --visit[n + 1];\n        }\n        if (down[pre[s] + 1][1] >= suf[t] - 1) {\n            ++visit[up[pre[s] + 1][1]];\n            --visit[down[pre[s] + 1][1] + 1];\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n        visit[i] = visit[i - 1] + visit[i];\n    for (int i = 1; i <= n; ++i)\n        if (visit[i])\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n}\n\nint main() {\n    n = read();\n    v[1] = read();\n    for (int i = 1; i <= n; ++i)\n        d[i] = read();\n    init();\n    solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MaxN=2e5+5;\n\nint N,M=1;\nint V[20],X[MaxN],Mn[MaxN];\nint L[MaxN][20],R[MaxN][20],F[1<<18],G[1<<18];\n\nint main(){\n\tint i,j,l,r;\n\tscanf(\"%d%d\",&N,&V[0]);\n\tfor(i=V[0]>>1;i;i>>=1)\n\t\tV[M++]=i;\n\tM++;\n\tfor(i=1;i<=N;i++)\n\t\tscanf(\"%d\",&X[i]);\n\tfor(i=0;i<M;i++)\n\t\tL[1][i]=1,R[N][i]=N;\n\tfor(i=2;i<=N;i++)\n\t\tfor(j=0;j<M;j++)\n\t\t\tif(X[i]-X[i-1]<=V[j])\n\t\t\t\tL[i][j]=L[i-1][j];\n\t\t\telse L[i][j]=i-(j<M-1);\n\tfor(i=N-1;i;i--)\n\t\tfor(j=0;j<M;j++)\n\t\t\tif(X[i+1]-X[i]<=V[j])\n\t\t\t\tR[i][j]=R[i+1][j];\n\t\t\telse R[i][j]=i+(j<M-1);\n\tF[0]=1;\n\tfor(i=0;i<1<<M;i++){\n\t\tif(!i)\n\t\t\tj=M;\n\t\telse for(j=0;~i>>j&1;j++);\n\t\tfor(j--;~j;j--)\n\t\t\tF[i|1<<j]=max(F[i|1<<j],R[F[i]][j]);\n\t}\n\tmemset(G,0x3f,sizeof(G));\n\tG[0]=N;\n\tfor(i=0;i<1<<M;i++){\n\t\tif(!i)\n\t\t\tj=M;\n\t\telse for(j=0;~i>>j&1;j++);\n\t\tfor(j--;~j;j--)\n\t\t\tG[i|1<<j]=min(G[i|1<<j],L[G[i]][j]);\n\t}\n\tmemset(Mn,0x3f,sizeof(Mn));\n\tfor(i=0;i<1<<M;i++)\n\t\tMn[F[i]]=min(Mn[F[i]],G[(1<<M)-1-i]);\n\tfor(i=N-1;i;i--)\n\t\tMn[i]=min(Mn[i],Mn[i+1]);\n\tfor(i=1;i<=N;i++)\n\t\tputs(Mn[L[i][0]]<=R[i][0]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong long x[210000];\nint sa[210000];\nint nx_L[19][210000];\nint nx_R[19][210000];\n\nint d[20];\nint L[1<<19];\nint R[1<<19];\npair<int,int>p[1<<19];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lld\",x+i);\n\t}\n\td[0]=b;\n\tint n=1;\n\tfor(int i=0;d[i];i++){\n\t\td[i+1]=d[i]/2;\n\t\tn=i+2;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tint to=a;\n\t\tnx_L[i][a]=a;\n\t\tfor(int j=a-1;j>=0;j--){\n\t\t\tnx_L[i][j]=to;\n\t\t\tif(j&&x[j]-x[j-1]>d[i])to=j;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tint to=a;\n\t\tnx_R[i][a]=a;\n\t\tfor(int j=a-1;j>=0;j--){\n\t\t\tnx_R[i][j]=to;\n\t\t\tif(j&&x[a-j]-x[a-1-j]>d[i])to=j;\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<n);i++){\n\t\tint at=L[i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i&(1<<j))continue;\n\t\t\tint to=nx_L[j][at];\n\t\t\tL[i+(1<<j)]=max(L[i+(1<<j)],to);\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<n);i++){\n\t\tint at=R[i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i&(1<<j))continue;\n\t\t\tint to=nx_R[j][at];\n\t\t\tR[i+(1<<j)]=max(R[i+(1<<j)],to);\n\t\t}\n\t}\n\tint sz=0;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tif(i&1);\n\t\telse{\n\t\t\tp[sz++]=make_pair(L[i],i);\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tprintf(\"%d: \",d[i]);\n\t\tfor(int j=0;j<a;j++)printf(\"%d \",nx_L[i][j]);\n\t\t\tprintf(\"\\n\");\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%d: \",d[i]);\n\t\tfor(int j=0;j<a;j++)printf(\"%d \",nx_R[i][j]);\n\t\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tstd::sort(p,p+sz);\n\tset<pair<int,int> >S;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tif(i&1);\n\t\telse{\n\t\t\tS.insert(make_pair(R[i],i));\n\t\t}\n\t}\n\tint at=0;\n\tfor(int i=0;i<a;i++){\n\t\tint lq=a-nx_R[0][a-1-i];\n\t\tint rq=a-nx_L[0][i];\n\t\twhile(at<sz&&p[at].first<lq){\n\t\t\tS.erase(make_pair(R[(1<<n)-2-p[at].second],(1<<n)-2-p[at].second));\n\t\t\tat++;\n\t\t}\n\t\t//printf(\"%d %d\\n\",lq,rq);\n\t\tif(S.size()){\n\t\t\tpair<int,int> tp=*(S.rbegin());\n\t\t\tif(tp.first>=rq)printf(\"Possible\\n\");\n\t\t\telse printf(\"Impossible\\n\");\n\t\t}else{\n\t\t\tif(at<sz&&rq==0)printf(\"Possible\\n\");\n\t\t\telse printf(\"Impossible\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cout << #x\" = \" << x;\n\n#define st first\n#define nd second\n\nusing namespace std;\nusing namespace placeholders;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\nconst int MAXN = 2E5 + 10, MAXD = 19;\n\nint n, V;\nint a[MAXN];\nint pre[MAXD][MAXN], nex[MAXD][MAXN];\nint prem[1 << MAXD], sufm[1 << MAXD];\n\nint cnt[MAXN];\n\nint main(){\n\tscanf(\"%d%d\", &n, &V);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", a + i);\n\t\n\tint D = 32 - __builtin_clz(V);\n\tfor (int k = 0; k <= D; ++k){\n\t\tint len = V >> D - k;\n\t\tpre[k][0] = 1;\n\t\tfor (int j, i = 1; i <= n; i = j){\n\t\t\tpre[k][i] = i;\n\t\t\tfor (j = i + 1; j <= n && a[j] - a[j - 1] <= len; ++j)\n\t\t\t\tpre[k][j] = i;\n\t\t}\n\t\tnex[k][n + 1] = n;\n\t\tfor (int j, i = n; i >= 1; i = j){\n\t\t\tnex[k][i] = i;\n\t\t\tfor (j = i - 1; j >= 1 && a[j + 1] - a[j] <= len; --j)\n\t\t\t\tnex[k][j] = i;\n\t\t}\n\t}\n\n\tint n0 = 1 << D;\n\tprem[0] = 0, sufm[0] = n + 1;\n\tfor (int i = 1; i < n0; ++i){\n\t\tprem[i] = 0;\n\t\tfor (int j = 0; j < D; ++j)\n\t\t\tif (i >> j & 1)\n\t\t\t\tprem[i] = max(prem[i], nex[j][prem[i ^ 1 << j] + 1]);\n\t}\n\tfor (int i = 1; i < n0; ++i){\n\t\tsufm[i] = n + 1;\n\t\tfor (int j = 0; j < D; ++j)\n\t\t\tif (i >> j & 1)\n\t\t\t\tsufm[i] = min(sufm[i], pre[j][sufm[i ^ 1 << j] - 1]);\n\t}\n\n\tfor (int i = 0; i < n0; ++i){\n\t\tint l = prem[i] + 1, r = sufm[n0 - 1 ^ i] - 1;\n\t\tif (l > r){\n\t\t\t++cnt[1], --cnt[n + 1];\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tif (nex[D][l] >= r)\n\t\t\t\t++cnt[l], --cnt[nex[D][l] + 1];\n\t\t\tif (pre[D][r] <= l)\n\t\t\t\t++cnt[pre[D][r]], --cnt[r + 1];\n\t\t}\n\t}\n\n\tpartial_sum(cnt + 1, cnt + n + 1, cnt + 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tputs(cnt[i] ? \"Possible\" : \"Impossible\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define MAX(x,y) x=max(x,y)\n#define MIN(x,y) x=min(x,y)\n#define inf 0x3f3f3f3f\nusing namespace std;\n\nconst int N=400005;\n\nint n,v,g[N*2],f[N*2],bin[25],tot,len[25],lef[25][N],rig[25][N],a[N],bel[N],p1[N],p2[N];\nbool ans[N];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nvoid dp()\n{\n\tbin[0]=1;\n\tfor (int i=1;i<=tot;i++) bin[i]=bin[i-1]*2;\n\tfor (int i=0;i<bin[tot];i++) g[i]=n+1;\n\tfor (int i=0;i<bin[tot];i++)\n\t\tfor (int j=0;j<=tot;j++)\n\t\t\tif (!(i&bin[j])) MAX(f[i+bin[j]],rig[j][f[i]+1]),MIN(g[i+bin[j]],lef[j][g[i]-1]);\n\tfor (int i=0;i<bin[tot];i++)\n\t{\n\t\tint l=f[i],r=g[i^(bin[tot]-1)];\n\t\tif (l+1>=r)\n\t\t{\n\t\t\tfor (int j=1;j<=n;j++) ans[j]=1;\n\t\t\treturn;\n\t\t}\n\t\tif (p1[bel[l+1]]<=l+1&&p2[bel[l+1]]>=r-1) ans[bel[l+1]]=1;\n\t}\n}\n\nint main()\n{\n\tn=read();v=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n\ttot=0;len[0]=0;\n\twhile (v) len[++tot]=v,v>>=1;\n\tsort(len,len+tot+1);\n\tmemset(lef,inf,sizeof(lef));\n\tfor (int i=0;i<tot;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tint l=j;\n\t\t\twhile (l<n&&a[l+1]-a[l]<=len[i]) l++;\n\t\t\trig[i][j]=l;lef[i][l]=j;j=l;\n\t\t}\n\tint id=0;\n\tfor (int j=1;j<=n;j++)\n\t{\n\t\tint l=j;bel[j]=++id;\n\t\twhile (l<n&&a[l+1]-a[l]<=len[tot]) l++,bel[l]=id;\n\t\tp1[id]=j;p2[id]=l;j=l;\n\t}\n\tdp();\n\tfor (int i=1;i<=n;i++) puts(ans[bel[i]]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nconst int maxn=400100;\nint dpl[maxn],dpr[maxn];\nint val[maxn];\nint nex[maxn][20],las[maxn][20];\nint a[maxn];\nint b[20],k=-1;\nint f[maxn];\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n//\tfreopen(\"E.out\",\"w\",stdout);\n\tint n,v;\n\tscanf(\"%d%d\",&n,&v);\n\twhile(v){\n\t\tb[++k]=v;\n\t\tv/=2;\n\t}\n\tb[++k]=0;\n\tfor(int i=0;i<=k;i++)\n\t\tif(i<k-i)\n\t\t\tswap(b[i],b[k-i]);\n\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int j=0;j<=k;j++)\n\t{\n\t\tnex[n][j]=n;\n\t\tnex[n+1][j]=n;\n\t\tlas[1][j]=1;\n\t\tlas[0][j]=1;\n\t}\n\tfor(int i=n-1;i>=1;i--)\n\t\tfor(int j=0;j<=k;j++)\n\t\t{\n\t\t\tif(a[i+1]-a[i]<=b[j])\n\t\t\t\tnex[i][j]=nex[i+1][j];\n\t\t\telse\n\t\t\t\tnex[i][j]=i;\n\t\t}\n\tfor(int i=2;i<=n;i++)\n\t\tfor(int j=0;j<=k;j++)\n\t\t{\n\t\t\tif(a[i]-a[i-1]<=b[j])\n\t\t\t\tlas[i][j]=las[i-1][j];\n\t\t\telse\n\t\t\t\tlas[i][j]=i;\n\t\t}\n\n\n\tfor(int i=0;i<(1<<k);i++){\n\t\tfor(int j=0;j<k;j++){\n\t\t\tif(i&(1<<j)) continue;\n\t\t\tif(nex[dpl[i]+1][j]>dpl[i|(1<<j)])\n\t\t\t\tdpl[i|(1<<j)]=nex[dpl[i]+1][j];\n\t\t}\n\t}\n\n\tfor(int i=0;i<(1<<k);i++)\n\t\tdpr[i]=n+1;\n\tfor(int i=0;i<(1<<k);i++){\n\t\tfor(int j=0;j<k;j++){\n\t\t\tif(i&(1<<j)) continue;\n\t\t\tif(las[dpr[i]-1][j]<dpr[i|(1<<j)])\n\t\t\t\tdpr[i|(1<<j)]=las[dpr[i]-1][j];\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;i++)\n\t\tf[i]=n+1;\n\tfor(int i=0;i<(1<<k);i++)\n\t\tif(dpr[((1<<k)-1)^i]-1<f[dpl[i]+1])\n\t\t\tf[dpl[i]+1]=dpr[((1<<k)-1)^i]-1;\n\n\tint r,mn;\n\tfor(int i=1;i<=n;i=r+1){\n\t\tr=nex[i][k],mn=n+1;\n\t\tfor(int j=i;j<=r;j++)\n\t\t\tif(f[j]<mn) mn=f[j];\n\t\tif(mn<=r){\n\t\t\tfor(int j=i;j<=r;j++)\n\t\t\t\tprintf(\"Possible\\n\");\n\t\t}\n\t\telse{\n\t\t\tfor(int j=i;j<=r;j++)\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=200010,SH=18,SN=1<<SH,INF=0x7f7f7f7f;\nint tol[N][SH],tor[N][SH];\nint fl[SN],fr[SN];\nint x[N],v[N];\nint ext[N];\nint main(){\n\tint n=ni,vs=0;\n\tv[0]=ni;\n\tfor(int &i=vs;v[i];i++){\n\t\tv[i+1]=v[i]>>1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tx[i]=ni;\n\t}\n\tfor(int j=0;j<=vs;j++){\n\t\tx[0]=-INF;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ttol[i][j]=x[i]-x[i-1]<=v[j]?tol[i-1][j]:i;\n\t\t}\n\t\tx[n+1]=INF;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\ttor[i][j]=x[i+1]-x[i]<=v[j]?tor[i+1][j]:i;\n\t\t}\n\t}\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tfl[s]=0;\n\t\tfor(int i=1;i<=vs;i++){\n\t\t\tif((s>>(i-1))&1){\n\t\t\t\tapmax(fl[s],tor[fl[s^(1<<(i-1))]+1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tfr[s]=n+1;\n\t\tfor(int i=1;i<=vs;i++){\n\t\t\tif((s>>(i-1))&1){\n\t\t\t\tapmin(fr[s],tol[fr[s^(1<<(i-1))]-1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(ext,127,sizeof(ext));\n\tfor(int s=0,ts=1<<vs;s<ts;s++){\n\t\tapmin(ext[fl[s]],fr[s^(ts-1)]);\n\t}\n\tfor(int i=n;i>=1;i--){\n\t\tapmin(ext[i-1],ext[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tputs(ext[tol[i][0]-1]<=tor[i][0]+1?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 10.01.2020 23:57:48       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, v;\n  cin >> n >> v;\n  vector<int> x(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i];\n  }\n  vector<int> vs(1, v / 2);\n  while (vs.back() > 0) {\n    vs.push_back(vs.back() / 2);\n  }\n  int cnt = (int) vs.size();\n  vector<pair<int, int>> segs;\n  int beg = 0;\n  while (beg < n) {\n    int end = beg;\n    while (end + 1 < n && x[end + 1] - x[end] <= v) {\n      ++end;\n    }\n    segs.emplace_back(beg, end);\n    beg = end + 1;\n  }\n  if ((int) segs.size() > cnt + 1) {\n    for (int i = 0; i < n; i++) {\n      cout << \"Impossible\" << '\\n';\n    }\n    return 0;\n  }\n  vector<vector<int>> nxt(cnt, vector<int>(n + 1, n));\n  vector<vector<int>> prv(cnt, vector<int>(n + 1, 0));\n  for (int id = 0; id < cnt; id++) {\n    for (int i = n - 1; i >= 0; i--) {\n      if (i < n - 1 && x[i + 1] - x[i] > vs[id]) {\n        nxt[id][i] = i + 1;\n      } else {\n        nxt[id][i] = nxt[id][i + 1];\n      }\n    }\n    for (int i = 1; i <= n; i++) {\n      if (i > 1 && x[i - 1] - x[i - 2] > vs[id]) {\n        prv[id][i] = i - 1;\n      } else {\n        prv[id][i] = prv[id][i - 1];\n      }\n    }\n  }\n  vector<int> pref(1 << cnt, 0);\n  for (int t = 0; t < (1 << cnt); t++) {\n    for (int id = 0; id < cnt; id++) {\n      if (!(t & (1 << id))) {\n        pref[t | (1 << id)] = max(pref[t | (1 << id)], nxt[id][pref[t]]);\n      }\n    }\n  }\n  vector<int> suf(1 << cnt, n);\n  suf[0] = n;\n  for (int t = 0; t < (1 << cnt); t++) {\n    for (int id = 0; id < cnt; id++) {\n      if (!(t & (1 << id))) {\n        suf[t | (1 << id)] = min(suf[t | (1 << id)], prv[id][suf[t]]);\n      }\n    }\n  }\n  for (auto& p : segs) {\n    int from = p.first;\n    int to = p.second;\n    bool ok = false;\n    for (int t = 0; t < (1 << cnt); t++) {\n      ok |= (pref[t] >= from && suf[(1 << cnt) - 1 - t] <= to + 1);\n    }\n    for (int i = from; i <= to; i++) {\n      cout << (ok ? \"Possible\" : \"Impossible\") << '\\n';\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MaxN=2e5+5;\n\nint N,M=1;\nint V[20],X[MaxN],Mn[MaxN];\nint L[MaxN][20],R[MaxN][20],F[1<<18],G[1<<18];\n\nint main(){\n\tint i,j,l,r;\n\tscanf(\"%d%d\",&N,&V[0]);\n\tfor(i=V[0]>>1;i;i>>=1)\n\t\tV[M++]=i;\n\tM++;\n\treverse(V,V+M);\n\tfor(i=1;i<=N;i++)\n\t\tscanf(\"%d\",&X[i]);\n\tfor(i=0;i<M;i++)\n\t\tL[1][i]=1,R[N][i]=N;\n\tfor(i=2;i<=N;i++)\n\t\tfor(j=0;j<M;j++)\n\t\t\tif(X[i]-X[i-1]<=V[j])\n\t\t\t\tL[i][j]=L[i-1][j];\n\t\t\telse L[i][j]=i;\n\tfor(i=N-1;i;i--)\n\t\tfor(j=0;j<M;j++)\n\t\t\tif(X[i+1]-X[i]<=V[j])\n\t\t\t\tR[i][j]=R[i+1][j];\n\t\t\telse R[i][j]=i;\n\tF[0]=0;\n\tfor(i=0;i<1<<M-1;i++)\n\t\tfor(j=0;j<M-1;j++)\n\t\t\tif(~i>>j&1)\n\t\t\t\tF[i|1<<j]=max(F[i|1<<j],F[i]<N?R[F[i]+1][j]:N);\n\tmemset(G,0x3f,sizeof(G));\n\tG[0]=N+1;\n\tfor(i=0;i<1<<M-1;i++)\n\t\tfor(j=0;j<M-1;j++)\n\t\t\tif(~i>>j&1)\n\t\t\t\tG[i|1<<j]=min(G[i|1<<j],G[i]>1?L[G[i]-1][j]:1);\n\tmemset(Mn,0x3f,sizeof(Mn));\n\tfor(i=0;i<1<<M-1;i++)\n\t\tMn[F[i]]=min(Mn[F[i]],G[(1<<M-1)-1-i]);\n\tfor(i=N-1;~i;i--)\n\t\tMn[i]=min(Mn[i],Mn[i+1]);\n\tfor(i=1;i<=N;i++)\n\t\tputs(Mn[L[i][M-1]-1]<=R[i][M-1]+1?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=2e5+50;\nint n,v,lg,x[N];\nint len[20], bin[20];\nint mxr[N*4], mnl[N*4];\n\nstruct BIT_MAX {\n\tint bit[N];\n\tBIT_MAX() {for(int i=0;i<N;i++) bit[i]=-1e9;}\n\tinline void inc(int p,int v) {\n\t\tfor(int i=p;i<=n+1;i+=(i&(-i))) bit[i]=max(bit[i],v);\n\t}\n\tinline int ask(int p,int v=-1e9) {\n\t\tfor(int i=p;i;i-=(i&(-i))) v=max(v,bit[i]);\n\t\treturn v;\n\t}\n\tinline void init(int lim) {\n\t\tfor(int l=1,r;l<=n;l=r+1) {\n\t\t\tr=l;\n\t\t\twhile(r<n && x[r+1]-x[r]<=lim) ++r;\n\t\t\tinc(l,r);\n\t\t}\n\t}\n} bit_max[21];\n\nstruct BIT_MIN {\n\tint bit[N];\n\tBIT_MIN() {for(int i=0;i<N;i++) bit[i]=1e9;}\n\tinline void inc(int p,int v) {\n\t\tfor(int i=p;i;i-=(i&(-i))) bit[i]=min(bit[i],v);\n\t}\n\tinline int ask(int p,int v=1e9) {\n\t\tfor(int i=p;i<=n;i+=(i&(-i))) v=min(v,bit[i]);\n\t\treturn v;\n\t}\n\tinline void init(int lim) {\n\t\tfor(int l=1,r;l<=n;l=r+1) {\n\t\t\tr=l;\n\t\t\twhile(r<n && x[r+1]-x[r]<=lim) ++r;\n\t\t\tinc(r,l);\n\t\t}\n\t}\n} bit_min[20];\n\nint ok[N];\nint main() {\n\tn=rd(), v=rd();\n\tfor(int i=1;i<=n;i++) x[i]=rd();\n\t\n\tfor(int t=v;;t/=2) {\n\t\tlen[lg++]=t;\n\t\tif(!t) break;\n\t}\n\tfor(int i=0;i<lg;i++) {\n\t\tbin[i]=1<<i;\n\t\tbit_max[i].init(len[i]);\n\t\tbit_min[i].init(len[i]);\n\t} \n\tmxr[0]=0; mnl[0]=n+1; bin[lg]=1<<lg;\n\tfor(int s=1;s<bin[lg];++s) {\n\t\tif(s&1) continue;\n\t\tint mx=0, mn=n+1;\n\t\tfor(int k=0;k<lg;++k) if(s&bin[k]) {\n\t\t\tmx=max(mx,bit_max[k].ask(mxr[s^bin[k]]+1));\n\t\t\tmn=min(mn,bit_min[k].ask(mnl[s^bin[k]]-1));\n\t\t}\n\t\tmxr[s]=mx; mnl[s]=mn;\n\t}\n\tfor(int i=0;i<bin[lg];++i) {\n\t\tif(!(i&1)) {\n\t\t\tint s1=i, s2=(bin[lg]-1)^1^i;\n\t\t\tbit_max[20].inc(mnl[s2],mxr[s1]);\n\t\t}\n\t}\n\tfor(int l=1,r;l<=n;l=r+1) {\n\t\tr=l;\n\t\twhile(r<n && x[r+1]-x[r]<=v) ++r;\n\t\tif(bit_max[20].ask(r+1)>=l-1) for(int i=l;i<=r;i++) ok[i]=1;\n\t}\n\tfor(int i=1;i<=n;i++) puts((ok[i]) ? \"Possible\" : \"Impossible\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXMASK=(1<<19);\nconst int MAXN=20;\nconst int MAXM=200005;\nint a[MAXM],n,V,mx;\nvector<pii> vec[MAXN];\nint L[MAXN][MAXM],R[MAXN][MAXM];\nvoid work(int x,int o)\n{\n\tfor(int i=1,nxt;i<=n;i=nxt+1)\n\t{\n\t\tnxt=i;while(nxt+1<=n&&a[nxt+1]-a[nxt]<=x)++nxt;\n\t\tfor(int j=i;j<=nxt;j++)L[o][j]=i,R[o][j]=nxt;\n\t}\n}\nint f[MAXMASK],g[MAXMASK],num[MAXN][MAXMASK],bin[25];\nint main()\n{\n\tbin[1]=1;for(int i=2;i<=20;i++)bin[i]=bin[i-1]<<1;\n\tn=read();V=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tint temp=V;while(temp)work(temp,mx++),temp>>=1;\n\tfor(int i=1;i<=n;i++)L[mx][i]=R[mx][i]=i;\n\tmemset(g,63,sizeof(g));g[0]=n+1;\n\tfor(int i=1;i<bin[mx+1];i++)for(int j=1;j<=mx;j++)if(i&bin[j])\n\t{\n\t\tint pre=f[i^bin[j]];\n\t\tf[i]=max(f[i],R[j][pre+1]);\n\t\tif(pre==n)f[i]=n;\n\t\tpre=g[i^bin[j]];\n\t\tg[i]=min(g[i],L[j][pre-1]);\n\t\tif(pre==1)g[i]=1;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tbool tf=false;\n\t\tfor(int j=0;j<bin[mx+1];j++)\n\t\t{\n\t\t\tint lim1=L[0][i],lim2=R[0][i];\n\t\t\tif(f[j]>=lim1-1&&g[(bin[mx+1]-1)^j]<=lim2+1){tf=true;break;}\n\t\t}\n\t\tif(tf)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define chmax(a,b) a=max(a,b);\n#define N (1<<18)\n#define M 19\nll n,v;\nclass Alpha{\n public:\n ll f[N];\n P g[N][M];\n void setg(ll a[]){\n     for(int k=0;k<M;k++){\n         for(int i=0;i<n;i++)g[i][k]=make_pair(i,i);\n         ll bef=-1e18,pnt=0; a[n]=1e18;\n         for(int i=0;i<=n;i++){\n          if(abs(a[i]-bef)>(v>>k)){\n           for(int j=pnt;j<i;j++)g[j][k]=make_pair(pnt,i-1);\n           pnt=i;   \n          }\n          bef=a[i];\n         }\n         if((v>>k)==0)break;\n     }\n }\n void main(ll a[]){\n  setg(a);   \n  for(int i=0;i<N;i++)f[i]=-1;\n  for(int i=0;i<N;i++){\n      for(int j=0;j<M-1;j++){\n          if(i&(1<<j))continue;\n          chmax(f[i+(1<<j)],g[f[i]+1][j+1].second);\n      }\n  }\n  //for(int i=0;i<16;i++)cout<<f[i]<<\" \";cout<<endl;\n }\n};Alpha L,R;\n\nclass Solve{\n  public:\n  unordered_map<ll,bool> mas;\n  bool main(ll l,ll r){\n      if(mas.size()>30)return 0;\n      if(mas.find(l)!=mas.end()){\n       return mas[l];   \n      }\n      bool res=0;\n      int cnt=0;\n      for(int x=v;x;x>>=1)cnt++;\n      int who=2;\n      for(int i=0;i<cnt;i++)who*=2;cout<<who<<endl;\n      for(int i=0;i<who;i++){\n       int ls=i,rs=who-1-i;\n       if(l-1<=L.f[ls]&&n-1-R.f[rs]<=r+1)res=1;\n      }\n      mas[l]=res;\n      return res;\n  }\n};Solve sv;\n\nll a[N];\nint main(){\n    cin>>n>>v;\n    for(int i=0;i<n;i++)cin>>a[i];\n    L.main(a);\n    for(int i=0;i<n/2;i++)swap(a[i],a[n-i-1]);\n    R.main(a);\n    for(int i=0;i<n;i++){\n     bool ans=sv.main(L.g[i][0].first,L.g[i][0].second);   \n     cout<<(ans?\"Possible\":\"Impossible\")<<endl;\n    }\n return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=2E5+5;\n\nint N,M,K,V;\nint a[Maxn];\nint F[Maxn],G[Maxn];\nint L[20][Maxn],R[20][Maxn];\nchar Ans[50],_1[50]={\"Possible\"},_2[50]={\"Inpossible\"};\n//int nxt[Maxn];\n\ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n\nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1)\n\t\t\t\tMAX(F[i],R[M-j][min(F[i-(1<<j)]+1,N)]),\n\t\t\t\tMIN(G[i],L[M-j][max(G[i-(1<<j)]-1,1)]);\n\t}\n\tfor(int i=1;i<=N;++i)\n\t\tK+=(L[0][i]!=L[0][i-1]);\n\tif(K>20){\n\t\tfor(int i=1;i<=N;++i)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=1,j;i<=N;++i)\n\t\tif(L[0][i]!=L[0][i-1]){\n\t\t\tfor(j=0;j<(1<<M);++j)\n\t\t\t\tif(F[j]>=L[0][i]-1 && G[j]<=R[0][i]+1)\n\t\t\t\t\t{memcpy(Ans,_1,sizeof(_1)); break ;}\n\t\t\tif(j==1<<M) memcpy(Ans,_2,sizeof(_2));\n\t\t\tprintf(\"%s\\n\",Ans);\n\t\t}else printf(\"%s\\n\",Ans);\n/*\tmemset(nxt,-1,sizeof(nxt));\n\tfor(int i=0;i<(1<<M);++i) MAX(nxt[G[(1<<M)-1-i]],F[i]);\n\tfor(int i=1;i<=N+1;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[R[0][i]+1]>=L[0][i]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b);\n#define N (1<<18)\n#define M 18\nll n,v;\nclass Alpha{\n public:\n ll f[N];\n ll g[N][M];\n void setg(ll a[]){\n     for(int k=0;k<M;k++){\n         ll bef=-1e18,pnt=0; a[n]=1e18;\n         for(int i=0;i<=n;i++){\n          if(abs(a[i]-bef)>(v>>k)){\n           for(int j=pnt;j<i;j++)g[j][k]=i-1;\n           pnt=i;   \n          }\n          bef=a[i];\n         }\n         if((v>>k)==0)break;\n     }\n     for(int k=0;k<4;k++){\n     for(int i=0;i<=n;i++){ \n         cout<<g[i][k]<<\" \";\n     }\n     cout<<endl;\n     }cout<<endl;\n }\n void main(ll a[]){\n  setg(a);   \n  for(int i=0;i<N;i++)f[i]=-1;\n  for(int i=0;i<N;i++){\n      for(int j=1;j<M;j++){\n          if(i&(1<<j))continue;\n          chmax(f[i+(1<<j)],g[f[i]+1][j]);\n      }\n  }\n }\n};Alpha L,R;\n\nclass Solve{\n  public:\n  unordered_map<ll,bool> mas;\n  bool main(ll l,ll r){\n      if(mas.size()>M)return 0;\n      if(mas.find(l)!=mas.end()){\n       return mas[l];   \n      }\n      bool res=0;\n      for(int i=0;i<N;i++){\n       int ls=i,rs=N-1-i;\n       if(l-1<=L.f[ls]&&n-1-R.f[rs]<=r+1)res=1;\n      }\n      mas[l]=res;\n      return res;\n  }\n};Solve sv;\n\nll a[N];\nint main(){\n    cin>>n>>v;\n    for(int i=0;i<n;i++)cin>>a[i];\n    L.main(a);\n    for(int i=0;i<n/2;i++)swap(a[i],a[n-i-1]);\n    R.main(a);\n    for(int i=0;i<n;i++){\n     bool ans=sv.main(R.g[i][0],L.g[i][0]);   \n     cout<<(ans?\"Possible\":\"Impossible\")<<endl;\n    }\n return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint n,v,a[200001],fa[200001][21],l[200002][21],r[200002][21],V[21],cnt,fl[1048576],fr[1048576],k,L,R;\nbool b[200001];\n\nint ask(int x,int y) {return fa[x][y]==x?x:fa[x][y]=ask(fa[x][y],y);}\nint getmin(int a,int b) {return a<b?a:b;}\nint getmax(int a,int b) {return a>b?a:b;}\n\nvoid unite(int x,int y,int z)\n{\n\tint p=ask(x,z),q=ask(y,z);\n\tif (p==q) return;\n\tfa[p][z]=q;\n\tl[q][z]=getmin(l[p][z],l[q][z]);\n\tr[q][z]=getmax(r[q][z],r[p][z]);\n}\n\nint main()\n{\t\n\tscanf(\"%d%d\",&n,&v); cnt=-1;\n\tmemset(b,0,sizeof(b));\n\tfor (int i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\twhile (v) V[++cnt]=v,v>>=1; V[++cnt]=0;\n\tfor (int i=0; i<=cnt; i++)\n\t{\n\t\tfor (int j=1; j<=n; j++) fa[j][i]=l[j][i]=r[j][i]=j;\n\t\tfor (int j=1; j<n; j++) if (a[j+1]-a[j]<=V[i]) unite(j,j+1,i);\n\t}\n\tfor (int i=0; i<=cnt; i++) r[n+1][i]=n,l[0][i]=1;\n\tk=(1<<cnt); \n\tfor (int i=0; i<k; i++) fl[i]=0,fr[i]=n+1;\n\tfor (int i=1; i<k; i++)\n\t\tfor (int j=0; j<cnt; j++)\n\t\t\tif ((i>>j)&1)\n\t\t\t{\n\t\t\t\tfl[i]=getmax(fl[i],r[ask(fl[i^(1<<j)]+1,j+1)][j+1]);\n\t\t\t\tfr[i]=getmin(fr[i],l[ask(fr[i^(1<<j)]-1,j+1)][j+1]);\n\t\t\t}\n\tfor (int i=0; i<k; i++)\n\t{\n\t\tL=fl[i]; R=fr[i^(k-1)];\n\t\tif (R<=L+1) \n\t\t{\n\t\t\tfor (int j=1; j<=n; j++) printf(\"Possible\\n\"); \n\t\t\treturn 0;\n\t\t} \n\t\tif (ask(L+1,0)==ask(R-1,0)) b[ask(L+1,0)]=1;\n\t}\n\tfor (int i=1; i<=n; i++) if (b[ask(i,0)]) printf(\"Possible\\n\"); else printf(\"Impossible\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define dis(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 4e5+233;\nint L[22][maxn],R[22][maxn];\nint f[maxn],g[maxn];\nint ans[maxn]; \nint n,V,tmp,x[maxn],v[25];\nint main(){\n\tn = rd(),V = tmp = rd();\n\tRep(i,1,n) x[i] = rd();\n\ttmp /= 2;\n\twhile(tmp){\n\t\tv[++v[0]] = tmp;\n\t\ttmp /= 2;\n\t}\n\tv[++v[0]] = 0;\n\tRep(d,1,v[0]){\n\t\tfor(int i=1,j=-1;i<=n;i=j+1){\n\t\t\tfor(j=i+1;j<=n && x[j]-x[j-1]<=v[d];j++);j--;\n//\t\t\tprintf(\"[%d %d]\\n\",i,j);\n\t\t\tRep(k,i,j){\n\t\t\t\tL[d][k] = i;\n\t\t\t\tR[d][k] = j;\n\t\t\t}\n\t\t}R[d][n+1] = n;L[d][0] = 1;\n\t}\n\t\n\tfor(int i=1,j=-1;i<=n;i=j+1){\n\t\tfor(j=i+1;j<=n && x[j]-x[j-1]<=V;j++);j--;\n//\t\tprintf(\"[%d %d][%d %d]\\n\",i,j,x[j]-x[i],x[j+1]-x[i]);\n\t\tRep(k,i,j){\n\t\t\tL[0][k] = i;\n\t\t\tR[0][k] = j;\n//\t\t\tprintf(\"L[%d][%d] = %d\\n\",V,k,L[0][k]);\n\t\t}\n\t}R[0][n+1] = n;L[0][0] = 1;\n\trep(i,0,1<<v[0]) f[i] = 0;\n\trep(i,0,1<<v[0]){\n\t\tfor(int j=1;j<=v[0];++j){\n\t\t\tif(i>>(j-1)&1^1){\n\t\t\t\tf[i|(1<<(j-1))] = max(f[i|(1<<(j-1))],R[j][f[i]+1]);\n\t\t\t}//如果不包括，那么可以选择 \n\t\t}\n\t}\n\trep(i,0,1<<v[0]) g[i] = n+1;\n\trep(i,0,1<<v[0]){\n\t\tfor(int j=1;j<=v[0];++j){\n\t\t\tif(i>>(j-1)&1^1){\n\t\t\t\tg[i|(1<<(j-1))] = min(g[i|(1<<(j-1))],L[j][g[i]-1]);\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,0,1<<v[0]){\n//\t\tprintf(\"[%d%d%d%d%d] : %d,%d\\n\",i/16%2,i/8%2,i/4%2,i/2%2,i%2,f[i],g[i]);\n//\t}\n\trep(i,0,1<<v[0]){\n\t\tint j=((1<<v[0])-1)^i;\n//\t\tprintf(\"[%d %d]\\n\",i,j);\n\t\tint pos = f[i]+1;\n\t//\tprintf(\"[%d %d]\\n\",f[i],g[j]);\n\t\tif(f[i]+1 > g[j]){\n\t\t\tRep(i,1,n) puts(\"Possible\");\n\t\t\treturn 0;\n\t\t} else\n\t\tif(L[0][pos] <= f[i]+1 && g[j]-1 <= R[0][pos]){\n\t\t\tans[L[0][pos]]++;\n\t\t\tans[R[0][pos]+1]--;\n\t\t}//区间可行 \n\t}\n\tRep(i,1,n) ans[i] += ans[i-1];\n\tRep(i,1,n){\n//\t\tprintf(\"{%d %d}\\n\",L[0][i],R[0][i]);\n\t\tif(ans[i]) puts(\"Possible\");\n\t\t\t  else puts(\"Impossible\");\n\t}\n\treturn 0;\n}\n/*\n5 3\n-4 0 1 2 6\n\n11 12\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b);\n#define N (1<<18)\n#define M 18\nll n,v;\nclass Alpha{\n public:\n ll f[N];\n ll g[N][M];\n void setg(ll a[]){\n     for(int k=0;k<M;k++){\n         ll bef=-1e18,pnt=0; a[n]=1e18;\n         for(int i=0;i<=n;i++){\n          if(abs(a[i]-bef)>(v>>k)){\n           for(int j=pnt;j<i;j++)g[j][k]=i-1;\n           pnt=i;   \n          }\n          bef=a[i];\n         }\n     }/*\n     for(int k=0;k<4;k++){\n     for(int i=0;i<=n;i++){ \n         cout<<g[i][k]<<\" \";\n     }\n     cout<<endl;\n     }cout<<endl;*/\n }\n void main(ll a[]){\n  setg(a);   \n  for(int i=0;i<N;i++)f[i]=-1;\n  for(int i=0;i<N;i++){\n      for(int j=1;j<M;j++){\n          if(i&(1<<j))continue;\n          chmax(f[i+(1<<j)],g[f[i]+1][j]);\n      }\n  }\n }\n};Alpha L,R;\n\nclass Solve{\n  public:\n  unordered_map<ll,bool> mas;\n  bool main(ll l,ll r){\n      if(mas.size()>M)return 0;\n      if(mas.find(l)!=mas.end()){\n       return mas[l];   \n      }\n      bool res=0;\n      for(int i=0;i<N;i++){\n       int ls=i,rs=N-1-i;\n       if(l<=L.f[ls]&&n-1-R.f[rs]<=r)res=1;\n      }\n      mas[l]=res;\n      return res;\n  }\n};Solve sv;\n\nll a[N];\nint main(){\n    cin>>n>>v;\n    for(int i=0;i<n;i++)cin>>a[i];\n    L.main(a);\n    for(int i=0;i<n/2;i++)swap(a[i],a[n-i-1]);\n    R.main(a);\n    for(int i=0;i<n;i++){\n     bool ans=sv.main(R.g[i][0],L.g[i][0]);   \n     cout<<(ans?\"Possible\":\"Impossible\")<<endl;\n    }\n return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nint n,v,m,a[200005],len[25],L[200005][25],R[200005][25],f[1000005],g[1000005];\npriority_queue<int> q;\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\twhile(v) len[m++]=v,v>>=1;len[m++]=0;\n\tfor(int i=0;i<m/2;i++) swap(len[i],len[m-i-1]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tL[i][p]=L[i-1][p];\n\t\t\tif(i==1||a[i]-a[i-1]>len[p]) L[i][p]=i;\n\t\t}\n\t}\n\tfor(int i=n;i;i--){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tR[i][p]=R[i+1][p];\n\t\t\tif(i==n||a[i+1]-a[i]>len[p]) R[i][p]=i;\n\t\t}\n\t}\n\tf[0]=0;g[0]=n+1;\n\tfor(int i=1;i<(1<<m);i++){\n\t\tg[i]=n+1;\n\t\tfor(int p=0;p<m;p++) if(i&(1<<p)){\n\t\t\tf[i]=max(f[i],f[i^(1<<p)]);\n\t\t\tf[i]=max(f[i],R[f[i^(1<<p)]+1][p]);\n\t\t\tg[i]=min(g[i],L[g[i^(1<<p)]-1][p]);\n\t\t}\n\t}\n\tint S=(1<<m-1)-1;\n\tfor(int i=1,pos=0;i<=n;i++){\n\t\twhile(f[pos]>=L[i][m-1]-1&&pos<=S) q.push(S^pos),pos++;\n\t\twhile(!q.empty()&&f[S^q.top()]<L[i][m-1]-1) q.pop();\n\t\tif(q.empty()){\n\t\t\tputs(\"Impossible\");continue;\n\t\t}\n\t\tif(g[q.top()]>R[i][m-1]+1) puts(\"Impossible\");\n\t\telse puts(\"Possible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2018-1-18\n//miaomiao\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define Set(a, v) memset(a, v, sizeof(a))\n#define For(i, a, b) for(int i = (a); i <= (int)(b); ++i)\n\n#define M 18\n#define N (100000+5)\n\nint n, m, dn, pos[N], dis[M], nxt[N][M], beg[N], endd[N];\nint f[1<<M];\n\nbool Solve(int l, int r){\n\tif(l == 1 && r == n) return true;\n\n\tf[0] = 0;\n\t\n\tint tmp;\n\tFor(i, 1, (1<<dn)-1){\n\t\tf[i] = 0;\n\t\tFor(j, 1, dn) if(i & (1<<(j-1))){\n\t\t\ttmp = f[i ^ (1<<(j-1))] + 1;\n\t\t\tif(tmp >= l && tmp <= r) tmp = r+1;\n\n\t\t\tf[i] = max(f[i], nxt[tmp][j]);\n\t\t\tif(f[i]+1 >= l && f[i]+1 <= r) f[i] = r;\n\t\t}\n\t\tif(f[i] >= n) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tFor(i, 1, n) scanf(\"%d\", &pos[i]);\n\t\n\tint st, ed, cnt = 0;\n\tfor(int d = m; d >= 0; d >>= 1){\n\t\tst = 1; if(d != m) dis[++dn] = d;\n\n\t\twhile(st <= n){\n\t\t\ted = st;\n\t\t\twhile(ed < n && pos[ed+1]-pos[ed] <= d) ++ed;\n\t\t\tFor(i, st, ed) nxt[i][dn] = ed;\n\t\t\t\n\t\t\tif(d == m){\n\t\t\t\tbeg[++cnt] = st; endd[cnt] = ed;\n\t\t\t}\n\t\t\tst = ed+1;\n\t\t}\n\n\t\tif(!d) break;\n\t}\n\n\tFor(i, 1, dn) nxt[n+1][i] = n+1;\n//\tFor(i, 1, n) For(j, 1, dn) printf(\"nxt[%d][%d] = %d\\n\", i, j, nxt[i][j]);\n\n\tif(cnt > dn+1){\n\t\tFor(i, 1, n) puts(\"Impossible\"); return 0;\n\t}\n\n\tFor(si, 1, cnt){\n\t//\tprintf(\"%d -> %d free\\n\", beg[si], end[si]);\n\t\tif(Solve(beg[si], endd[si])){\n\t\t\tFor(i, beg[si], endd[si]) puts(\"Possible\");\n\t\t}else{\n\t\t\tFor(i, beg[si], endd[si]) puts(\"Impossible\"); \n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=2E5+5;\n\nint N,M,K,V;\nint a[Maxn];\nint F[Maxn],G[Maxn];\nint L[20][Maxn],R[20][Maxn];\nchar Ans[50],_1[50]={\"Possible\"},_2[50]={\"Impossible\"};\n//int nxt[Maxn];\n\ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n\nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1)\n\t\t\t\tMAX(F[i],R[M-j][min(F[i-(1<<j)]+1,N)]),\n\t\t\t\tMIN(G[i],L[M-j][max(G[i-(1<<j)]-1,1)]);\n\t}\n\tfor(int i=1;i<=N;++i)\n\t\tK+=(L[0][i]!=L[0][i-1]);\n\tif(K>20){\n\t\tfor(int i=1;i<=N;++i)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=1,j;i<=N;++i)\n\t\tif(L[0][i]!=L[0][i-1]){\n\t\t\tfor(j=0;j<(1<<M);++j)\n\t\t\t\tif(F[j]>=L[0][i]-1 && G[j]<=R[0][i]+1)\n\t\t\t\t\t{memcpy(Ans,_1,sizeof(_1)); break ;}\n\t\t\tif(j==1<<M) memcpy(Ans,_2,sizeof(_2));\n\t\t\tprintf(\"%s\\n\",Ans);\n\t\t}else printf(\"%s\\n\",Ans);\n/*\tmemset(nxt,-1,sizeof(nxt));\n\tfor(int i=0;i<(1<<M);++i) MAX(nxt[G[(1<<M)-1-i]],F[i]);\n\tfor(int i=1;i<=N+1;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[R[0][i]+1]>=L[0][i]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=1e6+5;\nint n,m;\nint v,x[maxn],rj[maxn][25],lj[maxn][25];\nint lx[maxn],rx[maxn];\nint mn[maxn];\nint main(){\n\tread(n);read(v);\n\trep(i,1,n)read(x[i]);\n\twhile((1<<m)<=v)m++;m++;\n\trep2(i,0,m){\n\t\tlj[0][i]=1;\n\t\trep(j,1,n)lj[j][i]=(x[j]-x[j-1]<=(v>>i))?lj[j-1][i]:j;\n\t\trj[n+1][i]=n;\n\t\tper(j,n,1)rj[j][i]=(x[j+1]-x[j]<=(v>>i))?rj[j+1][i]:j;\n\t}\n\trep2(i,0,1<<m)rx[i]=n+1;\n\trep2(i,0,1<<m)rep2(j,0,m)if(!(i&(1<<j))){\n\t\tlx[i|(1<<j)]=max(lx[i|(1<<j)],rj[lx[i]+1][j]);\n\t\trx[i|(1<<j)]=min(rx[i|(1<<j)],lj[rx[i]-1][j]);\n\t}\n\trep(i,0,n)mn[i]=n+2;\n\trep2(i,0,1<<m)if(!(i&1))mn[lx[i]]=min(mn[lx[i]],rx[((1<<m)-1)^i^1]);\n\tper(i,n-1,0)mn[i]=min(mn[i],mn[i+1]);\n\trep(i,1,n){\n\t\tif(mn[lj[i][0]-1]<=rj[i][0]+1)puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR (i, 0, n)\n#define _ << \" _ \" <<\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define debug\n#define TRACE(x)\n\nusing namespace std;\n\ntypedef long long llint;\n\nconst int MAXN = 200010;\nconst int MAXLG = 22;\nconst int MAXMASK = (1 << MAXLG) + 10;\n\nint n, maxv, x[MAXN], r[MAXN][MAXLG], l[MAXN][MAXLG];\nint dpL[MAXMASK], dpR[MAXMASK], p[MAXN];\n\nint main(void) {\n  scanf(\"%d %d\",&n,&maxv);\n  REP(i, n) scanf(\"%d\",&x[i]);\n\n  int lg = 0;\n  for (int v = maxv; v >= 0; v /= 2, ++lg) {\n    for (int i = n - 1; i >= 0; --i) {\n      r[i][lg] = i;\n      if (i < n - 1 && x[i+1] - x[i] <= v)\n\tr[i][lg] = r[i+1][lg];\n    }\n    for (int i = 0; i < n; ++i) {\n      l[i][lg] = i;\n      if (i > 0 && x[i] - x[i-1] <= v)\n\tl[i][lg] = l[i-1][lg];\n    }\n\n    REP(i, n)\n      TRACE(i _ lg _ l[i][lg] _ r[i][lg]);\n    if (v == 0) break;\n  }\n\n  REP(mask, (1 << (lg + 1)) - 1) {\n    if (mask & 1) continue;\n\n    dpL[mask] = -1;\n    dpR[mask] = n;\n\n    REP(j, lg + 1)\n      if (mask & (1 << j)) {\n\tTRACE(j _ dpL[mask & ~(1 << j)]);\n\tif (dpL[mask & ~(1 << j)] == n - 1)\n\t  dpL[mask] = n - 1;\n\telse\n\t  dpL[mask] = max(dpL[mask], r[dpL[mask & ~(1 << j)] + 1][j]);\n\n\tif (dpR[mask & ~(1 << j)] == 0)\n\t  dpR[mask] = 0;\n\telse\n\t  dpR[mask] = min(dpR[mask], l[dpR[mask & ~(1 << j)] - 1][j]);\n      }\n  }\n\n  REP(mask1, (1 << (lg + 1)) - 1) {\n    if (mask1 & 1) continue;\n    int mask2 = ((1 << (lg + 1)) - 1) ^ mask1;\n    if (mask2 & 1) mask2 ^= 1;\n    \n    TRACE(mask1 _ mask2 _ dpL[mask1] _ dpR[mask2]);\n\n    int lo = dpL[mask1] + 1;\n    int hi = dpR[mask2] - 1;\n    if (lo > hi) {\n      ++p[0];\n      --p[n];\n      continue;\n    }\n\n    int from = l[lo][0];\n    int to = r[lo][0];\n\n    if (from <= lo && to >= hi) {\n      ++p[from];\n      --p[to+1];\n    }\n  }\n\n  int curr = 0;\n  REP(i, n) {\n    curr += p[i];\n    if (curr > 0)\n      printf(\"Possible\\n\");\n    else\n      printf(\"Impossible\\n\");\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=1<<18;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nint L[N],R[N],x[N];\nint p[18][N],q[N];\ninline void umin(int &x,int y) { y<x?x=y:0; }\ninline void umax(int &x,int y) { x<y?x=y:0; }\nint main()\n{\n\tint n=gi()-1,v=gi(),i,j,k=v,m=0,u[20]={},s;\n\twhile (k) u[m++]=k>>=1;\n\n\tfor (i=0;i<=n;i++) x[i]=gi();\n\tfor (i=n;i;i--) x[i]-=x[i-1];\n\n\tfor (i=0;i<m;i++) {\n\t\tp[i][n+1]=n+1;\n\t\tfor (j=n;j;j--)\n\t\t\tp[i][j]=x[j]<=u[i]?p[i][j+1]:j;\n\t}\n\tfor (s=0;s<1<<m;s++)\n\t\tfor (i=0;i<m;i++)\n\t\t\tif (!(s>>i&1))\n\t\t\t\tumax(L[s|1<<i],p[i][L[s]+1]);\n\n\tfor (i=0;i<m;i++)\n\t\tfor (j=1;j<=n;j++)\n\t\t\tp[i][j]=x[j]<=u[i]?p[i][j-1]:j;\n\tfor (s=0;s<1<<m;s++) R[s]=n+1;\n\tfor (s=0;s<1<<m;s++)\n\t\tfor (i=0;i<m;i++)\n\t\t\tif (!(s>>i&1))\n\t\t\t\tumin(R[s|1<<i],R[s|1<<i]?p[i][R[s]-1]:0);\n\n\tfor (i=n,q[n+1]=n+1;i;i--)\n\t\tq[i]=x[i]>v?i:q[i+1];\n\tfor (i=0;i<=n;i++) {\n\t\tif (!i||x[i]>v) k=i;\n\t\tfor (s=0;s<1<<m;s++)\n\t\t\tif (L[s]>=k&&R[s^((1<<m)-1)]<=q[i+1])\n\t\t\t\tbreak;\n\t\tputs(s<1<<m?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (1050000)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,m,p[N],cnt,ri[N],le[N];\nvector<int> seg[22];\nvector<int>::iterator it;\nvoid spj(){\n\tif(seg[cnt].size()<=cnt+2)return;\n\tfor(int i=1;i<=n;i++)puts(\"Impossible\");exit(0);\n}\nint getr(int x,int v){\n\tit=upper_bound(seg[x].begin(),seg[x].end(),v);\n\tif(it==seg[x].end())it--;return (*it);\n}\nint getl(int x,int v){\n\tit=lower_bound(seg[x].begin(),seg[x].end(),v);\n\tif(it!=seg[x].begin())it--; return (*it)+1;\n}\nint main(){\n//\tfreopen(\"in.in\",\"r\",stdin);\n//\tfreopen(\"my.out\",\"w\",stdout);\n\tread(n),read(m);\n\tfor(int i=1;i<=n;i++)read(p[i]); p[n+1]=inf,p[0]=-inf;\n//\tcout<<inf<<endl;\n\tfor(cnt=0;(m>>cnt)>0;cnt++);\n\tfor(int i=0;i<=cnt;i++)\n\tfor(int j=1;j<=n;j++)\n\tif(p[j+1]-p[j]>(m>>i))seg[cnt-i].push_back(j);\n//\tcout<<cnt+1<<endl;\n//\tfor(int i=0;i<=cnt;i++){\n//\t\tprintf(\"#%d(%d):\",i,m>>(cnt-i));\n//\t\tfor(int j=0;j<seg[i].size();j++)printf(\"%d \",seg[i][j]); puts(\"\");\n//\t}\n\tspj();\n\tfor(int i=0;i<(1<<cnt);i++)le[i]=n+1,ri[i]=0;\n\tfor(int i=0;i<(1<<cnt);i++)\n\tfor(int j=cnt-1;~j;j--)\n\tif(!(i&(1<<j))){\n\t\tint v=i|(1<<j);\n\t\tri[v]=max(ri[v],getr(j,ri[i]));\n\t\tle[v]=min(le[v],getl(j,le[i]-1));\n\t}\n//\tfor(int i=0;i<(1<<cnt);i++)\n//\tprintf(\"%d %d %d\\n\",i,le[i],ri[i]);\n\tfor(int i=0;i<seg[cnt].size();i++){\n\t\tbool fl=0; int L=(i==0)?1:seg[cnt][i-1]+1,R=seg[cnt][i];\n\t\tfor(int j=0;j<(1<<cnt);j++)\n\t\tif(ri[j]>=L-1&&le[((1<<cnt)-1)^j]<=R+1){fl=1;break;}\n\t\tfor(int tt=L;tt<=R;tt++)\n\t\tif(!fl)puts(\"Impossible\");else puts(\"Possible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nconst int N=270000,LOG=20;\nint x[N],v[N],L[LOG][N],R[LOG][N],val[N],Lf[N],Rf[N],n,k,tot;\nint main(){\n    read(n);\n    read(v[0]);\n    while(v[k]) v[k+1]=v[k]>>1,k++;\n    tot=(1<<k)-1;\n    for(int i=1;i<=n;i++)\n        read(x[i]);\n    for(int i=0;i<=k;i++){\n        L[i][1]=1;\n        for(int j=2;j<=n;j++) \n            if(x[j]-x[j-1]<=v[i]) \n                L[i][j]=L[i][j-1];\n            else L[i][j]=j;\n        R[i][n]=n;\n        for(int j=n-1;j>=0;j--) \n            if(x[j+1]-x[j]<=v[i]) \n                R[i][j]=R[i][j+1];\n            else R[i][j]=j;\n    }\n    for(int i=1;i<=tot;i++) \n        Lf[i]=1,Rf[i]=n;\n    Lf[0]=0,Rf[0]=n+1;\n    for(int i=0;i<=tot;i++)\n        for(int j=1;j<=k;j++) \n            if(!((i>>(j-1))&1)) {\n                Lf[i|(1<<(j-1))]=max(Lf[i|(1<<(j-1))],R[j][Lf[i]+1]);\n                Rf[i|(1<<(j-1))]=min(Rf[i|(1<<(j-1))],L[j][Rf[i]-1]);\n            }\n    for(int i=0;i<=n+1;i++) \n        val[i]=2*n;\n    for(int i=0;i<=tot;i++) \n        val[Lf[i]]=min(val[Lf[i]],Rf[tot^i]);\n    for(int i=n;i>=0;i--) \n        val[i]=min(val[i],val[i+1]);\n    for(int i=1;i<=n;i++) \n        printf(val[L[0][i]-1]<=R[0][i]+1?\"Possible\\n\":\"Impossible\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\nconst int mod = 1e9 + 7;\n\nint n, m, a[200005];\nint lvl[200005];\nint l[1<<19], r[1<<19];\n\nvector<int> dv;\nint prv[19][200005], nxt[19][200005];\n\nvoid solve(int *ans, int nxt[19][200005]){\n\tfor(int i=0; i<n-1; i++){\n\t\tlvl[i] = lower_bound(dv.begin(), dv.end(), a[i+1] - a[i]) - dv.begin();\n\t}\n\tfor(int i=0; i<m; i++){\n\t\tnxt[i][n-1] = n-1;\n\t\tfor(int j=n-2; j>=0; j--){\n\t\t\tif(lvl[j] > i) nxt[i][j] = j;\n\t\t\telse nxt[i][j] = nxt[i][j+1];\n\t\t}\n\t}\n\tans[0] = -1;\n\tfor(int i=0; i<(1<<m); i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif((i >> j) & 1) continue;\n\t\t\tint cur = nxt[j][min(n-1, ans[i] + 1)];\n\t\t\tans[i | (1<<j)] = max(ans[i | (1<<j)], cur);\n\t\t}\n\t}\n}\n\nint dx[200005];\n\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\tdv.push_back(m);\n\twhile(dv.back() >= 1){\n\t\tdv.push_back(dv.back() / 2);\n\t}\n\tsort(dv.begin(), dv.end());\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tm = dv.size();\n\tsolve(l, nxt);\n\tint s = 0;\n\tvector<pi> v;\n\tfor(int i=0; i+1<n; i++){\n\t\tif(lvl[i] == dv.size()){\n\t\t\tv.push_back(pi(s, i));\n\t\t\ts = i+1;\n\t\t}\n\t}\n\tv.push_back(pi(s, n-1));\n\tif(v.size() > 20){\n\t\twhile(n--) puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=0; i<n; i++) a[i] *= -1;\n\treverse(a, a+n);\n\tsolve(r, prv);\t\n\tfor(int i=0; i<(1<<m); i++){\n\t\tr[i] = n - 1 - r[i];\n\t}\n\tfor(int i=0; i<m; i++){\n\t\tfor(int j=0; j<=n-1; j++){\n\t\t\tprv[i][j] = n-1-prv[i][j];\n\t\t}\n\t\treverse(prv[i], prv[i] + n);\n\t//\tfor(int j=0; j<n; j++) printf(\"%d %d %d %d\\n\",i,j,prv[i][j],nxt[i][j]);\n\t}\n\tfor(auto &i : v){\n\t//\tprintf(\"%d %d\\n\", i.first, i.second);\n\t\tfor(int j=0; j<(1<<(m-1)); j++){\n\t\t\tint p = (1 << (m-1)) - j - 1;\n\t\t\tif(l[j] >= i.first - 1 && r[p] <= i.second + 1){\n\t\t\t\tdx[i.first]++;\n\t\t\t\tdx[i.second+1]--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++){\t\n\n\t\tif(i) dx[i] += dx[i-1];\n\t\tif(dx[i]>0) puts(\"Possible\");\n\t\telse puts(\"Impossible\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define ri rd<int>\nusing namespace std;\nconst int maxN = 2e5 + 7;\nconst int maxV = 20;\nconst int maxS = (1 << maxV);\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\ninline void Min(int &x, int y) {if (y < x) x = y;}\ninline void Max(int &x, int y) {if (y > x) x = y;}\n\nint n, m, V;\nint a[maxN], b[maxN];\nint nx[maxV][maxN], pr[maxV][maxN];\nint f[maxS], g[maxS];\n\nstruct dsu {\n\tint mn, mx, fa;\n}fa[maxN];\n\ninline int find(int x) {return (fa[x].fa != x) ? fa[x].fa = find(fa[x].fa) : x;}\n\nvoid merge(int x, int y) {\n\tif (find(x) != find(y)) {\n\t\tMin(fa[find(y)].mn, fa[find(x)].mn);\n\t\tMax(fa[find(y)].mx, fa[find(x)].mx);\n\t\tfa[find(x)].fa = find(y);\n\t}\n}\n\nstruct rec {\n\tint l, r;\n\tinline bool operator < (const rec &v) const {\n\t\treturn r < v.r;\n\t}\n}q[maxS]; int tt;\n\nint main() {\n\n\tn = ri(), m = ri();\n\trep (i, 1, n) a[i] = ri();\n\tfor (int i = m; i > 0; i >>= 1) b[++V] = i; b[++V] = 0;\n\treverse(b+1, b+V+1);\n\t\n\trep (i, 1, n) fa[i] = (dsu){i, i, i};\n\n\trep (j, 1, V) {\n\t\trep (i, 2, n) if (a[i] - a[i - 1] <= b[j]) merge(i, i-1);\n\t\trep (i, 1, n) nx[j][i] = fa[find(i)].mx, pr[j][i] = fa[find(i)].mn;\n\t\tnx[j][n+1] = n;\n\t\tpr[j][0] = 1;\n\t}\n\n\tint mask = (1 << V) - 1;\n\tf[0] = 0;\n\trep (s, 1, mask) {\n\t\tf[s] = 0;\n\t\trep (j, 1, V) if (s >> (j-1) & 1)\n\t\t\tMax(f[s], nx[j][f[s ^ (1 << (j-1))] + 1]);\n\t}\n\tg[0] = n+1;\n\trep (s, 1, mask) {\n\t\tg[s] = n+1;\n\t\trep (j, 1, V) if (s >> (j-1) & 1)\n\t\t\tMin(g[s], pr[j][g[s ^ (1 << (j-1))] - 1]);\n\t}\n\n\trep (s, 1, mask = (1 << (V-1)) - 1)\n\t\tq[++tt] = (rec){f[s], g[mask ^ s]};\n\tsort(q+1, q+tt+1);\n\n\tfor (int i = 1, j = 1, cl = -1; i <= n; ++ i) {\n\t\tint l = fa[find(i)].mn, r = fa[find(i)].mx;\n\t\tfor (; j <= tt && q[j].r <= r+1; ++ j) cl = max(cl, q[j].l);\n\t\tputs(cl >= l - 1 ? \"Possible\" : \"Impossible\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<cmath>\n#include<functional>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nvoid sort(int &a,int &b)\n{\n\tif(a>b)\n\t\tswap(a,b);\n}\nvoid open(const char *s)\n{\n#ifndef ONLINE_JUDGE\n\tchar str[100];\n\tsprintf(str,\"%s.in\",s);\n\tfreopen(str,\"r\",stdin);\n\tsprintf(str,\"%s.out\",s);\n\tfreopen(str,\"w\",stdout);\n#endif\n}\nint rd()\n{\n\tint s=0,c;\n\twhile((c=getchar())<'0'||c>'9');\n\tdo\n\t{\n\t\ts=s*10+c-'0';\n\t}\n\twhile((c=getchar())>='0'&&c<='9');\n\treturn s;\n}\nint upmin(int &a,int b)\n{\n\tif(b<a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint upmax(int &a,int b)\n{\n\tif(b>a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint v[200010];\nint f[1<<21];\nint g[1<<21];\nint l[30][200010];\nint r[30][200020];\nint a[200010];\nint b[200010];\nint main()\n{\n//\topen(\"agc012e\");\n\tint n;\n\tscanf(\"%d%d\",&n,&v[1]);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tint t=1;\n\twhile(1)\n\t{\n\t\tv[t+1]=v[t]/2;\n\t\tt++;\n\t\tif(!v[t])\n\t\t\tbreak;\n\t}\n\tfor(i=1;i<=t;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j==1||a[j]-a[j-1]>v[i])\n\t\t\t\tl[i][j]=j;\n\t\t\telse\n\t\t\t\tl[i][j]=l[i][j-1];\n\t\tfor(j=n;j>=1;j--)\n\t\t\tif(j==n||a[j+1]-a[j]>v[i])\n\t\t\t\tr[i][j]=j;\n\t\t\telse\n\t\t\t\tr[i][j]=r[i][j+1];\n\t}\n\tmemset(f,0,sizeof f);\n\tint all=1<<t;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(f[i]==n)\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],f[i]);\n\t\t\t\telse\n\t\t\t\t\tupmax(f[i|(1<<(j-1))],r[j][f[i]+1]);\n\t\t\t}\n\tfor(i=0;i<all;i++)\n\t\tg[i]=n+1;\n\tfor(i=0;i<all;i++)\n\t\tfor(j=1;j<=t;j++)\n\t\t\tif(!((i>>(j-1))&1))\n\t\t\t{\n\t\t\t\tif(g[i]==1)\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],g[i]);\n\t\t\t\telse\n\t\t\t\t\tupmin(g[i|(1<<(j-1))],l[j][g[i]-1]);\n\t\t\t}\n\tif(f[all-2]>=n)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t\tprintf(\"Possible\\n\");\n\t\treturn 0;\n\t}\n\tfor(i=0;i<all;i++)\n\t\tif(!(i&1)&&(f[i]+r[1][f[i]+1]>=n||g[(all-1)^i^1]<=r[1][f[i]+1]+1))\n\t\t\tb[l[1][f[i]+1]]=1;\n\tint last=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(b[i])\n\t\t\tlast=i;\n\t\tif(l[1][i]<=last||(i<=r[1][1]&&r[1][1]>=g[all-2]-1))\n\t\t\tprintf(\"Possible\\n\");\n\t\telse\n\t\t\tprintf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\n#ifdef _DEBUG\n#define dbg(x) cerr << #x << \":\" << x << endl;\n#else\n#define dbg(x) while(false){}\n#endif\n\n#define fi(a, b) for(int i=a;i<b;++i)\n#define fj(a, b) for(int j=a;j<b;++j)\n\n////////\n\nint const M = 22;\nint const N = (1<<M);\nstring const YES = \"Possible\";\nstring const NO = \"Impossible\";\n\nint n, v, x[N];\nint le[N][M], ri[N][M];\nint cnt;\nstring ans[N];\n\nvoid setAns(string val, int l, int r){\n\tfi(l, r+1) ans[i] = val;\n}\n\nvoid print(){\n\tfi(1, n+1) printf(\"%s\\n\", ans[i].c_str());\n\texit(0);\n}\n\nvoid check(){\n\tint cn = cnt + 1;\n\tint v = 1;\n\twhile(v <= n){\n\t\tv = ri[v][0] + 1;\n\t\t--cn;\n\t}\n\tif(cn < 0){\n\t\tsetAns(NO, 1, n);\n\t\tprint();\n\t}\n}\n\nvoid build(){\n\tint vi = v;\n\tfi(0, M){\n\t\tcnt = i;\n\t\tle[1][i] = x[1];\n\t\tfj(2, n+1){\n\t\t\tif(x[j] - x[j-1] <= vi) le[j][i] = le[j-1][i];\n\t\t\telse le[j][i] = j;\n\t\t}\n\t\tri[n][i] = n;\n\t\tfor(int j=n-1;j>0;--j){\n\t\t\tif(x[j+1] - x[j] <= vi) ri[j][i] = ri[j+1][i];\n\t\t\telse ri[j][i] = j;\n\t\t}\n\t\tif(vi == 0) break;\n\t\tvi /= 2;\n\t}\n}\n\nint dl[N], dr[N];\n\nvoid remax(int &a, int b){\n\ta = max(a, b);\n}\n\nvoid remin(int &a, int b){\n\ta = min(a, b);\n}\n\nvoid calcDp(){\n\tdl[0] = 0;\n\tfi(0, (1<<cnt)){\n\t\tfj(0, cnt){\n\t\t\tif((1<<j)&i) continue;\n\t\t\tremax(dl[((1<<j)^i)], ri[dl[i]+1][j+1]);\n\t\t}\n\t}\n\tfi(0, (1<<cnt)) dr[i] = n+1;\n\tfi(0, (1<<cnt)){\n\t\tfj(0, cnt){ \n\t\t\tif((1<<j)&i) continue;\n\t\t\tif(dr[((1<<j)^i)] == 1) continue;\n\t\t\tremin(dr[(1<<j)^i], le[dr[i]-1][j+1]);\n\t\t}\n\t}\n}\n\nvoid findAnswers(){\n\tint v, nxt;\n\tv = 1;\n\twhile(v <= n){\n\t\tnxt = ri[v][0];\n\t\tbool can = false;\n\t\tfi(0, (1<<(cnt))){\n\t\t\tint maskL = i;\n\t\t\tint maskR = ( ((1<<(cnt))-1) ^ maskL );\n\t\t\tint lb = max(dl[maskL], 1);\n\t\t\tint rb = min(dr[maskR], n);\n\t\t\tif(lb+1 >= v && rb-1 <= nxt){\n\t\t\t\tcan = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(can){\n\t\t\tsetAns(YES, v, nxt);\n\t\t}else{\n\t\t\tsetAns(NO, v, nxt);\n\t\t}\n\t\tv = nxt + 1;\n\t}\n}\n\nvoid solve(){\n\tscanf(\"%d %d\",&n,&v);\n\tfi(1, n+1) scanf(\"%d\",&x[i]);\n\n\tbuild();\n\tdbg(cnt);\n\tcheck();\n\tcalcDp();\n\tfindAnswers();\n\tprint();\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Headers */\n#include <unordered_map>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#define FOR(i,a,b,c) for(int i=(a);i<=(b);i+=(c))\n#define ROF(i,a,b,c) for(int i=(a);i>=(b);i-=(c))\n#define FORL(i,a,b,c) for(long long i=(a);i<=(b);i+=(c))\n#define ROFL(i,a,b,c) for(long long i=(a);i>=(b);i-=(c))\n#define FORR(i,a,b,c) for(register int i=(a);i<=(b);i+=(c))\n#define ROFR(i,a,b,c) for(register int i=(a);i>=(b);i-=(c))\n#define RevEdge(x) x^1\n#define lowbit(x) x&(-x)\n#define LeftChild(x) x<<1\n#define RightChild(x) (x<<1)+1\n#define CLOSE_IN() fclose(stdin);\n#define CLOSE_OUT() fclose(stdout);\n#define FILE_IN(x) freopen(x,\"r\",stdin);\n#define FILE_OUT(x) freopen(x,\"w\",stdout);\n#define IOS(x) std::ios::sync_with_stdio(x)\n#define Dividing() printf(\"-----------------------------------\\n\");\nnamespace FastIO {\n#define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n    const int SIZ = 1 << 21 | 1;\n    char* iS, * iT, ibuff[SIZ], obuff[SIZ], * oS = obuff, * oT = oS + SIZ - 1, fu[110], cc;\n    int fr;\n    inline void out() {\n        fwrite(obuff, 1, oS - obuff, stdout);\n        oS = obuff;\n    }\n    template<class Type>\n    inline void read(Type& x) {\n        x = 0;\n        Type y = 1;\n        for (cc = gc(); (cc > '9' || cc < '0') && cc != '-'; cc = gc());\n        cc == '-' ? y = -1 : x = (cc & 15);\n        for (cc = gc(); cc >= '0' && cc <= '9'; cc = gc())\n            x = x * 10 + (cc & 15);\n        x *= y;\n    }\n    template<class Type>\n    inline void print(Type x, char text = '\\n') {\n        if (x < 0)\n            * oS++ = '-', x *= -1;\n        if (x == 0)\n            * oS++ = '0';\n        while (x)\n            fu[++fr] = x % 10 + '0', x /= 10;\n        while (fr);\n            * oS++ = fu[fr--];\n        * oS++ = text;\n        out();\n    }\n    inline void prints(char x[], char text = '\\n') {\n        for (register int i = 0; x[i]; ++i)\n            * oS++ = x[i];\n        * oS++ = text;\n        out();\n    }\n}\nusing namespace FastIO;\ntemplate<typename T>\ninline T max(T a, T b) {return (a > b) ? a : b;}\ntemplate<typename T>\ninline T min(T a, T b) {return (a > b) ? b : a;}\n/* definitions */\n#define pii std::pair<int, int>\n#define mp std::make_pair\n#define fi first\n#define se second\nconst int inf = 0x3f3f3f3f, MAXN = 2e5 + 10;\nint n, v, dep, pos[MAXN], L[20][MAXN], R[20][MAXN], maxl[MAXN << 4], maxr[MAXN << 4];\nbool ans[MAXN];\npii seg[MAXN];\n/* functions */\nint main(int argc, char *argv[]) {\n    /*FILE_IN(\"data.in\");*/ read(n); read(v);\n    FOR(i, 1, n, 1) read(pos[i]);\n    pos[0] = -inf - v - 1; pos[n + 1] = inf + v + 1;\n    for(int k = v; k >= 0; k >>= 1, dep++) {\n        R[dep][n + 1] = n + 1;\n        FOR(i, 1, n, 1) L[dep][i] = (pos[i] - pos[i - 1] <= k) ? L[dep][i - 1] : i;\n        ROF(i, n, 1, 1) R[dep][i] = (pos[i + 1] - pos[i] <= k) ? R[dep][i + 1] : i;\n        if(k == 0) {dep++; break;}\n    }\n    FOR(i, 1, n, 1) seg[i] = mp(L[0][i], R[0][i]);\n    int cnt = std::unique(seg + 1, seg + n + 1) - (seg + 1);\n    FOR(i, 0, (1 << dep) - 1, 1) maxr[i] = n + 1;\n    FOR(s, 0, (1 << dep) - 1, 2)\n        FOR(i, 0, dep - 1, 1) {\n            if(!(s & (1 << i))) continue;\n            maxl[s] = max(maxl[s], R[i][maxl[s ^ (1 << i)] + 1]);\n            maxr[s] = min(maxr[s], L[i][maxr[s ^ (1 << i)] - 1]);\n        }\n    if(cnt > dep) {FOR(i, 1, n, 1) puts(\"Impossible\"); return 0;}\n    FOR(i, 1, cnt, 1)\n        FOR(s, 0, (1 << dep) - 1, 2)\n            if(maxl[s] >= seg[i].fi - 1 && maxr[(1 << dep) - 2 - s] <= seg[i].se + 1) {\n                FOR(j, seg[i].fi, seg[i].se, 1) ans[j] = 1; break;\n            }\n    FOR(i, 1, n, 1) puts(ans[i] ? \"Possible\" : \"Impossible\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,v,x[200005];\nint go[200005][20],go2[200005][20];\nint dp[(1<<20)],dp2[(1<<20)];\nint used[200005];\nP p[200005];\n\nint main(){\n\tcin>>n>>v;\n\trepn(i,n)cin>>x[i];\n\tvector<int>vi;\n\twhile(1){\n\t\tvi.pb(v);\n\t\tif(v == 0) break;\n\t\tv/=2;\n\t}\n\trep(j,vi.size()){\n\t\tvector<int>vec;\n\t\trepn(i,n-1){\n\t\t\tif(x[i+1]-x[i] > vi[j]){\n\t\t\t\tvec.pb(i);\n\t\t\t}\n\t\t}\n\t\tvec.pb(n);\n\t\trepn(i,n){\n\t\t\tint e = vec[POSL(vec,i)];\n\t\t\tgo[i][j] = e;\n\t\t\tif(j==0) p[i].sc = e;\n\t\t}\n\t}\n\trep(j,vi.size()){\n\t\tvector<int>vec;\n\t\tvec.pb(1);\n\t\trepn(i,n-1){\n\t\t\tif(x[i+1]-x[i] > vi[j]){\n\t\t\t\tvec.pb(i+1);\n\t\t\t}\n\t\t}\n\t\trepn(i,n){\n\t\t\tint e = vec[POSU(vec,i)-1];\n\t\t\tgo2[i][j] = e;\n\t\t\tif(j==0) p[i].fi = e;\n\t\t}\n\t}\n\t//repn(i,n)cout<<p[i].fi<<\" \"<<p[i].sc<<endl;\n\trep(i,(1<<20)) dp[i] = -INF;\n\tdp[0] = 0;\n\tint z = vi.size();\n\tfor(int mask=0;mask<(1<<z);mask++){\n\t\tif(dp[mask] < 0) continue;\n\t\tfor(int i=0;i<z;i++){\n\t\t\tif(((mask>>i)&1)) continue;\n\t\t\tint NXT = go[dp[mask]+1][i];\n\t\t\tif(dp[mask]==n) NXT=n;\n\t\t\tdp[mask+(1<<i)] = max(dp[mask+(1<<i)],NXT);\n\t\t}\n\t}\n\trep(i,(1<<20)) dp2[i] = INF;\n\tdp2[0] = n+1;\n\t//int z = vi.size();\n\tfor(int mask=0;mask<(1<<z);mask++){\n\t\tif(dp2[mask] > n+1) continue;\n\t\tfor(int i=0;i<z;i++){\n\t\t\tif(((mask>>i)&1)) continue;\n\t\t\tint NXT = go2[dp2[mask]-1][i];\n\t\t\tif(dp2[mask]==1) NXT=1;\n\t\t\tdp2[mask+(1<<i)] = min(dp2[mask+(1<<i)],NXT);\n\t\t}\n\t}\n\tvector<P>L;\n//\tbool allok = 0;\n\tfor(int mask=0;mask<(1<<z);mask++){\n\t\tif(mask%2 == 1) continue;\n\t\tint mask2 = (1<<z)-2-mask;\n\t\tint x = dp[mask];\n\t\tint y = dp2[mask2];\n\t\t//cout<<x<<y<<endl;\n\t\tif(x+1>y-1) used[1] += 1;\n\t\telse{\n\t\t\tint L = p[x+1].fi;\n\t\t\tint R = p[x+1].sc;\n\t\t\tif(L<=x+1 && y-1<=R){\n\t\t\t\tused[L]++;\n\t\t\t\tused[R+1]--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++) used[i]+=used[i-1];\n\tfor(int i=1;i<=n;i++){\n\t\tputs(used[i]?\"Possible\":\"Impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nint arr[200005], pre[200005][25], nxt[200005][25], dp_l[800005], dp_r[800005];\nint main()\n{\n\t// freopen(\"AGC012-E.in\", \"r\", stdin);\n\tint n, v, len = 0;\n\tscanf(\"%d%d\", &n, &v);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", arr + i);\n\twhile (true)\n\t{\n\t\tpre[0][len] = pre[1][len] = 0;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t\tpre[i][len] = arr[i] - arr[i - 1] <= v ? pre[i - 1][len] : i - 1;\n\t\tnxt[n + 1][len] = nxt[n][len] = n + 1;\n\t\tfor (int i = n - 1; i; i--)\n\t\t\tnxt[i][len] = arr[i + 1] - arr[i] <= v ? nxt[i + 1][len] : i + 1;\n\t\tlen++;\n\t\tif (!v)\n\t\t\tbreak;\n\t\tv >>= 1;\n\t}\n\tfor (int i = 0; i < 1 << len; i++)\n\t{\n\t\tdp_l[i] = 1;\n\t\tdp_r[i] = n;\n\t}\n\tfor (int i = 0; i < 1 << len; i++)\n\t{\n\t\tfor (int j = 0; j < len; j++)\n\t\t{\n\t\t\tif (i & (1 << j))\n\t\t\t\tcontinue;\n\t\t\tdp_l[i | (1 << j)] = std::max(dp_l[i | (1 << j)], nxt[dp_l[i]][j]);\n\t\t\tdp_r[i | (1 << j)] = std::min(dp_r[i | (1 << j)], pre[dp_r[i]][j]);\n\t\t}\n\t}\n\tif (dp_l[(1 << len) - 1] <= n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor (int l = 1; l <= n; l = nxt[l][0])\n\t{\n\t\tbool flg = false;\n\t\tint r = nxt[l][0];\n\t\tfor (int i = 0; i < 1 << len && !flg; i++)\n\t\t{\n\t\t\tif (i & 1)\n\t\t\t\tcontinue;\n\t\t\tflg |= l <= dp_l[i] && dp_r[(1 << len) - 2 ^ i] < r;\n\t\t}\n\t\tfor (int i = l; i < r; i++)\n\t\t\tputs(flg ? \"Possible\" : \"Impossible\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define MAX(x,y) x=max(x,y)\n#define MIN(x,y) x=min(x,y)\n#define inf 0x3f3f3f3f\nusing namespace std;\n\nconst int N=200005;\n\nint n,v,g[N],f[N],bin[20],tot,len[20],lef[20][N],rig[20][N],a[N],bel[N],p1[N],p2[N];\nbool ans[N];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nvoid dp()\n{\n\tbin[0]=1;\n\tfor (int i=1;i<=tot;i++) bin[i]=bin[i-1]*2;\n\tfor (int i=0;i<bin[tot];i++) g[i]=n+1;\n\tfor (int i=0;i<bin[tot];i++)\n\t\tfor (int j=0;j<=tot;j++)\n\t\t\tif (!(i&bin[j])) MAX(f[i+bin[j]],rig[j][f[i]+1]),MIN(g[i+bin[j]],lef[j][g[i]-1]);\n\tfor (int i=0;i<bin[tot];i++)\n\t{\n\t\tint l=f[i],r=g[i^(bin[tot]-1)];\n\t\tif (l+1>=r)\n\t\t{\n\t\t\tfor (int j=1;j<=n;j++) ans[j]=1;\n\t\t\treturn;\n\t\t}\n\t\tif (p1[bel[l+1]]<=l+1&&p2[bel[l+1]]>=r-1) ans[bel[l+1]]=1;\n\t}\n}\n\nint main()\n{\n\tn=read();v=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n\ttot=0;len[0]=0;\n\twhile (v) len[++tot]=v,v>>=1;\n\tsort(len,len+tot+1);\n\tmemset(lef,inf,sizeof(lef));\n\tfor (int i=0;i<tot;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tint l=j;\n\t\t\twhile (l<n&&a[l+1]-a[l]<=len[i]) l++;\n\t\t\trig[i][j]=l;lef[i][l]=j;j=l;\n\t\t}\n\tint id=0;\n\tfor (int j=1;j<=n;j++)\n\t{\n\t\tint l=j;bel[j]=++id;\n\t\twhile (l<n&&a[l+1]-a[l]<=len[tot]) l++,bel[l]=id;\n\t\tp1[id]=j;p2[id]=l;j=l;\n\t}\n\tdp();\n\tfor (int i=1;i<=n;i++) puts(ans[bel[i]]?\"Possible\":\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define FOR(i, x, y) for (decay<decltype(y)>::type i = (x), _##i = (y); i < _##i; ++i)\n#define FORD(i, x, y) for (decay<decltype(x)>::type i = (x), _##i = (y); i > _##i; --i)\n#ifdef zerol\n#define dbg(x...) do { cout << \"\\033[32;1m\" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\n// -----------------------------------------------------------------------------\n\nconst int N = 2E5 + 100;\nconst int M = 20;\nint nxt[M][N], bak[M][N], ans[N];\nint f[1 << M], g[1 << M];\nLL x[N];\nvector<LL> spans;\n\nint main() {\n    int n, v; cin >> n >> v;\n    while (v) {\n        spans.push_back(v);\n        v /= 2;\n    }\n    spans.push_back(0);\n    FOR (i, 1, n + 1) cin >> x[i];\n\n    int m = spans.size();\n    FOR (i, 0, m) {\n        const auto& span = spans[i];\n        FORD (j, n, 0) {\n            if (j < n && x[j + 1] - x[j] <= span) {\n                nxt[i][j] = nxt[i][j + 1];\n            } else {\n                nxt[i][j] = j;\n            }\n        }\n        FOR (j, 1, n + 1) {\n            if (j > 1 && x[j] - x[j - 1] <= span) {\n                bak[i][j] = bak[i][j - 1];\n            } else {\n                bak[i][j] = j;\n            }\n            // dbg(i, span, j, nxt[i][j], bak[i][j]);\n        }\n    }\n\n    fill(g, g + (1 << m), n + 1);\n    FOR (u, 0, 1 << m) {\n        if (u & 1) continue;\n        dbg(u, f[u], g[u]);\n        FOR (i, 1, m) {\n            if ((u >> i) & 1) continue;\n            int v = u | (1 << i);\n\n            if (f[u] == n) f[v] = n;\n            else f[v] = max(f[v], nxt[i][f[u] + 1]);\n            if (g[u] == 1) g[v] = 1;\n            else g[v] = min(g[v], bak[i][g[u] - 1]);\n        }\n    }\n\n    FOR (u, 0, 1 << m) {\n        if (u & 1) continue;\n        int v = ((1 << m) - 2) ^ u;\n        int st = f[u] + 1, ed = g[v] - 1;\n        if (st > n || ed < 1) {\n            fill(ans + 1, ans + n + 1, 1);\n            break;\n        }\n        if (nxt[0][st] >= ed) {\n            FOR (i, bak[0][st], nxt[0][st] + 1) {\n                if (ans[i]) break;\n                ans[i] = 1;\n            }\n        }\n    }\n\n    FOR (i, 1, n + 1) {\n        puts(ans[i] ? \"Possible\" : \"Impossible\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 200010\n#define LG 25\nint R[LG][MAXN],L[LG][MAXN],fl[4194304],fr[4194304];\nint V[LG],cnt,X[MAXN],lg,tot,n,x[MAXN];\nvoid Min(int &x,int y)\n{\n\tif(x>y) x=y;\n}\nvoid Max(int &x,int y)\n{\n\tif(x<y) x=y;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&V[0]);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&x[i]);\n\twhile(V[lg])\n\t\tV[++lg]=V[lg-1]/2;\n\tfor(int i=0;i<=lg;i++)\n\t{\n\t\tint ls=0;\n\t\tfor(int j=2;j<=n+1;j++)\n\t\t\tif(x[j]-x[j-1]>V[i]||j==n+1)\n\t\t\t{\n\t\t\t\tfor(int k=ls;k<j-1;k++)\n\t\t\t\t\tL[i][k]=j-1;\n\t\t\t\tfor(int k=ls+2;k<=j;k++)\n\t\t\t\t\tR[i][k]=ls+1;\n\t\t\t\tls=j-1;\n\t\t\t\tif(i==0) X[++cnt]=j-1;\n\t\t\t}\n\t}\n\tif(cnt>lg+1)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\ttot=1<<(lg+1);\n\tfor(int i=0;i<tot;i+=2)\n\t\tfr[i]=n+1;\n\tfor(int i=0;i<tot;i+=2)\n\t\tfor(int j=1;j<=lg;j++)\n\t\t\tif((i&(1<<j))==0)\n\t\t\t{\n\t\t\t\tMax(fl[i|(1<<j)],L[j][fl[i]]);\n\t\t\t\tMin(fr[i|(1<<j)],R[j][fr[i]]);\n\t\t\t}\n\tfor(int i=1;i<=cnt;i++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int j=0;j<tot;j+=2)\n\t\t\tif(fl[j]>=X[i-1]&&fr[tot-j-2]<=X[i]+1)\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(int j=X[i-1]+1;j<=X[i];j++)\n\t\t\tif(flag) printf(\"Possible\\n\");\n\t\t\telse printf(\"Impossible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N, V;\nint M, SM;\n\nint T[22][MAX_N];\nint nex[22][MAX_N];\n\nint dp[(1 << 22)], rdp[(1 << 22)];\nint ok[MAX_N];\n\nvector<ll> v;\nll A[MAX_N];\n\nvoid pre(int dp[MAX_N]) {\n\trep(i, 0, M) {\n\t\trep(j, 0, N - 1) {\n\t\t\tT[0][j] = (abs(A[j + 1] - A[j]) > v[i]) ? j : (j + 1);\n\t\t}\n\t\tT[0][N - 1] = N - 1;\n\t\trep(q, 0, 20) {\n\t\t\trep(j, 0, N) {\n\t\t\t\tT[q + 1][j] = T[q][T[q][j]];\n\t\t\t}\n\t\t}\n\t\trep(j, 0, N) {\n\t\t\tnex[i][j] = T[20][j];\n\t\t}\n\t}\n\trep(bit, 0, (1 << SM)) {\n\t\tif(dp[bit] == N - 1) continue;\n\t\trep(i, 0, SM) {\n\t\t\tif(bit & (1 << i)) continue;\n\t\t\tMAX(dp[bit | (1 << i)], nex[i][dp[bit] + 1]);\n\t\t}\n\t}\n\trep(bit, 0, (1 << SM)) {\n\t\tif(dp[bit] == N - 1) continue;\n\t\tdp[bit] = nex[SM][dp[bit] + 1];\n\t}\n}\n\nvoid solve() {\n\tcin >> N >> V;\n\trep(i, 0, N) cin >> A[i];\n\twhile(V >= 1) {\n\t\tv.pb(V);\n\t\tV /= 2;\n\t}\n\tv.pb(0);\n\tM = sz(v);\n\tSM = M - 1;\n\n\treverse(all(v));\n\t\n\tpre(dp);\n\n\treverse(A, A + N);\n\tpre(rdp);\n\n\trep(bit, 0, (1 << SM)) rdp[bit] = N - 1 - rdp[bit];\n\n\trep(bit, 0, (1 << SM)) {\n\t\tint rbit = (1 << SM) - 1 - bit;\n\t\tint l = dp[bit], r = rdp[rbit];\n\t\tl++;\n\t\tif(l > r) {\n\t\t\tok[l]--;\n\t\t\tok[r]++;\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\tok[i + 1] += ok[i];\n\t\tif(ok[i]) cout << \"Possible\\n\";\n\t\telse cout << \"Impossible\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nnamespace INPUT{\n\tconst int L=1<<15;\n\tchar _buf[L],*S,*T,c;\n\tchar _gc(){\n\t\tif(S==T){\n\t\t\tT=(S=_buf)+fread(_buf,1,L,stdin);\n\t\t\tif(S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n\tvoid readi(int &X){\n\t\tregister bool flag;\n\t\tfor(c=_gc();(c<'0'||c>'9')&&c!='-';c=_gc());\n\t\tif(c=='-') X=0,flag=true; else X=c&15,flag=false;\n\t\tfor(c=_gc();c>='0'&&c<='9';X=X*10+(c&15),c=_gc());\n\t\tif(flag) X=-X;\n\t}\n}\nusing INPUT::readi;\n\nconst int Maxn=2E5+5;\n\nint N,M,K,V;\nint a[Maxn];\nint F[Maxn],G[Maxn];\nint L[20][Maxn],R[20][Maxn];\nchar Ans[50],_1[50]={\"Possible\"},_2[50]={\"Impossible\"};\n//int nxt[Maxn];\n\ninline void MIN(int &x,int y){if(x>y)x=y;}\ninline void MAX(int &x,int y){if(x<y)x=y;}\n\nint main(){\n\treadi(N),readi(V);\n\twhile(V>>M) ++M;\n\tfor(int i=1;i<=N;++i) readi(a[i]);\n\tfor(int i=0;i<=M;++i){\n\t\tL[i][1]=1;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(a[j]-a[j-1]>(V>>i)) L[i][j]=j;\n\t\tfor(int j=2;j<=N;++j)\n\t\t\tif(L[i][j]==0) L[i][j]=L[i][j-1];\n\t\t\n\t\tR[i][N]=N;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(a[j+1]-a[j]>(V>>i)) R[i][j]=j;\n\t\tfor(int j=N-1;j>=1;--j)\n\t\t\tif(R[i][j]==0) R[i][j]=R[i][j+1];\n\t}\n\tG[0]=N+1;\n\tfor(int i=1;i<(1<<M);++i){\n\t\tG[i]=N+1;\n\t\tfor(int j=0;j<M;++j)\n\t\t\tif((i>>j)&1)\n\t\t\t\tMAX(F[i],R[M-j][min(F[i-(1<<j)]+1,N)]),\n\t\t\t\tMIN(G[i],L[M-j][max(G[i-(1<<j)]-1,1)]);\n\t}\n\tfor(int i=1;i<=N;++i)\n\t\tK+=(L[0][i]!=L[0][i-1]);\n\tif(K>20){\n\t\tfor(int i=1;i<=N;++i)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int i=1,j;i<=N;++i)\n\t\tif(L[0][i]!=L[0][i-1]){\n\t\t\tfor(j=0;j<(1<<M);++j)\n\t\t\t\tif(F[j]>=L[0][i]-1 && G[(1<<M)-1-j]<=R[0][i]+1)\n\t\t\t\t\t{memcpy(Ans,_1,sizeof(_1)); break ;}\n\t\t\tif(j==1<<M) memcpy(Ans,_2,sizeof(_2));\n\t\t\tprintf(\"%s\\n\",Ans);\n\t\t}else printf(\"%s\\n\",Ans);\n/*\tmemset(nxt,-1,sizeof(nxt));\n\tfor(int i=0;i<(1<<M);++i) MAX(nxt[G[(1<<M)-1-i]],F[i]);\n\tfor(int i=1;i<=N+1;++i) MAX(nxt[i],nxt[i-1]);\n\tfor(int i=1;i<=N;++i)\n\t\tif(nxt[R[0][i]+1]>=L[0][i]-1)\n\t\t\tputs(\"Possible\");\n\t\telse\n\t\t\tputs(\"Impossible\");*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 200001\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nint n,cnt,v[N],x[N],tl[N][19],tr[N][19];\nint fl[1<<19],fr[1<<19];\nint main()\n{\n\tre(n),re(v[0]);\n\twhile(v[cnt])\n\t{\n\t\t++cnt;\n\t\tv[cnt]=v[cnt-1]>>1;\n\t}\n\tfor(int i=1;i<=n;++i)re(x[i]);\n\tfor(int i=0;i<=cnt;++i)\n\t{\n\t\tint last=1;\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(j==n || x[j+1]-x[j]>v[i])\n\t\t\t{\n\t\t\t\tfor(int k=last;k<=j;++k)\n\t\t\t\t\ttl[k][i]=last,tr[k][i]=j;\n\t\t\t\tlast=j+1;\n\t\t\t}\n\t}\n\tfor(int i=0;i<(1<<cnt+1);++i)\n\t{\n\t\tfl[i]=0;\n\t\tfr[i]=n+1;\n\t\tfor(int j=0;j<=cnt;++j)\n\t\t\tif(i>>j&1)\n\t\t\t{\n\t\t\t\tfl[i]=max(fl[i],tr[min(fl[i^(1<<j)]+1,n)][j]);\n\t\t\t\tfr[i]=min(fr[i],tl[max(fr[i^(1<<j)]-1,1)][j]);\n\t\t\t}\n\t}\n\tint gg=0,l=1;\n\twhile(l<=n)\n\t{\n\t\tint r=tr[l][0];\n\t\tif(gg>cnt)\n\t\t{\n\t\t\tfor(int i=l;i<=r;++i)\n\t\t\t\tputs(\"Impossible\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbool ok=0;\n\t\t\tfor(int i=0;i<(1<<cnt+1);++i)\n\t\t\t{\n\t\t\t\tint gl=i,gr=((1<<cnt+1)-1)^i;\n\t\t\t\tif(gl&1)gl^=1;\n\t\t\t\tif(gr&1)gr^=1;\n\t\t\t\tif(fl[gl]>=l-1 && fr[gr]<=r+1)\n\t\t\t\t{\n\t\t\t\t\tok=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=l;i<=r;++i)\n\t\t\t\tputs(ok?\"Possible\":\"Impossible\");\n\t\t}\n\t\tl=r+1;\n\t\t++gg;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,v;\nint x[200010];\nvector<pair<int,int> >tot;\nint nl[20][200010],nr[20][200010];\nint fl[1<<20],fr[1<<20];\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",x+i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint j=i;\n\t\twhile(j+1<=n && x[j+1]-x[j]<=v)j++;\n\t\ttot.push_back(make_pair(i,j));\n\t\ti=j;\n\t}\n\tif((int)tot.size()>20)\n\t{\n\t\tfor(int i=1;i<=n;i++)puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tv/=2;\n\tint k;\n\tfor(k=0;;k++,v/=2)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint j=i;\n\t\t\twhile(j+1<=n && x[j+1]-x[j]<=v)j++;\n\t\t\tfor(int t=i;t<=j;t++)nl[k][t]=j,nr[k][t]=i;\n\t\t\ti=j;\n\t\t}\n\t\tif(!v)break;\n\t}\n\tk++;\n\tfor(int i=0;i<(1<<k);i++)fr[i]=n+1;\n\tfor(int i=0;i<(1<<k);i++)\n\t{\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tif(i>>j&1)continue;\n\t\t\tfl[i|(1<<j)]=min(n,max(fl[i|(1<<j)],nl[j][fl[i]+1]));\n\t\t\tfr[i|(1<<j)]=max(1,min(fr[i|(1<<j)],nr[j][fr[i]-1]));\n\t\t}\n\t}\n\tfor(int i=0;i<(int)tot.size();i++)\n\t{\n\t\tbool ok=false;\n\t\tfor(int j=0;j<(1<<k);j++)\n\t\t{\n\t\t\tint a=fl[j],b=fr[((1<<k)-1)^j];\n\t\t\tif((a>=tot[i].first-1 && b<=tot[i].second+1) || a+1>=b)\n\t\t\t{\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=tot[i].first;j<=tot[i].second;j++)puts(ok?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nint V;\nint xs[214514];\nint vs[20];\nint dp1[1145141];\nint dp2[1145141];\nint dp3[1145141];\nint dp4[1145141];\nvector<int> segs[20];\n\nint main() {\n  scanf(\"%d%d\", &N, &V);\n  for (int i=0; i<N; i++) {\n    scanf(\"%d\", &xs[i]);\n  }\n\n  int v = V;\n  int cnt = 0;\n  while (v >= 0) {\n    vs[cnt++] = v;\n    if (v == 0) break;\n    v /= 2;\n  }\n\n  for (int i=0; i<cnt; i++) {\n    int v = vs[i];\n    segs[i].emplace_back(0);\n    for (int idx=1; idx<N; idx++) {\n      if (xs[idx]-xs[idx-1] > v) segs[i].emplace_back(idx);\n    }\n    segs[i].emplace_back(N);\n  }\n\n  int lim = 1 << cnt;\n  fill(dp1, dp1+lim, -1);\n  dp1[0] = 0;\n  for (int st=0; st<lim; st++) {\n    for (int i=0; i<cnt; i++) {\n      if (st >> i & 1) continue;\n      int nst = st | (1 << i);\n      int g = *upper_bound(segs[i].begin(), segs[i].end(), dp1[st]);\n      dp1[nst] = max(dp1[nst], g);\n    }\n  }\n\n  fill(dp2, dp2+lim, N);\n  dp2[0] = N-1;\n  for (int st=0; st<lim; st++) {\n    for (int i=0; i<cnt; i++) {\n      if (st >> i & 1) continue;\n      int nst = st | (1 << i);\n      auto itr = upper_bound(segs[i].begin(), segs[i].end(), dp2[st]);\n      itr--;\n      dp2[nst] = min(dp2[nst], *itr-1);\n    }\n  }\n\n  /*fill(dp3, dp3+lim, -1);\n  dp3[0] = 1;\n  for (int st=0; st<lim; st++) {\n    for (int i=0; i<cnt; i++) {\n      if (st >> i & 1) continue;\n      int nst = st | (1 << i);\n      int g = *upper_bound(segs[i].begin(), segs[i].end(), dp3[st]);\n      dp3[nst] = max(dp3[nst], g);\n    }\n  }\n\n  fill(dp4, dp4+lim, N);\n  dp4[0] = N-2;\n  for (int st=0; st<lim; st++) {\n    for (int i=0; i<cnt; i++) {\n      if (st >> i & 1) continue;\n      int nst = st | (1 << i);\n      auto itr = upper_bound(segs[i].begin(), segs[i].end(), dp4[st]);\n      itr--;\n      dp4[nst] = min(dp4[nst], *itr-1);\n    }\n  }*/\n\n  for (int i=0; i<N; i++) {\n    auto itr = upper_bound(segs[0].begin(), segs[0].end(), i);\n    int b = *itr;\n    itr--;\n    int a = *itr-1;\n    bool ok = false;\n    for (int st=0; st<lim; st++) {\n      if (st & 1) continue;\n      int cst = (lim-1) & (~st) & ~1;\n      //if (dp1[st] > a && dp2[cst] <= b) ok = true;\n      //if (dp1[st] >= a && dp2[cst] < b) ok = true;\n      //if (dp3[st] > a && dp2[cst] < b) ok = true;\n      //if (dp1[st] > a && dp4[cst] < b) ok = true;\n      if (dp1[st] > a && dp2[cst] < b) ok = true;\n      if (ok) break;\n    }\n    if (ok) puts(\"Possible\");\n    else puts(\"Impossible\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200010;\n\nint N, V;\nint x[maxn];\nint id[maxn];\n\nint m, cnt;\nint val[20];\nbool f[2][1<<20][20];\n\nbool ans[20];\n\nbool F[20][1<<20];\nbool G[20][1<<20];\n\nint main() {\n\tscanf(\"%d%d\", &N, &V);\n\tfor(int v = V / 2; v > 0; v /= 2) val[m++] = v;\n\tval[m++]=0;\n\tfor(int i = 0; i < N; ++i) scanf(\"%d\", &x[i]);\n\tid[0] = 0;\n\tcnt = 1;\n\tfor(int i = 1; i < N; ++i) {\n\t\tif(x[i] - x[i-1] > V) id[i] = cnt++;\n\t\telse id[i] = id[i-1];\n\t}\n\n\tif(cnt == 1) { for(int i = 0; i < N; ++i) puts(\"Possible\"); return 0; }\n\tif(cnt > 20) { for(int i = 0; i < N; ++i) puts(\"Impossible\"); return 0; }\n\n\tmemset(f, 0, sizeof(f));\n\tfor(int j = 0; j < 1<<m; ++j) \n\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1)\n\t\t\tf[0][j][k] = true;\n\tif(id[0] != id[1]) \n\t\tfor(int j = 0; j < 1<<m; ++j) F[id[0]][j] = true;\n\tfor(int i = 1, p = 0; i < N; ++i) {\n\t\tp ^= 1;\n\t\tmemset(f[p], 0, sizeof(f[p]));\n\t\tfor(int j = 0; j < 1<<m; ++j) {\n\t\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1) {\n\t\t\t\tfor(int l = 0; l < m; ++l) f[p][j][k] |= f[p^1][j^(1<<k)][l];\n\t\t\t\tif(x[i] - x[i-1] <= val[k]) f[p][j][k] |= f[p^1][j][k];\n\t\t\t}\n\t\t}\n\t\tif(i == N-1 || id[i+1] != id[i]) {\n\t\t\tfor(int j = 0; j < 1<<m; ++j) {\n\t\t\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1) {\n\t\t\t\t\tF[id[i]][j] |= f[p][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(f, 0, sizeof(f));\n\tfor(int j = 0; j < 1<<m; ++j) \n\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1)\n\t\t\tf[0][j][k] = true;\n\tif(id[N-1]!=id[N-2]) \n\t\tfor(int j = 0; j < 1<<m; ++j) G[id[N-1]][j] = true;\n\tfor(int i = N - 2, p = 0; i >= 0; --i) {\n\t\tp ^= 1;\n\t\tmemset(f[p], 0, sizeof(f[p]));\n\t\tfor(int j = 0; j < 1<<m; ++j) {\n\t\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1) {\n\t\t\t\tfor(int l = 0; l < m; ++l) f[p][j][k] |= f[p^1][j^(1<<k)][l];\n\t\t\t\tif(x[i+1] - x[i] <= val[k]) f[p][j][k] |= f[p^1][j][k];\n\t\t\t}\n\t\t}\n\t\tif(i == 0 || id[i-1] != id[i]) {\n\t\t\tfor(int j = 0; j < 1<<m; ++j) {\n\t\t\t\tfor(int k = 0; k < m; ++k) if(j >> k & 1) {\n\t\t\t\t\tG[id[i]][j] |= f[p][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst int mask = (1<<m) - 1;\n\tfor(int i = 0; i < cnt; ++i) {\n\t\tif(i == 0) {\n\t\t\tfor(int k = 0; k < 1<<m; ++k) \n\t\t\t\tif(G[i+1][k]) { ans[i] = true; break; }\n\t\t} else if(i == cnt - 1) {\n\t\t\tfor(int k = 0; k < 1<<m; ++k) \n\t\t\t\tif(F[i-1][k]) { ans[i] = true; break; }\n\t\t} else {\n\t\t\tfor(int k = 0; k < 1<<m; ++k) {\n\t\t\t\tif(F[i-1][k] && G[i+1][mask ^ 1]) { ans[i] = true; break; }\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; ++i) puts(ans[id[i]] ? \"Possible\" : \"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 200005;\n\nll x[MAX_N];\nint v[18], l[MAX_N][18], r[MAX_N][18];\nint dpl[1 << 18], dpr[1 << 18];\nint team[MAX_N], ok[MAX_N];\nP lr[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, V;\n    cin >> n >> V;\n    rep(i,n) cin >> x[i];\n    int val = V, num = 0;\n    while(val > 0){\n        val >>= 1, v[num++] = val;\n    }\n    int st = 0, id = 0;\n    rep(i,n){\n        if(i == n-1){\n            srep(k, st, n) team[k] = id;\n            lr[id++] = {st, n-1};\n        }else{\n            if(x[i+1] - x[i] > V){\n                srep(k, st, i + 1) team[k] = id;\n                lr[id++] = {st, i};\n                st = i + 1;\n            }\n        }\n    }\n    rep(j,num){\n        int st = 0;\n        rep(i,n){\n            if(i == n-1){\n                srep(k, st, n) r[k][j] = n-1;\n            }else{\n                if(x[i+1] - x[i] > v[j]){\n                    srep(k, st, i + 1) r[k][j] = i;\n                    st = i + 1;\n                }\n            }\n        }\n        st = n-1;\n        rrep(i,n){\n            if(i == 0){\n                rep(k, st + 1) l[k][j] = 0;\n            }else{\n                if(x[i] - x[i-1] > v[j]){\n                    srep(k, i, st + 1) l[k][j] = i;\n                    st = i - 1;\n                }\n            }\n        }\n    }\n    rep(i,(1 << num)){\n        dpr[i] = -1, dpl[i] = n;\n    }\n    rep(i,(1 << num)){\n        rep(j,num){\n            if(!(i >> j & 1)){\n                if(dpr[i] == n-1) dpr[i ^ (1 << j)] = n-1;\n                else cmx(dpr[i ^ (1 << j)], r[dpr[i] + 1][j]);\n                if(dpl[i] == 0) dpl[i ^ (1 << j)] = 0;\n                else cmn(dpl[i ^ (1 << j)], l[dpl[i] - 1][j]);\n            }\n        }\n    }\n    rep(i,(1 << num)){\n        int R = dpr[i], L = dpl[i^((1 << num) - 1)];\n        if(L - R <= 1){\n            rep(j,id) ok[j] = 1;\n            break;\n        }else{\n            P p = lr[team[R + 1]];\n            if(L - p.se <= 1) ok[team[R + 1]] = 1;\n        }\n    }\n    rep(i,n){\n        if(ok[team[i]]) cout << \"Possible\\n\";\n        else cout << \"Impossible\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint dpl[1<<20],dpr[1<<20],n,v,x[200011],l[21][200001],r[21][200001],q[100001];bool ans[200001];\nint main()\n{\n\tscanf(\"%d%d\",&n,&v);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&x[i]);\n\tint tmp=v;while(tmp)q[++q[0]]=tmp,tmp>>=1;q[++q[0]]=0;for(int i=1;i<=q[0]-i+1;++i)swap(q[i],q[q[0]-i+1]);\n//\tfor(int i=1;i<=q[0];++i)printf(\"%d \",q[i]);putchar(10);\n\tfor(int i=1;i<=q[0];++i)\n\t{\n\t\tint pt=1;\n\t\tfor(int j=1;j<=n;++j){if(x[j]-x[j-1]>q[i])pt=j;l[i][j]=pt;}pt=n;\n\t\tfor(int j=n;j;--j){if(x[j+1]-x[j]>q[i])pt=j;r[i][j]=pt;}\n\t}\n//\tfor(int i=1;i<=n;++i)printf(\"%d %d\\n\",l[q[0]][i],r[q[0]][i]);\n\tfor(int i=0;i<(1<<q[0]);++i)dpl[i]=1,dpr[i]=n;\n\tfor(int i=0;i<(1<<q[0]);++i)\n\t{\n\t\tfor(int j=1;j<=q[0];++j)\n\t\t{\n\t\t\tif(i&(1<<j-1))continue;\n\t\t\tif(dpl[i]>n)dpl[i|(1<<j-1)]=dpl[i];else dpl[i|(1<<j-1)]=max(dpl[i|(1<<j-1)],r[j][dpl[i]]+1);\n\t\t\tif(dpr[i]<1)dpr[i|(1<<j-1)]=dpr[i];else dpr[i|(1<<j-1)]=min(dpr[i|(1<<j-1)],l[j][dpr[i]]-1);\n\t\t}\n\t}\n\tint cnt=0;for(int i=1;i<=n;i=r[q[0]][i]+1)++cnt;if(cnt>q[0]){for(int i=1;i<=n;++i)printf(\"Impossible\\n\");return 0;}\n//\tfor(int i=0;i<(1<<q[0]);++i)printf(\"%d %d %d\\n\",i,dpl[i],dpr[i]);\n\tfor(int i=1;i<=n;i=r[q[0]][i]+1)\n\t{\n\t\tbool flg=false;\n\t\tfor(int j=0;j<(1<<q[0]-1);++j)if(dpl[j]>=l[q[0]][i]&&dpr[((1<<q[0]-1)-1)^j]<=r[q[0]][i]){flg=true;break;}\n\t\tfor(int j=l[q[0]][i];j<=r[q[0]][i];++j)ans[j]=flg;\n\t}\n\tfor(int i=1;i<=n;++i)printf(ans[i]?\"Possible\\n\":\"Impossible\\n\");return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,v;\n  cin>>n>>v;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n\n  vector<Int> dp;\n  vector<vector<Int> > ps;\n  while(v){\n    vector<Int> dp2(n,0);\n    for(Int i=1;i<n;i++)\n      dp2[i]=dp2[i-1]+(x[i]-x[i-1]>v);\n    if(dp.empty()) dp=dp2;\n\n    vector<Int> ps2;\n    ps2.emplace_back(0);\n    for(Int i=1;i<n;i++)\n      if(dp2[i]!=dp2[i-1]) ps2.emplace_back(i);\n    ps2.emplace_back(n);\n    ps.emplace_back(ps2);\n    v>>=1;\n  }\n  \n  {\n    vector<Int> ps2(n+1,0);\n    iota(ps2.begin(),ps2.end(),0);\n    ps.emplace_back(ps2);\n  }\n\n  vector<vector<Int> > memo(ps.size(),vector<Int>(n,-1));\n  function<Int(Int,Int)> calc=\n    [&](Int d,Int k)->Int{\n      if(d+1==(Int)ps.size()) return 1;\n      Int &res=memo[d][k];\n      if(~res) return res;\n      res=0;\n      vector<Int> &v=ps[d];\n      vector<Int> &u=ps[d+1];\n      Int x=lower_bound(u.begin(),u.end(),v[k])-u.begin();\n      while(u[x]<v[k+1]){\n\tres++;\n\tx++;\n      }\n      return res;\n    };\n  \n  using P = pair<Int, Int>;\n  Int flg;\n  function<void(Int,const set<P>&)> dfs=\n    [&](Int d,const set<P> &sp){\n      {\n\tauto latte=sp.begin();\n\tInt res=latte->first==0;\n\twhile(latte!=sp.end()){\n\t  auto malta=latte;\n\t  if(++malta==sp.end()) break;;\n\t  res&=latte->second==malta->first;\n\t  latte=malta;\n\t}\n\tres&=latte->second==n;\n\tflg|=res;\n      }\n      \n      if(d==(Int)ps.size()) return;\n      \n      Int cnt=0;\n      vector<Int> &v=ps[d];\n      {\n\tauto latte=v.begin();\n\tfor(auto &p:sp){\n\t  cnt+=lower_bound(latte,v.end(),p.first)-latte;\n\t  latte=lower_bound(latte,v.end(),p.second);\n\t}\n\tcnt+=v.end()-latte-1;\n      }\n      \n      if(0){\n\tcout<<d<<\":\"<<cnt<<\"::\"<<(Int)ps.size()<<endl;\n\tfor(auto p:sp) cout<<p.first<<\" \"<<p.second<<endl;\n\tcout<<endl;\n      }\n      \n      if(d+1==(Int)ps.size()){\n\tflg|=(cnt<=1);\n\treturn;\n      }\n      \n      if(d+cnt>(Int)ps.size()) return;\n      \n      Int ncnt=0;\n\n      {\n\tInt k=0;\n\tfor(auto &p:sp){\n\t  while(v[k]<p.first){\n\t    ncnt+=calc(d,k);\n\t    k++;\n\t  }\n\t  k=lower_bound(v.begin(),v.end(),p.second)-v.begin();\n\t}\n\twhile(k+1<(Int)v.size()){\n\t  ncnt+=calc(d,k);\n\t  k++;\n\t}\n      }\n      //cout<<d<<\":\"<<cnt<<\":\"<<ncnt<<endl;\n\n      set<P> nsp=sp;\n      {\n\tInt k=0;\n\tfor(auto &p:sp){\n\t  while(v[k]<p.first){\n\t    if(d+ncnt-calc(d,k)<=(Int)ps.size()){\n\t      nsp.emplace(v[k],v[k+1]);\n\t      dfs(d+1,nsp);\n\t      nsp.erase(P(v[k],v[k+1]));\n\t      if(flg) return;\n\t    }\n\t    k++;\n\t  }\n\t  k=lower_bound(v.begin(),v.end(),p.second)-v.begin();\n\t}\n\twhile(k+1<(Int)v.size()){\n\t  if(d+ncnt-calc(d,k)<=(Int)ps.size()){\n\t    nsp.emplace(v[k],v[k+1]);\n\t    dfs(d+1,nsp);\n\t    nsp.erase(P(v[k],v[k+1]));\n\t    if(flg) return;\n\t  }\n\t  k++;\n\t}\n      }\n      \n    };\n  \n  for(Int i=0;i<n;){\n    Int l=i,r=*upper_bound(ps[0].begin(),ps[0].end(),l);\n    set<P> sp;\n    sp.emplace(l,r);\n    flg=0;\n    dfs(1,sp);\n    string ans=(flg?\"Possible\":\"Impossible\");\n    Int p=i;\n    while(i<n&&dp[p]==dp[i]){\n      cout<<ans<<endl;\n      i++;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by xiqiao\n#include<bits/stdc++.h>\n#define maxn 200005\nusing namespace std;\ntypedef long long ll;\nint n;\nint l[maxn][30],r[maxn][30];\nint a[maxn];\nvoid pre_work(int wh,int v){\n\tl[0][wh]=0;l[1][wh]=0;\n\tfor(int i=2;i<=n;i++){\n\t\tif(a[i-1]-a[i-2]<=v)l[i][wh]=l[i-1][wh];\n\t\telse l[i][wh]=i-1;\n\t}\n\tr[n][wh]=n;r[n-1][wh]=n;\n\tfor(int i=n-2;i>=0;i--){\n\t\tif(a[i+1]-a[i]<=v)r[i][wh]=r[i+1][wh];\n\t\telse r[i][wh]=i+1;\n\t}\n}\nint f[maxn*3],f2[maxn*3];\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tint V;\n\tscanf(\"%d%d\",&n,&V);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",&a[i]);\n\tint g=0;\n\tfor(int x=V;x;x>>=1){\n\t\tpre_work(g++,x);\n\t}\n\tpre_work(g++,0);\n\tfor(int i=0;i<(1<<g);i++)f[i]=0;\n\tfor(int i=0;i<(1<<g);i++){\n\t\tfor(int j=0;j<g;j++){\n\t\t\tif((1<<j)&i)continue;\n\t\t\tf[i|(1<<j)]=max(f[i|(1<<j)],r[f[i]][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<g);i++)f2[i]=n;\n\tfor(int i=0;i<(1<<g);i++){\n\t\tfor(int j=0;j<g;j++){\n\t\t\tif((1<<j)&i)continue;\n\t\t\tf2[i|(1<<j)]=min(f2[i|(1<<j)],l[f2[i]][j]);\n\t\t}\n\t}\n\tif(f[(1<<g)-1]<n){\n\t\tfor(int i=0;i<n;i++)puts(\"Impossible\");\n\t\treturn 0;\n\t}\n\tint L,R;L=1;\n\tfor(L=0;L<n;L=R){\n\t\tbool ok=0;R=r[L][0];\n\t\tfor(int j=0;j<(1<<g);j++){\n\t\t\tif(j&1)continue;\n\t\t\tif(f[j]>=L && f2[(1<<g)-2-j]<=R){\n\t\t\t\tok=1;break;\n\t\t\t}\n\t\t}\n\t\tfor(int j=L;j<R;j++){\n\t\t\tif(!ok)puts(\"Impossible\");\n\t\t\telse puts(\"Possible\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define ins insert\n#define pii pair<int,int>\n#define fs first\n#define sc second\n#define mpr make_pair\n#define iter iterator\n#define all(X) X.begin(),X.end()\n#define sau(X) sort(all(X)),X.resize(unique(all(X))-X.begin())\n#define exist(X,ele) binary_search(all(X),ele)\n\ntemplate<typename T1,typename T2>\nostream& operator << (ostream& out,const pair<T1,T2>& X)\n{\n\tout<<\"{\"<<X.fs<<\",\"<<X.sc<<\"}\";\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& out,const vector<T>& X)\n{\n\tfor(auto i:X) out<<i<<\" \";\n\treturn out;\n}\n\ninline void cmin(int& x,int y)\n{\n\tx=min(x,y);\n}\n\ninline void cmax(int& x,int y)\n{\n\tx=max(x,y);\n}\n\nconst int inf=5000000000000000ll;\n\nint N,V;\nvector<int> a;\nint p[20][200010];\nint nxt[20][200010][2];\nbool ans[200010];\nint cnt=0;\n\ninline string t(int x)\n{\n\tstring res=\"\";\n\tfor(int i=0;i<=5;i++)\n\t{\n\t\tres+=(bool)(x&(1<<i))+'0';\n\t}\n\treturn res;\n}\n\ninline bool solve(int L,int R,int U)\n{\n//\tcout<<\"  Solving \"<<setw(4)<<left<<L<<setw(4)<<left<<R<<t(U)<<endl;\n\t\n\tvector<int> v;\n\tfor(int i=0;i<=cnt;i++)\n\t{\n\t\tif(U&(1<<i)) v.pb(i);\n\t}\n\tint U2=(1<<(int)v.size())-1;\n\tvector<int> dp((1<<(int)v.size()),-1);\n\tdp[0]=L;\n\tfor(int msk=0;msk<=U2;msk++)\n\t{\n\t\tif(dp[msk]==-1) continue;\n\t\tfor(int j=0;j<v.size();j++)\n\t\t{\n\t\t\tif(!(msk&(1<<j)))\n\t\t\t{\n\t\t\t\tcmax(dp[msk|(1<<j)],dp[msk]);\n\t\t\t\tcmax(dp[msk|(1<<j)],nxt[v[j]][dp[msk]][0]);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int msk=0;msk<=U2;msk++)\n//\t{\n//\t\tcout<<\"msk=\"<<t(msk)<<\" dp[msk]=\"<<dp[msk]<<endl;\n//\t}\n//\tcout<<\" Ret : \"<<(dp[U2]>R)<<endl;\n\treturn dp[U2]>R;\n}\n\nmain()\n{\n\tios::sync_with_stdio(false);\n\t\n\tcin>>N>>V;\n\tfor(int i=0,x;i<N;i++)\n\t{\n\t\tcin>>x;\n\t\ta.pb(x);\n\t}\n\tfor(int i=0,v=V,lv=-1;v!=lv;i++,lv=v,v/=2)\n\t{\n\t\tfor(int j=1;j<N;j++)\n\t\t{\n\t\t\tp[i][j]=p[i][j-1];\n\t\t\tif(a[j]-a[j-1]>v) p[i][j]++;\n\t\t}\n\t\tcnt++;\n\t}\n\tfor(int i=0,v=V,lv=-1;v!=lv;i++,lv=v,v/=2)\n\t{\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(j && p[i][j]==p[i][j-1])\n\t\t\t{\n\t\t\t\tnxt[i][j][0]=nxt[i][j-1][0];\n\t\t\t\tnxt[i][j][1]=nxt[i][j-1][1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int k=j;k<=N;k++)\n\t\t\t{\n\t\t\t\tif(k==N || p[i][k]!=p[i][j])\n\t\t\t\t{\n\t\t\t\t\tnxt[i][j][0]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=j;k>=-1;k--)\n\t\t\t{\n\t\t\t\tif(k==-1 || p[i][k]!=p[i][j])\n\t\t\t\t{\n\t\t\t\t\tnxt[i][j][1]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tnxt[i][j][0]=(upper_bound(p[i],p[i]+N,p[i][j])-p[i]);   // [j, )\n//\t\t\tnxt[i][j][1]=(lower_bound(p[i],p[i]+N,p[i][j])-p[i])-1; // ( ,j]\n\t\t}\n//\t\tcout<<\"D=\"<<i<<endl;\n//\t\tfor(int j=0;j<N;j++) cout<<nxt[i][j][0]<<\" \"; cout<<endl;\n//\t\tfor(int j=0;j<N;j++) cout<<nxt[i][j][1]<<\" \"; cout<<endl;\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n//\t\tcout<<\"StartPos=\"<<i<<endl;\n\t\tif(i!=0 && nxt[0][i][0]==nxt[0][i-1][0])\n\t\t{\n\t\t\tans[i]=ans[i-1];\n\t\t\tcontinue;\n\t\t}\n\t\tans[i]=false;\n\t\tint U=((1<<(cnt+1))-2); \n\t\tfor(int mskL=0;mskL<=U;mskL++)\n\t\t{\n\t\t\tif(mskL&1) continue;\n\t\t\tint mskR=U^mskL;\n\t\t\tif(nxt[0][i][1]<0 && mskL) continue;\n\t\t\tif(nxt[0][i][0]>=N && mskR) continue;\n\t\t\tif(nxt[0][i][1]>=0 && nxt[0][i][0]<N && ((!mskL)||(!mskR)) ) continue;\n\t\t\tbool ok=true;\n\t\t\tif(nxt[0][i][1]>=0) ok&=solve(0,nxt[0][i][1],mskL);\n\t\t\tif(nxt[0][i][0]<N) ok&=solve(nxt[0][i][0],N-1,mskR);\n\t\t\tans[i]|=ok;\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(ans[i]) cout<<\"Possible\"<<endl;\n\t\telse cout<<\"Impossible\"<<endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// AT 2365\n// DeP\n#include <cctype>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nnamespace IO {\n    const int MAXSIZE = 1 << 18 | 1;\n    char buf[MAXSIZE], *p1, *p2;\n\n    inline int Gc() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2)? EOF: *p1++; }\n    template<class T> void read(T& x) {\n        x = 0; int f = 0, ch = Gc();\n        while (!isdigit(ch)) f |= ch == '-', ch = Gc();\n        while (isdigit(ch)) x = x * 10 + ch - '0', ch = Gc();\n        if (f) x = -x;\n    }\n}\nusing IO::read;\n\ntypedef pair<int, int> Pii;\nconst int MAXN = 2e5+5, LOG = 21, INF = 0x3f3f3f3f;\n\nint n, V;\nint X[MAXN], f[MAXN], g[MAXN];\nint L[LOG][MAXN], R[LOG][MAXN];\nbool Ans[MAXN];\nPii segs[MAXN];\n\nint main() {\n    // input\n    read(n); read(V);\n    for (int i = 1; i <= n; ++i) read(X[i]);\n    X[0] = -INF; X[n+1] = INF;\n    // solve\n    int log = 0;\n    for (int v = V; v >= 0; v /= 2, ++log) {\n        R[log][n+1] = n+1;\n        for (int i = 1; i <= n; ++i) L[log][i] = X[i] - X[i-1] <= v? L[log][i-1]: i;\n        for (int i = n; i >= 1; --i) R[log][i] = X[i+1] - X[i] <= v? R[log][i+1]: i;\n        if (!v) { ++log; break; }\n    }\n    for (int i = 1; i <= n; ++i) segs[i] = make_pair(L[0][i], R[0][i]);\n    int tot = unique(segs+1, segs+1+n) - segs - 1;\n    if (tot > log) {\n        for (int i = 1; i <= n; ++i) puts(\"Impossible\");\n        return 0;\n    }\n    for (int S = 0; S < (1 << log); ++S) f[S] = n+1;\n    for (int S = 0; S < (1 << log); S += 2) {\n        for (int i = 0; i < log; ++i) if ((S >> i) & 1) {\n            f[S] = min(f[S], L[i][f[S ^ (1 << i)] - 1]);\n            g[S] = max(g[S], R[i][g[S ^ (1 << i)] + 1]);\n        }\n    }\n    for (int i = 1; i <= tot; ++i)\n        for (int S = 0; S < (1 << log); S += 2)\n            if (g[S] >= segs[i].first-1 && segs[i].second+1 >= f[((1<<log)-1)-(S+1)]) {\n                for (int k = segs[i].first; k <= segs[i].second; ++k) Ans[k] = true;\n                break;\n            }\n    // output\n    for (int i = 1; i <= n; ++i) puts(Ans[i]? \"Possible\": \"Impossible\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 220000\ninline char gc(){\n    static char now[1<<16],*S,*T;\n    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}\n    return *S++;\n}\n#define S 1<<19\ninline int read(){\n    int x=0,f=1;char ch=gc();\n    while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}\n    while (ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=gc();}\n    return x*f;\n}\nint f1[S],f2[S],n,num,bin[20],st[N],a[N],right[N][20],left[N][20],v;\nint main(){\n    n=read();v=read();int Log=0;\n    for (int i=1;i<=n;++i) a[i]=read();\n    while ((1<<Log)<=v) Log++;Log++;\n    for (int i=0;i<=Log+1;++i) bin[i]=1<<i;\n    num=1;for (int i=2;i<=n;++i) if (a[i]-a[i-1]>v) num++;\n    for (int j=0;j<Log;++j){\n        left[1][j]=1;right[n][j]=n;\n        for (int i=2;i<=n;++i) if (a[i]-a[i-1]>(v>>j)) left[i][j]=i;else left[i][j]=left[i-1][j];\n        for (int i=n-1;i>=1;--i) if (a[i+1]-a[i]>(v>>j)) right[i][j]=i;else right[i][j]=right[i+1][j];\n    }   \n    if (num>Log){\n        for (int i=1;i<=n;++i) printf(\"Impossible\\n\");return 0;\n    }\n    for (int s=0;s<=bin[Log]-1;++s) {f1[s]=0,f2[s]=n+1;}\n    for (int s=0;s<=bin[Log]-1;++s){\n        for (int i=0;i<Log;++i){\n            if (s&bin[i])continue;\n            if (f1[s]==n) f1[s|bin[i]]=n;else f1[s|bin[i]]=max(f1[s|bin[i]],right[f1[s]+1][Log-i-1]);\n            if (f2[s]==1) f2[s|bin[i]]=1;else f2[s|bin[i]]=min(f2[s|bin[i]],left[f2[s]-1][Log-i-1]);\n        }\n    }for (int i=0;i<=n;++i) st[i]=n+2;\n    for (int s=0;s<=bin[Log-1]-1;++s){\n        int s1=(bin[Log-1]-1)^s;\n        st[f1[s]]=min(st[f1[s]],f2[s1]);\n    } for (int i=n-1;i>=0;--i) st[i]=min(st[i],st[i+1]);\n    for (int i=1;i<=n;++i){\n        int l=left[i][0],r=right[i][0];\n        if (st[l-1]<=r+1) printf(\"Possible\\n\");else printf(\"Impossible\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nconst int NMAX = 300000;\nconst int LOGN = 20;\nint V[LOGN];\nint Lmost[NMAX][LOGN], Rmost[NMAX][LOGN];\n \nint dpL[1<<LOGN], dpR[1<<LOGN];\nint arr[NMAX+1];\nint dp[NMAX+2];\n \nint main(){\n    int N; scanf(\"%d%d\",&N,&V[0]);\n    for(int i=1;i<=N;i++) scanf(\"%d\",arr+i);\n \n    int M = 1;\n    while(V[M-1]){\n        V[M] = V[M-1]/2;\n        M++;\n    }\n \n    for(int i=0;i<M;i++){\n        int v = V[i];\n        int j = 1;\n        while(j<=N){\n            int k = j+1;\n            while(k<=N && arr[k]-arr[k-1] <= v) k++;\n            for(int x=j;x<k;x++) Rmost[x][i] = k-1;\n            j = k;\n        }\n        j = N;\n        while(j>=1){\n            int k = j-1;\n            while(k>=1 && arr[k+1]-arr[k] <= v) k--;\n            for(int x=j;x>k;x--) Lmost[x][i] = k+1;\n            j = k;\n        }\n    }\n \n    for(int i=0;i<(1<<M);i++) dpR[i] = N+1;\n    for(int i=1;i<(1<<M);i++){\n        for(int j=0;j<M;j++) if(i&(1<<j)){\n            // use V[j]\n            int L = dpL[i^(1<<j)];\n            dpL[i] = max(dpL[i], Rmost[L+1][j]);\n \n            int R = dpR[i^(1<<j)];\n            dpR[i] = min(dpR[i], Lmost[R-1][j]);\n        }\n    }\n \n    for(int i=0;i<=N+1;i++) dp[i] = -0x3fFFffFF;\n \n    for(int i=2;i<(1<<M);i+=2){\n        int j = ((1<<M)-1)^i^1;\n        dp[dpR[j]] = max(dp[dpR[j]], dpL[i]);\n    }\n \n    for(int i=1;i<=N+1;i++)\n        dp[i] = max(dp[i], dp[i-1]);\n \n    for(int i=1;i<=N;i++){\n        int L = Lmost[i][0], R = Rmost[i][0];\n        int det = dp[R+1];\n        if(det>=L-1) printf(\"Possible\\n\");\n        else printf(\"Impossible\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nclass segtree{\npublic:\n\tstatic const int N=1<<18;\n\tint dp[1<<19];\n\tsegtree(){\n\t\tmemset(dp,0,sizeof(dp));\n\t\t\n\t}\n\tvoid init(int v){\n\t\tfor(int i=0;i<N*2;i++){\n\t\t\tdp[i]=v;\n\t\t}\n\t}\n\tvoid update(int k,int v){\n\t\tk+=N-1;\n\t\tdp[k]=min(v,dp[k]);\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdp[k]=min(dp[k*2+1],dp[k*2+2]);\n\t\t}\n\t}\n\n\tint query(int a,int b,int k=0,int l=0,int r=N){\n\t\tif(b<=l || r<=a)return INF;\n\t\tif(a<=l && r<=b)return dp[k];\n\t\tint mid=(l+r)/2;\n\t\tint vl=query(a,b,k*2+1,l,mid);\n\t\tint vr=query(a,b,k*2+2,mid,r);\n\t\treturn min(vl,vr);\n\t}\n};\n\nsegtree seg;\n\nint n;\nll v;\nll x[200005];\nll to[2][20][200005];\nll dp[2][1<<20];\nbool ans[200005];\n\nint main(void){\n\tscanf(\"%d%lld\",&n,&v);\n\tseg.init(n+1);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t}\n\tint jp=0;\n\tll tmp=v;\n\twhile(v>0){\n\t\tjp++;\n\t\tv/=2LL;\n\t}\n\tjp++;\n\tv=tmp;\n\tfor(int ty=0;ty<2;ty++){\n\t\ttmp=v;\n\t\tfor(int i=0;i<jp;i++){\n\t\t\tint f=0;\n\t\t\tfor(int j=1;j<n;j++){\n\t\t\t\tif(x[j-1]+v<x[j]){\n\t\t\t\t\tfor(int k=f;k<j;k++){\n\t\t\t\t\t\tto[ty][i][k]=j;\n\t\t\t\t\t}\n\t\t\t\t\tf=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=f;j<n;j++){\n\t\t\t\tto[ty][i][j]=n;\n\t\t\t}\n\t\t\tto[ty][i][n]=n;\n\t\t\tv/=2;\n\t\t}\n\t\tfor(int i=0;i<(1<<jp);i++){\n\t\t\t//printf(\"%d %d %lld\\n\",ty,i,dp[ty][i]);\n\t\t\tfor(int j=0;j<jp;j++){\n\t\t\t\tif(!(i>>j & 1)){\n\t\t\t\t\tdp[ty][i|(1<<j)]=max(dp[ty][i|(1<<j)],to[ty][j][dp[ty][i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv=tmp;\n\t\treverse(x,x+n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i]=-x[i];\n\t\t}\n\t}\n\tfor(int i=0;i<jp;i++){\n\t\treverse(to[1][i],to[1][i]+n);\n\t\tfor(int j=0;j<n;j++){\n\t\t\tto[1][i][j]=n-to[1][i][j];\n\t\t}\n\t}\n\n\tfor(int i=0;i<(1<<jp);i++){\n\t\tdp[1][i]=n-dp[1][i];\n\t}\n\tfor(int i=0;i<(1<<jp);i++){\n\t\tif(i>>0 & 1)continue;\n\t\t//printf(\"ad %d %lld %lld\\n\",i,dp[0][i],dp[1][(1<<jp)-i-2]);\n\t\tseg.update(dp[0][i],dp[1][(1<<jp)-i-2]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\t//printf(\"%lld %lld\\n\",to[0][0][i],to[1][0][i]);\n\t\tif(to[0][0][i]==n-1){\n\t\t\tif(to[1][0][i]==0){\n\t\t\t\tans[i]=true;\n\t\t\t}else{\n\t\t\t\tans[i]=(seg.query(to[1][0][i],seg.N)<=n);\n\t\t\t}\n\t\t}else{\n\t\t\tif(to[1][0][i]==0){\n\t\t\t\tans[i]=(seg.query(0,seg.N)<=to[0][0][i]);\n\t\t\t}else{\n\t\t\t\tans[i]=(seg.query(to[1][0][i],seg.N)<=to[0][0][i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%s\\n\",ans[i]?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\n#include <cstdlib>\n\nusing std::pair;\ntypedef pair<int,int> pii;\nconst int N = 200010;\nconst int M = 18;\nint _w;\n\nint max( int a, int b ) {\n\treturn a > b ? a : b;\n}\n\nint n, v, x[N], m;\n\nint ans[N];\nvoid answer() {\n\tfor( int i = 1; i <= n; ++i )\n\t\tputs( ans[i] ? \"Possible\" : \"Impossible\" );\n\texit(0);\n}\n\nint R[M][N];\nvoid prelude() {\n\tint t = v;\n\tfor( m = 0; ; ++m, t >>= 1 ) {\n\t\tR[m][n] = R[m][n+1] = n;\n\t\tfor( int j = n-1; j >= 1; --j )\n\t\t\tif( x[j+1] - x[j] > t )\n\t\t\t\tR[m][j] = j;\n\t\t\telse R[m][j] = R[m][j+1];\n\t\tif( !t ) break;\n\t}\n\t++m;\n}\n\nint f[1<<M];\nbool check( int l, int r ) {\n\tmemset(f, 0, sizeof f);\n\tfor( int i = 0; i < (1<<m); ++i )\n\t\tfor( int j = 1; j < m; ++j )\n\t\t\tif( (i&(1<<j)) == 0 ) {\n\t\t\t\tint k = i|(1<<j);\n\t\t\t\tf[k] = max( f[k], R[j][f[i]+1] );\n\t\t\t\tif( f[k] >= l-1 && f[k] <= r )\n\t\t\t\t\tf[k] = r;\n\t\t\t}\n\treturn f[(1<<m)-2] == n;\n}\n\nvoid solve() {\n\tstatic pii tmp[N];\n\tstatic int tn;\n\tfor( int i = 1; i <= n; i = R[0][i]+1 )\n\t\ttmp[tn++] = pii(i, R[0][i]);\n\tif( tn > m ) answer();\n\tfor( int i = 0; i < tn; ++i )\n\t\tif( check(tmp[i].first, tmp[i].second) ) {\n\t\t\tfor( int j = tmp[i].first; j <= tmp[i].second; ++j )\n\t\t\t\tans[j] = 1;\n\t\t}\n\tanswer();\n}\n\nint main() {\n\t_w = scanf( \"%d%d\", &n, &v );\n\tfor( int i = 1; i <= n; ++i )\n\t\t_w = scanf( \"%d\", x+i );\n\tprelude(), solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=1e6+5,M=5e6+5;\nconst int INF=2000000000;\nint n,V;\nint x[N];\nint cnt[25];\nint l[25][N],r[25][N];\nint f1[M],f2[M];\nbool ans[N];\nvoid Init(){\n    for(int i=0;i<M;i++)\n        f1[i]=0,f2[i]=INF;\n}\nint Upfind(int id,int pos){\n    pos++;\n    int p=upper_bound(l[id]+1,l[id]+cnt[id]+1,pos)-l[id]-1;\n    if(p<=0)\n        return pos;\n    return max(r[id][p],pos-1);\n}\nint Lowfind(int id,int pos){\n    pos--;\n    int p=lower_bound(r[id]+1,r[id]+cnt[id]+1,pos)-r[id];\n    if(p>=cnt[id]+1)\n        return pos;\n    return min(l[id][p],pos+1);\n}\nint main()\n{\n    Init();\n    scanf(\"%d%d\",&n,&V);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&x[i]);\n    x[n+1]=INF;\n    x[0]=-INF;\n    int logV=0;\n   while(1<<(logV+1)<=V)\n        logV++;\n    int v=V*2;\n    for(int t=0;t<=logV+1;t++){\n        v>>=1;\n        cnt[t]=1;\n        l[t][1]=1;\n        for(int i=1;i<=n;i++){\n            r[t][cnt[t]]=i;\n            if(x[i+1]-x[i]>v){\n                cnt[t]++;\n                l[t][cnt[t]]=i+1;\n            }\n        }\n        cnt[t]--;\n    }\n    if(cnt[0]>logV+2){\n        for(int i=1;i<=n;i++)\n\t\t\tputs(\"Impossible\");\n\t\treturn 0;\n    }\n    int tot=1<<(logV+2);\n    f1[0]=0,f2[0]=n+1;\n    for(int s=0;s<tot;s+=2)\n        for(int i=0;i<=logV+1;i++){\n            if(!(s&(1<<i)))\n                continue;\n            f1[s]=max(f1[s],Upfind(i,f1[s^(1<<i)]));\n            f2[s]=min(f2[s],Lowfind(i,f2[s^(1<<i)]));\n        }\n    for(int i=1;i<=cnt[0];i++){\n        int ln=l[0][i],rn=r[0][i];\n        for(int s1=0;s1<tot;s1+=2){\n            int s2=tot-1-s1-1;\n            int lpos=f1[s1];\n            int rpos=f2[s2];\n            if(lpos>=ln-1&&rpos<=rn+1){\n                ans[i]=true;\n                break;\n            }\n        }\n    }\n    int pos=1;\n    for(int i=1;i<=n;i++){\n        if(ans[pos]==true)\n            puts(\"Possible\");\n        else\n            puts(\"Impossible\");\n        if(x[i+1]-x[i]>V)\n            pos++;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 12345678\nusing namespace std;\ninline int read()\n{int x=0,f=0;\nchar c=getchar();\nwhile (c<'0'||c>'9') \n{if (c=='-') f=1;\nc=getchar();\n}\nwhile (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\nif (f) x=-x;\nreturn x;\n}\ninline int max(int a,int b)\n{return a>b?a:b;}\ninline int min(int a,int b)\n{return a<b?a:b;}\nint l[21][200005],r[21][200005];\nint a[200005],n,v,p[21],cnt=0;\nint fl[262145],fr[262145],tot[21];\ninline int calc(int pos)\n{int lp=l[cnt+1][pos]-1,rp=r[cnt+1][pos]+1;\nfor (int i=0;i<(1<<cnt);i++)\n{if (fl[i]>=lp&&fr[(1<<cnt)-1-i]<=rp) return 1;\n}\nreturn 0;\n}\nint main (){\n\tint i,j;\n\tn=read();v=read();\n\tfor (i=1;i<=n;i++)\n\t{a[i]=read();}\n\twhile (v) {p[++cnt]=v;v>>=1;}\n\tp[++cnt]=0;\n\treverse(p+1,p+cnt+1);\n\tfor (j=1;j<=cnt;j++)\n\t{int pos=1;\n\twhile (pos<=n)\n\t{int sta=pos;\n\twhile (pos<=n&&a[pos+1]-a[pos]<=p[j]) pos++;\n\tfor (i=sta;i<=pos;i++) \n\t{l[j][i]=sta;r[j][i]=pos;}\n\tpos++;tot[j]++;\n\t}\n\tl[j][n+1]=n+1;r[j][n+1]=n+1;\n\tl[j][0]=0;r[j][0]=0;\n\t}\n\tif (tot[cnt]>cnt)\n\t{for (i=1;i<=n;i++)\n\t{puts(\"Impossible\");}\n\treturn 0;\n\t}\n\tcnt--;\n\tfor (i=0;i<(1<<cnt);i++)\n\t{fl[i]=0;fr[i]=n+1;\n\tfor (j=1;j<=cnt;j++)\n\t{if (!((1<<(j-1))&i)) continue;\n\tfl[i]=max(fl[i],r[j][fl[(i^(1<<(j-1)))]+1]);\n\tfr[i]=min(fr[i],l[j][fr[(i^(1<<(j-1)))]-1]);\n\t}\n\t}\n\tint las;\n\tfor (i=1;i<=n;i++)\n\t{if (l[cnt+1][i]==i) las=calc(i);\n\tputs(las?\"Possible\":\"Impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n#define pb push_back\n\nusing namespace std;\nconst int N=200005,M=20;\nbool ans[N];\nint n,m,a[N],c;\nint g1[M][N],g2[M][N],f1[1<<M],f2[1<<M];\nvector <int> vt[N],Q[N];\nstruct data{int x,y;} dat[N];\n\nint getint()\n{\n\tchar ch;\n\tint f=1;\n\twhile(!isdigit(ch=getchar())) if(ch=='-') f=-1;\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x*f;\n}\n\nint main()\n{\n\tn=getint(),m=getint();\n\trep(i,1,n) a[i]=getint();\n\tfor(int x=m; ; x>>=1,++c)\n\t{\n\t\tint i=1,j=1;\n\t\twhile(j+1<=n && a[j+1]-a[j]<=x) ++j;\n\t\trep(k,1,n+1) g2[c][k]=n+1;\n\t\trep(k,1,n)\n\t\t{\n\t\t\tif(k>j) i=j=k;\n\t\t\twhile(j+1<=n && a[j+1]-a[j]<=x) ++j;\n\t\t\tif(!c) dat[k]=(data){i,j};\n\t\t\telse\n\t\t\t{\n\t\t\t\tg1[c][i]=max(g1[c][i],j);\n\t\t\t\tg2[c][j]=min(g2[c][j],i);\n\t\t\t}\n\t\t}\n\t\tg1[c][n+1]=n,g2[c][0]=1;\n\t\trep(k,1,n) g1[c][i]=max(g1[c][i],g1[c][i-1]);\n\t\trepd(k,n,1) g2[c][i]=min(g2[c][i],g2[c][i+1]);\n\t\tif(!x) break;\n\t}\n\trep(i,0,(1<<c)-1) f2[i]=n+1;\n\trep(i,0,(1<<c)-1)\n\t{\n\t\trep(j,0,c-1) if(!(i&(1<<j)))\n\t\t{\n\t\t\tf1[i|(1<<j)]=max(f1[i|(1<<j)],g1[j+1][f1[i]+1]);\n\t\t\tf2[i|(1<<j)]=min(f2[i|(1<<j)],g2[j+1][f2[i]-1]);\n\t\t}\n\t}\n\tint S=(1<<c)-1;\n\trep(i,0,S)\n\t{\n\t\tint x=min(f1[i]+1,n);\n\t\tint y=max(f2[S^i]-1,1);\n\t\tvt[x].pb(y);\n\t}\n\trep(i,1,n) Q[dat[i].x].pb(i);\n\tint p=n+1;\n\trepd(i,n,1)\n\t{\n\t\tint sz=vt[i].size();\n\t\trep(j,0,sz-1) p=min(p,vt[i][j]);\n\t\tsz=Q[i].size();\n\t\trep(j,0,sz-1) ans[Q[i][j]]=p<=dat[Q[i][j]].y;\n\t}\n\trep(i,1,n) if(ans[i]) puts(\"Possible\"); else puts(\"Impossible\");\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<stdlib.h>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nint p[210000];\nint q[210000];\nint c[210000];\nint L[1<<18];\nint R[1<<18];\nvector<int>en[18];\nvector<int>ee;\nlong long sum[210000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",p+i);\n\t\tif(i)q[i]=p[i]-p[i-1];\n\n\t}\n\tint tt=b;\n\tfor(int i=0;i<a;i++){\n\t\tif(tt<q[i])ee.push_back(i);\n\t}\n\tint BI=0;\n\tee.push_back(a);\n\tfor(int i=0;i<18;i++){\n\t\tif(tt==0)break;\n\t\tBI++;\n\t\ttt/=2;\n\t\tc[i]=tt;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(c[i]<q[j])en[i].push_back(j);\n\t\t}\n\t\ten[i].push_back(a);\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t\tint at=L[i];\n\t\tint tmp=b;\n\t\tfor(int j=0;j<BI;j++){\n\t\t//\ttmp/=2;\n\t\t\tif(i&(1<<j))continue;\n\t\t\tif(at==a){\n\t\t\t\tL[i+(1<<j)]=a;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to=upper_bound(en[j].begin(),en[j].end(),at)-en[j].begin();\n\n\t//\t\tprintf(\"%d %d %d %d %d\\n\",i,j,at,to,(int)(en[j].size()));\n\t\t\tL[i+(1<<j)]=max(L[i+(1<<j)],en[j][to]);\n\t\t//\tif(tmp==0)break;\n\t\t}\n\t}\n\t//return 0;\n\treverse(p,p+a);\n\tfor(int i=0;i<a;i++){\n\t\tif(i)q[i]=p[i-1]-p[i];\n\t}\n\tfor(int i=0;i<BI;i++)en[i].clear();\n\tfor(int i=0;i<BI;i++){\n\t\tif(c[i]){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(c[i]<q[j])en[i].push_back(j);\n\t\t\t}\n\t\t\ten[i].push_back(a);\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t\tint at=R[i];\n\t\tint tmp=b;\n\t\tfor(int j=0;j<BI;j++){\n\t\t//\ttmp/=2;\n\t\t\tif(i&(1<<j))continue;\n\t\t\tif(R[i]==a){\n\t\t\t\tR[i+(1<<j)]=a;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to=upper_bound(en[j].begin(),en[j].end(),at)-en[j].begin();\n\t//\t\tprintf(\"%d %d %d %d %d\\n\",i,j,at,to,(int)(en[j].size()));\n\t\t\tR[i+(1<<j)]=max(R[i+(1<<j)],en[j][to]);\n\t\t//\tif(tmp==0)break;\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t//\tif(i>=(1<<2))continue;\n\t//\tprintf(\"%d: %d %d\\n\",i,L[i],R[i]);\n\t}\n\tfor(int i=0;i<(1<<BI);i++){\n\t\tint left=L[i];\n\t\tint right=a-R[(1<<BI)-1-i];\n\t\tleft++;\n\t\tif(upper_bound(ee.begin(),ee.end(),right)-upper_bound(ee.begin(),ee.end(),left)<=0){\n\t\t\tsum[left]++;\n\t\t\tsum[right+1]--;\n\t//\t\tprintf(\"%d %d\\n\",left-1,right);\n\t\t}\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tsum[i+1]+=sum[i];\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tsum[i+1]+=sum[i];\n\t}\n\t//for(int i=0;i<=a;i++)printf(\"%lld \",sum[i]);printf(\"\\n\");\n\tfor(int i=0;i<a;i++){\n\t\tint left,right;\n\t\tint ind=upper_bound(ee.begin(),ee.end(),i)-ee.begin();\n\t\tif(ind==0)left=0;\n\t\telse left=ee[ind-1];\n\t\tind=upper_bound(ee.begin(),ee.end(),i)-ee.begin();\n\t\tright=ee[ind];\n//\t\tprintf(\"%d: %d %d\\n\",i,left,right);\n\t\tif(sum[left]==sum[right])printf(\"Impossible\\n\");\n\t\telse printf(\"Possible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nint n,v,m,a[200005],len[25],L[200005][25],R[200005][25],f[1000005],g[1000005];\npriority_queue<int> q;\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\twhile(v) len[m++]=v,v>>=1;len[m++]=0;\n\tfor(int i=0;i<m/2;i++) swap(len[i],len[m-i-1]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tL[i][p]=L[i-1][p];\n\t\t\tif(i==1||a[i]-a[i-1]>len[p]) L[i][p]=i;\n\t\t}\n\t}\n\tfor(int i=n;i;i--){\n\t\tfor(int p=0;p<m;p++){\n\t\t\tR[i][p]=R[i+1][p];\n\t\t\tif(i==n||a[i+1]-a[i]>len[p]) R[i][p]=i;\n\t\t}\n\t}\n\tf[0]=0;g[0]=n+1;\n\tfor(int i=1;i<(1<<m);i++){\n\t\tg[i]=n+1;\n\t\tfor(int p=0;p<m;p++) if(i&(1<<p)){\n\t\t\tf[i]=max(f[i],R[f[i^(1<<p)]+1][p]);\n\t\t\tg[i]=min(g[i],L[g[i^(1<<p)]-1][p]);\n\t\t}\n\t}\n\tint S=(1<<m-1)-1;\n\tfor(int i=1,pos=0;i<=n;i++){\n\t\twhile(f[pos]>=L[i][m-1]-1&&pos<=S) q.push(S^pos),pos++;\n\t\twhile(!q.empty()&&f[S^q.top()]<L[i][m-1]-1) q.pop();\n\t\tif(q.empty()){\n\t\t\tputs(\"Impossible\");continue;\n\t\t}\n\t\tif(g[q.top()]>R[i][m-1]+1) puts(\"Impossible\");\n\t\telse puts(\"Possible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ctz __builtin_ctz\n\nconst int N = 400005, inf = 0x3f3f3f3f;\n\nvoid up(int &x, int y) { x = std::max(x, y); }\nvoid down(int &x, int y) { x = std::min(x, y); }\n\nint f[N], g[N], x[N], L[19][N], R[19][N], sum[N];\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tint n, v; std::cin >> n >> v;\n\tint lg = std::__lg(v) + 1, mask = ~(-1 << lg);\n\tx[0] = -inf, x[n + 1] = inf;\n\tfor (int i = 1; i <= n; ++i) std::cin >> x[i];\n\tfor (int t = 0; t <= lg; ++t) {\n\t\tint _v = v >> t;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tL[t][i] = x[i] - x[i - 1] <= _v ? L[t][i - 1] : i;\n\t\tfor (int i = n; i >= 1; --i)\n\t\t\tR[t][i] = x[i + 1] - x[i] <= _v ? R[t][i + 1] : i;\n\t}\n\tstd::fill(g, g + mask + 1, n + 1);\n\tfor (int i = 0; i < mask; ++i) {\n\t\tfor (int _j = mask ^ i, j = ctz(_j); _j; j = ctz(_j &= _j - 1)) {\n\t\t\tup(f[i | 1 << j], f[i]);\n\t\t\tif (f[i] < n) up(f[i | 1 << j], R[j + 1][f[i] + 1]);\n\t\t\tdown(g[i | 1 << j], g[i]);\n\t\t\tif (g[i] > 1) down(g[i | 1 << j], L[j + 1][g[i] - 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i <= mask; ++i)\n\t\tif (f[i] + 1 >= g[mask - i]) {\n\t\t\twhile (n--) std::cout << \"Possible\\n\"; return 0;\n\t\t}\n\tfor (int i = 0; i <= mask; ++i)\n\t\tif (R[0][f[i] + 1] + 1 >= g[mask - i])\n\t\t\t++sum[f[i] + 1], --sum[R[0][f[i] + 1] + 1];\n\tfor (int i = 1; i <= n; ++i) sum[i] += sum[i - 1];\n\tfor (int i = 1; i <= n; ++i) std::cout << (sum[i] ? \"Possible\" : \"Impossible\") << '\\n';\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// tzl ak IOI! \n\n#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n#define FILL(a, b) memset((a), (b), sizeof((a)))\n#define MCPY(a, b) memcpy((a), (b), sizeof((b)))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f = 0; x = 0; char c = getchar();\n\twhile((c < '0' || c > '9') && c != '-') c = getchar();\n\tif(c == '-') { f = 1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\n\tif(f) x = -x; return;\n}\n\ntemplate <typename T1, typename T2>\nvoid scf(T1 &x, T2 &y) { scf(x); return scf(y); }\n\ntemplate <typename T1, typename T2, typename T3>\nvoid scf(T1 &x, T2 &y, T3 &z) { scf(x); scf(y); return scf(z); }\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid scf(T1 &x, T2 &y, T3 &z, T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n\ninline char mygetchar(){ char c = getchar(); while(c == ' ' || c == '\\n') c = getchar(); return c; }\n\ntemplate <typename T>\nvoid chkmax(T &x, const T &y){ if(y > x) x = y; return; }\n\ntemplate <typename T>\nvoid chkmin(T &x, const T &y){ if(y < x) x = y; return; }\n\n#ifdef ONLINE_JUDGE\n#define debug(x,c) ;\n#else\n#define DEBUG\n#define debug(x,c) cerr<<#x<<\"=\"<<x<<c;\n#endif\n\nvoid TZL();\n\nvoid RANK1();\n\n#define tzl int\n#define ak main\n#define IOI ()\ntzl ak IOI\n{\n#undef tzl\n#undef ak\n#undef IOI\n\n\tTZL();\n\tRANK1();\n\n#define tzl return\n#define caisi 0\n#define myy ;\n\ttzl caisi myy\n#undef tzl\n#undef caisi\n#undef myy\n}\n\n//---------------------------head----------------------------\n\nconst int N = 2e5 + 100;\nconst int lgN = 20;\n\nint n, V, m;\nint x[N];\nint lb[lgN][N], rb[lgN][N];\nvii seg[lgN];\nint dpl[1048576], dpr[1048576];\n\nvoid get_seg()\n{\n\tfor(int i = 1, j; i <= n; i = j)\n\t{\n\t\tj = i + 1;\n\t\twhile(j <= n && x[j] - x[j - 1] <= V) ++j;\n\t\tseg[m].pb({i, j - 1});\n\t}\n\tfor(auto x: seg[m])\n\t{\n\t\tint l = x.X, r = x.Y;\n\t\tforn(i, l, r) lb[m][i] = l, rb[m][i] = r;\n\t}\n\t++m;\n\treturn;\n}\n\nvoid TZL()\n{\n\tscf(n, V);\n\tforn(i, 1, n) scf(x[i]);\n\twhile(V)\n\t{\n\t\tget_seg();\n\t\tV >>= 1;\n\t}\n\tforn(i, 1, n) lb[m][i] = i, rb[m][i] = i;\n\t++m;\n\treturn;\n}\n\nvoid DPL()\n{\n\tforn(msk, 1, (1 << m) - 1)\n\t{\n\t\trep(i, m) if((msk >> i) & 1)\n\t\t{\n\t\t\tchkmax(dpl[msk], dpl[msk ^ (1 << i)]);\n\t\t\tchkmax(dpl[msk], rb[i][dpl[msk ^ (1 << i)] + 1]);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid DPR()\n{\n\tdpr[0] = n + 1;\n\tforn(msk, 1, (1 << m) - 1)\n\t{\n\t\tdpr[msk] = n + 1;\n\t\trep(i, m) if((msk >> i) & 1)\n\t\t{\n\t\t\tchkmin(dpr[msk], dpr[msk ^ (1 << i)]);\n\t\t\tchkmin(dpr[msk], lb[i][dpr[msk ^ (1 << i)] - 1]);\n\t\t}\n\t}\n\treturn;\n}\n\nvii all;\nbool ans[N];\nint TOT;\n\nvoid check(int l, int r)\n{\n\tfor(int msk = 0; msk < (1 << m); msk += 2)\n\t{\n\t\tint lb = dpl[msk], rb = dpr[TOT ^ msk];\n\t\tif(l <= lb + 1 && r >= rb - 1)\n\t\t{\n\t\t\tforn(i, l, r) ans[i] = 1;\n\t\t\treturn;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid RANK1()\n{\n\tif(SZ(seg[0]) <= m)\n\t{\n\t\tDPL(); DPR();\n\t\tTOT = (1 << m) - 2;\n\t\tfor(auto x: seg[0]) check(x.X, x.Y);\n\t}\n\tforn(i, 1, n) puts(ans[i] ? \"Possible\" : \"Impossible\");\n\treturn;\n}"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nint main(void){\n    long long i,j,n,m,k,a[262144],b,c,h,w,r=0,l,t,v;\n    long long fmap[262144][32],bmap[262144][32];\n    long long varr[32],vs=0;\n    long long fdp[1048576],bdp[1048576];\n    long long fl[262144]={0};\n    bool refl[262144]={0};\n    scanf(\"%lld%lld\",&n,&v);\n    while(1){\n        varr[vs]=v;\n        vs++;\n        if(v==0){break;}\n        v/=2;\n    }\n    a[0]=-llinf;\n    for(i=1;i<=n;i++){\n        scanf(\"%lld\",&a[i]);\n        fl[i]=fl[i-1];\n        if((a[i]-a[i-1])>varr[0]){\n          fl[i]++;\n        }\n    }\n    fl[n+1]=fl[n]+1;\n    a[n+1]=llinf;\n    for(i=0;i<32;i++){\n        fmap[n][i]=n+1;\n        fmap[n+1][i]=n+1;\n        bmap[1][i]=0;\n        bmap[0][i]=0;\n    }\n    for(i=n-1;i>=1;i--){\n        for(j=0;j<vs;j++){\n            fmap[i][j]=fmap[i+1][j];\n            if((a[i+1]-a[i])>varr[j]){\n                fmap[i][j]=i+1;\n            }\n        }\n    }\n    for(i=2;i<=n;i++){\n        for(j=0;j<vs;j++){\n            bmap[i][j]=bmap[i-1][j];\n            if((a[i]-a[i-1])>varr[j]){\n                bmap[i][j]=i-1;\n            }\n        }\n    }\n    for(i=0;i<1048576;i++){\n        fdp[i]=1;\n        bdp[i]=n;\n    }\n    for(i=0;i<(1ll<<vs);i++){\n        for(j=0;j<vs;j++){\n            if((i&(1ll<<j))!=0){continue;}\n            fdp[i|(1ll<<j)]=llmax(fmap[fdp[i]][j],fdp[i|(1ll<<j)]);\n            bdp[i|(1ll<<j)]=llmin(bmap[bdp[i]][j],bdp[i|(1ll<<j)]);\n        }\n    }\n    for(i=0;i<(1ll<<vs);i+=2){\n      h=i;\n      w=(i^((1ll<<vs)-2ll));\n      if(fdp[h]>bdp[w]){\n        for(i=1;i<=n;i++){\n          printf(\"Possible\\n\");\n        }\n        return 0;\n      }\n      if(fl[fdp[h]]==fl[bdp[w]]){\n        refl[fl[fdp[h]]]=1;\n      }\n    }\n    for(i=1;i<=n;i++){\n      if(refl[fl[i]]){\n        printf(\"Possible\\n\");\n      }\n      else{\n        printf(\"Impossible\\n\");\n      }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n\n#define N_MAX     200000\n#define GROUP_MAX 18\n#define DP_SIZE   ((N_MAX+31)/32)\n\n\n\ntypedef struct tag_group_t\n{\n\tint l, r, is_invalid;\n}group_t;\n\n\ntypedef struct\n{\n\tint depth, is_valid_invalid;\n\tunsigned long flags[DP_SIZE];\n}state_t;\n\n\n\ntypedef int mapdata_t;\n\ntypedef struct\n{\n\tunsigned long key[DP_SIZE];\n}mapkey_t;\n\ntypedef struct\n{\n\tmapkey_t key;\n\tmapdata_t data;\n}mapm_t;\n\n\ntypedef struct\n{\n\tmapm_t **member;\n\tint member_num, area_size;\n}map_t;\n\n\nmap_t *dp[GROUP_MAX+1];\ngroup_t g_group[GROUP_MAX+1][GROUP_MAX+1];\nint group_num;\nint n, v;\nint x[N_MAX];\nmapkey_t g_key[GROUP_MAX+1];\n\n\nmapm_t *mapm_alloc(mapkey_t *key, mapdata_t *data)\n{\n\tmapm_t *mapm;\n\tmapm=malloc(sizeof(mapm_t));\n\tmapm->key=*key;\n\tmapm->data=*data;\n\treturn mapm;\n}\n\n\nvoid mapm_free(mapm_t *mapm)\n{\n\tfree(mapm);\n}\n\n\nvoid mapm_key_get(mapm_t *mapm, mapkey_t *key)\n{\n\t*key=mapm->key;\n}\n\n\nvoid mapm_data_get(mapm_t *mapm, mapdata_t *data)\n{\n\t*data=mapm->data;\n}\n\n\nmap_t *map_alloc(int area_size)\n{\n\tmap_t *map;\n\n\tmap=malloc(sizeof(map_t));\n\tif(map!=NULL)\n\t{\n\t\tmap->member_num=0;\n\t\tmap->area_size=area_size;\n\t\tmap->member=malloc(sizeof(mapm_t*)*area_size);\n\t\tif(map->member!=NULL)\n\t\t{\n\t\t\treturn map;\n\t\t}\n\t\tfree(map);\n\t}\n\treturn NULL;\n}\n\n\nvoid map_clear(map_t *map)\n{\n\tint i;\n\n\tif(map==NULL) return;\n\n\tfor(i=map->member_num-1;i>=0;i--)\n\t{\n\t\tmapm_free(map->member[i]);\n\t}\n\tmap->member_num=0;\n}\n\n\nvoid map_free(map_t *map)\n{\n\tif(map)\n\t{\n\t\tmap_clear(map);\n\t\tfree(map->member);\n\t\tfree(map);\n\t}\n}\n\n\nint map_search(map_t *map, mapkey_t *key, int *index)\n{\n\tint s, e, c, r;\n\n\ts=0;\n\te=map->member_num-1;\n\t*index=0;\n\tfor(;;)\n\t{\n\t\tif(s>e) break;\n\t\tc=(s+e)/2;\n\t\tr=memcmp(key, &(map->member[c]->key), sizeof(mapkey_t));\n\t\tif(r<0)\n\t\t{\n\t\t\te=c-1;\n\t\t\t*index=c;\n\t\t} else if(r>0) {\n\t\t\ts=c+1;\n\t\t\t*index=s;\n\t\t} else {\n\t\t\t*index=c;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nvoid map_realloc(map_t *map, int area_size)\n{\n\tmapm_t **prev;\n\n\tif(area_size<map->member_num) area_size=map->member_num;\n\tprev=map->member;\n\tmap->member=realloc(prev, sizeof(mapm_t*)*area_size);\n\tif(map->member==NULL)\n\t{\n\t\tmap->member=prev;\n\t\treturn;\n\t}\n\tmap->area_size=area_size;\n}\n\n\nvoid map_add(map_t *map, mapkey_t *key, mapdata_t *data)\n{\n\tint index;\n\tmapm_t *mapm;\n\n\tif(map_search(map, key, &index))\n\t{\n\t\tmap->member[index]->data=*data;\n\t\treturn;\n\t}\n\tif(map->member_num>=map->area_size)\n\t{\n\t\tmap_realloc(map, map->area_size+1000);\n\t}\n\tmapm=mapm_alloc(key, data);\n\tmemmove(map->member+index, map->member+index+1, sizeof(mapm_t*)*(map->member_num-index));\n\tmap->member[index]=mapm;\n\treturn;\n}\n\n\nint map_get(map_t *map, mapkey_t *key, mapdata_t *data)\n{\n\tint index;\n\n\tif(map_search(map, key, &index)==0)\n\t{\n\t\treturn 0;\n\t}\n\t*data=map->member[index]->data;\n\treturn 1;\n}\n\n\nvoid bit_set(void *pv, int s, int e)\n{\n\tunsigned long *p;\n\tint si, sb, ei, eb, i;\n\n\n\tp=pv;\n\tsi=(s>>5);\n\tei=(e>>5);\n\tsb=s&0x1F;\n\teb=e&0x1F;\n\tif(si==ei)\n\t{\n\t\tp[si]|=((1UL<<(eb-sb+1))-1)<<sb;\n\t\treturn;\n\t}\n\n\tif(sb)\n\t{\n\t\tp[si]|=(0xFFFFFFFFUL<<(sb));\n\t}\n\tfor(i=si+1;i<ei;i++) p[i]=0xFFFFFFFFUL;\n\tif(eb)\n\t{\n\t\tp[ei]|=(0xFFFFFFFFUL>>(eb));\n\t}\n}\n\n\nint bit_get(void *pv, int b)\n{\n\tunsigned long *p;\n\tint si, sb;\n\n\tp=pv;\n\tsi=(b>>5);\n\tsb=b&0x1F;\n\treturn (p[si]>>sb)&1;\n}\n\n\nint group_max_calc(int v)\n{\n\tint i;\n\n\tif(v<0) return 0;\n\tfor(i=0;(1<<i)<=v;i++)\n\t\t;\n\treturn i+1;\n}\n\n\nint group_calc(group_t d[], group_t s[], int s_num, int v)\n{\n\tint i, j;\n\tint d_num=0, d_num_limit;\n\n\td_num_limit=group_max_calc(v);\n//printf(\"v=%d d_num_limit=%d\\n\", v, d_num_limit);\n\tfor(i=0;i<s_num;i++)\n\t{\n\t\tif(s[i].is_invalid) continue;\n\n\t\td[d_num].l=s[i].l;\n\t\td[d_num].is_invalid=0;\n\t\tfor(j=s[i].l;j<s[i].r;j++)\n\t\t{\n\t\t\tif(x[j+1]-x[j]>v)\n\t\t\t{\n\t\t\t\td[d_num++].r=j;\n\t\t\t\tif(d_num>=d_num_limit) return -1;\n\t\t\t\td[d_num].l=j+1;\n\t\t\t\td[d_num].is_invalid=0;\n\t\t\t}\n\t\t}\n\t\td[d_num++].r=j;\n\t}\n\treturn d_num;\n}\n\n\nint calc(group_t group[], int group_num, int depth)\n{\n\tgroup_t *group2;\n\tint group2_num;\n\tint i, v2, ret=0;\n\n\tif(map_get(dp[depth], &g_key[depth], &ret)) return ret;\n\n\tgroup2=g_group[depth];\n\tv2=(v>>depth);\n\tgroup2_num=group_calc(group2, group, group_num, v2);\n\tif(group2_num<0) return 0;\n\n\tif(0)\n\t{\n\t\tprintf(\"group_num=%d depth=%d v=%d\", group_num, depth, v);\n\t\tfor(i=0;i<group_num;i++)\n\t\t{\n//\t\t\tif(group[i].is_invalid) continue;\n\t\t\tprintf(\" %d-%d[%d]\", group[i].l, group[i].r, group[i].is_invalid);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif(0)\n\t{\n\t\tprintf(\"group2_num=%d depth=%d v2=%d\", group2_num, depth, v2);\n\t\tfor(i=0;i<group2_num;i++)\n\t\t{\n//\t\t\tif(group2[i].is_invalid) continue;\n\t\t\tprintf(\" %d-%d[%d]\", group2[i].l, group2[i].r, group2[i].is_invalid);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif(v2<=0)\n\t{\n\t\treturn (group2_num<=1);\n\t}\n\tif(group2_num<=1)\n\t{\n\t\treturn 1;\n\t}\n\n\tfor(i=0;i<group2_num;i++)\n\t{\n\t\tg_key[depth+1]=g_key[depth];\n\t\tbit_set(&g_key[depth+1], group2[i].l, group2[i].r);\n\t\tgroup2[i].is_invalid=1;\n\t\tif(calc(group2, group2_num, depth+1)) ret=1;\n\t\tgroup2[i].is_invalid=0;\n\t}\n\n\tmap_add(dp[depth], &g_key[depth], &ret);\n\n\treturn ret;\n}\n\n\nint main(void)\n{\n\tint i, j, group_num, result;\n\tgroup_t temp, group[GROUP_MAX];\n\n\tfor(i=0;i<=GROUP_MAX;i++) dp[i]=map_alloc(1000);\nif(0)\n{\n\tchar xxx[100]={0};\n\tbit_set(xxx, 2, 8);\n\tfor(i=0;i<50;i++) printf(\"%d\", bit_get(xxx, i));\n\tprintf(\"\\n\");\n\texit(1);\n}\n\n\twhile(scanf(\"%d%d\", &n, &v)==2)\n\t{\n\t\tfor(i=0;i<=GROUP_MAX;i++) map_clear(dp[i]);\n//\t\tprintf(\"\\nn=%d v=%d\\n\", n, v);\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x[i]);\n\t\t}\n\t\ttemp.l=0;\n\t\ttemp.r=n-1;\n\t\ttemp.is_invalid=0;\n\t\tgroup_num=group_calc(group, &temp, 1, v);\n\t\tfor(i=0;i<group_num;i++)\n\t\t{\n\t\t\tg_key[1]=g_key[0];\n\t\t\tbit_set(g_key[1].key, group[i].l, group[i].r);\n\t\t\tgroup[i].is_invalid=1;\n\t\t\tresult=calc(group, group_num, 1);\n\t\t\tgroup[i].is_invalid=0;\n\t\t\tfor(j=group[i].l;j<=group[i].r;j++)\n\t\t\t{\n\t\t\t\tprintf(\"%s\\n\", result?\"Possible\":\"Impossible\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pb2 pop_back\n#define pf push_front\n#define pf2 pop_front\n#define line printf(\"\\n\")\n#define rep(k,i,j) for(int k = (int)i;k<(int) j;k++)\n#define repd(k,i,j) for(int k = i;k>=(int)j;k--)\n#define ll long long\n#define pq priority_queue\n\nint dirx[8] = {0,1,0,-1,1,1,-1,-1};\nint diry[8] = {1,0,-1,0,1,-1,1,-1};\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e16;\nconst double EPS = 1e-6;\n\nusing namespace std;\n\nconst int maxn = 5e5+5;\n\nint n,v;\nint loc[maxn];\n\nint jump[maxn][20],m;\n\nint dp[maxn];\n\nint ch[maxn];\n\nint in_q[maxn];\n\nqueue<int> q;\nint solve(){\n\tmemset(dp,-1,sizeof dp);\n\tmemset(in_q,0,sizeof in_q);\n\t\n\tq.push(1);\n\tdp[1] = ch[0];\n\tin_q[1] = 1;\n\t\n\twhile(q.size()){\n\t\tint mask = q.front();\n\t\tint a = dp[mask];\n\t\t\n\t\tq.pop();\n\t\tin_q[mask] = 0;\n\t\t\n\t\tif(a==n)return 1;\n\t\trep(k,0,m)if(((1<<k)&mask)==0){\n\t\t\tint b = ch[jump[a][k]];\n\t\t\tint maskb = (mask|(1<<k));\n\t\t\t\n\t\t\tif(dp[maskb]<b){\n\t\t\t\tdp[maskb] = b;\n\t\t\t\tif(!in_q[maskb])q.push(maskb),in_q[maskb] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&v);\n\t\n\trep(k,0,n)scanf(\"%d\",&loc[k]);\n\t\n\t\n\tfor(;v>=0;v/=2){\n\t\trep(k,0,n){\n\t\t\tint i = k;\n\t\t\twhile(i<n){\n\t\t\t\tif(i<n-1 && loc[i+1]-loc[i]<=v){\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\twhile(k<=i)jump[k++][m] = i+1;\n\t\t\tk = i;\n\t\t}\n\t\t//printf(\"%d \\n\",v);\n\t\tm++;\n\t\tif(v==0)break;\n\t}\n\t\n\tif(m>=20)return 0;\n\t\n\trep(k,0,maxn)ch[k] = k;\n\t\n\tint hit = 0;\n\trep(k,0,n){\n\t\tif(hit>18){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint nxt = jump[k][0];\n\t\t\n\t\thit++;\n\t\tch[k] = nxt;\n\t\tint ret = solve();\n\t\tch[k] = k;\n\t\t\n\t\twhile(k<nxt)printf(\"%s\\n\",ret?\"Possible\":\"Impossible\"),k++;\n\t\tk = nxt-1;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n\n#define N_MAX     200000\n#define GROUP_MAX 18\n#define DP_SIZE   ((N_MAX+31)/32)\n\n\n\ntypedef struct tag_group_t\n{\n\tint l, r, is_invalid;\n}group_t;\n\n\nunsigned long dp[GROUP_MAX][DP_SIZE];\ngroup_t g_group[GROUP_MAX+1][GROUP_MAX+1];\nint group_num;\nint n, v;\nint x[N_MAX];\n\n\nint group_max_calc(int v)\n{\n\tint i;\n\n\tif(v<0) return 0;\n\tfor(i=0;(1<<i)<=v;i++)\n\t\t;\n\treturn i+1;\n}\n\n\nint group_calc(group_t d[], group_t s[], int s_num, int v)\n{\n\tint i, j;\n\tint d_num=0, d_num_limit;\n\n\td_num_limit=group_max_calc(v);\n//printf(\"v=%d d_num_limit=%d\\n\", v, d_num_limit);\n\tfor(i=0;i<s_num;i++)\n\t{\n\t\tif(s[i].is_invalid) continue;\n\n\t\td[d_num].l=s[i].l;\n\t\td[d_num].is_invalid=0;\n\t\tfor(j=s[i].l;j<s[i].r;j++)\n\t\t{\n\t\t\tif(x[j+1]-x[j]>v)\n\t\t\t{\n\t\t\t\td[d_num++].r=j;\n\t\t\t\tif(d_num>=d_num_limit) return -1;\n\t\t\t\td[d_num].l=j+1;\n\t\t\t\td[d_num].is_invalid=0;\n\t\t\t}\n\t\t}\n\t\td[d_num++].r=j;\n\t}\n\treturn d_num;\n}\n\n\nint calc(group_t group[], int group_num, int depth)\n{\n\tgroup_t *group2;\n\tint group2_num;\n\tint i, v2, ret=0;\n\n\tgroup2=g_group[depth];\n\tv2=(v>>depth);\n\tgroup2_num=group_calc(group2, group, group_num, v2);\n\tif(group2_num<0) return 0;\n\n\tif(0)\n\t{\n\t\tprintf(\"group_num=%d depth=%d v=%d\", group_num, depth, v);\n\t\tfor(i=0;i<group_num;i++)\n\t\t{\n//\t\t\tif(group[i].is_invalid) continue;\n\t\t\tprintf(\" %d-%d[%d]\", group[i].l, group[i].r, group[i].is_invalid);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif(0)\n\t{\n\t\tprintf(\"group2_num=%d depth=%d v2=%d\", group2_num, depth, v2);\n\t\tfor(i=0;i<group2_num;i++)\n\t\t{\n//\t\t\tif(group2[i].is_invalid) continue;\n\t\t\tprintf(\" %d-%d[%d]\", group2[i].l, group2[i].r, group2[i].is_invalid);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif(v2<=0)\n\t{\n\t\treturn (group2_num<=1);\n\t}\n\tif(group2_num<=1)\n\t{\n\t\treturn 1;\n\t}\n\n\tfor(i=0;i<group2_num;i++)\n\t{\n\t\tgroup2[i].is_invalid=1;\n\t\tif(calc(group2, group2_num, depth+1)) ret=1;\n\t\tgroup2[i].is_invalid=0;\n\t}\n\n\treturn ret;\n}\n\n\nint main(void)\n{\n\tint i, j, group_num, result;\n\tgroup_t temp, group[GROUP_MAX];\n\n\twhile(scanf(\"%d%d\", &n, &v)==2)\n\t{\n\t\tmemset(dp, 0, sizeof(dp));\n//\t\tprintf(\"\\nn=%d v=%d\\n\", n, v);\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x[i]);\n\t\t}\n\t\ttemp.l=0;\n\t\ttemp.r=n-1;\n\t\ttemp.is_invalid=0;\n\t\tgroup_num=group_calc(group, &temp, 1, v);\n\t\tfor(i=0;i<group_num;i++)\n\t\t{\n\t\t\tgroup[i].is_invalid=1;\n\t\t\tresult=calc(group, group_num, 1);\n\t\t\tgroup[i].is_invalid=0;\n\t\t\tfor(j=group[i].l;j<=group[i].r;j++)\n\t\t\t{\n\t\t\t\tprintf(\"%s\\n\", result?\"Possible\":\"Impossible\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n\n#define N_MAX     200000\n#define GROUP_MAX 18\n#define DP_SIZE   ((N_MAX+31)/32)\n\n\n\ntypedef struct tag_group_t\n{\n\tint l, r, is_invalid;\n}group_t;\n\n\nunsigned long dp[GROUP_MAX][DP_SIZE];\ngroup_t g_group[GROUP_MAX+1][GROUP_MAX+1];\nint group_num;\nint n, v;\nint x[N_MAX];\n\n\nint group_max_calc(int v)\n{\n\tint i;\n\n\tif(v<0) return 0;\n\tfor(i=0;(1<<i)<=v;i++)\n\t\t;\n\treturn i+1;\n}\n\n\nint group_calc(group_t d[], group_t s[], int s_num, int v)\n{\n\tint i, j;\n\tint d_num=0, d_num_limit;\n\n\td_num_limit=group_max_calc(v);\n//printf(\"v=%d d_num_limit=%d\\n\", v, d_num_limit);\n\tfor(i=0;i<s_num;i++)\n\t{\n\t\tif(s[i].is_invalid) continue;\n\n\t\td[d_num].l=s[i].l;\n\t\td[d_num].is_invalid=0;\n\t\tfor(j=s[i].l;j<s[i].r;j++)\n\t\t{\n\t\t\tif(x[j+1]-x[j]>v)\n\t\t\t{\n\t\t\t\td[d_num++].r=j;\n\t\t\t\tif(d_num>=d_num_limit) return -1;\n\t\t\t\td[d_num].l=j+1;\n\t\t\t\td[d_num].is_invalid=0;\n\t\t\t}\n\t\t}\n\t\td[d_num++].r=j;\n\t}\n\treturn d_num;\n}\n\n\nint calc(group_t group[], int group_num, int depth)\n{\n\tgroup_t *group2;\n\tint group2_num;\n\tint i, v2, ret=0;\n\n\tgroup2=g_group[depth];\n\tv2=(v>>depth);\n\tgroup2_num=group_calc(group2, group, group_num, v2);\n\tif(group2_num<0) return 0;\n\n\tif(0)\n\t{\n\t\tprintf(\"group_num=%d depth=%d v=%d\", group_num, depth, v);\n\t\tfor(i=0;i<group_num;i++)\n\t\t{\n//\t\t\tif(group[i].is_invalid) continue;\n\t\t\tprintf(\" %d-%d[%d]\", group[i].l, group[i].r, group[i].is_invalid);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif(0)\n\t{\n\t\tprintf(\"group2_num=%d depth=%d v2=%d\", group2_num, depth, v2);\n\t\tfor(i=0;i<group2_num;i++)\n\t\t{\n//\t\t\tif(group2[i].is_invalid) continue;\n\t\t\tprintf(\" %d-%d[%d]\", group2[i].l, group2[i].r, group2[i].is_invalid);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif(v2<=0)\n\t{\n\t\treturn (group2_num<=1);\n\t}\n\tif(group2_num<=1)\n\t{\n\t\treturn 1;\n\t}\n\n\tfor(i=0;i<group2_num;i++)\n\t{\n\t\tgroup2[i].is_invalid=1;\n\t\tif(calc(group2, group2_num, depth+1)) ret=1;\n\t\t}\n\t\tgroup2[i].is_invalid=0;\n\t}\n\n\treturn 0;\n}\n\n\nint main(void)\n{\n\tint i, j, group_num, result;\n\tgroup_t temp, group[GROUP_MAX];\n\n\twhile(scanf(\"%d%d\", &n, &v)==2)\n\t{\n\t\tmemset(dp, 0, sizeof(dp));\n//\t\tprintf(\"\\nn=%d v=%d\\n\", n, v);\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x[i]);\n\t\t}\n\t\ttemp.l=0;\n\t\ttemp.r=n-1;\n\t\ttemp.is_invalid=0;\n\t\tgroup_num=group_calc(group, &temp, 1, v);\n\t\tfor(i=0;i<group_num;i++)\n\t\t{\n\t\t\tgroup[i].is_invalid=1;\n\t\t\tresult=calc(group, group_num, 1);\n\t\t\tgroup[i].is_invalid=0;\n\t\t\tfor(j=group[i].l;j<=group[i].r;j++)\n\t\t\t{\n\t\t\t\tprintf(\"%s\\n\", result?\"Possible\":\"Impossible\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\nhwll bits[N_MAX];\n\null vs[N_MAX], vlen = 0;\null termiL[N_MAX][20], termiR[N_MAX][20];\nsll dpL[1 << 20], dpR[1 << 20];\n\nsll req[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\twhile (true) {\n\t\tvs[vlen] = k;\n\t\tvlen++;\n\t\tif (!k) break;\n\t\tk /= 2;\n\t}\n\n\tsll tnal;\n\n\tfor (i = 0; i < vlen; i++) {\n\t\ttnal = n - 1;\n\t\tfor (j = n - 1; j >= 0; j--) {\n\t\t\ttermiR[j][i] = tnal;\n\t\t\t// printf(\"%lld-> %lld (%lld)\\n\", j, tnal, i);\n\n\t\t\tif (j && a[j] - a[j - 1] > vs[i]) tnal = j - 1;\n\t\t}\n\t\ttnal = 0;\n\t\tfor (j = 0; j < n; j++) {\n\t\t\ttermiL[j][i] = tnal;\n\t\t\t// printf(\"<-%lld %lld (%lld)\\n\", j, tnal, i);\n\n\t\t\tif (j < n - 1 && a[j + 1] - a[j] > vs[i]) tnal = j + 1;\n\t\t}\n\t}\n\n\tull bitlen = (1LL << vlen) / 2;\n\tfor (i = 0; !(i >> (vlen)); i += 2) {\n\t\tbits[i / 2] = (hwll){bitcount(i), i};\n\t}\n\tqsort(bits, bitlen, sizeof(hwll), phwllABcomp);\n\n\tdpL[0] = -1;\n\tfor (i = 1; i < bitlen; i++) {\n\t\tull v = bits[i].b;\n\n\t\tdpL[v] = -1;\n\t\tfor (j = 1; j < vlen; j++) {\n\t\t\tif (!(v & (1LL << j))) continue;\n\n\t\t\tull prev = v ^ (1LL << j);\n\t\t\tsll pdp = dpL[prev];\n\t\t\tif (pdp == n - 1) {\n\t\t\t\tdpL[v] = n - 1;\n\t\t\t} else {\n\t\t\t\tdpL[v] = smax(dpL[v], termiR[pdp + 1][j]);\n\t\t\t}\n\t\t}\n\t\t// printf(\"L %lld; %llu\\n\", v, dpL[v]);\n\t}\n\tdpR[0] = n;\n\tfor (i = 1; i < bitlen; i++) {\n\t\tull v = bits[i].b;\n\n\t\tdpR[v] = n;\n\t\tfor (j = 1; j < vlen; j++) {\n\t\t\tif (!(v & (1LL << j))) continue;\n\n\t\t\tull prev = v ^ (1LL << j);\n\t\t\tsll pdp = dpR[prev];\n\t\t\tif (pdp == 0) {\n\t\t\t\tdpR[v] = 0;\n\t\t\t} else {\n\t\t\t\tdpR[v] = smin(dpR[v], termiL[pdp - 1][j]);\n\t\t\t}\n\t\t}\n\t\t// printf(\"R %lld; %llu\\n\", v, dpR[v]);\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\treq[i] = -1;\n\t}\n\tbool isall = false;\n\tfor (i = 0; i < bitlen; i++) {\n\t\tull v = bits[i].b;\n\t\tull u = bits[bitlen - 1].b ^ v;\n\n\t\tif (dpL[v] + 1 >= dpR[u]) {\n\t\t\tisall = true;\n\t\t\tbreak;\n\t\t}\n\t\treq[dpR[u] - 1] = smax(req[dpR[u] - 1], dpL[v] + 1);\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\treq[i] = smax(req[i], req[i - 1]);\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tsll coverL = termiL[i][0], coverR = termiR[i][0];\n\n\t\t// printf(\"%lld: %lld ~ %lld\\n\", i, coverL, coverR);\n\t\tif (isall || req[coverR] >= coverL) {\n\t\t\tputs(\"Possible\");\n\t\t} else {\n\t\t\tputs(\"Impossible\");\n\t\t}\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Hanako\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Jiro\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\tscanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint V = sc.nextInt();\n\t\tlong[] x = new long[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tx[i] = sc.nextLong();\n\t\t}\n\n\t\tint cnt = 0;\n\t\tint tmp = V;\n\t\twhile (tmp > 0) {\n\t\t\t++cnt;\n\t\t\ttmp /= 2;\n\t\t}\n\t\t++cnt;\n\t\tint[] Vs = new int[cnt];\n\t\tVs[0] = V;\n\t\tfor (int i = 1; i < cnt; ++i) {\n\t\t\tVs[i] = Vs[i - 1] / 2;\n\t\t}\n\t\tint[][] toRight = new int[cnt][N];\n\t\tint[][] toLeft = new int[cnt][N];\n\t\tfor (int i = 0; i < cnt; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\ttoRight[i][j] = j;\n\t\t\t\ttoLeft[i][j] = j;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < cnt; ++i) {\n\t\t\tfor (int j = N - 2; j >= 0; --j) {\n\t\t\t\tif (x[j + 1] - x[j] <= Vs[i]) {\n\t\t\t\t\ttoRight[i][j] = toRight[i][j + 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; ++i) {\n\t\t\tfor (int j = 1; j < N; ++j) {\n\t\t\t\tif (x[j] - x[j - 1] <= Vs[i]) {\n\t\t\t\t\ttoLeft[i][j] = toLeft[i][j - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] dpRight = new int[1 << cnt];\n\t\tint[] dpLeft = new int[1 << cnt];\n\n\t\tArrays.fill(dpLeft, N);\n\t\tArrays.fill(dpRight, -1);\n\n\t\tfor (int i = 0; i < (1 << cnt); ++i) {\n\t\t\tfor (int nxt = 0; nxt < cnt; ++nxt) {\n\t\t\t\tif ((i & (1 << nxt)) > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint ni = i | (1 << nxt);\n\t\t\t\tdpRight[ni] = Math.max(dpRight[ni], dpRight[i]);\n\t\t\t\tif (dpRight[i] + 1 < N)\n\t\t\t\t\tdpRight[ni] = Math.max(dpRight[ni], toRight[nxt][dpRight[i] + 1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < (1 << cnt); ++i) {\n\t\t\tfor (int nxt = 0; nxt < cnt; ++nxt) {\n\t\t\t\tif ((i & (1 << nxt)) > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint ni = i | (1 << nxt);\n\t\t\t\tdpLeft[ni] = Math.min(dpLeft[ni], dpLeft[i]);\n\t\t\t\tif (dpLeft[i] - 1 >= 0)\n\t\t\t\t\tdpLeft[ni] = Math.min(dpLeft[ni], toLeft[nxt][dpLeft[i] - 1]);\n\t\t\t}\n\t\t}\n\t\tint[] ans = new int[N];\n\t\tfor (int i = 0; i < (1 << cnt); i += 2) {\n\t\t\tint co = ((1 << cnt) - 1) ^ i;\n\t\t\tco -= 1;\n\t\t\tif (dpLeft[co] - dpRight[i] <= 1) {\n\t\t\t\tArrays.fill(ans, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dpLeft[co] - toRight[0][dpRight[i] + 1] <= 1) {\n\t\t\t\t++ans[toLeft[0][dpLeft[co] - 1]];\n\t\t\t\tif (toRight[0][dpRight[i] + 1] + 1 < N) {\n\t\t\t\t\t--ans[toRight[0][dpRight[i] + 1] + 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tans[i] += ans[i - 1];\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (ans[i] > 0) {\n\t\t\t\tSystem.out.println(\"Possible\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Impossible\");\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// package atcoder.agc.agc012;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int v = in.nextInt();\n\n        int[] x = in.nextInts(n);\n        int vv = v;\n        int maxJump = 0;\n        while (vv >= 1) {\n            maxJump++;\n            vv /= 2;\n        }\n        maxJump++;\n\n        int[][] nextRight = new int[maxJump][n];\n        for (int d = 0 ; d < maxJump ; d++) {\n            int canGo = v >>> d;\n\n            for (int i = 0 ; i < n ;) {\n                int j = i+1;\n                while (j < n && x[j] - x[j-1] <= canGo) {\n                    j++;\n                }\n                for (int k = i ; k < j ; k++) {\n                    nextRight[d][k] = j;\n                }\n                i = j;\n            }\n        }\n\n        int[][] nextLeft = new int[maxJump][n];\n        for (int d = 0 ; d < maxJump ; d++) {\n            int canGo = v >>> d;\n            for (int i = n-1 ; i >= 0 ;) {\n                int j = i-1;\n                while (j >= 0 && x[j+1] - x[j] <= canGo) {\n                    j--;\n                }\n                for (int k = i ; k > j ; k--) {\n                    nextLeft[d][k] = j;\n                }\n                i = j;\n            }\n        }\n\n        int[] dpLeft = new int[1<<maxJump];\n        for (int i = 0 ; i < (1<<maxJump) ; i += 2) {\n            for (int k = 1 ; k < maxJump ; k++) {\n                if (((i >> k) & 1) == 0) {\n                    int ti = i | (1<<k);\n                    dpLeft[ti] = Math.max(dpLeft[ti], dpLeft[i] == n ? n : nextRight[k][dpLeft[i]]);\n\n                }\n            }\n        }\n\n        int[] dpRight = new int[1<<maxJump];\n        Arrays.fill(dpRight, n-1);\n        for (int i = 0 ; i < (1<<maxJump) ; i += 2) {\n            for (int k = 1 ; k < maxJump ; k++) {\n                if (((i >> k) & 1) == 0) {\n                    int ti = i | (1<<k);\n                    dpRight[ti] = Math.min(dpRight[ti], dpRight[i] == -1 ? -1 : nextLeft[k][dpRight[i]]);\n                }\n            }\n        }\n\n        for (int i = 0 ; i < n ; i++) {\n            boolean isOK = false;\n            int from = nextLeft[0][i] + 1;\n            int to = nextRight[0][i] - 1;\n            int fullPtn = (1<<maxJump)-2;\n            for (int leftPtn = 0 ; leftPtn < (1<<maxJump) ; leftPtn += 2) {\n                int rightPtn = fullPtn-leftPtn;\n                int leftPart = dpLeft[leftPtn];\n                int rightPart = dpRight[rightPtn];\n                if (from <= leftPart && rightPart <= to) {\n                    isOK = true;\n                    break;\n                }\n            }\n            out.println(isOK ? \"Possible\" : \"Impossible\");\n        }\n        out.flush();\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), V = ni();\n\t\tint[] x = na(n);\n\t\tString IMP = \"Impossible\";\n\t\tString P = \"Possible\";\n\t\tint[] ws = new int[20];\n\t\tint p = 0;\n\t\tfor(int w = V;w >= 0;w/=2){\n\t\t\tws[p++] = w;\n\t\t\tif(w == 0)break;\n\t\t}\n\t\t\n\t\tDJSet ds = new DJSet(n);\n\t\tint[][] tos = new int[20][];\n\t\tfor(int i = p-1;i >= 0;i--){\n\t\t\ttos[i] = new int[n];\n\t\t\tfor(int j = 0;j < n-1;j++){\n\t\t\t\tif(x[j+1] - x[j] <= ws[i]){\n\t\t\t\t\tds.union(j, j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\ttos[i][j] = ds.max[ds.root(j)];\n\t\t\t}\n\t\t}\n\t\tif(ds.count() > p){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tout.println(IMP);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n;){\n\t\t\tint right = ds.max[ds.root(i)];\n\t\t\t// [i,right]\n\t\t\tint[] reach = new int[1<<p-1];\n\t\t\tArrays.fill(reach, -1);\n\t\t\treach[0] = i == 0 ? right : -1;\n\t\t\tfor(int j = 0;j < 1<<p-1;j++){\n\t\t\t\tfor(int k = 0;k < p-1;k++){\n\t\t\t\t\tif(j<<~k>=0){\n\t\t\t\t\t\tint ne = reach[j] + 1;\n\t\t\t\t\t\tif(ne == n){\n\t\t\t\t\t\t\treach[j|1<<k] = n-1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint nval = tos[k+1][ne];\n\t\t\t\t\t\tif(i-1 <= nval && nval <= right){\n\t\t\t\t\t\t\tnval = right;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treach[j|1<<k] = Math.max(reach[j|1<<k], nval);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(reach[(1<<p-1)-1] == n-1){\n\t\t\t\tfor(int k = i;k <= right;k++){\n\t\t\t\t\tout.println(P);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int k = i;k <= right;k++){\n\t\t\t\t\tout.println(IMP);\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = ds.max[ds.root(i)]+1;\n\t\t}\n\t}\n\t\n\tpublic static class DJSet {\n\t\tpublic int[] upper;\n\t\tpublic int[] min;\n\t\tpublic int[] max;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t\tmin = new int[n];\n\t\t\tfor(int i = 0;i < n;i++)min[i] = i;\n\t\t\tmax = Arrays.copyOf(min, n);\n\t\t}\n\n\t\tpublic int root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tpublic boolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tpublic boolean union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[y] < upper[x]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tmin[x] = Math.min(min[x], min[y]);\n\t\t\t\tmax[x] = Math.max(max[x], max[y]);\n\t\t\t\tupper[x] += upper[y];\n\t\t\t\tupper[y] = x;\n\t\t\t}\n\t\t\treturn x == y;\n\t\t}\n\n\t\tpublic int count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : upper)\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint V = sc.nextInt();\n\t\tlong[] x = new long[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tx[i] = sc.nextLong();\n\t\t}\n\n\t\tint cnt = 0;\n\t\tint tmp = V;\n\t\twhile (tmp > 0) {\n\t\t\t++cnt;\n\t\t\ttmp /= 2;\n\t\t}\n\t\t++cnt;\n\t\tint[] Vs = new int[cnt];\n\t\tVs[0] = V;\n\t\tfor (int i = 1; i < cnt; ++i) {\n\t\t\tVs[i] = Vs[i - 1] / 2;\n\t\t}\n\n\t\tDJSet[] ds = new DJSet[cnt];\n\t\tfor (int i = 0; i < ds.length; ++i) {\n\t\t\tds[i] = new DJSet(N);\n\t\t}\n\t\tfor (int i = 0; i < cnt; ++i) {\n\t\t\tfor (int j = 0; j + 1 < N; ++j) {\n\t\t\t\tif (Math.abs(x[j] - x[j + 1]) <= Vs[i]) {\n\t\t\t\t\tds[i].setUinon(j, j + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] dpRight = new int[1 << cnt];\n\t\tint[] dpLeft = new int[1 << cnt];\n\n\t\tArrays.fill(dpLeft, N);\n\t\tArrays.fill(dpRight, -1);\n\n\t\tfor (int i = 0; i < (1 << cnt); ++i) {\n\t\t\tfor (int nxt = 0; nxt < cnt; ++nxt) {\n\t\t\t\tif ((i & (1 << nxt)) > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint ni = i | (1 << nxt);\n\t\t\t\tdpRight[ni] = Math.max(dpRight[ni], dpRight[i]);\n\t\t\t\tif (dpRight[i] + 1 < N)\n\t\t\t\t\tdpRight[ni] = Math.max(dpRight[ni], ds[nxt].max(dpRight[i] + 1));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < (1 << cnt); ++i) {\n\t\t\tfor (int nxt = 0; nxt < cnt; ++nxt) {\n\t\t\t\tif ((i & (1 << nxt)) > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint ni = i | (1 << nxt);\n\t\t\t\tdpLeft[ni] = Math.min(dpLeft[ni], dpLeft[i]);\n\t\t\t\tif (dpLeft[i] - 1 >= 0)\n\t\t\t\t\tdpLeft[ni] = Math.min(dpLeft[ni], ds[nxt].min(dpLeft[i] - 1));\n\t\t\t}\n\t\t}\n\t\tint[] ans = new int[N];\n\t\tfor (int i = 0; i < (1 << cnt); i += 2) {\n\t\t\tint co = ((1 << cnt) - 1) ^ i;\n\t\t\tco -= 1;\n\t\t\tif (dpLeft[co] - dpRight[i] <= 1) {\n\t\t\t\tArrays.fill(ans, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dpLeft[co] - ds[0].max(dpRight[i] + 1) <= 1) {\n\t\t\t\t++ans[ds[0].min(dpLeft[co] - 1)];\n\t\t\t\tif (ds[0].max(dpRight[i] + 1) + 1 < N) {\n\t\t\t\t\t--ans[ds[0].max(dpRight[i] + 1) + 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tans[i] += ans[i - 1];\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (ans[i] > 0) {\n\t\t\t\tSystem.out.println(\"Possible\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Impossible\");\n\t\t\t}\n\t\t}\n\t}\n\n\tclass DJSet {\n\t\tint n;\n\t\tint[] upper;\n\t\tint[] max;\n\t\tint[] min;\n\n\t\tpublic DJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\tupper = new int[n];\n\t\t\tmin = new int[n];\n\t\t\tmax = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tmax[i] = i;\n\t\t\t\tmin[i] = i;\n\t\t\t}\n\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUinon(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tint tmp = x;\n\t\t\t\tx = y;\n\t\t\t\ty = tmp;\n\t\t\t}\n\t\t\tmin[y] = Math.min(min[y], min[x]);\n\t\t\tmax[y] = Math.max(max[y], max[x]);\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\n\t\tint max(int x) {\n\t\t\tx = root(x);\n\t\t\treturn max[x];\n\t\t}\n\n\t\tint min(int x) {\n\t\t\tx = root(x);\n\t\t\treturn min[x];\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint v = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\n\t\tint[] b = new int[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tb[i] = a[i + 1] - a[i];\n\t\t}\n\n\t\tint[] seq = new int[40];\n\t\tint ptr = 0;\n\t\twhile (true) {\n\t\t\tseq[ptr++] = v;\n\t\t\tif (v == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv /= 2;\n\t\t}\n\t\t\n\t\tfor (int i = 0, j = ptr - 1; i < j; i++, j--) {\n\t\t\tint tmp = seq[i];\n\t\t\tseq[i] = seq[j];\n\t\t\tseq[j] = tmp;\n\t\t}\n\n\t\tint[][] nxt = new int[ptr][n];\n\t\tint[][] prv = new int[ptr][n];\n\n\t\tfor (int i = 0; i < ptr; i++) {\n\t\t\tint gap = seq[i];\n\t\t\tfor (int j = 0; j < n;) {\n\t\t\t\tint nxtJ = j + 1;\n\t\t\t\twhile (nxtJ < n && b[nxtJ - 1] <= gap) {\n\t\t\t\t\tnxtJ++;\n\t\t\t\t}\n\n\t\t\t\tfor (int k = j; k < nxtJ; k++) {\n\t\t\t\t\tnxt[i][k] = nxtJ - 1;\n\t\t\t\t\tprv[i][k] = j;\n\t\t\t\t}\n\n\t\t\t\tj = nxtJ;\n\t\t\t}\n\t\t}\n\n\t\tint[] pref = new int[1 << (ptr - 1)];\n\t\tint[] suff = new int[1 << (ptr - 1)];\n\n\t\tfor (int mask = 0; mask < 1 << (ptr - 1); mask++) {\n\t\t\tfor (int i = 0; i < ptr - 1; i++) {\n\t\t\t\tif (test(mask, i)) {\n\t\t\t\t\tint was = pref[mask ^ (1 << i)];\n\t\t\t\t\tif (was == n) {\n\t\t\t\t\t\tpref[mask] = n;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpref[mask] = Math.max(pref[mask], nxt[i][was] + 1);\n\t\t\t\t\t}\n\n\t\t\t\t\twas = suff[mask ^ (1 << i)];\n\t\t\t\t\tif (was == n) {\n\t\t\t\t\t\tsuff[mask] = n;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsuff[mask] = Math.max(suff[mask], n - prv[i][n - 1 - was]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] maxLeft = new int[n + 1]; // index - length of right\n\t\tArrays.fill(maxLeft, -1);\n\t\tint allMask = (1 << (ptr - 1)) - 1;\n\t\tfor (int maskL = 0; maskL <= allMask; maskL++) {\n\t\t\tint maskR = allMask ^ maskL;\n\n\t\t\tint valL = pref[maskL];\n\t\t\tint valR = suff[maskR];\n\t\t\t\n\t\t\tmaxLeft[valR] = Math.max(maxLeft[valR], valL);\n\t\t}\n\n\t\tint canL = -1;\n\t\tfor (int i = 0; i < n;) {\n\t\t\tint j = nxt[ptr - 1][i];\n\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\tcanL = Math.max(canL, maxLeft[n - 1 - k]);\n\t\t\t}\n\n\t\t\tString outp = canL >= i ? \"Possible\" : \"Impossible\";\n\n\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\tout.println(outp);\n\t\t\t}\n\n\t\t\ti = j + 1;\n\t\t}\n\t}\n\n\tboolean test(int mask, int i) {\n\t\treturn ((mask >> i) & 1) == 1;\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// package atcoder.agc.agc012;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int v = in.nextInt();\n\n        int[] x = in.nextInts(n);\n        int vv = v;\n        int maxJump = 0;\n        while (vv >= 1) {\n            maxJump++;\n            vv /= 2;\n        }\n        maxJump++;\n\n        int[][] nextRight = new int[maxJump][n];\n        for (int d = 0 ; d < maxJump ; d++) {\n            int canGo = v >>> d;\n\n            for (int i = 0 ; i < n ;) {\n                int j = i+1;\n                while (j < n && x[j] - x[j-1] <= canGo) {\n                    j++;\n                }\n                for (int k = i ; k < j ; k++) {\n                    nextRight[d][k] = j;\n                }\n                i = j;\n            }\n        }\n\n        int requiredStep = 0;\n        for (int i = 0 ; i < n ; ) {\n            int j = nextRight[0][i];\n            requiredStep++;\n            i = j;\n        }\n        if (requiredStep >= 22) {\n            for (int i = 0; i < n ; i++) {\n                out.println(\"Impossible\");\n            }\n            out.flush();\n            return;\n        }\n\n        int[][] nextLeft = new int[maxJump][n];\n        for (int d = 0 ; d < maxJump ; d++) {\n            int canGo = v >>> d;\n            for (int i = n-1 ; i >= 0 ;) {\n                int j = i-1;\n                while (j >= 0 && x[j+1] - x[j] <= canGo) {\n                    j--;\n                }\n                for (int k = i ; k > j ; k--) {\n                    nextLeft[d][k] = j;\n                }\n                i = j;\n            }\n        }\n\n        int[] dpLeft = new int[1<<maxJump];\n        for (int i = 0 ; i < (1<<maxJump) ; i += 2) {\n            for (int k = 1 ; k < maxJump ; k++) {\n                if (((i >> k) & 1) == 0) {\n                    int ti = i | (1<<k);\n                    dpLeft[ti] = Math.max(dpLeft[ti], dpLeft[i] == n ? n : nextRight[k][dpLeft[i]]);\n\n                }\n            }\n        }\n\n        int[] dpRight = new int[1<<maxJump];\n        Arrays.fill(dpRight, n-1);\n        for (int i = 0 ; i < (1<<maxJump) ; i += 2) {\n            for (int k = 1 ; k < maxJump ; k++) {\n                if (((i >> k) & 1) == 0) {\n                    int ti = i | (1<<k);\n                    dpRight[ti] = Math.min(dpRight[ti], dpRight[i] == -1 ? -1 : nextLeft[k][dpRight[i]]);\n                }\n            }\n        }\n\n        for (int i = 0 ; i < n ; ) {\n            boolean isOK = false;\n            int from = nextLeft[0][i] + 1;\n            int to = nextRight[0][i] - 1;\n            int fullPtn = (1<<maxJump)-2;\n            for (int leftPtn = 0 ; leftPtn < (1<<maxJump) ; leftPtn += 2) {\n                int rightPtn = fullPtn-leftPtn;\n                int leftPart = dpLeft[leftPtn];\n                int rightPart = dpRight[rightPtn];\n                if (from <= leftPart && rightPart <= to) {\n                    isOK = true;\n                    break;\n                }\n            }\n            for (int j = from ; j <= to ; j++) {\n                out.println(isOK ? \"Possible\" : \"Impossible\");\n            }\n            i = to+1;\n        }\n        out.flush();\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)924844033;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tn = io.nextInt();\n\t\t\tV = io.nextInt();\n\t\t\tx = io.nextIntArray(n);\n\t\t\t\n\t\t\troot = new O(0, n, V);\n\t\t\tint d = 0;\n\t\t\tfor (int i = V; i > 0; i /= 2) d++;\n//\t\t\tfor (O o : root.childs) {\n//\t\t\t\tdump(root.childs.size(), d, o.l, o.r);\n//\t\t\t}\n\t\t\td0 = d;\n\t\t\tans = new boolean[n];\n\t\t\tfunc();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tio.out.println(ans[i] ? \"Possible\" : \"Impossible\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint d0;\n\tint n, V;\n\tint[] x;\n\tO root;\n\tMap<Long, Boolean> mp = new HashMap<>();\n\tboolean func() {\n\t\tif (root.childs.size() - 1 > d0) {\n\t\t\treturn false;\n\t\t}\n\t\tList<O> os = new ArrayList<>();\n\t\tfor (O o : root.childs) os.add(o);\n\t\treturn func(os, d0 + 1);\n\t}\n\tboolean[] ans;\n\tboolean func(List<O> os, int d) {\n\t\tif (os.isEmpty()) return true;\n\t\tif (d == 0) return false;\n\n\t\tlong h = 0;\n\t\tfor (O o : os) h += o.hash;\n\t\tif (mp.containsKey(h)) return mp.get(h);\n\t\t\n//\t\tfor (O o : os) {\n//\t\t\tdump(os.size(), d, o.l, o.r);\n//\t\t}\n\t\t\n\t\tList<O> oc = new ArrayList<>();\n\t\tLOOP: for (O o : os) {\n\t\t\tint size = 0;\n\t\t\toc.clear();\n\t\t\tfor (O t : os) {\n\t\t\t\tif (o == t) continue;\n\t\t\t\tsize += t.childs.size();\n\t\t\t\tif (size > d - 1) continue LOOP;\n\t\t\t\toc.addAll(t.childs);\n\t\t\t}\n\t\t\tif (func(oc, d - 1)) {\n\t\t\t\tif (d != d0 + 1) {\n\t\t\t\t\tmp.put(h, true);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = o.l; i < o.r; i++) ans[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmp.put(h, false);\n\t\treturn false;\n\t}\n\t\n\tclass O {\n\t\t// [l,r)\n\t\tint l, r;\n\t\tlong hash = random.nextLong();\n\t\tList<O> childs = new ArrayList<>();\n\t\t\n\t\tboolean include(int i) { return i >= l && i < r; }\n\t\t\n\t\tO(int l, int r, int v) {\n\t\t\tthis.l = l;\n\t\t\tthis.r = r;\n\t\t\tif (v > 0) {\n\t\t\t\tfor (int i = l, j; i < r; i = j) {\n\t\t\t\t\tfor (j = i + 1; j < r && x[j] - x[j-1] <= v; j++) ;\n\t\t\t\t\tchilds.add(new O(i, j, v / 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\t\n\tvoid printArrayLn(List<Integer> xs) { for(int i = 0; i < xs.size(); i++) io.out.print(xs.get(i) + (i==xs.size()-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "// package agc.agc012;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int V = in.nextInt();\n        int[] x = new int[n];\n        for (int i = 0; i < n ; i++) {\n            x[i] = in.nextInt();\n        }\n        int[] revx = x.clone();\n        for (int i = 0; i < x.length; i++) {\n            revx[i] = -x[n-1-i];\n        }\n\n        int[] left = doit(V, x);\n        int[] right = doit(V, revx);\n        int[] top = stepV(V, x);\n\n        UnionFind uf = new UnionFind(n);\n        for (int i = 0; i < n ; ) {\n            int j = i;\n            while (j < n && top[i] == top[j]) {\n                uf.unite(i, j);\n                j++;\n            }\n            i = j;\n        }\n\n        boolean[] isOK = new boolean[n];\n        int full = (1<<REDUCE)-1;\n        for (int leftp = 0 ; leftp <= full ; leftp++) {\n            if (left[leftp] + right[full-leftp] >= n) {\n                Arrays.fill(isOK, true);\n                continue;\n            }\n\n            int tc = top[left[leftp]];\n            int rp = right[full-leftp];\n            if (tc + rp >= n) {\n                //debug(leftp, left[leftp], top[left[leftp]]);\n                int id = uf.find(left[leftp]);\n                isOK[id] = true;\n                // ok!\n            }\n        }\n\n        for (int i = 0; i < n ; i++) {\n            out.println(isOK[uf.find(i)] ? \"Possible\" : \"Impossible\");\n        }\n        out.flush();\n    }\n\n    static int REDUCE = 19;\n\n    static class UnionFind {\n        int[] rank;\n        int[] parent;\n        int[] cnt;\n\n        public UnionFind(int n) {\n            rank = new int[n];\n            parent = new int[n];\n            cnt = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                cnt[i] = 1;\n            }\n        }\n\n        public int find(int a) {\n            if (parent[a] == a) {\n                return a;\n            }\n            parent[a] = find(parent[a]);\n            return parent[a];\n        }\n\n        public void unite(int a, int b) {\n            a = find(a);\n            b = find(b);\n            if (a == b) {\n                return;\n            }\n            if (rank[a] < rank[b]) {\n                parent[a] = b;\n                cnt[b] += cnt[a];\n                cnt[a] = cnt[b];\n            } else {\n                parent[b] = a;\n                cnt[a] += cnt[b];\n                cnt[b] = cnt[a];\n                if (rank[a] == rank[b]) {\n                    rank[a]++;\n                }\n            }\n        }\n\n        public int groupCount(int a) {\n            return cnt[find(a)];\n        }\n\n        private boolean issame(int a, int b) {\n            return find(a) == find(b);\n        }\n    }\n\n\n    static int[] stepV(int V, int[] x) {\n        int[] next = new int[x.length+1];\n        if (V == -1) {\n            return next;\n        }\n        for (int i = 0; i < x.length ; ) {\n            int j = i;\n            while (j+1 < x.length && x[j+1] - x[j] <= V) {\n                j++;\n            }\n            for (int k = i ; k <= j; k++) {\n                next[k] = j+1;\n            }\n            i = j+1;\n        }\n        next[x.length] = x.length;\n        return next;\n    }\n\n    static int[] doit(int V, int[] x) {\n        int[] vs = new int[REDUCE];\n        Arrays.fill(vs, -1);\n        vs[0] = V/2;\n        for (int i = 1 ; i < vs.length; i++) {\n            vs[i] = vs[i-1] / 2;\n            if (vs[i] == 0) {\n                break;\n            }\n        }\n        int[][] next = new int[REDUCE][];\n        for (int gi = 0 ; gi < next.length ; gi++) {\n            int v = vs[gi];\n            next[gi] = stepV(v, x);\n        }\n\n        int[] dp = new int[1<<REDUCE];\n        for (int set = 0; set < dp.length ; set++) {\n            for (int i = 0; i < REDUCE ; i++) {\n                if ((set & (1<<i)) >= 1) {\n                    continue;\n                }\n                int now = dp[set];\n                int ti = set | (1<<i);\n                dp[ti] = Math.max(dp[ti], Math.max(now, next[i][now]));\n            }\n        }\n        return dp;\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "// package atcoder.agc.agc012;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int v = in.nextInt();\n\n        int[] x = in.nextInts(n);\n        int vv = v;\n        int maxJump = 0;\n        while (vv >= 1) {\n            maxJump++;\n            vv /= 2;\n        }\n        maxJump++;\n\n        int[][] nextRight = new int[maxJump][n];\n        for (int d = 0 ; d < maxJump ; d++) {\n            int canGo = v >>> d;\n\n            for (int i = 0 ; i < n ;) {\n                int j = i+1;\n                while (j < n && x[j] - x[j-1] <= canGo) {\n                    j++;\n                }\n                for (int k = i ; k < j ; k++) {\n                    nextRight[d][k] = j;\n                }\n                i = j;\n            }\n        }\n\n        int[][] nextLeft = new int[maxJump][n];\n        for (int d = 0 ; d < maxJump ; d++) {\n            int canGo = v >>> d;\n            for (int i = n-1 ; i >= 0 ;) {\n                int j = i-1;\n                while (j >= 0 && x[j+1] - x[j] <= canGo) {\n                    j--;\n                }\n                for (int k = i ; k > j ; k--) {\n                    nextLeft[d][k] = j;\n                }\n                i = j;\n            }\n        }\n\n        int[] dpLeft = new int[1<<maxJump];\n        for (int i = 0 ; i < (1<<maxJump) ; i++) {\n            for (int k = 0 ; k < maxJump ; k++) {\n                if (((i >> k) & 1) == 0) {\n                    int ti = i | (1<<k);\n                    dpLeft[ti] = Math.max(dpLeft[ti], dpLeft[i] == n ? n : nextRight[k][dpLeft[i]]);\n\n                }\n            }\n        }\n\n        int[] dpRight = new int[1<<maxJump];\n        Arrays.fill(dpRight, n-1);\n        for (int i = 0 ; i < (1<<maxJump) ; i++) {\n            for (int k = 0 ; k < maxJump ; k++) {\n                if (((i >> k) & 1) == 0) {\n                    int ti = i | (1<<k);\n                    dpRight[ti] = Math.min(dpRight[ti], dpRight[i] == -1 ? -1 : nextLeft[k][dpRight[i]]);\n                }\n            }\n        }\n\n        for (int i = 0 ; i < n ; i++) {\n            boolean isOK = false;\n            int from = nextLeft[0][i] + 1;\n            int to = nextRight[0][i] - 1;\n            int fullPtn = (1<<maxJump)-2;\n            for (int leftPtn = 0 ; leftPtn < (1<<maxJump) ; leftPtn += 2) {\n                int rightPtn = fullPtn-leftPtn;\n                int leftPart = dpLeft[leftPtn];\n                int rightPart = dpRight[rightPtn];\n                if (from <= leftPart && rightPart <= to) {\n                    isOK = true;\n                    break;\n                }\n            }\n            out.println(isOK ? \"Possible\" : \"Impossible\");\n        }\n        out.flush();\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int N = int.Parse(str[0]);\n        long V = int.Parse(str[1]);\n        str = Console.ReadLine().Split(' ');\n        long[] X = new long[N];\n        for(int i=0;i<N;i++){\n            X[i] = int.Parse(str[i]);\n        }\n        int[] DPL;\n        int[] DPR;\n        int K;\n        {\n            int k = 0;\n            long V0 = V;\n            while(V0 > 0){\n                V0 /= 2;\n                k++;\n            }\n            K = 1 << k;\n            int[,] LT = new int[k,N];\n            V0 = V;\n            for(int i=0;i<k;i++){\n                V0 /= 2;\n                int p = N-1;\n                for(int j=N-1;j>=0;j--){\n                    if(j != N-1 && X[j+1] - X[j] > V0){\n                        p = j;\n                    }\n                    LT[i,j] = p;\n                }\n            }\n            DPL = new int[1 << k];\n            DPL[0] = -1;\n            for(int i=1;i<1<<k;i++){\n                int max = 0;\n                for(int j=0;j<k;j++){\n                    if((i & (1 << j)) != 0){\n                        max = Math.Max(max,DPL[i - (1 << j)] == N-1 ? N-1 : LT[j,DPL[i - (1 << j)]+1]);\n                    }\n                }\n                DPL[i] = max;\n            }\n            int[,] RT = new int[k,N];\n            V0 = V;\n            for(int i=0;i<k;i++){\n                V0 /= 2;\n                int p = 0;\n                for(int j=0;j<N;j++){\n                    if(j != 0 && X[j] - X[j-1] > V0){\n                        p = j;\n                    }\n                    RT[i,j] = p;\n                }\n            }\n            DPR = new int[1 << k];\n            DPR[0] = N;\n            for(int i=1;i<1<<k;i++){\n                int min = N-1;\n                for(int j=0;j<k;j++){\n                    if((i & (1 << j)) != 0){\n                        min = Math.Min(min,DPR[i - (1 << j)] == 0 ? 0 : RT[j,DPR[i - (1 << j)]-1]);\n                    }\n                }\n                DPR[i] = min;\n            }\n        }\n        int[] L = new int[K];\n        int[] R = new int[K];\n        for(int i=0;i<K;i++){\n            L[i] = DPL[i];\n            R[i] = DPR[K-1-i];\n        }\n        int[] P = new int[N+1];\n        Array.Sort(L,R);\n        {\n            int p = N+1;\n            int rp = K-1;\n            for(int i=N-1;i>=-1;i--){\n                while(rp >= 0 && L[rp] >= i){\n                    p = Math.Min(p,R[rp]);\n                    rp--;\n                }\n                P[i+1] = p;\n            }\n        }\n        {\n            int i = 0;\n            while(i < N){\n                int j = i;\n                while(i < N - 1 && X[i+1] - X[i] <= V){\n                    i++;\n                }\n                if(P[j] <= i+1){\n                    for(;j<=i;j++){\n                        sb.Append(\"Possible\\n\");\n                    }\n                }\n                else{\n                    for(;j<=i;j++){\n                        sb.Append(\"Impossible\\n\");\n                    }\n                }\n                i++;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nnamespace Program\n{\n    public class Solver\n    {\n        Random rnd = new Random();\n        public void Solve()\n        {\n            var n = ri;\n            var V = new List<int>() { ri };\n            while (V.Last() != 0) V.Add(V.Last() / 2);\n            V.Reverse();\n            Debug.WriteLine(V.AsJoinedString());\n            var m = V.Count;\n            var pos = new long[n + 1]; pos[n] = INF;\n            for (int i = 0; i < n; i++)\n                pos[i] = ri;\n            var to = Enumerate(m, x => new int[n]);\n            for (int k = 0; k < m; k++)\n                for (int i = n - 1; i >= 0; i--)\n                {\n                    if (pos[i + 1] - pos[i] <= V[k]) to[k][i] = to[k][i + 1];\n                    else to[k][i] = i + 1;\n                }\n            if (solve(n, pos, to, -1, -1))\n            {\n                var p = 0;\n                while (p != n)\n                {\n                    var np = to[m - 1][p];\n                    var ok = solve(n, pos, to, p, np);\n                    for (int i = p; i < np; i++)\n                        Console.WriteLine(ok ? \"Possible\" : \"Impossible\");\n                    p = np;\n                }\n\n            }\n            else\n            {\n                for (int i = 0; i < n; i++)\n                    Console.WriteLine(\"Impossible\");\n            }\n\n\n\n        }\n        bool solve(int n, long[] pos, int[][] to, int l, int r)\n        {\n            var k = l == -1 ? to.Length : to.Length - 1;\n            Debug.WriteLine($\"{l} {r} {k}\");\n            var dp = new int[1 << k];\n            for (int i = 0; i < 1 << k; i++)\n            {\n                var p = dp[i];\n                if(l<=p&&p<r)p=r;\n                Debug.WriteLine($\"{i} {p}\");\n                if (p == n) return true;\n                for (int j = 0; j < k; j++)\n                    if ((i >> j & 1) == 0)\n                    {\n                        var t = to[j][p];\n                        dp[i | (1 << j)] = Max(dp[i | (1 << j)], t);\n                    }\n            }\n            return false;\n        }\n\n        const long INF = 1L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie);\n    }\n    static public void Main()\n    {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter\n    {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char()\n        {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int N = int.Parse(str[0]);\n        long V = int.Parse(str[1]);\n        str = Console.ReadLine().Split(' ');\n        long[] X = new long[N];\n        for(int i=0;i<N;i++){\n            X[i] = int.Parse(str[i]);\n        }\n        int[] DPL;\n        int[] DPR;\n        int K;\n        {\n            int k = 0;\n            long V0 = V;\n            while(V0 > 0){\n                V0 /= 2;\n                k++;\n            }\n            K = 1 << k;\n            int[,] LT = new int[k,N];\n            V0 = V;\n            for(int i=0;i<k;i++){\n                V0 /= 2;\n                int p = N-1;\n                for(int j=N-1;j>=0;j--){\n                    if(j != N-1 && X[j+1] - X[j] > V0){\n                        p = j;\n                    }\n                    LT[i,j] = p;\n                }\n            }\n            DPL = new int[1 << k];\n            DPL[0] = -1;\n            for(int i=1;i<1<<k;i++){\n                int max = 0;\n                for(int j=0;j<k;j++){\n                    if((i & (1 << j)) != 0){\n                        max = Math.Max(max,LT[j,DPL[i - (1 << j)]+1]);\n                    }\n                }\n                DPL[i] = max;\n            }\n            int[,] RT = new int[k,N];\n            V0 = V;\n            for(int i=0;i<k;i++){\n                V0 /= 2;\n                int p = 0;\n                for(int j=0;j<N;j++){\n                    if(j != 0 && X[j] - X[j-1] > V0){\n                        p = j;\n                    }\n                    RT[i,j] = p;\n                }\n            }\n            DPR = new int[1 << k];\n            DPR[0] = N;\n            for(int i=1;i<1<<k;i++){\n                int min = N-1;\n                for(int j=0;j<k;j++){\n                    if((i & (1 << j)) != 0){\n                        min = Math.Min(min,RT[j,DPR[i - (1 << j)]-1]);\n                    }\n                }\n                DPR[i] = min;\n            }\n        }\n        int[] L = new int[K];\n        int[] R = new int[K];\n        for(int i=0;i<K;i++){\n            L[i] = DPL[i];\n            R[i] = DPR[K-1-i];\n        }\n        int[] P = new int[N+1];\n        Array.Sort(L,R);\n        {\n            int p = N+1;\n            int rp = K-1;\n            for(int i=N-1;i>=-1;i--){\n                while(rp >= 0 && L[rp] >= i){\n                    p = Math.Min(p,R[rp]);\n                    rp--;\n                }\n                P[i+1] = p;\n            }\n        }\n        {\n            int i = 0;\n            while(i < N){\n                int j = i;\n                while(i < N - 1 && X[i+1] - X[i] <= V){\n                    i++;\n                }\n                if(P[j] <= i+1){\n                    for(;j<=i;j++){\n                        sb.Append(\"Possible\\n\");\n                    }\n                }\n                else{\n                    for(;j<=i;j++){\n                        sb.Append(\"Impossible\\n\");\n                    }\n                }\n                i++;\n            }\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n// import dcomp.functional;\n\nint n, m;\nlong[] x, v;\n\nint distLBase(int p, int f) {\n    if (p == n) return n;\n    if (p == n-1 || x[p+1]-x[p] > v[f]) return p+1;\n    return distL(p+1, f);\n}\nmemoCont!distLBase distL;\n\nint checkLBase(int f) {\n    int ans = 0;\n    foreach (i; 0..m) {\n        if (!(f & (1<<i))) continue;\n        ans = max(ans, distL(checkL(f ^ (1<<i)), i));\n    }\n    return ans;\n}\nmemoCont!checkLBase checkL;\n\nint distRBase(int p, int f) {\n    if (p == -1) return 0;\n    if (p == 0 || x[p]-x[p-1] > v[f]) return p;\n    return distR(p-1, f);\n}\nmemoCont!distRBase distR;\n\nint checkRBase(int f) {\n    int ans = n;\n    foreach (i; 0..m) {\n        if (!(f & (1<<i))) continue;\n        ans = min(ans, distR(checkR(f ^ (1<<i))-1, i));\n    }\n    return ans;\n}\nmemoCont!checkRBase checkR;\n\n\nint main() {\n    auto sc = new Scanner(stdin);\n    long V;\n    sc.read(n, V, x);\n\n    long buf = V;\n    while (V) {\n        V /= 2;\n        v ~= V;\n    }\n    V = buf;\n//    writeln(v);\n\n    m = v.length.to!int;\n\n    distL.init([[0, n], [0, 1<<m]]);\n    distR.init([[-1, n], [0, 1<<m]]);\n    checkL.init([[0, 1<<m]]);\n    checkR.init([[0, 1<<m]]);\n    int cnt = 0;\n    int l = 0;\n    while (l < n) {\n        int r = l+1;\n        while (r < n && x[r]-x[r-1] <= V) r++;\n//        writeln(l, \" \", r);\n        cnt++;\n        bool f = false;\n        if (cnt <= 22) {\n            foreach (i; 0..1<<m) {\n                int a = checkL(i);\n                int b = checkR(((1<<m)-1) ^ i);\n                if (l <= a && b <= r) {\n                    f = true;\n                }\n            }\n        }\n        foreach (i; 0..r-l) {\n            if (f) {\n                writeln(\"Possible\");\n            } else {\n                writeln(\"Impossible\");\n            }\n        }\n        l = r;\n    }\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/functional.d */\n// module dcomp.functional;\n\nstruct memoCont(alias pred) {\n    import core.exception : RangeError;\n    import std.range, std.algorithm, std.conv;\n    import std.string : join;\n    import std.traits : ReturnType, ParameterTypeTuple, isIntegral;\n    import std.typecons : tuple, Tuple;\n    import std.meta;\n    alias R = ReturnType!pred;\n    alias Args = ParameterTypeTuple!pred;\n    static assert (allSatisfy!(isIntegral, Args));\n    static immutable N = Args.length;\n    int[2][N] rng;\n    int[N] len;\n    R[] dp;\n    bool[] used;\n    void init(int[2][N] rng) {\n        this.rng = rng;\n        len = rng[].map!(a => a[1]-a[0]+1).array;\n        int sz = len.reduce!\"a*b\";\n        dp = new R[sz];\n        used = new bool[sz];\n    }\n    R opCall(Args args) {\n        int idx, base = 1;\n        foreach (i, v; args) {\n            version(assert) {\n                if (v < rng[i][0] || rng[i][1] < v) {\n                    throw new RangeError;\n                }\n            }\n            assert(rng[i][0] <= v && v <= rng[i][1]);\n            idx += base*(v - rng[i][0]);\n            base *= len[i];\n        }\n        if (used[idx]) return dp[idx];\n        used[idx] = true;\n        auto r = pred(args);\n        dp[idx] = r;\n        return r;\n    }\n}\n\nunittest {\n//     import dcomp.numeric.primitive;\n//     import dcomp.modint;\n    alias Mint = ModInt!(10^^9+7);\n    auto fact = factTable!Mint(100);\n    auto iFac = invFactTable!Mint(100);\n    Mint C0(int a, int b) {\n        if (a < 0 || a < b) return Mint(0);\n        return fact[a]*iFac[b]*iFac[a-b];\n    }\n    struct A {\n        static memoCont!C1base C1;\n        static Mint C1base(int a, int b) {\n            if (a == 0) {\n                if (b == 0) return Mint(1);\n                return Mint(0);\n            }\n            if (b < 0) return Mint(0);\n            return C1(a-1, b-1) + C1(a-1, b);\n        }\n    }\n    A.C1.init([[0, 100], [-2, 100]]);\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            assert(C0(i, j) == A.C1(i, j));\n        }\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n    auto opBinary(string op:\"*\")(ModInt r) const {return make( (long(v)*r.v%MD).to!uint );}\n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    static assert( is(ModInt!(uint(1000000000) * 2))); //not overflow\n    static assert(!is(ModInt!(uint(1145141919) * 2))); //overflow!\n    alias Mint = ModInt!(10^^9+7);\n    // negative check\n    assert(Mint(-1).v == 10^^9 + 6);\n    assert(Mint(-1L).v == 10^^9 + 6);\n\n    Mint a = 48;\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n\n    Mint c = Mint(15);\n    Mint d = Mint(3);\n    assert((c/d).v == 5);\n}\n\nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(DModInt r) {\n        return make(normS(v+r.v));\n    }\n    auto opBinary(string op:\"-\")(DModInt r) {\n        return make(normS(v+MD-r.v));\n    }\n    auto opBinary(string op:\"*\")(DModInt r) {\n        return make((long(v)*r.v%MD).to!uint);\n    }\n    auto opBinary(string op:\"/\")(DModInt r) {\n        return this*inv(r);\n    }\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    alias Mint = DModInt!(\"default\");\n    Mint.MD = 10^^9 + 7;\n    //negative check\n    assert(Mint(-1).v == 10^^9 + 6);\n    assert(Mint(-1L).v == 10^^9 + 6);\n    Mint a = Mint(48);\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n    Mint c = Mint(15);\n    Mint d = Mint(3);\n    assert((c/d).v == 5);\n}\n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n// optimize\nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\nunittest {\n    import std.stdio;\n    alias Mint = ModInt!(10^^9 + 7);\n    auto r = factTable!Mint(20);\n    Mint a = 1;\n    assert(r[0] == Mint(1));\n    foreach (i; 1..20) {\n        a *= Mint(i);\n        assert(r[i] == a);\n    }\n    auto p = invFactTable!Mint(20);\n    foreach (i; 1..20) {\n        assert((r[i]*p[i]).v == 1);\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                //todo optimize\n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File, writeln;\n    import std.datetime;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    foreach (i; 0..1_000_000) {\n        fout.writeln(3*i, \" \", 3*i+1, \" \", 3*i+2);\n    }\n    fout.close;\n    writeln(\"Scanner Speed Test(3*1,000,000 int)\");\n    StopWatch sw;\n    sw.start;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    foreach (i; 0..500_000) {\n        int a, b, c;\n        sc.read(a, b, c);\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    foreach (i; 500_000..700_000) {\n        int[3] d;\n        sc.read(d);\n        int a = d[0], b = d[1], c = d[2];\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    foreach (i; 700_000..1_000_000) {\n        int[] d;\n        sc.read(d);\n        assert(d.length == 3);\n        int a = d[0], b = d[1], c = d[2];\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    writeln(sw.peek.msecs, \"ms\");\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n//fold(for old compiler)\nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n    unittest {\n        import std.stdio;\n        auto l = [1, 2, 3, 4, 5];\n        assert(l.fold!\"a+b\"(10) == 25);\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\n\nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n\nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n\nunittest {\n    assert(pow(3, 5) == 243);\n    assert(pow(3, 5, 2) == 486);\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\nunittest {\n    assert(lcm(2, 4) == 4);\n    assert(lcm(3, 5) == 15);\n    assert(lcm(1, 1) == 1);\n    assert(lcm(0, 100) == 0);\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T) //unsignedはNG\n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nunittest {\n    import std.numeric : gcd;\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            auto e = extGcd(i, j);\n            assert(e[2] == gcd(i, j));\n            assert(e[0] * i + e[1] * j == e[2]);\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n\nint n, m;\nlong[] x, v;\n\nint distL(int p, int f) {\n    if (p == n) return n;\n    if (p == n-1 || x[p+1]-x[p] > v[f]) return p+1;\n    return distL(p+1, f);\n}\n\nint checkL(int f) {\n    int ans = 0;\n    foreach (i; 0..m) {\n        if (!(f & (1<<i))) continue;\n        ans = max(ans, distL(checkL(f ^ (1<<i)), i));\n    }\n    return ans;\n}\n\nint distR(int p, int f) {\n    if (p == -1) return 0;\n    if (p == 0 || x[p]-x[p-1] > v[f]) return p;\n    return distR(p-1, f);\n}\n\nint checkR(int f) {\n    int ans = n;\n    foreach (i; 0..m) {\n        if (!(f & (1<<i))) continue;\n        ans = min(ans, distR(checkR(f ^ (1<<i))-1, i));\n    }\n    return ans;\n}\n\n\nint main() {\n    auto sc = new Scanner(stdin);\n    long V;\n    sc.read(n, V, x);\n\n    long buf = V;\n    while (V) {\n        V /= 2;\n        v ~= V;\n    }\n    V = buf;\n//    writeln(v);\n\n    m = v.length.to!int;\n\n    int cnt = 0;\n    int l = 0;\n    while (l < n) {\n        int r = l+1;\n        while (r < n && x[r]-x[r-1] <= V) r++;\n//        writeln(l, \" \", r);\n        cnt++;\n        bool f = false;\n        if (cnt <= 22) {\n            foreach (i; 0..1<<m) {\n                int a = checkL(i);\n                int b = checkR(((1<<m)-1) ^ i);\n                if (l <= a && b <= r) {\n                    f = true;\n                }\n            }\n        }\n        foreach (i; 0..r-l) {\n            if (f) {\n                writeln(\"Possible\");\n            } else {\n                writeln(\"Impossible\");\n            }\n        }\n        l = r;\n    }\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n//fold(for old compiler)\nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n    unittest {\n        import std.stdio;\n        auto l = [1, 2, 3, 4, 5];\n        assert(l.fold!\"a+b\"(10) == 25);\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                //todo optimize\n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File, writeln;\n    import std.datetime;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    foreach (i; 0..1_000_000) {\n        fout.writeln(3*i, \" \", 3*i+1, \" \", 3*i+2);\n    }\n    fout.close;\n    writeln(\"Scanner Speed Test(3*1,000,000 int)\");\n    StopWatch sw;\n    sw.start;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    foreach (i; 0..500_000) {\n        int a, b, c;\n        sc.read(a, b, c);\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    foreach (i; 500_000..700_000) {\n        int[3] d;\n        sc.read(d);\n        int a = d[0], b = d[1], c = d[2];\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    foreach (i; 700_000..1_000_000) {\n        int[] d;\n        sc.read(d);\n        assert(d.length == 3);\n        int a = d[0], b = d[1], c = d[2];\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    writeln(sw.peek.msecs, \"ms\");\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n     \nvoid main() {\n    auto input = readln.split.map!(to!int);\n    auto N = input[0];\n    auto V = input[1];\n    auto X = readln.split.map!(to!long).array;\n\n    Tuple!(int, int, int, int)[][] segments;\n\n\n    while (true) {\n        Tuple!(int, int, int, int)[] tmp;\n        long prev = - (1L << 59);\n        foreach (i; 0..N) {\n            if (X[i] - prev > V)\n                tmp ~= tuple(i, i, 1, i);\n            else\n                tmp[$-1][1] = i;\n            prev = X[i];\n        }\n        segments ~= tmp;\n        if (V == 0)\n            break;\n        V /= 2;\n    }\n\n    int logV = segments.length.to!int;\n\n    foreach (i; 0..logV-1) {\n        int k = 0;\n        foreach (j; 0..segments[i].length) {\n            int old_k = k;\n            segments[i][j][3] = old_k;\n            while (k < segments[i+1].length && segments[i+1][k][1] <= segments[i][j][1])\n                k++;\n            segments[i][j][2] = k - old_k;\n        }\n    } \n    \n\n    if (segments[0].length > logV) {\n        N.iota.each!(_ => \"Impossible\".writeln);\n        return;\n    }\n\n    debug {segments.each!writeln;}\n    auto ans = new bool[](N);\n\n    bool solve(int start) {\n        Tuple!(int, int, int, int)[] q;\n        foreach (s; segments[0])\n            if (s[0] != segments[0][start][0])\n                q ~= s;\n        q.sort!\"a[2] < b[2]\"();\n        \n        foreach (i; 1..logV) {\n            int rest = logV - i;\n            \n            if (q.map!(a => a[2]).sum > rest)\n                return false;\n            \n            Tuple!(int, int, int, int)[] r;\n            foreach (s; q)\n                foreach (j; s[3]..s[3]+s[2])\n                    r ~= segments[i][j];\n\n            if (r.length == 0)\n                return true;\n\n            r.sort!\"a[2] < b[2]\"();\n            r.popBack;\n            q = r;\n        }\n\n        return q.length == 0;\n    }\n    \n    foreach (start; 0..segments[0].length) {\n        bool ok = solve(start.to!int);\n        foreach (i; segments[0][start][0]..segments[0][start][1]+1)\n            ans[i] = ok;\n    }\n\n    ans.map!(a => a ? \"Possible\" : \"Impossible\").each!writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto V = s[1];\n    auto X = readln.split.map!(to!int).array;\n\n    int[] NS = [V];\n\n    while (NS.back > 1) {\n        NS ~= NS.back / 2;\n    }\n\n    int K = NS.length.to!int;\n    int[][] L = new int[][](K);\n    int[][] R = new int[][](K);\n\n    foreach (i, n; NS.enumerate) {\n        int l = -1;\n        int r = -1;\n        foreach (j; 0..N) {\n            if (l == -1) {\n                l = j;\n                r = j;\n            } else if (X[j] - X[j-1] <= n) {\n                r = j;\n            } else {\n                L[i] ~= l;\n                R[i] ~= r;\n                l = j;\n                r = j;\n            }\n        }\n\n        L[i] ~= l;\n        R[i] ~= r;\n    }\n\n\n    auto dp1 = new int[](1 << K);\n    auto dp2 = new int[](1 << K);\n    dp2.fill(N-1);\n\n    foreach (mask; 0..(1 << K)) {\n        foreach (i; 0..K) {\n            if (mask & (1 << i)) continue;\n            auto next1 = R[i].assumeSorted.upperBound(dp1[mask]);\n            auto next2 = L[i].assumeSorted.lowerBound(dp2[mask]);\n            dp1[mask|(1<<i)] = max(dp1[mask|(1<<i)], dp1[mask]);\n            dp2[mask|(1<<i)] = min(dp2[mask|(1<<i)], dp2[mask]);\n            if (!next1.empty) dp1[mask|(1<<i)] = max(dp1[mask|(1<<i)], next1.front);\n            if (!next2.empty) dp2[mask|(1<<i)] = min(dp2[mask|(1<<i)], next2.back);\n        } \n    }\n\n    auto ok = new bool[](L[0].length);\n    \n    foreach (mask1; 0..(1<<K)) {\n        if (mask1 & 1) continue;\n        int mask2 = (1 << K) - 1;\n        mask2 ^= mask1;\n        mask2 &= ~1;\n        foreach (i; 0..L[0].length) {\n            if (dp1[mask1] + 1 >= dp2[mask2]) {\n                ok[i] = true;\n            } else if (L[0][i] <= dp1[mask1] + 1 && dp2[mask2] - 1 <= R[0][i]) {\n                ok[i] = true;\n            }\n            \n        }\n    }\n\n    \n    foreach (i; 0..L[0].length) {\n        foreach (j; L[0][i]..R[0][i]+1) {\n            writeln(ok[i] ? \"Possible\" : \"Impossible\");\n        }\n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n// import dcomp.functional;\n\nint n, m;\nlong[] x, v;\n\nint distLBase(int p, int f) {\n    if (p == n) return n;\n    if (p == n-1 || x[p+1]-x[p] > v[f]) return p+1;\n    return distL(p+1, f);\n}\nmemoCont!distLBase distL;\n\nint checkLBase(int f) {\n    int ans = 0;\n    foreach (i; 0..m) {\n        if (!(f & (1<<i))) continue;\n        ans = max(ans, distL(checkL(f ^ (1<<i)), i));\n    }\n    return ans;\n}\nmemoCont!checkLBase checkL;\n\nint distRBase(int p, int f) {\n    if (p == -1) return 0;\n    if (p == 0 || x[p]-x[p-1] > v[f]) return p;\n    return distR(p-1, f);\n}\nmemoCont!distRBase distR;\n\nint checkRBase(int f) {\n    int ans = n;\n    foreach (i; 0..m) {\n        if (!(f & (1<<i))) continue;\n        ans = min(ans, distR(checkR(f ^ (1<<i))-1, i));\n    }\n    return ans;\n}\nmemoCont!checkRBase checkR;\n\n\nint main() {\n    auto sc = new Scanner(stdin);\n    long V;\n    sc.read(n, V, x);\n\n    long buf = V;\n    while (V) {\n        V /= 2;\n        v ~= V;\n    }\n    V = buf;\n//    writeln(v);\n\n    m = v.length.to!int;\n\n    distL.init([[0, n], [0, 1<<m]]);\n    distR.init([[0, n], [0, 1<<m]]);\n    checkL.init([[0, 1<<m]]);\n    checkR.init([[0, 1<<m]]);\n    int cnt = 0;\n    int l = 0;\n    while (l < n) {\n        int r = l+1;\n        while (r < n && x[r]-x[r-1] <= V) r++;\n//        writeln(l, \" \", r);\n        cnt++;\n        bool f = false;\n        if (cnt <= 22) {\n            foreach (i; 0..1<<m) {\n                int a = checkL(i);\n                int b = checkR(((1<<m)-1) ^ i);\n                if (l <= a && b <= r) {\n                    f = true;\n                }\n            }\n        }\n        foreach (i; 0..r-l) {\n            if (f) {\n                writeln(\"Possible\");\n            } else {\n                writeln(\"Impossible\");\n            }\n        }\n        l = r;\n    }\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/functional.d */\n// module dcomp.functional;\n\nstruct memoCont(alias pred) {\n    import core.exception : RangeError;\n    import std.range, std.algorithm, std.conv;\n    import std.string : join;\n    import std.traits : ReturnType, ParameterTypeTuple, isIntegral;\n    import std.typecons : tuple, Tuple;\n    import std.meta;\n    alias R = ReturnType!pred;\n    alias Args = ParameterTypeTuple!pred;\n    static assert (allSatisfy!(isIntegral, Args));\n    static immutable N = Args.length;\n    int[2][N] rng;\n    int[N] len;\n    R[] dp;\n    bool[] used;\n    void init(int[2][N] rng) {\n        this.rng = rng;\n        len = rng[].map!(a => a[1]-a[0]+1).array;\n        int sz = len.reduce!\"a*b\";\n        dp = new R[sz];\n        used = new bool[sz];\n    }\n    R opCall(Args args) {\n        int idx, base = 1;\n        foreach (i, v; args) {\n            version(assert) {\n                if (v < rng[i][0] || rng[i][1] < v) {\n                    throw new RangeError;\n                }\n            }\n            assert(rng[i][0] <= v && v <= rng[i][1]);\n            idx += base*(v - rng[i][0]);\n            base *= len[i];\n        }\n        if (used[idx]) return dp[idx];\n        used[idx] = true;\n        auto r = pred(args);\n        dp[idx] = r;\n        return r;\n    }\n}\n\nunittest {\n//     import dcomp.numeric.primitive;\n//     import dcomp.modint;\n    alias Mint = ModInt!(10^^9+7);\n    auto fact = factTable!Mint(100);\n    auto iFac = invFactTable!Mint(100);\n    Mint C0(int a, int b) {\n        if (a < 0 || a < b) return Mint(0);\n        return fact[a]*iFac[b]*iFac[a-b];\n    }\n    struct A {\n        static memoCont!C1base C1;\n        static Mint C1base(int a, int b) {\n            if (a == 0) {\n                if (b == 0) return Mint(1);\n                return Mint(0);\n            }\n            if (b < 0) return Mint(0);\n            return C1(a-1, b-1) + C1(a-1, b);\n        }\n    }\n    A.C1.init([[0, 100], [-2, 100]]);\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            assert(C0(i, j) == A.C1(i, j));\n        }\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n    auto opBinary(string op:\"*\")(ModInt r) const {return make( (long(v)*r.v%MD).to!uint );}\n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    static assert( is(ModInt!(uint(1000000000) * 2))); //not overflow\n    static assert(!is(ModInt!(uint(1145141919) * 2))); //overflow!\n    alias Mint = ModInt!(10^^9+7);\n    // negative check\n    assert(Mint(-1).v == 10^^9 + 6);\n    assert(Mint(-1L).v == 10^^9 + 6);\n\n    Mint a = 48;\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n\n    Mint c = Mint(15);\n    Mint d = Mint(3);\n    assert((c/d).v == 5);\n}\n\nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(DModInt r) {\n        return make(normS(v+r.v));\n    }\n    auto opBinary(string op:\"-\")(DModInt r) {\n        return make(normS(v+MD-r.v));\n    }\n    auto opBinary(string op:\"*\")(DModInt r) {\n        return make((long(v)*r.v%MD).to!uint);\n    }\n    auto opBinary(string op:\"/\")(DModInt r) {\n        return this*inv(r);\n    }\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    alias Mint = DModInt!(\"default\");\n    Mint.MD = 10^^9 + 7;\n    //negative check\n    assert(Mint(-1).v == 10^^9 + 6);\n    assert(Mint(-1L).v == 10^^9 + 6);\n    Mint a = Mint(48);\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n    Mint c = Mint(15);\n    Mint d = Mint(3);\n    assert((c/d).v == 5);\n}\n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n// optimize\nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\nunittest {\n    import std.stdio;\n    alias Mint = ModInt!(10^^9 + 7);\n    auto r = factTable!Mint(20);\n    Mint a = 1;\n    assert(r[0] == Mint(1));\n    foreach (i; 1..20) {\n        a *= Mint(i);\n        assert(r[i] == a);\n    }\n    auto p = invFactTable!Mint(20);\n    foreach (i; 1..20) {\n        assert((r[i]*p[i]).v == 1);\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                //todo optimize\n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File, writeln;\n    import std.datetime;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    foreach (i; 0..1_000_000) {\n        fout.writeln(3*i, \" \", 3*i+1, \" \", 3*i+2);\n    }\n    fout.close;\n    writeln(\"Scanner Speed Test(3*1,000,000 int)\");\n    StopWatch sw;\n    sw.start;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    foreach (i; 0..500_000) {\n        int a, b, c;\n        sc.read(a, b, c);\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    foreach (i; 500_000..700_000) {\n        int[3] d;\n        sc.read(d);\n        int a = d[0], b = d[1], c = d[2];\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    foreach (i; 700_000..1_000_000) {\n        int[] d;\n        sc.read(d);\n        assert(d.length == 3);\n        int a = d[0], b = d[1], c = d[2];\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    writeln(sw.peek.msecs, \"ms\");\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n//fold(for old compiler)\nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n    unittest {\n        import std.stdio;\n        auto l = [1, 2, 3, 4, 5];\n        assert(l.fold!\"a+b\"(10) == 25);\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\n\nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n\nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n\nunittest {\n    assert(pow(3, 5) == 243);\n    assert(pow(3, 5, 2) == 486);\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\nunittest {\n    assert(lcm(2, 4) == 4);\n    assert(lcm(3, 5) == 15);\n    assert(lcm(1, 1) == 1);\n    assert(lcm(0, 100) == 0);\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T) //unsignedはNG\n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nunittest {\n    import std.numeric : gcd;\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            auto e = extGcd(i, j);\n            assert(e[2] == gcd(i, j));\n            assert(e[0] * i + e[1] * j == e[2]);\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n     \nvoid main() {\n    auto input = readln.split.map!(to!int);\n    auto N = input[0];\n    auto V = input[1];\n    auto X = readln.split.map!(to!long).array;\n\n    Tuple!(int, int, int, int)[][] segments;\n\n\n    while (true) {\n        Tuple!(int, int, int, int)[] tmp;\n        long prev = - (1L << 59);\n        foreach (i; 0..N) {\n            if (X[i] - prev > V)\n                tmp ~= tuple(i, i, 1, i);\n            else\n                tmp[$-1][1] = i;\n            prev = X[i];\n        }\n        segments ~= tmp;\n        if (V == 0)\n            break;\n        V /= 2;\n    }\n\n    int logV = segments.length.to!int;\n\n    foreach (i; 0..logV-1) {\n        int k = 0;\n        foreach (j; 0..segments[i].length) {\n            int old_k = k;\n            segments[i][j][3] = old_k;\n            while (k < segments[i+1].length && segments[i+1][k][1] <= segments[i][j][1])\n                k++;\n            segments[i][j][2] = k - old_k;\n        }\n    } \n    \n\n    if (segments[0].length > logV) {\n        N.iota.each!(_ => \"Impossible\".writeln);\n        return;\n    }\n\n    debug {segments.each!writeln;}\n    auto ans = new bool[](N);\n\n    bool solve(int start) {\n        Tuple!(int, int, int, int)[] q;\n        foreach (s; segments[0])\n            if (s[0] != segments[0][start][0])\n                q ~= s;\n        q.sort!\"a[2] < b[2]\"();\n        \n        foreach (i; 1..logV) {\n            int rest = logV - i;\n            \n            if (q.map!(a => a[2]).sum > rest)\n                return false;\n            \n            Tuple!(int, int, int, int)[] r;\n            foreach (s; q)\n                foreach (j; s[3]..s[3]+s[2])\n                    r ~= segments[i][j];\n\n            if (r.length == 0)\n                return true;\n\n            r.sort!\"a[2] < b[2]\"();\n            r.popBack;\n            q = r;\n        }\n\n        return q.length == 0;\n    }\n    \n    foreach (start; 0..segments[0].length) {\n        bool ok = solve(start);\n        foreach (i; segments[0][start][0]..segments[0][start][1]+1)\n            ans[i] = ok;\n    }\n\n    ans.map!(a => a ? \"Possible\" : \"Impossible\").each!writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto V = s[1];\n    auto X = readln.split.map!(to!int).array;\n\n    int[] NS = [V];\n\n    while (NS.back > 0) {\n        NS ~= NS.back / 2;\n    }\n\n    int K = NS.length.to!int;\n    int[][] L = new int[][](K);\n    int[][] R = new int[][](K);\n\n    foreach (i, n; NS.enumerate) {\n        int l = -1;\n        int r = -1;\n        foreach (j; 0..N) {\n            if (l == -1) {\n                l = j;\n                r = j;\n            } else if (X[j] - X[j-1] <= n) {\n                r = j;\n            } else {\n                L[i] ~= l;\n                R[i] ~= r;\n                l = j;\n                r = j;\n            }\n        }\n\n        L[i] ~= l;\n        R[i] ~= r;\n    }\n\n\n    auto dp1 = new int[](1 << K);\n    auto dp2 = new int[](1 << K);\n    dp1.fill(-1);\n    dp2.fill(N);\n\n    foreach (mask; 0..(1 << K)) {\n        foreach (i; 0..K) {\n            if (mask & (1 << i)) continue;\n            auto next1 = R[i].assumeSorted.upperBound(dp1[mask]);\n            auto next2 = L[i].assumeSorted.lowerBound(dp2[mask]);\n            dp1[mask|(1<<i)] = max(dp1[mask|(1<<i)], dp1[mask]);\n            dp2[mask|(1<<i)] = min(dp2[mask|(1<<i)], dp2[mask]);\n            if (!next1.empty) dp1[mask|(1<<i)] = max(dp1[mask|(1<<i)], next1.front);\n            if (!next2.empty) dp2[mask|(1<<i)] = min(dp2[mask|(1<<i)], next2.back);\n        } \n    }\n\n    auto ok = new bool[](L[0].length);\n    \n    foreach (mask1; 0..(1<<K)) {\n        if (mask1 & 1) continue;\n        int mask2 = (1 << K) - 1;\n        mask2 ^= mask1;\n        mask2 &= ~1;\n        foreach (i; 0..L[0].length) {\n            if (dp1[mask1] + 1 >= dp2[mask2]) {\n                ok[i] = true;\n            } else if (L[0][i] <= dp1[mask1] + 1 && dp2[mask2] - 1 <= R[0][i]) {\n                ok[i] = true;\n            }\n            \n        }\n    }\n\n    \n    foreach (i; 0..L[0].length) {\n        foreach (j; L[0][i]..R[0][i]+1) {\n            writeln(ok[i] ? \"Possible\" : \"Impossible\");\n        }\n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n// import dcomp.functional;\n\nint n, m;\nlong[] x, v;\n\nint distLBase(int p, int f) {\n    if (p == n) return n;\n    if (p == n-1 || x[p+1]-x[p] > v[f]) return p+1;\n    return distL(p+1, f);\n}\nmemoCont!distLBase distL;\n\nint checkLBase(int f) {\n    int ans = 0;\n    foreach (i; 0..m) {\n        if (!(f & (1<<i))) continue;\n        ans = max(ans, distL(checkL(f ^ (1<<i)), i));\n    }\n    return ans;\n}\nmemoCont!checkLBase checkL;\n\nint distRBase(int p, int f) {\n    if (p == -1) return 0;\n    if (p == 0 || x[p]-x[p-1] > v[f]) return p;\n    return distR(p-1, f);\n}\nmemoCont!distRBase distR;\n\nint checkRBase(int f) {\n    int ans = n;\n    foreach (i; 0..m) {\n        if (!(f & (1<<i))) continue;\n        ans = min(ans, distR(checkR(f ^ (1<<i))-1, i));\n    }\n    return ans;\n}\nmemoCont!checkRBase checkR;\n\n\nint main() {\n    auto sc = new Scanner(stdin);\n    long V;\n    sc.read(n, V, x);\n\n    long buf = V;\n    while (V) {\n        V /= 2;\n        v ~= V;\n    }\n    V = buf;\n//    writeln(v);\n\n    m = v.length.to!int;\n\n    distL.init([[0, n], [0, m]]);\n    distR.init([[-1, n], [0, m]]);\n    checkL.init([[0, 1<<m]]);\n    checkR.init([[0, 1<<m]]);\n    int cnt = 0;\n    int l = 0;\n    while (l < n) {\n        int r = l+1;\n        while (r < n && x[r]-x[r-1] <= V) r++;\n//        writeln(l, \" \", r);\n        cnt++;\n        bool f = false;\n        if (cnt <= 22) {\n            foreach (i; 0..1<<m) {\n                int a = checkL(i);\n                int b = checkR(((1<<m)-1) ^ i);\n                if (l <= a && b <= r) {\n                    f = true;\n                }\n            }\n        }\n        foreach (i; 0..r-l) {\n            if (f) {\n                writeln(\"Possible\");\n            } else {\n                writeln(\"Impossible\");\n            }\n        }\n        l = r;\n    }\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/functional.d */\n// module dcomp.functional;\n\nstruct memoCont(alias pred) {\n    import core.exception : RangeError;\n    import std.range, std.algorithm, std.conv;\n    import std.string : join;\n    import std.traits : ReturnType, ParameterTypeTuple, isIntegral;\n    import std.typecons : tuple, Tuple;\n    import std.meta;\n    alias R = ReturnType!pred;\n    alias Args = ParameterTypeTuple!pred;\n    static assert (allSatisfy!(isIntegral, Args));\n    static immutable N = Args.length;\n    int[2][N] rng;\n    int[N] len;\n    R[] dp;\n    bool[] used;\n    void init(int[2][N] rng) {\n        this.rng = rng;\n        len = rng[].map!(a => a[1]-a[0]+1).array;\n        int sz = len.reduce!\"a*b\";\n        dp = new R[sz];\n        used = new bool[sz];\n    }\n    R opCall(Args args) {\n        int idx, base = 1;\n        foreach (i, v; args) {\n            version(assert) {\n                if (v < rng[i][0] || rng[i][1] < v) {\n                    throw new RangeError;\n                }\n            }\n            assert(rng[i][0] <= v && v <= rng[i][1]);\n            idx += base*(v - rng[i][0]);\n            base *= len[i];\n        }\n        if (used[idx]) return dp[idx];\n        used[idx] = true;\n        auto r = pred(args);\n        dp[idx] = r;\n        return r;\n    }\n}\n\nunittest {\n//     import dcomp.numeric.primitive;\n//     import dcomp.modint;\n    alias Mint = ModInt!(10^^9+7);\n    auto fact = factTable!Mint(100);\n    auto iFac = invFactTable!Mint(100);\n    Mint C0(int a, int b) {\n        if (a < 0 || a < b) return Mint(0);\n        return fact[a]*iFac[b]*iFac[a-b];\n    }\n    struct A {\n        static memoCont!C1base C1;\n        static Mint C1base(int a, int b) {\n            if (a == 0) {\n                if (b == 0) return Mint(1);\n                return Mint(0);\n            }\n            if (b < 0) return Mint(0);\n            return C1(a-1, b-1) + C1(a-1, b);\n        }\n    }\n    A.C1.init([[0, 100], [-2, 100]]);\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            assert(C0(i, j) == A.C1(i, j));\n        }\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n    auto opBinary(string op:\"*\")(ModInt r) const {return make( (long(v)*r.v%MD).to!uint );}\n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    static assert( is(ModInt!(uint(1000000000) * 2))); //not overflow\n    static assert(!is(ModInt!(uint(1145141919) * 2))); //overflow!\n    alias Mint = ModInt!(10^^9+7);\n    // negative check\n    assert(Mint(-1).v == 10^^9 + 6);\n    assert(Mint(-1L).v == 10^^9 + 6);\n\n    Mint a = 48;\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n\n    Mint c = Mint(15);\n    Mint d = Mint(3);\n    assert((c/d).v == 5);\n}\n\nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(DModInt r) {\n        return make(normS(v+r.v));\n    }\n    auto opBinary(string op:\"-\")(DModInt r) {\n        return make(normS(v+MD-r.v));\n    }\n    auto opBinary(string op:\"*\")(DModInt r) {\n        return make((long(v)*r.v%MD).to!uint);\n    }\n    auto opBinary(string op:\"/\")(DModInt r) {\n        return this*inv(r);\n    }\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    alias Mint = DModInt!(\"default\");\n    Mint.MD = 10^^9 + 7;\n    //negative check\n    assert(Mint(-1).v == 10^^9 + 6);\n    assert(Mint(-1L).v == 10^^9 + 6);\n    Mint a = Mint(48);\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n    Mint c = Mint(15);\n    Mint d = Mint(3);\n    assert((c/d).v == 5);\n}\n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n// optimize\nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\nunittest {\n    import std.stdio;\n    alias Mint = ModInt!(10^^9 + 7);\n    auto r = factTable!Mint(20);\n    Mint a = 1;\n    assert(r[0] == Mint(1));\n    foreach (i; 1..20) {\n        a *= Mint(i);\n        assert(r[i] == a);\n    }\n    auto p = invFactTable!Mint(20);\n    foreach (i; 1..20) {\n        assert((r[i]*p[i]).v == 1);\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                //todo optimize\n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File, writeln;\n    import std.datetime;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    foreach (i; 0..1_000_000) {\n        fout.writeln(3*i, \" \", 3*i+1, \" \", 3*i+2);\n    }\n    fout.close;\n    writeln(\"Scanner Speed Test(3*1,000,000 int)\");\n    StopWatch sw;\n    sw.start;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    foreach (i; 0..500_000) {\n        int a, b, c;\n        sc.read(a, b, c);\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    foreach (i; 500_000..700_000) {\n        int[3] d;\n        sc.read(d);\n        int a = d[0], b = d[1], c = d[2];\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    foreach (i; 700_000..1_000_000) {\n        int[] d;\n        sc.read(d);\n        assert(d.length == 3);\n        int a = d[0], b = d[1], c = d[2];\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    writeln(sw.peek.msecs, \"ms\");\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n//fold(for old compiler)\nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n    unittest {\n        import std.stdio;\n        auto l = [1, 2, 3, 4, 5];\n        assert(l.fold!\"a+b\"(10) == 25);\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\n\nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n\nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n\nunittest {\n    assert(pow(3, 5) == 243);\n    assert(pow(3, 5, 2) == 486);\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\nunittest {\n    assert(lcm(2, 4) == 4);\n    assert(lcm(3, 5) == 15);\n    assert(lcm(1, 1) == 1);\n    assert(lcm(0, 100) == 0);\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T) //unsignedはNG\n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nunittest {\n    import std.numeric : gcd;\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            auto e = extGcd(i, j);\n            assert(e[2] == gcd(i, j));\n            assert(e[0] * i + e[1] * j == e[2]);\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto V = s[1];\n    auto X = readln.split.map!(to!int).array;\n\n    int[] NS = [V];\n\n    while (NS.back > 0) {\n        NS ~= NS.back / 2;\n    }\n\n    int K = NS.length.to!int;\n    int[][] L = new int[][](K);\n    int[][] R = new int[][](K);\n\n    foreach (i, n; NS.enumerate) {\n        int l = -1;\n        int r = -1;\n        foreach (j; 0..N) {\n            if (l == -1) {\n                l = j;\n                r = j;\n            } else if (X[j] - X[j-1] <= n) {\n                r = j;\n            } else {\n                L[i] ~= l;\n                R[i] ~= r;\n                l = j;\n                r = j;\n            }\n        }\n\n        L[i] ~= l;\n        R[i] ~= r;\n    }\n\n\n    auto dp1 = new int[](1 << K);\n    auto dp2 = new int[](1 << K);\n    dp2.fill(N-1);\n\n    foreach (mask; 0..(1 << K)) {\n        foreach (i; 0..K) {\n            if (mask & (1 << i)) continue;\n            auto next1 = R[i].assumeSorted.upperBound(dp1[mask]);\n            auto next2 = L[i].assumeSorted.lowerBound(dp2[mask]);\n            dp1[mask|(1<<i)] = max(dp1[mask|(1<<i)], dp1[mask]);\n            dp2[mask|(1<<i)] = min(dp2[mask|(1<<i)], dp2[mask]);\n            if (!next1.empty) dp1[mask|(1<<i)] = max(dp1[mask|(1<<i)], next1.front);\n            if (!next2.empty) dp2[mask|(1<<i)] = min(dp2[mask|(1<<i)], next2.back);\n        } \n    }\n\n    auto ok = new bool[](L[0].length);\n    \n    foreach (mask1; 0..(1<<K)) {\n        if (mask1 & 1) continue;\n        int mask2 = (1 << K) - 1;\n        mask2 ^= mask1;\n        mask2 &= ~1;\n        foreach (i; 0..L[0].length) {\n            if (dp1[mask1] + 1 >= dp2[mask2]) {\n                ok[i] = true;\n            } else if (L[0][i] <= dp1[mask1] + 1 && dp2[mask2] - 1 <= R[0][i]) {\n                ok[i] = true;\n            }\n            \n        }\n    }\n\n    \n    foreach (i; 0..L[0].length) {\n        foreach (j; L[0][i]..R[0][i]+1) {\n            writeln(ok[i] ? \"Possible\" : \"Impossible\");\n        }\n    }\n}\n\n"
  },
  {
    "language": "Bash",
    "code": "//Camel and Oases\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint const N=1e5+10;\nint const S=1<<17;\nint n,V;\nint d[N];\nint logV,a[20][N];\nint U,f1[S],f2[S];\nint upFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<=x) L=mid+1;\n        if(a[mid]>x) R=mid;\n    }\n    if(a[L]>x) return a[L];\n    else return a[R];\n}\nint lowFind(int a[],int x)\n{\n    int L=1,R=a[0];\n    while(L<R-1)\n    {\n        int mid=(L+R)>>1;\n        if(a[mid]<x) L=mid;\n        if(a[mid]>=x) R=mid-1;\n    }\n    if(a[R]<x) return a[R]+1;\n    else return a[L]+1;\n}\nvoid type(int s)\n{\n    for(int i=logV;i>=1;i--) printf(\"%d\",(s>>(i-1))%2);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&V);\n    logV=0;\n    while((1<<logV)<=V) logV++;\n    logV++;\n    for(int i=1;i<=n;i++) scanf(\"%d\",&d[i]),d[i-1]=d[i]-d[i-1];\n    d[n]=0;\n    for(int i=1;i<=logV;i++)\n    {\n        a[i][0]=1;\n        for(int j=1;j<=n;j++)\n        {\n            a[i][a[i][0]]=j;\n            if(d[j]>(V>>(i-1))) a[i][0]++;\n        }\n    }\n    /*for(int i=1;i<=logV;i++)\n    {\n    \tprintf(\"%d-%d \",1,a[i][1]);\n        for(int j=2;j<=a[i][0];j++) printf(\"%d-%d \",a[i][j-1]+1,a[i][j]);\n        printf(\"\\n\");\n    }*/\n    if(a[1][0]>logV)\n    {\n        for(int i=1;i<=n;i++) puts(\"Impossible\");\n        return 0;\n    }\n    U=(1<<logV)-1;\n    for(int s=0;s<=U;s++) f1[s]=1,f2[s]=n;\n    for(int s=0;s<=U;s+=2)\n        for(int i=2;i<=logV;i++)\n        {\n            int s0=1<<(i-1);\n            if(s&s0) continue;\n            f1[s|s0]=max(f1[s|s0],upFind(a[i],f1[s]));\n            f2[s|s0]=min(f2[s|s0],lowFind(a[i],f2[s]-1));\n        }\n    /*for(int s=0;s<=U;s+=2)\n        type(s),printf(\"   1-%2d  %2d-%2d\\n\",f1[s],f2[U-s-1],n);*/\n    for(int i=1;i<=a[1][0];i++)\n    {\n        bool f=false;\n        int fr=a[1][i-1]+1,to=a[1][i];\n        if(i==1) fr=1;\n        for(int s=0;s<=U&&!f;s+=2)\n            if(fr<=f1[s]+1 && f2[U-s-1]-1<=to) f=true;\n        if(f) for(int j=fr;j<=to;j++) puts(\"Possible\");\n        else for(int j=fr;j<=to;j++) puts(\"Impossible\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long i64;\n\ntemplate<class T>\nvoid selectMin(T & x, const T & y)\n{\n\tif (x > y)\n\t\tx = y;\n}\ntemplate<class T>\nvoid selectMax(T & x, const T & y)\n{\n\tif (x < y)\n\t\tx = y;\n}\n\nconst int MAXN = 2e5 + 10;\nconst int MAXLOG = 20 + 5;\nconst int PINF = 0x3F3F3F3F;\n\nconst char NSOL[] = \"Impossible\";\nconst char FSOL[] = \"Possible\";\n\nint N, V;\nint lg2 = -1;\nint exp_2[MAXLOG];\nint R[MAXLOG][MAXN];\nint cnt[MAXLOG];\nint dp1[MAXN << 3], dp2[MAXN << 3];\nint A[MAXN];\n\nvoid prepare()\n{\n\texp_2[0] = 1;\n\tfor (int i = 1; i < MAXLOG; i++)\n\t\texp_2[i] = exp_2[i - 1] * 2;\n}\n\nint main()\n{\n\tprepare();\n\tcin >> N >> V;\n\tfor (int i = 1; i <= N; i++)\n\t\tcin >> A[i];\n\n\tint x = V * 2;\n\twhile (x)\n\t{\n\t\tx /= 2, lg2++;\n\n\t\t// Split segments\n\t\tfor (int i = 1; i < N; i++)\n\t\t{\n\t\t\tif (A[i + 1] - A[i] <= x)\n\t\t\t\tcontinue;\n\t\t\tR[lg2][++cnt[lg2]] = i;\n\t\t}\n\t\tR[lg2][++cnt[lg2]] = N;\n\t}\n\n\tif (cnt[0] > lg2 + 1)\n\t{\n\t\tfor (int i = 1; i <= N; i++)\n\t\t\tputs(NSOL);\n\t\treturn 0;\n\t}\n\n\tfor (int s = 0; s < exp_2[lg2]; s++)\n\t\tdp2[s] = N + 1;\n\tfor (int s = 0; s < exp_2[lg2]; s++)\n\t\tfor (int i = 1; i <= lg2; i++)\n\t\t{\n\t\t\tif (s & exp_2[i - 1])\n\t\t\t\tcontinue;\n\t\t\tselectMax(dp1[s | exp_2[i - 1]],\n\t\t\t\t\t*upper_bound(R[i] + 1, R[i] + cnt[i] + 1, dp1[s]));\n\t\t\tselectMin(dp2[s | exp_2[i - 1]],\n\t\t\t\t\tR[i][lower_bound(R[i] + 1, R[i] + cnt[i] + 1, dp2[s] - 1)\n\t\t\t\t\t\t\t- R[i] - 1] + 1);\n\t\t}\n\n\tfor (int i = 1; i <= cnt[0]; i++)\n\t{\n\t\tbool solution = false;\n\t\tfor (int s = 0; s < exp_2[lg2]; s++)\n\t\t\tif (dp1[s] >= R[0][i - 1] && dp2[exp_2[lg2] - s - 1] <= R[0][i] + 1)\n\t\t\t{\n\t\t\t\tsolution = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tfor (int j = R[0][i - 1] + 1; j <= R[0][i]; j++)\n\t\t\tputs(solution ? FSOL : NSOL);\n\n\t}\n\n}\n"
  },
  {
    "language": "Python",
    "code": "n,v=map(int,raw_input().split())\na=map(int,raw_input().split())\nm=0\nvv=v\nwhile vv>0:\n    vv/=2\n    m+=1\nm+=1\nnxl=[[None]*m for _ in xrange(n)]\nnxr=[[None]*m for _ in xrange(n)]\nfor j in xrange(m):\n    nxl[n-1][j]=n-1\n    nxr[0][j]=0\nfor j in xrange(m):\n    now=0\n    pre=0\n    while now<n-1:\n        while now<n-1:\n            nx=now+1\n            if a[nx]-a[now]>v/(2**j):break\n            now=nx\n        for i in xrange(pre,nx):\n            nxl[i][j]=now\n        pre=nx\n        now=nx\nfor j in xrange(m):\n    now=n-1\n    pre=n-1\n    while now>0:\n        while now>0:\n            nx=now-1\n            if a[now]-a[nx]>v/(2**j):break\n            now=nx\n        for i in xrange(pre,nx,-1):\n            nxr[i][j]=now\n        pre=nx\n        now=nx\ndpl=[0]*(1<<m)\ndpr=[n-1]*(1<<m)\nfor i in xrange(1<<m):\n    for j in xrange(m):\n        if not (i>>j&1):\n            L=nxl[dpl[i]][j]\n            R=nxr[dpr[i]][j]\n            if L==n-1:L-=1\n            if R==0:R+=1\n            dpl[i|(1<<j)]=max(dpl[i|(1<<j)],L+1)\n            dpr[i|(1<<j)]=min(dpr[i|(1<<j)],R-1)\nf=False\nok=[False]*n\nfor i in xrange(1<<m):\n    if i&1:i=i^1\n    left=dpl[i]\n    nokori=((1<<m)-1)^i\n    nokori-=1\n    right=dpr[nokori]\n    if left<right:\n        if nxl[left][0]>=right:\n            for j in xrange(left,right+1):\n                ok[j]=True\n    else:\n        f=True\n        break\nif f:\n    for i in xrange(n):\n        print \"Possible\"\nelse:\n    for i in xrange(n):\n        print \"Possible\" if ok[i] else \"Impossible\""
  },
  {
    "language": "Python",
    "code": "import copy\nfrom functools import reduce\n\ndef jumps(vol):\n\tj = 0\n\twhile vol > 0:\n\t\tvol = vol // 2\n\t\tj += 1\n\treturn j\n\ndef visitable(oases, i, vol):\n\treturn visitable_r(oases, i, vol, [False] * len(oases))\n\ndef visitable_r(oases, i, vol, visited):\n\t# visit all visitable by sliding\n\tvisited[i] = True\n\t# print(\"i: \", i, \" vol: \", vol)\n\t# print(visited)\n\tj = i + 1\n\twhile j < len(oases) and (oases[j] - oases[j-1] <= vol):\n\t\tvisited[j] = True\n\t\tj += 1\n\tj = i - 1\n\twhile j >= 0 and (oases[j+1] - oases[j] <= vol):\n\t\tvisited[j] = True\n\t\tj -= 1\n\t# print(\"spread: \", visited)\n\n\tif reduce((lambda x, y: x and y), visited):\n\t\treturn True\n\tif vol == 0:\n\t\treturn False\n\n\tif not checkMaybeViable(visited, vol):\n\t\treturn False\n\tunvisited = 0\n\tfor j in range(len(oases)):\n\t\tif not visited[j]:\n\t\t\tunvisited += 1\n\t\t\tif visitable_r(oases, j, vol//2, copy.copy(visited)):\n\t\t\t\treturn True\n\treturn unvisited == 0\n\ndef checkMaybeViable(visited, vol):\n\tjump = jumps(vol)\n\tisles = 0\n\tlastNeedToVisit = 0\n\tfor i in range(len(visited)):\n\t\tif i == 0 or ((oases[i] - lastNeedToVisit > vol) and (not visited[i])):\n\t\t\tlastNeedToVisit = oases[i]\n\t\t\tisles += 1\n\t\t\tif isles > jump + 1:\n\t\t\t\treturn False\n\treturn True\n\n# [n, vol] = list(map(lambda x: int(x), \"16 19\".split()))\n# oases = list(map(lambda x: int(x), \"-49 -48 -33 -30 -21 -14 0 15 19 23 44 52 80 81 82 84\".split()))\n[n, vol] = list(map(lambda x: int(x), input().split()))\noases = list(map(lambda x: int(x), input().split()))\nfor i in range(n):\n\tif visitable(oases, i, vol):\n\t\tprint(\"Possible\")\n\telse:\n\t\tprint(\"Impossible\")"
  },
  {
    "language": "Python",
    "code": "import copy\nfrom functools import reduce\n\ndef jumps(vol):\n\tj = 0\n\twhile vol > 0:\n\t\tvol = vol // 2\n\t\tj += 1\n\treturn j\n\ndef visitable(oases, i, vol):\n\treturn visitable_r(oases, i, vol, [False] * len(oases))\n\ndef visitable_r(oases, i, vol, visited):\n\t# visit all visitable by sliding\n\tvisited[i] = True\n\t# print(\"i: \", i, \" vol: \", vol)\n\t# print(visited)\n\tj = i + 1\n\twhile j < len(oases) and (oases[j] - oases[j-1] <= vol):\n\t\tvisited[j] = True\n\t\tj += 1\n\tj = i - 1\n\twhile j >= 0 and (oases[j+1] - oases[j] <= vol):\n\t\tvisited[j] = True\n\t\tj -= 1\n\t# print(\"spread: \", visited)\n\n\tif reduce((lambda x, y: x and y), visited):\n\t\treturn True\n\n\tif not checkMaybeViable(visited, vol):\n\t\treturn False\n\tunvisited = 0\n\tfor j in range(len(oases)):\n\t\tif not visited[j]:\n\t\t\tunvisited += 1\n\t\t\tif visitable_r(oases, j, vol//2, copy.copy(visited)):\n\t\t\t\treturn True\n\treturn unvisited == 0\n\ndef checkMaybeViable(visited, vol):\n\tjump = jumps(vol)\n\tisles = 0\n\tlastNeedToVisit = 0\n\tfor i in range(len(visited)):\n\t\tif i == 0 or ((oases[i] - lastNeedToVisit > vol) and (not visited[i])):\n\t\t\tlastNeedToVisit = oases[i]\n\t\t\tisles += 1\n\t\t\tif isles > jump + 1:\n\t\t\t\treturn False\n\treturn True\n\n[n, vol] = list(map(lambda x: int(x), input().split()))\noases = list(map(lambda x: int(x), input().split()))\nfor i in range(n):\n\tif visitable(oases, i, vol):\n\t\tprint(\"Possible\")\n\telse:\n\t\tprint(\"Impossible\")"
  },
  {
    "language": "Python",
    "code": "n,v=map(int,raw_input().split())\na=map(int,raw_input().split())\nm=0\nvv=v\nwhile vv>0:\n    vv/=2\n    m+=1\nm+=1\nnxl=[[None]*m for _ in xrange(n)]\nnxr=[[None]*m for _ in xrange(n)]\nfor j in xrange(m):\n    nxl[n-1][j]=n-1\n    nxr[0][j]=0\nfor j in xrange(m):\n    now=0\n    pre=0\n    while now<n-1:\n        while now<n-1:\n            nx=now+1\n            if a[nx]-a[now]>v/(2**j):break\n            now=nx\n        for i in xrange(pre,nx):\n            nxl[i][j]=now\n        pre=nx\n        now=nx\nfor j in xrange(m):\n    now=n-1\n    pre=n-1\n    while now>0:\n        while now>0:\n            nx=now-1\n            if a[now]-a[nx]>v/(2**j):break\n            now=nx\n        for i in xrange(pre,nx,-1):\n            nxr[i][j]=now\n        pre=nx\n        now=nx\ndpl=[0]*(1<<m)\ndpr=[n-1]*(1<<m)\nfor i in xrange(1<<m):\n    for j in xrange(m):\n        if not (i>>j&1):\n            L=nxl[dpl[i]][j]\n            R=nxr[dpr[i]][j]\n            if L==n-1:L-=1\n            if R==0:R+=1\n            dpl[i|(1<<j)]=max(dpl[i|(1<<j)],L+1)\n            dpr[i|(1<<j)]=min(dpr[i|(1<<j)],R-1)\nf=False\nok=[0]*(n+1)\nfor i in xrange(1<<m):\n    if i&1:i=i^1\n    left=dpl[i]\n    nokori=((1<<m)-1)^i\n    nokori-=1\n    right=dpr[nokori]\n    if left<right:\n        if nxl[left][0]>=right:\n            ok[left]+=1\n            ok[right+1]-=1\n    else:\n        f=True\n        break\nif f:\n    for i in xrange(n):\n        print \"Possible\"\nelse:\n    for i in xrange(n):\n        ok[i+1]+=ok[i]\n    for i in xrange(n):\n        print \"Possible\" if ok[i]>0 else \"Impossible\""
  },
  {
    "language": "Python",
    "code": "n,v=map(int,raw_input().split())\na=map(int,raw_input().split())\nm=0\nvv=v\nwhile vv>0:\n    vv/=2\n    m+=1\nm+=1\nnxl=[[None]*m for _ in xrange(n)]\nnxr=[[None]*m for _ in xrange(n)]\nfor j in xrange(m):\n    nxl[n-1][j]=n-1\n    nxr[0][j]=0\nfor j in xrange(m):\n    now=0\n    pre=0\n    while now<n-1:\n        while now<n-1:\n            nx=now+1\n            if a[nx]-a[now]>v/(2**j):break\n            now=nx\n        for i in xrange(pre,nx):\n            nxl[i][j]=now\n        pre=nx\n        now=nx\nfor j in xrange(m):\n    now=n-1\n    pre=n-1\n    while now>0:\n        while now>0:\n            nx=now-1\n            if a[now]-a[nx]>v/(2**j):break\n            now=nx\n        for i in xrange(pre,nx,-1):\n            nxr[i][j]=now\n        pre=nx\n        now=nx\ndpl=[0]*(1<<m)\ndpr=[n-1]*(1<<m)\nfor i in xrange(1<<m):\n    for j in xrange(m):\n        if not (i>>j&1):\n            L=nxl[dpl[i]][j]\n            R=nxr[dpr[i]][j]\n            if L==n-1:L-=1\n            if R==0:R+=1\n            dpl[i|(1<<j)]=max(dpl[i|(1<<j)],L+1)\n            dpr[i|(1<<j)]=min(dpr[i|(1<<j)],R-1)\n\nfor i in xrange(n):\n    left=nxr[i][0]\n    right=nxl[i][0]\n    ok=False\n    for j in xrange(1<<m):\n        if (j&1):continue\n        if dpl[j]>=left:\n            nokori=((1<<m)-1)^j\n            nokori-=1\n            if dpr[nokori]<=right:\n                ok=True\n                break\n    print \"Possible\" if ok else \"Impossible\"\n"
  },
  {
    "language": "Python",
    "code": "n = map(int, raw_input().split())\nx = map(int, raw_input().split())\n#x.sort(reverse = True)\n#print x\nfor i in range(0, n[0]):\n    mem = [0]*n[0]\n    v = n[1]\n    V = n[1]\n    mem[i]=1\n    go(mem,v,i,V)\n    if chk(mem) == 1:\n        print Possible\n    else:\n        print Impossible\n        \ndef go(mem,v,i,V):\n    if (i-1)<0:\n        if x[i+1]-x[i]<=v and mem[i+1]==0:\n            mem[i+1]=1\n            go(mem,V,i+1,V)\n        elif V>=1:\n            for j in range(0,n[0]):\n                if mem[j]==0:\n                    go(mem,V/2,j,V/2)\n        else:\n            return 0\n    elif (i+1)==n[0]:\n        if x[i]-x[i-1]<=v and mem[i-1]==0:\n            mem[i-1]=1\n            go(mem,v,i-1,V)\n        elif V>=1:\n            for j in range(0,n[0]):\n                if mem[j]==0:\n                    go(mem,V/2,j,V/2)\n        else:\n            return 0\n    else:\n        if x[i+1]-x[i]<=v and mem[i+1]==0:\n            mem[i+1]=1\n            go(mem,V,i+1,V)\n        elif x[i]-x[i-1]<=v and mem[i-1]==0:\n            mem[i-1]=1\n            go(mem,v,i-1,V)\n        elif V>=1:\n            for j in range(0,n[0]):\n                if mem[j]==0:\n                    go(mem,V/2,j,V/2)\n        else:\n            return 0\ndef chk(mem):\n    for t in range(0,n[0]):\n        if mem[t]!=1:\n            return 0\n    return 1"
  }
]