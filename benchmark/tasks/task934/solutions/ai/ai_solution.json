[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <math.h>\n\nbool can_visit_all_oases(int N, int V, int* oases) {\n    for (int start = 0; start < N; start++) {\n        bool visited[N];\n        for (int i = 0; i < N; i++) \n            visited[i] = false;\n        \n        int current_water = V;\n        int current_pos = oases[start];\n        visited[start] = true;\n        \n        while (true) {\n            bool found_next = false;\n            int best_dist = INT_MAX;\n            int best_index = -1;\n            \n            for (int i = 0; i < N; i++) {\n                if (!visited[i]) {\n                    int dist = abs(oases[i] - current_pos);\n                    \n                    if (dist <= current_water && dist < best_dist) {\n                        best_dist = dist;\n                        best_index = i;\n                        found_next = true;\n                    }\n                }\n            }\n            \n            if (found_next) {\n                current_water = current_water - best_dist;\n                current_pos = oases[best_index];\n                visited[best_index] = true;\n                current_water *= 2;  // Refill at oasis\n            } else {\n                break;\n            }\n        }\n        \n        bool all_visited = true;\n        for (int i = 0; i < N; i++) {\n            if (!visited[i]) {\n                all_visited = false;\n                break;\n            }\n        }\n        \n        if (!all_visited) \n            return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    int N, V;\n    scanf(\"%d %d\", &N, &V);\n    \n    int oases[N];\n    for (int i = 0; i < N; i++) \n        scanf(\"%d\", &oases[i]);\n    \n    printf(can_visit_all_oases(N, V, oases) ? \"YES\\n\" : \"NO\\n\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint can_visit_all(int N, int V, int x[]) {\n    qsort(x, N, sizeof(int), compare);\n    \n    for (int i = 0; i < N - 1; i++) {\n        int distance = x[i + 1] - x[i];\n        if (distance > V) {\n            return 0;\n        }\n        V -= distance;\n    }\n    \n    for (int i = N - 1; i > 0; i--) {\n        int distance = x[i] - x[i - 1];\n        if (distance > V) {\n            return 0;\n        }\n        V -= distance;\n    }\n    \n    return 1;\n}\n\nint main() {\n    int N, V;\n    scanf(\"%d %d\", &N, &V);\n    int x[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &x[i]);\n    }\n    \n    if (can_visit_all(N, V, x)) {\n        printf(\"Possible\\n\");\n    } else {\n        printf(\"Impossible\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nbool canVisitAllOases(int N, int V, vector<int>& x) {\n    sort(x.begin(), x.end());\n    int max_gap = 0;\n    for (int i = 1; i < N; ++i) {\n        max_gap = max(max_gap, x[i] - x[i-1]);\n    }\n    int required_initial = max_gap;\n    int current_V = V;\n    while (current_V > 1) {\n        required_initial = (required_initial + 1) / 2;\n        current_V /= 2;\n    }\n    return required_initial <= 1;\n}\n\nint main() {\n    int N, V;\n    cin >> N >> V;\n    vector<int> x(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> x[i];\n    }\n    if (canVisitAllOases(N, V, x)) {\n        cout << \"Possible\" << endl;\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:24:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Arrays;\n\npublic class CamelOasis {\n    public static boolean canVisitAll(int[] x, int V) {\n        Arrays.sort(x);\n        int n = x.length;\n        for (int start = 0; start < n; start++) {\n            boolean[] visited = new boolean[n];\n            visited[start] = true;\n            if (dfs(x, visited, start, V, V)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean dfs(int[] x, boolean[] visited, int current, int currentV, int maxV) {\n        boolean allVisited = true;\n        for (boolean v : visited) {\n            if (!v) {\n                allVisited = false;\n                break;\n            }\n        }\n        if (allVisited) {\n            return true;\n        }\n\n        for (int i = 0; i < x.length; i++) {\n            if (!visited[i]) {\n                int distance = Math.abs(x[i] - x[current]);\n                if (currentV >= distance) {\n                    visited[i] = true;\n                    if (dfs(x, visited, i, currentV - distance, maxV)) {\n                        return true;\n                    }\n                    visited[i] = false;\n                } else if (currentV >= distance / 2) {\n                    visited[i] = true;\n                    if (dfs(x, visited, i, maxV / 2, maxV)) {\n                        return true;\n                    }\n                    visited[i] = false;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int[] x = {0, 1, 3, 6};\n        int V = 10;\n        System.out.println(canVisitAll(x, V));\n    }\n}",
    "timestamp": "2025-08-05 23:24:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CamelOases {\n    public static boolean canVisitAllOases(int[] oases, int initialWater) {\n        int n = oases.length;\n        \n        for (int start = 0; start < n; start++) {\n            if (!canReachAllOasesFromStart(oases, start, initialWater)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private static boolean canReachAllOasesFromStart(int[] oases, int startIndex, int initialWater) {\n        int n = oases.length;\n        boolean[] visited = new boolean[n];\n        int currentWater = initialWater;\n        int currentLocation = oases[startIndex];\n        \n        visited[startIndex] = true;\n        \n        while (true) {\n            boolean moved = false;\n            int bestIndex = -1;\n            int bestDistance = Integer.MAX_VALUE;\n            \n            for (int i = 0; i < n; i++) {\n                if (!visited[i]) {\n                    int distance = Math.abs(currentLocation - oases[i]);\n                    \n                    if (distance <= currentWater) {\n                        if (distance < bestDistance) {\n                            bestIndex = i;\n                            bestDistance = distance;\n                        }\n                    }\n                }\n            }\n            \n            if (bestIndex != -1) {\n                currentWater -= bestDistance;\n                currentLocation = oases[bestIndex];\n                visited[bestIndex] = true;\n                currentWater += initialWater;  // Refill at oasis\n                moved = true;\n            }\n            \n            if (!moved) {\n                break;\n            }\n        }\n        \n        for (boolean v : visited) {\n            if (!v) return false;\n        }\n        \n        return true;\n    }\n    \n    public static void main(String[] args) {\n        int[] oases = {1, 5, 10, 15, 20};\n        int initialWater = 20;\n        \n        System.out.println(canVisitAllOases(oases, initialWater));\n    }\n}",
    "timestamp": "2025-08-05 23:24:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nbool canVisitAllOases(vector<int>& oases, int initialWater) {\n    int n = oases.size();\n    \n    for (int start = 0; start < n; start++) {\n        vector<bool> visited(n, false);\n        int currentWater = initialWater;\n        int currentPos = oases[start];\n        \n        visited[start] = true;\n        \n        while (true) {\n            bool moved = false;\n            int bestOasis = -1;\n            double minCost = numeric_limits<double>::max();\n            \n            for (int i = 0; i < n; i++) {\n                if (!visited[i]) {\n                    double dist = abs(oases[i] - currentPos);\n                    \n                    if (dist <= currentWater) {\n                        double waterAfterMove = currentWater - dist;\n                        \n                        if (waterAfterMove/2 + currentWater >= dist) {\n                            double totalCost = dist + waterAfterMove/2;\n                            \n                            if (totalCost < minCost) {\n                                minCost = totalCost;\n                                bestOasis = i;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            if (bestOasis == -1) break;\n            \n            double dist = abs(oases[bestOasis] - currentPos);\n            currentWater -= dist;\n            currentWater /= 2;\n            currentWater += initialWater;\n            \n            currentPos = oases[bestOasis];\n            visited[bestOasis] = true;\n            moved = true;\n            \n            if (find(visited.begin(), visited.end(), false) == visited.end()) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int n, initialWater;\n    cin >> n >> initialWater;\n    \n    vector<int> oases(n);\n    for (int i = 0; i < n; i++) {\n        cin >> oases[i];\n    }\n    \n    sort(oases.begin(), oases.end());\n    \n    cout << (canVisitAllOases(oases, initialWater) ? \"Yes\" : \"No\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:24:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_visit_all_oases(oasis_positions, initial_water_volume):\n    N = len(oasis_positions)\n    oasis_positions.sort()\n\n    def can_traverse_from(start_index):\n        water_volume = initial_water_volume\n        visited = set()\n        current_index = start_index\n\n        while len(visited) < N:\n            visited.add(current_index)\n            # Check moving to the next unvisited oasis\n            next_index = -1\n            for i in range(N):\n                if i not in visited and abs(oasis_positions[i] - oasis_positions[current_index]) <= water_volume:\n                    next_index = i\n                    break\n\n            if next_index == -1:  # Cannot move forward\n                # Try to jump to any other unvisited oasis\n                jump_success = False\n                for i in range(N):\n                    if i not in visited:\n                        jump_success = True\n                        current_index = i\n                        water_volume /= 2\n                        break\n                if not jump_success:\n                    return False\n            else:\n                # Move forward\n                water_volume -= abs(oasis_positions[next_index] - oasis_positions[current_index])\n                current_index = next_index\n                # Refill water at the new oasis\n                water_volume = initial_water_volume\n\n        return len(visited) == N\n\n    # Try starting from each oasis\n    for i in range(N):\n        if can_traverse_from(i):\n            return True\n    return False\n\n# Example Usage:\n# oases = [0, 2, 4, 6, 8]\n# initial_volume = 5\n# print(can_visit_all_oases(oases, initial_volume))  # Output: True or False",
    "timestamp": "2025-08-13 15:08:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CamelJourney {\n    \n    public static boolean canVisitAllOases(int[] oases, int initialWater) {\n        int n = oases.length;\n        for (int start = 0; start < n; start++) {\n            boolean[] visited = new boolean[n];\n            if (!canVisitAllFrom(start, initialWater, oases, visited)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private static boolean canVisitAllFrom(int start, int water, int[] oases, boolean[] visited) {\n        int n = oases.length;\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{start, water});\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int index = curr[0];\n            int currWater = curr[1];\n            \n            if (visited[index]) continue;\n            visited[index] = true;\n            \n            for (int i = 0; i < n; i++) {\n                if (!visited[i]) {\n                    int distance = Math.abs(oases[i] - oases[index]);\n                    if (distance <= currWater) {\n                        queue.offer(new int[]{i, currWater - distance});\n                    }\n                    queue.offer(new int[]{i, currWater / 2}); // Jumping option\n                }\n            }\n        }\n        \n        for (boolean v : visited) {\n            if (!v) return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[] oases = {0, 10, 20, 30};\n        int initialWater = 15;\n        System.out.println(canVisitAllOases(oases, initialWater)); // Output depend on the oases and initialWater configuration\n    }\n}",
    "timestamp": "2025-08-13 15:09:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void* a, const void* b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint canVisitAll(int* oases, int N, double V) {\n    for (int i = 0; i < N; i++) {\n        double water = V;\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            int distance = abs(oases[j] - oases[i]);\n            if (distance > water) return 0;\n            water = (water - distance) * 0.5; // Jump reduces the water\n            if (water <= 0) return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int N;\n    double V;\n    scanf(\"%d %lf\", &N, &V);\n    \n    int* oases = (int*)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &oases[i]);\n    }\n    \n    if (canVisitAll(oases, N, V)) {\n        printf(\"Possible\\n\");\n    } else {\n        printf(\"Impossible\\n\");\n    }\n    \n    free(oases);\n    return 0;\n}",
    "timestamp": "2025-08-13 15:09:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool canVisitAllOasesFrom(int start, vector<int>& oases, int V) {\n    int n = oases.size();\n    vector<bool> visited(n, false);\n    visited[start] = true;\n    \n    int water = V;\n    int pos = oases[start];\n    int visitedCount = 1;\n    \n    while (visitedCount < n) {\n        bool canContinue = false;\n        for (int i = 0; i < n; ++i) {\n            if (!visited[i]) {\n                int distance = abs(oases[i] - pos);\n                if (distance <= water) {\n                    visited[i] = true;\n                    water -= distance;\n                    pos = oases[i];\n                    visitedCount++;\n                    canContinue = true;\n                    break;\n                }\n            }\n        }\n        if (!canContinue) {\n            if (water > 0) {\n                water /= 2;\n            } else {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> oases(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> oases[i];\n    }\n    int V;\n    cin >> V;\n    \n    sort(oases.begin(), oases.end());\n    \n    for (int i = 0; i < N; ++i) {\n        if (!canVisitAllOasesFrom(i, oases, V)) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    \n    cout << \"Yes\" << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 15:09:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_visit_all_oases(N, oases, V):\n    def can_reach_all(start_index):\n        water = V\n        visited = [False] * N\n        current_pos = oases[start_index]\n        visited[start_index] = True\n        \n        for i in range(N):\n            if i == start_index:\n                continue\n            \n            distance = abs(current_pos - oases[i])\n            \n            while distance > water:\n                water //= 2\n                if water == 0:\n                    return False\n            \n            water -= distance\n            current_pos = oases[i]\n            visited[i] = True\n        \n        return all(visited)\n    \n    return [can_reach_all(i) for i in range(N)]\n\n# Example usage\nN = int(input())\noases = list(map(int, input().split()))\nV = int(input())\n\nresult = can_visit_all_oases(N, oases, V)\nfor res in result:\n    print(\"YES\" if res else \"NO\")",
    "timestamp": "2025-08-13 15:09:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    N, V = map(int, sys.stdin.readline().split())\n    x = list(map(int, sys.stdin.readline().split()))\n    x.sort()\n    \n    max_gap = 0\n    for i in range(N-1):\n        gap = x[i+1] - x[i]\n        if gap > max_gap:\n            max_gap = gap\n    \n    if max_gap <= V * (2 ** (N-1)):\n        print(\"Possible\")\n    else:\n        print(\"Impossible\")\n\nsolve()",
    "timestamp": "2025-08-13 15:09:29"
  }
]