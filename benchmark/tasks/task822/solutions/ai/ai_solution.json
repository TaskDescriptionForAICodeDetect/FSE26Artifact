[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\nint solve(int *arr, int n) {\n    int a, b, changes1 = 0, changes2 = 0;\n    \n    for (int first = 0; first < 2; first++) {\n        for (int second = 0; second < 2; second++) {\n            int curr_changes = 0;\n            a = first;\n            b = second;\n            \n            for (int i = 0; i < n; i++) {\n                if (i % 2 == 0 && arr[i] != a) curr_changes++;\n                if (i % 2 == 1 && arr[i] != b) curr_changes++;\n            }\n            \n            if (first == 0 && second == 1) changes1 = curr_changes;\n            else changes2 = curr_changes;\n        }\n    }\n    \n    return (changes1 < changes2) ? changes1 : changes2;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    printf(\"%d\\n\", solve(arr, n));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100000\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int a[MAX_N];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    int freq1_odd[100001] = {0};\n    int freq1_even[100001] = {0};\n    int freq2_odd[100001] = {0};\n    int freq2_even[100001] = {0};\n\n    for (int i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            freq1_even[a[i]]++;\n        } else {\n            freq1_odd[a[i]]++;\n        }\n    }\n\n    int max1_even = 0, max2_even = 0, val1_even = 0, val2_even = 0;\n    for (int i = 1; i <= 100000; i++) {\n        if (freq1_even[i] > max1_even) {\n            max2_even = max1_even;\n            val2_even = val1_even;\n            max1_even = freq1_even[i];\n            val1_even = i;\n        } else if (freq1_even[i] > max2_even) {\n            max2_even = freq1_even[i];\n            val2_even = i;\n        }\n    }\n\n    int max1_odd = 0, max2_odd = 0, val1_odd = 0, val2_odd = 0;\n    for (int i = 1; i <= 100000; i++) {\n        if (freq1_odd[i] > max1_odd) {\n            max2_odd = max1_odd;\n            val2_odd = val1_odd;\n            max1_odd = freq1_odd[i];\n            val1_odd = i;\n        } else if (freq1_odd[i] > max2_odd) {\n            max2_odd = freq1_odd[i];\n            val2_odd = i;\n        }\n    }\n\n    int res;\n    if (val1_even != val1_odd) {\n        res = n - max1_even - max1_odd;\n    } else {\n        int option1 = n - max1_even - max2_odd;\n        int option2 = n - max2_even - max1_odd;\n        res = min(option1, option2);\n    }\n\n    printf(\"%d\\n\", res);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    map<int, int> freq1, freq2;\n    for (int i = 0; i < n; i += 2) {\n        freq1[v[i]]++;\n    }\n    for (int i = 1; i < n; i += 2) {\n        freq2[v[i]]++;\n    }\n\n    vector<pair<int, int>> vec1(freq1.begin(), freq1.end());\n    vector<pair<int, int>> vec2(freq2.begin(), freq2.end());\n\n    sort(vec1.begin(), vec1.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second > b.second;\n    });\n    sort(vec2.begin(), vec2.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second > b.second;\n    });\n\n    int max1 = (vec1.size() > 0) ? vec1[0].second : 0;\n    int max2 = (vec2.size() > 0) ? vec2[0].second : 0;\n\n    if (vec1.size() > 0 && vec2.size() > 0 && vec1[0].first == vec2[0].first) {\n        int alt1 = (vec1.size() > 1) ? vec1[1].second : 0;\n        int alt2 = (vec2.size() > 1) ? vec2[1].second : 0;\n        max1 = max(max1 + alt2, max2 + alt1);\n    } else {\n        max1 += max2;\n    }\n\n    cout << n - max1 << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] v = new int[n];\n        for (int i = 0; i < n; i++) {\n            v[i] = scanner.nextInt();\n        }\n\n        Map<Integer, Integer> oddFreq = new HashMap<>();\n        Map<Integer, Integer> evenFreq = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                evenFreq.put(v[i], evenFreq.getOrDefault(v[i], 0) + 1);\n            } else {\n                oddFreq.put(v[i], oddFreq.getOrDefault(v[i], 0) + 1);\n            }\n        }\n\n        List<Map.Entry<Integer, Integer>> evenList = new ArrayList<>(evenFreq.entrySet());\n        List<Map.Entry<Integer, Integer>> oddList = new ArrayList<>(oddFreq.entrySet());\n\n        evenList.sort((a, b) -> b.getValue() - a.getValue());\n        oddList.sort((a, b) -> b.getValue() - a.getValue());\n\n        int evenMax1 = evenList.isEmpty() ? 0 : evenList.get(0).getValue();\n        int evenMax2 = evenList.size() <= 1 ? 0 : evenList.get(1).getValue();\n        int oddMax1 = oddList.isEmpty() ? 0 : oddList.get(0).getValue();\n        int oddMax2 = oddList.size() <= 1 ? 0 : oddList.get(1).getValue();\n\n        int totalEven = n / 2;\n        int totalOdd = n / 2;\n\n        int minChanges;\n        if (!evenList.isEmpty() && !oddList.isEmpty() && evenList.get(0).getKey().equals(oddList.get(0).getKey())) {\n            minChanges = Math.min(totalEven - evenMax1 + totalOdd - oddMax2,\n                                 totalEven - evenMax2 + totalOdd - oddMax1);\n        } else {\n            minChanges = (totalEven - evenMax1) + (totalOdd - (oddList.isEmpty() ? 0 : oddMax1));\n        }\n\n        System.out.println(minChanges);\n    }\n}",
    "timestamp": "2025-08-05 23:02:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    public int minReplacements(int[] arr) {\n        int n = arr.length;\n        if (n <= 2) return 0;\n        \n        int replacements = Integer.MAX_VALUE;\n        \n        for (int first : Set.of(arr[0], arr[1])) {\n            for (int second : Set.of(arr[0], arr[1])) {\n                if (first == second) continue;\n                \n                int currentReplacements = 0;\n                int[] temp = arr.clone();\n                \n                for (int i = 0; i < n; i += 2) {\n                    if (temp[i] != first) {\n                        temp[i] = first;\n                        currentReplacements++;\n                    }\n                }\n                \n                for (int i = 1; i < n; i += 2) {\n                    if (temp[i] != second) {\n                        temp[i] = second;\n                        currentReplacements++;\n                    }\n                }\n                \n                replacements = Math.min(replacements, currentReplacements);\n            }\n        }\n        \n        return replacements;\n    }\n}",
    "timestamp": "2025-08-05 23:02:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(vector<int>& arr) {\n    int n = arr.size();\n    int ans = INT_MAX;\n    \n    for (int x : arr) {\n        for (int y : arr) {\n            if (x == y) continue;\n            \n            int changes = 0;\n            vector<int> pattern(n);\n            \n            for (int i = 0; i < n; i++) {\n                if (i % 2 == 0) \n                    pattern[i] = x;\n                else \n                    pattern[i] = y;\n            }\n            \n            for (int i = 0; i < n; i++) {\n                if (arr[i] != pattern[i])\n                    changes++;\n            }\n            \n            ans = min(ans, changes);\n        }\n    }\n    \n    return ans;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) \n        cin >> arr[i];\n    \n    cout << solve(arr) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_replacements_to_wavy_pattern(seq):\n    n = len(seq)\n    \n    even_count = {}\n    odd_count = {}\n\n    for i in range(0, n, 2):  # Count frequency of elements at even indices\n        even_count[seq[i]] = even_count.get(seq[i], 0) + 1\n        \n    for i in range(1, n, 2):  # Count frequency of elements at odd indices\n        odd_count[seq[i]] = odd_count.get(seq[i], 0) + 1\n\n    even_max = max(even_count.values(), default=0)\n    odd_max = max(odd_count.values(), default=0)\n\n    even_max_value = [key for key in even_count if even_count[key] == even_max]\n    odd_max_value = [key for key in odd_count if odd_count[key] == odd_max]\n\n    if even_max_value[0] != odd_max_value[0]:\n        return n - even_max - odd_max\n    else:\n        if len(even_max_value) > 1:\n            second_even_max = even_max\n        else:\n            second_even_max = max([even_count[key] for key in even_count if key != even_max_value[0]], default=0)\n        \n        if len(odd_max_value) > 1:\n            second_odd_max = odd_max\n        else:\n            second_odd_max = max([odd_count[key] for key in odd_count if key != odd_max_value[0]], default=0)\n        \n        return n - max(even_max + second_odd_max, odd_max + second_even_max)\n\n# Example usage\nsequence = [1, 2, 1, 2, 1, 2]\nprint(min_replacements_to_wavy_pattern(sequence))  # Output will vary depending on the sequence",
    "timestamp": "2025-08-13 13:23:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class WaveSequence {\n    public static int minReplacements(int[] sequence) {\n        // Maps to count occurrences of numbers in odd and even indices\n        Map<Integer, Integer> oddCount = new HashMap<>();\n        Map<Integer, Integer> evenCount = new HashMap<>();\n        \n        int n = sequence.length;\n\n        // Counting numbers occurrences on odd and even places\n        for (int i = 0; i < n; i++) {\n            int num = sequence[i];\n            if (i % 2 == 0) {\n                evenCount.put(num, evenCount.getOrDefault(num, 0) + 1);\n            } else {\n                oddCount.put(num, oddCount.getOrDefault(num, 0) + 1);\n            }\n        }\n\n        // Variables to store the numbers with max count on odd and even indices\n        int maxEvenNum = -1, maxEvenCount = 0;\n        int secMaxEvenNum = -1, secMaxEvenCount = 0;\n        int maxOddNum = -1, maxOddCount = 0;\n        int secMaxOddNum = -1, secMaxOddCount = 0;\n\n        // Finding the most and second most frequent numbers in even indices\n        for (Map.Entry<Integer, Integer> entry : evenCount.entrySet()) {\n            int num = entry.getKey();\n            int count = entry.getValue();\n            if (count > maxEvenCount) {\n                secMaxEvenNum = maxEvenNum;\n                secMaxEvenCount = maxEvenCount;\n                maxEvenNum = num;\n                maxEvenCount = count;\n            } else if (count > secMaxEvenCount) {\n                secMaxEvenNum = num;\n                secMaxEvenCount = count;\n            }\n        }\n\n        // Finding the most and second most frequent numbers in odd indices\n        for (Map.Entry<Integer, Integer> entry : oddCount.entrySet()) {\n            int num = entry.getKey();\n            int count = entry.getValue();\n            if (count > maxOddCount) {\n                secMaxOddNum = maxOddNum;\n                secMaxOddCount = maxOddCount;\n                maxOddNum = num;\n                maxOddCount = count;\n            } else if (count > secMaxOddCount) {\n                secMaxOddNum = num;\n                secMaxOddCount = count;\n            }\n        }\n\n        // Compute replacements needed\n        int case1 = (n / 2 - maxEvenCount) + (n / 2 - (maxOddNum == maxEvenNum ? secMaxOddCount : maxOddCount));\n        int case2 = (n / 2 - maxOddCount) + (n / 2 - (maxEvenNum == maxOddNum ? secMaxEvenCount : maxEvenCount));\n\n        // Return the minimum of both cases\n        return Math.min(case1, case2);\n    }\n\n    public static void main(String[] args) {\n        // Example usage:\n        int[] sequence = {1, 2, 1, 2, 1, 2, 1, 2};\n        System.out.println(minReplacements(sequence)); // Output should be 0\n    }\n}",
    "timestamp": "2025-08-13 13:23:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint minReplacementsToWave(int arr[], int n) {\n    int count1 = 0, count2 = 0;\n    int num1Odd = arr[0], num1Even = arr[1];\n    int num2Odd = arr[1], num2Even = arr[0];\n\n    // Count mismatches for pattern starting with arr[0]\n    for (int i = 0; i < n; i += 2) {\n        if (arr[i] != num1Odd) count1++;\n    }\n    for (int i = 1; i < n; i += 2) {\n        if (arr[i] != num1Even) count1++;\n    }\n\n    // Count mismatches for pattern starting with arr[1]\n    for (int i = 0; i < n; i += 2) {\n        if (arr[i] != num2Odd) count2++;\n    }\n    for (int i = 1; i < n; i += 2) {\n        if (arr[i] != num2Even) count2++;\n    }\n\n    return count1 < count2 ? count1 : count2;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    printf(\"%d\\n\", minReplacementsToWave(arr, n));\n    return 0;\n}",
    "timestamp": "2025-08-13 13:24:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minReplacementsForWPattern(seq) {\n    const n = seq.length;\n    const count1 = {};\n    const count2 = {};\n\n    // Count frequencies in odd and even indices\n    for (let i = 0; i < n; i += 2) {\n        count1[seq[i]] = (count1[seq[i]] || 0) + 1;\n        count2[seq[i + 1]] = (count2[seq[i + 1]] || 0) + 1;\n    }\n\n    const oddCounts = Object.entries(count1).sort((a, b) => b[1] - a[1]);\n    const evenCounts = Object.entries(count2).sort((a, b) => b[1] - a[1]);\n\n    const oddMost = oddCounts[0];\n    const evenMost = evenCounts[0];\n\n    let res = Number.MAX_SAFE_INTEGER;\n\n    if (oddMost[0] !== evenMost[0]) {\n        res = n - oddMost[1] - evenMost[1];\n    } else {\n        if (oddCounts.length > 1) {\n            res = Math.min(res, n - oddCounts[1][1] - evenMost[1]);\n        }\n        if (evenCounts.length > 1) {\n            res = Math.min(res, n - oddMost[1] - evenCounts[1][1]);\n        }\n        if (oddCounts.length === 1 && evenCounts.length === 1) {\n            res = Math.min(res, n / 2, n / 2);\n        }\n    }\n\n    return res;\n}",
    "timestamp": "2025-08-13 13:24:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(arr):\n    n = len(arr)\n    if n % 2 != 0:\n        return -1\n\n    def count_replacements(x, y):\n        replacements = 0\n        for i in range(n):\n            if i % 2 == 0 and arr[i] != x:\n                replacements += 1\n            elif i % 2 == 1 and arr[i] != y:\n                replacements += 1\n        return replacements\n\n    unique_elements = set(arr)\n    if len(unique_elements) > 2:\n        return -1\n\n    min_replacements = float('inf')\n    for x in unique_elements:\n        for y in unique_elements:\n            if x != y:\n                min_replacements = min(min_replacements, count_replacements(x, y))\n\n    return min_replacements",
    "timestamp": "2025-08-13 13:24:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(sequence) {\n    const n = sequence.length;\n    let result = Infinity;\n\n    for (let first of new Set(sequence)) {\n        for (let second of new Set(sequence.filter(x => x !== first))) {\n            let changes1 = 0;\n            let changes2 = 0;\n\n            for (let i = 0; i < n; i++) {\n                if (i % 2 === 0) {\n                    if (sequence[i] !== first) changes1++;\n                    if (sequence[i] !== second) changes2++;\n                } else {\n                    if (sequence[i] !== second) changes1++;\n                    if (sequence[i] !== first) changes2++;\n                }\n            }\n\n            result = Math.min(result, Math.min(changes1, changes2));\n        }\n    }\n\n    return result;\n}",
    "timestamp": "2025-08-13 13:24:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(sys.stdin.readline())\n    v = list(map(int, sys.stdin.readline().split()))\n    \n    # Separate into even and odd positions\n    even = v[::2]\n    odd = v[1::2]\n    \n    def get_top2(arr):\n        freq = defaultdict(int)\n        for num in arr:\n            freq[num] += 1\n        # Get top 2 most frequent elements\n        sorted_freq = sorted(freq.items(), key=lambda x: -x[1])\n        # Add dummy entries if less than 2\n        while len(sorted_freq) < 2:\n            sorted_freq.append((0, 0))\n        return sorted_freq[:2]\n    \n    even_top = get_top2(even)\n    odd_top = get_top2(odd)\n    \n    min_changes = float('inf')\n    \n    # Try all combinations of top 2 from even and odd\n    for e_num, e_cnt in even_top:\n        for o_num, o_cnt in odd_top:\n            if e_num != o_num:\n                changes = (len(even) - e_cnt) + (len(odd) - o_cnt)\n                if changes < min_changes:\n                    min_changes = changes\n    \n    print(min_changes)\n\nsolve()",
    "timestamp": "2025-08-13 13:24:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    rl.on('line', (input) => {\n        const n = parseInt(input.split(' ')[0]);\n        const v = input.split(' ').slice(1).map(Number);\n        \n        const count1 = new Map();\n        const count2 = new Map();\n        \n        for (let i = 0; i < n; i++) {\n            if (i % 2 === 0) {\n                count1.set(v[i], (count1.get(v[i]) || 0) + 1);\n            } else {\n                count2.set(v[i], (count2.get(v[i]) || 0) + 1);\n            }\n        }\n        \n        const sorted1 = Array.from(count1.entries()).sort((a, b) => b[1] - a[1]);\n        const sorted2 = Array.from(count2.entries()).sort((a, b) => b[1] - a[1]);\n        \n        let max1 = sorted1[0][1];\n        let max2 = sorted2[0][1];\n        \n        if (sorted1[0][0] !== sorted2[0][0]) {\n            console.log(n - max1 - max2);\n        } else {\n            const candidate1 = sorted1.length > 1 ? sorted1[1][1] : 0;\n            const candidate2 = sorted2.length > 1 ? sorted2[1][1] : 0;\n            const option1 = max1 + candidate2;\n            const option2 = candidate1 + max2;\n            console.log(n - Math.max(option1, option2));\n        }\n        \n        rl.close();\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:24:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nint minReplacementsForPattern(vector<int>& sequence) {\n    int n = sequence.size();\n    unordered_map<int, int> count1, count2;\n\n    for (int i = 0; i < n; i += 2) {\n        count1[sequence[i]]++;\n    }\n\n    for (int i = 1; i < n; i += 2) {\n        count2[sequence[i]]++;\n    }\n\n    vector<pair<int, int>> freq1(count1.begin(), count1.end());\n    vector<pair<int, int>> freq2(count2.begin(), count2.end());\n\n    sort(freq1.begin(), freq1.end(), [](pair<int, int>& a, pair<int, int>& b) {\n        return a.second > b.second;\n    });\n\n    sort(freq2.begin(), freq2.end(), [](pair<int, int>& a, pair<int, int>& b) {\n        return a.second > b.second;\n    });\n\n    if (freq1[0].first != freq2[0].first) {\n        return n - freq1[0].second - freq2[0].second;\n    } else {\n        int option1 = n - freq1[0].second - (freq2.size() > 1 ? freq2[1].second : 0);\n        int option2 = n - freq2[0].second - (freq1.size() > 1 ? freq1[1].second : 0);\n        return min(option1, option2);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> sequence(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> sequence[i];\n    }\n    cout << minReplacementsForPattern(sequence) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:39:33"
  }
]