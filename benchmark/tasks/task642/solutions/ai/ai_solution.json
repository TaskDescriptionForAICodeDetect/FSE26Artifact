[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_N 100005\n\nlong long tree[4 * MAX_N];\nlong long arr[MAX_N];\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        tree[node] = arr[start];\n        return;\n    }\n    int mid = (start + end) / 2;\n    build(2 * node, start, mid);\n    build(2 * node + 1, mid + 1, end);\n    tree[node] = tree[2 * node] + tree[2 * node + 1];\n}\n\nvoid update(int node, int start, int end, int idx, long long val) {\n    if (start == end) {\n        tree[node] += val;\n        return;\n    }\n    int mid = (start + end) / 2;\n    if (idx <= mid)\n        update(2 * node, start, mid, idx, val);\n    else\n        update(2 * node + 1, mid + 1, end, idx, val);\n    tree[node] = tree[2 * node] + tree[2 * node + 1];\n}\n\nlong long query(int node, int start, int end, int l, int r) {\n    if (r < start || end < l)\n        return 0;\n    if (l <= start && end <= r)\n        return tree[node];\n    int mid = (start + end) / 2;\n    long long left = query(2 * node, start, mid, l, r);\n    long long right = query(2 * node + 1, mid + 1, end, l, r);\n    return left + right;\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n    \n    for (int i = 0; i < N; i++)\n        scanf(\"%lld\", &arr[i]);\n    \n    build(1, 0, N-1);\n    \n    while (Q--) {\n        int type;\n        scanf(\"%d\", &type);\n        \n        if (type == 0) {\n            int p;\n            long long x;\n            scanf(\"%d %lld\", &p, &x);\n            update(1, 0, N-1, p, x);\n        } else {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            printf(\"%lld\\n\", query(1, 0, N-1, l, r-1));\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:24:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n    long long a[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lld\", &a[i]);\n    }\n    while (Q--) {\n        int type;\n        scanf(\"%d\", &type);\n        if (type == 0) {\n            int p;\n            long long x;\n            scanf(\"%d %lld\", &p, &x);\n            a[p] += x;\n        } else {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            long long sum = 0;\n            for (int i = l; i < r; i++) {\n                sum += a[i];\n            }\n            printf(\"%lld\\n\", sum);\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:24:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nclass FenwickTree {\nprivate:\n    std::vector<long long> tree;\n    int size;\n\npublic:\n    FenwickTree(int n) : size(n + 1) {\n        tree.resize(size, 0);\n    }\n\n    void update(int index, long long delta) {\n        index++;\n        while (index < size) {\n            tree[index] += delta;\n            index += index & -index;\n        }\n    }\n\n    long long query(int index) {\n        index++;\n        long long sum = 0;\n        while (index > 0) {\n            sum += tree[index];\n            index -= index & -index;\n        }\n        return sum;\n    }\n\n    long long rangeQuery(int l, int r) {\n        return query(r - 1) - query(l - 1);\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int N, Q;\n    std::cin >> N >> Q;\n\n    FenwickTree ft(N);\n    for (int i = 0; i < N; ++i) {\n        long long val;\n        std::cin >> val;\n        ft.update(i, val);\n    }\n\n    while (Q--) {\n        int type;\n        std::cin >> type;\n        if (type == 0) {\n            int p;\n            long long x;\n            std::cin >> p >> x;\n            ft.update(p, x);\n        } else {\n            int l, r;\n            std::cin >> l >> r;\n            std::cout << ft.rangeQuery(l, r) << '\\n';\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:25:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n    static class FenwickTree {\n        long[] tree;\n        int size;\n\n        FenwickTree(int n) {\n            this.size = n;\n            this.tree = new long[n + 1];\n        }\n\n        void update(int index, long delta) {\n            for (; index <= size; index += index & -index) {\n                tree[index] += delta;\n            }\n        }\n\n        long query(int index) {\n            long res = 0;\n            for (; index > 0; index -= index & -index) {\n                res += tree[index];\n            }\n            return res;\n        }\n\n        long rangeQuery(int l, int r) {\n            return query(r) - query(l);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n\n        String[] parts = br.readLine().split(\" \");\n        int N = Integer.parseInt(parts[0]);\n        int Q = Integer.parseInt(parts[1]);\n\n        FenwickTree ft = new FenwickTree(N);\n        parts = br.readLine().split(\" \");\n        for (int i = 1; i <= N; i++) {\n            long val = Long.parseLong(parts[i - 1]);\n            ft.update(i, val);\n        }\n\n        for (int q = 0; q < Q; q++) {\n            parts = br.readLine().split(\" \");\n            int type = Integer.parseInt(parts[0]);\n            if (type == 0) {\n                int p = Integer.parseInt(parts[1]) + 1;\n                long x = Long.parseLong(parts[2]);\n                ft.update(p, x);\n            } else {\n                int l = Integer.parseInt(parts[1]) + 1;\n                int r = Integer.parseInt(parts[2]);\n                pw.println(ft.rangeQuery(l - 1, r));\n            }\n        }\n        pw.flush();\n    }\n}",
    "timestamp": "2025-08-05 22:25:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static class SegmentTree {\n        int[] tree;\n        int[] arr;\n        int n;\n\n        public SegmentTree(int[] arr) {\n            this.arr = arr;\n            this.n = arr.length;\n            tree = new int[4 * n];\n            build(0, 0, n - 1);\n        }\n\n        private void build(int node, int start, int end) {\n            if (start == end) {\n                tree[node] = arr[start];\n                return;\n            }\n            int mid = (start + end) / 2;\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid + 1, end);\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n        }\n\n        public void update(int p, int x) {\n            updateUtil(0, 0, n - 1, p, x);\n        }\n\n        private void updateUtil(int node, int start, int end, int p, int x) {\n            if (start == end) {\n                arr[p] += x;\n                tree[node] += x;\n                return;\n            }\n            int mid = (start + end) / 2;\n            if (p <= mid)\n                updateUtil(2 * node + 1, start, mid, p, x);\n            else\n                updateUtil(2 * node + 2, mid + 1, end, p, x);\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n        }\n\n        public int query(int l, int r) {\n            return queryUtil(0, 0, n - 1, l, r - 1);\n        }\n\n        private int queryUtil(int node, int start, int end, int l, int r) {\n            if (r < start || end < l)\n                return 0;\n            if (l <= start && end <= r)\n                return tree[node];\n            int mid = (start + end) / 2;\n            int left = queryUtil(2 * node + 1, start, mid, l, r);\n            int right = queryUtil(2 * node + 2, mid + 1, end, l, r);\n            return left + right;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int Q = sc.nextInt();\n        int[] arr = new int[N];\n        for (int i = 0; i < N; i++)\n            arr[i] = sc.nextInt();\n\n        SegmentTree st = new SegmentTree(arr);\n\n        for (int q = 0; q < Q; q++) {\n            int type = sc.nextInt();\n            if (type == 0) {\n                int p = sc.nextInt();\n                int x = sc.nextInt();\n                st.update(p - 1, x);\n            } else {\n                int l = sc.nextInt();\n                int r = sc.nextInt();\n                System.out.println(st.query(l - 1, r));\n            }\n        }\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 22:25:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nclass SegmentTree {\nprivate:\n    std::vector<long long> tree;\n    int n;\n\n    void updateTree(int node, int start, int end, int index, int value) {\n        if (start == end) {\n            tree[node] += value;\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        if (index <= mid)\n            updateTree(2*node+1, start, mid, index, value);\n        else\n            updateTree(2*node+2, mid+1, end, index, value);\n        tree[node] = tree[2*node+1] + tree[2*node+2];\n    }\n\n    long long queryTree(int node, int start, int end, int left, int right) {\n        if (right < start || end < left)\n            return 0;\n        if (left <= start && end <= right)\n            return tree[node];\n        int mid = start + (end - start) / 2;\n        long long leftSum = queryTree(2*node+1, start, mid, left, right);\n        long long rightSum = queryTree(2*node+2, mid+1, end, left, right);\n        return leftSum + rightSum;\n    }\n\n    void buildTree(int node, int start, int end, const std::vector<int>& arr) {\n        if (start == end) {\n            tree[node] = arr[start];\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        buildTree(2*node+1, start, mid, arr);\n        buildTree(2*node+2, mid+1, end, arr);\n        tree[node] = tree[2*node+1] + tree[2*node+2];\n    }\n\npublic:\n    SegmentTree(const std::vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4*n, 0);\n        buildTree(0, 0, n-1, arr);\n    }\n\n    void update(int index, int value) {\n        updateTree(0, 0, n-1, index, value);\n    }\n\n    long long query(int left, int right) {\n        return queryTree(0, 0, n-1, left, right-1);\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int N, Q;\n    std::cin >> N >> Q;\n\n    std::vector<int> arr(N);\n    for (int i = 0; i < N; ++i)\n        std::cin >> arr[i];\n\n    SegmentTree segTree(arr);\n\n    while (Q--) {\n        int type, a, b;\n        std::cin >> type >> a >> b;\n\n        if (type == 0)\n            segTree.update(a, b);\n        else\n            std::cout << segTree.query(a, b) << \"\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:25:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class FenwickTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def update(self, index, delta):\n        index += 1\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n\n    def query(self, index):\n        index += 1\n        sum = 0\n        while index > 0:\n            sum += self.tree[index]\n            index -= index & -index\n        return sum\n\n    def range_query(self, left, right):\n        return self.query(right) - self.query(left - 1)\n\ndef process_queries(arr, queries):\n    N = len(arr)\n    ft = FenwickTree(N)\n    for i in range(N):\n        ft.update(i, arr[i])\n    results = []\n    for query in queries:\n        if query[0] == 0:  # Update operation\n            p, x = query[1], query[2]\n            ft.update(p, x)\n        elif query[0] == 1:  # Query operation\n            l, r = query[1], query[2]\n            results.append(ft.range_query(l, r - 1))\n    return results\n\n# Example usage:\n# arr = [1, 2, 3, 4, 5]\n# queries = [(1, 0, 3), (0, 1, 1), (1, 0, 3), (1, 2, 5)]\n# print(process_queries(arr, queries))  # Output: [6, 7, 12]",
    "timestamp": "2025-08-13 10:31:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class ArrayQueries {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int[] array = new int[N];\n        for (int i = 0; i < N; i++) {\n            array[i] = scanner.nextInt();\n        }\n\n        int Q = scanner.nextInt();\n        for (int i = 0; i < Q; i++) {\n            int type = scanner.nextInt();\n            if (type == 0) {\n                int p = scanner.nextInt();\n                int x = scanner.nextInt();\n                array[p] += x;\n            } else if (type == 1) {\n                int l = scanner.nextInt();\n                int r = scanner.nextInt();\n                int sum = 0;\n                for (int j = l; j < r; j++) {\n                    sum += array[j];\n                }\n                System.out.println(sum);\n            }\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 10:31:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nvoid processQueries(int* a, int n, int q) {\n    int queryType, p, x, l, r;\n    while (q--) {\n        scanf(\"%d\", &queryType);\n        if (queryType == 0) {\n            scanf(\"%d %d\", &p, &x);\n            a[p] += x;\n        } else if (queryType == 1) {\n            scanf(\"%d %d\", &l, &r);\n            int sum = 0;\n            for (int i = l; i < r; ++i) {\n                sum += a[i];\n            }\n            printf(\"%d\\n\", sum);\n        }\n    }\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    int a[n];\n    \n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &a[i]);\n    }\n    \n    processQueries(a, n, q);\n    return 0;\n}",
    "timestamp": "2025-08-13 10:31:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.build(arr, 0, 0, self.n - 1)\n\n    def build(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n            return\n        mid = (start + end) // 2\n        self.build(arr, 2*node+1, start, mid)\n        self.build(arr, 2*node+2, mid+1, end)\n        self.tree[node] = self.tree[2*node+1] + self.tree[2*node+2]\n\n    def update(self, node, start, end, index, val):\n        if start == end:\n            self.tree[node] += val\n            return\n        mid = (start + end) // 2\n        if index <= mid:\n            self.update(2*node+1, start, mid, index, val)\n        else:\n            self.update(2*node+2, mid+1, end, index, val)\n        self.tree[node] = self.tree[2*node+1] + self.tree[2*node+2]\n\n    def query(self, node, start, end, l, r):\n        if r < start or end < l:\n            return 0\n        if l <= start and end <= r:\n            return self.tree[node]\n        mid = (start + end) // 2\n        left_sum = self.query(2*node+1, start, mid, l, r)\n        right_sum = self.query(2*node+2, mid+1, end, l, r)\n        return left_sum + right_sum\n\ndef main():\n    N, Q = map(int, input().split())\n    arr = list(map(int, input().split()))\n    \n    st = SegmentTree(arr)\n    \n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        \n        if query[0] == 0:\n            p, x = query[1], query[2]\n            st.update(0, 0, N-1, p-1, x)\n        else:\n            l, r = query[1], query[2]\n            print(st.query(0, 0, N-1, l-1, r-1))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 10:32:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    a = list(map(int, input[ptr:ptr+N]))\n    ptr += N\n    \n    # Fenwick Tree implementation\n    class FenwickTree:\n        def __init__(self, size):\n            self.n = size\n            self.tree = [0] * (self.n + 1)\n        \n        def update(self, index, delta):\n            while index <= self.n:\n                self.tree[index] += delta\n                index += index & -index\n        \n        def query(self, index):\n            res = 0\n            while index > 0:\n                res += self.tree[index]\n                index -= index & -index\n            return res\n    \n    ft = FenwickTree(N)\n    for i in range(1, N+1):\n        ft.update(i, a[i-1])\n    \n    Q = int(input[ptr])\n    ptr += 1\n    for _ in range(Q):\n        query = input[ptr]\n        if query == '0':\n            p = int(input[ptr+1])\n            x = int(input[ptr+2])\n            ptr += 3\n            ft.update(p+1, x)\n        else:\n            l = int(input[ptr+1])\n            r = int(input[ptr+2])\n            ptr += 3\n            sum_lr = ft.query(r) - ft.query(l)\n            print(sum_lr)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 10:32:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass FenwickTree {\npublic:\n    explicit FenwickTree(int size) : tree(size + 1, 0) {}\n\n    void update(int index, int delta) {\n        for (++index; index < tree.size(); index += index & -index) {\n            tree[index] += delta;\n        }\n    }\n\n    int query(int index) const {\n        int sum = 0;\n        for (++index; index > 0; index -= index & -index) {\n            sum += tree[index];\n        }\n        return sum;\n    }\n\nprivate:\n    vector<int> tree;\n};\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    vector<int> arr(N);\n    FenwickTree fenwick(N);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> arr[i];\n        fenwick.update(i, arr[i]);\n    }\n\n    for (int i = 0; i < Q; ++i) {\n        int type;\n        cin >> type;\n        if (type == 0) {\n            int p, x;\n            cin >> p >> x;\n            fenwick.update(p, x);\n        } else if (type == 1) {\n            int l, r;\n            cin >> l >> r;\n            int sum = fenwick.query(r - 1) - fenwick.query(l - 1);\n            cout << sum << '\\n';\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:59:32"
  }
]