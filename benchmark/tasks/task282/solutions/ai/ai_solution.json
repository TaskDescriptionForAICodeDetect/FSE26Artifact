[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100000\n\ntypedef struct {\n    int u, v;\n} Edge;\n\nEdge edges[MAX];\nint min_pos, max_pos;\n\nvoid dfs(int u, int visited[], int adj[][MAX], int N) {\n    visited[u] = 1;\n    if (u < min_pos) min_pos = u;\n    if (u > max_pos) max_pos = u;\n    for (int v = 1; v <= N; v++) {\n        if (adj[u][v] && !visited[v]) {\n            dfs(v, visited, adj, N);\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int adj[MAX][MAX] = {0};\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &edges[i].u, &edges[i].v);\n        adj[edges[i].u][edges[i].v] = 1;\n    }\n    \n    int visited[MAX] = {0};\n    int total_walk = 0;\n    \n    for (int i = 1; i <= N; i++) {\n        if (!visited[i]) {\n            min_pos = N + 1;\n            max_pos = 0;\n            dfs(i, visited, adj, N);\n            if (min_pos <= max_pos) {\n                total_walk += (max_pos - min_pos) * 2;\n            }\n        }\n    }\n    \n    total_walk += (N + 1);\n    printf(\"%d\\n\", total_walk);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:54:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> left(N + 2, 0), right(N + 2, N + 1);\n    \n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        if (a < b) {\n            right[a] = min(right[a], b - 1);\n            left[b] = max(left[b], a + 1);\n        } else {\n            right[b] = min(right[b], a - 1);\n            left[a] = max(left[a], b + 1);\n        }\n    }\n    \n    for (int i = 2; i <= N; ++i) {\n        left[i] = max(left[i], left[i - 1]);\n    }\n    for (int i = N - 1; i >= 1; --i) {\n        right[i] = min(right[i], right[i + 1]);\n    }\n    \n    long long ans = 0;\n    for (int i = 1; i <= N; ++i) {\n        if (left[i] > right[i]) {\n            cout << -1 << endl;\n            return 0;\n        }\n        ans += (right[i] - left[i] + 1) * 2;\n    }\n    \n    cout << ans + N + 1 << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 20:54:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ShoppingMall {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        int[] inDegree = new int[N + 1];\n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            graph.get(a).add(b);\n            inDegree[b]++;\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 1; i <= N; i++) {\n            if (inDegree[i] == 0) {\n                queue.add(i);\n            }\n        }\n        \n        List<Integer> topOrder = new ArrayList<>();\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            topOrder.add(u);\n            for (int v : graph.get(u)) {\n                inDegree[v]--;\n                if (inDegree[v] == 0) {\n                    queue.add(v);\n                }\n            }\n        }\n        \n        int minPos = 0;\n        int maxPos = 0;\n        int currentPos = 0;\n        long totalWalk = 0;\n        \n        for (int shop : topOrder) {\n            if (shop < currentPos) {\n                minPos = Math.min(minPos, shop);\n            } else if (shop > currentPos) {\n                maxPos = Math.max(maxPos, shop);\n            }\n            currentPos = shop;\n        }\n        \n        totalWalk = maxPos - minPos;\n        totalWalk += (N + 1 - minPos);\n        \n        System.out.println(totalWalk);\n    }\n}",
    "timestamp": "2025-08-05 20:55:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ShoppingTrip {\n    public static int minimumWalkingLength(int N, List<int[]> restrictions) {\n        // Create adjacency list for graph representation\n        List<List<Integer>> graph = new ArrayList<>(N + 1);\n        for (int i = 0; i < N + 1; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        // Indegree array to track dependencies\n        int[] inDegree = new int[N + 1];\n\n        // Build graph and calculate indegree\n        for (int[] restriction : restrictions) {\n            int before = restriction[0];\n            int after = restriction[1];\n            graph.get(before).add(after);\n            inDegree[after]++;\n        }\n\n        // Topological sorting\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 1; i <= N; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        List<Integer> topologicalOrder = new ArrayList<>();\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            topologicalOrder.add(current);\n\n            for (int neighbor : graph.get(current)) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        // If topological sorting is not possible\n        if (topologicalOrder.size() != N) {\n            return -1;\n        }\n\n        // Calculate minimum walking length\n        int totalWalkLength = 0;\n        for (int i = 0; i < topologicalOrder.size() - 1; i++) {\n            int currentShop = topologicalOrder.get(i);\n            int nextShop = topologicalOrder.get(i + 1);\n            totalWalkLength += Math.abs(currentShop - nextShop);\n        }\n\n        // Add walking length to exit\n        totalWalkLength += Math.abs(topologicalOrder.get(N - 1) - (N + 1));\n\n        return totalWalkLength;\n    }\n\n    public static void main(String[] args) {\n        int N = 5;\n        List<int[]> restrictions = new ArrayList<>();\n        restrictions.add(new int[]{1, 3});\n        restrictions.add(new int[]{2, 4});\n\n        int result = minimumWalkingLength(N, restrictions);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 20:55:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100001\n\nint graph[MAX_N][MAX_N];\nint visited[MAX_N];\nint n, m;\n\nint dfs(int v) {\n    visited[v] = 1;\n    for (int i = 1; i <= n; i++) {\n        if (graph[v][i] && !visited[i]) {\n            if (dfs(i)) return 1;\n        } else if (graph[v][i] && visited[i]) {\n            return 1;\n        }\n    }\n    visited[v] = 2;\n    return 0;\n}\n\nint has_cycle() {\n    memset(visited, 0, sizeof(visited));\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            if (dfs(i)) return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        graph[a][b] = 1;\n    }\n\n    if (has_cycle()) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    int total_distance = 0;\n    int current_pos = 1;\n\n    for (int i = 1; i <= n; i++) {\n        int min_dist = MAX_N;\n        int next_shop = -1;\n\n        for (int j = 1; j <= n; j++) {\n            int is_valid = 1;\n            for (int k = 1; k <= n; k++) {\n                if (graph[k][j]) {\n                    is_valid = 0;\n                    break;\n                }\n            }\n\n            if (is_valid) {\n                int dist = abs(current_pos - j);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                    next_shop = j;\n                }\n            }\n        }\n\n        if (next_shop == -1) break;\n\n        total_distance += min_dist;\n        current_pos = next_shop;\n\n        for (int j = 1; j <= n; j++) {\n            graph[j][next_shop] = 0;\n        }\n    }\n\n    total_distance += abs(current_pos - (n + 1));\n    printf(\"%d\\n\", total_distance);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:55:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n    int N, R;\n    cin >> N >> R;\n\n    vector<bool> visited(N + 1, false);\n    vector<vector<int>> restrictions(N + 1);\n\n    for (int i = 0; i < R; i++) {\n        int x, y;\n        cin >> x >> y;\n        restrictions[y].push_back(x);\n    }\n\n    int total_distance = 0;\n    int current_pos = 0;\n\n    for (int i = 1; i <= N; i++) {\n        bool can_visit = true;\n        for (int req : restrictions[i]) {\n            if (!visited[req]) {\n                can_visit = false;\n                break;\n            }\n        }\n\n        if (can_visit) {\n            total_distance += abs(current_pos - i);\n            current_pos = i;\n            visited[i] = true;\n        }\n    }\n\n    total_distance += abs(current_pos - (N + 1));\n\n    cout << total_distance << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:55:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef minimum_walking_distance(N, restrictions):\n    adj = defaultdict(list)\n    in_degree = {i: 0 for i in range(1, N+1)}\n\n    for u, v in restrictions:\n        adj[u].append(v)\n        in_degree[v] += 1\n\n    queue = deque()\n    order = []\n\n    for node in range(1, N+1):\n        if in_degree[node] == 0:\n            queue.append(node)\n\n    while queue:\n        node = queue.popleft()\n        order.append(node)\n        for neighbor in adj[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(order) != N:\n        return -1\n\n    total_distance = 0\n    current_pos = 0\n    for shop in order:\n        total_distance += abs(shop - current_pos)\n        current_pos = shop\n    \n    total_distance += abs((N + 1) - current_pos)\n\n    return total_distance\n\n# Example usage:\nN = 5\nrestrictions = [(3, 4), (2, 5)]\nprint(minimum_walking_distance(N, restrictions))  # Output: minimum walking distance",
    "timestamp": "2025-08-13 04:05:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ShoppingMall {\n    private static int N;\n    private static List<List<Integer>> adjacencyList;\n    private static int[] indegree;\n    \n    public static int calculateMinimumWalkingLength(int N, int[][] restrictions) {\n        ShoppingMall.N = N;\n        adjacencyList = new ArrayList<>();\n        indegree = new int[N + 1];\n        \n        for (int i = 0; i <= N; i++) {\n            adjacencyList.add(new ArrayList<>());\n        }\n        \n        for (int[] restriction : restrictions) {\n            int before = restriction[0];\n            int after = restriction[1];\n            adjacencyList.get(before).add(after);\n            indegree[after]++;\n        }\n\n        return topologicalSortAndCalculateDistance();\n    }\n\n    private static int topologicalSortAndCalculateDistance() {\n        Queue<Integer> queue = new LinkedList<>();\n        List<Integer> topologicalOrder = new ArrayList<>();\n        \n        for (int i = 1; i <= N; i++) {\n            if (indegree[i] == 0) {\n                queue.add(i);\n            }\n        }\n        \n        while (!queue.isEmpty()) {\n            int shop = queue.poll();\n            topologicalOrder.add(shop);\n            \n            for (int nextShop : adjacencyList.get(shop)) {\n                indegree[nextShop]--;\n                if (indegree[nextShop] == 0) {\n                    queue.add(nextShop);\n                }\n            }\n        }\n        \n        // Calculate minimum walking distance\n        int currentPosition = 0;\n        int walkingDistance = 0;\n        \n        for (int shop : topologicalOrder) {\n            walkingDistance += Math.abs(shop - currentPosition);\n            currentPosition = shop;\n        }\n        \n        // Go to the exit from the last shop\n        walkingDistance += Math.abs(N + 1 - currentPosition);\n        \n        return walkingDistance;\n    }\n\n    public static void main(String[] args) {\n        int N = 5;\n        int[][] restrictions = {\n            {1, 2},\n            {1, 3},\n            {3, 4},\n            {4, 5},\n            {2, 5}\n        };\n        \n        int minimumWalkingLength = calculateMinimumWalkingLength(N, restrictions);\n        System.out.println(\"Minimum Walking Length: \" + minimumWalkingLength);\n    }\n}",
    "timestamp": "2025-08-13 04:05:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 1000\n\nint N, M;\nint in_degree[MAXN + 1];\nint adj[MAXN + 1][MAXN + 1];\nint adj_count[MAXN + 1];\nint order[MAXN + 1];\nint order_count;\nint dist[MAXN + 2];\n\nvoid topological_sort() {\n    int queue[MAXN + 1];\n    int front = 0, rear = 0;\n\n    for (int i = 1; i <= N; ++i) {\n        if (in_degree[i] == 0) {\n            queue[rear++] = i;\n        }\n    }\n\n    order_count = 0;\n    while (front < rear) {\n        int shop = queue[front++];\n        order[order_count++] = shop;\n        for (int i = 0; i < adj_count[shop]; ++i) {\n            int next = adj[shop][i];\n            if (--in_degree[next] == 0) {\n                queue[rear++] = next;\n            }\n        }\n    }\n}\n\nvoid calculate_distances() {\n    for (int i = 0; i <= N + 1; ++i) {\n        dist[i] = 0;\n    }\n    \n    for (int i = 0; i < order_count; ++i) {\n        int shop = order[i];\n        for (int j = 0; j < adj_count[shop]; ++j) {\n            int next = adj[shop][j];\n            if (dist[next] < dist[shop] + 1) {\n                dist[next] = dist[shop] + 1;\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    memset(in_degree, 0, sizeof(in_degree));\n    memset(adj_count, 0, sizeof(adj_count));\n\n    while (M--) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        adj[u][adj_count[u]++] = v;\n        in_degree[v]++;\n    }\n\n    // Adding exit point\n    for (int i = 1; i <= N; ++i) {\n        adj[i][adj_count[i]++] = N + 1;\n    }\n\n    topological_sort();\n    calculate_distances();\n\n    int min_walking_length = 0;\n    for (int i = 1; i <= N; ++i) {\n        min_walking_length += 2;\n    }\n\n    min_walking_length -= dist[N + 1];\n\n    printf(\"%d\\n\", min_walking_length);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:05:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\n\ndef min_shopping_distance(N: int, restrictions: List[Tuple[int, int]]) -> int:\n    # Create adjacency list for restrictions\n    graph = [[] for _ in range(N+1)]\n    in_degree = [0] * (N+1)\n    for u, v in restrictions:\n        graph[u].append(v)\n        in_degree[v] += 1\n\n    # Topological sort to order shops\n    order = []\n    queue = [i for i in range(1, N+1) if in_degree[i] == 0]\n    while queue:\n        curr = queue.pop(0)\n        order.append(curr)\n        for neighbor in graph[curr]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # If not all shops can be visited, return -1\n    if len(order) != N:\n        return -1\n\n    # Calculate minimum walking distance\n    total_distance = 0\n    for i in range(len(order) - 1):\n        total_distance += abs(order[i] - order[i+1])\n\n    # Add distance from entrance to first shop and last shop to exit\n    total_distance += order[0] - 1\n    total_distance += N + 1 - order[-1]\n\n    return total_distance",
    "timestamp": "2025-08-13 04:06:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    adj = defaultdict(list)\n    in_degree = [0] * (N + 2)\n    for _ in range(M):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a].append(b)\n        in_degree[b] += 1\n    \n    # Kahn's algorithm for topological sort\n    q = deque()\n    for i in range(1, N + 1):\n        if in_degree[i] == 0:\n            q.append(i)\n    \n    topo_order = []\n    while q:\n        u = q.popleft()\n        topo_order.append(u)\n        for v in adj[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                q.append(v)\n    \n    # The path is entrance -> topo_order -> exit\n    path = [0] + topo_order + [N + 1]\n    total = 0\n    for i in range(1, len(path)):\n        total += abs(path[i] - path[i-1])\n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 04:06:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint minWalkingDistance(int N, const vector<pair<int, int>>& restrictions) {\n    vector<vector<int>> dp(N + 1, vector<int>(N + 1, INT_MAX));\n    dp[0][0] = 0;\n    \n    for (int i = 0; i <= N; ++i) {\n        for (int j = 0; j <= N; ++j) {\n            if (dp[i][j] == INT_MAX) continue;\n\n            int next = (j == N) ? N + 1 : j + 1;  \n              \n            dp[next][j] = min(dp[next][j], dp[i][j] + abs(next - i));\n            dp[i][next] = min(dp[i][next], dp[i][j] + abs(next - j));\n\n            for (const auto& r : restrictions) {\n                if (i < r.second && j >= r.first) {\n                    dp[r.second][j] = min(dp[r.second][j], dp[i][j] + abs(r.second - i));\n                }\n                if (j < r.second && i >= r.first) {\n                    dp[i][r.second] = min(dp[i][r.second], dp[i][j] + abs(r.second - j));\n                }\n            }\n        }\n    }\n    \n    int result = INT_MAX;\n    for (int i = 0; i <= N; ++i) {\n        result = min(result, dp[i][N]);\n    }\n    \n    return result;\n}\n\nint main() {\n    int N;\n    int R;\n    \n    cin >> N >> R;\n    \n    vector<pair<int, int>> restrictions(R);\n    for (int i = 0; i < R; ++i) {\n        cin >> restrictions[i].first >> restrictions[i].second;\n    }\n    \n    cout << minWalkingDistance(N, restrictions) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:17:10"
  }
]