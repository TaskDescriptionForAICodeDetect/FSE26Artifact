[
  {
    "language": "Crystal",
    "code": "n = gets.not_nil!.to_i\na = gets.not_nil!.split.map do |char| char.to_i end\n\n\n\ndef get_index_min(array,min)\n    index_min = array.index(min, offset: 1).not_nil!\n\n    if index_min == array.size - 1 ||index_min == Nil || index_min == 0\n        array_cp = array.clone\n        array_cp.sort!.uniq\n        if array.\n        index_min = array.index(array_cp[2]).not_nil!\n        puts index_min\n    end\n    return index_min\nend\n\nuntil a.size == 2 \n   \n    if a.size == 3\n        index_min = 1\n        a[0] += a[1]\n        a[2] += a[1]\n        a.delete_at(1)\n        # puts a\n        break\n    end\n    index_min = get_index_min a,a.min\n\n    # until index_min != a.size - 1\n    #     b = a.clone\n    #     b.delete_at(get_index_min b, b.min)\n    #     index_min = get_index_min a, b.min\n    # end  \n\n\n\n    # a[0] += a[1]\n    # a[2] += a[1]\n    puts \"-----------\"\n    puts a\n    puts \"index_min = #{index_min}\"\n    a[index_min - 1] +=a[index_min]\n    a[index_min + 1] +=a[index_min]\n    puts a\n    a.delete_at(index_min)\n    puts a\nend\n\nputs a.sum"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=500005;\nconst int mo=998244353;\n\nint n,m,N,M;\nint fac[maxn],ifac[maxn],pw1[maxn],pw2[maxn];\n\ninline int pow(int a,int b,int p){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%p)\n\t\tif(b&1)ans=1ll*ans*a%p;\n\treturn ans;\n}\n\ninline int C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn 1ll*fac[n]*ifac[m]%mo*ifac[n-m]%mo;\n}\n\nint main(){\n\tcin>>n>>m;\n\tN=min(n,m),M=max(n,m);\n\tfac[0]=ifac[0]=pw1[0]=pw2[0]=1;\n\tfor(int i=1;i<=n;i++)pw1[i]=1ll*pw1[i-1]*(m+1)%mo;\n\tfor(int i=1;i<=m;i++)pw2[i]=1ll*pw2[i-1]*(n+1)%mo;\n\tfor(int i=1;i<=M;i++)fac[i]=1ll*fac[i-1]*i%mo;\n\tifac[M]=pow(fac[M],mo-2,mo);\n\tfor(int i=M-1;i;i--)ifac[i]=1ll*ifac[i+1]*(i+1)%mo;\n\tlong long ans=0,w=1;\n\tfor(int i=0;i<=N;i++,w=-w)\n\t\tans+=w*C(n,i)*C(m,i)%mo*fac[i]%mo*pw1[n-i]%mo*pw2[m-i]%mo;\n\tcout<<(ans%mo+mo)%mo<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n/*\nGF(p)\ninverse:O(log p) based on Fermat's little theorem (a^(p-1)=1 mod p)\n*/\n\ntemplate<int32_t mod>\nstruct ModInt{\n\tint32_t a;\n\tinline int32_t normalize(int64_t x){\n\t\tx%=mod;\n\t\tif(x<0)x+=mod;\n\t\treturn x;\n\t}\n\tModInt(const int64_t a=0):a(normalize(a)){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta-=x.a;\n\t\tif(a<0)a+=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=(int64_t)a*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt x){return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt x){return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt x){return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt x){return ModInt(*this)/=x;}\n\tbool operator==(const ModInt x){return a==x.a;}\n\tbool operator!=(const ModInt x){return a!=x.a;}\n\n\tModInt operator-(){return ModInt(0)-ModInt(*this);}\n\tModInt pow(int64_t ex)const{\n\t\tint64_t x=a;\n\t\tint64_t res=1;\n\t\twhile(ex){\n\t\t\tif(ex&1)res=res*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tex>>=1;\n\t\t}\n\t\treturn ModInt(res);\n\t}\n\tModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<int32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<int32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\n\nusing mint=ModInt<998244353>;\n\n/*\nbased on Cooley-Tukey\nO(nlogn)\n*/\n\ntemplate<class Mint,int32_t root>\nstruct NumberTheoreticTransform{\n\tstatic void ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(root).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    static void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tstatic vector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n};\nusing NTT=NumberTheoreticTransform<mint,3>;\n\n/*\neach operation:O(n) or O(nlogn) \n*/\n \ntemplate<class Mint,class Convoluter>\nstruct Poly{\n\tvector<Mint>v;\n    inline void normalize(){\n        while(v.size()&&v.back()==0)v.pop_back();\n    }\n\ttemplate<class...Args>\n\tPoly(Args...args):v(args...){}\n \n\tPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n \n\tint size()const{return v.size();}\n \n\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n \n\tPoly operator+(const Poly &x){\n\t\tint n=max(size(),x.size());\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\treturn res;\n\t}\n\tPoly operator-(const Poly &x){\n\t\tint n=max(size(),x.size());\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\treturn res;\n\t}\n\tPoly operator*(const Poly& x){\n\t\treturn Convoluter::convolute(v,x.v);\n\t}\n\tPoly operator*(const Mint& x){\n\t\tint n=size();\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\treturn res;\n\t}\n\tPoly operator/(const Mint& x){\n\t\treturn (*this)*x.inv();\n\t}\n \n\tPoly& operator+=(const Poly& x){return *this=(*this)+x;}\n\tPoly& operator-=(const Poly& x){return *this=(*this)-x;}\n\tPoly& operator*=(const Poly& x){return *this=(*this)*x;}\n\tPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\tPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n \n    Poly pre(int n){\n        return {v.begin(),v.begin()+min(n,size())};\n    }\n    Poly rev(){\n        vector<Mint>res=v;\n        reverse(res.begin(),res.end());\n        return res;\n    }\n    Poly diff(int n){\n        vector<Mint>res(n);\n        for(int i=1;i<size()&&i<=n;i++)res[i-1]=coef(i)*i;\n        return res;\n    }\n    Poly inte(int n){\n        vector<Mint>res(n);\n        for(int i=0;i<size()&&i+1<n;i++)res[i+1]=coef(i)/(i+1);\n        return res;\n    }\n \n    Poly inv(int m){\n        Poly res{1};\n        for(int i=1;i<m;i*=2){\n            res=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n        }\n        return res.pre(m);\n    }\n    Poly exp(int n){\n        Poly f{1};\n        for(int i=1;i<n;i*=2){\n            f=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n        }\n        return f.pre(n);\n    }\n \n    Poly log(int n){\n        return (diff(n-1)*inv(n-1)).inte(n);\n    }\n\t\n\tPoly pow(int n,mint k){\n\t\tauto res=log(n);\n\t\tres*=k;\n\t\treturn res.exp(n);\n\t}\n \n\tMint& operator[](const int i){return v[i];}\n};\nusing poly=Poly<mint,NTT>;\n \ntemplate<class Mint,class Convoluter>\nostream& operator<<(ostream& ost,Poly<Mint,Convoluter>a){\n    for(int i=0;i<a.size();i++){\n        if(i)cout<<\" \";\n        cout<<a.v[i];\n    }\n    return ost;\n}\n\n\ntemplate<class Mint>\nstruct Combinations{\n\tint N;\n\tvector<Mint>facts,finvs,invs;\n\tCombinations(int n):N(n),facts(n),finvs(n),invs(n){\n\t\tfacts[0]=finvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tinvs[i]=Mint(i).inv();\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n){return facts[n];}\n\tinline Mint finv(int n){return finvs[n];}\n\tinline Mint inv(int n){return invs[n];}\n\tinline Mint binom(int n,int k){return facts[n]*finvs[k]*finvs[n-k];}\n};\nCombinations<mint>C(555555);\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n\n\tpoly p(N+1);\n\n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=C.finv(i)*in*(N+1-i);\n\t}\n\n\tp=p.pow(N+1,M);\n\n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*C.finv(N-i);\n\t}\n\tans*=C.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\n//uint mod=1;\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n    ModInt(int64_t x=0):a((x%mod+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n        if(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=(uint64_t)a*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-(){return ModInt()-*this;}\n\tinline ModInt pow(uint64_t ex)const{\n\t\tuint64_t x=a;\n\t\tuint64_t res=1;\n\t\twhile(ex){\n\t\t\tif(ex&1)res=res*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tex>>=1;\n\t\t}\n\t\treturn ModInt(res);\n\t}\n\n    inline ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,const ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t N>\nstruct ModIntTable{\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n)const{return facts[n];}\n\tinline Mint finv(int n)const{return finvs[n];}\n\tinline Mint inv(int n)const{return invs[n];}\n\tinline Mint binom(int n,int k)const{return facts[n]*finvs[k]*finvs[n-k];}\n};\nModIntTable<mint,1<<19>mtable;\n\n\n\nconst mint prim_root=3;\n\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tmint in=mint(n).inv();\n\trep(i,n)\n\t\tf[i]*=in;\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\n\n\nvector<mint> multiply(vector<mint> x,vector<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1].v);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*mtable.inv(i+1);\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\t//yosupo judge\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn make_pair(f.low(s),g.low(s));\n\t}\n};\n\nusing poly=Poly<mint>;\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=mtable.finv(i)*in*(N+1-i);\n\t}\n\n\tp=p.log(N+1);\n\trep(i,N+1)p[i]*=M;\n\tp=p.exp(N+1);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*mtable.finv(N-i);\n\t}\n\tans*=mtable.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for (int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T sqr(const T &a) { return a * a; }\ntypedef long long LL;\ntypedef long double LD;\nvoid procStatus() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\nLL read() {\n\tLL x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (;!isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n\tfor (;isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\treturn x * flag;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 5e5 + 9, Mod = 998244353;\nint mmul(int a, int b){\n    int ret;\n    __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret) : \"a\"(a), \"b\"(b), \"c\"(Mod));\n    return ret;\n}\nint mplus(int a, int b) {\n\ta += b;\n\tif (a >= Mod) a -= Mod;\n\treturn a;\n}\nint fpm(int base, int tims) {\n\tint r = 1;\n\tfor (; tims; base = mmul(base, base), tims >>= 1) \n\t\tif (tims & 1) r = mmul(r, base);\n\treturn r;\n}\nint fac[Maxn], inv[Maxn], invFac[Maxn];\n\nvoid Init() {\n\tfac[0] = 1;\n\trep (i, 1, Maxn - 1) fac[i] = mmul(fac[i - 1], i);\n\tinv[1] = 1;\n\trep (i, 2, Maxn - 1) inv[i] = mmul(inv[Mod % i], Mod - Mod / i);\n\tinvFac[0] = 1;\n\trep (i, 1, Maxn - 1) invFac[i] = mmul(invFac[i - 1], inv[i]);\n}\n\nint C(int n, int m) {\n\tif (n < m || n < 0 || m < 0) return 0;\t\n\treturn mmul(fac[n], mmul(invFac[n - m], invFac[m]));\n}\n\nint n, m;\nint f(int k) {\n\treturn mmul(C(n, k), mmul(C(m, k), mmul(fac[k], mmul(fpm(n + 1, m - k), fpm(m + 1, n - k)))));\n}\n\nvoid Solve() {\n\tn = read(), m = read();\n\tint ans = 0;\n\trep (k, 0, min(n, m)) {\n\t\tint coef = (k & 1) ? (Mod - 1) : 1;\n\t\tans = mplus(ans, mmul(coef, f(k)));\n\t}\n\tcout << ans << endl; \n}\n\nint main() {\n//\tfreopen(\"bosky.in\", \"r\", stdin);\n//\tfreopen(\"bosky.out\", \"w\", stdout);\n\n\tInit();\n\tSolve();\t\n\n#ifdef Qrsikno\n//\tprocStatus();\n\tdebug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#define ll long long\n#define inf 20021225\n#define N 500010\n#define mdn 998244353\nusing namespace std;\nint read()\n{\n\tint s=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();\n\treturn f*s;\n}\nint fac[N],inv[N];\nint ksm(int bs,int mi)\n{\n\tint ans=1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=1ll*ans*bs%mdn;\n\t\tbs=1ll*bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nvoid init()\n{\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<N;i++)\tfac[i]=1ll*fac[i-1]*i%mdn;\n\tinv[N-1]=ksm(fac[N-1],mdn-2);\n\tfor(int i=N-1;~i;i--)\tinv[i-1]=1ll*inv[i]*i%mdn;\n}\nint C(int n,int m)\n{\n\treturn n<m?0:1ll*fac[n]*inv[m]%mdn*inv[n-m]%mdn;\n}\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nvoid dpu(int &x,int y){x-=x-y<0?y-mdn:y;}\nint F(int n,int m,int i){return 1ll*C(n,i)*C(m,i)%mdn*fac[i]%mdn*ksm(m+1,n-i)%mdn*ksm(n+1,m-i)%mdn;}\nint main()\n{\n\tint n=read(),m=read(); init(); int ans=0;\n\tfor(int i=0;i<=min(n,m);i++)\n\t\tif(i&1)\tdpu(ans,F(n,m,i));\n\t\telse\tupd(ans,F(n,m,i));\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct ModInt{\n\tuint a;\n    ModInt(ll x=0):a((x%mod+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n        if(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=ull(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){\n\t\treturn s(a+x.a);\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\treturn s(a+mod-x.a);\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt<998244353>;\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t N>\nstruct ModIntTable{\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n){return facts[n];}\n\tinline Mint finv(int n){return finvs[n];}\n\tinline Mint inv(int n){return invs[n];}\n\tinline Mint binom(int n,int k){return facts[n]*finvs[k]*finvs[n-k];}\n};\nModIntTable<mint,1<<19>mtable;\n\n\ntemplate<class Mint,int32_t root>\nstruct NumberTheoreticTransform{\n\tstatic void ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(root).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    static void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tstatic vector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n};\nusing NTT=NumberTheoreticTransform<mint,3>;\n\n\nconst uint32_t mod=998244353;\nconst mint prim_root=3;\n\n\nstatic const int LG=19;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tmint in=mint(n).inv();\n\trep(i,n)\n\t\tf[i]*=in;\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i=false){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\n\n\nvector<mint> multiply(vector<mint> x,vector<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n \ntemplate<class Mint>\nstruct NTTFriendlyPoly{\n\tvoid ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(3).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tvector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n\n\tvector<Mint>v;\n\ttemplate<class...Args>\n\tNTTFriendlyPoly(Args...args):v(args...){}\n \n\tNTTFriendlyPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n \n\tint size()const{return v.size();}\n \n\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n \n\tNTTFriendlyPoly operator+(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator-(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator*(const NTTFriendlyPoly& x){\n\t\treturn multiply(v,x.v);\n\t}\n\tNTTFriendlyPoly operator*(const Mint& x){\n\t\tint n=size();\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator/(const Mint& x){\n\t\treturn (*this)*x.inv();\n\t}\n \n\tNTTFriendlyPoly& operator+=(const NTTFriendlyPoly& x){return *this=(*this)+x;}\n\tNTTFriendlyPoly& operator-=(const NTTFriendlyPoly& x){return *this=(*this)-x;}\n\tNTTFriendlyPoly& operator*=(const NTTFriendlyPoly& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n\tNTTFriendlyPoly operator-(){return NTTFriendlyPoly()-*this;}\n \n    NTTFriendlyPoly pre(int n){\n        NTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n&&i<size();i++)res[i]=v[i];\n\t\treturn res;\n    }\n    NTTFriendlyPoly rev(){\n        vector<Mint>res=v;\n\t\twhile(res.size()&&res.back()==0)res.pop_back();\n        reverse(res.begin(),res.end());\n        return res;\n    }\n    NTTFriendlyPoly diff(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=1;i<size()&&i<=n;i++)res[i-1]=v[i]*i;\n        return res;\n    }\n    NTTFriendlyPoly inte(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=0;i<size()&&i+1<n;i++)res[i+1]=v[i]*mtable.inv(i+1);\n        return res;\n    }\n\n    NTTFriendlyPoly inv(int n){\n        vector<mint>res{coef(0).inv()};\n\n        for(int d=1;d<n;d<<=1){\n            vector<Mint>f(2*d),g(2*d);\n            for(int j=0;j<2*d;j++)f[j]=coef(j);\n            for(int j=0;j<d;j++)g[j]=res[j];\n            \n            inplace_fmt(f);inplace_fmt(g);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++){\n                f[j]=0;\n                f[j+d]=-f[j+d];\n            }\n            inplace_fmt(f);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++)f[j]=res[j];\n            res=f;\n        }\n        return NTTFriendlyPoly(res).pre(n);\n    }\n    \n    \n    NTTFriendlyPoly inv2(int n){\n        NTTFriendlyPoly res{coef(0).inv()};\n        for(int i=1;i<n;i*=2){\n            res=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n        }\n        return res.pre(n);\n    }\n    \n    \n\n\tNTTFriendlyPoly exp(int n){\n\t\tNTTFriendlyPoly f0{1},g0{1};\n\t\tvector<Mint>F0{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tvector<Mint>G0=g0.v;\n\t\t\tinplace_fmt(G0);\n\t\t\tvector<Mint>Delta(d);\n\t\t\tfor(int j=0;j<d;j++)Delta[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tDelta[0]-=1;\n\t\t\tNTTFriendlyPoly delta(2*d);\n\t\t\tfor(int j=0;j<d;j++)delta[d+j]=Delta[j];\t\t\n\t\t\t\n\t\t\tNTTFriendlyPoly epsilon(2*d);\n\t\t\t\n\t\t\n\t\t\t\n\t\t\tvector<Mint>DF0=f0.diff(d-1).v;DF0.push_back(0);\n\t\t\tinplace_fmt(DF0);\n\t\t\tfor(int j=0;j<d;j++)DF0[j]*=G0[j];\n\t\t\tinplace_fmt(DF0,true);\n\t\t\tfor(int j=0;j<d-1;j++){\n\t\t\t\tepsilon[j]+=coef(j+1)*(j+1);\n\t\t\t\tepsilon[j+d]+=DF0[j]-coef(j+1)*(j+1);\n\t\t\t}\n\t\t\tepsilon[d-1]+=DF0[d-1];\n\n\n\t\t\tDelta=delta.v;\n\t\t\tinplace_fmt(Delta);\n\t\t\tvector<Mint>DH0=diff(d-1).v;DH0.resize(2*d);\n\t\t\tinplace_fmt(DH0);\n\t\t\tfor(int j=0;j<2*d;j++)Delta[j]*=DH0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tfor(int j=0;j<d;j++)epsilon[j+d]-=Delta[j+d];\n\t\t\n\n\t\t\tepsilon=epsilon.inte(2*d)-pre(2*d);\n\t\t\t\n\t\t\tvector<Mint>Epsilon=epsilon.v;\n\t\t\tinplace_fmt(Epsilon);\n\t\t\trep(j,d)DH0[j]=f0[j],DH0[j+d]=0;\n\t\t\tinplace_fmt(DH0);\n\t\t\trep(j,2*d)Epsilon[j]*=DH0[j];\n\t\t\tinplace_fmt(Epsilon,true);\n\t\t\tf0.v.resize(2*d);\n\t\t\trep(j,d)f0[j+d]-=Epsilon[j+d];\n\t\t\t//f0=(f0-epsilon*f0).pre(2*d);\n\t\t\t\n\t\t\tG0.resize(2*d);\n\t\t\trep(j,d)G0[j]=g0[j];\n\t\t\tinplace_fmt(G0);\n\t\t\tF0=f0.v; \n\t\t\tinplace_fmt(F0);\n\t\t\tvector<Mint>T(2*d);rep(j,2*d)T[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d){\n\t\t\t\tT[j]=0;\n\t\t\t\tT[j+d]=-T[j+d];\n\t\t\t}\n\t\t\tinplace_fmt(T);\n\t\t\trep(j,2*d)T[j]*=G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d)T[j]=g0[j];\n\t\t\tg0=T;\n\t\t}\n\t\treturn f0.pre(n);\n\t}\n\n    NTTFriendlyPoly exp2(int n){\n        NTTFriendlyPoly f{1};\n        for(int i=1;i<n;i*=2){\n            f=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n        }\n        return f.pre(n);\n    }\n\n\tNTTFriendlyPoly exp3(int n){\n\t\tNTTFriendlyPoly f{1},g{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tg=g*Mint(2)-(g*g*f).pre(d);\n\n\t\t\tNTTFriendlyPoly q=diff(d-1);\n\t\t\tq=q+g*(f.diff(d-1)-f*q).pre(2*d-1);\n\t\t\tf=f+(f*(pre(2*d)-q.inte(2*d))).pre(2*d);\n\t\t}\n\t\treturn f.pre(n);\n\t}\n\n\n \n    NTTFriendlyPoly log(int n){\n        return (diff(n-1)*inv(n-1)).inte(n);\n    }\n \n    NTTFriendlyPoly pow(int n,mint k){\n\t\tauto res=log(n);\n\t\tres*=k;\n\t\treturn res.exp(n);\n\t}\n\tMint& operator[](const int i){return v[i];}\n};\nusing poly=NTTFriendlyPoly<mint>;\n \ntemplate<class Mint>\nostream& operator<<(ostream& ost,NTTFriendlyPoly<Mint>a){\n    for(int i=0;i<a.size();i++){\n        if(i)cout<<\" \";\n        cout<<a.v[i];\n    }\n    return ost;\n}\n\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=mtable.finv(i)*in*(N+1-i);\n\t}\n \n\tp=p.pow(N+1,M);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*mtable.finv(N-i);\n\t}\n\tans*=mtable.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\nusing namespace std;\ninline int readint(){\n\tint x=0;\n\tbool f=0;\n\tchar c=getchar();\n\twhile(!isdigit(c)&&c!='-') c=getchar();\n\tif(c=='-'){\n\t\tf=1;\n\t\tc=getchar();\n\t}\n\twhile(isdigit(c)){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn f?-x:x;\n}\nconst int maxn=5e5+5;\nint n,m;\ntypedef long long ll;\nconst ll mod=998244353;\nll inv[maxn],cn[maxn],cm[maxn],pown[maxn],powm[maxn],fac[maxn];\nint main(){\n\t#ifdef LOCAL\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n\t#endif\n\tn=readint();\n\tm=readint();\n\tinv[1]=1;\n\tfor(int i=2;i<=n||i<=m;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tcn[0]=1;\n\tfor(int i=1;i<=n;i++) cn[i]=cn[i-1]*(n-i+1)%mod*inv[i]%mod;\n\tcm[0]=1;\n\tfor(int i=1;i<=m;i++) cm[i]=cm[i-1]*(m-i+1)%mod*inv[i]%mod;\n\tpown[0]=1;\n\tfor(int i=1;i<=m;i++) pown[i]=pown[i-1]*(n+1)%mod;\n\tpowm[0]=1;\n\tfor(int i=1;i<=n;i++) powm[i]=powm[i-1]*(m+1)%mod;\n\tfac[0]=1;\n\tfor(int i=1;i<=n&&i<=m;i++) fac[i]=fac[i-1]*i%mod;\n\tll ans=0;\n\tfor(int i=0;i<=n&&i<=m;i++){\n\t\tll res=cn[i]*cm[i]%mod*fac[i]%mod*pown[m-i]%mod*powm[n-i]%mod;\n\t\tif(i%2==0) ans=(ans+res)%mod;\n\t\telse ans=(ans+mod-res)%mod;\n\t}\n\tprintf(\"%d\\n\",(int)ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\tconst int N = 5e5 + 5, mod = 998244353;\n\n\tint n, m, Fac[N], Inv[N];\n\n\tinline int qpow(int x, int tim)\n\t{\n\t\tint ans = 1;\n\t\tfor (; tim; tim >>= 1, x = int((ll)x * x % mod))\n\t\t\tif (tim & 1)\n\t\t\t\tans = int((ll)ans * x % mod);\n\t\treturn ans;\n\t}\n\n\tinline int C(const int x, const int y)\n\t{ return x < y ? 0 : int((ll)Fac[x] * Inv[y] % mod * Inv[x - y] % mod); }\n\n\tvoid work()\n\t{\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n < m)\n\t\t\tswap(n, m);\n\t\tFac[0] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tFac[i] = int((ll)Fac[i - 1] * i % mod);\n\t\tInv[n] = qpow(Fac[n], mod - 2);\n\t\tfor (int i = n; i; i--)\n\t\t\tInv[i - 1] = int((ll)Inv[i] * i % mod);\n\t\tint ans = 0;\n\t\tfor (int r = 0, d = 1; r <= m; r++, d = -d)\n\t\t\tans = int((ans + (ll)(mod + d) * C(n, r) % mod * C(m, r) % mod * Fac[r] % mod * qpow(m + 1, n - r) % mod * qpow(n + 1, m - r) % mod) % mod);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n  int N,M;\n  cin>>N>>M;\n  int N*N=A;\n  int M*M=B;\n  int A+B=C;\n  int B*N=D;\n  int e;\n  cin>>e;\n  cout<<C*D;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n    ModInt(int64_t x=0):a((x%mod+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n        if(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=(uint64_t)a*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt x){return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt x){return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt x){return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt x){return ModInt(*this)/=x;}\n\tbool operator==(const ModInt x){return a==x.a;}\n\tbool operator!=(const ModInt x){return a!=x.a;}\n\n\tModInt operator-(){return ModInt(0)-ModInt(*this);}\n\tinline ModInt pow(uint64_t ex)const{\n\t\tuint64_t x=a;\n\t\tuint64_t res=1;\n\t\twhile(ex){\n\t\t\tif(ex&1)res=res*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tex>>=1;\n\t\t}\n\t\treturn ModInt(res);\n\t}\n\n    inline ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\ntemplate<class Mint,int32_t root>\nstruct NumberTheoreticTransform{\n\tstatic void ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(root).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    static void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tstatic vector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n};\nusing NTT=NumberTheoreticTransform<mint,3>;\n\n \ntemplate<class Mint,class Convoluter>\nstruct NTTFriendlyPoly{\n\tvector<Mint>v;\n    inline void normalize(){\n        while(v.size()&&v.back()==0)v.pop_back();\n    }\n\ttemplate<class...Args>\n\tNTTFriendlyPoly(Args...args):v(args...){}\n \n\tNTTFriendlyPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n \n\tint size()const{return v.size();}\n \n\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n \n\tNTTFriendlyPoly operator+(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator-(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator*(const NTTFriendlyPoly& x){\n\t\treturn Convoluter::convolute(v,x.v);\n\t}\n\tNTTFriendlyPoly operator*(const Mint& x){\n\t\tint n=size();\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator/(const Mint& x){\n\t\treturn (*this)*x.inv();\n\t}\n \n\tNTTFriendlyPoly& operator+=(const NTTFriendlyPoly& x){return *this=(*this)+x;}\n\tNTTFriendlyPoly& operator-=(const NTTFriendlyPoly& x){return *this=(*this)-x;}\n\tNTTFriendlyPoly& operator*=(const NTTFriendlyPoly& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n \n    NTTFriendlyPoly pre(int n){\n        return {v.begin(),v.begin()+min(n,size())};\n    }\n    NTTFriendlyPoly rev(){\n        vector<Mint>res=v;\n        reverse(res.begin(),res.end());\n        return res;\n    }\n    NTTFriendlyPoly diff(int n){\n        vector<Mint>res(n);\n        for(int i=1;i<size()&&i<=n;i++)res[i-1]=coef(i)*i;\n        return res;\n    }\n    NTTFriendlyPoly inte(int n){\n        vector<Mint>res(n);\n        for(int i=0;i<size()&&i+1<n;i++)res[i+1]=coef(i)/(i+1);\n        return res;\n    }\n\n    NTTFriendlyPoly inv(int m){\n        NTTFriendlyPoly res{coef(0).inv()};\n\n        for(int d=1;d<m;d<<=1){\n            vector<Mint>f(2*d),g(2*d);\n            for(int j=0;j<2*d;j++)f[j]=coef(j);\n            for(int j=0;j<d;j++)g[j]=res[j];\n            \n            Convoluter::ntt(f);Convoluter::ntt(g);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            Convoluter::intt(f);\n            for(int j=0;j<d;j++){\n                f[j]=0;\n                f[j+d]=-f[j+d];\n            }\n            Convoluter::ntt(f);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            Convoluter::intt(f);\n            for(int j=0;j<d;j++)f[j]=res[j];\n            res=f;\n        }\n        return res.pre(m);\n    }\n    \n    NTTFriendlyPoly inv2(int m){\n        NTTFriendlyPoly res{coef(0).inv()};\n        for(int i=1;i<m;i*=2){\n            res=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n        }\n        return res.pre(m);\n    }\n    \n    NTTFriendlyPoly exp(int n){\n        NTTFriendlyPoly f{1};\n        for(int i=1;i<n;i*=2){\n            f=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n        }\n        return f.pre(n);\n    }\n \n    NTTFriendlyPoly log(int n){\n        return (diff(n-1)*inv(n-1)).inte(n);\n    }\n \n    NTTFriendlyPoly pow(int n,mint k){\n\t\tauto res=log(n);\n\t\tres*=k;\n\t\treturn res.exp(n);\n\t}\n\tMint& operator[](const int i){return v[i];}\n};\nusing poly=NTTFriendlyPoly<mint,NTT>;\n \ntemplate<class Mint,class Convoluter>\nostream& operator<<(ostream& ost,NTTFriendlyPoly<Mint,Convoluter>a){\n    for(int i=0;i<a.size();i++){\n        if(i)cout<<\" \";\n        cout<<a.v[i];\n    }\n    return ost;\n}\n\n\ntemplate<class Mint>\nstruct Combinations{\n\tint N;\n\tvector<Mint>facts,finvs,invs;\n\tCombinations(int n):N(n),facts(n),finvs(n),invs(n){\n\t\tfacts[0]=finvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tinvs[i]=Mint(i).inv();\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n){return facts[n];}\n\tinline Mint finv(int n){return finvs[n];}\n\tinline Mint inv(int n){return invs[n];}\n\tinline Mint binom(int n,int k){return facts[n]*finvs[k]*finvs[n-k];}\n};\nCombinations<mint>C(555555);\n \nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=C.finv(i)*in*(N+1-i);\n\t}\n \n\tp=p.pow(N+1,M);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*C.finv(N-i);\n\t}\n\tans*=C.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5e5 + 5;\nconst int P = 998244353;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint fac[MAXN], inv[MAXN];\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\telse return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\tinv[n] = power(fac[n], P - 2);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1ll) % P;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint main() {\n\tint n, m; read(n), read(m);\n\tinit(max(n, m));\n\tint ans = 0;\n\tfor (int i = 0; i <= min(n, m); i++)\n\t\tif (i & 1) update(ans, P - 1ll * binom(n, i) * binom(m, i) % P * fac[i] % P * power(n + 1, m - i) % P * power(m + 1, n - i) % P);\n\t\telse update(ans, 1ll * binom(n, i) * binom(m, i) % P * fac[i] % P * power(n + 1, m - i) % P * power(m + 1, n - i) % P);\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=500005;\nconst int mod=998244353;\nint n,m,ans;\nint fac[maxn],ifac[maxn],pw_n[maxn],pw_m[maxn];\nint C(int a,int b){\n\tif(a<b||a<0||b<0)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint s=max(n,m);\n\tfac[0]=ifac[0]=fac[1]=ifac[1]=1;\n\tfor(int i=2;i<=s;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod;\n\t}\n\tREP(i,s)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tpw_n[0]=1;\n\tREP(i,m)pw_n[i]=1LL*pw_n[i-1]*(n+1)%mod;\n\tpw_m[0]=1;\n\tREP(i,n)pw_m[i]=1LL*pw_m[i-1]*(m+1)%mod;\n\trep(i,min(n,m)+1){\n\t\tans+=1LL*C(n,i)*C(m,i)%mod*fac[i]%mod*pw_n[m-i]%mod*pw_m[n-i]%mod*(i&1?(mod-1):1)%mod;\n\t\tif(ans>=mod)ans-=mod; \n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=500005;\nconst int mod=998244353;\nint n,m;\nll fac[maxn],inv_fac[maxn];\ninline ll fpow(ll a,ll b)\n{\n\tll ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1) ret=ret*a%mod;\n\treturn ret;\n}\ninline ll C(int n,int m)\n{\n\tif(n<m) return 0;\n\treturn fac[n]*inv_fac[m]%mod*inv_fac[n-m]%mod;\n}\nint main()\n{\n\tfac[0]=fac[1]=inv_fac[0]=inv_fac[1]=1;\n\tfor(int i=2;i<maxn;i++) fac[i]=fac[i-1]*i%mod;\n\tfor(int i=2;i<maxn;i++) inv_fac[i]=(mod-mod/i)*inv_fac[mod%i]%mod;\n\tfor(int i=2;i<maxn;i++) inv_fac[i]=inv_fac[i]*inv_fac[i-1]%mod;\n\tscanf(\"%d%d\",&n,&m);\n\tll ans=0;\n\tfor(int i=0;i<=min(n,m);i++)\n\t\t(ans+=((i&1)?mod-1:1)*C(n,i)%mod*C(m,i)%mod*fac[i]%mod\n\t\t*fpow(n+1,m-i)%mod*fpow(m+1,n-i))%=mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing i64 = long long;\n\nconst int N = 500000 + 7;\nconst i64 MOD = 998244353;\n\nint n, m;\ni64 fac[N], ifc[N], inv[N];\ni64 ans = 0;\n\ni64 pow(i64 a, i64 k) {\n\ti64 t = 1;\n\tfor (; k; a = a * a % MOD, k >>= 1) if (k & 1) t = t * a % MOD;\n\treturn t;\n}\ni64 binom(i64 n, i64 m) {\n\treturn n < m || m < 0 ? 0 : fac[n] * ifc[m] % MOD * ifc[n - m] % MOD;\n}\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\t\n\tscanf(\"%d%d\", &n, &m);\n\tif (n > m) std::swap(n, m);\n\tinv[1] = 1;\n\tfor (int i = 2; i <= m; ++i)\n\t\tinv[i] = -MOD / i * inv[MOD % i] % MOD;\n\tfor (int i = fac[0] = ifc[0] = 1; i <= m; ++i)\n\t\tfac[i] = fac[i - 1] * i % MOD, ifc[i] = ifc[i - 1] * inv[i] % MOD;\n\tfor (int i = 0; i <= n; ++i)\n\t\tans += (i & 1 ? -1 : 1) * binom(n, i) * binom(m, i) % MOD * fac[i] % MOD\n\t\t\t* pow(m + 1, n - i) % MOD * pow(n + 1, m - i) % MOD;\n\tans = (ans % MOD + MOD) % MOD;\n\tprintf(\"%lld\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 5e5;\nconst int P = 998244353;\nllong fact[N+3],finv[N+3];\nint n,m;\n\nllong quickpow(llong x,llong y)\n{\n\tllong cur = x,ret = 1ll;\n\tfor(int i=0; y; i++)\n\t{\n\t\tif(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}\n\t\tcur = cur*cur%P;\n\t}\n\treturn ret;\n}\nllong comb(llong x,llong y) {return x<0||y<0||x<y?0ll:fact[x]*finv[y]%P*finv[x-y]%P;}\n\nint main()\n{\n\tfact[0] = 1ll; for(int i=1; i<=N; i++) fact[i] = fact[i-1]*i%P;\n\tfinv[N] = quickpow(fact[N],P-2); for(int i=N-1; i>=0; i--) finv[i] = finv[i+1]*(i+1ll)%P;\n\tscanf(\"%d%d\",&n,&m); int lim = min(n,m); llong pwn = quickpow(n+1,m-lim),pwm = quickpow(m+1,n-lim); llong ans = 0ll;\n\tfor(int i=lim; i>=0; i--)\n\t{\n\t\tllong cur = comb(m,i)*comb(n,i)%P*fact[i]%P*pwn%P*pwm%P;\n\t\tif(i&1) {ans = (ans-cur+P)%P;} else {ans = (ans+cur)%P;}\n\t\tpwn = pwn*(n+1ll)%P,pwm = pwm*(m+1ll)%P;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Copyright@3_soon,From Hangzhou No.2 High School Baimahu\n//Problem:\n//Result:\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define re register\n#define LL long long\n#define DB double\n#define il inline\n#define For(x,a,b) for(re int x=a;x<=b;x++)\n#define For2(x,a,b) for(re int x=a;x>=b;x--)\n#define LFor(x,a,b) for(re LL x=a;x<=b;x++)\n#define LFor2(x,a,b) for(re LL x=a;x>=b;x--)\n#define Abs(x) ((x>0)? x:-x)\n#define mod (LL)998244353\nint gi()\n{\n    int res=0,fh=1;char ch=getchar();\n    while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();\n    if(ch=='-') fh=-1,ch=getchar();\n    while(ch>='0'&&ch<='9')res=res*10+ch-'0',ch=getchar();\n    return fh*res;\n}\nLL gl()\n{\n    LL res=0,fh=1;char ch=getchar();\n    while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();\n    if(ch=='-') fh=-1,ch=getchar();\n    while(ch>='0'&&ch<='9')res=res*10+ch-'0',ch=getchar();\n    return fh*res;\n}\nLL n,m;\nLL fac[1000005],inv[1000005];\nil LL C(LL a,LL b){return fac[a]*inv[b]%mod*inv[a-b]%mod;}\nil LL ksm(LL b,LL k){LL sum=1;while(k){if(k&1) sum=sum*b%mod;k>>=1;b=b*b%mod;}return sum%mod;}\nLL ans;\n\nint main()\n{\n\tn=gl(),m=gl();\n\tif(n>m) swap(n,m);\n\tfac[0]=1;\n\tFor(i,1,m)  fac[i]=1ll*i*fac[i-1]%mod;\n    inv[m]=ksm(fac[m],mod-2);\n    For2(i,m-1,0) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tans=0;\n\tFor(i,0,n) ans=(ans+(i&1? -1:1)*(C(n,i)*C(m,i)%mod*fac[i]%mod*ksm(n+1,m-i)%mod*ksm(m+1,n-i)%mod)+mod)%mod;\n\tprintf(\"%lld\\n\",(ans)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst ll MOD = 998244353;\nconst int MX = 500010;\n\ninline void add(ll &x, ll y) {\n\tx += y;\n\tif (x >= MOD) x -= MOD;\n}\n\nll inv[MX], fact[MX], ifact[MX];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i = 2; i < MX; ++i) {\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = ifact[0] = 1;\n    for (int i = 1; i < MX; ++i) {\n        fact[i] = fact[i-1] * i % MOD;\n        ifact[i] = ifact[i-1] * inv[i] % MOD;\n    }\n}\n\nll comb(int n, int r) {\n    if (n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\nint main() {\n\tinit();\n\n\tint N, M; cin >> N >> M;\n\n\tvector<ll> pn(M + 1), pm(N + 1);\n\tpn[0] = pm[0] = 1;\n\n\tfor (int i = 1; i <= M; ++i)\n\t\tpn[i] = pn[i-1] * (N + 1) % MOD;\n\tfor (int i = 1; i <= N; ++i)\n\t\tpm[i] = pm[i-1] * (M + 1) % MOD;\n\n\tll ans = 0;\n\tfor (int i = 0; i <= N && i <= M; ++i) {\n\t\tll val = comb(N, i) * comb(M, i) % MOD * fact[i] % MOD * pn[M - i] % MOD * pm[N - i] % MOD;\n\t\tif (i & 1) val = MOD - val;\n\t\tif (val == MOD) val = 0;\n\t\tadd(ans, val);\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int mod = 998244353, N = 5e5;\nint n, m, ans, fac[N + 3], inv[N + 3];\n\nint qpow(int a, int b){\n    int ret = 1;\n    while(b){\n        if(b & 1) ret = (ll)ret * a % mod;\n        a = (ll)a * a % mod; b >>= 1;\n    }\n    assert(ret != 0);\n    return ret;\n}\nvoid init(){\n    fac[0] = 1;\n    for(int i = 1; i <= N; i++) fac[i] = (ll)fac[i - 1] * i % mod;\n    inv[N] = qpow(fac[N], mod - 2);\n    for(int i = N - 1; i; i--) inv[i] = (ll)inv[i + 1] * (i + 1) % mod;\n}\nvoid upd(int &x, int add){\n    x += add;\n    if(x >= mod) x -= mod;\n}\nint C(int a, int b){\n    if(a == b || b == 0) return 1;\n    return (ll)fac[a] * inv[b] % mod * inv[a - b] % mod;\n}\n\nint main(){\n    scanf(\"%d %d\", &n, &m); init();\n    for(int i = 0, k = 1; i <= min(n, m); i++, k = -k){\n        upd(ans, ((ll)k * C(n, i) % mod * C(m, i) % mod * fac[i] % mod * qpow(m + 1, n - i) % mod * qpow(n + 1, m - i) % mod + mod) % mod);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc()) \n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int MOD = 998244353;\ninline void Add(int& x,int y) {\n  x = x + y >= MOD ? x + y - MOD : x + y;\n}\ninline void Sub(int& x,int y) {\n  x = x - y < 0 ? x - y + MOD : x - y;\n}\nint power(int a,int b) {\n  int ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\n\nconst int N = 500010;\nint jc[N], ijc[N], n, m;\nvoid prework(int sz) {\n  jc[0] = 1;\n  rep (i, 1, sz) jc[i] = 1ll * jc[i-1] * i % MOD;\n  ijc[sz] = power(jc[sz], MOD - 2);\n  rrp (i, sz-1, 0) ijc[i] = 1ll * ijc[i+1] * (i+1) % MOD;\n}\nint comb(int a,int b) {\n  if (a < b || b < 0) return 0;\n  return 1ll * jc[a] * ijc[b] % MOD * ijc[a-b] % MOD;\n}\nint main() {\n  read(n), read(m);\n  prework(max(n, m));\n  int ans = 0;\n  rep (k, 0, min(n, m)) {\n    int tmp = 1ll * comb(n, k) * comb(m, k) % MOD * jc[k] % MOD;\n    tmp = 1ll * tmp * power(n+1, m - k) % MOD;\n    tmp = 1ll * tmp * power(m+1, n - k) % MOD;\n    if (k&1) Sub(ans, tmp);\n    else Add(ans, tmp);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nint n,m;\nconst int mod=998244353;\nint powM[500050],powN[500050],fact[500050],ifact[500050];\n\ninline int pow(int a,int b){\n\tint ret=1;\n\tfor (;b;b>>=1,a=static_cast<long long>(a)*a%mod)\n\t\tif (b&1) ret=static_cast<long long>(ret)*a%mod;\n\treturn ret;\n}\n\nint ans;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tpowM[0]=1,powN[0]=1;\n\tfor (int i=1;i<=n;i++) powM[i]=powM[i-1]*(m+1LL)%mod;\n\tfor (int i=1;i<=m;i++) powN[i]=powN[i-1]*(n+1LL)%mod;\n\tfact[0]=1;\n\tfor (int i=1;i<=n||i<=m;i++) fact[i]=static_cast<long long>(fact[i-1])*i%mod;\n\tifact[std::max(n,m)]=pow(fact[std::max(n,m)],mod-2);\n\tfor (int i=std::max(n,m);i;i--) ifact[i-1]=static_cast<long long>(ifact[i])*i%mod;\n\tfor (int i=0;i<=n&&i<=m;i++){\n\t\tif (i&1) ans=(ans-static_cast<long long>(ifact[i])*ifact[n-i]%mod*ifact[m-i]%mod*powM[n-i]%mod*powN[m-i]%mod+mod)%mod;\n\t\telse ans=(ans+static_cast<long long>(ifact[i])*ifact[n-i]%mod*ifact[m-i]%mod*powM[n-i]%mod*powN[m-i]%mod+mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",static_cast<long long>(ans)*fact[n]%mod*fact[m]%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int Max_NM(500050);\nconst int MOD(998244353);\ntypedef long long int LL;\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\nvoid exgcd(int a, int b, int &x, int &y)\n{\n\tif (b == 0)\n\t\tx = 1, y = 0;\n\telse\n\t\texgcd(b, a % b, y, x), y -= x * (a / b);\n}\n\ninline int inverse(int a)\n{\n\tint invx, invy;\n\texgcd(a, MOD, invx, invy);\n\treturn (invx % MOD + MOD) % MOD;\n}\n\nint N, M, Fac[Max_NM], Inv[Max_NM], powerM1[Max_NM], powerN1[Max_NM]; \n\ninline int Com(int n, int m)\n{\n\treturn Mult(Fac[n], Mult(Inv[m], Inv[n - m]));\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &M);\n\tFac[0] = 1;\n\tfor (int i = 1;i <= max(N, M);++i)\n\t\tFac[i] = Mult(Fac[i - 1], i);\n\tInv[max(N, M)] = inverse(Fac[max(N, M)]);\n\tfor (int i = max(N, M) - 1;i >= 0;--i)\n\t\tInv[i] = Mult(Inv[i + 1], i + 1);\n\tpowerM1[0] = 1;\n\tfor (int i = 1;i <= N;++i)\n\t\tpowerM1[i] = Mult(powerM1[i - 1], M + 1);\n\tpowerN1[0] = 1;\n\tfor (int i = 1;i <= M;++i)\n\t\tpowerN1[i] = Mult(powerN1[i - 1], N + 1);\n\tint Ans = 0;\n\tfor (int R = 0, val;R <= min(N, M);++R)\n\t{\n\t\tval = Mult(Mult(Mult(Com(N, R), Com(M, R)), Fac[R]), Mult(powerM1[N - R], powerN1[M - R]));\n\t\tif (R & 1)\n\t\t\tAns = Sub(Ans, val);\n\t\telse\n\t\t\tAns = Add(Ans, val);\n\t}\n\tprintf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll; \ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n \ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n \n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n \n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n \n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n \n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n \n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n \n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n \n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n \n private:\n  Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n \ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n \ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n \ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n \ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n \ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n \ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n \ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n \n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n \nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n \nvector<Mint> fact;\nvector<Mint> inv_fact;\n \ntemplate <typename T>\nclass NTT {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  static Type md;\n  static Modular<T> root;\n  static int base;\n  static int max_base;\n  static vector<Modular<T>> roots;\n  static vector<int> rev;\n \n  static void clear() {\n    root = 0;\n    base = 0;\n    max_base = 0;\n    roots.clear();\n    rev.clear();\n  }\n \n  static void init() {\n    md = T::value;\n    assert(md >= 3 && md % 2 == 1);\n    auto tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (md - 1) >> 1) == 1) {\n      root++;\n    }\n    assert(power(root, md - 1) == 1);\n    root = power(root, (md - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n \n  static void ensure_base(int nbase) {\n    if (md != T::value) {\n      clear();\n    }\n    if (roots.empty()) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = roots[i] * z;\n      }\n      base++;\n    }\n  }\n \n  static void fft(vector<Modular<T>> &a) {\n    int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          Modular<T> x = a[i + j];\n          Modular<T> y = a[i + j + k] * roots[j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n \n  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n    if (a.empty() || b.empty()) {\n      return {};\n    }\n    int eq = (a == b);\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq) b = a; else fft(b);\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] *= b[i] * inv_sz;\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n};\n \ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\n \ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<Modular<T>> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x.resize(b.size() << 1);\n    b.resize(b.size() << 1);\n    vector<Modular<T>> c = b;\n    NTT<T>::fft(c);\n    NTT<T>::fft(x);\n    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n    fill(x.begin() + (x.size() >> 1), x.end(), 0);\n    NTT<T>::fft(x);\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    for (int i = 0; i < ((int) x.size() >> 1); i++) {\n      b[i + ((int) x.size() >> 1)] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  if (n == 1) {\n    return {1 / a[0]};\n  }\n  int m = (n + 1) >> 1;\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n  int need = n << 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    ++nbase;\n  }\n  NTT<T>::ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  NTT<T>::fft(a);\n  NTT<T>::fft(b);\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n  for (int i = 0; i < size; ++i) {\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  NTT<T>::fft(a);\n  a.resize(n);\n  return a;\n}\n \ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (min(a.size(), b.size()) < 150) {\n    vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        c[i + j] += a[i] * b[j];\n      }\n    }\n    return c;\n  }\n  return NTT<T>::multiply(a, b);\n}\n \ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  return a = a * b;\n}\n \ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n \ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n \ntemplate <typename T>\nvector<T> operator-(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] = -c[i];\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  vector<T> c(a.size() + b.size() - 1, 0);\n  for (int i = 0; i < (int) a.size(); i++) {\n    for (int j = 0; j < (int) b.size(); j++) {\n      c[i + j] += a[i] * b[j];\n    }\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  return a = a * b;\n}\n \ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> x = b * b * a_cut;\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n \ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n \ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T>{1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n \ntemplate <typename T>\nvector<T> derivative(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] *= i;   \t\n  }\n  if (!c.empty()) {\n    c.erase(c.begin());\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> primitive(const vector<T>& a) {\n  vector<T> c = a;\n  c.insert(c.begin(), 0);\n  for (int i = 1; i < (int) c.size(); i++) {\n    c[i] /= i;\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> logarithm(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 1);\n  vector<T> u = primitive(derivative(a) * inverse(a));\n  u.resize(a.size());\n  return u;\n}\n \ntemplate <typename T>\nvector<T> exponent(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 0);\n  int n = (int) a.size();\n  vector<T> b = {1};\n  while ((int) b.size() < n) {\n    vector<T> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x[0] += 1;\n    vector<T> old_b = b;\n    b.resize(b.size() << 1);\n    x -= logarithm(b);\n    x *= old_b;\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<T> multiply(const vector<vector<T>>& a) {\n  if (a.empty()) {\n    return {0};\n  }\n  function<vector<T>(int, int)> mult = [&](int l, int r) {\n    if (l == r) {\n      return a[l];\n    }\n    int y = (l + r) >> 1;\n    return mult(l, y) * mult(y + 1, r);\n  };\n  return mult(0, (int) a.size() - 1);\n}\n\nstruct Combi\n{\n\tvector<int> fact;\n\tvector<int> ifact;\n\tvector<int> inv;\n\tvector<int> pow2;\n\tconst int MOD = 998244353;\n\tint add(int a, int b)\n\t{\n\t\ta+=b;\n\t\twhile(a>=MOD) a-=MOD;\n\t\treturn a;\n\t}\n\tint mult(int a, int b)\n\t{\n\t\treturn (a*1LL*b)%MOD;\n\t}\n\tint modpow(int a, int b)\n\t{\n\t\tint r=1;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1) r=mult(r,a);\n\t\t\ta=mult(a,a);\n\t\t\tb>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tint choose(int a, int b)\n\t{\n\t\tif(a<b) return 0;\n\t\tif(b==0) return 1;\n\t\tif(a==b) return 1;\n\t\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n\t}\n\tint inverse(int a)\n\t{\n\t\treturn modpow(a,MOD-2);\n\t}\n\tvoid init(int _n)\n\t{\n\t\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\t\tfact.resize(_n+1);\n\t\tifact.resize(_n+1);\n\t\tinv.resize(_n+1);\n\t\tpow2.resize(_n+1);\n\t\tpow2[0]=1;\n\t\tifact[0]=1;\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\t\tfact[i]=mult(fact[i-1],i);\n\t\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t\t}\n\t\tifact[_n] = inverse(fact[_n]);\n\t\tfor(int i=_n-1;i>=1;i--)\n\t\t{\n\t\t    ifact[i] = mult(ifact[i + 1], i + 1);\n\t\t}\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t    inv[i] = mult(fact[i-1],ifact[i]);\n\t\t}\n\t}\n};\nCombi combi;\nconst int MOD = 998244353;\n\nint mod_pow(int a, int n, int mod) { int ret = 1; while (n) { if (n & 1) ret = ret *1LL* a % mod; a = a *1LL* a % mod; n >>= 1; } return ret; }\nint inv(int n){return mod_pow(n,MOD-2,MOD);}\nconst int LG = 22;\nconst int root_pw = (1<<LG);\nint iprt,prt;\n \nvoid fft (vector<int> & a, bool invert) \n{\n\tint n = (int) a.size();\n \n\tfor (int i=1, j=0; i<n; ++i) {\n\t\tint bit = n >> 1;\n\t\tfor (; j>=bit; bit>>=1)\n\t\t\tj -= bit;\n\t\tj += bit;\n\t\tif (i < j)\n\t\t\tswap (a[i], a[j]);\n\t}\n \n\tfor (int len=2; len<=n; len<<=1) {\n\t\tint wlen = invert ? iprt : prt;\n\t\tfor (int i=len; i<root_pw; i<<=1)\n\t\t\twlen = int((wlen*1LL*wlen)%MOD);\n\t\tfor (int i=0; i<n; i+=len) {\n\t\t\tint w = 1;\n\t\t\tfor (int j=0; j<len/2; ++j) {\n\t\t\t\tint u = a[i+j]; int v = int((a[i+j+len/2]*1LL*w)%MOD);\n\t\t\t\ta[i+j] = u+v < MOD ? u+v : u+v-MOD;\n\t\t\t\ta[i+j+len/2] = u-v >= 0 ? u-v : u-v+MOD;\n\t\t\t\tw = int (w * 1LL * wlen % MOD);\n\t\t\t}\n\t\t}\n\t}\n\tif (invert) {\n\t\tll nrev = inv(n);\n\t\tfor (int i=0; i<n; ++i)\n\t\t\ta[i] = int((a[i]*1LL*nrev)%MOD);\n\t}\n}\n \nvoid multiply(vector<int>& a, vector<int>& b, vector<int>& res)\n{\n\tvector<int> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n\tint n = 1;\n\twhile(n < max(a.size(), b.size())) n <<= 1;\n\tfa.resize(n); fb.resize(n);\n\tfft(fa, 0); fft(fb, 0);\n\tres.resize(n);\n\tfor(int i = 0; i < n; i++) \n\t{\n\t\tres[i] = int((fa[i]*1LL*fb[i])%MOD);\n\t}\n\tfft(res, 1);\n}\n \nvector<int> inverse(vector<int> &a, int deg) //returns a 2^{deg} polynomial\n{\n\tvector<int> h[2];\n\th[0].pb(mod_pow(a[0],MOD-2,MOD));\n\tint cur=0; int pre=1;\n\tfor(int i=0;i<deg;i++) //after this it'll be of size 2^{deg}\n\t{\n\t\tcur^=1; pre^=1;\n\t\th[cur].resize((1<<(i+1)));\n\t\th[pre].resize((1<<(i+1)));\n\t\tmultiply(h[pre],h[pre],h[cur]);\n\t\tvector<int> pf;\n\t\tpf.assign((1<<(i+1)),0);\n\t\tfor(int j=0;j<min(pf.size(),a.size());j++) pf[j]=a[j];\n\t\th[cur].resize((1<<(i+2))); pf.resize((1<<(i+2)));\n\t\tmultiply(pf,h[cur],h[cur]);\n\t\th[cur].resize((1<<(i+1)));\n\t\tfor(int j=0;j<(1<<i);j++)\n\t\t{\n\t\t\th[cur][j] = combi.add(h[pre][j], combi.add(h[pre][j], MOD - h[cur][j]));\n\t\t}\n\t\tfor(int j=(1<<i);j<(1<<(i+1));j++)\n\t\t{\n\t\t\tif(h[cur][j]!=0) h[cur][j] = MOD - h[cur][j];\n\t\t}\n\t}\n\treturn h[cur];\n}\n \nvector<int> ln(vector<int> &a, int deg)\n{\n\twhile(a.size()<(1<<deg)) a.pb(0);\n\tvector<int> num,denom;\n\tdenom = inverse(a, deg);\n\tnum.resize((1<<deg));\n\tfor(int i = 0; i < (1<<deg); i++)\n\t{\n\t\tif(i+1<a.size())\n\t\t{\n\t\t\tnum[i] = combi.mult(a[i+1], i+1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnum[i] = 0;\n\t\t}\n\t}\n\tnum.resize((1<<(deg+1))); denom.resize((1<<(deg+1)));\n\tvector<int> res;\n\tmultiply(num,denom,res);\n\tres.resize(1<<deg);\n\tvector<int> ans(1<<deg,0);\n\tfor(int i=1;i<(1<<deg);i++)\n\t{\n\t\tans[i]=combi.mult(res[i-1],inv(i));\n\t}\n\treturn ans;\n}\n \nvector<int> exp(vector<int> &a, int deg)\n{\t\n\tvector<int> h[2];\n\th[0].pb(1);\n\tint cur=0; int pre=1;\n\tfor(int i=0;i<deg;i++) //after this it'll be of size 2^{deg}\n\t{\n\t\tcur^=1; pre^=1;\n\t\tvector<int> pf;\n\t\tpf.assign((1<<(i+1)),0);\n\t\tfor(int j=0;j<min(pf.size(),a.size());j++) pf[j]=a[j];\n\t\tpf[0]=combi.add(pf[0],1);\n\t\tvector<int> LN = ln(h[pre],i+1);\n\t\tfor(int j=0;j<(1<<(i+1));j++)\n\t\t{\n\t\t\tpf[j] = combi.add(pf[j], MOD - LN[j]);\n\t\t}\n\t\th[pre].resize((1<<(i+2))); pf.resize((1<<(i+2)));\n\t\tmultiply(pf,h[pre],h[cur]);\n\t\th[cur].resize((1<<(i+1)));\n\t}\n\treturn h[cur];\n}\n \nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcombi.init(666666);\n\tint tmpmult = 7*17;\n\ttmpmult = combi.mult(tmpmult, mod_pow(2, 23 - LG, MOD)); \n\tprt = mod_pow(3, tmpmult, MOD);\n\tiprt = inv(prt);\n\tint n,m; cin>>n>>m;\n\tvector<Mint> a(m+1);\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\ta[i] = combi.mult(m+1-i,combi.ifact[i]);\n\t}\n\t/*\n\tfor(int i=0;i<a.size();i++)\n\t{\n\t\tcerr<<a[i]<<' ';\n\t}\n\tcerr<<'\\n';\n\t*/\n\tvector<Mint> T; int deg=0; bool stp=0;\n\tfor(int i=0;i<a.size();i++)\n\t{\n\t\tif(!stp&&a[i]==0) {deg=i+1; continue;}\n\t\tT.pb(a[i]); stp=1;\n\t}\n\tMint coeff = T[0]; //should be nonempty\n\tMint icoeff = inv(int(T[0]));\n\tT = T*vector<Mint>{icoeff};\n\tvector<Mint> tmpNW = exponent(logarithm(T)*vector<Mint>{n});\n\tint tt = combi.modpow(int(coeff),n);\n\tfor(int i=0;i<tmpNW.size();i++) tmpNW[i]=combi.mult(int(tmpNW[i]),tt);\n\tvector<Mint> NW;\n\tfor(int i=0;i<min(ll(m+1),ll(n)*ll(deg));i++)\n\t{\n\t\tNW.pb(0);\n\t}\n\tfor(int i=0;i<tmpNW.size();i++)\n\t{\n\t\tif(NW.size()<=m+1) NW.pb(tmpNW[i]);\n\t\telse break;\n\t}\n\t/*\n\tfor(int i=0;i<NW.size();i++) cerr<<NW[i]<<' ';\n\tcerr<<'\\n';\n\t*/\n\tint ans=0;\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\tans=combi.add(ans,combi.mult(int(NW[i]),combi.ifact[m-i]));\n\t}\n\tans=combi.mult(ans,combi.fact[m]);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int Mod = 998244353;\nconst int Maxn = 1e6;\n\nint QuickPow(int a, int k) {\n\tint ret = 1;\n\twhile(k) {\n\t\tif(k & 1) ret = 1LL * ret * a % Mod;\n\t\ta = 1LL * a * a % Mod;\n\t\tk >>= 1;\n\t}\n\treturn ret;\n}\nint fac[Maxn + 5], inv_fac[Maxn + 5];\nvoid Init() {\n\tfac[0] = inv_fac[0] = 1;\n\tfor(int i = 1; i <= Maxn; i++)\n\t\tfac[i] = 1LL * fac[i - 1] * i % Mod;\n\tinv_fac[Maxn] = QuickPow(fac[Maxn], Mod - 2);\n\tfor(int i = Maxn - 1; i >= 1; i--)\n\t\tinv_fac[i] = 1LL * inv_fac[i + 1] * (i + 1) % Mod;\n}\nint C(int n, int m) {\n\treturn 1LL * fac[n] * inv_fac[m] % Mod * inv_fac[n - m] % Mod;\n}\ninline void add(int &n, int m) {\n\tn += m;\n\tif(n >= Mod) n -= Mod;\n}\ninline void del(int &n, int m) {\n\tn -= m;\n\tif(n < 0) n += Mod;\n}\n\nint powN[Maxn + 5], powM[Maxn + 5];\nint main() {\n#ifdef LOACL\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n\tint N, M;\n\tscanf(\"%d %d\", &N, &M);\n\tInit();\n\tif(N > M) swap(N, M);\n\tpowN[0] = powM[0] = 1;\n\tfor(int i = 1; i <= M; i++)\n\t\tpowN[i] = 1LL * powN[i - 1] * (N + 1) % Mod;\n\tfor(int i = 1; i <= N; i++)\n\t\tpowM[i] = 1LL * powM[i - 1] * (M + 1) % Mod;\n\tint ans = 0;\n\tfor(int i = 0; i <= N; i++) {\n\t\tint tmp = 1LL * C(N, i) * C(M, i) % Mod * fac[i] % Mod * powN[M - i] % Mod * powM[N - i] % Mod;\n\t\tif(i & 1) del(ans, tmp);\n\t\telse add(ans, tmp);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<ans*fact[n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <string>\n#include <cmath>\n#include <cassert>\n#define SIZE 1000005\n#define MOD 998244353\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll inv[SIZE],fac[SIZE],finv[SIZE];\nvoid make()\n{\n\tfac[0]=fac[1]=1;\n\tfinv[0]=finv[1]=1;\n\tinv[1]=1;\n\tfor(int i=2;i<SIZE;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n}\nll C(int a,int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nll mpow(ll m,ll t)\n{\n\tif(t==0) return 1;\n\tll ret=mpow(m,t/2);\n\tret=ret*ret%MOD;\n\tif(t%2==1) ret=ret*m%MOD;\n\treturn ret;\n}\nint main()\n{\n\tmake();\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tll ret=0;\n\tfor(int k=0;k<=min(n,m);k++)\n\t{\n\t\tll sum=mpow(n+1,m-k)*mpow(m+1,n-k)%MOD;\n\t\tsum*=C(m,k)*C(n,k)%MOD;\n\t\tsum%=MOD;\n\t\tsum*=fac[k];\n\t\tsum%=MOD;\n\t\tif(k%2==0) ret+=sum;\n\t\telse ret-=sum;\n\t\tret+=MOD;\n\t\tret%=MOD;\n\t\t//printf(\"%lld\\n\",sum);\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long hxtype;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst int N=500005;\nconst ll p=998244353ll;\nll fa[N],ia[N];\ninline ll expo(ll a,int b=998244351){\n\tll c=1ll;\n\twhile(b){\n\t\tif(b&1)c=c*a%p;\n\t\tb>>=1; a=a*a%p;\n\t}\n\treturn c;\n}\nint main(){\n\tint n,m,i;ll ans=0ll,tmp;\n\tscanf(\"%d%d\",&n,&m);\n\tif(n>m)swap(n,m);\n\tfa[0]=1ll;\n\trep(i,1,m)fa[i  ]=fa[i-1]*i%p;\n\tia[m]=expo(fa[m]);\n\tper(i,m,1)ia[i-1]=ia[i  ]*i%p;\n\trep(i,0,n){\n\t\ttmp=ia[i];\n\t\ttmp=tmp*(fa[n]*ia[n-i]%p)%p;\n\t\ttmp=tmp*(fa[m]*ia[m-i]%p)%p;\n\t\ttmp=tmp*(expo(m+1,n-i)*expo(n+1,m-i)%p)%p;\n\t\tif(i&1)ans-=tmp;else ans+=tmp;\n\t}\n\tprintf(\"%lld\",(ans+p*p)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct ModInt{\n\tuint a;\n    ModInt(ll x=0):a((x+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n        if(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=ull(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\nconst int N = 5e5 + 5, mod = 998244353;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nint n, m, ans, fac[N], inv[N];\nint ksm(int x, int y) {\n\tint res = 1;\n\tfor( ; y; x = x * x % mod, y >>= 1) {\n\t\tif(y & 1) res = res * x % mod;\n\t}\n\treturn res;\n}\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n; ++ i) fac[i] = fac[i - 1] * i % mod;\n\tinv[n] = ksm(fac[n], mod - 2);\n\tfor(int i = n - 1; i >= 0; -- i) inv[i] = inv[i + 1] * (i + 1) % mod;\n}\nint C(int n, int m) {return n < m ? 0 : fac[n] * inv[m] % mod * inv[n - m] % mod;}\nsigned main() {\n\tn = read(); m = read();\n\tif(n > m) swap(n, m); init(m);\n\tfor(int k = 0; k <= n; ++ k) {\n\t\tint tmp = C(n, k) * C(m, k) % mod * fac[k] * ksm(m + 1, n - k) % mod * ksm(n + 1, m - k) % mod;\n\t\tif(k & 1) ans = (ans - tmp + mod) % mod;\n\t\telse ans = (ans + tmp) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 1020000,mo=998244353;\nint n,m,res,fac[N],ifac[N];\ninline int power(int a, int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1)res=1LL*res*a%mo;a=1LL*a*a%mo;n>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n){\n\tfac[0]=1;rep(i,1,n)fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n]=power(fac[n],mo-2);per(i,n-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n}\ninline int C(int n, int m){return 1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo;}\nint main() {\n\tread(n);read(m);init(max(n,m));\n\trep(k,0,min(n,m))res=(res+1LL*(k&1?mo-1:1)*C(n,k)%mo*C(m,k)%mo*fac[k]%mo*power(m+1,n-k)%mo*power(n+1,m-k))%mo;\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=600005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nint fac[MAXN],inv[MAXN];\nint upd(int x,int y) { return x+y>=mods?x+y-mods:(x+y<0?x+y+mods:x+y); }\ninline int quick_pow(int x,int y)\n{\n\tint ret=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mods;\n\t\tx=1ll*x*x%mods;\n\t}\n\treturn ret;\n}\nvoid Init(int n)\n{\n\tfac[0]=1;\n\tfor (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mods;\n\tinv[n]=quick_pow(fac[n],mods-2);\n\tfor (int i=n-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mods;\n}\nint C(int x,int y){ return 1ll*fac[x]*inv[y]%mods*inv[x-y]%mods; }\nint main()\n{\n\tint n=read(),m=read();\n\tif (n>m) swap(n,m);\n\tInit(m);\n\tint ans=0;\n\tfor (int i=0;i<=n;i++) ans=upd(ans,1ll*C(n,i)*C(m,i)%mods*fac[i]%mods*quick_pow(m+1,n-i)%mods*quick_pow(n+1,m-i)%mods*((i&1)?-1:1));\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define qwq(x) cout<<\"# \"<<#x<<\" = \"<<x<<endl;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=500005,mod=998244353;\nint fac[N],rev[N],pw1[N],pw2[N];\nint n,m,ans;\n\nint power(int x,int p){\n\tint res=1;\n\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\tif(p&1)res=(ll)res*x%mod;\n\treturn res;\n}\n\nint C(int n,int m){\n\treturn (ll)fac[n]*rev[m]%mod*rev[n-m]%mod;\n}\n\nvoid init(int lim){\n\tfac[0]=pw1[0]=pw2[0]=1;\n\trep(i,1,lim){\n\t\tfac[i]=(ll)fac[i-1]*i%mod;\n\t\tpw1[i]=(ll)pw1[i-1]*(n+1)%mod;\n\t\tpw2[i]=(ll)pw2[i-1]*(m+1)%mod;\n\t}\n\trev[lim]=power(fac[lim],mod-2);\n\tper(i,lim,1)rev[i-1]=(ll)rev[i]*i%mod;\n}\n\nint main(){\n\tread(n),read(m);\n\tinit(max(n,m));\n\trep(i,0,min(n,m)){\n\t\tint now=(ll)C(n,i)*C(m,i)%mod;\n\t\tnow=(ll)now*fac[i]%mod;\n\t\tnow=(ll)now*pw1[m-i]%mod;\n\t\tnow=(ll)now*pw2[n-i]%mod;\n\t\tif(i&1)ans=(ans+mod-now)%mod;\n\t\telse ans=(ans+now)%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 500233, mod = 998244353;\nint n, m, fac[N], inv[N];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  if (n < m) swap(n, m);\n  fac[0] = fac[1] = inv[0] = inv[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    fac[i] = (ll) fac[i - 1] * i % mod;\n    inv[i] = mod - (ll) mod / i * inv[mod % i] % mod;\n  }\n  for (int i = 2; i <= n; i++) {\n    inv[i] = (ll) inv[i] * inv[i - 1] % mod;\n  }\n  int pn = fac[n], pm = fac[m], ans = 0;\n  for (int i = n - m; i; i--) pn = (ll) pn * (m + 1) % mod;\n  for (int i = m; ~i; i--) {\n    int coef = (ll) pn * pm % mod * inv[n - i] % mod * inv[m - i] % mod * inv[i] % mod * (i & 1 ? mod - 1 : 1) % mod;\n    pn = (ll) pn * (m + 1) % mod;\n    pm = (ll) pm * (n + 1) % mod;\n    ans = (ans + coef) % mod;\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\n\nusing namespace std;\n\ntypedef long long li;\ntypedef unsigned long long lu;\nconst li infl = ~0LLU >> 2;\n\ntemplate <class T>\ninline void Min(T &x, T y) {\n  if (y < x) x = y;\n}\ntemplate <class T>\ninline void Max(T &x, T y) {\n  if (y > x) x = y;\n}\n\nconst int mod = 998244353;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (int)((li)x * y % mod); }\ninline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\nint Inv(int x) {\n  return Pow(x, mod - 2);\n}\n\n// ----------------------------------------\n\nconst int maxn = 5e5;\nint n, m;\nint fact[maxn + 1], ifact[maxn + 1];\nint down[maxn + 1];\n\nvoid Init(void) {\n  fact[0] = 1;\n  for (int i = 1; i <= m; ++i) {\n    fact[i] = Mul(fact[i - 1], i);\n  }\n  ifact[m] = Pow(fact[m], mod - 2);\n  for (int i = m; i >= 1; --i) {\n    ifact[i - 1] = Mul(ifact[i], i);\n  }\n  down[0] = 1;\n  for (int i = 1; i <= m; ++i) {\n    down[i] = Mul(down[i - 1], n - i + 1);\n  }\n}\n\nint Binom(int n, int m) {\n  return Mul(fact[n], ifact[m], ifact[n - m]);\n}\n\nint Sgn(int k) {\n  return k & 1 ? mod - 1 : 1;\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  if (n < m) swap(n, m);\n  Init();\n  int ans = 0;\n  for (int k = 0; k <= m; ++k) {\n    Add(ans, Mul(Mul(Binom(m, k), Sgn(k), down[k]),\n                 Mul(Pow(n + 1, m - k), Pow(m + 1, n - k))));\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//2019.7.22 by ljz\n//email 573902690@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 1e18+1e9\n#define eps 1e-10\n#define RG register\n#define db double\n#define lb long db\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define pb push_back\n#define gc getchar\n#define Pi 2.0*acos(-1.0)\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void write(RG __int128 x){\n//    if(x>10)write(x/10);\n//    putchar(x%10+'0');\n//}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int kcz=998244353;\nconst int N=5e5+10;\nnamespace MAIN{\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    inline int mul(const res &x,const res &y){\n        return int(1LL*x*y%kcz);\n    }\n    int n,m;\n    int fac[N],inv[N];\n    inline int C(const res &x,const res &y){\n        return mul(fac[x],mul(inv[y],inv[x-y]));\n    }\n    inline int A(const res &x,const res &y){\n        return mul(fac[x],inv[x-y]);\n    }\n    int pwn[N],pwm[N];\n    int ans;\n    inline void MAIN(){\n        n=read(),m=read(),fac[0]=fac[1]=inv[0]=inv[1]=pwn[0]=pwm[0]=1;\n        if(n>m)swap(n,m);\n        for(res i=1;i<=m;i++)pwn[i]=mul(pwn[i-1],n+1),pwm[i]=mul(pwm[i-1],m+1);\n        for(res i=2;i<=m;i++)fac[i]=mul(fac[i-1],i),inv[i]=mul(inv[kcz%i],kcz-kcz/i);\n        for(res i=2;i<=m;i++)inv[i]=mul(inv[i-1],inv[i]);\n        for(res i=0;i<=n;i++)add(ans,i&1?kcz-mul(mul(C(n,i),A(m,i)),mul(pwn[m-i],pwm[n-i])):mul(mul(C(n,i),A(m,i)),mul(pwn[m-i],pwm[n-i])));\n        printf(\"%d\\n\",ans);\n    }\n}\nint main(){\n    MAIN::MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){return s(a+x.a);}\n\tModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,const ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\n\n\ntemplate<class Mint,int32_t lg>\nstruct ModIntTable{\n\tint N;\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():N(1<<lg),facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n)const{return facts[n];}\n\tinline Mint finv(int n)const{return finvs[n];}\n\tinline Mint inv(int n)const{return invs[n];}\n\tinline Mint binom(int n,int k)const{return facts[n]*finvs[k]*finvs[n-k];}\n};\nModIntTable<mint,19>mtable;\n\n\n\nconst uint32_t mod=998244353;\nconst mint prim_root=3;\n\n\ntemplate<int lg>\nstruct NTT{\n\tvector<mint>roots,iroots;\n\tNTT():roots(1<<lg+1),iroots(1<<lg+1){\n\t\trep(w,lg+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n\tvoid broken_fmt(vector<mint>&f){\n\t\tconst int n=f.size();\n\t\tfor(int b=n/2;b>=1;b/=2){\n\t\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\t\trep(j,b){\n\t\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid broken_ifmt(vector<mint>&f){\n\t\tconst int n=f.size();\n\t\tfor(int b=1;b<=n/2;b*=2){\n\t\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\t\trep(j,b){\n\t\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\t\tf[i+j+b]=tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmint in=mint(n).inv();\n\t\trep(i,n)\n\t\t\tf[i]*=in;\n\t}\n\n\tvoid inplace_fmt(vector<mint>&f,const bool i=false){\n\t\tif(!i)broken_fmt(f);\n\t\telse broken_ifmt(f);\n\t}\n\n\n\n\tvector<mint> multiply(vector<mint> x,vector<mint> y,bool same=false){\n\t\tint n=x.size()+y.size()-1;\n\t\tint s=1;\n\t\twhile(s<n)s*=2;\n\t\tx.resize(s);inplace_fmt(x,false);\n\t\tif(!same){\n\t\t\ty.resize(s);inplace_fmt(y,false);\n\t\t}else\n\t\t\ty=x;\n\t\trep(i,s)\n\t\t\tx[i]*=y[i];\n\t\tinplace_fmt(x,true);x.resize(n);\n\t\treturn x;\n\t}\n};\nNTT<20>ntt;\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tmint in=mint(n).inv();\n\trep(i,n)\n\t\tf[i]*=in;\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i=false){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\n\n\nvector<mint> multiply(vector<mint> x,vector<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n \ntemplate<class Mint>\nstruct NTTFriendlyPoly{\n\tvoid ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(3).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tvector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n\n\tvector<Mint>v;\n\ttemplate<class...Args>\n\tNTTFriendlyPoly(Args...args):v(args...){}\n \n\tNTTFriendlyPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n \n\tint size()const{return v.size();}\n \n\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n \n\tNTTFriendlyPoly operator+(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator-(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator*(const NTTFriendlyPoly& x){\n\t\treturn multiply(v,x.v);\n\t}\n\tNTTFriendlyPoly operator*(const Mint& x){\n\t\tint n=size();\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator/(const Mint& x){\n\t\treturn (*this)*x.inv();\n\t}\n \n\tNTTFriendlyPoly& operator+=(const NTTFriendlyPoly& x){return *this=(*this)+x;}\n\tNTTFriendlyPoly& operator-=(const NTTFriendlyPoly& x){return *this=(*this)-x;}\n\tNTTFriendlyPoly& operator*=(const NTTFriendlyPoly& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n\tNTTFriendlyPoly operator-(){return NTTFriendlyPoly()-*this;}\n \n    NTTFriendlyPoly pre(int n){\n        NTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n&&i<size();i++)res[i]=v[i];\n\t\treturn res;\n    }\n    NTTFriendlyPoly rev(){\n        vector<Mint>res=v;\n\t\twhile(res.size()&&res.back()==0)res.pop_back();\n        reverse(res.begin(),res.end());\n        return res;\n    }\n    NTTFriendlyPoly diff(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=1;i<size()&&i<=n;i++)res[i-1]=v[i]*i;\n        return res;\n    }\n    NTTFriendlyPoly inte(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=0;i<size()&&i+1<n;i++)res[i+1]=v[i]*mtable.inv(i+1);\n        return res;\n    }\n\n    NTTFriendlyPoly inv(int n){\n        vector<mint>res{coef(0).inv()};\n\n        for(int d=1;d<n;d<<=1){\n            vector<Mint>f(2*d),g(2*d);\n            for(int j=0;j<2*d;j++)f[j]=coef(j);\n            for(int j=0;j<d;j++)g[j]=res[j];\n            \n            inplace_fmt(f);inplace_fmt(g);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++){\n                f[j]=0;\n                f[j+d]=-f[j+d];\n            }\n            inplace_fmt(f);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++)f[j]=res[j];\n            res=f;\n        }\n        return NTTFriendlyPoly(res).pre(n);\n    }\n    \n    \n    NTTFriendlyPoly inv2(int n){\n        NTTFriendlyPoly res{coef(0).inv()};\n        for(int i=1;i<n;i*=2){\n            res=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n        }\n        return res.pre(n);\n    }\n    \n    \n\n\tNTTFriendlyPoly exp(int n){\n\t\tNTTFriendlyPoly f0{1},g0{1};\n\t\tvector<Mint>F0{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tvector<Mint>G0=g0.v;\n\t\t\tinplace_fmt(G0);\n\t\t\tvector<Mint>Delta(d);\n\t\t\tfor(int j=0;j<d;j++)Delta[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tDelta[0]-=1;\n\t\t\tNTTFriendlyPoly delta(2*d);\n\t\t\tfor(int j=0;j<d;j++)delta[d+j]=Delta[j];\t\t\n\t\t\t\n\t\t\tNTTFriendlyPoly epsilon(2*d);\n\t\t\t\n\t\t\n\t\t\t\n\t\t\tvector<Mint>DF0=f0.diff(d-1).v;DF0.push_back(0);\n\t\t\tinplace_fmt(DF0);\n\t\t\tfor(int j=0;j<d;j++)DF0[j]*=G0[j];\n\t\t\tinplace_fmt(DF0,true);\n\t\t\tfor(int j=0;j<d-1;j++){\n\t\t\t\tepsilon[j]+=coef(j+1)*(j+1);\n\t\t\t\tepsilon[j+d]+=DF0[j]-coef(j+1)*(j+1);\n\t\t\t}\n\t\t\tepsilon[d-1]+=DF0[d-1];\n\n\n\t\t\tDelta=delta.v;\n\t\t\tinplace_fmt(Delta);\n\t\t\tvector<Mint>DH0=diff(d-1).v;DH0.resize(2*d);\n\t\t\tinplace_fmt(DH0);\n\t\t\tfor(int j=0;j<2*d;j++)Delta[j]*=DH0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tfor(int j=0;j<d;j++)epsilon[j+d]-=Delta[j+d];\n\t\t\n\n\t\t\tepsilon=epsilon.inte(2*d)-pre(2*d);\n\t\t\t\n\t\t\tvector<Mint>Epsilon=epsilon.v;\n\t\t\tinplace_fmt(Epsilon);\n\t\t\trep(j,d)DH0[j]=f0[j],DH0[j+d]=0;\n\t\t\tinplace_fmt(DH0);\n\t\t\trep(j,2*d)Epsilon[j]*=DH0[j];\n\t\t\tinplace_fmt(Epsilon,true);\n\t\t\tf0.v.resize(2*d);\n\t\t\trep(j,d)f0[j+d]-=Epsilon[j+d];\n\t\t\t//f0=(f0-epsilon*f0).pre(2*d);\n\t\t\t\n\t\t\tG0.resize(2*d);\n\t\t\trep(j,d)G0[j]=g0[j];\n\t\t\tinplace_fmt(G0);\n\t\t\tF0=f0.v; \n\t\t\tinplace_fmt(F0);\n\t\t\tvector<Mint>T(2*d);rep(j,2*d)T[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d){\n\t\t\t\tT[j]=0;\n\t\t\t\tT[j+d]=-T[j+d];\n\t\t\t}\n\t\t\tinplace_fmt(T);\n\t\t\trep(j,2*d)T[j]*=G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d)T[j]=g0[j];\n\t\t\tg0=T;\n\t\t}\n\t\treturn f0.pre(n);\n\t}\n\n    NTTFriendlyPoly exp2(int n){\n        NTTFriendlyPoly f{1};\n        for(int i=1;i<n;i*=2){\n            f=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n        }\n        return f.pre(n);\n    }\n\n\tNTTFriendlyPoly exp3(int n){\n\t\tNTTFriendlyPoly f{1},g{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tg=g*Mint(2)-(g*g*f).pre(d);\n\n\t\t\tNTTFriendlyPoly q=diff(d-1);\n\t\t\tq=q+g*(f.diff(d-1)-f*q).pre(2*d-1);\n\t\t\tf=f+(f*(pre(2*d)-q.inte(2*d))).pre(2*d);\n\t\t}\n\t\treturn f.pre(n);\n\t}\n\n\n \n    NTTFriendlyPoly log(int n){\n        return (diff(n-1)*inv(n-1)).inte(n);\n    }\n \n    NTTFriendlyPoly pow(int n,mint k){\n\t\tauto res=log(n);\n\t\tres*=k;\n\t\treturn res.exp(n);\n\t}\n\tMint& operator[](const int i){return v[i];}\n};\nusing poly=NTTFriendlyPoly<mint>;\n \ntemplate<class Mint>\nostream& operator<<(ostream& ost,NTTFriendlyPoly<Mint>a){\n    for(int i=0;i<a.size();i++){\n        if(i)cout<<\" \";\n        cout<<a.v[i];\n    }\n    return ost;\n}\n\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=mtable.finv(i)*in*(N+1-i);\n\t}\n \n\tp=p.pow(N+1,M);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*mtable.finv(N-i);\n\t}\n\tans*=mtable.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define fd(i,a,b)for(int i=b,_e=a;i>=_e;--i)\n#define ll long long\nusing namespace std;\nconst int N=5e5+5,mo=998244353;\nint n,m,ans,nn;\nint jc[N],ny[N],_n[N],_m[N];\nint ksm(int x,int y){\n\tint t=1;\n\tfor(;y;y>>=1,x=(ll)x*x%mo)if(y&1)t=(ll)t*x%mo;\n\treturn t;\n}\nint main(){\n\tcin>>n>>m;nn=max(n,m);\n\tjc[0]=_n[0]=_m[0]=1;\n\tfo(i,1,nn)jc[i]=(ll)jc[i-1]*i%mo,_n[i]=(ll)_n[i-1]*(n+1)%mo,_m[i]=(ll)_m[i-1]*(m+1)%mo;\n\tny[nn]=ksm(jc[nn],mo-2);\n\tfd(i,0,nn-1)ny[i]=(ll)ny[i+1]*(i+1)%mo;\n\tfo(i,0,min(n,m))\n\t\tans=((ll)(i&1?-1:1)*jc[n]*jc[m]%mo*ny[n-i]%mo*ny[m-i]%mo*ny[i]%mo*_n[m-i]%mo*_m[n-i]+ans)%mo;\n\tcout<<(ans+mo)%mo;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=1000005,M=998244353;\nint n,m,fac[N],inv[N],ans;\nint ksm(int x,int y){\n\tif (!y)return 1;\n\tint z=ksm(x,y/2);\n\tz*=z;z%=M;\n\tif (y&1)z*=x;\n\treturn z%M;\n}\nint C(int x,int y){\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n} \nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfac[0]=inv[0]=1;\n\tfor (int i=1;i<=max(n,m);i++){\n\t\tfac[i]=fac[i-1]*i%M;\n\t\tinv[i]=ksm(fac[i],M-2);\n\t}\n\tfor (int i=min(n,m);~i;i--)(ans+=ksm(n+1,m-i)*ksm(m+1,n-i)%M*ksm(M-1,i)%M*C(n,i)%M*C(m,i)%M*fac[i])%=M;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 19.01.2020 03:43:22       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  Mint ans = 0;\n  Mint c = 1;\n  for (int p = 0; p <= min(n, m); p++) {\n    ans += (p % 2 == 0 ? 1 : -1) * c * power(Mint(m + 1), n - p) * power(Mint(n + 1), m - p);\n    c = c * (m - p) * (n - p) / (p + 1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define mxn 500010\n#define LL long long\n#define mod 998244353\nusing namespace std;\nLL fac[mxn],ifc[mxn];\nint n,m,sl,fh,ans;\nint rd()\n{\n\tsl=0;fh=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=getchar();}\n\twhile('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=getchar();\n\treturn sl*fh;\n}\nLL C(int x,int y) {return fac[x]*ifc[y]%mod*ifc[x-y]%mod;}\nLL _pow(LL k,int i)\n{\n\tstatic LL t;t=1;\n\tfor(;i;i>>=1,k=k*k%mod)\n\t\tif(i&1)\n\t\t\tt=t*k%mod;\n\treturn t;\n}\nint main()\n{\n\tn=rd();m=rd();if(n>m) swap(n,m);fac[0]=1;\n\tfor(int i=1;i<=m;++i) fac[i]=i*fac[i-1]%mod;\n\tifc[m]=_pow(fac[m],mod-2);\n\tfor(int i=m;i;--i) ifc[i-1]=i*ifc[i]%mod;\n\tLL X=_pow(m+1,n),Y=_pow(n+1,m),invn=_pow(n+1,mod-2),invm=_pow(m+1,mod-2);\n\tfor(int i=0,c=1;i<=n;++i,c=mod-c,X=X*invm%mod,Y=Y*invn%mod) ans=(ans+c*X%mod*Y%mod*fac[i]%mod*C(n,i)%mod*C(m,i))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\t#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<ll,ll>\n#define vint vector<ll>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst ll N=5e5+5;\nconst ll mod=998244353;\nll fac[N],inv[N],n,m,maxn,po_m[N],po_n[N],ans;\nll C(ll n,ll m){\n\tif(n<m)return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nsigned main(){\n\tn=read(),m=read(),maxn=max(n,m);\n\tfac[0]=1;for(ll i=1;i<=maxn;i++)fac[i]=fac[i-1]*i%mod;\n\tinv[1]=1;for(ll i=2;i<=maxn;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tinv[0]=1;for(ll i=1;i<=maxn;i++)inv[i]=inv[i-1]*inv[i]%mod;\n\tpo_m[0]=1;for(ll i=1;i<=n;i++)po_m[i]=po_m[i-1]*(m+1)%mod;\n\tpo_n[0]=1;for(ll i=1;i<=m;i++)po_n[i]=po_n[i-1]*(n+1)%mod;\n\tfor(ll i=0;i<=min(n,m);i++)ans=(ans+(i&1?mod-1:1)*C(n,i)%mod*C(m,i)%mod*fac[i]%mod*po_m[n-i]%mod*po_n[m-i]%mod)%mod;\n\treturn cout<<ans,signed();\n}\n/*\n1 2\n2 3\n10 7\n314159 265358\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct ModInt{\n\tuint a;\n    ModInt(ll x=0):a((x+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=ull(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\n//const int MOD = (int) 1e9 + 7;\nconst int MOD = 119 << 23 | 1;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\n#define db(x) cerr << #x << \" = \" << (x) << \" \";\n#define endln cerr << \"\\n\";\n\ntemplate<const int mod, const int maxf>\nstruct NTT {\n    int rts[maxf + 1];\n    int bitrev[maxf];\n    int iv[maxf + 1];\n\n    int fpow(int a, int k) {\n        if (!k) return 1;\n        int res = a, tmp = a;\n        k--;\n        while (k) {\n            if (k & 1) {\n                res = (long long) res * tmp % mod;\n            }\n            tmp = (long long) tmp * tmp % mod;\n            k >>= 1;\n        }\n        return res;\n    }\n    int prt() {\n        vector<int> dvs;\n        for (int i = 2; i * i < mod; i++) {\n            if ((mod - 1) % i) continue;\n            dvs.push_back(i);\n            if (i * i != mod - 1) dvs.push_back((mod - 1) / i);\n        }\n        for (int i = 2; i < mod; i++) {\n            int flag = 1;\n            for (int j = 0; j < dvs.size(); j++) {\n                if (fpow(i, dvs[j]) == 1) {\n                    flag = 0;\n                    break;\n                }\n            }\n            if (flag) return i;\n        }\n        assert(0);\n        return -1;\n    }\n    NTT() {\n        int k = 0; while ((1 << k) < maxf) k++;\n        bitrev[0] = 0;\n        for (int i = 1; i < maxf; i++) {\n            bitrev[i] = bitrev[i >> 1] >> 1 | ((i & 1) << k - 1);\n        }\n        int pw = fpow(prt(), (mod - 1) / maxf);\n        rts[0] = 1;\n        for (int i = 1; i <= maxf; i++) {\n            rts[i] = (long long) rts[i - 1] * pw % mod;\n        }\n        for (int i = 1; i <= maxf; i <<= 1) {\n            iv[i] = fpow(i, mod - 2);\n        }\n    }\n    void dft(int a[], int n, int sign) {\n        int d = 0; while ((1 << d) * n != maxf) d++;\n        for (int i = 0; i < n; i++) {\n            if (i < (bitrev[i] >> d)) {\n                swap(a[i], a[bitrev[i] >> d]);\n            }\n        }\n        for (int len = 2; len <= n; len <<= 1) {\n            int delta = maxf / len * sign;\n            for (int i = 0; i < n; i += len) {\n                int *w = sign > 0 ? rts : rts + maxf;\n                for (int k = 0; k + k < len; k++) {\n                    int &a1 = a[i + k + (len >> 1)], &a2 = a[i + k];\n                    int t = (long long) *w * a1 % mod;\n                    a1 = a2 - t;\n                    a2 = a2 + t;\n                    a1 += a1 < 0 ? mod : 0;\n                    a2 -= a2 >= mod ? mod : 0;\n                    w += delta;\n                }\n            }\n        }\n        if (sign < 0) {\n            int in = iv[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = (long long) a[i] * in % mod;\n            }\n        }\n    }\n    void multiply(int a[], int b[], int na, int nb, int c[]) {\n        static int fa[maxf], fb[maxf];\n        int n = na + nb - 1; while (n != (n & -n)) n += n & -n;\n        for (int i = 0; i < n; i++) fa[i] = fb[i] = 0;\n        for (int i = 0; i < na; i++) fa[i] = a[i];\n        for (int i = 0; i < nb; i++) fb[i] = b[i];\n        dft(fa, n, 1), dft(fb, n, 1);\n        for (int i = 0; i < n; i++) fa[i] = (long long) fa[i] * fb[i] % mod;\n        dft(fa, n, -1);\n        for (int i = 0; i < n; i++) c[i] = fa[i];\n    }\n    vector<int> multiply(vector<int> a, vector<int> b) {\n        static int fa[maxf], fb[maxf], fc[maxf];\n        int na = a.size(), nb = b.size();\n        for (int i = 0; i < na; i++) fa[i] = a[i];\n        for (int i = 0; i < nb; i++) fb[i] = b[i];\n        multiply(fa, fb, na, nb, fc);\n        int k = na + nb - 1;\n        vector<int> res(k);\n        for (int i = 0; i < k; i++) res[i] = fc[i];\n        return res;\n    }\n};\nNTT<MOD, 1 << 20> ntt;\n\nvoid chemthan() {\n    int n, m; cin >> n >> m;\n    vi fac(n + m + 1);\n    vi ifac(n + m + 1);\n    fac[0] = 1; FOR(i, 1, sz(fac)) fac[i] = mult(fac[i - 1], i);\n    FOR(i, 0, sz(fac)) ifac[i] = inv(fac[i]);\n    auto binom = [&] (int n, int k) {\n        return mult(fac[n], mult(ifac[k], ifac[n - k]));\n    };\n    vi a(m + 1), b(n + 1);\n    FOR(i, 0, m + 1) {\n        int coef = mult(binom(m, i), fpow(n + 1, m - i));\n        if (i & 1) {\n            coef = (MOD - coef) % MOD;\n        }\n        a[i] = coef;\n    }\n    FOR(i, 0, n + 1) {\n        b[i] = mult(fpow(m, i), ifac[i]);\n    }\n    vi c = ntt.multiply(a, b);\n    int res = 0;\n    FOR(i, 0, n + 1) {\n        addmod(res, mult(c[i], mult(fac[n], ifac[n - i])));\n    }\n    cout << res << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int mod=998244353;\nconst int maxn=500000;\nint read()\n{\n\tchar c=getchar();\n\tint res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nlong long ksm(long long x,long long n)\n{\n\tlong long ans=1;\n\twhile(n)\n\t{\n\t\tif(n&1) ans=ans*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn ans;\n}\nint n,m;\nlong long fir[maxn+5],inv[maxn+5];\nlong long C(int n,int m)\n{\n\tif(n<m) return 0;\n\treturn fir[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid pre()\n{\n\tfir[0]=1;\n\tfor(int i=1;i<=maxn;i++) fir[i]=fir[i-1]*i%mod;\n\tinv[maxn]=ksm(fir[maxn],mod-2);\n\tfor(int i=maxn-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\nint main()\n{\n\tpre();\n\tn=read(),m=read();\n\tlong long ans=0;\n\tfor(int i=0;i<=min(n,m);i++)\n\t{\n\t\tif(i&1) ans=(ans-C(n,i)*C(m,i)%mod*ksm(m+1,n-i)%mod*ksm(n+1,m-i)%mod*fir[i]%mod)%mod;\n\t\telse ans=(ans+C(n,i)*C(m,i)%mod*ksm(m+1,n-i)%mod*ksm(n+1,m-i)%mod*fir[i]%mod)%mod;\n\t}\n\tans=(ans%mod+mod)%mod;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=500000,mod=998244353;\nint jc[500010],inv[500010],nmi[500010],mmi[500010],n,m,ans;\n\nint quickmi(int a,int b)\n{\n\tint t=1;\n\tfor (; b; b>>=1,a=1ll*a*a%mod)\n\t\tif (b&1) t=1ll*t*a%mod;\n\treturn t;\n}\n\nint main()\n{\n\tjc[0]=1;\n\tfor (int i=1; i<=N; i++) jc[i]=1ll*jc[i-1]*i%mod;\n\tinv[N]=quickmi(jc[N],mod-2);\n\tfor (int i=N; i; i--) inv[i-1]=1ll*inv[i]*i%mod;\n\tscanf(\"%d%d\",&n,&m),nmi[0]=mmi[0]=1;\n\tfor (int i=1; i<=N; i++) nmi[i]=1ll*nmi[i-1]*(n+1)%mod;\n\tfor (int i=1; i<=N; i++) mmi[i]=1ll*mmi[i-1]*(m+1)%mod;\n\tfor (int i=max(m-n,0); i<=m; i++)\n\t\tans=(ans+(((m-i)&1)?(mod-1ll):(1ll))*nmi[i]%mod*inv[i]%mod*mmi[n-m+i]%mod*inv[n-m+i]%mod*inv[m-i])%mod;\n\tans=1ll*ans*jc[n]%mod*jc[m]%mod;\n\treturn printf(\"%d\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 500050\n#define mod 998244353\nint fr[N],ifr[N],n,m,as;\nint pw(int a,int p){int as=1;while(p){if(p&1)as=1ll*as*a%mod;a=1ll*a*a%mod;p>>=1;}return as;}\nint main()\n{\n\tfr[0]=ifr[0]=1;for(int i=1;i<=5e5;i++)fr[i]=1ll*fr[i-1]*i%mod,ifr[i]=pw(fr[i],mod-2);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<=n&&i<=m;i++)as=(as+1ll*(i&1?mod-1:1)*fr[n]%mod*ifr[i]%mod*ifr[n-i]%mod*fr[m]%mod*ifr[m-i]%mod*pw(m+1,n-i)%mod*pw(n+1,m-i))%mod;\n\tprintf(\"%d\\n\",as);\n}//???"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nconst int inv2=(mod+1)>>1;\n\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\n\nint add(int a,int b) {\n    return a+b>=mod?a+b-mod:a+b;\n}\n\nint sub(int a,int b) {\n    return a-b<0?a-b+mod:a-b;\n}\n\nint mul(int a,int b) {\n    return 1ll*a*b%mod;\n}\n\nint qpow(int a,int b) {\n    int ret=1;\n    while(b) {\n        if(b&1) ret=mul(ret,a);\n        a=mul(a,a),b>>=1;\n    }\n    return ret;\n}\n\nvector<int> padd(vector<int> a,vector<int> b) {\n    if(a.size()<b.size()) a.resize(b.size());\n    for(int i=0;i<b.size();i++) a[i]=add(a[i],b[i]);\n    return a;\n}\n\nvector<int> psub(vector<int> a,vector<int> b) {\n    if(a.size()<b.size()) a.resize(b.size());\n    for(int i=0;i<b.size();i++) a[i]=sub(a[i],b[i]);\n    return a;\n}\n\nint www[1000010];\n\nvector<int> pmul(vector<int> a,vector<int> b) {\n    int n=a.size(),m=b.size(),l=0;\n    if(n<20||m<20) {\n        vector<int> ret(n+m-1);\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++) ret[i+j]=add(ret[i+j],mul(a[i],b[j]));\n        return ret;\n    }\n    m=n+m-1;for(n=1;n<m;n<<=1) ++l;\n    vector<int> r(n);\n    for(int i=0;i<n;i++) r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n    auto dft=[&](vector<int> &a,int f) {\n        for(int i=0;i<n;i++) if(i<r[i]) swap(a[i],a[r[i]]);\n        for(int i=1;i<n;i<<=1) {\n            int wn=qpow(3,(mod-1)/(i<<1));\n\t\t\tif(f==-1) wn=qpow(wn,mod-2);\n\t\t\tint *P=www;*P=1;\n\t\t\tfor(int j=1;j<i;j++) *(P+j)=1ll**(P+j-1)*wn%mod;\n            for(int p=i<<1,j=0;j<n;j+=p) {\n                for(int k=0;k<i;k++) {\n                    int x=a[j+k],y=mul(*(P+k),a[j+k+i]);\n                    a[j+k]=add(x,y),a[j+k+i]=sub(x,y);\n                }\n            }\n        }\n        if(f==-1) {\n            int inv=qpow(n,mod-2);\n            for(int i=0;i<n;i++) a[i]=mul(a[i],inv);\n        }\n    };\n    a.resize(n),b.resize(n);\n    dft(a,1),dft(b,1);\n    for(int i=0;i<n;i++) a[i]=mul(a[i],b[i]);\n    dft(a,-1);\n    a.resize(m);return a;\n}\n\nint get2(int n) {\n    int ret=1;\n    while(ret<n) ret<<=1;\n    return ret;\n}\n\nvector<int> pinv(vector<int> a,int n) {\n    if(n==1) return vector<int>(1,qpow(a[0],mod-2));\n    auto rem_a=a;rem_a.resize(n>>1);\n    auto b=pinv(rem_a,n>>1);\n    auto ret=pmul(a,b);ret.resize(n);\n    ret=pmul(ret,b);ret.resize(n);\n    ret=psub(pmul(b,vector<int>(1,2)),ret);\n    return ret;\n}\n\npair<vector<int>,vector<int>> pdiv(vector<int> a,vector<int> b) {\n    auto rev_a=a,rev_b=b;\n    reverse(rev_a.begin(),rev_a.end());\n    reverse(rev_b.begin(),rev_b.end());\n    auto rem_rev_a=rev_a,rem_rev_b=rev_b;\n    rem_rev_a.resize(a.size()-b.size()+1);\n    rem_rev_b.resize(a.size()-b.size()+1);\n    auto inv_rev_b=pinv(rem_rev_b,get2(a.size()-b.size()+1));\n    inv_rev_b.resize(a.size()-b.size()+1);\n    auto q=pmul(rem_rev_a,inv_rev_b);\n    q.resize(a.size()-b.size()+1);\n    reverse(q.begin(),q.end());\n    auto r=psub(a,pmul(q,b));\n    r.resize(b.size()-1);\n    return make_pair(q,r);\n}\n\nvector<int> pmod(vector<int> a,vector<int> b) {\n    return pdiv(a,b).second;\n}\n\nvoid print(vector<int> a) {\n    for(auto x:a) printf(\"%d \",x);\n    puts(\"\");\n}\n\nvector<int> psqrt(vector<int> a,int n) {\n    if(n==1) return vector<int>(1,1);\n    auto rem_a=a;\n    rem_a.resize(n>>1);\n    auto b=psqrt(rem_a,n>>1);\n    auto ret=pinv(b,n);\n    ret=pmul(a,ret);\n    ret.resize(n);\n    ret=padd(ret,b);\n    ret=pmul(ret,vector<int>(1,inv2));\n    return ret;\n}\n\nvector<int> pval(vector<int> a,vector<int> b) {\n    int m=b.size();\n    if(a.size()<b.size()) a.resize(b.size());\n    if(b.size()<a.size()) b.resize(a.size());\n    vector<vector<int>> prod(a.size()<<2);\n    function<void(int,int,int)> getprod=[&](int x,int l,int r) {\n        if(l==r) {\n            prod[x].resize(2);\n            prod[x][0]=sub(0,b[l]);prod[x][1]=1;\n            return;\n        }\n        int mid=(l+r)>>1;\n        getprod(x<<1,l,mid),getprod(x<<1|1,mid+1,r);\n        if(x!=1) prod[x]=pmul(prod[x<<1],prod[x<<1|1]);\n    };\n    getprod(1,0,a.size()-1);\n    vector<int> ans(a.size());\n    function<void(int,int,int,vector<int>)> solve=[&](int x,int l,int r,vector<int> a) {\n        if(l==r) {\n            ans[l]=a[0];return;\n        }\n        int mid=(l+r)>>1;\n        solve(x<<1,l,mid,pmod(a,prod[x<<1]));\n        solve(x<<1|1,mid+1,r,pmod(a,prod[x<<1|1]));\n    };\n    solve(1,0,a.size()-1,a);\n    ans.resize(m);\n    return ans;\n}\n\nvector<int> pder(vector<int> a) {\n    for(int i=1;i<a.size();i++) a[i-1]=mul(i,a[i]);\n    a.pop_back();\n    return a;\n}\n\nvector<int> pint(vector<int> a) {\n    vector<int> inv(a.size()+1);\n    inv[1]=1;for(int i=2;i<inv.size();i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    a.push_back(0);\n    for(int i=a.size()-2;~i;i--) a[i+1]=mul(inv[i+1],a[i]);\n    a[0]=0;\n    return a;\n}\n\nvector<int> pln(vector<int> a,int n) {\n    auto ret=pder(a);\n    ret=pmul(ret,pinv(a,n));\n    ret.resize(n);\n    ret=pint(ret);\n    ret.resize(n);\n    return ret;\n}\n\nvector<int> pexp(vector<int> a,int n) {\n    if(n==1) return vector<int>(1,1);\n    auto rem_a=a;\n    rem_a.resize(n>>1);\n    auto b=pexp(rem_a,n>>1);\n    auto ret=vector<int>(1,1);\n    ret=psub(ret,pln(b,n));\n    ret=padd(ret,a);\n    ret=pmul(ret,b);\n    ret.resize(n);\n    return ret;\n}\n\nvector<int> pqpow(vector<int> a,int k,int n) {\n\tint t=a[0];\n\tfor(auto &x:a) x=1ll*x*qpow(t,mod-2)%mod;\n\tvector<int> c=pln(a,n);\n\tfor(auto &x:c) x=1ll*x*k%mod;\n\tc=pexp(c,n);\n\tfor(auto &x:c) x=1ll*x*qpow(t,k)%mod;\n\treturn c;\n}\n\nint fac[1000010];\n\nint main() {\n\tint n=gi(),m=gi();\n\tfac[0]=1;for(int i=1;i<=m;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tvector<int> G(m+1);\n\tfor(int i=0;i<=m;i++) G[i]=1ll*(m+1-i)*qpow(fac[i],mod-2)%mod;\n\tvector<int> F=pqpow(G,n,get2(m+1));\n\tint ans=0;\n\tfor(int i=0;i<=m;i++) ans=(ans+1ll*F[i]*qpow(fac[m-i],mod-2))%mod;\n\tans=1ll*ans*fac[m]%mod;\n\tcout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n//#define int long long\nusing namespace std;\nconst int maxn=5e5+1000;\ntypedef long long ll;\nint n,m;\nconst int mod=998244353;\nint fr[maxn],ans;\ninline int ksm(int num,int t){\n\tint res=1;\n\tfor(;t;t>>=1,num=1ll*num*num%mod){\n\t\tif(t&1)res=1ll*res*num%mod;\n\t}\n\treturn res;\n}\ninline int c(int m,int n){\n\treturn 1ll*fr[n]*ksm((1ll*fr[m]*fr[n-m])%mod,mod-2)%mod;\t\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfr[0]=fr[1]=1;\n\tfor(int i=2;i<maxn;i++)fr[i]=1ll*fr[i-1]*i%mod;\t\n\tfor(int i=0;i<=min(n,m);i++){\n\t\tans=(ans+1ll*ksm(-1,i)*(1ll*c(i,n)*c(i,m)%mod*fr[i]%mod*ksm(m+1,n-i)%mod*ksm(n+1,m-i)%mod)%mod)%mod;\t\n\t}\n\tans=(ans%mod+mod)%mod;\n\tcout<<ans;\n\treturn 0;\n}//"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef bool boolean;\n\nconst int N = 5e5 + 5;\n\n#define ll long long\n\nvoid exgcd(int a, int b, int& x, int& y) {\n\tif (!b) {\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t}\n}\n\nint inv(int a, int n) {\n\tint x, y;\n\texgcd(a, n, x, y);\n\treturn (x < 0) ? (x + n) : (x);\n}\n\nconst int Mod = 998244353;\n\ntemplate <const int Mod = :: Mod>\nclass Z {\n\tpublic:\n\t\tint v;\n\n\t\tZ() : v(0) {\t}\n\t\tZ(int x) : v(x){\t}\n\t\tZ(ll x) : v(x % Mod) {\t}\n\n\t\tfriend Z operator + (const Z& a, const Z& b) {\n\t\t\tint x;\n\t\t\treturn Z(((x = a.v + b.v) >= Mod) ? (x - Mod) : (x));\n\t\t}\n\t\tfriend Z operator - (const Z& a, const Z& b) {\n\t\t\tint x;\n\t\t\treturn Z(((x = a.v - b.v) < 0) ? (x + Mod) : (x));\n\t\t}\n\t\tfriend Z operator * (const Z& a, const Z& b) {\n\t\t\treturn Z(a.v * 1ll * b.v);\n\t\t}\n\t\tfriend Z operator ~(const Z& a) {\n\t\t\treturn inv(a.v, Mod);\n\t\t}\n\t\tfriend Z operator - (const Z& a) {\n\t\t\treturn Z(0) - a;\n\t\t}\n\t\tZ& operator += (Z b) {\n\t\t\treturn *this = *this + b;\n\t\t}\n\t\tZ& operator -= (Z b) {\n\t\t\treturn *this = *this - b;\n\t\t}\n\t\tZ& operator *= (Z b) {\n\t\t\treturn *this = *this * b;\n\t\t}\n\t\tfriend boolean operator == (const Z& a, const Z& b) {\n\t\t\treturn a.v == b.v;\n\t\t} \n};\n\nZ<> qpow(Z<> a, int p) {\n\tZ<> rt = Z<>(1), pa = a;\n\tfor ( ; p; p >>= 1, pa = pa * pa) {\n\t\tif (p & 1) {\n\t\t\trt = rt * pa;\n\t\t}\n\t}\n\treturn rt;\n}\n\ntypedef Z<> Zi;\n\nint n, m;\nZi fac[N], _fac[N];\n\nvoid init_fac(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfac[i] = fac[i - 1] * i;\n\t}\n\t_fac[n] = ~fac[n];\n\tfor (int i = n; i; i--) {\n\t\t_fac[i - 1] = _fac[i] * i; \n\t}\n}\nZi comb(int n, int m) {\n\treturn fac[n] * _fac[m] * _fac[n - m];\n}\n\nZi pwn[N], pwm[N];\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tinit_fac(max(n, m));\n\tpwn[0] = 1;\n\tfor (int i = 1; i <= m; i++)\n\t\tpwn[i] = pwn[i - 1] * (n + 1);\n\tpwm[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tpwm[i] = pwm[i - 1] * (m + 1);\n\tZi ans = 0;\n\tfor (int i = 0; i <= n && i <= m; i++) {\n\t\tZi tmp = comb(n, i) * comb(m, i) * fac[i] * pwn[m - i] * pwm[n - i];\n\t\tif (i & 1) {\n\t\t\tans -= tmp;\n\t\t} else {\n\t\t\tans += tmp;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans.v);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<stdint.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/rope>\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define VIS(it,con) for(auto it=con.begin();it!=con.end();++it)\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define MIN(x,y) (x=min(x,(y)))\n#define MAX(x,y) (x=max(x,(y)))\n#define mid (l+r>>1)\n#define lch (idx*2+1)\n#define rch (idx*2+2)\n/*****************************************************************************/\n#include<bits/stdc++.h>\n#define int int_fast64_t\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\n#define REP(i,j,k) for(register int i=(j);i<(k);++i)\n#define RREP(i,j,k) for(register int i=(j)-1;i>=(k);--i)\n#define ALL(a) a.begin(),a.end()\n#define MST(a,v) memset(a,(v),sizeof a)\n#define pb push_back\n#define F first\n#define S second\n#define endl '\\n'\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#define __debug\n#ifdef __debug\n\t#define IOS (void)0\n\t#define de(...) cerr<<__VA_ARGS__\n\t#define ar(a,s,t) {REP(__i,s,t)de(a[__i]<<' ');de(endl);}\n#else\n\t#define IOS cin.tie(0),cout.tie(0),ios_base::sync_with_stdio(false)\n\t#define de(...) (void)0\n\t#define ar(...) (void)0\n#endif\n/***********************************default***********************************/\nconst int maxn=5e5+9,mo=998244353;\nint n,m,fac[maxn],res=0;\n\nint qp(int x,int t=mo-2){\n\tint re=1;\n\twhile(t){\n\t\tif(t&1)re=re*x%mo;\n\t\tx=x*x%mo,t>>=1;\n\t}\n\treturn re;\n}\n\nint c(int x,int y){\n\tif(x==y)return 1;\n\telse if(y>x||y<0)return 0;\n\telse return fac[x]*qp(fac[y])%mo*qp(fac[x-y])%mo;\n}\n\nmain(){\n\tIOS;\n\tfac[0]=1;REP(i,1,maxn)fac[i]=fac[i-1]*i%mo;\n\tcin>>n>>m;\n\tREP(i,0,min(n,m)+1){\n\t\t(res+=(i%2?-1:1)*c(n,i)*c(m,i)%mo*fac[i]%mo*qp(m+1,n-i)%mo*qp(n+1,m-i)%mo)%=mo;\n\t}\n\tcout<<(mo+res%mo)%mo<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nint (*rd)()=read<int>;\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\nconst u32 P=998244353;\nu32 &inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\nu32 &dec(u32 &a, u32 b) {return (a-=b)&0x80000000?(a+=P):a;}\nu32 sum(u32 a, u32 b) {return inc(a, b);}\nu32 dif(u32 a, u32 b) {return dec(a, b);}\nu64 power(u64 a, int b) {\n\tu64 ans=1;\n\tfor(; b; a=a*a%P, b/=2) if(b&1) ans=ans*a%P;\n\treturn ans;\n}\n\nconst int N=5e5+1;\nu32 fac[N], ifac[N], pwn[N], pwm[N];\nint main() {\n\tint n=rd(), m=rd();\n\tu32 ans=0;\n\tif(n<m) std::swap(n, m);\n\tfac[0]=1;\n\tfor(int i=1; i<=n; ++i) fac[i]=(u64)fac[i-1]*i%P;\n\tifac[n]=power(fac[n], P-2);\n\tfor(int i=n; i--; ) ifac[i]=(i+1llu)*ifac[i+1]%P;\n\tpwn[0]=pwm[0]=1;\n\tfor(int i=1; i<=m; ++i) pwn[i]=pwn[i-1]*(n+1llu)%P;\n\tfor(int i=1; i<=n; ++i) pwm[i]=pwm[i-1]*(m+1llu)%P;\n\tfor(int r=0; r<=m; ++r) {\n\t\tu32 cur=(u64)fac[n]*ifac[n-r]%P*ifac[r]%P*fac[m]%P*ifac[m-r]%P*pwm[n-r]%P*pwn[m-r]%P;\n\t\tif(r&1) dec(ans, cur); else inc(ans, cur);\n\t}\n\tprintf(\"%u\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 500100;\nconst ll MOD = 998244353;\n\nint N, M;\nll ninv[MAXN];\nll fac[MAXN];\nll finv[MAXN];\nll npow[MAXN], mpow[MAXN];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin >> N >> M;\n\n    ninv[1] = 1;\n    for (int i = 2; i <= max (N, M); i++)\n    {\n        int K = MOD % i;\n        ll r = ((ninv[K] * (K - MOD)) / i) % MOD + MOD;\n        ninv[i] = r % MOD;\n    }\n\n    fac[0] = finv[0] = npow[0] = mpow[0] = 1;\n    for (int i = 1; i <= max (N, M); i++)\n    {\n        fac[i] = (fac[i-1] * i) % MOD;\n        finv[i] = (finv[i-1] * ninv[i]) % MOD;\n        npow[i] = (npow[i-1] * (N + 1)) % MOD;\n        mpow[i] = (mpow[i-1] * (M + 1)) % MOD;\n    }\n\n    ll ans = 0;\n    for (int i = 0; i <= min (N, M); i++)\n    {\n        // N choose i, M choose i, i!, (M+1)^(N-i), (N+1)^(M-i)\n        ll lchoose = (((fac[N] * finv[i]) % MOD) * finv[N-i]) % MOD;\n        ll rchoose = (fac[M] * finv[M-i]) % MOD;\n        ll nv = (lchoose * rchoose) % MOD;\n        nv = (nv * mpow[N-i]) % MOD;\n        nv = (nv * npow[M-i]) % MOD;\n        if (i % 2 == 0)\n            ans += nv;\n        else\n            ans -= nv;\n    }\n\n    ans = (ans % MOD + MOD) % MOD;\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){\n\t\treturn s(a+x.a);\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\treturn s(a+mod-x.a);\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt<998244353>;\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t N>\nstruct ModIntTable{\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n){return facts[n];}\n\tinline Mint finv(int n){return finvs[n];}\n\tinline Mint inv(int n){return invs[n];}\n\tinline Mint binom(int n,int k){return facts[n]*finvs[k]*finvs[n-k];}\n};\nModIntTable<mint,1<<19>mtable;\n\n\ntemplate<class Mint,int32_t root>\nstruct NumberTheoreticTransform{\n\tstatic void ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(root).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    static void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tstatic vector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n};\nusing NTT=NumberTheoreticTransform<mint,3>;\n\n\nconst uint32_t mod=998244353;\nconst mint prim_root=3;\n\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tmint in=mint(n).inv();\n\trep(i,n)\n\t\tf[i]*=in;\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i=false){\n\tif(!i)NTT::ntt(f);\n\telse NTT::intt(f);\n\treturn;\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\n\n\nvector<mint> multiply(vector<mint> x,vector<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n \ntemplate<class Mint>\nstruct NTTFriendlyPoly{\n\tvoid ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(3).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tvector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n\n\tvector<Mint>v;\n\ttemplate<class...Args>\n\tNTTFriendlyPoly(Args...args):v(args...){}\n \n\tNTTFriendlyPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n \n\tint size()const{return v.size();}\n \n\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n \n\tNTTFriendlyPoly operator+(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator-(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator*(const NTTFriendlyPoly& x){\n\t\treturn multiply(v,x.v);\n\t}\n\tNTTFriendlyPoly operator*(const Mint& x){\n\t\tint n=size();\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator/(const Mint& x){\n\t\treturn (*this)*x.inv();\n\t}\n \n\tNTTFriendlyPoly& operator+=(const NTTFriendlyPoly& x){return *this=(*this)+x;}\n\tNTTFriendlyPoly& operator-=(const NTTFriendlyPoly& x){return *this=(*this)-x;}\n\tNTTFriendlyPoly& operator*=(const NTTFriendlyPoly& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n\tNTTFriendlyPoly operator-(){return NTTFriendlyPoly()-*this;}\n \n    NTTFriendlyPoly pre(int n){\n        NTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n&&i<size();i++)res[i]=v[i];\n\t\treturn res;\n    }\n    NTTFriendlyPoly rev(){\n        vector<Mint>res=v;\n\t\twhile(res.size()&&res.back()==0)res.pop_back();\n        reverse(res.begin(),res.end());\n        return res;\n    }\n    NTTFriendlyPoly diff(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=1;i<size()&&i<=n;i++)res[i-1]=v[i]*i;\n        return res;\n    }\n    NTTFriendlyPoly inte(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=0;i<size()&&i+1<n;i++)res[i+1]=v[i]*mtable.inv(i+1);\n        return res;\n    }\n\n    NTTFriendlyPoly inv(int n){\n        vector<mint>res{coef(0).inv()};\n\n        for(int d=1;d<n;d<<=1){\n            vector<Mint>f(2*d),g(2*d);\n            for(int j=0;j<2*d;j++)f[j]=coef(j);\n            for(int j=0;j<d;j++)g[j]=res[j];\n            \n            inplace_fmt(f);inplace_fmt(g);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++){\n                f[j]=0;\n                f[j+d]=-f[j+d];\n            }\n            inplace_fmt(f);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++)f[j]=res[j];\n            res=f;\n        }\n        return NTTFriendlyPoly(res).pre(n);\n    }\n    \n    \n    NTTFriendlyPoly inv2(int n){\n        NTTFriendlyPoly res{coef(0).inv()};\n        for(int i=1;i<n;i*=2){\n            res=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n        }\n        return res.pre(n);\n    }\n    \n    \n\n\tNTTFriendlyPoly exp(int n){\n\t\tNTTFriendlyPoly f0{1},g0{1};\n\t\tvector<Mint>F0{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tvector<Mint>G0=g0.v;\n\t\t\tinplace_fmt(G0);\n\t\t\tvector<Mint>Delta(d);\n\t\t\tfor(int j=0;j<d;j++)Delta[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tDelta[0]-=1;\n\t\t\tNTTFriendlyPoly delta(2*d);\n\t\t\tfor(int j=0;j<d;j++)delta[d+j]=Delta[j];\t\t\n\t\t\t\n\t\t\tNTTFriendlyPoly epsilon(2*d);\n\t\t\t\n\t\t\n\t\t\t\n\t\t\tvector<Mint>DF0=f0.diff(d-1).v;DF0.push_back(0);\n\t\t\tinplace_fmt(DF0);\n\t\t\tfor(int j=0;j<d;j++)DF0[j]*=G0[j];\n\t\t\tinplace_fmt(DF0,true);\n\t\t\tfor(int j=0;j<d-1;j++){\n\t\t\t\tepsilon[j]+=coef(j+1)*(j+1);\n\t\t\t\tepsilon[j+d]+=DF0[j]-coef(j+1)*(j+1);\n\t\t\t}\n\t\t\tepsilon[d-1]+=DF0[d-1];\n\n\n\t\t\tDelta=delta.v;\n\t\t\tinplace_fmt(Delta);\n\t\t\tvector<Mint>DH0=diff(d-1).v;DH0.resize(2*d);\n\t\t\tinplace_fmt(DH0);\n\t\t\tfor(int j=0;j<2*d;j++)Delta[j]*=DH0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tfor(int j=0;j<d;j++)epsilon[j+d]-=Delta[j+d];\n\t\t\n\n\t\t\tepsilon=epsilon.inte(2*d)-pre(2*d);\n\t\t\t\n\t\t\tvector<Mint>Epsilon=epsilon.v;\n\t\t\tinplace_fmt(Epsilon);\n\t\t\trep(j,d)DH0[j]=f0[j],DH0[j+d]=0;\n\t\t\tinplace_fmt(DH0);\n\t\t\trep(j,2*d)Epsilon[j]*=DH0[j];\n\t\t\tinplace_fmt(Epsilon,true);\n\t\t\tf0.v.resize(2*d);\n\t\t\trep(j,d)f0[j+d]-=Epsilon[j+d];\n\t\t\t//f0=(f0-epsilon*f0).pre(2*d);\n\t\t\t\n\t\t\tG0.resize(2*d);\n\t\t\trep(j,d)G0[j]=g0[j];\n\t\t\tinplace_fmt(G0);\n\t\t\tF0=f0.v; \n\t\t\tinplace_fmt(F0);\n\t\t\tvector<Mint>T(2*d);rep(j,2*d)T[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d){\n\t\t\t\tT[j]=0;\n\t\t\t\tT[j+d]=-T[j+d];\n\t\t\t}\n\t\t\tinplace_fmt(T);\n\t\t\trep(j,2*d)T[j]*=G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d)T[j]=g0[j];\n\t\t\tg0=T;\n\t\t}\n\t\treturn f0.pre(n);\n\t}\n\n    NTTFriendlyPoly exp2(int n){\n        NTTFriendlyPoly f{1};\n        for(int i=1;i<n;i*=2){\n            f=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n        }\n        return f.pre(n);\n    }\n\n\tNTTFriendlyPoly exp3(int n){\n\t\tNTTFriendlyPoly f{1},g{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tg=g*Mint(2)-(g*g*f).pre(d);\n\n\t\t\tNTTFriendlyPoly q=diff(d-1);\n\t\t\tq=q+g*(f.diff(d-1)-f*q).pre(2*d-1);\n\t\t\tf=f+(f*(pre(2*d)-q.inte(2*d))).pre(2*d);\n\t\t}\n\t\treturn f.pre(n);\n\t}\n\n\n \n    NTTFriendlyPoly log(int n){\n        return (diff(n-1)*inv(n-1)).inte(n);\n    }\n \n    NTTFriendlyPoly pow(int n,mint k){\n\t\tauto res=log(n);\n\t\tres*=k;\n\t\treturn res.exp(n);\n\t}\n\tMint& operator[](const int i){return v[i];}\n};\nusing poly=NTTFriendlyPoly<mint>;\n \ntemplate<class Mint>\nostream& operator<<(ostream& ost,NTTFriendlyPoly<Mint>a){\n    for(int i=0;i<a.size();i++){\n        if(i)cout<<\" \";\n        cout<<a.v[i];\n    }\n    return ost;\n}\n\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=mtable.finv(i)*in*(N+1-i);\n\t}\n \n\tp=p.pow(N+1,M);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*mtable.finv(N-i);\n\t}\n\tans*=mtable.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 500005\n#define p 998244353\n#define ll long long\nint a[N],b[N],c[N],d[N],i,m,n,x;\nint main()\n{\n    scanf(\"%d%d\",&m,&n);\n    for(*a=*b=a[1]=b[1]=1,i=2;i<=m||i<=n;i++)a[i]=(ll)a[i-1]*i%p,b[i]=(ll)(p-p/i)*b[p%i]%p;\n    for(*c=*d=i=1;i<=m||i<=n;i++)b[i]=(ll)b[i-1]*b[i]%p,c[i]=c[i-1]*(m+1ll)%p,d[i]=d[i-1]*(n+1ll)%p;\n    for(i=0;i<=m&&i<=n;i++)x=(x+(ll)b[m-i]*b[n-i]%p*d[m-i]%p*c[n-i]%p*(i&1?p-b[i]:b[i]))%p;\n    return 0*printf(\"%d\\n\",(ll)a[m]*a[n]%p*x%p);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pa pair<int,int>\nusing namespace std;\nconst int inf = 2147483647;\nconst int mod = 998244353;\nconst int N = 500001;\n\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint jc[N], inv[N];\n\nint add(int x, int y) {\n\tx += y;\n\treturn x >= mod ? x - mod : x;\n}\n\nint dec(int x, int y) {\n\tx -= y;\n\treturn x < 0 ? x + mod : x;\n}\n\nint pow_mod(int a, int k) {\n\tint ans = 1;\n\twhile(k) {\n\t\tif(k & 1) ans = (LL)ans * a % mod;\n\t\ta = (LL)a * a % mod, k /= 2;\n\t} return ans;\n}\n\nint C(int n, int m) {return (LL)jc[n] * inv[m] % mod * inv[n - m] % mod;}\n\nint A(int n, int m) {return (LL)jc[n] * inv[n - m] % mod;}\n\nint main() {\n\tint n = read(), m = read();\n\tif(n < m) swap(n, m);\n\tjc[0] = 1; for(int i = 1; i <= n; i++) jc[i] = (LL)jc[i - 1] * i % mod;\n\tinv[n] = pow_mod(jc[n], mod - 2); for(int i = n; i >= 1; i--) inv[i - 1] = (LL)inv[i] * i % mod;\n\tint ans = (LL)pow_mod(n + 1, m) * pow_mod(m + 1, n) % mod;\n\tfor(int i = 1; i <= m; i++) {\n\t\tif(i & 1) ans = dec(ans, (LL)C(n, i) * A(m, i) % mod * pow_mod(n + 1, m - i) % mod * pow_mod(m + 1, n - i) % mod);\n\t\telse ans = add(ans, (LL)C(n, i) * A(m, i) % mod * pow_mod(n + 1, m - i) % mod * pow_mod(m + 1, n - i) % mod);\n\t} put(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=998244353;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nint del(int x) { return x>=P?x-P:x; }\nvoid add(int &x,int y) { x=del(x+y); }\nint ksm (int a,int b)\n{\n\tint ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=(LL)ans*a%P;\n\t\ta=(LL)a*a%P,b>>=1;\n\t}\n\treturn ans;\n}\nint jc[N],inv[N];\nvoid init (int n)\n{\n\tjc[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tjc[i]=(LL)i*jc[i-1]%P;\n\tinv[n]=ksm (jc[n],P-2);\n\tfor (int i=n-1; i>=0; i--)\n\t\tinv[i]=(LL)(i+1)*inv[i+1]%P;\n}\nint C(int n,int m) { return (LL)jc[n]*inv[m]%P*inv[n-m]%P; }\nint n,m,m1[N],m2[N];\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n),sc(m); int k=max (n,m),ans=0; init (k);\n\tm1[0]=m2[0]=1;\n\tfor (int i=1; i<=k; i++)\n\t\tm1[i]=(LL)m1[i-1]*(m+1)%P,m2[i]=(LL)m2[i-1]*(n+1)%P;\n\tk=min (n,m);\n\tfor (int i=0; i<=k; i++)\n\t{\n\t\tint g=(LL)C(n,i)*C(m,i)%P*jc[i]%P*m1[n-i]%P*m2[m-i]%P;\n\t\tadd(ans,(i&1)?P-g:g);\n\t}\n\tpr(ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cassert>\n#include <climits>\n#include <numeric>\n#include <sstream>\nusing namespace std;\ntypedef long long ll;\n#define DEBUG\n#ifdef DEBUG\n\t#define debug printf\n#else\n\t#define debug(...)\n#endif\nconst int maxn = 5e5 + 5;\nconst int maxm = maxn - 5;\nconst int mod = 998244353;\nll f[maxn],invf[maxn];\nll mypow(ll a,ll b)\n{\n\tll res = 1;\n\tfor(;b;b >>= 1,a = a * a % mod)\n\t{\n\t\tif(b & 1)\n\t\t{\n\t\t\tres = res * a % mod;\n\t\t}\n\t}\n\treturn res;\n}\nll n,m,ans;\nvoid init()\n{\n\tf[0] = 1;\n\tfor(int i = 1;i <= n; ++i)\n\t{\n\t\tf[i] = f[i - 1] * i % mod;\n\t}\n\tinvf[n] = mypow(f[n],mod - 2);\n\tfor(int i = n - 1;i >= 0; --i)\n\t{\n\t\tinvf[i] = invf[i + 1] * (i + 1) % mod;\n\t}\n}\nll comb(ll n,ll k)\n{\n\tif(n < 0 || k < 0 || n < k)\n\t{\n\t\treturn 0;\n\t}\n\treturn f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint main(int argc, char const *argv[])\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(n < m)\n\t{\n\t\tswap(n,m);\n\t}\n\tinit();\n\tfor(int k = 0;k <= m; ++k)\n\t{\n\t\tll fg = k & 1 ? -1 : 1;\n\t\tans += fg * comb(n,k) % mod * comb(m,k) % mod * f[k] % mod\n\t\t\t\t* mypow(m + 1,n - k) % mod * mypow(n + 1,m - k) % mod;\n\t\tans %= mod;\n\t\tans = (ans + mod) % mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PII pair<int, int>\n#define PLL pair<LL, LL>\n#define VI vector<int>\n#define VPII vector<PII>\n#define LL long long\n#define LD long double\n#define f first\n#define s second\n#define MP make_pair\n#define PB push_back\n#define pb pop_back\n#define ALL(c) (c).begin(), (c).end()\n#define SIZ(c) (int)(c).size()\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i, b, e) for(int i = (b); i <= (int)(e); ++i)\n#define FORD(i, b, e) for(int i = (b); i >= (int)(e); --i)\n\n#define Sim template<class n\nSim, class s> ostream & operator << (ostream &p, pair<n, s> x)\n{return p << \"<\" << x.f << \", \" << x.s << \">\";}\nSim> auto operator << (ostream &p, n y) -> \ntypename enable_if<!is_same<n, string>::value, decltype(y.begin(), p)>::type \n{int o = 0; p << \"{\"; for(auto c: y) {if(o++) p << \", \"; p << c;} return p << \"}\";}\nvoid dor() {cerr << endl;}\nSim, class...s> void dor(n p, s...y) {cerr << p << \" \"; dor(y...);}\nSim, class s> void mini(n &p, s y) {if(p>y) p = y;}\nSim, class s> void maxi(n &p, s y) {if(p<y) p = y;}\n#ifdef DEB\n#define debug(...) dor(__FUNCTION__, \":\", __LINE__, \": \", __VA_ARGS__)\n#else\n#define debug(...)\n#endif \n\n#define I(x) #x \" = \", (x), \" \"\n#define A(a, i) #a \"[\" #i \" = \", i, \"] = \", a[i], \" \"\nconst int M = 1024 * 512;\nconst LL mod = 998244353;\n\nint n, m;\n\nLL sil[M], odw[M];\n\nLL poww(LL x, LL e)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tif (e % 2 == 0)\n\t{\n\t\treturn poww(x * x % mod, e / 2);\n\t}\n\treturn poww(x, e - 1) * x % mod;\n}\n\nLL newt(int a, int b)\n{\n\tassert(b >= 0 && b <= a);\n\tLL res = sil[a] * odw[b] % mod;\n\treturn res * odw[a - b] % mod;\n}\n\nint main()\n{\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(NULL);\n\tsil[0] = 1;\n\todw[0] = 1;\n\tFOR(i, 1, M - 1)\n\t{\n\t\tsil[i] = sil[i - 1] * i % mod;\n\t\todw[i] = poww(sil[i], mod - 2);\n\t}\n\t\n\tscanf(\"%d%d\", &n, &m);\n\tLL res = 0;\n\t\n\tFOR(i, 0, min(n, m))\n\t{\n\t\tLL tmp = newt(n, i) * newt(m, i) % mod;\n\t\ttmp = tmp * sil[i] % mod;\n\t\ttmp = tmp * poww(m + 1, n - i) % mod;\n\t\ttmp = tmp * poww(n + 1, m - i) % mod;\n\t\tres = (res + poww(-1, i) * tmp + mod) % mod;\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 998244353\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt n, m;\nInt res;\n\nInt mod_pow(Int x, Int a, Int m = MOD){\n    if(a == 0)return 1;\n    Int res = mod_pow(x, a / 2, m);\n    res = res * res % m;\n    if(a % 2)res *= x;\n    return res % m;\n}\n\nInt inv(Int x, Int m = MOD){\n    return mod_pow(x, m-2, m);\n}\n\nInt fact[1080000];\nInt revfact[1080000];\nInt rev[1080000];\n\nvoid init(){\n    Int m = MOD;\n    fact[0] = 1;\n    revfact[0] = 1;\n    rev[0] = 0;\n    rev[1] = 1;\n    for(int i = 1;i < 1080000;i++){\n        fact[i] = fact[i-1] * i % m;\n        if(i>1)rev[i] = m / i * (m-rev[m % i]) % m;\n        revfact[i] = revfact[i-1] * rev[i] % m;\n    }\n}\n\nInt nCk(Int n, Int k){\n    if(n < k)return 0;\n    return fact[n] * revfact[n-k] % MOD * revfact[k] % MOD;\n}\n\n\n\nint main(){\n    init();\n    cin >> n >> m;\n    res = mod_pow(m+1,n) * mod_pow(n+1,m) % MOD;\n    for(int i = 1;i <= n;i++){\n        Int tmp = nCk(n, i) * nCk(m, i) % MOD *fact[i] % MOD * mod_pow(m+1,n-i) % MOD * mod_pow(n+1, m-i) % MOD;\n        if(i % 2)res -= tmp;\n        else res += tmp;\n        res %= MOD;\n    }\n    if(res < 0)res += MOD;\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define INF 2147483647\n#define mod 998244353\n\nll fact[500010], ifact[500010];\n\nll fpow(ll a, ll b){\n    ll sum = 1;\n    for(; b; b >>= 1){\n        if(b & 1){\n            sum *= a;\n            sum %= mod;\n        }\n        a *= a;\n        a %= mod;\n    }\n    return sum;\n}\n\nll C(int a, int b){\n    return fact[a] * ifact[a - b] % mod * ifact[b] % mod;\n}\n\nint main(){\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    fact[0] = ifact[0] = 1;\n    for(int i = 1; i <= 500000; i++){\n        fact[i] = fact[i - 1] * i % mod;\n        ifact[i] = fpow(fact[i], mod - 2);\n    }\n\n    ll ans = fpow(n + 1, m) * fpow(m + 1, n) % mod;\n    ll num = -1;\n    for(int i = 1; i <= std::min(n, m); i++){\n        ans += num * (C(n, i) * C(m, i) % mod * fact[i] % mod * fpow(n + 1, m - i) % mod * fpow(m + 1, n - i) % mod);\n        ans += mod;\n        ans %= mod;\n        num *= -1;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937 mrand(random_device{}());\n\n#define rep(i , l , r) for (int i = (l); i < (r); ++i)\n\nconst int N = 5e5 + 5;\nconst int mod = 998244353;\n\nint n , m , mx , mn;\nint cm[N] , cn[N] , fac[N] , ifac[N];\n\ntemplate <typename T> inline void chkmin(T &x , T y) { x = min(x , y); }\ntemplate <typename T> inline void chkmax(T &x , T y) { x = max(x , y); }\ntemplate <typename T> inline void read(T &x) {\n   T f = 1; x = 0;\n   char c = getchar();\n   for (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n   for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';\n   x *= f;\n}\n\ninline void inc(int &x , int y) {\n\tx = x + y < mod ? x + y : x + y - mod;\n}\ninline void dec(int &x , int y) {\n\tx = x - y >= 0 ? x - y : x - y + mod;\n}\ninline int binom(int n , int m) {\n\tif (n < m) return 0;\n\telse return 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\ninline int quickpow(int a , int n) {\n\tint res = 1;\n\tfor (; n; n >>= 1 , a = 1LL * a * a % mod)\n\t\tif (n & 1) res = 1LL * res * a % mod;\n\treturn res;\n}\nint main() {\n   \t\n   \tread(n); read(m); mx = max(m , n); mn = min(m , n);\n   \tfac[0] = 1;\n   \tfor (int i = 1; i <= mx; ++i) fac[i] = 1LL * fac[i - 1] * i % mod;\n   \tifac[mx] = quickpow(fac[mx] , mod - 2);\n   \tfor (int i = mx - 1; i >= 0; --i) ifac[i] = 1LL * ifac[i + 1] * (i + 1) % mod;\n   \tcm[0] = cn[0] = 1;\n   \tfor (int i = 1; i <= mx; ++i) cm[i] = 1LL * cm[i - 1] * (m + 1) % mod;\n   \tfor (int i = 1; i <= mx; ++i) cn[i] = 1LL * cn[i - 1] * (n + 1) % mod;\n   \tint ans = 0;\n   \tfor (int i = 0; i <= mn; ++i) {\n   \t\tint val = 1LL * binom(n , i) * binom(m , i) % mod * cm[n - i] % mod * cn[m - i] % mod * fac[i] % mod;\n   \t\tif (i & 1) dec(ans , val); else inc(ans , val);\t\n\t}\n\tprintf(\"%d\\n\" , ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 500233, mod = 998244353;\nint n, m, fac[N], inv[N];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  if (n < m) swap(n, m);\n  fac[0] = fac[1] = inv[0] = inv[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    fac[i] = (ll) fac[i - 1] * i % mod;\n    inv[i] = mod - (ll) mod / i * inv[mod % i] % mod;\n  }\n  for (int i = 2; i <= n; i++) {\n    inv[i] = (ll) inv[i] * inv[i - 1] % mod;\n  }\n  int pn = fac[n], pm = fac[m], ans = 0;\n  for (int i = n - m; i; i--) pn = (ll) pn * (m + 1) % mod;\n  for (int i = m; ~i; i--) {\n    int coef = (ll) pn * pm % mod * inv[n - i] % mod * inv[m - i] % mod * inv[i] % mod * (i & 1 ? mod - 1 : 1) % mod;\n    pn = (ll) pn * (m + 1) % mod;\n    pm = (ll) pm * (n + 1) % mod;\n    ans = (ans + coef) % mod;\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define int long long\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') bo = -1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tres = (res << 1) + (res << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn bo * res;\n}\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = read();\n}\n\ntemplate <typename T, typename... Argv>\nvoid read(T &a, Argv &... argv) {\n\tread(a);\n\tread(argv...);\n}\n\nconst int N = 1e6 + 100, p = 998244353;\nint fac[N], inv[N], _n[N], _m[N];\n\ntemplate <typename T>\nT mul(T x, T y) {\n\treturn 1LL * x * y % p;\n}\n\ntemplate <typename T, typename... Argv>\nT mul(T x, Argv... argv) {\n\treturn mul(x, mul(argv...));\n}\n\nint ksm(int x, int y) {\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nvoid init(int n, int m) {\n\tint M = std::max(n, m);\n\tfac[0] = _n[0] = _m[0] = 1;\n\tfor (int i = 1; i <= M; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[n] = ksm(fac[n], p - 2);\n\tfor (int i = n; i >= 1; --i) inv[i - 1] = mul(inv[i], i);\n\tfor (int i = 1; i <= M; ++i) _n[i] = mul(_n[i - 1], n + 1);\n\tfor (int i = 1; i <= M; ++i) _m[i] = mul(_m[i - 1], m + 1);\n}\n\nint C(int n, int m) {\n\treturn m > n || m < 0 ? 0 : mul(fac[n], inv[m], inv[n - m]);\n}\n\nsigned main() {\n\tint n = read(), m = read(), ans = 0;\n\tinit(n, m);\n\tfor (int i = 0, opt = 1; i <= std::min(n, m); ++i, opt = p - opt) {\n\t\t(ans += mul(opt, C(n, i), C(m, i), fac[i], _m[n - i], _n[m - i])) %= p;\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define ll long long\n#define mod 998244353\n#define N 500010\nusing namespace std;\nll fac[N],inv[N];\nll ksm(ll a,ll b=mod-2)\n{\n\tif(b==0) return 1;\n\tif(b==1) return a;\n\tll q=ksm(a,b>>1);\n\tif(b&1) return q*q%mod*a%mod;\n\treturn q*q%mod;\n}\nll C(int a,int b)\n{\n\tif(b>a || b<0) return 0;\n\tif(a==b || b==0) return 1;\n\treturn fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tint mn=max(n,m);\n\tfac[0]=1;\n\tfor(int i=1;i<=mn;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[mn]=ksm(fac[mn]);\n\tfor(int i=mn-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\tmn=min(n,m);\n\tll ans=0;\n\tfor(int i=0;i<=mn;i++)\n\tans=(ans+(i&1?-1:1)*C(n,i)*C(m,i)%mod*fac[i]%mod*ksm(n+1,m-i)%mod*ksm(m+1,n-i)%mod+mod)%mod;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int P = 998244353;\nint power(int base, int exp) {\n    int result = 1;\n    while (exp > 0) {\n        if (exp & 1)\n            result = 1LL * result * base % P;\n        base = 1LL * base * base % P;\n        exp >>= 1;\n    }\n    return result;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    int l = max(n, m);\n    vector<int> factorial(l + 1), inv_factorial(l + 1);\n    factorial[0] = 1;\n    for (int i = 1; i <= l; ++i)\n        factorial[i] = 1LL * factorial[i - 1] * i % P;\n    inv_factorial[l] = power(factorial[l], P - 2);\n    for (int i = l; i >= 1; --i)\n        inv_factorial[i - 1] = 1LL * inv_factorial[i] * i % P;\n    auto binom = [&](int n, int m) {return 1LL * factorial[n] * inv_factorial[m] % P * inv_factorial[n - m] % P;};\n    int ans = 0;\n    for (int i = min(n, m), x = 1LL * power(m + 1, n - i) * power(n + 1, m - i) % P; i >= 0; --i) {\n        int res = 1LL * binom(n, i) * binom(m, i) % P * factorial[i] % P * x % P;\n        x = 1LL * x * (n + 1) % P * (m + 1) % P;\n        if (i % 2 == 0)\n            ans = (ans + res) % P;\n        else\n            ans = (ans - res + P) % P;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=5e5+9,mod=998244353;\n\tinline int add(int x,int y){return x+y>=mod?x-mod+y:x+y;}\n\tinline int sub(int x,int y){return x>=y?x-y:x+mod-y;}\n\tinline int qpow(int x,int y){\n\t\tint ret=1;\n\t\twhile(y){\n\t\t\tif(y&1) ret=1LL*x*ret%mod;\n\t\t\tx=1LL*x*x%mod,y>>=1;\n\t\t}\n\t\treturn ret;\n\t}\n\tint fac[N],ifac[N],pwn[N],pwm[N];\n\tinline int C(int n,int m){\n\t\tif(n<0 || m<0 || n<m) return 0;\n\t\treturn 1LL*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n\t}\n\n\tint n,m;\n\tint main(){\n\t\tn=read<int>(),m=read<int>();\n\t\tif(n<m) swap(n,m);\n\n\t\tfac[0]=ifac[0]=pwn[0]=pwm[0]=1;\n\t\tfor(int i=1;i<=n;i++) fac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[n]=qpow(fac[n],mod-2);\n\t\tfor(int i=n-1;i>=1;i--) ifac[i]=1LL*ifac[i+1]*(i+1)%mod;\n\t\tfor(int i=1;i<=n;i++) pwm[i]=1LL*pwm[i-1]*(m+1)%mod;\n\t\tfor(int i=1;i<=m;i++) pwn[i]=1LL*pwn[i-1]*(n+1)%mod;\n\n\t\tint ans=0;\n\t\tfor(int i=0;i<=m;i++){\n\t\t\tint tmp=1LL*fac[i]*C(n,i)%mod*C(m,i)%mod*pwn[m-i]%mod*pwm[n-i]%mod;\n\t\t\tif(i&1) ans=sub(ans,tmp);\n\t\t\telse ans=add(ans,tmp);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=500005,mod=998244353;\nint fac[Maxn],ifac[Maxn];\nint ksm(int x,int k){\n    int ret=1,tmp=x;\n    while(k){\n        if(k&1)ret=1ll*ret*tmp%mod;\n        tmp=1ll*tmp*tmp%mod;k>>=1;\n    }\n    return ret;\n}\nint inv(int x){return ksm(x,mod-2);}\nint C(int n,int m){return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nint main(){\n    for(int i=fac[0]=1;i<Maxn;i++)fac[i]=1ll*fac[i-1]*i%mod;\n    for(int i=0;i<Maxn;i++)ifac[i]=inv(fac[i]);\n    int n,m,ans=0;cin>>n>>m;\n    for(int i=0,w=1;i<=min(n,m);i++,w*=-1)\n        ans=(ans+1ll*w*C(n,i)*C(m,i)%mod*fac[i]%mod*ksm(m+1,n-i)%mod*ksm(n+1,m-i))%mod;\n    cout<<(ans+mod)%mod<<\"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nusing cat = long long;\n\ncat mod = 998244353;\n\ncat pw(cat a, cat e) {\n\tif(e <= 0) return 1;\n\tcat x = pw(a, e/2);\n\tx = x * x % mod;\n\tif(e&1) x = x * a % mod;\n\treturn x;\n}\n\ncat om[22];\n\nvoid ntt(cat * a, int n, bool rev = 0) {\n\tfor(int i = 0, j = 0; i < n; ++i) {\n\t\tif(i < j) swap(a[i], a[j]);\n\t\tfor(int k = n>>1; (j^=k) < k; k >>= 1) {}\n\t}\n\tfor(int i = 2, e = 1; i <= n; i <<= 1, e++) {\n\t\tint len = i>>1;\n\t\tcat w = om[e];\n\t\tstatic cat om_pw[1<<19];\n\t\tom_pw[0] = 1;\n\t\tfor(int j = 1; j < len; j++) om_pw[j] = om_pw[j-1] * w % mod;\n\t\tfor(int j = 0; j < n; j += i) {\n\t\t\tcat * cur_ptr = om_pw;\n\t\t\tfor(int k = j; k < j+len; ++k) {\n\t\t\t\tcat u = a[k], v = a[k+len] * *(cur_ptr++) % mod;\n\t\t\t\ta[k] = u + v, a[k+len] = u - v;\n\t\t\t\tif(a[k] >= mod) a[k] -= mod;\n\t\t\t\tif(a[k+len] < 0) a[k+len] += mod;\n\t\t\t}\n\t\t}\n\t}\n\tif(rev) {\n\t\tcat n_inv = pw(n, mod-2);\n\t\treverse(a+1, a+n);\n\t\tfor(int i = 0; i < n; i++) a[i] = a[i] * n_inv % mod;\n\t}\n}\n\nint main() {\n\tfor(int i = 0; i < 22; i++) om[i] = pw(3, (mod-1)>>i);\n\tint N, M;\n\tcin >> N >> M;\n\tcat fac[500010], inv[500010];\n\tfac[0] = inv[0] = 1;\n\tfor(int i = 1; i <= 500000; i++) fac[i] = fac[i-1] * i % mod;\n\tfor(int i = 1; i <= 500000; i++) inv[i] = (i%2 == 0 && i > 2) ? inv[2] * inv[i/2] % mod : pw(i, mod-2);\n\tfor(int i = 1; i <= 500000; i++) inv[i] = inv[i-1] * inv[i] % mod;\n\tcat A[1<<20];\n\tmemset(A, 0, sizeof(A));\n\tcat N_pw = 1;\n\tfor(int i = 0; i <= M; i++) {\n\t\tA[i] = inv[i] * N_pw % mod;\n\t\tN_pw = N_pw * N % mod;\n\t}\n\tntt(A, 1<<20);\n\tcat B[1<<20];\n\tmemset(B, 0, sizeof(B));\n\tcat M_pw = 1;\n\tfor(int i = N; i >= 0; i--) {\n\t\tB[i] = inv[i] * inv[N-i] % mod * M_pw % mod;\n\t\tM_pw = M_pw * (mod-1-M) % mod;\n\t}\n\tntt(B, 1<<20);\n\tcat C[1<<20];\n\tfor(int i = 0; i < (1<<20); i++) C[i] = A[i] * B[i] % mod;\n\tntt(C, 1<<20, 1);\n\tcat ans = 0;\n\tfor(int i = 0; i <= M; i++) ans = (ans + C[i] * inv[M-i]) % mod;\n\tans = ans * fac[N] % mod * fac[M] % mod * (N%2 ? mod-1 : 1) % mod;\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 500010;\nconst int mod = 998244353;\ntypedef long long LL;\nint mul(int a, int b) { return (LL) a * b % mod; }\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint fastpow(int a, int b) {\n\tint res = 1;\n\twhile (b) {\n\t\tif (b & 1) res = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint fac[MAXN], inv[MAXN];\nint C(int a, int b) { return b > a ? 0 : (LL) fac[a] * inv[b] % mod * inv[a - b] % mod; }\nint main() {\n\tfac[0] = fac[1] = inv[0] = inv[1] = 1;\n\tfor (int i = 2; i != MAXN; ++i) {\n\t\tfac[i] = mul(fac[i - 1], i);\n\t\tinv[i] = mul(inv[mod % i], mod - mod / i);\n\t}\n\tfor (int i = 2; i != MAXN; ++i)\n\t\tinv[i] = mul(inv[i], inv[i - 1]);\n\tint n, m;\n\tstd::cin >> n >> m;\n\tint ans = 0;\n\tfor (int i = std::min(n, m); ~i; --i)\n\t\treduce(ans += (LL) fastpow(n + 1, m - i) * fastpow(m + 1, n - i) % mod * (i & 1 ? mod - 1 : 1) % mod * C(n, i) % mod * C(m, i) % mod * fac[i] % mod - mod);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=600000 +117;\nconst int MM=500000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nLL dp[2][NN]={};\nLL fact[NN]={};\nLL rev[NN]={};\nLL mi[2][NN]={};\nconst int mod=998244353;\nLL ksm(LL a,LL b){\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=ret*a%mod;\n\treturn ret;\n}\nLL getfact(int n){\n\tfact[0]=1;\n\tfor(int i=1;i<=n;++i)fact[i]=fact[i-1]*i%mod;\n\trev[n]=ksm(fact[n],mod-2);\n\tfor(int i=n;i>=1;--i)rev[i-1]=rev[i]*i%mod;\n}\nLL comp(int n,int m){\n\treturn fact[n]*rev[m]%mod*rev[n-m]%mod;\n}\nint main(){\n\t//open();\n\tn=read();\n\tm=read();\n\tgetfact(max(n,m));\n\tint sym=1;\n\tLL ans=0;\n\tmi[0][0]=mi[1][0]=1;\n\tfor(int i=1;i<=max(n,m);++i){\n\t\tmi[0][i]=mi[0][i-1]*(n+1)%mod;\n\t\tmi[1][i]=mi[1][i-1]*(m+1)%mod;\n\t}\n\tfor(int i=0;i<=min(n,m);++i){\n\t\tans+=sym*comp(n,i)*comp(m,i)%mod*fact[i]%mod*mi[0][m-i]%mod*mi[1][n-i]%mod;\n\t\tans%=mod;\n\t\tsym=-sym;\n\t}\n\tans=(ans+mod)%mod;\n\tprintf(\"%lld\\n\",ans);\n\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define int long long\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') bo = -1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tres = (res << 1) + (res << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn bo * res;\n}\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = read();\n}\n\ntemplate <typename T, typename... Argv>\nvoid read(T &a, Argv &... argv) {\n\tread(a);\n\tread(argv...);\n}\n\nconst int N = 1e6 + 100, p = 998244353;\nint fac[N], inv[N], _n[N], _m[N];\n\ntemplate <typename T>\nT mul(T x, T y) {\n\treturn 1LL * x * y % p;\n}\n\ntemplate <typename T, typename... Argv>\nT mul(T x, Argv... argv) {\n\treturn mul(x, mul(argv...));\n}\n\nint ksm(int x, int y) {\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nvoid init(int n, int m) {\n\tint M = std::max(n, m);\n\tfac[0] = _n[0] = _m[0] = 1;\n\tfor (int i = 1; i <= M; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[n] = ksm(fac[n], p - 2);\n\tfor (int i = n; i >= 1; --i) inv[i - 1] = mul(inv[i], i);\n\tfor (int i = 1; i <= M; ++i) _n[i] = mul(_n[i - 1], n + 1);\n\tfor (int i = 1; i <= M; ++i) _m[i] = mul(_m[i - 1], m + 1);\n}\n\nint C(int n, int m) {\n\treturn m > n || m < 0 ? 0 : mul(fac[n], inv[m], inv[n - m]);\n}\n\nsigned main() {\n\tint n = read(), m = read(), ans = 0;\n\tinit(n, m);\n\tfor (int i = 0, opt = 1; i <= std::min(n, m); ++i, opt = p - opt) {\n\t\tans = (ans + mul(opt, C(n, i), C(m, i), fac[i], _m[n - i], _n[m - i])) % p;\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nconst int maxn=5e5+1000;\ntypedef long long ll;\nint n,m;\nconst int mod=998244353;\nint fr[maxn],ans;\ninline int ksm(int num,int t){\n\tint res=1;\n\tfor(;t;t>>=1,num=1ll*num*num%mod){\n\t\tif(t&1)res=1ll*res*num%mod;\n\t}\n\treturn res;\n}\ninline int c(int m,int n){\n\treturn 1ll*fr[n]*ksm((fr[m]*fr[n-m])%mod,mod-2)%mod;\t\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfr[0]=fr[1]=1;\n\tfor(int i=2;i<maxn;i++)fr[i]=1ll*fr[i-1]*i%mod;\t\n\tfor(int i=0;i<=min(n,m);i++){\n\t\tans=(ans+1ll*ksm(-1,i)*(1ll*c(i,n)*c(i,m)%mod*fr[i]%mod*ksm(m+1,n-i)%mod*ksm(n+1,m-i)%mod)%mod)%mod;\t\n\t}\n\tans=(ans%mod+mod)%mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int P = 998244353;\nconst int MAX = 500100;\nint mul(int a,int b){\n  return a * b % P;\n}\nvoid add(int &a,int b){\n  a += b;\n  if(a >= P)\n    a -= P;\n}\nvoid sub(int &a,int b){\n  a -= b;\n  if(a < 0){\n    a += P;\n  }\n}\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w & 1){\n      r = r * a % P;\n    }\n    w/=2;\n    a = a * a % P;\n  }\n  return r;\n}\nint n,m,sil[MAX],odw[MAX];\nint dwu(int a,int b){\n  return mul(sil[a], mul(odw[b],odw[a-b]));\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  sil[0] = 1;\n  R(i,MAX-1){\n    sil[i+1] = mul(sil[i], i + 1);\n  }\n  R(i,MAX){\n    odw[i] = pot(sil[i], P-2);\n  }\n  cin >> n >> m;\n  int res = 0;\n  R(i,min(n,m)+1){\n    int ak = mul(dwu(n,i), dwu(m,i));\n    ak = mul(ak, sil[i]);\n    ak = mul(ak, pot(n+1,m-i));\n    ak = mul(ak, pot(m+1,n-i));\n    if(i & 1){\n      sub(res,ak);\n    }else{\n      add(res,ak);\n    }\n  }\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll; \ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n \ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n \n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n \n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n \n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n \n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n \n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n \n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n \n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n \n private:\n  Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n \ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n \ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n \ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n \ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n \ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n \ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n \ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n \n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n \nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n \nvector<Mint> fact;\nvector<Mint> inv_fact;\n \ntemplate <typename T>\nclass NTT {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  static Type md;\n  static Modular<T> root;\n  static int base;\n  static int max_base;\n  static vector<Modular<T>> roots;\n  static vector<int> rev;\n \n  static void clear() {\n    root = 0;\n    base = 0;\n    max_base = 0;\n    roots.clear();\n    rev.clear();\n  }\n \n  static void init() {\n    md = T::value;\n    assert(md >= 3 && md % 2 == 1);\n    auto tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (md - 1) >> 1) == 1) {\n      root++;\n    }\n    assert(power(root, md - 1) == 1);\n    root = power(root, (md - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n \n  static void ensure_base(int nbase) {\n    if (md != T::value) {\n      clear();\n    }\n    if (roots.empty()) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = roots[i] * z;\n      }\n      base++;\n    }\n  }\n \n  static void fft(vector<Modular<T>> &a) {\n    int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          Modular<T> x = a[i + j];\n          Modular<T> y = a[i + j + k] * roots[j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n \n  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n    if (a.empty() || b.empty()) {\n      return {};\n    }\n    int eq = (a == b);\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq) b = a; else fft(b);\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] *= b[i] * inv_sz;\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n};\n \ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\n \ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<Modular<T>> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x.resize(b.size() << 1);\n    b.resize(b.size() << 1);\n    vector<Modular<T>> c = b;\n    NTT<T>::fft(c);\n    NTT<T>::fft(x);\n    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n    fill(x.begin() + (x.size() >> 1), x.end(), 0);\n    NTT<T>::fft(x);\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    for (int i = 0; i < ((int) x.size() >> 1); i++) {\n      b[i + ((int) x.size() >> 1)] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  if (n == 1) {\n    return {1 / a[0]};\n  }\n  int m = (n + 1) >> 1;\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n  int need = n << 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    ++nbase;\n  }\n  NTT<T>::ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  NTT<T>::fft(a);\n  NTT<T>::fft(b);\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n  for (int i = 0; i < size; ++i) {\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  NTT<T>::fft(a);\n  a.resize(n);\n  return a;\n}\n \ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (min(a.size(), b.size()) < 150) {\n    vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        c[i + j] += a[i] * b[j];\n      }\n    }\n    return c;\n  }\n  return NTT<T>::multiply(a, b);\n}\n \ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  return a = a * b;\n}\n \ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n \ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n \ntemplate <typename T>\nvector<T> operator-(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] = -c[i];\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  vector<T> c(a.size() + b.size() - 1, 0);\n  for (int i = 0; i < (int) a.size(); i++) {\n    for (int j = 0; j < (int) b.size(); j++) {\n      c[i + j] += a[i] * b[j];\n    }\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  return a = a * b;\n}\n \ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> x = b * b * a_cut;\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n \ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n \ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T>{1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n \ntemplate <typename T>\nvector<T> derivative(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] *= i;   \t\n  }\n  if (!c.empty()) {\n    c.erase(c.begin());\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> primitive(const vector<T>& a) {\n  vector<T> c = a;\n  c.insert(c.begin(), 0);\n  for (int i = 1; i < (int) c.size(); i++) {\n    c[i] /= i;\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> logarithm(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 1);\n  vector<T> u = primitive(derivative(a) * inverse(a));\n  u.resize(a.size());\n  return u;\n}\n \ntemplate <typename T>\nvector<T> exponent(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 0);\n  int n = (int) a.size();\n  vector<T> b = {1};\n  while ((int) b.size() < n) {\n    vector<T> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x[0] += 1;\n    vector<T> old_b = b;\n    b.resize(b.size() << 1);\n    x -= logarithm(b);\n    x *= old_b;\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<T> multiply(const vector<vector<T>>& a) {\n  if (a.empty()) {\n    return {0};\n  }\n  function<vector<T>(int, int)> mult = [&](int l, int r) {\n    if (l == r) {\n      return a[l];\n    }\n    int y = (l + r) >> 1;\n    return mult(l, y) * mult(y + 1, r);\n  };\n  return mult(0, (int) a.size() - 1);\n}\n\nstruct Combi\n{\n\tvector<int> fact;\n\tvector<int> ifact;\n\tvector<int> inv;\n\tvector<int> pow2;\n\tconst int MOD = 998244353;\n\tint add(int a, int b)\n\t{\n\t\ta+=b;\n\t\twhile(a>=MOD) a-=MOD;\n\t\treturn a;\n\t}\n\tint mult(int a, int b)\n\t{\n\t\treturn (a*1LL*b)%MOD;\n\t}\n\tint modpow(int a, int b)\n\t{\n\t\tint r=1;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1) r=mult(r,a);\n\t\t\ta=mult(a,a);\n\t\t\tb>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tint choose(int a, int b)\n\t{\n\t\tif(a<b) return 0;\n\t\tif(b==0) return 1;\n\t\tif(a==b) return 1;\n\t\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n\t}\n\tint inverse(int a)\n\t{\n\t\treturn modpow(a,MOD-2);\n\t}\n\tvoid init(int _n)\n\t{\n\t\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\t\tfact.resize(_n+1);\n\t\tifact.resize(_n+1);\n\t\tinv.resize(_n+1);\n\t\tpow2.resize(_n+1);\n\t\tpow2[0]=1;\n\t\tifact[0]=1;\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\t\tfact[i]=mult(fact[i-1],i);\n\t\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t\t}\n\t\tifact[_n] = inverse(fact[_n]);\n\t\tfor(int i=_n-1;i>=1;i--)\n\t\t{\n\t\t    ifact[i] = mult(ifact[i + 1], i + 1);\n\t\t}\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t    inv[i] = mult(fact[i-1],ifact[i]);\n\t\t}\n\t}\n};\nCombi combi;\nconst int MOD = 998244353;\n\nint mod_pow(int a, int n, int mod) { int ret = 1; while (n) { if (n & 1) ret = ret *1LL* a % mod; a = a *1LL* a % mod; n >>= 1; } return ret; }\nint inv(int n){return mod_pow(n,MOD-2,MOD);}\nconst int LG = 22;\nconst int root_pw = (1<<LG);\nint iprt,prt;\n \nvoid fft (vector<int> & a, bool invert) \n{\n\tint n = (int) a.size();\n \n\tfor (int i=1, j=0; i<n; ++i) {\n\t\tint bit = n >> 1;\n\t\tfor (; j>=bit; bit>>=1)\n\t\t\tj -= bit;\n\t\tj += bit;\n\t\tif (i < j)\n\t\t\tswap (a[i], a[j]);\n\t}\n \n\tfor (int len=2; len<=n; len<<=1) {\n\t\tint wlen = invert ? iprt : prt;\n\t\tfor (int i=len; i<root_pw; i<<=1)\n\t\t\twlen = int((wlen*1LL*wlen)%MOD);\n\t\tfor (int i=0; i<n; i+=len) {\n\t\t\tint w = 1;\n\t\t\tfor (int j=0; j<len/2; ++j) {\n\t\t\t\tint u = a[i+j]; int v = int((a[i+j+len/2]*1LL*w)%MOD);\n\t\t\t\ta[i+j] = u+v < MOD ? u+v : u+v-MOD;\n\t\t\t\ta[i+j+len/2] = u-v >= 0 ? u-v : u-v+MOD;\n\t\t\t\tw = int (w * 1LL * wlen % MOD);\n\t\t\t}\n\t\t}\n\t}\n\tif (invert) {\n\t\tll nrev = inv(n);\n\t\tfor (int i=0; i<n; ++i)\n\t\t\ta[i] = int((a[i]*1LL*nrev)%MOD);\n\t}\n}\n \nvoid multiply(vector<int>& a, vector<int>& b, vector<int>& res)\n{\n\tvector<int> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n\tint n = 1;\n\twhile(n < max(a.size(), b.size())) n <<= 1;\n\tfa.resize(n); fb.resize(n);\n\tfft(fa, 0); fft(fb, 0);\n\tres.resize(n);\n\tfor(int i = 0; i < n; i++) \n\t{\n\t\tres[i] = int((fa[i]*1LL*fb[i])%MOD);\n\t}\n\tfft(res, 1);\n}\n \nvector<int> inverse(vector<int> &a, int deg) //returns a 2^{deg} polynomial\n{\n\tvector<int> h[2];\n\th[0].pb(mod_pow(a[0],MOD-2,MOD));\n\tint cur=0; int pre=1;\n\tfor(int i=0;i<deg;i++) //after this it'll be of size 2^{deg}\n\t{\n\t\tcur^=1; pre^=1;\n\t\th[cur].resize((1<<(i+1)));\n\t\th[pre].resize((1<<(i+1)));\n\t\tmultiply(h[pre],h[pre],h[cur]);\n\t\tvector<int> pf;\n\t\tpf.assign((1<<(i+1)),0);\n\t\tfor(int j=0;j<min(pf.size(),a.size());j++) pf[j]=a[j];\n\t\th[cur].resize((1<<(i+2))); pf.resize((1<<(i+2)));\n\t\tmultiply(pf,h[cur],h[cur]);\n\t\th[cur].resize((1<<(i+1)));\n\t\tfor(int j=0;j<(1<<i);j++)\n\t\t{\n\t\t\th[cur][j] = combi.add(h[pre][j], combi.add(h[pre][j], MOD - h[cur][j]));\n\t\t}\n\t\tfor(int j=(1<<i);j<(1<<(i+1));j++)\n\t\t{\n\t\t\tif(h[cur][j]!=0) h[cur][j] = MOD - h[cur][j];\n\t\t}\n\t}\n\treturn h[cur];\n}\n \nvector<int> ln(vector<int> &a, int deg)\n{\n\twhile(a.size()<(1<<deg)) a.pb(0);\n\tvector<int> num,denom;\n\tdenom = inverse(a, deg);\n\tnum.resize((1<<deg));\n\tfor(int i = 0; i < (1<<deg); i++)\n\t{\n\t\tif(i+1<a.size())\n\t\t{\n\t\t\tnum[i] = combi.mult(a[i+1], i+1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnum[i] = 0;\n\t\t}\n\t}\n\tnum.resize((1<<(deg+1))); denom.resize((1<<(deg+1)));\n\tvector<int> res;\n\tmultiply(num,denom,res);\n\tres.resize(1<<deg);\n\tvector<int> ans(1<<deg,0);\n\tfor(int i=1;i<(1<<deg);i++)\n\t{\n\t\tans[i]=combi.mult(res[i-1],inv(i));\n\t}\n\treturn ans;\n}\n \nvector<int> exp(vector<int> &a, int deg)\n{\t\n\tvector<int> h[2];\n\th[0].pb(1);\n\tint cur=0; int pre=1;\n\tfor(int i=0;i<deg;i++) //after this it'll be of size 2^{deg}\n\t{\n\t\tcur^=1; pre^=1;\n\t\tvector<int> pf;\n\t\tpf.assign((1<<(i+1)),0);\n\t\tfor(int j=0;j<min(pf.size(),a.size());j++) pf[j]=a[j];\n\t\tpf[0]=combi.add(pf[0],1);\n\t\tvector<int> LN = ln(h[pre],i+1);\n\t\tfor(int j=0;j<(1<<(i+1));j++)\n\t\t{\n\t\t\tpf[j] = combi.add(pf[j], MOD - LN[j]);\n\t\t}\n\t\th[pre].resize((1<<(i+2))); pf.resize((1<<(i+2)));\n\t\tmultiply(pf,h[pre],h[cur]);\n\t\th[cur].resize((1<<(i+1)));\n\t}\n\treturn h[cur];\n}\n \nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcombi.init(500101);\n\tint tmpmult = 7*17;\n\ttmpmult = combi.mult(tmpmult, mod_pow(2, 23 - LG, MOD)); \n\tprt = mod_pow(3, tmpmult, MOD);\n\tiprt = inv(prt);\n\tint n,m; cin>>n>>m;\n\tvector<Mint> a(m+1);\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\ta[i] = combi.mult(m+1-i,combi.ifact[i]);\n\t}\n\t/*\n\tfor(int i=0;i<a.size();i++)\n\t{\n\t\tcerr<<a[i]<<' ';\n\t}\n\tcerr<<'\\n';\n\t*/\n\tvector<Mint> T; int deg=0; bool stp=0;\n\tfor(int i=0;i<a.size();i++)\n\t{\n\t\tif(!stp&&a[i]==0) {deg=i+1; continue;}\n\t\tT.pb(a[i]); stp=1;\n\t}\n\tMint coeff = T[0]; //should be nonempty\n\tMint icoeff = inv(int(T[0]));\n\tT = T*vector<Mint>{icoeff};\n\tvector<Mint> tmpNW = exponent(logarithm(T)*vector<Mint>{n});\n  \tint tt=combi.modpow(int(coeff),n);\n\tfor(int i=0;i<tmpNW.size();i++) tmpNW[i]=combi.mult(int(tmpNW[i]),tt);\n\tvector<Mint> NW(m+1,0);\n \t int cur=min(ll(m+1),ll(n)*ll(deg));\n\tfor(int i=0;i<tmpNW.size();i++)\n\t{\n\t\tif(cur<=m) NW[cur] = tmpNW[i];\n\t\telse break;\n\t}\n\t/*\n\tfor(int i=0;i<NW.size();i++) cerr<<NW[i]<<' ';\n\tcerr<<'\\n';\n\t*/\n\tint ans=0;\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\tans=combi.add(ans,combi.mult(int(NW[i]),combi.ifact[m-i]));\n\t}\n\tans=combi.mult(ans,combi.fact[m]);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\ntypedef long long LL;\nint n,m;\n#define mod 998244353\nint main()\n{\n\t//freopen(\"circle.in\",\"r\",stdin);\n\t//freopen(\"circle.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&m);\n\tif(n>m)\n\t\tswap(n,m);\n\tLL ans=3,ml=2;\n\tfor(int i=2;i<=m;i++)\n\t\tans=(ans*2+ml)%mod,ml=ml*2%mod;\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct ModInt{\n\tuint a;\n    ModInt(ll x=0):a((x+=mod)<mod?x:x-mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta=(a+=x.a)<mod?a:a-mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta=(a+=mod-x.a)<mod?a:a-mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=ull(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll; \ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = 998244353;\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\t\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinit(888888);\n\tint ans = 0;\n\tint n,m; cin>>n>>m;\n\tfor(int i=0;i<=min(n,m);i++)\n\t{\n\t\tint res=mult(choose(n,i),mult(choose(m,i),mult(fact[i],mult(modpow(m+1,n-i),modpow(n+1,m-i)))));\n\t\tif(i&1) ans=add(ans,MOD-res);\n\t\telse ans=add(ans,res);\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 998244353;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\nusing namespace modular;\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 1000007\n\nint N, M;\nint fac[MAX_N], ifac[MAX_N], pwn[MAX_N], pwm[MAX_N];\n\nvoid init() {\n    int MX = 1000000;\n    fac[0] = ifac[0] = pwn[0] = pwm[0] = 1;\n    Rep(i, MX) {\n        fac[i] = mul(fac[i - 1], i);\n        pwn[i] = mul(pwn[i - 1], N + 1);\n        pwm[i] = mul(pwm[i - 1], M + 1);\n    }\n    ifac[MX] = qpow(fac[MX], MOD - 2);\n    irep(i, MX, 2) ifac[i - 1] = mul(ifac[i], i);\n}\n\ninline int C(int x, int y) {\n    if (y < 0 || x < y) return 0;\n    return mul(fac[x], mul(ifac[x - y], ifac[y]));\n}\n\nvoid solve() {\n    int res = 0, ed = std::min(N, M);\n    rep(r, 0, ed) {\n        int tmp = mul(C(N, r), C(M, r));\n        tmp = mul(tmp, mul(fac[r], mul(pwn[M - r], pwm[N - r])));\n        inc(res, (r & 1) ? MOD - tmp : tmp);\n    }\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n    read(N), read(M);\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef long long LL;\nconst int N = 500003, mod = 998244353;\nint n, m, ans, tmp, fac[N], inv[N];\ninline int kasumi(int a, int b){\n\tint res = 1;\n\twhile(b){\n\t\tif(b & 1) res = (LL) res * a % mod;\n\t\ta = (LL) a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\ninline void init(){\n\tfac[0] = 1;\n\tfor(Rint i = 1;i <= m;i ++) fac[i] = (LL) i * fac[i - 1] % mod;\n\tinv[m] = kasumi(fac[m], mod - 2);\n\tfor(Rint i = m;i;i --) inv[i - 1] = (LL) i * inv[i] % mod;\n}\ninline int C(int n, int m){\n\treturn (LL) fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tif(n > m) swap(n, m);\n\tinit();\n\tfor(Rint i = 0;i <= n;i ++){\n\t\ttmp = (LL) C(n, i) * C(m, i) % mod * fac[i] % mod * kasumi(m + 1, n - i) % mod * kasumi(n + 1, m - i) % mod;\n\t\tif(i & 1) ans = (ans + mod - tmp) % mod;\n\t\telse ans = (ans + tmp) % mod;\n\t}\n\tprintf(\"%d\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll mod = 998244353;\n\nll bin_pow(ll a, ll p) {\n  ll r = 1;\n  while (p) {\n    if (p&1) r = r*a%mod;\n    a = a*a%mod;\n    p >>= 1;\n  }\n  return r;\n}\n\nll fac[1000000], ifac[1000000];\n\nll ncr(int n, int k) {\n  if (n < 0 || k < 0 || k > n) return 0;\n  return fac[n]*ifac[k] %mod * ifac[n-k] %mod;\n}\nint main() {\n  ios::sync_with_stdio(0); cin.tie(0);\n  ll w, h;\n  cin >> w >> h;\n  fac[0] = ifac[0] = 1;\n  for (int i = 1; i <= w || i <= h; i++) {\n    fac[i] = fac[i-1]*i%mod;\n    ifac[i] = bin_pow(fac[i], mod-2);\n    assert(fac[i]*ifac[i]%mod == 1);\n  }\n  ll ans = 0;\n  for (int k = 0; k <= w && k <= h; k++) {\n    (ans += (k%2 ? -1 : 1)* ncr(w,k)*ncr(h,k) %mod *fac[k]%mod *bin_pow(w+1,h-k) %mod *bin_pow(h+1,w-k)) %= mod;\n  }\n  cout << (ans+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 500010\n#define mod 998244353\nusing namespace std;\ntypedef long long ll;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,m,mx,mn;\nint ci_n[maxn],ci_m[maxn];\nint fac[maxn],inv[maxn];\nint quick_pow(int x,int p)\n{\n    int an=1,po=x;\n    while(p)\n    {\n        if(p&1)  an=1ll*an*po%mod;\n        po=1ll*po*po%mod;\n        p>>=1;\n    }\n    return an;\n}\nint ans;\nvoid add(int &x,int y)\n{\n    x=(x+y>=mod)?x+y-mod:x+y;\n}\nint C(int x,int y)\n{\n    return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n    n=read();m=read();mx=max(n,m);mn=min(n,m);\n    fac[0]=1;\n    for(int i=1;i<=mx;i++)  fac[i]=1ll*fac[i-1]*i%mod;\n    inv[mx]=quick_pow(fac[mx],mod-2);\n    for(int i=mx-1;i>=0;i--)  inv[i]=1ll*inv[i+1]*(i+1)%mod;\n    ci_m[0]=ci_n[0]=1;\n    for(int i=1;i<=n;i++)  ci_m[i]=1ll*ci_m[i-1]*(m+1)%mod;\n    for(int i=1;i<=m;i++)  ci_n[i]=1ll*ci_n[i-1]*(n+1)%mod;\n    for(int i=0;i<=mn;i++)\n    {\n        int tmp=1ll*C(n,i)*C(m,i)%mod*fac[i]%mod*ci_m[n-i]%mod*ci_n[m-i]%mod;\n        add(ans,(i&1)?mod-tmp:tmp);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nconst int mo=998244353,N=1e6+5;\nint ksm(int a,int b){\n\tint ans=1;\n\twhile (b){\n\t\tif (b&1) ans=ans*a%mo;\n\t\ta=a*a%mo;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[N],inv[N],f[N];\n\nint C(int a,int b){\n\treturn fac[a]*inv[b]%mo*inv[a-b]%mo;\n}\nsigned main(){\n\tint n,m,ans=0;\n\tscanf(\"%lld%lld\",&n,&m);\n\tfac[0]=1;\n\tfor (int i=1;i<N;++i)\n\t\tfac[i]=(fac[i-1]*i)%mo;\n\tinv[N-1]=ksm(fac[N-1],mo-2);\n\tfor (int i=N-2;i>=0;i--)\n\t\tinv[i]=(inv[i+1]*(i+1))%mo;\n\tif (n>m) std::swap(n,m);\n\tfor (int i=0;i<=n;++i)\n\t\tf[i]=C(n,i)*C(m,i)%mo*fac[i]%mo*ksm(n+1,m-i)%mo*ksm(m+1,n-i)%mo;\n\tfor (int i=0;i<=n;++i)\n\t\t ans=((ans+(1-((i&1)<<1))*f[i])%mo+mo)%mo;\n\tprintf(\"%lld\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb push_back\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nconst int P = 998244353, R = 3;\nconst int SZ = 20, N = 1 << SZ;\n\nint Pow(int x, int y) {\n\tint r = 1;\n\twhile (y) {\n\t\tif (y & 1) r = (long long)r * x % P;\n\t\tx = (long long)x * x % P;\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\n\nvoid FFT(int *a, bool f) {\n\tint i, j, k, x, y, z;\n\tj = 0;\n\tfor (i = 1; i < N; i++) {\n\t\tfor (k = N >> 1; j >= k; k >>= 1) j -= k;\n\t\tj += k;\n\t\tif (i < j) {\n\t\t\tk = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = k;\n\t\t}\n\t}\n\tfor (i = 1; i < N; i <<= 1) {\n\t\tx = Pow(f ? Pow(R, P - 2) : R, P / i >> 1);\n\t\tfor (j = 0; j < N; j += i << 1) {\n\t\t\ty = 1;\n\t\t\tfor (k = 0; k < i; k++) {\n\t\t\t\tz = (long long)a[i | j | k] * y % P;\n\t\t\t\ta[i | j | k] = a[j | k] - z;\n\t\t\t\tif (a[i | j | k] < 0) a[i | j | k] += P;\n\t\t\t\ta[j | k] += z;\n\t\t\t\tif (a[j | k] >= P) a[j | k] -= P;\n\t\t\t\ty = (long long)y * x % P;\n\t\t\t}\n\t\t}\n\t}\n\tif (f) {\n\t\tj = Pow(N, P - 2);\n\t\tfor (i = 0; i < N; i++) a[i] = (long long)a[i] * j % P;\n\t}\n}\n\nconst int mod = 998244353;\n\nll pw(ll x, ll y = mod - 2) {\n\tll res = 1;\n\twhile(y) {\n\t\tif(y & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint n, m;\nll F[1000010];\nint V[1<<20|50];\n\nint main() {\n\tF[0] = 1;\n\tfor(int i=1;i<1000010;i++) F[i] = i * F[i-1] % mod;\n\tscanf(\"%d%d\", &n, &m);\n\tif(m < n) swap(n, m);\n\tfor(int i=0;i<=n;i++) {\n\t\tV[i] = (ll)(n - i) * pw(F[i]) % mod;\n\t}\n\tFFT(V, false);\n\tfor(int i=0;i<N;i++) V[i] = pw(V[i], m);\n\tFFT(V, true);\n\tfor(int i=0;i<=n;i++) V[i] = (ll) V[i] * F[n] % mod;\n\tint ans = 0;\n\tfor(int i=0;i<=n;i++) {\n\t\tint t = V[i];\n\t\tans = (ans + (ll)t * pw(F[n-i])) % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\ninline char gc(){\n\tstatic char buf[100000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x=0;char ch=gc();bool positive=1;\n\tfor(;!isdigit(ch);ch=gc()) if(ch=='-') positive=0;\n\tfor(;isdigit(ch);ch=gc()) x=x*10+ch-'0';\n\treturn positive?x:-x;\n}\ninline void write(ll x){\n\tif(x<0){\n\t\tx=-x;putchar('-');\n\t}\n\tif(x>=10) write(x/10);\n\tputchar('0'+x%10);\n}\ninline void writeln(ll x){write(x);puts(\"\");}\ninline void writep(ll x){write(x);putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=5e5+5,mo=998244353;\nint fac[N],inv[N];\nint ksm(int x,int p){\n\tint res=1;\n\tfor(;p;p>>=1,x=(ll)x*x%mo){\n\t\tif(p&1) res=(ll)res*x%mo;\n\t}\n\treturn res;\n}\nvoid init(int n){\n\tFor(i,fac[0]=1,n) fac[i]=(ll)i*fac[i-1]%mo;\n\tinv[n]=ksm(fac[n],mo-2);\n\tRep(i,n-1,0) inv[i]=(ll)inv[i+1]*(i+1)%mo;\n}\nint C(int n,int m){\n\treturn (ll)fac[n]*inv[m]%mo*inv[n-m]%mo;\n}\nint main(){\n\tinit(N-1);\n\tint n=read(),m=read(),ans=0;\n\tFor(i,0,min(n,m)){\n\t\tint ssw=(ll)C(n,i)*C(m,i)%mo*fac[i]%mo;\n\t\tint ksg=(ll)ksm(n+1,m-i)*ksm(m+1,n-i)%mo;\n\t\tssw=(ll)ssw*ksg%mo;\n\t\tif(i%2) ans=(ans+mo-ssw)%mo;\n\t\telse ans=(ans+ssw)%mo;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,m,jc[1000010],ny[1000100],ans,p=998244353;\nll C(ll x,ll y){\n\treturn jc[x]*ny[y]%p*ny[x-y]%p;\n}\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y&1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nint main(){\n\tll i,xlh;\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(n>m)swap(n,m);\n\tjc[0]=ny[0]=1;\n\tfor(i=1;i<=m;i++)jc[i]=jc[i-1]*i%p,ny[i]=ksm(jc[i],p-2);\n\tfor(i=0;i<=n;i++){\n\t\txlh=C(n,i)*C(m,i)%p*jc[i]%p*ksm(n+1,m-i)%p*ksm(m+1,n-i)%p;\n\t\tif(i%2)ans=(ans-xlh+p)%p;\n\t\t else ans=(ans+xlh)%p;\n\t}\n\tprintf(\"%lld\",ans);\n}\n/*\n仔细想想不难，但感觉这种容斥确实非常奇怪。 \n*/"
  },
  {
    "language": "C++",
    "code": "/*====Corycle====*/\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<map>\n#define ll long long\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int Mod=998244353;\nconst int N=5e5+5;\nint read(){\n\tint s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}\n\treturn s*f;\n}\nint n,m,Ans,fac[N],inv[N];\nint mod(int x){return x>=Mod?x-Mod:x;}\nvoid Prepare(int maxn){\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=maxn;i++)fac[i]=1ll*fac[i-1]*i%Mod;\n\tfor(int i=2;i<=maxn;i++)inv[i]=1ll*inv[Mod%i]*(Mod-Mod/i)%Mod;\n\tfor(int i=2;i<=maxn;i++)inv[i]=1ll*inv[i-1]*inv[i]%Mod;\n}\nint C(int n,int m){return n<m?0:1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;}\nint Pow(int x,int y){\n\tint ans=1;\n\twhile(y){if(y&1)ans=1ll*ans*x%Mod;x=1ll*x*x%Mod;y>>=1;}\n\treturn ans;\n}\nint main(){\n//\tfreopen(\"_.in\",\"r\",stdin);\n//\tfreopen(\"_.out\",\"w\",stdout);\n\tn=read();m=read();Prepare(max(n,m));\n\tfor(int i=0;i<=min(n,m);i++){\n\t\tAns=mod(Ans+1ll*(i&1?Mod-1:1)*C(n,i)%Mod*C(m,i)%Mod*fac[i]%Mod*Pow(m+1,n-i)%Mod*Pow(n+1,m-i)%Mod);\n\t}\n\tprintf(\"%d\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define MAXN 500006\n#define P 998244353\nint n , m;\n\nint Pow( int x , int a ) {\n    int ret = 1;\n    while( a ) {\n        if( a & 1 ) ret = 1ll * ret * x % P;\n        x = 1ll * x * x % P , a >>= 1;\n    }\n    return ret;\n}\n\nint J[MAXN] , iJ[MAXN];\n\nint C( int a , int b ) {\n    return J[a] * 1ll * iJ[b] % P * iJ[a] % P;\n}\n\nint main() {\n    J[0] = iJ[0] = 1;\n    for( int i = 1 ; i < MAXN ; ++ i ) J[i] = J[i - 1] * 1ll * i % P , iJ[i] = Pow( J[i] , P - 2 );\n    cin >> n >> m;\n    int lim = min( n , m );\n    int c = 0 , res = 0;\n    for( int i = 0 , zjk ; i <= lim ; ++ i ) {\n        zjk = C( n , i ) * 1ll * C( m , i ) % P * J[i] % P * Pow( n + 1 , m - i ) % P * Pow( m + 1 , n - i ) % P;\n        if( c ) zjk = P - zjk;\n        c ^= 1;\n        res = ( res + zjk ) % P;\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){\n\t\treturn s(a+x.a);\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\treturn s(a+mod-x.a);\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt<998244353>;\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t N>\nstruct ModIntTable{\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n){return facts[n];}\n\tinline Mint finv(int n){return finvs[n];}\n\tinline Mint inv(int n){return invs[n];}\n\tinline Mint binom(int n,int k){return facts[n]*finvs[k]*finvs[n-k];}\n};\nModIntTable<mint,1<<19>mtable;\n\n\ntemplate<class Mint,int32_t root>\nstruct NumberTheoreticTransform{\n\tstatic void ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(root).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    static void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tstatic vector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n};\nusing NTT=NumberTheoreticTransform<mint,3>;\n\n\nconst uint32_t mod=998244353;\nconst mint prim_root=3;\n\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tmint in=mint(n).inv();\n\trep(i,n)\n\t\tf[i]*=in;\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i=false){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\n\n\nvector<mint> multiply(vector<mint> x,vector<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n \ntemplate<class Mint>\nstruct NTTFriendlyPoly{\n\tvoid ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(3).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tvector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n\n\tvector<Mint>v;\n\ttemplate<class...Args>\n\tNTTFriendlyPoly(Args...args):v(args...){}\n \n\tNTTFriendlyPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n \n\tint size()const{return v.size();}\n \n\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n \n\tNTTFriendlyPoly operator+(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator-(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator*(const NTTFriendlyPoly& x){\n\t\treturn multiply(v,x.v);\n\t}\n\tNTTFriendlyPoly operator*(const Mint& x){\n\t\tint n=size();\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator/(const Mint& x){\n\t\treturn (*this)*x.inv();\n\t}\n \n\tNTTFriendlyPoly& operator+=(const NTTFriendlyPoly& x){return *this=(*this)+x;}\n\tNTTFriendlyPoly& operator-=(const NTTFriendlyPoly& x){return *this=(*this)-x;}\n\tNTTFriendlyPoly& operator*=(const NTTFriendlyPoly& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n\tNTTFriendlyPoly operator-(){return NTTFriendlyPoly()-*this;}\n \n    NTTFriendlyPoly pre(int n){\n        NTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n&&i<size();i++)res[i]=v[i];\n\t\treturn res;\n    }\n    NTTFriendlyPoly rev(){\n        vector<Mint>res=v;\n\t\twhile(res.size()&&res.back()==0)res.pop_back();\n        reverse(res.begin(),res.end());\n        return res;\n    }\n    NTTFriendlyPoly diff(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=1;i<size()&&i<=n;i++)res[i-1]=v[i]*i;\n        return res;\n    }\n    NTTFriendlyPoly inte(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=0;i<size()&&i+1<n;i++)res[i+1]=v[i]*mtable.inv(i+1);\n        return res;\n    }\n\n    NTTFriendlyPoly inv(int n){\n        vector<mint>res{coef(0).inv()};\n\n        for(int d=1;d<n;d<<=1){\n            vector<Mint>f(2*d),g(2*d);\n            for(int j=0;j<2*d;j++)f[j]=coef(j);\n            for(int j=0;j<d;j++)g[j]=res[j];\n            \n            inplace_fmt(f);inplace_fmt(g);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++){\n                f[j]=0;\n                f[j+d]=-f[j+d];\n            }\n            inplace_fmt(f);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++)f[j]=res[j];\n            res=f;\n        }\n        return NTTFriendlyPoly(res).pre(n);\n    }\n    \n    \n    NTTFriendlyPoly inv2(int n){\n        NTTFriendlyPoly res{coef(0).inv()};\n        for(int i=1;i<n;i*=2){\n            res=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n        }\n        return res.pre(n);\n    }\n    \n    \n\n\tNTTFriendlyPoly exp(int n){\n\t\tNTTFriendlyPoly f0{1},g0{1};\n\t\tvector<Mint>F0{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tvector<Mint>G0=g0.v;\n\t\t\tinplace_fmt(G0);\n\t\t\tvector<Mint>Delta(d);\n\t\t\tfor(int j=0;j<d;j++)Delta[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tDelta[0]-=1;\n\t\t\tNTTFriendlyPoly delta(2*d);\n\t\t\tfor(int j=0;j<d;j++)delta[d+j]=Delta[j];\t\t\n\t\t\t\n\t\t\tNTTFriendlyPoly epsilon(2*d);\n\t\t\t\n\t\t\n\t\t\t\n\t\t\tvector<Mint>DF0=f0.diff(d-1).v;DF0.push_back(0);\n\t\t\tinplace_fmt(DF0);\n\t\t\tfor(int j=0;j<d;j++)DF0[j]*=G0[j];\n\t\t\tinplace_fmt(DF0,true);\n\t\t\tfor(int j=0;j<d-1;j++){\n\t\t\t\tepsilon[j]+=coef(j+1)*(j+1);\n\t\t\t\tepsilon[j+d]+=DF0[j]-coef(j+1)*(j+1);\n\t\t\t}\n\t\t\tepsilon[d-1]+=DF0[d-1];\n\n\n\t\t\tDelta=delta.v;\n\t\t\tinplace_fmt(Delta);\n\t\t\tvector<Mint>DH0=diff(d-1).v;DH0.resize(2*d);\n\t\t\tinplace_fmt(DH0);\n\t\t\tfor(int j=0;j<2*d;j++)Delta[j]*=DH0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tfor(int j=0;j<d;j++)epsilon[j+d]-=Delta[j+d];\n\t\t\n\n\t\t\tepsilon=epsilon.inte(2*d)-pre(2*d);\n\t\t\t\n\t\t\tvector<Mint>Epsilon=epsilon.v;\n\t\t\tinplace_fmt(Epsilon);\n\t\t\trep(j,d)DH0[j]=f0[j],DH0[j+d]=0;\n\t\t\tinplace_fmt(DH0);\n\t\t\trep(j,2*d)Epsilon[j]*=DH0[j];\n\t\t\tinplace_fmt(Epsilon,true);\n\t\t\tf0.v.resize(2*d);\n\t\t\trep(j,d)f0[j+d]-=Epsilon[j+d];\n\t\t\t//f0=(f0-epsilon*f0).pre(2*d);\n\t\t\t\n\t\t\tG0.resize(2*d);\n\t\t\trep(j,d)G0[j]=g0[j];\n\t\t\tinplace_fmt(G0);\n\t\t\tF0=f0.v; \n\t\t\tinplace_fmt(F0);\n\t\t\tvector<Mint>T(2*d);rep(j,2*d)T[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d){\n\t\t\t\tT[j]=0;\n\t\t\t\tT[j+d]=-T[j+d];\n\t\t\t}\n\t\t\tinplace_fmt(T);\n\t\t\trep(j,2*d)T[j]*=G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d)T[j]=g0[j];\n\t\t\tg0=T;\n\t\t}\n\t\treturn f0.pre(n);\n\t}\n\n    NTTFriendlyPoly exp2(int n){\n        NTTFriendlyPoly f{1};\n        for(int i=1;i<n;i*=2){\n            f=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n        }\n        return f.pre(n);\n    }\n\n\tNTTFriendlyPoly exp3(int n){\n\t\tNTTFriendlyPoly f{1},g{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tg=g*Mint(2)-(g*g*f).pre(d);\n\n\t\t\tNTTFriendlyPoly q=diff(d-1);\n\t\t\tq=q+g*(f.diff(d-1)-f*q).pre(2*d-1);\n\t\t\tf=f+(f*(pre(2*d)-q.inte(2*d))).pre(2*d);\n\t\t}\n\t\treturn f.pre(n);\n\t}\n\n\n \n    NTTFriendlyPoly log(int n){\n        return (diff(n-1)*inv(n-1)).inte(n);\n    }\n \n    NTTFriendlyPoly pow(int n,mint k){\n\t\tauto res=log(n);\n\t\tres*=k;\n\t\treturn res.exp(n);\n\t}\n\tMint& operator[](const int i){return v[i];}\n};\nusing poly=NTTFriendlyPoly<mint>;\n \ntemplate<class Mint>\nostream& operator<<(ostream& ost,NTTFriendlyPoly<Mint>a){\n    for(int i=0;i<a.size();i++){\n        if(i)cout<<\" \";\n        cout<<a.v[i];\n    }\n    return ost;\n}\n\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=mtable.finv(i)*in*(N+1-i);\n\t}\n \n\tp=p.pow(N+1,M);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*mtable.finv(N-i);\n\t}\n\tans*=mtable.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mod = 998244353;\nll fp(ll a,ll k){\n\tll ans=1;\n\tfor(;k;k>>=1,a=a*a%mod)\n\t\tif(k&1) ans=a*ans%mod;\n\treturn ans;\n}\nint n,m;\nll fac[1001000],ifac[1001000];\nll C(int n,int m){return fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nint main(){\n\tcin>>n>>m;\n\tfac[0]=1;\n\tfor(int i=1;i<=1000000;i++) fac[i]=fac[i-1]*i%mod;\n\tifac[1000000]=fp(fac[1000000],mod-2);\n\tfor(int i=1000000;i;i--) ifac[i-1]=ifac[i]*i%mod;\n\tll ans=0;\n\tfor(int i=0;i<=min(n,m);i++)\n\t\tans=(ans+(i&1?-1:1)*C(n,i)*C(m,i)%mod*fac[i]%mod*fp(n+1,m-i)%mod*fp(m+1,n-i))%mod;\n\tcout<<(ans+mod)%mod<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937 mrand(random_device{}());\n\n#define rep(i , l , r) for (int i = (l); i < (r); ++i)\n\nconst int N = 5e5 + 5;\nconst int mod = 998244353;\n\nint n , m , mx , mn;\nint cm[N] , cn[N] , fac[N] , ifac[N];\n\ntemplate <typename T> inline void chkmin(T &x , T y) { x = min(x , y); }\ntemplate <typename T> inline void chkmax(T &x , T y) { x = max(x , y); }\ntemplate <typename T> inline void read(T &x) {\n   T f = 1; x = 0;\n   char c = getchar();\n   for (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n   for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';\n   x *= f;\n}\n\ninline void inc(int &x , int y) {\n\tx = x + y < mod ? x + y : x + y - mod;\n}\ninline void dec(int &x , int y) {\n\tx = x - y >= 0 ? x - y : x - y + mod;\n}\ninline int binom(int n , int m) {\n\tif (n < m) return 0;\n\telse return 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\ninline int quickpow(int a , int n) {\n\tint res = 1;\n\tfor (; n; n >>= 1 , a = 1LL * a * a % mod)\n\t\tif (n & 1) res = 1LL * res * a % mod;\n\treturn res;\n}\nint main() {\n   \t\n   \tread(n); read(m); mx = max(m , n); mn = min(m , n);\n   \tfac[0] = 1;\n   \tfor (int i = 1; i <= mx; ++i) fac[i] = 1LL * fac[i - 1] * i % mod;\n   \tifac[mx] = quickpow(fac[mx] , mod - 2);\n   \tfor (int i = mx - 1; i >= 0; --i) ifac[i] = 1LL * ifac[i + 1] * (i + 1) % mod;\n   \tcm[0] = cn[0] = 1;\n   \tfor (int i = 1; i <= mx; ++i) cm[i] = 1LL * cm[i - 1] * (m + 1) % mod;\n   \tfor (int i = 1; i <= mx; ++i) cn[i] = 1LL * cn[i - 1] * (n + 1) % mod;\n   \tint ans = 0;\n   \tfor (int i = 0; i <= mn; ++i) {\n   \t\tint val = 1LL * binom(n , i) * binom(m , i) % mod * cm[n - i] % mod * cn[m - i] % mod * fac[i] % mod;\n   \t\tif (i & 1) dec(ans , val); else inc(ans , val);\t\n\t}\n\tprintf(\"%d\\n\" , ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define LL long long\nusing namespace std;\nint n,m;\nLL ans;\nconst int N=500010,mod=998244353;\nLL jc[N],inv[N];\nLL ksm(LL a,LL b,LL mod)\n{\n\tLL res=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)res=res*a%mod;\n\treturn res;\n}\nvoid YYCH()\n{\n\tjc[0]=jc[1]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=m;++i)jc[i]=jc[i-1]*i%mod;\n\tinv[m]=ksm(jc[m],mod-2,mod);\n\tfor(int i=m-1;i>=1;--i)inv[i]=inv[i+1]*(i+1)%mod;\n}\nLL C(int n,int m){return jc[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\tcin>>n>>m;if(n>m)swap(n,m);YYCH();\n\tfor(int i=0;i<=n;++i)\n\t\t(ans+=(LL)(i&1?-1:1)*C(n,i)*C(m,i)%mod*jc[i]%mod*ksm(m+1,n-i,mod)%mod*ksm(n+1,m-i,mod))%=mod;\n\tcout<<(ans%mod+mod)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N (500010)\n#define P (998244353)\nusing namespace std;\nint ksm(int a,int p){int res=1;for(;p;p>>=1,a=1ll*a*a%P)if(p&1)res=1ll*res*a%P;return res;}\nint n,m,jc[N],inv[N],ans;\nint C(int n,int m){return 1ll*jc[n]*inv[m]%P*inv[n-m]%P;}\nint main(){\n\tscanf(\"%d%d\",&n,&m),jc[0]=inv[0]=1;\n\tfor(int i=1;i<=max(n,m);i++)jc[i]=1ll*jc[i-1]*i%P,inv[i]=ksm(jc[i],P-2);\n\tfor(int i=0;i<=min(n,m);i++)(ans+=((i&1)?-1ll:1ll)*C(n,i)%P*C(m,i)%P*jc[i]%P*ksm(n+1,m-i)%P*ksm(m+1,n-i)%P)%=P;\n\tprintf(\"%d\\n\",ans<0?ans+P:ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\n#define spln(i,n) (i==n?'\\n':' ')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nconst int mod=998244353;\nint n,m,i,j,fac[500005],inv[500005],fi[500005],ans;\nint c(int x,int y)\n{\n\treturn 1ll*fac[x]*fi[y]%mod*fi[x-y]%mod; \n}\nint qp(int x,int y)\n{\n\tint z=1;\n\twhile(y){\n\t\tif(y&1){\n\t\t\tz=1ll*z*x%mod;\n\t\t}\n\t\tx=1ll*x*x%mod;\n\t\ty/=2;\n\t}\n\treturn z;\n}\nint main()\n{\n\tfac_init(500002);\n\tread(n);read(m);\n\tfz0g(i,min(n,m)){\n\t\tint tmp=1ll*c(n,i)*c(m,i)%mod*fac[i]%mod*qp(m+1,n-i)%mod*qp(n+1,m-i)%mod;\n\t\tif(i&1)dec(ans,tmp) else inc(ans,tmp);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct ModInt{\n\tuint a;\n\tModInt& s(uint vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n    ModInt(ll x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){\n\t\treturn s(a+x.a);\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\treturn s(a+mod-x.a);\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=ull(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=998244353;\nconst int MAXN=500010, LOG=20;\n\nll n, m, k, u, v, x, y, t, a, b, ans;\nll F[MAXN], I[MAXN];\n\nll powmod(ll a, ll b){\n\tll res=1;\n\tfor (; b; b>>=1, a=a*a%mod) if (b&1) res=res*a%mod;\n\treturn res;\n}\n\nll nCr(ll n, ll r){\n\tif (r<0 || r>n) return 0;\n\treturn F[n]*I[r]%mod*I[n-r]%mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tF[0]=1;\n\tfor (int i=1; i<MAXN; i++) F[i]=F[i-1]*i%mod;\n\tI[MAXN-1]=powmod(F[MAXN-1], mod-2);\n\tfor (int i=MAXN-1; i; i--) I[i-1]=I[i]*i%mod;\n\tcin>>n>>m;\n\tfor (int i=0; i<=min(n, m); i++){\n\t\tll tmp=nCr(n, i)*nCr(m, i)%mod*F[i]%mod;\n\t\ttmp=tmp*powmod(n+1, m-i)%mod*powmod(m+1, n-i)%mod;\n\t\tif (i&1) tmp*=-1;\n\t\tans=(ans + tmp)%mod;\n\t}\n\tif (ans<0) ans+=mod;\n\tcout<<ans<<\"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=998244353;\nint n,m;\nll ans=0;\nll fac[500005],inv[500005];\n\nll C(ll x,ll y){return x<y?0:fac[x]*inv[y]%cys*inv[x-y]%cys;}\n\nll qpow(ll x,ll p){\n\tll ret=1;\n\tfor(;p;p>>=1,x=x*x%cys) if(p&1) ret=ret*x%cys;\n\treturn ret;\n}\n\nint main(){\n\tn=readint(); m=readint();\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=max(n,m);i++) fac[i]=fac[i-1]*i%cys;\n\tinv[max(n,m)]=qpow(fac[max(n,m)],cys-2);\n\tfor(int i=max(n,m)-1;i>=1;i--) inv[i]=inv[i+1]*(i+1)%cys;\n\tfor(int i=0;i<=min(n,m);i++) ans=(ans+(i&1?cys-1:1)*C(n,i)%cys*C(m,i)%cys*fac[i]%cys*qpow(m+1,n-i)%cys*qpow(n+1,m-i)%cys)%cys;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m;\nlong long inv[100010];\nlong long qpow(long long a,long long b){\n\tlong long ans=1,base=a;\n\twhile(b){\n\t\tif(b&1){\n\t\t\tans*=base;\n\t\t\tans%=998244353;\n\t\t}\n\t\tbase*=base;\n\t\tbase%=998244353;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nlong long cn[100010];\nlong long cm[100010];\nlong long ans;\nlong long jc[100010];\nlong long m_[100010];\nlong long n_[100010];\nint main(){\n\tcin>>n>>m;\n\tinv[1]=1;\n\tfor(long long i=2;i<=max(n,m);i++){\n\t\tinv[i]=(998244353ll-998244353ll/i)*inv[998244353ll%i]%998244353ll;\n\t}\n\tjc[0]=jc[1]=1;\n\tfor(long long i=2;i<=max(n,m);i++){\n\t\tjc[i]=jc[i-1]*i%998244353ll;\n\t}\n\tcn[0]=1;\n\tfor(long long i=0;i<n;i++){\n\t\tcn[i+1]=cn[i]*(n-i)%998244353ll*inv[i+1]%998244353ll;\n\t}\n\tcm[0]=1;\n\tfor(long long i=0;i<m;i++){\n\t\tcm[i+1]=cm[i]*(m-i)%998244353ll*inv[i+1]%998244353ll;\n\t}\n\tm_[0]=n_[0]=1;\n\tfor(long long i=1;i<=max(m,n);i++){\n\t\tm_[i]=m_[i-1]*(m+1)%998244353ll;\n\t\tn_[i]=n_[i-1]*(n+1)%998244353ll;\n\t}\n\tfor(long long i=0;i<=min(n,m);i++){\n\t\tlong long s=cn[i]*cm[i]%998244353ll*jc[i]%998244353ll*m_[n-i]%998244353ll*n_[m-i]%998244353ll;\n\t\tans=i&1?(ans-s):(ans+s);\n\t\tans=(ans%998244353ll+998244353ll)%998244353ll;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\nusing namespace std;\nconst int P=998244353;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n    R int res=1;\n    for(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n    return res;\n}\nconst int N=5e5+5;\nint fac[N],ifac[N],bin[2][N],n,m,res,d;\ninline int C(R int n,R int m){return 1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\ninline int A(R int n,R int m){return mul(fac[n],ifac[n-m]);}\nvoid init(){\n\tif(n>m)swap(n,m);\n\tbin[0][0]=bin[1][0]=fac[0]=ifac[0]=1;\n\tfp(i,1,m){\n\t\tfac[i]=mul(fac[i-1],i),\n\t\tbin[0][i]=mul(bin[0][i-1],m+1),\n\t\tbin[1][i]=mul(bin[1][i-1],n+1);\n\t}\n\tifac[m]=ksm(fac[m],P-2);\n\tfd(i,m-1,1)ifac[i]=mul(ifac[i+1],i+1);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m),init();\n\tfp(i,0,n){\n\t\td=1ll*C(n,i)*A(m,i)%P*bin[0][n-i]%P*bin[1][m-i]%P;\n\t\tupd(res,(i&1)?P-d:d);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct ModInt{\n\tuint a;\n    ModInt(ll x=0):a((x+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\ta=a<mod?a:a-mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n\t\ta=a<mod?a:a-mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=ull(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n  if(abs(a) < eps && abs(b) < eps) return 0;\n  else if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n  if(a < b) return -1;\n  return 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n  if(a < b) return -1;\n  if(a == b) return 0;\n  return 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n  if(na == 0) return 0;\n  int be = 0, en = na - 1;\n  if(*a <= *(a + na - 1)){\n    if(f_lb == 0) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != 1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != -1) en = mid;\n      else be = mid + 1;\n    }\n    if(f_small && jud(*(a + be), val) == 1) be--;\n    if(!f_small && jud(*(a + be), val) == -1) be++;\n  } else {\n    if(f_lb) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != -1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != 1) en = mid;\n      else be = mid + 1;\n    }\n    if(!f_small && jud(*(a + be), val) == -1) be--;\n    if(f_small && jud(*(a + be), val) == 1) be++;\n  }\n  return be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n  if(m < 0) return 0;\n  long long ans = 1;\n  long long k = n;\n  while(m){\n    if(m & 1) {\n      ans *= k;\n      if(mod) ans %= mod;\n    }\n    k *= k;\n    if(mod) k %= mod;\n    m >>= 1;\n  }\n  return ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n  if(mod == -1) mod = MOD;\n  a += b;\n  while(a >= mod) a -= mod;\n  while(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    cerr << arr[i] << ' ';\n  cerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    output1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 500100;\nconst int mod = 998244353;\nint n, m;\nll fac[maxn], invfac[maxn];\n\nll c(int a, int b) {\n  if (a < b) return 0;\n  return fac[a] * invfac[b] % mod * invfac[a - b] % mod;\n}\n\nint main() {\n  //............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！........................................\n  ios_base::sync_with_stdio(0);\n  #ifdef DEBUG //......................................................................................................\n  freopen(\"input.txt\", \"r\", stdin);\n  #endif //...........................................................................................................\n\n  scanf(\"%d%d\", &n, &m);\n  if (n > m) swap(n, m);\n  fac[0] = 1;\n  for (int i = 1; i < maxn; i++) fac[i] = fac[i - 1] * i % mod;\n  invfac[maxn - 1] = pow(fac[maxn - 1], mod - 2, mod);\n  for (int i = maxn - 1; i > 0; i--) invfac[i - 1] = invfac[i] * i % mod;\n  ll ans = 0;\n  for (int i = 0; i <= n; i++) {\n    ll f = bool((i + 1) % 2) * 2 - 1;\n    ans += f * c(n, i) % mod * c(m, i) % mod * fac[i] % mod * pow(m + 1, n - i, mod) % mod * pow(n + 1, m - i, mod) % mod;\n    ans %= mod;\n  }\n  cout << (ans + mod) % mod << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nconst int inv2=(mod+1)>>1;\n\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\n\nint add(int a,int b) {\n    return a+b>=mod?a+b-mod:a+b;\n}\n\nint sub(int a,int b) {\n    return a-b<0?a-b+mod:a-b;\n}\n\nint mul(int a,int b) {\n    return 1ll*a*b%mod;\n}\n\nint qpow(int a,int b) {\n    int ret=1;\n    while(b) {\n        if(b&1) ret=mul(ret,a);\n        a=mul(a,a),b>>=1;\n    }\n    return ret;\n}\n\nvector<int> padd(vector<int> a,vector<int> b) {\n    if(a.size()<b.size()) a.resize(b.size());\n    for(int i=0;i<b.size();i++) a[i]=add(a[i],b[i]);\n    return a;\n}\n\nvector<int> psub(vector<int> a,vector<int> b) {\n    if(a.size()<b.size()) a.resize(b.size());\n    for(int i=0;i<b.size();i++) a[i]=sub(a[i],b[i]);\n    return a;\n}\n\nint www[1000010];\n\nvector<int> pmul(vector<int> a,vector<int> b) {\n    int n=a.size(),m=b.size(),l=0;\n    if(n<70||m<70) {\n        vector<int> ret(n+m-1);\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++) ret[i+j]=add(ret[i+j],mul(a[i],b[j]));\n        return ret;\n    }\n    m=n+m-1;for(n=1;n<m;n<<=1) ++l;\n    vector<int> r(n);\n    for(int i=0;i<n;i++) r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n    auto dft=[&](vector<int> &a,int f) {\n        for(int i=0;i<n;i++) if(i<r[i]) swap(a[i],a[r[i]]);\n        for(int i=1;i<n;i<<=1) {\n            int wn=qpow(3,(mod-1)/(i<<1));\n\t\t\tif(f==-1) wn=qpow(wn,mod-2);\n\t\t\tint *P=www;*P=1;\n\t\t\tfor(int j=1;j<i;j++) *(P+j)=1ll**(P+j-1)*wn%mod;\n            for(int p=i<<1,j=0;j<n;j+=p) {\n                for(int k=0;k<i;k++) {\n                    int x=a[j+k],y=mul(*(P+k),a[j+k+i]);\n                    a[j+k]=add(x,y),a[j+k+i]=sub(x,y);\n                }\n            }\n        }\n        if(f==-1) {\n            int inv=qpow(n,mod-2);\n            for(int i=0;i<n;i++) a[i]=mul(a[i],inv);\n        }\n    };\n    a.resize(n),b.resize(n);\n    dft(a,1),dft(b,1);\n    for(int i=0;i<n;i++) a[i]=mul(a[i],b[i]);\n    dft(a,-1);\n    a.resize(m);return a;\n}\n\nint get2(int n) {\n    int ret=1;\n    while(ret<n) ret<<=1;\n    return ret;\n}\n\nvector<int> pinv(vector<int> a,int n) {\n    if(n==1) return vector<int>(1,qpow(a[0],mod-2));\n    auto rem_a=a;rem_a.resize(n>>1);\n    auto b=pinv(rem_a,n>>1);\n    auto ret=pmul(a,b);ret.resize(n);\n    ret=pmul(ret,b);ret.resize(n);\n    ret=psub(pmul(b,vector<int>(1,2)),ret);\n    return ret;\n}\n\nvector<int> pder(vector<int> a) {\n    for(int i=1;i<a.size();i++) a[i-1]=mul(i,a[i]);\n    a.pop_back();\n    return a;\n}\n\nvector<int> pint(vector<int> a) {\n    vector<int> inv(a.size()+1);\n    inv[1]=1;for(int i=2;i<inv.size();i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    a.push_back(0);\n    for(int i=a.size()-2;~i;i--) a[i+1]=mul(inv[i+1],a[i]);\n    a[0]=0;\n    return a;\n}\n\nvector<int> pln(vector<int> a,int n) {\n    auto ret=pder(a);\n    ret=pmul(ret,pinv(a,n));\n    ret.resize(n);\n    ret=pint(ret);\n    ret.resize(n);\n    return ret;\n}\n\nnamespace Exp {\n\n\tint w[1000010],r[1000010],F[1000010],G[1000010],A[1000010],B[1000010],len,inv[1000010];\n\n\tvoid inc(int &a,int b) {\n\t\ta=a+b>=mod?a+b-mod:a+b;\n\t}\n\n\tvoid dec(int &a,int b) {\n\t\ta=a-b<0?a-b+mod:a-b;\n\t}\n\n\tvoid NTT(int *a,int f) {\n\t\tfor(int i=0;i<len;i++) if(i<r[i]) swap(a[i],a[r[i]]);\n\t\tfor(int i=1;i<len;i<<=1) {\n\t\t\tint wn=qpow(3,(mod-1)/(i<<1));\n\t\t\tint *W=w;*W=1;for(int j=1;j<i;j++) *(W+j)=1ll**(W+j-1)*wn%mod;\n\t\t\tfor(int p=i<<1,j=0;j<len;j+=p)\n\t\t\t\tfor(int k=0;k<i;k++) {\n\t\t\t\t\tint x=a[j+k],y=1ll**(W+k)*a[j+k+i]%mod;\n\t\t\t\t\ta[j+k]=x+y>=mod?x+y-mod:x+y;\n\t\t\t\t\ta[j+k+i]=x-y<0?x-y+mod:x-y;\n\t\t\t\t}\n\t\t}\n\t\tif(f==-1) {\n\t\t\treverse(a+1,a+len);\n\t\t\tint inv=qpow(len,mod-2);\n\t\t\tfor(int i=0;i<len;i++) a[i]=1ll*a[i]*inv%mod;\n\t\t}\n\t}\n\n\tvoid init() {\n\t\tint l=__builtin_ctz(len);\n\t\tfor(int i=0;i<len;i++) r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n\t}\n\n\tvoid init_inv() {\n\t\tinv[1]=1;\n\t\tfor(int i=2;i<1000010;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t}\n\t\n\tvoid solve(int l,int r) {\n\t\tif(l==r) {\n\t\t\tif(l) G[l]=1ll*G[l]*inv[l]%mod;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tsolve(l,mid);\n\t\tif(r-l<200) {\n\t\t\tfor(int i=mid+1;i<=r;i++)\n\t\t\t\tfor(int j=l;j<=mid;j++) G[i]=(G[i]+1ll*G[j]*F[i-j]%mod*(i-j))%mod;\n\t\t}\n\t\telse {\n\t\t\tlen=1;while(len<=r-l) len<<=1;init();\n\t\t\tfor(int i=0;i<len;i++) A[i]=B[i]=0;\n\t\t\tfor(int i=l;i<=mid;i++) A[i-l]=G[i];\n\t\t\tfor(int i=0;i<=r-l;i++) B[i]=1ll*i*F[i]%mod;\n\t\t\tNTT(A,1);NTT(B,1);\n\t\t\tfor(int i=0;i<len;i++) A[i]=1ll*A[i]*B[i]%mod;\n\t\t\tNTT(A,-1);\n\t\t\tfor(int i=mid+1;i<=r;i++) inc(G[i],A[i-l]);\n\t\t}\n\t\tsolve(mid+1,r);\n\t}\n\n}\n\nvector<int> pexp(vector<int> a,int n) {\n\ta.resize(n);\n\tfor(int i=0;i<n;i++) Exp::F[i]=a[i];\n\tExp::G[0]=1;Exp::solve(0,n-1);\n\tfor(int i=0;i<n;i++) a[i]=Exp::G[i];\n\treturn a;\n}\n\nvector<int> pqpow(vector<int> a,int k,int n) {\n\tint t=a[0];\n\tfor(auto &x:a) x=1ll*x*qpow(t,mod-2)%mod;\n\tvector<int> c=pln(a,n);\n\tfor(auto &x:c) x=1ll*x*k%mod;\n\tc=pexp(c,n);\n\tfor(auto &x:c) x=1ll*x*qpow(t,k)%mod;\n\treturn c;\n}\n\nint fac[1000010];\n\nint main() {\n\tint n=gi(),m=gi();Exp::init_inv();\n\tfac[0]=1;for(int i=1;i<=m;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tvector<int> G(m+1);\n\tfor(int i=0;i<=m;i++) G[i]=1ll*(m+1-i)*qpow(fac[i],mod-2)%mod;\n\tvector<int> F=pqpow(G,n,get2(m+1));\n\tint ans=0;\n\tfor(int i=0;i<=m;i++) ans=(ans+1ll*F[i]*qpow(fac[m-i],mod-2))%mod;\n\tans=1ll*ans*fac[m]%mod;\n\tcout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 500050\n#define mod 998244353\nint fr[N],ifr[N],n,m,as;\nint pw(int a,int p){int as=1;while(p){if(p&1)as=1ll*as*a%mod;a=1ll*a*a%mod;p>>=1;}return as;}\nint main()\n{\n\tfr[0]=ifr[0]=1;for(int i=1;i<=5e5;i++)fr[i]=1ll*fr[i-1]*i%mod,ifr[i]=pw(fr[i],mod-2);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<=n&&i<=m;i++)as=(as+1ll*(i&1?mod-1:1)*fr[n]%mod*ifr[i]%mod*ifr[n-i]%mod*fr[m]%mod*ifr[m-i]%mod*pw(m+1,n-i)%mod*pw(n+1,m-i))%mod;\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 5e5 + 100;\nconst int Mod = 998244353;\n\nnamespace MATH\n{\n\tint fac[Maxn], ifac[Maxn];\n\n\tinline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n\n\tinline void init (int n = 5e5)\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % Mod;\n\t\tifac[n] = Pow (fac[n], Mod - 2);\n\t\tfor (int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % Mod;\n\t}\n\n\tinline int C (int n, int m) { if (n < m) return 0; return (LL) fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n}\n\nusing namespace MATH;\n\nint N, M;\n\ninline void Solve ()\n{\n\tint ans = 0;\n\tfor (int k = 0; k <= min (N, M); ++k)\n\t{\n\t\tint sum = (LL) C (N, k) * C (M, k) % Mod * fac[k] % Mod * Pow (M + 1, N - k) % Mod * Pow (N + 1, M - k) % Mod;\n\t\tif (k & 1) Add (ans, Mod - sum);\n\t\telse Add (ans, sum);\n\t}\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tMATH :: init ();\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int mo=998244353;\nconst int N=500005;\nint fac[N],inv[N],n,m;\nvoid init(){\n\tfac[0]=inv[0]=inv[1]=1;\n\tFor(i,2,N-1) inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;\n\tFor(i,1,N-1) inv[i]=1ll*inv[i-1]*inv[i]%mo;\n\tFor(i,1,N-1) fac[i]=1ll*fac[i-1]*i%mo;\n}\nint C(int x,int y){\n\tif (x<0||y<0||y>x) return 0;\n\treturn 1ll*fac[x]*inv[y]%mo*inv[x-y]%mo;\n}\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tint ans=0;\n\tFor(i,0,min(n,m)){\n\t\tint val=1ll*C(n,i)*C(m,i)%mo*fac[i]%mo;\n\t\tval=1ll*val*power(m+1,n-i)%mo;\n\t\tval=1ll*val*power(n+1,m-i)%mo;\n\t\tans=(ans+(i&1?mo-val:val))%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5e5 + 5;\nconst int P = 998244353;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint fac[MAXN], inv[MAXN];\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\telse return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\tinv[n] = power(fac[n], P - 2);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1ll) % P;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint main() {\n\tint n, m; read(n), read(m);\n\tinit(max(n, m));\n\tint ans = 0;\n\tfor (int i = 0; i <= min(n, m); i++)\n\t\tif (i & 1) update(ans, P - 1ll * binom(n, i) * binom(m, i) % P * fac[i] % P * power(n + 1, m - i) % P * power(m + 1, n - i) % P);\n\t\telse update(ans, 1ll * binom(n, i) * binom(m, i) % P * fac[i] % P * power(n + 1, m - i) % P * power(m + 1, n - i) % P);\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int Mod=998244353;\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(long long)ans*t%Mod;\n\t\tt=(long long)t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[500010],inv[500010];\nint C(int x,int y)\n{\n\tif(x<0||y<0||x-y<0)return 0;\n\treturn (long long)fac[x]*inv[y]%Mod*inv[x-y]%Mod;\n}\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tint N=max(n,m);\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=(long long)fac[i-1]*i%Mod;\n\tinv[N]=fpow(fac[N],Mod-2)%Mod;\n\tfor(int i=N;i>=1;i--)\n\t\tinv[i-1]=(long long)inv[i]*i%Mod;\n\tint ans=0;\n\tfor(int i=0;i<=min(n,m);i++)\n\t{\n\t\tint sum=(long long)C(n,i)*C(m,i)%Mod*fac[i]%Mod*fpow(n+1,m-i)%Mod*fpow(m+1,n-i)%Mod;\n\t\tif(i&1)ans=(ans-sum+Mod)%Mod;\n\t\telse ans=(ans+sum)%Mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nll pow_mod(ll x,int k) {\n  ll ans=1;\n  while (k) {\n  \tif (k&1) ans=ans*x%MOD;\n  \tx=x*x%MOD;\n  \tk>>=1;\n  }\n  return ans;\n}\n\nll facd[500005],facv[500005];\n\nvoid pre(int n) {\n  facd[0]=1;\n  for(int i=1;i<=n;i++) facd[i]=facd[i-1]*i%MOD;\n  facv[n]=pow_mod(facd[n],MOD-2);\n  for(int i=n-1;i>=0;i--) facv[i]=facv[i+1]*(i+1)%MOD;\n}\n\ninline ll C(int n,int m) {\n  return (n<m)?0:facd[n]*facv[m]%MOD*facv[n-m]%MOD;\n}\n\nint main() {\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  pre(max(n,m));\n  int ans=0;\n  ll s1=pow_mod(n+1,m),s2=pow_mod(m+1,n),inv1=pow_mod(n+1,MOD-2),inv2=pow_mod(m+1,MOD-2);\n  for(int i=0;i<=min(n,m);i++) {\n    ans=(ans+C(n,i)*C(m,i)%MOD*facd[i]%MOD*((i&1)?MOD-1:1)%MOD*s1%MOD*s2)%MOD;\n    s1=s1*inv1%MOD;\n    s2=s2*inv2%MOD;\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 500010\n#define mod 998244353\nusing namespace std;\ntypedef long long ll;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,m,mx,mn;\nint ci_n[maxn],ci_m[maxn];\nint fac[maxn],inv[maxn];\nint quick_pow(int x,int p)\n{\n    int an=1,po=x;\n    while(p)\n    {\n        if(p&1)  an=1ll*an*po%mod;\n        po=1ll*po*po%mod;\n        p>>=1;\n    }\n    return an;\n}\nint ans;\nvoid add(int &x,int y)\n{\n    x=(x+y>=mod)?x+y-mod:x+y;\n}\nint C(int x,int y)\n{\n    return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n    n=read();m=read();mx=max(n,m);mn=min(n,m);\n    fac[0]=1;\n    for(int i=1;i<=mx;i++)  fac[i]=1ll*fac[i-1]*i%mod;\n    inv[mx]=quick_pow(fac[mx],mod-2);\n    for(int i=mx-1;i>=0;i--)  inv[i]=1ll*inv[i+1]*(i+1)%mod;\n    ci_m[0]=ci_n[0]=1;\n    for(int i=1;i<=n;i++)  ci_m[i]=1ll*ci_m[i-1]*(m+1)%mod;\n    for(int i=1;i<=m;i++)  ci_n[i]=1ll*ci_n[i-1]*(n+1)%mod;\n    for(int i=0;i<=mn;i++)\n    {\n        int tmp=1ll*C(n,i)*C(m,i)%mod*fac[i]%mod*ci_m[n-i]%mod*ci_n[m-i]%mod;\n        add(ans,(i&1)?mod-tmp:tmp);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define N 500012\n#define mod 998244353\ninline int M(int x){return (x>=mod)?(x-mod):x;}\ninline int M1(int x){return (x<0)?(x+mod):x;}\ninline int ksm(int p,int k){int res=1;while(k){if(k&1)res=1ll*res*p%mod;k>>=1;p=1ll*p*p%mod;}return res;}\nint n,m,fac[N],inv[N],P1[N],P2[N],ans=0;\ninline int C(int n,int m){if(m>n)return 0;return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main(){\n\tfac[0]=1;for(int i=1;i<N;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[N-1]=ksm(fac[N-1],mod-2);for(int i=N-2;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tscanf(\"%d%d\",&n,&m);int i;\n\tP1[0]=1;for(i=1;i<N;i++)P1[i]=1ll*P1[i-1]*(n+1)%mod;\n\tP2[0]=1;for(i=1;i<N;i++)P2[i]=1ll*P2[i-1]*(m+1)%mod;\n\tfor(i=0;i<=min(n,m);i++)ans=(ans+1ll*((i&1)?(mod-1):1)*C(n,i)%mod*C(m,i)%mod*fac[i]%mod*P1[m-i]%mod*P2[n-i])%mod;printf(\"%d\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll; \ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n \ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n \n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n \n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n \n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n \n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n \n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n \n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n \n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n \n private:\n  Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n \ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n \ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n \ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n \ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n \ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n \ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n \ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n \n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n \nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n \nvector<Mint> fact;\nvector<Mint> inv_fact;\n \ntemplate <typename T>\nclass NTT {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  static Type md;\n  static Modular<T> root;\n  static int base;\n  static int max_base;\n  static vector<Modular<T>> roots;\n  static vector<int> rev;\n \n  static void clear() {\n    root = 0;\n    base = 0;\n    max_base = 0;\n    roots.clear();\n    rev.clear();\n  }\n \n  static void init() {\n    md = T::value;\n    assert(md >= 3 && md % 2 == 1);\n    auto tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (md - 1) >> 1) == 1) {\n      root++;\n    }\n    assert(power(root, md - 1) == 1);\n    root = power(root, (md - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n \n  static void ensure_base(int nbase) {\n    if (md != T::value) {\n      clear();\n    }\n    if (roots.empty()) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = roots[i] * z;\n      }\n      base++;\n    }\n  }\n \n  static void fft(vector<Modular<T>> &a) {\n    int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          Modular<T> x = a[i + j];\n          Modular<T> y = a[i + j + k] * roots[j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n \n  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n    if (a.empty() || b.empty()) {\n      return {};\n    }\n    int eq = (a == b);\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq) b = a; else fft(b);\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] *= b[i] * inv_sz;\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n};\n \ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\n \ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<Modular<T>> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x.resize(b.size() << 1);\n    b.resize(b.size() << 1);\n    vector<Modular<T>> c = b;\n    NTT<T>::fft(c);\n    NTT<T>::fft(x);\n    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n    fill(x.begin() + (x.size() >> 1), x.end(), 0);\n    NTT<T>::fft(x);\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    for (int i = 0; i < ((int) x.size() >> 1); i++) {\n      b[i + ((int) x.size() >> 1)] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  if (n == 1) {\n    return {1 / a[0]};\n  }\n  int m = (n + 1) >> 1;\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n  int need = n << 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    ++nbase;\n  }\n  NTT<T>::ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  NTT<T>::fft(a);\n  NTT<T>::fft(b);\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n  for (int i = 0; i < size; ++i) {\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  NTT<T>::fft(a);\n  a.resize(n);\n  return a;\n}\n \ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (min(a.size(), b.size()) < 150) {\n    vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        c[i + j] += a[i] * b[j];\n      }\n    }\n    return c;\n  }\n  return NTT<T>::multiply(a, b);\n}\n \ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  return a = a * b;\n}\n \ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n \ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n \ntemplate <typename T>\nvector<T> operator-(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] = -c[i];\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  vector<T> c(a.size() + b.size() - 1, 0);\n  for (int i = 0; i < (int) a.size(); i++) {\n    for (int j = 0; j < (int) b.size(); j++) {\n      c[i + j] += a[i] * b[j];\n    }\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  return a = a * b;\n}\n \ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> x = b * b * a_cut;\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n \ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n \ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T>{1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n \ntemplate <typename T>\nvector<T> derivative(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] *= i;   \t\n  }\n  if (!c.empty()) {\n    c.erase(c.begin());\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> primitive(const vector<T>& a) {\n  vector<T> c = a;\n  c.insert(c.begin(), 0);\n  for (int i = 1; i < (int) c.size(); i++) {\n    c[i] /= i;\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> logarithm(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 1);\n  vector<T> u = primitive(derivative(a) * inverse(a));\n  u.resize(a.size());\n  return u;\n}\n \ntemplate <typename T>\nvector<T> exponent(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 0);\n  int n = (int) a.size();\n  vector<T> b = {1};\n  while ((int) b.size() < n) {\n    vector<T> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x[0] += 1;\n    vector<T> old_b = b;\n    b.resize(b.size() << 1);\n    x -= logarithm(b);\n    x *= old_b;\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<T> multiply(const vector<vector<T>>& a) {\n  if (a.empty()) {\n    return {0};\n  }\n  function<vector<T>(int, int)> mult = [&](int l, int r) {\n    if (l == r) {\n      return a[l];\n    }\n    int y = (l + r) >> 1;\n    return mult(l, y) * mult(y + 1, r);\n  };\n  return mult(0, (int) a.size() - 1);\n}\n\nstruct Combi\n{\n\tvector<int> fact;\n\tvector<int> ifact;\n\tvector<int> inv;\n\tvector<int> pow2;\n\tconst int MOD = 998244353;\n\tint add(int a, int b)\n\t{\n\t\ta+=b;\n\t\twhile(a>=MOD) a-=MOD;\n\t\treturn a;\n\t}\n\tint mult(int a, int b)\n\t{\n\t\treturn (a*1LL*b)%MOD;\n\t}\n\tint modpow(int a, int b)\n\t{\n\t\tif(b<0) return 0;\n\t\tint r=1;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1) r=mult(r,a);\n\t\t\ta=mult(a,a);\n\t\t\tb>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tint choose(int a, int b)\n\t{\n\t\tif(a<b) return 0;\n\t\tif(b==0) return 1;\n\t\tif(a==b) return 1;\n\t\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n\t}\n\tint inverse(int a)\n\t{\n\t\treturn modpow(a,MOD-2);\n\t}\n\tvoid init(int _n)\n\t{\n\t\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\t\tfact.resize(_n+1);\n\t\tifact.resize(_n+1);\n\t\tinv.resize(_n+1);\n\t\tpow2.resize(_n+1);\n\t\tpow2[0]=1;\n\t\tifact[0]=1;\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\t\tfact[i]=mult(fact[i-1],i);\n\t\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t\t}\n\t\tifact[_n] = inverse(fact[_n]);\n\t\tfor(int i=_n-1;i>=1;i--)\n\t\t{\n\t\t    ifact[i] = mult(ifact[i + 1], i + 1);\n\t\t}\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t    inv[i] = mult(fact[i-1],ifact[i]);\n\t\t}\n\t}\n};\nCombi combi;\nconst int MOD = 998244353;\n\nint mod_pow(int a, int n, int mod) { int ret = 1; while (n) { if (n & 1) ret = ret *1LL* a % mod; a = a *1LL* a % mod; n >>= 1; } return ret; }\nint inv(int n){return mod_pow(n,MOD-2,MOD);}\nconst int LG = 22;\nconst int root_pw = (1<<LG);\nint iprt,prt;\n \nvoid fft (vector<int> & a, bool invert) \n{\n\tint n = (int) a.size();\n \n\tfor (int i=1, j=0; i<n; ++i) {\n\t\tint bit = n >> 1;\n\t\tfor (; j>=bit; bit>>=1)\n\t\t\tj -= bit;\n\t\tj += bit;\n\t\tif (i < j)\n\t\t\tswap (a[i], a[j]);\n\t}\n \n\tfor (int len=2; len<=n; len<<=1) {\n\t\tint wlen = invert ? iprt : prt;\n\t\tfor (int i=len; i<root_pw; i<<=1)\n\t\t\twlen = int((wlen*1LL*wlen)%MOD);\n\t\tfor (int i=0; i<n; i+=len) {\n\t\t\tint w = 1;\n\t\t\tfor (int j=0; j<len/2; ++j) {\n\t\t\t\tint u = a[i+j]; int v = int((a[i+j+len/2]*1LL*w)%MOD);\n\t\t\t\ta[i+j] = u+v < MOD ? u+v : u+v-MOD;\n\t\t\t\ta[i+j+len/2] = u-v >= 0 ? u-v : u-v+MOD;\n\t\t\t\tw = int (w * 1LL * wlen % MOD);\n\t\t\t}\n\t\t}\n\t}\n\tif (invert) {\n\t\tll nrev = inv(n);\n\t\tfor (int i=0; i<n; ++i)\n\t\t\ta[i] = int((a[i]*1LL*nrev)%MOD);\n\t}\n}\n \nvoid multiply(vector<int>& a, vector<int>& b, vector<int>& res)\n{\n\tvector<int> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n\tint n = 1;\n\twhile(n < max(a.size(), b.size())) n <<= 1;\n\tfa.resize(n); fb.resize(n);\n\tfft(fa, 0); fft(fb, 0);\n\tres.resize(n);\n\tfor(int i = 0; i < n; i++) \n\t{\n\t\tres[i] = int((fa[i]*1LL*fb[i])%MOD);\n\t}\n\tfft(res, 1);\n}\n \nvector<int> inverse(vector<int> &a, int deg) //returns a 2^{deg} polynomial\n{\n\tvector<int> h[2];\n\th[0].pb(mod_pow(a[0],MOD-2,MOD));\n\tint cur=0; int pre=1;\n\tfor(int i=0;i<deg;i++) //after this it'll be of size 2^{deg}\n\t{\n\t\tcur^=1; pre^=1;\n\t\th[cur].resize((1<<(i+1)));\n\t\th[pre].resize((1<<(i+1)));\n\t\tmultiply(h[pre],h[pre],h[cur]);\n\t\tvector<int> pf;\n\t\tpf.assign((1<<(i+1)),0);\n\t\tfor(int j=0;j<min(pf.size(),a.size());j++) pf[j]=a[j];\n\t\th[cur].resize((1<<(i+2))); pf.resize((1<<(i+2)));\n\t\tmultiply(pf,h[cur],h[cur]);\n\t\th[cur].resize((1<<(i+1)));\n\t\tfor(int j=0;j<(1<<i);j++)\n\t\t{\n\t\t\th[cur][j] = combi.add(h[pre][j], combi.add(h[pre][j], MOD - h[cur][j]));\n\t\t}\n\t\tfor(int j=(1<<i);j<(1<<(i+1));j++)\n\t\t{\n\t\t\tif(h[cur][j]!=0) h[cur][j] = MOD - h[cur][j];\n\t\t}\n\t}\n\treturn h[cur];\n}\n \nvector<int> ln(vector<int> &a, int deg)\n{\n\twhile(a.size()<(1<<deg)) a.pb(0);\n\tvector<int> num,denom;\n\tdenom = inverse(a, deg);\n\tnum.resize((1<<deg));\n\tfor(int i = 0; i < (1<<deg); i++)\n\t{\n\t\tif(i+1<a.size())\n\t\t{\n\t\t\tnum[i] = combi.mult(a[i+1], i+1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnum[i] = 0;\n\t\t}\n\t}\n\tnum.resize((1<<(deg+1))); denom.resize((1<<(deg+1)));\n\tvector<int> res;\n\tmultiply(num,denom,res);\n\tres.resize(1<<deg);\n\tvector<int> ans(1<<deg,0);\n\tfor(int i=1;i<(1<<deg);i++)\n\t{\n\t\tans[i]=combi.mult(res[i-1],inv(i));\n\t}\n\treturn ans;\n}\n \nvector<int> exp(vector<int> &a, int deg)\n{\t\n\tvector<int> h[2];\n\th[0].pb(1);\n\tint cur=0; int pre=1;\n\tfor(int i=0;i<deg;i++) //after this it'll be of size 2^{deg}\n\t{\n\t\tcur^=1; pre^=1;\n\t\tvector<int> pf;\n\t\tpf.assign((1<<(i+1)),0);\n\t\tfor(int j=0;j<min(pf.size(),a.size());j++) pf[j]=a[j];\n\t\tpf[0]=combi.add(pf[0],1);\n\t\tvector<int> LN = ln(h[pre],i+1);\n\t\tfor(int j=0;j<(1<<(i+1));j++)\n\t\t{\n\t\t\tpf[j] = combi.add(pf[j], MOD - LN[j]);\n\t\t}\n\t\th[pre].resize((1<<(i+2))); pf.resize((1<<(i+2)));\n\t\tmultiply(pf,h[pre],h[cur]);\n\t\th[cur].resize((1<<(i+1)));\n\t}\n\treturn h[cur];\n}\n \nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcombi.init(500101);\n\tint tmpmult = 7*17;\n\ttmpmult = combi.mult(tmpmult, mod_pow(2, 23 - LG, MOD)); \n\tprt = mod_pow(3, tmpmult, MOD);\n\tiprt = inv(prt);\n\tint n,m; cin>>n>>m;\n\tvector<Mint> a(m+1);\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\ta[i] = 0;//combi.mult(m+1-i,combi.ifact[i]);\n\t}\n\ta[1] = n;\n\ta = exponent(a);\n\tvector<Mint> b(m+1);\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\tb[i] = combi.mult(combi.modpow(m+1,n-i),combi.choose(n,i));\n\t\tif(i&1) b[i]=combi.mult(int(b[i]),MOD-1);\n\t}\n\t/*\n\tvector<Mint> T; int deg=0; bool stp=0;\n\tfor(int i=0;i<a.size();i++)\n\t{\n\t\tif(!stp&&a[i]==0) {deg=i+1; continue;}\n\t\tT.pb(a[i]); stp=1;\n\t}\n\tMint coeff = T[0]; //should be nonempty\n\tMint icoeff = inv(int(T[0]));\n\tT = T*vector<Mint>{icoeff};\n\tvector<Mint> tmpNW = exponent(logarithm(T)*vector<Mint>{n});\n  \tint tt=combi.modpow(int(coeff),n);\n\tfor(int i=0;i<tmpNW.size();i++) tmpNW[i]=combi.mult(int(tmpNW[i]),tt);\n\tvector<Mint> NW(m+1,0);\n \t int cur=min(ll(m+1),ll(n)*ll(deg));\n\tfor(int i=0;i<tmpNW.size();i++)\n\t{\n\t\tif(cur<=m) NW[cur++] = tmpNW[i];\n\t\telse break;\n\t}\n\t*/\n\t\n\t/*\n\tfor(int i=0;i<NW.size();i++) cerr<<NW[i]<<' ';\n\tcerr<<'\\n';\n\t*/\n\tvector<Mint> NW = a*b;\n\tint ans=0;\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\tans=combi.add(ans,combi.mult(int(NW[i]),combi.ifact[m-i]));\n\t}\n\tans=combi.mult(ans,combi.fact[m]);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int p=998244353;\nint fac[500005],ifac[500005],inv[500005];\nint N,M;\nint qpow(int a,int k){\n\tint ans=1;\n\twhile(k){\n\t\tif(k&1) ans=1LL*ans*a%p;\n\t\ta=1LL*a*a%p;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m){if(n<m) return 0;return 1LL*fac[n]*ifac[m]%p*ifac[n-m]%p;}\n\nint main(){\n\tscanf(\"%d%d\",&N,&M);\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1;\n\tfor(int i=2;i<=500000;i++)\n\t\tinv[i]=1LL*(p-p/i)*inv[p%i]%p,\n\t\tfac[i]=1LL*fac[i-1]*i%p,\n\t\tifac[i]=1LL*ifac[i-1]*inv[i]%p;\n\tint ans=0; \n\tfor(int i=0;i<=N&&i<=M;i++){\n\t\tint tmp=1LL*C(N,i)*C(M,i)%p*qpow(N+1,M-i)%p*qpow(M+1,N-i)%p*fac[i]%p;\n\t\tif(i&1) ans=(ans-tmp+p)%p;\n\t\telse ans=(ans+tmp)%p;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline void myassert(bool a,string s){ if(!a)cerr<<s<<endl,exit(0);}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=5e5+20;\nconst int mod=998244353;\nint jc[maxn],jcn[maxn],inv[maxn];\n\ninline int power(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(ll)ans*a%mod;\n\t\tb>>=1;\n\t\ta=(ll)a*a%mod;\n\t}\n\treturn ans;\n}\n\ninline void prepare()\n{\n\tjc[0]=jc[1]=jcn[0]=jcn[1]=inv[1]=1;\n\tREP(i,2,5e5+1)jc[i]=(ll)i*jc[i-1]%mod,inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod,jcn[i]=(ll)jcn[i-1]*inv[i]%mod;\n}\n\nint n,m;\n\ninline void init()\n{\n\tn=read();m=read();\n}\n\ninline int C(int n,int m){ return 1ll*jc[n]*jcn[m]%mod*jcn[n-m]%mod;}\n\ninline void doing()\n{\n\tint ans=0;\n\tint pron=power(m+1,n),prom=power(n+1,m);\n\tREP(i,0,min(n,m))\n\t{\n\t\tans=(ans+(ll)C(n,i)*C(m,i)%mod*jc[i]%mod*pron%mod*prom*(i&1?-1:1))%mod;\n\t\tpron=(ll)pron*inv[m+1]%mod;\n\t\tprom=(ll)prom*inv[n+1]%mod;\n\t}\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}\n\nint main()\n{\n\tprepare();\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<map>\n#include<string>\n#include<bitset>\n\n#define maxn 1000005\n#define MOD 998244353\n\nusing namespace std;\n\ninline long long getint()\n{\n\tlong long num=0,flag=1;char c;\n\twhile((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;\n\twhile(c>='0'&&c<='9')num=num*10+c-48,c=getchar();\n\treturn num*flag;\n}\n\nint n,m;\nint fac[maxn],inv[maxn];\n\ninline int ksm(int num,long long k)\n{\n\tint ret=1;\n\tfor(;k;k>>=1,num=1ll*num*num%MOD)if(k&1)ret=1ll*ret*num%MOD;\n\treturn ret;\n}\ninline int C(int p,int q)\n{return 1ll*fac[p]*inv[q]%MOD*inv[p-q]%MOD;}\n\nint main()\n{\n\tn=getint(),m=getint();\n\tif(n>m)swap(n,m);\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=m;i++)fac[i]=1ll*fac[i-1]*i%MOD;\n\tfor(int i=2;i<=m;i++)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;\n\tfor(int i=2;i<=m;i++)inv[i]=1ll*inv[i]*inv[i-1]%MOD;\n\tlong long ans=0;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tint tmp=1ll*C(n,i)*C(m,i)%MOD*fac[i]%MOD*ksm(m+1,n-i)%MOD*ksm(n+1,m-i)%MOD;\n\t\tif(i&1)ans=(ans-tmp+MOD)%MOD;\n\t\telse ans=(ans+tmp)%MOD;\n\t}\n\tprintf(\"%lld\\n\",(ans+MOD)%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 500010;\nconst int mod = 998244353;\n\ntypedef long long LL;\n\ninline int Pow(int x, int y) {\n    int res = 1;\n    for (; y; y >>= 1, x = (LL)x * x % mod) if (y & 1) res = (LL)res * x % mod;\n    return res;\n}\n\nint frac[N], inv[N];\n\ninline int C(int n, int r) {\n    return (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;\n}\n\nint main() {\n    int n, m; scanf(\"%d%d\", &n, &m);\n    if (n > m) swap(n, m);\n    frac[0] = inv[0] = 1;\n    for (int i = 1; i <= m; i++) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2);\n    int res = 0;\n    for (int i = 0; i <= n; i++) {\n        int w = (LL)C(n, i) * C(m, i) % mod * frac[i] % mod * Pow(m + 1, n - i) % mod * Pow(n + 1, m - i) % mod;\n        if (i & 1) res = (res + mod - w) % mod;\n        else res = (res + w) % mod;\n    }\n    printf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint fac[500005],inv[500005],invf[500005];\nconst int p=998244353,G=114514;\nint f[1<<20|5],g[1<<20|5],N,rev[1<<20|5],w[1<<21|5];\nint C(int a,int b){return fac[a]*invf[b]%p*invf[a-b]%p;}\nint fpm(int a,int b){\n\tint c=1;for(;b;b>>=1,a=a*a%p)if(b&1)c=c*a%p;\n\treturn c;\n}\nint sum(int a,int b){return (a+=b)>=p?a-p:a;}\nint minu(int a,int b){return (a-=b)<0?a+p:a;}\nvoid dft(int *a){\n\tfor(int i=1;i<N;++i)if(i<rev[i])swap(a[i],a[rev[i]]);\n\tfor(int i=1;i<N;i<<=1){\n\t\tfor(int j=0;j<N;j+=i+i){\n\t\t\tfor(int k=0;k<i;++k){\n\t\t\t\tint u=a[j+k],v=a[i+j+k]*w[i+k]%p;\n\t\t\t\ta[j+k]=sum(u,v);\n\t\t\t\ta[j+k+i]=minu(u,v);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid idft(int *a){\n\treverse(a+1,a+N);\n\tdft(a);\n\tint iN=fpm(N,p-2)%p;\n\tfor(int i=0;i<N;++i)a[i]=a[i]*iN%p;\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint n,m;\t\n\tread(n,m);\n\tfac[0]=fac[1]=inv[1]=invf[0]=invf[1]=1;\n\tfor(int i=2;i<=m;++i){\n\t\tfac[i]=fac[i-1]*i%p;\n\t\tinv[i]=(p-p/i)*inv[p%i]%p;\n\t\tinvf[i]=invf[i-1]*inv[i]%p;\n\t}\n\tfor(int i=0;i<=m;++i){\n\t\tf[i]=(m-i+1)*invf[i]%p;\n\t}\n\tg[0]=fac[m];\n\tN=1;\n\twhile(N<=m+m)N<<=1;\n\tfor(int i=1;i<N;++i){\n\t\trev[i]=(rev[i>>1]>>1)|((i&1)*(N>>1));\n\t}\n\tfor(int i=1;i<N;i<<=1){\n\t\tint xw=fpm(G,(p-1)/i/2),ww=1;\n\t\tfor(int j=0;j<i;++j){\n\t\t\tw[i+j]=ww;\n\t\t\tww=ww*xw%p;\n\t\t}\n\t}\n\tfor(;n;n>>=1){\n\t\tdft(f);\n\t\tif(n&1){\n\t\t\tdft(g);\n\t\t\tfor(int i=0;i<N;++i)g[i]=g[i]*f[i]%p;\n\t\t\tidft(g);\n\t\t\tfor(int i=m+1;i<=m+m;++i)g[i]=0;\n\t\t}\n\t\tfor(int i=0;i<N;++i)f[i]=f[i]*f[i]%p;\n\t\tidft(f);\n\t\tfor(int i=m+1;i<=m+m;++i)f[i]=0;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=m;++i)ans=(ans+g[i]*invf[m-i])%p;;\n\twrite(ans,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=5e5+5,P=998244353;\nint pw(int a,int m){\n    int res=1;\n    while(m)m&1?res=1ll*res*a%P:0,a=1ll*a*a%P,m>>=1;\n    return res;\n}\nint fac[N],fnv[N];\n\nint n,m;\nint binom(int n,int m){\n    if(n<m)return 0;\n    return fac[n]*1ll*fnv[m]%P*fnv[n-m]%P;\n}\nint sig(int x){\n    return 1-2*(x&1);\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    fac[0]=1;\n    if(n<m)swap(n,m);\n    FOR(i,1,n)fac[i]=1ll*fac[i-1]*i%P;\n    fnv[n]=pw(fac[n],P-2);\n    ROF(i,n,1)fnv[i-1]=fnv[i]*1ll*i%P;\n    int ans=0;\n    FOR(i,0,min(n,m)){\n        ans=(ans+binom(n,i)*1ll*binom(m,i)%P*fac[i]%P*pw(m+1,n-i)%P*pw(n+1,m-i)%P*sig(i))%P;\n    }\n    ans=(ans+P)%P;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long int int64;\nstatic const int64 mod = 998244353LL;\nint n,m;\nint64 pown1[500003],powm1[500003];\nint64 fac[500003],inv[500003],invfac[500003];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tpown1[0] = 1;\n\tfor(int i = 1;i <= m;++i) {\n\t\tpown1[i] = pown1[i-1] * (n+1) % mod;\n\t}\n\tpowm1[0] = 1;\n\tfor(int i = 1;i <= n;++i) {\n\t\tpowm1[i] = powm1[i-1] * (m+1) % mod;\n\t}\n\tinv[1] = fac[0] = fac[1] = invfac[0] = invfac[1] = 1;\n\tfor(int i = 2;i <= 500000;++i) {\n\t\tfac[i] = (fac[i-1] * i) % mod;\n\t\tinv[i] = (mod-mod/i) * inv[mod%i] % mod;\n\t\tinvfac[i] = (invfac[i-1]*inv[i]) % mod;\n\t}\n\tint64 ans = 0;\n\tfor(int i = 0;i <= n && i <= m;++i) {\n\t\tans += pown1[m-i] * powm1[n-i] % mod * fac[n] % mod * invfac[n-i] % mod * fac[m] % mod * invfac[m-i] % mod * invfac[i] % mod * ((i&1)==0?1:-1);\n\t}\n\tans %= mod;\n\tif(ans < 0) ans += mod;\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int mod=998244353;\nconst int maxn=500000;\nint read()\n{\n\tchar c=getchar();\n\tint res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nlong long ksm(long long x,long long n)\n{\n\tlong long ans=1;\n\twhile(n)\n\t{\n\t\tif(n&1) ans=ans*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn ans;\n}\nint n,m;\nlong long fir[maxn+5],inv[maxn+5];\nlong long C(int n,int m)\n{\n\tif(n<m) return 0;\n\treturn fir[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid pre()\n{\n\tfir[0]=1;\n\tfor(int i=1;i<=maxn;i++) fir[i]=fir[i-1]*i%mod;\n\tinv[maxn]=ksm(fir[maxn],mod-2);\n\tfor(int i=maxn-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\nint main()\n{\n\tpre();\n\tn=read(),m=read();\n\tlong long ans=0;\n\tfor(int i=0;i<=min(n,m);i++)\n\t{\n\t\tif(i&1) ans=(ans-C(n,i)*C(m,i)%mod*ksm(m+1,n-i)%mod*ksm(n+1,m-i)%mod*fir[i]%mod)%mod;\n\t\telse ans=(ans+C(n,i)*C(m,i)%mod*ksm(m+1,n-i)%mod*ksm(n+1,m-i)%mod*fir[i]%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctype.h>\n#include <algorithm>\n#define mp make_pair\n#define Debug(...) fprintf(stdout, __VA_ARGS__)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<int, LL> pil;\n\nconst int MAXN = 5e5 + 7;\nconst int MOD = 998244353;\nconst int sig[] = {1, -1};\n\ntemplate<typename T> inline T read() {\n\tT res = 0, flag = 1; char in = getchar();\n\twhile(!isdigit(in)) { if(in == '-') flag = -1; in = getchar(); }\n\twhile(isdigit(in)) { res = (res << 1) + (res << 3) + in - '0'; in = getchar(); }\n\treturn res * flag;\n}\n\ntemplate<typename T> inline void chkmax(T &a, T b) { if(a < b) a = b; }\ntemplate<typename T> inline void chkmin(T &a, T b) { if(a > b) a = b; }\n\nint fac[MAXN], ifac[MAXN], inv[MAXN];\nint muln[MAXN], mulm[MAXN];\n\ninline void Add(int &x, int y) { x += y; if(x >= MOD) x -= MOD; if(x < 0) x += MOD; }\n\ninline int C(int n, int m) {\n\tif(n < m) return 0;\n\treturn (LL) fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\n\nint n, m, ans;\n\ninline int f(int x) { return (LL) C(n, x) * C(m, x) % MOD * fac[x] % MOD * muln[m - x] % MOD * mulm[n - x] % MOD; }\n\ninline void init() {\n\tfac[0] = ifac[0] = inv[1] = 1;\n\tfor(int i = 1; i < MAXN; ++i) fac[i] = (LL) fac[i - 1] * i % MOD;\n\tfor(int i = 2; i < MAXN; ++i) inv[i] = (LL) (MOD / i) * (MOD - inv[MOD % i]) % MOD;\n\tfor(int i = 1; i < MAXN; ++i) ifac[i] = (LL) ifac[i - 1] * inv[i] % MOD;\n\n\tn = read<int>(); m = read<int>();\n\tmuln[0] = mulm[0] = 1;\n\tmuln[1] = n + 1; mulm[1] = m + 1;\n\tfor(int i = 2; i < MAXN; ++i) muln[i] = (LL) muln[i - 1] * muln[1] % MOD;\n\tfor(int i = 2; i < MAXN; ++i) mulm[i] = (LL) mulm[i - 1] * mulm[1] % MOD;\n}\n\ninline void solve() {\n\tint tp = min(n, m);\n\tfor(int i = 0; i <= tp; ++i) {\n\t\tAdd(ans, f(i) * sig[i & 1]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n\n\tinit();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,int b){a-=b;return a<0?a+mod:a;}\ninline int mul(int a,int b){return (ll)a*b%mod;}\ninline int qpow(int a,int b){int ret=1;for(;b;b>>=1,a=mul(a,a))if(b&1)ret=mul(ret,a);return ret;}\n/* math */\nconst int N = 5e5+5;\nint fac[N],ifac[N];\nint pwn[N], pwm[N];\nint nn,mm;\ninline void init(int n=5e5){\n\tfac[0]=ifac[0]=1;for(int i=1;i<=n;i++)fac[i]=mul(fac[i-1],i);\n\tifac[n]=qpow(fac[n],mod-2);for(int i=n-1;i;i--)ifac[i]=mul(ifac[i+1],i+1);\n\tpwn[0]=pwm[0]=1;\n\tfor(int i=1;i<=mm;i++)pwn[i]=mul(pwn[i-1],nn+1);\n\tfor(int i=1;i<=nn;i++)pwm[i]=mul(pwm[i-1],mm+1);\n}\ninline int binom(int a,int b){\n\tif(b>a)return 0;\n\treturn mul(fac[a],mul(ifac[a-b],ifac[b]));\n}\n\nint main()\n{\n\tcin >> nn >> mm;\n\tinit();\n\tint ans=0;\n\tfor(int d=0,s=1;d<=min(nn,mm);++d,s=mod-s){\n\t\t// cout << d << \":\" << mm-d << \":\" << pwn[mm-d] << \":\" << mul(pwn[mm-d],pwm[nn-d]) << endl;\n\t\tint sum = mul(mul(mul(binom(nn,d),binom(mm,d)),fac[d]),mul(pwn[mm-d],pwm[nn-d]));\n\t\tans=add(ans, mul(s,sum));\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<ans*fact[n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\ninline void write(int x)\n{\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)write(x/10);\n    putchar(x%10+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\ninline int power(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}return ans;\n}\nint bin[2][500010],fac[500010],inv[500010];\ninline int C(int m,int n){return 1LL*fac[m]*inv[n]%mod*inv[m-n]%mod;}\ninline int A(int m,int n){return 1LL*fac[m]*inv[m-n]%mod;}\nint main()\n{\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n=read(),m=read();\n    if(n>m)swap(n,m);\n    bin[0][0]=1;for(int i=1;i<=n;i++)bin[0][i]=1LL*bin[0][i-1]*(m+1)%mod;\n    bin[1][0]=1;for(int i=1;i<=m;i++)bin[1][i]=1LL*bin[1][i-1]*(n+1)%mod;\n    fac[0]=1;for(int i=1;i<=m;i++)fac[i]=1LL*fac[i-1]*i%mod;\n    inv[m]=power(fac[m],mod-2);\n    for(int i=m;i>=1;i--)inv[i-1]=1LL*inv[i]*i%mod;\n    int ans=1LL*bin[0][n]*bin[1][m]%mod;\n    for(int i=1;i<=n;i++)\n    {\n    \tint uf=1LL*C(n,i)*A(m,i)%mod*bin[0][n-i]%mod*bin[1][m-i]%mod;\n    \tif(i&1)ans=(ans-uf+mod)%mod;\n    \telse ans=(ans+uf)%mod;\n    }pr2(ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 1e6 + 10;\nconst ll MOD = 998244353;\n\nll sq(ll x) { return x * x % MOD; }\nll qpow(ll a, ll b) { return b ? sq(qpow(a, b / 2)) * (b & 1 ? a : 1) % MOD : 1; }\nll inv(ll x) { return qpow(x, MOD - 2); }\n\nint N, M;\nll fac[MAX_N], ifac[MAX_N], pow_n1[MAX_N], pow_m1[MAX_N];\n\nll comb(int n, int m) { return fac[n] * ifac[n - m] % MOD * ifac[m] % MOD; }\n\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    fac[0] = 1;\n    for (int i = 1; i <= N + M; i++) fac[i] = fac[i - 1] * i % MOD;\n    ifac[N + M] = inv(fac[N + M]);\n    for (int i = N + M; i; i--) ifac[i - 1] = ifac[i] * i % MOD;\n    pow_n1[0] = pow_m1[0] = 1;\n    for (int i = 1; i <= N + M; i++) {\n        pow_n1[i] = pow_n1[i - 1] * (N + 1) % MOD;\n        pow_m1[i] = pow_m1[i - 1] * (M + 1) % MOD;\n    }\n    ll ans = 0;\n    for (int i = 0; i <= min(N, M); i++) {\n        ll t = i & 1 ? MOD - 1 : 1;\n        (t *= comb(N, i) * comb(M, i) % MOD) %= MOD;\n        (t *= fac[i]) %= MOD;\n        (t *= pow_n1[M - i] * pow_m1[N - i] % MOD) %= MOD;\n        (ans += t) %= MOD;\n    }\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MD=998244353;\nconst int N=5e5+5;\nint fac[N],inv[N],n,m;\nvoid add(int &x,int y) {\n\tx+=y;\n\tif(x>=MD) x-=MD;\n\tif(x<0) x+=MD;\n}\nint quick_pow(int x,int y) {\n\tint ans=1;\n\twhile(y) {\n\t\tif(y&1) ans=1LL*ans*x%MD;\n\t\ty>>=1;\n\t\tx=1LL*x*x%MD;\n\t}\n\treturn ans;\n}\nvoid init() {\n\tfac[0]=1;\n\tfor(int i=1;i<N;i++) fac[i]=1LL*fac[i-1]*i%MD;\n\tinv[N-1]=quick_pow(fac[N-1],MD-2);\n\tfor(int i=N-2;i>=0;i--) inv[i]=1LL*inv[i+1]*(i+1)%MD;\n}\nint C(int n,int m) {\n\treturn 1LL*fac[n]*inv[m]%MD*inv[n-m]%MD;\n}\nint main() {\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tif(n>m) swap(n,m);\n\tint ans=0;\n\tfor(int i=0;i<=n;i++) {\n\t\tadd(ans,1LL*C(n,i)*C(m,i)%MD*fac[i]%MD*quick_pow(m+1,n-i)%MD*quick_pow(n+1,m-i)%MD*(i&1?-1:1));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define read() Read<int>()\nnamespace pb_ds{   \n    namespace io{\n        const int MaxBuff=1<<15;\n        const int Output=1<<23;\n        char B[MaxBuff],*S=B,*T=B;\n\t\t#define getc() ((S==T)&&(T=(S=B)+fread(B,1,MaxBuff,stdin),S==T)?0:*S++)\n        char Out[Output],*iter=Out;\n        inline void flush(){\n            fwrite(Out,1,iter-Out,stdout);\n            iter=Out;\n        }\n    }\n    template<class Type> inline Type Read(){\n        using namespace io;\n        register char ch;\n        register Type ans=0; \n        register bool neg=0;\n        while(ch=getc(),(ch<'0' || ch>'9') && ch!='-');\n        ch=='-'?neg=1:ans=ch-'0';\n        while(ch=getc(),'0'<= ch && ch<='9') ans=ans*10+ch-'0';\n        return neg?-ans:ans;\n    }\n    template<class Type> inline void Print(register Type x,register char ch='\\n'){\n        using namespace io;\n        if(!x) *iter++='0';\n        else{\n            if(x<0) *iter++='-',x=-x;\n            static int s[100]; \n            register int t=0;\n            while(x) s[++t]=x%10,x/=10;\n            while(t) *iter++='0'+s[t--];\n        }\n        *iter++=ch;\n    }\n}\nusing namespace pb_ds;\nusing namespace std;\ntypedef long long ll;\nconst int N=5e5+5;\nconst int Mod=998244353;\nint n,m,ans;\nint fac[N],inv[N];\ninline int Pow(int x,int y){\n\tint res=1;\n\twhile (y){\n\t\tif (y&1) res=1ll*res*x%Mod;\n\t\tx=1ll*x*x%Mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\ninline void math_init(int nn){\n\tfac[0]=1;\n\tfor (int i=1;i<=nn;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[nn]=Pow(fac[nn],Mod-2);\n\tfor (int i=nn;i;--i)\n\t\tinv[i-1]=1ll*inv[i]*i%Mod;\n}\ninline int C(int x,int y){\n\tif (x<y || x<0 || y<0) return 0;\n\treturn 1ll*(1ll*fac[x]*inv[y]%Mod)*inv[x-y]%Mod;\n}\ninline void ad(int &x,int y){\n\tx+=y;\n\tif (x>=Mod) x-=Mod;\n\tif (x<0) x+=Mod;\n}\nint main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tn=read(),m=read();\n\tmath_init(max(n,m));\n\tfor (int i=0;i<=n && i<=m;++i){\n\t\tint now=1ll*C(n,i)*C(m,i)%Mod;\n\t\tnow=1ll*now*fac[i]%Mod;\n\t\tnow=1ll*now*Pow(m+1,n-i)%Mod;\n\t\tnow=1ll*now*Pow(n+1,m-i)%Mod;\n\t\tif (i&1) ad(ans,Mod-now);\n\t\telse ad(ans,now);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define PB push_back\n#define ll long long\nusing namespace std;\nconst int mo=998244353;\nconst int N=500005;\nint fac[N],inv[N];\nint n,m,ans;\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nint C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%mo*inv[x-y]%mo;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tif (n>m) swap(n,m);\n\tfac[0]=inv[0]=inv[1]=1;\n\tFor(i,2,m) inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;\n\tFor(i,1,m) inv[i]=1ll*inv[i-1]*inv[i]%mo;\n\tFor(i,1,m) fac[i]=1ll*fac[i-1]*i%mo;\n\tFor(i,0,min(n,m))\n\t\tans=(ans+1ll*(i&1?mo-1:1)*C(n,i)%mo*C(m,i)%mo*fac[i]%mo*power(m+1,n-i)%mo*power(n+1,m-i))%mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\ninline int read() {\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }\n\tdo x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');\n\treturn x * f;\n}\n\ntypedef long long ll;\nconst int MAXN = 500001;\nconst int mod = 998244353;\n\nint n,m;\nll fac[MAXN],ifac[MAXN];\nll pown[MAXN],powm[MAXN];\n\nll C(int n,int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint main() {\n\tn = read(), m = read();\n\tfac[0] = 1;\n\tfor(int i = 1;i <= n || i <= m;i++) fac[i] = (fac[i - 1] * i) % mod;\n\tifac[0] = ifac[1] = 1;\n\tfor(int i = 2;i <= n || i <= m;i++) ifac[i] = ((mod - mod / i) * ifac[mod % i]) % mod;\n\tfor(int i = 2;i <= n || i <= m;i++) ifac[i] = (ifac[i - 1] * ifac[i]) % mod;\n\tpown[0] = powm[0] = 1;\n\tfor(int i = 1;i <= m;i++) pown[i] = (pown[i - 1] * (n + 1)) % mod;\n\tfor(int i = 1;i <= n;i++) powm[i] = (powm[i - 1] * (m + 1)) % mod;\n\tll ans = 0;\n\tfor (int i = 0;i <= n && i <= m;i++) {\n\t\tll res = (C(n,i) * C(m,i)) % mod;\n\t\tres = res * fac[i] % mod;\n\t\tres = res * pown[m - i] % mod;\n\t\tres = res * powm[n - i] % mod;\n\t\tif(i & 1) ans = (ans + mod - res) % mod;\n\t\telse ans = (ans + res) % mod;\n\t}\n\tstd::printf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#define int long long\nusing namespace std;\nconst int maxn=500086;\nconst int mod=998244353;\nint qpow(int a,int b,int p)\n{\n\tint res=1,base=a%p;\n\twhile(b) \n\t{\n\t\tif(b&1) res=res*base%p;\n\t\tb>>=1,base=base*base%p;\n\t}\n\treturn res;\n}\nint jc[maxn],inv[maxn];\nint n,m;\nint C(int n,int m)\n{\n\tif(n<m) return 0;\n\treturn jc[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint F(int i)\n{\n\tint fir=C(n,i)*C(m,i)%mod;\n\tint sec=qpow(m+1,n-i,mod)*qpow(n+1,m-i,mod)%mod;\n\treturn fir*sec%mod*jc[i]%mod;\n}\nsigned main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tjc[0]=1; for(int i=1;i<maxn;++i) jc[i]=jc[i-1]*i%mod;\n\tinv[0]=inv[1]=1; for(int i=2;i<maxn;++i) inv[i]=mod-(mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<maxn;++i) inv[i]=inv[i]*inv[i-1]%mod;\n\tint ans=0; \n\tfor(int i=0,type=1;i<=n&&i<=m;++i,type=mod-type) ans=(ans+type*F(i))%mod;\n\tprintf(\"%lld\\n\",ans);\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define ri register int\ntypedef long long ll;\nconst int mod=998244353,N=5e5+5;\nint fac[N],ifac[N];\ninline int fpow(ri a,ri b){\n\tri ans=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)\n\t\tif(b&1) ans=(ll)ans*a%mod;\n\treturn ans;\n}\ninline int C(ri n,ri m){\n\treturn m<0||n<m?0:(ll)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\ninline int min(ri x,ri y){\n\treturn x<y ? x:y;\n}\ninline int max(ri x,ri y){\n\treturn x>y ? x:y;\n}\nint main(){\n\tri n,m,i,ans,l;\n\tscanf(\"%d%d\",&n,&m);\n\tl=max(n,m);\n\tfac[0]=1;\n\tfor(i=1;i<=l;++i) fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[l]=fpow(fac[l],mod-2);\n\tfor(i=l;i;--i) ifac[i-1]=(ll)ifac[i]*i%mod;\n\tl=min(n,m);\n\tans=0;\n\tfor(i=0;i<=l;++i)\n\t\tif(i&1)\n\t\t\tans=(ans-(ll)C(n,i)*C(m,i)%mod*fac[i]%mod*fpow(m+1,n-i)%mod*fpow(n+1,m-i))%mod;\n\t\telse\n\t\t\tans=(ans+(ll)C(n,i)*C(m,i)%mod*fac[i]%mod*fpow(m+1,n-i)%mod*fpow(n+1,m-i))%mod;\n\tans=ans<0?ans+mod:ans;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nusing cat = long long;\n\ncat mod = 998244353;\n\ncat pw(cat a, cat e) {\n\tif(e <= 0) return 1;\n\tcat x = pw(a, e/2);\n\tx = x * x % mod;\n\tif(e&1) x = x * a % mod;\n\treturn x;\n}\n\ncat om[22];\n\nvoid ntt(cat * a, int n, bool rev = 0) {\n\tfor(int i = 0, j = 0; i < n; ++i) {\n\t\tif(i < j) swap(a[i], a[j]);\n\t\tfor(int k = n>>1; (j^=k) < k; k >>= 1) {}\n\t}\n\tfor(int i = 2, e = 1; i <= n; i <<= 1, e++) {\n\t\tint len = i>>1;\n\t\tcat w = om[e];\n\t\tfor(int j = 0; j < n; j += i) {\n\t\t\tcat cur = 1;\n\t\t\tfor(int k = j; k < j+len; ++k) {\n\t\t\t\tcat u = a[k], v = a[k+len] * cur % mod;\n\t\t\t\ta[k] = u + v, a[k+len] = u - v;\n\t\t\t\tif(a[k] >= mod) a[k] -= mod;\n\t\t\t\tif(a[k+len] < 0) a[k+len] += mod;\n\t\t\t\tcur = cur * w % mod;\n\t\t\t}\n\t\t}\n\t}\n\tif(rev) {\n\t\tcat n_inv = pw(n, mod-2);\n\t\treverse(a+1, a+n);\n\t\tfor(int i = 0; i < n; i++) a[i] = a[i] * n_inv % mod;\n\t}\n}\n\nint main() {\n\tfor(int i = 0; i < 22; i++) om[i] = pw(3, (mod-1)>>i);\n\tint N, M;\n\tcin >> N >> M;\n\tcat fac[500010], inv[500010];\n\tfac[0] = inv[0] = 1;\n\tfor(int i = 1; i <= 500000; i++) fac[i] = fac[i-1] * i % mod;\n\tfor(int i = 1; i <= 500000; i++) inv[i] = (i%2 == 0 && i > 2) ? inv[2] * inv[i/2] % mod : pw(i, mod-2);\n\tfor(int i = 1; i <= 500000; i++) inv[i] = inv[i-1] * inv[i] % mod;\n\tcat A[1<<20];\n\tmemset(A, 0, sizeof(A));\n\tcat N_pw = 1;\n\tfor(int i = 0; i <= M; i++) {\n\t\tA[i] = inv[i] * N_pw % mod;\n\t\tN_pw = N_pw * N % mod;\n\t}\n\tntt(A, 1<<20);\n\tcat B[1<<20];\n\tmemset(B, 0, sizeof(B));\n\tcat M_pw = 1;\n\tfor(int i = N; i >= 0; i--) {\n\t\tB[i] = inv[i] * inv[N-i] % mod * M_pw % mod;\n\t\tM_pw = M_pw * (mod-1-M) % mod;\n\t}\n\tntt(B, 1<<20);\n\tcat C[1<<20];\n\tfor(int i = 0; i < (1<<20); i++) C[i] = A[i] * B[i] % mod;\n\tntt(C, 1<<20, 1);\n\tcat ans = 0;\n\tfor(int i = 0; i <= M; i++) ans = (ans + C[i] * inv[M-i]) % mod;\n\tans = ans * fac[N] % mod * fac[M] % mod * (N%2 ? mod-1 : 1) % mod;\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (2)\n#pragma G++ optimize (2)\n#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define mod 998244353\n#define MAX 500005\nusing namespace std;\n//char nc()\n//{\n//\tstatic char buf[100000],*p1=buf,*p2=buf;\n//\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\nchar nc(){return getchar();}\nint read()\n{\n\tint x=0,y=1;\n\tchar c=nc();\n\twhile(!isdigit(c))\n\t{\n\t\tif(c=='-')y=-1;\n\t\tc=nc();\n\t}\n\twhile(isdigit(c))\n\t{\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\t\tc=nc();\n\t}\n\treturn x*y;\n}\nint n,m;\nlong long fac[MAX],facinv[MAX],pwn1[MAX],pwm1[MAX];\nlong long mo(long long x)\n{\n\treturn x<mod?x:x-mod;\n}\nlong long quick_pow(long long x,long long y)\n{\n\tlong long re=1;\n\twhile(y)\n\t{\n\t\tif(y&1) re=re*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn re;\n}\nlong long C(long long down,long long up)\n{\n\treturn fac[down]*facinv[down-up]%mod*facinv[up]%mod;\n}\nint main()\n{\n\tn=read();m=read();\n\tint up=max(n,m);\n\tfac[0]=1;\n\tfor(int i=1;i<=up;i++)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tfacinv[up]=quick_pow(fac[up],mod-2);\n\tfor(int i=up;i;i--)\n\t\tfacinv[i-1]=facinv[i]*i%mod;\n\tpwn1[0]=1;\n\tfor(int i=1;i<=m;i++)\n\t\tpwn1[i]=pwn1[i-1]*(n+1)%mod;\n\tpwm1[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tpwm1[i]=pwm1[i-1]*(m+1)%mod;\n\tlong long ANS=0;\n\tfor(int i=0;i<=min(n,m);i++)\n\t\tif(!(i&1)) ANS=(ANS+C(n,i)*C(m,i)%mod*fac[i]%mod*pwm1[n-i]%mod*pwn1[m-i])%mod;\n\t\telse ANS=mo(ANS-C(n,i)*C(m,i)%mod*fac[i]%mod*pwm1[n-i]%mod*pwn1[m-i]%mod+mod);\n\tprintf(\"%lld\",ANS);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\nusing namespace std;\nconst int N = 5e5 + 5;\nconst int mod = 998244353;\nint fac[N], inv[N], n, m, ans;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nint ksm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = x * x % mod)\n\t\tif(y & 1) res = res * x % mod;\n\treturn res;\n}\nvoid init(int n)\n{\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n; i ++) fac[i] = fac[i - 1] * i % mod;\n\tinv[n] = ksm(fac[n], mod - 2);\n\tfor(int i = n - 1; i >= 0; i --) inv[i] = inv[i + 1] * (i + 1) % mod;\n}\nint C(int n, int m)\n{\n\tif(n < m || n < 0 || m < 0) return 0;\n\treturn fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\nsigned main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read(); m = read(); init(max(n, m));\n\tfor(int k = 0; k <= min(n, m); k ++)\n\t{\n\t\tint res = C(n, k) * C(m, k) % mod * fac[k] % mod * ksm(m + 1, n - k) % mod * ksm(n + 1, m - k) % mod;\n\t\tif(k & 1) ans = (ans - res + mod) % mod;\n\t\telse ans = (ans + res) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 5e5 + 5;\nconst int MOD = 998244353;\n\nint qpow(int base, int e) {\n    int ret = 1;\n    for (; e; e >>= 1) {\n        if (e & 1) {\n            ret = (LL) ret * base % MOD;\n        }\n        base = (LL) base * base % MOD;\n    }\n    return ret;\n}\n\nint fac[N], inv[N];\n\nvoid prep() {\n    fac[0] = 1;\n    for (int i = 1; i <= N - 1; ++i) {\n        fac[i] = (LL) fac[i - 1] * i % MOD;\n    }\n    inv[N - 1] = qpow(fac[N - 1], MOD - 2);\n    for (int i = N - 1; i >= 1; --i) {\n        inv[i - 1] = (LL) inv[i] * i % MOD;\n    }\n}\n\nint comb(int n, int m) {\n    return (LL) fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\n\nint main() {\n    prep();\n    int n = read(), m = read(), ans = 0;\n    if (n > m) swap(n, m);\n    int mul1 = qpow(n + 1, m - n), mul2 = 1;\n    for (int i = n; i >= 0; --i) {\n        ans = (ans + (i & 1 ? -1LL : 1LL) * comb(n, i) * comb(m, i) % MOD\n                * fac[i] % MOD * mul1 % MOD * mul2) % MOD;\n        mul1 = (LL) mul1 * (n + 1) % MOD;\n        mul2 = (LL) mul2 * (m + 1) % MOD;\n    }\n    if (ans < 0) ans += MOD;\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\ninline int read() {\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }\n\tdo x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');\n\treturn x * f;\n}\n\ntypedef long long ll;\nconst int MAXN = 500001;\nconst int mod = 998244353;\n\nint n,m;\nll fac[MAXN],ifac[MAXN];\nll pown[MAXN],powm[MAXN];\n\nll C(int n,int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint main() {\n\tn = read(), m = read();\n\tfac[0] = 1;\n\tfor(int i = 1;i <= n || i <= m;i++) fac[i] = (fac[i - 1] * i) % mod;\n\tifac[0] = ifac[1] = 1;\n\tfor(int i = 2;i <= n || i <= m;i++) ifac[i] = ((mod - mod / i) * ifac[mod % i]) % mod;\n\tfor(int i = 2;i <= n || i <= m;i++) ifac[i] = (ifac[i - 1] * ifac[i]) % mod;\n\tpown[0] = powm[0] = 1;\n\tfor(int i = 1;i <= m;i++) pown[i] = (pown[i - 1] * (n + 1)) % mod;\n\tfor(int i = 1;i <= n;i++) powm[i] = (powm[i - 1] * (m + 1)) % mod;\n\tll ans = 0;\n\tfor(int i = 0;i <= n && i <= m;i++) {\n\t\tll res = (C(n,i) * C(m,i)) % mod;\n\t\tres = res * fac[i] % mod;\n\t\tres = res * pown[m - i] % mod;\n\t\tres = res * powm[n - i] % mod;\n\t\tif(i & 1) ans = (ans + mod - res) % mod;\n\t\telse ans = (ans + res) % mod;\n\t}\n\tstd::printf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rgi register int\n#define ll long long\nnamespace IO {\n#define _CCF_ 8388608\n// #define getchar() (_Ip1==_Ip2&&(_Ip2=(_Ip1=_I)+fread(_I,1,1<<21,stdin),_Ip1==_Ip2)?EOF:*_Ip1++)\n// #define putchar(c) (_Op-_O<_CCF_)?(*_Op++=c):(fwrite(_O,_Op-_O,1,stdout),_Op=_O,*_Op++=c)\n\tchar _I[_CCF_],*_Ip1=_I,*_Ip2=_I,_O[_CCF_],*_Op=_O;\n\tint _f,_ch,_On[32],_Oh; long long _k;\n\ttemplate<typename _T> inline void read(_T&_x){\n\t\t_x=_f=_ch=0; while(!isdigit(_ch)) _f|=(_ch=='-'),_ch=getchar();\n\t\twhile(isdigit(_ch)) _x=(_x<<1)+(_x<<3)+(_ch^'0'),_ch=getchar();\n\t\t_f&&(_x=-_x);}\n\ttemplate<typename _T> inline void write(_T _x){\n\t\tif(_x==0) return putchar('0'),void(); if(_x<0) putchar('-'),_x=-_x;\n\t\twhile(_x>0) _k=_x/10,_On[++_Oh]=(_x-(_k<<1)-(_k<<3))^'0',_x=_k;\n\t\twhile(_Oh>0) putchar(_On[_Oh]),--_Oh;}\n\tinline void _Exit0() {fwrite(_O,_Op-_O,1,stdout),exit(0);}\n} using namespace IO;\nconst int maxn=500004,mod=998244353;\n\nint inv[maxn];\ninline int powmod(ll a,int b) {\n\tll res=1;\n\twhile(b>0) {\n\t\tif(b&1) (res*=a)%=mod;\n\t\t(a*=a)%=mod,b>>=1;\n\t} return res;\n}\ninline int calc(int n,int m) {\n\tll res=0,fact=1,bn=1,bm=1,pn=powmod(n+1,m),pm=powmod(m+1,n);\n\tfor(rgi i=0;i<=n;++i) {\n\t\t(res+=((i&1)?(mod-1ll):1ll)*fact%mod*bn%mod*bm%mod*pn%mod*pm)%=mod;\n\t\t(bn*=(ll)(n-i)*inv[i+1]%mod)%=mod,(bm*=(ll)(m-i)*inv[i+1]%mod)%=mod;\n\t\t(pn*=inv[n+1])%=mod,(pm*=inv[m+1])%=mod;\n\t\t(fact*=i+1)%=mod;\n\t} return res;\n}\nsigned main() {\n\t// rgi T,n,m,a,b; read(T);\n\t// inv[1]=1; for(rgi i=2;i<maxn;++i) inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;\n\t// while(T--) {\n\t// \tread(n),read(m),read(a),read(b);\n\t// \tif(a!=0&&(a==b||a==-b)) write(calc(n,m));\n\t// \telse write((a?powmod(m+1,n):1)*(b?powmod(n+1,m):1)%mod);\n\t// \tputchar('\\n');\n\t// } _Exit0();\n\tint n,m; read(n),read(m);\n\tinv[1]=1; for(rgi i=2;i<maxn;++i) inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;\n\twrite(calc(std::min(n,m),std::max(n,m))),_Exit0();\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 5121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\n\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tlong long ret=0;\n\tinit_C(1100000);\n\tfor(int i=0;i<=b;i++){\n\t\tif(i>a)continue;\n\t\tlong long ks=Comb(b,i)*Comb(a,i)%mod;\n\t\tks=ks*fact[i]%mod;\n\t\tks=ks*pw(a+1,b-i)%mod*pw(b+1,a-i)%mod;\n\t\tif(i%2)ret=(ret+mod-ks)%mod;\n\t\telse ret=(ret+ks)%mod;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t\treturn s(a+x.a);\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t\treturn s(a+mod-x.a);\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt<998244353>;\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t N>\nstruct ModIntTable{\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n){return facts[n];}\n\tinline Mint finv(int n){return finvs[n];}\n\tinline Mint inv(int n){return invs[n];}\n\tinline Mint binom(int n,int k){return facts[n]*finvs[k]*finvs[n-k];}\n};\nModIntTable<mint,1<<19>mtable;\n\n\ntemplate<class Mint,int32_t root>\nstruct NumberTheoreticTransform{\n\tstatic void ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(root).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    static void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tstatic vector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n};\nusing NTT=NumberTheoreticTransform<mint,3>;\n\n\nconst uint32_t mod=998244353;\nconst mint prim_root=3;\n\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tmint in=mint(n).inv();\n\trep(i,n)\n\t\tf[i]*=in;\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i=false){\n\tif(!i)NTT::ntt(f);\n\telse NTT::intt(f);\n\treturn;\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\n\n\nvector<mint> multiply(vector<mint> x,vector<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n \ntemplate<class Mint>\nstruct NTTFriendlyPoly{\n\tvoid ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(3).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tvector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n\n\tvector<Mint>v;\n\ttemplate<class...Args>\n\tNTTFriendlyPoly(Args...args):v(args...){}\n \n\tNTTFriendlyPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n \n\tint size()const{return v.size();}\n \n\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n \n\tNTTFriendlyPoly operator+(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator-(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator*(const NTTFriendlyPoly& x){\n\t\treturn multiply(v,x.v);\n\t}\n\tNTTFriendlyPoly operator*(const Mint& x){\n\t\tint n=size();\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator/(const Mint& x){\n\t\treturn (*this)*x.inv();\n\t}\n \n\tNTTFriendlyPoly& operator+=(const NTTFriendlyPoly& x){return *this=(*this)+x;}\n\tNTTFriendlyPoly& operator-=(const NTTFriendlyPoly& x){return *this=(*this)-x;}\n\tNTTFriendlyPoly& operator*=(const NTTFriendlyPoly& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n\tNTTFriendlyPoly operator-(){return NTTFriendlyPoly()-*this;}\n \n    NTTFriendlyPoly pre(int n){\n        NTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n&&i<size();i++)res[i]=v[i];\n\t\treturn res;\n    }\n    NTTFriendlyPoly rev(){\n        vector<Mint>res=v;\n\t\twhile(res.size()&&res.back()==0)res.pop_back();\n        reverse(res.begin(),res.end());\n        return res;\n    }\n    NTTFriendlyPoly diff(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=1;i<size()&&i<=n;i++)res[i-1]=v[i]*i;\n        return res;\n    }\n    NTTFriendlyPoly inte(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=0;i<size()&&i+1<n;i++)res[i+1]=v[i]*mtable.inv(i+1);\n        return res;\n    }\n\n    NTTFriendlyPoly inv(int n){\n        vector<mint>res{coef(0).inv()};\n\n        for(int d=1;d<n;d<<=1){\n            vector<Mint>f(2*d),g(2*d);\n            for(int j=0;j<2*d;j++)f[j]=coef(j);\n            for(int j=0;j<d;j++)g[j]=res[j];\n            \n            inplace_fmt(f);inplace_fmt(g);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++){\n                f[j]=0;\n                f[j+d]=-f[j+d];\n            }\n            inplace_fmt(f);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++)f[j]=res[j];\n            res=f;\n        }\n        return NTTFriendlyPoly(res).pre(n);\n    }\n    \n    \n    NTTFriendlyPoly inv2(int n){\n        NTTFriendlyPoly res{coef(0).inv()};\n        for(int i=1;i<n;i*=2){\n            res=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n        }\n        return res.pre(n);\n    }\n    \n    \n\n\tNTTFriendlyPoly exp(int n){\n\t\tNTTFriendlyPoly f0{1},g0{1};\n\t\tvector<Mint>F0{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tvector<Mint>G0=g0.v;\n\t\t\tinplace_fmt(G0);\n\t\t\tvector<Mint>Delta(d);\n\t\t\tfor(int j=0;j<d;j++)Delta[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tDelta[0]-=1;\n\t\t\tNTTFriendlyPoly delta(2*d);\n\t\t\tfor(int j=0;j<d;j++)delta[d+j]=Delta[j];\t\t\n\t\t\t\n\t\t\tNTTFriendlyPoly epsilon(2*d);\n\t\t\t\n\t\t\n\t\t\t\n\t\t\tvector<Mint>DF0=f0.diff(d-1).v;DF0.push_back(0);\n\t\t\tinplace_fmt(DF0);\n\t\t\tfor(int j=0;j<d;j++)DF0[j]*=G0[j];\n\t\t\tinplace_fmt(DF0,true);\n\t\t\tfor(int j=0;j<d-1;j++){\n\t\t\t\tepsilon[j]+=coef(j+1)*(j+1);\n\t\t\t\tepsilon[j+d]+=DF0[j]-coef(j+1)*(j+1);\n\t\t\t}\n\t\t\tepsilon[d-1]+=DF0[d-1];\n\n\n\t\t\tDelta=delta.v;\n\t\t\tinplace_fmt(Delta);\n\t\t\tvector<Mint>DH0=diff(d-1).v;DH0.resize(2*d);\n\t\t\tinplace_fmt(DH0);\n\t\t\tfor(int j=0;j<2*d;j++)Delta[j]*=DH0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tfor(int j=0;j<d;j++)epsilon[j+d]-=Delta[j+d];\n\t\t\n\n\t\t\tepsilon=epsilon.inte(2*d)-pre(2*d);\n\t\t\t\n\t\t\tvector<Mint>Epsilon=epsilon.v;\n\t\t\tinplace_fmt(Epsilon);\n\t\t\trep(j,d)DH0[j]=f0[j],DH0[j+d]=0;\n\t\t\tinplace_fmt(DH0);\n\t\t\trep(j,2*d)Epsilon[j]*=DH0[j];\n\t\t\tinplace_fmt(Epsilon,true);\n\t\t\tf0.v.resize(2*d);\n\t\t\trep(j,d)f0[j+d]-=Epsilon[j+d];\n\t\t\t//f0=(f0-epsilon*f0).pre(2*d);\n\t\t\t\n\t\t\tG0.resize(2*d);\n\t\t\trep(j,d)G0[j]=g0[j];\n\t\t\tinplace_fmt(G0);\n\t\t\tF0=f0.v; \n\t\t\tinplace_fmt(F0);\n\t\t\tvector<Mint>T(2*d);rep(j,2*d)T[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d){\n\t\t\t\tT[j]=0;\n\t\t\t\tT[j+d]=-T[j+d];\n\t\t\t}\n\t\t\tinplace_fmt(T);\n\t\t\trep(j,2*d)T[j]*=G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d)T[j]=g0[j];\n\t\t\tg0=T;\n\t\t}\n\t\treturn f0.pre(n);\n\t}\n\n    NTTFriendlyPoly exp2(int n){\n        NTTFriendlyPoly f{1};\n        for(int i=1;i<n;i*=2){\n            f=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n        }\n        return f.pre(n);\n    }\n\n\tNTTFriendlyPoly exp3(int n){\n\t\tNTTFriendlyPoly f{1},g{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tg=g*Mint(2)-(g*g*f).pre(d);\n\n\t\t\tNTTFriendlyPoly q=diff(d-1);\n\t\t\tq=q+g*(f.diff(d-1)-f*q).pre(2*d-1);\n\t\t\tf=f+(f*(pre(2*d)-q.inte(2*d))).pre(2*d);\n\t\t}\n\t\treturn f.pre(n);\n\t}\n\n\n \n    NTTFriendlyPoly log(int n){\n        return (diff(n-1)*inv(n-1)).inte(n);\n    }\n \n    NTTFriendlyPoly pow(int n,mint k){\n\t\tauto res=log(n);\n\t\tres*=k;\n\t\treturn res.exp(n);\n\t}\n\tMint& operator[](const int i){return v[i];}\n};\nusing poly=NTTFriendlyPoly<mint>;\n \ntemplate<class Mint>\nostream& operator<<(ostream& ost,NTTFriendlyPoly<Mint>a){\n    for(int i=0;i<a.size();i++){\n        if(i)cout<<\" \";\n        cout<<a.v[i];\n    }\n    return ost;\n}\n\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=mtable.finv(i)*in*(N+1-i);\n\t}\n \n\tp=p.pow(N+1,M);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*mtable.finv(N-i);\n\t}\n\tans*=mtable.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n    ModInt(int64_t x=0):a((x%mod+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n        if(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=(uint64_t)a*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt x){return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt x){return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt x){return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt x){return ModInt(*this)/=x;}\n\tbool operator==(const ModInt x){return a==x.a;}\n\tbool operator!=(const ModInt x){return a!=x.a;}\n\n\tModInt operator-(){return ModInt(0)-ModInt(*this);}\n\tinline ModInt pow(uint64_t ex)const{\n\t\tuint64_t x=a;\n\t\tuint64_t res=1;\n\t\twhile(ex){\n\t\t\tif(ex&1)res=res*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tex>>=1;\n\t\t}\n\t\treturn ModInt(res);\n\t}\n\n    inline ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t N>\nstruct ModIntTable{\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n){return facts[n];}\n\tinline Mint finv(int n){return finvs[n];}\n\tinline Mint inv(int n){return invs[n];}\n\tinline Mint binom(int n,int k){return facts[n]*finvs[k]*finvs[n-k];}\n};\nModIntTable<mint,1<<19>mtable;\n\n\ntemplate<class Mint,int32_t root>\nstruct NumberTheoreticTransform{\n\tstatic void ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(root).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    static void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tstatic vector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n};\nusing NTT=NumberTheoreticTransform<mint,3>;\n\n\nconst uint32_t mod=998244353;\nconst mint prim_root=3;\n\n\nstatic const int LG=19;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tmint in=mint(n).inv();\n\trep(i,n)\n\t\tf[i]*=in;\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i=false){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\n\n\nvector<mint> multiply(vector<mint> x,vector<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n \ntemplate<class Mint>\nstruct NTTFriendlyPoly{\n\tvoid ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(3).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tvector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n\n\tvector<Mint>v;\n\ttemplate<class...Args>\n\tNTTFriendlyPoly(Args...args):v(args...){}\n \n\tNTTFriendlyPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n \n\tint size()const{return v.size();}\n \n\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n \n\tNTTFriendlyPoly operator+(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator-(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator*(const NTTFriendlyPoly& x){\n\t\treturn multiply(v,x.v);\n\t}\n\tNTTFriendlyPoly operator*(const Mint& x){\n\t\tint n=size();\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator/(const Mint& x){\n\t\treturn (*this)*x.inv();\n\t}\n \n\tNTTFriendlyPoly& operator+=(const NTTFriendlyPoly& x){return *this=(*this)+x;}\n\tNTTFriendlyPoly& operator-=(const NTTFriendlyPoly& x){return *this=(*this)-x;}\n\tNTTFriendlyPoly& operator*=(const NTTFriendlyPoly& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n\tNTTFriendlyPoly operator-(){return NTTFriendlyPoly()-*this;}\n \n    NTTFriendlyPoly pre(int n){\n        NTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n&&i<size();i++)res[i]=v[i];\n\t\treturn res;\n    }\n    NTTFriendlyPoly rev(){\n        vector<Mint>res=v;\n\t\twhile(res.size()&&res.back()==0)res.pop_back();\n        reverse(res.begin(),res.end());\n        return res;\n    }\n    NTTFriendlyPoly diff(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=1;i<size()&&i<=n;i++)res[i-1]=v[i]*i;\n        return res;\n    }\n    NTTFriendlyPoly inte(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=0;i<size()&&i+1<n;i++)res[i+1]=v[i]*mtable.inv(i+1);\n        return res;\n    }\n\n    NTTFriendlyPoly inv(int n){\n        vector<mint>res{coef(0).inv()};\n\n        for(int d=1;d<n;d<<=1){\n            vector<Mint>f(2*d),g(2*d);\n            for(int j=0;j<2*d;j++)f[j]=coef(j);\n            for(int j=0;j<d;j++)g[j]=res[j];\n            \n            inplace_fmt(f);inplace_fmt(g);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++){\n                f[j]=0;\n                f[j+d]=-f[j+d];\n            }\n            inplace_fmt(f);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++)f[j]=res[j];\n            res=f;\n        }\n        return NTTFriendlyPoly(res).pre(n);\n    }\n    \n    \n    NTTFriendlyPoly inv2(int n){\n        NTTFriendlyPoly res{coef(0).inv()};\n        for(int i=1;i<n;i*=2){\n            res=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n        }\n        return res.pre(n);\n    }\n    \n    \n\n\tNTTFriendlyPoly exp(int n){\n\t\tNTTFriendlyPoly f0{1},g0{1};\n\t\tvector<Mint>F0{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tvector<Mint>G0=g0.v;\n\t\t\tinplace_fmt(G0);\n\t\t\tvector<Mint>Delta(d);\n\t\t\tfor(int j=0;j<d;j++)Delta[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tDelta[0]-=1;\n\t\t\tNTTFriendlyPoly delta(2*d);\n\t\t\tfor(int j=0;j<d;j++)delta[d+j]=Delta[j];\t\t\n\t\t\t\n\t\t\tNTTFriendlyPoly epsilon(2*d);\n\t\t\t\n\t\t\n\t\t\t\n\t\t\tvector<Mint>DF0=f0.diff(d-1).v;DF0.push_back(0);\n\t\t\tinplace_fmt(DF0);\n\t\t\tfor(int j=0;j<d;j++)DF0[j]*=G0[j];\n\t\t\tinplace_fmt(DF0,true);\n\t\t\tfor(int j=0;j<d-1;j++){\n\t\t\t\tepsilon[j]+=coef(j+1)*(j+1);\n\t\t\t\tepsilon[j+d]+=DF0[j]-coef(j+1)*(j+1);\n\t\t\t}\n\t\t\tepsilon[d-1]+=DF0[d-1];\n\n\n\t\t\tDelta=delta.v;\n\t\t\tinplace_fmt(Delta);\n\t\t\tvector<Mint>DH0=diff(d-1).v;DH0.resize(2*d);\n\t\t\tinplace_fmt(DH0);\n\t\t\tfor(int j=0;j<2*d;j++)Delta[j]*=DH0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tfor(int j=0;j<d;j++)epsilon[j+d]-=Delta[j+d];\n\t\t\n\n\t\t\tepsilon=epsilon.inte(2*d)-pre(2*d);\n\t\t\t\n\t\t\tvector<Mint>Epsilon=epsilon.v;\n\t\t\tinplace_fmt(Epsilon);\n\t\t\trep(j,d)DH0[j]=f0[j],DH0[j+d]=0;\n\t\t\tinplace_fmt(DH0);\n\t\t\trep(j,2*d)Epsilon[j]*=DH0[j];\n\t\t\tinplace_fmt(Epsilon,true);\n\t\t\tf0.v.resize(2*d);\n\t\t\trep(j,d)f0[j+d]-=Epsilon[j+d];\n\t\t\t//f0=(f0-epsilon*f0).pre(2*d);\n\t\t\t\n\t\t\tG0.resize(2*d);\n\t\t\trep(j,d)G0[j]=g0[j];\n\t\t\tinplace_fmt(G0);\n\t\t\tF0=f0.v; \n\t\t\tinplace_fmt(F0);\n\t\t\tvector<Mint>T(2*d);rep(j,2*d)T[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d){\n\t\t\t\tT[j]=0;\n\t\t\t\tT[j+d]=-T[j+d];\n\t\t\t}\n\t\t\tinplace_fmt(T);\n\t\t\trep(j,2*d)T[j]*=G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d)T[j]=g0[j];\n\t\t\tg0=T;\n\t\t}\n\t\treturn f0.pre(n);\n\t}\n\n    NTTFriendlyPoly exp2(int n){\n        NTTFriendlyPoly f{1};\n        for(int i=1;i<n;i*=2){\n            f=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n        }\n        return f.pre(n);\n    }\n\n\tNTTFriendlyPoly exp3(int n){\n\t\tNTTFriendlyPoly f{1},g{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tg=g*Mint(2)-(g*g*f).pre(d);\n\n\t\t\tNTTFriendlyPoly q=diff(d-1);\n\t\t\tq=q+g*(f.diff(d-1)-f*q).pre(2*d-1);\n\t\t\tf=f+(f*(pre(2*d)-q.inte(2*d))).pre(2*d);\n\t\t}\n\t\treturn f.pre(n);\n\t}\n\n\n \n    NTTFriendlyPoly log(int n){\n        return (diff(n-1)*inv(n-1)).inte(n);\n    }\n \n    NTTFriendlyPoly pow(int n,mint k){\n\t\tauto res=log(n);\n\t\tres*=k;\n\t\treturn res.exp(n);\n\t}\n\tMint& operator[](const int i){return v[i];}\n};\nusing poly=NTTFriendlyPoly<mint>;\n \ntemplate<class Mint>\nostream& operator<<(ostream& ost,NTTFriendlyPoly<Mint>a){\n    for(int i=0;i<a.size();i++){\n        if(i)cout<<\" \";\n        cout<<a.v[i];\n    }\n    return ost;\n}\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=mtable.finv(i)*in*(N+1-i);\n\t}\n\n\tp=p.pow(N+1,M);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*mtable.finv(N-i);\n\t}\n\tans*=mtable.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint mt(int a,int b)\n{\n\tif(b==0)\n\t{\n\t\treturn 1;\n\t}\n\tint c=mt(a,b>>1);\n\tc=(long long)c*c%998244353;\n\tif(b&1)\n\t{\n\t\tc=(long long)c*a%998244353;\n\t}\n\treturn c;\n}\nint jc[524288],injc[524288];\nint main()\n{\n\tinjc[1]=1;\n\tfor(int i=2;i<=500000;i++)\n\t{\n\t\tinjc[i]=(long long)998244353/i*injc[998244353%i]%998244353;\n\t\tinjc[i]=998244353-injc[i];\n\t}\n\tjc[0]=1;\n\tinjc[0]=1;\n\tfor(int i=1;i<=500000;i++)\n\t{\n\t\tjc[i]=(long long)jc[i-1]*i%998244353;\n\t\tinjc[i]=(long long)injc[i-1]*injc[i]%998244353;\n\t}\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tint ans=0;\n\tfor(int i=0;i<=n&&i<=m;i++)\n\t{\n\t\tint inc=jc[n];\n\t\tinc=(long long)inc*injc[n-i]%998244353;\n\t\tinc=(long long)inc*jc[m]%998244353;\n\t\tinc=(long long)inc*injc[m-i]%998244353;\n\t\tinc=(long long)inc*injc[i]%998244353;\n\t\tinc=(long long)inc*mt(n+1,m-i)%998244353;\n\t\tinc=(long long)inc*mt(m+1,n-i)%998244353;\n\t\tif(i&1)\n\t\t{\n\t\t\tans-=inc;\n\t\t\tif(ans<0)\n\t\t\t{\n\t\t\t\tans+=998244353;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans+=inc;\n\t\t\tif(ans>=998244353)\n\t\t\t{\n\t\t\t\tans-=998244353;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define C(n,m) (jc[n]*Jc[m]%998244353*Jc[(n)-(m)]%998244353)\n#define min(a,b) (a<b?a:b)\n#define mod 998244353\n#define Mod 998244351\n#define ll long long\n#define G 3\n//#define file\nusing namespace std;\n\nll A[1048576],B[1048576],a[1048576],b[1048576],w[500001],jc[500001],Jc[500001],ans;\nint N,len,n,m,i,j,k,l;\n\nll qpower(ll a,int b) {ll ans=1;while (b) {if (b&1) ans=ans*a%mod;a=a*a%mod;b>>=1;} return ans;}\nvoid swap(int &x,int &y) {int z=x;x=y;y=z;}\nll dft(ll *a,int type)\n{\n\tint i,j,k,l,S=N,s1=2,s2=1;\n\t\n\tfo(i,0,N-1)\n\t{\n\t\tj=i;k=0;\n\t\tfo(l,1,len) k=k*2+(j&1),j>>=1;\n\t\tA[k]=a[i];\n\t}\n\tmemcpy(a,A,N*8);\n\t\n\tfo(i,1,len)\n\t{\n\t\tll W=(type==1)?qpower(G,(mod-1)/s1):qpower(G,(mod-1)-(mod-1)/s1);\n\t\tS>>=1;\n\t\t\n\t\tfo(j,0,S-1)\n\t\t{\n\t\t\tll w=1;\n\t\t\tfo(k,0,s2-1)\n\t\t\t{\n\t\t\t\tll u=a[j*s1+k],v=a[j*s1+k+s2]*w;\n\t\t\t\ta[j*s1+k]=(u+v)%mod;\n\t\t\t\ta[j*s1+k+s2]=(u-v)%mod;\n\t\t\t\tw=w*W%mod;\n\t\t\t}\n\t\t}\n\t\ts1<<=1,s2<<=1;\n\t}\n}\n\nvoid mul(ll *a,ll *b)\n{\n\tll s=qpower(N,Mod);\n\tint i;\n\t\n\tmemset(B,0,sizeof(B));\n\tmemcpy(B,b,4*N);\n\tdft(a,1);\n\tdft(B,1);\n\tfo(i,0,N-1) a[i]=a[i]*B[i]%mod;\n\tdft(a,-1);\n\tfo(i,0,N/2-1) a[i]=a[i]*s%mod;\n\tfo(i,N/2,N-1) a[i]=0;\n}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"agc035F.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%d%d\",&n,&m);len=ceil(log2(n+1))+1;N=qpower(2,len);\n\tif (n>m) swap(n,m);\n\tjc[0]=jc[1]=Jc[0]=Jc[1]=w[1]=1;fo(i,2,500000) w[i]=mod-w[mod%i]*(mod/i)%mod,jc[i]=jc[i-1]*i%mod,Jc[i]=Jc[i-1]*w[i]%mod;\n\t\n\tfo(i,0,n) a[i]=qpower(n+1,m-i)*C(m,i)*qpower(-1,i)%mod; //or min(n,m)\n\tfo(i,0,n) b[i]=qpower(m,i)*Jc[i]%mod;\n\tmul(a,b);\n\t\n\tfo(i,0,n) ans=(ans+Jc[n-i]*a[i])%mod;\n\tfo(i,1,n) ans=ans*i%mod;\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<climits>\n\ntypedef long long LL;\nusing namespace std;\nconst int mod = 998244353, maxn = 5e5 + 10;\n\nint read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x << 3) + (x << 1) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nint fac[maxn], ifac[maxn], inv[maxn];\n\nint C(int N, int M) { return (LL)fac[N] * ifac[M] % mod * ifac[N - M] % mod; }\n\nint Pow(int x, int p)\n{\n\tint r = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) r = (LL)x * r % mod;\n\t\tx = (LL)x * x % mod; p >>= 1;\n\t}\n\treturn r;\n}\n\nint main()\n{\n\n\tint n = read(), m = read();\n\n\tfac[0] = fac[1] = inv[0] = inv[1] = ifac[0] = ifac[1] = 1;\n\tfor(int i = 2; i <= max(n, m); ++i)\n\t{\n \t\tfac[i] = (LL)fac[i - 1] * i % mod;\n\t\tinv[i] = (LL)(mod - mod / i) * inv[mod % i] % mod;\n\t\tifac[i] = (LL)ifac[i - 1] * inv[i] % mod;\n\t}\n\n\tint ans = 0;\n\tfor(int k = 0; k <= min(n, m); ++k)\n\t\t(ans += (LL)C(n, k) * C(m, k) % mod * fac[k] % mod * Pow(m + 1, n - k) % mod * Pow(n + 1, m - k) % mod * Pow(mod - 1, k) % mod) %= mod;\n\tcout << (ans + mod) % mod << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb push_back\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nint N, M;\nconst int mod = 998244353;\nll F[500050], IF[500050];\nll pw(ll x, ll y = mod - 2) {\n\tll res = 1;\n\twhile(y) {\n\t\tif(y & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nll nCr(int n, int r) {\n\tif(r < 0 || r > n) return 0;\n\treturn F[n] * IF[r] % mod * IF[n-r] % mod;\n}\n\nll f[500050];\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tF[0] = 1; for(int i=1;i<500050;i++) F[i] = i * F[i-1] % mod;\n\tIF[500049] = pw(F[500049]);\n\tfor(int i=500048;i>=0;i--) IF[i] = (i+1) * IF[i+1] % mod;\n\tif(N > M) swap(N, M);\n\tint ans = 0;\n\tfor(int k=0;k<=N;k++) {\n\t\tans = (ans + pw(mod-1, k) * nCr(N, k) % mod * nCr(M, k) % mod * F[k] % mod * pw(M+1, N-k) % mod * pw(N+1, M-k)) % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2019.7.22 by ljz\n//email 573902690@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 1e18+1e9\n#define eps 1e-10\n#define RG register\n#define db double\n#define lb long db\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define pb push_back\n#define gc getchar\n#define Pi 2.0*acos(-1.0)\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void write(RG __int128 x){\n//    if(x>10)write(x/10);\n//    putchar(x%10+'0');\n//}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int kcz=998244353;\nconst int N=5e5+10;\nnamespace MAIN{\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    inline int mul(const res &x,const res &y){\n        return int(1LL*x*y%kcz);\n    }\n    int n,m;\n    int fac[N],inv[N];\n    inline int C(const res &x,const res &y){\n        return mul(fac[x],mul(inv[y],inv[x-y]));\n    }\n    inline int A(const res &x,const res &y){\n        return mul(fac[x],inv[x-y]);\n    }\n    int pwn[N],pwm[N];\n    int ans;\n    inline void MAIN(){\n        n=read(),m=read(),fac[0]=fac[1]=inv[0]=inv[1]=pwn[0]=pwm[0]=1;\n        if(n>m)swap(n,m);\n        for(res i=1;i<=m;i++)pwn[i]=mul(pwn[i-1],n+1),pwm[i]=mul(pwm[i-1],m+1);\n        for(res i=2;i<=m;i++)fac[i]=mul(fac[i-1],i),inv[i]=mul(inv[kcz%i],kcz-kcz/i);\n        for(res i=2;i<=m;i++)inv[i]=mul(inv[i-1],inv[i]);\n        for(res i=0;i<=n;i++)add(ans,i&1?kcz-mul(mul(C(n,i),A(m,i)),mul(pwn[m-i],pwm[n-i])):mul(mul(C(n,i),A(m,i)),mul(pwn[m-i],pwm[n-i])));\n        printf(\"%d\\n\",ans);\n    }\n}\nint main(){\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #define che\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define fi first\n#define se second\n#define MK make_pair\n#define PB push_back\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int ,int> PII;\nconst int N=1e6+10;\nconst LL MOD = 998244353;\nLL fac[N], inv[N], ifac[N], pwm[N], pwn[N];\nint n, m;\nLL C(int n, int m){return fac[n]*ifac[m]%MOD*ifac[n-m]%MOD;}\nLL P(int n, int m){return fac[n]*ifac[n-m]%MOD;}\nvoid upsum(LL &a, LL b){a=(a+b)%MOD;}\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tfor (int i=0; i<2; ++i)fac[i] = ifac[i] = inv[i]=1;\n\tfor (int i=2; i<=1000000; ++i){\n\t\tinv[i] = (MOD-inv[MOD%i])*(MOD/i)%MOD;\n\t\tfac[i] = fac[i-1]*i%MOD;\n\t\tifac[i] = ifac[i-1]*inv[i]%MOD;\n\t}\n\tscanf(\"%d%d\", &n, &m);\n\tif (n>m)swap(n,m);\n\tpwn[0]=pwm[0]=1;\n\tfor (int i=1; i<=m; ++i) pwn[i]=pwn[i-1]*(n+1)%MOD, pwm[i]= pwm[i-1]*(m+1)%MOD;\n\tLL ans=0;\n\tfor (int k=0,sgn=1; k<=n; ++k,sgn=MOD-sgn){\n\t\tupsum(ans, C(n,k)*P(m,k)%MOD*pwm[n-k]%MOD*pwn[m-k]%MOD*sgn%MOD);\n\t\t#ifdef che\n\t\tdebug(\"k=%d, ans=%lld\\n\", k, ans);\n\t\t#endif\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define rrep(i,a,b) for(int i=(a);i>=(b);--i)\ntypedef long long LL;\nconst LL MOD = 998244353;\nconst int N = 5e5;\n\nint n,m;\nLL fac[N+5],ifac[N+5],pwn1[N+5],pwm1[N+5];\n\nLL pw(LL x,int n){\n\tLL res=1;\n\tfor(int y=1;y<=n;y<<=1,x=x*x%MOD) if(n&y) res=res*x%MOD;\n\treturn res;\n}\n\nint main(){\n\tcin>>n>>m;\n\tfac[0]=1;\n\trep(i,1,N)fac[i]=fac[i-1]*i%MOD;\n\tifac[N]=pw(fac[N],MOD-2);\n\trrep(i,N-1,0)ifac[i]=ifac[i+1]*(i+1)%MOD;\n\tpwn1[0] = pwm1[0] = 1;\n\trep(i,1,N) pwn1[i]=pwn1[i-1]*(n+1)%MOD, pwm1[i]=pwm1[i-1]*(m+1)%MOD;\n\t\n\tLL ans = 0;\n\trep(i,0,min(m,n)){\n\t\tLL tmp = fac[m] * ifac[i] % MOD * ifac[m-i] % MOD * fac[n] % MOD * ifac[n-i] % MOD * pwn1[m-i] % MOD * pwm1[n-i] % MOD;\n\t\tans = (i % 2 == 0) ? (ans + tmp) % MOD : (ans - tmp + MOD) % MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 998244353\n#define rep(i,j,k) for(int i=(j),LIM=(k);i<=LIM;i++)\n#define per(i,j,k) for(int i=(j),LIM=(k);i>=LIM;i--)\n#define LL long long\nusing namespace std;\n\nint n,m;\nint Pow(int b,LL k){ int r=1;for(;k;k>>=1,b=1ll*b*b%mod) if(k&1) r=1ll*r*b%mod;return r; }\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint Cn=1,Cm=1,ans=0,fc=1;\n\trep(i,0,min(n,m)){\n\t\tans = (ans + 1ll * Cn * Cm % mod * (i&1 ? -1ll : 1ll) * fc % mod * Pow(m+1,n-i) % mod * Pow(n+1,m-i)) % mod;\n\t\tCn = 1ll * Cn * (n-i) % mod * Pow(i+1 , mod-2) % mod;\n\t\tCm = 1ll * Cm * (m-i) % mod * Pow(i+1 , mod-2) % mod;\t\n\t\tfc = 1ll * fc * (i+1) % mod;\n\t}\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxs=6e5,mod=998244353;\nint n,m,s;\nlong long Ans,fac[maxs],inv[maxs],pown[maxs],powm[maxs];\ninline long long read(){\n\tlong long x=0,f=1;\n\tchar c;\n\tdo{c=getchar();if(c=='-') f*=-1;}while(!isdigit(c));\n\twhile(isdigit(c)){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n\treturn x*f;\n}\nlong long qpow(long long x,int i){\n\tlong long res=1;\n\twhile(i){\n\t\tif(i&1) res=res*x%mod;\n\t\tx=x*x%mod;i>>=1;\n\t}\n\treturn res;\n}\nlong long C(int a,int b){return inv[b]*inv[a-b]%mod*fac[a]%mod;}\nlong long F(int k){return C(n,k)*C(m,k)%mod*fac[k]%mod*(pown[m-k]*powm[n-k]%mod)%mod;}\nint main(){\n\tn=read();m=read();Ans=0;\n\ts=max(n,m);\n\tfac[0]=1;\n\tfor(int i=1;i<=s;i++){fac[i]=fac[i-1]*i%mod;}\n\tinv[s]=qpow(fac[s],mod-2);\n\tfor(int i=s;i>=1;i--){inv[i-1]=inv[i]*i%mod;}\n\tpown[0]=powm[0]=1;\n\tfor(int i=1;i<=s;i++){\n\t\tpown[i]=pown[i-1]*(n+1)%mod;\n\t\tpowm[i]=powm[i-1]*(m+1)%mod;\n\t}\n\tfor(int i=0;i<=n;i++){Ans=(Ans+mod+(i%2==0?1:-1)*(F(i)))%mod;}\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 500005, P = 998244353;\nint n, m, fac[N], ifac[N], pwn[N], pwm[N];\n\nint power(int a, int x) {\n\tint ans = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % P)\n\t\tif (x & 1) ans = 1ll * ans * a % P;\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = pwm[0] = 1; i <= n; ++i)\n\t\tpwm[i] = (m + 1ll) * pwm[i - 1] % P;\n\tfor (int i = pwn[0] = 1; i <= m; ++i)\n\t\tpwn[i] = (n + 1ll) * pwn[i - 1] % P;\n\tfor (int i = fac[0] = 1; i <= max(n, m); ++i)\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\tifac[max(n, m)] = power(fac[max(n, m)], P - 2);\n\tfor (int i = max(n, m); i; --i)\n\t\tifac[i - 1] = 1ll * ifac[i] * i % P;\n\tint ans = 0;\n\tfor (int i = 0; i <= n && i <= m; ++i)\n\t\tans = (ans + (i & 1 ? -1ll : 1ll) * ifac[n - i] * ifac[i] % P * ifac[m - i] % P * pwm[n - i] % P * pwn[m - i]) % P;\n\tans = 1ll * ans * fac[n] % P * fac[m] % P;\n\tprintf(\"%d\\n\", (ans + P) % P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\n\nconstexpr lint MOD = 998244353;\ntemplate <int mod>\nstruct ModInt\n{\n    using lint = long long;\n    int val;\n    constexpr ModInt() : val(0) {}\n    constexpr void _setval(lint v) { v = (v % mod) + mod; val = v >= mod ? v - mod : v; }\n    constexpr ModInt(lint v) { _setval(v); }\n    constexpr operator int() const { return val; }\n    constexpr ModInt operator+(const ModInt &x) const { return ModInt((lint)val + x.val); }\n    constexpr ModInt operator-(const ModInt &x) const { return ModInt((lint)val - x.val); }\n    constexpr ModInt operator*(const ModInt &x) const { return ModInt((lint)val * x.val); }\n    constexpr ModInt operator/(const ModInt &x) const { return ModInt((lint)val * x.inv()); }\n    constexpr ModInt operator-() const { return ModInt(-val); }\n    constexpr ModInt &operator+=(const ModInt &x) { return *this = *this + x; }\n    constexpr ModInt &operator-=(const ModInt &x) { return *this = *this - x; }\n    constexpr ModInt &operator*=(const ModInt &x) { return *this = *this * x; }\n    constexpr ModInt &operator/=(const ModInt &x) { return *this = *this / x; }\n    friend constexpr ModInt operator+(lint a, const ModInt &x) { return ModInt(a % mod + x.val); }\n    friend constexpr ModInt operator-(lint a, const ModInt &x) { return ModInt(a % mod - x.val); }\n    friend constexpr ModInt operator*(lint a, const ModInt &x) { return ModInt(a % mod * x.val); }\n    friend constexpr ModInt operator/(lint a, const ModInt &x) { return ModInt(a % mod * x.inv()); }\n    constexpr bool operator==(const ModInt &x) { return val == x.val; }\n    constexpr bool operator!=(const ModInt &x) { return val != x.val; }\n    friend istream &operator>>(istream &is, ModInt &x) { lint t; is >> t; x = ModInt(t); return is; }\n    friend ostream &operator<<(ostream &os, const ModInt &x) { os << x.val;  return os; }\n\n    constexpr lint power(lint n) const {\n        lint ans = 1, tmp = this->val;\n        while (n) {\n            if (n & 1) ans = ans * tmp % mod;\n            tmp = tmp * tmp % mod;\n            n /= 2;\n        }\n        return ans;\n    }\n    constexpr lint inv() const { return this->power(mod - 2); }\n    constexpr ModInt operator^(lint n) const { return ModInt(this->power(n)); }\n    constexpr ModInt &operator^=(lint n) { return *this = *this ^ n; }\n\n    inline ModInt fac() const {\n        static vector<ModInt> facs;\n        int l0 = facs.size();\n        if (l0 > this->val) return facs[this->val];\n\n        facs.resize(this->val + 1);\n        for (int i = l0; i <= this->val; i++) facs[i] = (i == 0 ? ModInt(1) : facs[i - 1] * ModInt(i));\n        return facs[this->val];\n    }\n\n    ModInt doublefac() const {\n        lint k = (this->val + 1) / 2;\n        if (this->val & 1) return ModInt(k * 2).fac() / ModInt(2).power(k) / ModInt(k).fac();\n        else return ModInt(k).fac() * ModInt(2).power(k);\n    }\n\n    ModInt nCr(const ModInt &r) const {\n        if (this->val < r.val) return ModInt(0);\n        return this->fac() / ((*this - r).fac() * r.fac());\n    }\n};\nusing mint = ModInt<MOD>;\n\nint main()\n{\n    lint N, M;\n    cin >> N >> M;\n    mint ret = 0;\n    REP(i, min(N, M) + 1) // bad がi個\n    {\n        mint tmp = mint(N).nCr(i) * mint(M).nCr(i) * mint(i).fac() * (mint(N + 1) ^ (M - i)) * (mint(M + 1) ^ (N - i));\n        // dbg(i);\n        // dbg(tmp);\n        if (i % 2) ret -= tmp;\n        else ret += tmp;\n    }\n    cout << ret << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author       : YangDavid\n * Created Time : 2019年07月15日 星期一 17时10分20秒\n */\n\n#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int maxn = 555555, MOD = 998244353;\nint muln(int x, int y) { return 1LL * x * y % MOD; }\nint qpow(int x, int y) {\n    int ret = 1;\n    for(; y; y >>= 1, x = muln(x, x))\n        if(y & 1) ret = muln(ret, x);\n    return ret;\n}\nint mo(int x) {\n    if(x < 0) return x + MOD;\n    if(x >= MOD) return x - MOD;\n    return x;\n}\nint fac[maxn], ifac[maxn];\nint C(int n, int m) {\n    if(n < m) return 0;\n    return muln(fac[n], muln(ifac[m], ifac[n - m]));\n}\n\nint main() {\n    fac[0] = ifac[0] = 1;\n    for(int i = 1; i <= 555000; ++i) {\n        fac[i] = muln(fac[i - 1], i);\n        ifac[i] = qpow(fac[i], MOD - 2);\n    }\n\n    int n, m, Min, ans = 0;\n    scanf(\"%d%d\", &n, &m);\n    Min = min(n, m);\n    for(int k = 0; k <= Min; ++k) {\n        ans = mo(ans + ((k&1)?-1:1) * muln(C(n,k),muln(C(m,k),muln(fac[k],muln(qpow(m+1,n-k),qpow(n+1,m-k))))));\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const N = 500000, md = 998244353;\nint fc[N + 1], inv[N + 1], fcin[N + 1];\n\nint ch(int n, int r) { return (ll)fc[n] * fcin[r] % md * fcin[n - r] % md; }\nvoid ad(int &x, int y) { if ((x += y) >= md)x -= md; }\n\nint pw(int x, int p){\n\tint an = 1;\n\twhile (p){\n\t\tif (p & 1)an = (ll)an * x % md;\n\t\tx = (ll)x * x % md;\n\t\tp >>= 1;\n\t}\n\treturn an;\n}\n\nint main(){\n\tfc[0] = 1;\n\tf(i, 1, N + 1)fc[i] = (ll)fc[i - 1] * i % md;\n\tinv[1] = 1;\n\tf(i, 2, N + 1)inv[i] = md - md / i * (ll)inv[md % i] % md;\n\tfcin[0] = 1;\n\tf(i, 1, N + 1)fcin[i] = (ll)fcin[i - 1] * inv[i] % md;\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tif (n > m)swap(n, m);\n\tint an = 0;\n\tf(i, 0, n + 1){\n\t\tint z = (ll)pw(m + 1, n - i) * pw(n + 1, m - i) % md * ch(n, i) % md * ch(m, i) % md * fc[i] % md;\n\t\tif (i & 1)z = md - z;\n\t\tad(an, z);\n\t}\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nusing LL = long long;\n\nconst int maxN = 5e5 + 5;\nconst int mod = 998244353;\n\nint n, m, ans;\nint fac[maxN], inv[maxN];\n\ninline void Mod(int& x)\n{ x >= mod ? x -= mod : x < 0 ? x += mod : 0; }\n\nint QPow(int bas, int ind)\n{\n    int res = 1;\n    while (ind)\n    {\n        if (ind & 1)\n            res = (LL)res * bas % mod;\n        bas = (LL)bas * bas % mod;\n        ind >>= 1;\n    }\n    return res;\n}\n\nvoid Init(int lim)\n{\n    fac[0] = inv[0] = 1;\n    for (int i = 1; i <= lim; ++i)\n        fac[i] = (LL)fac[i - 1] * i % mod;\n    inv[lim] = QPow(fac[lim], mod - 2);\n    for (int i = lim - 1; i; --i)\n        inv[i] = (LL)inv[i + 1] * (i + 1) % mod;\n}\n\ninline int C(int n, int m)\n{ return (LL)fac[n] * inv[m] % mod * inv[n - m] % mod; }\n\nint main()\n{\n    cin >> n >> m;\n    if (n > m)\n        swap(n, m);\n    Init(m);\n    for (int i = 0; i <= n; ++i)\n        if (i & 1)\n            Mod(ans -= (LL)C(n, i) * C(m, i) % mod * fac[i] % mod * QPow(m + 1, n - i) % mod * QPow(n + 1, m - i) % mod);\n        else\n            Mod(ans += (LL)C(n, i) * C(m, i) % mod * fac[i] % mod * QPow(m + 1, n - i) % mod * QPow(n + 1, m - i) % mod);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int D=998244353;\nconst int MAXN=500233;\nint n,m,ans;\nint fac[MAXN],inv[MAXN],N[MAXN],M[MAXN];\n\nint qpow(int x,int y) {\n\tint ret=1;\n\twhile(y) {\n\t\tif(y&1) ret=1ll*ret*x%D;\n\t\tx=1ll*x*x%D;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nvoid first(int lim) {\n\tfac[0]=1;\n\tfor(int i=1;i<=lim;i++) fac[i]=1ll*fac[i-1]*i%D;\n\tinv[lim]=qpow(fac[lim],D-2);\n\tfor(int i=lim-1;~i;i--) inv[i]=1ll*inv[i+1]*(i+1)%D;\n\n\tN[0]=M[0]=1;\n\tfor(int i=1;i<=lim;i++) N[i]=1ll*N[i-1]*(n+1)%D;\n\tfor(int i=1;i<=lim;i++) M[i]=1ll*M[i-1]*(m+1)%D;\n}\nint C(int x,int y) {\n\treturn 1ll*fac[x]*inv[y]%D*inv[x-y]%D;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tif(n>m) swap(n,m);\n\tfirst(m);\n\tfor(int i=0,val;i<=n;i++) {\n\t\tval=1ll*C(n,i)*C(m,i)%D*fac[i]%D*M[n-i]%D*N[m-i]%D;\n\t\tif(i&1) ans=(ans+D-val)%D;\n\t\telse ans=(ans+val)%D;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconst int P = 998244353;\n\nconst int N = 5e5+5;\n\nint f[N];\nint finv[N];\n\nint nk[N];\nint mk[N];\n\nint n,m;\n\nint qpow(int a, int b)\n{\n\tint res = 1;\n\twhile(b)\n\t{\n\t\tif(b%2)\n\t\t\tres = res*a %P;\n\t\t\n\t\ta = a*a %P;\n\t\tb /= 2; \n\t}\n\treturn res;\n}\n\nint getInv(int a)\n{\t\n\treturn qpow(a,P-2);\n}\n\nvoid init()\n{\n\tf[0] = 1;\n\t\n\tint t = max(n,m);\n\t\n\tfor(int i = 1; i <= t; i++)\n\t{\n\t\tf[i] = (f[i-1]*i)%P;\n\t}\n\tfinv[t] = getInv(f[t]) % P;\n\n\tfor(int i = t; i > 0; i--)\n\t{\n\t\tfinv[i-1] = finv[i]*i %P;\n\t}\n\t\n\tnk[0] = 1, mk[0] = 1;\n\tfor(int i = 1; i <= t; i++)\n\t{\n\t\tnk[i] = nk[i-1]*(n+1) % P;\n\t\tmk[i] = mk[i-1]*(m+1) % P;\n\t}\n}\n\nint choose(int a, int b)\n{\n\tint A = f[a]*finv[b] % P;\n\tint B = A*finv[a-b] % P;\n\t\n\tint res = B;\n\n\treturn res; \n}\n\nlong long ans;\n\nint cal(int k)\n{\n//\tint res = (( (nk[m-k]*mk[n-k])%P * f[k])%P *(choose(n,k)*choose(m,k))%P) % P;\n\t\n\tint res;\n\tint A = nk[m-k]*mk[n-k]%P;\n\tint B = A*f[k] %P;\n\tint C = B*choose(n,k) %P;\n\tint D = C*choose(m,k) %P;\n\tres = D;\n\t\n\tif(k%2)\n\t{\n\t\treturn -res;\n\t}\n\telse\n\t{\n\t\treturn res;\n\t}\n}\n\nvoid debug()\n{\n\tfor(int i = 0; i <= max(n,m); i++)\n\t{\n\t\tprintf(\"f[%lld]=%lld\\n\",i,f[i]);\n\t}\n}\n\nsigned main()\n{\n\tcin >> n >> m;\n\t\n\tinit();\n//\tdebug();\n\t\n\tfor(int i = 0; i <= min(n,m); i++)\n\t{\n\t\tans += cal(i);\n\t\tans = (ans+P) %P;\n//\t\tprintf(\"res[%lld]=%lld\\n\", i, cal(i));\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define stt static\n#define rg register\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n#define y1 substitute_of_y1\n#define DEBUG(x) cerr<<#x\" = \"<<x<<endl;\nusing namespace std;\n\ntemplate<typename T> il T rd(){\n\tT nmb=0;int sgn=0;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-')sgn=1;chr=getchar();}\n\twhile(isdigit(chr)){nmb=(nmb<<3)+(nmb<<1)+chr-'0';chr=getchar();}\n\treturn sgn?-nmb:nmb;\n}\ntemplate<typename T> void wt(T nmb){\n\tif(nmb>9)wt(nmb/10);\n\tputchar(nmb%10+'0');\n}\ntemplate<typename T> il void cmax(T &x,T y){x=x>y?x:y;}\ntemplate<typename T> il void cmin(T &x,T y){x=x<y?x:y;}\ninline void proc_status(){\n\tifstream t (\"/proc/self/status\");\n\tcerr<<string(istreambuf_iterator<char>(t),istreambuf_iterator<char>())<<endl;\n\t/*freopen(\"/proc/self/status\",\"r\",stdin);\n\tchar ch[100];\n\twhile(scanf(\"%s\",ch)!=EOF)cerr<<ch<<endl;*/\n}\n\nconst int N=5e5+10;\nconst int P=998244353;\n\nint fac[N],inv[N];\nil int pwr(int x,int y){\n\tint z=1;\n\tfor(;y;y>>=1,x=(ll)x*x%P)\n\t\tif(y&1)z=(ll)z*x%P;\n\treturn z;\n}\nil void getfac(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=(ll)fac[i-1]*i%P;\n\tinv[n]=pwr(fac[n],P-2);\n\tfor(int i=n;i;--i)\n\t\tinv[i-1]=(ll)inv[i]*i%P;\n}\nil int C(int n,int m){\n\tif(n<0||m<0||n<m)return 0;\n\treturn (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\n\nint main(){\n\tint n=rd<int>(),m=rd<int>();\n\tgetfac(max(n,m));\n\tint Ans=0;\n\tfor(int i=0,lim=min(n,m);i<=lim;++i)\n\t\t(Ans+=(ll)(i&1?P-1:1)*C(n,i)%P*C(m,i)%P*fac[i]%P*pwr(n+1,m-i)%P*pwr(m+1,n-i)%P)%=P;\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=500005,mod=998244353;\nint n,m,d,ans,fact[N],inv[N],pwn[N],pwm[N];\ninline void inc(int& x,CI y)\n{\n\tif ((x+=y)>=mod) x-=mod;\n}\ninline void dec(int& x,CI y)\n{\n\tif ((x-=y)<0) x+=mod;\n}\ninline int quick_pow(int x,int p=mod-2,int mul=1)\n{\n\tfor (;p;p>>=1,x=1LL*x*x%mod) if (p&1) mul=1LL*mul*x%mod; return mul;\n}\ninline void init(CI n,CI m)\n{\n\tRI i; for (fact[0]=i=1;i<=m;++i) fact[i]=1LL*fact[i-1]*i%mod;\n\tfor (inv[m]=quick_pow(fact[m]),i=m-1;~i;--i) inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tfor (pwn[0]=i=1;i<=m;++i) pwn[i]=1LL*pwn[i-1]*(n+1)%mod;\n\tfor (pwm[0]=i=1;i<=m;++i) pwm[i]=1LL*pwm[i-1]*(m+1)%mod;\n}\ninline int C(CI n,CI m)\n{\n\treturn 1LL*fact[n]*inv[m]%mod*inv[n-m]%mod;\n}\ninline int A(CI n,CI m)\n{\n\treturn 1LL*fact[n]*inv[n-m]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m); if (n>m) swap(n,m);\n\tinit(n,m); for (RI i=0;i<=n;++i)\n\t{\n\t\tint d=1LL*C(n,i)*A(m,i)%mod*pwm[n-i]%mod*pwn[m-i]%mod;\n\t\tif (i&1) dec(ans,d); else inc(ans,d);\n\t}\n\treturn printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n//#define int long long\nusing namespace std;\nconst int maxn=5e5+1000;\ntypedef long long ll;\nint n,m;\nconst int mod=998244353;\nint fr[maxn],ans;\ninline int ksm(int num,int t){\n\tint res=1;\n\tfor(;t;t>>=1,num=1ll*num*num%mod){\n\t\tif(t&1)res=1ll*res*num%mod;\n\t}\n\treturn res;\n}\ninline int c(int m,int n){\n\treturn 1ll*fr[n]*ksm((1ll*fr[m]*fr[n-m])%mod,mod-2)%mod;\t\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfr[0]=fr[1]=1;\n\tfor(int i=2;i<maxn;i++)fr[i]=1ll*fr[i-1]*i%mod;\t\n\tfor(int i=0;i<=min(n,m);i++){\n\t\tans=(ans+1ll*ksm(-1,i)*(1ll*c(i,n)*c(i,m)%mod*fr[i]%mod*ksm(m+1,n-i)%mod*ksm(n+1,m-i)%mod)%mod)%mod;\t\n\t}\n\tans=(ans%mod+mod)%mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inv(x) power(x,Mod-2)\n#define upd(a,b) a=add(a,b)\n#define rdc(a,b) a=sub(a,b)\nusing namespace std;\ntypedef long long ll;\nconst int Mod=998244353;\nint add(int a,const int b){a+=b;if(a>=Mod)a-=Mod;return a;}\nint sub(int a,const int b){a-=b;if(a<0)a+=Mod;return a;}\nint mul(const int a,const int b){return (ll)a*b%Mod;}\nint power(int x,int cs)\n{\n\tint ras=1;\n\twhile(cs)\n\t{\n\t\tif(cs&1) ras=mul(ras,x);\n\t\tx=mul(x,x);cs>>=1;\n\t}\n\treturn ras;\n}\nconst int N=5e5+50,pn=5e5+10;\nint n,m,ans=0;\nint zp[N],fp[N],cf1[N],cf2[N];\nint C(int a,int b){return mul(zp[a],mul(fp[b],fp[a-b]));}\nvoid init()\n{\n\tint i;\n\tzp[0]=fp[0]=1;\n\tfor(i=1;i<=pn;i++) zp[i]=mul(zp[i-1],i);\n\tfp[pn]=inv(zp[pn]);\n\tfor(i=pn-1;i>=1;i--) fp[i]=mul(fp[i+1],i+1);\n}\nint main()\n{\n\tint i,tmp;\n\tinit();\n\tcin>>n>>m;\n\tcf1[0]=1;\n\tfor(i=1;i<=n;i++) cf1[i]=mul(cf1[i-1],m+1);\n\tcf2[0]=1;\n\tfor(i=1;i<=m;i++) cf2[i]=mul(cf2[i-1],n+1);\n\tfor(i=0;i<=min(n,m);i++)\n\t{\n\t\ttmp=mul(mul(cf1[n-i],cf2[m-i]),mul(zp[i],mul(C(n,i),C(m,i))));\n\t\tif(i&1) rdc(ans,tmp);\n\t\telse upd(ans,tmp);\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m;\nll f[500005],r[500005],ans;\nll modpow(ll x,ll n){\n\tll ret = 1;\n\twhile(n){\n\t\tif(n%2) ret = ret*x%mod;\n\t\tn /= 2;\n\t\tx = x*x%mod;\n\t}\n\treturn ret;\n}\nll C(int n,int m){\n\tif(m < 0 || n < m) return 0;\n\treturn f[n] * r[m] % mod * r[n-m] % mod;\n}\nint main(){\n\tcin >> n >> m;\n\tll ans = 0;\n\tf[0] = 1;\n\tfor(int i=1;i<500005;i++) f[i] = f[i-1]*1LL*i%mod;\n\tr[500004] = modpow(f[500004],mod-2);\n\tfor(int i=500003;i>=0;i--) r[i] = r[i+1]*1LL*(i+1)%mod;\n\t\n\tfor(int i=0;i<=min(n,m);i++){\n\t\tll way = C(n,i)*C(m,i)%mod*f[i]%mod*modpow(m+1,n-i)%mod*modpow(n+1,m-i)%mod;\n\t\tif(i%2 == 0) ans += way;\n\t\telse ans -= way;\n\t}\n\tcout << (ans%mod+mod)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct ModInt{\n\tuint a;\n    ModInt(ll x=0):a((x+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\tif((a+=x.a)>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\tif((a+=mod-x.a)>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=ull(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nconst int N=5e5+2;\nconst int mod=998244353;\nusing namespace std;\nint fact[N],inv[N],pn[N],pm[N];\nint binpow(int x,int y){\n\tint tich=1;\n\twhile(y){\n\t\tif(y&1){\n\t\t\ttich*=x;\n\t\t\ttich%=mod;\n\t\t}\n\t\tx*=x;\n\t\tx%=mod;\n\t\ty>>=1;\n\t}\n\treturn tich;\n}\nint C(int x,int y){\n\treturn (fact[y]*((inv[x]*inv[y-x])%mod))%mod;\n}\nsigned main(){\n\tint n,m,i,j=1,ans=0;\n\tcin>>n>>m;\n\tfact[0]=1;\n\tpn[0]=1;\n\tpm[0]=1;\n\tfor(i=1;i<=max(n,m);i++){\n\t\tpn[i]=(pn[i-1]*(n+1))%mod;\n\t\tpm[i]=(pm[i-1]*(m+1))%mod;\n\t\tfact[i]=(fact[i-1]*i)%mod;\n//\t\tcout<<fact[i]<<endl;\n\t}\n\tinv[max(n,m)]=binpow(fact[max(n,m)],mod-2);\n\tfor(i=max(n,m);i>=1;i--){\n\t\tinv[i-1]=(inv[i]*i)%mod;\n//\t\tcout<<inv[i]<<endl;\n\t}\n\tfor(i=0;i<=min(n,m);i++){\n\t\tans+=j*((((C(i,n)*C(i,m))%mod)*((fact[i]*pn[m-i])%mod))%mod)*pm[n-i];\n\t\tans%=mod;\n\t\tif(ans<0){\n\t\t\tans+=mod;\n\t\t}\n\t\tj*=-1;\n//\t\tcout<<i<<' '<<ans<<endl;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define mp make_pair\n#define squ(x) ((LL)(x) * (x))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\n\ntemplate<typename T> inline T read() {\n\tT sum = 0, fg = 1; char c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') fg = -1;\n\tfor (; isdigit(c); c = getchar()) sum = (sum << 3) + (sum << 1) + (c ^ 0x30);\n\treturn fg * sum;\n}\n\nconst int maxn = 5e5 + 10;\nconst int mod = 998244353;\n\nint n, m;\n\ninline void Add(int &x, int y) { y += (y < 0 ? mod : 0), x += y, x -= (x >= mod ? mod : 0); }\ninline int Pow(int x, int y) {\n\tint res = 1;\n\tfor (; y; y >>= 1, x = squ(x) % mod) if (y & 1) res = (LL) res * x % mod;\n\treturn res;\n}\n\nint fac[maxn], ifac[maxn];\ninline void init(int N) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N; i++) fac[i] = (LL) fac[i - 1] * i % mod;\n\tifac[N] = Pow(fac[N], mod - 2);\n\tfor (int i = N - 1; ~i; i--) ifac[i] = (LL) ifac[i + 1] * (i + 1) % mod;\n}\ninline int C(int _n, int _m) { return (LL) fac[_n] * ifac[_n - _m] % mod * ifac[_m] % mod ; }\n\ninline int f(int k) { return (LL) C(n, k) * C(m, k) % mod * fac[k] % mod * Pow(m + 1, n - k) % mod * Pow(n + 1, m - k) % mod; }\n\nint main() {\n#ifdef xunzhen\n\tfreopen(\"calc.in\", \"r\", stdin);\n\tfreopen(\"calc.out\", \"w\", stdout);\n#endif\n\n\tn = read<int>(), m = read<int>(), init(max(n, m));\n\n\tint ans = 0;\n\tfor (int i = 0, e = min(n, m); i <= e; i++) Add(ans, (i & 1 ? -1 : 1) * f(i));\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define inc(i,j,k) for(re int i=j;i<=k;i++)\n#define dec(i,j,k) for(re int i=j;i>=k;i--)\n#define ll long long \nusing namespace std;\nconst int N=5e5+5;\nconst int mod=998244353;\ninline int read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x;\n}\nint n,m;\nll fac[N],inv[N];\nll qp(ll x,ll k){ \n\tll res=1;\n\twhile(k){\n\t\tif(k&1) res=res*x%mod;\n\t\tk>>=1,x=x*x%mod;\n\t}\n\treturn res;\n}\nll c(int n,int m){\n\tif(n<m||n<0||m<0) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main(){\n\tn=read(),m=read();\n\tfac[0]=inv[0]=inv[1]=1;\n\tinc(i,1,max(n,m)) fac[i]=fac[i-1]*i%mod;\n\tinc(i,2,max(n,m)) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tinc(i,3,max(n,m)) inv[i]=inv[i-1]*inv[i]%mod; \n\tll ans=0;\n\tinc(i,0,min(n,m)){\n\t\tif(i&1) (ans+=mod-c(n,i)*c(m,i)%mod*fac[i]%mod*qp(m+1,n-i)%mod*qp(n+1,m-i)%mod)%=mod;\n\t\telse (ans+=c(n,i)*c(m,i)%mod*fac[i]%mod*qp(m+1,n-i)%mod*qp(n+1,m-i)%mod)%=mod;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define N 1000102\nconst int p=998244353;\nint n,m,f[N],finv[N],inv[N];\ninline int C(int nn,int mm)\n{\n    if(nn<mm)return 0;\n    return 1ll*f[nn]*finv[mm]%p*finv[nn-mm]%p;\n}\ninline int ksm(int d,int k){int ret=1;while(k){if(k&1)ret=1ll*ret*d%p;d=1ll*d*d%p;k>>=1;}return ret;}\nint main()\n{\n    f[0]=finv[0]=f[1]=finv[1]=inv[1]=1;\n    for(int i=2;i<=1000000;i++)\n    {\n        inv[i]=1ll*(p-p/i)*inv[p%i]%p;\n        f[i]=1ll*f[i-1]*i%p;finv[i]=1ll*finv[i-1]*inv[i]%p;\n    }\n    scanf(\"%d%d\",&n,&m);if(n>m)swap(n,m);\n    int ans=0;\n    for(int i=0;i<=n;i++)\n    {\n        int te=1ll*C(n,i)*C(m,i)%p*f[i]%p*ksm(m+1,n-i)%p*ksm(n+1,m-i)%p;\n        if(i&1)ans=(ans-te+p)%p;\n        else ans=(ans+te)%p;\n    }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\n#define rg register\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 500005;\nconst int MOD = 998244353;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nnamespace ModCalculator {\n\ninline void Inc(int &x, int y) {\n\tx += y; if (x >= MOD) x -= MOD;\n}\ninline void Dec(int &x, int y) {\n\tx -= y; if (x < 0) x += MOD;\n}\ninline int Add(int x, int y) {\n\tInc(x, y); return x;\n}\ninline int Sub(int x, int y) {\n\tDec(x, y); return x;\n}\ninline int Mul(int x, int y) {\n\treturn 1LL * x * y % MOD;\n}\n\n}\nusing namespace ModCalculator;\n\ninline int ksm(int x, int k) {\n\tint ret = 1;\n\twhile (k) {\n\t\tif (k & 1) ret = Mul(ret, x);\n\t\tx = Mul(x, x);\n\t\tk >>= 1;\n\t}\n\treturn ret;\n}\n\nint n, m;\nint fac[MAXN], finv[MAXN], npw[MAXN], mpw[MAXN];\n\ninline int C(int x, int y) {\n\treturn Mul(fac[x], Mul(finv[y], finv[x - y]));\n}\n\nvoid init() {\n\tread(n); read(m);\n\tif (n > m) swap(n, m);\n\tfac[0] = 1;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tfac[i] = Mul(fac[i - 1], i);\n\t}\n\tfinv[m] = ksm(fac[m], MOD - 2);\n\tfor (int i = m - 1; i >= 0; --i) {\n\t\tfinv[i] = Mul(finv[i + 1], i + 1);\n\t}\n\tnpw[0] = mpw[0] = 1;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tnpw[i] = Mul(npw[i - 1], n + 1);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tmpw[i] = Mul(mpw[i - 1], m + 1);\n\t}\n}\n\nvoid solve() {\n\tint ans = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tint tmp = Mul(Mul(Mul(C(n, i), C(m, i)), fac[i]), Mul(npw[m - i], mpw[n - i]));\n\t\t(i & 1)? Dec(ans, tmp) : Inc(ans, tmp);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define forg(i,x) for(int i=first[x];i;i=nxt[i])\n#define uu unsigned\n#define fi first\n#define se second\n#define od(x) ((x)&1)\n#define ev(x) (od(x)^1)\n#define mi2(x) (1<<(x))\n#define scanf a1234=scanf\n#define fre(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nint a1234;\nchar buf[1<<18],*bufs=buf,*buft=buf;\ninline int gc(){\n    return bufs==buft&&(buft=(bufs=buf)+fread(buf,1,1<<18,stdin)),bufs==buft?-1:*bufs++;\n}\ninline void xxx(){for(;;);}\n\nconst int mxn=5e5+3,mod=998244353;int n,m;\nlong long jc[mxn],inv[mxn];\ninline long long por(long long a,int b){\n\tlong long res=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)res=res*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn res;\n}\ninline long long C(int a,int b){return jc[a]*inv[a-b]%mod*inv[b]%mod;}\ninline long long P(int a,int b){return jc[a]*inv[a-b]%mod;}\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    jc[0]=inv[0]=1;for(int i=1;i<mxn;++i)jc[i]=jc[i-1]*i%mod;\n    inv[mxn-1]=por(jc[mxn-1],mod-2);for(int i=mxn-2;i;--i)inv[i]=inv[i+1]*(i+1)%mod;\n    int ans=0;\n    for(int i=0,fu=-1;i<=min(n,m);++i){\n    \tfu*=-1;\n    \tans+=P(n,i)*C(m,i)%mod*/*por(2,i)%mod**/por(m+1,n-i)%mod*por(n+1,m-i)%mod*fu,ans%=mod;\n//    \tprintf(\"%d\\n\",ans);\n    }\n    if(ans<0)ans+=mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define int long long\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') bo = -1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tres = (res << 1) + (res << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn bo * res;\n}\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = read();\n}\n\ntemplate <typename T, typename... Argv>\nvoid read(T &a, Argv &... argv) {\n\tread(a);\n\tread(argv...);\n}\n\nconst int N = 1e6 + 100, p = 998244353;\nint fac[N], inv[N], _n[N], _m[N];\n\ntemplate <typename T>\nT mul(T x, T y) {\n\treturn 1LL * x * y % p;\n}\n\ntemplate <typename T, typename... Argv>\nT mul(T x, Argv... argv) {\n\treturn mul(x, mul(argv...));\n}\n\nint ksm(int x, int y) {\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nvoid init(int n, int m) {\n\tint M = std::max(n, m);\n\tfac[0] = _n[0] = _m[0] = 1;\n\tfor (int i = 1; i <= M; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[n] = ksm(fac[n], p - 2);\n\tfor (int i = n; i >= 1; --i) inv[i - 1] = mul(inv[i], i);\n\tfor (int i = 1; i <= M; ++i) _n[i] = mul(_n[i - 1], n + 1);\n\tfor (int i = 1; i <= M; ++i) _m[i] = mul(_m[i - 1], m + 1);\n}\n\nint C(int n, int m) {\n\treturn mul(fac[n], inv[m], inv[n - m]);\n}\n\nsigned main() {\n\tint n = read(), m = read(), ans = 0;\n\tinit(n, m);\n\tfor (int i = 0, opt = 1; i <= std::min(n, m); ++i, opt = p - opt) {\n\t\tans = (ans + 1LL * opt * C(n, i) % p * C(m, i) % p * fac[i] % p * _m[n - i] % p * _n[m - i] % p) % p;\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m;\nlong long inv[100010];\nlong long qpow(long long a,long long b){\n\tlong long ans=1,base=a;\n\twhile(b){\n\t\tif(b&1){\n\t\t\tans*=base;\n\t\t\tans%=998244353;\n\t\t}\n\t\tbase*=base;\n\t\tbase%=998244353;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nlong long cn[100010];\nlong long cm[100010];\nlong long ans;\nlong long jc[100010];\nlong long m_[100010];\nlong long n_[100010];\nint main(){\n\tcin>>n>>m;\n\tinv[1]=1;\n\tfor(long long i=2;i<=max(n,m);i++){\n\t\tinv[i]=(998244353ll-998244353ll/i)*inv[998244353ll%i]%998244353ll;\n\t}\n\tjc[0]=jc[1]=1;\n\tfor(long long i=2;i<=max(n,m);i++){\n\t\tjc[i]=jc[i-1]*i%998244353ll;\n\t}\n\tcn[0]=1;\n\tfor(long long i=0;i<n;i++){\n\t\tcn[i+1]=cn[i]*(n-i)%998244353ll*inv[i+1]%998244353ll;\n\t}\n\tcm[0]=1;\n\tfor(long long i=0;i<m;i++){\n\t\tcm[i+1]=cm[i]*(m-i)%998244353ll*inv[i+1]%998244353ll;\n\t}\n\tm_[0]=n_[0]=1;\n\tfor(long long i=1;i<=max(m,n);i++){\n\t\tm_[i]=m_[i-1]*(m+1)%998244353ll;\n\t\tn_[i]=n_[i-1]*(n+1)%998244353ll;\n\t}\n\tfor(long long i=0;i<=min(n,m);i++){\n\t\tlong long s=cn[i]*cm[i]%998244353ll*jc[i]%998244353ll*m_[n-i]%998244353ll*n_[m-i]%998244353ll;\n\t\tans=i&1?(ans-s):(ans+s);\n\t\tans=(ans%998244353ll+998244353ll)%998244353ll;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 20000000;\nconst int MOD = 998244353;\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\twhile( p ) {\n\t\tif( p & 1 ) ret = 1LL*ret*b%MOD;\n\t\tb = 1LL*b*b%MOD;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nint fct[MAXN + 5], ifct[MAXN + 5];\nvoid init() {\n\tfct[0] = 1;\n\tfor(int i=1;i<=MAXN;i++)\n\t\tfct[i] = 1LL*fct[i-1]*i%MOD;\n\tifct[MAXN] = pow_mod(fct[MAXN], MOD-2);\n\tfor(int i=MAXN-1;i>=0;i--)\n\t\tifct[i] = 1LL*ifct[i+1]*(i+1)%MOD;\n}\nint pw1[MAXN + 5], pw2[MAXN + 5];\nint main() {\n\tinit();\tint N, M;\n\tscanf(\"%d%d\", &N, &M);\n\tint ans = 0;\n\tpw1[0] = pw2[0] = 1;\n\tfor(int i=1;i<=max(N, M);i++)\n\t\tpw1[i] = 1LL*pw1[i-1]*(N+1)%MOD, pw2[i] = 1LL*pw2[i-1]*(M+1)%MOD;\n\tfor(int i=0,f=1;i<=min(N,M);i++,f=1LL*f*(MOD-1)%MOD) {\n\t\tint del = 1LL*ifct[N-i]*ifct[M-i]%MOD*ifct[i]%MOD;\n\t\tdel = 1LL*del*pw1[M-i]%MOD*pw2[N-i]%MOD;\n\t\tans = (ans + 1LL*f*del)%MOD;\n\t}\n\tprintf(\"%lld\\n\", 1LL*ans*fct[N]%MOD*fct[M]%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint fac[500005], ifac[500005];\n\nint power(int x, int t)\n{\n\tint ret = 1;\n\twhile(t > 0) {\n\t\tif(t & 1) ret = 1LL * ret * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tfac[0] = 1;\n\trep1(i, 500000) fac[i] = 1LL * fac[i - 1] * i % MOD;\n\tifac[500000] = power(fac[500000], MOD - 2);\n\tfor(int i = 500000; i >= 1; i --) ifac[i - 1] = 1LL * ifac[i] * i % MOD;\n\t\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tint ret = 0;\n\tfor(int i = 0; i <= min(n, m); i ++) {\n\t\tint ca = 1LL * fac[m] * ifac[m - i] % MOD;\n\t\tca = 1LL * fac[n] * ifac[i] % MOD * ifac[n - i] % MOD * ca % MOD;\n\t\tca = 1LL * power(m + 1, n - i) * power(n + 1, m - i) % MOD * ca % MOD;\n\t\tif(i & 1) ret = (ret - ca + MOD) % MOD;\n\t\telse ret = (ret + ca) % MOD;\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') bo = -1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tres = (res << 1) + (res << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn bo * res;\n}\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = read();\n}\n\ntemplate <typename T, typename... Argv>\nvoid read(T &a, Argv &... argv) {\n\tread(a);\n\tread(argv...);\n}\n\nconst int N = 1e6 + 100, p = 998244353;\nint fac[N], inv[N], _n[N], _m[N];\n\ntemplate <typename T>\nT mul(T x, T y) {\n\treturn 1LL * x * y % p;\n}\n\ntemplate <typename T, typename... Argv>\nT mul(T x, Argv... argv) {\n\treturn mul(x, mul(argv...));\n}\n\nint ksm(int x, int y) {\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nvoid init(int n, int m) {\n\tint M = std::max(n, m);\n\tfac[0] = _n[0] = _m[0] = 1;\n\tfor (int i = 1; i <= M; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[n] = ksm(fac[n], p - 2);\n\tfor (int i = n; i >= 1; --i) inv[i - 1] = mul(inv[i], i);\n\tfor (int i = 1; i <= M; ++i) _n[i] = mul(_n[i - 1], n + 1);\n\tfor (int i = 1; i <= M; ++i) _m[i] = mul(_m[i - 1], m + 1);\n}\n\nint C(int n, int m) {\n\treturn m > n || m < 0 ? 0 : mul(fac[n], inv[m], inv[n - m]);\n}\n\nint main() {\n\tint n = read(), m = read(), ans = 0;\n\tinit(n, m);\n\tfor (int i = 0, opt = 1; i <= std::min(n, m); ++i, opt = p - opt) {\n\t\t(ans += mul(opt, C(n, i), C(m, i), fac[i], _m[n - i], _n[m - i])) %= p;\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define MAXN 500006\n#define P 998244353\nint n , m;\n\nint Pow( int x , int a ) {\n    int ret = 1;\n    while( a ) {\n        if( a & 1 ) ret = 1ll * ret * x % P;\n        x = 1ll * x * x % P , a >>= 1;\n    }\n    return ret;\n}\n\nint J[MAXN] , iJ[MAXN];\n\nint C( int a , int b ) {\n    return J[a] * 1ll * iJ[b] % P * iJ[a - b] % P;\n}\n\nint main() {\n    J[0] = iJ[0] = 1;\n    for( int i = 1 ; i < MAXN ; ++ i ) J[i] = J[i - 1] * 1ll * i % P , iJ[i] = Pow( J[i] , P - 2 );\n    cin >> n >> m;\n    int lim = min( n , m );\n    int c = 0 , res = 0;\n    for( int i = 0 , zjk ; i <= lim ; ++ i ) {\n        zjk = C( n , i ) * 1ll * C( m , i ) % P * J[i] % P * Pow( n + 1 , m - i ) % P * Pow( m + 1 , n - i ) % P;\n        if( c ) zjk = P - zjk;\n        c ^= 1;\n        res = ( res + zjk ) % P;\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define retrun return\n#define cpnst const\nint n,m;\ntypedef long long ll;\ncpnst ll mod=119<<23|1;\nll fac[1111111],inv[1111111],pwn[1111111],pwm[1111111];\nll qpow(ll x,ll k){ll r=1;for(;k;k>>=1,(x*=x)%=mod)if(k&1)(r*=x)%=mod;return r;}\nvoid precalc()\n{\n\tregister int i;\n\tcpnst int lim=1e6;\n\tfor(i=fac[0]=1;i<=lim;i++)fac[i]=fac[i-1]*i%mod;\n\tfor(i=lim,inv[i]=qpow(fac[i],mod-2);i;i--)inv[i-1]=inv[i]*i%mod;\n}\nll C(ll n,ll r){return fac[n]*inv[r]%mod*inv[n-r]%mod;}\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m),precalc();\n\tregister int i;\n\tfor(i=pwn[0]=pwm[0]=1;i<=1e6;i++)pwn[i]=pwn[i-1]*(n+1)%mod,pwm[i]=pwm[i-1]*(m+1)%mod;\n\tll ans=0;\n\tfor(i=0;i<=n&&i<=m;i++)\n\t{\n\t\tll d=C(n,i)*C(m,i)%mod*fac[i]%mod*pwn[m-i]%mod*pwm[n-i]%mod;\n\t\tans+=(i&1)?mod-d:d;\n\t}printf(\"%lld\\n\",ans%mod);\n}\n/*\nJust go for it.\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nint fact[500050],inv[500050];\n\nint qpow(int base,int tms)\n{\n    int tmp = 1;\n    while(tms)\n    {\n        if(tms & 1) tmp = tmp * 1ll * base % mod;\n        base = base * 1ll * base % mod;\n        tms >>= 1;\n    }\n    return tmp;\n}\n\nint C(int n,int r)\n{\n    return fact[n] * 1ll * inv[r] % mod * inv[n - r] % mod;\n}\n\nint main()\n{\n    fact[0] = inv[0] = 1;\n    for(int i = 1;i <= 500000; ++ i)\n        fact[i] = fact[i - 1] * 1ll * i % mod;\n    inv[500000] = qpow(fact[500000],mod - 2);\n    for(int i = 499999;i >= 1; -- i)\n        inv[i] = inv[i + 1] * 1ll * (i + 1) % mod;\n    int n,m; scanf(\"%d%d\",&n,&m);\n    int lim = min(n,m),ans = 0;\n    for(int i = 0,sgn = 1;i <= lim; ++ i,sgn = mod - sgn)\n        ans = (ans + sgn * 1ll * C(n,i) % mod * C(m,i) % mod * qpow(n + 1,m - i) % mod * qpow(m + 1,n - i) % mod) % mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;\nusing std::endl;\n\nconst int P = 998244353, N = 5e5 + 233;\n\ninline int fpow(int x, int y) {\n  int ret = 1;\n  for ( ; y; y >>= 1, x = 1ll * x * x % P)\n    if (y & 1) ret = 1ll * ret * x % P;\n  return ret;\n}\n\nint n, m, fac[N], inv[N], ans;\n\ninline int binom(int x, int y) {\n  if (x < y) return 0;\n  return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\n\nint main() {\n  for (int i = fac[0] = 1; i < N; ++i)\n    fac[i] = 1ll * fac[i - 1] * i % P;\n  inv[N - 1] = fpow(fac[N - 1], P - 2);\n  for (int i = N - 1; i; --i )\n    inv[i - 1] = 1ll * inv[i] * i % P;\n  std::cin >> n >> m;\n  if (n < m) std::swap(n, m);\n  for (int i = 0; i <= m; ++i) {\n    int tmp = 1ll * ((i & 1) ? P - 1 : 1) * binom(n, i) % P * binom(m, i) % P * fac[i] % P\n      * fpow(m + 1, n - i) % P * fpow(n + 1, m - i) % P;\n    ans = (ans + tmp) % P;\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct ModInt{\n\tuint a;\n    ModInt(ll x=0):a((a+=mod)<mod?a:a-mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta=(a+=x.a)<mod?a:a-mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta=(a+=mod-x.a)<mod?a:a-mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=ull(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 500005\nusing namespace std;\nconst int mod = 998244353;\nint n,m,ans,fac[maxn],inv[maxn];\nint Pow(int a,int b){int s=1;for(;b;b>>=1,a=1ll*a*a%mod) b&1&&(s=1ll*s*a%mod);return s;}\nint C(int n,int m){return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m); if(n>m) swap(n,m);\n\tfor(int i=fac[0]=inv[0]=1;i<=m;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[m]=Pow(fac[m],mod-2);\n\tfor(int i=m-1;i>=1;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tfor(int i=0;i<=n;i++) ans=(ans+(i&1?-1:1)*1ll*C(n,i)*C(m,i)%mod*fac[i]%mod*Pow(m+1,n-i)%mod*Pow(n+1,m-i))%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MN 500000\n#define mod 998244353\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m,ans,p[MN+5],inv[MN+5];\ninline int C(int n,int m){return m>n?0:1LL*p[n]*inv[m]%mod*inv[n-m]%mod;}\ninline int pw(int x,int k)\n{\n    int res=1;\n    for(;k;k>>=1,x=1LL*x*x%mod) if(k&1) res=1LL*res*x%mod;\n    return res;\n}\nint main()\n{\n    n=read();m=read();p[0]=p[1]=inv[0]=inv[1]=1;if(n>m) swap(n,m);\n    for(int i=2;i<=MN;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=2;i<=MN;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod;\n    for(int i=0;i<=n;++i)\n    {\n        int res=1LL*C(n,i)*pw(m+1,n-i)%mod*C(m,i)%mod*p[i]%mod*pw(n+1,m-i)%mod;\n        if(~i&1) ans=(ans+res)%mod; else ans=(ans+mod-res)%mod;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 500010\n#define maxm 100010\n#define inf 1000000007\n#define mod 998244353\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int>pii;\ntypedef bitset<maxn> bit;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,m,mx,mn;\nint ci_n[maxn],ci_m[maxn];\nint fac[maxn],inv[maxn];\nint quick_pow(int x,int p)\n{\n    int an=1,po=x;\n    while(p)\n    {\n        if(p&1)  an=1ll*an*po%mod;\n        po=1ll*po*po%mod;\n        p>>=1;\n    }\n    return an;\n}\nint ans;\nvoid add(int &x,int y)\n{\n    x=(x+y>=mod)?x+y-mod:x+y;\n}\nint C(int x,int y)\n{\n    return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n    n=read();m=read();mx=max(n,m);mn=min(n,m);\n    fac[0]=1;\n    for(int i=1;i<=mx;i++)  fac[i]=1ll*fac[i-1]*i%mod;\n    inv[mx]=quick_pow(fac[mx],mod-2);\n    for(int i=mx-1;i>=0;i--)  inv[i]=1ll*inv[i+1]*(i+1)%mod;\n    ci_m[0]=ci_n[0]=1;\n    for(int i=1;i<=n;i++)  ci_m[i]=1ll*ci_m[i-1]*(m+1)%mod;\n    for(int i=1;i<=m;i++)  ci_n[i]=1ll*ci_n[i-1]*(n+1)%mod;\n    for(int i=0;i<=mn;i++)\n    {\n        int tmp=1ll*C(n,i)*C(m,i)%mod*fac[i]%mod*ci_m[n-i]%mod*ci_n[m-i]%mod;\n        add(ans,(i&1)?mod-tmp:tmp);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Have a nice day:)\n#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\ninline int read();\n\nconst int maxn=5e5+5;\nconst int mod=998244353;\n\nint n, m, ans;\nint fac[maxn], inv[maxn];\nint Pow(int a, int b)\n{\n    int u=1;\n    for(; b; b>>=1, a=1ll*a*a%mod) if(b&1) u=1ll*u*a%mod;\n    return u;\n}\n\nvoid Init()\n{\n    fac[0]=inv[0]=1;\n    for(int i=1; i<=maxn-5; ++i) fac[i]=1ll*fac[i-1]*i%mod;\n    inv[maxn-5]=Pow(fac[maxn-5], mod-2);\n    for(int i=maxn-6; i>=1; --i) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\n\nint C(int a, int b) { return 1ll*fac[b]*inv[a]%mod*inv[b-a]%mod; }\n\nvoid Work()\n{    \n    n=read(), m=read(); Init();\n    for(int i=min(n, m); i>=0; --i)\n    {\n        ans=(ans+(i&1 ? -1ll : 1ll)*C(i, n)*C(i, m)%mod*fac[i]%mod\n            *Pow(n+1, m-i)%mod*Pow(m+1, n-i)%mod)%mod;\n    }\n    printf(\"%d\", (ans+mod)%mod);\n}\n\nint main()\n{\n  \n    Work();\n\n    return 0;\n}\n\ninline int read()\n{\n    char c; bool type=1;\n    while((c=getchar())<'0' || c>'9')\n        if(c=='-') type=0;\n    int ans=c^48;\n    while((c=getchar())>='0' && c<='9')\n        ans=(ans<<3)+(ans<<1)+(c^48);\n    return type?ans:-ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nusing cat = long long;\n\ncat mod = 998244353;\n\ncat pw(cat a, cat e) {\n\tif(e <= 0) return 1;\n\tcat x = pw(a, e/2);\n\tx = x * x % mod;\n\tif(e&1) x = x * a % mod;\n\treturn x;\n}\n\ncat om[22];\n\nvoid ntt(cat * a, int n, bool rev = 0) {\n\tfor(int i = 0, j = 0; i < n; ++i) {\n\t\tif(i < j) swap(a[i], a[j]);\n\t\tfor(int k = n>>1; (j^=k) < k; k >>= 1) {}\n\t}\n\tfor(int i = 2, e = 1; i <= n; i <<= 1, e++) {\n\t\tint len = i>>1;\n\t\tcat w = om[e];\n\t\tstatic cat om_pw[1<<19];\n\t\tom_pw[0] = 1;\n\t\tfor(int j = 1; j < len; j++) om_pw[j] = om_pw[j-1] * w % mod;\n\t\tfor(int j = 0; j < n; j += i) {\n\t\t\tcat * cur_ptr = om_pw;\n\t\t\tcat * l_ptr = a + j;\n\t\t\tcat * r_ptr = a + j + len;\n\t\t\tfor(int k = 0; k < len; k++) {\n\t\t\t\tcat u = *l_ptr, v = (*r_ptr) * (*(cur_ptr++)) % mod;\n\t\t\t\tcat s = u + v, d = u - v;\n\t\t\t\tif(s >= mod) s -= mod;\n\t\t\t\tif(d < 0) d += mod;\n\t\t\t\t*(l_ptr++) = s;\n\t\t\t\t*(r_ptr++) = d;\n\t\t\t}\n\t\t}\n\t}\n\tif(rev) {\n\t\tcat n_inv = pw(n, mod-2);\n\t\treverse(a+1, a+n);\n\t\tfor(int i = 0; i < n; i++) a[i] = a[i] * n_inv % mod;\n\t}\n}\n\nint main() {\n\tfor(int i = 0; i < 22; i++) om[i] = pw(3, (mod-1)>>i);\n\tint N, M;\n\tcin >> N >> M;\n\tcat fac[500010], inv[500010];\n\tfac[0] = inv[0] = 1;\n\tfor(int i = 1; i <= 500000; i++) fac[i] = fac[i-1] * i % mod;\n\tfor(int i = 1; i <= 500000; i++) inv[i] = (i%2 == 0 && i > 2) ? inv[2] * inv[i/2] % mod : pw(i, mod-2);\n\tfor(int i = 1; i <= 500000; i++) inv[i] = inv[i-1] * inv[i] % mod;\n\tcat A[1<<20];\n\tmemset(A, 0, sizeof(A));\n\tcat N_pw = 1;\n\tfor(int i = 0; i <= M; i++) {\n\t\tA[i] = inv[i] * N_pw % mod;\n\t\tN_pw = N_pw * N % mod;\n\t}\n\tntt(A, 1<<20);\n\tcat B[1<<20];\n\tmemset(B, 0, sizeof(B));\n\tcat M_pw = 1;\n\tfor(int i = N; i >= 0; i--) {\n\t\tB[i] = inv[i] * inv[N-i] % mod * M_pw % mod;\n\t\tM_pw = M_pw * (mod-1-M) % mod;\n\t}\n\tntt(B, 1<<20);\n\tcat C[1<<20];\n\tfor(int i = 0; i < (1<<20); i++) C[i] = A[i] * B[i] % mod;\n\tntt(C, 1<<20, 1);\n\tcat ans = 0;\n\tfor(int i = 0; i <= M; i++) ans = (ans + C[i] * inv[M-i]) % mod;\n\tans = ans * fac[N] % mod * fac[M] % mod * (N%2 ? mod-1 : 1) % mod;\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconst int P = 998244353;\n\nconst int N = 5e5+5;\n\nint f[N];\nint finv[N];\n\nint nk[N];\nint mk[N];\n\nint n,m;\n\nvoid ex_gcd(int a, int b, int &x, int &y)\n{\n\tif(!b)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn;\n\t}\n\tex_gcd(b,a%b,y,x);\n\ty -= a/b*x;\n}\n\nint qpow(int a, int b)\n{\n\tint res = 1;\n\twhile(b)\n\t{\n\t\tif(b%2)\n\t\t\tres = res*a %P;\n\t\t\n\t\ta = a*a %P;\n\t\tb /= 2; \n\t}\n\treturn res;\n}\n\nint getInv(int a)\n{\n/*\tint x,y;\n\tex_gcd(a,P,x,y);\n\t\n\tx = (x%P+P)%P;\n\n\treturn x;*/\n\t\n\treturn qpow(a,P-2);\n}\n\nvoid init()\n{\n\tf[0] = 1;\n\t\n\tint t = max(n,m);\n\t\n\tfor(int i = 1; i <= t; i++)\n\t{\n\t\tf[i] = (f[i-1]*i)%P;\n\t}\n\tfinv[t] = getInv(f[t]) % P;\n\n\tfor(int i = t; i > 0; i--)\n\t{\n\t\tfinv[i-1] = finv[i]*i %P;\n\t}\n\t\n\tnk[0] = 1, mk[0] = 1;\n\tfor(int i = 1; i <= t; i++)\n\t{\n\t\tnk[i] = nk[i-1]*(n+1) % P;\n\t\tmk[i] = mk[i-1]*(m+1) % P;\n\t}\n}\n\nint choose(int a, int b)\n{\n\tint A = f[a]*finv[b] % P;\n\tint B = A*finv[a-b] % P;\n\t\n\tint res = B;\n\n\treturn res; \n}\n\nlong long ans;\n\nint cal(int k)\n{\n\tint res = (( (nk[m-k]*mk[n-k])%P * f[k])%P *(choose(n,k)*choose(m,k))%P) % P;\n\t\n\tint A = nk[m-k]*mk[n-k]%P;\n\tint B = A*f[k] %P;\n\tint C = B*choose(n,k) %P;\n\tint D = C*choose(m,k) %P;\n\tres = D;\n\t\n\tif(k%2)\n\t{\n\t\treturn -res;\n\t}\n\telse\n\t{\n\t\treturn res;\n\t}\n}\n\nvoid debug()\n{\n\tfor(int i = 0; i <= max(n,m); i++)\n\t{\n\t\tprintf(\"f[%lld]=%lld\\n\",i,f[i]);\n\t}\n}\n\nsigned main()\n{\n\tcin >> n >> m;\n\t\n\tinit();\n//\tdebug();\n\t\n\tfor(int i = 0; i <= min(n,m); i++)\n\t{\n\t\tans += cal(i);\n\t\tans %= P;\n//\t\tprintf(\"res[%lld]=%lld\\n\", i, cal(i));\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 500000\n#define X 998244353\n#define swap(x,y) (x^=y^=x^=y)\n#define Qinv(x) Qpow(x,X-2)\n#define A(x,y) (1LL*Fac[x]*IFac[(x)-(y)]%X)\n#define C(x,y) (1LL*A(x,y)*IFac[y]%X)\n#define Inc(x,y) ((x+=(y))>=X&&(x-=X))\nusing namespace std;\nint n,m,Fac[N+5],IFac[N+5],Pn[N+5],Pm[N+5];\nI int Qpow(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}\nint main()\n{\n\tRI i,t,ans=0;scanf(\"%d%d\",&n,&m),n>m&&swap(n,m);\n\tfor(Fac[0]=Pn[0]=Pm[0]=i=1;i<=m;++i)\n\t\tFac[i]=1LL*Fac[i-1]*i%X,Pn[i]=1LL*Pn[i-1]*(n+1)%X,Pm[i]=1LL*Pm[i-1]*(m+1)%X;\n\tfor(IFac[m]=Qinv(Fac[m]),i=m-1;~i;--i) IFac[i]=1LL*IFac[i+1]*(i+1)%X;\n\tfor(i=0;i<=n;++i) t=1LL*C(n,i)*A(m,i)%X*Pn[m-i]%X*Pm[n-i]%X,Inc(ans,i&1?X-t:t);\n\treturn printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int mod = 998244353;\nconst int N = 500005;\nusing LL = long long;\nint n, m, factor[N], ifactor[N];\nvoid reduce(int &x) { x += x >> 31 & mod; }\nint pow(int x, int y, int ans = 1) {\n\tfor (; y; y >>= 1, x = (LL) x * x % mod)\n\t\tif (y & 1) ans = (LL) ans * x % mod;\n\treturn ans;\n}\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> m; int p = std::max(n, m);\n\tfactor[0] = 1;\n\tfor (int i = 1; i <= p; ++i)\n\t\tfactor[i] = (LL) factor[i - 1] * i % mod;\n\tifactor[p] = pow(factor[p], mod - 2);\n\tfor (int i = p; i; --i)\n\t\tifactor[i - 1] = (LL) ifactor[i] * i % mod;\n\tint ans = 0;\n\tfor (int i = 0; i <= n && i <= m; ++i) {\n\t\tint val = (LL) factor[n] * factor[m] % mod * ifactor[n - i] % mod * ifactor[m - i] % mod * ifactor[i] % mod * pow(n + 1, m - i) % mod * pow(m + 1, n - i) % mod;\n\t\tif (i & 1) reduce(ans -= val); else reduce(ans += val - mod);\n\t}\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct ModInt{\n\tuint32_t a;\n    ModInt(int64_t x=0):a((x%mod+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n        if(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=(uint64_t)a*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-(){return ModInt()-*this;}\n\tinline ModInt pow(uint64_t ex)const{\n\t\tuint64_t x=a;\n\t\tuint64_t res=1;\n\t\twhile(ex){\n\t\t\tif(ex&1)res=res*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tex>>=1;\n\t\t}\n\t\treturn ModInt(res);\n\t}\n\n    inline ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unistd.h>\nusing namespace std;\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){return s(a+x.a);}\n\tModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,const ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\n\nusing mint=ModInt<998244353>;\ntemplate<class Mint,int32_t N>\nstruct ModIntTable{\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n)const{return facts[n];}\n\tinline Mint finv(int n)const{return finvs[n];}\n\tinline Mint inv(int n)const{return invs[n];}\n\tinline Mint binom(int n,int k)const{return facts[n]*finvs[k]*finvs[n-k];}\n};\nModIntTable<mint,1<<19>mtable;\n\n\n\nnamespace NTTFriendlyPoly{\n\t\n\tconst uint32_t mod=998244353;\n\tconst uint32_t prim_root=3;\n\n\tusing Mint=ModInt<mod>;\n\n\n\tconst int LG=20;\n\tMint invs[1<<LG];\n\tMint roots[1<<LG+1],iroots[1<<LG+1];\n\tstruct InitTable{\n\t\tInitTable(){\n\t\t\tinvs[1]=1;\n\t\t\tfor(int i=2;i<1<<LG;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\t\trep(w,LG+1){\n\t\t\t\tconst int s=(1<<w)-1;\n\t\t\t\tconst Mint g=Mint(prim_root).pow((mod-1)>>w),ig=g.inv();\n\t\t\t\tMint p=1,ip=1;\n\t\t\t\trep(i,1<<w){\n\t\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}InitTableDummy;\n\n\tvoid ntt(vector<Mint>&f){\n\t\tconst int n=f.size();\n\t\tfor(int b=n/2;b>=1;b/=2){\n\t\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\t\trep(j,b){\n\t\t\t\t\tconst Mint tmp=f[i+j]-f[i+j+b];\n\t\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid intt(vector<Mint>&f){\n\t\tconst int n=f.size();\n\t\tfor(int b=1;b<=n/2;b*=2){\n\t\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\t\trep(j,b){\n\t\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\t\tconst Mint tmp=f[i+j]-f[i+j+b];\n\t\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\t\tf[i+j+b]=tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst Mint in=Mint(n).inv();\n\t\trep(i,n)\n\t\t\tf[i]*=in;\n\t}\n\n\tvector<Mint> multiply(vector<Mint> x,vector<Mint> y){\n\t\tint n=x.size()+y.size()-1;\n\t\tint s=1<<__lg(n-1)+1;\n\t\tx.resize(s);\n\t\ty.resize(s);\n\t\tntt(x);ntt(y);\n\t\trep(i,s)\n\t\t\tx[i]*=y[i];\n\t\tintt(x);x.resize(n);\n\t\treturn x;\n\t}\n\n\n\n\ttemplate<class Mint>\n\tstruct Poly{\n\t\tvector<Mint>v;\n\t\ttemplate<class...Args>\n\t\tPoly(Args...args):v(args...){}\n\t\tPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n\t\n\n\t\tinline int size()const{return v.size();}\n\t\n\t\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n\t\n\t\tPoly operator+(const Poly &x)const{\n\t\t\tint n=max(size(),x.size());\n\t\t\tPoly<Mint>res(n);\n\t\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\t\treturn res;\n\t\t}\n\t\tPoly operator-(const Poly &x)const{\n\t\t\tint n=max(size(),x.size());\n\t\t\tPoly<Mint>res(n);\n\t\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\t\treturn res;\n\t\t}\n\t\tPoly operator*(const Poly& x)const{\n\t\t\treturn multiply(v,x.v);\n\t\t}\n\t\tPoly operator*(const Mint& x)const{\n\t\t\tint n=size();\n\t\t\tvector<Mint>res(n);\n\t\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\t\treturn res;\n\t\t}\n\t\tPoly operator/(const Mint& x)const{\n\t\t\treturn (*this)*x.inv();\n\t\t}\n\t\n\t\tPoly& operator+=(const Poly& x){return *this=(*this)+x;}\n\t\tPoly& operator-=(const Poly& x){return *this=(*this)-x;}\n\t\tPoly& operator*=(const Poly& x){return *this=(*this)*x;}\n\t\tPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\t\tPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n\t\tPoly operator-(){return Poly()-*this;}\n\t\n\t\tPoly pre(int n)const{\n\t\t\tPoly<Mint>res(n);\n\t\t\tfor(int i=0;i<n&&i<size();i++)res[i]=v[i];\n\t\t\treturn res;\n\t\t}\n\t\tPoly rev()const{\n\t\t\tvector<Mint>res=v;\n\t\t\twhile(res.size()&&res.back()==0)res.pop_back();\n\t\t\treverse(res.begin(),res.end());\n\t\t\treturn res;\n\t\t}\n\t\tPoly diff(int n)const{\n\t\t\tPoly<Mint>res(n);\n\t\t\tfor(int i=1;i<size()&&i<=n;i++)res[i-1]=v[i]*i;\n\t\t\treturn res;\n\t\t}\n\t\tPoly inte(int n)const{\n\t\t\tPoly<Mint>res(n);\n\t\t\tfor(int i=0;i<size()&&i+1<n;i++)res[i+1]=v[i]*invs[i+1];\n\t\t\treturn res;\n\t\t}\n\n\t\tPoly inv(int n)const{\n\t\t\tvector<Mint>res{coef(0).inv()};\n\n\t\t\tfor(int d=1;d<n;d<<=1){\n\t\t\t\tvector<Mint>f(2*d),g(2*d);\n\t\t\t\tfor(int j=0;j<2*d;j++)f[j]=coef(j);\n\t\t\t\tfor(int j=0;j<d;j++)g[j]=res[j];\n\t\t\t\t\n\t\t\t\tntt(f);ntt(g);\n\t\t\t\tfor(int j=0;j<2*d;j++)f[j]*=g[j];\n\t\t\t\tintt(f);\n\t\t\t\tfor(int j=0;j<d;j++){\n\t\t\t\t\tf[j]=0;\n\t\t\t\t\tf[j+d]=-f[j+d];\n\t\t\t\t}\n\t\t\t\tntt(f);\n\t\t\t\tfor(int j=0;j<2*d;j++)f[j]*=g[j];\n\t\t\t\tintt(f);\n\t\t\t\tfor(int j=0;j<d;j++)f[j]=res[j];\n\t\t\t\tres=f;\n\t\t\t}\n\t\t\treturn Poly(res).pre(n);\n\t\t}\n\t\t\n\t\t\n\t\tPoly inv2(int n){\n\t\t\tPoly res{coef(0).inv()};\n\t\t\tfor(int i=1;i<n;i*=2){\n\t\t\t\tres=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n\t\t\t}\n\t\t\treturn res.pre(n);\n\t\t}\n\t\t\n\t\t\n\n\t\tPoly exp(int n){\n\t\t\tPoly f0{1},g0{1};\n\t\t\tvector<Mint>F0{1};\n\t\t\tfor(int d=1;d<n;d<<=1){\n\t\t\t\tvector<Mint>G0=g0.v;\n\t\t\t\tntt(G0);\n\t\t\t\tvector<Mint>Delta(d);\n\t\t\t\tfor(int j=0;j<d;j++)Delta[j]=F0[j]*G0[j];\n\t\t\t\tintt(Delta);\n\t\t\t\tDelta[0]-=1;\n\t\t\t\tPoly delta(2*d);\n\t\t\t\tfor(int j=0;j<d;j++)delta[d+j]=Delta[j];\t\t\n\t\t\t\t\n\t\t\t\tPoly epsilon(2*d);\n\t\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\tvector<Mint>DF0=f0.diff(d-1).v;DF0.push_back(0);\n\t\t\t\tntt(DF0);\n\t\t\t\tfor(int j=0;j<d;j++)DF0[j]*=G0[j];\n\t\t\t\tintt(DF0);\n\t\t\t\tfor(int j=0;j<d-1;j++){\n\t\t\t\t\tepsilon[j]+=coef(j+1)*(j+1);\n\t\t\t\t\tepsilon[j+d]+=DF0[j]-coef(j+1)*(j+1);\n\t\t\t\t}\n\t\t\t\tepsilon[d-1]+=DF0[d-1];\n\n\n\t\t\t\tDelta=delta.v;\n\t\t\t\tntt(Delta);\n\t\t\t\tvector<Mint>DH0=diff(d-1).v;DH0.resize(2*d);\n\t\t\t\tntt(DH0);\n\t\t\t\tfor(int j=0;j<2*d;j++)Delta[j]*=DH0[j];\n\t\t\t\tintt(Delta);\n\t\t\t\tfor(int j=0;j<d;j++)epsilon[j+d]-=Delta[j+d];\n\t\t\t\n\n\t\t\t\tepsilon=epsilon.inte(2*d)-pre(2*d);\n\t\t\t\t\n\t\t\t\tvector<Mint>Epsilon=epsilon.v;\n\t\t\t\tntt(Epsilon);\n\t\t\t\trep(j,d)DH0[j]=f0[j],DH0[j+d]=0;\n\t\t\t\tntt(DH0);\n\t\t\t\trep(j,2*d)Epsilon[j]*=DH0[j];\n\t\t\t\tintt(Epsilon);\n\t\t\t\tf0.v.resize(2*d);\n\t\t\t\trep(j,d)f0[j+d]-=Epsilon[j+d];\n\t\t\t\t//f0=(f0-epsilon*f0).pre(2*d);\n\n\t\t\t\tif(2*d>=n)break;\n\t\t\t\t\n\t\t\t\tG0.resize(2*d);\n\t\t\t\trep(j,d)G0[j]=g0[j];\n\t\t\t\tntt(G0);\n\t\t\t\tF0=f0.v; \n\t\t\t\tntt(F0);\n\t\t\t\tvector<Mint>T(2*d);rep(j,2*d)T[j]=F0[j]*G0[j];\n\t\t\t\tintt(T);\n\t\t\t\trep(j,d){\n\t\t\t\t\tT[j]=0;\n\t\t\t\t\tT[j+d]=-T[j+d];\n\t\t\t\t}\n\t\t\t\tntt(T);\n\t\t\t\trep(j,2*d)T[j]*=G0[j];\n\t\t\t\tintt(T);\n\t\t\t\trep(j,d)T[j]=g0[j];\n\t\t\t\tg0=T;\n\t\t\t}\n\t\t\treturn f0.pre(n);\n\t\t}\n\n\t\tPoly exp2(int n){\n\t\t\tPoly f{1};\n\t\t\tfor(int i=1;i<n;i*=2){\n\t\t\t\tf=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n\t\t\t}\n\t\t\treturn f.pre(n);\n\t\t}\n\n\t\tPoly exp3(int n){\n\t\t\tPoly f{1},g{1};\n\t\t\tfor(int d=1;d<n;d<<=1){\n\t\t\t\tg=g*Mint(2)-(g*g*f).pre(d);\n\n\t\t\t\tPoly q=diff(d-1);\n\t\t\t\tq=q+g*(f.diff(d-1)-f*q).pre(2*d-1);\n\t\t\t\tf=f+(f*(pre(2*d)-q.inte(2*d))).pre(2*d);\n\t\t\t}\n\t\t\treturn f.pre(n);\n\t\t}\n\n\n\t\n\t\tPoly log(int n){\n\t\t\treturn (diff(n-1)*inv(n-1)).inte(n);\n\t\t}\n\t\n\t\tPoly pow(int n,Mint k){\n\t\t\tauto res=log(n);\n\t\t\tres*=k;\n\t\t\treturn res.exp(n);\n\t\t}\n\t\tMint& operator[](const int i){return v[i];}\n\t};\n\t\n\ttemplate<class Mint>\n\tostream& operator<<(ostream& ost,Poly<Mint>a){\n\t\tfor(int i=0;i<a.size();i++){\n\t\t\tif(i)cout<<\" \";\n\t\t\tcout<<a.v[i];\n\t\t}\n\t\treturn ost;\n\t}\n\tusing poly=Poly<Mint>;\n};\n\nusing NTTFriendlyPoly::poly;\n\n\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=mtable.finv(i)*in*(N+1-i);\n\t}\n \n\tp=p.pow(N+1,M);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*mtable.finv(N-i);\n\t}\n\tans*=mtable.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 5e5, mod = 998244353;\nint n, m, fact[maxn + 3], finv[maxn + 3];\n\nint qpow(int a, int b) {\n\tint c = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % mod) {\n\t\tif (b & 1) c = 1ll * a * c % mod;\n\t}\n\treturn c;\n}\n\nvoid prework(int n) {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = 1ll * fact[i - 1] * i % mod;\n\t}\n\tfinv[n] = qpow(fact[n], mod - 2);\n\tfor (int i = n; i; i--) {\n\t\tfinv[i - 1] = 1ll * finv[i] * i % mod;\n\t}\n}\n\nint C(int n, int m) {\n\treturn 1ll * fact[n] * finv[m] % mod * finv[n - m] % mod;\n}\n\nint main() {\n\tprework(maxn);\n\tscanf(\"%d %d\", &n, &m);\n\tint ans = 0;\n\tfor (int i = 0; i <= min(n, m); i++) {\n\t\tans = (ans + 1ll * (i & 1 ? mod - 1 : 1) * qpow(m + 1, n - i) % mod * qpow(n + 1, m - i) % mod * C(n, i) % mod * C(m, i) % mod * fact[i]) % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int N = 1e7 + 10, mod = 998244353;\nint fac[N], inv[N], n, ans, m;\nint qpow(int a, int b) {\n    int c = 1;\n    while(b) {\n        if(b & 1) c = 1ll * c * a % mod;\n        a = 1ll * a * a % mod;\n        b >>= 1;\n    } return c;\n}\nint C(int x, int y) {\n    if(x < y) return 0;\n    return 1ll * fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    if(n > m) swap(n, m);\n    fac[0] = 1;\n    for(int i = 1; i <= m; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;\n    inv[m] = qpow(fac[m], mod - 2);\n    for(int i = m; i >= 1; --i) inv[i - 1] = 1ll * inv[i] * i % mod;\n    for(int i = 0, o = 1; i <= n; ++i, o = mod - o)\n        ans += 1ll * C(n, i) * C(m, i) % mod * fac[i] % mod * qpow(m + 1, n - i) % mod * qpow(n + 1, m - i) % mod * o % mod,\n        ans %= mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define int long long\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') bo = -1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tres = (res << 1) + (res << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn bo * res;\n}\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = read();\n}\n\ntemplate <typename T, typename... Argv>\nvoid read(T &a, Argv &... argv) {\n\tread(a);\n\tread(argv...);\n}\n\nconst int N = 1e6 + 100, p = 998244353;\nint fac[N], inv[N], _n[N], _m[N];\n\ntemplate <typename T>\nT mul(T x, T y) {\n\treturn 1LL * x * y % p;\n}\n\ntemplate <typename T, typename... Argv>\nT mul(T x, Argv... argv) {\n\treturn mul(x, mul(argv...));\n}\n\nint ksm(int x, int y) {\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nvoid init(int n, int m) {\n\tint M = std::max(n, m);\n\tfac[0] = _n[0] = _m[0] = 1;\n\tfor (int i = 1; i <= M; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[n] = ksm(fac[n], p - 2);\n\tfor (int i = n; i >= 1; --i) inv[i - 1] = mul(inv[i], i);\n\tfor (int i = 1; i <= M; ++i) _n[i] = mul(_n[i - 1], n + 1);\n\tfor (int i = 1; i <= M; ++i) _m[i] = mul(_m[i - 1], m + 1);\n}\n\nint C(int n, int m) {\n\treturn m > n || m < 0 ? 0 : mul(fac[n], inv[m], inv[n - m]);\n}\n\nsigned main() {\n\tint n = read(), m = read(), ans = 0;\n\tinit(n, m);\n\tfor (int i = 0, opt = 1; i <= std::min(n, m); ++i, opt = p - opt) {\n\t\tans = (ans + mul(opt, C(n, i), C(m, i), fac[i], _m[n - i], _n[m - i])) % p;\n\t}\n\tstd::cout << (ans % p + p) % p << std::endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ri register int\nusing namespace std;\ntypedef vector<int> poly;\ntypedef long long ll;\n#define pb push_back\n#define rez resize\nconst int rlen=1<<18|1;\nchar buf[rlen],*ib=buf,*ob=buf;\n#define gc() (((ib==ob)&&(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)\ninline int read() {\n  int ans=0;\n  char ch=gc();\n  while(!isdigit(ch)) ch=gc();\n  while(isdigit(ch)) ans=((ans<<2)+ans<<1)+(ch^48),ch=gc();\n  return ans;\n}\nnamespace modular {\n  const int mod=998244353;\n  inline int add(int a,int b) { return a+b<mod?a+b:a+b-mod; }\n  inline int dec(int a,int b) { return a<b?a-b+mod:a-b; }\n  inline int mul(int a,int b) { return (ll)a*b%mod; }\n  inline void Add(int&a,int b) { a=a+b<mod?a+b:a+b-mod; }\n  inline void Dec(int&a,int b) { a=a<b?a-b+mod:a-b; }\n  inline void Mul(int&a,int b) { a=(ll)a*b%mod; }\n  inline int ksm(int a,int p) { int ret=1;for(;p;p>>=1,Mul(a,a)) (p&1)&&(Mul(ret,a),1);return ret; }\n  inline int Inv(int a) { return ksm(a,mod-2); }\n} using namespace modular;\nconst int N=5e5+5;\nint n,m,fac[N],ifac[N],pwn[N],pwm[N];\ninline void init_fac(int lm=0) {\n  lm=max(n,m),fac[0]=fac[1]=ifac[0]=ifac[1]=1;\n  for(ri i=2;i<=lm;++i) fac[i]=mul(fac[i-1],i);\n  ifac[lm]=Inv(fac[lm]);\n  for(ri i=lm-1;i>1;--i) ifac[i]=mul(ifac[i+1],i+1);\n  pwn[0]=1;\n  for(ri i=1;i<=m;++i) pwn[i]=mul(pwn[i-1],n+1);\n  pwm[0]=1;\n  for(ri i=1;i<=n;++i) pwm[i]=mul(pwm[i-1],m+1);\n}\ninline int C(int n,int m) { return n<m||m<0?0:(ll)fac[n]*ifac[m]%mod*ifac[n-m]%mod; }\nint main() {\n  #ifdef ldxcaicai\n  freopen(\"lx.in\",\"r\",stdin);\n  #endif\n  n=read(),m=read(),init_fac();\n  int res=0;\n  for(ri t,i=0;i<=n&&i<=m;++i) {\n    t=mul(mul(C(n,i),C(m,i)),mul(pwn[m-i],pwm[n-i]));\n    (i&1?Dec:Add)(res,mul(fac[i],t));\n  }\n  cout<<res;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n    ModInt(int64_t x=0):a((x%mod+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n        if(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=(uint64_t)a*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt x){return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt x){return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt x){return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt x){return ModInt(*this)/=x;}\n\tbool operator==(const ModInt x){return a==x.a;}\n\tbool operator!=(const ModInt x){return a!=x.a;}\n\n\tModInt operator-(){return ModInt(0)-ModInt(*this);}\n\tinline ModInt pow(uint64_t ex)const{\n\t\tuint64_t x=a;\n\t\tuint64_t res=1;\n\t\twhile(ex){\n\t\t\tif(ex&1)res=res*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tex>>=1;\n\t\t}\n\t\treturn ModInt(res);\n\t}\n\n    inline ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t N>\nstruct ModIntTable{\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n){return facts[n];}\n\tinline Mint finv(int n){return finvs[n];}\n\tinline Mint inv(int n){return invs[n];}\n\tinline Mint binom(int n,int k){return facts[n]*finvs[k]*finvs[n-k];}\n};\nModIntTable<mint,1<<21>mtable;\n\n\ntemplate<class Mint,int32_t root>\nstruct NumberTheoreticTransform{\n\tstatic void ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(root).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    static void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tstatic vector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n};\nusing NTT=NumberTheoreticTransform<mint,3>;\n\n\nconst uint32_t mod=998244353;\nconst mint prim_root=3;\n\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tmint in=mint(n).inv();\n\trep(i,n)\n\t\tf[i]*=in;\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i=false){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\n\n\nvector<mint> multiply(vector<mint> x,vector<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n \ntemplate<class Mint>\nstruct NTTFriendlyPoly{\n\tvoid ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(3).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tvector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n\n\tvector<Mint>v;\n\ttemplate<class...Args>\n\tNTTFriendlyPoly(Args...args):v(args...){}\n \n\tNTTFriendlyPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n \n\tint size()const{return v.size();}\n \n\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n \n\tNTTFriendlyPoly operator+(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator-(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator*(const NTTFriendlyPoly& x){\n\t\treturn multiply(v,x.v);\n\t}\n\tNTTFriendlyPoly operator*(const Mint& x){\n\t\tint n=size();\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator/(const Mint& x){\n\t\treturn (*this)*x.inv();\n\t}\n \n\tNTTFriendlyPoly& operator+=(const NTTFriendlyPoly& x){return *this=(*this)+x;}\n\tNTTFriendlyPoly& operator-=(const NTTFriendlyPoly& x){return *this=(*this)-x;}\n\tNTTFriendlyPoly& operator*=(const NTTFriendlyPoly& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n\tNTTFriendlyPoly operator-(){return NTTFriendlyPoly()-*this;}\n \n    NTTFriendlyPoly pre(int n){\n        NTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n&&i<size();i++)res[i]=v[i];\n\t\treturn res;\n    }\n    NTTFriendlyPoly rev(){\n        vector<Mint>res=v;\n\t\twhile(res.size()&&res.back()==0)res.pop_back();\n        reverse(res.begin(),res.end());\n        return res;\n    }\n    NTTFriendlyPoly diff(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=1;i<size()&&i<=n;i++)res[i-1]=v[i]*i;\n        return res;\n    }\n    NTTFriendlyPoly inte(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=0;i<size()&&i+1<n;i++)res[i+1]=v[i]*mtable.inv(i+1);\n        return res;\n    }\n\n    NTTFriendlyPoly inv(int n){\n        vector<mint>res{coef(0).inv()};\n\n        for(int d=1;d<n;d<<=1){\n            vector<Mint>f(2*d),g(2*d);\n            for(int j=0;j<2*d;j++)f[j]=coef(j);\n            for(int j=0;j<d;j++)g[j]=res[j];\n            \n            inplace_fmt(f);inplace_fmt(g);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++){\n                f[j]=0;\n                f[j+d]=-f[j+d];\n            }\n            inplace_fmt(f);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++)f[j]=res[j];\n            res=f;\n        }\n        return NTTFriendlyPoly(res).pre(n);\n    }\n    \n    \n    NTTFriendlyPoly inv2(int n){\n        NTTFriendlyPoly res{coef(0).inv()};\n        for(int i=1;i<n;i*=2){\n            res=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n        }\n        return res.pre(n);\n    }\n    \n    \n\n\tNTTFriendlyPoly exp(int n){\n\t\tNTTFriendlyPoly f0{1},g0{1};\n\t\tvector<Mint>F0{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tvector<Mint>G0=g0.v;\n\t\t\tinplace_fmt(G0);\n\t\t\tvector<Mint>Delta(d);\n\t\t\tfor(int j=0;j<d;j++)Delta[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tDelta[0]-=1;\n\t\t\tNTTFriendlyPoly delta(2*d);\n\t\t\tfor(int j=0;j<d;j++)delta[d+j]=Delta[j];\t\t\n\t\t\t\n\t\t\tNTTFriendlyPoly epsilon(2*d);\n\t\t\t\n\t\t\n\t\t\t\n\t\t\tvector<Mint>DF0=f0.diff(d-1).v;DF0.push_back(0);\n\t\t\tinplace_fmt(DF0);\n\t\t\tfor(int j=0;j<d;j++)DF0[j]*=G0[j];\n\t\t\tinplace_fmt(DF0,true);\n\t\t\tfor(int j=0;j<d-1;j++){\n\t\t\t\tepsilon[j]+=coef(j+1)*(j+1);\n\t\t\t\tepsilon[j+d]+=DF0[j]-coef(j+1)*(j+1);\n\t\t\t}\n\t\t\tepsilon[d-1]+=DF0[d-1];\n\n\n\t\t\tDelta=delta.v;\n\t\t\tinplace_fmt(Delta);\n\t\t\tvector<Mint>DH0=diff(d-1).v;DH0.resize(2*d);\n\t\t\tinplace_fmt(DH0);\n\t\t\tfor(int j=0;j<2*d;j++)Delta[j]*=DH0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tfor(int j=0;j<d;j++)epsilon[j+d]-=Delta[j+d];\n\t\t\n\n\t\t\tepsilon=epsilon.inte(2*d)-pre(2*d);\n\t\t\t\n\t\t\tvector<Mint>Epsilon=epsilon.v;\n\t\t\tinplace_fmt(Epsilon);\n\t\t\trep(j,d)DH0[j]=f0[j],DH0[j+d]=0;\n\t\t\tinplace_fmt(DH0);\n\t\t\trep(j,2*d)Epsilon[j]*=DH0[j];\n\t\t\tinplace_fmt(Epsilon,true);\n\t\t\tf0.v.resize(2*d);\n\t\t\trep(j,d)f0[j+d]-=Epsilon[j+d];\n\t\t\t//f0=(f0-epsilon*f0).pre(2*d);\n\t\t\t\n\t\t\tG0.resize(2*d);\n\t\t\trep(j,d)G0[j]=g0[j];\n\t\t\tinplace_fmt(G0);\n\t\t\tF0=f0.v; \n\t\t\tinplace_fmt(F0);\n\t\t\tvector<Mint>T(2*d);rep(j,2*d)T[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d){\n\t\t\t\tT[j]=0;\n\t\t\t\tT[j+d]=-T[j+d];\n\t\t\t}\n\t\t\tinplace_fmt(T);\n\t\t\trep(j,2*d)T[j]*=G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d)T[j]=g0[j];\n\t\t\tg0=T;\n\t\t}\n\t\treturn f0.pre(n);\n\t}\n\n    NTTFriendlyPoly exp2(int n){\n        NTTFriendlyPoly f{1};\n        for(int i=1;i<n;i*=2){\n            f=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n        }\n        return f.pre(n);\n    }\n\n\tNTTFriendlyPoly exp3(int n){\n\t\tNTTFriendlyPoly f{1},g{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tg=g*Mint(2)-(g*g*f).pre(d);\n\n\t\t\tNTTFriendlyPoly q=diff(d-1);\n\t\t\tq=q+g*(f.diff(d-1)-f*q).pre(2*d-1);\n\t\t\tf=f+(f*(pre(2*d)-q.inte(2*d))).pre(2*d);\n\t\t}\n\t\treturn f.pre(n);\n\t}\n\n\n \n    NTTFriendlyPoly log(int n){\n        return (diff(n-1)*inv(n-1)).inte(n);\n    }\n \n    NTTFriendlyPoly pow(int n,mint k){\n\t\tauto res=log(n);\n\t\tres*=k;\n\t\treturn res.exp(n);\n\t}\n\tMint& operator[](const int i){return v[i];}\n};\nusing poly=NTTFriendlyPoly<mint>;\n \ntemplate<class Mint>\nostream& operator<<(ostream& ost,NTTFriendlyPoly<Mint>a){\n    for(int i=0;i<a.size();i++){\n        if(i)cout<<\" \";\n        cout<<a.v[i];\n    }\n    return ost;\n}\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=mtable.finv(i)*in*(N+1-i);\n\t}\n\n\tp=p.pow(N+1,M);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*mtable.finv(N-i);\n\t}\n\tans*=mtable.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=500005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nll nPk(ll n,ll k){\n\treturn nCk(n,k)*F[k]%mod;\n}\n\nint h,w;\n\nint main(){\n\tInit();\n\tcin>>h>>w;\n\tll res=0;\n\tif(h>w) swap(h,w);\n\tfor(int i=0;i<=h;i++){\n\t\tll t=nCk(h,i)*nPk(w,i)%mod*Pow(w+1,h-i)%mod*Pow(h+1,w-i)%mod;\n\t\tif(i%2==1) (t*=mod-1)%=mod;\n\t\t(res+=t)%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register int\n#define F(x,y,z) for(re x=y;x<=z;x++)\n#define FOR(x,y,z) for(re x=y;x>=z;x--)\ntypedef long long ll;\n#define I inline void\n#define IN inline int\nconst int Mod=998244353;\nint n,m,ans,fac[505000],inv[505000],sum;\nI add(int &x,int y){(x+=y)>=Mod?x-=Mod:0;}\nIN Plus(int x,int y){(x+=y)>=Mod?x-=Mod:0;return x;}\nIN C(int x,int y){return (ll)fac[x]*inv[y]%Mod*inv[x-y]%Mod;}\nIN A(int x,int y){return (ll)fac[x]*inv[x-y]%Mod;}\nIN Pow(int x,int y=Mod-2){\n\tre res=1;\n\twhile(y){\n\t\tif(y&1)res=(ll)res*x%Mod;\n\t\tx=(ll)x*x%Mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tios::sync_with_stdio(false);cin.tie(0);\n\tcin>>n>>m;if(n>=m)swap(n,m);\n\tfac[0]=1;F(i,1,m)fac[i]=(ll)fac[i-1]*i%Mod;\n\tinv[m]=Pow(fac[m]);FOR(i,m-1,0)inv[i]=(ll)inv[i+1]*(i+1)%Mod;\t\n\tsum=Pow(n+1,m-n);\n\tFOR(k,n,0){\n\t\tif(k&1)add(ans,Mod-(ll)C(n,k)*A(m,k)%Mod*sum%Mod);\n\t\telse add(ans,(ll)C(n,k)*A(m,k)%Mod*sum%Mod);\n\t\tsum=(ll)sum*(n+1)%Mod*(m+1)%Mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = 998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\nconst int LOG = 20;\nconst int N = 1 << LOG;\nconst int NN = N + 5;\nll w[NN];\nint binRev[NN];\nll RN;\n\nvoid initFFT() {\n\tll W = 2;\n\tfor(;; W++) {\n\t\tll x = W;\n\t\tfor (int i = 1; i < LOG; i++)\n\t\t\tx = mult(x, x);\n\t\tif (x == MOD - 1) break;\n\t}\n\tw[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tw[i] = mult(w[i - 1], W);\n\tfor (int mask = 1; mask < N; mask++)\n\t\tbinRev[mask] = (binRev[mask >> 1] >> 1) ^ ((mask & 1) << (LOG - 1));\n\tRN = rev(N);\n}\nvoid FFT(ll* A) {\n\tfor (int mask = 0; mask < N; mask++)\n\t\tif (mask < binRev[mask])\n\t\t\tswap(A[mask], A[binRev[mask]]);\n\tfor (int lvl = 0; lvl < LOG; lvl++) {\n\t\tint len = 1 << lvl;\n\t\tfor (int st = 0; st < N; st += len * 2)\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tll x = A[st + i], y = mult(A[st + len + i], w[i << (LOG - 1 - lvl)]);\n\t\t\t\tA[st + i] = add(x, y);\n\t\t\t\tA[st + len + i] = sub(x, y);\n\t\t\t}\n\t}\n}\n\nll f[NN], rf[NN];\nll a[NN];\nll b[NN];\nint n, m;\n\nvoid sqr() {\n\tFFT(b);\n\tfor (int i = 0; i < N; i++)\n\t\tb[i] = mult(b[i], b[i]);\n\tFFT(b);\n\treverse(b + 1, b + N);\n\tfor (int i = 0; i < N; i++)\n\t\tb[i] = mult(b[i], RN);\n\tfor (int i = n + 1; i < N; i++)\n\t\tb[i] = 0;\n}\nvoid mlt() {\n\tFFT(b);\n\tfor (int i = 0; i < N; i++)\n\t\tb[i] = mult(b[i], a[i]);\n\tFFT(b);\n\treverse(b + 1, b + N);\n\tfor (int i = 0; i < N; i++)\n\t\tb[i] = mult(b[i], RN);\n\tfor (int i = n + 1; i < N; i++)\n\t\tb[i] = 0;\n}\n\nvoid prnt() {\n\tfor (int i = 0; i <= n; i++)\n\t\teprintf(\"%lld \", b[i]);\n\teprintf(\"\\n\");\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tinitFFT();\n\n/*\t\n\tfor (int i = 0; i < 4; i++)\n\t\ta[i] = 1;\n\tFFT(a);\n\tfor (int i = 0; i < N; i++)\n\t\ta[i] = mult(a[i], a[i]);\n\tFFT(a);\n\treverse(a + 1, a + N);\n\tfor (int i = 0; i < 10; i++)\n\t\tprintf(\"%lld \", mult(a[i], RN));\n\tprintf(\"\\n\");\n\treturn 0;\n*/\n\n\n\tf[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tf[i] = mult(f[i - 1], i);\n\trf[N - 1] = rev(f[N - 1]);\n\tfor (int i = N - 1; i > 0; i--)\n\t\trf[i - 1] = mult(rf[i], i);\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tfor (int i = 0; i <= n; i++)\n\t\ta[i] = mult(n + 1 - i, rf[i]);\n\tb[0] = 1;\n\tFFT(a);\n\tint k = 0;\n\twhile((1 << k) <= m) k++;\n\tfor (int j = k - 1; j >= 0; j--) {\n\t\tsqr();\n//\t\tprnt();\n\t\tif ((m >> j) & 1) mlt();\n//\t\tprnt();\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i <= n; i++)\n\t\tans = add(ans, mult(b[i], rf[n - i]));\n\tprintf(\"%lld\\n\", mult(f[n], ans));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\nconst int md = 998244353;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n#if !defined(_WIN32) || defined(_WIN64)\n  return (int) ((long long) a * b % md);\n#endif\n  unsigned long long x = (long long) a * b;\n  unsigned xh = (unsigned) (x >> 32), xl = (unsigned) x, d, m;\n  asm(\n    \"divl %4; \\n\\t\"\n    : \"=a\" (d), \"=d\" (m)\n    : \"d\" (xh), \"a\" (xl), \"r\" (md)\n  );\n  return m;\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nnamespace ntt {\n  int base = 1;\n  vector<int> roots = {0, 1};\n  vector<int> rev = {0, 1};\n  int max_base = -1;\n  int root = -1;\n\n  void init() {\n    int tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (true) {\n      if (power(root, 1 << max_base) == 1) {\n        if (power(root, 1 << (max_base - 1)) != 1) {\n          break;\n        }\n      }\n      root++;\n    }\n  }\n\n  void ensure_base(int nbase) {\n    if (max_base == -1) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      int z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = mul(roots[i], z);\n      }\n      base++;\n    }\n  }\n\n  void fft(vector<int> &a) {\n    int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          int x = a[i + j];\n          int y = mul(a[i + j + k], roots[j + k]);\n          a[i + j] = x + y - md;\n          if (a[i + j] < 0) a[i + j] += md;\n          a[i + j + k] = x - y + md;\n          if (a[i + j + k] >= md) a[i + j + k] -= md;\n        }\n      }\n    }\n  }\n\n  vector<int> multiply(vector<int> a, vector<int> b, int eq = 0) {\n    int need = (int) (a.size() + b.size() - 1);\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq) b = a; else fft(b);\n    int inv_sz = inv(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] = mul(mul(a[i], b[i]), inv_sz);\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<int> square(vector<int> a) {\n    return multiply(a, a, 1);\n  }\n\n  vector<int> get(vector<int> a, int k) {\n    int n = a.size();\n    vector<int> res = {1};\n    while(k > 0) {\n      if(k & 1) {\n        res = multiply(res, a);\n        res.resize(n);\n      }\n      a = square(a);\n      a.resize(n);\n      k >>= 1;\n    }\n    return res;\n  }\n}\n\nint m, n;\n\nint main() {\n  // 0 x1 x2 ... xm\n  // (n - 0, x1 - 0) * (n - x1 + 0 + 1)\n  // (n - x1, x2 - x1) * (n - x2 + x1 + 1)\n  // (n - x2, x3 - x2) * (n - x3 + x2 + 1)\n  //...\n  // (n - x_(m - 1), xm - x_(m - 1)) * (n - xm + x_(m - 1) + 1)\n  // (n)! / ((x1)!(x2 - x1)!...(xm - x_(m - 1))!(n - xm)!) * (n + 1 - x1) * (n + 1 - (x2 - x1)) * ... * (n + 1 - (xm - x_(m - 1)))\n  // 1 / (n - xm)! * (n + 1 - x1) / (x1)! * ...\n  cin >> m >> n;\n  vector<int> p(n + 1);\n  p[0] = 1;\n  range(i, 1, n + 1) p[i] = mul(i, p[i - 1]);\n  vector<int> a(n + 1);\n  range(i, 0, n + 1) a[i] = mul(n + 1 - i, inv(p[i]));\n  a = ntt::get(a, m);\n  vector<int> b(n + 1);\n  range(i, 0, n + 1) b[i] = inv(p[i]);\n  b = ntt::multiply(a, b);\n  cout << mul(b[n], p[n]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=5e5+5;\nconst int mod=998244353;\nint n,m,l,r,ans,tmp=1,f[N],fac[N],inv[N];\n\ninline int mul(int x,int y) {return 1ll*x*y%mod;}\ninline int C(int n,int m) {return mul(fac[n],mul(inv[m],inv[n-m]));}\ninline int modpow(int x,int y,int res=1) {\n\tfor(;y;y>>=1,x=mul(x,x)) if(y&1) res=mul(res,x);\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&m),\n\tl=min(n,m),r=max(n,m),fac[0]=inv[0]=1;\n\tfor(int i=1;i<=r;++i) fac[i]=mul(fac[i-1],i);\n\tfor(int i=1;i<=r;++i) inv[i]=modpow(fac[i],mod-2);\n\tfor(int i=0;i<=l;++i)\n\t\tf[i]=mul(mul(mul(C(m,i),C(n,i)),mul(modpow(m+1,n-i),modpow(n+1,m-i))),fac[i]),\n\t\t(ans+=mul(tmp,f[i]))%=mod,tmp=mod-tmp;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define N 1000102\nconst int p=998244353;\nint n,m,f[N],finv[N],inv[N];\ninline int C(int nn,int mm)\n{\n    if(nn<mm)return 0;\n    return 1ll*f[nn]*finv[mm]%p*finv[nn-mm]%p;\n}\ninline int ksm(int d,int k){int ret=1;while(k){if(k&1)ret=1ll*ret*d%p;d=1ll*d*d%p;k>>=1;}return ret;}\nint main()\n{\n    f[0]=finv[0]=f[1]=finv[1]=inv[1]=1;\n    for(int i=2;i<=1000000;i++)\n    {\n        inv[i]=1ll*(p-p/i)*inv[p%i]%p;\n        f[i]=1ll*f[i-1]*i%p;finv[i]=1ll*finv[i-1]*inv[i]%p;\n    }\n    scanf(\"%d%d\",&n,&m);if(n>m)swap(n,m);\n    int ans=0;\n    for(int i=0;i<=n;i++)\n    {\n        int te=1ll*C(n,i)*C(m,i)%p*f[i]%p*ksm(m+1,n-i)%p*ksm(n+1,m-i)%p;\n        if(i&1)ans=(ans-te+p)%p;\n        else ans=(ans+te)%p;\n    }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){return s(a+x.a);}\n\tModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt<998244353>;\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t N>\nstruct ModIntTable{\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n){return facts[n];}\n\tinline Mint finv(int n){return finvs[n];}\n\tinline Mint inv(int n){return invs[n];}\n\tinline Mint binom(int n,int k){return facts[n]*finvs[k]*finvs[n-k];}\n};\nModIntTable<mint,1<<19>mtable;\n\n\ntemplate<class Mint,int32_t root>\nstruct NumberTheoreticTransform{\n\tstatic void ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(root).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    static void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tstatic vector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n};\nusing NTT=NumberTheoreticTransform<mint,3>;\n\n\nconst uint32_t mod=998244353;\nconst mint prim_root=3;\n\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tmint in=mint(n).inv();\n\trep(i,n)\n\t\tf[i]*=in;\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i=false){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\n\n\nvector<mint> multiply(vector<mint> x,vector<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n \ntemplate<class Mint>\nstruct NTTFriendlyPoly{\n\tvoid ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(3).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tvector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n\n\tvector<Mint>v;\n\ttemplate<class...Args>\n\tNTTFriendlyPoly(Args...args):v(args...){}\n \n\tNTTFriendlyPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n \n\tint size()const{return v.size();}\n \n\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n \n\tNTTFriendlyPoly operator+(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator-(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator*(const NTTFriendlyPoly& x){\n\t\treturn multiply(v,x.v);\n\t}\n\tNTTFriendlyPoly operator*(const Mint& x){\n\t\tint n=size();\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator/(const Mint& x){\n\t\treturn (*this)*x.inv();\n\t}\n \n\tNTTFriendlyPoly& operator+=(const NTTFriendlyPoly& x){return *this=(*this)+x;}\n\tNTTFriendlyPoly& operator-=(const NTTFriendlyPoly& x){return *this=(*this)-x;}\n\tNTTFriendlyPoly& operator*=(const NTTFriendlyPoly& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n\tNTTFriendlyPoly operator-(){return NTTFriendlyPoly()-*this;}\n \n    NTTFriendlyPoly pre(int n){\n        NTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n&&i<size();i++)res[i]=v[i];\n\t\treturn res;\n    }\n    NTTFriendlyPoly rev(){\n        vector<Mint>res=v;\n\t\twhile(res.size()&&res.back()==0)res.pop_back();\n        reverse(res.begin(),res.end());\n        return res;\n    }\n    NTTFriendlyPoly diff(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=1;i<size()&&i<=n;i++)res[i-1]=v[i]*i;\n        return res;\n    }\n    NTTFriendlyPoly inte(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=0;i<size()&&i+1<n;i++)res[i+1]=v[i]*mtable.inv(i+1);\n        return res;\n    }\n\n    NTTFriendlyPoly inv(int n){\n        vector<mint>res{coef(0).inv()};\n\n        for(int d=1;d<n;d<<=1){\n            vector<Mint>f(2*d),g(2*d);\n            for(int j=0;j<2*d;j++)f[j]=coef(j);\n            for(int j=0;j<d;j++)g[j]=res[j];\n            \n            inplace_fmt(f);inplace_fmt(g);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++){\n                f[j]=0;\n                f[j+d]=-f[j+d];\n            }\n            inplace_fmt(f);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++)f[j]=res[j];\n            res=f;\n        }\n        return NTTFriendlyPoly(res).pre(n);\n    }\n    \n    \n    NTTFriendlyPoly inv2(int n){\n        NTTFriendlyPoly res{coef(0).inv()};\n        for(int i=1;i<n;i*=2){\n            res=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n        }\n        return res.pre(n);\n    }\n    \n    \n\n\tNTTFriendlyPoly exp(int n){\n\t\tNTTFriendlyPoly f0{1},g0{1};\n\t\tvector<Mint>F0{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tvector<Mint>G0=g0.v;\n\t\t\tinplace_fmt(G0);\n\t\t\tvector<Mint>Delta(d);\n\t\t\tfor(int j=0;j<d;j++)Delta[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tDelta[0]-=1;\n\t\t\tNTTFriendlyPoly delta(2*d);\n\t\t\tfor(int j=0;j<d;j++)delta[d+j]=Delta[j];\t\t\n\t\t\t\n\t\t\tNTTFriendlyPoly epsilon(2*d);\n\t\t\t\n\t\t\n\t\t\t\n\t\t\tvector<Mint>DF0=f0.diff(d-1).v;DF0.push_back(0);\n\t\t\tinplace_fmt(DF0);\n\t\t\tfor(int j=0;j<d;j++)DF0[j]*=G0[j];\n\t\t\tinplace_fmt(DF0,true);\n\t\t\tfor(int j=0;j<d-1;j++){\n\t\t\t\tepsilon[j]+=coef(j+1)*(j+1);\n\t\t\t\tepsilon[j+d]+=DF0[j]-coef(j+1)*(j+1);\n\t\t\t}\n\t\t\tepsilon[d-1]+=DF0[d-1];\n\n\n\t\t\tDelta=delta.v;\n\t\t\tinplace_fmt(Delta);\n\t\t\tvector<Mint>DH0=diff(d-1).v;DH0.resize(2*d);\n\t\t\tinplace_fmt(DH0);\n\t\t\tfor(int j=0;j<2*d;j++)Delta[j]*=DH0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tfor(int j=0;j<d;j++)epsilon[j+d]-=Delta[j+d];\n\t\t\n\n\t\t\tepsilon=epsilon.inte(2*d)-pre(2*d);\n\t\t\t\n\t\t\tvector<Mint>Epsilon=epsilon.v;\n\t\t\tinplace_fmt(Epsilon);\n\t\t\trep(j,d)DH0[j]=f0[j],DH0[j+d]=0;\n\t\t\tinplace_fmt(DH0);\n\t\t\trep(j,2*d)Epsilon[j]*=DH0[j];\n\t\t\tinplace_fmt(Epsilon,true);\n\t\t\tf0.v.resize(2*d);\n\t\t\trep(j,d)f0[j+d]-=Epsilon[j+d];\n\t\t\t//f0=(f0-epsilon*f0).pre(2*d);\n\t\t\t\n\t\t\tG0.resize(2*d);\n\t\t\trep(j,d)G0[j]=g0[j];\n\t\t\tinplace_fmt(G0);\n\t\t\tF0=f0.v; \n\t\t\tinplace_fmt(F0);\n\t\t\tvector<Mint>T(2*d);rep(j,2*d)T[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d){\n\t\t\t\tT[j]=0;\n\t\t\t\tT[j+d]=-T[j+d];\n\t\t\t}\n\t\t\tinplace_fmt(T);\n\t\t\trep(j,2*d)T[j]*=G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d)T[j]=g0[j];\n\t\t\tg0=T;\n\t\t}\n\t\treturn f0.pre(n);\n\t}\n\n    NTTFriendlyPoly exp2(int n){\n        NTTFriendlyPoly f{1};\n        for(int i=1;i<n;i*=2){\n            f=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n        }\n        return f.pre(n);\n    }\n\n\tNTTFriendlyPoly exp3(int n){\n\t\tNTTFriendlyPoly f{1},g{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tg=g*Mint(2)-(g*g*f).pre(d);\n\n\t\t\tNTTFriendlyPoly q=diff(d-1);\n\t\t\tq=q+g*(f.diff(d-1)-f*q).pre(2*d-1);\n\t\t\tf=f+(f*(pre(2*d)-q.inte(2*d))).pre(2*d);\n\t\t}\n\t\treturn f.pre(n);\n\t}\n\n\n \n    NTTFriendlyPoly log(int n){\n        return (diff(n-1)*inv(n-1)).inte(n);\n    }\n \n    NTTFriendlyPoly pow(int n,mint k){\n\t\tauto res=log(n);\n\t\tres*=k;\n\t\treturn res.exp(n);\n\t}\n\tMint& operator[](const int i){return v[i];}\n};\nusing poly=NTTFriendlyPoly<mint>;\n \ntemplate<class Mint>\nostream& operator<<(ostream& ost,NTTFriendlyPoly<Mint>a){\n    for(int i=0;i<a.size();i++){\n        if(i)cout<<\" \";\n        cout<<a.v[i];\n    }\n    return ost;\n}\n\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=mtable.finv(i)*in*(N+1-i);\n\t}\n \n\tp=p.pow(N+1,M);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*mtable.finv(N-i);\n\t}\n\tans*=mtable.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2,3,\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define db double\n#define in inline\nnamespace fast_io\n{\n\tchar buf[1<<12],*p1=buf,*p2=buf,sr[1<<23],z[23],nc;int C=-1,Z=0,Bi=0,ny;\n\tin char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}\n\tin int read()\n\t{\n\t\tint x=0;ny=1;while(nc=gc(),(nc<48||nc>57)&&nc!=EOF)if(nc==45)ny=-1;Bi=1;if(nc<0)return nc;\n\t\tx=nc-48;while(nc=gc(),47<nc&&nc<58&&nc!=EOF)x=(x<<3)+(x<<1)+(nc^48),Bi++;return x*ny;\n\t}\n\tin db gf() {int a=read(),y=ny,b=(nc!='.')?0:read();return (b?a+(db)b/pow(10,Bi)*y:a);}\n\tin int gs(char *s) {char c,*t=s;while(c=gc(),c<32);*s++=c;while(c=gc(),c>32)*s++=c;return s-t;}\n\tin void ot() {fwrite(sr,1,C+1,stdout);C=-1;}\n\tin void flush() {if(C>1<<22) ot();}\n\ttemplate <typename T>\n\tin void write(T x,char t)\n\t{\n\t\tint y=0;if(x<0)y=1,x=-x;while(z[++Z]=x%10+48,x/=10);\n\t\tif(y)z[++Z]='-';while(sr[++C]=z[Z],--Z);sr[++C]=t;flush();\n\t}\n\tin void write(char *s) {int l=strlen(s);for(int i=0;i<l;i++)sr[++C]=*s++;sr[++C]='\\n';flush();}\n};\nusing namespace fast_io;\nconst int N=5e5+5,p=998244353;\nint n,m,mx,mn,ans,cm[N],cn[N],fac[N],inv[N];\nin void M(int &x) {x-=p;x+=x>>31&p;}\nin int qpow(int a,int b) {int c=1;for(;b;b>>=1,a=1ll*a*a%p)if(b&1)c=1ll*a*c%p;return c;}\nin int c(int n,int m) {return 1ll*fac[n]*inv[m]%p*inv[n-m]%p;}\nint main()\n{\n\tn=read(),m=read();mx=max(n,m);mn=min(n,m);\n\tfac[0]=cm[0]=cn[0]=1;for(int i=1;i<=mx;i++) fac[i]=1ll*fac[i-1]*i%p;\n\tinv[mx]=qpow(fac[mx],p-2);for(int i=mx-1;~i;i--) inv[i]=inv[i+1]*(i+1ll)%p;\n\tfor(int i=1;i<=n;i++) cm[i]=cm[i-1]*(m+1ll)%p;\n\tfor(int i=1;i<=m;i++) cn[i]=cn[i-1]*(n+1ll)%p;\n\tfor(int i=0;i<=mn;i++)\n\t{\n\t\tint res=1ll*c(n,i)*c(m,i)%p*fac[i]%p*cm[n-i]%p*cn[m-i]%p;\n\t\tM(ans+=(i&1)?p-res:res);\n\t}\n\twrite(ans,'\\n');\n\treturn ot(),0;\n}\n//Author: disangan233"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll mo=998244353;\nconst int NUM_=1200001;\nstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\nll comb(ll N_, ll C_) {\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nint N,M;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\tcomb(0,0);\n\tcin>>N>>M;\n\tll ret=0;\n\t\n\tFOR(i,min(N,M)+1) {\n\t\tll pat=comb(N,i)*comb(M,i)%mo*fact[i]%mo*modpow(M+1,N-i)%mo*modpow(N+1,M-i)%mo;\n\t\tif(i%2==0) ret+=pat;\n\t\telse ret+=mo-pat;\n\t}\n\tcout<<ret%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nconst int inv2=(mod+1)>>1;\n\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\n\nint add(int a,int b) {\n    return a+b>=mod?a+b-mod:a+b;\n}\n\nint sub(int a,int b) {\n    return a-b<0?a-b+mod:a-b;\n}\n\nint mul(int a,int b) {\n    return 1ll*a*b%mod;\n}\n\nint qpow(int a,int b) {\n    int ret=1;\n    while(b) {\n        if(b&1) ret=mul(ret,a);\n        a=mul(a,a),b>>=1;\n    }\n    return ret;\n}\n\nvector<int> padd(vector<int> a,vector<int> b) {\n    if(a.size()<b.size()) a.resize(b.size());\n    for(int i=0;i<b.size();i++) a[i]=add(a[i],b[i]);\n    return a;\n}\n\nvector<int> psub(vector<int> a,vector<int> b) {\n    if(a.size()<b.size()) a.resize(b.size());\n    for(int i=0;i<b.size();i++) a[i]=sub(a[i],b[i]);\n    return a;\n}\n\nvector<int> pmul(vector<int> a,vector<int> b) {\n    int n=a.size(),m=b.size(),l=0;\n    if(n<20||m<20) {\n        vector<int> ret(n+m-1);\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++) ret[i+j]=add(ret[i+j],mul(a[i],b[j]));\n        return ret;\n    }\n    m=n+m-1;for(n=1;n<m;n<<=1) ++l;\n    vector<int> r(n);\n    for(int i=0;i<n;i++) r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n    auto dft=[&](vector<int> &a,int f) {\n        for(int i=0;i<n;i++) if(i<r[i]) swap(a[i],a[r[i]]);\n        for(int i=1;i<n;i<<=1) {\n            int wn=qpow(3,(mod-1)/(i<<1));\n            if(f==-1) wn=qpow(wn,mod-2);\n            for(int p=i<<1,j=0;j<n;j+=p) {\n                int w=1;\n                for(int k=0;k<i;k++,w=mul(w,wn)) {\n                    int x=a[j+k],y=mul(w,a[j+k+i]);\n                    a[j+k]=add(x,y),a[j+k+i]=sub(x,y);\n                }\n            }\n        }\n        if(f==-1) {\n            int inv=qpow(n,mod-2);\n            for(int i=0;i<n;i++) a[i]=mul(a[i],inv);\n        }\n    };\n    a.resize(n),b.resize(n);\n    dft(a,1),dft(b,1);\n    for(int i=0;i<n;i++) a[i]=mul(a[i],b[i]);\n    dft(a,-1);\n    a.resize(m);return a;\n}\n\nint get2(int n) {\n    int ret=1;\n    while(ret<n) ret<<=1;\n    return ret;\n}\n\nvector<int> pinv(vector<int> a,int n) {\n    if(n==1) return vector<int>(1,qpow(a[0],mod-2));\n    auto rem_a=a;rem_a.resize(n>>1);\n    auto b=pinv(rem_a,n>>1);\n    auto ret=pmul(a,b);ret.resize(n);\n    ret=pmul(ret,b);ret.resize(n);\n    ret=psub(pmul(b,vector<int>(1,2)),ret);\n    return ret;\n}\n\npair<vector<int>,vector<int>> pdiv(vector<int> a,vector<int> b) {\n    auto rev_a=a,rev_b=b;\n    reverse(rev_a.begin(),rev_a.end());\n    reverse(rev_b.begin(),rev_b.end());\n    auto rem_rev_a=rev_a,rem_rev_b=rev_b;\n    rem_rev_a.resize(a.size()-b.size()+1);\n    rem_rev_b.resize(a.size()-b.size()+1);\n    auto inv_rev_b=pinv(rem_rev_b,get2(a.size()-b.size()+1));\n    inv_rev_b.resize(a.size()-b.size()+1);\n    auto q=pmul(rem_rev_a,inv_rev_b);\n    q.resize(a.size()-b.size()+1);\n    reverse(q.begin(),q.end());\n    auto r=psub(a,pmul(q,b));\n    r.resize(b.size()-1);\n    return make_pair(q,r);\n}\n\nvector<int> pmod(vector<int> a,vector<int> b) {\n    return pdiv(a,b).second;\n}\n\nvoid print(vector<int> a) {\n    for(auto x:a) printf(\"%d \",x);\n    puts(\"\");\n}\n\nvector<int> psqrt(vector<int> a,int n) {\n    if(n==1) return vector<int>(1,1);\n    auto rem_a=a;\n    rem_a.resize(n>>1);\n    auto b=psqrt(rem_a,n>>1);\n    auto ret=pinv(b,n);\n    ret=pmul(a,ret);\n    ret.resize(n);\n    ret=padd(ret,b);\n    ret=pmul(ret,vector<int>(1,inv2));\n    return ret;\n}\n\nvector<int> pval(vector<int> a,vector<int> b) {\n    int m=b.size();\n    if(a.size()<b.size()) a.resize(b.size());\n    if(b.size()<a.size()) b.resize(a.size());\n    vector<vector<int>> prod(a.size()<<2);\n    function<void(int,int,int)> getprod=[&](int x,int l,int r) {\n        if(l==r) {\n            prod[x].resize(2);\n            prod[x][0]=sub(0,b[l]);prod[x][1]=1;\n            return;\n        }\n        int mid=(l+r)>>1;\n        getprod(x<<1,l,mid),getprod(x<<1|1,mid+1,r);\n        if(x!=1) prod[x]=pmul(prod[x<<1],prod[x<<1|1]);\n    };\n    getprod(1,0,a.size()-1);\n    vector<int> ans(a.size());\n    function<void(int,int,int,vector<int>)> solve=[&](int x,int l,int r,vector<int> a) {\n        if(l==r) {\n            ans[l]=a[0];return;\n        }\n        int mid=(l+r)>>1;\n        solve(x<<1,l,mid,pmod(a,prod[x<<1]));\n        solve(x<<1|1,mid+1,r,pmod(a,prod[x<<1|1]));\n    };\n    solve(1,0,a.size()-1,a);\n    ans.resize(m);\n    return ans;\n}\n\nvector<int> pder(vector<int> a) {\n    for(int i=1;i<a.size();i++) a[i-1]=mul(i,a[i]);\n    a.pop_back();\n    return a;\n}\n\nvector<int> pint(vector<int> a) {\n    vector<int> inv(a.size()+1);\n    inv[1]=1;for(int i=2;i<inv.size();i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    a.push_back(0);\n    for(int i=a.size()-2;~i;i--) a[i+1]=mul(inv[i+1],a[i]);\n    a[0]=0;\n    return a;\n}\n\nvector<int> pln(vector<int> a,int n) {\n    auto ret=pder(a);\n    ret=pmul(ret,pinv(a,n));\n    ret.resize(n);\n    ret=pint(ret);\n    ret.resize(n);\n    return ret;\n}\n\nvector<int> pexp(vector<int> a,int n) {\n    if(n==1) return vector<int>(1,1);\n    auto rem_a=a;\n    rem_a.resize(n>>1);\n    auto b=pexp(rem_a,n>>1);\n    auto ret=vector<int>(1,1);\n    ret=psub(ret,pln(b,n));\n    ret=padd(ret,a);\n    ret=pmul(ret,b);\n    ret.resize(n);\n    return ret;\n}\n\nvector<int> pqpow(vector<int> a,int k,int n) {\n\tint t=a[0];\n\tfor(auto &x:a) x=1ll*x*qpow(t,mod-2)%mod;\n\tvector<int> c=pln(a,n);\n\tfor(auto &x:c) x=1ll*x*k%mod;\n\tc=pexp(c,n);\n\tfor(auto &x:c) x=1ll*x*qpow(t,k)%mod;\n\treturn c;\n}\n\nint fac[500010];\n\nint main() {\n    /*int n=gi();\n    vector<int> a(n);\n    for(int i=0;i<n;i++) a[i]=gi();\n    auto ans=pexp(a,get2(n));\n    ans.resize(n);\n    print(ans);*/\n\tint n=gi(),m=gi();\n\tfac[0]=1;for(int i=1;i<=m;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tvector<int> G(m+1);\n\tfor(int i=0;i<=m;i++) G[i]=1ll*(m+1-i)*qpow(fac[i],mod-2)%mod;\n\tvector<int> F=pqpow(G,n,get2(m+1));\n\tint ans=0;\n\tfor(int i=0;i<=m;i++) ans=(ans+1ll*F[i]*qpow(fac[m-i],mod-2))%mod;\n\tans=1ll*ans*fac[m]%mod;\n\tcout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=5e5+5,mo=998244353;\nint vf[N],fac[N],inv[N],n,m,i,ans,m1[N],m2[N];\ninline int C(int n,int m){return 1ll*vf[m]*vf[n-m]%mo*fac[n]%mo;}\nint main(){\n\tfor(i=*vf=*fac=1;i<N;++i)inv[i]=i==1?1:1ll*(mo-mo/i)*inv[mo%i]%mo,\n\t\tvf[i]=1ll*vf[i-1]*inv[i]%mo,fac[i]=1ll*fac[i-1]*i%mo;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=*m1=*m2=1;i<N;++i)m1[i]=1ll*m1[i-1]*(m+1)%mo,m2[i]=1ll*m2[i-1]*(n+1)%mo;\n\tfor(i=std::max(n-m,0);i<=n;++i)\n\t\tans=(ans+1ll*C(n,i)*vf[m-n+i]%mo*m1[i]%mo*((n-i)&1?mo-m2[m-n+i]:m2[m-n+i]))%mo;\n\tans=1ll*ans*fac[m]%mo;printf(\"%d\\n\",ans);\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pa pair<int,int>\nusing namespace std;\nconst int inf = 2147483647;\nconst int mod = 998244353;\nconst int N = 500001;\n\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint jc[N], inv[N];\n\nint add(int x, int y) {\n\tx += y;\n\treturn x >= mod ? x - mod : x;\n}\n\nint dec(int x, int y) {\n\tx -= y;\n\treturn x < 0 ? x + mod : x;\n}\n\nint pow_mod(int a, int k) {\n\tint ans = 1;\n\twhile(k) {\n\t\tif(k & 1) ans = (LL)ans * a % mod;\n\t\ta = (LL)a * a % mod, k /= 2;\n\t} return ans;\n}\n\nint C(int n, int m) {return (LL)jc[n] * inv[m] % mod * inv[n - m] % mod;}\n\nint A(int n, int m) {return (LL)jc[n] * inv[n - m] % mod;}\n\nint main() {\n\tint n = read(), m = read();\n\tjc[0] = 1; for(int i = 1; i <= _max(n, m); i++) jc[i] = (LL)jc[i - 1] * i % mod;\n\tinv[n] = pow_mod(jc[n], mod - 2); for(int i = n; i >= 1; i--) inv[i - 1] = (LL)inv[i] * i % mod;\n\tint ans = (LL)pow_mod(n + 1, m) * pow_mod(m + 1, n) % mod;\n\tfor(int i = 1; i <= _min(n, m); i++) {\n\t\tif(i & 1) ans = dec(ans, (LL)C(n, i) * A(m, i) % mod * pow_mod(n + 1, m - i) % mod * pow_mod(m + 1, n - i) % mod);\n\t\telse ans = add(ans, (LL)C(n, i) * A(m, i) % mod * pow_mod(n + 1, m - i) % mod * pow_mod(m + 1, n - i) % mod);\n\t} put(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Badwaper gg\n#include<bits/stdc++.h>\n#define inf 1e9\n#define eps 1e-6\n#define mp make_pair\n#define pb push_back\n#define re register ll\n#define fr first\n#define sd second\n#define FOR(i,a,b) for(re i=a;i<=b;i++)\n#define REP(i,a,b) for(re i=a;i>=b;i--)\n#define lowbit(x) x&(-x)\n#define Z(x) (x>=mod?x-mod:x)\n#define N 500010 \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline ll read()\n{\n\tchar ch=getchar();\n\tll s=0,w=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*w;\n}\nconst int mod=998244353;\nint n,fac[N],inv[N],m,P;\ninline int ksm(int a,int b)\n{\n\tint ans=1;if(b<0)return 0;\n\twhile(b){if(b&1)ans=1LL*ans*a%mod;b>>=1;a=1LL*a*a%mod;}\n\treturn ans;\n}\ninline int C(int n,int m){if(n<m)return 0;return 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),m=read();P=max(n,m);\n\tfac[0]=1;FOR(i,1,P)fac[i]=1LL*fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;FOR(i,2,P)inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n\tFOR(i,1,P)inv[i]=1LL*inv[i-1]*inv[i]%mod;\n\tint ans=0,c=1;\n\tFOR(i,0,P)ans=Z(ans+1LL*c*C(n,i)%mod*C(m,i)%mod*fac[i]%mod*ksm(m+1,n-i)%mod*ksm(n+1,m-i)%mod),c=mod-c;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int T=2e7,MOD=998244353;\n\nint fac[T+3],inv[T+3],n_[T+3],m_[T+3];\nint n,m;\n\nint fADD(int a,int b){return ((1ll*a+b)%MOD+MOD)%MOD;}\nint fTIME(int a,int b){return int(1ll*a*b%MOD);}\nint QPow(int a,int b){\n\tint res=1;\n\twhile(b){\n\t\tif(b&1) res=fTIME(res,a);\n\t\ta=fTIME(a,a);\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nvoid Process(){\n\tfac[0]=1;for(int i=1;i<=T;i++) fac[i]=fTIME(fac[i-1],i);\n\tinv[T]=QPow(fac[T],MOD-2);for(int i=T-1;i>=0;i--) inv[i]=fTIME(inv[i+1],i+1);\n\tn_[0]=1;for(int i=1;i<=T;i++) n_[i]=fTIME(n_[i-1],n+1);\n\tm_[0]=1;for(int i=1;i<=T;i++) m_[i]=fTIME(m_[i-1],m+1);\n}\nint fC(int a,int b){return fTIME(fac[b],fTIME(inv[a],inv[b-a]));}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n//\tif(n>m) swap(n,m);\n\tProcess();\n\tint ans=0;\n\tfor(int i=0;i<=min(m,n);i++){\n\t\tif(i%2) ans=((ans-fTIME(fTIME(fC(i,n),fC(i,m)),fTIME(fac[i],fTIME(n_[m-i],m_[n-i]))))%MOD+MOD)%MOD;\n\t\telse ans=fADD(ans,fTIME(fTIME(fC(i,n),fC(i,m)),fTIME(fac[i],fTIME(n_[m-i],m_[n-i]))));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\n#define LL long long\n\nusing namespace std;\n\nconst int maxN = (int) 5e5;\nconst int mod = (int) 998244353;\n\nLL qpow(LL a, LL b)\n{\n\tLL ans = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1) ans = ans * a % mod;\n\t\ta = a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nint n, m, ans;\nint fac[maxN + 2], ifac[maxN + 2];\n\nvoid init(int n)\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tifac[n] = qpow(fac[n], mod - 2);\n\tfor (int i = n - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;\n}\n\nint C(int n, int m)\n{\n\tif (n < 0 || m < 0 || m > n) return 0;\n\treturn 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint main()\n{ \n\tscanf(\"%d%d\", &n, &m);\n\tif (n < m) swap(n, m);\n\tinit(n);\n\tfor (int k = 0; k <= m; ++k)\n\t{\n\t\tans += 1ll * qpow(-1, k) * C(n, k) % mod * C(m, k) % mod * fac[k] % mod * qpow(m + 1, n - k) % mod * qpow(n + 1, m - k) % mod;\n\t\tans %= mod;\n\t\t(ans += mod) %= mod;\n\t}\n\tprintf(\"%d\\n\", (1ll * ans + mod) % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<stdint.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/rope>\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define VIS(it,con) for(auto it=con.begin();it!=con.end();++it)\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define MIN(x,y) (x=min(x,(y)))\n#define MAX(x,y) (x=max(x,(y)))\n#define mid (l+r>>1)\n#define lch (idx*2+1)\n#define rch (idx*2+2)\n/*****************************************************************************/\n#include<bits/stdc++.h>\n#define int int_fast64_t\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\n#define REP(i,j,k) for(register int i=(j);i<(k);++i)\n#define RREP(i,j,k) for(register int i=(j)-1;i>=(k);--i)\n#define ALL(a) a.begin(),a.end()\n#define MST(a,v) memset(a,(v),sizeof a)\n#define pb push_back\n#define F first\n#define S second\n#define endl '\\n'\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#define __debug\n#ifdef __debug\n\t#define IOS (void)0\n\t#define de(...) cerr<<__VA_ARGS__\n\t#define ar(a,s,t) {REP(__i,s,t)de(a[__i]<<' ');de(endl);}\n#else\n\t#define IOS cin.tie(0),cout.tie(0),ios_base::sync_with_stdio(false)\n\t#define de(...) (void)0\n\t#define ar(...) (void)0\n#endif\n/***********************************default***********************************/\nconst int maxn=5e5+9,mo=998244353;\nint n,m,fac[maxn],res=0;\n\nint qp(int x,int t=mo-2){\n\tint re=1;\n\twhile(t){\n\t\tif(t&1)re=re*x%mo;\n\t\tx=x*x%mo,t>>=1;\n\t}\n\treturn re;\n}\n\nint c(int x,int y){\n\tif(x==y)return 1;\n\telse if(y>x||y<0)return 0;\n\telse return fac[x]*qp(fac[y])%mo*qp(fac[x-y])%mo;\n}\n\nmain(){\n\tIOS;\n\tfac[0]=1;REP(i,1,maxn)fac[i]=fac[i-1]*i%mo;\n\tcin>>n>>m;\n\tREP(i,0,min(n,m)+1){\n\t\t(res+=(i%2?-1:1)*c(n,i)*c(m,i)%mo*fac[i]%mo*qp(m+1,n-i)%mo*qp(n+1,m-i)%mo)%=mo;\n\t}\n\tcout<<(mo+res%mo)%mo<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 500010, P = 998244353;\n\nint n, m;\nint inv[N], ifac[N], fac[N], pw[N], qw[N];\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n >> m;\n  if (n < m) swap(n, m);\n  inv[1] = 1;\n  for (int i = 2; i <= n; ++i)\n    inv[i] = -(P / i) * (ll)inv[P % i] % P + P;\n  ifac[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    ifac[i] = ifac[i - 1] * (ll)inv[i] % P;\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    fac[i] = fac[i - 1] * (ll)i % P;\n  pw[0] = 1;\n  for (int i = 1; i <= m; ++i)\n    pw[i] = pw[i - 1] * (n + 1LL) % P;\n  qw[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    qw[i] = qw[i - 1] * (m + 1LL) % P;\n  int ans = 0;\n  for (int i = 0; i <= m; ++i) {\n    int res = ((i & 1) ? (P - 1) : 1) * (ll)pw[m - i] % P * ifac[i] % P * ifac[m - i] % P * qw[n - i] % P * ifac[n - i] % P;\n    ans = (ans + res) % P;\n  }\n  ans = ans * (ll)fac[n] % P * fac[m] % P;\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n      -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int _ = 5e5 + 7 , MOD = 998244353;\nint jc[_] , inv[_] , N , M;\n\nint poww(long long a , int b){\n\tint times = 1;\n\twhile(b){if(b & 1) times = times * a % MOD; a = a * a % MOD; b >>= 1;}\n\treturn times;\n}\n\nint C(int p , int q){return 1ll * jc[p] * inv[q] % MOD * inv[p - q] % MOD;}\n\nint main(){\n\tcin >> N >> M; if(N < M) swap(N , M);\n\tjc[0] = 1; for(int i = 1 ; i <= N ; ++i) jc[i] = 1ll * jc[i - 1] * i % MOD;\n\tinv[N] = poww(jc[N] , MOD - 2);\n\tfor(int i = N - 1 ; i >= 0 ; --i) inv[i] = inv[i + 1] * (i + 1ll) % MOD;\n\tint sum = 0;\n\tfor(int i = 0 ; i <= M ; ++i)\n\t\tsum = (sum + (i & 1 ? -1ll : 1ll) * C(N , i) * C(M , i) % MOD * jc[i] % MOD * poww(M + 1 , N - i) % MOD * poww(N + 1 , M - i) % MOD + MOD) % MOD;\n\tcout << sum; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint fac[1<<20|5],inv[1<<20|5],invf[1<<20|5],nn;\nconst int p=998244353,G=114514;\nint f[1<<20|5],g[1<<20|5],N,rev[1<<20|5],w[1<<22|5];\nint C(int a,int b){return fac[a]*invf[b]%p*invf[a-b]%p;}\n\nint fpm(int a,int b){\n\tint c=1;for(;b;b>>=1,a=a*a%p)if(b&1)c=c*a%p;\n\treturn c;\n}\nvoid upd(int N){\n\tif(nn<N){\n\t\tfor(int i=nn;i<N;++i){\n\t\t\tfac[i]=fac[i-1]*i%p;\n\t\t\tinv[i]=(p-p/i)*inv[p%i]%p;\n\t\t\tinvf[i]=inv[i]*invf[i-1]%p;\n\t\t}\t\n\t\tfor(int i=nn;i<N;i<<=1){\n\t\t\tint xw=fpm(G,(p-1)/i/2),ww=1;\n\t\t\tfor(int j=0;j<i;++j){\n\t\t\t\tw[i+j]=ww;\n\t\t\t\tww=ww*xw%p;\n\t\t\t}\n\t\t}\n\t\tnn=N;\n\t}\n}\nint sum(int a,int b){return (a+=b)>=p?a-p:a;}\nint minu(int a,int b){return (a-=b)<0?a+p:a;}\nvoid dft(int *a,int N){\n\tfor(int i=1;i<N;++i){\n\t\trev[i]=rev[i>>1]>>1|((i&1)*(N>>1));\n\t\tif(i<rev[i])swap(a[i],a[rev[i]]);\n\t}\n\tfor(int i=1;i<N;i<<=1){\n\t\tfor(int j=0;j<N;j+=i+i){\n\t\t\tfor(int k=0;k<i;++k){\n\t\t\t\tint u=a[j+k],v=a[i+j+k]*w[i+k]%p;\n\t\t\t\ta[j+k]=sum(u,v);\n\t\t\t\ta[j+k+i]=minu(u,v);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid idft(int *a,int N){\n\treverse(a+1,a+N);\n\tdft(a,N);\n\tint iN=fpm(N,p-2)%p;\n\tfor(int i=0;i<N;++i)a[i]=a[i]*iN%p;\n}\nint h1[1<<20|5],h2[1<<20|5],h3[1<<20|5],h4[1<<20|5],h5[1<<20|5];\nvoid Inv(int *a,int n,int *b){\n\tb[0]=fpm(a[0],p-2);\t\n\t/*for(int i=1;i<n;++i){\n\t\tb[i]=0;\n\t\tfor(int j=1;j<=i;++j)b[i]=(b[i]+b[i-j]*a[j])%p;\n\t\tb[i]=(p-b[i])*b[0]%p;\n\t}\n\tassert(a[0]*b[0]%p==1);\n\tfor(int i=1;i<n;++i){\n\t\tint s=0;\n\t\tfor(int j=0;j<=i;++j)s=(s+a[j]*b[i-j])%p;\n\t\tassert(!s);\n\t}\n\treturn;*/\n\tfor(int i=1;i<n;++i)b[i]=0;\n\tint m=1;\n\tfor(;m<n;m<<=1){\n\t\tint N=m<<2;\n\t\tupd(N);\n\t\tfor(int i=0;i<m;++i){\n\t\t\th1[i]=b[i];\t\n\t\t}\t\n\t\tfor(int i=m;i<N;++i)h1[i]=0;\n\t\tfor(int i=0;i<m<<1;++i)h2[i]=a[i];\n\t\tfor(int i=m<<1;i<N;++i)h2[i]=0;\n\t\tdft(h1,N);\n\t\tdft(h2,N);\n\t\tfor(int i=0;i<N;++i)h1[i]=h1[i]*h1[i]%p*h2[i]%p;\n\t\tidft(h1,N);\n\t\tfor(int i=0;i<m<<1;++i)b[i]=(2*b[i]+p-h1[i])%p;\n\t}\n\tfor(int i=n;i<m;++i)b[i]=0;\n} \nvoid ln(int *a,int n,int *b){\n\tInv(a,n,h3);\n\tint N=1;\n\twhile(N<n+n)N<<=1;\n\tupd(N);\n\tfor(int i=1;i<n;++i)h1[i-1]=a[i]*i%p;\t\n\tfor(int i=n-1;i<N;++i)h1[i]=0;\n\tfor(int i=n;i<N;++i)h3[i]=0;\n\tdft(h1,N);\n\tdft(h3,N);\n\tfor(int i=0;i<N;++i)h1[i]=h1[i]*h3[i]%p;\n\tidft(h1,N);\n\tb[0]=0;\n\tfor(int i=1;i<n;++i)b[i]=h1[i-1]*inv[i]%p;\n}\nvoid exp(int *a,int n,int *b){\n/*\tb[0]=1;\n\tfor(int i=1;i<n;++i){\n\t\tb[i]=0;\n\t\tfor(int j=1;j<=i;++j)b[i]=(b[i]+b[i-j]*C(i-1,j-1)%p*a[j])%p;\n\t}\n\treturn;*/\n\tb[0]=1;\n\tint m=1;\n\tfor(;m<n;m<<=1){\n\t\tln(b,m<<1,h4);\n\t\tfor(int i=0;i<m<<1;++i)(h4[i]-=a[i])<0?h4[i]+=p:0;\n\t\tint N=m<<2;\n\t\tupd(N);\n\t\tfor(int i=m<<1;i<N;++i)h4[i]=0;\n\t\tfor(int i=0;i<m;++i)h1[i]=b[i];\n\t\tfor(int i=m;i<N;++i)h1[i]=0;\n\t\tdft(h1,N);\n\t\tdft(h4,N);\n\t\tfor(int i=0;i<N;++i)h1[i]=h1[i]*h4[i]%p;\n\t\tidft(h1,N);\n\t\tfor(int i=0;i<m<<1;++i)b[i]=(b[i]+p-h1[i])%p;\n\t}\n\tfor(int i=n;i<m;++i)b[i]=0;\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint n,m;\t\n\tread(n,m);\n\tfac[0]=fac[1]=inv[1]=invf[0]=invf[1]=1;\n\tfor(int i=2;i<=m;++i){\n\t\tfac[i]=fac[i-1]*i%p;\n\t\tinv[i]=(p-p/i)*inv[p%i]%p;\n\t\tinvf[i]=inv[i]*invf[i-1]%p;\n\t}\n\tfor(int i=0;i<=m;++i){\n\t\tf[i]=(m-i+1)*invf[i]%p;\n\t}\n\tnn=2;\n\tfor(int i=1;i<nn;i<<=1){\n\t\tint xw=fpm(G,(p-1)/i/2),ww=1;\n\t\tfor(int j=0;j<i;++j){\n\t\t\tw[i+j]=ww;\n\t\t\tww=ww*xw%p;\n\t\t}\n\t}\n\tint s=f[0],is=fpm(s,p-2);\n\tfor(int i=0;i<=m;++i)f[i]=f[i]*is%p;\n\tln(f,m+1,g);\n\tfor(int i=0;i<=m;++i){f[i]=g[i]*n%p;g[i]=0;}\n\texp(f,m+1,g);\n\ts=fpm(s,n);\n\tfor(int i=0;i<=m;++i)g[i]=g[i]*s%p;\n\tint ans=0;\n\tfor(int i=0;i<=m;++i)ans=(ans+g[i]*invf[m-i]%p*fac[m])%p;\n\twrite(ans,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long LL;\nconst int N = 5e5+10 , mod = 998244353;\ninline int read()\n{\n\tregister int x = 0 , f = 0; register char c = getchar();\n\twhile(c < '0' || c > '9') f |= c == '-' , c = getchar();\n\twhile(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0' , c = getchar();\n\treturn f ? -x : x;\n}\nint n , m;\nint fac[N] , inv[N];\ninline int add(int a , int b) { a += b; return a >= mod ? a - mod : a; }\ninline int mul(int a , int b) { return (LL)a * b % mod; }\ninline int ksm(int a , int k) { a %= mod; int ans = 1; for( ; k ; k >>= 1 , a = mul(a , a)) if(k & 1) ans = mul(ans , a); return ans; }\ninline int C(int n , int m) { return mul(fac[n] , mul(inv[m] , inv[n-m])); }\nint main()\n{\n\tn = read(); m = read(); if(n > m) swap(n , m);\n\tfac[0] = inv[0] = inv[1] = 1;\n\tfor(int i = 1 ; i <= m ; ++i) fac[i] = mul(fac[i-1] , i); //cout << fac[1] << ' '; cout << '\\n';\n\tfor(int i = 2 ; i <= m ; ++i) inv[i] = mul(inv[mod % i] , mod - mod / i);\n\t//cout << inv[0] << ' ' << inv[1] << '\\n';\n\tfor(int i = 1 ; i <= m ; ++i) inv[i] = mul(inv[i-1] , inv[i]);\n\t//cout << inv[1] << ' '; cout << '\\n';\n\tint ans = 0 , op = 0 , tmp; // cout << C(2 , 0) << '\\n';\n\tfor(int i = 0 ; i <= n ; ++i)\n\t{\n\t\top ^= 1;\n\t\ttmp = mul(mul(C(n , i) , C(m , i)) , mul(ksm(n + 1 , m - i) , ksm(m + 1 , n - i)));\n\t\tans = add(ans , (op ? 1 : -1) * mul(tmp , fac[i])); ans = add(ans , mod);\n\t\t// cout << ans << ' '; \n\t}\n\t// cout << '\\n';\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int P = 998244353;\nint power(int base, int exp) {\n    int result = 1;\n    while (exp > 0) {\n        if (exp & 1)\n            result = 1LL * result * base % P;\n        base = 1LL * base * base % P;\n        exp >>= 1;\n    }\n    return result;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    int l = max(n, m);\n    vector<int> factorial(l + 1), inv_factorial(l + 1);\n    factorial[0] = 1;\n    for (int i = 1; i <= l; ++i)\n        factorial[i] = 1LL * factorial[i - 1] * i % P;\n    inv_factorial[l] = power(factorial[l], P - 2);\n    for (int i = l; i >= 1; --i)\n        inv_factorial[i - 1] = 1LL * inv_factorial[i] * i % P;\n    auto binom = [&](int n, int m) {return 1LL * factorial[n] * inv_factorial[m] % P * inv_factorial[n - m] % P;};\n    int ans = 0;\n    for (int i = min(n, m), x = 1LL * power(m + 1, n - i) * power(n + 1, m - i) % P; i >= 0; --i) {\n        int res = 1LL * binom(n, i) * binom(m, i) % P * factorial[i] % P * x % P;\n        x = 1LL * x * (n + 1) % P * (m + 1) % P;\n        if (i % 2 == 0)\n            ans = (ans + res) % P;\n        else\n            ans = (ans - res + P) % P;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=5e5+5;\nconst int mod=998244353;\nint n,m,inv[N],jc[N],jcn[N],pn[N],pm[N],ans;\nint C(int n,int m){return 1ll*jc[n]*jcn[m]%mod*jcn[n-m]%mod;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tif(n<m)swap(n,m);\n\tinv[1]=jc[0]=jcn[0]=1;\n\tfor(int i=2;i<=n;++i)inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;\n\tfor(int i=1;i<=n;++i){\n\t\tjc[i]=1ll*jc[i-1]*i%mod;\n\t\tjcn[i]=1ll*jcn[i-1]*inv[i]%mod;\n\t}\n\tfor(int i=pn[0]=1;i<=m;++i)pn[i]=1ll*pn[i-1]*(n+1)%mod;\n\tfor(int i=pm[0]=1;i<=n;++i)pm[i]=1ll*pm[i-1]*(m+1)%mod;\n\tfor(int i=0;i<=m;++i){\n\t\tint res=1ll*C(n,i)*C(m,i)%mod*jc[i]%mod*pn[m-i]%mod*pm[n-i]%mod;\n\t\ti&1?ans=(ans-res+mod)%mod:ans=(ans+res)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 20000000;\nconst int MOD = 998244353;\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\twhile( p ) {\n\t\tif( p & 1 ) ret = 1LL*ret*b%MOD;\n\t\tb = 1LL*b*b%MOD;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nint fct[MAXN + 5], ifct[MAXN + 5];\nvoid init() {\n\tfct[0] = 1;\n\tfor(int i=1;i<=MAXN;i++)\n\t\tfct[i] = 1LL*fct[i-1]*i%MOD;\n\tifct[MAXN] = pow_mod(fct[MAXN], MOD-2);\n\tfor(int i=MAXN-1;i>=0;i--)\n\t\tifct[i] = 1LL*ifct[i+1]*(i+1)%MOD;\n}\nint pw1[MAXN + 5], pw2[MAXN + 5];\nint main() {\n\tinit();\tint N, M;\n\tscanf(\"%d%d\", &N, &M);\n\tint ans = 0;\n\tpw1[0] = pw2[0] = 1;\n\tfor(int i=1;i<=max(N, M);i++)\n\t\tpw1[i] = 1LL*pw1[i-1]*(N+1)%MOD, pw2[i] = 1LL*pw2[i-1]*(M+1)%MOD;\n\tfor(int i=0,f=1;i<=min(N,M);i++,f=1LL*f*(MOD-1)%MOD) {\n\t\tint del = 1LL*ifct[N-i]*ifct[M-i]%MOD*ifct[i]%MOD;\n\t\tdel = 1LL*del*pw1[M-i]%MOD*pw2[N-i]%MOD;\n\t\tans = (ans + 1LL*f*del)%MOD;\n\t}\n\tprintf(\"%lld\\n\", 1LL*ans*fct[N]%MOD*fct[M]%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Mod = 998244353;\nconst int Max_N = 500005;\n\nint fexp(int base, int exp) {\n\tint ret = 1;\n\twhile (exp) {\n\t\tif (exp & 1)\n\t\t\tret = 1LL * ret * base % Mod;\n\t\tbase = 1LL * base * base % Mod;\n\t\texp >>= 1;\n\t}\n\treturn ret;\n}\n\ninline int get_inv(int x) {\n\treturn fexp(x, Mod - 2);\n}\n\nint N, M, Ans;\nint pwN[Max_N], pwM[Max_N], fac[Max_N], inv[Max_N];\n\ninline int binom(int x, int y) {\n\treturn 1LL * fac[x] * inv[y] % Mod * inv[x - y] % Mod;\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tpwN[0] = pwM[0] = 1;\n\tfor (int i = 1; i < Max_N; i++) {\n\t\tpwN[i] = 1LL * pwN[i - 1] * (N + 1) % Mod;\n\t\tpwM[i] = 1LL * pwM[i - 1] * (M + 1) % Mod;\n\t}\n\tfac[0] = 1;\n\tfor (int i = 1; i < Max_N; i++)\n\t\tfac[i] = 1LL * fac[i - 1] * i % Mod;\n\tinv[Max_N - 1] = get_inv(fac[Max_N - 1]);\n\tfor (int i = Max_N - 2; i >= 0; i--)\n\t\tinv[i] = 1LL * inv[i + 1] * (i + 1) % Mod;\n\t\n\tfor (int d = 1, i = 0; i <= min(N, M); i++, d *= -1) {\n\t\tAns = (Ans + 1LL * d * (1LL * binom(N, i) * binom(M, i) % Mod * fac[i] % Mod) * (1LL * pwM[N - i] * pwN[M - i] % Mod) % Mod) % Mod;\n\t}\n\tif (Ans < 0)\n\t\tAns = (Ans + Mod) % Mod;\n\tprintf(\"%d\\n\", Ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= int(n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n\nnamespace {\n    const int mo = 998244353;\n    const int G = 3;\n    inline int add(int x, int y) { x += y; return x >= mo ? x - mo : x; }\n    inline int sub(int x, int y) { x -= y; return x < 0 ? x + mo : x; }\n    inline int mul(int x, int y) { return (lo) x * y % mo; }\n    inline int power(int a, lo k = mo - 2) {\n\t\tint ans = 1;\n\t\tfor (; k; k >>= 1, a = mul(a, a))\n\t\t\tif (k & 1) ans = mul(ans, a);\n\t\treturn ans;\n    }\n    inline int getind(int x) {\n\t\tunordered_map <int, int> mp;\n\t\tint K = sqrt(mo), ix = power(x);\n\t\tfor (int t = 1, k = 0; k <= K; k++, t = mul(t, G))\n\t\t\tmp[t] = k;\n\t\tint p = power(G, K);\n\t\tfor (int t = p, k = 1; k <= K; k++, t = mul(t, p))\n\t\t\tif (mp.count(mul(t, ix))) {\n\t\t\t\treturn k * K - mp[mul(t, ix)];\n\t\t\t}\n\t\tassert(0);\n    }\n    inline int getSqrt(int x) {\n\t\tint t = power(G, getind(x) / 2);\n\t\treturn min(t, mo - t);\n    }\n}\ntypedef unsigned long long ul;\ntypedef vector <int> poly;\n#define pb push_back\n\nconst int N = (1 << 20) + 233;\nnamespace FFT {\n    int fft_n, fft_l, rev[N];\n    ul *data[30], wn[N << 1];\n\t\n    inline void prepare(int n) {\n\t\tfft_n = 1; fft_l = -1;\n\t\twhile (fft_n < n) fft_n <<= 1, ++fft_l;\n\t\tre0 (i, fft_n) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << fft_l);\n\tul *cur = wn;\n\tfor (int cn = 2, step = 0; cn <= fft_n; cn <<= 1, ++step) {\n\t    data[step] = cur;\n\t    ul t = power(G, (mo - 1) / cn), w = 1;\n\t    re0 (k, cn) *cur++ = w, w = w * t % mo;\n\t}\n    }\n    inline void dft(ul *a, int n) {\n\tre0 (i, n) if (i < rev[i]) swap(a[i], a[rev[i]]);\n\tfor (int l = 2, step = 0; l <= fft_n; l <<= 1, ++step) \n\t    for (int i = 0, m = l >> 1; i < fft_n; i += l) {\n\t\tul *l = a + i, *r = a + i + m, *w = data[step];\n\t\tfor (int k = 0; k < m; k++, ++l, ++r, ++w) {\n\t\t    ul y = *r * *w % mo;\n\t\t    *r = *l + mo - y; *l += y;\n\t\t}\n\t    }\n\tre0 (i, n) a[i] %= mo;\n    }\n    inline void idft(ul *a, int n) {\n\tdft(a, n);\n\treverse(a + 1, a + n);\n\tint invn = power(n);\n\tre0 (i, n) a[i] = mul(a[i], invn);\n    }\n    poly realmain(poly a, poly b, int op = 1) {\n\tstatic ul x[N], y[N];\n\tint n = a.size(), m = b.size();\n\tprepare(n * op + m - 1);\n\tre0 (i, fft_n) {\n\t    x[i] = i < n ? a[i] : 0;\n\t    y[i] = i < m ? b[i] : 0;\n\t}\n\tdft(x, fft_n); dft(y, fft_n);\n\tre0 (i, fft_n) x[i] = mul(op == 2 ? x[i] : 1, mul(x[i], y[i]));\n\tidft(x, fft_n);\n\tpoly ans(n + m - 1, 0);\n\tre0 (i, ans.size()) ans[i] = x[i];\n\treturn ans;\n    }\n}\n\npoly K(poly a, int l) { a.resize(l); return a; }\npoly rev(poly a) { reverse(a.begin(), a.end()); return a; }\n\ninline void ovo(poly a) {\n    cout << \"(\";\n    re0 (i, a.size()) cout << a[i] << \",)\"[i + 1 == a.size()];\n    cout << \"\\n\";\n}\n\npoly operator + (poly a, poly b) {\n    if (a.size() < b.size()) a.resize(b.size());\n    re0 (i, b.size()) a[i] = add(a[i], b[i]);\n    return a;\n}\n\npoly operator - (poly a, poly b) {\n    if (a.size() < b.size()) a.resize(b.size());\n    re0 (i, b.size()) a[i] = sub(a[i], b[i]);\n    return a;\n}\n\npoly operator * (poly a, poly b) {\n    if (a.size() + b.size() < 128) {\n\tif (!a.size() && !b.size()) return a;\n\tpoly ans(a.size() + b.size() - 1, 0);\n\tre0 (i, a.size()) re0 (j, b.size()) ans[i + j] = add(ans[i + j], mul(a[i], b[j]));\n\treturn ans;\n    }\n    return FFT::realmain(a, b);\n}\n\npoly operator * (poly a, int k) {\n    re0 (i, a.size()) a[i] = mul(a[i], k);\n    return a;\n}\n\npoly Der(poly a) {\n    if (!a.size()) return poly(1, 0);\n    poly t(a.size() - 1, 0);\n    rep (i, t.size()) t[i - 1] = mul(a[i], i);\n    return t;\n}\n\npoly Int(poly a) {\n    static int inv[N];\n    inv[0] = inv[1] = 1;\n    for (int i = 2; i <= (int) a.size(); i++)\n\tinv[i] = mul(mo - mo / i, inv[mo % i]);\n    poly t(a.size() + 1, 0);\n    rep (i, a.size()) t[i] = mul(a[i - 1], inv[i]);\n    return t;\n}\n\npoly Inv(poly a, int n) {\n    a.resize(n);\n    if (n == 1) return poly(1, power(a[0]));\n    poly b = Inv(a, (n + 1) >> 1); \n    return K(b * 2 - K(FFT::realmain(b, a, 2), n), n);\n}\n\npoly Ln(poly a, int n) {\n    return Int(K(Der(a) * Inv(a, n), n - 1));\n}\n\npoly Exp(poly a, int n) {\n    a.resize(n);\n    if (n == 1) return assert(a[0] == 0), poly(1, 1);\n    poly b = Exp(a, (n + 1) >> 1);\n    return K(b * (a + poly(1, 1) - Ln(b, n)), n);\n}\n\npoly Sqrt(poly a, int n) {\n    a.resize(n);\n    if (n == 1) return poly(1, getSqrt(a[0]));\n    poly b = Sqrt(a, (n + 1) >> 1);\n    return (b + K(a * Inv(b, n), n)) * power(2);\n}\n\npoly power(poly a, lo k) {\n    int n = a.size();\n    int p = 0;\n    while (p < a.size() && !a[p]) ++p;\n    if (p == a.size() || p * k > n) return poly(n, 0);\n    poly b(a.size() - p, 0);\n    int tmp = a[p], t = power(a[p]);\n    re0 (i, b.size()) b[i] = mul(t, a[i + p]);\n    b = Exp(Ln(b, n - p) * k, n - p);\n    b = rev(b); b.resize(b.size() + p * k); b = rev(b);\n    return K(b * power(tmp, k), n);\n}\n\nint fac[N], ifac[N];\ninline int C(int n, int m) {\n\treturn n < m ? 0 : mul(fac[n], mul(ifac[m], ifac[n - m]));\n}\n\nint main(void) {\n\tint n, m;\n\tread(n); read(m);\n\tfac[0] = 1; rep (i, m) fac[i] = mul(fac[i - 1], i);\n\tifac[m] = power(fac[m]); for (int i = m - 1; i >= 0; i--) ifac[i] = mul(ifac[i + 1], i + 1);\n\tpoly dp(m + 1, 0);\n\tfor (int k = 0; k <= m; k++) {\n\t\tdp[k] = mul(m + 1 - k, ifac[k]);\n\t}\n\tdp = power(dp, n);\n\tint ans = 0;\n\tfor (int i = 0; i <= m; i++) {\n\t\tans = add(ans, mul(dp[i], mul(fac[m], ifac[m - i])));\n\t}\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT power(T a, long long b) {\n  T r = 1;\n  while (b) {\n    if (b & 1) {\n      r *= a;\n    }\n    a *= a;\n    b >>= 1;\n  }\n  return r;\n}\n\nint inverse(int a, int m) {\n  a %= m;\n  if (a < 0) {\n    a += m;\n  }\n  int b = m, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= a * t;\n    swap(a, b);\n    u -= v * t;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += m;\n  }\n  return u;\n}\n\ntemplate <int _P>\nstruct modnum {\n  static constexpr int P = _P;\n\n private:\n  int v;\n\n public:\n  modnum() : v(0) {\n  }\n\n  modnum(long long _v) {\n    v = _v % P;\n    if (v < 0) {\n      v += P;\n    }\n  }\n\n  explicit operator int() const {\n    return v;\n  }\n\n  bool operator==(const modnum& o) const {\n    return v == o.v;\n  }\n\n  bool operator!=(const modnum& o) const {\n    return v != o.v;\n  }\n\n  modnum inverse() const {\n    return modnum(::inverse(v, P));\n  }\n\n  modnum operator-() const {\n    return modnum(v ? P - v : 0);\n  }\n  \n  modnum operator+() const {\n    return *this;\n  }\n\n  modnum& operator++() {\n    v++;\n    if (v == P) {\n      v = 0;\n    }\n    return *this;\n  }\n  \n  modnum& operator--() {\n    if (v == 0) {\n      v = P;\n    }\n    v--;\n    return *this;\n  }\n\n  modnum operator++(int) {\n    modnum r = *this;\n    ++*this;\n    return r;\n  }\n  \n  modnum operator--(int) {\n    modnum r = *this;\n    --*this;\n    return r;\n  }\n\n  modnum& operator+=(const modnum& o) {\n    v += o.v;\n    if (v >= P) {\n      v -= P;\n    }\n    return *this;\n  }\n\n  modnum operator+(const modnum& o) const {\n    return modnum(*this) += o;\n  }\n\n  modnum& operator-=(const modnum& o) {\n    v -= o.v;\n    if (v < 0) {\n      v += P;\n    }\n    return *this;\n  }\n\n  modnum operator-(const modnum& o) const {\n    return modnum(*this) -= o;\n  }\n\n  modnum& operator*=(const modnum& o) {\n    v = (int) ((long long) v * o.v % P);\n    return *this;\n  }\n\n  modnum operator*(const modnum& o) const {\n    return modnum(*this) *= o;\n  }\n  \n  modnum& operator/=(const modnum& o) {\n    return *this *= o.inverse();\n  }\n\n  modnum operator/(const modnum& o) const {\n    return modnum(*this) /= o;\n  }\n};\n\ntemplate <int _P>\nostream& operator<<(ostream& out, const modnum<_P>& n) {\n  return out << int(n);\n}\n\ntemplate <int _P>\nistream& operator>>(istream& in, modnum<_P>& n) {\n  long long _v;\n  in >> _v;\n  n = modnum<_P>(_v);\n  return in;\n}\n\nusing num = modnum<998244353>;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  int g = max(n, m);\n  vector<num> fact(g + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= g; ++i) {\n    fact[i] = fact[i - 1] * i;\n  }\n  vector<num> ifact(g + 1);\n  ifact[g] = num(1) / fact[g];\n  for (int i = g - 1; ~i; --i) {\n    ifact[i] = ifact[i + 1] * (i + 1);\n  }\n  auto c = [&](int a, int b) {\n    return fact[a] * ifact[b] * ifact[a - b];\n  };\n  num ans = 0;\n  for (int i = 0; i <= min(n, m); ++i) {\n    ans += c(n, i) * c(m, i) * power(num(n + 1), m - i) * power(num(m + 1), n - i) * fact[i] * ((i & 1) ? -1 : 1);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define inver(a) power(a,mod-2)\nusing namespace std;\ninline char nc()\n{\n    // return getchar();\n    static char buf[100000],*l=buf,*r=buf;\n    return l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x)\n{\n    x=0; int f=1,ch=nc();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n    while(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n    x*=f;\n}\ntypedef long long ll;\nconst int mod=998244353;\nconst int maxm=5e5+50;\nint n,m;\nint fac[maxm];\nint inv[maxm];\nll power(ll x,ll y)\n{\n    ll re=1;\n    while(y)\n    {\n        if(y&1) re=re*x%mod;\n        x=x*x%mod;\n        y>>=1;\n    }\n    return re;\n}\ninline ll binom(int x,int y)\n{\n    return (ll)fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nvoid init(int n)\n{\n    fac[0]=1;\n    for(int i=1;i<=n;++i) fac[i]=(ll)fac[i-1]*i%mod;\n    inv[n]=inver(fac[n]);\n    for(int i=n;i>=1;--i) inv[i-1]=(ll)inv[i]*i%mod;\n}\nint main()\n{\n    read(n),read(m);\n    if(n>m) swap(n,m);\n    init(m);\n    int an=0;\n    for(int i=0,f=1;i<=n;++i)\n    {\n        an=(an+f*power(m+1,n-i)%mod*power(n+1,m-i)%mod*fac[i]%mod*binom(n,i)%mod*binom(m,i))%mod;\n        f=mod-f;\n    }\n    printf(\"%d\\n\",an);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 20000005\n#define ll long long\n#define mod 998244353\nint n, m, ans;\nint fac[N], inv[N], mul1[N], mul2[N];\nint ksm(int a, int k)\n{\n\tif (!k)\n\t\treturn 1;\n\tint p = ksm(a, k / 2);\n\tif (k & 1)\n\t\treturn (ll)p * p % mod * a % mod;\n\treturn (ll)p * p % mod;\n}\nint C(int n, int m){return (ll)fac[n] * inv[m] % mod * inv[n - m] % mod;}\nint main()\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N - 5; i++)\n\t\tfac[i] = (ll)fac[i - 1] * i % mod;\n\tinv[N - 5] = ksm(fac[N - 5], mod - 2);\n\tfor (int i = N - 5; i >= 1; i--)\n\t\tinv[i - 1] = (ll)inv[i] * i % mod;\n\tscanf(\"%d%d\", &n, &m);\n\tmul1[0] = 1;\n\tfor (int i = 1; i <= m; i++)\n\t\tmul1[i] = (ll)mul1[i - 1] * (n + 1) % mod;\n\tmul2[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tmul2[i] = (ll)mul2[i - 1] * (m + 1) % mod;\n\tfor (int i = 0; i <= min(n, m); i++)\n\t{\n\t\tif (i & 1)\n\t\t\tans = (ans - (ll)C(n, i) * C(m, i) % mod * fac[i] % mod * mul1[m - i] % mod  * mul2[n - i]) % mod;\n\t\telse\n\t\t\tans = (ans + (ll)C(n, i) * C(m, i) % mod * fac[i] % mod * mul1[m - i] % mod  * mul2[n - i]) % mod;\n\t}\n\tif (ans < 0)ans += mod;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//Have a nice day:)\n#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\ninline int read();\n\nconst int maxn=5e5+5;\nconst int mod=998244353;\n\nint n, m, ans;\nint fac[maxn], inv[maxn];\nint Pow(int a, int b)\n{\n    int u=1;\n    for(; b; b>>=1, a=1ll*a*a%mod) if(b&1) u=1ll*u*a%mod;\n    return u;\n}\n\nvoid Init()\n{\n    fac[0]=inv[0]=1;\n    for(int i=1; i<=maxn-5; ++i) fac[i]=1ll*fac[i-1]*i%mod;\n    inv[maxn-5]=Pow(fac[maxn-5], mod-2);\n    for(int i=maxn-6; i>=1; --i) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\n\nint C(int a, int b) { return 1ll*fac[b]*inv[a]%mod*inv[b-a]%mod; }\n\nvoid Work()\n{    \n    n=read(), m=read(); Init();\n    for(int i=min(n, m); i>=0; --i)\n    {\n        ans=(ans+(i&1 ? -1ll : 1ll)*C(i, n)*C(i, m)%mod*fac[i]%mod\n            *Pow(n+1, m-i)%mod*Pow(m+1, n-i)%mod)%mod;\n    }\n    printf(\"%d\", ans);\n}\n\nint main()\n{\n   \n\n    Work();\n\n    return 0;\n}\n\ninline int read()\n{\n    char c; bool type=1;\n    while((c=getchar())<'0' || c>'9')\n        if(c=='-') type=0;\n    int ans=c^48;\n    while((c=getchar())>='0' && c<='9')\n        ans=(ans<<3)+(ans<<1)+(c^48);\n    return type?ans:-ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst ll MOD=998244353;\nint n,m;\nll fact[500005],inv[500005],pn[500005],pm[500005];\nll quick_pow(ll x,ll a)\n{\n\tll ans=1;\n\twhile(a)\n\t{\n\t\tif(a&1)ans=ans*x%MOD;\n\t\tx=x*x%MOD;\n\t\ta>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfact[0]=1;\n\tfor(int i=1;i<=max(n,m);i++)fact[i]=fact[i-1]*i%MOD;\n\tinv[max(n,m)]=quick_pow(fact[max(n,m)],MOD-2);\n\tfor(int i=max(n,m);i>=1;i--)inv[i-1]=inv[i]*i%MOD;\n\tpn[0]=pm[0]=1;\n\tfor(int i=1;i<=max(n,m);i++)\n\t{\n\t\tpn[i]=pn[i-1]*(n+1)%MOD;\n\t\tpm[i]=pm[i-1]*(m+1)%MOD;\n\t}\n\tll ans=0;\n\tfor(int i=0;i<=min(n,m);i++)\n\t{\n\t\tif(i&1)ans-=fact[n]*inv[i]%MOD*inv[n-i]%MOD*fact[m]%MOD*inv[m-i]%MOD*pm[n-i]%MOD*pn[m-i]%MOD;\n\t\telse ans+=fact[n]*inv[i]%MOD*inv[n-i]%MOD*fact[m]%MOD*inv[m-i]%MOD*pm[n-i]%MOD*pn[m-i]%MOD;\n\t}\n\tans%=MOD;\n\tif(ans<0)ans+=MOD;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\n\ntypedef unsigned int uint;\ntypedef long long unsigned int uint64;\n\n\nconstexpr uint Max_size = 2000010, Mod = 998244353;\n\nstruct Z\n{\n    uint v;\n    Z(const uint _v = 0) : v(_v) { }\n};\n\ninline Z operator+(const Z &x1, const Z &x2) { return x1.v + x2.v < Mod ? x1.v + x2.v : x1.v + x2.v - Mod; }\ninline Z operator-(const Z &x1, const Z &x2) { return x1.v >= x2.v ? x1.v - x2.v : x1.v + Mod - x2.v; }\ninline Z operator-(const Z &x) { return x.v ? Mod - x.v : 0; }\ninline Z operator*(const Z &x1, const Z &x2) { return static_cast<uint64>(x1.v) * x2.v % Mod; }\ninline Z &operator+=(Z &x1, const Z &x2) { x1.v = x1.v + x2.v < Mod ? x1.v + x2.v : x1.v + x2.v - Mod; return x1; }\ninline Z &operator-=(Z &x1, const Z &x2) { x1.v = x1.v >= x2.v ? x1.v - x2.v : x1.v + Mod - x2.v; return x1; }\ninline Z &operator*=(Z &x1, const Z &x2) { x1.v = static_cast<uint64>(x1.v) * x2.v % Mod; return x1; }\n \nZ Power(Z Base, int Exp)\n{\n    Z res = 1;\n    for (; Exp; Base *= Base, Exp >>= 1)\n        if (Exp & 1)\n            res *= Base;\n    return res;\n}\n\nZ sqrt(const Z x)\n{\n    if (x.v == 0)\n        return 0;\n    Z w = 1;\n    while (Power(w * w - x, (Mod - 1) / 2).v == 1)\n        ++w.v;\n    Z Base0 = w, Base1 = 1;\n    w = w * w - x;\n    Z res0 = 1, res1 = 0;\n    int Exp = (Mod + 1) / 2;\n    for (; Exp; std::tie(Base0, Base1) = std::make_tuple(Base0 * Base0 + Base1 * Base1 * w, 2 * Base0 * Base1), Exp >>= 1)\n        if (Exp & 1)\n            std::tie(res0, res1) = std::make_tuple(res0 * Base0 + res1 * Base1 * w, res0 * Base1 + Base0 * res1);\n    return res0.v < Mod - res0.v ? res0 : Mod - res0;\n}\n\nint size;\nint bitrev[Max_size];\nZ w[Max_size];\nZ Inv[Max_size];\n\ninline void init(int n)\n{\n    for (size = 1; size < n; size <<= 1)\n        ;\n    for (int i = 0; i < size; ++i)\n        bitrev[i] = bitrev[i >> 1] >> 1 | ((i & 1) * (size >> 1));\n    Z pr = Power(3, (Mod - 1) / size);\n    w[size / 2] = 1;\n    for (int i = 1; i < size / 2; ++i)\n        w[size / 2 + i] = w[size / 2 + i - 1] * pr;\n    for (int i = size / 2 - 1; i; --i)\n        w[i] = w[i << 1];\n    Inv[1] = 1;\n    for (int i = 2; i < size; ++i)\n        Inv[i] = (Mod - Mod / i) * Inv[Mod % i];\n}\n\ninline void DFT(Z A[], int L)\n{\n    static uint64 t[Max_size];\n    \n    int shift = __builtin_ctz(size) - __builtin_ctz(L);\n    for (int i = 0; i != L; ++i)\n        t[bitrev[i] >> shift] = A[i].v;\n    for (int d = 1; d != L; d <<= 1)\n        for (int i = 0; i != L; i += d << 1)\n            for (int j = 0; j != d; ++j)\n            {\n                uint64 tmp = t[i + d + j] * w[d + j].v % Mod;\n                t[i + d + j] = t[i + j] + Mod - tmp, t[i + j] = t[i + j] + tmp;\n            }\n    for (int i = 0; i != L; ++i)\n        A[i].v = t[i] % Mod;\n}\n\ninline void IDFT(Z A[], int L)\n{\n    std::reverse(A + 1, A + L);\n    DFT(A, L);\n    Z Inv_L = Power(L, Mod - 2);\n    for (int i = 0; i != L; ++i)\n        A[i] *= Inv_L;\n}\n\nvoid Rec(Z A[], Z res[], int L)\n{\n    Z B[Max_size], dfta[Max_size], dftb[Max_size];\n    for (int i = 0; i != L; ++i)\n        B[i] = dfta[i] = dftb[i] = 0;\n    B[0] = Power(A[0], Mod - 2);\n    for (int d = 1; d != L; d <<= 1)\n    {\n        for (int i = 0; i != d << 1; ++i)\n            dfta[i] = A[i];\n        for (int i = 0; i != d; ++i)\n            dftb[i] = B[i];\n        DFT(dfta, d << 1), DFT(dftb, d << 1);\n        for (int i = 0; i != d << 1; ++i)\n            dfta[i] *= dftb[i];\n        IDFT(dfta, d << 1);\n        for (int i = 0; i != d; ++i)\n            dfta[i] = 0;\n        DFT(dfta, d << 1);\n        for (int i = 0; i != d << 1; ++i)\n            dfta[i] *= dftb[i];\n        IDFT(dfta, d << 1);\n        for (int i = d; i != d << 1; ++i)\n            B[i] = -dfta[i];\n    }\n    for (int i = 0; i != L; ++i)\n        res[i] = B[i];\n}\n\nvoid Quo(Z A[], Z C[], Z res[], int L)\n{\n    if (L == 1)\n    {\n        res[0] = C[0] * Power(A[0], Mod - 2);\n        return;\n    }\n    Z B[Max_size], dfta[Max_size], dftb[Max_size], dftc[Max_size];\n    for (int i = 0; i != L; ++i)\n        B[i] = dfta[i] = dftb[i] = dftc[i] = 0;\n    Rec(A, B, L >> 1);\n    for (int i = 0; i != L; ++i)\n        dfta[i] = A[i];\n    for (int i = 0; i != L >> 1; ++i)\n        dftb[i] = B[i];\n    DFT(dfta, L), DFT(dftb, L);\n    for (int i = 0; i != L; ++i)\n        dfta[i] *= dftb[i];\n    IDFT(dfta, L);\n    for (int i = 0; i != L >> 1; ++i)\n        dfta[i] = 0;\n    DFT(dfta, L);\n    for (int i = 0; i != L >> 1; ++i)\n        dftc[i] = C[i];\n    DFT(dftc, L);\n    for (int i = 0; i != L; ++i)\n        dfta[i] *= dftc[i];\n    IDFT(dfta, L);\n    for (int i = 0; i != L; ++i)\n        dftc[i] *= dftb[i];\n    IDFT(dftc, L);\n    for (int i = 0; i != L >> 1; ++i)\n        dfta[i] = 0;\n    for (int i = L >> 1; i != L; ++i)\n        dfta[i] = C[i] - dfta[i];\n    DFT(dfta, L);\n    for (int i = 0; i != L; ++i)\n        dfta[i] *= dftb[i];\n    IDFT(dfta, L);\n    for (int i = 0; i != L; ++i)\n        res[i] = dftc[i];\n    for (int i = L >> 1; i != L; ++i)\n        res[i] += dfta[i];\n}\n\nvoid Sqrt(Z A[], Z res[], int L)\n{\n    static Z B[Max_size], C[Max_size], dftb[Max_size], dftc[Max_size], tmp[Max_size];\n    for (int i = 0; i != L; ++i)\n        B[i] = C[i] = dftb[i] = dftc[i] = tmp[i] = 0;\n    B[0] = sqrt(A[0]), C[0] = Power(sqrt(A[0]), Mod - 2);\n    dftb[0] = B[0];\n    DFT(dftb, 1);\n    for (int d = 1; d != L; d <<= 1)\n    {\n        for (int i = 0; i != d; ++i)\n            dftb[i] *= dftb[i];\n        IDFT(dftb, d);\n        for (int i = 0; i != d; ++i)\n            dftb[d + i] = dftb[i] - A[i] - A[d + i], dftb[i] = 0;\n        DFT(dftb, d << 1);\n        for (int i = 0; i != d << 1; ++i)\n            dftc[i] = C[i];\n        DFT(dftc, d << 1);\n        \n        for (int i = 0; i != d << 1; ++i)\n            dftb[i] *= dftc[i];\n        IDFT(dftb, d << 1);\n        for (int i = d; i != d << 1; ++i)\n            B[i] = dftb[i] * 499122176;\n        \n        if ((d << 1) != L)\n        {\n            for (int i = 0; i != d << 1; ++i)\n                dftb[i] = B[i];\n            DFT(dftb, d << 1);\n            for (int i = 0; i != d << 1; ++i)\n                tmp[i] = dftb[i] * dftc[i];\n            IDFT(tmp, d << 1);\n            for (int i = 0; i != d; ++i)\n                tmp[i] = 0;\n            DFT(tmp, d << 1);\n            for (int i = 0; i != d << 1; ++i)\n                tmp[i] *= dftc[i];\n            IDFT(tmp, d << 1);\n            for (int i = d; i != d << 1; ++i)\n                C[i] = -tmp[i];\n        }\n    }\n    for (int i = 0; i != L; ++i)\n        res[i] = B[i];\n}\n\nvoid Der(Z A[], Z res[], int L)\n{\n    for (int i = 1; i != L; ++i)\n        res[i - 1] = A[i] * i;\n    res[L - 1] = 0;\n}\n\nvoid Int(Z A[], Z res[], int L)\n{\n    for (int i = L - 1; i; --i)\n        res[i] = A[i - 1] * Inv[i];\n    res[0] = 0;\n}\n\nvoid Log(Z A[], Z res[], int L)\n{\n    Z der[Max_size];\n    Der(A, der, L);\n    Quo(A, der, der, L);\n    Int(der, res, L);\n}\n\nvoid Exp(Z A[], Z res[], int L)\n{\n    Z der[Max_size];\n    Der(A, der, L);\n    Z B[Max_size], C[Max_size], dfta[Max_size], dftb[Max_size], dftb2[Max_size], dftc[Max_size];\n    for (int i = 0; i != L; ++i)\n        B[i] = C[i] = dfta[i] = dftb[i] = dftb2[i] = dftc[i] = 0;\n    B[0] = C[0] = 1;\n    dftb2[0] = B[0];\n    DFT(dftb2, 2);\n    for (int d = 1; d != L; d <<= 1)\n    {\n        for (int i = 0; i != d; ++i)\n            dftc[i] = C[i];\n        DFT(dftc, d << 1);\n        for (int i = 0; i != d; ++i)\n            dftb[i] = dftb2[i << 1] * dftc[i << 1];\n        IDFT(dftb, d);\n        dftb[0] -= 1;\n        for (int i = 0; i != d; ++i)\n            dftb[d + i] = dftb[i], dftb[i] = 0; // g_0h_0-1\n        DFT(dftb, d << 1); \n        for (int i = 0; i != d - 1; ++i)\n            dfta[i] = der[i];\n        dfta[d - 1] = 0;\n        DFT(dfta, d << 1);\n        for (int i = 0; i != d << 1; ++i)\n            dfta[i] *= dftb[i];\n        IDFT(dfta, d << 1); // (g_0h_0-1){f_0}'\n        \n        Der(B, dftb, d);\n        DFT(dftb, d);\n        for (int i = 0; i != d; ++i)\n            dftb[i] *= dftc[i << 1];\n        IDFT(dftb, d); // {g_0}'h_0\n        \n        for (int i = 0; i != d - 1; ++i)\n            dftb[d + i] = dftb[i] - der[i], dftb[i] = 0;\n        for (int i = d - 1; i != d << 1; ++i)\n            dftb[i] -= der[i] + dfta[i];\n        Int(dftb, dftb, d << 1);\n        DFT(dftb, d << 1);\n        for (int i = 0; i != d << 1; ++i)\n            dftb[i] *= dftb2[i];\n        IDFT(dftb, d << 1);\n        for (int i = d; i != d << 1; ++i)\n            B[i] = -dftb[i];\n        \n        if ((d << 1) != L)\n        {\n            for (int i = 0; i != d << 1; ++i)\n                dftb2[i] = B[i];\n            DFT(dftb2, d << 2);\n            for (int i = 0; i != d << 1; ++i)\n                dftb[i] = dftb2[i << 1];\n            for (int i = 0; i != d << 1; ++i)\n                dftb[i] *= dftc[i];\n            IDFT(dftb, d << 1);\n            for (int i = 0; i != d; ++i)\n                dftb[i] = 0;\n            DFT(dftb, d << 1);\n            for (int i = 0; i != d << 1; ++i)\n                dftb[i] *= dftc[i];\n            IDFT(dftb, d << 1);\n            for (int i = d; i != d << 1; ++i)\n                C[i] = -dftb[i];\n        }\n    }\n    for (int i = 0; i != L; ++i)\n        res[i] = B[i];\n}\n\nvoid Rec_Sqrt(Z A[], Z res[], int L)\n{\n    Z B[Max_size], dfta[Max_size], dftb[Max_size];\n    for (int i = 0; i != L; ++i)\n        B[i] = dfta[i] = dftb[i] = 0;\n    B[0] = Power(sqrt(A[0]), Mod - 2);\n    for (int d = 1; d != L; d <<= 1)\n    {\n        for (int i = 0; i != d << 1; ++i)\n            dfta[i] = A[i];\n        for (int i = 0; i != d; ++i)\n            dftb[i] = B[i];\n        for (int i = d; i != d << 1; ++i)\n            dftb[i] = 0;\n        DFT(dfta, d << 2), DFT(dftb, d << 2);\n        for (int i = 0; i != d << 2; ++i)\n            dfta[i] *= dftb[i] * dftb[i] * dftb[i];\n        IDFT(dfta, d << 2);\n        for (int i = d; i != d << 1; ++i)\n            B[i] = -dfta[i] * 499122177;\n    }\n    for (int i = 0; i != L; ++i)\n        res[i] = B[i];\n}\n\nint N, L;\nZ A[Max_size], tmp[Max_size];\n\n/*int main(int argc, char **argv)\n{\n    IO >> N;\n    for (int i = 0; i != N; ++i)\n        IO >> A[i].v;\n    \n    for (L = 1; L < N; L <<= 1)\n        ;\n    init(L);\n    \n    Exp(A, A, L);\n    \n    for (int i = 0; i != N; ++i)\n        IO << A[i].v << ' ';\n    \n    return 0;\n\t}*/\n\nint qpow(int a,int b) {\n\tint ret=1;\n\twhile(b) {\n\t\tif(b&1) ret=1ll*ret*a%mod;\n\t\ta=1ll*a*a%mod,b>>=1;\n\t}\n\treturn ret;\n}\n\nint fac[500010];\n\nint main() {\n\tint n,m;cin>>n>>m;\n\tfac[0]=1;for(int i=1;i<=m;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tfor(int i=0;i<=m;i++) A[i].v=1ll*(m+1-i)*qpow(fac[i],mod-2)%mod*qpow(m+1,mod-2)%mod;\n\tint L=524288;\n\tinit(L);\n\tLog(A,A,L);\n\tfor(int i=0;i<L;i++) A[i].v=1ll*A[i].v*n%mod;\n\tExp(A,A,L);\n\tint ans=0;\n\tfor(int i=0;i<=m;i++) ans=(ans+1ll*A[i].v*qpow(fac[m-i],mod-2)%mod*qpow(m+1,n))%mod;\n\tcout<<1ll*ans*fac[m]%mod;\n\t/*int n=gi(),m=gi();\n\tfac[0]=1;for(int i=1;i<=m;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tvector<int> G(m+1);\n\tfor(int i=0;i<=m;i++) G[i]=1ll*(m+1-i)*qpow(fac[i],mod-2)%mod;\n\tvector<int> F=pqpow(G,n,get2(m+1));\n\tint ans=0;\n\tfor(int i=0;i<=m;i++) ans=(ans+1ll*F[i]*qpow(fac[m-i],mod-2))%mod;\n\tans=1ll*ans*fac[m]%mod;\n\tcout<<ans;*/\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//problem:agc035_f\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=5e5+5,MOD=998244353;\ninline int mod1(int x){return x<MOD?x:x-MOD;}\ninline int mod2(int x){return x<0?x+MOD:x;}\nint n,m,fac[MAXN],invf[MAXN];\ninline int pow_mod(int x,int i){int y=1;while(i){if(i&1)y=(ll)y*x%MOD;x=(ll)x*x%MOD;i>>=1;}return y;}\ninline int comb(int n,int k){return n<k?0:(ll)fac[n]*invf[k]%MOD*invf[n-k]%MOD;}\nint main() {\n\tn=read(),m=read();if(n>m)swap(n,m);\n\tfac[0]=1;for(int i=1;i<=m;++i)fac[i]=(ll)fac[i-1]*i%MOD;\n\tinvf[m]=pow_mod(fac[m],MOD-2);\n\tfor(int i=m-1;i>=0;--i)invf[i]=(ll)invf[i+1]*(i+1)%MOD;assert(invf[0]==1);\n\tint ans=0;\n\tfor(int i=0;i<=n;++i){\n\t\tint tmp=(ll)comb(n,i)*comb(m,i)%MOD*pow_mod(n+1,m-i)%MOD*pow_mod(m+1,n-i)%MOD*fac[i]%MOD;\n\t\tif(i&1)ans=mod2(ans-tmp);\n\t\telse ans=mod1(ans+tmp);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 998244353\n#define LL long long\n#define N 500011\nLL n,m,fac[N],inv[N],ans;\nLL q_pow(LL a,LL b){\n\tLL res=1;\n\twhile(b){\n\t\tif(b&1ll) res=res*a%MOD;\n\t\tb>>=1ll;\n\t\ta=a*a%MOD;\n\t}\n\treturn res;\n}\nLL C(LL x,LL y){\n\tif(x<y) return 0;\n\tif(!y) return 1;\n\treturn fac[x]*inv[y]%MOD*inv[x-y]%MOD;\n}\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tinv[0]=fac[0]=inv[1]=fac[1]=1;\n\tfor(int i=1;i<=500000;i++) fac[i]=fac[i-1]*i%MOD;\n\tinv[500000]=q_pow(fac[500000],MOD-2);\n\tfor(int i=499999;i>=2;i--) inv[i]=inv[i+1]*(i+1)%MOD;\n\tint typ=1;\n\tint nn=min(n,m);\n\tfor(int i=0;i<=nn;i++){\n\t\tans=(ans+typ*C(n,i)*C(m,i)%MOD*q_pow(m+1,n-i)%MOD*q_pow(n+1,m-i)%MOD*fac[i]%MOD)%MOD;\n\t\tif(ans<0) ans+=MOD;\n\t\ttyp=typ*-1;\n\t}\n\tprintf(\"%lld\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n//#define int long long\nusing namespace std;\nconst int maxn=5e5+1000;\ntypedef long long ll;\nint n,m;\nconst int mod=998244353;\nint fr[maxn],ans;\ninline int ksm(int num,int t){\n\tint res=1;\n\tfor(;t;t>>=1,num=1ll*num*num%mod){\n\t\tif(t&1)res=1ll*res*num%mod;\n\t}\n\treturn res;\n}\ninline int c(int m,int n){\n\treturn 1ll*fr[n]*ksm((1ll*fr[m]*fr[n-m])%mod,mod-2)%mod;\t\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfr[0]=fr[1]=1;\n\tfor(int i=2;i<maxn;i++)fr[i]=1ll*fr[i-1]*i%mod;\t\n\tfor(int i=0;i<=min(n,m);i++){\n\t\tans=(ans+1ll*ksm(-1,i)*(1ll*c(i,n)*c(i,m)%mod*fr[i]%mod*ksm(m+1,n-i)%mod*ksm(n+1,m-i)%mod)%mod)%mod;\t\n\t}\n\tans=(ans%mod+mod)%mod;\n\tcout<<ans;\n\treturn 0;\n}////"
  },
  {
    "language": "C++",
    "code": "Problem F and F2 are the same problem, but with different constraints and time limits.\n\nWe have a board divided into \nN\nN horizontal rows and \nN\nN vertical columns of square cells. The cell at the \ni\ni-th row from the top and the \nj\nj-th column from the left is called Cell \n(\ni\n,\nj\n)\n(i,j). Each cell is either empty or occupied by an obstacle. Also, each empty cell has a digit written on it. If \nA\ni\n,\nj\n=\nAi,j= 1, 2, ..., or 9, Cell \n(\ni\n,\nj\n)\n(i,j) is empty and the digit \nA\ni\n,\nj\nAi,j is written on it. If \nA\ni\n,\nj\n=\nAi,j= #, Cell \n(\ni\n,\nj\n)\n(i,j) is occupied by an obstacle.\n\nCell \nY\nY is reachable from cell \nX\nX when the following conditions are all met:\n\nCells \nX\nX and \nY\nY are different.\nCells \nX\nX and \nY\nY are both empty.\nOne can reach from Cell \nX\nX to Cell \nY\nY by repeatedly moving right or down to an adjacent empty cell.\nConsider all pairs of cells \n(\nX\n,\nY\n)\n(X,Y) such that cell \nY\nY is reachable from cell \nX\nX. Find the sum of the products of the digits written on cell \nX\nX and cell \nY\nY for all of those pairs."
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define int long long\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') bo = -1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tres = (res << 1) + (res << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn bo * res;\n}\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = read();\n}\n\ntemplate <typename T, typename... Argv>\nvoid read(T &a, Argv &... argv) {\n\tread(a);\n\tread(argv...);\n}\n\nconst int N = 1e6 + 100, p = 998244353;\nint fac[N], inv[N], _n[N], _m[N];\n\nLL mul(LL x, LL y) {\n\treturn 1LL * x * y % p;\n}\n\nint ksm(int x, int y) {\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nvoid init(int n, int m) {\n\tint M = std::max(n, m);\n\tfac[0] = _n[0] = _m[0] = 1;\n\tfor (int i = 1; i <= M; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[n] = ksm(fac[n], p - 2);\n\tfor (int i = n; i >= 1; --i) inv[i - 1] = mul(inv[i], i);\n\tfor (int i = 1; i <= M; ++i) _n[i] = mul(_n[i - 1], n + 1);\n\tfor (int i = 1; i <= M; ++i) _m[i] = mul(_m[i - 1], m + 1);\n}\n\nint C(int n, int m) {\n\treturn mul(fac[n], mul(inv[m], inv[n - m]));\n}\n\nsigned main() {\n\tint n = read(), m = read(), ans = 0;\n\tinit(n, m);\n\tfor (int i = 0; i <= std::min(n, m); ++i) {\n\t\tLL res = 1LL * C(n, i) % p * C(m, i) % p * fac[i] % p * _m[n - i] % p * _n[m - i] % p;\n\t\tif (i & 1) ans = (ans - res + p) % p;\n\t\telse ans = (ans + res) % p;\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n#define ll long long\n#define mod 998244353\nll n,m,k,f[500005],inv[500005],ra[500005],le[500005],ans;\nll ksm(ll x,ll y){\n\tll anss=1,t=x;\n\twhile(y){\n\t\tif(y&1) anss=anss*t%mod;\n\t\tt=t*t%mod;\n\t\ty>>=1;\n\t}\n\treturn anss;\n}\nll jug(ll x){\n\treturn (x&1)?mod-1:1;\n}\nll C(ll n,ll m){\n\treturn f[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tk=max(n,m);\n\tf[0]=1;\n\tfor(ll i=1;i<=k;i++) f[i]=f[i-1]*i%mod;\n\tinv[k]=ksm(f[k],mod-2);\n\tfor(ll i=k-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\tra[0]=1;\n\tfor(ll i=1;i<=k;i++) ra[i]=ra[i-1]*(n+1)%mod;\n\tle[0]=1;\n\tfor(ll i=1;i<=k;i++) le[i]=le[i-1]*(m+1)%mod;\n\tfor(ll i=0;i<=min(n,m);i++){\n//\t\tcout<<jug(i)<<' '<<C(n,i)<<' '<<C(m,i)<<' '<<ra[m-i]<<' '<<le[n-i]<<endl;\n\t\tans=(ans+jug(i)*C(n,i)%mod*C(m,i)%mod*ra[m-i]%mod*le[n-i]%mod*f[i])%mod;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MOD=998244353,MAX_N=1<<20|5;\ninline void mo(int& x){ x>=MOD?x-=MOD:0; }\ninline int mo1(int x){ return x>=MOD?x-MOD:x; }\ninline int mo2(int x){ return x<0?x+MOD:x; }\ninline int fpow(int x,int n,int ret=1){\n\tfor(;n;n>>=1,x=1ll*x*x%MOD)\n\t\tn&1?ret=1ll*ret*x%MOD:0;\n\treturn ret;\n}\nint fac[MAX_N],inv[MAX_N],fac_inv[MAX_N];\nvoid init(int n){\n\tfac[0]=fac_inv[0]=inv[1]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfac[i]=1ll*fac[i-1]*i%MOD;\n\t\tif(i>1) inv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD;\n\t\tfac_inv[i]=1ll*fac_inv[i-1]*inv[i]%MOD;\n\t}\n}\nvoid get_k_pow(int a[],int b[],int n,int k){\n\tb[0]=fpow(a[0],k);\n\tint inv_0=fpow(a[0],MOD-2);\n\tfor(int i=0;i<n;++i)\n\t\tb[i+1]=mo2(1ll*a[1]*b[i]%MOD*(k+MOD-i)%MOD\n\t\t\t*inv[i+1]%MOD*inv_0%MOD);\n}\nint a[MAX_N],b[MAX_N];\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tinit(n+1);\n\ta[0]=n+1; a[1]=MOD-1;\n\tget_k_pow(a,b,n,m);\n//\tfor(int i=0;i<=n;++i) printf(\"[%d]\",b[i]); puts(\"\");\n\tfor(int i=0,pw=1;i<=n;++i,pw=1ll*pw*(m+1)%MOD) \n\t\ta[i]=1ll*pw*fac_inv[i]%MOD;\n\tint ret=0;\n\tfor(int i=0;i<=n;++i)\n\t\tret=(ret+1ll*a[i]*b[n-i])%MOD;\n\tret=1ll*ret*fac[n]%MOD;\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<998244353>;\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N, M; cin >> N >> M;\n\tnum val = pow(num(M+1), N) * pow(num(N+1), M);\n\tnum ans = val;\n\tfor (int i = 1; i <= min(N, M); i++) {\n\t\tval *= N - i + 1;\n\t\tval *= M - i + 1;\n\t\tval /= i;\n\t\tval /= M+1;\n\t\tval /= N+1;\n\t\tval *= -1;\n\t\tans += val;\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define scanf _D_F_GEW__\n#define puts _D_GS_G_DSGS_D\n#define printf _D_GEW_G_DSG__\n#ifndef ONLINE_JUDGE\n#define cin fin\n#define cout fout\n#define FILE_NAME \"\"\nifstream fin(FILE_NAME \".in\");\nofstream fout(FILE_NAME \".out\");\n#endif\nconst int N=500100,mod=998244353;\ntypedef long long ll;\nint ksm(ll a,int b,int c=1){\n\tfor(;b;b/=2,a=a*a%mod)\n\t\tif(b&1)c=c*a%mod;\n\treturn c;\n}\nint pn[N],pm[N],jc[N],jc2[N],n,m,ans;\nvoid init(){\n\tjc[0]=1;\n\tfor(int i=1;i<N;++i)jc[i]=(ll)jc[i-1]*i%mod;\n\tjc2[N-1]=ksm(jc[N-1],mod-2);\n\tfor(int i=N-1;i;--i)jc2[i-1]=(ll)jc2[i]*i%mod;\n\tpm[0]=pn[0]=1;\n\tfor(int i=1;i<N;++i)pm[i]=(ll)pm[i-1]*(m+1)%mod,pn[i]=(ll)pn[i-1]*(n+1)%mod;\n}\nint C(int n,int k){\n\tif(n<k||k<0)return 0;\n\treturn (ll)jc[n]*jc2[k]%mod*jc2[n-k]%mod;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>m;init();\n\tfor(int i=0;i<=n;++i){\n\t\tint tmp=(ll)C(n,i)*C(m,i)%mod*jc[i]%mod*pm[n-i]%mod*pn[m-i]%mod;\n\t\tif(i&1)ans=(ans-tmp+mod)%mod;\n\t\telse ans=(ans+tmp)%mod;\n\t}\n\tcout<<ans<<endl;\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=1010000;\nll fac[N],fnv[N];\nint n,m;\n\nint main() {\n\tfac[0]=fnv[0]=1;\n\tfor (int i=1;i<=1000000;i++) {\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tfnv[i]=fnv[i-1]*powmod(i,mod-2)%mod;\n\t}\n\tscanf(\"%d%d\",&n,&m);\n\tif (n>m) swap(n,m);\n\tll ans=0;\n\tfor (int i=0;i<=n;i++) {\n\t\tans=(ans+powmod(mod-1,i)*powmod(n+1,m-i)%mod*powmod(m+1,n-i)%mod*\n\t\t\tfac[m]%mod*fnv[m-i]%mod*fac[n]%mod*fnv[n-i]%mod*fnv[i])%mod;\n//\t\tprintf(\"%d %lld\\n\",i,powmod(mod-1,i)*powmod(n+1,m-i)%mod*powmod(m+1,n-i)%mod*\n//\t\t\tfac[m]%mod*fnv[m-i]%mod*fac[n]%mod*fnv[n-i]%mod*fnv[i]%mod);\n\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\ntypedef long long ll;\nconst int N=500005,P=998244353;\n\nint fexp(int a,int b)\n{\n\tll x=1,o=a;\n\tfor(;b;b>>=1,o=o*o%P)\n\t\tif(b&1)x=x*o%P;\n\treturn x;\n}\n\nint n,m,ans,fac[N],ifac[N];\n\nint C(int n,int m){return 1ll*fac[n]*ifac[n-m]%P*ifac[m]%P;}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tif(n<m){\n\t\tint t=n;\n\t\tn=m;\n\t\tm=t;\n\t}\n\tfac[0]=1;\n\tfor(int i=1; i<=n; i++)fac[i]=1ll*fac[i-1]*i%P;\n\tifac[n]=fexp(fac[n],P-2);\n\tfor(int i=n-1; ~i; i--)ifac[i]=1ll*ifac[i+1]*(i+1)%P;\n\tfor(int k=0; k<=m; k++){\n\t\tint f=1ll*C(n,k)*C(m,k)%P*fac[k]%P*fexp(m+1,n-k)%P*fexp(n+1,m-k)%P;\n\t\tif(k&1)ans=(ans+P-f)%P;else ans=(ans+f)%P;\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 998244353;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    template <class I>\n    inline modint &operator ^= (I b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    template <class I>\n    inline friend modint operator ^ (modint a, I b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\nconst int NP = 1e6 + 7;\nmodint p[NP], v[NP], vp[NP];\ninline void init(int n) {\n  p[0] = v[0] = 1;\n  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n  vp[n] = 1 / p[n];\n  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n}\ninline modint binom(int n, int m) {\n  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n}\n\nint main() {\n\tint n, m;\n\trd(n, m), init(max(n, m) + 1);\n\tmodint a = (modint)(m + 1) ^ n, b = (modint)(n + 1) ^ m, w = 1, ans;\n\tfor (int i = 0; i <= min(n, m); i++, a *= v[m+1], b *= v[n+1], w = -w)\n\t\tans += w * binom(n, i) * binom(m, i) * p[i] * a * b; \n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 998244353\n#define rep(i,j,k) for(int i=(j),LIM=(k);i<=LIM;i++)\n#define per(i,j,k) for(int i=(j),LIM=(k);i>=LIM;i--)\n#define LL long long\nusing namespace std;\n\nint n,m;\nint Pow(int b,LL k){ int r=1;for(;k;k>>=1,b=1ll*b*b%mod) if(k&1) r=1ll*r*b%mod;return r; }\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint Cn=1,Cm=1,ans=0,fc=1;\n\trep(i,0,min(n,m)){\n\t\tans = (ans + 1ll * Cn * Cm % mod * (i&1 ? -1ll : 1ll) * fc % mod * Pow(m+1,n-i) % mod * Pow(n+1,m-i)) % mod;\n\t\tCn = 1ll * Cn * (n-i) % mod * Pow(i+1 , mod-2) % mod;\n\t\tCm = 1ll * Cm * (m-i) % mod * Pow(i+1 , mod-2) % mod;\t\n\t\tfc = 1ll * fc * (i+1) % mod;\n\t}\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define mxn 500010\n#define LL long long\n#define mod 998244353\nusing namespace std;\nLL fac[mxn],ifc[mxn];\nint n,m,sl,fh,ans;\nint rd()\n{\n\tsl=0;fh=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=getchar();}\n\twhile('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=getchar();\n\treturn sl*fh;\n}\nLL C(int x,int y) {return fac[x]*ifc[y]%mod*ifc[x-y]%mod;}\nLL _pow(LL k,int i)\n{\n\tstatic LL t;t=1;\n\tfor(;i;i>>=1,k=k*k%mod)\n\t\tif(i&1)\n\t\t\tt=t*k%mod;\n\treturn t;\n}\nint main()\n{\n\tn=rd();m=rd();if(n>m) swap(n,m);fac[0]=1;\n\tfor(int i=1;i<=m;++i) fac[i]=i*fac[i-1]%mod;\n\tifc[m]=_pow(fac[m],mod-2);\n\tfor(int i=m;i;--i) ifc[i-1]=i*ifc[i]%mod;\n\tfor(int i=0,c=1;i<=n;++i,c=mod-c) ans=(ans+c*C(n,i)%mod*C(m,i)%mod*fac[i]%mod*_pow(m+1,n-i)%mod*_pow(n+1,m-i))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 7/15/2019, 5:16:41 AM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\nusing ll = long long;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a) { return (*this *= power(MOD - 2)); }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 998244353;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nclass combination\n{\npublic:\n  vector<mint> inv, fact, factinv;\n  static int MAX_SIZE;\n  combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1; i < MAX_SIZE; i++)\n    {\n      fact[i] = mint(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  mint operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n};\nint combination::MAX_SIZE = 1e6 + 10;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nll N, M;\n\nint main()\n{\n  cin >> N >> M;\n  combination C{};\n  if (N > M)\n  {\n    swap(N, M);\n  }\n  mint ans = 0;\n  mint n{N}, m{M};\n  for (auto i = 0; i <= N; i++)\n  {\n    mint sum = (n + 1).power(M - i) * (m + 1).power(N - i) * C(M, i) * C(N, i) * C.fact[i];\n    if (i % 2 == 0)\n    {\n      ans += sum;\n    }\n    else\n    {\n      ans -= sum;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=500005;\nconst int mod=998244353;\nint fact[maxn],inv[maxn],n,m;\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)res=1LL*res*x%mod;\n\t\tx=1LL*x*x%mod;\n\t\ty>>=1;\n    }\n    return res;\n}\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=mod)x-=mod;\n}\ninline int C(int x,int y)\n{\n\tif(x<y)return 0;\n\treturn 1LL*fact[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfact[0]=1;\n\tfor(int i=1;i<=500001;++i)fact[i]=1LL*fact[i-1]*i%mod;\n\tinv[500001]=qpow(fact[500001],mod-2);\n\tfor(int i=500000;i>=0;--i)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tint ans=0;int nowm=qpow(m+1,n),nown=qpow(n+1,m),invm=qpow(m+1,mod-2),invn=qpow(n+1,mod-2);\n\tfor(int i=0;i<=min(n,m);++i)\n\t{\n\t\tadd(ans,1LL*(i&1?mod-1:1)*C(n,i)%mod*C(m,i)%mod*fact[i]%mod*nowm%mod*nown%mod);\n\t\tnowm=1LL*nowm*invm%mod;nown=1LL*nown*invn%mod;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') bo = -1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tres = (res << 1) + (res << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn bo * res;\n}\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = read();\n}\n\ntemplate <typename T, typename... Argv>\nvoid read(T &a, Argv &... argv) {\n\tread(a);\n\tread(argv...);\n}\n\nconst int N = 1e6 + 100, p = 998244353;\nint fac[N], inv[N], _n[N], _m[N];\n\ntemplate <typename T>\nT mul(T x, T y) {\n\treturn 1LL * x * y % p;\n}\n\ntemplate <typename T, typename... Argv>\nT mul(T x, Argv... argv) {\n\treturn mul(x, mul(argv...));\n}\n\nint ksm(int x, int y) {\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nvoid init(int n, int m) {\n\tint M = std::max(n, m);\n\tfac[0] = _n[0] = _m[0] = 1;\n\tfor (int i = 1; i <= M; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[M] = ksm(fac[M], p - 2);\n\tfor (int i = M; i >= 1; --i) inv[i - 1] = mul(inv[i], i);\n\tfor (int i = 1; i <= M; ++i) _n[i] = mul(_n[i - 1], n + 1);\n\tfor (int i = 1; i <= M; ++i) _m[i] = mul(_m[i - 1], m + 1);\n}\n\nint C(int n, int m) {\n\treturn m > n || m < 0 ? 0 : mul(fac[n], inv[m], inv[n - m]);\n}\n\nint main() {\n\tint n = read(), m = read(), ans = 0;\n\tinit(n, m);\n\tfor (int i = 0, opt = 1; i <= n; ++i, opt = p - opt) {\n\t\t(ans += mul(opt, C(n, i), C(m, i), fac[i], _m[n - i], _n[m - i])) %= p;\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (2)\n#pragma G++ optimize (2)\n#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define mod 998244353\n#define MAX 500005\nusing namespace std;\n//char nc()\n//{\n//\tstatic char buf[100000],*p1=buf,*p2=buf;\n//\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\nchar nc(){return getchar();}\nint read()\n{\n\tint x=0,y=1;\n\tchar c=nc();\n\twhile(!isdigit(c))\n\t{\n\t\tif(c=='-')y=-1;\n\t\tc=nc();\n\t}\n\twhile(isdigit(c))\n\t{\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\t\tc=nc();\n\t}\n\treturn x*y;\n}\nint n,m;\nlong long fac[MAX],facinv[MAX],pwn1[MAX],pwm1[MAX];\nlong long mo(long long x)\n{\n\treturn x<mod?x:x-mod;\n}\nlong long quick_pow(long long x,long long y)\n{\n\tlong long re=1;\n\twhile(y)\n\t{\n\t\tif(y&1) re=re*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn re;\n}\nlong long C(long long down,long long up)\n{\n\treturn fac[down]*facinv[down-up]%mod*facinv[up]%mod;\n}\nint main()\n{\n\tn=read();m=read();\n\tint up=max(n,m);\n\tfac[0]=1;\n\tfor(int i=1;i<=up;i++)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tfacinv[up]=quick_pow(fac[up],mod-2);\n\tfor(int i=up;i;i--)\n\t\tfacinv[i-1]=facinv[i]*i%mod;\n\tpwn1[0]=1;\n\tfor(int i=1;i<=m;i++)\n\t\tpwn1[i]=pwn1[i-1]*(n+1)%mod;\n\tpwm1[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tpwm1[i]=pwm1[i-1]*(m+1)%mod;\n\tlong long ANS=0;\n\tfor(int i=0;i<=min(n,m);i++)\n\t\tif(!(i&1)) ANS=(ANS+C(n,i)*C(m,i)%mod*fac[i]%mod*pwm1[n-i]%mod*pwn1[m-i])%mod;\n\t\telse ANS=mo(ANS-C(n,i)*C(m,i)%mod*fac[i]%mod*pwm1[n-i]%mod*pwn1[m-i]%mod+mod);\n\tprintf(\"%lld\",ANS);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxs=6e5,mod=998244353;\nint n,m,s;\nlong long Ans,fac[maxs],inv[maxs],pown[maxs],powm[maxs];\ninline long long read(){\n\tlong long x=0,f=1;\n\tchar c;\n\tdo{c=getchar();if(c=='-') f*=-1;}while(!isdigit(c));\n\twhile(isdigit(c)){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n\treturn x*f;\n}\nlong long qpow(long long x,int i){\n\tlong long res=1;\n\twhile(i){\n\t\tif(i&1) res=res*x%mod;\n\t\tx=x*x%mod;i>>=1;\n\t}\n\treturn res;\n}\nlong long C(int a,int b){return inv[b]*inv[a-b]%mod*fac[a]%mod;}\nlong long F(int k){return C(n,k)*C(m,k)%mod*fac[k]%mod*(pown[m-k]*powm[n-k]%mod)%mod;}\nint main(){\n\tn=read();m=read();Ans=0;\n\ts=max(n,m);\n\tfac[0]=1;\n\tfor(int i=1;i<=s;i++){fac[i]=fac[i-1]*i%mod;}\n\tinv[s]=qpow(fac[s],mod-2);\n\tfor(int i=s;i>=1;i--){inv[i-1]=inv[i]*i%mod;}\n\tpown[0]=powm[0]=1;\n\tfor(int i=1;i<=s;i++){\n\t\tpown[i]=pown[i-1]*(n+1)%mod;\n\t\tpowm[i]=powm[i-1]*(m+1)%mod;\n\t}\n\tfor(int i=0;i<=min(n,m);i++){Ans=(Ans+mod+(i%2==0?1:-1)*(F(i)))%mod;}\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    if(N < M) swap(N, M);\n    Combination C(N + M);\n    \n    mint ans = 0;\n    REP(i, M + 1){\n        mint c1 = C.nCr(M, i) * C.nPr(N, i);\n        mint c2 = pow((mint)N + 1, M - i) * pow((mint)M + 1, N - i);\n        if(i % 2 == 0) ans += c1 * c2;\n        else ans -= c1 * c2;\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXDIM=500000;\nconst int MOD=998244353;\nvoid inc(int &a,int b) { if((a+=b)>=MOD) a-=MOD; }\nvoid dec(int &a,int b) { inc(a,MOD-b); }\n\n\n\n\nint h,w;\n\n\nint inv[MAXDIM+1];\nint fac[MAXDIM+1];\nint ifac[MAXDIM+1];\n\nint freerowways[MAXDIM+1];\nint freecolways[MAXDIM+1];\n\nint choose(int n,int k) { assert(0<=n&&n<=max(h,w)); if(k<0||k>n) return 0; return (ll)fac[n]*ifac[k]%MOD*ifac[n-k]%MOD; }\n\n\n\n\nint solve() {\n\tinv[1]=1; FORE(i,2,MAXDIM) inv[i]=(ll)(MOD-MOD/i)*inv[MOD%i]%MOD;\n\tfac[0]=1; FORE(i,1,MAXDIM) fac[i]=(ll)fac[i-1]*i%MOD;\n\tifac[0]=1; FORE(i,1,MAXDIM) ifac[i]=(ll)ifac[i-1]*inv[i]%MOD;\n\n\tfreerowways[0]=1; FORE(i,1,h) freerowways[i]=(ll)freerowways[i-1]*(w+1)%MOD;\n\tfreecolways[0]=1; FORE(i,1,w) freecolways[i]=(ll)freecolways[i-1]*(h+1)%MOD;\n\n\tint ret=0;\n\tREPE(nfixed,min(h,w)) {\n\t\tint ways=(ll)choose(w,nfixed)*choose(h,nfixed)%MOD*freerowways[h-nfixed]%MOD*freecolways[w-nfixed]%MOD*fac[nfixed]%MOD;\n\t\tif(nfixed%2==0) inc(ret,ways); else dec(ret,ways);\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d\",&h,&w);\n\tprintf(\"%d\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct ModInt{\n\tuint32_t a;\n    ModInt(int64_t x=0):a((x%mod+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n        if(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=(uint64_t)a*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-(){return ModInt()-*this;}\n\tModInt pow(uint64_t ex)const{\n\t\tuint64_t x=a;\n\t\tuint64_t res=1;\n\t\twhile(ex){\n\t\t\tif(ex&1)res=res*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tex>>=1;\n\t\t}\n\t\treturn ModInt(res);\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair<int, int>\n#define iiii pair<int, pii>\n#define mp make_pair\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i, x) for(int (i) = 0; (i) < (x); (i)++)\ninline int getint() {\n\tint x = 0, p = 1; char c = getchar();\n\twhile (c <= 32) c = getchar();\n\tif (c == 45) p = -p, c = getchar();\n\twhile (c > 32) x = x * 10 + c - 48, c = getchar();\n\treturn x * p;\n}\nusing namespace std;\n//ruogu_alter\nconst int N = 5e5 + 5;\nconst int mod = 998244353;\nint n, m, fac[N], inv[N];\n//\ninline void add(int &x, int y) {\n  x += y; if (x >= mod) x -= mod;\n}\ninline void sub(int &x, int y) {\n  x -= y; if (x < 0) x += mod;\n}\ninline int mul(int x, int y) {\n  ll ans = 1ll * x * y;\n  return ans % mod;\n}\ninline int modpow(int x, int y) {\n  int ans = 1;\n  while (y) {\n    if (y & 1) ans = mul(ans, x);\n    x = mul(x, x);\n    y >>= 1;\n  }\n  return ans;\n}\ninline int modinv(int x) {\n  return modpow(x, mod - 2);\n}\nint c(int x, int y) {\n  if (y < 0 || x < y) return 0;\n  return mul(fac[x], mul(inv[y], inv[x - y]));\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tn = getint(); m = getint();\n  fac[0] = 1; for (int i = 1; i < N; i++) fac[i] = mul(fac[i - 1], i);\n  inv[N - 1] = modinv(fac[N - 1]);\n  for (int i = N - 2; i >= 0; i--) inv[i] = mul(inv[i + 1], i + 1);\n  int res = 0;\n  rep(i, min(n, m) + 1) {\n    int tmp = mul(mul(c(n, i), c(m, i)), fac[i]);\n    tmp = mul(tmp, modpow(m + 1, n - i));\n    tmp = mul(tmp, modpow(n + 1, m - i));\n    if (i & 1) sub(res, tmp);\n    else add(res, tmp);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define per(i, a, b) for (int i = a; i >= b; i--)\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\ntypedef long long ll;\n\ntemplate <typename _T>\ninline void read(_T &f) {\n\tf = 0; _T fu = 1; char c = getchar();\n\twhile (c < '0' || c > '9') { if (c == '-') { fu = -1; } c = getchar(); }\n\twhile (c >= '0' && c <= '9') { f = (f << 3) + (f << 1) + (c & 15); c = getchar(); }\n\tf *= fu;\n}\n\ntemplate <typename T>\nvoid print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x < 10) putchar(x + 48);\n\telse print(x / 10), putchar(x % 10 + 48);\n}\n\ntemplate <typename T>\nvoid print(T x, char t) {\n\tprint(x); putchar(t);\n}\n\nconst int N = 5e5 + 5, md = 998244353;\n\ninline int add(int x, int y) {\n\tx += y;\n\tif (x >= md) x -= md;\n\treturn x;\n}\n\ninline int sub(int x, int y) {\n\tx -= y;\n\tif (x < 0) x += md;\n\treturn x;\n}\n\ninline int mul(int x, int y) { return 1ll * x * y % md; }\n\ninline int fpow(int x, int y) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = mul(ans, x);\n\t\ty >>= 1; x = mul(x, x);\n\t}\n\treturn ans;\n}\n\nint fac[N], inv[N];\nint n, m, ans;\n\ninline int C(int n, int m) {\n\tif (n < 0 || m < 0 || n < m) return 0;\n\treturn mul(fac[n], mul(inv[m], inv[n - m]));\n}\n\nint main() {\n\tread(n); read(m);\n\tif (n < m) swap(n, m);\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++) fac[i] = mul(fac[i - 1], i);\n\tinv[n] = fpow(fac[n], md - 2);\n\tfor (int i = n; i >= 1; i--) inv[i - 1] = mul(inv[i], i);\n\tint pw1 = fpow(m + 1, n), pw2 = fpow(n + 1, m), inv1 = fpow(m + 1, md - 2), inv2 = fpow(n + 1, md - 2);\n\tfor (int i = 0; i <= m; i++, pw1 = mul(pw1, inv1), pw2 = mul(pw2, inv2)) {\n\t\tint v = mul(mul(C(n, i), C(m, i)), mul(mul(pw1, pw2), fac[i]));\n\t\tif (i & 1) ans = sub(ans, v);\n\t\telse ans = add(ans, v);\n\t}\n\tprint(ans, '\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<long long>;\nusing ld = long double;\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nconst int mod = 998244353;\nconst int p = mod;\nconst int gen = 5;\n\nint powMod(int a, int n) {\n  int res = 1;\n  while (n) {\n    if (n & 1) { res = ((LL)res * a) % p; }\n    n >>= 1; a = ((LL)a * a) % p;\n  }\n  return res;\n}\n\n\nstruct FFT {\nprivate:\n  int *A, *B, *tmp, *res, *omega;\n  int *perm;\n  int maxh;\n  // not needed if this is going to be used just once\n  void Clear(int n) {\n    REP (i, n) { A[i] = B[i] = res[i] = tmp[i] = 0; }\n  }\n  \n  void fft(int* from, int* to, int depth, bool inv){\n    int N = (1 << depth);\n    for (int i = 0; i < N; i++) { to[perm[i] >> (maxh - depth)] = from[i]; }\n    RE (m, depth) {\n      int step = 1 << m;\n      for (int pos = 0; pos < N; pos += step){\n        int cur = 0;\n        int delta = 1 << (maxh - m);\n        if (!inv) { cur = 1 << maxh; delta *= -1; }\n        int *lft = to + pos, *rgt = lft + step / 2;\n        REP (k, step / 2) {\n          int a = *lft, b = (ll)omega[cur] * *rgt % mod;\n          *lft = a + b; if (*lft >= mod) { *lft -= mod; } ++lft;\n          *rgt = a - b; if (*rgt < 0) { *rgt += mod; } ++rgt;\n          cur += delta;\n        }\n      }\n    }\n\n    if (inv) {\n      const int a = powMod(N, mod - 2);\n      REP (i, N) { to[i] = (ll)to[i] * a % mod; }\n    }\n  }\n  \npublic:\n  FFT(int deg) { // max degree of a polynomial given as input\n    maxh = 0; int N = 1, h = -1;\n    while (N <= 2 * deg) { maxh++; N *= 2; }\n    deg = N + 20;\n    A = new int[deg];\n    B = new int[deg];\n    res = new int[deg];\n    tmp = new int[deg];\n    omega = new int[deg];\n    perm = new int[deg];\n\n    omega[0] = 1;\n    omega[1] = powMod(gen, (p - 1) / N);\n    for (int i = 2; i <= N; ++i) {\n      omega[i] = (ll)omega[i - 1] * omega[1] % mod;\n    }\n    perm[0] = 0;\n    RE (i, N - 1) {\n      if ((i & (i - 1)) == 0) { h++; }\n      perm[i] = perm[i ^ (1 << h)] | (1 << (maxh - h - 1));\n    }\n  }\n  /*VI pow(VI Q, int x, int terms) {\n    int depth = 0, size = 1;\n    int N = terms + 5;\n    while (size < N) { depth++; size *= 2; }\n    Clear(size);\n    copy(ALL(Q), A);// copy(ALL(R), B);\n    fft(A, res, depth, false);\n    REP (i, size) tmp[i] = powMod(res[i], x);\n    // koniec\n    fft(tmp, res, depth, true);\n    VI ans;\n    REP (i, terms) { ans.PB(res[i]); }\n    return ans;\n  }*/\n  VI mul(VI Q, VI R) {\n    int depth = 0, size = 1;\n    int N = SZ(Q) + SZ(R) - 1;\n    while (size < N) { depth++; size *= 2; }\n    Clear(size);\n    copy(ALL(Q), A); copy(ALL(R), B);\n    fft(A, res, depth, false);\n    if (Q == R) {\n      REP (i, size) tmp[i] = (ll)res[i] * res[i] % mod;\n    } else {\n      fft(B, tmp, depth, false);\n      REP (i, size) tmp[i] = (ll)tmp[i] * res[i] % mod;\n    }\n    fft(tmp, res, depth, true);\n    VI ans;\n    REP (i, N) { ans.PB(res[i]); }\n    return ans;\n  }\n};\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int n, m;\n  cin >> n >> m;\n\n  const int S = max(n, m) + 5;\n\n  vi fact(S), inv_fact(S);\n  fact[0] = 1;\n  for (int i = 1; i < S; ++i) {\n    fact[i] = (ll)fact[i - 1] * i % mod;\n  }\n  inv_fact[S-1] = powMod(fact[S-1], mod - 2);\n  for (int i = S - 2; i >= 0; --i) {\n    inv_fact[i] = (ll)inv_fact[i + 1] * (i + 1) % mod;\n  }\n\n  vi polybase(m + 1);\n  for (int k = 0; k <= m; ++k) {\n    polybase[k] = (ll)(m - k + 1) * inv_fact[k] % mod;\n  }\n  debug(polybase);\n\n  vi norm(m + 1);\n  for (int k = 0; k <= m; ++k) {\n    norm[k] = inv_fact[k];\n  }\n\n  FFT fft(S);\n  vi poly(m + 1);\n  poly[0] = 1;\n\n  function<vi(vi, int)> MakePow = [&](vi P, int uh) {\n    if (uh == 1) { return P; }\n    auto ans = MakePow(P, uh / 2);\n    ans = fft.mul(ans, ans);\n    ans.resize(m + 1);\n\n    if (uh & 1) {\n      ans = fft.mul(ans, P);\n      ans.resize(m + 1);\n    }\n    return ans;\n  };\n\n  /*int uh = n;\n  while (uh) {\n    if (uh & 1) { poly = fft.mul(poly, polybase); --n; }\n    if (!uh) { break; }\n    uh >>= 1;\n    poly = fft.mul(poly, poly);\n  }*/\n\n  poly = MakePow(polybase, n);\n  //poly = fft.pow(poly, n, m + 1);\n  poly = fft.mul(poly, norm);\n  poly.resize(m + 1);\n  debug(poly);\n\n  int ans = (ll)poly[m] * fact[m] % mod;\n  cout << ans << \"\\n\";\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb push_back\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nconst int P = 998244353, R = 3;\nconst int SZ = 20, N = 1 << SZ;\n\nint Pow(int x, int y) {\n\tint r = 1;\n\twhile (y) {\n\t\tif (y & 1) r = (long long)r * x % P;\n\t\tx = (long long)x * x % P;\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\n\nvoid FFT(int *a, bool f) {\n\tint i, j, k, x, y, z;\n\tj = 0;\n\tfor (i = 1; i < N; i++) {\n\t\tfor (k = N >> 1; j >= k; k >>= 1) j -= k;\n\t\tj += k;\n\t\tif (i < j) {\n\t\t\tk = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = k;\n\t\t}\n\t}\n\tfor (i = 1; i < N; i <<= 1) {\n\t\tx = Pow(f ? Pow(R, P - 2) : R, P / i >> 1);\n\t\tfor (j = 0; j < N; j += i << 1) {\n\t\t\ty = 1;\n\t\t\tfor (k = 0; k < i; k++) {\n\t\t\t\tz = (long long)a[i | j | k] * y % P;\n\t\t\t\ta[i | j | k] = a[j | k] - z;\n\t\t\t\tif (a[i | j | k] < 0) a[i | j | k] += P;\n\t\t\t\ta[j | k] += z;\n\t\t\t\tif (a[j | k] >= P) a[j | k] -= P;\n\t\t\t\ty = (long long)y * x % P;\n\t\t\t}\n\t\t}\n\t}\n\tif (f) {\n\t\tj = Pow(N, P - 2);\n\t\tfor (i = 0; i < N; i++) a[i] = (long long)a[i] * j % P;\n\t}\n}\n\nconst int mod = 998244353;\n\nll pw(ll x, ll y = mod - 2) {\n\tll res = 1;\n\twhile(y) {\n\t\tif(y & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint n, m;\nll F[1000010];\nint V[1<<20|50];\n\nint main() {\n\tF[0] = 1;\n\tfor(int i=1;i<1000010;i++) F[i] = i * F[i-1] % mod;\n\tscanf(\"%d%d\", &n, &m);\n\tif(m < n) swap(n, m);\n\tfor(int i=0;i<=n;i++) {\n\t\tV[i] = (ll)(n + 1- i) * pw(F[i]) % mod;\n\t}\n\tFFT(V, false);\n\tfor(int i=0;i<N;i++) V[i] = pw(V[i], m);\n\tFFT(V, true);\n\tfor(int i=0;i<=n;i++) V[i] = (ll) V[i] * F[n] % mod;\n\tint ans = 0;\n\tfor(int i=0;i<=n;i++) {\n\t\tint t = V[i];\n\t\tans = (ans + (ll)t * pw(F[n-i])) % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\n\n\n\ntemplate <ui P> struct Group {};\ntemplate <> struct Group<4194304001u> { constexpr static ui bits = 25, root = 199, rootInverse = 758768563u; };\ntemplate <> struct Group<998244353u> { constexpr static ui bits = 23, root = 31, rootInverse = 128805723; };\ntemplate <> struct Group<104857601u> { constexpr static ui bits = 22, root = 21, rootInverse = 49932191; };\ntemplate <> struct Group<924844033u> { constexpr static ui bits = 21, root = 3597, rootInverse = 508059997; };\n\ntemplate <ui Prime> class FFT {\npublic:\n\ttypedef Field<Prime> F;\n\n\tFFT() {\n\t\tOMEGA[Group<Prime>::bits] = Group<Prime>::root;\n\t\tOMEGA_INV[Group<Prime>::bits] = Group<Prime>::rootInverse;\n\t\tfor (size_t i = Group<Prime>::bits; i > 0; --i) {\n\t\t\tOMEGA[i-1] = ui((ull(OMEGA[i])*ull(OMEGA[i]))%Prime);\n\t\t\tOMEGA_INV[i-1] = ui((ull(OMEGA_INV[i])*ull(OMEGA_INV[i]))%Prime);\n\t\t}\n\t}\n\n\tvoid fft(std::vector<F> &V, bool inverse = false) {\n\t\tint P = 1;\n\t\twhile ((1u << P) < V.size()) ++P;\n\t\tV.resize(1u << P);\n\t\tfft(V, P, inverse);\n\t}\n\n\tvoid fft(std::vector<F> &V, const int P, bool inverse = false) {\n\t\tif (P == 0) return;\n\t\t//if (P > Group<Prime>::bits) throw std::runtime_error(\"Number of bits in FFT too large\");\n\t\t//if (V.size() != (1 << P)) throw std::runtime_error(\"Vector has wrong size\");\n\t\tfor (int i = 1, j = 0; i < (1 << P); ++i) {\n\t\t\tint bit = (1 << (P - 1));\n\t\t\tfor (; j >= bit; bit >>= 1) j -= bit;\n\t\t\tj += bit;\n\t\t\tif (i < j) std::swap(V[i], V[j]);\n\t\t}\n\n\t\tfor (int B = 1; B <= P; ++B) {\n\t\t\tF omega = inverse ? OMEGA_INV[B] : OMEGA[B];\n\t\t\tfor (int i = 0; i < (1 << P); i += (1 << B)) {\n\t\t\t\tF x = 1;\n\t\t\t\tfor (int j = 0; j < (1 << (B - 1)); j++) {\n\t\t\t\t\tF u = V[i + j], v = V[i + j + (1 << (B - 1))] * x;\n\t\t\t\t\tV[i + j] = u + v;\n\t\t\t\t\tV[i + j + (1 << (B - 1))] = u - v;\n\t\t\t\t\tx *= omega;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (inverse) {\n\t\t\tF q = 1 / F(1 << P);\n\t\t\tfor (F &v:V) v *= q;\n\t\t}\n\t}\n\nprivate:\n\tstd::array<ui, Group<Prime>::bits+1> OMEGA, OMEGA_INV;\n};\n\n\ntypedef Field<998244353> FF;\n\nclass FTwoHistograms {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, M; cin >> N >> M;\n\n        auto F = FF::fact(500001);\n        auto I = FF::invfact(500001);\n        FF ans = 0;\n        vector<FF> MP(N+1, 1), NP(M+1, 1);\n        for (int i = 0; i < N; ++i) MP[i+1] = MP[i] * (M+1);\n        for (int i = 0; i < M; ++i) NP[i+1] = NP[i] * (N+1);\n\n        for (int i = 0; i <= min(M,N); i+=2) {\n            ans += MP[N-i] * NP[M-i] * I[i] * I[N-i] * I[M-i];\n        }\n\n        for (int i = 1; i <= min(M,N); i += 2) {\n            ans -= MP[N-i] * NP[M-i] * I[i] * I[N-i] * I[M-i];\n        }\n\n        cout << ans * F[M] * F[N] << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tFTwoHistograms solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t\treturn s(a+x.a);\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t\treturn s(a+mod-x.a);\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt<998244353>;\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t N>\nstruct ModIntTable{\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n){return facts[n];}\n\tinline Mint finv(int n){return finvs[n];}\n\tinline Mint inv(int n){return invs[n];}\n\tinline Mint binom(int n,int k){return facts[n]*finvs[k]*finvs[n-k];}\n};\nModIntTable<mint,1<<19>mtable;\n\n\ntemplate<class Mint,int32_t root>\nstruct NumberTheoreticTransform{\n\tstatic void ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(root).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    static void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tstatic vector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n};\nusing NTT=NumberTheoreticTransform<mint,3>;\n\n\nconst uint32_t mod=998244353;\nconst mint prim_root=3;\n\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tmint in=mint(n).inv();\n\trep(i,n)\n\t\tf[i]*=in;\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i=false){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\n\n\nvector<mint> multiply(vector<mint> x,vector<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n \ntemplate<class Mint>\nstruct NTTFriendlyPoly{\n\tvoid ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(3).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tvector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n\n\tvector<Mint>v;\n\ttemplate<class...Args>\n\tNTTFriendlyPoly(Args...args):v(args...){}\n \n\tNTTFriendlyPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n \n\tint size()const{return v.size();}\n \n\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n \n\tNTTFriendlyPoly operator+(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator-(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tNTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator*(const NTTFriendlyPoly& x){\n\t\treturn multiply(v,x.v);\n\t}\n\tNTTFriendlyPoly operator*(const Mint& x){\n\t\tint n=size();\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator/(const Mint& x){\n\t\treturn (*this)*x.inv();\n\t}\n \n\tNTTFriendlyPoly& operator+=(const NTTFriendlyPoly& x){return *this=(*this)+x;}\n\tNTTFriendlyPoly& operator-=(const NTTFriendlyPoly& x){return *this=(*this)-x;}\n\tNTTFriendlyPoly& operator*=(const NTTFriendlyPoly& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n\tNTTFriendlyPoly operator-(){return NTTFriendlyPoly()-*this;}\n \n    NTTFriendlyPoly pre(int n){\n        NTTFriendlyPoly<Mint>res(n);\n\t\tfor(int i=0;i<n&&i<size();i++)res[i]=v[i];\n\t\treturn res;\n    }\n    NTTFriendlyPoly rev(){\n        vector<Mint>res=v;\n\t\twhile(res.size()&&res.back()==0)res.pop_back();\n        reverse(res.begin(),res.end());\n        return res;\n    }\n    NTTFriendlyPoly diff(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=1;i<size()&&i<=n;i++)res[i-1]=v[i]*i;\n        return res;\n    }\n    NTTFriendlyPoly inte(int n){\n        NTTFriendlyPoly<Mint>res(n);\n        for(int i=0;i<size()&&i+1<n;i++)res[i+1]=v[i]*mtable.inv(i+1);\n        return res;\n    }\n\n    NTTFriendlyPoly inv(int n){\n        vector<mint>res{coef(0).inv()};\n\n        for(int d=1;d<n;d<<=1){\n            vector<Mint>f(2*d),g(2*d);\n            for(int j=0;j<2*d;j++)f[j]=coef(j);\n            for(int j=0;j<d;j++)g[j]=res[j];\n            \n            inplace_fmt(f);inplace_fmt(g);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++){\n                f[j]=0;\n                f[j+d]=-f[j+d];\n            }\n            inplace_fmt(f);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            inplace_fmt(f,true);\n            for(int j=0;j<d;j++)f[j]=res[j];\n            res=f;\n        }\n        return NTTFriendlyPoly(res).pre(n);\n    }\n    \n    \n    NTTFriendlyPoly inv2(int n){\n        NTTFriendlyPoly res{coef(0).inv()};\n        for(int i=1;i<n;i*=2){\n            res=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n        }\n        return res.pre(n);\n    }\n    \n    \n\n\tNTTFriendlyPoly exp(int n){\n\t\tNTTFriendlyPoly f0{1},g0{1};\n\t\tvector<Mint>F0{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tvector<Mint>G0=g0.v;\n\t\t\tinplace_fmt(G0);\n\t\t\tvector<Mint>Delta(d);\n\t\t\tfor(int j=0;j<d;j++)Delta[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tDelta[0]-=1;\n\t\t\tNTTFriendlyPoly delta(2*d);\n\t\t\tfor(int j=0;j<d;j++)delta[d+j]=Delta[j];\t\t\n\t\t\t\n\t\t\tNTTFriendlyPoly epsilon(2*d);\n\t\t\t\n\t\t\n\t\t\t\n\t\t\tvector<Mint>DF0=f0.diff(d-1).v;DF0.push_back(0);\n\t\t\tinplace_fmt(DF0);\n\t\t\tfor(int j=0;j<d;j++)DF0[j]*=G0[j];\n\t\t\tinplace_fmt(DF0,true);\n\t\t\tfor(int j=0;j<d-1;j++){\n\t\t\t\tepsilon[j]+=coef(j+1)*(j+1);\n\t\t\t\tepsilon[j+d]+=DF0[j]-coef(j+1)*(j+1);\n\t\t\t}\n\t\t\tepsilon[d-1]+=DF0[d-1];\n\n\n\t\t\tDelta=delta.v;\n\t\t\tinplace_fmt(Delta);\n\t\t\tvector<Mint>DH0=diff(d-1).v;DH0.resize(2*d);\n\t\t\tinplace_fmt(DH0);\n\t\t\tfor(int j=0;j<2*d;j++)Delta[j]*=DH0[j];\n\t\t\tinplace_fmt(Delta,true);\n\t\t\tfor(int j=0;j<d;j++)epsilon[j+d]-=Delta[j+d];\n\t\t\n\n\t\t\tepsilon=epsilon.inte(2*d)-pre(2*d);\n\t\t\t\n\t\t\tvector<Mint>Epsilon=epsilon.v;\n\t\t\tinplace_fmt(Epsilon);\n\t\t\trep(j,d)DH0[j]=f0[j],DH0[j+d]=0;\n\t\t\tinplace_fmt(DH0);\n\t\t\trep(j,2*d)Epsilon[j]*=DH0[j];\n\t\t\tinplace_fmt(Epsilon,true);\n\t\t\tf0.v.resize(2*d);\n\t\t\trep(j,d)f0[j+d]-=Epsilon[j+d];\n\t\t\t//f0=(f0-epsilon*f0).pre(2*d);\n\t\t\t\n\t\t\tG0.resize(2*d);\n\t\t\trep(j,d)G0[j]=g0[j];\n\t\t\tinplace_fmt(G0);\n\t\t\tF0=f0.v; \n\t\t\tinplace_fmt(F0);\n\t\t\tvector<Mint>T(2*d);rep(j,2*d)T[j]=F0[j]*G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d){\n\t\t\t\tT[j]=0;\n\t\t\t\tT[j+d]=-T[j+d];\n\t\t\t}\n\t\t\tinplace_fmt(T);\n\t\t\trep(j,2*d)T[j]*=G0[j];\n\t\t\tinplace_fmt(T,true);\n\t\t\trep(j,d)T[j]=g0[j];\n\t\t\tg0=T;\n\t\t}\n\t\treturn f0.pre(n);\n\t}\n\n    NTTFriendlyPoly exp2(int n){\n        NTTFriendlyPoly f{1};\n        for(int i=1;i<n;i*=2){\n            f=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n        }\n        return f.pre(n);\n    }\n\n\tNTTFriendlyPoly exp3(int n){\n\t\tNTTFriendlyPoly f{1},g{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tg=g*Mint(2)-(g*g*f).pre(d);\n\n\t\t\tNTTFriendlyPoly q=diff(d-1);\n\t\t\tq=q+g*(f.diff(d-1)-f*q).pre(2*d-1);\n\t\t\tf=f+(f*(pre(2*d)-q.inte(2*d))).pre(2*d);\n\t\t}\n\t\treturn f.pre(n);\n\t}\n\n\n \n    NTTFriendlyPoly log(int n){\n        return (diff(n-1)*inv(n-1)).inte(n);\n    }\n \n    NTTFriendlyPoly pow(int n,mint k){\n\t\tauto res=log(n);\n\t\tres*=k;\n\t\treturn res.exp(n);\n\t}\n\tMint& operator[](const int i){return v[i];}\n};\nusing poly=NTTFriendlyPoly<mint>;\n \ntemplate<class Mint>\nostream& operator<<(ostream& ost,NTTFriendlyPoly<Mint>a){\n    for(int i=0;i<a.size();i++){\n        if(i)cout<<\" \";\n        cout<<a.v[i];\n    }\n    return ost;\n}\n\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=mtable.finv(i)*in*(N+1-i);\n\t}\n \n\tp=p.pow(N+1,M);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*mtable.finv(N-i);\n\t}\n\tans*=mtable.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 1200000\n\nconst LL mod=998244353;\nLL n,m,p,ans,fac[N],ifac[N],pwn[N],pwm[N];\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nvoid upd(LL &x,LL y){x=(x+y%mod+mod)%mod;}\n\nLL C(LL x,LL y){return fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tp=n+m;\n\tfac[0]=1; for (LL i=1;i<=p;++i) fac[i]=fac[i-1]*i%mod;\n\tifac[p]=inv(fac[p]); for (LL i=p-1;~i;--i) ifac[i]=ifac[i+1]*(i+1)%mod;\n\tpwn[0]=pwm[0]=1;\n\tfor (LL i=1;i<=p;++i){pwn[i]=pwn[i-1]*(n+1)%mod; pwm[i]=pwm[i-1]*(m+1)%mod;}\n\tfor (LL i=0;i<=min(n,m);++i)\n\t\tupd(ans,(i&1?-1:1)*C(n,i)*C(m,i)%mod*fac[i]%mod*pwn[m-i]%mod*pwm[n-i]);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 500005\nusing namespace std;\nconst int mod = 998244353;\nint n,m,ans,fac[maxn],inv[maxn];\nint Pow(int a,int b){int s=1;for(;b;b>>=1,a=1ll*a*a%mod) b&1&&(s=1ll*s*a%mod);return s;}\nint C(int n,int m){return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m); if(n>m) swap(n,m);\n\tfor(int i=fac[0]=inv[0]=1;i<=m;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[m]=Pow(fac[m],mod-2);\n\tfor(int i=m-1;i>=1;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tfor(int i=0;i<=n;i++) ans=(ans+(i&1?-1:1)*1ll*C(n,i)*C(m,i)%mod*fac[i]%mod*Pow(m+1,n-i)%mod*Pow(n+1,m-i))%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\nusing namespace std;\nconst int P=998244353;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n    R int res=1;\n    for(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n    return res;\n}\nconst int N=5e5+5;\nint fac[N],ifac[N],bin[2][N],n,m,res,d;\ninline int C(R int n,R int m){return 1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\ninline int A(R int n,R int m){return mul(fac[n],ifac[n-m]);}\nvoid init(){\n\tif(n>m)swap(n,m);\n\tbin[0][0]=bin[1][0]=fac[0]=ifac[0]=1;\n\tfp(i,1,m){\n\t\tfac[i]=mul(fac[i-1],i),\n\t\tbin[0][i]=mul(bin[0][i-1],m+1),\n\t\tbin[1][i]=mul(bin[1][i-1],n+1);\n\t}\n\tifac[m]=ksm(fac[m],P-2);\n\tfd(i,m-1,1)ifac[i]=mul(ifac[i+1],i+1);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m),init();\n\tfp(i,0,n){\n\t\td=1ll*C(n,i)*A(m,i)%P*bin[0][n-i]%P*bin[1][m-i]%P;\n\t\tupd(res,(i&1)?P-d:d);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int mod = 998244353, N = 5e5;\nint n, m, ans, fac[N + 3], inv[N + 3];\n\nint qpow(int a, int b){\n    int ret = 1;\n    while(b){\n        if(b & 1) ret = (ll)ret * a % mod;\n        a = (ll)a * a % mod; b >>= 1;\n    }\n    assert(ret != 0);\n    return ret;\n}\nvoid init(){\n    fac[0] = 1;\n    for(int i = 1; i <= N; i++) fac[i] = (ll)fac[i - 1] * i % mod;\n    inv[N] = qpow(fac[N], mod - 2);\n    for(int i = N - 1; i; i--) inv[i] = (ll)inv[i + 1] * (i + 1) % mod;\n}\nvoid upd(int &x, int add){\n    x += add;\n    if(x >= mod) x -= mod;\n}\nint C(int a, int b){\n    if(a == b || b == 0) return 1;\n    return (ll)fac[a] * inv[b] % mod * inv[a - b] % mod;\n}\n\nint main(){\n    scanf(\"%d %d\", &n, &m); init();\n    for(int i = 0, k = 1; i <= min(n, m); i++, k = -k){\n        upd(ans, ((ll)k * C(n, i) % mod * C(m, i) % mod * fac[i] % mod * qpow(m + 1, n - i) % mod * qpow(n + 1, m - i) % mod + mod) % mod);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 5e5 + 10, mod = 998244353;\n\nint n, m;\nint fac[maxN + 1], inv[maxN + 1];\n\ninline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }\n\ninline int SUB(int x, int y) { return x - y < 0 ? x - y + mod : x - y; }\n\ninline int mpow(int a, int x)\n{\n\tint ans = 1;\n\twhile(x)\n\t{\n\t\tif(x & 1) ans = 1ll * ans * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tx >>= 1;\n\t}\n\treturn ans;\n}\n\ninline int C(int n, int m)\n{\n\tif(n < m) return 0;\n\treturn 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tint lim = max(n, m), ans = 0;\n\n\tfac[0] = 1;\n\tfor(int i = 1; i <= lim; i++) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tinv[lim] = mpow(fac[lim], mod - 2);\n\tfor(int i = lim - 1; i >= 0; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n\n\tlim = min(n, m);\n\tfor(int i = 0; i <= lim; i++)\n\t{\n\t\tint res = 1ll * C(n, i) * C(m, i) % mod * fac[i] % mod * mpow(n + 1, m - i) % mod * mpow(m + 1, n - i) % mod;\n\t\tans = (i & 1) ? SUB(ans, res) : ADD(ans, res);\n\t}\n\n\tprintf(\"%d\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n    ModInt(int64_t x=0):a((x%mod+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n        if(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=(uint64_t)a*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-(){return ModInt()-*this;}\n\tinline ModInt pow(uint64_t ex)const{\n\t\tuint64_t x=a;\n\t\tuint64_t res=1;\n\t\twhile(ex){\n\t\t\tif(ex&1)res=res*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tex>>=1;\n\t\t}\n\t\treturn ModInt(res);\n\t}\n\n    inline ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,const ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<ans*fact[n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\ntypedef long long ll;\nconst int N = 500054, mod = 998244353;\n\nint n, m;\nint inv[N];\n\nll PowerMod(ll a, int n, ll c = 1) {for (; n; n >>= 1, a = a * a % mod) if (n & 1) c = c * a % mod; return c;}\n\nint main() {\n\tint i, cur; ll ans, coef;\n\tscanf(\"%d%d\", &n, &m), inv[1] = 1;\n\tif (n > m) std::swap(n, m);\n\tans = cur = PowerMod(n + 1, m, PowerMod(m + 1, n));\n\tcoef = PowerMod((n + 1ll) * (m + 1ll) % mod, mod - 2, mod - 1);\n\tfor (i = 2; i <= n; ++i) inv[i] = ll(mod - mod / i) * inv[mod % i] % mod;\n\tfor (i = 1; i <= n; ans += cur, ++i)\n\t\tcur = cur * coef % mod * (n - i + 1ll) % mod * (m - i + 1ll) % mod * inv[i] % mod;\n\tprintf(\"%d\\n\", int(ans % mod));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Tenshi ni Fureta yo!\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\n\nnamespace fastIO\n{\n\tconst int MAX_BUFFER_SIZE = 1 << 16;\n\n\tchar buffer[MAX_BUFFER_SIZE], *cur = buffer, *ed = buffer;\n\n\tinline char getc() { return *(cur == ed ? ed = buffer + fread(buffer, 1, MAX_BUFFER_SIZE, stdin), cur = buffer : cur)++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\n// END tpl.\n\nconst int MOD = 998244353;\n\ninline int fpm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline int inv(int x) { assert(x); return fpm(x, MOD - 2); }\n\nnamespace MATH\n{\n\tconst int n = (int) 1e6;\n\n\tint fac[n + 5], ifac[n + 5];\n\n\tinline void init()\n\t{\n\t\tfac[0] = 1;\n\t\tfor(int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % MOD;\n\t\tifac[n] = inv(fac[n]);\n\t\tfor(int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % MOD;\n\t}\n\n\tinline int C(int N, int M) { return N < 0 || M < 0 || N < M ? 0 : (LL) fac[N] * ifac[N - M] % MOD * ifac[M] % MOD; }\n}\nusing MATH::fac;\nusing MATH::ifac;\nusing MATH::C;\n\nconst int MAXN = (int) 5e5;\n\nint n, m;\n\ninline void input()\n{\n\tn = read<int>(), m = read<int>();\n}\n\ninline void solve()\n{\n\tint ans = 0;\n\tfor(int i = 0; i <= min(n, m); ++i) (ans += (i & 1 ? -1 : +1) * (LL) C(n, i) * C(m, i) % MOD * fac[i] % MOD * fpm(m + 1, n - i) % MOD * fpm(n + 1, m - i) % MOD) %= MOD;\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n#ifdef K_ON\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tMATH::init();\n\tinput();\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define FIR first\n#define SEC second\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int mod=998244353,N=5e5+10;\nint Pow(int x,int y) {\n    int res=1;\n    while(y) {\n        if(y&1) res=res*(ll)x%mod;\n        x=x*(ll)x%mod,y>>=1;\n    }\n    return res;\n}\nint fac[N],inv[N];\nvoid getfac(int n) {\n    fac[0]=1; for(int i=1;i<=n;++i) fac[i]=fac[i-1]*(ll)i%mod;\n    inv[n]=Pow(fac[n],mod-2); for(int i=n;i>=1;--i) inv[i-1]=inv[i]*(ll)i%mod;\n}\nint C(int n,int m) { return fac[n]*(ll)inv[m]%mod*inv[n-m]%mod; }\nint main() {\n    int n,m; rd(n),rd(m); getfac(max(n,m));\n    int ans=0;\n    for(int i=0;i<=min(n,m);++i)\n        ans=(ans+((i&1)?-1:1)*C(n,i)*(ll)C(m,i)%mod*fac[i]%mod*Pow(m+1,n-i)%mod*Pow(n+1,m-i)%mod)%mod;\n    printf(\"%d\",(ans+mod)%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for (int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T sqr(const T &a) { return a * a; }\ntypedef long long LL;\ntypedef long double LD;\nvoid procStatus() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\nLL read() {\n\tLL x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (;!isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n\tfor (;isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\treturn x * flag;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 5e5 + 9, Mod = 998244353;\nint mmul(int a, int b){\n    int ret = 1ll * a * b % Mod;\n    return ret;\n}\nint mplus(int a, int b) {\n\ta += b;\n\tif (a >= Mod) a -= Mod;\n\treturn a;\n}\nint fpm(int base, int tims) {\n\tint r = 1;\n\tfor (; tims; base = mmul(base, base), tims >>= 1) \n\t\tif (tims & 1) r = mmul(r, base);\n\treturn r;\n}\nint fac[Maxn], inv[Maxn], invFac[Maxn];\n\nvoid Init() {\n\tfac[0] = 1;\n\trep (i, 1, Maxn - 1) fac[i] = mmul(fac[i - 1], i);\n\tinv[1] = 1;\n\trep (i, 2, Maxn - 1) inv[i] = mmul(inv[Mod % i], Mod - Mod / i);\n\tinvFac[0] = 1;\n\trep (i, 1, Maxn - 1) invFac[i] = mmul(invFac[i - 1], inv[i]);\n}\n\nint C(int n, int m) {\n\tif (n < m || n < 0 || m < 0) return 0;\t\n\treturn mmul(fac[n], mmul(invFac[n - m], invFac[m]));\n}\n\nint n, m;\nint f(int k) {\n\treturn mmul(C(n, k), mmul(C(m, k), mmul(fac[k], mmul(fpm(n + 1, m - k), fpm(m + 1, n - k)))));\n}\n\nvoid Solve() {\n\tn = read(), m = read();\n\tint ans = 0;\n\trep (k, 0, min(n, m)) {\n\t\tint coef = (k & 1) ? (Mod - 1) : 1;\n\t\tans = mplus(ans, mmul(coef, f(k)));\n\t}\n\tcout << ans << endl; \n}\n\nint main() {\n//\tfreopen(\"bosky.in\", \"r\", stdin);\n//\tfreopen(\"bosky.out\", \"w\", stdout);\n\n\tInit();\n\tSolve();\t\n\n#ifdef Qrsikno\n//\tprocStatus();\n\tdebug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint fac[500005],ifac[500005];\nconst int mod=998244353;\ninline int power(int a,int b){\n\tint c=1;\n\twhile(b){\n\t\tif(b&1)c=1ll*c*a%mod;\n\t\ta=1ll*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn c;\n}\ninline int c(int x,int y){\n\tif(y<0||y>x)return 0;\n\treturn 1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tif(n>m)swap(n,m);\n\tfac[0]=1;\n\tfor(int i=1;i<=m;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[m]=power(fac[m],mod-2);\n\tfor(int i=m;i>=1;i--)ifac[i-1]=1ll*ifac[i]*i%mod;\n\tint ans=0;\n\tfor(int i=0;i<=n;i++){\n\t\tans=(ans+(i&1?-1ll:1ll)*c(n,i)*c(m,i)%mod*fac[i]%mod*power(n+1,m-i)%mod*power(m+1,n-i))%mod;\n\t}\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unistd.h>\nusing namespace std;\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){return s(a+x.a);}\n\tModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,const ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\n\nusing mint=ModInt<998244353>;\ntemplate<class Mint,int32_t N>\nstruct ModIntTable{\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n)const{return facts[n];}\n\tinline Mint finv(int n)const{return finvs[n];}\n\tinline Mint inv(int n)const{return invs[n];}\n\tinline Mint binom(int n,int k)const{return facts[n]*finvs[k]*finvs[n-k];}\n};\nModIntTable<mint,1<<19>mtable;\n\n\n\nnamespace NTTFriendlyPoly{\n\t\n\tconst uint32_t mod=998244353;\n\tconst uint32_t prim_root=3;\n\n\tusing Mint=ModInt<mod>;\n\n\n\tconst int LG=19;\n\tMint invs[1<<LG];\n\tMint roots[1<<LG+1],iroots[1<<LG+1];\n\tstruct InitTable{\n\t\tInitTable(){\n\t\t\tinvs[1]=1;\n\t\t\tfor(int i=2;i<1<<LG;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\t\trep(w,LG+1){\n\t\t\t\tconst int s=(1<<w)-1;\n\t\t\t\tconst Mint g=Mint(prim_root).pow((mod-1)>>w),ig=g.inv();\n\t\t\t\tMint p=1,ip=1;\n\t\t\t\trep(i,1<<w){\n\t\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}InitTableDummy;\n\n\tvoid ntt(vector<Mint>&f){\n\t\tconst int n=f.size();\n\t\tfor(int b=n/2;b>=1;b/=2){\n\t\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\t\trep(j,b){\n\t\t\t\t\tconst Mint tmp=f[i+j]-f[i+j+b];\n\t\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid intt(vector<Mint>&f){\n\t\tconst int n=f.size();\n\t\tfor(int b=1;b<=n/2;b*=2){\n\t\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\t\trep(j,b){\n\t\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\t\tconst Mint tmp=f[i+j]-f[i+j+b];\n\t\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\t\tf[i+j+b]=tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst Mint in=Mint(n).inv();\n\t\trep(i,n)\n\t\t\tf[i]*=in;\n\t}\n\n\tvector<Mint> multiply(vector<Mint> x,vector<Mint> y){\n\t\tint n=x.size()+y.size()-1;\n\t\tint s=1<<__lg(n-1)+1;\n\t\tx.resize(s);\n\t\ty.resize(s);\n\t\tntt(x);ntt(y);\n\t\trep(i,s)\n\t\t\tx[i]*=y[i];\n\t\tintt(x);x.resize(n);\n\t\treturn x;\n\t}\n\n\n\n\ttemplate<class Mint>\n\tstruct Poly{\n\t\tvector<Mint>v;\n\t\ttemplate<class...Args>\n\t\tPoly(Args...args):v(args...){}\n\t\tPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n\t\n\n\t\tinline int size()const{return v.size();}\n\t\n\t\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n\t\n\t\tPoly operator+(const Poly &x)const{\n\t\t\tint n=max(size(),x.size());\n\t\t\tPoly<Mint>res(n);\n\t\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\t\treturn res;\n\t\t}\n\t\tPoly operator-(const Poly &x)const{\n\t\t\tint n=max(size(),x.size());\n\t\t\tPoly<Mint>res(n);\n\t\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\t\treturn res;\n\t\t}\n\t\tPoly operator*(const Poly& x)const{\n\t\t\treturn multiply(v,x.v);\n\t\t}\n\t\tPoly operator*(const Mint& x)const{\n\t\t\tint n=size();\n\t\t\tvector<Mint>res(n);\n\t\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\t\treturn res;\n\t\t}\n\t\tPoly operator/(const Mint& x)const{\n\t\t\treturn (*this)*x.inv();\n\t\t}\n\t\n\t\tPoly& operator+=(const Poly& x){return *this=(*this)+x;}\n\t\tPoly& operator-=(const Poly& x){return *this=(*this)-x;}\n\t\tPoly& operator*=(const Poly& x){return *this=(*this)*x;}\n\t\tPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\t\tPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n\t\tPoly operator-(){return Poly()-*this;}\n\t\n\t\tPoly pre(int n)const{\n\t\t\tPoly<Mint>res(n);\n\t\t\tfor(int i=0;i<n&&i<size();i++)res[i]=v[i];\n\t\t\treturn res;\n\t\t}\n\t\tPoly rev()const{\n\t\t\tvector<Mint>res=v;\n\t\t\twhile(res.size()&&res.back()==0)res.pop_back();\n\t\t\treverse(res.begin(),res.end());\n\t\t\treturn res;\n\t\t}\n\t\tPoly diff(int n)const{\n\t\t\tPoly<Mint>res(n);\n\t\t\tfor(int i=1;i<size()&&i<=n;i++)res[i-1]=v[i]*i;\n\t\t\treturn res;\n\t\t}\n\t\tPoly inte(int n)const{\n\t\t\tPoly<Mint>res(n);\n\t\t\tfor(int i=0;i<size()&&i+1<n;i++)res[i+1]=v[i]*invs[i+1];\n\t\t\treturn res;\n\t\t}\n\n\t\tPoly inv(int n)const{\n\t\t\tvector<Mint>res{coef(0).inv()};\n\n\t\t\tfor(int d=1;d<n;d<<=1){\n\t\t\t\tvector<Mint>f(2*d),g(2*d);\n\t\t\t\tfor(int j=0;j<2*d;j++)f[j]=coef(j);\n\t\t\t\tfor(int j=0;j<d;j++)g[j]=res[j];\n\t\t\t\t\n\t\t\t\tntt(f);ntt(g);\n\t\t\t\tfor(int j=0;j<2*d;j++)f[j]*=g[j];\n\t\t\t\tintt(f);\n\t\t\t\tfor(int j=0;j<d;j++){\n\t\t\t\t\tf[j]=0;\n\t\t\t\t\tf[j+d]=-f[j+d];\n\t\t\t\t}\n\t\t\t\tntt(f);\n\t\t\t\tfor(int j=0;j<2*d;j++)f[j]*=g[j];\n\t\t\t\tintt(f);\n\t\t\t\tfor(int j=0;j<d;j++)f[j]=res[j];\n\t\t\t\tres=f;\n\t\t\t}\n\t\t\treturn Poly(res).pre(n);\n\t\t}\n\t\t\n\t\t\n\t\tPoly inv2(int n){\n\t\t\tPoly res{coef(0).inv()};\n\t\t\tfor(int i=1;i<n;i*=2){\n\t\t\t\tres=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n\t\t\t}\n\t\t\treturn res.pre(n);\n\t\t}\n\t\t\n\t\t\n\n\t\tPoly exp(int n){\n\t\t\tPoly f0{1},g0{1};\n\t\t\tvector<Mint>F0{1};\n\t\t\tfor(int d=1;d<n;d<<=1){\n\t\t\t\tvector<Mint>G0=g0.v;\n\t\t\t\tntt(G0);\n\t\t\t\tvector<Mint>Delta(d);\n\t\t\t\tfor(int j=0;j<d;j++)Delta[j]=F0[j]*G0[j];\n\t\t\t\tintt(Delta);\n\t\t\t\tDelta[0]-=1;\n\t\t\t\tPoly delta(2*d);\n\t\t\t\tfor(int j=0;j<d;j++)delta[d+j]=Delta[j];\t\t\n\t\t\t\t\n\t\t\t\tPoly epsilon(2*d);\n\t\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\tvector<Mint>DF0=f0.diff(d-1).v;DF0.push_back(0);\n\t\t\t\tntt(DF0);\n\t\t\t\tfor(int j=0;j<d;j++)DF0[j]*=G0[j];\n\t\t\t\tintt(DF0);\n\t\t\t\tfor(int j=0;j<d-1;j++){\n\t\t\t\t\tepsilon[j]+=coef(j+1)*(j+1);\n\t\t\t\t\tepsilon[j+d]+=DF0[j]-coef(j+1)*(j+1);\n\t\t\t\t}\n\t\t\t\tepsilon[d-1]+=DF0[d-1];\n\n\n\t\t\t\tDelta=delta.v;\n\t\t\t\tntt(Delta);\n\t\t\t\tvector<Mint>DH0=diff(d-1).v;DH0.resize(2*d);\n\t\t\t\tntt(DH0);\n\t\t\t\tfor(int j=0;j<2*d;j++)Delta[j]*=DH0[j];\n\t\t\t\tintt(Delta);\n\t\t\t\tfor(int j=0;j<d;j++)epsilon[j+d]-=Delta[j+d];\n\t\t\t\n\n\t\t\t\tepsilon=epsilon.inte(2*d)-pre(2*d);\n\t\t\t\t\n\t\t\t\tvector<Mint>Epsilon=epsilon.v;\n\t\t\t\tntt(Epsilon);\n\t\t\t\trep(j,d)DH0[j]=f0[j],DH0[j+d]=0;\n\t\t\t\tntt(DH0);\n\t\t\t\trep(j,2*d)Epsilon[j]*=DH0[j];\n\t\t\t\tintt(Epsilon);\n\t\t\t\tf0.v.resize(2*d);\n\t\t\t\trep(j,d)f0[j+d]-=Epsilon[j+d];\n\t\t\t\t//f0=(f0-epsilon*f0).pre(2*d);\n\n\t\t\t\tif(2*d>=n)break;\n\t\t\t\t\n\t\t\t\tG0.resize(2*d);\n\t\t\t\trep(j,d)G0[j]=g0[j];\n\t\t\t\tntt(G0);\n\t\t\t\tF0=f0.v; \n\t\t\t\tntt(F0);\n\t\t\t\tvector<Mint>T(2*d);rep(j,2*d)T[j]=F0[j]*G0[j];\n\t\t\t\tintt(T);\n\t\t\t\trep(j,d){\n\t\t\t\t\tT[j]=0;\n\t\t\t\t\tT[j+d]=-T[j+d];\n\t\t\t\t}\n\t\t\t\tntt(T);\n\t\t\t\trep(j,2*d)T[j]*=G0[j];\n\t\t\t\tintt(T);\n\t\t\t\trep(j,d)T[j]=g0[j];\n\t\t\t\tg0=T;\n\t\t\t}\n\t\t\treturn f0.pre(n);\n\t\t}\n\n\t\tPoly exp2(int n){\n\t\t\tPoly f{1};\n\t\t\tfor(int i=1;i<n;i*=2){\n\t\t\t\tf=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n\t\t\t}\n\t\t\treturn f.pre(n);\n\t\t}\n\n\t\tPoly exp3(int n){\n\t\t\tPoly f{1},g{1};\n\t\t\tfor(int d=1;d<n;d<<=1){\n\t\t\t\tg=g*Mint(2)-(g*g*f).pre(d);\n\n\t\t\t\tPoly q=diff(d-1);\n\t\t\t\tq=q+g*(f.diff(d-1)-f*q).pre(2*d-1);\n\t\t\t\tf=f+(f*(pre(2*d)-q.inte(2*d))).pre(2*d);\n\t\t\t}\n\t\t\treturn f.pre(n);\n\t\t}\n\n\n\t\n\t\tPoly log(int n){\n\t\t\treturn (diff(n-1)*inv(n-1)).inte(n);\n\t\t}\n\t\n\t\tPoly pow(int n,Mint k){\n\t\t\tauto res=log(n);\n\t\t\tres*=k;\n\t\t\treturn res.exp(n);\n\t\t}\n\t\tMint& operator[](const int i){return v[i];}\n\t};\n\t\n\ttemplate<class Mint>\n\tostream& operator<<(ostream& ost,Poly<Mint>a){\n\t\tfor(int i=0;i<a.size();i++){\n\t\t\tif(i)cout<<\" \";\n\t\t\tcout<<a.v[i];\n\t\t}\n\t\treturn ost;\n\t}\n\tusing poly=Poly<Mint>;\n};\n\nusing NTTFriendlyPoly::poly;\n\n\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=mtable.finv(i)*in*(N+1-i);\n\t}\n \n\tp=p.pow(N+1,M);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*mtable.finv(N-i);\n\t}\n\tans*=mtable.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll; \ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n \ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n \n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n \n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n \n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n \n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n \n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n \n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n \n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n \n private:\n  Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n \ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n \ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n \ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n \ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n \ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n \ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n \ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n \n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n \nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n \nvector<Mint> fact;\nvector<Mint> inv_fact;\n \ntemplate <typename T>\nclass NTT {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  static Type md;\n  static Modular<T> root;\n  static int base;\n  static int max_base;\n  static vector<Modular<T>> roots;\n  static vector<int> rev;\n \n  static void clear() {\n    root = 0;\n    base = 0;\n    max_base = 0;\n    roots.clear();\n    rev.clear();\n  }\n \n  static void init() {\n    md = T::value;\n    assert(md >= 3 && md % 2 == 1);\n    auto tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (md - 1) >> 1) == 1) {\n      root++;\n    }\n    assert(power(root, md - 1) == 1);\n    root = power(root, (md - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n \n  static void ensure_base(int nbase) {\n    if (md != T::value) {\n      clear();\n    }\n    if (roots.empty()) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = roots[i] * z;\n      }\n      base++;\n    }\n  }\n \n  static void fft(vector<Modular<T>> &a) {\n    int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          Modular<T> x = a[i + j];\n          Modular<T> y = a[i + j + k] * roots[j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n \n  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n    if (a.empty() || b.empty()) {\n      return {};\n    }\n    int eq = (a == b);\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq) b = a; else fft(b);\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] *= b[i] * inv_sz;\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n};\n \ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\n \ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<Modular<T>> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x.resize(b.size() << 1);\n    b.resize(b.size() << 1);\n    vector<Modular<T>> c = b;\n    NTT<T>::fft(c);\n    NTT<T>::fft(x);\n    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n    fill(x.begin() + (x.size() >> 1), x.end(), 0);\n    NTT<T>::fft(x);\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    for (int i = 0; i < ((int) x.size() >> 1); i++) {\n      b[i + ((int) x.size() >> 1)] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  if (n == 1) {\n    return {1 / a[0]};\n  }\n  int m = (n + 1) >> 1;\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n  int need = n << 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    ++nbase;\n  }\n  NTT<T>::ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  NTT<T>::fft(a);\n  NTT<T>::fft(b);\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n  for (int i = 0; i < size; ++i) {\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  NTT<T>::fft(a);\n  a.resize(n);\n  return a;\n}\n \ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (min(a.size(), b.size()) < 150) {\n    vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        c[i + j] += a[i] * b[j];\n      }\n    }\n    return c;\n  }\n  return NTT<T>::multiply(a, b);\n}\n \ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  return a = a * b;\n}\n \ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n \ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n \ntemplate <typename T>\nvector<T> operator-(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] = -c[i];\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  vector<T> c(a.size() + b.size() - 1, 0);\n  for (int i = 0; i < (int) a.size(); i++) {\n    for (int j = 0; j < (int) b.size(); j++) {\n      c[i + j] += a[i] * b[j];\n    }\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  return a = a * b;\n}\n \ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> x = b * b * a_cut;\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n \ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n \ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T>{1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n \ntemplate <typename T>\nvector<T> derivative(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] *= i;   \t\n  }\n  if (!c.empty()) {\n    c.erase(c.begin());\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> primitive(const vector<T>& a) {\n  vector<T> c = a;\n  c.insert(c.begin(), 0);\n  for (int i = 1; i < (int) c.size(); i++) {\n    c[i] /= i;\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> logarithm(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 1);\n  vector<T> u = primitive(derivative(a) * inverse(a));\n  u.resize(a.size());\n  return u;\n}\n \ntemplate <typename T>\nvector<T> exponent(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 0);\n  int n = (int) a.size();\n  vector<T> b = {1};\n  while ((int) b.size() < n) {\n    vector<T> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x[0] += 1;\n    vector<T> old_b = b;\n    b.resize(b.size() << 1);\n    x -= logarithm(b);\n    x *= old_b;\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<T> multiply(const vector<vector<T>>& a) {\n  if (a.empty()) {\n    return {0};\n  }\n  function<vector<T>(int, int)> mult = [&](int l, int r) {\n    if (l == r) {\n      return a[l];\n    }\n    int y = (l + r) >> 1;\n    return mult(l, y) * mult(y + 1, r);\n  };\n  return mult(0, (int) a.size() - 1);\n}\n\nstruct Combi\n{\n\tvector<int> fact;\n\tvector<int> ifact;\n\tvector<int> inv;\n\tvector<int> pow2;\n\tconst int MOD = 998244353;\n\tint add(int a, int b)\n\t{\n\t\ta+=b;\n\t\twhile(a>=MOD) a-=MOD;\n\t\treturn a;\n\t}\n\tint mult(int a, int b)\n\t{\n\t\treturn (a*1LL*b)%MOD;\n\t}\n\tint modpow(int a, int b)\n\t{\n\t\tint r=1;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1) r=mult(r,a);\n\t\t\ta=mult(a,a);\n\t\t\tb>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tint choose(int a, int b)\n\t{\n\t\tif(a<b) return 0;\n\t\tif(b==0) return 1;\n\t\tif(a==b) return 1;\n\t\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n\t}\n\tint inverse(int a)\n\t{\n\t\treturn modpow(a,MOD-2);\n\t}\n\tvoid init(int _n)\n\t{\n\t\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\t\tfact.resize(_n+1);\n\t\tifact.resize(_n+1);\n\t\tinv.resize(_n+1);\n\t\tpow2.resize(_n+1);\n\t\tpow2[0]=1;\n\t\tifact[0]=1;\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\t\tfact[i]=mult(fact[i-1],i);\n\t\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t\t}\n\t\tifact[_n] = inverse(fact[_n]);\n\t\tfor(int i=_n-1;i>=1;i--)\n\t\t{\n\t\t    ifact[i] = mult(ifact[i + 1], i + 1);\n\t\t}\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t    inv[i] = mult(fact[i-1],ifact[i]);\n\t\t}\n\t}\n};\nCombi combi;\nconst int MOD = 998244353;\n\nint mod_pow(int a, int n, int mod) { int ret = 1; while (n) { if (n & 1) ret = ret *1LL* a % mod; a = a *1LL* a % mod; n >>= 1; } return ret; }\nint inv(int n){return mod_pow(n,MOD-2,MOD);}\nconst int LG = 22;\nconst int root_pw = (1<<LG);\nint iprt,prt;\n \nvoid fft (vector<int> & a, bool invert) \n{\n\tint n = (int) a.size();\n \n\tfor (int i=1, j=0; i<n; ++i) {\n\t\tint bit = n >> 1;\n\t\tfor (; j>=bit; bit>>=1)\n\t\t\tj -= bit;\n\t\tj += bit;\n\t\tif (i < j)\n\t\t\tswap (a[i], a[j]);\n\t}\n \n\tfor (int len=2; len<=n; len<<=1) {\n\t\tint wlen = invert ? iprt : prt;\n\t\tfor (int i=len; i<root_pw; i<<=1)\n\t\t\twlen = int((wlen*1LL*wlen)%MOD);\n\t\tfor (int i=0; i<n; i+=len) {\n\t\t\tint w = 1;\n\t\t\tfor (int j=0; j<len/2; ++j) {\n\t\t\t\tint u = a[i+j]; int v = int((a[i+j+len/2]*1LL*w)%MOD);\n\t\t\t\ta[i+j] = u+v < MOD ? u+v : u+v-MOD;\n\t\t\t\ta[i+j+len/2] = u-v >= 0 ? u-v : u-v+MOD;\n\t\t\t\tw = int (w * 1LL * wlen % MOD);\n\t\t\t}\n\t\t}\n\t}\n\tif (invert) {\n\t\tll nrev = inv(n);\n\t\tfor (int i=0; i<n; ++i)\n\t\t\ta[i] = int((a[i]*1LL*nrev)%MOD);\n\t}\n}\n \nvoid multiply(vector<int>& a, vector<int>& b, vector<int>& res)\n{\n\tvector<int> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n\tint n = 1;\n\twhile(n < max(a.size(), b.size())) n <<= 1;\n\tfa.resize(n); fb.resize(n);\n\tfft(fa, 0); fft(fb, 0);\n\tres.resize(n);\n\tfor(int i = 0; i < n; i++) \n\t{\n\t\tres[i] = int((fa[i]*1LL*fb[i])%MOD);\n\t}\n\tfft(res, 1);\n}\n \nvector<int> inverse(vector<int> &a, int deg) //returns a 2^{deg} polynomial\n{\n\tvector<int> h[2];\n\th[0].pb(mod_pow(a[0],MOD-2,MOD));\n\tint cur=0; int pre=1;\n\tfor(int i=0;i<deg;i++) //after this it'll be of size 2^{deg}\n\t{\n\t\tcur^=1; pre^=1;\n\t\th[cur].resize((1<<(i+1)));\n\t\th[pre].resize((1<<(i+1)));\n\t\tmultiply(h[pre],h[pre],h[cur]);\n\t\tvector<int> pf;\n\t\tpf.assign((1<<(i+1)),0);\n\t\tfor(int j=0;j<min(pf.size(),a.size());j++) pf[j]=a[j];\n\t\th[cur].resize((1<<(i+2))); pf.resize((1<<(i+2)));\n\t\tmultiply(pf,h[cur],h[cur]);\n\t\th[cur].resize((1<<(i+1)));\n\t\tfor(int j=0;j<(1<<i);j++)\n\t\t{\n\t\t\th[cur][j] = combi.add(h[pre][j], combi.add(h[pre][j], MOD - h[cur][j]));\n\t\t}\n\t\tfor(int j=(1<<i);j<(1<<(i+1));j++)\n\t\t{\n\t\t\tif(h[cur][j]!=0) h[cur][j] = MOD - h[cur][j];\n\t\t}\n\t}\n\treturn h[cur];\n}\n \nvector<int> ln(vector<int> &a, int deg)\n{\n\twhile(a.size()<(1<<deg)) a.pb(0);\n\tvector<int> num,denom;\n\tdenom = inverse(a, deg);\n\tnum.resize((1<<deg));\n\tfor(int i = 0; i < (1<<deg); i++)\n\t{\n\t\tif(i+1<a.size())\n\t\t{\n\t\t\tnum[i] = combi.mult(a[i+1], i+1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnum[i] = 0;\n\t\t}\n\t}\n\tnum.resize((1<<(deg+1))); denom.resize((1<<(deg+1)));\n\tvector<int> res;\n\tmultiply(num,denom,res);\n\tres.resize(1<<deg);\n\tvector<int> ans(1<<deg,0);\n\tfor(int i=1;i<(1<<deg);i++)\n\t{\n\t\tans[i]=combi.mult(res[i-1],inv(i));\n\t}\n\treturn ans;\n}\n \nvector<int> exp(vector<int> &a, int deg)\n{\t\n\tvector<int> h[2];\n\th[0].pb(1);\n\tint cur=0; int pre=1;\n\tfor(int i=0;i<deg;i++) //after this it'll be of size 2^{deg}\n\t{\n\t\tcur^=1; pre^=1;\n\t\tvector<int> pf;\n\t\tpf.assign((1<<(i+1)),0);\n\t\tfor(int j=0;j<min(pf.size(),a.size());j++) pf[j]=a[j];\n\t\tpf[0]=combi.add(pf[0],1);\n\t\tvector<int> LN = ln(h[pre],i+1);\n\t\tfor(int j=0;j<(1<<(i+1));j++)\n\t\t{\n\t\t\tpf[j] = combi.add(pf[j], MOD - LN[j]);\n\t\t}\n\t\th[pre].resize((1<<(i+2))); pf.resize((1<<(i+2)));\n\t\tmultiply(pf,h[pre],h[cur]);\n\t\th[cur].resize((1<<(i+1)));\n\t}\n\treturn h[cur];\n}\n \nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcombi.init(500101);\n\tint tmpmult = 7*17;\n\ttmpmult = combi.mult(tmpmult, mod_pow(2, 23 - LG, MOD)); \n\tprt = mod_pow(3, tmpmult, MOD);\n\tiprt = inv(prt);\n\tint n,m; cin>>n>>m;\n\tvector<Mint> a(m+1);\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\ta[i] = combi.mult(m+1-i,combi.ifact[i]);\n\t}\n\t/*\n\tfor(int i=0;i<a.size();i++)\n\t{\n\t\tcerr<<a[i]<<' ';\n\t}\n\tcerr<<'\\n';\n\t*/\n\tvector<Mint> T; int deg=0; bool stp=0;\n\tfor(int i=0;i<a.size();i++)\n\t{\n\t\tif(!stp&&a[i]==0) {deg=i+1; continue;}\n\t\tT.pb(a[i]); stp=1;\n\t}\n\tMint coeff = T[0]; //should be nonempty\n\tMint icoeff = inv(int(T[0]));\n\tT = T*vector<Mint>{icoeff};\n\tvector<Mint> tmpNW = exponent(logarithm(T)*vector<Mint>{n});\n  \tint tt=combi.modpow(int(coeff),n);\n\tfor(int i=0;i<tmpNW.size();i++) tmpNW[i]=combi.mult(int(tmpNW[i]),tt);\n\tvector<Mint> NW(m+1,0);\n \t int cur=min(ll(m+1),ll(n)*ll(deg));\n\tfor(int i=0;i<tmpNW.size();i++)\n\t{\n\t\tif(cur<=m) NW[cur++] = tmpNW[i];\n\t\telse break;\n\t}\n\t/*\n\tfor(int i=0;i<NW.size();i++) cerr<<NW[i]<<' ';\n\tcerr<<'\\n';\n\t*/\n\tint ans=0;\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\tans=combi.add(ans,combi.mult(int(NW[i]),combi.ifact[m-i]));\n\t}\n\tans=combi.mult(ans,combi.fact[m]);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10,lim=1e6,mo=998244353;\nll power(ll a,ll b=mo-2){\n\tll ans=1;\n\twhile (b){\n\t\tif (b&1)ans=ans*a%mo;\n\t\ta=a*a%mo;\n\t\tb>>=1;\n\t}return ans;\n}\nll jc[N],ny[N],n,m,ans;\nll C(ll n,ll m){\n\treturn (ny[m]*ny[n-m]%mo*jc[n])%mo;\n}\nint main(){\n\tcin>>n>>m;\n\tjc[0]=1;\n\tfor (int i=1;i<=lim;i++)jc[i]=jc[i-1]*i%mo;\n\tny[lim]=power(jc[lim]);\n\tfor (int i=lim;i;i--)ny[i-1]=ny[i]*i%mo;\n\tfor (int i=0;i<=n&&i<=m;i++){\n\t\tans=(ans+power(-1,i)*C(n,i)*C(m,i)%mo*jc[i]%mo*power(m+1,n-i)%mo*power(n+1,m-i))%mo;\n\t}\n\tcout<<(ans%mo+mo)%mo<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, _b = y; i <= _b; i ++)\n#define ff(i, x, y) for(int i = x, _b = y; i <  _b; i ++)\n#define fd(i, x, y) for(int i = x, _b = y; i >= _b; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\n#define dub(...) fprintf(stderr, _VA_ARGS)\nusing namespace std;\n\nconst int mo = 998244353;\n\nll ksm(ll x, ll y) {\n\tll s = 1;\n\tfor(; y; y /= 2, x = x * x % mo)\n\t\tif(y & 1) s = s * x % mo;\n\treturn s;\n}\n\nconst int N = 5e5 + 5;\n\nint n, m;\nll fac[N], nf[N];\n\nvoid build(int n) {\n\tfac[0] = 1; fo(i, 1, n) fac[i] = fac[i - 1] * i % mo;\n\tnf[n] = ksm(fac[n], mo - 2); fd(i, n, 1) nf[i - 1] = nf[i] * i % mo;\n}\n\nll C(int n, int m) {\n\tif(n < m) return 0;\n\treturn fac[n] * nf[m] % mo * nf[n - m] % mo;\n}\n\nint main() {\n\tbuild(5e5);\n\tscanf(\"%d %d\", &n, &m);\n\tll ans = 0;\n\tfo(k, 0, min(n, m))\n\t\tans += (k & 1 ? -1 : 1) * C(n, k) * C(m, k) % mo * fac[k] % mo * ksm(m + 1, n - k) % mo * ksm(n + 1, m - k) % mo;\n\tans = (ans % mo + mo) % mo;\n\tpp(\"%lld\\n\", ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconst int P = 998244353;\n\nconst int N = 5e5+5;\n\nint f[N];\nint finv[N];\n\nint nk[N];\nint mk[N];\n\nint n,m;\n\nvoid ex_gcd(int a, int b, int &x, int &y)\n{\n\tif(!b)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn;\n\t}\n\tex_gcd(b,a%b,y,x);\n\ty -= a/b*x;\n}\n\nint getInv(int a)\n{\n\tint x,y;\n\tex_gcd(a,P,x,y);\n\t\n\tx = (x%P+P)%P;\n\n\treturn x;\n}\n\nvoid init()\n{\n\tf[0] = 1;\n\t\n\tint t = max(n,m);\n\t\n\tfor(int i = 1; i <= t; i++)\n\t{\n\t\tf[i] = (f[i-1]*i)%P;\n\t}\n\tfinv[t] = getInv(f[t]) % P;\n\n\tfor(int i = t; i > 0; i--)\n\t{\n\t\tfinv[i-1] = finv[i]*i %P;\n\t}\n\t\n\tnk[0] = 1, mk[0] = 1;\n\tfor(int i = 1; i <= t; i++)\n\t{\n\t\tnk[i] = nk[i-1]*(n+1) % P;\n\t\tmk[i] = mk[i-1]*(m+1) % P;\n\t}\n}\n\nint choose(int a, int b)\n{\n\tint A = f[a]*finv[b] % P;\n\tint B = A*finv[a-b] % P;\n\t\n\tint res = B;\n\n\treturn res; \n}\n\nlong long ans;\n\nint cal(int k)\n{\n\tint res = (( (nk[m-k]*mk[n-k])%P * f[k])%P *(choose(n,k)*choose(m,k))%P) % P;\n\t\n\tint A = nk[m-k]*mk[n-k]%P;\n\tint B = A*f[k] %P;\n\tint C = B*choose(n,k) %P;\n\tint D = C*choose(m,k) %P;\n\tres = D;\n\t\n\tif(k%2)\n\t{\n\t\treturn -res;\n\t}\n\telse\n\t{\n\t\treturn res;\n\t}\n}\n\nvoid debug()\n{\n\tfor(int i = 0; i <= max(n,m); i++)\n\t{\n\t\tprintf(\"f[%lld]=%lld\\n\",i,f[i]);\n\t}\n}\n\nsigned main()\n{\n\tcin >> n >> m;\n\t\n\tinit();\n//\tdebug();\n\t\n\tfor(int i = 0; i <= min(n,m); i++)\n\t{\n\t\tans += cal(i);\n\t\tans %= P;\n//\t\tprintf(\"res[%lld]=%lld\\n\", i, cal(i));\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m;\nlong long inv[500010];\nlong long qpow(long long a,long long b){\n\tlong long ans=1,base=a;\n\twhile(b){\n\t\tif(b&1){\n\t\t\tans*=base;\n\t\t\tans%=998244353;\n\t\t}\n\t\tbase*=base;\n\t\tbase%=998244353;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nlong long cn[500010];\nlong long cm[500010];\nlong long ans;\nlong long jc[500010];\nlong long m_[500010];\nlong long n_[500010];\nint main(){\n\tcin>>n>>m;\n\tinv[1]=1;\n\tfor(long long i=2;i<=max(n,m);i++){\n\t\tinv[i]=(998244353ll-998244353ll/i)*inv[998244353ll%i]%998244353ll;\n\t}\n\tjc[0]=jc[1]=1;\n\tfor(long long i=2;i<=max(n,m);i++){\n\t\tjc[i]=jc[i-1]*i%998244353ll;\n\t}\n\tcn[0]=1;\n\tfor(long long i=0;i<n;i++){\n\t\tcn[i+1]=cn[i]*(n-i)%998244353ll*inv[i+1]%998244353ll;\n\t}\n\tcm[0]=1;\n\tfor(long long i=0;i<m;i++){\n\t\tcm[i+1]=cm[i]*(m-i)%998244353ll*inv[i+1]%998244353ll;\n\t}\n\tm_[0]=n_[0]=1;\n\tfor(long long i=1;i<=max(m,n);i++){\n\t\tm_[i]=m_[i-1]*(m+1)%998244353ll;\n\t\tn_[i]=n_[i-1]*(n+1)%998244353ll;\n\t}\n\tfor(long long i=0;i<=min(n,m);i++){\n\t\tlong long s=cn[i]*cm[i]%998244353ll*jc[i]%998244353ll*m_[n-i]%998244353ll*n_[m-i]%998244353ll;\n\t\tans=i&1?(ans-s):(ans+s);\n\t\tans=(ans%998244353ll+998244353ll)%998244353ll;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint a;\n\tModInt& s(uint vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n    ModInt(ll x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){\n\t\treturn s(a+x.a);\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\treturn s(a+mod-x.a);\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=ull(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt<998244353>;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 5e5 + 1000,mod = 998244353;\nint n,m,mx,mn;\nll ans,jc[N],jcinv[N],inv[N];\nll ksm(ll x,int y){ll res = 1; for(;y;y >>= 1,x = x * x % mod) if(y & 1) res = res * x % mod; return res;}\nll C(int x,int y){if(y < 0 || y > x) return 0; return jc[x] * jcinv[y] % mod * jcinv[x - y] % mod;}\nint main()\n{\n\tn = read(); m = read(); mx = max(m,n); mn = min(m,n);\n\tjc[0] = jc[1] = inv[0] = inv[1] = jcinv[0] = jcinv[1] = 1;\n\tfor(int i = 2;i <= mx;i ++)\n\t{\n\t\tjc[i] = jc[i - 1] * i % mod;\n\t\tinv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\t\tjcinv[i] = jcinv[i - 1] * inv[i] % mod;\n\t}\n\tfor(int i = 0;i <= mn;i ++)\n\t{\n\t\tif(i & 1) ans = (ans + mod - C(n,i) * C(m,i) % mod * ksm(m + 1,n - i) % mod * ksm(n + 1,m - i) % mod * jc[i] % mod) % mod;\n\t\telse ans = (ans + C(n,i) * C(m,i) % mod * ksm(m + 1,n - i) % mod * ksm(n + 1,m - i) % mod * jc[i] % mod) % mod;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconst int P = 998244353;\n\nconst int N = 5e5+5;\n\nint f[N];\nint finv[N];\n\nint nk[N];\nint mk[N];\n\nint n,m;\n\nvoid ex_gcd(int a, int b, int &x, int &y)\n{\n\tif(!b)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn;\n\t}\n\tex_gcd(b,a%b,y,x);\n\ty -= a/b*x;\n}\n\nint getInv(int a)\n{\n\tint x,y;\n\tex_gcd(a,P,x,y);\n\t\n\tx = (x%P+P)%P;\n\n\treturn x;\n}\n\nvoid init()\n{\n\tf[0] = 1;\n\t\n\tint t = max(n,m);\n\t\n\tfor(int i = 1; i <= t; i++)\n\t{\n\t\tf[i] = (f[i-1]*i)%P;\n\t\tif(f[i] < 0) puts(\"WTF1\");\n\t}\n\tfinv[t] = getInv(f[t]) % P;\n\tif(finv[t] < 0)\n\t{\n\t\tputs(\"WTF\");\n\t\tsystem(\"pause\");\n\t}\n\tfor(int i = t; i > 0; i--)\n\t{\n\t\tfinv[i-1] = finv[i]*i %P;\n\t\tif(finv[i-1] < 0) puts(\"WTF2\");\n\t}\n\t\n\tnk[0] = 1, mk[0] = 1;\n\tfor(int i = 1; i <= t; i++)\n\t{\n\t\tnk[i] = nk[i-1]*(n+1) % P;\n\t\tmk[i] = mk[i-1]*(m+1) % P;\n\t\tif(nk[i] < 0 || mk[i] < 0) puts(\"WTF3\");\n\t}\n}\n\nint choose(int a, int b)\n{\n\tint res = f[a] % P * finv[b] % P * finv[a-b] % P;\n\n\treturn res%P; \n}\n\nlong long ans;\n\nint cal(int k)\n{\n\tint res = (( (nk[m-k]*mk[n-k])%P * f[k])%P *(choose(n,k)*choose(m,k))%P) % P;\n\t\n\tint A = nk[m-k]*mk[n-k]%P;\n\tint B = A*f[k] %P;\n\tint C = B*choose(n,k) %P;\n\tint D = C*choose(m,k) %P;\n\tres = D;\n\t\n\tif(k%2)\n\t{\n\t\treturn -res;\n\t}\n\telse\n\t{\n\t\treturn res;\n\t}\n}\n\nvoid debug()\n{\n\tfor(int i = 0; i <= max(n,m); i++)\n\t{\n\t\tprintf(\"f[%lld]=%lld\\n\",i,f[i]);\n\t}\n}\n\nsigned main()\n{\n\tcin >> n >> m;\n\t\n\tinit();\n//\tdebug();\n\t\n\tfor(int i = 0; i <= min(n,m); i++)\n\t{\n\t\tans += cal(i);\n\t\tans %= P;\n//\t\tprintf(\"res[%lld]=%lld\\n\", i, cal(i));\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nint fact[500050],inv[500050];\n\nint qpow(int base,int tms)\n{\n    int tmp = 1;\n    while(tms)\n    {\n        if(tms & 1) tmp = tmp * 1ll * base % mod;\n        base = base * 1ll * base % mod;\n        tms >>= 1;\n    }\n    return tmp;\n}\n\nint C(int n,int r)\n{\n    return fact[n] * 1ll * inv[r] % mod * inv[n - r] % mod;\n}\n\nint main()\n{\n    fact[0] = inv[0] = 1;\n    for(int i = 1;i <= 500000; ++ i)\n        fact[i] = fact[i - 1] * 1ll * i % mod;\n    inv[500000] = qpow(fact[500000],mod - 2);\n    for(int i = 499999;i >= 1; -- i)\n        inv[i] = inv[i + 1] * 1ll * (i + 1) % mod;\n    int n,m; scanf(\"%d%d\",&n,&m);\n    int lim = min(n,m),ans = 0;\n    for(int i = 0,sgn = 1;i <= lim; ++ i,sgn = mod - sgn)\n        ans = (ans + sgn * 1ll * C(n,i) % mod * C(m,i) % mod * qpow(n,m - i) % mod * qpow(m,n - i) % mod) % mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=5e5+5,Mod=998244353;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n,m,Fac[MAXN],iFac[MAXN],ans;\ninline int Fp(int x,int k){int ans=1;for(;k;k>>=1,x=1ll*x*x%Mod)if(k&1)ans=1ll*ans*x%Mod;return ans;}\ninline void pre(int n){\n\tFac[0]=1;Rep(i,1,n)Fac[i]=1ll*Fac[i-1]*i%Mod;\n\tiFac[n]=Fp(Fac[n],Mod-2);Red(i,n,1)iFac[i-1]=1ll*iFac[i]*i%Mod;\n}\ninline int C(int n,int m){return n<0||m<0||n<m?0:1ll*Fac[n]*iFac[m]%Mod*iFac[n-m]%Mod;}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),m=read(),pre(5e5);if(n<m)swap(n,m);\n\tfor(int i=0,opt=1;i<=m;i++,opt=Mod-opt)ans=(ans+1ll*C(n,i)*C(m,i)%Mod*Fac[i]%Mod*Fp(n+1,m-i)%Mod*Fp(m+1,n-i)%Mod*opt)%Mod;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 998244353;\nconst ll INF = 1e18;\nconst int MX = 500005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n    friend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<int SZ> struct Combo {\n    mi smallInv[SZ], fac[SZ], ifac[SZ]; \n    vpi factors; vi cnt[SZ];\n\n    void genInv() {\n        if (sz(factors) == 1 && factors[0].s == 1) {\n            F0R(i,2) smallInv[i] = i;\n            FOR(i,2,SZ) { // use only O(SZ) operations for MOD a prime\n                int x = (MOD+i-1)/i;\n                smallInv[i] = smallInv[i*x-MOD]*x;\n            }\n        } else {\n            F0R(i,SZ) {\n                int x = invGeneral(i,MOD);\n                if (x == -1) smallInv[i] = 0;\n                else smallInv[i] = x;\n            }\n        }\n    }\n    \n    void init() {\n        // factors = factor(MOD); \n        factors = {{MOD,1}}; \n        genInv(); cnt[0] = vi(sz(factors)); fac[0] = ifac[0] = 1;\n        FOR(i,1,SZ) {\n            cnt[i] = cnt[i-1]; int I = i;\n            F0R(j,sz(factors)) while (I % factors[j].f == 0)\n                I /= factors[j].f, cnt[i][j] ++;\n            fac[i] = fac[i-1]*I; ifac[i] = ifac[i-1]*smallInv[I];\n        }\n    }\n\n    mi comb(int a, int b) {\n        if (a < b || b < 0) return 0;\n        auto tmp = fac[a]*ifac[b]*ifac[a-b];\n        F0R(i,sz(factors)) {\n            int t = cnt[a][i]-cnt[a-b][i]-cnt[b][i];\n            tmp *= pow(mi(factors[i].f),t);\n        }\n        return tmp;\n    }\n};\n\nCombo<MX> C;\nint N,M;\n\nint main() {\n\tC.init();\n    setIO(); re(N,M);\n    mi ans = 0;\n    F0R(k,min(M,N)+1) {\n    \tmi ret = C.comb(N,k)*C.comb(M,k)*C.fac[k];\n    \tret *= pow(mi(M+1),N-k)*pow(mi(N+1),M-k);\n    \tif (k%2 == 0) ans += ret;\n    \telse ans -= ret;\n    }\n    ps(ans);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\nV<mint> fact,ifact;\nmint Choose(int a,int b){\n\tif(b<0 || a<b) return 0;\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\nvoid InitFact(int N){\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1] * i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tInitFact(1100000);\n\n\tint H,W;\n\tcin >> H >> W;\n\tmint ans = 0;\n\trep(k,min(H,W)+1){\n\t\tmint tmp = Choose(H,k) * Choose(W,k) * fact[k] * mint(W+1).pow(H-k) * mint(H+1).pow(W-k);\n\t\tif(k&1) ans -= tmp;\n\t\telse ans += tmp;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n/*\nGF(p)\ninverse:O(log p) based on Fermat's little theorem (a^(p-1)=1 mod p)\n*/\n\ntemplate<int32_t mod>\nstruct ModInt{\n\tint32_t a;\n\tModInt(const int64_t a=0):a(a){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\ta=(a<mod)?a:a-mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta-=x.a;\n\t\ta=(a<0)?a+mod:a;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=(int64_t)a*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt x){return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt x){return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt x){return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt x){return ModInt(*this)/=x;}\n\tbool operator==(const ModInt x){return a==x.a;}\n\tbool operator!=(const ModInt x){return a!=x.a;}\n\n\tModInt operator-(){return ModInt(0)-ModInt(*this);}\n\tModInt pow(int64_t ex)const{\n\t\tint64_t x=a;\n\t\tint64_t res=1;\n\t\twhile(ex){\n\t\t\tif(ex&1)res=res*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tex>>=1;\n\t\t}\n\t\treturn ModInt(res);\n\t}\n\tModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<int32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<int32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\n\nusing mint=ModInt<998244353>;\n\n\ntemplate<class Mint>\nstruct Combinations{\n\tint N;\n\tvector<Mint>facts,finvs,invs;\n\tCombinations(int n):N(n),facts(n),finvs(n),invs(n){\n\t\tfacts[0]=finvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tinvs[i]=Mint(i).inv();\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n){return facts[n];}\n\tinline Mint finv(int n){return finvs[n];}\n\tinline Mint inv(int n){return invs[n];}\n\tinline Mint binom(int n,int k){return facts[n]*finvs[k]*finvs[n-k];}\n};\nCombinations<mint>C(555555);\n\n\nsigned main(){\t\n\tint N,M;\n\tcin>>N>>M;\n\n\tvector<mint>poN(555555),poM(555555);\n\tpoN[0]=1;\n\tpoM[0]=1;\n\tfor(int i=1;i<555555;i++){\n\t\tpoN[i]=poN[i-1]*(N+1);\n\t\tpoM[i]=poM[i-1]*(M+1);\n\t}\n\n\tmint ans=0;\n\n\tfor(int i=0;i<=N&&i<=M;i++){\n\t\tauto tmp=C.binom(N,i);\n\t\ttmp*=C.fact(M)*C.finv(M-i);\n\t\ttmp*=poM[N-i];\n\t\ttmp*=poN[M-i];\n\t\tif(i&1)ans-=tmp;\n\t\telse ans+=tmp;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n     if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=500000,N=M+5,mod=998244353;\nll fn[N],fm[N],fac[N],ni[N],ans;\nll ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nll p(int a,int b){\n\treturn fac[a]*ni[a-b]%mod;\n}\nll c(int a,int b){\n\treturn p(a,b)*ni[b]%mod;\n}\nint main(){\n\tFor(i,fac[0]=1,M)fac[i]=fac[i-1]*i%mod;\n\tni[M]=ksm(fac[M],mod-2); Rep(i,M,1)ni[i-1]=ni[i]*i%mod;\n\tint n=read(),m=read();\n\tFor(i,fn[0]=1,m)fn[i]=fn[i-1]*(n+1)%mod;\n\tFor(i,fm[0]=1,n)fm[i]=fm[i-1]*(m+1)%mod;\n\tFor(i,0,min(n,m)){\n\t\tans=(ans+((i&1)?-1:1)*c(n,i)*p(m,i)%mod*fm[n-i]%mod*fn[m-i])%mod;\n\t}\n\tcout<<(ans+mod)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 5e5 + 5;\nconst int   mod = 998244353;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvoid sub(int &a,int b)  {\n    a -= b;\n    if (a <  0)\n        a += mod;\n}\nint mul(int a,int b)    {\n    return  1ll * a * b % mod;\n}\nint Pow(int a,int b)    {\n    int ans = 1;\n    while (b)   {\n        if(b & 1)   ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\nint inv(int a,int p)    {\n    return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;\n}\nint Fac[N];\nint Inv[N];\n\nint Ckn(int n,int k)    {\n    if (n < k)  return  0;\n    if (k < 0)  return  0;\n\n    return  mul(Fac[n],mul(Inv[k],Inv[n - k]));\n}\n\ntypedef pair<int,int>   ii;\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    Fac[0] = Inv[0] = 1;\n\n    for(int i = 1 ; i < N ; ++i)    Fac[i] = mul(Fac[i - 1],i);     Inv[N - 1] = inv(Fac[N - 1],mod);\n    for(int i = N - 2 ; i ; --i)    Inv[i] = mul(Inv[i + 1],i + 1);\n\n    int n;  cin >> n;\n    int m;  cin >> m;\n\n    if (n > m)\n        swap(n,m);\n\n    int ans = 0;\n\n    for(int i = 0 ; i <= n ; ++i)   {\n        int cur = Fac[i];\n\n        cur = mul(cur,Ckn(n,i));\n        cur = mul(cur,Ckn(m,i));\n\n        cur = mul(cur,Pow(n + 1,m - i));\n        cur = mul(cur,Pow(m + 1,n - i));\n\n        if (i & 1)  sub(ans,cur);\n        else        add(ans,cur);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N = 5e5 + 50, P = 998244353; \n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nvoid upd(int &a,int b) { a=add(a,b); } \nint powMod(int a, int k) {\n\tint res = 1; \n\tfor (;k;k >>= 1, a = mul(a, a)) if (k & 1) res = mul(res, a); \n\treturn res;\n}\n\nint n, m, ans, fac[N], inv[N]; \nint Comb(int n, int m) {\n\tif (n < 0 || m > n) return 0; \n\treturn mul(fac[n], mul(inv[m], inv[n - m])); \n}\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\tfreopen(\"d.in\", \"r\", stdin); \n#endif\n\tfac[0] = 1; lop(i, 1, N) fac[i] = mul(fac[i - 1], i); \n\tinv[1] = 1; lop(i, 2, N) inv[i] = mul(P - P / i, inv[P % i]); \n\tinv[0] = 1; lop(i, 1, N) inv[i] = mul(inv[i - 1], inv[i]); \n\tcin >> n >> m; \n\tint flag = 1;\n\trep(p, 0, min(n, m)) {\n\t\tupd(ans, mul(flag, mul(fac[p], mul(mul(Comb(n, p), powMod(m + 1, n - p)), mul(Comb(m, p), powMod(n + 1, m - p)))))); \n\t//\tPr(\"p = %d, coefficient = %d\\n\", p,  mul(mul(Comb(n, p), powMod(m + 1, n - p)), mul(Comb(m, p), powMod(n + 1, m - p))));\n\t\tflag = flag == 1 ? P - 1 : 1;\n\t}\n\tcout << ans << endl;\n\treturn 0; \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=998244353;\ninline int kpow(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)s=1ll*s*a%mod;\n\treturn s;\n}\nint n,m,jc[500050],jcv[500050],ans;\ninline int C(int a,int b)\n{\n\tif(a<b)return 0;\n\treturn 1ll*jc[a]*jcv[b]%mod*jcv[a-b]%mod;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tjc[0]=1;\n\tfor(int i=1;i<=500000;++i)jc[i]=1ll*jc[i-1]*i%mod;\n\tjcv[500000]=kpow(jc[500000],mod-2);\n\tfor(int i=500000;i;--i)jcv[i-1]=1ll*jcv[i]*i%mod;\n\tfor(int i=0;i<=n&&i<=m;++i)\n\t\tif(i&1)ans=(ans+1ll*(mod-C(n,i))*C(m,i)%mod*jc[i]%mod*kpow(n+1,m-i)%mod*kpow(m+1,n-i))%mod;\n\t\telse ans=(ans+1ll*C(n,i)*C(m,i)%mod*jc[i]%mod*kpow(n+1,m-i)%mod*kpow(m+1,n-i))%mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') bo = -1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tres = (res << 1) + (res << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn bo * res;\n}\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = read();\n}\n\ntemplate <typename T, typename... Argv>\nvoid read(T &a, Argv &... argv) {\n\tread(a);\n\tread(argv...);\n}\n\nconst int N = 1e6 + 100, p = 998244353;\nint fac[N], inv[N], _n[N], _m[N];\n\ntemplate <typename T>\nT mul(T x, T y) {\n\treturn 1LL * x * y % p;\n}\n\ntemplate <typename T, typename... Argv>\nT mul(T x, Argv... argv) {\n\treturn mul(x, mul(argv...));\n}\n\nint ksm(int x, int y) {\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nvoid init(int n, int m) {\n\tint M = std::max(n, m);\n\tfac[0] = _n[0] = _m[0] = 1;\n\tfor (int i = 1; i <= M; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[n] = ksm(fac[n], p - 2);\n\tfor (int i = n; i >= 1; --i) inv[i - 1] = mul(inv[i], i);\n\tfor (int i = 1; i <= M; ++i) _n[i] = mul(_n[i - 1], n + 1);\n\tfor (int i = 1; i <= M; ++i) _m[i] = mul(_m[i - 1], m + 1);\n}\n\nint C(int n, int m) {\n\treturn m > n || m < 0 ? 0 : mul(fac[n], inv[m], inv[n - m]);\n}\n\nint main() {\n\tint n = read(), m = read(), ans = 0;\n\tinit(n, m);\n\tfor (int i = 0, opt = 1; i <= n; ++i, opt = p - opt) {\n\t\t(ans += mul(opt, C(n, i), C(m, i), fac[i], _m[n - i], _n[m - i])) %= p;\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=5e5+10,mod=998244353;\nint fac[maxn],inv[maxn],n,m,pwn[maxn],pwm[maxn];\nint qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)ans=1ll*ans*a%mod;\n\treturn ans;\n}\nint C(int x,int y){\n\tif(x<y||y<0)return 0;\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfac[0]=1,inv[0]=1;\n\tpwn[0]=1,pwm[0]=1;\n\tint M=max(n,m);\n\tfor(int i=1;i<=M;++i){\n\t\tpwn[i]=1ll*(n+1)*pwn[i-1]%mod;\n\t\tpwm[i]=1ll*(m+1)*pwm[i-1]%mod;\n\t}\n\tfor(int i=1;i<=M;++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[M]=qpow(fac[M],mod-2);\n\tfor(int i=M-1;i>=1;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tint ans=0;\n\tfor(int i=0;i<=min(n,m);++i){\n\t\tans=(ans+1ll*C(n,i)*C(m,i)%mod*fac[i]%mod*(i&1?mod-1:1)%mod*\n\t\t\tpwn[m-i]%mod*pwm[n-i])%mod;\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\nconst int N=500500,P=998244353;\nint n,m,ans,iv[N],fc[N],vf[N],pn[N],pm[N];\nint C(int x,int y){return 1ll*fc[x]*vf[x-y]%P*vf[y]%P;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tif(n>m) swap(n,m);\n\tiv[1]=fc[0]=vf[0]=pn[0]=pm[0]=1;\n\tFOR(i,2,m) iv[i]=1ll*iv[P%i]*(P-P/i)%P;\n\tFOR(i,1,m) fc[i]=1ll*fc[i-1]*i%P,vf[i]=1ll*vf[i-1]*iv[i]%P;\n\tFOR(i,1,m) pn[i]=1ll*pn[i-1]*(n+1)%P,pm[i]=1ll*pm[i-1]*(m+1)%P;\n\tFOR(i,0,n) (ans+=1ll*(i&1?P-1:1)*C(n,i)%P*C(m,i)%P*fc[i]%P*pn[m-i]%P*pm[n-i]%P)%=P;\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 2e6 + 100 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 998244353 ;\nconst double eps = 1e-7 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nll n, m, ans;\n\nll fac[maxn] = {1}, inv[maxn];\n\nll power(ll a, ll b)\n{\n\tif(b < 0) return 0;\n\tll ret = 1;\n\tfor(; b; b >>= 1, (a *= a) %= mod) if(b & 1) (ret *= a) %= mod;\n\treturn ret;\n}\n\nvoid init()\n{\n\tll N = 2e6;\n\trep(i, 1, N) fac[i] = fac[i - 1] * i % mod;\n\tinv[N] = power(fac[N], mod - 2);\n\tper(i, N, 1) inv[i - 1] = inv[i] * i % mod;\n}\n\nll binom(ll n, ll m)\n{\n\treturn n < m ? 0 : fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nsigned main()\n{\n\tinit();\n\tscanf(\"%lld %lld\", &n, &m);\n\trep(i, 0, n) (ans += binom(n, i) * binom(m, i) % mod * fac[i] % mod * power(m + 1, n - i) % mod * power(n + 1, m - i) % mod * power(mod - 1, i) % mod) %= mod;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=5e5+100,mod=998244353;\nll power(ll n,ll k){\n    if (k==0) return 1;\n    if (k%2==1){\n        ll x=power(n,k/2);\n        return x*x%mod*n%mod;\n    }\n    ll x=power(n,k/2);\n    return x*x%mod;\n}\nll fac[N];\nll fm[N];\nll ent(ll k,ll n){\n    if (k==0 || k==n) return 1;\n    if (k<0 || k>n) return 0;\n    return fac[n]*fm[k]%mod*fm[n-k]%mod;\n}\nint32_t main(){\n    ll n,m;\n    cin >> n >> m;\n    fac[0]=1;\n    for (int i=1;i<N;i++){\n        fac[i]=fac[i-1]*i%mod;\n        fm[i]=power(fac[i],mod-2);\n    }\n    ll ans=power(n+1,m)*power(m+1,n)%mod;\n    for (int i=1;i<=min(m,n);i++){\n        ll z=ent(i,m)*ent(i,n)%mod*fac[i]%mod*power(n+1,m-i)%mod*power(m+1,n-i)%mod;\n        if (i%2) ans-=z;\n        else ans+=z;\n        ans+=mod;\n        ans%=mod;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXDIM=500000;\nconst int MOD=998244353;\n\nconst int PRIMROOT=3;\nvoid inc(int &a,int b) { if((a+=b)>=MOD) a-=MOD; }\nint pw(int x,int n) { int ret=1; while(true) { if(n&1) ret=(ll)ret*x%MOD; if((n>>=1)==0) return ret; x=(ll)x*x%MOD; } }\n\nstruct NTT {\n\tvoid _init(int n,int &nlog,int &g,vector<int> &w) {\n\t\tassert((MOD - 1) % n == 0);\n\t\tg = pw(PRIMROOT, (MOD - 1) / n); nlog = 0; while ((1 << nlog) < n) ++nlog; if ((1 << nlog) != n) nlog = -1;\n\t\tw = vector<int>(n); w[0] = 1; FOR(i, 1, n) w[i] = (ll)w[i - 1]*g%MOD;\n\t}\n\tint fftn, fftnlog; int fftg; vector<int> fftw;\n\tvoid initfft(int n) { fftn = n, _init(fftn, fftnlog, fftg, fftw); assert(fftnlog != -1); }\n\tvoid fft(int *a, int n, bool inv) {\n\t\tif (n != fftn) initfft(n);\n\t\tfor (int i = 1, j = n >> 1, k, l = j; i < n; j ^= k, ++i) { if (i < j) swap(a[i], a[j]); for (k = l; k&j; j ^= k, k >>= 1); }\n\t\tint *l, *r, *w;\n\t\tif (inv) reverse(fftw.begin() + 1, fftw.end());\n\t\tfor (int hlen = 1, step = n >> 1; hlen < n; hlen <<= 1, step >>= 1) {\n\t\t\tfor (int i = 0; i < n; i += (hlen << 1)) {\n\t\t\t\tl = a + i, r = l + hlen, w = fftw.data();\n\t\t\t\tREP(off, hlen) {\n\t\t\t\t\tint v = (ll)(*r)*(*w)%MOD;\n\t\t\t\t\t*r = (*l)-v; if(*r<0) *r+=MOD;\n\t\t\t\t\t*l = (*l)+v; if(*l>=MOD) *l-=MOD;\n\t\t\t\t\t++l, ++r, w += step;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (inv) reverse(fftw.begin() + 1, fftw.end());\n\t\tif (inv) { int mlt = pw(n, MOD - 2); REP(i, n) a[i] = (ll)a[i]*mlt%MOD; }\n\t}\n\tvoid mult(const int *a,int na,const int *b,int nb,int *c,int nc) {\n\t\tint sz=1; while(sz<na+nb-1) sz*=2;\n\t\tvector<int> A(sz,0),B(sz,0);\n\t\tREP(i,na) A[i]=a[i]; REP(i,nb) B[i]=b[i];\n\t\tfft(A.data(),sz,false); fft(B.data(),sz,false); REP(i,sz) A[i]=(ll)A[i]*B[i]%MOD; fft(A.data(),sz,true);\n\t\tREP(i,nc) c[i]=i<sz?A[i]:0;\n\t}\n};\n\nNTT ntt;\n\n\n\nint h,w;\n\n\nint inv[MAXDIM+1];\nint fac[MAXDIM+1];\nint ifac[MAXDIM+1];\n\nvector<int> mult(const vector<int> &a,const vector<int> &b) {\n\tvector<int> ret(SZ(a),0);\n\tntt.mult(a.data(),SZ(a),b.data(),SZ(b),ret.data(),SZ(ret));\n\t//REPSZ(i,a) REPSZ(j,b) if(i+j<SZ(ret)) ret[i+j]=(ret[i+j]+(ll)a[i]*b[j])%MOD;\n\treturn ret;\n}\n\nvector<int> pw(vector<int> x,int n) {\n\tvector<int> ret(SZ(x),0); ret[0]=1;\n\twhile(true) { if(n&1) ret=mult(ret,x); if((n>>=1)==0) return ret; x=mult(x,x); }\n}\n\n\n\nint solve() {\n\tinv[1]=1; FORE(i,2,MAXDIM) inv[i]=(ll)(MOD-MOD/i)*inv[MOD%i]%MOD;\n\tfac[0]=1; FORE(i,1,MAXDIM) fac[i]=(ll)fac[i-1]*i%MOD;\n\tifac[0]=1; FORE(i,1,MAXDIM) ifac[i]=(ll)ifac[i-1]*inv[i]%MOD;\n\n\tvector<int> a(h+1);\n\tREPE(i,h) a[i]=(ll)(h+1-i)*ifac[i]%MOD;\n\t//printf(\"a:\"); REPSZ(i,a) printf(\" %d\",a[i]); puts(\"\");\n\n\tvector<int> b=pw(a,w);\n\t//printf(\"b:\"); REPSZ(i,b) printf(\" %d\",b[i]); puts(\"\");\n\n\tint ret=0;\n\tREPE(i,h) ret=(ret+(ll)b[i]*fac[h]%MOD*ifac[h-i])%MOD;\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d\",&h,&w);\n\tprintf(\"%d\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 14.07.2019 17:15:45       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact;\nvector<Mint> inv_fact;\n\ntemplate <typename T>\nclass NTT {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  static Type md;\n  static Modular<T> root;\n  static int base;\n  static int max_base;\n  static vector<Modular<T>> roots;\n  static vector<int> rev;\n\n  static void clear() {\n    root = 0;\n    base = 0;\n    max_base = 0;\n    roots.clear();\n    rev.clear();\n  }\n\n  static void init() {\n    md = T::value;\n    assert(md >= 3 && md % 2 == 1);\n    auto tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (md - 1) >> 1) == 1) {\n      root++;\n    }\n    assert(power(root, md - 1) == 1);\n    root = power(root, (md - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n\n  static void ensure_base(int nbase) {\n    if (md != T::value) {\n      clear();\n    }\n    if (roots.empty()) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = roots[i] * z;\n      }\n      base++;\n    }\n  }\n\n  static void fft(vector<Modular<T>> &a) {\n    int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          Modular<T> x = a[i + j];\n          Modular<T> y = a[i + j + k] * roots[j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n\n  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n    if (a.empty() || b.empty()) {\n      return {};\n    }\n    int eq = (a == b);\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq) b = a; else fft(b);\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] *= b[i] * inv_sz;\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n};\n\ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\n\ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<Modular<T>> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x.resize(b.size() << 1);\n    b.resize(b.size() << 1);\n    vector<Modular<T>> c = b;\n    NTT<T>::fft(c);\n    NTT<T>::fft(x);\n    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n    fill(x.begin() + (x.size() >> 1), x.end(), 0);\n    NTT<T>::fft(x);\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    for (int i = 0; i < ((int) x.size() >> 1); i++) {\n      b[i + ((int) x.size() >> 1)] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  if (n == 1) {\n    return {1 / a[0]};\n  }\n  int m = (n + 1) >> 1;\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n  int need = n << 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    ++nbase;\n  }\n  NTT<T>::ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  NTT<T>::fft(a);\n  NTT<T>::fft(b);\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n  for (int i = 0; i < size; ++i) {\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  NTT<T>::fft(a);\n  a.resize(n);\n  return a;\n}\n\ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (min(a.size(), b.size()) < 150) {\n    vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        c[i + j] += a[i] * b[j];\n      }\n    }\n    return c;\n  }\n  return NTT<T>::multiply(a, b);\n}\n\ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  return a = a * b;\n}\n\ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n\ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] = -c[i];\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  vector<T> c(a.size() + b.size() - 1, 0);\n  for (int i = 0; i < (int) a.size(); i++) {\n    for (int j = 0; j < (int) b.size(); j++) {\n      c[i + j] += a[i] * b[j];\n    }\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  return a = a * b;\n}\n\ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> x = b * b * a_cut;\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n\ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n\ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T>{1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n\ntemplate <typename T>\nvector<T> derivative(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] *= i;   \t\n  }\n  if (!c.empty()) {\n    c.erase(c.begin());\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> primitive(const vector<T>& a) {\n  vector<T> c = a;\n  c.insert(c.begin(), 0);\n  for (int i = 1; i < (int) c.size(); i++) {\n    c[i] /= i;\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<T> logarithm(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 1);\n  vector<T> u = primitive(derivative(a) * inverse(a));\n  u.resize(a.size());\n  return u;\n}\n \ntemplate <typename T>\nvector<T> exponent(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 0);\n  int n = (int) a.size();\n  vector<T> b = {1};\n  while ((int) b.size() < n) {\n    vector<T> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x[0] += 1;\n    vector<T> old_b = b;\n    b.resize(b.size() << 1);\n    x -= logarithm(b);\n    x *= old_b;\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<T> multiply(const vector<vector<T>>& a) {\n  if (a.empty()) {\n    return {0};\n  }\n  function<vector<T>(int, int)> mult = [&](int l, int r) {\n    if (l == r) {\n      return a[l];\n    }\n    int y = (l + r) >> 1;\n    return mult(l, y) * mult(y + 1, r);\n  };\n  return mult(0, (int) a.size() - 1);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  fact.resize(n + 1);\n  inv_fact.resize(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fact[i] = fact[i - 1] * i;\n  }\n  inv_fact[n] = 1 / fact[n];\n  for (int i = n - 1; i >= 0; i--) {\n    inv_fact[i] = inv_fact[i + 1] * (i + 1);\n  }\n  vector<Mint> poly(n + 1);\n  Mint invm1 = 1 / Mint(n + 1);\n  for (int i = 0; i <= n; i++) {\n    poly[i] = (n + 1 - i) * inv_fact[i] * invm1;\n  }\n  vector<Mint> z = exponent(logarithm(poly) * vector<Mint>{m});\n  Mint ans = 0;\n  for (int i = 0; i <= n; i++) {\n    ans += z[i] * inv_fact[n - i];\n  }\n  ans *= power(Mint(n + 1), m);\n  ans *= fact[n];\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5, mod = 998244353;\nint inv[maxn + 10], fac[maxn + 10], ifac[maxn + 10];\nint pn[maxn + 10], pm[maxn + 10], ans;\nint n, m;\n\nvoid init() {\n\tfac[0] = ifac[0] = pn[0] = pm[0] = 1;\n\tfor (int i = 1; i <= maxn; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tinv[i] = i == 1 ? 1 : mod - 1ll * (mod / i) * inv[mod % i] % mod;\n\t\tifac[i] = 1ll * ifac[i - 1] * inv[i] % mod;\n\t\tpn[i] = 1ll * pn[i - 1] * (n + 1) % mod;\n\t\tpm[i] = 1ll * pm[i - 1] * (m + 1) % mod;\n\t}\n}\n\ninline int comb(int x, int y) {\n\treturn 1ll * fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tinit();\n\tfor (int i = 0; i <= n && i <= m; ++i) {\n\t\tint w = 1ll * comb(n, i) % mod * comb(m, i) % mod * fac[i] % mod;\n\t\tw = 1ll * w * pm[n - i] % mod * pn[m - i] % mod;\n\t\tif (i & 1) ans = (ans - w + mod) % mod;\n\t\telse (ans += w) %= mod;\n\t}\n\tprintf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define LL long long\n#define MAXN 500000\n#define MOD 998244353\nint n,m,F,ans;\nint fac[MAXN+5],inv[MAXN+5],pn[MAXN+5],pm[MAXN+5];\nLL read(){\n   \tLL x=0,F=1;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n   \twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n    return x*F;\n}\nint fst_pow(int a,int b){\n\tint res=1;\n\twhile(b){\n\t\tif(b&1)res=1LL*res*a%MOD;\n\t\ta=1LL*a*a%MOD;\n\t\tb>>=1;\n\t}return res;\n}\nvoid prepare(){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\tfac[i]=1LL*fac[i-1]*i%MOD;\n\tinv[n]=fst_pow(fac[n],MOD-2);\n\tfor(int i=n-1;i>=0;i--)\n\tinv[i]=1LL*inv[i+1]*(i+1)%MOD;\n\tpn[0]=1;for(int i=1;i<=n;i++)pn[i]=1LL*pn[i-1]*(n+1)%MOD;\n\tpm[0]=1;for(int i=1;i<=n;i++)pm[i]=1LL*pm[i-1]*(m+1)%MOD;\n}\nint Comb(int a,int b){\n\treturn 1LL*fac[a]*inv[b]%MOD*inv[a-b]%MOD;\n}\nint main()\n{\n\t//freopen(\"gird.in\",\"r\",stdin);\n\t//freopen(\"gird.out\",\"w\",stdout);\n\tn=read(),m=read();\n\tif(n<m)swap(n,m);\n\tprepare();F=1;\n\tfor(int i=0;i<=m;i++){\n\t\tint tmp=F*(1LL*Comb(n,i)*Comb(m,i)%MOD*pn[m-i]%MOD*pm[n-i]%MOD*fac[i]%MOD)%MOD;\n\t\tans=(ans+(tmp+MOD)%MOD)%MOD;\n\t\tF*=-1;\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\n//uint mod=1;\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint a;\n\tModInt& s(uint vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n    ModInt(ll x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){\n\t\treturn s(a+x.a);\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\treturn s(a+mod-x.a);\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=ull(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt<998244353>;\n\n\n\ntemplate<class Mint,int32_t N>\nstruct ModIntTable{\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n)const{return facts[n];}\n\tinline Mint finv(int n)const{return finvs[n];}\n\tinline Mint inv(int n)const{return invs[n];}\n\tinline Mint binom(int n,int k)const{return facts[n]*finvs[k]*finvs[n-k];}\n};\nModIntTable<mint,1<<19>mtable;\n\n\n\nconst mint prim_root=3;\n\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vector<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tmint in=mint(n).inv();\n\trep(i,n)\n\t\tf[i]*=in;\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\n\n\nvector<mint> multiply(vector<mint> x,vector<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1].v);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*mtable.inv(i+1);\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\t//yosupo judge\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn make_pair(f.low(s),g.low(s));\n\t}\n};\n\nusing poly=Poly<mint>;\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=mtable.finv(i)*in*(N+1-i);\n\t}\n\n\tp=p.log(N+1);\n\trep(i,N+1)p[i]*=M;\n\tp=p.exp(N+1);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*mtable.finv(N-i);\n\t}\n\tans*=mtable.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans.a<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n\twhile(1){\n      cout<<1<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N (500010)\n#define P (998244353)\nusing namespace std;\nint ksm(int a,int p){int res=1;for(;p;p>>=1,a=1ll*a*a%P)if(p&1)res=1ll*res*a%P;return res;}\nint n,m,jc[N],inv[N],ans;\nint C(int n,int m){return 1ll*jc[n]*inv[m]%P*inv[n-m]%P;}\nint main(){\n\tscanf(\"%d%d\",&n,&m),jc[0]=inv[0]=1;\n\tfor(int i=1;i<=max(n,m);i++)jc[i]=1ll*jc[i-1]*i%P,inv[i]=ksm(jc[i],P-2);\n\tfor(int i=0;i<=min(n,m);i++)(ans+=((i&1)?-1ll:1ll)*C(n,i)%P*C(m,i)%P*jc[i]%P*ksm(n+1,m-i)%P*ksm(m+1,n-i)%P)%=P;\n\tprintf(\"%d\\n\",ans<0?ans+P:ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=500100,mod=998244353;\ntypedef long long ll;\nint ksm(ll a,int b,int c=1){\n\tfor(;b;b/=2,a=a*a%mod)\n\t\tif(b&1)c=c*a%mod;\n\treturn c;\n}\nint pn[N],pm[N],jc[N],jc2[N],n,m,ans;\nvoid init(){\n\tjc[0]=1;\n\tfor(int i=1;i<N;++i)jc[i]=(ll)jc[i-1]*i%mod;\n\tjc2[N-1]=ksm(jc[N-1],mod-2);\n\tfor(int i=N-1;i;--i)jc2[i-1]=(ll)jc2[i]*i%mod;\n\tpm[0]=pn[0]=1;\n\tfor(int i=1;i<N;++i)pm[i]=(ll)pm[i-1]*(m+1)%mod,pn[i]=(ll)pn[i-1]*(n+1)%mod;\n}\nint C(int n,int k){\n\tif(n<k||k<0)return 0;\n\treturn (ll)jc[n]*jc2[k]%mod*jc2[n-k]%mod;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>m;init();\n\tfor(int i=0;i<=n;++i){\n\t\tint tmp=(ll)C(n,i)*C(m,i)%mod*jc[i]%mod*pm[n-i]%mod*pn[m-i]%mod;\n\t\tif(i&1)ans=(ans-tmp+mod)%mod;\n\t\telse ans=(ans+tmp)%mod;\n\t}\n\tcout<<ans<<endl;\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=500005,P=998244353;\nint n,m,ans,fac[N],ifac[N];\ninline int pw(int a,int b){int r=1;for(;b;b>>=1,a=1ll*a*a%P)if(b&1)r=1ll*r*a%P;return r;}\ninline int C(int a,int b){return a<0||b<0||a<b?0:1ll*fac[a]*ifac[b]%P*ifac[a-b]%P;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);if(n<m)swap(n,m);\n\tfor(int i=fac[0]=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%P;\n\tifac[n]=pw(fac[n],P-2);\n\tfor(int i=n;i;i--)ifac[i-1]=1ll*ifac[i]*i%P;\n\tfor(int i=0;i<=m;i++)ans=(ans+1ll*(i&1?P-1:1)*C(n,i)%P*C(m,i)%P*fac[i]%P*pw(m+1,n-i)%P*pw(n+1,m-i))%P;\n\tprintf(\"%d\\n\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mo 998244353\n#define N 500010\nusing namespace std;\nll jie[N],nj[N],m,n,ans;\nll po(ll x,ll y){ll z=1;while (y){if(y%2)z=x*z%mo;x=x*x%mo;y/=2;}return z;}\nll C(ll x,ll y){return (jie[x]*nj[y]%mo)*nj[x-y]%mo;}\nint main(){\n\tcin>>n>>m;if (n>m) swap(m,n);\n\tjie[0]=1;for (int i=1;i<=m;i++)jie[i]=jie[i-1]*i%mo;\n\tnj[m]=po(jie[m],mo-2);for (int i=m-1;i>=0;i--)nj[i]=nj[i+1]*(i+1)%mo;\n\tfor (int i=0;i<=n;i++){\n\t\tans=(ans+((((C(m,i)*C(n,i)%mo)*po(m+1,n-i)%mo)*po(n+1,m-i)%mo)*po(mo-1,i)%mo)*jie[i])%mo;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nlong long read() {\n  long long x = 0, w = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) w = ch == '-' ? -1 : 1, ch = getchar();\n  while (isdigit(ch)) {\n    x = (x << 3) + (x << 1) + ch - '0';\n    ch = getchar();\n  }\n  return x * w;\n}\nconst int Max_n = 5e5 + 5, mod = 998244353;\nint n, m, ans;\nint fac[Max_n], ifac[Max_n];\nint f[Max_n];\nint ksm(int a, int b) {\n  int res = 1;\n  for (; b; b >>= 1, a = 1ll * a * a % mod)\n    if (b & 1) res = 1ll * res * a % mod;\n  return res;\n}\nint C(int n, int m) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\nint main() {\n  n = read(), m = read();\n  if (n > m) swap(n, m);\n  fac[0] = ifac[0] = 1;\n  for (int i = 1; i <= m; i++) fac[i] = 1ll * fac[i - 1] * i % mod;\n  ifac[m] = ksm(fac[m], mod - 2);\n  for (int i = m - 1; i; i--) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;\n  for (int i = 0; i <= n; i++) {\n    f[i] = 1ll * C(n, i) * C(m, i) % mod * fac[i] % mod;\n    f[i] = 1ll * f[i] * ksm(m + 1, n - i) % mod * ksm(n + 1, m - i) % mod;\n  }\n  for (int i = 0; i <= n; i++)\n    ans = ((ans + ksm(-1, i & 1) * f[i]) % mod + mod) % mod;\n  cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n    ModInt(int64_t x=0):a((x%mod+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n        if(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=(uint64_t)a*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt x){return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt x){return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt x){return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt x){return ModInt(*this)/=x;}\n\tbool operator==(const ModInt x){return a==x.a;}\n\tbool operator!=(const ModInt x){return a!=x.a;}\n\n\tModInt operator-(){return ModInt(0)-ModInt(*this);}\n\tinline ModInt pow(uint64_t ex)const{\n\t\tuint64_t x=a;\n\t\tuint64_t res=1;\n\t\twhile(ex){\n\t\t\tif(ex&1)res=res*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tex>>=1;\n\t\t}\n\t\treturn ModInt(res);\n\t}\n\n    inline ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\ntemplate<class Mint,int32_t root>\nstruct NumberTheoreticTransform{\n\tstatic void ntt(vector<Mint>&f){\n\t\tint n=f.size();\n        int s=__lg(n);\n\n        for(int i=0,j=1;j<n-1;j++){\n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j)swap(f[i],f[j]);\n        }\n\n        for(int m=1;m<=s;m++){\n            Mint wr=Mint(root).pow(Mint(-1).a>>m);\n            for(int i=0;i<n;i+=1<<m){\n                Mint w=1;\n                for(int j=0;j<1<<m-1;j++){\n                    Mint f0=f[i+j],f1=w*f[i+j+(1<<m-1)];\n                    f[i+j]=f0+f1;\n                    f[i+j+(1<<m-1)]=f0-f1;\n                    w*=wr;\n                }\n            }\n        }\n\t}\n\n    static void intt(vector<Mint>&f){\n        reverse(f.begin()+1,f.end());\n        ntt(f);\n        Mint in=Mint(f.size()).inv();\n        for(int i=0;i<f.size();i++)f[i]*=in;\n    }\n\n\tstatic vector<Mint>convolute(const vector<Mint>&A,const vector<Mint>&B){\n        if(A.size()==0||B.size()==0)return {};\n        int n=1<<__lg(A.size()+B.size()-2)+1;\n        \n        vector<Mint>a=A,b=B;\n        a.resize(n);b.resize(n);\n        ntt(a);\n        ntt(b);\n        for(int i=0;i<n;i++)a[i]*=b[i];\n        intt(a);\n        a.resize(A.size()+B.size()-1);\n        return a;\n    }\n};\nusing NTT=NumberTheoreticTransform<mint,3>;\n\n \ntemplate<class Mint,class Convoluter>\nstruct NTTFriendlyPoly{\n\tvector<Mint>v;\n    inline void normalize(){\n        while(v.size()&&v.back()==0)v.pop_back();\n    }\n\ttemplate<class...Args>\n\tNTTFriendlyPoly(Args...args):v(args...){}\n \n\tNTTFriendlyPoly(const initializer_list<Mint>&in):v(in.begin(),in.end()){}\n \n\tint size()const{return v.size();}\n \n\tinline Mint coef(const int i)const{return (i<v.size())?v[i]:Mint(0);}\n \n\tNTTFriendlyPoly operator+(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)+x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator-(const NTTFriendlyPoly &x){\n\t\tint n=max(size(),x.size());\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=coef(i)-x.coef(i);\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator*(const NTTFriendlyPoly& x){\n\t\treturn Convoluter::convolute(v,x.v);\n\t}\n\tNTTFriendlyPoly operator*(const Mint& x){\n\t\tint n=size();\n\t\tvector<Mint>res(n);\n\t\tfor(int i=0;i<n;i++)res[i]=v[i]*x;\n\t\treturn res;\n\t}\n\tNTTFriendlyPoly operator/(const Mint& x){\n\t\treturn (*this)*x.inv();\n\t}\n \n\tNTTFriendlyPoly& operator+=(const NTTFriendlyPoly& x){return *this=(*this)+x;}\n\tNTTFriendlyPoly& operator-=(const NTTFriendlyPoly& x){return *this=(*this)-x;}\n\tNTTFriendlyPoly& operator*=(const NTTFriendlyPoly& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator*=(const Mint& x){return *this=(*this)*x;}\n\tNTTFriendlyPoly& operator/=(const Mint& x){return *this=(*this)/x;}\n\tNTTFriendlyPoly operator-(){return NTTFriendlyPoly()-*this;}\n \n    NTTFriendlyPoly pre(int n){\n        return {v.begin(),v.begin()+min(n,size())};\n    }\n    NTTFriendlyPoly rev(){\n        vector<Mint>res=v;\n        reverse(res.begin(),res.end());\n        return res;\n    }\n    NTTFriendlyPoly diff(int n){\n        vector<Mint>res(n);\n        for(int i=1;i<size()&&i<=n;i++)res[i-1]=coef(i)*i;\n        return res;\n    }\n    NTTFriendlyPoly inte(int n){\n        vector<Mint>res(n);\n        for(int i=0;i<size()&&i+1<n;i++)res[i+1]=coef(i)/(i+1);\n        return res;\n    }\n\n    NTTFriendlyPoly inv(int n){\n        NTTFriendlyPoly res{coef(0).inv()};\n\n        for(int d=1;d<n;d<<=1){\n            vector<Mint>f(2*d),g(2*d);\n            for(int j=0;j<2*d;j++)f[j]=coef(j);\n            for(int j=0;j<d;j++)g[j]=res[j];\n            \n            Convoluter::ntt(f);Convoluter::ntt(g);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            Convoluter::intt(f);\n            for(int j=0;j<d;j++){\n                f[j]=0;\n                f[j+d]=-f[j+d];\n            }\n            Convoluter::ntt(f);\n            for(int j=0;j<2*d;j++)f[j]*=g[j];\n            Convoluter::intt(f);\n            for(int j=0;j<d;j++)f[j]=res[j];\n            res=f;\n        }\n        return res.pre(n);\n    }\n    \n    /*\n    NTTFriendlyPoly inv2(int n){\n        NTTFriendlyPoly res{coef(0).inv()};\n        for(int i=1;i<n;i*=2){\n            res=(res*Mint(2)-res*res*pre(2*i)).pre(2*i);\n        }\n        return res.pre(n);\n    }\n    */\n    \n\tNTTFriendlyPoly exp(int n){\n\t\tNTTFriendlyPoly f0{1},g0{1};\n\t\tvector<Mint>F0{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tvector<Mint>G0=g0.v;\n\t\t\tConvoluter::ntt(G0);\n\t\t\tvector<Mint>Delta(d);\n\t\t\tfor(int j=0;j<d;j++)Delta[j]=F0[j]*G0[j];\n\t\t\tConvoluter::intt(Delta);\n\t\t\tDelta[0]-=1;\n\t\t\tNTTFriendlyPoly delta(2*d);\n\t\t\tfor(int j=0;j<d;j++)delta[d+j]=Delta[j];\t\t\n\t\t\t\n\t\t\tNTTFriendlyPoly epsilon(2*d);\n\t\t\t\n\t\t\n\t\t\t\n\t\t\tvector<Mint>DF0=f0.diff(d-1).v;DF0.push_back(0);\n\t\t\tConvoluter::ntt(DF0);\n\t\t\tfor(int j=0;j<d;j++)DF0[j]*=G0[j];\n\t\t\tConvoluter::intt(DF0);\n\t\t\tfor(int j=0;j<d-1;j++){\n\t\t\t\tepsilon[j]+=coef(j+1)*(j+1);\n\t\t\t\tepsilon[j+d]+=DF0[j]-coef(j+1)*(j+1);\n\t\t\t}\n\t\t\tepsilon[d-1]+=DF0[d-1];\n\n\n\t\t\tDelta=delta.v;\n\t\t\tConvoluter::ntt(Delta);\n\t\t\tvector<Mint>DH0=diff(d-1).v;DH0.resize(2*d);\n\t\t\tConvoluter::ntt(DH0);\n\t\t\tfor(int j=0;j<2*d;j++)Delta[j]*=DH0[j];\n\t\t\tConvoluter::intt(Delta);\n\t\t\tfor(int j=0;j<d;j++)epsilon[j+d]-=Delta[j+d];\n\t\t\n\n\t\t\tepsilon=epsilon.inte(2*d)-pre(2*d);\n\t\t\t\n\t\t\tvector<Mint>Epsilon=epsilon.v;\n\t\t\tConvoluter::ntt(Epsilon);\n\t\t\trep(j,d)DH0[j]=f0[j],DH0[j+d]=0;\n\t\t\tConvoluter::ntt(DH0);\n\t\t\trep(j,2*d)Epsilon[j]*=DH0[j];\n\t\t\tConvoluter::intt(Epsilon);\n\t\t\tf0.v.resize(2*d);\n\t\t\trep(j,d)f0[j+d]-=Epsilon[j+d];\n\t\t\t//f0=(f0-epsilon*f0).pre(2*d);\n\t\t\t\n\t\t\tG0.resize(2*d);\n\t\t\trep(j,d)G0[j]=g0[j];\n\t\t\tConvoluter::ntt(G0);\n\t\t\tF0=f0.v; \n\t\t\tConvoluter::ntt(F0);\n\t\t\tvector<Mint>T(2*d);rep(j,2*d)T[j]=F0[j]*G0[j];\n\t\t\tConvoluter::intt(T);\n\t\t\trep(j,d){\n\t\t\t\tT[j]=0;\n\t\t\t\tT[j+d]=-T[j+d];\n\t\t\t}\n\t\t\tConvoluter::ntt(T);\n\t\t\trep(j,2*d)T[j]*=G0[j];\n\t\t\tConvoluter::intt(T);\n\t\t\trep(j,d)T[j]=g0[j];\n\t\t\tg0=T;\n\t\t}\n\t\treturn f0.pre(n);\n\t}\n\n    NTTFriendlyPoly exp2(int n){\n        NTTFriendlyPoly f{1};\n        for(int i=1;i<n;i*=2){\n            f=(f*(pre(2*i)-f.log(2*i))+f).pre(2*i);\n        }\n        return f.pre(n);\n    }\n\n\tNTTFriendlyPoly exp3(int n){\n\t\tNTTFriendlyPoly f{1},g{1};\n\t\tfor(int d=1;d<n;d<<=1){\n\t\t\tg=g*Mint(2)-(g*g*f).pre(d);\n\n\t\t\tNTTFriendlyPoly q=diff(d-1);\n\t\t\tq=q+g*(f.diff(d-1)-f*q).pre(2*d-1);\n\t\t\tf=f+(f*(pre(2*d)-q.inte(2*d))).pre(2*d);\n\t\t}\n\t\treturn f.pre(n);\n\t}\n\n\n \n    NTTFriendlyPoly log(int n){\n        return (diff(n-1)*inv(n-1)).inte(n);\n    }\n \n    NTTFriendlyPoly pow(int n,mint k){\n\t\tauto res=log(n);\n\t\tres*=k;\n\t\treturn res.exp(n);\n\t}\n\tMint& operator[](const int i){return v[i];}\n};\nusing poly=NTTFriendlyPoly<mint,NTT>;\n \ntemplate<class Mint,class Convoluter>\nostream& operator<<(ostream& ost,NTTFriendlyPoly<Mint,Convoluter>a){\n    for(int i=0;i<a.size();i++){\n        if(i)cout<<\" \";\n        cout<<a.v[i];\n    }\n    return ost;\n}\n\ntemplate<class Mint>\nstruct Combinations{\n\tint N;\n\tvector<Mint>facts,finvs,invs;\n\tCombinations(int n):N(n),facts(n),finvs(n),invs(n){\n\t\tfacts[0]=finvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tinvs[i]=Mint(i).inv();\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n){return facts[n];}\n\tinline Mint finv(int n){return finvs[n];}\n\tinline Mint inv(int n){return invs[n];}\n\tinline Mint binom(int n,int k){return facts[n]*finvs[k]*finvs[n-k];}\n};\nCombinations<mint>C(555555);\n \nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n \n\tpoly p(N+1);\n \n\tauto in=mint(N+1).inv();\n\tfor(int i=0;i<=N;i++){\n\t\tp[i]=C.finv(i)*in*(N+1-i);\n\t}\n \n\tp=p.pow(N+1,M);\n \n\tmint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tans+=p[i]*C.finv(N-i);\n\t}\n\tans*=C.fact(N);\n\tans*=mint(N+1).pow(M);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define MAXN 500006\nint n , m;\n\nint Pow( int x , int a ) {\n    int ret = 1;\n    while( a ) {\n        if( a & 1 ) ret = 1ll * ret * x % P;\n        x = 1ll * x * x % P , a >>= 1;\n    }\n    return ret;\n}\n\nint J[MAXN] , iJ[MAXN];\n\nint C( int a , int b ) {\n    return J[a] * 1ll * iJ[b] % P * iJ[a] % P;\n}\n\nint main() {\n    J[0] = iJ[0] = 1;\n    for( int i = 1 ; i < MAXN ; ++ i ) J[i] = J[i - 1] * 1ll * i % P , iJ[i] = Pow( J[i] , P - 2 );\n    cin >> n >> m;\n    int lim = min( n , m );\n    int c = 0 , res = 0;\n    for( int i = 0 , zjk ; i <= lim ; ++ i ) {\n        zjk = C( n , i ) * 1ll * C( m , i ) % P * J[i] % P * Pow( n + 1 , m - i ) % P * Pow( m + 1 , n - i ) % P;\n        if( c ) zjk = P - zjk;\n        c ^= 1;\n        res = ( res + zjk ) % P;\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct ModInt{\n\tuint a;\n    ModInt(ll x=0):a((x+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\tuint v=a+x.a;\n\t\ta=v<mod?v:v-mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\tuint v=a+mod-x.a;\n\t\ta=v<mod?v:v-mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=ull(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define N 500005\n#define mod 998244353\n#define ll long long\nll Pow(ll a, ll b)\n{\n\tll ans = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)\n\t\t\tans = ans * a % mod;\n\t\ta = a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\nint n, m, ans;\nint fac[N], inv[N];\nvoid Init(int n)\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\tinv[n] = Pow(fac[n], mod - 2);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\tinv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n}\nint C(int n, int m)\n{\n\tif (n < 0 || m < 0 || m > n)\n\t\treturn 0;\n\treturn 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tif (n < m) swap(n, m);\n\tInit(n);\n\tfor (int k = 0; k <= m; ++k)\n\t{\n\t\tans += 1ll * Pow(-1, k) * C(n, k) % mod * C(m, k) % mod * fac[k] % mod * Pow(m + 1, n - k) % mod * Pow(n + 1, m - k) % mod;\n\t\tans = (ans % mod + mod) % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 14.07.2019 17:15:45       \n**/\n#undef _GLIBCXX_DEBUG\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n \ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n \ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n \nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n \nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n \nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n \nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n \ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n \ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n \ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n \ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n \ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n \nvoid debug_out() { cerr << endl; }\n \ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n \n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n \ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n \ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n \n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n \n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n \n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n \n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n \n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n \n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n \n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n \n private:\n  Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n \ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n \ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n \ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n \ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n \ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n \ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n \ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n \n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n \nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n \nvector<Mint> fact;\nvector<Mint> inv_fact;\n \ntemplate <typename T>\nclass NTT {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  static Type md;\n  static Modular<T> root;\n  static int base;\n  static int max_base;\n  static vector<Modular<T>> roots;\n  static vector<int> rev;\n \n  static void clear() {\n    root = 0;\n    base = 0;\n    max_base = 0;\n    roots.clear();\n    rev.clear();\n  }\n \n  static void init() {\n    md = T::value;\n    assert(md >= 3 && md % 2 == 1);\n    auto tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (md - 1) >> 1) == 1) {\n      root++;\n    }\n    assert(power(root, md - 1) == 1);\n    root = power(root, (md - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n \n  static void ensure_base(int nbase) {\n    if (md != T::value) {\n      clear();\n    }\n    if (roots.empty()) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = roots[i] * z;\n      }\n      base++;\n    }\n  }\n \n  static void fft(vector<Modular<T>> &a) {\n    int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          Modular<T> x = a[i + j];\n          Modular<T> y = a[i + j + k] * roots[j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n \n  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n    if (a.empty() || b.empty()) {\n      return {};\n    }\n    int eq = (a == b);\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq) b = a; else fft(b);\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] *= b[i] * inv_sz;\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n};\n \ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\n \ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<Modular<T>> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x.resize(b.size() << 1);\n    b.resize(b.size() << 1);\n    vector<Modular<T>> c = b;\n    NTT<T>::fft(c);\n    NTT<T>::fft(x);\n    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n    fill(x.begin() + (x.size() >> 1), x.end(), 0);\n    NTT<T>::fft(x);\n    for (int i = 0; i < (int) x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    for (int i = 0; i < ((int) x.size() >> 1); i++) {\n      b[i + ((int) x.size() >> 1)] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  if (n == 1) {\n    return {1 / a[0]};\n  }\n  int m = (n + 1) >> 1;\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n  int need = n << 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    ++nbase;\n  }\n  NTT<T>::ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  NTT<T>::fft(a);\n  NTT<T>::fft(b);\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n  for (int i = 0; i < size; ++i) {\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  NTT<T>::fft(a);\n  a.resize(n);\n  return a;\n}\n \ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (min(a.size(), b.size()) < 150) {\n    vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        c[i + j] += a[i] * b[j];\n      }\n    }\n    return c;\n  }\n  return NTT<T>::multiply(a, b);\n}\n \ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n  return a = a * b;\n}\n \ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n \ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n \ntemplate <typename T>\nvector<T> operator-(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] = -c[i];\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  vector<T> c(a.size() + b.size() - 1, 0);\n  for (int i = 0; i < (int) a.size(); i++) {\n    for (int j = 0; j < (int) b.size(); j++) {\n      c[i + j] += a[i] * b[j];\n    }\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  return a = a * b;\n}\n \ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> x = b * b * a_cut;\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n \ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }\n  }\n  return a;\n}\n \ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n \ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T>{1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n \ntemplate <typename T>\nvector<T> derivative(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] *= i;   \t\n  }\n  if (!c.empty()) {\n    c.erase(c.begin());\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> primitive(const vector<T>& a) {\n  vector<T> c = a;\n  c.insert(c.begin(), 0);\n  for (int i = 1; i < (int) c.size(); i++) {\n    c[i] /= i;\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> logarithm(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 1);\n  vector<T> u = primitive(derivative(a) * inverse(a));\n  u.resize(a.size());\n  return u;\n}\n \ntemplate <typename T>\nvector<T> exponent(const vector<T>& a) {\n  assert(!a.empty() && a[0] == 0);\n  int n = (int) a.size();\n  vector<T> b = {1};\n  while ((int) b.size() < n) {\n    vector<T> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x[0] += 1;\n    vector<T> old_b = b;\n    b.resize(b.size() << 1);\n    x -= logarithm(b);\n    x *= old_b;\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n \ntemplate <typename T>\nvector<T> multiply(const vector<vector<T>>& a) {\n  if (a.empty()) {\n    return {0};\n  }\n  function<vector<T>(int, int)> mult = [&](int l, int r) {\n    if (l == r) {\n      return a[l];\n    }\n    int y = (l + r) >> 1;\n    return mult(l, y) * mult(y + 1, r);\n  };\n  return mult(0, (int) a.size() - 1);\n}\n \nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  fact.resize(n + 1);\n  inv_fact.resize(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fact[i] = fact[i - 1] * i;\n  }\n  inv_fact[n] = 1 / fact[n];\n  for (int i = n - 1; i >= 0; i--) {\n    inv_fact[i] = inv_fact[i + 1] * (i + 1);\n  }\n  vector<Mint> poly(n + 1);\n  Mint invm1 = 1 / Mint(n + 1);\n  for (int i = 0; i <= n; i++) {\n    poly[i] = (n + 1 - i) * inv_fact[i] * invm1;\n  }\n  vector<Mint> z = exponent(logarithm(poly) * vector<Mint>{m});\n  Mint ans = 0;\n  for (int i = 0; i <= n; i++) {\n    ans += z[i] * inv_fact[n - i];\n  }\n  ans *= power(Mint(n + 1), m);\n  ans *= fact[n];\n  cout << ans << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=5e5+5,Mo=998244353;\n\nint pwr(int x,int y) {\n\tint z=1;\n\tfor(;y;y>>=1,x=(ll)x*x%Mo)\n\t\tif (y&1) z=(ll)z*x%Mo;\n\treturn z;\n}\n\nint n,m,fac[N],inv[N],pwn[N],pwm[N];\n\nvoid pre(int N) {\n\tfac[0]=1;fo(i,1,N) fac[i]=(ll)fac[i-1]*i%Mo;\n\tinv[N]=pwr(fac[N],Mo-2);fd(i,N-1,0) inv[i]=(ll)inv[i+1]*(i+1)%Mo;\n\tpwn[0]=1;fo(i,1,N) pwn[i]=(ll)pwn[i-1]*(n+1)%Mo;\n\tpwm[0]=1;fo(i,1,N) pwm[i]=(ll)pwm[i-1]*(m+1)%Mo;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);pre(max(n,m));\n\tint ans=0;\n\tfo(i,0,min(n,m)) (ans+=(ll)(i&1?-1:1)*inv[i]*inv[n-i]%Mo*inv[m-i]%Mo*pwn[m-i]%Mo*pwm[n-i]%Mo)%=Mo;\n\tans=(ll)ans*fac[n]%Mo*fac[m]%Mo;\n\tprintf(\"%d\\n\",(ans+Mo)%Mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int MOD=998244353;\nconst int N=2000005;\n\nint jc[N],inv[N];\nLL C(int n,int m) {\n\treturn (LL)jc[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nLL Pow(LL x,int p) {\n\tif(p==0) return 1;\n\tif(!(p&1)) return Pow(x*x%MOD,p/2);\n\treturn x*Pow(x*x%MOD,p/2)%MOD;\n}\nvoid Init() {\n\tjc[0]=inv[0]=1;\n\tfor(LL i=1;i<N;i++)\n\t\tjc[i]=i*jc[i-1]%MOD;\n\tinv[N-1]=Pow(jc[N-1],MOD-2);\n\tfor(LL i=N-2;i>=1;i--)\n\t\tinv[i]=(i+1)*inv[i+1]%MOD;\n}\nint n,m,lim;\nint ans;\nint main() {\n\tInit();\n\tscanf(\"%d %d\",&n,&m);\n\tint lim=min(n,m);\n\tfor(int i=0;i<=lim;i++)\n\t\tans=(ans+(i&1?-1:1)*C(n,i)*C(m,i)%MOD*jc[i]%MOD*Pow(m+1,n-i)%MOD*Pow(n+1,m-i)%MOD+MOD)%MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=500005,P=998244353;\nint n,m,fac[N],inv[N],ifac[N];\nint C(int k1,int k2){\n\tif(k1<0||k2<0||k1-k2<0)return 0;\n\treturn 1LL*fac[k1]*ifac[k2]%P*ifac[k1-k2]%P;\n}\nint fpow(int k1,int k2){\n\tint k3=1;\n\tfor(;k2;k2>>=1,k1=1LL*k1*k1%P)if(k2&1)k3=1LL*k3*k1%P;\n\treturn k3;\n}\nint main(){\n\tfac[0]=fac[1]=inv[0]=inv[1]=ifac[0]=ifac[1]=1;\n\trep(i,2,N-1)fac[i]=1LL*fac[i-1]*i%P,inv[i]=1LL*(P-P/i)*inv[P%i]%P,ifac[i]=1LL*ifac[i-1]*inv[i]%P;\n\tscanf(\"%d%d\",&n,&m);\n\tif(m<n)swap(n,m);\n\tint pw1=fpow(m+1,n),pw2=fpow(n+1,m);\n\tint ans=0;\n\trep(r,0,n){\n\t\tif(r){\n\t\t\tpw1=1LL*pw1*inv[m+1]%P;\n\t\t\tpw2=1LL*pw2*inv[n+1]%P;\n\t\t}\n\t\t(ans+=(r&1?P-1LL:1LL)*C(n,r)%P*C(m,r)%P*fac[r]%P*pw1%P*pw2%P)%=P;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct ModInt{\n\tuint a;\n    ModInt(ll x=0):a((x%mod+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n        if(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=ull(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=500005,mod=998244353;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint n,m;\nint Fac[N],Inv[N];\nvoid prework(){\n\tint n=N-1;\n\tFac[0]=1;\n\tFor(i,1,n)\n\t\tFac[i]=(LL)Fac[i-1]*i%mod;\n\tInv[n]=Pow(Fac[n],mod-2);\n\tFod(i,n,1)\n\t\tInv[i-1]=(LL)Inv[i]*i%mod;\n}\nint C(int n,int m){\n\tif (m<0||m>n)\n\t\treturn 0;\n\treturn (LL)Fac[n]*Inv[m]%mod*Inv[n-m]%mod;\n}\nint main(){\n\tprework();\n\tn=read(),m=read();\n\tif (n>m)\n\t\tswap(n,m);\n\tint ans=0;\n\tFor(i,0,n){\n\t\tint v=(LL)Pow(m+1,n-i)*Pow(n+1,m-i)%mod;\n\t\tv=(LL)v*C(n,i)%mod*C(m,i)%mod;\n\t\tv=(LL)v*Fac[i]%mod;\n\t\tif (i&1)\n\t\t\tDel(ans,v);\n\t\telse\n\t\t\tAdd(ans,v);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nconst int mo=998244353,N=1e5+5;\nint ksm(int a,int b){\n\tint ans=1;\n\twhile (b){\n\t\tif (b&1) ans=ans*a%mo;\n\t\ta=a*a%mo;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[N],inv[N],f[N];\n\nint C(int a,int b){\n\treturn fac[a]*inv[b]%mo*inv[a-b]%mo;\n}\nsigned main(){\n\tint n,m,ans=0;\n\tscanf(\"%lld%lld\",&n,&m);\n\tfac[0]=1;\n\tfor (int i=1;i<N;++i)\n\t\tfac[i]=(fac[i-1]*i)%mo;\n\tinv[N-1]=ksm(fac[N-1],mo-2);\n\tfor (int i=N-2;i>=0;i--)\n\t\tinv[i]=(inv[i+1]*(i+1))%mo;\n\tif (n>m) std::swap(n,m);\n\tfor (int i=0;i<=n;++i)\n\t\tf[i]=C(n,i)*C(m,i)%mo*fac[i]%mo*ksm(n+1,m-i)%mo*ksm(m+1,n-i)%mo;\n\tfor (int i=0;i<=n;++i)\n\t\t ans=((ans+(1-((i&1)<<1))*f[i])%mo+mo)%mo;\n\tprintf(\"%lld\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll p=998244353;\nll n,m,ans,jc[1000010],ny[1000010];\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y&1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nll C(ll x,ll y){\n\treturn jc[x]*ny[y]%p*ny[x-y]%p;\n}\nint main(){\n\tll i,op;\n\tscanf(\"%lld%lld\",&n,&m);\n\tjc[0]=ny[0]=1;\n\tfor(i=1;i<=max(n,m);i++)jc[i]=jc[i-1]*i%p,ny[i]=ksm(jc[i],p-2)%p;\n\tfor(i=0;i<=min(n,m);i++){\n\t\tif(i%2)op=-1;\n\t\t else op=1;\n\t\tans=(ans+op*C(n,i)%p*C(m,i)%p*jc[i]%p*ksm(n+1,m-i)%p*ksm(m+1,n-i)%p+p)%p;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb push_back\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nconst int P = 998244353, R = 3;\nconst int SZ = 20, N = 1 << SZ;\n\nint Pow(int x, int y) {\n\tint r = 1;\n\twhile (y) {\n\t\tif (y & 1) r = (long long)r * x % P;\n\t\tx = (long long)x * x % P;\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\n\nvoid FFT(int *a, bool f) {\n\tint i, j, k, x, y, z;\n\tj = 0;\n\tfor (i = 1; i < N; i++) {\n\t\tfor (k = N >> 1; j >= k; k >>= 1) j -= k;\n\t\tj += k;\n\t\tif (i < j) {\n\t\t\tk = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = k;\n\t\t}\n\t}\n\tfor (i = 1; i < N; i <<= 1) {\n\t\tx = Pow(f ? Pow(R, P - 2) : R, P / i >> 1);\n\t\tfor (j = 0; j < N; j += i << 1) {\n\t\t\ty = 1;\n\t\t\tfor (k = 0; k < i; k++) {\n\t\t\t\tz = (long long)a[i | j | k] * y % P;\n\t\t\t\ta[i | j | k] = a[j | k] - z;\n\t\t\t\tif (a[i | j | k] < 0) a[i | j | k] += P;\n\t\t\t\ta[j | k] += z;\n\t\t\t\tif (a[j | k] >= P) a[j | k] -= P;\n\t\t\t\ty = (long long)y * x % P;\n\t\t\t}\n\t\t}\n\t}\n\tif (f) {\n\t\tj = Pow(N, P - 2);\n\t\tfor (i = 0; i < N; i++) a[i] = (long long)a[i] * j % P;\n\t}\n}\n\nconst int mod = 998244353;\n\nll pw(ll x, ll y = mod - 2) {\n\tll res = 1;\n\twhile(y) {\n\t\tif(y & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint n, m;\nll F[1000010];\nint V[1<<20|5], VX[1<<20|5];\n\nint main() {\n\tF[0] = 1;\n\tfor(int i=1;i<1000010;i++) F[i] = i * F[i-1] % mod;\n\tscanf(\"%d%d\", &n, &m);\n\tif(m < n) swap(n, m);\n\tfor(int i=0;i<=n;i++) {\n\t\tV[i] = (ll)(n + 1 - i) * pw(F[i]) % mod;\n\t}\n\tVX[0] = 1;\n\twhile(m) {\n\t\tif(m & 1) {\n\t\t\tFFT(V, false); FFT(VX, false);\n\t\t\tfor (int i = 0; i < N; i++) VX[i] = (ll) VX[i] * V[i] % mod;\n\t\t\tFFT(VX, true); FFT(V, true);\n\t\t\tfor(int i=n+1;i<N;i++) VX[i] = 0;\n\t\t}\n\t\tFFT(V, false);\n\t\trep(i, N) V[i] = (ll) V[i] * V[i] % mod;\n\t\tFFT(V, true);\n\t\tfor(int i=n+1;i<N;i++) V[i] = 0;\n\t\tm >>= 1;\n\t}\n\trep(i, N) V[i] = VX[i];\n\tfor(int i=0;i<=n;i++) V[i] = (ll) V[i] * F[n] % mod;\n\tint ans = 0;\n\tfor(int i=0;i<=n;i++) {\n\t\tint t = V[i];\n\t\tans = (ans + (ll)t * pw(F[n-i])) % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-20 08:25:35\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=1000010,mod=998244353;\ni64 power(i64 a,i64 b,i64 p)\n{\n\ti64 r=1;\n\tfor(;b;b>>=1,a=a*a%p) if(b&1) r=r*a%p;\n\treturn r;\n}\ni64 inv(i64 a){ return power(a,mod-2,mod); }\ni64 n,m,f[N],F[N],ans;\ni64 C(i64 a,i64 b){ return b>=0&&a>=b?f[a]*F[b]%mod*F[a-b]%mod:0; }\nint main()\n{\n\tn=read(); m=read(); f[0]=1;\n\tfr(i,1,n+m) f[i]=f[i-1]*i%mod;\n\tF[n+m]=inv(f[n+m]);\n\tfd(i,n+m,1) F[i-1]=F[i]*i%mod;\n\tfr(i,0,std::min(n,m)) ans=(ans+(i&1?-1:1)*C(n,i)*C(m,i)%mod*f[i]%mod*power(n+1,m-i,mod)%mod*power(m+1,n-i,mod))%mod;\n\tprintf(\"%d\\n\",int(ans<0?ans+mod:ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nint fact[500050],inv[500050];\n\nint qpow(int base,int tms)\n{\n    int tmp = 1;\n    while(tms)\n    {\n        if(tms & 1) tmp = tmp * 1ll * base % mod;\n        base = base * 1ll * base % mod;\n        tms >>= 1;\n    }\n    return tmp;\n}\n\nint C(int n,int r)\n{\n    return fact[n] * 1ll * inv[r] % mod * inv[n - r] % mod;\n}\n\nint main()\n{\n    fact[0] = inv[0] = 1;\n    for(int i = 1;i <= 500000; ++ i)\n        fact[i] = fact[i - 1] * 1ll * i % mod;\n    inv[500000] = qpow(fact[500000],mod - 2);\n    for(int i = 499999;i >= 1; -- i)\n        inv[i] = inv[i + 1] * 1ll * (i + 1) % mod;\n    int n,m; scanf(\"%d%d\",&n,&m);\n    int lim = min(n,m),ans = 0;\n    for(int i = 0,sgn = 1;i <= lim; ++ i,sgn = mod - sgn)\n        ans = (ans + sgn * 1ll * C(n,i) % mod * C(m,i) % mod * qpow(n + 1,m - i) % mod * qpow(m + 1,n - i) % mod * fact[i] % mod) % mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 500007 , mo = 998244353;\n\ninline lint powa(lint a,lint t)\n{\n\tlint b=1;\n\twhile(t){if(t&1)b=b*a%mo;a=a*a%mo,t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a)\n{\n\treturn powa(a,mo-2);\n}\n\nlint jc[_],rjc[_];\n\ninline void fuck(int n=_-1)\n{\n\tjc[0]=jc[1]=rjc[0]=1;\n\tfor(int i=2;i<=n;i++)jc[i]=jc[i-1]*i%mo;\n\trjc[n]=inva(jc[n]);\n\tfor(int i=n-1;i>=1;i--)rjc[i]=rjc[i+1]*(1ll+i)%mo;\n}\n\ninline lint C(int n,int m)\n{\n\tif(n<m || n<0 || m<0)return 0;\n\treturn jc[n]*rjc[m]%mo*rjc[n-m]%mo;\n}\n\nint n,m;\n\nint main()\n{\n\tn=ty(),m=ty();\n\tif(n>m)swap(n,m);\n\n\tfuck();\n\n\tlint ans=0;\n\tfor(int i=0;i<=n;i++)\n\t\tans=(ans+C(n,i)*C(m,i)%mo*jc[i]%mo*powa(n+1,m-i)%mo*powa(m+1,n-i)%mo*(i&1?mo-1:1)%mo)%mo;\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 500500\n\nint n, m, fac[N], rfac[N], ri[N];\nconst int mod = 998244353;\n\ninline int C(int n, int m) {\n    if (n < m) return 0;\n    return 1ll * rfac[m] * rfac[n-m] % mod * fac[n] % mod;\n}\n\nint powmod(int x, int n) {\n    int rlt = 1;\n    while (n) {\n        if (n & 1) rlt = 1ll * rlt * x % mod;\n        x = 1ll * x * x % mod, n >>= 1;\n    }\n    return rlt;\n}\n\nint main() {\n    fac[0] = rfac[0] = ri[1] = 1;\n    for (int i = 1; i < N; i ++) {\n        fac[i] = 1ll * i * fac[i-1] % mod;\n        if (i > 1) ri[i] = 1ll * (mod - mod / i) * ri[mod%i] % mod;\n        rfac[i] = 1ll * ri[i] * rfac[i-1] % mod;\n    }\n    scanf(\"%d %d\", &n, &m);\n    int rlt = 0;\n    for (int k = 0, pn = powmod(n + 1, m), pm = powmod(m + 1, n), sg = 1; k <= min(n, m); k ++) {\n        rlt = (rlt + 1ll * C(n, k) * C(m, k) % mod * pn % mod * pm % mod * sg * fac[k]) % mod;\n        sg *= -1, pn = 1ll * pn * ri[n+1] % mod, pm = 1ll * pm * ri[m+1] % mod;\n    }\n    if (rlt < 0) rlt += mod;\n    printf(\"%d\\n\", rlt);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\nconst int N = 5e5 + 5, mod = 998244353;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nint n, m, ans, fac[N], inv[N];\nint ksm(int x, int y) {\n\tint res = 1;\n\tfor( ; y; x = x * x % mod, y >>= 1) {\n\t\tif(y & 1) res = res * x % mod;\n\t}\n\treturn res;\n}\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n; ++ i) fac[i] = fac[i - 1] * i % mod;\n\tinv[n] = ksm(fac[n], mod - 2);\n\tfor(int i = n - 1; i >= 0; -- i) inv[i] = inv[i + 1] * (i + 1) % mod;\n}\nint C(int n, int m) {return n < m ? 0 : fac[n] * inv[m] % mod * inv[n - m] % mod;}\nsigned main() {\n\tn = read(); m = read();\n\tif(n > m) swap(n, m); init(5e5);\n\tfor(int k = 0; k <= n; ++ k) {\n\t\tint tmp = C(n, k) % mod * C(m, k) % mod * fac[k] % mod* ksm(m + 1, n - k) % mod * ksm(n + 1, m - k) % mod;\n\t\tif(k & 1) ans = (ans - tmp + mod) % mod;\n\t\telse ans = (ans + tmp) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register\nconst int mod=998244353;\nint ex(re int a,re int b)\n{\n\tre int ans=1;\n\tfor(;b;b>>=1,a=(long long)a*a%mod)if(b&1)ans=(long long)ans*a%mod;\n\treturn ans;\n}\nint main()\n{\n\tre int n,m,ans=0,jx=1;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(re int i=0;i<=n&&i<=m;i++)\n\t{\n\t\tre int num=(long long)ex(n+1,m-i)*ex(m+1,n-i)%mod*jx%mod;//printf(\"**%d %d %d\\n\",i,num,jx);\n\t\tif(i&1)ans=(ans+mod-num)%mod;\n\t\telse ans=(ans+num)%mod;\n\t\tjx=(long long)jx*(n-i)%mod*(m-i)%mod*ex(i+1,mod-2)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=500008,p=998244353;\nint read(){\n    int f=1,g=0;char ch=getchar();\n    for (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n    for (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n    return f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nint n,m,L,ans,po[N],inv[N],fa[N],fb[N];\nvoid check(int &x,int y){if ((x+=y)>=p) x-=p;}\nint main(){\n\tn=read();m=read();L=max(n,m);\n\tpo[0]=fa[0]=fb[0]=1;\n\tfor (int i=1;i<=L;i++){\n\t\tpo[i]=(ll)po[i-1]*i%p;\n\t\tfa[i]=(ll)fa[i-1]*(n+1)%p;\n\t\tfb[i]=(ll)fb[i-1]*(m+1)%p;\n\t}\n\tinv[L]=qpow(po[L],p-2);\n\tfor (int i=L;i;i--) inv[i-1]=(ll)inv[i]*i%p;\n\tans=0;\n\tfor (int k=0;k<=min(n,m);k++){\n\t\tint t=(ll)po[n]*po[m]%p*inv[n-k]%p*inv[m-k]%p*inv[k]%p*fa[m-k]%p*fb[n-k]%p;\n\t\tcheck(ans,(k&1) ? (p-t) : t);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n/*\nGF(p)\ninverse:O(log p) based on Fermat's little theorem (a^(p-1)=1 mod p)\n*/\n\ntemplate<int32_t mod>\nstruct ModInt{\n\tint32_t a;\n\tinline int32_t normalize(int64_t x){\n\t\tx%=mod;\n\t\tif(x<0)x+=mod;\n\t\treturn x;\n\t}\n\tModInt(const int64_t a=0):a(normalize(a)){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta-=x.a;\n\t\tif(a<0)a+=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=(int64_t)a*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt x){return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt x){return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt x){return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt x){return ModInt(*this)/=x;}\n\tbool operator==(const ModInt x){return a==x.a;}\n\tbool operator!=(const ModInt x){return a!=x.a;}\n\n\tModInt operator-(){return ModInt(0)-ModInt(*this);}\n\tModInt pow(int64_t ex)const{\n\t\tint64_t x=a;\n\t\tint64_t res=1;\n\t\twhile(ex){\n\t\t\tif(ex&1)res=res*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tex>>=1;\n\t\t}\n\t\treturn ModInt(res);\n\t}\n\tModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<int32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<int32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\n\nusing mint=ModInt<998244353>;\n\n\ntemplate<class Mint>\nstruct Combinations{\n\tint N;\n\tvector<Mint>facts,finvs,invs;\n\tCombinations(int n):N(n),facts(n),finvs(n),invs(n){\n\t\tfacts[0]=finvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tinvs[i]=Mint(i).inv();\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n){return facts[n];}\n\tinline Mint finv(int n){return finvs[n];}\n\tinline Mint inv(int n){return invs[n];}\n\tinline Mint binom(int n,int k){return facts[n]*finvs[k]*finvs[n-k];}\n};\nCombinations<mint>C(555555);\n\n\nsigned main(){\t\n\tint N,M;\n\tcin>>N>>M;\n\n\tvector<mint>poN(555555),poM(555555);\n\tpoN[0]=1;\n\tpoM[0]=1;\n\tfor(int i=1;i<555555;i++){\n\t\tpoN[i]=poN[i-1]*(N+1);\n\t\tpoM[i]=poM[i-1]*(M+1);\n\t}\n\n\tmint ans=0;\n\n\tfor(int i=0;i<=N&&i<=M;i++){\n\t\tauto tmp=C.binom(N,i);\n\t\ttmp*=C.fact(M)*C.finv(M-i);\n\t\ttmp*=poM[N-i];\n\t\ttmp*=poN[M-i];\n\t\tif(i&1)ans-=tmp;\n\t\telse ans+=tmp;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 500005;\nconst ll MOD = 998244353;\n\nint n, m;\nll fac[MX], faci[MX], inv[MX], pwn[MX], pwm[MX];\n\nvoid init()\n{\n\tint x = max(n, m);\n\tfac[0] = faci[0] = inv[0] = inv[1] = pwn[0] = pwm[0] = 1;\n\tfor(int i=1; i<=x; i++)\n\t{\n\t\tfac[i] = fac[i-1] * i % MOD;\n\t\tif(i > 1) inv[i] = (MOD*MOD-(MOD/i)*inv[MOD%i]) % MOD;\n\t\tfaci[i] = faci[i-1] * inv[i] % MOD;\n\t\tpwn[i] = pwn[i-1] * (n+1) % MOD;\n\t\tpwm[i] = pwm[i-1] * (m+1) % MOD;\n\t}\n}\n\nvoid work()\n{\n\tll ans = 0;\n\tauto C = [=](int x, int y){return fac[x]*faci[y]%MOD*faci[x-y]%MOD;};\n\tfor(int i=0; i<=min(n, m); i++)\n\t{\n\t\tll coe = (i&1) ? (MOD-1) : (+1);\n\t\tans = (ans + coe*C(n, i)%MOD*C(m, i)%MOD*pwn[m-i]%MOD*pwm[n-i]%MOD*fac[i]) % MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define re register\n#define ull unsigned ll\nusing namespace std;\ninline int read(){\n\tint s=0,t=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')t=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();\n\treturn s*t;\n}\nconst int N=5e5+5;\nconst int P=998244353;\nint n,m,Ans,fac[N],inv[N],fn[N],fm[N];\nint ksm(int x,int k){\n\tint res=1;\n\twhile(k){\n\t\tif(k&1)res=1ll*res*x%P;\n\t\tx=1ll*x*x%P,k>>=1;\n\t}return res;\n}\nvoid Pre(int Lim){\n\tfac[0]=1;for(int i=1;i<=Lim;i++)fac[i]=1ll*fac[i-1]*i%P;\n\tinv[Lim]=ksm(fac[Lim],P-2);for(int i=Lim;i>=1;i--)inv[i-1]=1ll*inv[i]*i%P;\n\tfn[0]=1;for(int i=1;i<=Lim;i++)fn[i]=1ll*fn[i-1]*(n+1)%P;\n\tfm[0]=1;for(int i=1;i<=Lim;i++)fm[i]=1ll*fm[i-1]*(m+1)%P;\n}\nint C(int n,int m){return (n<m||m<0)?0:1ll*fac[n]*inv[m]%P*inv[n-m]%P;}\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tn=read(),m=read(),Pre(5e5);\n\tfor(int i=0;i<=n;i++){\n\t\tint t0=1ll*(i&1?P-1:1)*C(n,i)%P*C(m,i)%P;\n\t\tint t1=1ll*fac[i]%P*fn[m-i]%P*fm[n-i]%P;\n\t\tAns=(Ans+1ll*t0*t1%P)%P;\n\t}printf(\"%d\",Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 500005;\nconst ll MOD = 998244353;\nll fac[MAXN], invfac[MAXN];\nll binom(ll a, ll b) {\n\tif (b < 0) return 0;\n\tif (b > a) return 0;\n\treturn (((fac[a] * invfac[b]) % MOD) * invfac[a - b]) % MOD;\n}\nll modex(ll a, ll p, ll m = MOD) {\n\tif (!p) return 1;\n\tif (p & 1) return a * modex(a, p - 1, m) % m;\n\tll v = modex(a, p >> 1, m);\n\treturn v * v % m;\n}\nll pown[MAXN], powm[MAXN];\nint main() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\tinvfac[MAXN - 1] = modex(fac[MAXN - 1], MOD - 2);\n\tfor (int i = MAXN - 2; i >= 0; --i)\n\t\tinvfac[i] = invfac[i + 1] * (i + 1) % MOD;\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tpowm[0] = pown[0] = 1;\n\tfor (int i = 1; i <= n; ++i) powm[i] = powm[i - 1] * (m + 1) % MOD;\n\tfor (int i = 1; i <= m; ++i) pown[i] = pown[i - 1] * (n + 1) % MOD;\n\tll ans = pown[m] * powm[n] % MOD;\n\tfor (int k = 1; k <= min(n, m); ++k) {\n\t\tll v = binom(m, k) * fac[n] % MOD * invfac[n - k] % MOD * pown[m - k] % MOD * powm[n - k] % MOD;\n\t\tif (k & 1) ans -= v;\n\t\telse ans += v;\n\t\tans %= MOD;\n\t}\n\tif (ans < 0) ans += MOD;\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "Text",
    "code": "Are you kidding me ? "
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final long MODULO = 998244353;\n        static long[] invs;\n        static long[] facts;\n        static long[] invfacts;\n\n        static {\n            int k = (int) 5e5;\n            invs = new long[k + 2];\n            invs[1] = 1;\n            for (int i = 2; i <= k + 1; ++i) {\n                invs[i] = ((MODULO - (MODULO / i) * (long) invs[(int) (MODULO % i)] % MODULO) % MODULO);\n            }\n            facts = new long[k + 2];\n            invfacts = new long[k + 2];\n            facts[0] = 1;\n            invfacts[0] = 1;\n            for (int i = 1; i <= k + 1; ++i) {\n                facts[i] = (facts[i - 1] * (long) i % MODULO);\n                invfacts[i] = (invfacts[i - 1] * (long) invs[i] % MODULO);\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int height = in.nextInt();\n            int width = in.nextInt();\n            long[] ph = new long[width + 1];\n            ph[0] = 1;\n            for (int i = 1; i < ph.length; ++i) {\n                ph[i] = ph[i - 1] * (height + 1) % MODULO;\n            }\n            long[] pw = new long[height + 1];\n            pw[0] = 1;\n            for (int i = 1; i < pw.length; ++i) {\n                pw[i] = pw[i - 1] * (width + 1) % MODULO;\n            }\n            long res = 0;\n            for (int common = 0; common <= height && common <= width; ++common) {\n                long ways = facts[height] * invfacts[common] % MODULO * invfacts[height - common] % MODULO\n                        * facts[width] % MODULO * invfacts[width - common] % MODULO\n                        * ph[width - common] % MODULO * pw[height - common] % MODULO;\n                if (common % 2 == 0) {\n                    res += ways;\n                } else {\n                    res -= ways;\n                }\n            }\n            res %= MODULO;\n            if (res < 0) res += MODULO;\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            PrimeFastFourierTransform fft = new PrimeFastFourierTransform(MiscUtils.MODF);\n            long[] res = new long[n + 1];\n            long[] revFac = IntegerUtils.generateReverseFactorials(n + 1, MiscUtils.MODF);\n            for (int i = 0; i <= n; i++) {\n                res[i] = (n + 1 - i) * revFac[i] % MiscUtils.MODF;\n            }\n            long[] ans1 = new long[n + 1];\n            fft.power(ans1, res, m);\n            long[] ans = new long[n + 1];\n            long[] next = new long[n + 1];\n            ans[0] = 1;\n            long[] ansNext = new long[n + 1];\n            for (int i = 0; (1 << i) <= m; i++) {\n                if ((m >> i & 1) == 1) {\n                    fft.multiply(ansNext, ans, res, n + 1);\n                    long[] temp = ans;\n                    ans = ansNext;\n                    ansNext = temp;\n                }\n                fft.multiply(next, res, res, n + 1);\n                long[] temp = res;\n                res = next;\n                next = temp;\n            }\n            long answer = 0;\n            for (int i = 0; i <= n; i++) {\n                answer += ans[i] * revFac[n - i] % MiscUtils.MODF;\n            }\n            answer *= IntegerUtils.factorial(n, MiscUtils.MODF);\n            answer %= MiscUtils.MODF;\n            out.printLine(answer);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class IntegerUtils {\n        private static long _x;\n        private static long _y;\n\n        public static long trueMod(long a, long b) {\n            a %= b;\n            a += b;\n            a %= b;\n            return a;\n        }\n\n        public static long factorial(int n, long mod) {\n            long result = 1;\n            for (int i = 2; i <= n; i++) {\n                result = result * i % mod;\n            }\n            return result % mod;\n        }\n\n        public static long power(long base, long exponent, long mod) {\n            if (base >= mod) {\n                base %= mod;\n            }\n            if (exponent == 0) {\n                return 1 % mod;\n            }\n            long result = power(base, exponent >> 1, mod);\n            result = result * result % mod;\n            if ((exponent & 1) != 0) {\n                result = result * base % mod;\n            }\n            return result;\n        }\n\n        public static long reverse(long number, long modulo) {\n            extGcd(number, modulo);\n            return trueMod(_x, modulo);\n        }\n\n        private static long extGcd(long a, long b) {\n            if (a == 0) {\n                _x = 0;\n                _y = 1;\n                return b;\n            }\n            long d = extGcd(b % a, a);\n            long nx = _y - (b / a) * _x;\n            _y = _x;\n            _x = nx;\n            return d;\n        }\n\n        public static long[] generateReverse(int upTo, long module) {\n            long[] result = new long[upTo];\n            if (upTo > 1) {\n                result[1] = 1;\n            }\n            for (int i = 2; i < upTo; i++) {\n                result[i] = (module - module / i * result[((int) (module % i))] % module) % module;\n            }\n            return result;\n        }\n\n        public static long[] generateReverseFactorials(int upTo, long module) {\n            long[] result = generateReverse(upTo, module);\n            if (upTo > 0) {\n                result[0] = 1;\n            }\n            for (int i = 1; i < upTo; i++) {\n                result[i] = result[i] * result[i - 1] % module;\n            }\n            return result;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class PrimeFastFourierTransform {\n        private final long MOD;\n        private final long root;\n        private final long reverseRoot;\n        private int rootPower;\n        private long[] aa;\n        private long[] bb;\n\n        public PrimeFastFourierTransform(long MOD) {\n            this.MOD = MOD;\n            rootPower = 1;\n            int pw = 0;\n            while ((MOD - 1) % (2 * rootPower) == 0) {\n                rootPower *= 2;\n                pw++;\n            }\n            for (int i = 2; ; i++) {\n                if (IntegerUtils.power(i, IntegerUtils.power(2, pw - 1, MOD - 1), MOD) != 1 &&\n                        IntegerUtils.power(i, IntegerUtils.power(2, pw, MOD - 1), MOD) == 1) {\n                    root = i;\n                    reverseRoot = IntegerUtils.reverse(i, MOD);\n                    break;\n                }\n            }\n        }\n\n        public void multiply(long[] result, long[] first, long[] second, int length) {\n            int resultSize = Integer.highestOneBit(result.length - 1) << 2;\n            resultSize = Math.max(resultSize, 4);\n            if (aa == null || aa.length < resultSize) {\n                aa = new long[resultSize];\n                bb = new long[resultSize];\n            }\n            Arrays.fill(aa, 0, resultSize, 0);\n            Arrays.fill(bb, 0, resultSize, 0);\n            for (int i = 0; i < length; i++) {\n                aa[i] = first[i];\n            }\n            for (int i = 0; i < length; i++) {\n                bb[i] = second[i];\n            }\n            fft(aa, false, resultSize);\n            if (first == second) {\n                System.arraycopy(aa, 0, bb, 0, resultSize);\n            } else {\n                fft(bb, false, resultSize);\n            }\n            for (int i = 0; i < resultSize; i++) {\n                aa[i] *= bb[i];\n                aa[i] %= MOD;\n            }\n            fft(aa, true, resultSize);\n            for (int i = 0; i < result.length; i++) {\n                result[i] = aa[i] % MOD;\n            }\n\n        }\n\n        public void power(long[] result, long[] arg, long exponent) {\n            int resultSize = Integer.highestOneBit(result.length - 1) << 2;\n            resultSize = Math.max(resultSize, 4);\n            if (aa == null || aa.length < resultSize) {\n                aa = new long[resultSize];\n                bb = new long[resultSize];\n            }\n            Arrays.fill(aa, 0, resultSize, 0);\n            for (int i = 0; i < result.length; i++) {\n                aa[i] = arg[i];\n            }\n            fft(aa, false, resultSize);\n            for (int i = 0; i < resultSize; i++) {\n                aa[i] = IntegerUtils.power(aa[i], exponent, MOD);\n            }\n            fft(aa, true, resultSize);\n            long delta = IntegerUtils.reverse(IntegerUtils.power(resultSize, exponent - 2, MOD), MOD);\n            for (int i = 0; i < resultSize; i++) {\n                aa[i] = aa[i] * delta % MOD;\n            }\n            for (int i = 0; i < result.length; i++) {\n                result[i] = aa[i] % MOD;\n            }\n        }\n\n        private void fft(long[] array, boolean invert, int size) {\n            for (int i = 1, j = 0; i < size; ++i) {\n                int bit = size >> 1;\n                for (; j >= bit; bit >>= 1) {\n                    j -= bit;\n                }\n                j += bit;\n                if (i < j) {\n                    long temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n\n            for (int len = 2; len <= size; len <<= 1) {\n                long wlen = invert ? reverseRoot : root;\n                for (int i = len; i < rootPower; i <<= 1) {\n                    wlen = wlen * wlen % MOD;\n                }\n                int half = len >> 1;\n                for (int i = 0; i < size; i += len) {\n                    long w = 1;\n                    for (int j = 0; j < half; ++j) {\n                        long u = array[i + j], v = array[i + j + half] * w % MOD;\n                        array[i + j] = u + v < MOD ? u + v : u + v - MOD;\n                        array[i + j + half] = u - v >= 0 ? u - v : u - v + MOD;\n                        w = w * wlen % MOD;\n                    }\n                }\n            }\n            if (invert) {\n                long reverseSize = IntegerUtils.reverse(size, MOD);\n                for (int i = 0; i < size; ++i) {\n                    array[i] = array[i] * reverseSize % MOD;\n                }\n            }\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MODF = 998244353;\n\n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nstruct ModInt(long M) {\n  long x;\n  this(in ModInt a) { x = a.x; }\n  this(in long a) { x = a % M; if (x < 0) x += M; }\n  ModInt opUnary(string op)() if (op == \"-\") { return ModInt(-x); }\n  ref ModInt opOpAssign(string op)(in ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x *= a.x; x %= M; }\n    else static assert(false);\n    return this;\n  }\n  ModInt opOpAssign(string op)(in long a) { return mixin(\"this \" ~ op ~ \"= ModInt(a)\"); }\n  ModInt opBinary(string op, T)(in T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(in long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\nenum long MO = 998244353;\nalias Mint = ModInt!MO;\nenum LIM = 3 * 10^^6;\n\nlong[] inv, fac, invFac;\nvoid prepare() {\n  inv = new long[LIM];\n  fac = new long[LIM];\n  invFac = new long[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = MO - ((MO / i) * inv[cast(size_t)(MO % i)]) % MO;\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = (fac[i - 1] * i) % MO;\n    invFac[i] = (invFac[i - 1] * inv[i]) % MO;\n  }\n}\nlong binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] % MO * invFac[cast(size_t)(n - k)] % MO;\n  } else {\n    return 0;\n  }\n}\n\n\nvoid main() {\n  /*\n  foreach (m; 1 .. 10 + 1) foreach (n; 1 .. 10 + 1) if (m * n <= 16) {\n    int[][][] as;\n    int cnt;\n    foreach (p; 0 .. (n + 1)^^m) foreach (q; 0 .. (m + 1)^^n) {\n      auto a = new int[][](m, n);\n      bool ok = true;\n      foreach (x; 0 .. m) foreach (y; 0 .. n) {\n        const k = p / (n + 1)^^x % (n + 1);\n        const l = q / (m + 1)^^y % (m + 1);\n        ok = ok && !(k == y && l == x + 1);\n        if (y < k) ++a[x][y];\n        if (x < l) ++a[x][y];\n      }\n      as ~= a;\n      if (ok) {\n        ++cnt;\n      }\n    }\n    as = as.sort.uniq.array;\n    writeln(m, \" \", n, \": \", as.length, \" \", cnt);\n    stdout.flush;\n    if (m == 2 && n == 2) {\n      foreach (a; as) {\n        writeln(a);\n      }\n    }\n  }\n  return;\n  */\n  \n  prepare();\n  \n  try {\n    for (; ; ) {\n      const M = readInt();\n      const N = readInt();\n      \n      auto pwN1 = new Mint[M + 1];\n      auto pwM1 = new Mint[N + 1];\n      pwN1[0] = Mint(1);\n      foreach (i; 1 .. M + 1) {\n        pwN1[i] = pwN1[i - 1] * (N + 1);\n      }\n      pwM1[0] = Mint(1);\n      foreach (i; 1 .. N + 1) {\n        pwM1[i] = pwM1[i - 1] * (M + 1);\n      }\n      \n      Mint ans;\n      foreach (l; 0 .. min(M, N) + 1) {\n        Mint tmp = (l % 2 != 0) ? -1 : +1;\n        tmp *= binom(M, l);\n        tmp *= binom(N, l);\n        tmp *= fac[l];\n        tmp *= pwN1[M - l];\n        tmp *= pwM1[N - l];\n        ans += tmp;\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nmod = 998244353\n\nif N > M:\n  N, M = M, N\n\nfact = [0] * (M + 1)\npowm = [0] * (M + 1)\npown = [0] * (M + 1)\nfact[0] = 1\npowm[0] = 1\npown[0] = 1\nfor i in range(1, M + 1):\n  fact[i] = fact[i - 1] * i % mod\n  powm[i] = powm[i - 1] * (M + 1) % mod\n  pown[i] = pown[i - 1] * (N + 1) % mod\n\ndef pow(n, m):\n  if m == 0:\n    return 1\n  elif m == 1:\n    return n\n  elif m % 2 == 0:\n    return pow(n, m // 2)**2 % mod\n  else:\n    return pow(n, m // 2)**2 % mod * n % mod\n\ninv_fact = [0] * (M + 1)\ninv_fact[M] = pow(fact[M], mod-2)\nfor i in reversed(range(0, M)):\n  inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    \ndef C(n, r):\n  return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n  \nans = 0\nfor i in range(N+1):\n  ans += (-1)**i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n  ans = ans % mod\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def p(i):\n  ans = 1\n  while i != 1:\n    ans *= i\n    i -= 1\n  return ans  \ndef comb_dp_sub(n, r):\n    global comb_table\n    if r == 0 or n == r:\n        return 1\n    else:\n        return comb_table[n - 1][r] + comb_table[n - 1][r - 1]\n\ndef comb_dp(n, r):\n    global comb_table\n    comb_table = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(i + 1):\n            comb_table[i][j] = comb_dp_sub(i, j)\n    return comb_table[n][r]\n  \nn,m = map(int, input().split())\n\nst = ((n+1)**m) * ((m+1)**n)\ngeneral = 0\nfor i in range(1,min(n,m)+1):\n  general += comb_dp(n,i) * comb_dp(m,i) * p(i)\n  \nprint(st - general)  \n  \n  "
  }
]