[
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\ntypedef ld Weight;\n\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g, const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < int(g.size()); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(), -1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now] != -1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\npair<Weight, Graph> chu_liu(const Graph&g, const int start, const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tWeight total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight, e.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < int(g.size()); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight, reve.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t\tif (cycle_edges.empty()) {\n\t\t\treturn make_pair(total_len, tree);\n\t\t}\n\t}\n\tvector<bool>node_is_cycle(g.size());\n\n\tvector<int>edge_is_cycle(e_size);\n\n\tvector<Weight>prev_lens(g.size(), ZERO);\n\n\tfor (auto ce : cycle_edges) {\n\t\tnode_is_cycle[ce.src] = true;\n\t\tprev_lens[ce.dst] = ce.weight;\n\t}\n\tGraph newg(g.size());\n\tconst int compress = cycle_edges[0].src;\n\tvector<Edge>memo(e_size);\n\tfor (int s = 0; s < int(g.size()); ++s) {\n\t\tbool src_is_cycle = node_is_cycle[s];\n\t\tfor (auto e : g[s]) {\n\t\t\tmemo[e.id] = e;\n\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (src_is_cycle) {\n\t\t\t\te.src = compress;\n\t\t\t}\n\t\t\telse if (dst_is_cycle) {\n\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\te.dst = compress;\n\t\t\t}\n\t\t\tnewg[e.src].push_back(e);\n\t\t}\n\t}\n\tauto p = chu_liu(newg, start, e_size);\n\tGraph compress_tree(p.second);\n\tGraph ans_tree(g.size());\n\tfor (auto es : compress_tree) {\n\t\tfor (auto e : es) {\n\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\tif (node_is_cycle[prev_edge.dst]) {\n\t\t\t\tfor (auto cycle_edge : cycle_edges) {\n\t\t\t\t\tif (cycle_edge.dst != prev_edge.dst) {\n\t\t\t\t\t\tans_tree[cycle_edge.src].emplace_back(cycle_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\treturn make_pair(p.first + cycle_len, ans_tree);\n}\n\nld getlen(const vector<ld>&a, const vector<ld>&b,const ld n) {\n\n\tld sum = 0;\n\tfor (int k = 0; k < a.size(); ++k) {\n\t\tsum += pow(a[k]*n - b[k], 2);\n\t}\n\treturn sum;\n}\n\nld getdis(const vector<ld>&a, const vector<ld>&b) {\n\tld amin = -1e8;\n\tld amax = 1e8;\n\tint num = 100;\n\twhile (num--) {\n\t\tld amid1 = (amin * 2 + amax) / 3;\n\t\tld amid2 = (amin + amax * 2) / 3;\n\t\tld ans1 = getlen(a, b, amid1);\n\t\tld ans2 = getlen(a, b, amid2);\n\t\tif (ans1 < ans2) {\n\t\t\tamax = amid2;\n\t\t}\n\t\telse {\n\t\t\tamin = amid1;\n\t\t}\n\t}\n\treturn getlen(a, b, amin);\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld v; cin >> v;\n\t\t\tvecs[i].emplace_back(v);\n\t\t}\n\t}\n\tGraph g(M);\n\tint aid = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i == j)continue;\n\t\t\telse {\n\t\t\t\tld len = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[i].push_back(Edge(i, j, len,aid++));\n\t\t\t}\n\t\t}\n\t}\n\tld ans = 1e18;\n\tfor (int i = 0; i < M; ++i) {\n\t\tvector<ld>v(N);\n\t\tauto p = chu_liu(g, i, M*(M - 1));\n\t\tld plus = getlen(v, vecs[i],0);\n\t\tans = min(ans, p.first+plus);\n\t}\n\tcout <<setprecision(12)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nconst int N = 111;\nconst int maxn = 111;\nconst int maxm = maxn * maxn;\nconst double eps = 1e-10;\nint n, m, pos[N];\ndouble v[N][N], val[N], dist[N][N];\n\ndouble get_r(int i, int j)\n{\n\tdouble up = 0.0;\n\tdouble down = 0.0;\n\tfor (int k = 1; k <= n; ++k) {\n\t\tup += v[j][k] * v[i][k];\n\t\tdown += v[j][k] * v[j][k];\n\t}\n\tif (fabs(down) < eps) return 0;\n\treturn up / down;\n}\n\nbool cmp(const int &x, const int &y) {\n\treturn y < x;\n}\n\nnamespace EdmondsAlgorithm { // O(ElogE + V^2) !!! 0-based !!!\n\tstruct enode { int from, dep;\n\t\tdouble c, key, delta; enode *ch[2], *next;\n\t} ebase[maxm], *etop, *fir[maxn], nil, *null, *inEdge[maxn], *chs[maxn];\n\ttypedef enode *edge; typedef enode *tree;\t\n\tint n, m, setFa[maxn], deg[maxn], que[maxn];\n\tinline void pushDown(tree x) { if (x->delta > 0) {\n\t\tx->ch[0]->key += x->delta; x->ch[0]->delta += x->delta;\n\t\tx->ch[1]->key += x->delta; x->ch[1]->delta += x->delta; x->delta = 0;\n\t}}\n\ttree merge(tree x, tree y) {\n\t\tif (x == null) return y; if (y == null) return x;\n\t\tif (x->key > y->key) swap(x, y); pushDown(x); x->ch[1] = merge(x->ch[1], y);\n\t\tif (x->ch[0]->dep < x->ch[1]->dep) swap(x->ch[0], x->ch[1]);\n\t\tx->dep = x->ch[1]->dep + 1; return x;\n\t}\n\tvoid addEdge(int u, int v, double w) {\n\t\tetop->from = u; etop->c = etop->key = w; etop->delta = etop->dep = 0;\n\t\tetop->next = fir[v]; etop->ch[0] = etop->ch[1] = null;\n\t\tfir[v] = etop; inEdge[v] = merge(inEdge[v], etop++);\n\t}\n\tvoid deleteMin(tree &r) { pushDown(r); r = merge(r->ch[0], r->ch[1]); }\n\tint findSet(int x) { return setFa[x] == x ? x : setFa[x] = findSet(setFa[x]); }\n\tvoid clear(int V, int E) {\n\t\tnull = &nil; null->ch[0] = null->ch[1] = null; null->dep = -1;\n\t\tn = V; m = E; etop = ebase;\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tfir[i] = NULL;\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tinEdge[i] = null;\n\t}\n\tdouble solve(int root) { double res = 0; int head, tail;\n\t\tfor (int i = 0; i < n; ++i) setFa[i] = i;\n\t\tfor ( ; ; ) { memset(deg, 0, sizeof(int) * n); chs[root] = inEdge[root];\n\t\t\tfor (int i = 0; i < n; ++i) if (i != root && setFa[i] == i) {\n\t\t\t\twhile (findSet(inEdge[i]->from) == findSet(i)) deleteMin(inEdge[i]);\n\t\t\t\t++deg[ findSet((chs[i] = inEdge[i])->from) ];\n\t\t\t}\n\t\t\tfor (int i = head = tail = 0; i < n; ++i)\n\t\t\t\tif (i != root && setFa[i] == i && deg[i] == 0) que[tail++] = i;\n\t\t\twhile (head < tail) {\n\t\t\t\tint x = findSet(chs[que[head++]]->from);\n\t\t\t\tif (--deg[x] == 0) que[tail++] = x;\n\t\t\t} bool found = false;\n\t\t\tfor (int i = 0; i < n; ++i) if (i != root && setFa[i] == i && deg[i] > 0) {\n\t\t\t\tint j = i; tree temp = null; found = true;\n\t\t\t\tdo {setFa[j = findSet(chs[j]->from)] = i;\n\t\t\t\t\tdeleteMin(inEdge[j]); res += chs[j]->key;\n\t\t\t\t\tinEdge[j]->key -= chs[j]->key; inEdge[j]->delta -= chs[j]->key;\n\t\t\t\t\ttemp = merge(temp, inEdge[j]);\n\t\t\t\t} while (j != i); inEdge[i] = temp;\n\t\t\t} if (!found) break;\n\t\t} for (int i = 0; i < n; ++ i) if (i != root && setFa[i] == i) res += chs[i]->key;\n\t\treturn res;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tval[i] = 0.0;\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tcin >> v[i][j];\n\t\t\tval[i] += v[i][j] * v[i][j];\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= m; ++i) {\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tdist[j][i] = 0.0;\n\t\t\tdouble r = get_r(i, j);\n\t\t\tfor (int k = 1; k <= n; ++k)\n\t\t\t\tdist[j][i] += (v[i][k] - r * v[j][k]) * (v[i][k] - r * v[j][k]);\n\t\t}\n\t}\n\tn = m;\n\tdouble ans = 0x7FFFFFFF/2;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tEdmondsAlgorithm::clear(m, m * m);\n\t\tfor (int j = 1;  j <= m; ++j)\n\t\t\tfor (int k = 1; k <= m; ++k) {\n\t\t\t\tEdmondsAlgorithm::addEdge(j - 1, k - 1, dist[j][k]);\n\t\t\t}\n\t\tdouble w = EdmondsAlgorithm::solve(i - 1);\n\t\t//cout << i << \" \" << w << endl;\n\t\tans = min(w + val[i], ans);\n\t}\n\tcout << setiosflags(ios::fixed) << setprecision(10) << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ninline double sq(double a) { return a*a; }\n\nstruct MST {\n    typedef double weight;\n    static const weight INF = 1e100;\n    static const int N = 128;\n\n    int n, no[N], prev[N], mark[N], temp[N];\n    vector<int> comp[N];\n    weight g[N][N], mcost[N];\n    \n    void init(int _n) {\n        n = _n;\n        rep(i, n) rep(j, n) g[i][j] = INF;\n    }\n\n    void rec(int v, int s, int r, weight &cost, bool &found) {\n        if(mark[v]) {\n            found = true;\n            memcpy(temp, no, sizeof(temp));\n            for(;;) {\n                cost += mcost[v];\n                v = prev[v];\n                if(v==s) break;\n                while(comp[v].size()) {\n                    no[comp[v].back()] = s;\n                    comp[s].push_back(comp[v].back());\n                    comp[v].pop_back();\n                }\n            }\n            rep(j, n) if(j!=r && no[j]==s) {\n                rep(i, n) if(no[i]!=s && g[i][j]<INF) g[i][j] -= mcost[temp[j]];\n            }\n        }\n        mark[v] = 1;\n        rep(i, n) if(no[i]!=no[v] && prev[no[i]]==v) {\n            if(!mark[no[i]] || i==s) rec(i, s, r, cost, found);\n        }\n    }\n\n    weight solve(int r) {\n        rep(i, n) {\n            no[i] = i;\n            comp[i].clear();\n            comp[i].push_back(i);\n        }\n        weight cost = 0;\n        for(;;) {\n            memset(prev, -1, sizeof(prev));\n            rep(i, n) mcost[i] = INF;\n            rep(i, n) rep(j, n) if(j!=r && no[i]!=no[j] && g[i][j]<INF) {\n                if(g[i][j] < mcost[no[j]]) {\n                    mcost[no[j]] = g[i][j];\n                    prev[no[j]] = no[i];\n                }\n            }\n            bool stop = true;\n            memset(mark, 0, sizeof(mark));\n            rep(i, n) if(i!=r && mark[i]==0 && comp[i].size()) {\n                bool found = false;\n                rec(i, i, r, cost, found);\n                if(found) stop = false;\n            }\n            if(stop) {\n                rep(i, n) if(prev[i]>=0) cost += mcost[i];\n                return cost;\n            }\n        }\n    }\n} mst;\n\nint N, M;\ndouble v[128][128];\ndouble w[128][128];\n\ndouble dot(int a, int b) {\n    double s = 0;\n    rep(i, N) s += v[a][i]*v[b][i];\n    return s;\n}\n\ndouble norm(int a) { return dot(a, a); }\n\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    rep(i, M) rep(j, N) scanf(\"%lf\", v[i]+j);\n    mst.init(M+1);\n    rep(i, M) mst.g[M][i] = norm(i);\n    rep(i, M) rep(j, M) if(i!=j) {\n        if(norm(i)==0) mst.g[i][j] = norm(j);\n        else mst.g[i][j] = norm(j)-sq(dot(i, j))/norm(i);\n    }\n    printf(\"%.9f\\n\", mst.solve(M));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<iomanip>\nusing namespace std;\n#define eps 1e-8\n#define INF 1000000\n#define maxn 200005\ndouble a[105][105];\ndouble sum[105];\nstruct Edge\n{\n    int u,v;\n    double w;\n}b[10005],e[10005];\nint pre[maxn],id[maxn],vis[maxn];\ndouble in[maxn];\n\nint dcmp(double x)\n{\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\ndouble Directed_MST(int root, int NV, int NE)\n{\n    double ret = 0;\n    while(1)\n    {\n        for(int i=0;i<NV;i++)\n            in[i]=INF;\n        memset(pre,-1,sizeof(pre));\n        memset(vis,-1,sizeof(vis));\n        memset(id,-1,sizeof(id));\n        for(int i=0;i<NE;i++)\n        {\n            if(e[i].u==e[i].v) continue;\n            int v=e[i].v;\n            if(e[i].w<in[v]){\n      //          ans=i;\n                pre[v]=e[i].u;\n                in[v]=e[i].w;\n            }\n        }\n        for(int i=0;i<NV;i++)\n        {\n            if(in[i]==INF&&i!=root)\n                return -1;\n        }\n        int cnt=0;\n        in[root]=0;\n        for(int i=0;i<NV;i++)\n        {\n            ret+=in[i];\n            int v=i;\n            while(vis[v]!=i&&id[v]==-1&&v!=root)\n            {\n                vis[v]=i;\n                v=pre[v];\n            }\n            if(v!=root&&id[v]==-1){\n                for(int u=pre[v];u!=v;u=pre[u])\n                {\n                    id[u]=cnt;\n                }\n                id[v]=cnt++;\n            }\n        }\n        if(cnt==0) break;\n        for(int i=0;i<NV;i++)\n            if(id[i]==-1) id[i]=cnt++;\n        for(int i=0;i<NE;i++)\n        {\n            int v=e[i].v;\n            e[i].u=id[e[i].u];\n            e[i].v=id[e[i].v];\n            e[i].w-=in[v];\n        }\n        NV = cnt;\n        root = id[root];\n     }\n    return ret;\n}\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<m;i++)    for(int j=0;j<n;j++)    scanf(\"%lf\",a[i]+j);\n    int tot=0;\n    for(int i=0;i<m;i++)             //j->i??±?\n    {\n        for(int j=0;j<m;j++)\n        {\n            double x1=0,x2=0,x3=0;     // y=r*r*x3-2*r*x2+x1\n            for(int k=0;k<n;k++)\n            {\n                x1+=a[i][k]*a[i][k];\n                x3+=a[j][k]*a[j][k];\n                x2+=a[i][k]*a[j][k];\n            }\n            sum[i]=x1;\n            if(i==j)    continue;\n            double x=x2/x3;\n            double y=x*x*x3-2.0*x*x2+x1;\n            b[tot].u=j;\n            b[tot].v=i;\n            b[tot].w=y;\n            tot++;\n        }\n    }\n    double fin=INF;\n    for(int i=0;i<m;i++)\n    {\n        for(int j=0;j<tot;j++)\n        {\n            e[j].w=b[j].w;\n            e[j].u=b[j].u;\n            e[j].v=b[j].v;\n        }\n        double temp=Directed_MST(i,m,tot);\n        if(temp<0)  while(1);\n        temp=temp+sum[i];\n        fin=min(fin,temp);\n    }\n    printf(\"%.7f\\n\",fin);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst int N = 111;\nconst double eps = 1e-10;\nint n, m, pos[N];\ndouble v[N][N], val[N], dist[N][N];\n\ndouble get_r(int i, int j)\n{\n    double up = 0.0;\n    double down = 0.0;\n    for (int k = 1; k <= n; ++k) {\n        up += v[j][k] * v[i][k];\n        down += v[j][k] * v[j][k];\n    }\n    if (fabs(down) < eps) return 0;\n    return up / down;\n}\n\nbool cmp(const int &x, const int &y) {\n    return y < x;\n}\n\nnamespace EdmondsAlgorithm { // O(ElogE + V^2) !!! 0-based !!!\n    const int maxn = 111;\n    const int maxm = maxn * maxn;\n    struct enode {\n        int from, dep;\n        double c, key, delta;\n        enode *ch[2], *next;\n    } ebase[maxm], *etop, *fir[maxn], nil, *null, *inEdge[maxn], *chs[maxn];\n    typedef enode *edge; typedef enode *tree;\n    int n, m, setFa[maxn], deg[maxn], que[maxn];\n    inline void pushDown(tree x) { if (x->delta) {\n            x->ch[0]->key += x->delta; x->ch[0]->delta += x->delta;\n            x->ch[1]->key += x->delta; x->ch[1]->delta += x->delta; x->delta = 0;\n        }}\n    tree merge(tree x, tree y) {\n        if (x == null) return y; if (y == null) return x;\n        if (x->key > y->key) swap(x, y); pushDown(x); x->ch[1] = merge(x->ch[1], y);\n        if (x->ch[0]->dep < x->ch[1]->dep) swap(x->ch[0], x->ch[1]);\n        x->dep = x->ch[1]->dep + 1; return x;\n    }\n    void addEdge(int u, int v, double w) {\n        etop->from = u; etop->c = etop->key = w; etop->delta = etop->dep = 0;\n        etop->next = fir[v]; etop->ch[0] = etop->ch[1] = null;\n        fir[v] = etop; inEdge[v] = merge(inEdge[v], etop++);\n    }\n    void deleteMin(tree &r) { pushDown(r); r = merge(r->ch[0], r->ch[1]); }\n    int findSet(int x) { return setFa[x] == x ? x : setFa[x] = findSet(setFa[x]); }\n    void clear(int V, int E) {\n        null = &nil; null->ch[0] = null->ch[1] = null; null->dep = -1;\n        n = V; m = E; etop = ebase;\n        for (int i = 0; i < V; ++i) fir[i] = NULL;\n        for (int i = 0; i < V; ++i) inEdge[i] = null;\n    }\n    double solve(int root) {\n        double res = 0;\n        int head, tail;\n        for (int i = 0; i < n; ++i) setFa[i] = i;\n        for ( ; ; ) { memset(deg, 0, sizeof(int) * n); chs[root] = inEdge[root];\n            for (int i = 0; i < n; ++i) if (i != root && setFa[i] == i) {\n                    while (findSet(inEdge[i]->from) == findSet(i)) deleteMin(inEdge[i]);\n                    ++deg[ findSet((chs[i] = inEdge[i])->from) ];\n                }\n            for (int i = head = tail = 0; i < n; ++i)\n                if (i != root && setFa[i] == i && deg[i] == 0) que[tail++] = i;\n            while (head < tail) {\n                int x = findSet(chs[que[head++]]->from);\n                if (--deg[x] == 0) que[tail++] = x;\n            } bool found = false;\n            for (int i = 0; i < n; ++i) if (i != root && setFa[i] == i && deg[i] > 0) {\n                    int j = i; tree temp = null; found = true;\n                    do {setFa[j = findSet(chs[j]->from)] = i;\n                        deleteMin(inEdge[j]); res += chs[j]->key;\n                        inEdge[j]->key -= chs[j]->key; inEdge[j]->delta -= chs[j]->key;\n                        temp = merge(temp, inEdge[j]);\n                    } while (j != i); inEdge[i] = temp;\n                } if (!found) break;\n        } for (int i = 0; i < n; ++ i) if (i != root && setFa[i] == i) res += chs[i]->key;\n        return res;\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    double max_val = 0;\n    for (int i = 1; i <= m; ++i) {\n        val[i] = 0.0;\n        for (int j = 1; j <= n; ++j) {\n            cin >> v[i][j];\n            val[i] += v[i][j] * v[i][j];\n        }\n    }\n    \n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            dist[j][i] = 0.0;\n            double r = get_r(i, j);\n            for (int k = 1; k <= n; ++k)\n                dist[j][i] += (v[i][k] - r * v[j][k]) * (v[i][k] - r * v[j][k]);\n            max_val += dist[j][i];\n        }\n    }\n    max_val *= 2.0;\n    for (int i = 1; i <= m; ++i)\n        dist[i][m + 1] = dist[m + 1][i] = max_val + val[i];\n\n    EdmondsAlgorithm::clear(m + 1, (m + 1) * (m + 1));\n    for (int i = 1; i <= m + 1; ++i)\n        for (int j = 1; j <= m + 1; ++j)\n            EdmondsAlgorithm::addEdge(i - 1, j - 1, dist[i][j]);\n    double ans = EdmondsAlgorithm::solve(m) - max_val;\n\n    cout << setiosflags(ios::fixed) << setprecision(10) << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nstruct SCC {\n\ttypedef vector<vector<int>> graph;\n\n\tint V;\n\tgraph G;\n\tvector<int> cmp;\n\tvector<int> vs;\n\tvector<bool> used;\n\n\tSCC(int V_):V(V_), G(V_), cmp(V_), used(V_) {}\n\tSCC(const graph &G_):V(G_.size()), G(G_), cmp(V), used(V) {}\n\n\tvoid add_edge(int from, int to) {\n\t\tG[from].emplace_back(to);\n\t}\n\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(!used[to]) dfs(to);\n\t\t}\n\t\tvs.emplace_back(v);\n\t}\n\n\tvoid rdfs(int v, int k, graph &rG) {\n\t\tused[v] = true;\n\t\tcmp[v] = k;\n\t\tfor(const auto &to : rG[v]) {\n\t\t\tif(!used[to]) rdfs(to, k, rG);\n\t\t}\n\t}\n\n\tint scc() {\n\t\tvs.clear();\n\t\tfill(used.begin(), used.end(), false);\n\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tif(!used[v]) dfs(v);\n\t\t}\n\n\t\tgraph rG(V);\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\trG[to].emplace_back(v);\n\t\t\t}\n\t\t}\n\n\t\tfill(used.begin(), used.end(), false);\n\t\tint k = 0;\n\t\tfor(int i = static_cast<int>(vs.size()) - 1; i >= 0; --i) {\n\t\t\tif(!used[vs[i]]) rdfs(vs[i], k++, rG);\n\t\t}\n\t\treturn k;\n\t}\n};\n\ntypedef double weight;\nconstexpr weight INF = (1 << 28);\n\nstruct edge {\n\tint to;\n\tweight cost;\n\tedge(int to_, weight cost_):to(to_), cost(cost_){}\n};\n\ntypedef vector<vector<edge>> weighted_graph;\n\nweight minimum_spanning_arborescence(int r, const weighted_graph &G, weight sum = 0) {\n\tconst int n = G.size();\n\n\tvector<int> rev(n, -1);\n\tvector<weight> minimum_weight(n, INF);\n\tfor(int v = 0; v < n; ++v) {\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(minimum_weight[e.to] > e.cost) {\n\t\t\t\tminimum_weight[e.to] = e.cost;\n\t\t\t\trev[e.to] = v;\n\t\t\t}\n\t\t}\n\t}\n\n\tSCC scc(n);\n\tfor(int v = 0; v < n; ++v) {\n\t\tif(v == r) continue;\n\t\tif(rev[v] == -1) return INF;\n\t\tscc.add_edge(rev[v], v);\n\t\tsum += minimum_weight[v];\n\t}\n\n\tconst int num = scc.scc();\n\tif(num == n) return sum;\n\n\tweighted_graph next_G(num);\n\tfor(int v = 0; v < n; ++v) {\n\t\tconst int from = scc.cmp[v];\n\t\tfor(const auto &e : G[v]) {\n\t\t\tconst int to = scc.cmp[e.to];\n\t\t\tif(from == to) continue;\n\n\t\t\tconst auto cost = e.cost - minimum_weight[e.to];\n\t\t\tnext_G[from].emplace_back(to, cost);\n\t\t}\n\t}\n\n\treturn minimum_spanning_arborescence(scc.cmp[r], next_G, sum);\n}\n\ntypedef vector<weight> vec;\n\ninline weight dot(const vec &a, const vec &b) {\n\tweight res = 0.0;\n\tfor(int i = 0; i < a.size(); ++i) {\n\t\tres += a[i] * b[i];\n\t}\n\treturn res;\n}\n\ninline weight norm(const vec &v) {\n\treturn dot(v, v);\n}\n\ninline weight calc(const vec &a, const vec &b) {\n\tconstexpr double EPS = 1e-9;\n\tconst auto n = norm(a);\n\tif(abs(n) < EPS) return norm(b);\n\n\tconst weight r = dot(a, b) / n;\n\tweight res = 0.0;\n\tfor(int i = 0; i < a.size(); ++i) {\n\t\tconst weight t = b[i] - r * a[i];\n\t\tres += t * t;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.precision(10);\n\tcout.flags(ios::fixed);\n\n\tint d, n;\n\tcin >> d >> n;\n\n\tvector<vec> vectors;\n\tvectors.reserve(n);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tvec v(d);\n\t\tfor(auto &e : v) cin >> e;\n\t\tvectors.emplace_back(v);\n\t}\n\n\tweighted_graph G(n + 1);\n\tG[n].reserve(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tG[n].emplace_back(i, norm(vectors[i]));\n\t}\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tG[i].reserve(n - 1);\n\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(i == j) continue;\n\t\t\tG[i].emplace_back(j, calc(vectors[i], vectors[j]));\n\t\t}\n\t}\n\n\tcout << minimum_spanning_arborescence(n, G) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdC++.h>\nusing namespace std;\nconst int N = 105, M = N * N;\nconst double inf = 1000, eps = 1e-8;\n//最小?形?\nint n, m, tot, pre[N], vis[N], id[N];\ndouble in[N], v[N][N];\nstruct Edge {\n\tint u, v;\n\tdouble dis;\n\tEdge(){}\n\tEdge(int u, int v, double dis): u(u), v(v), dis(dis){};\n}e[M];\nint sgn(double x) {\n\tif (fabs(x) < eps)\treturn 0;\n\treturn x < 0 ? -1 : 1;\n}\ndouble MST(int root) {\n\tdouble t = 0.0;\n\twhile (1) {\n\t\tfor (int i = 1; i <= n; ++i)\tin[i] = inf;\n\t\tfor (int i = 1; i <= tot; ++i) {\n\t\t\tint u = e[i].u;\n\t\t\tint v = e[i].v;\n\t\t\tif (sgn(e[i].dis - in[v]) < 0 && u != v) {\n\t\t\t\tpre[v] = u;\n\t\t\t\tin[v] = e[i].dis;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (i == root)\tcontinue;\n\t\t\tif (sgn(in[i] - inf) == 0)\treturn -1;\n\t\t}\n\t\t//find cycle\n\t\tint cnt = 0;\n\t\tmemset(id, -1 ,sizeof(id));\n\t\tmemset(vis, -1 ,sizeof(vis));\n\t\tin[root] = 0;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tt += in[i];\n\t\t\tint v = i;\n\t\t\twhile (vis[v] != i && id[v] == -1 && v != root) {\n\t\t\t\tvis[v] = i;\n\t\t\t\tv = pre[v];\n\t\t\t}\n\t\t\tif (v != root && id[v] == -1) {\n\t\t\t\tfor (int u = pre[v]; u != v; u = pre[u])\tid[u] = ++cnt;\n\t\t\t\tid[v] = cnt;\n\t\t\t}\n\t\t}\n\t\tif (!cnt)\tbreak;//no cycle\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (id[i] == -1)\tid[i] = ++cnt;\n\t\tfor (int i = 1; i <= tot; ++i) {\n\t\t\tint v = e[i].v;\n\t\t\te[i].u = id[e[i].u];\n\t\t\te[i].v = id[e[i].v];\n\t\t\tif (e[i].u != e[i].v)\te[i].dis -= in[v];\n\t\t}\n\t\tn = cnt;\n\t\troot = id[root];\n\t}\n\treturn t;\n}\ndouble dot(int x, int y) {\n\tdouble t = 0.0;\n\tfor (int i = 1; i <= m; ++i)\tt += v[x][i] * v[y][i];\n\treturn t;\n}\ndouble norm(int x) {\n\treturn dot(x, x);\n}\ndouble sqr(double x) {\n\treturn x * x;\n}\nint main() {\n\tscanf(\"%d%d\", &m, &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tscanf(\"%lf\", &v[i][j]);\n\tint rt = n + 1;\n\tfor (int i = 1; i <= n; ++i)\te[++tot] = Edge(rt, i, norm(i));\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (i == j)\tcontinue;\n\t\t\tif (norm(i) == 0)\te[++tot] = Edge(i, j, norm(j));\n\t\t\telse e[++tot] = Edge(i, j, norm(j) - sqr(dot(i, j)) / norm(i));\n\t\t}\n\tprintf(\"%.10lf\\n\", MST(rt));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nconst double eps=1e-9;\nbool eq(double a,double b){\n\treturn abs(a-b)<eps;\n}\n\nconst double inf=1e9;\n\ndouble dis[110][110];\nint root;\nint N;\n\nint prv[110];\n//vector<int> nxt[110];\n\n//int cid[110];//どこの頂点に縮約されたか\nvector<int> cycle;\nbool visited[110];\n\nbool remained[110];\n\nbool visit(int v,int s){\n\tif(v==root) return false;\n\tif(visited[v]){\n\t\treturn v==s;\n\t}\n\tvisited[v]=true;\n\tcycle.push_back(v);\n\tif(prv[v]==-1) return false;\n\treturn visit(prv[v],s);\n}\n\ndouble dmst(){\n//\tfor(int i=0;i<N;i++) cid[i]=i;\n\tfor(int i=0;i<N;i++) remained[i]=true;\n\twhile(true){\n\t\tdouble res=0;\n\t\t//そこに入ってくる最も小さい辺を求める(root以外)\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(!remained[i]) continue;\n\t\t\tif(i==root) continue;\n\t\t\tpair<double,int> best=make_pair(inf,-1);\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif(!remained[j]) continue;\n\t\t\t\tif(i==j) continue;\n\t\t\t\tbest=min(best,make_pair(dis[j][i],j));\n\t\t\t}\n\t\t\tprv[i]=best.second;\n\t\t\tres+=best.first;\n\t\t}\n/*\t\tprintf(\"prv::\");\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(i==root) continue;\n\t\t\tprintf(\"%d->%d %f\\n\",prv[i],i,dis[prv[i]][i]);\n\t\t}*/\n\t\t//サイクルを見つけて縮約する \n\t\tbool suc=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(i==root) continue;\n\t\t\tif(!remained[i]) continue;\n\t\t\tfor(int j=0;j<N;j++) visited[j]=false;\n\t\t\tcycle.clear();\n\t\t\tbool flg=visit(i,i);\n\t\t\tif(!flg) continue;\n\t\t\tsuc=false;\n\t\t\tdouble ccost=0;//sum of cost in cycle\n\t\t\tfor(int j=0;j<cycle.size();j++){\n\t\t\t\tint u=cycle[j];\n\t\t\t\tint v=cycle[(j+1)%cycle.size()];\n\t\t\t\tccost+=dis[v][u];//cycleには逆順で入っていることに注意 \n\t\t\t}\n\t\t\tfor(int j=1;j<cycle.size();j++){\n\t\t\t\tremained[cycle[j]]=false;\n\t\t\t}\n\t\t\t//サイクルから出る辺 \n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif(!remained[j]) continue;\n\t\t\t\tif(i==j) continue;\n\t\t\t\tfor(int k=0;k<cycle.size();k++){\n\t\t\t\t\tint v=cycle[k];\n\t\t\t\t\tdis[i][j]=min(dis[i][j],dis[v][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//サイクルに入る辺 \n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif(!remained[j]) continue;\n\t\t\t\tif(i==j) continue;\n\t\t\t\tdouble tmp=inf;\n\t\t\t\tfor(int k=0;k<cycle.size();k++){\n\t\t\t\t\tint u=cycle[k];//uに入る \n\t\t\t\t\tint v=cycle[(k+1)%cycle.size()];//サイクル上uの直前 \n\t\t\t\t\tdouble add_cost=ccost-dis[v][u];//足すべきコスト \n\t\t\t\t\tdouble cur_cost=dis[j][u]+add_cost;\n\t\t\t\t\ttmp=min(tmp,cur_cost);\n\t\t\t\t}\n\t\t\t\tdis[j][i]=tmp;\n\t\t\t}\n\t\t}\n\t\tif(suc) return res;\n\t}\n\treturn inf;\n}\n\ndouble get(vector<double> &v1,vector<double> &v2){\n\t//v1がすでにあるときv2を表す \n\t//グラフではv1->v2\n\t//|v2-r*v1|^2を最小化 \n\tdouble a=0,b=0,c=0;\n\tfor(int i=0;i<v1.size();i++){\n\t\tdouble x1=v1[i],x2=v2[i];\n\t\ta+=x1*x1;\n\t\tb+=(-(x1*x2)*2);\n\t\tc+=x2*x2;\n\t}\n\tif(eq(a,0.0)){\n\t\tif(eq(b,0.0)) return c;\n\t\telse return 0;\n\t}\n\treturn -b*b/(a*4)+c;\n}\n\nvector<double> vecs[110];\nint M;//num of vectors\nint D;//dimension\n\nint main(){\n\tscanf(\"%d%d\",&D,&M);\n\tvector<double> zeroV(D,0.0);\n\tvecs[0]=zeroV;\n\tfor(int i=1;i<=M;i++){\n\t\tfor(int j=0;j<D;j++){\n\t\t\tdouble val;\n\t\t\tscanf(\"%lf\",&val);\n\t\t\tvecs[i].push_back(val);\n\t\t}\n\t}\n\tfor(int i=0;i<=M;i++){\n\t\tif(i!=0) dis[i][0]=inf;\n\t\telse dis[i][0]=0;\n\t\tfor(int j=1;j<=M;j++){\n\t\t\tif(i==j) dis[i][j]=0;\n\t\t\telse dis[i][j]=get(vecs[i],vecs[j]);\n\t\t}\n\t}\n\troot=0;\n\tN=M+1;\n/*\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tprintf(\"%f \",dis[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tdouble res=dmst();\\\n\tprintf(\"%.9f\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nstruct SCC {\n\ttypedef vector<vector<int>> graph;\n\n\tint V;\n\tgraph G;\n\tvector<int> cmp;\n\tvector<int> vs;\n\tvector<bool> used;\n\n\tSCC(int V_):V(V_), G(V_), cmp(V_), used(V_) {}\n\tSCC(const graph &G_):V(G_.size()), G(G_), cmp(V), used(V) {}\n\n\tvoid add_edge(int from, int to) {\n\t\tG[from].emplace_back(to);\n\t}\n\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(!used[to]) dfs(to);\n\t\t}\n\t\tvs.emplace_back(v);\n\t}\n\n\tvoid rdfs(int v, int k, graph &rG) {\n\t\tused[v] = true;\n\t\tcmp[v] = k;\n\t\tfor(const auto &to : rG[v]) {\n\t\t\tif(!used[to]) rdfs(to, k, rG);\n\t\t}\n\t}\n\n\tint scc() {\n\t\tvs.clear();\n\t\tfill(used.begin(), used.end(), false);\n\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tif(!used[v]) dfs(v);\n\t\t}\n\n\t\tgraph rG(V);\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\trG[to].emplace_back(v);\n\t\t\t}\n\t\t}\n\n\t\tfill(used.begin(), used.end(), false);\n\t\tint k = 0;\n\t\tfor(int i = static_cast<int>(vs.size()) - 1; i >= 0; --i) {\n\t\t\tif(!used[vs[i]]) rdfs(vs[i], k++, rG);\n\t\t}\n\t\treturn k;\n\t}\n};\n\ntypedef double weight;\nconstexpr weight INF = (1 << 28);\n\nstruct edge {\n\tint to;\n\tweight cost;\n\tedge(int to_, weight cost_):to(to_), cost(cost_){}\n};\n\ntypedef vector<vector<edge>> weighted_graph;\n\nweight minimum_spanning_arborescence(int r, const weighted_graph &G, weight sum = 0) {\n\tconst int n = G.size();\n\n\tvector<int> rev(n, -1);\n\tvector<weight> minimum_weight(n, INF);\n\tfor(int v = 0; v < n; ++v) {\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(minimum_weight[e.to] > e.cost) {\n\t\t\t\tminimum_weight[e.to] = e.cost;\n\t\t\t\trev[e.to] = v;\n\t\t\t}\n\t\t}\n\t}\n\n\tSCC scc(n);\n\tfor(int v = 0; v < n; ++v) {\n\t\tif(v == r) continue;\n\t\tif(rev[v] == -1) return INF;\n\t\tscc.add_edge(rev[v], v);\n\t\tsum += minimum_weight[v];\n\t}\n\n\tconst int num = scc.scc();\n\tif(num == n) return sum;\n\n\tweighted_graph next_G(num);\n\tfor(int v = 0; v < n; ++v) {\n\t\tconst int from = scc.cmp[v];\n\t\tfor(const auto &e : G[v]) {\n\t\t\tconst int to = scc.cmp[e.to];\n\t\t\tif(from == to) continue;\n\n\t\t\tconst auto cost = e.cost - minimum_weight[e.to];\n\t\t\tnext_G[from].emplace_back(to, cost);\n\t\t}\n\t}\n\n\treturn minimum_spanning_arborescence(scc.cmp[r], next_G, sum);\n}\n\ntypedef vector<weight> vec;\n\ninline weight dot(const vec &a, const vec &b) {\n\tweight res = 0.0;\n\tfor(int i = 0; i < a.size(); ++i) {\n\t\tres += a[i] * b[i];\n\t}\n\treturn res;\n}\n\ninline weight norm(const vec &v) {\n\treturn dot(v, v);\n}\n\ninline weight calc(const vec &a, const vec &b) {\n\tconstexpr double EPS = 1e-9;\n\tconst auto n = norm(a);\n\tif(abs(n) < EPS) return norm(b);\n\n\tconst weight r = dot(a, b) / n;\n\tweight res = 0.0;\n\tfor(int i = 0; i < a.size(); ++i) {\n\t\tconst weight t = b[i] - r * a[i];\n\t\tres += t * t;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.precision(10);\n\tcout.flags(ios::fixed);\n\n\tint d, n;\n\tcin >> d >> n;\n\n\tvector<vec> vectors;\n\tvectors.reserve(n);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tvec v(d);\n\t\tfor(auto &e : v) cin >> e;\n\t\tvectors.emplace_back(v);\n\t}\n\n\tweighted_graph G(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tG[i].reserve(n - 1);\n\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(i == j) continue;\n\t\t\tG[i].emplace_back(j, calc(vectors[i], vectors[j]));\n\t\t}\n\t}\n\n\tweight ans = INF;\n\tfor(int r = 0; r < n; ++r) {\n\t\tchmin(ans, minimum_spanning_arborescence(r, G) + norm(vectors[r]));\n\t}\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef double ldouble;\ntypedef vector<ldouble> Point;\nldouble INF=1e9;\n\nstruct UnionFind{\n  vector<int> par,rank;\n  void init(int n){\n    par.clear();\n    rank.clear();\n    par.resize(n);\n    rank.resize(n);\n    for(int i=0;i<n;i++){\n      par[i]=i;\n      rank[i]=1;\n    }\n  }\n  \n  int find(int x){\n    if(x==par[x])return x;\n    return par[x]=find(par[x]);\n  }\n\n  bool same(int x,int y){\n    return ( find(x)==find(y) );\n  }\n  \n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])swap(x,y);\n    par[y]=x;\n    rank[x]+=rank[y];\n  }\n};\n\nstruct edge{\n  int from;\n  int to;\n  ldouble cost;\n  int id;\n  edge(int from,int to,ldouble cost,int id) :from(from), to(to),cost(cost),id(id) {}\n  bool operator < (const edge e)const{\n    return cost > e.cost;\n  }\n};\n\ntypedef priority_queue< edge > prque;\ntypedef prque* Prque;\n\ntypedef vector<edge> Node;\ntypedef vector<Node> Graph;\n\n\nPrque Merge(vector< Prque > &Q, vector<edge> &ev,int A,int C){\n  if( Q[C]->size() < Q[A]->size() ){\n\n    while( !Q[C]->empty() ){\n      edge e=Q[C]->top();\n      e.cost-=ev[C].cost;\n      e.cost+=ev[A].cost;\n      //      cout<<e.from<<' '<<e.to<<' '<<e.cost<<' '<<ev[A].cost<<' '<<ev[C].cost<<endl;\n      Q[A]->push(e);\n      Q[C]->pop();\n    }\n    ev[C].cost=ev[A].cost;\n    return Q[A];\n  }else{\n    while( !Q[A]->empty() ){\n      edge e=Q[A]->top();\n      e.cost-=ev[A].cost;\n      e.cost+=ev[C].cost;\n      //      cout<<e.from<<' '<<e.to<<' '<<e.cost<<endl;\n      Q[C]->push(e);\n      Q[A]->pop();\n    }\n    return Q[C];\n  }\n}\n\nldouble solve(Graph &G,vector<edge> &edges,int root){\n\n  int n=G.size();\n  ldouble res=0;\n  \n  vector<int> used(n,0);\n  vector< edge > ev(n, (edge){0,0,0,-1} );\n  vector< prque > pool(n);\n  vector< Prque > Q(n);\n  for(int i=0;i<n;i++)Q[i]=&pool[i];\n  \n  UnionFind uf;\n  uf.init(n);\n  \n  for(int i=0;i<(int)edges.size();i++){\n    edge e=edges[i];\n    Q[ e.to ]->push( e );\n  }\n  \n  used[root]=2;\n  for(int Pos=0;Pos<n;Pos++){\n    if(used[Pos]==2)continue;\n    int pos=Pos;\n    vector<int> path;\n    \n    while( used[pos] != 2 ){\n      pos=uf.find(pos);\n      \n      used[pos]=1;\n      path.push_back(pos);\n      if( Q[pos]->empty() ){\n        return INF;\n      }\n      \n      edge e=Q[pos]->top();\n\n      \n      Q[pos]->pop();\n      e.cost-=ev[pos].cost;\n      if( uf.same(e.from,pos) ) continue;\n      ldouble tmpcost=ev[pos].cost;\n      /*\n      cout<<\" pos=\"<<pos;\n      cout<<\" e.from=\"<<e.from;\n      cout<<\" e.to=\"<<e.to;\n      cout<<\" e.cost=\"<<e.cost;\n      cout<<\" tmpcost=\"<<tmpcost<<endl;\n      cout<<endl;\n      */\n      res+=e.cost;\n      e.cost+=tmpcost;\n      ev[pos]=e;\n      if( used[ uf.find(e.from) ] == 2 )break;\n      if( used[ uf.find(e.from) ] == 0 ){\n        pos=e.from;\n        continue;\n      }\n      int pre=uf.find(e.from);\n      for(int i=0;i<100;i++){\n        if(!uf.same(pre,pos)){\n          int A=uf.find(pre), B=uf.find(pos);\n          uf.unite(A,B);\n          int C=uf.find(A);\n          /*\n          cout<<\" !!A=\"<<A;\n          cout<<\" !!B=\"<<B;\n          cout<<\" !!C=\"<<C<<endl;\n          */\n          Prque tmp=NULL;\n          if(B==C)tmp=Merge(Q,ev,A,C);\n          else if(A==C)tmp=Merge(Q,ev,B,C);\n          else assert(0);\n          \n          Q[C]=tmp;\n        }\n        pre=uf.find(ev[pre].from);\n      }\n    }// while_pos\n\n    for(int i=0;i<(int)path.size();i++)used[ path[i] ]=2;\n  }// Pos\n  return res;\n}\n\n\nPoint add(Point a,Point b){\n  Point res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=a[i]+b[i];\n  return res;\n}\n\nPoint sub(Point a,Point b){\n  Point res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=a[i]-b[i];\n  return res;\n}\n\nldouble dot(Point a,Point b){\n  ldouble res=0;\n  for(int i=0;i<(int)a.size();i++)\n    res+=a[i]*b[i];\n  return res;\n}\n\nldouble norm(Point p){\n  return  dot(p,p);\n}\n\nldouble abs(Point p){\n  return  sqrt( norm(p) );\n}\n\ndouble Sqrt(double x){\n  if(x<0)return 0;\n  return sqrt(x);\n}\n\ndouble project(Point a,Point b){\n  ldouble t=dot(a,b);\n  \n  //  cout<<a[0]<<' '<<a[1]<<endl;\n  //  cout<<b[0]<<' '<<b[1]<<endl;\n  //  cout<< dot(a,b) <<endl;\n  return   abs( norm(b) - (t*t/norm(a)) );\n}\n\n\nint main(){\n  int n,m;\n  vector< Point > t;\n  \n  cin>>m>>n;\n  for(int i=0;i<n;i++){\n    Point a(m);\n    for(int j=0;j<m;j++){\n      cin>>a[j];\n    }\n\n    if(norm(a) < 0.00000001){\n      continue;\n    }\n    t.push_back(a);\n  }\n  n=t.size();\n  Graph G;\n  G.resize(n+1);\n  int cc=0;\n  for(int i=0;i<n;i++){\n    G[n].push_back( edge(n,i,norm(t[i]) , cc++) );\n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      ldouble cost=project(t[i],t[j]);\n      G[i].push_back( edge(i,j,cost,cc++) );\n    }\n  }\n\n  vector<edge> edges;\n  for(int i=0;i<=n;i++)\n    for(int j=0;j<(int)G[i].size();j++)\n      edges.push_back(G[i][j]);\n  \n  printf(\"%.10f\\n\",(double) solve(G,edges,n) );\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ntypedef double Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid PrintMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%.3f \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\n\nvoid SocDfs(const Graph &g, int from, vector<int> &visit, vector<int> &st) {\n  visit[from] = 1;\n  for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n    if (visit[it->dest]) { continue; }\n    SocDfs(g, it->dest, visit, st);\n  }\n  st.push_back(from);\n}\n\nvector<vector<int> > Soc(const Graph &g) {\n  const int n = g.size();\n  vector<vector<int> > ret;\n  Graph revg(n);\n  for (int i = 0; i < n; i++) {\n    for (Edges::const_iterator it = g[i].begin(); it != g[i].end(); it++) {\n      revg[it->dest].push_back(Edge(it->dest, i, it->weight));\n    }\n  }\n  vector<int> st;\n  vector<int> visit(n, 0);\n  for (int i = 0; i < n; i++) {\n    if (visit[i]) { continue; }\n    SocDfs(g, i, visit, st);\n  }\n  visit = vector<int>(n, 0);\n  for (int i = n - 1; i >= 0; i--) {\n    int index = st[i];\n    if (visit[index]) { continue; }\n    vector<int> nret;\n    SocDfs(revg, index, visit, nret);\n    ret.push_back(nret);\n  }\n  return ret;\n}\n\n// need Soc\nWeight Arborescence(const Graph &g, int root) {\n  const int n = g.size();\n  Weight ret = 0;\n  vector<Weight> inCost(n, 1000000000LL);\n  vector<int> parent(n, -1);\n  for (int from = 0; from < n; from++) {\n    for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n      if (it->weight < inCost[it->dest]) {\n        parent[it->dest] = from;\n        inCost[it->dest] = it->weight;\n      }\n      inCost[it->dest] = min(inCost[it->dest], it->weight);\n    }\n  }\n  Graph ng(n);\n  for (int i = 0; i < n; i++) {\n    if (i == root) { continue; }\n    if (parent[i] == -1) { return 1000000000LL; }\n    ng[parent[i]].push_back(Edge(parent[i], i, 0));\n    ret += inCost[i];\n  }\n  vector<vector<int> > connect = Soc(ng);\n  int m = connect.size();\n  if (m == n) { return ret; }\n  vector<int> mapto(n, -1);\n  vector<int> cycle(n, 0);\n  ret = 0;\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < (int)connect[i].size(); j++) {\n      mapto[connect[i][j]] = i;\n      if (connect[i].size() != 1) {\n        cycle[connect[i][j]] = 1;\n        ret += inCost[connect[i][j]];\n      }\n    }\n  }\n  ng = Graph(m);\n  for (int from = 0; from < n; from++) {\n    for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n      int to = it->dest;\n      if (to == root || mapto[from] == mapto[to]) { continue; }\n      Weight cost = it->weight;\n      if (cycle[to]) {\n        cost -= inCost[to];\n      }\n      ng[mapto[from]].push_back(Edge(mapto[from], mapto[to], cost));\n    }\n  }\n  return min(1e+10, ret + Arborescence(ng, mapto[root]));\n  //return min(1000000000LL, ret + Arborescence(ng, mapto[root]));\n}\n\ndouble vect[110][110];\nint n, m;\n\ninline double square(double x) { return x * x; }\n\ndouble Len(int x) {\n  double ret = 0.0;\n  REP(i, n) { ret += square(vect[x][i]); }\n  return ret;\n}\ndouble Inner(int i, int j) {\n  double ret = 0.0;\n  REP(k, n) { ret += vect[i][k] * vect[j][k]; }\n  return ret;\n}\ndouble calc(int i, int j) {\n  double ret = 0.0;\n  ret += Len(j) - square(Inner(j, i)) / Len(i);\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &n, &m) > 0) {\n    REP(i, m) {\n      REP(j, n) {\n        scanf(\"%lf\", &vect[i][j]);\n      }\n    }\n    Graph g(m + 1);\n    REP(i, m) {\n      g[m].push_back(Edge(m, i, Len(i)));\n    }\n    REP(i, m) {\n      REP(j, m) {\n        if (i == j) { continue; }\n        g[i].push_back(Edge(i, j, calc(i, j)));\n      }\n    }\n    double ans = Arborescence(g, m);\n    printf(\"%.8f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\n\n\nstruct edge\n{\n int begin;int end;\t\n};\n\nconst int maxx=120;\nbool vis[maxx],indfs[maxx];\nvector<double>zero;\nint n,m,root;\nvector<vector<double> >vec;\ndouble cost[maxx][maxx],Cost[maxx][maxx];\nbool operator <(const edge a,const edge b)\n{\n double ac=cost[a.begin][a.end];double bc=cost[b.begin][b.end];\n return ac>bc;//´?????´?????\t\n};\npriority_queue<edge>que[maxx];\ndouble minv(vector<double> a,vector<double> b)\n{\n double ab=0,bsqrt=0,asqrt=0;\n for(int i=0;i<a.size();i++)\n \t{ab+=a[i]*b[i];bsqrt+=b[i]*b[i];asqrt+=a[i]*a[i];}\n \t\n if((bsqrt-0.0)<1e-10)return asqrt;\n return asqrt-(ab*ab/bsqrt);\n}\nint belongcircle[maxx];\nint findbelong(int x)\n{\n if(x==belongcircle[x])return x;\n \telse return belongcircle[x]=findbelong(belongcircle[x]);\n}\n\ndouble ans,ansnow;\ndouble min(double a,double b)\n{\n if(a<b)return a;\n \telse return b;\n}\nvoid combinecircle(int now,int begin)\n{\n now=findbelong(now);\n if(vis[now])return ;\n belongcircle[now]=begin;\n vis[now]=true;\n edge e1=que[now].top();\n double coste=cost[e1.begin][e1.end];\n ansnow+=coste;\n\n for(int i=0;i<=m;i++)\n \t{\n \t edge e1=que[now].top();\n \t cost[begin][i]=min(cost[begin][i],cost[now][i]-coste);\n \t cost[i][begin]=min(cost[i][begin],cost[i][now]);\n\t}\n combinecircle(e1.end,begin);\n}\n\nbool findcircle(int now)\n{\n if(now==root)return false; \n now=findbelong(now);\n if(indfs[now])\n \t{\n \t memset(vis,0,sizeof(vis));\n \t combinecircle(now,now);\n \t while(!que[now].empty())que[now].pop();\n \t bool finish[maxx];\n \t memset(finish,0,sizeof(finish));\n \t for(int i=0;i<=m;i++)\n \t {  \n \t    int po=findbelong(i);\n \t    if(finish[po])continue;\n \t    finish[po]=true;\n \t    if(now==po)continue;\n\t    edge en;en.begin=now;en.end=po;\n \t \tque[now].push(en);\n \t }\n \t return true;\n\t}\n indfs[now]=true;\n return findcircle(que[now].top().end);\n}\n\n\nbool counted[maxx];\nint main()\n{\n ios::sync_with_stdio(false);\n cin>>n>>m;\n for(int i=0;i<n;i++)\n    zero.push_back(0.0);\n for(int i=0;i<m;i++)\n \t{\n\t vector<double>nowv;\n\t for(int j=0;j<n;j++)\n\t \t{ double nv;cin>>nv;nowv.push_back(nv);}\n\t vec.push_back(nowv);\n\t}\n vec.push_back(zero);\n for(int i=0;i<=m;i++)\n \tfor(int j=0;j<=m;j++)\n \t\t{ Cost[i][j]=minv(vec[i],vec[j]);}\n ans=999999999.0;\n root=m;\n \n ansnow=0;\n \t for(int i=0;i<=m;i++)\n \t   for(int j=0;j<=m;j++)\n \t\t{ cost[i][j]=Cost[i][j];}\n \t for(int i=0;i<=m;i++)\n \t \t{\n \t \t belongcircle[i]=i;\n \t \t while(!que[i].empty())que[i].pop();\n \t \t for(int j=0;j<=m;j++)\n \t \t \t{\n \t \t \t if(i==j)continue;\n \t \t \t edge en;en.begin=i;en.end=j;\n \t \t \t que[i].push(en);\n\t\t\t}\n\t\t}\n\t bool exis=false;\n\t \t do\n\t \t \t{\n\t \t \t exis=false;\n\t \t \t bool finish[maxx];\n\t \t \t memset(finish,0,sizeof(finish));\n\t \t \t for(int i=0;i<m;i++)\n\t \t \t {  \n\t\t\t    if(i==root)continue;\n\t\t\t    int po =findbelong(i);\n\t\t\t    if(finish[po])continue;\n\t \t \t    memset(indfs,0,sizeof(indfs));\n\t \t \t    exis=findcircle(po);\n\t \t \t    finish[po]=true;\n\t \t \t    if(exis)break;\n\t\t\t }\n\t\t\t}while(exis);\n\t memset(counted,0,sizeof(counted));\n\t for(int i=0;i<m;i++)\n\t \t{\n\t \t if(i==root)continue;\n\t\t int po=findbelong(i);\n\t\t if(counted[po])continue;\n\t\t counted[po]=true;\n\t\t ansnow+=cost[findbelong(que[po].top().begin)][findbelong(que[po].top().end)];\t\n\t\t}\n\t ans=min(ans,ansnow);\n cout<<ans<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100 + 10;\nconst int M = 10000 + 10;\nstruct edge\n{\n    int u, v;\n    double cost;\n    edge() {}\n    edge(int u, int v, double c): u(u), v(v), cost(c) {}\n} e[M];\nint pre[N], hash1[N], vis[N];\ndouble In[N];\ndouble Directed_MST(int root, int n, int m)\n{\n    double ret = 0;\n    while(true)\n    {\n        for(int i = 0; i < n; i++)\n            In[i] = INT_MAX;\n        for(int i = 0; i < m; i++) //找最小入?\n        {\n            int u = e[i].u;\n            int v = e[i].v;\n            if(e[i].cost < In[v] && u != v)\n            {\n                pre[v] = u;\n                In[v] = e[i].cost;\n            }\n        }\n        for(int i = 0; i < n; i++)\n        {\n            if(i == root)\n                continue;\n            if(In[i] == INT_MAX)\n                return -1;\n        }\n        int cntnode = 0;\n        memset(hash1, -1, sizeof(hash1));\n        memset(vis, -1, sizeof(vis));\n        In[root] = 0;\n        for(int i = 0; i < n; i++) //找?\n        {\n            ret += In[i];\n            int v = i;\n            while(vis[v] != i && hash1[v] == -1 && v != root)\n            {\n                vis[v] = i;\n                v = pre[v];\n            }\n            if(v != root && hash1[v] == -1)\n            {\n                for(int u = pre[v]; u != v; u = pre[u])\n                    hash1[u] = cntnode;\n                hash1[v] = cntnode++;\n            }\n        }\n        if(cntnode == 0)\n            break;\n        for(int i = 0; i < n; i++)\n            if(hash1[i] == -1)\n                hash1[i] = cntnode++;\n        for(int i = 0; i < m; i++) //重??\n        {\n            int v = e[i].v;\n            e[i].u = hash1[e[i].u];\n            e[i].v = hash1[e[i].v];\n            if(e[i].u != e[i].v)\n                e[i].cost -= In[v];\n        }\n        n = cntnode;\n        root = hash1[root];\n    }\n    return ret;\n}\nint n, m;\nconst int MAXV = 100 + 10;\ndouble vc[MAXV][MAXV];\ninline double sqr(double x) {return x * x;}\ndouble calCost(int a, int b, double r)\n{\n    double res = 0.0;\n    for(int i = 0; i < m; ++i)\n        res += sqr(vc[a][i] - r * vc[b][i]);\n    return res;\n}\ninline int sgn(double x) {return x < -1e-10 ? -1 : x > 1e-10 ? 1 : 0;}\nint main()\n{\n#ifdef ACM_TEST\n    freopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"in.txt\", \"w\", stdout);\n#endif\n    scanf(\"%d%d\", &m, &n);\n    for(int i = 1; i <= n; ++i)\n        for(int j = 0; j < m; ++j)\n            scanf(\"%lf\", &vc[i][j]);\n    int tot = 0;\n    for(int i = 1; i <= n; ++i)\n    {\n        e[tot++] = edge(0, i, calCost(i, 0, 0));\n    }\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n        {\n            if(i == j) continue;\n            double l = -1e9, r = 1e9, ll, rr;\n            while(sgn(r - l) > 0)\n            {\n                ll = (l + l + r) / 3.0;\n                rr = (l + r + r) / 3.0;\n                if(sgn(calCost(j, i, ll) - calCost(j, i, rr)) >= 0) l = ll;\n                else r = rr;\n            }\n            e[tot++] = edge(i, j, calCost(j, i, l));\n        }\n    double ans = Directed_MST(0, n + 1, tot);\n    printf(\"%.10f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n \n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n \ntypedef double Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n \nvoid PrintMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%.3f \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n \n \nvoid SocDfs(const Graph &g, int from, vector<int> &visit, vector<int> &st) {\n  visit[from] = 1;\n  for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n    if (visit[it->dest]) { continue; }\n    SocDfs(g, it->dest, visit, st);\n  }\n  st.push_back(from);\n}\n \nvector<vector<int> > Soc(const Graph &g) {\n  const int n = g.size();\n  vector<vector<int> > ret;\n  Graph revg(n);\n  for (int i = 0; i < n; i++) {\n    for (Edges::const_iterator it = g[i].begin(); it != g[i].end(); it++) {\n      revg[it->dest].push_back(Edge(it->dest, i, it->weight));\n    }\n  }\n  vector<int> st;\n  vector<int> visit(n, 0);\n  for (int i = 0; i < n; i++) {\n    if (visit[i]) { continue; }\n    SocDfs(g, i, visit, st);\n  }\n  visit = vector<int>(n, 0);\n  for (int i = n - 1; i >= 0; i--) {\n    int index = st[i];\n    if (visit[index]) { continue; }\n    vector<int> nret;\n    SocDfs(revg, index, visit, nret);\n    ret.push_back(nret);\n  }\n  return ret;\n}\n \n// need Soc\nWeight Arborescence(const Graph &g, int root) {\n  const int n = g.size();\n  Weight ret = 0;\n  vector<Weight> inCost(n, 1000000000LL);\n  vector<int> parent(n, -1);\n  for (int from = 0; from < n; from++) {\n    for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n      if (it->weight < inCost[it->dest]) {\n        parent[it->dest] = from;\n        inCost[it->dest] = it->weight;\n      }\n      inCost[it->dest] = min(inCost[it->dest], it->weight);\n    }\n  }\n  Graph ng(n);\n  for (int i = 0; i < n; i++) {\n    if (i == root) { continue; }\n    if (parent[i] == -1) { return 1000000000LL; }\n    ng[parent[i]].push_back(Edge(parent[i], i, 0));\n    ret += inCost[i];\n  }\n  vector<vector<int> > connect = Soc(ng);\n  int m = connect.size();\n  if (m == n) { return ret; }\n  vector<int> mapto(n, -1);\n  vector<int> cycle(n, 0);\n  ret = 0;\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < (int)connect[i].size(); j++) {\n      mapto[connect[i][j]] = i;\n      if (connect[i].size() != 1) {\n        cycle[connect[i][j]] = 1;\n        ret += inCost[connect[i][j]];\n      }\n    }\n  }\n  ng = Graph(m);\n  for (int from = 0; from < n; from++) {\n    for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n      int to = it->dest;\n      if (to == root || mapto[from] == mapto[to]) { continue; }\n      Weight cost = it->weight;\n      if (cycle[to]) {\n        cost -= inCost[to];\n      }\n      ng[mapto[from]].push_back(Edge(mapto[from], mapto[to], cost));\n    }\n  }\n  return min(1e+10, ret + Arborescence(ng, mapto[root]));\n  //return min(1000000000LL, ret + Arborescence(ng, mapto[root]));\n}\n \ndouble vect[110][110];\nint n, m;\n \ninline double square(double x) { return x * x; }\n \ndouble Len(int x) {\n  double ret = 0.0;\n  REP(i, n) { ret += square(vect[x][i]); }\n  return ret;\n}\ndouble Inner(int i, int j) {\n  double ret = 0.0;\n  REP(k, n) { ret += vect[i][k] * vect[j][k]; }\n  return ret;\n}\ndouble calc(int i, int j) {\n  double ret = 0.0;\n  ret += Len(j) - square(Inner(j, i)) / Len(i);\n  return ret;\n}\n \nint main() {\n  while (scanf(\"%d %d\", &n, &m) > 0) {\n    REP(i, m) {\n      REP(j, n) {\n        scanf(\"%lf\", &vect[i][j]);\n      }\n    }\n    Graph g(m + 1);\n    REP(i, m) {\n      g[m].push_back(Edge(m, i, Len(i)));\n    }\n    REP(i, m) {\n      REP(j, m) {\n        if (i == j) { continue; }\n        g[i].push_back(Edge(i, j, calc(i, j)));\n      }\n    }\n    double ans = Arborescence(g, m);\n    printf(\"%.8f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n//INSERT ABOVE HERE\ntemplate<typename T>\nstruct Arborescence{\n  struct SkewHeap{\n    using P = pair<T, int>;\n    const P INF;\n    const T add_identity;\n    SkewHeap(T inf):INF(inf,-1),add_identity(0){}\n\n    struct Node{\n      Node *l,*r;\n      P val;\n      T add;\n      Node(P val,T add):val(val),add(add){l=r=nullptr;}\n    };\n\n    P reflect(P x,T y){return P(x.first+y,x.second);}\n\n    void eval(Node *a){\n      if(a==nullptr) return;\n      if(a->add==add_identity) return;\n      if(a->l) a->l->add+=a->add;\n      if(a->r) a->r->add+=a->add;\n      a->val=reflect(a->val,a->add);\n      a->add=add_identity;\n    }\n\n    P top(Node *a){\n      return a?reflect(a->val,a->add):INF;\n    }\n\n    P snd(Node *a){\n      eval(a);\n      return a?min(top(a->l),top(a->r)):INF;\n    }\n\n    Node* add(Node *a,T d){\n      if(a) a->add+=d;\n      return a;\n    }\n\n    Node* push(T v,int i){\n      return new Node(P(v,i),add_identity);\n    }\n\n    Node* meld(Node *a,Node *b){\n      if(!a||!b) return a?a:b;\n      if(top(b)<top(a)) swap(a,b);\n      eval(a);\n      a->r=meld(a->r,b);\n      swap(a->l,a->r);\n      return a;\n    }\n\n    Node* pop(Node* a){\n      eval(a);\n      auto res=meld(a->l,a->r);\n      delete a;\n      return res;\n    }\n  };\n\n  struct UnionFind{\n    vector<int> r,p;\n    UnionFind(){}\n    UnionFind(int sz):r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    int find(int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(int x,int y){\n      return find(x)==find(y);\n    }\n    void unite(int x,int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n\n  struct edge{\n    int from,to;\n    T cost;\n    edge(){}\n    edge(int from,int to,T cost):from(from),to(to),cost(cost){}\n  };\n\n  int n;\n  vector<edge> es;\n\n  Arborescence(int n):n(n){};\n\n  void add_edge(int from,int to,T cost){\n    es.emplace_back(from,to,cost);\n  }\n\n  T build(int r){\n    UnionFind uf(n);\n    const T INF = numeric_limits<T>::max()/2;\n    SkewHeap hp(INF);\n    vector<typename SkewHeap::Node*> come(n,nullptr);\n    vector<int> used(n,0),from(n,-1);\n    vector<T> cost(n,-1);\n\n    used[r]=2;\n    for(int i=0;i<(int)es.size();i++){\n      edge &e=es[i];\n      come[e.to]=hp.meld(come[e.to],hp.push(e.cost,i));\n    }\n\n    T res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n        used[v]=1;\n        l.emplace_back(v);\n        if(!come[v]) return T(-1);\n        from[v]=uf.find(es[come[v]->val.second].from);\n        cost[v]=hp.top(come[v]).first;\n        come[v]=hp.pop(come[v]);\n        if(from[v]==v) continue;\n\n        res+=cost[v];\n        if(used[from[v]]==1){\n          int p=v;\n          do{\n            if(come[p]!=nullptr) hp.add(come[p],-cost[p]);\n            if(p!=v){\n              uf.unite(v,p);\n              come[v]=hp.meld(come[v],come[p]);\n            }\n            p=uf.find(from[p]);\n          }while(p!=v);\n        }else{\n          v=from[v];\n        }\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n};\n//END CUT HERE\n\nsigned AOJ_GRL_2B(){\n  int n,m,r;\n  cin>>n>>m>>r;\n  Arborescence<int> G(n);\n  for(int i=0;i<m;i++){\n    int s,t,w;\n    cin>>s>>t>>w;\n    G.add_edge(s,t,w);\n  }\n  cout<<G.build(r)<<endl;\n  return 0;\n}\n/*\n  verified on 201/05/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_B&lang=jp\n*/\n\nsigned AOJ_2309(){\n  double v[111][111];\n  double c[111][111];\n\n  Int n,m;\n  cin>>n>>m;\n  for(Int i=0;i<m;i++)\n    for(Int j=0;j<n;j++)\n      cin>>v[i][j];\n\n  for(Int i=0;i<m;i++){\n    c[i][i]=0;\n    for(Int j=0;j<n;j++) c[i][i]+=v[i][j]*v[i][j];\n  }\n\n  for(Int i=0;i<m;i++){\n    for(Int j=0;j<m;j++){\n      if(i==j) continue;\n      if(c[j][j]==0){\n        c[i][j]=c[i][i];\n        continue;\n      }\n      double r=0;\n      for(Int k=0;k<n;k++)\n        r+=v[i][k]*v[j][k];\n      r/=c[j][j];\n      c[i][j]=0;\n      for(Int k=0;k<n;k++)\n        c[i][j]+=(v[i][k]-r*v[j][k])*(v[i][k]-r*v[j][k]);\n    }\n  }\n\n  Arborescence<double> G(m+1);\n  for(Int i=0;i<m;i++){\n    G.add_edge(m,i,c[i][i]);\n    for(Int j=0;j<m;j++){\n      if(i==j) continue;\n      G.add_edge(j,i,c[i][j]);\n    }\n  }\n  cout<<fixed<<setprecision(12)<<G.build(m)<<endl;\n  return 0;\n}\n/*\n  verified on 2019/05/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2309\n*/\n\nsigned UVA_11183(){\n  Int T;\n  cin>>T;\n  for(Int t=1;t<=T;t++){\n    Int n,m;\n    cin>>n>>m;\n    Arborescence<Int> G(n);\n    for(int i=0;i<m;i++){\n      int s,t,w;\n      cin>>s>>t>>w;\n      G.add_edge(s,t,w);\n    }\n    Int ans=G.build(0);\n    cout<<\"Case #\"<<t<<\": \";\n    if(ans<0) cout<<\"Possums!\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2019/05/24\n  https://vjudge.net/problem/UVA-11183\n*/\n\n\nsigned main(){\n  //AOJ_GRL_2B();\n  AOJ_2309();\n  //UVA_11183();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\tGraph tree(g.size());\n\tld total_len = 0;\n\t{\n\t\tGraph revg(g.size());\n\n\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t}\n\t\t}\n\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\tif (node == start)continue;\n\t\t\telse {\n\t\t\t\tWeight amin = INF;\n\t\t\t\tEdge min_edge;\n\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amin < INF) {\n\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\t\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<Edge>memo(e_size);\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\te.src = compress;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\t\te.dst = compress;\n\t\t\t\t}\n\t\t\t\tnewg[e.src].push_back(e);\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<double, int> pii;\nint N, M;\ndouble vec[101][101];\ndouble dist[101][101];\nbool seen[101];\n\ndouble ternary_search(int p, int q) {\n    double lo = -100000, hi = 100000;\n    for (int i=0; i<100; ++i) {\n        double m1 = (2*lo + hi)/3, m2 = (lo + 2*hi)/3;\n        // calc norm(vec[p] - r*vec[q])\n        double n1 = 0.0, n2 = 0.0;\n        for (int j=0; j<N; ++j) {\n            n1 += (vec[p][j] - m1 * vec[q][j]) * (vec[p][j] - m1 * vec[q][j]);\n            n2 += (vec[p][j] - m2 * vec[q][j]) * (vec[p][j] - m2 * vec[q][j]);\n        }\n        if (n1 > n2) lo = m1;\n        else hi = m2;\n    }\n    double ret = 0;\n    for (int i=0; i<N; ++i)\n        ret += (vec[p][i] - lo * vec[q][i]) * (vec[p][i] - lo * vec[q][i]);\n    return ret;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i=0; i<M; ++i)\n        for (int j=0; j<N; ++j)\n            scanf(\"%lf\", &vec[i][j]);\n    for (int j=0; j<N; ++j)\n        vec[M][j] = 0.0;\n    M++;\n\n    for (int i=0; i<M; ++i)\n        for (int j=0; j<M; ++j) {\n            if (i == j) continue;\n            dist[j][i] = ternary_search(i, j);\n        }\n\n    memset(seen, false, sizeof(seen));\n    priority_queue<pii, vector<pii>, greater<pii> > q; q.push(make_pair(0, M-1));\n    double ans = 0;\n    while (!q.empty()) {\n        pii p = q.top(); q.pop();\n        int v = p.second;\n        if (seen[v]) continue;\n        seen[v] = true;\n        //printf(\"use %d %f\\n\", v, p.first);\n        ans += p.first;\n        for (int i = 0; i < M; ++i) {\n            if (seen[i] || i == v) continue;\n            //printf(\"add %d %d %lf\\n\", v, i, dist[v][i]);\n            q.push(make_pair(dist[v][i], i));\n        }\n    }\n\n    printf(\"%.12f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef ld Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\npair<Weight,Graph> chu_liu(const Graph&g, const int start) {\n\tGraph revg(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\t//vector<Edge>memo(g.size()*g.size());\n\tfor (auto es : g) {\n\t\tfor (auto e : es) {\n\t\t\t//memo[e.id] = e;\n\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t}\n\t}\n\tGraph tree(g.size());\n\tld total_len = 0;\n\tfor (int node = 0; node < g.size(); ++node) {\n\t\tif (node == start)continue;\n\t\telse {\n\t\t\tWeight amin = INF;\n\t\t\tEdge min_edge;\n\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\tmin_edge = Edge(reve.dst,reve.src, reve.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (amin < INF) {\n\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t}\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(g.size()*g.size());\n\n\t\tvector<pair<int,Weight>>prevs(g.size(), make_pair(-1,ZERO));\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tnode_is_cycle[ce.dst] = true;\n\t\t\tprevs[ce.dst] = make_pair(ce.src, ce.weight);\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prevs[e.dst].second, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start);\n\t\tGraph compress_tree(g.size());\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tEdge prev_edge(e);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tld fin_len = p.first + cycle_len;\n\t\treturn make_pair(fin_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start);\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst int N = 111;\nconst double eps = 1e-10;\nint n, m, pos[N];\ndouble v[N][N], val[N], dist[N][N];\n\ndouble get_r(int i, int j)\n{\n    double up = 0.0;\n    double down = 0.0;\n    for (int k = 1; k <= n; ++k) {\n        up += v[j][k] * v[i][k];\n        down += v[j][k] * v[j][k];\n    }\n    if (fabs(down) < eps) return 0;\n    return up / down;\n}\n\nbool cmp(const int &x, const int &y) {\n    return y < x;\n}\n\nnamespace Chuliu{\n    int n, used[N], pass[N], eg[N], more, que[N];\n    double g[N][N];\n    void combine(int id, double &sum) {\n        int tot = 0, from, i, j, k;\n        for ( ; id != 0 && !pass[id]; id = eg[id])\n            que[tot++] = id, pass[id] = 1;\n        for (from = 0; from < tot && que[from] != id; from++);\n        if (from == tot) return;\n\n        more = 1;\n        for (i = from; i < tot; i++) {\n            sum += g[eg[que[i]]][que[i]];\n            if (i == from) continue;\n            for (j = used[que[i]] = 1; j <= n; j++)\n                if (!used[j])\n                    if (g[que[i]][j] < g[id][j])\n                        g[id][j] = g[que[i]][j];\n        }\n        for (i = 1; i <= n; i++)\n            if (!used[i] && i != id) {\n                for (j = from; j < tot; j++) {\n                    k = que[j];\n                    if (g[i][id] > g[i][k] - g[eg[k]][k])\n                        g[i][id] = g[i][k] - g[eg[k]][k];\n                }\n            }\n    }\n    void clear(int V) {\n        n = V;\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                g[i][j] = dist[i][j];\n        for(int i = 1; i <= n; ++i)\n            g[i][i] = 0x3f3f3f3f;\n    }\n    double solve(int root) {\n        int i, j, k;\n        double sum = 0.0;\n        memset(used, 0, sizeof(int) * (n + 1));\n        for (more = 1; more; ) {\n            more = 0;\n            memset(eg, 0, sizeof(int) * (n + 1));\n            for (i = 1; i <= n; i++)\n                if (!used[i] && i != root) {\n                    for (j = 1, k = 0; j <= n; j++)\n                        if (!used[j] && i != j)\n                            if (k == 0 || g[j][i] < g[k][i]) k = j;\n                    eg[i] = k;\n                }\n            memset(pass, 0, sizeof(int) * (n + 1));\n            for (i = 1; i <= n; i++)\n                if (!used[i] && !pass[i] && i != root)\n                    combine(i, sum);\n        }\n        for (i = 1; i <= n; ++i)\n            if (!used[i] && i != root)\n                sum += g[eg[i]][i];\n        return sum;\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    double max_val = 0;\n    for (int i = 1; i <= m; ++i) {\n        val[i] = 0.0;\n        for (int j = 1; j <= n; ++j) {\n            cin >> v[i][j];\n            val[i] += v[i][j] * v[i][j];\n        }\n    }\n    \n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            dist[j][i] = 0.0;\n            double r = get_r(i, j);\n            for (int k = 1; k <= n; ++k)\n                dist[j][i] += (v[i][k] - r * v[j][k]) * (v[i][k] - r * v[j][k]);\n            max_val += dist[j][i];\n        }\n    }\n    max_val *= 2.0;\n    for (int i = 1; i <= m; ++i)\n        dist[i][m + 1] = dist[m + 1][i] = max_val + val[i];\n\n    Chuliu::clear(m + 1);\n    double ans = Chuliu::solve(m + 1) - max_val;\n\n    cout << setiosflags(ios::fixed) << setprecision(10) << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100 + 10;\nconst int M = 10000 + 10;\nstruct edge\n{\n    int u, v;\n    double cost;\n    edge() {}\n    edge(int u, int v, double c): u(u), v(v), cost(c) {}\n} e[M];\nint pre[N], hash1[N], vis[N];\ndouble In[N];\ndouble Directed_MST(int root, int n, int m)\n{\n    double ret = 0;\n    while(true)\n    {\n        for(int i = 0; i < n; i++)\n            In[i] = INT_MAX;\n        for(int i = 0; i < m; i++) //找最小入?\n        {\n            int u = e[i].u;\n            int v = e[i].v;\n            if(e[i].cost < In[v] && u != v)\n            {\n                pre[v] = u;\n                In[v] = e[i].cost;\n            }\n        }\n        for(int i = 0; i < n; i++)\n        {\n            if(i == root)\n                continue;\n            if(In[i] == INT_MAX)\n                return -1;\n        }\n        int cntnode = 0;\n        memset(hash1, -1, sizeof(hash1));\n        memset(vis, -1, sizeof(vis));\n        In[root] = 0;\n        for(int i = 0; i < n; i++) //找?\n        {\n            ret += In[i];\n            int v = i;\n            while(vis[v] != i && hash1[v] == -1 && v != root)\n            {\n                vis[v] = i;\n                v = pre[v];\n            }\n            if(v != root && hash1[v] == -1)\n            {\n                for(int u = pre[v]; u != v; u = pre[u])\n                    hash1[u] = cntnode;\n                hash1[v] = cntnode++;\n            }\n        }\n        if(cntnode == 0)\n            break;\n        for(int i = 0; i < n; i++)\n            if(hash1[i] == -1)\n                hash1[i] = cntnode++;\n        for(int i = 0; i < m; i++) //重??\n        {\n            int v = e[i].v;\n            e[i].u = hash1[e[i].u];\n            e[i].v = hash1[e[i].v];\n            if(e[i].u != e[i].v)\n                e[i].cost -= In[v];\n        }\n        n = cntnode;\n        root = hash1[root];\n    }\n    return ret;\n}\nint n, m;\nconst int MAXV = 100 + 10;\ndouble vc[MAXV][MAXV];\ninline double sqr(double x) {return x * x;}\ndouble calCost(int a, int b, double r)\n{\n    double res = 0.0;\n    for(int i = 0; i < m; ++i)\n        res += sqr(vc[a][i] - r * vc[b][i]);\n    return res;\n}\nconst double EPS = 1e-9;\ninline int sgn(double x) {return x < -EPS ? -1 : x > EPS ? 1 : 0;}\nint main()\n{\n#ifdef ACM_TEST\n    freopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"in.txt\", \"w\", stdout);\n#endif\n    scanf(\"%d%d\", &m, &n);\n    for(int i = 1; i <= n; ++i)\n        for(int j = 0; j < m; ++j)\n            scanf(\"%lf\", &vc[i][j]);\n    int tot = 0;\n    for(int i = 1; i <= n; ++i)\n    {\n        e[tot++] = edge(0, i, calCost(i, 0, 0));\n    }\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n        {\n            if(i == j) continue;\n            double l = -1e8, r = 1e8, ll, rr;\n            while(sgn(r - l) > 0)\n            {\n                ll = (l + l + r) / 3.0;\n                rr = (l + r + r) / 3.0;\n                if(sgn(calCost(j, i, ll) - calCost(j, i, rr)) >= 0) l = ll;\n                else r = rr;\n            }\n            e[tot++] = edge(i, j, calCost(j, i, l));\n        }\n    double ans = Directed_MST(0, n + 1, tot);\n    printf(\"%.10f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <map>\n#include <climits>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned UI;\ntypedef pair<int, int> PAIR;\n \nconst int MAXN(110);\nconst int MAXE(11000);\nconst int MAXK(100010);\nconst int MAXL(10);\nconst int MAXC(2);\nconst int INF((INT_MAX - 1) / 2);\nconst int F(0);\n\ntemplate<typename T>\ninline bool checkmax(T &a, const T &b) {\n\treturn b > a ? ((a = b), true) : false;\n}\n\ntemplate<typename T>\ninline bool checkmin(T &a, const T &b) {\n\treturn b < a ? ((a = b), true) : false;\n}\n\ntemplate<typename T>\ninline T ABS(T a) {\n\treturn a < 0 ? -a : a;\n}\n\ndouble dis(double x1, double y1, double x2, double y2) {\n\treturn sqrt((y2 - y1)*(y2 - y1) + (x2 - x1)*(x2 - x1));\n}\n\ndouble dis2(double x1, double y1, double x2, double y2) {\n\treturn (y2 - y1)*(y2 - y1) + (x2 - x1)*(x2 - x1);\n}\n\nint dcmp(double a, double b) {\n\tif (ABS(b - a) < 1e-11) return 0;\n\treturn a < b ? -1 : 1;\n}\n\nstruct E {\n\tint u, v;\n\tdouble w;\n\tE(int u_, int v_, double w_) :u(u_), v(v_), w(w_) {}\n\tE() {}\n\tfriend bool operator <(const E &a, const E &b) {\n\t\treturn a.w == b.w ? (a.u == b.u ? a.v < b.v : a.u < b.u) : a.w < b.w;\n\t}\n};\n\nint pre[MAXN];\nint vis[MAXN];\nint myHash[MAXN];\n\ndouble DMST(int n, int rt, int en, E *e) { //事先?保?解存在；可以?理平行?，自?，和指向rt的?；但?了效率考?，最好提前?理掉?些?\n\tdouble ret = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; ++i) pre[i] = -1;\n\t\tfor (int i = 0; i < en; ++i) {\n\t\t\tif (e[i].u == e[i].v || e[i].v == rt) continue;\n\t\t\tint v = e[i].v;\n\t\t\tif (pre[v] == -1 || e[i].w < e[pre[v]].w)\n\t\t\t\tpre[v] = i;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tvis[i] = -1;\n\t\t\tmyHash[i] = -1;\n\t\t\tif (pre[i] == -1 && i != rt) return -1;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == rt) continue;\n\t\t\tret += e[pre[i]].w;\n\t\t\tif (vis[i] != -1) continue;\n\t\t\tint u = i;\n\t\t\t//while (u != rt && vis[u] == -1) {\n\t\t\twhile (u != rt && myHash[u] == -1 && vis[u] != i) {\n\t\t\t\tvis[u] = i;\n\t\t\t\tu = e[pre[u]].u;\n\t\t\t}\n\t\t\t//if(u != rt && vis[u] == i) {\n\t\t\tif (u != rt && myHash[u] == -1) {\n\t\t\t\tint t = u;\n\t\t\t\tdo {\n\t\t\t\t\tmyHash[u] = cnt;\n\t\t\t\t\tu = e[pre[u]].u;\n\t\t\t\t} while (u != t);\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0) return ret;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (myHash[i] != -1) continue;\n\t\t\tmyHash[i] = cnt++;\n\t\t}\n\t\tfor (int i = 0; i < en; ++i) {\n\t\t\tif (e[i].v == rt) continue;\n\t\t\te[i].w -= e[pre[e[i].v]].w;\n\t\t\te[i].u = myHash[e[i].u];\n\t\t\te[i].v = myHash[e[i].v];\n\t\t}\n\t\trt = myHash[rt];\n\t\tn = cnt;\n\t}\n}\n\nE edge[MAXE];\nint en;\n\ndouble dat[110][110];\ndouble squSum[110];\n\ndouble calCost(int u, int v, int dim) {\n\tswap(u, v);\n\tdouble a = squSum[v], b = 0, c = squSum[u];\n\tfor (int i = 0; i < dim; ++i) b += dat[u][i] * dat[v][i];\n\tdouble x = b/a;\n\tb *= -2;\n\treturn a*x*x + b*x + c;\n}\n\nint main() {\n\tint dim, n;\n\tscanf(\"%d%d\", &dim, &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < dim; ++j)\n\t\t\tscanf(\"%lf\", dat[i] + j);\n\tfor (int i = 0; i < n; ++i) {\n\t\tsquSum[i] = 0;\n\t\tfor (int j = 0; j < dim; ++j)\n\t\t\tsquSum[i] += dat[i][j] * dat[i][j];\n\t}\n\ten = 0;\n\tfor (int i = 0; i < n; ++i) edge[en++] = E(n, i, squSum[i]);\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (i == j) continue;\n\t\t\tedge[en++] = E(i, j, calCost(i, j, dim));\n\t\t}\n\tprintf(\"%.8f\\n\", DMST(n + 1, n, en, edge));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid backward_traverse(int v, int s, int r, Matrix &g,\n  vector<int> &no, vector< vector<int> > &comp,\n  vector<int> &prev, vector<Weight> &mcost,\n  vector<int> &mark, Weight &cost, bool &found) {\n  const int n = g.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    for (int j = 0; j < n; ++j)\n      if (j != r && no[j] == s)\n        for (int i = 0; i < n; ++i)\n          if (no[i] != s && g[i][j] < INF)\n            g[i][j] -= mcost[ temp[j] ];\n  }\n  mark[v] = true;\n  for (int i = 0; i < n; ++i)\n    if (no[i] != no[v] && prev[ no[i] ] == v)\n      if (!mark[ no[i] ] || i == s)\n        backward_traverse(i, s, r, g,\n            no, comp, prev, mcost, mark, cost, found);\n}\n\nWeight minimum_spanning_arborescence(int r, Matrix &g) {\n  const int n = g.size();\n\n  vector<int> no(n);\n  vector< vector<int> > comp(n);\n  for (int i = 0; i < n; ++i) {\n    no[i] = i;\n    comp[i].push_back(i);\n  }\n  Weight cost = 0;\n  while (1) {\n    vector<int> prev(n, -1);\n    vector<Weight> mcost(n, INF);\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        if (j == r) continue;\n        if (no[i] != no[j] && g[i][j] < INF) {\n          if (g[i][j] < mcost[ no[j] ]) {\n            mcost[ no[j] ] = g[i][j];\n            prev[ no[j] ] = no[i];\n          }\n        }\n      }\n    }\n    bool stop = true;\n    vector<int> mark(n);\n    for (int i = 0; i < n; ++i) {\n      if (i == r || mark[i] || comp[i].size() == 0) continue;\n      bool found = false;\n      backward_traverse(i, i, r, g,\n          no, comp, prev, mcost, mark, cost, found);\n      if (found) stop = false;\n    }\n    if (stop) {\n      for (int i = 0; i < n; ++i)\n        if (prev[i] >= 0)\n          cost += mcost[i];\n      return cost;\n    }\n  }\n}\n\ndouble v[100][100];\nint n, m;\ndouble dot(int i, int j) {\n  double res = 0;\n  REP(k,n) {\n    res += v[i][k] * v[j][k];\n  }\n  return res;\n}\n\ndouble cost(int i, int j) {\n  if (dot(i,i) < EPS) return dot(j,j);\n  double r = dot(i,j) / dot(i,i);\n  double res = 0;\n  REP(k,n) {\n    double t = v[j][k] - r * v[i][k];\n    res += t * t;\n  }\n  return res;\n}\n\nint main() {\n  while(cin>>n>>m) {\n    REP(i,m) REP(j,n) cin>>v[i][j];\n    Matrix g(m+1,Array(m+1,INF));\n    REP(i,m) {\n      REP(j,m) {\n        if (i==j) continue;\n        g[i][j] = cost(i,j);\n      }\n      g[m][i] = dot(i,i);\n    }\n    // REP(i,m+1) {\n    //   REP(j,m+1) {\n    //     cout << g[i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    double res = minimum_spanning_arborescence(m,g);\n    printf(\"%.10f\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(),-1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now]!=-1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tld total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t}\n\t\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<Edge>memo(e_size);\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\te.src = compress;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\t\te.dst = compress;\n\t\t\t\t}\n\t\t\t\tnewg[e.src].push_back(e);\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define re(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using C = function<bool(T,T)>;\n  G g;\n  H h;\n  C c;\n  T INF;\n  E ei;\n  SkewHeap(G g,H h,C c,T INF,E ei):g(g),h(h),c(c),INF(INF),ei(ei){}\n  \n  struct Node{\n    Node *l,*r;\n    T val;\n    E add;\n    Node(T val,E add):val(val),add(add){l=r=nullptr;}\n  };\n\n  void eval(Node *a){\n    if(a==nullptr) return;\n    if(a->add==ei) return;\n    if(a->l) a->l->add=h(a->l->add,a->add);\n    if(a->r) a->r->add=h(a->r->add,a->add);\n    a->val=g(a->val,a->add);\n    a->add=ei;\n  }\n  \n  T top(Node *a){\n    return a!=nullptr?g(a->val,a->add):INF;\n  }\n\n  T snd(Node *a){\n    eval(a);\n    return a!=nullptr?min(top(a->l),top(a->r)):INF;\n  }\n\n  Node* add(Node *a,E d){\n    if(a!=nullptr) a->add=h(a->add,d);\n    return a;\n  }\n  \n  Node* push(T v){\n    return new Node(v,ei);\n  }\n  \n  Node* meld(Node *a,Node *b){\n    using V = tuple<Node*, Node*>;\n    stack<V> st;\n    Node* res;\n  ENTRYPOINT:\n    if(!a||!b) res=a?a:b;\n    else{\n      if(c(top(a),top(b))) swap(a,b);\n      eval(a);\n      st.emplace(a,b);\n      a=a->r;\n      goto ENTRYPOINT;\n    RETURNPOINT:\n      tie(a,b)=st.top();st.pop();\n      a->r=res;\n      swap(a->l,a->r);\n      res=a;\n    }\n    if(!st.empty()) goto RETURNPOINT;\n    return res;\n  }\n  \n  Node* pop(Node* a){\n    eval(a);\n    auto res=meld(a->l,a->r);\n    delete a;\n    return res;\n  }\n  \n};\n\n//INSERT ABOVE HERE\ntemplate<typename T>\nstruct Arborescence{\n  typedef pair<T, int> P;\n  using Heap = SkewHeap<P, T>;\n  \n  struct edge{\n    int from,to;\n    T cost;\n    edge(){}\n    edge(int from,int to,T cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  P INF;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<typename Heap::Node*> come;\n  vector<int> used,from;\n  vector<T> cost;\n  \n  Arborescence(int n,T INF):n(n),INF(INF,-1),uf(n),come(n,NULL),\n                used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,T cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v;\n      T c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  T build(int r){\n    typename Heap::G g=[](P a,T b){return P(a.first+b,a.second);};\n    typename Heap::H h=[](T a,T b){return a+b;};\n    typename Heap::C c=[](P a,P b){return a>b;};\n    Heap heap(g,h,c,INF,0);\n  \n    used[r]=2;\n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      come[e.to]=heap.meld(come[e.to],heap.push(P(e.cost,i)));\n    }\n    \n    T res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n    used[v]=1;\n    l.emplace_back(v);\n    if(!come[v]) return T(-1);\n    from[v]=uf.find(edges[come[v]->val.second].from);\n    cost[v]=heap.top(come[v]).first;\n    come[v]=heap.pop(come[v]);\n    if(from[v]==v) continue;\n    \n    res+=cost[v];\n    if(used[from[v]]==1){\n      int p=v;\n      do{\n        if(come[p]!=nullptr) heap.add(come[p],-cost[p]);\n        if(p!=v){\n          uf.unite(v,p);\n          come[v]=heap.meld(come[v],come[p]);\n        }\n        p=uf.find(from[p]);\n      }while(p!=v);\n    }else{\n      v=from[v];\n    }\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n};\n\nint n,m;\ndouble v[111][111];\ndouble cost[111][111];\nsigned main(){\n  cin>>n>>m;\n  Arborescence<double> G(m+1,1e14);\n  re(i,m)re(j,n)cin>>v[i][j];\n  re(j,n)v[m][j]=0;\n  re(i,m)re(j,m){\n    if(i==j)continue;\n    double L=-1000,R=1000;\n    re(k,50){\n      double mid=(L+R)/2;\n      double s1=0,s2=0;\n      re(l,n)s1+=abs(v[j][l]-mid*v[i][l])*abs(v[j][l]-mid*v[i][l]);\n      re(l,n)s2+=abs(v[j][l]-(mid+1e-6)*v[i][l])*abs(v[j][l]-(mid+1e-6)*v[i][l]);\n      if(s1>s2)L=mid;\n      else R=mid;\n    }\n    double sum=0;\n    re(l,n)sum+=abs(v[j][l]-L*v[i][l])*abs(v[j][l]-L*v[i][l]);\n    G.add_edge(i,j,sum);\n  }\n  re(i,m){\n    double sum=0;\n    re(l,n)sum+=v[i][l]*v[i][l];\n    G.add_edge(m,i,sum);\n  }\n  printf(\"%.9f\\n\", G.build(m));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (now == i) {\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tld total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t}\n\t\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<Edge>memo(e_size);\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\te.src = compress;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\t\te.dst = compress;\n\t\t\t\t}\n\t\t\t\tnewg[e.src].push_back(e);\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef pair<double,int> P;\nint N,M,from[101],nid[101];\ndouble inf=1e5,d[101][101],d2[101][101];\nbool vis[101];\nvector<int> cycle;\nbool visit(int v,int s,int r){\n\tif(v==r) return 0;\n\tif(vis[v]) return v==s;\n\tcycle.pb(v);\n\tvis[v]=1;\n\treturn visit(from[v],s,r);\n}\ndouble dir_msp(int r){\t//root = r\n\tint S=N;\n\tbool update=1;\n\twhile(update){\n//\t\tprintf(\"   S=%d\\n\",S);\n\t\tupdate=0;\n\t\tdouble sco=0;\n/*\t\trep(i,S){\n\t\t\trep(j,S) printf(\"%.2f \",d[i][j]);\n\t\t\tputs(\"\");\n\t\t}*/\n\t\trep(i,S){\n\t\t\tif(i==r) continue;\n\t\t\tP mn=P(inf,-1);\n\t\t\trep(j,S) if(i!=j) mn=min(mn,P(d[j][i],j));\n\t\t\tif(mn.fs==inf) return inf;\n\t\t\tfrom[i]=mn.sc;\n\t\t\tsco+=mn.fs;\n//\t\t\tprintf(\"from[%d]=%d\\n\",i,from[i]);\n//\t\t\tshow(sco);\n\t\t}\n\t\trep(i,S){\n\t\t\tif(i==r) continue;\n\t\t\trep(j,S) vis[j]=0;\n\t\t\tcycle.clear();\n\t\t\tif(!visit(i,i,r)) continue;\n\t\t\tupdate=1;\n\t\t\tint len=cycle.size();\n\t\t\tcycle.pb(cycle[0]);\n\t\t\tint S2=S-len+1,it=0;\n\t\t\trep(j,S){\n\t\t\t\tif(!vis[j]) nid[j]=it++;\n\t\t\t\telse nid[j]=-1;\n\t\t\t}\n\t\t\tr=nid[r];\n\t\t\trep(j,S) if(nid[j]!=-1){\t\t//o->o\n\t\t\t\trep(k,S) if(nid[k]!=-1){\n\t\t\t\t\td2[nid[j]][nid[k]]=d[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,S) if(nid[j]!=-1){\t\t//i->o\n\t\t\t\tdouble mn=inf;\n\t\t\t\trep(k,S) if(nid[k]==-1) mn=min(mn,d[k][j]);\n\t\t\t\td2[S2-1][nid[j]]=mn;\n\t\t\t}\n\t\t\tdouble csum=0;\n\t\t\trep(j,len) csum+=d[cycle[j+1]][cycle[j]];\n\t\t\trep(j,S) if(nid[j]!=-1){\n\t\t\t\tdouble mn=inf;\n\t\t\t\trep(k,len){\n\t\t\t\t\tmn=min(mn,d[j][cycle[k]]+csum-d[cycle[k+1]][cycle[k]]);\n\t\t\t\t}\n\t\t\t\td2[nid[j]][S2-1]=mn;\n\t\t\t}\n\t\t\tS=S2;\n\t\t\trep(j,S) rep(k,S) d[j][k]=d2[j][k];\n\t\t\tbreak;\n\t\t}\n\t\tif(!update) return sco;\n\t}\n}\ndouble v[101][100];\nint main(){\n\tcin>>M>>N;\n\trep(i,N) rep(j,M) cin>>v[i+1][j];\n\tN++;\n\trep(i,N) rep(j,N) if(i!=j){\n\t\tdouble a=0,b=0,c=0,r=0;\n\t\trep(k,M) a+=v[j][k]*v[j][k];\n\t\trep(k,M) b+=2*v[i][k]*v[j][k];\n\t\trep(k,M) c+=v[i][k]*v[i][k];\n\t\tif(a==0) r=0;\n\t\telse r=b/2/a;\n\t\td[j][i]=a*r*r-b*r+c;\n\t}\n/*\trep(i,N){\n\t\trep(j,N) printf(\"%.2f \",d[i][j]);\n\t\tcout<<endl;\n\t}*/\n\tprintf(\"%.12f\\n\",dir_msp(0));\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef ld Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\tGraph revg(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\t//vector<Edge>memo(g.size()*g.size());\n\tfor (auto es : g) {\n\t\tfor (auto e : es) {\n\t\t\t//memo[e.id] = e;\n\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t}\n\t}\n\tGraph tree(g.size());\n\tld total_len = 0;\n\tfor (int node = 0; node < g.size(); ++node) {\n\t\tif (node == start)continue;\n\t\telse {\n\t\t\tWeight amin = INF;\n\t\t\tEdge min_edge;\n\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\tmin_edge = Edge(reve.dst,reve.src, reve.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (amin < INF) {\n\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t}\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<pair<int,Weight>>prevs(g.size(), make_pair(-1,ZERO));\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tnode_is_cycle[ce.dst] = true;\n\t\t\tprevs[ce.dst] = make_pair(ce.src, ce.weight);\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prevs[e.dst].second, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, (M*(M + 1)));\n\t\tGraph compress_tree(g.size());\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tEdge prev_edge(e);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tld fin_len = p.first + cycle_len;\n\t\treturn make_pair(fin_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(M*(M+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\tGraph tree(g.size());\n\tld total_len = 0;\n\t{\n\t\tGraph revg(g.size());\n\n\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\t//memo[e.id] = e;\n\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t}\n\t\t}\n\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\tif (node == start)continue;\n\t\t\telse {\n\t\t\t\tWeight amin = INF;\n\t\t\t\tEdge min_edge;\n\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amin < INF) {\n\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(g.size()*g.size());\n\n\t\tvector<pair<int,Weight>>prevs(g.size(), make_pair(-1,ZERO));\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tnode_is_cycle[ce.dst] = true;\n\t\t\tprevs[ce.dst] = make_pair(ce.src, ce.weight);\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prevs[e.dst].second, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(g.size());\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tEdge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tld fin_len = p.first + cycle_len;\n\t\treturn make_pair(fin_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100 + 10;\nconst int M = 10000 + 10;\nstruct edge\n{\n    int u, v;\n    double cost;\n    edge() {}\n    edge(int u, int v, double c): u(u), v(v), cost(c) {}\n} e[M];\nint pre[N], hash1[N], vis[N];\ndouble In[N];\ndouble Directed_MST(int root, int n, int m)\n{\n    double ret = 0;\n    while(true)\n    {\n        for(int i = 0; i < n; i++)\n            In[i] = INT_MAX;\n        for(int i = 0; i < m; i++) //找最小入?\n        {\n            int u = e[i].u;\n            int v = e[i].v;\n            if(e[i].cost < In[v] && u != v)\n            {\n                pre[v] = u;\n                In[v] = e[i].cost;\n            }\n        }\n        for(int i = 0; i < n; i++)\n        {\n            if(i == root)\n                continue;\n            if(In[i] == INT_MAX)\n                return -1;\n        }\n        int cntnode = 0;\n        memset(hash1, -1, sizeof(hash1));\n        memset(vis, -1, sizeof(vis));\n        In[root] = 0;\n        for(int i = 0; i < n; i++) //找?\n        {\n            ret += In[i];\n            int v = i;\n            while(vis[v] != i && hash1[v] == -1 && v != root)\n            {\n                vis[v] = i;\n                v = pre[v];\n            }\n            if(v != root && hash1[v] == -1)\n            {\n                for(int u = pre[v]; u != v; u = pre[u])\n                    hash1[u] = cntnode;\n                hash1[v] = cntnode++;\n            }\n        }\n        if(cntnode == 0)\n            break;\n        for(int i = 0; i < n; i++)\n            if(hash1[i] == -1)\n                hash1[i] = cntnode++;\n        for(int i = 0; i < m; i++) //重??\n        {\n            int v = e[i].v;\n            e[i].u = hash1[e[i].u];\n            e[i].v = hash1[e[i].v];\n            if(e[i].u != e[i].v)\n                e[i].cost -= In[v];\n        }\n        n = cntnode;\n        root = hash1[root];\n    }\n    return ret;\n}\nint n, m;\nconst int MAXV = 100 + 10;\ndouble vc[MAXV][MAXV];\ndouble A, B, C;\ninline double calCost(double r)\n{\n    return A - r * B + r * r * C;\n}\nconst double EPS = 1e-10;\ninline int sgn(double x) {return x < -EPS ? -1 : x > EPS ? 1 : 0;}\nint main()\n{\n#ifdef ACM_TEST\n    freopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"in.txt\", \"w\", stdout);\n#endif\n    scanf(\"%d%d\", &m, &n);\n    for(int i = 1; i <= n; ++i)\n        for(int j = 0; j < m; ++j)\n            scanf(\"%lf\", &vc[i][j]);\n    int tot = 0;\n    for(int i = 1; i <= n; ++i)\n    {\n        double val = 0.0;\n        for(int j = 0; j < m; ++j)\n            val += vc[i][j] * vc[i][j];\n        e[tot++] = edge(0, i, val);\n    }\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n        {\n            if(i == j) continue;\n            A = 0, B = 0, C = 0;\n            for(int k = 0; k < m; ++k)\n            {\n                A += vc[i][k] * vc[i][k];\n                B += 2.0 * vc[i][k] * vc[j][k];\n                C += vc[j][k] * vc[j][k];\n            }\n            double l = -1e8, r = 1e8, ll, rr;\n            for(int k = 0; k < 100; ++k)\n            {\n                ll = (l + l + r) / 3.0;\n                rr = (l + r + r) / 3.0;\n                if(sgn(calCost(ll) - calCost(rr)) >= 0) l = ll;\n                else r = rr;\n            }\n            e[tot++] = edge(j, i, calCost(l));\n        }\n    double ans = Directed_MST(0, n + 1, tot);\n    printf(\"%.10f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (now == i) {\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tld total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t}\n\t\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<Edge>memo(e_size);\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\te.src = compress;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\t\te.dst = compress;\n\t\t\t\t}\n\t\t\t\tnewg[e.src].push_back(e);\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n\nconst double EPS = 1e-8;\ntypedef double Weight;\nconst Weight inf = 1LL << 50;\n\nstruct Edge {int src, dst; Weight weight;};\n\nstruct DMST {\n  int N;\n  vector< vector<Edge> > g;\n\n  DMST (int n) {\n    N = n;\n    g.clear();\n    g.resize(n);\n  }\n\n  vector<int> prev, visited;\n  vector<Weight> min_weight;\n\n  // rootツづーツ債ェツづつオツつスツ有ツ古シツ催渉ャツ全ツ暗ヲツ姪伉づーツ仰づ淞づゥ\n  // gツづ債破ツ嘉ウツつウツづェツづゥ\n  Weight dMST(int root) {\n\n    // ツづ債つカツづ淞づ詠ootツつゥツづァツ全ツ点ツづ可督楪達ツ嘉つ能ツづづ按つ「ツづ按づァreturn inf\n    visited.assign(N, 0);\n    visited[root] = 1;\n    vector<int> S; S.push_back(root);\n    while( !S.empty() ) {\n        int cur = S.back(); S.pop_back();\n        REP(i, g[cur].size()) {\n            int next = g[cur][i].dst;\n            if( !visited[next] ) {\n                visited[next] = 1;\n                S.push_back(next);\n            }\n        }\n    }\n    if( count(ALL(visited), 1) != N ) return inf;\n\n    Weight total_weight = 0;\n    for(;;) {\n        prev.assign(N, -1);\n        min_weight.assign(N, inf);\n\n        // ツ各ツ陳クツ点ツづ可禿シツづゥツ催渉ャツづ個陛督つセツつッツつゥツづァツづ按づゥツグツδ可フツづーツ催ャツづゥ\n        REP(i, N) REP(j, g[i].size()) {\n            const Edge &e = g[i][j];\n            if( e.dst != root && e.src != e.dst && min_weight[e.dst] > e.weight ) {\n                min_weight[e.dst] = e.weight;\n                prev[e.dst] = e.src;\n            }\n        }\n\n        // ツ仰ュツ連ツ個仰青ャツ閉ェツ閉ェツ嘉ーツづサツイツクツδ仰づーツ個淞出\n        vector<int> order;\n        visited.assign(N, 0);\n        REP(i, N) if( !visited[i] && prev[i] != -1 ) dfs(i, order);\n        visited.assign(N, -1);\n        int scc_num = 0;\n        for(int i = order.size() - 1; i >= 0; i--)\n            if( visited[order[i]] == -1 )\n                rdfs(order[i], scc_num++);\n\n        // ツ適ツ静伉づ可エツッツジツづ個重ツづ敖づーツ更ツ新ツつオツづ按つェツづァツサツイツクツδ仰づーツ縮ツ姪アツつキツづゥ\n        bool stop = true;\n        REP(scc, scc_num) {\n            if( count( ALL(visited), scc) >= 2 ) {\n                stop = false;\n                // ツ縮ツ姪ア\n                int contract = N;\n                REP(i, N) if( visited[i] == scc) { contract = i; break; }\n                Weight cycle_sum = 0;\n                REP(i, N) if( visited[i] == scc) cycle_sum += min_weight[i];\n\n                REP(i, N) REP(j, g[i].size()) {\n                    Edge &e = g[i][j];\n                    if( visited[e.dst] == scc) e.weight += cycle_sum - min_weight[e.dst];\n                    if( visited[e.src] == scc) e.src = contract;\n                    if( visited[e.dst] == scc) e.dst = contract;\n                }\n            }\n        }\n\n        if( stop ) {\n            REP(i, N) if( prev[i] != -1 ) total_weight += min_weight[i];\n            break;\n        }\n    }\n    return total_weight;\n  }\n\n  void dfs(int p, vector<int> &order) {\n    visited[p] = 1;\n    if( prev[p] != -1 && !visited[prev[p]] ) dfs(prev[p], order);\n    order.push_back(p);\n  }\n  void rdfs(int p, int scc) {\n    visited[p] = scc;\n    REP(i, N) if( prev[i] == p && visited[i] == -1 ) rdfs(i, scc);\n  }\n\n  void debug() {\n    REP(i, N) {\n        cout << i << \" : \";\n        REP(j, g[i].size()) cout << \"(\" << g[i][j].src << \"->\" << g[i][j].dst << \" \" << g[i][j].weight << \") \";\n        cout << endl;\n    }\n  }\n};\n\n\nint main() {\n  int N, M;\n  scanf(\"%d%d\", &N, &M);\n\n  vector<double> v[M + 1];\n  REP(m, M) {\n      REP(n, N) {\n          double x; cin >> x;\n          v[m].push_back(x);\n      }\n  }\n  v[M] = vector<double>(N, 0.0);\n\n  DMST dmst(M + 1);\n  REP(i, M) REP(j, M + 1) if (i != j) {\n      double p = 0, q = 0;\n      REP(k, N) p += v[i][k] * v[j][k];\n      REP(k, N) q += v[j][k] * v[j][k];\n      double r = p / q;\n      if (abs(q) < EPS) r = 0;\n//       cout << i << \" \" << j << \" \" << r << endl;\n      double w = 0;\n      REP(k, N) {\n          w += (v[i][k] - v[j][k] * r) * (v[i][k] - v[j][k] * r);\n      }\n      dmst.g[j].push_back( (Edge){j, i, w} );\n  }\n//   dmst.debug();\n\n  double ans = dmst.dMST(M);\n  printf(\"%.8f\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\ntypedef ld Weight;\n\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g, const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < int(g.size()); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(), -1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now] != -1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309テ」ツつ致arifyテ」ツ?療」ツ?淌」ツ?古」ツ??ヲツュツ」テ」ツ?療」ツ?湘・ツセツゥテ・ツ?ε」ツ?ァテ」ツ?催」ツ?ヲテ」ツ??」ツつ凝」ツ?凝」ツ?ッテ、ツクツ催ヲツ伉?\npair<Weight, Graph> chu_liu(const Graph&g, const int start, const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tWeight total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight, e.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < int(g.size()); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight, reve.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t\tif (cycle_edges.empty()) {\n\t\t\treturn make_pair(total_len, tree);\n\t\t}\n\t}\n\tvector<bool>node_is_cycle(g.size());\n\n\t/*ティツヲツ?ァツエツ?ヲツ閉ーテ」ツ?ッEdgeテ」ツ?ョテヲツ閉ーテ」ツ??」ツ?妥」ツ?ァティツ可ッテ」ツ??/\n\tvector<int>edge_is_cycle(e_size);\n\n\tvector<Weight>prev_lens(g.size(), ZERO);\n\n\tfor (auto ce : cycle_edges) {\n\t\tnode_is_cycle[ce.src] = true;\n\t\tprev_lens[ce.dst] = ce.weight;\n\t}\n\tGraph newg(g.size());\n\tconst int compress = cycle_edges[0].src;\n\t/*ティツヲツ?ァツエツ?ヲツ閉ーテ」ツ?ッEdgeテ」ツ?ョテヲツ閉ーテ」ツ??」ツ?妥」ツ?ァティツ可ッテ」ツ??/\n\tvector<Edge>memo(e_size);\n\tfor (int s = 0; s < int(g.size()); ++s) {\n\t\tbool src_is_cycle = node_is_cycle[s];\n\t\tfor (auto e : g[s]) {\n\t\t\tmemo[e.id] = e;\n\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (src_is_cycle) {\n\t\t\t\te.src = compress;\n\t\t\t}\n\t\t\telse if (dst_is_cycle) {\n\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\te.dst = compress;\n\t\t\t}\n\t\t\tnewg[e.src].push_back(e);\n\t\t}\n\t}\n\tauto p = chu_liu(newg, start, e_size);\n\tGraph compress_tree(p.second);\n\tGraph ans_tree(g.size());\n\tfor (auto es : compress_tree) {\n\t\tfor (auto e : es) {\n\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\tif (node_is_cycle[prev_edge.dst]) {\n\t\t\t\tfor (auto cycle_edge : cycle_edges) {\n\t\t\t\t\tif (cycle_edge.dst != prev_edge.dst) {\n\t\t\t\t\t\tans_tree[cycle_edge.src].emplace_back(cycle_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\treturn make_pair(p.first + cycle_len, ans_tree);\n}\n\nld getlen(const vector<ld>&a, const vector<ld>&b,const ld n) {\n\n\tld sum = 0;\n\tfor (int k = 0; k < a.size(); ++k) {\n\t\tsum += pow(a[k]*n - b[k], 2);\n\t}\n\treturn sum;\n}\n\nld getdis(const vector<ld>&a, const vector<ld>&b) {\n\tld amin = -1e8;\n\tld amax = 1e8;\n\tint num = 100;\n\twhile (num--) {\n\t\tld amid1 = (amin * 2 + amax) / 3;\n\t\tld amid2 = (amin + amax * 2) / 3;\n\t\tld ans1 = getlen(a, b, amid1);\n\t\tld ans2 = getlen(a, b, amid2);\n\t\tif (ans1 < ans2) {\n\t\t\tamax = amid2;\n\t\t}\n\t\telse {\n\t\t\tamin = amid1;\n\t\t}\n\t}\n\treturn getlen(a, b, amin);\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld v; cin >> v;\n\t\t\tvecs[i].emplace_back(v);\n\t\t}\n\t}\n\tGraph g(M);\n\tint aid = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i == j)continue;\n\t\t\telse {\n\t\t\t\tld len = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[i].push_back(Edge(i, j, len,aid++));\n\t\t\t}\n\t\t}\n\t}\n\tld ans = 1e18;\n\tfor (int i = 0; i < M; ++i) {\n\t\tvector<ld>v(N);\n\t\tauto p = chu_liu(g, i, M*(M - 1));\n\t\tld plus = getlen(v, vecs[i],0);\n\t\tans = min(ans, p.first+plus);\n\t}\n\tcout <<setprecision(12)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<double, int> pii;\nint N, M;\ndouble vec[101][101];\ndouble dist[101][101];\nbool seen[101];\n\ndouble ternary_search(int p, int q) {\n    double lo = -1e9, hi = 1e9;\n    for (int i=0; i<100; ++i) {\n        double m1 = (2*lo + hi)/3, m2 = (lo + 2*hi)/3;\n        // calc norm(vec[p] - r*vec[q])\n        double n1 = 0.0, n2 = 0.0;\n        for (int j=0; j<N; ++j) {\n            n1 += (vec[p][j] - m1 * vec[q][j]) * (vec[p][j] - m1 * vec[q][j]);\n            n2 += (vec[p][j] - m2 * vec[q][j]) * (vec[p][j] - m2 * vec[q][j]);\n        }\n        if (n1 > n2) lo = m1;\n        else hi = m2;\n    }\n    double ret = 0;\n    for (int i=0; i<N; ++i)\n        ret += (vec[p][i] - lo * vec[q][i]) * (vec[p][i] - lo * vec[q][i]);\n    return ret;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i=0; i<M; ++i)\n        for (int j=0; j<N; ++j)\n            scanf(\"%lf\", &vec[i][j]);\n    for (int j=0; j<N; ++j)\n        vec[M][j] = 0.0;\n\n    for (int i=0; i<M+1; ++i)\n        for (int j=i+1; j<M+1; ++j) {\n            double d = ternary_search(i, j);\n            dist[i][j] = dist[j][i] = d;\n        }\n\n    memset(seen, false, sizeof(seen));\n    priority_queue<pii, vector<pii>, greater<pii> > q; q.push(make_pair(0, M));\n    double ans = 0;\n    while (!q.empty()) {\n        pii p = q.top(); q.pop();\n        int v = p.second;\n        if (seen[v]) continue;\n        seen[v] = true;\n        //printf(\"use %d %f\\n\", v, p.first);\n        ans += p.first;\n        for (int i = 0; i < M+1; ++i) {\n            if (seen[i]) continue;\n            q.push(make_pair(dist[v][i], i));\n        }\n    }\n\n    printf(\"%.12f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst int N = 111;\nconst double eps = 1e-10;\nconst int INF = 0x7FFFFFFF/2;\nint n, m, pos[N];\ndouble v[N][N], val[N], dist[N][N];\n\ndouble get_r(int i, int j)\n{\n    double up = 0.0;\n    double down = 0.0;\n    for (int k = 1; k <= n; ++k) {\n        up += v[j][k] * v[i][k];\n        down += v[j][k] * v[j][k];\n    }\n    if (fabs(down) < eps) return 0;\n    return up / down;\n}\n\nbool cmp(const int &x, const int &y) {\n    return y < x;\n}\n\nnamespace Chuliu{\n    int n, used[N], pass[N], eg[N], more, que[N];\n    double g[N][N];\n    void combine(int id, double &sum) {\n        int tot = 0, from, i, j, k;\n        for ( ; id != 0 && !pass[id]; id = eg[id])\n            que[tot++] = id, pass[id] = 1;\n        for (from = 0; from < tot && que[from] != id; from++);\n        if (from == tot) return;\n\n        more = 1;\n        for (i = from; i < tot; i++) {\n            sum += g[eg[que[i]]][que[i]];\n            if (i == from) continue;\n            for (j = used[que[i]] = 1; j <= n; j++)\n                if (!used[j])\n                    if (g[que[i]][j] < g[id][j])\n                        g[id][j] = g[que[i]][j];\n        }\n        for (i = 1; i <= n; i++)\n            if (!used[i] && i != id) {\n                for (j = from; j < tot; j++) {\n                    k = que[j];\n                    if (g[i][id] > g[i][k] - g[eg[k]][k])\n                        g[i][id] = g[i][k] - g[eg[k]][k];\n                }\n            }\n    }\n    void clear(int V) {\n        n = V;\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                g[i][j] = dist[i][j];\n        for(int i = 1; i <= n; ++i)\n            g[i][i] = 0x3f3f3f3f;\n    }\n    double solve(int root) {\n        int i, j, k;\n        double sum = 0.0;\n        memset(used, 0, sizeof(int) * (n + 1));\n        for (more = 1; more; ) {\n            more = 0;\n            memset(eg, 0, sizeof(int) * (n + 1));\n            for (i = 1; i <= n; i++)\n                if (!used[i] && i != root) {\n                    for (j = 1, k = 0; j <= n; j++)\n                        if (!used[j] && i != j)\n                            if (k == 0 || g[j][i] < g[k][i]) k = j;\n                    eg[i] = k;\n                }\n            memset(pass, 0, sizeof(int) * (n + 1));\n            for (i = 1; i <= n; i++)\n                if (!used[i] && !pass[i] && i != root)\n                    combine(i, sum);\n        }\n        for (i = 1; i <= n; ++i)\n            if (!used[i] && i != root)\n                sum += g[eg[i]][i];\n        return sum;\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    double min_val = INF;\n    for (int i = 1; i <= m; ++i) {\n        val[i] = 0.0;\n        for (int j = 1; j <= n; ++j) {\n            cin >> v[i][j];\n            val[i] += v[i][j] * v[i][j];\n            min_val = min(min_val, val[i]);\n        }\n    }\n\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            dist[j][i] = 0.0;\n            double r = get_r(i, j);\n            for (int k = 1; k <= n; ++k)\n                dist[j][i] += (v[i][k] - r * v[j][k]) * (v[i][k] - r * v[j][k]);\n        }\n    }\n\n    for (int i = 1; i <= m; ++i)\n        dist[i][m + 1] = dist[m + 1][i] = INF + val[i];\n\n    Chuliu::clear(m + 1);\n    double ans = Chuliu::solve(m + 1) - INF;\n\n    cout << setiosflags(ios::fixed) << setprecision(10) << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stack>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int V_MAX=101;\nconst double INF=1e77;\n\nint ord[V_MAX],low[V_MAX];\nvoid dfs(int u,int &c,stack<int> &S,bool *inS,const vector<int> *G,int &scc_id,int *scc){\n\tord[u]=low[u]=c++;\n\tS.push(u);\n\tinS[u]=true;\n\n\trep(i,G[u].size()){\n\t\tint v=G[u][i];\n\t\tif(ord[v]==-1){\n\t\t\tdfs(v,c,S,inS,G,scc_id,scc);\n\t\t\tlow[u]=min(low[u],low[v]);\n\t\t}\n\t\telse if(inS[v]){\n\t\t\tlow[u]=min(low[u],ord[v]);\n\t\t}\n\t}\n\n\tif(ord[u]==low[u]){\n\t\tint v;\n\t\tdo{\n\t\t\tv=S.top(); S.pop();\n\t\t\tinS[v]=false;\n\t\t\tscc[v]=scc_id;\n\t\t}while(v!=u);\n\t\tscc_id++;\n\t}\n}\n\nint SCC(int n,const vector<int> *G,int *scc){\n\tstatic bool inS[V_MAX];\n\trep(u,n){\n\t\tord[u]=-1;\n\t\tinS[u]=false;\n\t}\n\tstack<int> S;\n\tint c=0,n_scc=0;\n\trep(u,n) if(ord[u]==-1) dfs(u,c,S,inS,G,n_scc,scc);\n\treturn n_scc;\n}\n\ntemplate<class T>\nstruct edge{\n\tint v;\n\tT cost;\n};\n\ntemplate<class T>\nT minimum_arborescence(int n,const vector< edge<T> > *G_in,int root){\n\tstatic vector< edge<T> > buf[V_MAX],buf2[V_MAX],*G=buf,*G2=buf2;\n\trep(u,n) G[u].clear();\n\trep(u,n) rep(i,G_in[u].size()) {\n\t\tconst edge<T> &e=G_in[u][i];\n\t\tif(u!=e.v) G[u].push_back(e);\n\t}\n\n\tT ans=0;\n\twhile(1){\n\t\tstatic int from[V_MAX];\n\t\tstatic T mini[V_MAX];\n\t\trep(u,n) from[u]=-1;\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tconst edge<T> &e=G[u][i];\n\t\t\tif(from[e.v]==-1 || mini[e.v]>e.cost){\n\t\t\t\tfrom[e.v]=u;\n\t\t\t\tmini[e.v]=e.cost;\n\t\t\t}\n\t\t}\n\n\t\trep(v,n) if(v!=root) {\n\t\t\tans+=mini[v];\n\t\t\tif(from[v]==-1) return INF;\n\t\t}\n\n\t\tstatic vector<int> H[V_MAX];\n\t\trep(v,n) H[v].clear();\n\t\trep(v,n) if(v!=root) H[from[v]].push_back(v);\n\n\t\tstatic int scc[V_MAX];\n\t\tint N=SCC(n,H,scc);\n\t\tif(n==N) return ans;\n\n\t\trep(i,N) G2[i].clear();\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tconst edge<T> &e=G[u][i];\n\t\t\tif(scc[u]!=scc[e.v]){\n\t\t\t\tG2[scc[u]].push_back((edge<T>){scc[e.v],e.cost-mini[e.v]});\n\t\t\t}\n\t\t}\n\t\tswap(G,G2);\n\t\tn=N;\n\t\troot=scc[root];\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&m,&n);\n\tdouble vec[101][100];\n\trep(i,n) rep(j,m) scanf(\"%lf\",vec[i]+j);\n\trep(j,m) vec[n][j]=0;\n\n\tvector< edge<double> > G[V_MAX];\n\trep(v,n){\n\t\tdouble cost=0;\n\t\trep(k,m) cost+=vec[v][k]*vec[v][k];\n\t\tG[n].push_back((edge<double>){v,cost});\n\t}\n\trep(u,n) rep(v,n+1) {\n\t\tdouble r1=0,r2=0;\n\t\trep(k,m){\n\t\t\tr1+=vec[u][k]*vec[v][k];\n\t\t\tr2+=vec[u][k]*vec[u][k];\n\t\t}\n\t\tdouble r=r1/r2;\n\n\t\tdouble cost=0;\n\t\trep(k,m) cost+=(vec[v][k]-r*vec[u][k])*(vec[v][k]-r*vec[u][k]);\n\t\tG[u].push_back((edge<double>){v,cost});\n\t}\n\n\tprintf(\"%.9f\",minimum_arborescence(n+1,G,n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing weight = double;\nconstexpr weight INF = 1e9;\n\nconstexpr weight eps = 1e-8;\n\nstruct edge {\n    int from, to;\n    weight cost;\n    \n    bool operator<(edge const& e) const {\n        return cost < e.cost;\n    }\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, weight cost) {\n    g[from].push_back(edge{from, to, cost});\n}\n\nint scc(std::vector<std::vector<int>>& G, std::vector<int>& cmp) {\n    int V = G.size();\n    std::vector<std::vector<int>> g(V), rg(V);\n    std::vector<bool> used(V, false);\n    std::vector<int> vs;\n    cmp.resize(V);\n    for(int i = 0; i < V; ++i) {\n        for(auto to : G[i]) {\n            g[i].push_back(to);\n            rg[to].push_back(i);\n        }\n    }\n    std::function<void(int)> dfs = [&g, &vs, &used, &dfs](int v) {\n        used[v] = true;\n        for(auto i : g[v]) {\n            if(!used[i]) {\n                dfs(i);\n            }\n        }\n        vs.push_back(v);\n    };\n    std::function<void(int, int)> rdfs = [&rg, &cmp, &used, &rdfs](int v, int k) {\n        used[v] = true;\n        cmp[v] = k;\n        for(int i : rg[v]) {\n            if(!used[i]) {\n                rdfs(i, k);\n            }\n        }\n    };\n    for(int v=0; v<V; ++v) {\n        if(!used[v]) {\n            dfs(v);\n        }\n    }\n    std::fill(used.begin(), used.end(), false);\n    int k = 0;\n    for(int i=vs.size()-1; i>=0; --i) {\n        if(!used[vs[i]]) {\n            rdfs(vs[i], k++);\n        }\n    }\n    return k;\n}\n\nstd::vector<std::vector<int>> build_graph(std::vector<std::vector<int>> const& g, std::vector<int> const& cmp, int K) {\n    int V = g.size();\n    std::vector<std::set<int>> s(K);\n    std::vector<std::vector<int>> res(K);\n    for(int i = 0; i < V; ++i) {\n        for(auto to : g[i]) {\n            s[cmp[i]].insert(cmp[to]);\n        }\n    }\n    for(int i = 0; i < K; ++i) {\n        for(auto j : s[i]) {\n            if(i != j) {\n                res[i].push_back(j);\n            }\n        }\n    }\n    return res;\n}\n\n\nweight minimum_spanning_rooted_arborescence(graph const& g, int root, weight sum = 0) {\n    int const n = g.size();\n\n    std::vector<int> rev(n, -1);\n    std::vector<weight> cost(n, INF);\n    for(int i = 0; i < n; ++i) {\n        for(auto& e : g[i]) {\n            if(e.cost < cost[e.to]) {\n                cost[e.to] = e.cost;\n                rev[e.to] = i;\n            }\n        }\n    }\n    for(int i = 0; i < n; ++i) {\n        if(i != root && rev[i] == -1) { // not exists\n            return INF;\n        }\n    }\n\n    std::vector<std::vector<int>> g2(n);\n    for(int i = 0; i < n; ++i) {\n        if(root == i) {\n            continue;\n        }\n        g2[rev[i]].push_back(i);\n        sum += cost[i];\n    }\n    std::vector<int> cmp(n);\n    int const K = scc(g2, cmp);\n    auto nxt = build_graph(g2, cmp, K);\n    if(nxt.size() == n) {\n        return sum;\n    }\n\n    graph ng(nxt.size());\n    for(int i = 0; i < n; ++i) {\n        for(auto& e : g[i]) {\n            if(cmp[i] == cmp[e.to]) {\n                continue;\n            }\n            ng[cmp[i]].push_back(edge{cmp[i], cmp[e.to], e.cost - cost[e.to]});\n        }\n    }\n\n    return minimum_spanning_rooted_arborescence(ng, cmp[root], sum);\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<double>> v;\n    for(int i = 0; i < M; ++i) {\n        double t = 0;\n        vector<weight> w(N);\n        for(int j = 0; j < N; ++j) {\n            cin >> w[j];\n            t += w[j] * w[j];\n        }\n        if(t > eps) {\n            v.push_back(w);\n        }\n    }\n    M = v.size();\n    graph g(M + 1);\n    int const root = M;\n    for(int i = 0; i < M; ++i) {\n        for(int j = 0; j < M; ++j) {\n            if(i == j) {\n                continue;\n            }\n            double prod = 0, dom = 0;\n            for(int k = 0; k < N; ++k) {\n                prod += v[i][k] * v[j][k];\n                dom += v[j][k] * v[j][k];\n            }\n            double r = prod / dom;\n            double cost = 0;\n            for(int k = 0; k < N; ++k) {\n                cost += (v[i][k] - r * v[j][k]) * (v[i][k] - r * v[j][k]);\n            }\n            add_edge(g, j, i, cost);\n        }\n        double d = 0;\n        for(int j = 0; j < N; ++j) {\n            d += v[i][j] * v[i][j];\n        }\n        add_edge(g, root, i, d);\n    }\n    cout << fixed << setprecision(10) << minimum_spanning_rooted_arborescence(g, root) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N (1<<19)\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,double> P;\ntypedef pair<double,int> R;\n\nint n, m;\ndouble v[100][100];\nbool saw[101];\nvector<P> e[101];\npriority_queue<R, vector<R>, greater<R> > que;\n\nint main(){\n    cin >> m >> n;\n    rep(i,n) rep(j,m) cin >> v[i][j];\n    rep(i,n){\n        double d = 0.0;\n        rep(j,m) d += v[i][j]*v[i][j];\n        if(d == 0.0) continue;\n        e[n].push_back(P(i,d));\n        rep(j,n){\n            if(i == j) continue;\n            double dd = 0.0;\n            double ss = -10000000.0, ee = 100000000.0, ms, me;\n            double vs, ve;\n            rep(u,200){\n                ms = (ss*2+ee)/3;\n                me = (ss+ee*2)/3;\n                vs = 0.0; ve = 0.0;\n                rep(k,m){\n                    vs += pow(v[j][k]+ms*v[i][k],2);\n                    ve += pow(v[j][k]+me*v[i][k],2);\n                }\n                if(vs > ve) ss = ms;\n                else ee = me;\n            }\n            e[i].push_back(P(j,vs));\n        }\n    }\n    que.push(P(0.0,n));\n    double ans = 0.0;\n    while(!que.empty()){\n        R r = que.top();\n        que.pop();\n        if(saw[r.second]) continue;\n        saw[r.second] = true;\n        ans += r.first;\n        rep(i,e[r.second].size()){\n            P to = e[r.second][i];\n            if(saw[to.first]) continue;\n            que.push(R(to.second,to.first));\n        }\n    }\n    printf(\"%.9f\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size());\n\t\t\tcomes[now] = true;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now]) {\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = true;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tld total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t}\n\t\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<Edge>memo(e_size);\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\te.src = compress;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\t\te.dst = compress;\n\t\t\t\t}\n\t\t\t\tnewg[e.src].push_back(e);\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N (1<<19)\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<long double,int> P;\n\nint n, m;\nlong double v[100][100];\nint saw[101];\nint com[101];\nbool dead[101];\nvector<P> e[101];\nvector<P> rev[101];\nvector<P> ee[101];\nP ree[101];\n\nint dfs_liu(int v, int o){\n    saw[v] = o;\n    rep(i,ee[v].size()){\n        P p = ee[v][i];\n        if(saw[p.second] >= 0 && saw[p.second] < o) continue;\n        if(saw[p.second] == o){\n            com[p.second] = p.second;\n            while(v != p.second){\n                com[v] = p.second;\n                v = ree[v].second;\n            }\n            return p.second;\n        }\n        int rec = dfs_liu(p.second,o);\n        if(rec != -1) return rec;\n    }\n    return -1;\n}\n\nlong double chu_liu(){\n    long double ret = 0.0;\n    memset(dead,0,sizeof(dead));\n    int debug = 0;\n    while(true){\n        debug++;\n        bool end = true;\n        rep(i,n){\n            ee[i].clear();\n            rev[i].clear();\n        }\n        rep(i,n) rep(j,e[i].size()){\n            if(dead[i] == true || dead[e[i][j].second] == true) continue;\n            rev[e[i][j].second].push_back(P(e[i][j].first,i));\n        }\n        /*\n        rep(i,n){\n            if(dead[i])  continue;\n            sort(rev[i].begin(),rev[i].end());\n        }\n        */\n        //cout << \"Ho\" << endl;\n        memset(saw,-1,sizeof(saw));\n        memset(com,-1,sizeof(com));\n        rep(i,n){\n            if(dead[i]) continue;\n            if(rev[i].size() == 0) continue;\n            long double mi = 100.0;\n            rep(j,rev[i].size()) mi = min(mi,rev[i][j].first+EPS);\n            rep(j,rev[i].size()){\n                if(rev[i][j].first < mi){\n                    ee[rev[i][j].second].push_back(P(rev[i][j].first,i));\n                    ree[i] = rev[i][j];\n                    break;\n                }\n            }\n        }\n        rep(i,n){\n            rep(j,ee[i].size()){\n                //cout << i << \" \" << ee[i][j].second << \" \" << ee[i][j].first << endl;\n            }\n        }\n        //cout << \"o\" << endl;\n        int d;\n        rep(i,n){\n            if(dead[i]) continue;\n            if(saw[i] >= 0) continue;\n            d = dfs_liu(i,i);\n            if(d >= 0){\n                end = false;\n                break;\n            }\n        }\n        //rep(i,n) cout << saw[i] << \" \";\n        //cout << endl;\n        //rep(i,n) cout << com[i] << \" \";\n        //cout << endl;\n        //cout << d << endl;\n        if(end) break;\n        rep(i,n){\n            if(dead[i]) continue;\n            rep(j,e[i].size()){\n                if(com[i] == d && com[e[i][j].second] == d){\n                    e[i][j].first = 100.0;\n                    continue;\n                }\n                if(com[e[i][j].second] == d){\n                    e[i][j].first -= ree[e[i][j].second].first;\n                    e[i][j].second = d;\n                    continue;\n                }\n                if(com[i] == d){\n                    if(i != d) e[d].push_back(e[i][j]);\n                }\n            }\n        }\n        rep(i,n){\n            if(dead[i]) continue;\n            if(com[i] == d){\n                ret += ree[i].first;\n                if(i != d) dead[i] = true;\n            }\n        }\n    }\n    rep(i,n){\n        if(dead[i]) continue;\n        ret += ree[i].first;\n    }\n    return ret;\n}\n\nint main(){\n    cin >> m >> n;\n    rep(i,n) rep(j,m) cin >> v[i][j];\n    rep(i,n){\n        long double d = 0.0;\n        rep(j,m) d += v[i][j]*v[i][j];\n        if(d == 0.0) continue;\n        e[n].push_back(P(d,i));\n        rev[i].push_back(P(d,n));\n        rep(j,n){\n            if(i == j) continue;\n            long double ss = -10000000000.0, ee = 100000000000.0, ms, me;\n            long double vs, ve;\n            rep(u,200){\n                ms = (ss*2+ee)/3;\n                me = (ss+ee*2)/3;\n                vs = 0.0; ve = 0.0;\n                rep(k,m){\n                    vs += pow(v[j][k]+ms*v[i][k],2);\n                    ve += pow(v[j][k]+me*v[i][k],2);\n                }\n                if(vs > ve) ss = ms;\n                else ee = me;\n            }\n            e[i].push_back(P(vs,j));\n            rev[i].push_back(P(vs,i));\n        }\n    }\n    n++;\n    rep(i,n){\n        rep(j,e[i].size()){\n            //cout << i << \" \" << e[i][j].second << \" \" << e[i][j].first << endl;\n        }\n    }\n    long double ans = chu_liu();\n    printf(\"%.9Lf\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\tGraph tree(g.size());\n\tld total_len = 0;\n\t{\n\t\tGraph revg(g.size());\n\n\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t}\n\t\t}\n\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\tif (node == start)continue;\n\t\t\telse {\n\t\t\t\tWeight amin = INF;\n\t\t\t\tEdge min_edge;\n\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amin < INF) {\n\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prev_lens[e.dst], e.id));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\nstruct edge\n{\n int begin;int end;\n};\nconst int maxnm=100;\nvector<double>zero;\ndouble cost[maxnm][maxnm];\nbool operator <( edge a, edge b)\n{\n double ac=cost[a.begin][a.end];\n double bc=cost[b.begin][b.end];\n return bc<ac;\n}\nint color[maxnm];\npriority_queue<edge>que[maxnm];\nvector<vector<double> >vec;\nint n,m;\n\ndouble minv(vector<double> a,vector<double> b)\n{\n double ab=0,bsqrt=0,asqrt=0;\n for(int i=0;i<a.size();i++)\n \t{\n \t ab+=a[i]*b[i];\n \t bsqrt+=b[i]*b[i];\n \t asqrt+=a[i]*a[i];\n\t}\n if(bsqrt==0.0)return asqrt;\n return asqrt-(ab*ab/bsqrt);\n}\npriority_queue<edge,vector<edge> >qdfs;\nbool vis[maxnm];\nvoid breakcircle(int now)\n{\n if(vis[now])\n \t{\n \t que[qdfs.top().begin].pop();\n \t while(!qdfs.empty())qdfs.pop();\n \t return ;\n\t}\n vis[now]=true;\n bool add2=0;\n edge e2;\n edge e1=que[now].top();que[now].pop();\n if(!que[now].empty()){ add2=true;e2=que[now].top();que[now].pop(); qdfs.push(e2);}\n que[now].push(e1);\n if(add2)que[now].push(e2);\n breakcircle(e1.end);\n}\nint root;\nbool findcircle(int now)\n{\n if(now==root)return false;\n if(color[now]==1)\n \t{\n \t memset(vis,0,sizeof(vis));\n \t breakcircle(now);\n \t return true;\n\t}\n else\n \t{\n \t color[now]=1;\n \t return findcircle(que[now].top().end);\n\t}\t\n}\nvoid build()\n{\n for(int i=0;i<m;i++)\n \t{\n \t while(!que[i].empty())que[i].pop();\n\t}\n for(int i=0;i<m;i++)\n \tfor(int j=0;j<m;j++)\n \t\t{\n \t\t if(i==root)continue;\n \t\t if(i==j)continue;\n \t\t \telse cost[i][j]=minv(vec[i],vec[j]);\n \t\t edge ned;\n \t\t ned.begin=i;ned.end=j;\n \t\t que[i].push(ned);\n\t\t}\n}\nint main()\n{\n cin>>n>>m;\n for(int i=0;i<n;i++)\n \tzero.push_back(0);\n for(int i=0;i<m;i++)\n \t{\n \t vector<double>nvec;\n \t for(int j=0;j<n;j++)\n \t \t{\n \t \t double nt;\n \t \t cin>>nt;\n \t \t nvec.push_back(nt);\n\t\t}\n\t vec.push_back(nvec);\n\t}\n \n double ans=99999999.0;\n for( root=0;root<m;root++)\n \t{\n \t build();\n \t double nowans=minv(vec[root],zero);\n\t bool exis=false;\n\t do{\n\t    exis=false;\n\t    memset(color,0,sizeof(color));\n \t for(int i=0;i<m;i++)\n \t \t{memset(color,0,sizeof(color));\n\t\t exis=findcircle(i);\t\n\t\t}\n\t }while(exis);\n\t for(int i=0;i<m;i++)\n\t \t{\n\t \t if(i==root)continue;\n\t \t edge ed=que[i].top();\n\t\t nowans+=cost[ed.begin][ed.end];\t\n\t\t}\n\t if(nowans<ans)ans=nowans;\n\t}\n cout<<ans<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef ld Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\nint E_SIZE = 10020;\npair<Weight,Graph> chu_liu(const Graph&g, const int start) {\n\tGraph revg(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\t//vector<Edge>memo(g.size()*g.size());\n\tfor (auto es : g) {\n\t\tfor (auto e : es) {\n\t\t\t//memo[e.id] = e;\n\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t}\n\t}\n\tGraph tree(g.size());\n\tld total_len = 0;\n\tfor (int node = 0; node < g.size(); ++node) {\n\t\tif (node == start)continue;\n\t\telse {\n\t\t\tWeight amin = INF;\n\t\t\tEdge min_edge;\n\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\tmin_edge = Edge(reve.dst,reve.src, reve.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (amin < INF) {\n\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t}\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(g.size()*g.size());\n\n\t\tvector<pair<int,Weight>>prevs(g.size(), make_pair(-1,ZERO));\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tnode_is_cycle[ce.dst] = true;\n\t\t\tprevs[ce.dst] = make_pair(ce.src, ce.weight);\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prevs[e.dst].second, e.id));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start);\n\t\tGraph compress_tree(g.size());\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tEdge prev_edge(e);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tld fin_len = p.first + cycle_len;\n\t\treturn make_pair(fin_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start);\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100 + 10;\nconst int M = 10000 + 10;\nstruct edge\n{\n    int u, v;\n    double cost;\n    edge() {}\n    edge(int u, int v, double c): u(u), v(v), cost(c) {}\n} e[M];\nint pre[N], hash1[N], vis[N];\ndouble In[N];\ndouble Directed_MST(int root, int n, int m)\n{\n    double ret = 0;\n    while(true)\n    {\n        for(int i = 0; i < n; i++)\n            In[i] = INT_MAX;\n        for(int i = 0; i < m; i++) //找最小入?\n        {\n            int u = e[i].u;\n            int v = e[i].v;\n            if(e[i].cost < In[v] && u != v)\n            {\n                pre[v] = u;\n                In[v] = e[i].cost;\n            }\n        }\n        for(int i = 0; i < n; i++)\n        {\n            if(i == root)\n                continue;\n            if(In[i] == INT_MAX)\n                return -1;\n        }\n        int cntnode = 0;\n        memset(hash1, -1, sizeof(hash1));\n        memset(vis, -1, sizeof(vis));\n        In[root] = 0;\n        for(int i = 0; i < n; i++) //找?\n        {\n            ret += In[i];\n            int v = i;\n            while(vis[v] != i && hash1[v] == -1 && v != root)\n            {\n                vis[v] = i;\n                v = pre[v];\n            }\n            if(v != root && hash1[v] == -1)\n            {\n                for(int u = pre[v]; u != v; u = pre[u])\n                    hash1[u] = cntnode;\n                hash1[v] = cntnode++;\n            }\n        }\n        if(cntnode == 0)\n            break;\n        for(int i = 0; i < n; i++)\n            if(hash1[i] == -1)\n                hash1[i] = cntnode++;\n        for(int i = 0; i < m; i++) //重??\n        {\n            int v = e[i].v;\n            e[i].u = hash1[e[i].u];\n            e[i].v = hash1[e[i].v];\n            if(e[i].u != e[i].v)\n                e[i].cost -= In[v];\n        }\n        n = cntnode;\n        root = hash1[root];\n    }\n    return ret;\n}\nint n, m;\nconst int MAXV = 100 + 10;\ndouble vc[MAXV][MAXV];\ninline double sqr(double x) {return x * x;}\ndouble calCost(int a, int b, double r)\n{\n    double res = 0.0;\n    for(int i = 0; i < m; ++i)\n        res += sqr(vc[a][i] - r * vc[b][i]);\n    return res;\n}\nconst double EPS = 5e-8;\ninline int sgn(double x) {return x < -EPS ? -1 : x > EPS ? 1 : 0;}\nint main()\n{\n#ifdef ACM_TEST\n    freopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"in.txt\", \"w\", stdout);\n#endif\n    scanf(\"%d%d\", &m, &n);\n    for(int i = 1; i <= n; ++i)\n        for(int j = 0; j < m; ++j)\n            scanf(\"%lf\", &vc[i][j]);\n    int tot = 0;\n    for(int i = 1; i <= n; ++i)\n    {\n        e[tot++] = edge(0, i, calCost(i, 0, 0));\n    }\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n        {\n            if(i == j) continue;\n            double l = -1e8, r = 1e8, ll, rr;\n            while(sgn(r - l) > 0)\n            {\n                ll = (l + l + r) / 3.0;\n                rr = (l + r + r) / 3.0;\n                if(sgn(calCost(j, i, ll) - calCost(j, i, rr)) >= 0) l = ll;\n                else r = rr;\n            }\n            e[tot++] = edge(i, j, calCost(j, i, 0.5 * (l + r)));\n        }\n    double ans = Directed_MST(0, n + 1, tot);\n    printf(\"%.10f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef pair<double, int> pii;\ntypedef long long ll;\nint N, M;\ndouble vec[101][101];\ndouble dist[101][101];\nbool seen[101];\n\ntypedef double Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid SccDfs(const Graph &g, int from, vector<int> &visit, vector<int> &st) {\n  visit[from] = 1;\n  for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n    if (visit[it->dest]) { continue; }\n    SccDfs(g, it->dest, visit, st);\n  }\n  st.push_back(from);\n}\n\nvector<vector<int> > Scc(const Graph &g) {\n  const int n = g.size();\n  vector<vector<int> > ret;\n  Graph revg(n);\n  for (int i = 0; i < n; i++) {\n    for (Edges::const_iterator it = g[i].begin(); it != g[i].end(); it++) {\n      revg[it->dest].push_back(Edge(it->dest, i, it->weight));\n    }\n  }\n  vector<int> st;\n  vector<int> visit(n, 0);\n  for (int i = 0; i < n; i++) {\n    if (visit[i]) { continue; }\n    SccDfs(g, i, visit, st);\n  }\n  visit = vector<int>(n, 0);\n  for (int i = n - 1; i >= 0; i--) {\n    int index = st[i];\n    if (visit[index]) { continue; }\n    vector<int> nret;\n    SccDfs(revg, index, visit, nret);\n    ret.push_back(nret);\n  }\n  return ret;\n}\n\nWeight Arborescence(const Graph &g, int root) {\n  const int n = g.size();\n  Weight ret = 0;\n  vector<Weight> inCost(n, 1e9);\n  vector<int> parent(n, -1);\n  for (int from = 0; from < n; from++) {\n    for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n      if (it->dest == from) { continue; }\n      if (it->weight < inCost[it->dest]) {\n        parent[it->dest] = from;\n        inCost[it->dest] = it->weight;\n      }\n      inCost[it->dest] = min(inCost[it->dest], it->weight);\n    }\n  }\n  Graph ng(n);\n  for (int i = 0; i < n; i++) {\n    if (i == root) { continue; }\n    if (parent[i] == -1) { return 1e9; }\n    ng[parent[i]].push_back(Edge(parent[i], i, 0));\n    ret += inCost[i];\n  }\n  vector<vector<int> > connect = Scc(ng);\n  int m = connect.size();\n  if (m == n) { return ret; }\n  vector<int> mapto(n, -1);\n  vector<int> cycle(n, 0);\n  ret = 0;\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < (int)connect[i].size(); j++) {\n      mapto[connect[i][j]] = i;\n      if (connect[i].size() != 1) {\n        cycle[connect[i][j]] = 1;\n        ret += inCost[connect[i][j]];\n      }\n    }\n  }\n  ng = Graph(m);\n  for (int from = 0; from < n; from++) {\n    for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n      int to = it->dest;\n      if (to == root || mapto[from] == mapto[to]) { continue; }\n      Weight cost = it->weight;\n      if (cycle[to]) {\n        cost -= inCost[to];\n      }\n      ng[mapto[from]].push_back(Edge(mapto[from], mapto[to], cost));\n    }\n  }\n  return min(1e9, (double)ret + Arborescence(ng, mapto[root]));\n}\n\n// p - r * q\ndouble ternary_search(int p, int q) {\n    double lo = -(1e9), hi = 1e9;\n    for (int i=0; i<100; ++i) {\n        double m1 = (2*lo + hi)/3, m2 = (lo + 2*hi)/3;\n        double n1 = 0.0, n2 = 0.0;\n        for (int j=0; j<N; ++j) {\n            n1 += (vec[p][j] - m1 * vec[q][j]) * (vec[p][j] - m1 * vec[q][j]);\n            n2 += (vec[p][j] - m2 * vec[q][j]) * (vec[p][j] - m2 * vec[q][j]);\n        }\n        if (n1 > n2) lo = m1;\n        else hi = m2;\n    }\n    double ret = 0;\n    for (int i=0; i<N; ++i)\n        ret += (vec[p][i] - lo * vec[q][i]) * (vec[p][i] - lo * vec[q][i]);\n    return ret;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i=0; i<M; ++i)\n        for (int j=0; j<N; ++j)\n            scanf(\"%lf\", &vec[i][j]);\n    for (int j=0; j<N; ++j)\n        vec[M][j] = 0.0;\n    M++;\n\n    Graph g(M);\n    vector<pair<double, pair<int,int> > > e;\n    for (int i=0; i<M; ++i)\n        for (int j=0; j<M; ++j) {\n            if (i == j) continue;\n            g[j].push_back(Edge(j, i, ternary_search(i, j)));\n            //dist[j][i] = ternary_search(i, j);\n        }\n\n    printf(\"%.20f\\n\", Arborescence(g, M-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef ld Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\nint E_SIZE = 10020;\npair<Weight,Graph> chu_liu(const Graph&g, const int start) {\n\tGraph revg(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(g.size()*g.size());\n\tfor (auto es : g) {\n\t\tfor (auto e : es) {\n\t\t\t//memo[e.id] = e;\n\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t}\n\t}\n\tGraph tree(g.size());\n\tld total_len = 0;\n\tfor (int node = 0; node < g.size(); ++node) {\n\t\tif (node == start)continue;\n\t\telse {\n\t\t\tWeight amin = INF;\n\t\t\tEdge min_edge;\n\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\tmin_edge = Edge(reve.dst,reve.src, reve.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (amin < INF) {\n\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t}\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(g.size()*g.size());\n\n\t\tvector<pair<int,Weight>>prevs(g.size(), make_pair(-1,ZERO));\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tnode_is_cycle[ce.dst] = true;\n\t\t\tprevs[ce.dst] = make_pair(ce.src, ce.weight);\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prevs[e.dst].second, e.id));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start);\n\t\tGraph compress_tree(g.size());\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tEdge prev_edge(e);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tld fin_len = p.first + cycle_len;\n\t\treturn make_pair(fin_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start);\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct SCC {\n  using Graph = vector<vector<int> >;\n  Graph graph, rgraph;\n  vector<int> cmp;\n  SCC(int V):graph(V), rgraph(V), cmp(V, -1){}\n  void add_edge(int from, int to) {\n    graph[from].push_back(to);\n    rgraph[to].push_back(from);\n  }\n  void dfs(const Graph& graph, int u, vector<int>& ord, vector<bool>& used) {\n    used[u] = true;\n    for(int v : graph[u]) {\n      if(!used[v]) dfs(graph, v, ord, used);\n    }\n    ord.push_back(u);\n  }\n  void rdfs(const Graph& rgraph, int u, int id) {\n    cmp[u] = id;\n    for(int v : rgraph[u]) {\n      if(cmp[v] == -1) rdfs(rgraph, v, id);\n    }\n  }\n  int build() {\n    int n = graph.size();\n    vector<int> ord;\n    vector<bool> used(n, false);\n    for(int u = 0; u < n; ++u) {\n      if(!used[u]) dfs(graph, u, ord, used);\n    }\n    reverse(ord.begin(), ord.end());\n    int sz = 0;\n    for(int u : ord) {\n      if(cmp[u] == -1) rdfs(rgraph, u, sz), ++sz;\n    }\n    return sz;\n  }\n};\ntemplate<typename Weight>\nstruct ChuLiu_Edmonds {\n  struct edge {\n    int to;\n    Weight cost;\n    edge(){}\n    edge(int to, Weight cost):to(to), cost(cost){}\n  };\n  using WeightedGraph = vector< vector<edge> >;\n  WeightedGraph graph;\n  vector<int> indeg;\n\n  Weight inf;\n\n  ChuLiu_Edmonds(int V, Weight inf):graph(V), indeg(V, 0), inf(inf){}\n\n  void add_edge(int from, int to, Weight cost) {\n    graph[from].emplace_back(to, cost);\n    indeg[to]++;\n  }\n  int get_root() {\n    for(int r = 0; r < (int)graph.size(); r++) {\n      if(indeg[r] == 0) return r;\n    }\n    return -1;\n  }\n  Weight minimum_cost_arborescence(WeightedGraph &g, int root) {\n    int N = g.size();\n\n    vector<int> into(N, -1);\n    vector<Weight> mincost(N, inf); // 頂点uに入るコストが最小の入る辺のfromとそのコスト\n    for(int u = 0; u < N; u++) {\n      for(edge& e : g[u]) {\n\tif(e.cost < mincost[e.to]) {\n\t  into[e.to] = u;\n\t  mincost[e.to] = e.cost;\n\t}\n      }\n    }\n\n    Weight res = 0;\n    SCC scc(N);\n    for(int u = 0; u < N; u++) {\n      if(u == root) continue;\n      assert(into[u] != -1);\n      assert(mincost[u] != inf);\n      scc.add_edge(into[u], u);\n      res += mincost[u];\n    }\n    int scc_sz = scc.build();\n    if((int)scc_sz == N) return res;\n\n    WeightedGraph reduce_g(scc_sz);\n    for(int u = 0; u < N; u++) {\n      for(edge& e : g[u]) {\n\tif(scc.cmp[u] == scc.cmp[e.to]) continue;\n\treduce_g[scc.cmp[u]].emplace_back(scc.cmp[e.to], e.cost-mincost[e.to]);\n      }\n    }\n\n    return res + minimum_cost_arborescence(reduce_g, scc.cmp[root]);\n  }\n  Weight build(int root = -1) {\n    if(root == -1) root = get_root();\n    return minimum_cost_arborescence(graph, root);\n  }\n};\n\ndouble sq(double x) {\n  return x*x;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M;\n  cin >> N >> M;\n  vector<vector<double> > vec(M, vector<double>(N));\n  rep(i, M) rep(j, N) cin >> vec[i][j];\n\n  vector<vector<double> > cost(M, vector<double>(M, inf));\n  rep(i, M) {\n    cost[i][i] = 0;\n    rep(k, N) cost[i][i] += sq(vec[i][k]);\n  }\n  rep(i, M) rep(j, M) {\n    if(i == j) continue;\n    if(cost[i][i] == 0) {\n      cost[i][j] = cost[j][j];\n    } else {\n      double r = 0;\n      rep(k, N) r += vec[i][k]*vec[j][k];\n      r /= cost[i][i];\n      cost[i][j] = 0;\n      rep(k, N) cost[i][j] += sq(vec[j][k]-r*vec[i][k]);\n    }\n  }\n\n  ChuLiu_Edmonds<double> mca(M+1, DBL_MAX/2);\n  rep(i, M) {\n    mca.add_edge(M, i, cost[i][i]);\n    rep(j, M) {\n      if(i == j) continue;\n      mca.add_edge(i, j, cost[i][j]);\n    }\n  }\n  cout << mca.build(M) << endl;\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\ntypedef ld Weight;\n\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g, const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < int(g.size()); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(), -1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now] != -1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight, Graph> chu_liu(const Graph&g, const int start, const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tWeight total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight, e.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < int(g.size()); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight, reve.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t\tif (cycle_edges.empty()) {\n\t\t\treturn make_pair(total_len, tree);\n\t\t}\n\t}\n\tvector<bool>node_is_cycle(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<int>edge_is_cycle(e_size);\n\n\tvector<Weight>prev_lens(g.size(), ZERO);\n\n\tfor (auto ce : cycle_edges) {\n\t\tnode_is_cycle[ce.src] = true;\n\t\tprev_lens[ce.dst] = ce.weight;\n\t}\n\tGraph newg(g.size());\n\tconst int compress = cycle_edges[0].src;\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\tfor (int s = 0; s < int(g.size()); ++s) {\n\t\tbool src_is_cycle = node_is_cycle[s];\n\t\tfor (auto e : g[s]) {\n\t\t\tmemo[e.id] = e;\n\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (src_is_cycle) {\n\t\t\t\te.src = compress;\n\t\t\t}\n\t\t\telse if (dst_is_cycle) {\n\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\te.dst = compress;\n\t\t\t}\n\t\t\tnewg[e.src].push_back(e);\n\t\t}\n\t}\n\tauto p = chu_liu(newg, start, e_size);\n\tGraph compress_tree(p.second);\n\tGraph ans_tree(g.size());\n\tfor (auto es : compress_tree) {\n\t\tfor (auto e : es) {\n\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\tif (node_is_cycle[prev_edge.dst]) {\n\t\t\t\tfor (auto cycle_edge : cycle_edges) {\n\t\t\t\t\tif (cycle_edge.dst != prev_edge.dst) {\n\t\t\t\t\t\tans_tree[cycle_edge.src].emplace_back(cycle_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\treturn make_pair(p.first + cycle_len, ans_tree);\n}\n\nld getlen(const vector<ld>&a, const vector<ld>&b,const ld n) {\n\n\tld sum = 0;\n\tfor (int k = 0; k < a.size(); ++k) {\n\t\tsum += pow(a[k]*n - b[k], 2);\n\t}\n\treturn sum;\n}\n\nld getdis(const vector<ld>&a, const vector<ld>&b) {\n\tld amin = -1e8;\n\tld amax = 1e8;\n\tint num = 100;\n\twhile (num--) {\n\t\tld amid1 = (amin * 2 + amax) / 3;\n\t\tld amid2 = (amin + amax * 2) / 3;\n\t\tld ans1 = getlen(a, b, amid1);\n\t\tld ans2 = getlen(a, b, amid2);\n\t\tif (ans1 < ans2) {\n\t\t\tamax = amid2;\n\t\t}\n\t\telse {\n\t\t\tamin = amid1;\n\t\t}\n\t}\n\treturn getlen(a, b, amin);\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld v; cin >> v;\n\t\t\tvecs[i].emplace_back(v);\n\t\t}\n\t}\n\tGraph g(M);\n\tint aid = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i == j)continue;\n\t\t\telse {\n\t\t\t\tld len = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[i].push_back(Edge(i, j, len,aid++));\n\t\t\t}\n\t\t}\n\t}\n\tld ans = 1e18;\n\tfor (int i = 0; i < M; ++i) {\n\t\tvector<ld>v(N);\n\t\tauto p = chu_liu(g, i, M*(M - 1));\n\t\tld plus = getlen(v, vecs[i],0);\n\t\tans = min(ans, p.first+plus);\n\t}\n\tcout <<setprecision(12)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#define clr(a,b) memset(a,b,sizeof(a))\nusing namespace std;\n\nconst int N=105;\nconst double dinf=1e10;\n\nint n,m,pre[N],vis[N],cnt,ced[N],i,j,k;\ndouble g[105][105],len[105];\ndouble gra[105][105];\n\nvoid dfs(int s)//dfs蛻、譏ッ蜷ヲ譛芽ァ」\n{\n    vis[s]=1;cnt++;\n    for(int i=1;i<=n;i++)\n        if(gra[s][i]<dinf&&!vis[i])\n            dfs(i);\n}\n\ndouble ZHULIU(int s)\n{\n\tclr(vis,0);cnt=0;\n\tdfs(s);if(cnt!=n)return -1;\n    clr(ced,0);double ans=0;\n    int i,j,k;//霑咎?逧?豈碑セ?・?束?檎ョ。莉門造\n    do\n\t{\n\t    for(i=1;i<=n;i++)//貂?勁閾ェ邇ッ?御サ・蜿頑アよッ丈クェ轤ケ逧??霎ケ\n\t    {\n\t        if(ced[i]||i==s)continue;\n\t        pre[i]=1;\n\t        for(j=1;j<=n;j++)\n                if(j!=s&&j!=i&&!ced[j]&&gra[pre[i]][i]>gra[j][i])\n                    pre[i]=j;\n\t    }\n\t    pre[s]=s;\n        for(i=1;i<=n;i++)\n        {\n            if(ced[i]||i==s)continue;\n            clr(vis,0);\n            for(j=i;j!=s&&!vis[j];j=pre[j])vis[j]=1;//蟇サ謇セ邇ッ?瑚「ォvis譬?ョー逧?弍邇ッ蜀?噪轤ケ\n            if(j==s)continue;\n            ans+=gra[pre[j]][j];\n            for(i=pre[j];i!=j;i=pre[i])//謚顔識驥檎噪譚??蜉?芦ans荳ュ蜴サ\n                ans+=gra[pre[i]][i],ced[i]=1;\n            for(k=1;k<=n;k++)//霑吩クェ蜥御ク矩擇驍」荳ェfor蝨ィ郛ゥ轤ケ\n                if(!ced[k]&&gra[k][j]<dinf)\n                    gra[k][j]-=gra[pre[j]][j];\n            for(i=pre[j];i!=j;i=pre[i])\n                for(k=1;k<=n;k++)\n                {\n                    if(ced[k])continue;\n                    gra[j][k]=min(gra[j][k],gra[i][k]);\n                    if(gra[k][i]<dinf)\n                        gra[k][j]=min(gra[k][j],gra[k][i]-gra[pre[i]][i]);\n                }\n            break;\n        }\n\t}while(i<=n);\n\tfor(int i=1;i<=n;i++)//謚贋ク肴弍蜑ゥ荳狗噪蜈・霎ケ驛ス蜉?ク?\n        if(!ced[i]&&i!=s)ans+=gra[pre[i]][i];\n\treturn ans;\n}\n\n\nint main(){\n//    freopen(\"in.txt\",\"r\",stdin);\n//    freopen(\"/home/axorb/in\",\"r\",stdin);\n    scanf(\"%d%d\",&m,&n);n++;\n    for(i=2;i<=n;i++){\n        for(j=1;j<=m;j++){\n            scanf(\"%lf\",&g[i][j]);\n            len[i]+=g[i][j]*g[i][j];\n        }\n        len[i]=sqrt(len[i]);\n        gra[1][i]=len[i]*len[i];\n        gra[i][1]=dinf;\n    }\n    for(i=2;i<=n;i++){\n        for(j=2;j<=n;j++){\n            double tmp=0;\n            if(i==j) gra[i][j]=dinf;\n            for(k=1;k<=m;k++){\n                tmp+=g[i][k]*g[j][k];\n            }\n            double ang=tmp/len[i]/len[j];\n            ang=sqrt(1-ang*ang);\n            gra[i][j]=(len[j]*ang)*(len[j]*ang);\n        }\n    }\n    printf(\"%.10lf\\n\",ZHULIU(1));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\nconst int maxn=110;\nconst int maxe=50010;\nstruct Edge\n{\n\tint u,v;\n\tdouble w;\n}edge[maxe];\nint nv,ne;\nvoid add(int u,int v,double w)\n{\n\tedge[ne].u=u;\n\tedge[ne].v=v;\n\tedge[ne++].w=w;\n}\nconst double inf=1e12;\ndouble In[maxn];\nint pre[maxn],ID[maxn],vis[maxn];\ndouble Directed_MST(int root)\n{\n\tdouble ret=0;\n\tint i,u,v,cnt;\n\twhile(1)\n\t{\n\t\tfor(i=0;i<=nv;++i)In[i]=inf;\n\t\tfor(i=0;i<ne;++i)\n\t\t{\n\t\t\tu=edge[i].u;\n\t\t\tv=edge[i].v;\n\t\t\tif(edge[i].w<In[v]&&u!=v)\n\t\t\t{\n\t\t\t\tIn[v]=edge[i].w;\n\t\t\t\tpre[v]=u;\n\t\t\t}\n\t\t}\n\t\t//cout <<\"root:\"<<root<<\" \";for(i=0;i<=nv;++i)cout <<In[i]<<\" \";cout <<endl;\n\t\tfor(i=0;i<=nv;++i)\n\t\t\tif(i!=root&&In[i]==inf)return -1;\n\t\tcnt=0;\n\t\tmemset(ID,-1,sizeof(ID));\n\t\tmemset(vis,-1,sizeof(vis));\n\t\tIn[root]=0;\n\t\tfor(i=0;i<=nv;++i)\n\t\t{\n\t\t\tret+=In[i];\n\t\t\tfor(v=i;vis[v]!=i&&ID[v]==-1&&v!=root;v=pre[v])\n\t\t\t\tvis[v]=i;\n\t\t\tif(v!=root&&ID[v]==-1)\n\t\t\t{\n\t\t\t\tfor(u=pre[v];u!=v;u=pre[u])\n\t\t\t\t\tID[u]=cnt;\n\t\t\t\tID[v]=cnt++;\n\t\t\t}\n\t\t}\n\t\tif(cnt==0)break;\n\t\tfor(i=0;i<=nv;++i)\n\t\t\tif(ID[i]==-1)ID[i]=cnt++;\n\t\tfor(i=0;i<ne;++i)\n\t\t{\n\t\t\tv=edge[i].v;\n\t\t\tedge[i].u=ID[edge[i].u];\n\t\t\tedge[i].v=ID[edge[i].v];\n\t\t\tif(edge[i].u!=edge[i].v)\n\t\t\t\tedge[i].w-=In[v];\n\t\t}\n\t\tnv=cnt-1;\n\t\troot=ID[root];\n\t}\n\treturn ret;\n}\nint n,m;\n#define sqr(v) ((v)*(v))\nstruct Point\n{\n\tdouble v[101];\n\tdouble length()\n\t{\n\t\tdouble res=0;\n\t\tfor(int i=0;i<m;++i)\n\t\t\tres+=sqr(v[i]);\n\t\treturn res;\n\t}\n\tPoint operator -(const Point &p)\n\t{\n\t\tPoint res;\n\t\tfor(int i=0;i<m;++i)\n\t\t\tres.v[i]=v[i]-p.v[i];\n\t\treturn res;\n\t}\n}pt[101];\ndouble len(int a,int b)\n{\n\tdouble lena=sqrt(pt[a].length()),lenb=sqrt(pt[b].length()),res=0;\n\tfor(int i=0;i<m;++i)\n\t\tres+=pt[a].v[i]*pt[b].v[i];\n\tdouble cosv=res/lena/lenb;\n\treturn sqr(lenb*sin(acos(cosv)));\n}\nint main()\n{\n\tint i,j;\n\tscanf(\"%d%d\",&m,&n);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=0;j<m;++j)\n\t\t{\n\t\t\tscanf(\"%lf\",&pt[i].v[j]);\n\t\t}\n\t\tadd(0,i,pt[i].length());\n\t}\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tadd(i,j,len(i,j));\n\t\t}\n\tnv=n;\n\tprintf(\"%.9f\\n\",Directed_MST(0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define double long double\n\ndouble size(const vector<double> &v){\n    int n = v.size();\n    double ret = 0;\n    rep(i,n) ret += v[i]*v[i];\n    return ret;\n}\n\nvector<double> getv(const vector<double> &v, const vector<double> &u, double r){\n    int n = v.size();\n    vector<double> ret(n);\n    rep(i,n) ret[i] = v[i]+u[i]*r;\n    return ret;\n}\n\nconst double LIM = 100;\ndouble calc(const vector<double> &v, const vector<double> &u){\n    int n = v.size();\n\n    double l=-LIM, r=LIM;\n    rep(loop,40){\n        double m1 = (2*l+r)/3, m2 = (l+2*r)/3;\n        if(size(getv(v,u,m1)) < size(getv(v,u,m2))) r = m2;\n        else l = m1;\n    }\n\n    return size(getv(v,u,r));\n}\n\nint main(){\n    int n,m;\n    cin >>n >>m;\n\n    vector<vector<double>> v(m);\n    rep(i,m){\n        vector<double> tmp(n);\n        rep(j,n) cin >>tmp[j];\n        v[i] = tmp;\n    }\n\n    double ans = 0;\n\n    using P = pair<double,int>;\n    priority_queue<P, vector<P>, greater<P>> pq;\n    vector<bool> vis(m);\n    rep(i,m) pq.push({size(v[i]),i});\n    while(!pq.empty()){\n        P now = pq.top();\n        pq.pop();\n        int x = now.se;\n        if(vis[x]) continue;\n\n        vis[x] = true;\n        ans += now.fi;\n        rep(i,m){\n            pq.push({calc(v[i],v[x]),i});\n        }\n    }\n\n    printf(\"%.10Lf\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -100;\n\tld amax = 100;\n\tint n = 30;\n\twhile (n--) {\n\t\tld amid0 = (amin*5 + amax*4) /9;\n\t\tld amid1 = (amin*4 + amax * 5) / 9;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(),-1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now]!=-1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tld total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t}\n\t\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<Edge>memo(e_size);\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\te.src = compress;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\t\te.dst = compress;\n\t\t\t\t}\n\t\t\t\tnewg[e.src].push_back(e);\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\tGraph revg(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\n\tfor (auto es : g) {\n\t\tfor (auto e : es) {\n\t\t\t//memo[e.id] = e;\n\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t}\n\t}\n\tGraph tree(g.size());\n\tld total_len = 0;\n\tfor (int node = 0; node < g.size(); ++node) {\n\t\tif (node == start)continue;\n\t\telse {\n\t\t\tWeight amin = INF;\n\t\t\tEdge min_edge;\n\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\tmin_edge = Edge(reve.dst,reve.src, reve.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (amin < INF) {\n\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t}\n\t\t}\n\t}\n\trevg.clear();\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(g.size()*g.size());\n\n\t\tvector<pair<int,Weight>>prevs(g.size(), make_pair(-1,ZERO));\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tnode_is_cycle[ce.dst] = true;\n\t\t\tprevs[ce.dst] = make_pair(ce.src, ce.weight);\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prevs[e.dst].second, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(g.size());\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tEdge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tld fin_len = p.first + cycle_len;\n\t\treturn make_pair(fin_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stack>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int V_MAX=101;\nconst double INF=1e77;\n\nint ord[V_MAX],low[V_MAX];\nvoid dfs(int u,int &c,stack<int> &S,bool *inS,const vector<int> *G,int &scc_id,int *scc){\n\tord[u]=low[u]=c++;\n\tS.push(u);\n\tinS[u]=true;\n\n\trep(i,G[u].size()){\n\t\tint v=G[u][i];\n\t\tif(ord[v]==-1){\n\t\t\tdfs(v,c,S,inS,G,scc_id,scc);\n\t\t\tlow[u]=min(low[u],low[v]);\n\t\t}\n\t\telse if(inS[v]){\n\t\t\tlow[u]=min(low[u],ord[v]);\n\t\t}\n\t}\n\n\tif(ord[u]==low[u]){\n\t\tint v;\n\t\tdo{\n\t\t\tv=S.top(); S.pop();\n\t\t\tinS[v]=false;\n\t\t\tscc[v]=scc_id;\n\t\t}while(v!=u);\n\t\tscc_id++;\n\t}\n}\n\nint SCC(int n,const vector<int> *G,int *scc){\n\tstatic bool inS[V_MAX];\n\trep(u,n){\n\t\tord[u]=-1;\n\t\tinS[u]=false;\n\t}\n\tstack<int> S;\n\tint c=0,n_scc=0;\n\trep(u,n) if(ord[u]==-1) dfs(u,c,S,inS,G,n_scc,scc);\n\treturn n_scc;\n}\n\ntemplate<class T>\nstruct edge{\n\tint v;\n\tT cost;\n};\n\ntemplate<class T>\nT minimum_arborescence(int n,const vector< edge<T> > *G_in,int root){\n\tstatic vector< edge<T> > buf[V_MAX],buf2[V_MAX],*G=buf,*G2=buf2;\n\trep(u,n) G[u].clear();\n\trep(u,n) rep(i,G_in[u].size()) {\n\t\tconst edge<T> &e=G_in[u][i];\n\t\tif(u!=e.v) G[u].push_back(e);\n\t}\n\n\tT ans=0;\n\twhile(1){\n\t\tstatic int from[V_MAX];\n\t\tstatic T mini[V_MAX];\n\t\trep(u,n) from[u]=-1;\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tconst edge<T> &e=G[u][i];\n\t\t\tif(from[e.v]==-1 || mini[e.v]>e.cost){\n\t\t\t\tfrom[e.v]=u;\n\t\t\t\tmini[e.v]=e.cost;\n\t\t\t}\n\t\t}\n\n\t\trep(v,n) if(v!=root) {\n\t\t\tans+=mini[v];\n\t\t\tif(from[v]==-1) return INF;\n\t\t}\n\n\t\tstatic vector<int> H[V_MAX];\n\t\trep(v,n) H[v].clear();\n\t\trep(v,n) if(v!=root) H[from[v]].push_back(v);\n\n\t\tstatic int scc[V_MAX];\n\t\tint N=SCC(n,H,scc);\n\t\tif(n==N) return ans;\n\n\t\trep(i,N) G2[i].clear();\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tconst edge<T> &e=G[u][i];\n\t\t\tif(scc[u]!=scc[e.v]){\n\t\t\t\tG2[scc[u]].push_back((edge<T>){scc[e.v],e.cost-mini[e.v]});\n\t\t\t}\n\t\t}\n\t\tswap(G,G2);\n\t\tn=N;\n\t\troot=scc[root];\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&m,&n);\n\tdouble vec[101][100];\n\trep(i,n) rep(j,m) scanf(\"%lf\",vec[i]+j);\n\trep(j,m) vec[n][j]=0;\n\n\tvector< edge<double> > G[V_MAX];\n\trep(v,n){\n\t\tdouble cost=0;\n\t\trep(k,m) cost+=vec[v][k]*vec[v][k];\n\t\tG[n].push_back((edge<double>){v,cost});\n\t}\n\trep(u,n) rep(v,n+1) {\n\t\tdouble r1=0,r2=0;\n\t\trep(k,m){\n\t\t\tr1+=vec[u][k]*vec[v][k];\n\t\t\tr2+=vec[u][k]*vec[u][k];\n\t\t}\n\t\tif(r2==0) continue;\n\t\tdouble r=r1/r2;\n\n\t\tdouble cost=0;\n\t\trep(k,m) cost+=(vec[v][k]-r*vec[u][k])*(vec[v][k]-r*vec[u][k]);\n\t\tG[u].push_back((edge<double>){v,cost});\n\t}\n\n\tprintf(\"%.9f\",minimum_arborescence(n+1,G,n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\ntypedef ld Weight;\n\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g, const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < int(g.size()); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(), -1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now] != -1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309テ」ツつ致arifyテ」ツ?療」ツ?淌」ツ?古」ツ??ヲツュツ」テ」ツ?療」ツ?湘・ツセツゥテ・ツ?ε」ツ?ァテ」ツ?催」ツ?ヲテ」ツ??」ツつ凝」ツ?凝」ツ?ッテ、ツクツ催ヲツ伉?\npair<Weight, Graph> chu_liu(const Graph&g, const int start, const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tWeight total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight, e.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < int(g.size()); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight, reve.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t\tif (cycle_edges.empty()) {\n\t\t\treturn make_pair(total_len, tree);\n\t\t}\n\t}\n\tvector<bool>node_is_cycle(g.size());\n\n\t/*ティツヲツ?ァツエツ?ヲツ閉ーテ」ツ?ッEdgeテ」ツ?ョテヲツ閉ーテ」ツ??」ツ?妥」ツ?ァティツ可ッテ」ツ??/\n\tvector<int>edge_is_cycle(e_size);\n\n\tvector<Weight>prev_lens(g.size(), ZERO);\n\n\tfor (auto ce : cycle_edges) {\n\t\tnode_is_cycle[ce.src] = true;\n\t\tprev_lens[ce.dst] = ce.weight;\n\t}\n\tGraph newg(g.size());\n\tconst int compress = cycle_edges[0].src;\n\t/*ティツヲツ?ァツエツ?ヲツ閉ーテ」ツ?ッEdgeテ」ツ?ョテヲツ閉ーテ」ツ??」ツ?妥」ツ?ァティツ可ッテ」ツ??/\n\tvector<Edge>memo(e_size);\n\tfor (int s = 0; s < int(g.size()); ++s) {\n\t\tbool src_is_cycle = node_is_cycle[s];\n\t\tfor (auto e : g[s]) {\n\t\t\tmemo[e.id] = e;\n\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (src_is_cycle) {\n\t\t\t\te.src = compress;\n\t\t\t}\n\t\t\telse if (dst_is_cycle) {\n\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\te.dst = compress;\n\t\t\t}\n\t\t\tnewg[e.src].push_back(e);\n\t\t}\n\t}\n\tauto p = chu_liu(newg, start, e_size);\n\tGraph compress_tree(p.second);\n\tGraph ans_tree(g.size());\n\tfor (auto es : compress_tree) {\n\t\tfor (auto e : es) {\n\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\tif (node_is_cycle[prev_edge.dst]) {\n\t\t\t\tfor (auto cycle_edge : cycle_edges) {\n\t\t\t\t\tif (cycle_edge.dst != prev_edge.dst) {\n\t\t\t\t\t\tans_tree[cycle_edge.src].emplace_back(cycle_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\treturn make_pair(p.first + cycle_len, ans_tree);\n}\n\nld getlen(const vector<ld>&a, const vector<ld>&b,const ld n) {\n\n\tld sum = 0;\n\tfor (int k = 0; k < a.size(); ++k) {\n\t\tsum += pow(a[k]*n - b[k], 2);\n\t}\n\treturn sum;\n}\n\nld getdis(const vector<ld>&a, const vector<ld>&b) {\n\tld amin = -1e8;\n\tld amax = 1e8;\n\tint num = 100;\n\twhile (num--) {\n\t\tld amid1 = (amin * 2 + amax) / 3;\n\t\tld amid2 = (amin + amax * 2) / 3;\n\t\tld ans1 = getlen(a, b, amid1);\n\t\tld ans2 = getlen(a, b, amid2);\n\t\tif (ans1 < ans2) {\n\t\t\tamax = amid2;\n\t\t}\n\t\telse {\n\t\t\tamin = amid1;\n\t\t}\n\t}\n\treturn getlen(a, b, amin);\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld v; cin >> v;\n\t\t\tvecs[i].emplace_back(v);\n\t\t}\n\t}\n\tGraph g(M);\n\tint aid = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i == j)continue;\n\t\t\telse {\n\t\t\t\tld len = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[i].push_back(Edge(i, j, len,aid++));\n\t\t\t}\n\t\t}\n\t}\n\tld ans = 1e18;\n\tfor (int i = 0; i < M; ++i) {\n\t\tvector<ld>v(N);\n\t\tauto p = chu_liu(g, i, M*(M - 1));\n\t\tld plus = getlen(v, vecs[i],0);\n\t\tans = min(ans, p.first+plus);\n\t}\n\tcout <<setprecision(12)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ninline double sq(double a) { return a*a; }\n\nstruct MST {\n    typedef double weight;\n    static const weight INF = 1e100;\n    static const int N = 128;\n\n    int n, r, no[N], prev[N], mark[N], temp[N];\n    vector<int> comp[N];\n    weight g[N][N], cost, mcost[N];\n    \n    void init(int _n) {\n        n = _n;\n        rep(i, n) rep(j, n) g[i][j] = INF;\n    }\n\n    void add_edge(int u, int v, weight w) { g[u][v] = w; }\n\n    bool rec(int v, int s) {\n        bool found = false;\n        if(mark[v]) {\n            found = true;\n            memcpy(temp, no, sizeof(temp));\n            for(;;) {\n                cost += mcost[v];\n                v = prev[v];\n                if(v==s) break;\n                while(comp[v].size()) {\n                    no[comp[v].back()] = s;\n                    comp[s].push_back(comp[v].back());\n                    comp[v].pop_back();\n                }\n            }\n            rep(j, n) if(j!=r && no[j]==s) {\n                rep(i, n) if(no[i]!=s && g[i][j]<INF) g[i][j] -= mcost[temp[j]];\n            }\n        }\n        mark[v] = 1;\n        rep(i, n) if(no[i]!=no[v] && prev[no[i]]==v) {\n            if(!mark[no[i]] || i==s) found |= rec(i, s);\n        }\n        return found;\n    }\n\n    weight solve(int _r) {\n        r = _r;\n        rep(i, n) {\n            no[i] = i;\n            comp[i].clear();\n            comp[i].push_back(i);\n        }\n        cost = 0;\n        for(;;) {\n            memset(prev, -1, sizeof(prev));\n            rep(i, n) mcost[i] = INF;\n            rep(i, n) rep(j, n) if(j!=r && no[i]!=no[j] && g[i][j]<INF) {\n                if(g[i][j] < mcost[no[j]]) {\n                    mcost[no[j]] = g[i][j];\n                    prev[no[j]] = no[i];\n                }\n            }\n            memset(mark, 0, sizeof(mark));\n            bool stop = true;\n            rep(i, n) if(i!=r && !mark[i] && comp[i].size()) {\n                if(rec(i, i)) stop = false;\n            }\n            if(stop) {\n                rep(i, n) if(prev[i]>=0) cost += mcost[i];\n                return cost;\n            }\n        }\n    }\n} mst;\n\nint N, M;\ndouble v[128][128];\n\ndouble dot(int a, int b) {\n    double s = 0;\n    rep(i, N) s += v[a][i]*v[b][i];\n    return s;\n}\n\ndouble norm(int a) { return dot(a, a); }\n\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    rep(i, M) rep(j, N) scanf(\"%lf\", v[i]+j);\n    mst.init(M+1);\n    rep(i, M) mst.add_edge(M, i, norm(i));\n    rep(i, M) rep(j, M) if(i!=j) {\n        if(norm(i)==0) mst.add_edge(i, j, norm(j));\n        else mst.add_edge(i, j, norm(j)-sq(dot(i, j))/norm(i));\n    }\n    printf(\"%.9f\\n\", mst.solve(M));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tld total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t}\n\t\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<Edge>memo(e_size);\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\te.src = compress;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\t\te.dst = compress;\n\t\t\t\t}\n\t\t\t\tnewg[e.src].push_back(e);\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define double long double\n\ndouble size(const vector<double> &v){\n    int n = v.size();\n    double ret = 0;\n    rep(i,n) ret += v[i]*v[i];\n    return ret;\n}\n\nvector<double> getv(const vector<double> &v, const vector<double> &u, double r){\n    int n = v.size();\n    vector<double> ret(n);\n    rep(i,n) ret[i] = v[i]+u[i]*r;\n    return ret;\n}\n\nconst double LIM = 100;\ndouble calc(const vector<double> &v, const vector<double> &u){\n    int n = v.size();\n\n    double l=-LIM, r=LIM;\n    rep(loop,40){\n        double m1 = (2*l+r)/3, m2 = (l+2*r)/3;\n        if(size(getv(v,u,m1)) < size(getv(v,u,m2))) r = m2;\n        else l = m1;\n    }\n\n    return size(getv(v,u,r));\n}\n\nbool comp(const vector<double> &v, const vector<double> &u){\n    return size(v) + min(size(u),calc(u,v)) < size(u) + min(size(v),calc(v,u));\n}\n\nint main(){\n    int n,m;\n    cin >>n >>m;\n\n    vector<vector<double>> v(m);\n    rep(i,m){\n        vector<double> tmp(n);\n        rep(j,n) cin >>tmp[j];\n        v[i] = tmp;\n    }\n\n    sort(all(v), comp);\n\n    double ans = 0;\n    rep(i,m){\n        double add = size(v[i]);\n        rep(j,i) add = min(add, calc(v[i],v[j]));\n        ans += add;\n    }\n    printf(\"%.10Lf\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\tGraph revg(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\n\tfor (auto es : g) {\n\t\tfor (auto e : es) {\n\t\t\t//memo[e.id] = e;\n\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t}\n\t}\n\tGraph tree(g.size());\n\tld total_len = 0;\n\tfor (int node = 0; node < g.size(); ++node) {\n\t\tif (node == start)continue;\n\t\telse {\n\t\t\tWeight amin = INF;\n\t\t\tEdge min_edge;\n\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\tmin_edge = Edge(reve.dst,reve.src, reve.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (amin < INF) {\n\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t}\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(g.size()*g.size());\n\n\t\tvector<pair<int,Weight>>prevs(g.size(), make_pair(-1,ZERO));\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tnode_is_cycle[ce.dst] = true;\n\t\t\tprevs[ce.dst] = make_pair(ce.src, ce.weight);\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prevs[e.dst].second, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(g.size());\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tEdge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tld fin_len = p.first + cycle_len;\n\t\treturn make_pair(fin_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\ntypedef long long LL;\nconst int V=120;\nconst int En=2100000;\nstruct Elf{int u,v;double len;}b[En];\nconst double oo=1e100;\ndouble ret;\nint N,M,Root;\nint id[V],pre[V],cnt,vis[V];\ndouble in[V];\nbool TreeMST()\n{\n\tret=0.0;\n\tint i,u,v;\n\twhile(1)\n\t{\n\t\tfor(i=0;i<N;i++)\n\t\tin[i]=oo;\n\t\tmemset(pre,-1,sizeof(pre));\n\t\tfor(i=0;i<M;i++)\n\t\t{\n\t\t\tu=b[i].u;\n\t\t\tv=b[i].v;\n\t\t\tif(b[i].len<in[v]&&u!=v)\n\t\t\t{\n\t\t\t\tpre[v]=u;\n\t\t\t\tin[v]=b[i].len;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tif(i==Root)continue;\n\t\t\tif(pre[i]==-1)return false;\n\t\t}\n\t\tin[Root]=0;\n\t\tcnt=0;\n\t\tmemset(id,-1,sizeof(id));\n\t\tmemset(vis,-01,sizeof(vis));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tret+=in[i];v=i;\n\t\t\twhile(vis[v]!=i&&id[v]==-1&&v!=Root)\n\t\t\t{vis[v]=i;v=pre[v];}\n\t\t\tif(v!=Root&&id[v]==-1)\n\t\t\t{\n\t\t\t\tfor(u=pre[v];u!=v;u=pre[u])\n\t\t\t\tid[u]=cnt;\n\t\t\t\tid[v]=cnt++;\n\t\t\t}\n\t\t}\n\t\tif(cnt==0)return true;\n\t\tfor(i=0;i<N;i++)\n\t\tif(id[i]==-1)id[i]=cnt++;\n\t\tfor(i=0;i<M;i++)\n\t\t{\n\t\t\tv=b[i].v;\n\t\t\tb[i].u=id[b[i].u];\n\t\t\tb[i].v=id[b[i].v];\n\t\t\tif(b[i].u!=b[i].v)\n\t\t\tb[i].len-=in[v];\n\t\t}\n\t\tN=cnt;\n\t\tRoot=id[Root];\n\t//\tfor(i=0;i<N;i++)printf(\"%d \",pre[i]);\n\t//\tprintf(\"%d %d\\n\",cnt,Root);\n\t}\n}\ndouble sqr(double x){return x*x;}\nint m,n;\ndouble a[120][120];\ndouble Cal(int x,int y,double r)\n{\n\tdouble ret=0.0;\n\tfor(int i=0;i<m;i++)\n\tret+=sqr(a[x][i]-a[y][i]*r);\n\treturn ret;\n}\nint i,j,k;\ndouble lo,up,mid1,mid2;\nint main()\n{\n\twhile(~scanf(\"%d%d\",&m,&n))\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=0;j<m;j++)\n\t\t\tscanf(\"%lf\",&a[i][j]);\n\t\t}\n\t\tN=n+1;M=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tb[M].u=0;\n\t\t\tb[M].v=i;\n\t\t\tdouble te=0.0;\n\t\t\tfor(j=0;j<m;j++)\n\t\t\tte+=a[i][j]*a[i][j];\n\t\t\tb[M++].len=te;\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(i==j)continue;\n\t\t\t\tlo=-1e10;up=1e10;\n\t\t\t\tfor(k=0;k<100;k++)\n\t\t\t\t{\n\t\t\t\t\tmid1=2.0*lo/3.0+up/3.0;\n\t\t\t\t\tmid2=lo/3.0+2.0*up/3.0;\n\t\t\t\t\tif(Cal(j,i,mid1)>Cal(j,i,mid2))lo=mid1;\n\t\t\t\t\telse up=mid2;\n\t\t\t\t}\n\t\t\t\tb[M].u=i;\n\t\t\t\tb[M].v=j;\n\t\t\t\tb[M++].len=Cal(j,i,lo);\n\t\t\t}\n\t\t}\n\t//\tfor(i=0;i<M;i++)\n\t//\tprintf(\"%d %d %.7f\\n\",b[i].u,b[i].v,b[i].len);\n\t\tRoot=0;\n\t\tif(TreeMST())printf(\"%.8f\\n\",ret);\n\t\telse puts(\"Obsidian\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\tGraph tree(g.size());\n\tld total_len = 0;\n\t{\n\t\tGraph revg(g.size());\n\n\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t}\n\t\t}\n\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\tif (node == start)continue;\n\t\t\telse {\n\t\t\t\tWeight amin = INF;\n\t\t\t\tEdge min_edge;\n\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amin < INF) {\n\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\t\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\te.src = compress;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\t\te.dst = compress;\n\t\t\t\t}\n\t\t\t\tnewg[e.src].push_back(e);\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ntypedef double weight_t;\nconst weight_t INF=1<<29;\n\nstruct edge{\n  int v;\n  weight_t w;\n};\n\nvector<int> minimum_spanning_arborescence(const vector<vector<edge> > &G,int root){\n  const int N=G.size();\n  vector<int> prev(N,-1);\n  vector<weight_t> weight(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      if(e.v!=root&&e.w<weight[e.v]){\n\tweight[e.v]=e.w;\n\tprev[e.v]=i;\n      }\n    }\n  }\n  vector<int> check(N,N);\n  int cycle_len=0;\n  vector<char> in_cycle(N);\n  for(int i=0;i<N;i++){\n    for(int j=i;j>=0;){\n      if(check[j]<i)break;\n      if(check[j]==i){\n\tfor(int k=j;;){\n\t  cycle_len++;\n\t  in_cycle[k]=true;\n\t  k=prev[k];\n\t  if(k==j)goto found;\n\t}\n      }\n      check[j]=i;\n      j=prev[j];\n    }\n  }\n  return prev;\n found:\n  int nN=N-cycle_len+1;\n  vector<int> newv(N),oldv(N);\n  for(int i=0,idx=0;i<N;i++){\n    if(!in_cycle[i]){\n      oldv[idx]=i;\n      newv[i]=idx++;\n    }else{\n      newv[i]=nN-1;\n    }\n  }\n  vector<vector<edge> > nG(nN);\n  vector<int> in(N,-1),out(N,-1);\n  vector<weight_t> in_val(N,INF),out_val(N,INF);\n  for(int i=0;i<N;i++){\n    for(auto e:G[i]){\n      weight_t nc=e.w-weight[e.v];\n      if(!in_cycle[i]){\n\tif(!in_cycle[e.v]){\n\t  nG[newv[i]].push_back({newv[e.v],nc});\n\t}else{\n\t  if(nc<in_val[i]){\n\t    in_val[i]=nc;\n\t    in[i]=e.v;\n\t  }\n\t}\n      }else{\n\tif(!in_cycle[e.v]){\n\t  if(nc<out_val[e.v]){\n\t    out_val[e.v]=nc;\n\t    out[e.v]=i;\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(in_val[i]<INF){\n      nG[newv[i]].push_back({nN-1,in_val[i]});\n    }\n    if(out_val[i]<INF){\n      nG[nN-1].push_back({newv[i],out_val[i]});\n    }\n  }\n  auto r=minimum_spanning_arborescence(nG,newv[root]);\n  vector<int> rv(N);\n  for(int i=0;i<nN-1;i++){\n    if(r[i]<0){\n      rv[oldv[i]]=r[i];\n    }else if(r[i]<nN-1){\n      rv[oldv[i]]=oldv[r[i]];\n    }else{\n      rv[oldv[i]]=out[oldv[i]];\n    }\n  }\n  int v_into_cycle=oldv[r[nN-1]];\n  int v_in_cycle=in[v_into_cycle];\n  rv[v_in_cycle]=v_into_cycle;\n  int x=prev[v_in_cycle];\n  for(int i=0;i<cycle_len-1;i++){\n    rv[x]=prev[x];\n    x=prev[x];\n  }\n  return rv;\n}\n\ndouble sqr(double d){\n  return d*d;\n}\n\nint main(){\n  int N,M;\n  cin>>M>>N;\n  double v[123][123];\n  double d[123][123]={};\n  vector<vector<edge> > G(N+1);\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      cin>>v[i][j];\n      d[N][i]+=sqr(v[i][j]);\n    }\n    G[N].push_back({i,d[N][i]});\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(i==j)continue;\n      double num=0,den=0;\n      for(int k=0;k<M;k++){\n\tnum+=v[j][k]*v[i][k];\n\tden+=sqr(v[i][k]);\n      }\n      if(den==0){\n\td[i][j]=d[N][j];\n      }else{\n\tfor(int k=0;k<M;k++){\n\t  d[i][j]+=sqr(v[j][k]-num/den*v[i][k]);\n\t}\n      }\n      G[i].push_back({j,d[i][j]});\n    }\n  }\n  auto r=minimum_spanning_arborescence(G,N);\n  double ans=0;\n  for(int i=0;i<N;i++){\n    ans+=d[r[i]][i];\n  }\n  cout<<fixed<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nconst int N = 111;\nconst int maxn = 111;\nconst int maxm = maxn * maxn;\nconst double eps = 1e-10;\nint n, m, pos[N];\ndouble v[N][N], val[N], dist[N][N];\n\ndouble get_r(int i, int j)\n{\n\tdouble up = 0.0;\n\tdouble down = 0.0;\n\tfor (int k = 1; k <= n; ++k) {\n\t\tup += v[j][k] * v[i][k];\n\t\tdown += v[j][k] * v[j][k];\n\t}\n\tif (fabs(down) < eps) return 0;\n\treturn up / down;\n}\n\nbool cmp(const int &x, const int &y) {\n\treturn y < x;\n}\n\nnamespace EdmondsAlgorithm { // O(ElogE + V^2) !!! 0-based !!!\n\tstruct enode { int from, dep;\n\t\tdouble c, key, delta; enode *ch[2], *next;\n\t} ebase[maxm], *etop, *fir[maxn], nil, *null, *inEdge[maxn], *chs[maxn];\n\ttypedef enode *edge; typedef enode *tree;\t\n\tint n, m, setFa[maxn], deg[maxn], que[maxn];\n\tinline void pushDown(tree x) { if (x->delta > 0) {\n\t\tx->ch[0]->key += x->delta; x->ch[0]->delta += x->delta;\n\t\tx->ch[1]->key += x->delta; x->ch[1]->delta += x->delta; x->delta = 0;\n\t}}\n\ttree merge(tree x, tree y) {\n\t\tif (x == null) return y; if (y == null) return x;\n\t\tif (x->key > y->key) swap(x, y); pushDown(x); x->ch[1] = merge(x->ch[1], y);\n\t\tif (x->ch[0]->dep < x->ch[1]->dep) swap(x->ch[0], x->ch[1]);\n\t\tx->dep = x->ch[1]->dep + 1; return x;\n\t}\n\tvoid addEdge(int u, int v, double w) {\n\t\tetop->from = u; etop->c = etop->key = w; etop->delta = etop->dep = 0;\n\t\tetop->next = fir[v]; etop->ch[0] = etop->ch[1] = null;\n\t\tfir[v] = etop; inEdge[v] = merge(inEdge[v], etop++);\n\t}\n\tvoid deleteMin(tree &r) { pushDown(r); r = merge(r->ch[0], r->ch[1]); }\n\tint findSet(int x) { return setFa[x] == x ? x : setFa[x] = findSet(setFa[x]); }\n\tvoid clear(int V, int E) {\n\t\tnull = &nil; null->ch[0] = null->ch[1] = null; null->dep = -1;\n\t\tn = V; m = E; etop = ebase;\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tfir[i] = NULL;\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tinEdge[i] = null;\n\t}\n\tdouble solve(int root) { double res = 0; int head, tail;\n\t\tfor (int i = 0; i < n; ++i) setFa[i] = i;\n\t\tfor ( ; ; ) { memset(deg, 0, sizeof(int) * n); chs[root] = inEdge[root];\n\t\t\tfor (int i = 0; i < n; ++i) if (i != root && setFa[i] == i) {\n\t\t\t\twhile (findSet(inEdge[i]->from) == findSet(i)) deleteMin(inEdge[i]);\n\t\t\t\t++deg[ findSet((chs[i] = inEdge[i])->from) ];\n\t\t\t}\n\t\t\tfor (int i = head = tail = 0; i < n; ++i)\n\t\t\t\tif (i != root && setFa[i] == i && deg[i] == 0) que[tail++] = i;\n\t\t\twhile (head < tail) {\n\t\t\t\tint x = findSet(chs[que[head++]]->from);\n\t\t\t\tif (--deg[x] == 0) que[tail++] = x;\n\t\t\t} bool found = false;\n\t\t\tfor (int i = 0; i < n; ++i) if (i != root && setFa[i] == i && deg[i] > 0) {\n\t\t\t\tint j = i; tree temp = null; found = true;\n\t\t\t\tdo {setFa[j = findSet(chs[j]->from)] = i;\n\t\t\t\t\tdeleteMin(inEdge[j]); res += chs[j]->key;\n\t\t\t\t\tinEdge[j]->key -= chs[j]->key; inEdge[j]->delta -= chs[j]->key;\n\t\t\t\t\ttemp = merge(temp, inEdge[j]);\n\t\t\t\t} while (j != i); inEdge[i] = temp;\n\t\t\t} if (!found) break;\n\t\t} for (int i = 0; i < n; ++ i) if (i != root && setFa[i] == i) res += chs[i]->key;\n\t\treturn res;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tval[i] = 0.0;\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tcin >> v[i][j];\n\t\t\tval[i] += v[i][j] * v[i][j];\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= m; ++i) {\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tdist[j][i] = 0.0;\n\t\t\tdouble r = get_r(i, j);\n\t\t\tfor (int k = 1; k <= n; ++k)\n\t\t\t\tdist[j][i] += (v[i][k] - r * v[j][k]) * (v[i][k] - r * v[j][k]);\n\t\t}\n\t}\n\tdouble ans = 0x7FFFFFFF/2;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tEdmondsAlgorithm::clear(m, m * m);\n\t\tfor (int j = 1;  j <= m; ++j)\n\t\t\tfor (int k = 1; k <= m; ++k) {\n\t\t\t\tEdmondsAlgorithm::addEdge(j - 1, k - 1, dist[j][k]);\n\t\t\t}\n\t\tdouble w = EdmondsAlgorithm::solve(i - 1);\n\t\t//cout << i << \" \" << w << endl;\n\t\tans = min(w + val[i], ans);\n\t}\n\tcout << setiosflags(ios::fixed) << setprecision(10) << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start) {\n\tGraph revg(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(g.size()*g.size());\n\tfor (auto es : g) {\n\t\tfor (auto e : es) {\n\t\t\t//memo[e.id] = e;\n\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t}\n\t}\n\tGraph tree(g.size());\n\tld total_len = 0;\n\tfor (int node = 0; node < g.size(); ++node) {\n\t\tif (node == start)continue;\n\t\telse {\n\t\t\tWeight amin = INF;\n\t\t\tEdge min_edge;\n\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\tmin_edge = Edge(reve.dst,reve.src, reve.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (amin < INF) {\n\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t}\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(g.size()*g.size());\n\n\t\tvector<pair<int,Weight>>prevs(g.size(), make_pair(-1,ZERO));\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tnode_is_cycle[ce.dst] = true;\n\t\t\tprevs[ce.dst] = make_pair(ce.src, ce.weight);\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prevs[e.dst].second, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start);\n\t\tGraph compress_tree(g.size());\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tEdge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tld fin_len = p.first + cycle_len;\n\t\treturn make_pair(fin_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start);\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start) {\n\tGraph revg(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(g.size()*(g.size()-1));\n\n\tfor (auto es : g) {\n\t\tfor (auto e : es) {\n\t\t\t//memo[e.id] = e;\n\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t}\n\t}\n\tGraph tree(g.size());\n\tld total_len = 0;\n\tfor (int node = 0; node < g.size(); ++node) {\n\t\tif (node == start)continue;\n\t\telse {\n\t\t\tWeight amin = INF;\n\t\t\tEdge min_edge;\n\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\tmin_edge = Edge(reve.dst,reve.src, reve.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (amin < INF) {\n\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t}\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(g.size()*g.size());\n\n\t\tvector<pair<int,Weight>>prevs(g.size(), make_pair(-1,ZERO));\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tnode_is_cycle[ce.dst] = true;\n\t\t\tprevs[ce.dst] = make_pair(ce.src, ce.weight);\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prevs[e.dst].second, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start);\n\t\tGraph compress_tree(g.size());\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tEdge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tld fin_len = p.first + cycle_len;\n\t\treturn make_pair(fin_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start);\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nstruct SCC {\n\ttypedef vector<vector<int>> graph;\n\n\tint V;\n\tgraph G;\n\tvector<int> cmp;\n\tvector<int> vs;\n\tvector<bool> used;\n\n\tSCC(int V_):V(V_), G(V_), cmp(V_), used(V_) {}\n\tSCC(const graph &G_):V(G_.size()), G(G_), cmp(V), used(V) {}\n\n\tvoid add_edge(int from, int to) {\n\t\tG[from].emplace_back(to);\n\t}\n\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(!used[to]) dfs(to);\n\t\t}\n\t\tvs.emplace_back(v);\n\t}\n\n\tvoid rdfs(int v, int k, graph &rG) {\n\t\tused[v] = true;\n\t\tcmp[v] = k;\n\t\tfor(const auto &to : rG[v]) {\n\t\t\tif(!used[to]) rdfs(to, k, rG);\n\t\t}\n\t}\n\n\tint scc() {\n\t\tvs.clear();\n\t\tfill(used.begin(), used.end(), false);\n\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tif(!used[v]) dfs(v);\n\t\t}\n\n\t\tgraph rG(V);\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\trG[to].emplace_back(v);\n\t\t\t}\n\t\t}\n\n\t\tfill(used.begin(), used.end(), false);\n\t\tint k = 0;\n\t\tfor(int i = static_cast<int>(vs.size()) - 1; i >= 0; --i) {\n\t\t\tif(!used[vs[i]]) rdfs(vs[i], k++, rG);\n\t\t}\n\t\treturn k;\n\t}\n};\n\ntypedef double weight;\nconstexpr weight INF = (1 << 28);\n\nstruct edge {\n\tint to;\n\tweight cost;\n\tedge(int to_, weight cost_):to(to_), cost(cost_){}\n};\n\ntypedef vector<vector<edge>> weighted_graph;\n\nweight minimum_spanning_arborescence(int r, const weighted_graph &G, weight sum = 0) {\n\tconst int n = G.size();\n\n\tvector<int> rev(n, -1);\n\tvector<weight> minimum_weight(n, INF);\n\tfor(int v = 0; v < n; ++v) {\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(minimum_weight[e.to] > e.cost) {\n\t\t\t\tminimum_weight[e.to] = e.cost;\n\t\t\t\trev[e.to] = v;\n\t\t\t}\n\t\t}\n\t}\n\n\tSCC scc(n);\n\tfor(int v = 0; v < n; ++v) {\n\t\tif(v == r) continue;\n\t\tif(rev[v] == -1) return INF;\n\t\tscc.add_edge(rev[v], v);\n\t\tsum += minimum_weight[v];\n\t}\n\n\tconst int num = scc.scc();\n\tif(num == n) return sum;\n\n\tweighted_graph next_G(num);\n\tfor(int v = 0; v < n; ++v) {\n\t\tconst int from = scc.cmp[v];\n\t\tfor(const auto &e : G[v]) {\n\t\t\tconst int to = scc.cmp[e.to];\n\t\t\tif(from == to) continue;\n\n\t\t\tconst auto cost = e.cost - minimum_weight[e.to];\n\t\t\tnext_G[from].emplace_back(to, cost);\n\t\t}\n\t}\n\n\treturn minimum_spanning_arborescence(scc.cmp[r], next_G, sum);\n}\n\ninline double dot(const vector<double> &a, const vector<double> &b) {\n\tdouble res = 0.0;\n\tfor(int i = 0; i < a.size(); ++i) {\n\t\tres += a[i] * b[i];\n\t}\n\treturn res;\n}\n\ninline double norm(const vector<double> &v) {\n\treturn dot(v, v);\n}\n\ninline double calc(const vector<double> &a, const vector<double> &b) {\n\tconst double r = dot(a, b) / norm(a);\n\tdouble res = 0.0;\n\tfor(int i = 0; i < a.size(); ++i) {\n\t\tconst double t = b[i] - r * a[i];\n\t\tres += t * t;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.precision(10);\n\tcout.flags(ios::fixed);\n\n\tint d, n;\n\tcin >> d >> n;\n\n\tvector<vector<double>> vectors;\n\tvectors.reserve(n);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tvector<double> v(d);\n\t\tfor(auto &e : v) cin >> e;\n\t\tvectors.emplace_back(v);\n\t}\n\n\tweighted_graph G(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tG[i].reserve(n - 1);\n\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(i == j) continue;\n\t\t\tG[i].emplace_back(j, calc(vectors[i], vectors[j]));\n\t\t}\n\t}\n\n\tdouble ans = INF;\n\tfor(int r = 0; r < n; ++r) {\n\t\tchmin(ans, minimum_spanning_arborescence(r, G) + norm(vectors[r]));\n\t}\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<iomanip>\nusing namespace std;\n#define eps 1e-12\n#define INF 1000000\n#define maxn 200005\ndouble a[105][105];\ndouble sum[105];\nstruct Edge\n{\n    int u,v;\n    double w;\n}b[10005],e[10005];\nint pre[maxn],id[maxn],vis[maxn];\ndouble in[maxn];\n\nint dcmp(double x)\n{\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\ndouble Directed_MST(int root, int NV, int NE)\n{\n    double ret = 0;\n    while(1)\n    {\n        for(int i=0;i<NV;i++)\n            in[i]=INF;\n        memset(pre,-1,sizeof(pre));\n        memset(vis,-1,sizeof(vis));\n        memset(id,-1,sizeof(id));\n        for(int i=0;i<NE;i++)\n        {\n            if(e[i].u==e[i].v) continue;\n            int v=e[i].v;\n            if(dcmp(e[i].w-in[v])<0){\n      //          ans=i;\n                pre[v]=e[i].u;\n                in[v]=e[i].w;\n            }\n        }\n        for(int i=0;i<NV;i++)\n        {\n            if(dcmp(in[i]-INF)==0&&i!=root)\n            {\n                //cout<<i<<endl;\n                return -1;\n            }\n        }\n        int cnt=0;\n        in[root]=0;\n        for(int i=0;i<NV;i++)\n        {\n            ret+=in[i];\n            int v=i;\n            while(vis[v]!=i&&id[v]==-1&&v!=root)\n            {\n                vis[v]=i;\n                v=pre[v];\n            }\n            if(v!=root&&id[v]==-1){\n                for(int u=pre[v];u!=v;u=pre[u])\n                {\n                    id[u]=cnt;\n                }\n                id[v]=cnt++;\n            }\n        }\n        if(cnt==0) break;\n        for(int i=0;i<NV;i++)\n            if(id[i]==-1) id[i]=cnt++;\n        for(int i=0;i<NE;i++)\n        {\n            int v=e[i].v;\n            e[i].u=id[e[i].u];\n            e[i].v=id[e[i].v];\n            e[i].w-=in[v];\n        }\n        NV = cnt;\n        root = id[root];\n     }\n    return ret;\n}\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)    for(int j=0;j<n;j++)    scanf(\"%lf\",a[i]+j);\n    int tot=0;\n    for(int i=1;i<=m;i++)             //j->i??±?\n    {\n        for(int j=1;j<=m;j++)\n        {\n            double x1=0,x2=0,x3=0;     // y=r*r*x3-2*r*x2+x1\n            for(int k=0;k<n;k++)\n            {\n                x1+=a[i][k]*a[i][k];\n                x3+=a[j][k]*a[j][k];\n                x2+=a[i][k]*a[j][k];\n            }\n            sum[i]=x1;\n            if(i==j)    continue;\n            double x=x2/x3;\n            double y=x*x*x3-2.0*x*x2+x1;\n            e[tot].u=j;\n            e[tot].v=i;\n            e[tot].w=y;\n            tot++;\n        }\n    }\n    for(int i=1;i<=m;i++)\n    {\n        e[tot].u=0;\n        e[tot].v=i;\n        e[tot].w=sum[i];\n        tot++;\n    }\n    double temp=Directed_MST(0,m+1,tot);\n    printf(\"%.7f\\n\",temp);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define N 105\n#define eps 1e-8\n#define INF 1e30\n\ninline double sqr(double x) {\n    return x * x;\n}\n\nint n, m;\ndouble a[N][N], b[N][N], d[N][N];\n\ndouble gao(int p, int q) {\n    double s1 = 0, s2 = 0;\n    for (int i = 1; i <= m; ++i) {\n        s1 += a[p][i] * a[q][i];\n        s2 += sqr(a[q][i]);\n    }\n    if (abs(s2) < eps) {\n        double s = 0;\n        for (int i = 1; i <= m; ++i)\n            s += sqr(a[p][i]);\n        return s;\n    }\n    double k = s1 / s2;\n    double ret = 0;\n    for (int i = 1; i <= m; ++i)\n        ret += sqr(k * a[q][i] - a[p][i]);\n    return ret;\n}\n\ndouble f[N];\nbool vis[N];\ndouble g[N][N];\n\nint pre[N];\nbool del[N], vst[N];\ndouble solve(int v) {\n    double res = 0;\n    int num = n;\n    memset(del, false, sizeof(del));\n    while(1) {\n        int i;\n        //æ´æ°preæ°ç»\n        for (i = 1; i <= n; ++i) {\n            if (del[i] || i == v) continue;\n            pre[i] = i;\n            g[i][i] = INF;\n            for (int j = 1; j <= n; ++j) {\n                if (del[j]) continue;\n                if (g[j][i] < g[pre[i]][i])\n                    pre[i] = j;\n            }\n        }\n        for (i = 1; i <= n; ++i) {\n            //æ¾ç¯\n            if (del[i] || i == v) continue;\n            int j = i;\n            memset(vst, 0, sizeof(vst));\n            while (!vst[j] && j != v) {\n                vst[j] = true;\n                j = pre[j];\n            }\n            if (j == v) continue;\n            i = j;\n            //æ´æ°resï¼æåç¯ç¼©ç¹\n            res += g[pre[i]][i];\n            for(j = pre[i]; j != i; j = pre[j]) {\n                res += g[pre[j]][j];\n                del[j] = true;\n            }\n            for(j = 1; j <= n; ++j) {\n                if(del[j]) continue;\n                if(g[j][i] != INF)\n                    g[j][i] -= g[pre[i]][i];\n            }\n            //æ´æ°ç¼©ç¹ä»¥åçæåç¯åå¶ä»ç¹çè¾¹æ\n            for(j = pre[i]; j != i; j = pre[j]) {\n                for(int k = 1; k <= n; ++k) {\n                    if(del[k])continue;\n                    g[i][k] = min(g[i][k], g[j][k]);\n                    if(g[k][j] != INF)\n                        g[k][i] = min(g[k][i], g[k][j] - g[pre[j]][j]);\n                }\n            }\n            //å®æç¼©ç¹\n            break;\n        }\n        //ä¸å­å¨æåç¯æ¶ï¼åæ­¢å¾ªç¯ï¼å¾åºresæç»å¼\n        if(i > n) {\n            for(int i = 1; i <= n; ++i) {\n                if(del[i] || i == v) continue;\n                res += g[pre[i]][i];\n            }\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    scanf(\"%d %d\", &m, &n);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= m; ++j)\n            scanf(\"%lf\", &a[i][j]);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            d[i][j] = gao(j, i);\n    double ans = INF;/*\n    for (int i = 1; i <= n; ++i, puts(\"\"))\n        for (int j = 1; j <= n; ++j)\n            printf(\" %.3f\", d[i][j]);*/\n    for (int i = 1; i <= n; ++i) {\n        double s = 0;\n        for (int j = 1; j <= m; ++j)\n            s += sqr(a[i][j]);\n        for (int j = 1; j <= n; ++j)\n            memcpy(g[j], d[j], sizeof(d[j]));\n        ans = min(ans, s + solve(i));\n    }\n    printf(\"%.8f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\ndouble c[110][110];\ndouble g[210][210];\nint rev[210];\nint v[210];\nint w[210];\nint u[210];\ndouble eps=1e-9;\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tscanf(\"%lf\",&c[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<210;i++)\n\t\tfor(int j=0;j<210;j++)\n\t\t\tg[i][j]=999999999;\n\tint s=b;\n\tfor(int i=0;i<b;i++){\n\t\tdouble dist=0;\n\t\tfor(int j=0;j<a;j++)dist+=c[i][j]*c[i][j];\n\t\tg[s][i]=dist;\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(i==j)continue;\n\t\t\tdouble L=-99999999;\n\t\t\tdouble R=99999999;\n\t\t\tfor(int k=0;k<100;k++){\n\t\t\t\tdouble m1=(L*2+R)/3;\n\t\t\t\tdouble m2=(L+R*2)/3;\n\t\t\t\tdouble d1=0;\n\t\t\t\tdouble d2=0;\n\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\td1+=(c[i][l]*m1-c[j][l])*(c[i][l]*m1-c[j][l]);\n\t\t\t\t\td2+=(c[i][l]*m2-c[j][l])*(c[i][l]*m2-c[j][l]);\n\t\t\t\t}\n\t\t\t\tg[i][j]=min(g[i][j],min(d1,d2));\n\t\t\t\tif(d1<d2)R=m2;\n\t\t\t\telse L=m1;\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ret=0;\n\tint sz=b+1;\n\tint rt=b;\n//\t\tfor(int i=0;i<sz;i++){\n//\t\tfor(int j=0;j<sz;j++)printf(\"%f \",g[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\twhile(1){\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tif(v[i])continue;\n\t\t\tif(rt==i)continue;\n\t\t\trev[i]=-1;\n\t//\t\tprintf(\"%d\\n\",i);\n\t\t\tfor(int j=0;j<sz;j++){\n\t\t\t\tif(v[j])continue;\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(!~rev[i]||g[rev[i]][i]>g[j][i])rev[i]=j;\n\t\t\t}\n\t\t\t\n\t\t\tif(!u[i])ret+=g[rev[i]][i];\n\t\t\tu[i]=1;\n\t\t}\n\t\t//printf(\"%d\\n\",sz);\n\t//\tfor(int i=0;i<sz;i++)printf(\"%d \",rev[i]);printf(\"\\n\");\n\t//\tif(sz>6)return 0;\n\t\tfor(int i=0;i<210;i++)w[i]=0;\n\t\tint cnt=0;\n\t\tint SZ=sz;\n\t\tfor(int i=0;i<SZ;i++){\n\t\t\tif(v[i])continue;\n\t\t\tif(w[i])continue;\n\t\t\tif(i==rt)continue;\n\t\t\tint at=i;\n\t\t\twhile(1){\n\t\t\t\tif(w[at]==2){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tvector<int>vs;\n\t\t\t\t\tint a2=at;\n\t\t\t\t\tif(w[rt]==2)rt=sz;\n\t\t\t\t\twhile(1){\n\t\t\t\t\t\tif(w[a2]==1)break;\n\t\t\t\t\t\tvs.push_back(a2);\n\t\t\t\t\t\tw[a2]=1;v[a2]=1;\n\t\t\t\t\t\ta2=rev[a2];\n\t\t\t\t\t}\n\t\t\t\t//\tprintf(\"{\");\n\t\t\t\t\tfor(int j=0;j<vs.size();j++){\n\t\t\t\t//\t\tprintf(\"%d,\",vs[j]);\n\t\t\t\t\t\tfor(int k=0;k<sz;k++){\n\t\t\t\t\t\t\tif(g[vs[j]][k]<999999)g[sz][k]=min(g[sz][k],g[vs[j]][k]);\n\t\t\t\t\t\t\tif(g[k][vs[j]]<999999)g[k][sz]=min(g[k][sz],g[k][vs[j]]-g[rev[vs[j]]][vs[j]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}//printf(\"}\\n\");\n\t\t\t\t\tsz++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(w[at]==1)break;\n\t\t\t\tif(at==rt)break;\n\t\t\t\tw[at]=2;\n\t\t\t\tat=rev[at];\n\t\t\t}\n\t\t\tat=i;\n\t\t\twhile(1){\n\t\t\t\tif(w[at]==1)break;\n\t\t\t\tif(at==rt)break;\n\t\t\t\tw[at]=1;\n\t\t\t\tat=rev[at];\n\t\t\t}\n\t\t}\n\t\tif(!cnt)break;\n\t}\n\tprintf(\"%f\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst int N = 111;\nconst double eps = 1e-10;\nint n, m, pos[N];\ndouble v[N][N], val[N], dist[N][N];\n\ndouble get_r(int i, int j)\n{\n    double up = 0.0;\n    double down = 0.0;\n    for (int k = 1; k <= n; ++k) {\n        up += v[j][k] * v[i][k];\n        down += v[j][k] * v[j][k];\n    }\n    if (fabs(down) < eps) return 0;\n    return up / down;\n}\n\nbool cmp(const int &x, const int &y) {\n    return y < x;\n}\n\nnamespace Chuliu{\n    int n, used[N], pass[N], eg[N], more, que[N];\n    double g[N][N];\n    void combine(int id, double &sum) {\n        int tot = 0, from, i, j, k;\n        for ( ; id != 0 && !pass[id]; id = eg[id])\n            que[tot++] = id, pass[id] = 1;\n        for (from = 0; from < tot && que[from] != id; from++);\n        if (from == tot) return;\n\t\t\n        more = 1;\n        for (i = from; i < tot; i++) {\n            sum += g[eg[que[i]]][que[i]];\n            if (i == from) continue;\n            for (j = used[que[i]] = 1; j <= n; j++)\n                if (!used[j])\n                    if (g[que[i]][j] < g[id][j])\n                        g[id][j] = g[que[i]][j];\n        }\n        for (i = 1; i <= n; i++)\n            if (!used[i] && i != id) {\n                for (j = from; j < tot; j++) {\n                    k = que[j];\n                    if (g[i][id] > g[i][k] - g[eg[k]][k])\n                        g[i][id] = g[i][k] - g[eg[k]][k];\n                }\n            }\n    }\n    void clear(int V) {\n        n = V;\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                g[i][j] = dist[i][j];\n        for(int i = 1; i <= n; ++i)\n            g[i][i] = 0x3f3f3f3f;\n    }\n    double solve(int root) {\n        int i, j, k;\n        double sum = 0.0;\n        memset(used, 0, sizeof(int) * (n + 1));\n        for (more = 1; more; ) {\n            more = 0;\n            memset(eg, 0, sizeof(int) * (n + 1));\n            for (i = 1; i <= n; i++)\n                if (!used[i] && i != root) {\n                    for (j = 1, k = 0; j <= n; j++)\n                        if (!used[j] && i != j)\n                            if (k == 0 || g[j][i] < g[k][i]) k = j;\n                    eg[i] = k;\n                }\n            memset(pass, 0, sizeof(int) * (n + 1));\n            for (i = 1; i <= n; i++)\n                if (!used[i] && !pass[i] && i != root)\n                    combine(i, sum);\n        }\n        for (i = 1; i <= n; ++i)\n            if (!used[i] && i != root)\n                sum += g[eg[i]][i];\n        return sum;\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    for (int i = 1; i <= m; ++i) {\n        val[i] = 0.0;\n        for (int j = 1; j <= n; ++j) {\n            cin >> v[i][j];\n            val[i] += v[i][j] * v[i][j];\n        }\n    }\n\t\n    double INF = 0;\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            dist[j][i] = 0.0;\n            double r = get_r(i, j);\n            for (int k = 1; k <= n; ++k)\n                dist[j][i] += (v[i][k] - r * v[j][k]) * (v[i][k] - r * v[j][k]);\n            INF += dist[j][i];\n        }\n    }\n    INF += 100 * 200;\n    for (int i = 1; i <= m; ++i)\n        dist[i][m + 1] = dist[m + 1][i] = INF + val[i];\n    Chuliu::clear(m + 1);\n    double w = Chuliu::solve(m + 1);\n    cout << setiosflags(ios::fixed) << setprecision(10) << w - INF << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\ndouble v[100][100];\ndouble len[100];\ndouble naiseki[100][100];\n\ntypedef vector<vector<double> > matrix;\ntypedef double weight;\nconst double inf = 1e10;\n\nvoid backward_traverse(int v, int s, int r, matrix &g,\n\t\t       vector<int> &no, vector< vector<int> > &comp,\n\t\t       vector<int> &prev, vector<weight> &mcost,\n\t\t       vector<int> &mark, weight &cost, bool &found) {\n  const int n = g.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    for (int j = 0; j < n; ++j)\n      if (j != r && no[j] == s)\n        for (int i = 0; i < n; ++i)\n          if (no[i] != s && g[i][j] < inf)\n            g[i][j] -= mcost[ temp[j] ];\n  }\n  mark[v] = true;\n  for (int i = 0; i < n; ++i)\n    if (no[i] != no[v] && prev[ no[i] ] == v)\n      if (!mark[ no[i] ] || i == s)\n        backward_traverse(i, s, r, g,\n\t\t\t  no, comp, prev, mcost, mark, cost, found);\n}\n\nweight minimum_spanning_arborescence(int r, matrix &g) {\n  const int n = g.size();\n\n  vector<int> no(n);\n  vector< vector<int> > comp(n);\n  for (int i = 0; i < n; ++i) {\n    no[i] = i;\n    comp[i].push_back(i);\n  }\n  weight cost = 0;\n  while (1) {\n    vector<int> prev(n, -1);\n    vector<weight> mcost(n, inf);\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        if (j == r) continue;\n        if (no[i] != no[j] && g[i][j] < inf) {\n          if (g[i][j] < mcost[ no[j] ]) {\n            mcost[ no[j] ] = g[i][j];\n            prev[ no[j] ] = no[i];\n          }\n        }\n      }\n    }\n    bool stop = true;\n    vector<int> mark(n);\n    for (int i = 0; i < n; ++i) {\n      if (i == r || mark[i] || comp[i].size() == 0) continue;\n      bool found = false;\n      backward_traverse(i, i, r, g,\n\t\t\tno, comp, prev, mcost, mark, cost, found);\n      if (found) stop = false;\n    }\n    if (stop) {\n      for (int i = 0; i < n; ++i){\n        if (prev[i] >= 0){\n          cost += mcost[i];\n\t}\n      }\n      return cost;\n    }\n  }\n}\n\nint main(){\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n\n  REP(i,m) REP(j,n) scanf(\"%lf\", &v[i][j]);\n  REP(i,m){\n    len[i] = 0.0;\n    REP(j,n) len[i] += v[i][j] * v[i][j];\n  }\n\n  vector<vector<double> > g(m + 1, vector<double>(m + 1));\n\n  REP(i,m) REP(j,m){\n    naiseki[i][j] = 0.0;\n    REP(k,n) naiseki[i][j] += v[i][k] * v[j][k];\n    naiseki[i][j] *= naiseki[i][j];\n\n    g[i][j] = len[j] - naiseki[j][i] / len[i];\n  }\n\n  REP(i,m){\n    g[m][i] = len[i];\n    g[i][m] = inf;\n  }\n  g[m][m] = inf;\n\n  // REP(i,m+1){ REP(j,m+1) printf(\"%.1f \", g[i][j]); puts(\"\"); }\n\n  double ans = minimum_spanning_arborescence(m, g);\n\n  printf(\"%.7f\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nstruct SCC {\n\ttypedef vector<vector<int>> graph;\n\n\tint V;\n\tgraph G;\n\tvector<int> cmp;\n\tvector<int> vs;\n\tvector<bool> used;\n\n\tSCC(int V_):V(V_), G(V_), cmp(V_), used(V_) {}\n\tSCC(const graph &G_):V(G_.size()), G(G_), cmp(V), used(V) {}\n\n\tvoid add_edge(int from, int to) {\n\t\tG[from].emplace_back(to);\n\t}\n\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(!used[to]) dfs(to);\n\t\t}\n\t\tvs.emplace_back(v);\n\t}\n\n\tvoid rdfs(int v, int k, graph &rG) {\n\t\tused[v] = true;\n\t\tcmp[v] = k;\n\t\tfor(const auto &to : rG[v]) {\n\t\t\tif(!used[to]) rdfs(to, k, rG);\n\t\t}\n\t}\n\n\tint scc() {\n\t\tvs.clear();\n\t\tfill(used.begin(), used.end(), false);\n\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tif(!used[v]) dfs(v);\n\t\t}\n\n\t\tgraph rG(V);\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\trG[to].emplace_back(v);\n\t\t\t}\n\t\t}\n\n\t\tfill(used.begin(), used.end(), false);\n\t\tint k = 0;\n\t\tfor(int i = static_cast<int>(vs.size()) - 1; i >= 0; --i) {\n\t\t\tif(!used[vs[i]]) rdfs(vs[i], k++, rG);\n\t\t}\n\t\treturn k;\n\t}\n};\n\ntypedef long double weight;\nconstexpr weight INF = (1 << 28);\n\nstruct edge {\n\tint to;\n\tweight cost;\n\tedge(int to_, weight cost_):to(to_), cost(cost_){}\n};\n\ntypedef vector<vector<edge>> weighted_graph;\n\nweight minimum_spanning_arborescence(int r, const weighted_graph &G, weight sum = 0) {\n\tconst int n = G.size();\n\n\tvector<int> rev(n, -1);\n\tvector<weight> minimum_weight(n, INF);\n\tfor(int v = 0; v < n; ++v) {\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(minimum_weight[e.to] > e.cost) {\n\t\t\t\tminimum_weight[e.to] = e.cost;\n\t\t\t\trev[e.to] = v;\n\t\t\t}\n\t\t}\n\t}\n\n\tSCC scc(n);\n\tfor(int v = 0; v < n; ++v) {\n\t\tif(v == r) continue;\n\t\tif(rev[v] == -1) return INF;\n\t\tscc.add_edge(rev[v], v);\n\t\tsum += minimum_weight[v];\n\t}\n\n\tconst int num = scc.scc();\n\tif(num == n) return sum;\n\n\tweighted_graph next_G(num);\n\tfor(int v = 0; v < n; ++v) {\n\t\tconst int from = scc.cmp[v];\n\t\tfor(const auto &e : G[v]) {\n\t\t\tconst int to = scc.cmp[e.to];\n\t\t\tif(from == to) continue;\n\n\t\t\tconst auto cost = e.cost - minimum_weight[e.to];\n\t\t\tnext_G[from].emplace_back(to, cost);\n\t\t}\n\t}\n\n\treturn minimum_spanning_arborescence(scc.cmp[r], next_G, sum);\n}\n\ntypedef vector<weight> vec;\n\ninline weight dot(const vec &a, const vec &b) {\n\tweight res = 0.0;\n\tfor(int i = 0; i < a.size(); ++i) {\n\t\tres += a[i] * b[i];\n\t}\n\treturn res;\n}\n\ninline weight norm(const vec &v) {\n\treturn dot(v, v);\n}\n\ninline weight calc(const vec &a, const vec &b) {\n\tconst weight r = dot(a, b) / norm(a);\n\tweight res = 0.0;\n\tfor(int i = 0; i < a.size(); ++i) {\n\t\tconst weight t = b[i] - r * a[i];\n\t\tres += t * t;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.precision(10);\n\tcout.flags(ios::fixed);\n\n\tint d, n;\n\tcin >> d >> n;\n\n\tvector<vec> vectors;\n\tvectors.reserve(n);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tvec v(d);\n\t\tfor(auto &e : v) cin >> e;\n\t\tvectors.emplace_back(v);\n\t}\n\n\tweighted_graph G(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tG[i].reserve(n - 1);\n\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(i == j) continue;\n\t\t\tG[i].emplace_back(j, calc(vectors[i], vectors[j]));\n\t\t}\n\t}\n\n\tweight ans = INF;\n\tfor(int r = 0; r < n; ++r) {\n\t\tchmin(ans, minimum_spanning_arborescence(r, G) + norm(vectors[r]));\n\t}\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst int N = 111;\nconst long double eps = 1e-10;\nconst int INF = 0x7FFFFFFF/2;\nint n, m, pos[N];\nlong double v[N][N], val[N], dist[N][N];\n\nlong double get_r(int i, int j)\n{\n    long double up = 0.0;\n    long double down = 0.0;\n    for (int k = 1; k <= n; ++k) {\n        up += v[j][k] * v[i][k];\n        down += v[j][k] * v[j][k];\n    }\n    if (fabs(down) < eps) return 0;\n    return up / down;\n}\n\nbool cmp(const int &x, const int &y) {\n    return y < x;\n}\n\nnamespace Chuliu{\n    int n, used[N], pass[N], eg[N], more, que[N];\n    long double g[N][N];\n    void combine(int id, long double &sum) {\n        int tot = 0, from, i, j, k;\n        for ( ; id != 0 && !pass[id]; id = eg[id])\n            que[tot++] = id, pass[id] = 1;\n        for (from = 0; from < tot && que[from] != id; from++);\n        if (from == tot) return;\n\n        more = 1;\n        for (i = from; i < tot; i++) {\n            sum += g[eg[que[i]]][que[i]];\n            if (i == from) continue;\n            for (j = used[que[i]] = 1; j <= n; j++)\n                if (!used[j])\n                    if (g[que[i]][j] < g[id][j])\n                        g[id][j] = g[que[i]][j];\n        }\n        for (i = 1; i <= n; i++)\n            if (!used[i] && i != id) {\n                for (j = from; j < tot; j++) {\n                    k = que[j];\n                    if (g[i][id] > g[i][k] - g[eg[k]][k])\n                        g[i][id] = g[i][k] - g[eg[k]][k];\n                }\n            }\n    }\n    void clear(int V) {\n        n = V;\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                g[i][j] = dist[i][j];\n        for(int i = 1; i <= n; ++i)\n            g[i][i] = 0x3f3f3f3f;\n    }\n    long double solve(int root) {\n        int i, j, k;\n        long double sum = 0.0;\n        memset(used, 0, sizeof(int) * (n + 1));\n        for (more = 1; more; ) {\n            more = 0;\n            memset(eg, 0, sizeof(int) * (n + 1));\n            for (i = 1; i <= n; i++)\n                if (!used[i] && i != root) {\n                    for (j = 1, k = 0; j <= n; j++)\n                        if (!used[j] && i != j)\n                            if (k == 0 || g[j][i] < g[k][i]) k = j;\n                    eg[i] = k;\n                }\n            memset(pass, 0, sizeof(int) * (n + 1));\n            for (i = 1; i <= n; i++)\n                if (!used[i] && !pass[i] && i != root)\n                    combine(i, sum);\n        }\n        for (i = 1; i <= n; ++i)\n            if (!used[i] && i != root)\n                sum += g[eg[i]][i];\n        return sum;\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    long double min_val = INF;\n    for (int i = 1; i <= m; ++i) {\n        val[i] = 0.0;\n        for (int j = 1; j <= n; ++j) {\n            cin >> v[i][j];\n            val[i] += v[i][j] * v[i][j];\n            min_val = min(min_val, val[i]);\n        }\n    }\n\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            dist[j][i] = 0.0;\n            long double r = get_r(i, j);\n            for (int k = 1; k <= n; ++k)\n                dist[j][i] += (v[i][k] - r * v[j][k]) * (v[i][k] - r * v[j][k]);\n        }\n    }\n\n    for (int i = 1; i <= m; ++i)\n        dist[i][m + 1] = dist[m + 1][i] = INF + val[i];\n\n    Chuliu::clear(m + 1);\n    long double ans = Chuliu::solve(m + 1) - INF;\n\n    cout << setiosflags(ios::fixed) << setprecision(10) << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n//Without merge technique\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using C = function<bool(T,T)>;\n  G g;\n  H h;\n  C c;\n  T INF;\n  E ei;\n  SkewHeap(G g,H h,C c,T INF,E ei):g(g),h(h),c(c),INF(INF),ei(ei){}\n  \n  struct Node{\n    Node *l,*r;\n    T val;\n    E add;\n    Node(T val,E add):val(val),add(add){l=r=nullptr;}\n  };\n\n  void eval(Node *a){\n    if(a==nullptr) return;\n    if(a->add==ei) return;\n    if(a->l) a->l->add=h(a->l->add,a->add);\n    if(a->r) a->r->add=h(a->r->add,a->add);\n    a->val=g(a->val,a->add);\n    a->add=ei;\n  }\n  \n  T top(Node *a){\n    return a!=nullptr?g(a->val,a->add):INF;\n  }\n\n  T snd(Node *a){\n    eval(a);\n    return a!=nullptr?min(top(a->l),top(a->r)):INF;\n  }\n\n  Node* add(Node *a,E d){\n    if(a!=nullptr) a->add=h(a->add,d);\n    return a;\n  }\n  \n  Node* push(T v){\n    return new Node(v,ei);\n  }\n  \n  Node* meld(Node *a,Node *b){\n    if(!a||!b) return a?a:b;\n    if(c(top(a),top(b))) swap(a,b);\n    eval(a);\n    a->r=meld(a->r,b);\n    swap(a->l,a->r);\n    return a;\n  }\n  \n  Node* pop(Node* a){\n    eval(a);\n    auto res=meld(a->l,a->r);\n    delete a;\n    return res;\n  }\n  \n};\n\n//INSERT ABOVE HERE\ntemplate<typename T>\nstruct Arborescence{\n  typedef pair<T, int> P;\n  using Heap = SkewHeap<P, T>;\n  \n  struct edge{\n    int from,to;\n    T cost;\n    edge(){}\n    edge(int from,int to,T cost):from(from),to(to),cost(cost){}\n  };\n  \n  int n;\n  P INF;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<typename Heap::Node*> come;\n  vector<int> used,from;\n  vector<T> cost;\n  \n  Arborescence(int n,T INF):n(n),INF(INF,-1),uf(n),come(n,NULL),\n                            used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(int from,int to,T cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(int m,int offset=0){\n    for(int i=0;i<m;i++){\n      int u,v;\n      T c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  T build(int r){\n    typename Heap::G g=[](P a,T b){return P(a.first+b,a.second);};\n    typename Heap::H h=[](T a,T b){return a+b;};\n    typename Heap::C c=[](P a,P b){return a>b;};\n    Heap heap(g,h,c,INF,0);\n  \n    used[r]=2;\n    for(int i=0;i<(int)edges.size();i++){\n      edge &e=edges[i];\n      come[e.to]=heap.meld(come[e.to],heap.push(P(e.cost,i)));\n    }\n    \n    T res=0;\n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      int v=i;\n      vector<int> l;\n      while(used[v]!=2){\n        used[v]=1;\n        l.emplace_back(v);\n        if(!come[v]) return T(-1);\n        from[v]=uf.find(edges[come[v]->val.second].from);\n        cost[v]=heap.top(come[v]).first;\n        come[v]=heap.pop(come[v]);\n        if(from[v]==v) continue;\n\t\n        res+=cost[v];\n        if(used[from[v]]==1){\n          int p=v;\n          do{\n            if(come[p]!=nullptr) heap.add(come[p],-cost[p]);\n            if(p!=v){\n              uf.unite(v,p);\n              come[v]=heap.meld(come[v],come[p]);\n            }\n            p=uf.find(from[p]);\n          }while(p!=v);\n        }else{\n          v=from[v];\n        }\n      }\n      for(int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n//END CUT HERE\nstruct AOJ_GRL_2B{\n  signed solve(){\n    int n,m,r;\n    cin>>n>>m>>r;\n    const int INF = 1e8;\n    Arborescence<int> G(n,INF);\n    G.input(m);\n    cout<<G.build(r)<<endl;\n    return 0;\n  }\n};\n\n/*\n  verified on 2018/03/04\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_B&lang=jp\n*/\n\nstruct UVA11183{\n  signed solve(){\n    Int T;\n    cin>>T;\n    for(Int t=1;t<=T;t++){\n      Int n,m;\n      cin>>n>>m;\n      const Int INF = 1e15;\n      Arborescence<Int> G(n,INF);\n      G.input(m);\n      Int ans=G.build(0);\n      cout<<\"Case #\"<<t<<\": \"; \n      if(ans<0) cout<<\"Possums!\"<<endl;\n      else cout<<ans<<endl;\n    }\n    return 0;\n  }\n};\n\n\n/*\n  verified on 2018/03/04\n  https://vjudge.net/problem/UVA-11183\n*/\n\ndouble v[111][111];\ndouble c[111][111];\nsigned AOJ_2309(){\n  Int n,m;\n  cin>>n>>m;\n  for(Int i=0;i<m;i++)\n    for(Int j=0;j<n;j++)\n      cin>>v[i][j];\n \n  for(Int i=0;i<m;i++){\n    c[i][i]=0;\n    for(Int j=0;j<n;j++) c[i][i]+=v[i][j]*v[i][j];\n  }\n  for(Int i=0;i<m;i++){\n    for(Int j=0;j<m;j++){\n      if(i==j) continue;\n      if(c[j][j]==0){\n        c[i][j]=c[i][i];\n        continue;\n      }\n      double r=0;\n      for(Int k=0;k<n;k++)\n        r+=v[i][k]*v[j][k];\n      r/=c[j][j];\n      c[i][j]=0;\n      for(Int k=0;k<n;k++)\n        c[i][j]+=(v[i][k]-r*v[j][k])*(v[i][k]-r*v[j][k]);      \n    }    \n  }\n  const double INF = 1e12;\n  Arborescence<double> G(m+1,INF);\n  for(Int i=0;i<m;i++){\n    G.add_edge(m,i,c[i][i]);\n    for(Int j=0;j<m;j++){\n      //cout<<i<<\" \"<<j<<\":\"<<c[i][j]<<endl;\n      if(i==j) continue;\n      G.add_edge(j,i,c[i][j]);\n    }\n  }\n  cout<<fixed<<setprecision(12)<<G.build(m)<<endl;\n  return 0;\n}\n\n/*\n  verified on 2018/07/26\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2309\n*/\n\nsigned main(){\n  //AOJ_GRL_2B ans;\n  //UVA11183 ans;\n  //ans.solve();\n  AOJ_2309();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<map>\n#include<ctime>\nusing namespace std;\n#define LL double\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define sqr(x) (x)*(x)\nconst int MAX=1005;\nconst LL inf=1e30;\nstruct node\n{\n    int u,v;\n    LL w;\n}g[MAX*MAX];\nint e,ans;\nint vis[MAX],id[MAX],pre[MAX];\nLL in[MAX],sum,res,gg[105][105];\nvoid add(int u,int v,LL w)\n{\n    g[e].u=u; g[e].v=v; g[e++].w=w;\n    //cout<<u<<\"->\"<<v<<\" \"<<w<<endl;\n    gg[u][v]=w;\n}\ndouble ZL(int root,int n)\n{\n    int i,j,k,u,v,vn;\n    res=0;\n    while(1)\n    {\n        for(i=0;i<n;i++)\n            in[i]=inf;\n        for(i=0;i<e;i++)\n        {\n            u=g[i].u; v=g[i].v;\n            if(g[i].w<in[v]&&u!=v)\n            {\n                pre[v]=u;\n                in[v]=g[i].w;\n            }\n        }\n        for(i=0;i<n;i++)\n        {\n            if(i!=root&&in[i]==inf)\n                return false;\n        }\n        vn=0;\n        memset(id,-1,sizeof(id));\n        memset(vis,-1,sizeof(vis));\n        in[root]=0;\n        for(i=0;i<n;i++)\n        {\n            res+=in[i];\n            v=i;\n            while(vis[v]!=i&&id[v]==-1&&v!=root)\n            {\n                vis[v]=i;\n                v=pre[v];\n            }\n            if(v!=root&&id[v]==-1)\n            {\n                for(u=pre[v];u!=v;u=pre[u])\n                {\n                    id[u]=vn;\n                }\n                id[v]=vn++;\n            }\n        }\n        if(vn==0)\n            break;\n        for(i=0;i<n;i++)\n        {\n            if(id[i]==-1)\n                id[i]=vn++;\n        }\n        for(i=0;i<e;i++)\n        {\n            v=g[i].v;\n            g[i].u=id[g[i].u];\n            g[i].v=id[g[i].v];\n            if(g[i].u!=g[i].v)\n            {\n                g[i].w-=in[v];\n            }\n        }\n        n=vn;\n        root=id[root];\n    }\n    return res;\n}\ndouble a[105][105],len[105];\nint main()\n{\n    int n,m,i,j,k;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        e=0;\n        rep (i, m) {\n            len[i] = 0;\n            rep (j, n) {\n                scanf (\"%lf\", &a[i][j]);\n                len[i] += a[i][j] * a[i][j];\n            }\n            len[i] = sqrt(len[i]);\n        }\n        rep (i, m) {\n            rep (j, m) {\n                if (i == j) continue;\n                double now = 0.0;\n                rep (k, n) {\n                    now += a[i][k] * a[j][k];\n                }\n                now /= len[i] * len[j];\n                now = sqrt (1.0 - now * now);\n                gg[j + 1][i + 1] = sqr(len[i] * now);\n                add(j+1,i+1,gg[j+1][i+1]);\n            }\n            gg[0][i + 1] = sqr(len[i]);\n            add(0,i+1,gg[0][i+1]);\n            //gg[i + 1][0] = -1;\n            //gg[i + 1][i + 1] = -1;\n        }\n        //for(int i=0;i<=m;i++)\n            //for(int j=0;j<=m;j++)\n                //printf(\"%d->%d %lf\\n\",i,j,gg[i][j]);\n        printf(\"%.8f\\n\",ZL(0,m+1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nld getlen(const vector<ld>&now, const vector<ld>&comp) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin * 2 + amax) / 3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld alen0 = 0,alen1=0;\n\t\t{\n\t\t\tvector<ld>aft(now);\n\t\t\tfor (int i = 0; i < aft.size(); ++i) {\n\t\t\t\taft[i] -= comp[i] * amid0;\n\t\t\t\talen0 += aft[i] * aft[i];\n\t\t\t}\n\t\t}\n\t\t{\n\n\t\t\tvector<ld>aft(now);\n\t\t\tfor (int i = 0; i < aft.size(); ++i) {\n\t\t\t\taft[i] -= comp[i] * amid1;\n\t\t\t\talen1 += aft[i] * aft[i];\n\t\t\t}\n\t\t}\n\t\tif (alen0 > alen1) {\n\t\t\tamin = amid0;\n\t\t}\n\t\telse {\n\t\t\tamax = amid1;\n\t\t}\n\t\tif (n == 0)return alen0;\n\t}\n\t\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M, vector<ld>(N));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tsort(vecs.begin(), vecs.end(), [](const vector<ld>&l, const vector<ld>&r) {\n\t\tld al = 0,ar=0;\n\t\tfor (auto v : l) {\n\t\t\tal += v*v;\n\t\t}\n\t\tfor (auto v : r) {\n\t\t\tar += v*v;\n\t\t}\n\t\treturn al < ar;\n\t});\n\tld ans = 0;\n\tfor (int i = 0; i < vecs.size(); ++i) {\n\t\tld len = 0;\n\t\tfor (auto v : vecs[i]) {\n\t\t\tlen += v*v;\n\t\t}\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tld alen = getlen(vecs[i], vecs[j]);\n\t\t\tlen = min(len, alen);\n\t\t}\n\t\tans += len;\n\t}\n\tcout <<setprecision(22)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\ntypedef ld Weight;\n\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g, const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < int(g.size()); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(), -1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now] != -1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight, Graph> chu_liu(const Graph&g, const int start, const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tWeight total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight, e.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < int(g.size()); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight, reve.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t\tif (cycle_edges.empty()) {\n\t\t\treturn make_pair(total_len, tree);\n\t\t}\n\t}\n\tvector<bool>node_is_cycle(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<int>edge_is_cycle(e_size);\n\n\tvector<Weight>prev_lens(g.size(), ZERO);\n\n\tfor (auto ce : cycle_edges) {\n\t\tnode_is_cycle[ce.src] = true;\n\t\tprev_lens[ce.dst] = ce.weight;\n\t}\n\tGraph newg(g.size());\n\tconst int compress = cycle_edges[0].src;\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\tfor (int s = 0; s < int(g.size()); ++s) {\n\t\tbool src_is_cycle = node_is_cycle[s];\n\t\tfor (auto e : g[s]) {\n\t\t\tmemo[e.id] = e;\n\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (src_is_cycle) {\n\t\t\t\te.src = compress;\n\t\t\t}\n\t\t\telse if (dst_is_cycle) {\n\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\te.dst = compress;\n\t\t\t}\n\t\t\tnewg[e.src].push_back(e);\n\t\t}\n\t}\n\tauto p = chu_liu(newg, start, e_size);\n\tGraph compress_tree(p.second);\n\tGraph ans_tree(g.size());\n\tfor (auto es : compress_tree) {\n\t\tfor (auto e : es) {\n\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\tif (node_is_cycle[prev_edge.dst]) {\n\t\t\t\tfor (auto cycle_edge : cycle_edges) {\n\t\t\t\t\tif (cycle_edge.dst != prev_edge.dst) {\n\t\t\t\t\t\tans_tree[cycle_edge.src].emplace_back(cycle_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\treturn make_pair(p.first + cycle_len, ans_tree);\n}\n\nld getlen(const vector<ld>&a, const vector<ld>&b,const ld n) {\n\n\tld sum = 0;\n\tfor (int k = 0; k < a.size(); ++k) {\n\t\tsum += pow(a[k]*n - b[k], 2);\n\t}\n\treturn sum;\n}\n\nld getdis(const vector<ld>&a, const vector<ld>&b) {\n\tld amin = -1e8;\n\tld amax = 1e8;\n\tint num = 100;\n\twhile (num--) {\n\t\tld amid1 = (amin * 2 + amax) / 3;\n\t\tld amid2 = (amin + amax * 2) / 3;\n\t\tld ans1 = getlen(a, b, amid1);\n\t\tld ans2 = getlen(a, b, amid2);\n\t\tif (ans1 < ans2) {\n\t\t\tamax = amid2;\n\t\t}\n\t\telse {\n\t\t\tamin = amid1;\n\t\t}\n\t}\n\treturn getlen(a, b, amin);\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld v; cin >> v;\n\t\t\tvecs[i].emplace_back(v);\n\t\t}\n\t}\n\tGraph g(M);\n\tint aid = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i == j)continue;\n\t\t\telse {\n\t\t\t\tld len = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[i].push_back(Edge(i, j, len,aid++));\n\t\t\t}\n\t\t}\n\t}\n\tld ans = 1e18;\n\tfor (int i = 0; i < M; ++i) {\n\t\tvector<ld>v(N);\n\t\tauto p = chu_liu(g, i, M*(M - 1));\n\t\tld plus = getlen(v, vecs[i],0);\n\t\tans = min(ans, p.first+plus);\n\t}\n\tcout <<setprecision(12)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\ntypedef ld Weight;\n\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g, const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < int(g.size()); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(), -1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now] != -1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\npair<Weight, Graph> chu_liu(const Graph&g, const int start, const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tWeight total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight, e.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < int(g.size()); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight, reve.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t\tif (cycle_edges.empty()) {\n\t\t\treturn make_pair(total_len, tree);\n\t\t}\n\t}\n\tvector<bool>node_is_cycle(g.size());\n\n\tvector<int>edge_is_cycle(e_size);\n\n\tvector<Weight>prev_lens(g.size(), ZERO);\n\n\tfor (auto ce : cycle_edges) {\n\t\tnode_is_cycle[ce.src] = true;\n\t\tprev_lens[ce.dst] = ce.weight;\n\t}\n\tGraph newg(g.size());\n\tconst int compress = cycle_edges[0].src;\n\tvector<Edge>memo(e_size);\n\tfor (int s = 0; s < int(g.size()); ++s) {\n\t\tbool src_is_cycle = node_is_cycle[s];\n\t\tfor (auto e : g[s]) {\n\t\t\tmemo[e.id] = e;\n\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (src_is_cycle) {\n\t\t\t\te.src = compress;\n\t\t\t}\n\t\t\telse if (dst_is_cycle) {\n\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\te.dst = compress;\n\t\t\t}\n\t\t\tnewg[e.src].push_back(e);\n\t\t}\n\t}\n\tauto p = chu_liu(newg, start, e_size);\n\tGraph compress_tree(p.second);\n\tGraph ans_tree(g.size());\n\tfor (auto es : compress_tree) {\n\t\tfor (auto e : es) {\n\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\tif (node_is_cycle[prev_edge.dst]) {\n\t\t\t\tfor (auto cycle_edge : cycle_edges) {\n\t\t\t\t\tif (cycle_edge.dst != prev_edge.dst) {\n\t\t\t\t\t\tans_tree[cycle_edge.src].emplace_back(cycle_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\treturn make_pair(p.first + cycle_len, ans_tree);\n}\n\nld getlen(const vector<ld>&a, const vector<ld>&b,const ld n) {\n\n\tld sum = 0;\n\tfor (int k = 0; k < a.size(); ++k) {\n\t\tsum += pow(a[k]*n - b[k], 2);\n\t}\n\treturn sum;\n}\n\nld getdis(const vector<ld>&a, const vector<ld>&b) {\n\tld amin = -1e8;\n\tld amax = 1e8;\n\tint num = 100;\n\twhile (num--) {\n\t\tld amid1 = (amin * 2 + amax) / 3;\n\t\tld amid2 = (amin + amax * 2) / 3;\n\t\tld ans1 = getlen(a, b, amid1);\n\t\tld ans2 = getlen(a, b, amid2);\n\t\tif (ans1 < ans2) {\n\t\t\tamax = amid2;\n\t\t}\n\t\telse {\n\t\t\tamin = amid1;\n\t\t}\n\t}\n\treturn getlen(a, b, amin);\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld v; cin >> v;\n\t\t\tvecs[i].emplace_back(v);\n\t\t}\n\t}\n\tGraph g(M);\n\tint aid = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i == j)continue;\n\t\t\telse {\n\t\t\t\tld len = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[i].push_back(Edge(i, j, len,aid++));\n\t\t\t}\n\t\t}\n\t}\n\tld ans = 1e18;\n\tfor (int i = 0; i < M; ++i) {\n\t\tvector<ld>v(N);\n\t\tauto p = chu_liu(g, i, M*(M - 1));\n\t\tld plus = getlen(v, vecs[i],0);\n\t\tans = min(ans, p.first+plus);\n\t}\n\tcout <<setprecision(12)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\n#define clr(x,a) memset(x,a,sizeof(x))\n#define sz(x) (int)x.size()\n#define see(x) cerr<<#x<<\" \"<<x<<endl\n#define se(x) cerr<<\" \"<<x \n#define pb push_back\n#define mk make_pair\n#define X first\n#define Y second\n#define maxn 205\n#define maxm 11005\n#define type double \ndouble sqr(double x)\n{\n\treturn x*x;\n}\nconst int inf = ~0u >> 1;\nstruct edge\n{\n    int u,v;\n    type cost;\n    int oldu,oldv;\n    edge(){}\n    edge(int a,int b,type c,int d,int e):u(a),v(b),cost(c),oldu(d),oldv(e){}\n}e[maxm];\nint pre[maxn],id[maxn],vis[maxn];\nint mark;\ntype in[maxn];\ntype dirmst(int root,int nv,int ne)\n{\n    type ret = 0;\n    int cnt = 0;\n    int oldroot = root;\n    while(1)\n    {\n        cnt++;\n        fill(in,in + nv,inf);\n        for(int i = 0;i < ne;i++)\n        {\n            int u = e[i].u;\n            int v = e[i].v;\n            if(e[i].cost < in[v] && u != v)\n            {\n                if(e[i].oldu == oldroot)\n                    mark = e[i].oldv;\n                pre[v] = u;\n                in[v] = e[i].cost;\n            }\n        }\n        for(int i = 0;i <nv;i++)\n        {\n            if(i == root)\n                continue;\n            if(in[i] == inf)\n                return -1;\n        }\n        int cntnode = 0;\n        fill(id,id + nv,-1);\n        fill(vis,vis + nv,-1);\n        in[root] = 0;\n        for(int i = 0;i < nv;i++)\n        {\n            ret += in[i];\n            int v = i;\n            while(vis[v] != i && id[v] == -1 && v != root)\n            {\n                vis[v] = i;\n                v = pre[v];\n            }\n            if(v != root && id[v] == -1)\n            {\n                for(int u = pre[v];u != v;u = pre[u])\n                    id[u] = cntnode;\n                id[v] = cntnode++;\n            }\n        }\n        if(cntnode == 0)\n            break;\n        for(int i = 0;i < nv;i++)\n            if(id[i] == -1)\n                id[i] = cntnode++;\n        for(int i = 0;i < ne;i++)\n        {\n            int v = e[i].v;\n            e[i].u = id[e[i].u];\n            e[i].v = id[e[i].v];\n            if(e[i].u != e[i].v)\n                e[i].cost -= in[v];\n        }\n        nv = cntnode;\n        root = id[root];\n    }\n    return ret;\n}\n\nint n,m;\ndouble dv[maxn],db[maxn][maxn];\ndouble g[maxn][maxn],f[maxn][maxn];\nvoid init()\n{\n\tint i,j,k;\n\tclr(g,0);\n\tclr(dv,0);\n\tclr(db,0);\n\tfor(i=1; i<=n;i++)\n\t{\n\t\tfor(j=1; j<=m; j++)\n\t\t{\n\t\t\tscanf(\"%lf\",&g[i][j]);\n\t\t\tdv[i]+=sqr(g[i][j]);\n\t\t}\n\t}\n\tfor(i=1; i<=n ;i++)\n\tfor(j=1; j<=n ;j++)\n\t{\n\t\tfor(k=1; k<=m; k++)\n\t\t{\n\t\t\tdb[i][j]+=g[i][k]*g[j][k];\n\t\t}\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in\",\"r\",stdin);\n\tint i,j,k;\n    while(scanf(\"%d %d\",&m,&n) == 2)\n    {\n    \tinit();\n        int sum = 0;\n        mark = -1;\n        int el=0;\n        clr(f,0);\n        for(i=1; i<=n; i++)\n        {\n        \tj=0;\n        \tf[j][i]=dv[i];\n        \te[el++] = edge(j,i,f[j][i],j,i);\n        \tfor(j=1; j<=n; j++)\n        \tif(i!=j)\n        \t{\n        \t\tf[j][i]=(dv[j]*dv[i]-db[i][j]*db[i][j])/dv[j];\n        \t\te[el++] = edge(j,i,f[j][i],j,i);\n        \t}\n        }\n\t\t\n        double ans = dirmst(0,n + 1,el);\n        printf(\"%.6f\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst double INF = 1e32;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst;\n  double cost;\n  Edge(int s, int d, double c) : \n    src(s), dst(d), cost(c) {}\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nvoid add_edge(Graph& G, int a, int b, double c){\n  G[a].push_back(Edge(a, b, c));\n}\n// Strongly Connected Components(強連結成分)\n\n// Step1\nvoid SCC_dfs(const Graph& G, vector<bool>& visit, vector<int>& order, int v){\n  visit[v] = true;\n  REP(i, G[v].size()){\n    int dst = G[v][i].dst;\n    if(!visit[dst]) SCC_dfs(G, visit, order, dst);\n  }\n  order.push_back(v);\n}\n\n// Step2\nGraph reverse_graph(const Graph& G){\n  Graph revG(G.size());\n  REP(i, G.size()){\n    REP(j, G[i].size()){\n      const Edge &e = G[i][j];\n      revG[e.dst].push_back(Edge(e.dst, e.src, e.cost));\n    }\n  }\n  return revG;\n}\n\n// Step3\nvoid SCC_rdfs(const Graph& G, vector<bool>& visit, vector<int>& comp, int v, int k){\n  visit[v] = true;\n  REP(i, G[v].size()){\n    int dst = G[v][i].dst;\n    if(!visit[dst]) SCC_rdfs(G, visit, comp, dst, k);\n  }\n  comp[v] = k;\n}\n\n// 強連結成分分解\nint SCC(const Graph& G, vector<int>& comp){\n  Graph revG = reverse_graph(G);\n  comp = vector<int>(G.size());\n  vector<bool> visit(G.size());\n  vector<int> order(G.size());\n  int k = 0;\n  REP(i, G.size()) if(!visit[i]) SCC_dfs(G, visit, order, i);\n  reverse(order.begin(), order.end()); \n\n  visit = vector<bool>(G.size());\n  REP(i, order.size()){\n    if(!visit[order[i]]) SCC_rdfs(revG, visit, comp, order[i], k++);\n  }\n  return k;\n}\n\n\ndouble MOB(Graph& G, int root){\n  int V = G.size();\n  double res = 0;\n\n  // 各ノードに入る最小の辺を求める\n  vector<Edge> min_edge(V, Edge(-1, -1, INF));\n  REP(v, V) REP(i, G[v].size()){\n    Edge& e = G[v][i];\n    if(min_edge[e.dst].cost > e.cost){\n      min_edge[e.dst] = e;\n    }\n  }\n\n  // コストを足し合わせる\n  /*\n  printf(\"V = %d root = %d\\n\", V, root);\n  REP(v, V) REP(i, G[v].size()) printf(\"G[%d][%d] = Edge(%d, %d, %lf)\\n\", v, i, G[v][i].src, G[v][i].dst, G[v][i].cost);\n  REP(v, V) printf(\"min_edge[%d].cost = %lf\\n\", v, min_edge[v].cost);\n  */\n  REP(v, V) if(v != root) {\n    if(min_edge[v].cost == INF) return INF; // rootから到達不可能な頂点が存在する\n    res += min_edge[v].cost;\n  }\n\n  // 各辺のコストを、最小のコスト分だけ減らす\n  REP(v, V) REP(i, G[v].size()){\n    Edge& e = G[v][i];\n    if(e.dst != root) e.cost -= min_edge[e.dst].cost;\n  }\n\n  // 強連結成分分解で、ループがあるかどうか調べる\n  Graph sG(V);\n  REP(v, V) if(v != root) {\n    Edge& e = min_edge[v];\n    sG[e.src].push_back(e);\n  }\n  vector<int> comp;\n  int m = SCC(sG, comp);\n  if(m == V) return res; // ループがなければ終了\n\n  // 次に調べるグラフを作る\n  Graph nG(m);\n  REP(v, V) REP(i, G[v].size()){\n    Edge& e = G[v][i];\n    if(comp[v] != comp[e.dst]) nG[comp[v]].push_back(Edge(comp[v], comp[e.dst], e.cost));\n  }\n\n  return min(INF, res + MOB(nG, comp[root]));\n}\nint main(){\n  int N, M;\n  while(cin >> N >> M){\n    vector<double> v[100];\n    REP(i, M){\n      v[i] = vector<double>(N);\n      REP(j, N) cin >> v[i][j];\n    }\n    double dot[100][100] = {};\n    REP(i, M) REP(j, M){\n      REP(k, N) dot[i][j] += v[i][k] * v[j][k];\n    }\n    double dist[100][100] = {};\n    REP(i, M) REP(j, M){\n      dist[i][j] = dot[j][j] - (abs(dot[i][i]) < 1e-9 ? 0.0 : (dot[i][j] * dot[i][j]) / dot[i][i]);\n    }\n    Graph G(M + 1);\n    REP(i, M) REP(j, M) if(i != j) {\n      add_edge(G, i, j, dist[i][j]);\n    }\n    REP(i, M) {\n      add_edge(G, M, i, dot[i][i]);\n    }\n    printf(\"%.16lf\\n\", MOB(G, M));\n    //REP(i, M) REP(j, M) printf(\"dist[%d][%d] = %lf\\n\", i, j, dist[i][j]);\n    /*\n    double ans = 1e16;\n    REP(s, M){\n      typedef pair<double, double> P;\n      typedef pair<P, int> S;\n      priority_queue<S, vector<S>, greater<S> > que;\n      que.push(S(P(dot[s][s], dot[s][s]), s));\n      double used[100] = {};\n      double sum = 0;\n      //printf(\"start = %d\\n\", s);\n      while(!que.empty()){\n        double alld = que.top().first.first;\n        double d = que.top().first.second;\n        int u = que.top().second;\n        //printf(\"alld = %lf d = %lf u = %d\\n\", alld, d, u);\n        que.pop();\n        if(used[u]) continue;\n        //printf(\"add %d %lf\\n\", u, d);\n        sum += d;\n        used[u] = true;\n        REP(i, M) if(!used[i]){\n          //printf(\"push(%lf, %lf, %d)\\n\", alld + dist[u][i], dist[u][i], i);\n          que.push(S(P(alld + dist[u][i], dist[u][i]), i));\n        }\n      }\n      //printf(\"sum = %lf\\n\", sum);\n      ans = min(ans, sum);\n    }\n    printf(\"%.16lf\\n\", ans);\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<iomanip>\nusing namespace std;\n#define eps 1e-8\n#define INF 1000000\n#define maxn 200005\ndouble a[105][105];\ndouble sum[105];\nstruct Edge\n{\n    int u,v;\n    double cost;\n}b[10005],edge[10005];\nint pre[maxn],id[maxn],visit[maxn];\ndouble in[maxn];\ndouble gao(int root,int n,int m)\n{\n    double res = 0;\n    int u,v;\n    while(1)\n    {\n        for(int i = 0;i < n;i++)\n            in[i] = INF;\n        for(int i = 0;i < m;i++)\n            if(edge[i].u != edge[i].v && edge[i].cost < in[edge[i].v])\n            {\n                pre[edge[i].v] = edge[i].u;\n                in[edge[i].v] = edge[i].cost;\n            }\n        for(int i = 0;i < n;i++)\n            if(i != root && in[i] == INF)\n                return -1;\n        int tn = 0;\n        memset(id,-1,sizeof(id));\n        memset(visit,-1,sizeof(visit));\n        in[root] = 0;\n        for(int i = 0;i < n;i++)\n        {\n            res += in[i];\n            v = i;\n            while( visit[v] != i && id[v] == -1 && v != root)\n            {\n                visit[v] = i;\n                v = pre[v];\n            }\n            if( v != root && id[v] == -1 )\n            {\n                for(int u = pre[v]; u != v ;u = pre[u])\n                    id[u] = tn;\n                id[v] = tn++;\n            }\n        }\n        if(tn == 0)break;\n        for(int i = 0;i < n;i++)\n            if(id[i] == -1)\n                id[i] = tn++;\n        for(int i = 0;i < m;)\n        {\n            v = edge[i].v;\n            edge[i].u = id[edge[i].u];\n            edge[i].v = id[edge[i].v];\n            if(edge[i].u != edge[i].v)\n                edge[i++].cost -= in[v];\n            else\n                swap(edge[i],edge[--m]);\n        }\n        n = tn;\n        root = id[root];\n    }\n    return res;\n}\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<m;i++)    for(int j=0;j<n;j++)    scanf(\"%lf\",a[i]+j);\n    int tot=0;\n    for(int i=0;i<m;i++)             //j->i??±?\n    {\n        for(int j=0;j<m;j++)\n        {\n            double x1=0,x2=0,x3=0;     // y=r*r*x3-2*r*x2+x1\n            for(int k=0;k<n;k++)\n            {\n                x1+=a[i][k]*a[i][k];\n                x3+=a[j][k]*a[j][k];\n                x2+=a[i][k]*a[j][k];\n            }\n            sum[i]=x1;\n            if(i==j)    continue;\n            double x=x2/x3;\n            double y=x*x*x3-2.0*x*x2+x1;\n            b[tot].u=j;\n            b[tot].v=i;\n            b[tot].cost=y;\n            tot++;\n        }\n    }\n    double fin=INF;\n    for(int i=0;i<m;i++)\n    {\n        for(int j=0;j<tot;j++)\n        {\n            edge[j].cost=b[j].cost;\n            edge[j].u=b[j].u;\n            edge[j].v=b[j].v;\n        }\n        double temp=gao(i,m,tot)+sum[i];\n        fin=min(fin,temp);\n    }\n    printf(\"%.10f\\n\",fin);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\ntypedef ld Weight;\n\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g, const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < int(g.size()); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(), -1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now] != -1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309テ」ツつ致arifyテ」ツ?療」ツ?淌」ツ?古」ツ??ヲツュツ」テ」ツ?療」ツ?湘・ツセツゥテ・ツ?ε」ツ?ァテ」ツ?催」ツ?ヲテ」ツ??」ツつ凝」ツ?凝」ツ?ッテ、ツクツ催ヲツ伉?\npair<Weight, Graph> chu_liu(const Graph&g, const int start, const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tWeight total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight, e.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < int(g.size()); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight, reve.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t\tif (cycle_edges.empty()) {\n\t\t\treturn make_pair(total_len, tree);\n\t\t}\n\t}\n\tvector<bool>node_is_cycle(g.size());\n\n\t/*ティツヲツ?ァツエツ?ヲツ閉ーテ」ツ?ッEdgeテ」ツ?ョテヲツ閉ーテ」ツ??」ツ?妥」ツ?ァティツ可ッテ」ツ??/\n\tvector<int>edge_is_cycle(e_size);\n\n\tvector<Weight>prev_lens(g.size(), ZERO);\n\n\tfor (auto ce : cycle_edges) {\n\t\tnode_is_cycle[ce.src] = true;\n\t\tprev_lens[ce.dst] = ce.weight;\n\t}\n\tGraph newg(g.size());\n\tconst int compress = cycle_edges[0].src;\n\t/*ティツヲツ?ァツエツ?ヲツ閉ーテ」ツ?ッEdgeテ」ツ?ョテヲツ閉ーテ」ツ??」ツ?妥」ツ?ァティツ可ッテ」ツ??/\n\tvector<Edge>memo(e_size);\n\tfor (int s = 0; s < int(g.size()); ++s) {\n\t\tbool src_is_cycle = node_is_cycle[s];\n\t\tfor (auto e : g[s]) {\n\t\t\tmemo[e.id] = e;\n\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (src_is_cycle) {\n\t\t\t\te.src = compress;\n\t\t\t}\n\t\t\telse if (dst_is_cycle) {\n\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\te.dst = compress;\n\t\t\t}\n\t\t\tnewg[e.src].push_back(e);\n\t\t}\n\t}\n\tauto p = chu_liu(newg, start, e_size);\n\tGraph compress_tree(p.second);\n\tGraph ans_tree(g.size());\n\tfor (auto es : compress_tree) {\n\t\tfor (auto e : es) {\n\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\tif (node_is_cycle[prev_edge.dst]) {\n\t\t\t\tfor (auto cycle_edge : cycle_edges) {\n\t\t\t\t\tif (cycle_edge.dst != prev_edge.dst) {\n\t\t\t\t\t\tans_tree[cycle_edge.src].emplace_back(cycle_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\treturn make_pair(p.first + cycle_len, ans_tree);\n}\n\nld getlen(const vector<ld>&a, const vector<ld>&b,const ld n) {\n\n\tld sum = 0;\n\tfor (int k = 0; k < a.size(); ++k) {\n\t\tsum += pow(a[k]*n - b[k], 2);\n\t}\n\treturn sum;\n}\n\nld getdis(const vector<ld>&a, const vector<ld>&b) {\n\tld amin = -1e8;\n\tld amax = 1e8;\n\tint num = 100;\n\twhile (num--) {\n\t\tld amid1 = (amin * 2 + amax) / 3;\n\t\tld amid2 = (amin + amax * 2) / 3;\n\t\tld ans1 = getlen(a, b, amid1);\n\t\tld ans2 = getlen(a, b, amid2);\n\t\tif (ans1 < ans2) {\n\t\t\tamax = amid2;\n\t\t}\n\t\telse {\n\t\t\tamin = amid1;\n\t\t}\n\t}\n\treturn getlen(a, b, amin);\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld v; cin >> v;\n\t\t\tvecs[i].emplace_back(v);\n\t\t}\n\t}\n\tGraph g(M);\n\tint aid = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i == j)continue;\n\t\t\telse {\n\t\t\t\tld len = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[i].push_back(Edge(i, j, len,aid++));\n\t\t\t}\n\t\t}\n\t}\n\tld ans = 1e18;\n\tfor (int i = 0; i < M; ++i) {\n\t\tvector<ld>v(N);\n\t\tauto p = chu_liu(g, i, M*(M - 1));\n\t\tld plus = getlen(v, vecs[i],0);\n\t\tans = min(ans, p.first+plus);\n\t}\n\tcout <<setprecision(12)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\ntypedef double Weight;\n\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g, const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < int(g.size()); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(), -1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now] != -1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight, Graph> chu_liu(const Graph&g, const int start, const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tWeight total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight, e.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < int(g.size()); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight, reve.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t\tif (cycle_edges.empty()) {\n\t\t\treturn make_pair(total_len, tree);\n\t\t}\n\t}\n\tvector<bool>node_is_cycle(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<int>edge_is_cycle(e_size);\n\n\tvector<Weight>prev_lens(g.size(), ZERO);\n\n\tfor (auto ce : cycle_edges) {\n\t\tnode_is_cycle[ce.src] = true;\n\t\tprev_lens[ce.dst] = ce.weight;\n\t}\n\tGraph newg(g.size());\n\tconst int compress = cycle_edges[0].src;\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\tfor (int s = 0; s < int(g.size()); ++s) {\n\t\tbool src_is_cycle = node_is_cycle[s];\n\t\tfor (auto e : g[s]) {\n\t\t\tmemo[e.id] = e;\n\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (src_is_cycle) {\n\t\t\t\te.src = compress;\n\t\t\t}\n\t\t\telse if (dst_is_cycle) {\n\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\te.dst = compress;\n\t\t\t}\n\t\t\tnewg[e.src].push_back(e);\n\t\t}\n\t}\n\tauto p = chu_liu(newg, start, e_size);\n\tGraph compress_tree(p.second);\n\tGraph ans_tree(g.size());\n\tfor (auto es : compress_tree) {\n\t\tfor (auto e : es) {\n\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\tif (node_is_cycle[prev_edge.dst]) {\n\t\t\t\tfor (auto cycle_edge : cycle_edges) {\n\t\t\t\t\tif (cycle_edge.dst != prev_edge.dst) {\n\t\t\t\t\t\tans_tree[cycle_edge.src].emplace_back(cycle_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\treturn make_pair(p.first + cycle_len, ans_tree);\n}\n\nld getlen(const vector<ld>&a, const vector<ld>&b,const ld n) {\n\n\tld sum = 0;\n\tfor (int k = 0; k < a.size(); ++k) {\n\t\tsum += pow(a[k]*n - b[k], 2);\n\t}\n\treturn sum;\n}\n\nld getdis(const vector<ld>&a, const vector<ld>&b) {\n\tld amin = -1e8;\n\tld amax = 1e8;\n\tint num = 100;\n\twhile (num--) {\n\t\tld amid1 = (amin * 2 + amax) / 3;\n\t\tld amid2 = (amin + amax * 2) / 3;\n\t\tld ans1 = getlen(a, b, amid1);\n\t\tld ans2 = getlen(a, b, amid2);\n\t\tif (ans1 < ans2) {\n\t\t\tamax = amid2;\n\t\t}\n\t\telse {\n\t\t\tamin = amid1;\n\t\t}\n\t}\n\treturn getlen(a, b, amin);\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld v; cin >> v;\n\t\t\tvecs[i].emplace_back(v);\n\t\t}\n\t}\n\tGraph g(M);\n\tint aid = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i == j)continue;\n\t\t\telse {\n\t\t\t\tld len = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[i].push_back(Edge(i, j, len,aid++));\n\t\t\t}\n\t\t}\n\t}\n\tld ans = 1e18;\n\tfor (int i = 0; i < M; ++i) {\n\t\tvector<ld>v(N);\n\t\tauto p = chu_liu(g, i, M*(M - 1));\n\t\tld plus = getlen(v, vecs[i],0);\n\t\tans = min(ans, p.first+plus);\n\t}\n\tcout <<setprecision(12)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (now == i) {\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tld total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t}\n\t\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<Edge>memo(e_size);\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\te.src = compress;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\t\te.dst = compress;\n\t\t\t\t}\n\t\t\t\tnewg[e.src].push_back(e);\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n\n//Without merge technique\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\n\n\ntemplate<typename T, typename E>\nstruct SkewHeap{\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using C = function<bool(T,T)>;\n  G g;\n  H h;\n  C c;\n  T INF;\n  E ei;\n  SkewHeap(G g,H h,C c,T INF,E ei):g(g),h(h),c(c),INF(INF),ei(ei){}\n  \n  struct Node{\n    Node *l,*r;\n    T val;\n    E add;\n    Node(T val,E add):val(val),add(add){l=r=nullptr;}\n  };\n\n  void eval(Node *a){\n    if(a==nullptr) return;\n    if(a->add==ei) return;\n    if(a->l) a->l->add=h(a->l->add,a->add);\n    if(a->r) a->r->add=h(a->r->add,a->add);\n    a->val=g(a->val,a->add);\n    a->add=ei;\n  }\n  \n  T top(Node *a){\n    return a!=nullptr?g(a->val,a->add):INF;\n  }\n\n  T snd(Node *a){\n    eval(a);\n    return a!=nullptr?min(top(a->l),top(a->r)):INF;\n  }\n\n  Node* add(Node *a,E d){\n    if(a!=nullptr) a->add=h(a->add,d);\n    return a;\n  }\n  \n  Node* push(T v){\n    return new Node(v,ei);\n  }\n  \n  Node* meld(Node *a,Node *b){\n    if(a==nullptr) return b;\n    if(b==nullptr) return a;\n    if(c(top(a),top(b))) swap(a,b);\n    eval(a);\n    a->r=meld(a->r,b);\n    swap(a->l,a->r);\n    return a;\n  }\n  \n  Node* pop(Node* a){\n    eval(a);\n    auto res=meld(a->l,a->r);\n    delete a;\n    return res;\n  }\n  \n};\n\n//INSERT ABOVE HERE\ntemplate<typename T>\nstruct Arborescence{\n  typedef pair<T, Int> P;\n  using Heap = SkewHeap<P, T>;\n  \n  struct edge{\n    Int from,to;\n    T cost;\n    edge(){}\n    edge(Int from,Int to,T cost):from(from),to(to),cost(cost){}\n  };\n  \n  Int n;\n  P INF;\n  UnionFind uf;\n  vector<edge> edges;\n  vector<typename Heap::Node*> come;\n  vector<Int> used,from;\n  vector<T> cost;\n  \n  Arborescence(Int n,T INF):n(n),INF(INF,-1),uf(n),come(n,NULL),\n\t\t\t    used(n,0),from(n,-1),cost(n,-1){};\n\n  void add_edge(Int from,Int to,T cost){\n    edges.emplace_back(from,to,cost);\n  }\n\n  void input(Int m,Int offset=0){\n    for(Int i=0;i<m;i++){\n      Int u,v;\n      T c;\n      cin>>u>>v>>c;\n      add_edge(u+offset,v+offset,c);\n    }\n  }\n\n  T build(Int r){\n    typename Heap::G g=[](P a,T b){return P(a.first+b,a.second);};\n    typename Heap::H h=[](T a,T b){return a+b;};\n    typename Heap::C c=[](P a,P b){return a>b;};\n    Heap heap(g,h,c,INF,0);\n  \n    used[r]=2;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge &e=edges[i];\n      come[e.to]=heap.meld(come[e.to],heap.push(P(e.cost,i)));\n    }\n    \n    T res=0;\n    for(Int i=0;i<n;i++){\n      if(used[i]) continue;\n      Int v=i;\n      vector<Int> l;\n      while(used[v]!=2){\n\tused[v]=1;\n\tl.emplace_back(v);\n\tif(!come[v]) return T(-1);\n\tfrom[v]=uf.find(edges[come[v]->val.second].from);\n\tcost[v]=heap.top(come[v]).first;\n\tcome[v]=heap.pop(come[v]);\n\tif(from[v]==v) continue;\n\t\n\tres+=cost[v];\n\tif(used[from[v]]==1){\n\t  Int p=v;\n\t  do{\n\t    if(come[p]!=nullptr) heap.add(come[p],-cost[p]);\n\t    if(p!=v){\n\t      uf.unite(v,p);\n\t      come[v]=heap.meld(come[v],come[p]);\n\t    }\n\t    p=uf.find(from[p]);\n\t  }while(p!=v);\n\t}else{\n\t  v=from[v];\n\t}\n      }\n      for(Int u:l) used[u]=2;\n    }\n    return res;\n  }\n  \n};\n\ndouble v[111][111];\ndouble c[111][111];\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  for(Int i=0;i<m;i++)\n    for(Int j=0;j<n;j++)\n      cin>>v[i][j];\n\n  for(Int i=0;i<m;i++){\n    c[i][i]=0;\n    for(Int j=0;j<n;j++) c[i][i]+=v[i][j]*v[i][j];\n  }\n  for(Int i=0;i<m;i++){\n    for(Int j=0;j<m;j++){\n      if(i==j) continue;\n      if(c[j][j]==0){\n\tc[i][j]=c[i][i];\n\tcontinue;\n      }\n      double r=0;\n      for(Int k=0;k<n;k++)\n\tr+=v[i][k]*v[j][k];\n      r/=c[j][j];\n      c[i][j]=0;\n      for(Int k=0;k<n;k++)\n\tc[i][j]+=(v[i][k]-r*v[j][k])*(v[i][k]-r*v[j][k]);      \n    }    \n  }\n  const double INF = 1e12;\n  Arborescence<double> G(m+1,INF);\n  for(Int i=0;i<m;i++){\n    G.add_edge(m,i,c[i][i]);\n    for(Int j=0;j<m;j++){\n      //cout<<i<<\" \"<<j<<\":\"<<c[i][j]<<endl;\n      if(i==j) continue;\n      G.add_edge(j,i,c[i][j]);\n    }\n  }\n  cout<<fixed<<setprecision(12)<<G.build(m)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint main(){\n  int N, M;\n  while(cin >> N >> M){\n    vector<double> v[100];\n    REP(i, M){\n      v[i] = vector<double>(N);\n      REP(j, N) cin >> v[i][j];\n    }\n    double dot[100][100] = {};\n    REP(i, M) REP(j, M){\n      REP(k, N) dot[i][j] += v[i][k] * v[j][k];\n    }\n    double dist[100][100] = {};\n    REP(i, M) REP(j, M){\n      dist[i][j] = dot[j][j] - (dot[i][j] * dot[i][j]) / dot[i][i];\n    }\n    double ans = 1e16;\n    REP(s, M){\n      typedef pair<double, int> P;\n      priority_queue<P, vector<P>, greater<P> > que;\n      que.push(P(dot[s][s], s));\n      double used[100] = {};\n      double sum = 0;\n      while(!que.empty()){\n        double d = que.top().first;\n        int u = que.top().second;\n        que.pop();\n        if(used[u]) continue;\n        sum += d;\n        used[u] = true;\n        REP(i, M) if(!used[i]){\n          que.push(P(dist[u][i], i));\n        }\n      }\n      ans = min(ans, sum);\n    }\n    printf(\"%.16lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 105\n\nenum Type{\n\tNONE,\n\tSTART,\n\tFINISH,\n};\n\nstruct Heap{\n\tHeap(){\n\t\tleft = NULL;\n\t\tright = NULL;\n\t\tdiff = 0;\n\t\tcost = 0;\n\t\tedge_id = 0;\n\t}\n\n\tHeap(double arg_cost,double arg_edge_id){\n\t\tleft = NULL;\n\t\tright = NULL;\n\t\tdiff = 0;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tHeap *left,*right;\n\tint edge_id;\n\tdouble cost,diff;\n};\n\nstruct Edge{\n\tEdge(int arg_from,int arg_to,double arg_cost){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint from,to;\n\tdouble cost;\n};\n\nint V,E;\nint boss[NUM];\nint table_index;\nint FROM[NUM];\ndouble from_cost[NUM];\nvector<Edge> edge;\nHeap heap_table[10005];\nHeap* HEAP[NUM];\nType type[NUM];\n\n\nvoid lazy(Heap* A){\n\n\tif(A->left){\n\t\tA->left->diff += A->diff;\n\t}\n\tif(A->right){\n\t\tA->right->diff += A->diff;\n\t}\n\tA->cost += A->diff;\n\tA->diff = 0;\n}\n\n\nHeap* meld(Heap* A,Heap* B){\n\n\tif(!A){\n\t\treturn B;\n\t}\n\tif(!B){\n\t\treturn A;\n\t}\n\n\tif((A->cost+A->diff) > (B->cost+B->diff)){\n\t\tswap(A,B);\n\t}\n\n\tlazy(A);\n\n\tA->right = meld(A->right,B);\n\tswap(A->left,A->right);\n\n\treturn A;\n}\n\nHeap* pop(Heap *A){\n\tlazy(A);\n\treturn meld(A->left,A->right);\n}\n\n\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tboss[boss_x] = boss_y;\n}\n\nvoid init(){\n\n\tfor(int i = 0; i < V; i++){\n\t\tboss[i] = i;\n\t}\n}\n\ndouble MCA(int root){\n\n\tinit();\n\ttable_index = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\ttype[i] = NONE;\n\t\tHEAP[i] = NULL;\n\t}\n\ttype[root] = FINISH;\n\n\tfor(int i = 0; i < edge.size(); i++){\n\n\t\theap_table[table_index] = Heap(edge[i].cost,i);\n\t\tHEAP[edge[i].to] = meld(HEAP[edge[i].to],&heap_table[table_index++]);\n\t}\n\n\tdouble ret = 0;\n\n\tfor(int start = 0; start < V; start++){\n\n\t\tif(type[start] != NONE)continue;\n\n\t\tint current = start;\n\t\tvector<int> USED;\n\n\t\twhile(type[current] != FINISH){\n\n\t\t\ttype[current] = START;\n\t\t\tUSED.push_back(current);\n\n\t\t\tif(!HEAP[current]){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tFROM[current] = get_boss(edge[HEAP[current]->edge_id].from);\n\n\t\t\tfrom_cost[current] = HEAP[current]->cost+HEAP[current]->diff;\n\n\t\t\tHEAP[current] = pop(HEAP[current]);\n\n\t\t\tif(FROM[current] == current)continue;\n\n\t\t\tret += from_cost[current];\n\n\t\t\tif(type[FROM[current]] == START){\n\n\t\t\t\tint tmp = current;\n\n\t\t\t\tdo{\n\t\t\t\t\tif(HEAP[tmp]){\n\t\t\t\t\t\tHEAP[tmp]->diff -= from_cost[tmp];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(tmp != current){\n\t\t\t\t\t\tunite(tmp,current);\n\t\t\t\t\t\tHEAP[current] = meld(HEAP[current],HEAP[tmp]);\n\t\t\t\t\t}\n\n\t\t\t\t\ttmp = get_boss(FROM[tmp]);\n\n\t\t\t\t}while(tmp != current);\n\n\n\t\t\t}else{\n\t\t\t\tcurrent = FROM[current];\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < USED.size(); k++){\n\t\t\ttype[USED[k]] = FINISH;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tint N,M;\n\n\tscanf(\"%d %d\",&N,&M);\n\tV = M+1;\n\n\tdouble table[NUM][NUM];\n\n\tfor(int k = 0; k < N; k++){\n\t\ttable[0][k] = 0;\n\t}\n\n\tfor(int i = 1; i <= M; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tscanf(\"%lf\",&table[i][k]);\n\t\t}\n\t}\n\n\tdouble naiseki,norm,r,cost;\n\n\tfor(int from = 0; from <= M; from++){\n\t\tfor(int to = 1; to <= M; to++){\n\t\t\tif(to == from)continue;\n\n\t\t\tnaiseki = 0;\n\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tnaiseki += table[from][i]*table[to][i];\n\t\t\t}\n\n\t\t\tnorm = 0;\n\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tnorm += table[from][i]*table[from][i];\n\t\t\t}\n\n\t\t\tif(fabs(norm) < EPS){ //入力には0ベクトルもある\n\n\t\t\t\tcost = 0;\n\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tcost += table[to][i]*table[to][i];\n\t\t\t\t}\n\t\t\t\tedge.push_back(Edge(from,to,cost));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tr = naiseki/norm;\n\n\t\t\tcost = 0;\n\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tcost += (table[to][i]-r*table[from][i])*(table[to][i]-r*table[from][i]);\n\t\t\t}\n\n\t\t\tedge.push_back(Edge(from,to,cost));\n\t\t}\n\t}\n\n\tprintf(\"%.10lf\\n\",MCA(0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -100;\n\tld amax = 100;\n\tint n = 50;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<Edge>prev_es(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tprev_es[e.dst] = e;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (i == start)continue;\n\t\t\tint now = i;\n\t\t\tvector<Edge>cycles;\n\t\t\tvector<int>comes(g.size(),-1);\n\t\t\tcomes[now] = 0;\n\t\t\tint num = 1;\n\t\t\twhile (1) {\n\t\t\t\tcycles.emplace_back(prev_es[now]);\n\t\t\t\tnow = prev_es[now].src;\n\t\t\t\tif (comes[now]!=-1) {\n\t\t\t\t\tcycles = vector < Edge>(cycles.begin() + comes[now], cycles.end());\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t\telse if (now == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomes[now] = num++;\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\tvector<Edge>cycle_edges;\n\tld total_len = 0;\n\t{\n\t\tGraph tree(g.size());\n\t\t{\n\t\t\tGraph revg(g.size());\n\n\n\t\t\tfor (auto es : g) {\n\t\t\t\tfor (auto e : es) {\n\t\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\t\tif (node == start)continue;\n\t\t\t\telse {\n\t\t\t\t\tWeight amin = INF;\n\t\t\t\t\tEdge min_edge;\n\t\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (amin < INF) {\n\t\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcycle_edges = getcycle::get_cycle(tree, start);\n\t}\n\t\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<Edge>memo(e_size);\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\te.src = compress;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\t\te.dst = compress;\n\t\t\t\t}\n\t\t\t\tnewg[e.src].push_back(e);\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight w;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), w(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.w != f.w ? e.w > f.w : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n\nvoid backward_traverse(int v, int s, int r,\n  Graph &gg,\n  vector<int> &no, vector< vector<int> > &comp,\n  vector<int> &prev, vector< vector<int> > &next, vector<Weight> &mcost,\n  vector<int> &mark, Weight &cost, bool &found) {\n  const int n = gg.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n\n    for (int k = 0; k < comp[s].size(); ++k) {\n      int j = comp[s][k];\n      if (j != r)\n        for (int l = 0; l < gg[j].size(); ++l)\n          if (no[ gg[j][l].src ] != s)\n            gg[j][l].w -= mcost[ temp[j] ];\n    }\n  }\n  mark[v] = true;\n  for (int k = 0; k < next[v].size(); ++k) {\n    int i = next[v][k];\n    if (no[i] != no[v] && prev[ no[i] ] == v)\n      if (!mark[ no[i] ] || i == s)\n        backward_traverse(i, s, r, gg,\n            no, comp, prev, next, mcost, mark, cost, found);\n  }\n}\nWeight minimum_spanning_arborescence(int r, Graph &g) {\n  const int n = g.size();\n  Graph gg(n);\n  for (int i = 0; i < g.size(); ++i)\n    for (int j = 0; j < g[i].size(); ++j)\n      gg[ g[i][j].dst ].push_back( g[i][j] );\n\n  vector<int> no(n);\n  vector< vector<int> > comp(n);\n  for (int i = 0; i < n; ++i) {\n    no[i] = i;\n    comp[i].push_back(i);\n  }\n  Weight cost = 0;\n  while (1) {\n    vector<int> prev(n, -1);\n    vector<Weight> mcost(n, inf);\n\n    for (int j = 0; j < n; ++j) {\n      if (j == r) continue;\n      for (int k = 0; k < gg[j].size(); ++k) {\n        int i = gg[j][k].src;\n        if (no[i] != no[j]) {\n          if (gg[j][k].w < mcost[ no[j] ]) {\n            mcost[ no[j] ] = gg[j][k].w;\n            prev[ no[j] ] = no[i];\n          }\n        }\n      }\n    }\n    vector< vector<int> > next(n);\n    for (int i = 0; i < n; ++i)\n      if (prev[i] >= 0)\n        next[ prev[i] ].push_back( i );\n\n    bool stop = true;\n    vector<int> mark(n);\n    for (int i = 0; i < n; ++i) {\n      if (i == r || mark[i] || comp[i].size() == 0) continue;\n      bool found = false;\n      backward_traverse(i, i, r, gg,\n          no, comp, prev, next, mcost, mark, cost, found);\n      if (found) stop = false;\n    }\n    if (stop) {\n      for (int i = 0; i < n; ++i)\n        if (prev[i] >= 0)\n          cost += mcost[i];\n      return cost;\n    }\n  }\n}\n\ndouble f(const vector<double>& v) {\n    double res = 0;\n    REP(i, v.size()) res += v[i]*v[i];\n    return res;\n}\n\nvector<double> sub(const vector<double>& a, const vector<double>& b) {\n    vector<double> res(a.size());\n    REP(i, a.size()) res[i] = a[i] - b[i];\n    return res;\n}\nvector<double> mul(const vector<double>& v, const double r) {\n    vector<double> res(v.size());\n    REP(i, v.size()) {\n        res[i] = v[i]*r;\n    }\n    return res;\n}\n\n// |b - a * hoge|^2 -> min\ndouble getW(const vector<double>& a, const vector<double>& b) {\n    double l = -inf, r = inf;\n    REP(t, 100) {\n        double m1 = (2*l+r)/3, m2 = (l+2*r)/3;\n        if ( f( sub(b, mul(a, m1)) ) < f( sub(b, mul(a, m2)) ) ) {\n            r = m2;\n        }\n        else {\n            l = m1;\n        }\n    }\n    return f( sub(b, mul(a, (l + r)/2)) );\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n, m; cin >> n >> m;\n    vector< vector<double> > v(m, vector<double>(n)); cin >> v;\n    int s = m;\n    Graph G(s+1);\n    REP(i, m) REP(j, m) {\n        G[i].pb( Edge(i, j, getW(v[i], v[j])) );\n    }\n    REP(i, m) {\n        G[s].pb( Edge(s, i, f(v[i])) );\n    }\n    cout << fixed << setprecision(10);\n    cout << minimum_spanning_arborescence(s, G) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stack>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int V_MAX=101;\nconst double INF=1e77;\n\nint ord[V_MAX],low[V_MAX];\nvoid dfs(int u,int &c,stack<int> &S,bool *inS,const vector<int> *G,int &scc_id,int *scc){\n\tord[u]=low[u]=c++;\n\tS.push(u);\n\tinS[u]=true;\n\n\trep(i,G[u].size()){\n\t\tint v=G[u][i];\n\t\tif(ord[v]==-1){\n\t\t\tdfs(v,c,S,inS,G,scc_id,scc);\n\t\t\tlow[u]=min(low[u],low[v]);\n\t\t}\n\t\telse if(inS[v]){\n\t\t\tlow[u]=min(low[u],ord[v]);\n\t\t}\n\t}\n\n\tif(ord[u]==low[u]){\n\t\tint v;\n\t\tdo{\n\t\t\tv=S.top(); S.pop();\n\t\t\tinS[v]=false;\n\t\t\tscc[v]=scc_id;\n\t\t}while(v!=u);\n\t\tscc_id++;\n\t}\n}\n\nint SCC(int n,const vector<int> *G,int *scc){\n\tstatic bool inS[V_MAX];\n\trep(u,n){\n\t\tord[u]=-1;\n\t\tinS[u]=false;\n\t}\n\tstack<int> S;\n\tint c=0,n_scc=0;\n\trep(u,n) if(ord[u]==-1) dfs(u,c,S,inS,G,n_scc,scc);\n\treturn n_scc;\n}\n\ntemplate<class T>\nstruct edge{\n\tint v;\n\tT cost;\n};\n\ntemplate<class T>\nT minimum_arborescence(int n,const vector< edge<T> > *G_in,int root){\n\tstatic vector< edge<T> > buf[V_MAX],buf2[V_MAX],*G=buf,*G2=buf2;\n\trep(u,n) G[u].clear();\n\trep(u,n) rep(i,G_in[u].size()) {\n\t\tconst edge<T> &e=G_in[u][i];\n\t\tif(u!=e.v) G[u].push_back(e);\n\t}\n\n\tT ans=0;\n\twhile(1){\n\t\tstatic int from[V_MAX];\n\t\tstatic T mini[V_MAX];\n\t\trep(u,n) from[u]=-1;\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tconst edge<T> &e=G[u][i];\n\t\t\tif(from[e.v]==-1 || mini[e.v]>e.cost){\n\t\t\t\tfrom[e.v]=u;\n\t\t\t\tmini[e.v]=e.cost;\n\t\t\t}\n\t\t}\n\n\t\trep(v,n) if(v!=root) {\n\t\t\tans+=mini[v];\n\t\t\tif(from[v]==-1) return INF;\n\t\t}\n\n\t\tstatic vector<int> H[V_MAX];\n\t\trep(v,n) H[v].clear();\n\t\trep(v,n) if(v!=root) H[from[v]].push_back(v);\n\n\t\tstatic int scc[V_MAX];\n\t\tint N=SCC(n,H,scc);\n\t\tif(n==N) return ans;\n\n\t\trep(i,N) G2[i].clear();\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tconst edge<T> &e=G[u][i];\n\t\t\tif(scc[u]!=scc[e.v]){\n\t\t\t\tG2[scc[u]].push_back((edge<T>){scc[e.v],e.cost-mini[e.v]});\n\t\t\t}\n\t\t}\n\t\tswap(G,G2);\n\t\tn=N;\n\t\troot=scc[root];\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&m,&n);\n\tdouble vec[101][100];\n\trep(i,n) rep(j,m) scanf(\"%lf\",vec[i]+j);\n\trep(j,m) vec[n][j]=0;\n\n\tvector< edge<double> > G[V_MAX];\n\trep(v,n){\n\t\tdouble cost=0;\n\t\trep(k,m) cost+=vec[v][k]*vec[v][k];\n\t\tG[n].push_back((edge<double>){v,cost});\n\t}\n\trep(u,n) rep(v,n+1) {\n\t\tdouble r1=0,r2=0;\n\t\trep(k,m){\n\t\t\tr1+=vec[u][k]*vec[v][k];\n\t\t\tr2+=vec[u][k]*vec[u][k];\n\t\t}\n\t\tdouble r=r1/r2;\n\n\t\tdouble cost=0;\n\t\trep(k,m) cost+=(vec[v][k]-r*vec[u][k])*(vec[v][k]-r*vec[u][k]);\n\t\tG[u].push_back((edge<double>){v,cost});\n\t\tprintf(\"%d -> %d : %f\\n\",u,v,cost);\n\t}\n\n\tprintf(\"%.9f\",minimum_arborescence(n+1,G,n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\tGraph tree(g.size());\n\tld total_len = 0;\n\t{\n\t\tGraph revg(g.size());\n\n\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t}\n\t\t}\n\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\tif (node == start)continue;\n\t\t\telse {\n\t\t\t\tWeight amin = INF;\n\t\t\t\tEdge min_edge;\n\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amin < INF) {\n\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\t\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\te.src = compress;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\te.dst = compress;\n\t\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\t}\n\t\t\t\tnewg[compress].push_back(e);\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int root,const int e_size) {\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\tGraph tree(g.size());\n\tld total_len = 0;\n\t{\n\t\tGraph revg(g.size());\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t}\n\t\t}\n\t\tvector<Weight>mins(g.size());\n\t\tvector<Edge>min_edges(g.size());\n\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\tif (node == root)continue;\n\t\t\telse {\n\t\t\t\tWeight amin = INF;\n\t\t\t\tEdge min_edge;\n\t\t\t\tfor (auto e : g[node]) {\n\t\t\t\t\tif (mins[e.dst] > e.weight) {\n\t\t\t\t\t\tamin = e.weight;\n\t\t\t\t\t\tmin_edge = Edge(e.src, e.dst, e.weight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amin < INF) {\n\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < mins.size(); ++i) {\n\t\t\tif (mins[i] < INF) {\n\t\t\t\ttotal_len += min_edges[i].weight;\n\t\t\t\ttree[min_edges[i].src].emplace_back(min_edges[i]);\n\t\t\t}\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, root));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prev_lens[e.dst], e.id));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, root, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\tGraph tree(g.size());\n\tld total_len = 0;\n\t{\n\t\tGraph revg(g.size());\n\n\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t}\n\t\t}\n\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\tif (node == start)continue;\n\t\t\telse {\n\t\t\t\tWeight amin = INF;\n\t\t\t\tEdge min_edge;\n\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amin < INF) {\n\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\t\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\te.src = compress;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\te.weight -= prev_lens[e.dst];\n\t\t\t\t\te.dst = compress;\n\t\t\t\t}\n\t\t\t\tnewg[compress].push_back(e);\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n//#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\nusing namespace std;\n#define peter cout<<\"i am peter\"<<endl\ntypedef long long ll;\n\nconst double eps = 1e-9;\nint sgn(double x){\n    if(abs(x) < eps) return 0;\n    else return x > 0 ? 1 : -1;\n}\n\n#define N 200\nint n, m;\ndouble v[N][N], dis[N];\nbool vis[N];\n\ndouble getdis(int a, int b){\n    double l = -1e9, r = 1e9, mid1, mid2;\n    int tt = 100;\n    while(r - l > 1e-12 && tt--){\n        mid1 = (l + r) * 0.5;\n        mid2 = (mid1 + r) * 0.5;\n        double dis1 = 0.0, dis2 = 0.0;\n        for(int i = 1; i <= n; i++){\n            dis1 += (v[a][i] - mid1 * v[b][i]) * (v[a][i] - mid1 * v[b][i]);\n            dis2 += (v[a][i] - mid2 * v[b][i]) * (v[a][i] - mid2 * v[b][i]);\n        }\n        if(sgn(dis1 - dis2) <= 0) r = mid2;\n        else l = mid1;\n    }\n    double dis = 0.0;\n    for(int i = 1; i <= n; i++){\n        dis += (v[a][i] - l * v[b][i]) * (v[a][i] - l * v[b][i]);\n    }\n    return dis;\n}\n\ndouble prim(){\n    for(int i = 1; i <= m; i++){\n        dis[i] = 0.0;\n        for(int j = 1; j <= n; j++) dis[i] += v[i][j] * v[i][j];\n        vis[i] = 0;\n    }\n    double res = 0.0;\n    for(int ii = 1; ii <= m; ii++){\n        double mini = 1e15;\n        int w = 1;\n        for(int i = 1; i <= m; i++){\n            if(vis[i] == 1) continue;\n            if(sgn(dis[i] - mini) < 0){\n                mini = dis[i];\n                w = i;\n            }\n        }\n        res += dis[w];\n        vis[w] = 1;\n        for(int i = 1; i <= m; i++){\n            if(vis[i] == 1) continue;\n            dis[i] = min(dis[i], getdis(i, w));\n        }\n    }\n    return res;\n}\n\nint main(){\n    //freopen(\"/Users/peteryuanpan/data.txt\",\"r\",stdin);\n    while(~scanf(\"%d%d\",&n,&m)){\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                scanf(\"%lf\", &v[i][j]);\n            }\n        }\n        printf(\"%.10f\\n\", prim());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<double, int> pii;\nint N, M;\ndouble vec[101][101];\ndouble dist[101][101];\nbool seen[101];\n\ndouble ternary_search(int p, int q) {\n    double lo = -100000, hi = 100000;\n    for (int i=0; i<100; ++i) {\n        double m1 = (2*lo + hi)/3, m2 = (lo + 2*hi)/3;\n        // calc norm(vec[p] - r*vec[q])\n        double n1 = 0.0, n2 = 0.0;\n        for (int j=0; j<N; ++j) {\n            n1 += (vec[p][j] - m1 * vec[q][j]) * (vec[p][j] - m1 * vec[q][j]);\n            n2 += (vec[p][j] - m2 * vec[q][j]) * (vec[p][j] - m2 * vec[q][j]);\n        }\n        if (n1 > n2) lo = m1;\n        else hi = m2;\n    }\n    double ret = 0;\n    for (int i=0; i<N; ++i)\n        ret += (vec[p][i] - lo * vec[q][i]) * (vec[p][i] - lo * vec[q][i]);\n    return ret;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i=0; i<M; ++i)\n        for (int j=0; j<N; ++j)\n            scanf(\"%lf\", &vec[i][j]);\n    for (int j=0; j<N; ++j)\n        vec[M][j] = 0.0;\n    M++;\n\n    for (int i=0; i<M; ++i)\n        for (int j=0; j<M; ++j) {\n            if (i == j) continue;\n            dist[j][i] = ternary_search(i, j);\n        }\n\n    memset(seen, false, sizeof(seen));\n    priority_queue<pii, vector<pii>, greater<pii> > q; q.push(make_pair(0, M-1));\n    double ans = 0;\n    while (!q.empty()) {\n        pii p = q.top(); q.pop();\n        int v = p.second;\n        if (seen[v]) continue;\n        seen[v] = true;\n        //printf(\"use %d %f\\n\", v, p.first);\n        ans += p.first;\n        for (int i = 0; i < M; ++i) {\n            if (seen[i] || i == v) continue;\n            printf(\"add %d %d %lf\\n\", v, i, dist[v][i]);\n            q.push(make_pair(dist[v][i], i));\n        }\n    }\n\n    printf(\"%.12f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N (1<<19)\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,int> P;\n\nint n, m;\ndouble v[100][100];\nint saw[101];\nint com[101];\nbool dead[101];\nvector<P> e[101];\nvector<P> rev[101];\nvector<P> ee[101];\nP ree[101];\n\nint dfs_liu(int v, int o){\n    saw[v] = o;\n    rep(i,ee[v].size()){\n        P p = ee[v][i];\n        if(saw[p.second] >= 0 && saw[p.second] < o) continue;\n        if(saw[p.second] == o){\n            com[p.second] = p.second;\n            while(v != p.second){\n                com[v] = p.second;\n                v = ree[v].second;\n            }\n            return p.second;\n        }\n        int rec = dfs_liu(p.second,o);\n        if(rec != -1) return rec;\n    }\n    return -1;\n}\n\ndouble chu_liu(){\n    double ret = 0.0;\n    memset(dead,0,sizeof(dead));\n    int debug = 0;\n    while(true){\n        debug++;\n        bool end = true;\n        rep(i,n){\n            ee[i].clear();\n            rev[i].clear();\n        }\n        rep(i,n) rep(j,e[i].size()) rev[e[i][j].second].push_back(P(e[i][j].first,i));\n        rep(i,n){\n            if(dead[i])  continue;\n            sort(rev[i].begin(),rev[i].end());\n        }\n        //cout << \"Ho\" << endl;\n        memset(saw,-1,sizeof(saw));\n        memset(com,-1,sizeof(com));\n        rep(i,n){\n            if(dead[i]) continue;\n            if(rev[i].size() == 0) continue;\n            ee[rev[i][0].second].push_back(P(rev[i][0].first,i));\n            ree[i] = rev[i][0];\n        }\n        rep(i,n){\n            rep(j,ee[i].size()){\n                //cout << i << \" \" << ee[i][j].second << \" \" << ee[i][j].first << endl;\n            }\n        }\n        //cout << \"o\" << endl;\n        int d;\n        rep(i,n){\n            if(dead[i]) continue;\n            if(saw[i] >= 0) continue;\n            d = dfs_liu(i,i);\n            if(d >= 0){\n                end = false;\n                break;\n            }\n        }\n        rep(i,n) //cout << saw[i] << \" \";\n        //cout << endl;\n        rep(i,n) //cout << com[i] << \" \";\n        //cout << endl;\n        //cout << d << endl;\n        if(debug == 5) break;\n        if(end) break;\n        rep(i,n){\n            if(dead[i]) continue;\n            rep(j,e[i].size()){\n                if(com[i] == d && com[e[i][j].second] == d){\n                    e[i][j].first = 100.0;\n                    continue;\n                }\n                if(com[e[i][j].second] == d){\n                    e[i][j].first -= ree[e[i][j].second].first;\n                    e[i][j].second = d;\n                    continue;\n                }\n                if(com[i] == d){\n                    if(i != d) e[d].push_back(e[i][j]);\n                }\n            }\n        }\n        rep(i,n){\n            if(dead[i]) continue;\n            if(com[i] == d){\n                ret += ree[i].first;\n                if(i != d) dead[i] = true;\n            }\n        }\n    }\n    rep(i,n){\n        if(dead[i]) continue;\n        ret += ree[i].first;\n    }\n    return ret;\n}\n\nint main(){\n    cin >> m >> n;\n    rep(i,n) rep(j,m) cin >> v[i][j];\n    rep(i,n){\n        double d = 0.0;\n        rep(j,m) d += v[i][j]*v[i][j];\n        if(d == 0.0) continue;\n        e[n].push_back(P(d,i));\n        rev[i].push_back(P(d,n));\n        rep(j,n){\n            if(i == j) continue;\n            double ss = -10000000000.0, ee = 100000000000.0, ms, me;\n            double vs, ve;\n            rep(u,200){\n                ms = (ss*2+ee)/3;\n                me = (ss+ee*2)/3;\n                vs = 0.0; ve = 0.0;\n                rep(k,m){\n                    vs += pow(v[j][k]+ms*v[i][k],2);\n                    ve += pow(v[j][k]+me*v[i][k],2);\n                }\n                if(vs > ve) ss = ms;\n                else ee = me;\n            }\n            e[i].push_back(P(vs,j));\n            rev[i].push_back(P(vs,i));\n        }\n    }\n    n++;\n    rep(i,n){\n        rep(j,e[i].size()){\n            //cout << i << \" \" << e[i][j].second << \" \" << e[i][j].first << endl;\n        }\n    }\n    double ans = chu_liu();\n    printf(\"%.9f\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\ndouble v[100][100];\ndouble len[100];\ndouble naiseki[100][100];\n\ntypedef vector<vector<double> > matrix;\ntypedef double weight;\nconst double inf = 1e10;\n\nvoid backward_traverse(int v, int s, int r, matrix &g,\n\t\t       vector<int> &no, vector< vector<int> > &comp,\n\t\t       vector<int> &prev, vector<weight> &mcost,\n\t\t       vector<int> &mark, weight &cost, bool &found) {\n  const int n = g.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n    for (int j = 0; j < n; ++j)\n      if (j != r && no[j] == s)\n        for (int i = 0; i < n; ++i)\n          if (no[i] != s && g[i][j] < inf)\n            g[i][j] -= mcost[ temp[j] ];\n  }\n  mark[v] = true;\n  for (int i = 0; i < n; ++i)\n    if (no[i] != no[v] && prev[ no[i] ] == v)\n      if (!mark[ no[i] ] || i == s)\n        backward_traverse(i, s, r, g,\n\t\t\t  no, comp, prev, mcost, mark, cost, found);\n}\n\nweight minimum_spanning_arborescence(int r, matrix &g) {\n  const int n = g.size();\n\n  vector<int> no(n);\n  vector< vector<int> > comp(n);\n  for (int i = 0; i < n; ++i) {\n    no[i] = i;\n    comp[i].push_back(i);\n  }\n  weight cost = 0;\n  while (1) {\n    vector<int> prev(n, -1);\n    vector<weight> mcost(n, inf);\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        if (j == r) continue;\n        if (no[i] != no[j] && g[i][j] < inf) {\n          if (g[i][j] < mcost[ no[j] ]) {\n            mcost[ no[j] ] = g[i][j];\n            prev[ no[j] ] = no[i];\n          }\n        }\n      }\n    }\n    bool stop = true;\n    vector<int> mark(n);\n    for (int i = 0; i < n; ++i) {\n      if (i == r || mark[i] || comp[i].size() == 0) continue;\n      bool found = false;\n      backward_traverse(i, i, r, g,\n\t\t\tno, comp, prev, mcost, mark, cost, found);\n      if (found) stop = false;\n    }\n    if (stop) {\n      for (int i = 0; i < n; ++i){\n        if (prev[i] >= 0){\n          cost += mcost[i];\n\t}\n      }\n      return cost;\n    }\n  }\n}\n\nint main(){\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n\n  REP(i,m) REP(j,n) scanf(\"%lf\", &v[i][j]);\n  REP(i,m){\n    len[i] = 0.0;\n    REP(j,n) len[i] += v[i][j] * v[i][j];\n  }\n\n  vector<vector<double> > g(m + 1, vector<double>(m + 1));\n\n  REP(i,m) REP(j,m){\n    naiseki[i][j] = 0.0;\n    REP(k,n) naiseki[i][j] += v[i][k] * v[j][k];\n    naiseki[i][j] *= naiseki[i][j];\n\n    g[i][j] = len[j] - naiseki[j][i] / len[i];\n  }\n\n  REP(i,m){\n    g[m][i] = len[i];\n    g[i][m] = inf;\n  }\n  g[m][m] = inf;\n\n  // REP(i,m+1){ REP(j,m+1) printf(\"%.1f \", g[i][j]); puts(\"\"); }\n\n  double ans = minimum_spanning_arborescence(m, g);\n\n  printf(\"%.8f\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef ld Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid backward_traverse(int v, int s, int r,\n\tGraph &gg,\n\tvector<int> &no, vector< vector<int> > &comp,\n\tvector<int> &prev, vector< vector<int> > &next, vector<Weight> &mcost,\n\tvector<int> &mark, Weight &cost, bool &found) {\n\tconst int n = gg.size();\n\tif (mark[v]) {\n\t\tvector<int> temp = no;\n\t\tfound = true;\n\t\tdo {\n\t\t\tcost += mcost[v];\n\t\t\tv = prev[v];\n\t\t\tif (v != s) {\n\t\t\t\twhile (comp[v].size() > 0) {\n\t\t\t\t\tno[comp[v].back()] = s;\n\t\t\t\t\tcomp[s].push_back(comp[v].back());\n\t\t\t\t\tcomp[v].pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t} while (v != s);\n\n\t\tfor (int k = 0; k < comp[s].size(); ++k) {\n\t\t\tint j = comp[s][k];\n\t\t\tif (j != r)\n\t\t\t\tfor (int l = 0; l < gg[j].size(); ++l)\n\t\t\t\t\tif (no[gg[j][l].src] != s)\n\t\t\t\t\t\tgg[j][l].weight -= mcost[temp[j]];\n\t\t}\n\t}\n\tmark[v] = true;\n\tfor (int k = 0; k < next[v].size(); ++k) {\n\t\tint i = next[v][k];\n\t\tif (no[i] != no[v] && prev[no[i]] == v)\n\t\t\tif (!mark[no[i]] || i == s)\n\t\t\t\tbackward_traverse(i, s, r, gg,\n\t\t\t\t\tno, comp, prev, next, mcost, mark, cost, found);\n\t}\n}\n\nWeight minimum_spanning_arborescence(int r, Graph &g) {\n\tconst int n = g.size();\n\tGraph gg(n);\n\tfor (int i = 0; i < g.size(); ++i)\n\t\tfor (int j = 0; j < g[i].size(); ++j)\n\t\t\tgg[g[i][j].dst].push_back(g[i][j]);\n\n\tvector<int> no(n);\n\tvector< vector<int> > comp(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tno[i] = i;\n\t\tcomp[i].push_back(i);\n\t}\n\tWeight cost = 0;\n\twhile (1) {\n\t\tvector<int> prev(n, -1);\n\t\tvector<Weight> mcost(n, INF);\n\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (j == r) continue;\n\t\t\tfor (int k = 0; k < gg[j].size(); ++k) {\n\t\t\t\tint i = gg[j][k].src;\n\t\t\t\tif (no[i] != no[j]) {\n\t\t\t\t\tif (gg[j][k].weight < mcost[no[j]]) {\n\t\t\t\t\t\tmcost[no[j]] = gg[j][k].weight;\n\t\t\t\t\t\tprev[no[j]] = no[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector< vector<int> > next(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (prev[i] >= 0)\n\t\t\t\tnext[prev[i]].push_back(i);\n\n\t\tbool stop = true;\n\t\tvector<int> mark(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == r || mark[i] || comp[i].size() == 0) continue;\n\t\t\tbool found = false;\n\t\t\tbackward_traverse(i, i, r, gg,\n\t\t\t\tno, comp, prev, next, mcost, mark, cost, found);\n\t\t\tif (found) stop = false;\n\t\t}\n\t\tif (stop) {\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tif (prev[i] >= 0)\n\t\t\t\t\tcost += mcost[i];\n\t\t\treturn cost;\n\t\t}\n\t}\n}\n\nint n, m;\nld calc(vector<ld> v1, vector<ld> v2)\n{\n\tld lb = -INF, ub = INF;\n\tREP(rp, 100)\n\t{\n\t\tld d1 = (lb * 2 + ub) / 3, d2 = (lb + ub * 2) / 3;\n\t\tld sum1 = 0, sum2 = 0;\n\t\tREP(i, n)\n\t\t{\n\t\t\tsum1 += pow(v2[i] - d1 * v1[i], 2);\n\t\t\tsum2 += pow(v2[i] - d2 * v1[i], 2);\n\t\t}\n\t\tif (sum1 < sum2) ub = d2;\n\t\telse lb = d1;\n\t}\n\tld res = 0;\n\tREP(i, n)\n\t{\n\t\tres += pow(v2[i] - lb * v1[i], 2);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tcin >> n >> m;\n\tvector<vector<ld>> v(m + 1, vector<ld>(n));\n\tREP(i, m)REP(j, n) cin >> v[i + 1][j];\n\tGraph g(m + 1);\n\tREP(i, m + 1)REP(j, m + 1)\n\t{\n\t\tif (i == j) continue;\n\t\tg[i].push_back(Edge{ i,j,calc(v[i], v[j]) });\n\t}\n\tcout << minimum_spanning_arborescence(0, g) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\npair<Weight,Graph> chu_liu(const Graph&g, const int start) {\n\tGraph revg(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\t//vector<Edge>memo(g.size()*g.size());\n\tfor (auto es : g) {\n\t\tfor (auto e : es) {\n\t\t\t//memo[e.id] = e;\n\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t}\n\t}\n\tGraph tree(g.size());\n\tld total_len = 0;\n\tfor (int node = 0; node < g.size(); ++node) {\n\t\tif (node == start)continue;\n\t\telse {\n\t\t\tWeight amin = INF;\n\t\t\tEdge min_edge;\n\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\tmin_edge = Edge(reve.dst,reve.src, reve.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (amin < INF) {\n\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t}\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(g.size()*g.size());\n\n\t\tvector<pair<int,Weight>>prevs(g.size(), make_pair(-1,ZERO));\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tnode_is_cycle[ce.dst] = true;\n\t\t\tprevs[ce.dst] = make_pair(ce.src, ce.weight);\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prevs[e.dst].second, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start);\n\t\tGraph compress_tree(g.size());\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tEdge prev_edge(e);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tld fin_len = p.first + cycle_len;\n\t\treturn make_pair(fin_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start);\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <string>\n#include <math.h>\nusing namespace std;\n\nstruct edge{\n\tint d,k,od,ok;\n\tdouble data;\n}e[100000];\nint pre[1000],id[1000],vis[1000];\ndouble in[1000],tmp;\ndouble a[120][120];\ndouble d[120];\nint n,m,nn,root;\ndouble ans2;\n\ndouble cal2(int p,int q,double k){\n\tfor (int i=1;i<=m;++i) d[i]=a[p][i]-a[q][i]*k;\n\tdouble tmp = 0;\n\tfor (int i=1;i<=m;++i) tmp+=d[i]*d[i];\n\treturn tmp;\n}\n\ndouble cal(int p,int q){\n\tdouble l = -10000,r = 10000,mid1,mid2;\n\twhile (r-l>1e-6){\n\t\tdouble tmp = (r-l)/3;\n\t\tmid1=l+tmp;\n\t\tmid2=mid1+tmp;\n\t\tif (cal2(p,q,mid1)<cal2(p,q,mid2)) r=mid2;\n\t\telse l=mid1;\n\t}\n//\tprintf(\"%d %d %.2f\\n\",p,q,cal2(p,q,mid1));\n\treturn cal2(p,q,mid1);\n}\n\nvoid addedge(int p,int q,double k,int od,int ok){\n\te[++nn].k=q;\n\te[nn].d=p;\n\te[nn].od=od;\n\te[nn].ok=ok;\n\te[nn].data=k;\n}\n\ndouble work(int root){\n\tint sum=n;\n\tans2=1e50;\n\tint oldroot=root;\n\tdouble res=0;\n\twhile (1){\n\t\tfor (int i=1;i<=sum;++i) in[i]=1e50;\n\t\tfor (int i=1;i<=nn;++i){\n\t\t\tint u=e[i].d,v=e[i].k;\n\t\t\tif (e[i].data<in[v] && u!=v){\n\t\t\t\tif (e[i].od == oldroot) ans2=e[i].ok;\n\t\t\t\tpre[v]=u;\n\t\t\t\tin[v]=e[i].data;\n\t\t\t}\n\t\t}\n\t\tfor (int i=1;i<=sum;++i){\n\t\t\tif (i==root) continue;\n\t\t\tif (in[i]>1e40) return -1;\n\t\t}\n\t\tint cntnode = 0;\n\t\tmemset(id,-1,sizeof(id));\n\t\tmemset(vis,-1,sizeof(vis));\n\t\tin[root] = 0;\n\t\tfor (int i=1;i<=sum;++i){\n\t\t\tres+=in[i];\n\t\t\tint v=i;\n\t\t\twhile (vis[v]!=i && id[v]==-1 && v!=root){\n\t\t\t\tvis[v]=i;\n\t\t\t\tv=pre[v];\n\t\t\t}\n\t\t\tif (v!=root && id[v]==-1){\n\t\t\t\tfor (int u=pre[v];u!=v;u=pre[u]) id[u]=cntnode+1;\n\t\t\t\tid[v]=++cntnode;\n\t\t\t}\n\t\t}\n\t\tif (!cntnode) break;\n\t\tfor (int i=1;i<=sum;++i)\n\t\t\tif (id[i]==-1) id[i]=++cntnode;\n\t\tfor (int i=1;i<=nn;++i){\n\t\t\tint v=e[i].k;\n\t\t\te[i].d=id[e[i].d];\n\t\t\te[i].k=id[e[i].k];\n\t\t\tif (e[i].d!=e[i].k) e[i].data-=in[v];\n\t\t}\n\t\tsum=cntnode;\n\t\troot = id[root];\n\t}\n\treturn res;\n}\n\t\t\t\ndouble cal3(int k){\n\tdouble tmp = 0;\n\tfor (int i=1;i<=m;++i) tmp+=a[k][i]*a[k][i];\n\treturn tmp;\n}\n\t\t\t\nint main(){\n\twhile (scanf(\"%d%d\",&m,&n)==2){\n\t\tnn=0;\n\t\tfor (int i=1;i<=n;++i)\n\t\t\tfor (int j=1;j<=m;++j) scanf(\"%lf\",&a[i][j]);\n\t\tdouble tt = 0;\n\t\tfor (int i=1;i<=n;++i)\n\t\t\tfor (int j=1;j<=n;++j){\n\t\t\t\taddedge(i,j,cal(j,i),i,j);\n//\t\t\t\tprintf(\"%d %d %.2f\\n\",i,j,e[nn].data);\n\t\t\t}\n\t\t++n;\n\t\tfor (int i=1;i<n;++i){ \n\t\t\taddedge(n,i,cal3(i),n,i);\n//\t\t\tprintf(\"%d: %.2f\\n\",i,cal3(i));\n\t\t}\n\t\troot = n;\n\t\tprintf(\"%.12f\\n\",work(root));\n\t}\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef ld Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\nint E_SIZE = 10020;\npair<Weight,Graph> chu_liu(const Graph&g, const int start) {\n\tGraph revg(g.size());\n\n\t///*????´???°???Edge?????°????????§??????*/\n\t//vector<Edge>memo(g.size()*g.size());\n\t//for (auto es : g) {\n\t//\tfor (auto e : es) {\n\t//\t\tmemo[e.id] = e;\n\t//\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t//\t}\n\t//}\n\tGraph tree(g.size());\n\tld total_len = 0;\n\tfor (int node = 0; node < g.size(); ++node) {\n\t\tif (node == start)continue;\n\t\telse {\n\t\t\tWeight amin = INF;\n\t\t\tEdge min_edge;\n\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\tmin_edge = Edge(reve.dst,reve.src, reve.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (amin < INF) {\n\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t}\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(g.size()*g.size());\n\n\t\tvector<pair<int,Weight>>prevs(g.size(), make_pair(-1,ZERO));\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tnode_is_cycle[ce.dst] = true;\n\t\t\tprevs[ce.dst] = make_pair(ce.src, ce.weight);\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prevs[e.dst].second, e.id));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start);\n\t\tGraph compress_tree(g.size());\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tEdge prev_edge(e);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tld fin_len = p.first + cycle_len;\n\t\treturn make_pair(fin_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start);\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\n\n\nstruct edge\n{\n int begin;int end;\t\n};\n\nconst int maxx=120;\nbool vis[maxx],indfs[maxx];\nvector<double>zero;\nint n,m,root;\nvector<vector<double> >vec;\ndouble cost[maxx][maxx],Cost[maxx][maxx];\nbool operator <(const edge a,const edge b)\n{\n double ac=cost[a.begin][a.end];double bc=cost[b.begin][b.end];\n return ac>bc;//´?????´?????\t\n};\npriority_queue<edge>que[maxx];\ndouble minv(vector<double> a,vector<double> b)\n{\n double ab=0,bsqrt=0,asqrt=0;\n for(int i=0;i<a.size();i++)\n \t{ab+=a[i]*b[i];bsqrt+=b[i]*b[i];asqrt+=a[i]*a[i];}\n \t\n if((bsqrt-0.0)<1e-10)return asqrt;\n return asqrt-(ab*ab/bsqrt);\n}\nint belongcircle[maxx];\nint findbelong(int x)\n{\n if(x==belongcircle[x])return x;\n \telse return belongcircle[x]=findbelong(belongcircle[x]);\n}\n\ndouble ans,ansnow;\ndouble min(double a,double b)\n{\n if(a<b)return a;\n \telse return b;\n}\nvoid combinecircle(int now,int begin)\n{\n now=findbelong(now);\n if(vis[now])return ;\n vis[now]=true;\n edge e1=que[now].top();\n double coste=cost[findbelong(e1.begin)][findbelong(e1.end)];\n ansnow+=coste;\n bool finish[maxx];\n memset(finish,0,sizeof(finish));\n for(int i=0;i<=m;i++)\n \t{\n \t int po=findbelong(i);\n \t if(po==now||po==begin)continue;\n \t if(finish[po])continue;\n \t finish[po]=true;\n \t cost[begin][po]=min(cost[begin][po],cost[now][po]-coste);\n \t cost[po][begin]=min(cost[po][begin],cost[po][now]);\n\t}\n belongcircle[now]=begin;\n combinecircle(e1.end,begin);\n return ;\n}\nvoid build();\nbool findcircle(int now)\n{\n if(now==root)return false; \n now=findbelong(now);\n if(indfs[now])\n \t{\n \t memset(vis,0,sizeof(vis));\n \t combinecircle(now,now);\n \t build();\n \t return true;\n\t}\n indfs[now]=true;\n return findcircle(que[now].top().end);\n}\n\nvoid build()\n{\n bool finish[maxx];\n memset(finish,0,sizeof(finish));\n for(int i=0;i<m;i++)\n \t{\n \t int po=findbelong(i);\n \t if(finish[po])continue;\n \t finish[po]=true;\n \t while(!que[po].empty())que[po].pop();\n \t for(int j=0;j<=m;j++)\n \t \t{\n \t \t int pb=findbelong(j);\n \t \t if(po==pb)continue;\n \t \t edge en;en.begin=po;en.end=pb;\n \t \t que[po].push(en);\n\t\t}\n\t}\n return ;\n}\nbool counted[maxx];\nint main()\n{\n ios::sync_with_stdio(false);\n cin>>n>>m;\n for(int i=0;i<n;i++)\n    zero.push_back(0.0);\n for(int i=0;i<m;i++)\n \t{\n\t vector<double>nowv;\n\t for(int j=0;j<n;j++)\n\t \t{ double nv;cin>>nv;nowv.push_back(nv);}\n\t vec.push_back(nowv);\n\t}\n vec.push_back(zero);\n for(int i=0;i<=m;i++)\n \tfor(int j=0;j<=m;j++)\n \t\t{ cost[i][j]=minv(vec[i],vec[j]);}\n root=m;\n ansnow=0;\n belongcircle[root]=root;\n \t for(int i=0;i<m;i++)\n \t \t{\n \t \t belongcircle[i]=i;\n \t \t}\n\t bool exis=false;\n\t \t do\n\t \t \t{\n\t \t \t build();\n\t \t \t exis=false;\n\t \t \t bool finish[maxx];\n\t \t \t memset(finish,0,sizeof(finish));\n\t \t \t for(int i=0;i<m;i++)\n\t \t \t {  \n\t\t\t    int po=findbelong(i);\n\t\t\t    if(finish[po])continue;\n\t \t \t    memset(indfs,0,sizeof(indfs));\n\t \t \t    exis=findcircle(po);\n\t \t \t    finish[po]=true;\n\t\t\t }\n\t\t\t}while(exis);\n\t memset(counted,0,sizeof(counted));\n\t for(int i=0;i<m;i++)\n\t \t{\n\t\t int po=findbelong(i);\n\t\t if(counted[po])continue;\n\t\t counted[po]=true;\n\t\t ansnow+=cost[findbelong(que[po].top().begin)][findbelong(que[po].top().end)];\t\n\t\t}\n printf(\"%.8f\\n\",ansnow);\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\n#define M (201000)\nint N, a[40];\ndouble dp[40][M];\n\ninline double calc(double a, double b) { return fabs(a-b)/a; }\n\nint main() {\n    scanf(\"%d\", &N);\n    rep(i, N) scanf(\"%d\", a+i);\n    rep(i, N) rep(j, M) dp[i][j] = 1e100;\n    rep(i, M) dp[0][i] = calc(a[0], i);\n    rep(i, N-1) for(int j=1; j<M; j++) for(int k=j; k<M; k+=j) {\n        dp[i+1][k] = min(dp[i+1][k], max(dp[i][j], calc(a[i+1], k)));\n    }\n    double ans = 1e100;\n    rep(i, M) ans = min(ans, dp[N-1][i]);\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\n\n\nstruct edge\n{\n int begin;int end;\t\n};\n\nconst int maxx=120;\nbool vis[maxx],indfs[maxx];\nvector<double>zero;\nint n,m,root;\nvector<vector<double> >vec;\ndouble cost[maxx][maxx],Cost[maxx][maxx];\nbool operator <(const edge a,const edge b)\n{\n double ac=cost[a.begin][a.end];double bc=cost[b.begin][b.end];\n return ac>bc;//´?????´?????\t\n};\npriority_queue<edge>que[maxx];\ndouble minv(vector<double> a,vector<double> b)\n{\n double ab=0,bsqrt=0,asqrt=0;\n for(int i=0;i<a.size();i++)\n \t{ab+=a[i]*b[i];bsqrt+=b[i]*b[i];asqrt+=a[i]*a[i];}\n \t\n if((bsqrt-0.0)<1e-10)return asqrt;\n return asqrt-(ab*ab/bsqrt);\n}\nint belongcircle[maxx];\nint findbelong(int x)\n{\n if(x==belongcircle[x])return x;\n \telse return belongcircle[x]=findbelong(belongcircle[x]);\n}\n\ndouble ans,ansnow;\ndouble min(double a,double b)\n{\n if(a<b)return a;\n \telse return b;\n}\nvoid combinecircle(int now,int begin)\n{\n now=findbelong(now);\n if(vis[now])return ;\n belongcircle[now]=begin;\n vis[now]=true;\n edge e1=que[now].top();\n double coste=cost[e1.begin][e1.end];\n ansnow+=coste;\n bool finish[maxx];\n memset(finish,0,sizeof(finish));\n for(int i=0;i<=m;i++)\n \t{\n \t int po=findbelong(i);\n \t if(finish[po])continue;\n \t finish[po]=true;\n \t edge e1=que[now].top();\n \t cost[begin][po]=min(cost[begin][po],cost[now][po]-coste);\n \t cost[po][begin]=min(cost[po][begin],cost[po][now]);\n\t}\n combinecircle(e1.end,begin);\n}\n\nbool findcircle(int now)\n{\n if(now==root)return false; \n now=findbelong(now);\n if(indfs[now])\n \t{\n \t memset(vis,0,sizeof(vis));\n \t combinecircle(now,now);\n \t while(!que[now].empty())que[now].pop();\n \t bool finish[maxx];\n \t memset(finish,0,sizeof(finish));\n \t for(int i=0;i<=m;i++)\n \t {  \n \t    int po=findbelong(i);\n \t    if(finish[po])continue;\n \t    finish[po]=true;\n \t    if(now==po)continue;\n\t    edge en;en.begin=now;en.end=po;\n \t \tque[now].push(en);\n \t }\n \t return true;\n\t}\n indfs[now]=true;\n return findcircle(que[now].top().end);\n}\n\n\nbool counted[maxx];\nint main()\n{\n ios::sync_with_stdio(false);\n cin>>n>>m;\n for(int i=0;i<n;i++)\n    zero.push_back(0.0);\n for(int i=0;i<m;i++)\n \t{\n\t vector<double>nowv;\n\t for(int j=0;j<n;j++)\n\t \t{ double nv;cin>>nv;nowv.push_back(nv);}\n\t vec.push_back(nowv);\n\t}\n vec.push_back(zero);\n for(int i=0;i<=m;i++)\n \tfor(int j=0;j<=m;j++)\n \t\t{ Cost[i][j]=minv(vec[i],vec[j]);}\n ans=999999999.0;\n root=m;\n \n ansnow=0;\n \t for(int i=0;i<=m;i++)\n \t   for(int j=0;j<=m;j++)\n \t\t{ cost[i][j]=Cost[i][j];}\n \t for(int i=0;i<=m;i++)\n \t \t{\n \t \t belongcircle[i]=i;\n \t \t while(!que[i].empty())que[i].pop();\n \t \t for(int j=0;j<=m;j++)\n \t \t \t{\n \t \t \t if(i==j)continue;\n \t \t \t edge en;en.begin=i;en.end=j;\n \t \t \t que[i].push(en);\n\t\t\t}\n\t\t}\n\t bool exis=false;\n\t \t do\n\t \t \t{\n\t \t \t exis=false;\n\t \t \t bool finish[maxx];\n\t \t \t memset(finish,0,sizeof(finish));\n\t \t \t for(int i=0;i<m;i++)\n\t \t \t {  \n\t\t\t    if(i==root)continue;\n\t\t\t    int po =findbelong(i);\n\t\t\t    if(finish[po])continue;\n\t \t \t    memset(indfs,0,sizeof(indfs));\n\t \t \t    exis=findcircle(po);\n\t \t \t    finish[po]=true;\n\t \t \t    if(exis)break;\n\t\t\t }\n\t\t\t}while(exis);\n\t memset(counted,0,sizeof(counted));\n\t for(int i=0;i<m;i++)\n\t \t{\n\t \t if(i==root)continue;\n\t\t int po=findbelong(i);\n\t\t if(counted[po])continue;\n\t\t counted[po]=true;\n\t\t ansnow+=cost[findbelong(que[po].top().begin)][findbelong(que[po].top().end)];\t\n\t\t}\n\t ans=min(ans,ansnow);\n cout<<ans<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef float Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start) {\n\tGraph revg(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(g.size()*g.size());\n\n\tfor (auto es : g) {\n\t\tfor (auto e : es) {\n\t\t\t//memo[e.id] = e;\n\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t}\n\t}\n\tGraph tree(g.size());\n\tld total_len = 0;\n\tfor (int node = 0; node < g.size(); ++node) {\n\t\tif (node == start)continue;\n\t\telse {\n\t\t\tWeight amin = INF;\n\t\t\tEdge min_edge;\n\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\tmin_edge = Edge(reve.dst,reve.src, reve.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (amin < INF) {\n\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t}\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(g.size()*g.size());\n\n\t\tvector<pair<int,Weight>>prevs(g.size(), make_pair(-1,ZERO));\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tnode_is_cycle[ce.dst] = true;\n\t\t\tprevs[ce.dst] = make_pair(ce.src, ce.weight);\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prevs[e.dst].second, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t\tne_size++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start);\n\t\tGraph compress_tree(g.size());\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tEdge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tld fin_len = p.first + cycle_len;\n\t\treturn make_pair(fin_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start);\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n//#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\nusing namespace std;\n#define peter cout<<\"i am peter\"<<endl\ntypedef long long ll;\n\nconst double eps = 1e-8;\nint sgn(double x){\n    if(abs(x) < eps) return 0;\n    else return x > 0 ? 1 : -1;\n}\n\n#define N 200\nint n, m;\ndouble v[N][N], dis[N];\nbool vis[N];\n\ndouble getdis(int a, int b){\n    double l = -1e6, r = 1e6, mid1, mid2;\n    int tt = 100;\n    while(r - l > 1e-12 && tt--){\n        mid1 = (l + r) * 0.5;\n        mid2 = (mid1 + r) * 0.5;\n        double dis1 = 0.0, dis2 = 0.0;\n        for(int i = 1; i <= n; i++){\n            dis1 += (v[a][i] - mid1 * v[b][i]) * (v[a][i] - mid1 * v[b][i]);\n            dis2 += (v[a][i] - mid2 * v[b][i]) * (v[a][i] - mid2 * v[b][i]);\n        }\n        if(sgn(dis1 - dis2) <= 0) r = mid2;\n        else l = mid1;\n    }\n    double dis = 0.0;\n    for(int i = 1; i <= n; i++){\n        dis += (v[a][i] - l * v[b][i]) * (v[a][i] - l * v[b][i]);\n    }\n    return dis;\n}\n\ndouble prim(int sta){\n    for(int i = 1; i <= m; i++){\n        dis[i] = 0.0;\n        for(int j = 1; j <= n; j++) dis[i] += v[i][j] * v[i][j];\n        vis[i] = 0;\n    }\n    double res = 0.0;\n    for(int ii = 1; ii <= m; ii++){\n        double mini = 1e15;\n        int w = 1;\n        for(int i = 1; i <= m; i++){\n            if(vis[i] == 1) continue;\n            if(sgn(dis[i] - mini) < 0){\n                mini = dis[i];\n                w = i;\n            }\n        }\n        if(ii == 1) w = sta;\n        res += dis[w];\n        vis[w] = 1;\n        for(int i = 1; i <= m; i++){\n            if(vis[i] == 1) continue;\n            dis[i] = min(dis[i], getdis(i, w));\n        }\n    }\n    return res;\n}\n\nint main(){\n    //freopen(\"/Users/peteryuanpan/data.txt\",\"r\",stdin);\n    while(~scanf(\"%d%d\",&n,&m)){\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                scanf(\"%lf\", &v[i][j]);\n            }\n        }\n        double ans = 1e20;\n        for(int i = 1; i <= m; i++){\n            ans = min(ans, prim(i));\n        }\n        printf(\"%.10f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\n\n\nstruct edge\n{\n int begin;int end;\t\n};\n\nconst int maxx=120;\nbool vis[maxx],indfs[maxx];\nvector<double>zero;\nint n,m,root;\nvector<vector<double> >vec;\ndouble cost[maxx][maxx],Cost[maxx][maxx];\nbool operator <(const edge a,const edge b)\n{\n double ac=cost[a.begin][a.end];double bc=cost[b.begin][b.end];\n return ac>bc;//´?????´?????\t\n};\npriority_queue<edge>que[maxx];\ndouble minv(vector<double> a,vector<double> b)\n{\n double ab=0,bsqrt=0,asqrt=0;\n for(int i=0;i<a.size();i++)\n \t{ab+=a[i]*b[i];bsqrt+=b[i]*b[i];asqrt+=a[i]*a[i];}\n \t\n if((bsqrt-0.0)<1e-10)return asqrt;\n return asqrt-(ab*ab/bsqrt);\n}\nint belongcircle[maxx];\nint findbelong(int x)\n{\n if(x==belongcircle[x])return x;\n \telse return belongcircle[x]=findbelong(belongcircle[x]);\n}\n\ndouble ans,ansnow;\ndouble min(double a,double b)\n{\n if(a<b)return a;\n \telse return b;\n}\nvoid combinecircle(int now,int begin)\n{\n now=findbelong(now);\n if(vis[now])return ;\n\n vis[now]=true;\n edge e1=que[now].top();\n double coste=cost[findbelong(e1.begin)][findbelong(e1.end)];\n  belongcircle[now]=begin;\n ansnow+=coste;\n bool finish[maxx];\n memset(finish,0,sizeof(finish));\n for(int i=0;i<=m;i++)\n \t{\n \t int po=findbelong(i);\n \t if(finish[po])continue;\n \t finish[po]=true;\n \t cost[begin][po]=min(cost[begin][po],cost[now][po]-coste);\n \t cost[po][begin]=min(cost[po][begin],cost[po][now]);\n\t}\n combinecircle(e1.end,begin);\n}\n\nbool findcircle(int now)\n{\n if(now==root)return false; \n now=findbelong(now);\n if(indfs[now])\n \t{\n \t memset(vis,0,sizeof(vis));\n \t combinecircle(now,now);\n \t while(!que[now].empty())que[now].pop();\n \t bool finish[maxx];\n \t memset(finish,0,sizeof(finish));\n \t for(int i=0;i<=m;i++)\n \t {  \n \t    int po=findbelong(i);\n \t    if(finish[po])continue;\n \t    finish[po]=true;\n \t    if(now==po)continue;\n\t    edge en;en.begin=now;en.end=po;\n \t \tque[now].push(en);\n \t }\n \t return true;\n\t}\n indfs[now]=true;\n return findcircle(que[now].top().end);\n}\n\n\nbool counted[maxx];\nint main()\n{\n ios::sync_with_stdio(false);\n cin>>n>>m;\n for(int i=0;i<n;i++)\n    zero.push_back(0.0);\n for(int i=0;i<m;i++)\n \t{\n\t vector<double>nowv;\n\t for(int j=0;j<n;j++)\n\t \t{ double nv;cin>>nv;nowv.push_back(nv);}\n\t vec.push_back(nowv);\n\t}\n vec.push_back(zero);\n for(int i=0;i<=m;i++)\n \tfor(int j=0;j<=m;j++)\n \t\t{ Cost[i][j]=minv(vec[i],vec[j]);}\n ans=999999999.0;\n root=m;\n \n ansnow=0;\n belongcircle[root]=root;\n \t for(int i=0;i<=m;i++)\n \t   for(int j=0;j<=m;j++)\n \t\t{ cost[i][j]=Cost[i][j];}\n \t for(int i=0;i<m;i++)\n \t \t{\n \t \t belongcircle[i]=i;\n \t \t while(!que[i].empty())que[i].pop();\n \t \t for(int j=0;j<=m;j++)\n \t \t \t{\n \t \t \t if(i==j)continue;\n \t \t \t edge en;en.begin=i;en.end=j;\n \t \t \t que[i].push(en);\n\t\t\t}\n\t\t}\n\t bool exis=false;\n\t \t do\n\t \t \t{\n\t \t \t exis=false;\n\t \t \t bool finish[maxx];\n\t \t \t memset(finish,0,sizeof(finish));\n\t \t \t for(int i=0;i<m;i++)\n\t \t \t {  \n\t\t\t    if(i==root)continue;\n\t\t\t    int po =findbelong(i);\n\t\t\t    if(finish[po])continue;\n\t \t \t    memset(indfs,0,sizeof(indfs));\n\t \t \t    exis=findcircle(po);\n\t \t \t    finish[po]=true;\n\t \t \t    if(exis)break;\n\t\t\t }\n\t\t\t}while(exis);\n\t memset(counted,0,sizeof(counted));\n\t for(int i=0;i<m;i++)\n\t \t{\n\t \t if(i==root)continue;\n\t\t int po=findbelong(i);\n\t\t if(counted[po])continue;\n\t\t counted[po]=true;\n\t\t ansnow+=cost[findbelong(que[po].top().begin)][findbelong(que[po].top().end)];\t\n\t\t}\n\t ans=min(ans,ansnow);\n cout<<ans<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\n\n\nstruct edge\n{\n int begin;int end;\t\n};\n\nconst int maxx=120;\nbool vis[maxx],indfs[maxx];\nvector<double>zero;\nint n,m,root;\nvector<vector<double> >vec;\ndouble cost[maxx][maxx],Cost[maxx][maxx];\nbool operator <(const edge a,const edge b)\n{\n double ac=cost[a.begin][a.end];double bc=cost[b.begin][b.end];\n return ac>bc;//´?????´?????\t\n};\npriority_queue<edge>que[maxx];\ndouble minv(vector<double> a,vector<double> b)\n{\n double ab=0,bsqrt=0,asqrt=0;\n for(int i=0;i<a.size();i++)\n \t{ab+=a[i]*b[i];bsqrt+=b[i]*b[i];asqrt+=a[i]*a[i];}\n \t\n if((bsqrt-0.0)<1e-10)return asqrt;\n return asqrt-(ab*ab/bsqrt);\n}\nint belongcircle[maxx];\nint findbelong(int x)\n{\n if(x==belongcircle[x])return x;\n \telse return belongcircle[x]=findbelong(belongcircle[x]);\n}\n\ndouble ans,ansnow;\ndouble min(double a,double b)\n{\n if(a<b)return a;\n \telse return b;\n}\nvoid combinecircle(int now,int begin)\n{\n now=findbelong(now);\n if(vis[now])return ;\n vis[now]=true;\n edge e1=que[now].top();\n double coste=cost[findbelong(e1.begin)][findbelong(e1.end)];\n ansnow+=coste;\n bool finish[maxx];\n memset(finish,0,sizeof(finish));\n for(int i=0;i<=m;i++)\n \t{\n \t int po=findbelong(i);\n \t if(po==now||po==begin)continue;\n \t if(finish[po])continue;\n \t finish[po]=true;\n \t cost[begin][po]=min(cost[begin][po],cost[now][po]-coste);\n \t cost[po][begin]=min(cost[po][begin],cost[po][now]);\n\t}\n belongcircle[now]=begin;\n combinecircle(e1.end,begin);\n}\n\nbool findcircle(int now)\n{\n if(now==root)return false; \n now=findbelong(now);\n if(indfs[now])\n \t{\n \t memset(vis,0,sizeof(vis));\n \t combinecircle(now,now);\n \t return true;\n\t}\n indfs[now]=true;\n return findcircle(que[now].top().end);\n}\n\nvoid build()\n{\n bool finish[maxx];\n memset(finish,0,sizeof(finish));\n for(int i=0;i<m;i++)\n \t{\n \t int po=findbelong(i);\n \t if(finish[po])continue;\n \t finish[po]=true;\n \t while(!que[po].empty())que[po].pop();\n \t for(int j=0;j<=m;j++)\n \t \t{\n \t \t int pb=findbelong(j);\n \t \t if(po==pb)continue;\n \t \t edge en;en.begin=po;en.end=pb;\n \t \t que[po].push(en);\n\t\t}\n\t}\n return ;\n}\nbool counted[maxx];\nint main()\n{\n cin>>n>>m;\n for(int i=0;i<n;i++)\n    zero.push_back(0.0);\n for(int i=0;i<m;i++)\n \t{\n\t vector<double>nowv;\n\t for(int j=0;j<n;j++)\n\t \t{ double nv;cin>>nv;nowv.push_back(nv);}\n\t vec.push_back(nowv);\n\t}\n vec.push_back(zero);\n for(int i=0;i<=m;i++)\n \tfor(int j=0;j<=m;j++)\n \t\t{ cost[i][j]=minv(vec[i],vec[j]);}\n root=m;\n ansnow=0;\n belongcircle[root]=root;\n \t for(int i=0;i<m;i++)\n \t \t{\n \t \t belongcircle[i]=i;\n \t \t}\n\t bool exis=false;\n\t \t do\n\t \t \t{\n\t \t \t build();\n\t \t \t exis=false;\n\t \t \t bool finish[maxx];\n\t \t \t memset(finish,0,sizeof(finish));\n\t \t \t for(int i=0;i<m;i++)\n\t \t \t {  \n\t\t\t    int po=findbelong(i);\n\t\t\t    if(finish[po])continue;\n\t \t \t    memset(indfs,0,sizeof(indfs));\n\t \t \t    exis=findcircle(po);\n\t \t \t    finish[po]=true;\n\t \t \t    if(exis){break;}\n\t\t\t }\n\t\t\t}while(exis);\n\t memset(counted,0,sizeof(counted));\n\t for(int i=0;i<m;i++)\n\t \t{\n\t\t int po=findbelong(i);\n\t\t if(counted[po])continue;\n\t\t counted[po]=true;\n\t\t ansnow+=cost[findbelong(que[po].top().begin)][findbelong(que[po].top().end)];\t\n\t\t}\n cout<<ansnow<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight w;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), w(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.w != f.w ? e.w > f.w : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n\nvoid backward_traverse(int v, int s, int r,\n  Graph &gg,\n  vector<int> &no, vector< vector<int> > &comp,\n  vector<int> &prev, vector< vector<int> > &next, vector<Weight> &mcost,\n  vector<int> &mark, Weight &cost, bool &found) {\n  const int n = gg.size();\n  if (mark[v]) {\n    vector<int> temp = no;\n    found = true;\n    do {\n      cost += mcost[v];\n      v = prev[v];\n      if (v != s) {\n        while (comp[v].size() > 0) {\n          no[comp[v].back()] = s;\n          comp[s].push_back(comp[v].back());\n          comp[v].pop_back();\n        }\n      }\n    } while (v != s);\n\n    for (int k = 0; k < comp[s].size(); ++k) {\n      int j = comp[s][k];\n      if (j != r)\n        for (int l = 0; l < gg[j].size(); ++l)\n          if (no[ gg[j][l].src ] != s)\n            gg[j][l].w -= mcost[ temp[j] ];\n    }\n  }\n  mark[v] = true;\n  for (int k = 0; k < next[v].size(); ++k) {\n    int i = next[v][k];\n    if (no[i] != no[v] && prev[ no[i] ] == v)\n      if (!mark[ no[i] ] || i == s)\n        backward_traverse(i, s, r, gg,\n            no, comp, prev, next, mcost, mark, cost, found);\n  }\n}\nWeight minimum_spanning_arborescence(int r, Graph &g) {\n  const int n = g.size();\n  Graph gg(n);\n  for (int i = 0; i < g.size(); ++i)\n    for (int j = 0; j < g[i].size(); ++j)\n      gg[ g[i][j].dst ].push_back( g[i][j] );\n\n  vector<int> no(n);\n  vector< vector<int> > comp(n);\n  for (int i = 0; i < n; ++i) {\n    no[i] = i;\n    comp[i].push_back(i);\n  }\n  Weight cost = 0;\n  while (1) {\n    vector<int> prev(n, -1);\n    vector<Weight> mcost(n, inf);\n\n    for (int j = 0; j < n; ++j) {\n      if (j == r) continue;\n      for (int k = 0; k < gg[j].size(); ++k) {\n        int i = gg[j][k].src;\n        if (no[i] != no[j]) {\n          if (gg[j][k].w < mcost[ no[j] ]) {\n            mcost[ no[j] ] = gg[j][k].w;\n            prev[ no[j] ] = no[i];\n          }\n        }\n      }\n    }\n    vector< vector<int> > next(n);\n    for (int i = 0; i < n; ++i)\n      if (prev[i] >= 0)\n        next[ prev[i] ].push_back( i );\n\n    bool stop = true;\n    vector<int> mark(n);\n    for (int i = 0; i < n; ++i) {\n      if (i == r || mark[i] || comp[i].size() == 0) continue;\n      bool found = false;\n      backward_traverse(i, i, r, gg,\n          no, comp, prev, next, mcost, mark, cost, found);\n      if (found) stop = false;\n    }\n    if (stop) {\n      for (int i = 0; i < n; ++i)\n        if (prev[i] >= 0)\n          cost += mcost[i];\n      return cost;\n    }\n  }\n}\n\ndouble f(const vector<double>& v) {\n    double res = 0;\n    REP(i, v.size()) res += v[i]*v[i];\n    return res;\n}\n\nvector<double> sub(const vector<double>& a, const vector<double>& b) {\n    vector<double> res(a.size());\n    REP(i, a.size()) res[i] = a[i] - b[i];\n    return res;\n}\nvector<double> mul(const vector<double>& v, const double r) {\n    vector<double> res(v.size());\n    REP(i, v.size()) {\n        res[i] = v[i]*r;\n    }\n    return res;\n}\n\n// |b - a * hoge|^2 -> min\ndouble getW(const vector<double>& a, const vector<double>& b) {\n    double l = -inf, r = inf;\n    REP(t, 100) {\n        double m1 = (2*l+r)/3, m2 = (l+2*r)/3;\n        if ( f( sub(b, mul(a, m1)) ) < f( sub(b, mul(a, m2)) ) ) {\n            r = m2;\n        }\n        else {\n            l = m1;\n        }\n    }\n    return f( sub(b, mul(a, (l + r)/2)) );\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n, m; cin >> n >> m;\n    vector< vector<double> > v(m, vector<double>(n)); cin >> v;\n    int s = m;\n    Graph G(s+1);\n    REP(i, m) REP(j, m) {\n        G[i].pb( Edge(i, j, getW(v[i], v[j])) );\n    }\n    REP(i, m) {\n        G[s].pb( Edge(s, i, f(v[i])) );\n    }\n    cout << fixed << setprecision(10);\n    cout << minimum_spanning_arborescence(s, G) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<double> Point;\n\ndouble INF=1e9;\n\nstruct UnionFind{\n  vector<int> par,rank;\n  void init(int n){\n    par.clear();\n    rank.clear();\n    par.resize(n);\n    rank.resize(n);\n    for(int i=0;i<n;i++){\n      par[i]=i;\n      rank[i]=1;\n    }\n  }\n  \n  int find(int x){\n    if(x==par[x])return x;\n    return par[x]=find(par[x]);\n  }\n\n  bool same(int x,int y){\n    return ( find(x)==find(y) );\n  }\n  \n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])swap(x,y);\n    par[y]=x;\n    rank[x]+=rank[y];\n  }\n};\n\nstruct edge{\n  int from;\n  int to;\n  double cost;\n  int id;\n  edge(int from,int to,double cost,int id) :from(from), to(to),cost(cost),id(id) {}\n  bool operator < (const edge e)const{\n    return cost > e.cost;\n  }\n};\n\ntypedef priority_queue< edge > prque;\ntypedef prque* Prque;\n\ntypedef vector<edge> Node;\ntypedef vector<Node> Graph;\n\n\nPrque Merge(vector< Prque > &Q, vector<edge> &ev,int A,int C){\n  if( Q[C]->size() < Q[A]->size() ){\n\n    while( !Q[C]->empty() ){\n      edge e=Q[C]->top();\n      e.cost-=ev[C].cost;\n      e.cost+=ev[A].cost;\n      //      cout<<e.from<<' '<<e.to<<' '<<e.cost<<' '<<ev[A].cost<<' '<<ev[C].cost<<endl;\n      Q[A]->push(e);\n      Q[C]->pop();\n    }\n    ev[C].cost=ev[A].cost;\n    return Q[A];\n  }else{\n    while( !Q[A]->empty() ){\n      edge e=Q[A]->top();\n      e.cost-=ev[A].cost;\n      e.cost+=ev[C].cost;\n      //      cout<<e.from<<' '<<e.to<<' '<<e.cost<<endl;\n      Q[C]->push(e);\n      Q[A]->pop();\n    }\n    return Q[C];\n  }\n}\n\ndouble solve(Graph &G,vector<edge> &edges,int root){\n\n  int n=G.size();\n  double res=0;\n  \n  vector<int> used(n,0);\n  vector< edge > ev(n, (edge){0,0,0,-1} );\n  vector< prque > pool(n);\n  vector< Prque > Q(n);\n  for(int i=0;i<n;i++)Q[i]=&pool[i];\n  \n  UnionFind uf;\n  uf.init(n);\n  \n  for(int i=0;i<(int)edges.size();i++){\n    edge e=edges[i];\n    Q[ e.to ]->push( e );\n  }\n  \n  used[root]=2;\n  for(int Pos=0;Pos<n;Pos++){\n    if(used[Pos]==2)continue;\n    int pos=Pos;\n    vector<int> path;\n    \n    while( used[pos] != 2 ){\n      pos=uf.find(pos);\n      \n      used[pos]=1;\n      path.push_back(pos);\n      if( Q[pos]->empty() ){\n        return INF;\n      }\n      \n      edge e=Q[pos]->top();\n\n      \n      Q[pos]->pop();\n      e.cost-=ev[pos].cost;\n      if( uf.same(e.from,pos) ) continue;\n      double tmpcost=ev[pos].cost;\n      /*\n      cout<<\" pos=\"<<pos;\n      cout<<\" e.from=\"<<e.from;\n      cout<<\" e.to=\"<<e.to;\n      cout<<\" e.cost=\"<<e.cost;\n      cout<<\" tmpcost=\"<<tmpcost<<endl;\n      cout<<endl;\n      */\n      res+=e.cost;\n      e.cost+=tmpcost;\n      ev[pos]=e;\n      if( used[ uf.find(e.from) ] == 2 )break;\n      if( used[ uf.find(e.from) ] == 0 ){\n        pos=e.from;\n        continue;\n      }\n      int pre=uf.find(e.from);\n      for(int i=0;i<100;i++){\n        if(!uf.same(pre,pos)){\n          int A=uf.find(pre), B=uf.find(pos);\n          uf.unite(A,B);\n          int C=uf.find(A);\n          /*\n          cout<<\" !!A=\"<<A;\n          cout<<\" !!B=\"<<B;\n          cout<<\" !!C=\"<<C<<endl;\n          */\n          Prque tmp=NULL;\n          if(B==C)tmp=Merge(Q,ev,A,C);\n          else if(A==C)tmp=Merge(Q,ev,B,C);\n          else assert(0);\n          \n          Q[C]=tmp;\n        }\n        pre=uf.find(ev[pre].from);\n      }\n    }// while_pos\n\n    for(int i=0;i<(int)path.size();i++)used[ path[i] ]=2;\n  }// Pos\n  return res;\n}\n\n\nPoint add(Point a,Point b){\n  Point res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=a[i]+b[i];\n  return res;\n}\n\nPoint sub(Point a,Point b){\n  Point res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=a[i]-b[i];\n  return res;\n}\n\ndouble dot(Point a,Point b){\n  double res=0;\n  for(int i=0;i<(int)a.size();i++)\n    res+=a[i]*b[i];\n  return res;\n}\n\ndouble norm(Point p){\n  return  dot(p,p);\n}\n\nPoint project(Point a,Point b,Point p){\n  Point base( a.size() );\n  Point target( a.size() );\n  for(int i=0;i<(int)a.size();i++){\n    base[i]=b[i]-a[i];\n    target[i]=p[i]-a[i];\n  }\n  double t=dot(base,target);\n  Point res=a;\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=res[i]+base[i]*t/norm(base);\n  return res;\n}\n\n\nint main(){\n  int n,m;\n  vector< Point > t;\n  \n  cin>>m>>n;\n  for(int i=0;i<n;i++){\n    Point a(m);\n    for(int j=0;j<m;j++){\n      cin>>a[j];\n    }\n    t.push_back(a);\n  }\n\n  Point cen( m , 0 );\n  \n  Graph G;\n  G.resize(n+1);\n  int cc=0;\n  for(int i=0;i<n;i++){\n    G[n].push_back( edge(n,i,norm(t[i]) , cc++) );\n    \n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      Point pp = project( t[j] , add(t[j],t[i]) , cen);\n      double cost= norm( pp);\n      G[i].push_back( edge(i,j,cost,cc++) );\n    }\n  }\n\n  vector<edge> edges;\n  for(int i=0;i<=n;i++)\n    for(int j=0;j<(int)G[i].size();j++)\n      edges.push_back(G[i][j]);\n  \n  printf(\"%.10f\\n\", solve(G,edges,n) );\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef pair<double, int> pii;\ntypedef long long ll;\nint N, M;\ndouble vec[101][101];\ndouble dist[101][101];\nbool seen[101];\n\ntypedef double Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid SccDfs(const Graph &g, int from, vector<int> &visit, vector<int> &st) {\n  visit[from] = 1;\n  for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n    if (visit[it->dest]) { continue; }\n    SccDfs(g, it->dest, visit, st);\n  }\n  st.push_back(from);\n}\n\nvector<vector<int> > Scc(const Graph &g) {\n  const int n = g.size();\n  vector<vector<int> > ret;\n  Graph revg(n);\n  for (int i = 0; i < n; i++) {\n    for (Edges::const_iterator it = g[i].begin(); it != g[i].end(); it++) {\n      revg[it->dest].push_back(Edge(it->dest, i, it->weight));\n    }\n  }\n  vector<int> st;\n  vector<int> visit(n, 0);\n  for (int i = 0; i < n; i++) {\n    if (visit[i]) { continue; }\n    SccDfs(g, i, visit, st);\n  }\n  visit = vector<int>(n, 0);\n  for (int i = n - 1; i >= 0; i--) {\n    int index = st[i];\n    if (visit[index]) { continue; }\n    vector<int> nret;\n    SccDfs(revg, index, visit, nret);\n    ret.push_back(nret);\n  }\n  return ret;\n}\n\n// select min weight edge\nGraph SccGraph(const Graph &g) {\n  vector<vector<int> > scc = Scc(g);\n  const int n = g.size();\n  const int m = scc.size();\n  vector<int> mapto(n);\n  for (int i = 0; i < (int)scc.size(); i++) {\n    for (int j = 0; j < (int)scc[i].size(); j++) {\n      mapto[scc[i][j]] = i;\n    }\n  }\n  Graph ret(m);\n  vector<int> indexs(m, -1);\n  for (int from = 0; from < m; from++) {\n    int e = 0;\n    for (int i = 0; i < (int)scc[from].size(); i++) {\n      for (Edges::const_iterator it = g[scc[from][i]].begin(); it != g[scc[from][i]].end(); it++) {\n        int to = mapto[it->dest];\n        if (from == to) { continue; } // loopback\n        if (indexs[to] == -1) {\n          ret[from].push_back(Edge(from, to, it->weight));\n          indexs[to] = e++;\n        } else {\n          // select edge\n          ret[from][indexs[to]].weight = min(ret[from][indexs[to]].weight, it->weight);\n        }\n      }\n    }\n    for (Edges::const_iterator it = ret[from].begin(); it != ret[from].end(); it++) {\n      indexs[it->dest] = -1;\n    }\n  }\n  return ret;\n}\n\nWeight Arborescence(const Graph &g, int root) {\n  const int n = g.size();\n  Weight ret = 0;\n  vector<Weight> inCost(n, 1e9);\n  vector<int> parent(n, -1);\n  for (int from = 0; from < n; from++) {\n    for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n      if (it->dest == from) { continue; }\n      if (it->weight < inCost[it->dest]) {\n        parent[it->dest] = from;\n        inCost[it->dest] = it->weight;\n      }\n      inCost[it->dest] = min(inCost[it->dest], it->weight);\n    }\n  }\n  Graph ng(n);\n  for (int i = 0; i < n; i++) {\n    if (i == root) { continue; }\n    if (parent[i] == -1) { return 1e9; }\n    ng[parent[i]].push_back(Edge(parent[i], i, 0));\n    ret += inCost[i];\n  }\n  vector<vector<int> > connect = Scc(ng);\n  int m = connect.size();\n  if (m == n) { return ret; }\n  vector<int> mapto(n, -1);\n  vector<int> cycle(n, 0);\n  ret = 0;\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < (int)connect[i].size(); j++) {\n      mapto[connect[i][j]] = i;\n      if (connect[i].size() != 1) {\n        cycle[connect[i][j]] = 1;\n        ret += inCost[connect[i][j]];\n      }\n    }\n  }\n  ng = Graph(m);\n  for (int from = 0; from < n; from++) {\n    for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n      int to = it->dest;\n      if (to == root || mapto[from] == mapto[to]) { continue; }\n      Weight cost = it->weight;\n      if (cycle[to]) {\n        cost -= inCost[to];\n      }\n      ng[mapto[from]].push_back(Edge(mapto[from], mapto[to], cost));\n    }\n  }\n  return min(1e9, (double)ret + Arborescence(ng, mapto[root]));\n}\n\n// p - r * q\ndouble ternary_search(int p, int q) {\n    double lo = -(1e9), hi = 1e9;\n    for (int i=0; i<100; ++i) {\n        double m1 = (2*lo + hi)/3, m2 = (lo + 2*hi)/3;\n        double n1 = 0.0, n2 = 0.0;\n        for (int j=0; j<N; ++j) {\n            n1 += (vec[p][j] - m1 * vec[q][j]) * (vec[p][j] - m1 * vec[q][j]);\n            n2 += (vec[p][j] - m2 * vec[q][j]) * (vec[p][j] - m2 * vec[q][j]);\n        }\n        if (n1 > n2) lo = m1;\n        else hi = m2;\n    }\n    double ret = 0;\n    for (int i=0; i<N; ++i)\n        ret += (vec[p][i] - lo * vec[q][i]) * (vec[p][i] - lo * vec[q][i]);\n    return ret;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i=0; i<M; ++i)\n        for (int j=0; j<N; ++j)\n            scanf(\"%lf\", &vec[i][j]);\n    for (int j=0; j<N; ++j)\n        vec[M][j] = 0.0;\n    M++;\n\n    Graph g(M);\n    vector<pair<double, pair<int,int> > > e;\n    for (int i=0; i<M; ++i)\n        for (int j=0; j<M; ++j) {\n            if (i == j) continue;\n            g[j].push_back(Edge(j, i, ternary_search(i, j)));\n            //dist[j][i] = ternary_search(i, j);\n        }\n\n    printf(\"%.20f\\n\", Arborescence(g, M-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<double> Point;\n\ndouble INF=1e9;\n\nstruct UnionFind{\n  vector<int> par,rank;\n  void init(int n){\n    par.clear();\n    rank.clear();\n    par.resize(n);\n    rank.resize(n);\n    for(int i=0;i<n;i++){\n      par[i]=i;\n      rank[i]=1;\n    }\n  }\n  \n  int find(int x){\n    if(x==par[x])return x;\n    return par[x]=find(par[x]);\n  }\n\n  bool same(int x,int y){\n    return ( find(x)==find(y) );\n  }\n  \n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])swap(x,y);\n    par[y]=x;\n    rank[x]+=rank[y];\n  }\n};\n\nstruct edge{\n  int from;\n  int to;\n  double cost;\n  int id;\n  edge(int from,int to,double cost,int id) :from(from), to(to),cost(cost),id(id) {}\n  bool operator < (const edge e)const{\n    return cost > e.cost;\n  }\n};\n\ntypedef priority_queue< edge > prque;\ntypedef prque* Prque;\n\ntypedef vector<edge> Node;\ntypedef vector<Node> Graph;\n\n\nPrque Merge(vector< Prque > &Q, vector<edge> &ev,int A,int C){\n  if( Q[C]->size() < Q[A]->size() ){\n\n    while( !Q[C]->empty() ){\n      edge e=Q[C]->top();\n      e.cost-=ev[C].cost;\n      e.cost+=ev[A].cost;\n      //      cout<<e.from<<' '<<e.to<<' '<<e.cost<<' '<<ev[A].cost<<' '<<ev[C].cost<<endl;\n      Q[A]->push(e);\n      Q[C]->pop();\n    }\n    ev[C].cost=ev[A].cost;\n    return Q[A];\n  }else{\n    while( !Q[A]->empty() ){\n      edge e=Q[A]->top();\n      e.cost-=ev[A].cost;\n      e.cost+=ev[C].cost;\n      //      cout<<e.from<<' '<<e.to<<' '<<e.cost<<endl;\n      Q[C]->push(e);\n      Q[A]->pop();\n    }\n    return Q[C];\n  }\n}\n\ndouble solve(Graph &G,vector<edge> &edges,int root){\n\n  int n=G.size();\n  double res=0;\n  \n  vector<int> used(n,0);\n  vector< edge > ev(n, (edge){0,0,0,-1} );\n  vector< prque > pool(n);\n  vector< Prque > Q(n);\n  for(int i=0;i<n;i++)Q[i]=&pool[i];\n  \n  UnionFind uf;\n  uf.init(n);\n  \n  for(int i=0;i<(int)edges.size();i++){\n    edge e=edges[i];\n    Q[ e.to ]->push( e );\n  }\n  \n  used[root]=2;\n  for(int Pos=0;Pos<n;Pos++){\n    if(used[Pos]==2)continue;\n    int pos=Pos;\n    vector<int> path;\n    \n    while( used[pos] != 2 ){\n      pos=uf.find(pos);\n      \n      used[pos]=1;\n      path.push_back(pos);\n      if( Q[pos]->empty() ){\n        return INF;\n      }\n      \n      edge e=Q[pos]->top();\n\n      \n      Q[pos]->pop();\n      e.cost-=ev[pos].cost;\n      if( uf.same(e.from,pos) ) continue;\n      int tmpcost=ev[pos].cost;\n      /*\n      cout<<\" pos=\"<<pos;\n      cout<<\" e.from=\"<<e.from;\n      cout<<\" e.to=\"<<e.to;\n      cout<<\" e.cost=\"<<e.cost;\n      cout<<\" tmpcost=\"<<tmpcost<<endl;\n      cout<<endl;\n      */\n      res+=e.cost;\n      e.cost+=tmpcost;\n      ev[pos]=e;\n      if( used[ uf.find(e.from) ] == 2 )break;\n      if( used[ uf.find(e.from) ] == 0 ){\n        pos=e.from;\n        continue;\n      }\n      int pre=uf.find(e.from);\n      for(int i=0;i<100;i++){\n        if(!uf.same(pre,pos)){\n          int A=uf.find(pre), B=uf.find(pos);\n          uf.unite(A,B);\n          int C=uf.find(A);\n          /*\n          cout<<\" !!A=\"<<A;\n          cout<<\" !!B=\"<<B;\n          cout<<\" !!C=\"<<C<<endl;\n          */\n          Prque tmp=NULL;\n          if(B==C)tmp=Merge(Q,ev,A,C);\n          else if(A==C)tmp=Merge(Q,ev,B,C);\n          else assert(0);\n          \n          Q[C]=tmp;\n        }\n        pre=uf.find(ev[pre].from);\n      }\n    }// while_pos\n\n    for(int i=0;i<(int)path.size();i++)used[ path[i] ]=2;\n  }// Pos\n  return res;\n}\n\n\nPoint add(Point a,Point b){\n  Point res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=a[i]+b[i];\n  return res;\n}\n\nPoint sub(Point a,Point b){\n  Point res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=a[i]-b[i];\n  return res;\n}\n\ndouble dot(Point a,Point b){\n  double res=0;\n  for(int i=0;i<(int)a.size();i++)\n    res+=a[i]*b[i];\n  return res;\n}\n\ndouble norm(Point p){\n  return  dot(p,p);\n}\n\nPoint project(Point a,Point b,Point p){\n  Point base( a.size() );\n  Point target( a.size() );\n  for(int i=0;i<(int)a.size();i++){\n    base[i]=b[i]-a[i];\n    target[i]=p[i]-a[i];\n  }\n  double t=dot(base,target);\n  Point res=a;\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=res[i]+base[i]*t/norm(base);\n  return res;\n}\n\n\nint main(){\n  int n,m;\n  vector< Point > t;\n  \n  cin>>m>>n;\n  for(int i=0;i<n;i++){\n    Point a(m);\n    for(int j=0;j<m;j++){\n      cin>>a[j];\n    }\n    t.push_back(a);\n  }\n\n  Point cen( m , 0 );\n  \n  Graph G;\n  G.resize(n+1);\n  int cc=0;\n  for(int i=0;i<n;i++){\n    G[n].push_back( edge(n,i, (norm(t[i])) , cc++) );\n    \n    \n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      \n      Point pp = project( t[j] , add(t[j],t[i]) , cen);\n      double cost= norm( pp);\n      G[i].push_back( edge(i,j,cost,cc++) );\n\n      //      cout<<i<<' '<<j<<' '<< cost << ' ' <<pp[0]<<' '<<pp[1]<<endl;\n    }\n  }\n\n  vector<edge> edges;\n  for(int i=0;i<=n;i++)\n    for(int j=0;j<(int)G[i].size();j++)\n      edges.push_back(G[i][j]);\n  \n  printf(\"%.10f\\n\", solve(G,edges,n) );\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// (重み, u->v)\nusing Edge = pair<double,pair<int,int>>;\n\nconst double INF = 19191919;\n\n// 辺集合, 頂点数, 根\ndouble Chu_Liu_Edmonds(const vector<Edge> es, int V, int root){\n    // 頂点iに入ってくる辺(u->i)の中で、最小のコストの辺を管理 (コスト, u)\n    vector<pair<double,int>> mn(V, {INF,-1});\n    for(Edge e:es){\n        int u = e.se.fi, v = e.se.se;\n        mn[v] = min(mn[v], {e.fi, u});\n    }\n    mn[root] = {0,-1};\n\n    // 連結成分に分ける(1つの閉路に対して1つの番号を与える)\n    vector<int> cmp(V);\n    // この連結成分が閉路であるか\n    vector<bool> cycle(V,false);\n    int cc = 0;\n\n    vector<bool> vis(V);\n    rep(i,V){\n        if(vis[i]) continue;\n\n        vector<int> path;\n        int now = i;\n\n        while(now!=-1 && !vis[now]){\n            vis[now] = true;\n            path.pb(now);\n\n            // 今張っている辺を逆方向にたどる\n            now = mn[now].se;\n        }\n\n        if(now != -1){\n            bool in_cycle = false;\n            for(int j:path){\n                cmp[j] = cc;\n                if(j == now){\n                    // 閉路の始点(これ以降のpathに入ってる頂点が閉路をなす)\n                    in_cycle = true;\n                    cycle[cc] = true;\n                }\n\n                if(!in_cycle) ++cc;\n            }\n            if(in_cycle) ++cc;\n        }\n        else{\n            // 閉路なし\n            for(int j:path) cmp[j] = cc++;\n        }\n    }\n\n    if(cc == V){\n        // すべての頂点が違う連結成分に分かれたので 閉路なし\n        double ans = 0;\n        rep(i,V) ans += mn[i].fi;\n        return ans;\n    }\n\n    // 閉路分のコスト\n    double cycle_cost = 0;\n    rep(i,V){\n        if(i!=root && cycle[cmp[i]]) cycle_cost += mn[i].fi;\n    }\n\n    // コストを再設定\n    vector<Edge> nes;\n    for(Edge e:es){\n        int u = e.se.fi, v = e.se.se;\n        int cu = cmp[u], cv = cmp[v];\n\n        if(cu == cv){\n            // 閉路内の辺は無視\n            continue;\n        }\n        else if(cycle[cv]){\n            // コストを再設定\n            nes.pb({e.fi - mn[v].fi, {cu,cv}});\n        }\n        else{\n            nes.pb({e.fi, {cu,cv}});\n        }\n    }\n\n    return cycle_cost + Chu_Liu_Edmonds(nes, cc, cmp[root]);\n};\n\ndouble size(const vector<double> &v){\n    int n = v.size();\n    double ret = 0;\n    rep(i,n) ret += v[i]*v[i];\n    return ret;\n}\n\nvector<double> getv(const vector<double> &v, const vector<double> &u, double r){\n    int n = v.size();\n    vector<double> ret(n);\n    rep(i,n) ret[i] = v[i]+u[i]*r;\n    return ret;\n}\n\nconst double LIM = 100;\ndouble calc(const vector<double> &v, const vector<double> &u){\n    int n = v.size();\n\n    double l=-LIM, r=LIM;\n    rep(loop,60){\n        double m1 = (2*l+r)/3, m2 = (l+2*r)/3;\n        if(size(getv(v,u,m1)) < size(getv(v,u,m2))) r = m2;\n        else l = m1;\n    }\n\n    return size(getv(v,u,r));\n}\n\nint main(){\n    int n,m;\n    cin >>n >>m;\n\n    vector<vector<double>> v(m);\n    rep(i,m){\n        vector<double> tmp(n);\n        rep(j,n) cin >>tmp[j];\n        v[i] = tmp;\n    }\n\n    vector<Edge> Es;\n    rep(i,m)rep(j,m)if(i!=j){\n        Es.pb({calc(v[j],v[i]),{i,j}});\n        // printf(\" %d %d  -> %f\\n\",i,j,calc(v[j],v[i]));\n    }\n\n    double ans = INF;\n    rep(i,m){\n        double res = Chu_Liu_Edmonds(Es,m,i);\n        ans = min(ans, size(v[i])+res);\n        // printf(\"  %d::  %f\\n\",i,res);\n    }\n    printf(\"%.10f\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <map>\n#include <climits>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned UI;\ntypedef pair<int, int> PAIR;\n \nconst int MAXN(110);\nconst int MAXE(11000);\nconst int MAXK(100010);\nconst int MAXL(10);\nconst int MAXC(2);\nconst int INF((INT_MAX - 1) / 2);\nconst int F(0);\n\ntemplate<typename T>\ninline bool checkmax(T &a, const T &b) {\n\treturn b > a ? ((a = b), true) : false;\n}\n\ntemplate<typename T>\ninline bool checkmin(T &a, const T &b) {\n\treturn b < a ? ((a = b), true) : false;\n}\n\ntemplate<typename T>\ninline T ABS(T a) {\n\treturn a < 0 ? -a : a;\n}\n\ndouble dis(double x1, double y1, double x2, double y2) {\n\treturn sqrt((y2 - y1)*(y2 - y1) + (x2 - x1)*(x2 - x1));\n}\n\ndouble dis2(double x1, double y1, double x2, double y2) {\n\treturn (y2 - y1)*(y2 - y1) + (x2 - x1)*(x2 - x1);\n}\n\nint dcmp(double a, double b) {\n\tif (ABS(b - a) < 1e-8) return 0;\n\treturn a < b ? -1 : 1;\n}\n\nstruct E {\n\tint u, v;\n\tdouble w;\n\tE(int u_, int v_, double w_) :u(u_), v(v_), w(w_) {}\n\tE() {}\n\tfriend bool operator <(const E &a, const E &b) {\n\t\treturn a.w == b.w ? (a.u == b.u ? a.v < b.v : a.u < b.u) : a.w < b.w;\n\t}\n};\n\nint pre[MAXN];\nbool vis[MAXN];\nint myHash[MAXN];\n\ndouble DMST(int n, int rt, int en, E *e) { //可以?理平行?，自?，和指向rt的?；但?了效率考?，最好提前?理掉?些?\n\tdouble ret = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; ++i) pre[i] = -1;\n\t\tfor (int i = 0; i < en; ++i) {\n\t\t\tif (e[i].u == e[i].v || e[i].v == rt) continue;\n\t\t\tint v = e[i].v;\n\t\t\tif (pre[v] == -1 || e[i].w < e[pre[v]].w)\n\t\t\t\tpre[v] = i;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tvis[i] = false;\n\t\t\tmyHash[i] = -1;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == rt) continue;\n\t\t\tret += e[pre[i]].w;\n\t\t\tif (vis[i]) continue;\n\t\t\tint u = i;\n\t\t\twhile (u != rt && !vis[u]) {\n\t\t\t\tvis[u] = true;\n\t\t\t\tu = e[pre[u]].u;\n\t\t\t}\n\t\t\tif (u == i) {\n\t\t\t\tdo {\n\t\t\t\t\tmyHash[u] = cnt;\n\t\t\t\t\tu = e[pre[u]].u;\n\t\t\t\t} while (u != i);\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (myHash[i] != -1) continue;\n\t\t\tmyHash[i] = cnt++;\n\t\t}\n\t\tif (cnt == n) return ret;\n\t\tfor (int i = 0; i < en; ++i) {\n\t\t\tif (e[i].v == rt) continue;\n\t\t\te[i].w -= e[pre[e[i].v]].w;\n\t\t\te[i].u = myHash[e[i].u];\n\t\t\te[i].v = myHash[e[i].v];\n\t\t}\n\t\trt = myHash[rt];\n\t\tn = cnt;\n\t}\n}\n\nE edge[MAXE];\nint en;\n\ndouble dat[110][110];\ndouble squSum[110];\n\ndouble calCost(int u, int v, int dim) {\n\tswap(u, v);\n\tdouble a = squSum[v], b = 0, c = squSum[u];\n\tfor (int i = 0; i < dim; ++i) b += dat[u][i] * dat[v][i];\n\tdouble x = b/a;\n\tb *= -2;\n\treturn a*x*x + b*x + c;\n}\n\nint main() {\n\tint dim, n;\n\tscanf(\"%d%d\", &dim, &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < dim; ++j)\n\t\t\tscanf(\"%lf\", dat[i] + j);\n\tfor (int i = 0; i < n; ++i) {\n\t\tsquSum[i] = 0;\n\t\tfor (int j = 0; j < dim; ++j)\n\t\t\tsquSum[i] += dat[i][j] * dat[i][j];\n\t}\n\ten = 0;\n\tfor (int i = 0; i < n; ++i) edge[en++] = E(n, i, squSum[i]);\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (i == j) continue;\n\t\t\tedge[en++] = E(i, j, calCost(i, j, dim));\n\t\t}\n\tprintf(\"%.8f\\n\", DMST(n + 1, n, en, edge));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef double Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\n//aoj2309???varify??????????????£??????????????§????????????????????????\npair<Weight,Graph> chu_liu(const Graph&g, const int start,const int e_size) {\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(e_size);\n\tGraph tree(g.size());\n\tld total_len = 0;\n\t{\n\t\tGraph revg(g.size());\n\n\n\t\tfor (auto es : g) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tmemo[e.id] = e;\n\t\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t\t}\n\t\t}\n\t\tfor (int node = 0; node < g.size(); ++node) {\n\t\t\tif (node == start)continue;\n\t\t\telse {\n\t\t\t\tWeight amin = INF;\n\t\t\t\tEdge min_edge;\n\t\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\t\tmin_edge = Edge(reve.dst, reve.src, reve.weight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amin < INF) {\n\t\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\t\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(e_size);\n\n\t\tvector<Weight>prev_lens(g.size(), ZERO);\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tprev_lens[ce.dst] = ce.weight;\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tint ne_size = 0;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prev_lens[e.dst], e.id));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start, e_size);\n\t\tGraph compress_tree(p.second);\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tconst Edge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tWeight cycle_len = 0;\n\t\tfor (auto e : cycle_edges) {\n\t\t\tcycle_len += e.weight;\n\t\t}\n\t\treturn make_pair(p.first + cycle_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start,(g.size())*((g.size()+1)));\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define N 105\n#define eps 1e-8\n#define INF 1e30\n\ninline double sqr(double x) {\n    return x * x;\n}\n\nint n, m;\ndouble a[N][N], b[N][N], d[N][N];\n\ndouble gao(int p, int q) {\n    double s1 = 0, s2 = 0;\n    for (int i = 1; i <= m; ++i) {\n        s1 += a[p][i] * a[q][i];\n        s2 += sqr(a[q][i]);\n    }\n    if (abs(s2) < eps) {\n        double s = 0;\n        for (int i = 1; i <= m; ++i)\n            s += sqr(a[p][i]);\n        return s;\n    }\n    double k = s1 / s2;\n    double ret = 0;\n    for (int i = 1; i <= m; ++i)\n        ret += sqr(k * a[q][i] - a[p][i]);\n    return ret;\n}\n\ndouble f[N];\nbool vis[N];\ndouble g[N][N];\n\nint pre[N];\nbool del[N], vst[N];\ndouble solve(int v) {\n    double res = 0;\n    int num = n;\n    memset(del, false, sizeof(del));\n    while(1) {\n        int i;\n        //æ´æ°preæ°ç»\n        for (i = 1; i <= n; ++i) {\n            if (del[i] || i == v) continue;\n            pre[i] = i;\n            g[i][i] = INF;\n            for (int j = 1; j <= n; ++j) {\n                if (del[j]) continue;\n                if (g[j][i] < g[pre[i]][i])\n                    pre[i] = j;\n            }\n        }\n        for (i = 1; i <= n; ++i) {\n            //æ¾ç¯\n            if (del[i] || i == v) continue;\n            int j = i;\n            memset(vst, 0, sizeof(vst));\n            while (!vst[j] && j != v) {\n                vst[j] = true;\n                j = pre[j];\n            }\n            if (j == v) continue;\n            i = j;\n            //æ´æ°resï¼æåç¯ç¼©ç¹\n            res += g[pre[i]][i];\n            for(j = pre[i]; j != i; j = pre[j]) {\n                res += g[pre[j]][j];\n                del[j] = true;\n            }\n            for(j = 1; j <= n; ++j) {\n                if(del[j]) continue;\n                if(g[j][i] != INF)\n                    g[j][i] -= g[pre[i]][i];\n            }\n            //æ´æ°ç¼©ç¹ä»¥åçæåç¯åå¶ä»ç¹çè¾¹æ\n            for(j = pre[i]; j != i; j = pre[j]) {\n                for(int k = 1; k <= n; ++k) {\n                    if(del[k])continue;\n                    g[i][k] = min(g[i][k], g[j][k]);\n                    if(g[k][j] != INF)\n                        g[k][i] = min(g[k][i], g[k][j] - g[pre[j]][j]);\n                }\n            }\n            //å®æç¼©ç¹\n            for(j = pre[i]; j != i; j = pre[j]) {\n                del[j] = true;\n            }\n            break;\n        }\n        //ä¸å­å¨æåç¯æ¶ï¼åæ­¢å¾ªç¯ï¼å¾åºresæç»å¼\n        if(i > n) {\n            for(int i = 1; i <= n; ++i) {\n                if(del[i] || i == v) continue;\n                res += g[pre[i]][i];\n            }\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    scanf(\"%d %d\", &m, &n);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= m; ++j)\n            scanf(\"%lf\", &a[i][j]);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            d[i][j] = gao(j, i);\n    double ans = INF;/*\n    for (int i = 1; i <= n; ++i, puts(\"\"))\n        for (int j = 1; j <= n; ++j)\n            printf(\" %.3f\", d[i][j]);*/\n    for (int i = 1; i <= n; ++i) {\n        double s = 0;\n        for (int j = 1; j <= m; ++j)\n            s += sqr(a[i][j]);\n        for (int j = 1; j <= n; ++j)\n            memcpy(g[j], d[j], sizeof(d[j]));\n        ans = min(ans, s + solve(i));\n    }\n    printf(\"%.8f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"cstring\"\n#include \"cstdio\"\n#include \"cmath\"\nusing namespace std;\nconst double INF = 1E10;\nconst double eps = 1e-8;\nconst int N = 110;\ndouble d[N], g[N][N], a[N][N];\nint pre[N], flag[N], mark[N];\nint visit[N];\ndouble sqr(double x){return x * x;}\ndouble gao(int x, int y, int n)\n{\n\tdouble va = 0, vb = 0, vc = 0;\n\tfor(int i = 1; i <= n; ++ i){\n\t\tva += sqr(a[x][i]);\n\t\tvc += sqr(a[y][i]);\n\t\tvb += -2.0 * a[x][i] * a[y][i];\n\t}\n\tif(fabs(va) < eps) return INF;\n\treturn (4.0 * va * vc - vb * vb) / (4.0 * va);\n}\n\ndouble ZhuLiu(int root, int n)\n{\n\tint i, j, k;\n\tdouble res = 0;\n\tmemset(flag, 0, sizeof(flag));\n\twhile(1){\n\t\tfor(i = 1; i <= n; ++ i){\n\t\t\tif(flag[i] || i == root) continue;\n\t\t\tpre[i] = i;\n\t\t\tg[i][i] = INF;\n\t\t\tfor(j = 1; j <= n; ++ j){\n\t\t\t\tif(!flag[j] && g[j][i] < g[pre[i]][i])\n\t\t\t\t\tpre[i] = j;\n\t\t\t}\n\t\t}\n\t\tfor(i = 1; i <= n; ++ i){\n\t\t\tif(flag[i] || i == root) continue;\n\t\t\tmemset(mark, 0, sizeof(mark));\n\t\t\tmark[root] = 1;\n\t\t\tj = i;\n\t\t\tdo{\n\t\t\t\tmark[j] = 1;\n\t\t\t\tj = pre[j];\n\t\t\t}while(!mark[j]);\n\t\t\tif(j == root) continue;\n\t\t\ti = j;\n\t\t\tres += g[pre[i]][i];\n\t\t\tfor(j = pre[i]; j != i; j = pre[j]){\n\t\t\t\tflag[j] = 1;\n\t\t\t\tres += g[pre[j]][j];\n\t\t\t}\n\t\t\tfor(j = 1; j <= n; ++ j){\n\t\t\t\tif(!flag[j] && g[j][i] < INF){\n\t\t\t\t\tg[j][i] -= g[pre[i]][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j = pre[i]; j != i; j = pre[j]){\n\t\t\t\tfor(k = 1; k <= n; ++ k){\n\t\t\t\t\tif(!flag[k]){\n\t\t\t\t\t\tg[i][k] = min(g[i][k], g[j][k]);\n\t\t\t\t\t\tif(g[k][j] < INF){\n\t\t\t\t\t\t\tg[k][i] = min(g[k][i], g[k][j] - g[pre[j]][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(i > n){\n\t\t\tfor(j = 1; j <= n; ++ j){\n\t\t\t\tif(!flag[j] && j != root){\n\t\t\t\t\tres += g[pre[j]][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\nint main(void)\n{\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m + 1; ++ i){\n\t\tfor(int j = 1; j <= m + 1; ++ j){\n\t\t\tg[i][j] = INF;\n\t\t}\n\t}\t\n\tfor(int i = 1; i <= m; ++ i){\n\t\tg[m + 1][i] = 0;\n\t}\n\tfor(int i = 1; i <= m; ++ i){\n\t\tfor(int j = 1; j <= n; ++ j){\n\t\t\tscanf(\"%lf\", &a[i][j]);\n\t\t\tg[m + 1][i] += sqr(a[i][j]);\n\t\t}\n\t}\n\tfor(int i = 1; i <= m; ++ i){\n\t\tfor(int j = 1; j <= m; ++ j){\n\t\t\tif(i == j) continue;\n\t\t\tg[i][j] = gao(i, j, n);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", ZhuLiu(m + 1, m + 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repf(i, a, b) for (int i = (a); i <= (b); ++i)\nconst int maxint = -1u>>1;\n\n#define sqr(x) ((x) * (x))\n\nconst double inf = 1e20;\n    \nint n, m;\ndouble g[111][111];\nint pre[111], id[111], mark[111], st[111], top, lft;\ndouble cost[111];\nbool v[111];\n\nbool find_circle() {\n    fill (v, v + n, false);\n    for (int i = 1; i < n; ++i) {\n        if (id[i] != i || v[i]) {\n            continue;\n        }\n        fill (mark, mark + n, -1);\n        top = 0;\n        int temp = i;\n        while (temp != 0 && mark[temp] == -1 && !v[temp]) {\n            v[temp] = true;\n            mark[temp] = top;\n            st[top++] = temp;\n            temp = pre[temp];\n            //printf (\"temp here %d\\n\", temp);\n        }\n        //printf (\"temp %d mark %d\\n\", temp, mark[temp]);\n        if (mark[temp] != -1) {\n            lft = mark[temp];\n            return true;\n        }\n    }\n    return false;\n}\n\ndouble combine() {\n    double res = 0.0;\n    int now = st[lft];\n    for (int i = lft; i < top; ++i) {\n        int temp = st[i];\n        res += cost[temp];\n        id[temp] = now;\n        for (int j = 0; j < n; ++j) {\n            if (g[j][temp] != -1) {\n                double tcost = g[j][temp] - cost[temp];\n                if (g[j][now] == -1 || tcost < g[j][now])\n                    g[j][now] = tcost;\n            }\n            if ((g[temp][j] != -1 && g[temp][j] < g[now][j]) || g[now][j] == -1) {\n                g[now][j] = g[temp][j];\n            }\n        }\n    }\n    cost[now] = inf;\n    for (int i = 1; i < n; ++i) {\n        if (id[i] == i) {\n            pre[i] = id[pre[i]];\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (i != now && id[i] == i && g[i][now] != -1 && g[i][now] < cost[now]) {\n            pre[now] = i, cost[now] = g[i][now];\n        }\n    }\n    return res;\n}\n\ndouble gao() {\n    id[0] = 0;\n    repf (i, 1, n - 1) {\n        id[i] = i;\n        cost[i] = inf;\n        for (int j = 0; j < n; ++j) {\n            if (i != j && g[j][i] != -1 && g[j][i] < cost[i]) {\n                cost[i] = g[j][i];\n                pre[i] = j;\n            }\n        }\n    }\n    double ans = 0;\n    while (find_circle()) ans += combine();\n    repf (i, 1, n - 1) {\n        if (id[i] == i) {\n            ans += cost[i];\n        }\n    }\n    return ans;\n}\n\ndouble a[111][111], len[111];\n\nint main() {\n    while (scanf (\"%d%d\", &n, &m) != EOF) {\n        rep (i, m) {\n            len[i] = 0;\n            rep (j, n) {\n                scanf (\"%lf\", &a[i][j]);\n                len[i] += a[i][j] * a[i][j];\n            }\n            len[i] = sqrt(len[i]);\n        }\n        rep (i, m) {\n            rep (j, m) {\n                if (i == j) continue;\n                double now = 0.0;\n                rep (k, n) {\n                    now += a[i][k] * a[j][k];\n                }\n                now /= len[i] * len[j];\n                now = sqrt (1.0 - now * now);\n                g[j + 1][i + 1] = sqr(len[i] * now);\n            }\n            g[0][i + 1] = sqr(len[i]);\n            g[i + 1][0] = -1;\n            g[i + 1][i + 1] = -1;\n        }\n        g[0][0] = -1;\n        n = m + 1;\n        printf (\"%.8lf\\n\", gao());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\ndouble size(const vector<double> &v){\n    int n = v.size();\n    double ret = 0;\n    rep(i,n) ret += v[i]*v[i];\n    return ret;\n}\n\nvector<double> getv(const vector<double> &v, const vector<double> &u, double r){\n    int n = v.size();\n    vector<double> ret(n);\n    rep(i,n) ret[i] = v[i]+u[i]*r;\n    return ret;\n}\n\nconst double LIM = 3;\ndouble calc(const vector<double> &v, const vector<double> &u){\n    int n = v.size();\n\n    double l=-LIM, r=LIM;\n    rep(loop,40){\n        double m1 = (2*l+r)/3, m2 = (l+2*r)/3;\n        if(size(getv(v,u,m1)) < size(getv(v,u,m2))) r = m2;\n        else l = m1;\n    }\n\n    return size(getv(v,u,r));\n}\n\nbool comp(const vector<double> &v, const vector<double> &u){\n    return size(v) + calc(v,u) < size(u) + calc(u,v);\n}\n\nint main(){\n    int n,m;\n    cin >>n >>m;\n\n    vector<vector<double>> v(m);\n    rep(i,m){\n        vector<double> tmp(n);\n        rep(j,n) cin >>tmp[j];\n        v[i] = tmp;\n    }\n\n    sort(all(v), comp);\n\n    double ans = 0;\n    rep(i,m){\n        double add = size(v[i]);\n        rep(j,i) add = min(add, calc(v[i],v[j]));\n        ans += add;\n    }\n    printf(\"%.10f\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\ntypedef ld Weight;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nconst Weight INF = 1e18;\nconst Weight ZERO = 0;\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nld getdis(const vector<ld>&f, const vector<ld>&t) {\n\tld amin = -1e9;\n\tld amax = 1e9;\n\tint n = 100;\n\twhile (n--) {\n\t\tld amid0 = (amin*2 + amax) /3;\n\t\tld amid1 = (amin + amax * 2) / 3;\n\t\tld len0 = 0;\n\t\tld len1 = 0;\n\t\t{\n\t\t\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen0 += (t[i] - amid0*f[i])*(t[i] - amid0*f[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.size(); ++i) {\n\t\t\t\tlen1 += (t[i] - amid1*f[i])*(t[i] - amid1*f[i]);\n\t\t\t}\n\t\t}\n\t\tif (len0<len1) {\n\t\t\tamax = amid1;\n\t\t}\n\t\telse {\n\t\t\tamin = amid0;\n\t\t}\n\t\tif (!n)return len0;\n\t}\n}\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nnamespace getcycle {\n\tpair<int,vector<Edge>> dfs(const Graph&g,vector<int>&used,const int now,const int id) {\n\t\tif (used[now]==-1) {\n\t\t\tused[now] = id;\n\t\t\tfor (auto e : g[now]) {\n\t\t\t\tif (used[e.dst] ==id) {\n\t\t\t\t\treturn make_pair(e.dst, vector<Edge>(1, e));\n\t\t\t\t}else if (used[e.dst]!=-1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(used[e.dst] == -1);\n\t\t\t\t\tauto p(dfs(g, used, e.dst,id));\n\t\t\t\t\tif (p.first == -1) {\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p.first == -2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.second.push_back(e);\n\t\t\t\t\t\tif (p.first == now) {\n\t\t\t\t\t\t\treturn make_pair(-1, p.second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn make_pair(-2, vector<Edge>(0));\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn make_pair(0,vector<Edge>(0));\n\t\t}\n\t}\n\tvector<Edge>get_cycle(const Graph&g,const int start) {\n\t\tvector<int>used(g.size(),-1);\n\t\t\n\t\tint id = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (used[i]==-1) {\n\t\t\t\t\n\t\t\t\tvector<Edge>cycles = dfs(g, used, i,id).second;\n\t\t\t\tid++;\n\t\t\t\tif (!cycles.empty()) {\n\n\t\t\t\t\treverse(cycles.begin(), cycles.end());\n\t\t\t\t\treturn cycles;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector<Edge>(0);\n\t}\n}\n\nconst int E_SIZE = 10010;\npair<Weight,Graph> chu_liu(const Graph&g, const int start) {\n\tGraph revg(g.size());\n\n\t/*????´???°???Edge?????°????????§??????*/\n\tvector<Edge>memo(g.size()*g.size());\n\tfor (auto es : g) {\n\t\tfor (auto e : es) {\n\t\t\tmemo[e.id] = e;\n\t\t\trevg[e.dst].emplace_back(e.dst, e.src, e.weight);\n\t\t}\n\t}\n\tGraph tree(g.size());\n\tld total_len = 0;\n\tfor (int node = 0; node < g.size(); ++node) {\n\t\tif (node == start)continue;\n\t\telse {\n\t\t\tWeight amin = INF;\n\t\t\tEdge min_edge;\n\t\t\tfor (auto reve : revg[node]) {\n\t\t\t\tif (amin > reve.weight) {\n\t\t\t\t\tamin = reve.weight;\n\t\t\t\t\tmin_edge = Edge(reve.dst,reve.src, reve.weight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (amin < INF) {\n\t\t\t\ttotal_len += min_edge.weight;\n\t\t\t\ttree[min_edge.src].emplace_back(min_edge);\n\t\t\t}\n\t\t}\n\t}\n\tWeight cycle_len = 0;\n\tvector<Edge>cycle_edges(getcycle::get_cycle(tree, start));\n\tfor (auto e : cycle_edges) {\n\t\tcycle_len += e.weight;\n\t}\n\tif (cycle_edges.empty()) {\n\t\treturn make_pair(total_len,g);\n\t}\n\telse {\n\t\tvector<bool>node_is_cycle(g.size());\n\n\t\t/*????´???°???Edge?????°????????§??????*/\n\t\tvector<int>edge_is_cycle(g.size()*g.size());\n\n\t\tvector<pair<int,Weight>>prevs(g.size(), make_pair(-1,ZERO));\n\t\t\n\t\tfor (auto ce : cycle_edges) {\n\t\t\tnode_is_cycle[ce.src] = true;\n\t\t\tnode_is_cycle[ce.dst] = true;\n\t\t\tprevs[ce.dst] = make_pair(ce.src, ce.weight);\n\t\t}\n\t\tGraph newg(g.size());\n\t\tconst int compress = cycle_edges[0].src;\n\t\tfor (int s = 0; s < g.size();++s){\n\t\t\tbool src_is_cycle = node_is_cycle[s];\n\t\t\tfor (auto e : g[s]) {\n\t\t\t\tbool dst_is_cycle = node_is_cycle[e.dst];\n\t\t\t\tif (src_is_cycle&&dst_is_cycle) {\n\t\t\t\t}\n\t\t\t\telse if (src_is_cycle) {\n\t\t\t\t\tnewg[compress].push_back(Edge(compress, e.dst, e.weight, e.id));\n\t\t\t\t}\n\t\t\t\telse if (dst_is_cycle) {\n\t\t\t\t\tnewg[s].push_back(Edge(s, compress, e.weight-prevs[e.dst].second, e.id));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewg[s].push_back(Edge(s, e.dst, e.weight, e.id));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto p=chu_liu(newg, start);\n\t\tGraph compress_tree(g.size());\n\t\tGraph ans_tree(g.size());\n\t\tfor (auto es : compress_tree) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tEdge prev_edge(memo[e.id]);\n\t\t\t\tans_tree[prev_edge.src].emplace_back(prev_edge);\n\t\t\t}\n\t\t}\n\t\tld fin_len = p.first + cycle_len;\n\t\treturn make_pair(fin_len, ans_tree);\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>vecs(M,vector<ld>(N));\n\tvector<vector<ld>>edges(M, vector<ld > (M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> vecs[i][j];\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int node = 1;\n\tGraph g(M+1);\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld inidis = 0;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tinidis += vecs[i][j] * vecs[i][j];\n\t\t}\n\t\tg[start].emplace_back(start, node + i, inidis,id++);\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tld dis = getdis(vecs[i], vecs[j]);\n\t\t\t\tg[node + i].emplace_back(node + i, node + j, dis, id++);\n\t\t\t}\n\t\t}\n\t}\n\tauto p=chu_liu(g, start);\n\tcout <<fixed<<setprecision(22)<< p.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\ndouble c[110][110];\ndouble g[210][210];\nint rev[210];\nint v[210];\nint w[210];\nint u[210];\ndouble eps=1e-9;\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tscanf(\"%lf\",&c[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<210;i++)\n\t\tfor(int j=0;j<210;j++)\n\t\t\tg[i][j]=999999999;\n\tint s=b;\n\tfor(int i=0;i<b;i++){\n\t\tdouble dist=0;\n\t\tfor(int j=0;j<a;j++)dist+=c[i][j]*c[i][j];\n\t\tg[s][i]=dist;\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(i==j)continue;\n\t\t\tdouble L=-99999999;\n\t\t\tdouble R=99999999;\n\t\t\tfor(int k=0;k<100;k++){\n\t\t\t\tdouble m1=(L*2+R)/3;\n\t\t\t\tdouble m2=(L+R*2)/3;\n\t\t\t\tdouble d1=0;\n\t\t\t\tdouble d2=0;\n\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\td1+=(c[i][l]*m1-c[j][l])*(c[i][l]*m1-c[j][l]);\n\t\t\t\t\td2+=(c[i][l]*m2-c[j][l])*(c[i][l]*m2-c[j][l]);\n\t\t\t\t}\n\t\t\t\tg[i][j]=min(g[i][j],min(d1,d2));\n\t\t\t\tif(d1<d2)R=m2;\n\t\t\t\telse L=m1;\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ret=0;\n\tint sz=b+1;\n\tint rt=b;\n//\t\tfor(int i=0;i<sz;i++){\n//\t\tfor(int j=0;j<sz;j++)printf(\"%f \",g[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\twhile(1){\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tif(v[i])continue;\n\t\t\tif(rt==i)continue;\n\t\t\trev[i]=-1;\n\t//\t\tprintf(\"%d\\n\",i);\n\t\t\tfor(int j=0;j<sz;j++){\n\t\t\t\tif(v[j])continue;\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(!~rev[i]||g[rev[i]][i]>g[j][i])rev[i]=j;\n\t\t\t}\n\t\t\t\n\t\t\tif(!u[i])ret+=g[rev[i]][i];\n\t\t\tu[i]=1;\n\t\t}\n\t//\tfor(int i=0;i<sz;i++)printf(\"%d \",rev[i]);printf(\"\\n\");\n\t\tif(sz>6)return 0;\n\t\tfor(int i=0;i<210;i++)w[i]=0;\n\t\tint cnt=0;\n\t\tint SZ=sz;\n\t\tfor(int i=0;i<SZ;i++){\n\t\t\tif(v[i])continue;\n\t\t\tif(w[i])continue;\n\t\t\tif(i==rt)continue;\n\t\t\tint at=i;\n\t\t\twhile(1){\n\t\t\t\tif(w[at]==2){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tvector<int>vs;\n\t\t\t\t\tint a2=at;\n\t\t\t\t\tif(w[rt]==2)rt=sz;\n\t\t\t\t\twhile(1){\n\t\t\t\t\t\tif(w[a2]==1)break;\n\t\t\t\t\t\tvs.push_back(a2);\n\t\t\t\t\t\tw[a2]=1;v[a2]=1;\n\t\t\t\t\t\ta2=rev[a2];\n\t\t\t\t\t}\n\t\t\t\t//\tprintf(\"{\");\n\t\t\t\t\tfor(int j=0;j<vs.size();j++){\n\t\t\t\t//\t\tprintf(\"%d,\",vs[j]);\n\t\t\t\t\t\tfor(int k=0;k<sz;k++){\n\t\t\t\t\t\t\tif(g[vs[j]][k]<999999)g[sz][k]=min(g[sz][k],g[vs[j]][k]);\n\t\t\t\t\t\t\tif(g[k][vs[j]]<999999)g[k][sz]=min(g[k][sz],g[k][vs[j]]-g[rev[vs[j]]][vs[j]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}//printf(\"}\\n\");\n\t\t\t\t\tsz++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(w[at]==1)break;\n\t\t\t\tif(at==rt)break;\n\t\t\t\tw[at]=2;\n\t\t\t\tat=rev[at];\n\t\t\t}\n\t\t\tat=i;\n\t\t\twhile(1){\n\t\t\t\tif(w[at]==1)break;\n\t\t\t\tif(at==rt)break;\n\t\t\t\tw[at]=1;\n\t\t\t\tat=rev[at];\n\t\t\t}\n\t\t}\n\t\tif(!cnt)break;\n\t}\n\tprintf(\"%f\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\nstruct Edge\n{\n\tint u,v;\n\tdouble w;\n};\nEdge edge[20010];\ndouble cost[20010];\nint pre[20010],vst[20010],id[20010];\ndouble inf = 1e60;\ndouble a[110][110],sum[110];\ndouble g[110][110],g2[110][110];\nint M,root,N;\ndouble cal()\n{\n\tdouble ans=0;\n\twhile(1){\n\t\tfor(int i=0;i<N;i++)\n\t\t\tcost[i]=inf;\n\t\tfor(int i=0;i<M;i++)\n\t\t\tif(edge[i].u!=edge[i].v&&cost[edge[i].v]>edge[i].w){\n\t\t\t\tcost[edge[i].v]=edge[i].w;\n\t\t\t\tpre[edge[i].v]=edge[i].u;\n\t\t\t}\n\t\t/*for(int i=0;i<n;i++)\n\t\t\tif(i!=root&&cost[i]==inf)\n\t\t\t\treturn -1;*/\n\t\tint cnt=0;\n\t\tmemset(vst,-1,sizeof(vst));\n\t\tmemset(id,-1,sizeof(id));\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(i==root)\n\t\t\t\tcontinue;\n\t\t\tans+=cost[i];\n\t\t\tint u=i;\n\t\t\twhile(u!=root&&id[u]==-1&&vst[u]!=i){\n\t\t\t\tvst[u]=i;\n\t\t\t\tu=pre[u];\n\t\t\t}\n\t\t\tif(u==root||id[u]!=-1)\n\t\t\t\tcontinue;\n\t\t\tfor(int j=pre[u];j!=u;j=pre[j])\n\t\t\t\tid[j]=cnt;\n\t\t\tid[u]=cnt++;\n\t\t}\n\t\tif(!cnt)\n\t\t\treturn ans;\n\n\t\tfor(int i=0;i<N;i++)\n\t\t\tif(id[i]==-1)\n\t\t\t\tid[i]=cnt++;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tif(edge[i].u!=edge[i].v){\n\t\t\t\tedge[i].w-=cost[edge[i].v];\n\t\t\t\tedge[i].v=id[edge[i].v];\n\t\t\t\tedge[i].u=id[edge[i].u];\n\t\t\t}\n\t\t}\n\t\tN=cnt;\n\t\troot=id[root];\n\t}\n}\n\nint main()\n{\n\tint n,m;\n\twhile (scanf(\"%d%d\",&n,&m)==2)\n\t{\n\t\tmemset(sum,0,sizeof(sum));\n\t\tmemset(g2,0,sizeof(g2));\n\t\tmemset(g,0,sizeof(g));\n\t\tM=0;\n\t\tfor (int i=0;i<m;i++)\n\t\t\tfor (int j=0;j<n;j++)\n\t\t\t\tscanf(\"%lf\",&a[i][j]);\n\t\tfor (int i=0;i<m;i++)\n\t\t{\n\t\t\tsum[i]=0;\n\t\t\tfor (int j=0;j<n;j++)\n\t\t\t\tsum[i]+=a[i][j]*a[i][j];\n\t\t}\n\t\tfor (int i=0;i<m;i++)\n\t\t\tfor (int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tg2[i][j]=0;\n\t\t\t\tfor (int k=0;k<n;k++)\n\t\t\t\t\tg2[i][j]+=a[i][k]*a[j][k];\n\t\t\t}\n\t\tM=0;\n\t\tdouble total=0;\n\t\tfor (int i=0;i<m;i++)\n\t\t\tfor (int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif (i==j) continue;\n\t\t\t\tdouble r=g2[i][j]/sum[i];\n\t\t\t\tg[i][j]=sum[i]*r*r-2*r*g2[i][j]+sum[j];\n\t\t\t\tedge[M].u=i;\n\t\t\t\tedge[M].v=j;\n\t\t\t\tedge[M].w=g[i][j];\n\t\t\t\ttotal+=g[i][j];\n\t\t\t\tM++;\n\t\t\t}\n\t\tfor (int i=0;i<m;i++)\n\t\t{\n\t\t\ttotal+=sum[i];\n\t\t\tg[root][i]=sum[i];\n\t\t\tedge[M].u=m;\n\t\t\tedge[M].v=i;\n\t\t\tedge[M].w=sum[i];\n\t\t\tM++;\n\t\t}\n\t\troot=m+1;\n\t\tfor (int i=0;i<=m;i++)\n\t\t{\n\t\t\tedge[M].u=root;\n\t\t\tedge[M].v=i;\n\t\t\tedge[M].w=total+1;\n\t\t\tM++;\n\t\t}\n\t\tN=m+2;\n\t\tprintf(\"%.8f\\n\",cal()-total-1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tdouble[][] v = new double[M][N];\n\t\tdouble[][] len = new double[M + 1][M + 1];\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tv[i][j] = sc.nextDouble();\n\t\t\t\tlen[M][i] += v[i][j] * v[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tdouble a = len[M][j];\n\t\t\t\tdouble b = 0;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tb += v[i][k] * v[j][k];\n\t\t\t\t}\n\t\t\t\tdouble c = len[M][i];\n\t\t\t\tlen[j][i] = a == 0 ? c : c - b * b / a;\n\t\t\t}\n\t\t}\n\t\tboolean[] visited = new boolean[M + 1];\n\t\tvisited[M] = true;\n\t\tPriorityQueue<Edge> q = new PriorityQueue<Edge>();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tq.add(new Edge(len[M][i], M, i));\n\t\t}\n\t\tdouble ans = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tEdge cur = q.poll();\n\t\t\tif (visited[cur.to]) continue;\n\t\t\tvisited[cur.to] = true;\n\t\t\tans += cur.len;\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (!visited[i]) q.add(new Edge(len[cur.to][i], cur.to, i));\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"%.7f\\n\", ans);\n\t}\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tdouble len;\n\t\tint from, to;\n\n\t\tpublic Edge(double len, int from, int to) {\n\t\t\tthis.len = len;\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t}\n\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn Double.compare(this.len, o.len);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef calc(V, es, r):\n    mins = [(10**18, -1)]*V\n    for s, t, w in es:\n        mins[t] = min(mins[t], (w, s))\n    mins[r] = (-1, -1)\n\n    group = [0]*V\n    comp = [0]*V\n    cnt = 0\n\n    used = [0]*V\n    for v in range(V):\n        if not used[v]:\n            chain = []\n            cur = v\n            while cur!=-1 and not used[cur]:\n                chain.append(cur)\n                used[cur] = 1\n                cur = mins[cur][1]\n            if cur!=-1:\n                cycle = 0\n                for e in chain:\n                    group[e] = cnt\n                    if e==cur:\n                        cycle = 1\n                        comp[cnt] = 1\n                    if not cycle:\n                        cnt += 1\n                if cycle:\n                    cnt += 1\n            else:\n                for e in chain:\n                    group[e] = cnt\n                    cnt += 1\n\n    if cnt == V:\n        return sum(map(lambda x:x[0], mins)) + 1\n\n    res = sum(mins[v][0] for v in range(V) if v!=r and comp[group[v]])\n\n    n_es = []\n    for s, t, w in es:\n        gs = group[s]; gt = group[t]\n        if gs == gt:\n            continue\n        if comp[gt]:\n            n_es.append((gs, gt, w - mins[t][0]))\n        else:\n            n_es.append((gs, gt, w))\n    return res + calc(cnt, n_es, group[r])\n\ndef solve():\n    N, M = map(int, readline().split())\n    V = []\n    D = []\n    for i in range(M):\n        *Vi, = map(float, readline().split())\n        d = sum(e**2 for e in Vi)\n        if d <= 1e-9:\n            continue\n        V.append(Vi)\n        D.append(d)\n\n    M = len(V)\n    E = []\n    for i in range(M):\n        Vi = V[i]\n        for j in range(M):\n            if i == j:\n                continue\n            Vj = V[j]\n            t = 0\n            for k in range(N):\n                t += Vi[k] * Vj[k]\n            r = t / (D[j])\n            c = 0\n            for k in range(N):\n                c += (Vi[k] - r*Vj[k])**2\n            E.append((j+1, i+1, c))\n        E.append((0, i+1, D[i]))\n    write(\"%.16f\\n\" % calc(M+1, E, 0))\nsolve()\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n \nuse std::fmt;\nuse std::cmp::Ordering;\nuse std::collections::BinaryHeap;\nuse ::State::{NotVisit, Confirmed, Pending};\nuse std::mem::swap;\nuse std::fmt::{Display, Error, Formatter};\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nstruct Vector {\n    factors: Vec<f64>,\n    norm: f64,\n    sum: f64,\n}\nimpl Vector {\n    fn new(vec: Vec<f64>) -> Vector {\n        let mut norm = 0_f64;\n        let mut sum = 0_f64;\n        for &v in &vec {\n            norm += v * v;\n            sum += v;\n        }\n        Vector{factors: vec, norm: norm, sum: sum}\n    }\n    fn distance(&self, other: &Self) -> f64 {\n        if other.norm == 0_f64 {\n            self.norm\n        } else {\n            let mut dot = 0_f64;\n            for i in 0..self.factors.len() {\n                dot += self.factors[i] * other.factors[i];\n            }\n            -dot * dot / other.norm + self.norm\n        }\n    }\n}\n#[derive(Clone)]\npub struct UnionFind {\n    pub size: usize,\n    array: Vec<i32>,\n}\n \nimpl UnionFind {\n    fn new(size: usize) -> UnionFind {\n        UnionFind{size: size, array: vec![-1; size]}\n    }\n    fn find(&mut self, a: usize) -> usize {\n        if self.array[a] < 0 {\n            a\n        }else {\n            let parent = self.array[a] as usize;\n            let p = self.find(parent);\n            self.array[a] = p as i32;\n            p\n        }\n    }\n    fn check_is_same(&mut self, a: usize, b: usize) -> bool {\n        let ap = self.find(a);\n        let bp = self.find(b);\n        ap == bp\n    }\n    fn merge(&mut self, a: usize, b: usize) {\n        let ap = self.find(a);\n        let bp = self.find(b);\n        if ap != bp {\n            if self.array[ap] < self.array[bp] {\n                self.array[ap] = self.array[bp];\n                self.array[bp] = ap as i32;\n            }else {\n                self.array[bp] = self.array[ap];\n                self.array[ap] = bp as i32;\n            }\n        }\n    }\n}\nfn main(){\n    let_all!(n: usize, m: usize);\n    let mut vectors = Vec::with_capacity(m + 1);\n    for _ in 0 .. m {\n        vectors.push(Vector::new(read_line!(' '; f64)));\n    }\n    vectors.push(Vector::new(vec![0_f64; n]));\n    let mut nodes = Vec::with_capacity(m + 1);\n    for i in 0 .. vectors.len() {\n        let mut edges = Vec::with_capacity(m);\n        for j in 0 .. vectors.len() {\n            if i != j {\n                edges.push(Edge{from: j, cost: vectors[i].distance(&vectors[j])});\n            }\n        }\n        nodes.push(Node::new(edges));\n    }\n    println!(\"{:.*}\", 10, solve(nodes, m));\n}\nstruct Edge {\n    from: usize, cost: f64\n}\nimpl Display for Edge {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Edge(from: {}, cost: {})\", self.from, self.cost)\n    }\n}\nimpl Ord for Edge {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.cost.partial_cmp(&other.cost).unwrap()\n    }\n}\nimpl PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.cost.partial_cmp(&other.cost)\n    }\n}\nimpl PartialEq for Edge {\n    fn eq(&self, other: &Self) -> bool {\n        self.cost == other.cost\n    }\n}\nimpl Eq for Edge {}\nstruct Node {\n    in_edges: Vec<Edge>,\n}\nfn show<T:Display>(vec:&Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else{\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        print!(\"]\\n\");\n    }\n}\nimpl Node {\n    fn new(mut vec:Vec<Edge>) -> Node {\n        vec.sort_by(|a, b| a.cmp(b).reverse());\n        Node{in_edges: vec}\n    }\n    fn pop_min_in_edge(&mut self) -> Option<Edge> {\n        self.in_edges.pop()\n    }\n    fn pop_all_edges(&mut self) -> Vec<Edge> {\n        let mut ret = Vec::new();\n        swap(&mut self.in_edges, &mut ret);\n        ret\n    }\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nenum State {\n    Confirmed, Pending, NotVisit\n}\nfn solve(mut nodes: Vec<Node>, root: usize) -> f64 {\n    let mut node_state = vec![NotVisit; nodes.len()];\n    node_state[root] = Confirmed;\n    let mut union = UnionFind::new(nodes.len());\n    let mut result = 0_f64;\n    let mut from_node = vec![0; nodes.len()];\n    let mut from_cost = vec![0_f64; nodes.len()];\n    for start in 0 .. nodes.len() {\n        if node_state[start] == NotVisit {\n            let mut searching = Vec::new();\n            let mut current = start;\n            while node_state[current] != Confirmed {\n                match node_state[current] {\n                    Pending => {\n                        let mut in_cycle = union.find(from_node[current]);\n                        let mut edges = Vec::new();\n                        for e in nodes[current].pop_all_edges() {\n                            edges.push(Edge{from: e.from, cost: e.cost - from_cost[current]});\n                        }\n                        while !union.check_is_same(in_cycle, current) {\n                            for e in nodes[in_cycle].pop_all_edges() {\n                                edges.push(Edge{from: e.from, cost: e.cost - from_cost[in_cycle]});\n                            }\n                            union.merge(in_cycle, current);\n                            in_cycle = union.find(from_node[in_cycle]);\n                        }\n                        let parent = union.find(current);\n                        nodes[parent] = Node::new(edges);\n                        if let Some(e) = nodes[parent].pop_min_in_edge() {\n                            result += e.cost;\n                            current = union.find(e.from);\n                            from_node[parent] = current;\n                            from_cost[parent] = e.cost;\n                        }else {\n                            unreachable!()\n                        }\n                    }\n                    NotVisit => {\n                        searching.push(current);\n                        node_state[current] = Pending;\n                        if let Some(e) = nodes[current].pop_min_in_edge() {\n                            result += e.cost;\n                            let parent = current;\n                            current = union.find(e.from);\n                            from_node[parent] = current;\n                            from_cost[parent] = e.cost;\n                        }else {\n                            unreachable!()\n                        }\n                    }\n                    Confirmed => unreachable!()\n                }\n            }\n            for s in searching {\n                node_state[s] = Confirmed;\n            }\n        }\n    }\n    result\n}\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nstruct Vector {\n    factors: Vec<f64>,\n    norm: f64,\n    sum: f64,\n}\nimpl Vector {\n    fn new(vec: Vec<f64>) -> Vector {\n        let mut norm = 0_f64;\n        let mut sum = 0_f64;\n        for &v in &vec {\n            norm += v * v;\n            sum += v;\n        }\n        Vector{factors: vec, norm: norm, sum: sum}\n    }\n    fn distance(&self, other: &Self) -> f64 {\n        if other.norm == 0_f64 {\n            self.norm\n        } else {\n            let mut dot = 0_f64;\n            for i in 0..self.factors.len() {\n                dot += self.factors[i] * other.factors[i];\n            }\n            -dot * dot / other.norm + self.norm\n        }\n    }\n}\nfn main(){\n    let_all!(n: usize, m: usize);\n    let mut vectors = Vec::with_capacity(m);\n    for _ in 0 .. m {\n        vectors.push(Vector::new(read_line!(' '; f64)));\n    }\n    vectors.sort_by(|a, b| a.norm.partial_cmp(&b.norm).unwrap());\n    let mut result = vectors[0].norm;\n    for i in 1 .. m {\n        let mut min = vectors[i].norm;\n        for j in 0 .. i {\n            let dist = vectors[i].distance(&vectors[j]);\n            if min > dist {\n                min = dist;\n            }\n        }\n        result += min;\n    }\n    println!(\"{:.*}\", 10, result);\n}\n"
  }
]