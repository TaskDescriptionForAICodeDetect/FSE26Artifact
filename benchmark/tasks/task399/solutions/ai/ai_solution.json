[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double *data;\n    int dim;\n} Vector;\n\nvoid subtractVectors(Vector *result, const Vector *a, const Vector *b, double coeff) {\n    for (int i = 0; i < a->dim; i++) {\n        result->data[i] = a->data[i] - coeff * b->data[i];\n    }\n}\n\ndouble dotProduct(const Vector *a, const Vector *b) {\n    double sum = 0.0;\n    for (int i = 0; i < a->dim; i++) {\n        sum += a->data[i] * b->data[i];\n    }\n    return sum;\n}\n\ndouble squaredLength(const Vector *v) {\n    return dotProduct(v, v);\n}\n\nvoid gramSchmidt(Vector *vectors, int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            double coeff = dotProduct(&vectors[i], &vectors[j]) / squaredLength(&vectors[j]);\n            subtractVectors(&vectors[i], &vectors[i], &vectors[j], coeff);\n        }\n    }\n}\n\ndouble calculateTotalSquaredLength(Vector *vectors, int n) {\n    double total = 0.0;\n    for (int i = 0; i < n; i++) {\n        total += squaredLength(&vectors[i]);\n    }\n    return total;\n}\n\nint main() {\n    int n, dim;\n    scanf(\"%d %d\", &n, &dim);\n\n    Vector *vectors = (Vector *)malloc(n * sizeof(Vector));\n    for (int i = 0; i < n; i++) {\n        vectors[i].dim = dim;\n        vectors[i].data = (double *)malloc(dim * sizeof(double));\n        for (int j = 0; j < dim; j++) {\n            scanf(\"%lf\", &vectors[i].data[j]);\n        }\n    }\n\n    gramSchmidt(vectors, n);\n    double total = calculateTotalSquaredLength(vectors, n);\n\n    printf(\"%.6lf\\n\", total);\n\n    for (int i = 0; i < n; i++) {\n        free(vectors[i].data);\n    }\n    free(vectors);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:22:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ndouble min_squared_sum(const vector<vector<double>>& vectors) {\n    if (vectors.empty()) return 0.0;\n    int n = vectors.size();\n    int dim = vectors[0].size();\n    vector<vector<double>> basis;\n\n    double total = 0.0;\n\n    for (const auto& vec : vectors) {\n        vector<double> u = vec;\n        for (const auto& b : basis) {\n            double dot = 0.0;\n            double b_sq = 0.0;\n            for (int i = 0; i < dim; ++i) {\n                dot += u[i] * b[i];\n                b_sq += b[i] * b[i];\n            }\n            if (b_sq == 0.0) continue;\n            double coeff = dot / b_sq;\n            for (int i = 0; i < dim; ++i) {\n                u[i] -= coeff * b[i];\n            }\n        }\n\n        double u_sq = 0.0;\n        for (int i = 0; i < dim; ++i) {\n            u_sq += u[i] * u[i];\n        }\n\n        if (u_sq > 1e-10) {\n            basis.push_back(u);\n            total += u_sq;\n        }\n    }\n\n    return total;\n}",
    "timestamp": "2025-08-05 21:22:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class VectorSumMinimizer {\n    public static double minimizeSquaredSum(List<double[]> vectors) {\n        if (vectors.isEmpty()) {\n            return 0.0;\n        }\n\n        int n = vectors.get(0).length;\n        double[][] basis = new double[n][n];\n        int basisSize = 0;\n        double total = 0.0;\n\n        for (double[] v : vectors) {\n            double[] u = Arrays.copyOf(v, n);\n            for (int i = 0; i < basisSize; i++) {\n                double[] b = basis[i];\n                double dot = 0.0;\n                double norm = 0.0;\n                for (int j = 0; j < n; j++) {\n                    dot += u[j] * b[j];\n                    norm += b[j] * b[j];\n                }\n                if (norm == 0) {\n                    continue;\n                }\n                double coeff = dot / norm;\n                for (int j = 0; j < n; j++) {\n                    u[j] -= coeff * b[j];\n                }\n            }\n\n            double squaredNorm = 0.0;\n            for (int j = 0; j < n; j++) {\n                squaredNorm += u[j] * u[j];\n            }\n\n            if (squaredNorm > 1e-10) {\n                double norm = Math.sqrt(squaredNorm);\n                for (int j = 0; j < n; j++) {\n                    basis[basisSize][j] = u[j] / norm;\n                }\n                basisSize++;\n                total += squaredNorm;\n            }\n        }\n\n        return total;\n    }\n}",
    "timestamp": "2025-08-05 21:23:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass VectorMinimizer {\n    public static double minimumSquaredLength(double[][] vectors) {\n        int n = vectors.length;\n        int dim = vectors[0].length;\n        \n        double[][] dp = new double[1 << n][n];\n        for (double[] row : dp) {\n            Arrays.fill(row, Double.MAX_VALUE);\n        }\n        \n        for (int i = 0; i < n; i++) {\n            dp[1 << i][i] = calcSquaredLength(vectors[i]);\n        }\n        \n        for (int mask = 1; mask < (1 << n); mask++) {\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) == 0) continue;\n                \n                for (int j = 0; j < n; j++) {\n                    if (i == j || (mask & (1 << j)) == 0) continue;\n                    \n                    double[] diff = subtractVectors(vectors[i], vectors[j]);\n                    double diffLength = calcSquaredLength(diff);\n                    int prevMask = mask ^ (1 << i);\n                    \n                    dp[mask][i] = Math.min(dp[mask][i], \n                        dp[prevMask][j] + diffLength);\n                }\n            }\n        }\n        \n        double minSum = Double.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            minSum = Math.min(minSum, dp[(1 << n) - 1][i]);\n        }\n        \n        return minSum;\n    }\n    \n    private static double calcSquaredLength(double[] vector) {\n        double sum = 0;\n        for (double val : vector) {\n            sum += val * val;\n        }\n        return sum;\n    }\n    \n    private static double[] subtractVectors(double[] v1, double[] v2) {\n        double[] result = new double[v1.length];\n        for (int i = 0; i < v1.length; i++) {\n            result[i] = v1[i] - v2[i];\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-05 21:23:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\n#define MAX_DIM 100\n#define MAX_VECTORS 1000\n\ntypedef struct {\n    double components[MAX_DIM];\n    int dimension;\n} Vector;\n\ndouble vector_squared_length(Vector* v) {\n    double sum = 0;\n    for (int i = 0; i < v->dimension; i++) {\n        sum += v->components[i] * v->components[i];\n    }\n    return sum;\n}\n\ndouble compute_coefficient(Vector* base, Vector* diff) {\n    double numerator = 0, denominator = 0;\n    for (int i = 0; i < base->dimension; i++) {\n        numerator += base->components[i] * diff->components[i];\n        denominator += base->components[i] * base->components[i];\n    }\n    return denominator != 0 ? numerator / denominator : 0;\n}\n\nVector subtract_vectors(Vector* a, Vector* b) {\n    Vector result;\n    result.dimension = a->dimension;\n    for (int i = 0; i < a->dimension; i++) {\n        result.components[i] = a->components[i] - b->components[i];\n    }\n    return result;\n}\n\ndouble solve_minimum_squared_length(Vector* vectors, int n) {\n    if (n == 0) return 0;\n    \n    double total_squared_length = 0;\n    int* used = calloc(n, sizeof(int));\n    \n    for (int i = 0; i < n; i++) {\n        if (used[i]) continue;\n        \n        double min_length = DBL_MAX;\n        int best_base = -1;\n        \n        for (int j = 0; j < n; j++) {\n            if (used[j]) continue;\n            \n            double current_length = vector_squared_length(&vectors[j]);\n            if (current_length < min_length) {\n                min_length = current_length;\n                best_base = j;\n            }\n        }\n        \n        used[best_base] = 1;\n        total_squared_length += min_length;\n        \n        for (int j = 0; j < n; j++) {\n            if (used[j]) continue;\n            \n            Vector diff = subtract_vectors(&vectors[j], &vectors[best_base]);\n            double coeff = compute_coefficient(&vectors[best_base], &diff);\n            \n            Vector modified_diff;\n            modified_diff.dimension = diff.dimension;\n            for (int k = 0; k < diff.dimension; k++) {\n                modified_diff.components[k] = diff.components[k] - coeff * vectors[best_base].components[k];\n            }\n            \n            double modified_length = vector_squared_length(&modified_diff);\n            if (modified_length < vector_squared_length(&vectors[j])) {\n                total_squared_length += modified_length;\n                used[j] = 1;\n            } else {\n                total_squared_length += vector_squared_length(&vectors[j]);\n            }\n        }\n    }\n    \n    free(used);\n    return total_squared_length;\n}\n\nint main() {\n    // Example usage\n    int n, dim;\n    scanf(\"%d %d\", &n, &dim);\n    \n    Vector* vectors = malloc(n * sizeof(Vector));\n    for (int i = 0; i < n; i++) {\n        vectors[i].dimension = dim;\n        for (int j = 0; j < dim; j++) {\n            scanf(\"%lf\", &vectors[i].components[j]);\n        }\n    }\n    \n    double result = solve_minimum_squared_length(vectors, n);\n    printf(\"%.6f\\n\", result);\n    \n    free(vectors);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n#include <iostream>\n\nclass VectorMinimizer {\nprivate:\n    int N;\n    std::vector<std::vector<double>> vectors;\n    std::vector<std::vector<double>> preprocessed;\n\n    double squared_length(const std::vector<double>& vec) {\n        double sum = 0;\n        for (double x : vec) sum += x * x;\n        return sum;\n    }\n\n    std::vector<double> vector_subtract(const std::vector<double>& a, const std::vector<double>& b) {\n        std::vector<double> result(N);\n        for (int i = 0; i < N; ++i) {\n            result[i] = a[i] - b[i];\n        }\n        return result;\n    }\n\n    std::vector<double> vector_linear_combination(const std::vector<double>& a, const std::vector<double>& b, double coef) {\n        std::vector<double> result(N);\n        for (int i = 0; i < N; ++i) {\n            result[i] = a[i] + coef * b[i];\n        }\n        return result;\n    }\n\npublic:\n    VectorMinimizer(int dimensions) : N(dimensions) {}\n\n    void add_vector(const std::vector<double>& vec) {\n        vectors.push_back(vec);\n    }\n\n    double minimize() {\n        int M = vectors.size();\n        if (M == 0) return 0;\n        \n        preprocessed.resize(M);\n        preprocessed[0] = vectors[0];\n        double total_squared_length = squared_length(preprocessed[0]);\n\n        for (int i = 1; i < M; ++i) {\n            double min_length = std::numeric_limits<double>::max();\n            std::vector<double> best_vec;\n\n            // Try recording as is\n            double curr_length = squared_length(vectors[i]);\n            if (curr_length < min_length) {\n                min_length = curr_length;\n                best_vec = vectors[i];\n            }\n\n            // Try recording as difference from previous vectors\n            for (int j = 0; j < i; ++j) {\n                // Try different linear combinations\n                for (double coef = -10.0; coef <= 10.0; coef += 0.1) {\n                    std::vector<double> diff_vec = vector_subtract(vectors[i], vector_linear_combination(preprocessed[j], preprocessed[j], coef));\n                    double length = squared_length(diff_vec);\n                    \n                    if (length < min_length) {\n                        min_length = length;\n                        best_vec = diff_vec;\n                    }\n                }\n            }\n\n            preprocessed[i] = best_vec;\n            total_squared_length += min_length;\n        }\n\n        return total_squared_length;\n    }\n};\n\nint main() {\n    // Example usage\n    VectorMinimizer vm(3);  // 3-dimensional vectors\n    vm.add_vector({1, 2, 3});\n    vm.add_vector({4, 5, 6});\n    vm.add_vector({7, 8, 9});\n\n    double result = vm.minimize();\n    std::cout << \"Minimum total squared length: \" << result << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef minimum_squared_length(vectors):\n    n = len(vectors)\n    dims = len(vectors[0])\n    \n    # Initial solution: record each vector directly\n    min_squared_sum = np.sum([np.linalg.norm(v)**2 for v in vectors])\n    best_solution = vectors.copy()\n\n    def objective_function(coeffs, v, base):\n        # Calculate the squared norm of the vector v' = v - coeff * base\n        new_vec = v - coeffs * base\n        return np.sum(new_vec**2)\n\n    for i in range(n):\n        for j in range(i):\n            # Attempt to record vector i using vector j\n            res = minimize(objective_function, 0, args=(np.array(vectors[i]), np.array(vectors[j])), method='L-BFGS-B')\n            coeff = res.x\n            new_vector = np.array(vectors[i]) - coeff * np.array(vectors[j])\n            new_squared_sum = np.sum([np.linalg.norm(vec)**2 for vec in vectors[:i]] + [np.linalg.norm(new_vector)**2] + [np.linalg.norm(vec)**2 for vec in vectors[i+1:]])\n\n            if new_squared_sum < min_squared_sum:\n                min_squared_sum = new_squared_sum\n                best_solution = vectors[:i] + [new_vector.tolist()] + vectors[i+1:]\n\n    return best_solution, min_squared_sum\n\n# Example Usage\nvectors = [[1, 2], [3, 4], [5, 6]]\nresult = minimum_squared_length(vectors)\nprint(\"Preprocessed Vectors:\", result[0])\nprint(\"Minimum Sum of Squared Lengths:\", result[1])",
    "timestamp": "2025-08-13 06:16:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MinimumSquaredLength {\n    \n    public static double minSquaredLength(List<double[]> vectors) {\n        int n = vectors.size();\n        int dimension = vectors.get(0).length;\n        \n        // dp[i] represents the minimum squared length to record vectors[0...i]\n        double[] dp = new double[n];\n        double[][] squaredLengths = new double[n][n];\n\n        // Calculate the squared length of a vector\n        for (int i = 0; i < n; i++) {\n            double[] vecI = vectors.get(i);\n            double sum = 0;\n            for (int j = 0; j < dimension; j++) {\n                sum += vecI[j] * vecI[j];\n            }\n            squaredLengths[i][i] = sum;\n        }\n\n        // Calculate the squared length of the difference of two vectors\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double[] vecI = vectors.get(i);\n                double[] vecJ = vectors.get(j);\n                double sum = 0;\n                for (int k = 0; k < dimension; k++) {\n                    double diff = vecJ[k] - vecI[k];\n                    sum += diff * diff;\n                }\n                squaredLengths[i][j] = sum;\n            }\n        }\n        \n        Arrays.fill(dp, Double.MAX_VALUE);\n        dp[0] = squaredLengths[0][0];\n        \n        // Fill dp array\n        for (int i = 1; i < n; i++) {\n            dp[i] = squaredLengths[0][i]; // Direct recording of vector[i]\n            for (int j = 0; j < i; j++) {\n                double diffSquaredLength = squaredLengths[j][i];\n                dp[i] = Math.min(dp[i], dp[j] + diffSquaredLength);\n            }\n        }\n\n        return dp[n - 1];\n    }\n    \n    public static void main(String[] args) {\n        List<double[]> vectors = Arrays.asList(\n            new double[] {2.0, 1.0},\n            new double[] {3.0, 4.0},\n            new double[] {5.0, 2.0}\n        );\n\n        System.out.println(minSquaredLength(vectors));\n    }\n}",
    "timestamp": "2025-08-13 06:16:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define MAX_VECTORS 1000\n#define MAX_DIMENSION 10\n#define INF 1e9\n\ndouble vectors[MAX_VECTORS][MAX_DIMENSION];\ndouble dp[MAX_VECTORS];\nint n, d;\n\ndouble squared_norm(double *v) {\n    double norm = 0.0;\n    for (int i = 0; i < d; i++) {\n        norm += v[i] * v[i];\n    }\n    return norm;\n}\n\ndouble squared_difference(double *v1, double *v2, double c) {\n    double result = 0.0;\n    for (int i = 0; i < d; i++) {\n        double diff = v1[i] - c * v2[i];\n        result += diff * diff;\n    }\n    return result;\n}\n\ndouble solve() {\n    dp[0] = squared_norm(vectors[0]);\n    \n    for (int i = 1; i < n; i++) {\n        dp[i] = squared_norm(vectors[i]);\n        for (int j = 0; j < i; j++) {\n            double c = 0.0;\n            double numerator = 0.0, denominator = 0.0;\n            \n            for (int k = 0; k < d; k++) {\n                numerator += vectors[i][k] * vectors[j][k];\n                denominator += vectors[j][k] * vectors[j][k];\n            }\n            \n            if (denominator != 0) {\n                c = numerator / denominator;\n            }\n            \n            double cost = squared_difference(vectors[i], vectors[j], c);\n            dp[i] = fmin(dp[i], dp[j] + cost);\n        }\n    }\n    \n    return dp[n-1];\n}\n\nint main() {\n    // Input number of vectors and their dimension\n    scanf(\"%d %d\", &n, &d);\n    \n    // Input each vector\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < d; j++) {\n            scanf(\"%lf\", &vectors[i][j]);\n        }\n    }\n    \n    // Calculate and output the result\n    double result = solve();\n    printf(\"%.9lf\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 06:16:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_squared_length_sum(vectors):\n    n = len(vectors)\n    if n == 0:\n        return 0\n    \n    # Dynamic programming approach\n    dp = [float('inf')] * n\n    dp[0] = sum(x*x for x in vectors[0])\n    \n    for i in range(1, n):\n        # Option 1: Record vector as is\n        dp[i] = min(dp[i], sum(x*x for x in vectors[i]))\n        \n        # Option 2: Try to record as difference from previous vectors\n        for j in range(i):\n            # Find optimal coefficient to minimize squared length\n            current = vectors[i]\n            prev = vectors[j]\n            \n            # Compute optimal coefficient by projection\n            numerator = sum(a*b for a, b in zip(current, prev))\n            denominator = sum(x*x for x in prev)\n            \n            if denominator != 0:\n                coeff = numerator / denominator\n                diff_vector = [current[k] - coeff * prev[k] for k in range(len(current))]\n                \n                candidate_sum = dp[j] + sum(x*x for x in diff_vector)\n                dp[i] = min(dp[i], candidate_sum)\n    \n    return dp[-1]",
    "timestamp": "2025-08-13 06:16:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import numpy as np\n\ndef minimal_squared_length(vectors):\n    if not vectors:\n        return 0.0\n    \n    basis = []\n    total = 0.0\n    \n    for v in vectors:\n        current = np.array(v, dtype=float)\n        for b in basis:\n            projection = np.dot(current, b) / np.dot(b, b)\n            current -= projection * b\n        norm_sq = np.dot(current, current)\n        if norm_sq > 1e-10:\n            basis.append(current)\n        total += norm_sq\n    \n    return total",
    "timestamp": "2025-08-13 06:16:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <cmath>\n\nusing namespace std;\n\ndouble minimizeSumSquaredLengths(vector<vector<double>>& vectors) {\n    int n = vectors.size();\n    int N = vectors[0].size();\n    \n    vector<double> dp(n, numeric_limits<double>::infinity());\n    vector<vector<double>> diff(n, vector<double>(n, 0.0));\n    \n    for (int i = 0; i < n; ++i) {\n        dp[i] = 0.0;\n        for (int j = 0; j < N; ++j) {\n            dp[i] += vectors[i][j] * vectors[i][j];\n        }\n    }\n    \n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            double numerator = 0.0, denominator = 0.0;\n            for (int k = 0; k < N; ++k) {\n                numerator += vectors[i][k] * vectors[j][k];\n                denominator += vectors[j][k] * vectors[j][k];\n            }\n            if (denominator != 0) {\n                double alpha = numerator / denominator;\n                double currentDiff = 0.0;\n                for (int k = 0; k < N; ++k) {\n                    double value = vectors[i][k] - alpha * vectors[j][k];\n                    currentDiff += value * value;\n                }\n                diff[i][j] = currentDiff;\n            }\n        }\n    }\n    \n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            dp[i] = min(dp[i], dp[j] + diff[i][j]);\n        }\n    }\n    \n    double minSum = dp[0];\n    for (int i = 1; i < n; ++i) {\n        minSum = min(minSum, dp[i]);\n    }\n    \n    return minSum;\n}\n\nint main() {\n    int n, N;\n    cin >> n >> N;\n    \n    vector<vector<double>> vectors(n, vector<double>(N));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> vectors[i][j];\n        }\n    }\n    \n    double result = minimizeSumSquaredLengths(vectors);\n    cout << fixed << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:31:05"
  }
]