[
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <queue>\n#define MAXNUM 2000\n#define zero 1000 // (1000,1000)が原点\nusing namespace std;\n\n\nconst int ddx[] = {-1,0,1,0} ,ddy[] = {0,-1,0,1};\nint shoki[MAXNUM + 1][MAXNUM + 1], p[20][20], cx[20], cy[20], hx, hy, n;\n\nint solve(int pre){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= shoki[cy[i] + zero][cx[i] + zero]) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit){ // 未探索の位置にあるクリスタル\n\t\t\tif(pre == -1 && abs(hx - cx[i]) + abs(hy - cy[i]) + sum < shoki[cy[i] + zero][cx[i] + zero]){ // １つ目のクリスタルをとる\n\t\t\t\tsum += abs(hx - cx[i]) + abs(hy - cy[i]);\n\t\t\t\tbit += 1 << i;\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbit -= 1 << i;\n\t\t\t\tsum -= abs(hx - cx[i]) + abs(hy - cy[i]);\n\t\t\t}\n\t\t\telse if(pre != -1 && p[pre][i] + sum < shoki[cy[i] + zero][cx[i] + zero]){ // ２〜ｎつ目のクリスタルを取る\n\t\t\t\tbit += 1 << i;\n\t\t\t\tsum += p[pre][i];\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tsum -= p[pre][i];\n\t\t\t\tbit -= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint  dx, dy, x, y, count, i, j, k;\n\tqueue<int> qx, qy;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(i == j)\n\t\t\t\t\tp[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tp[i][j] = abs(cx[i] - cx[j]) + abs(cy[i] - cy[j]);\n\t\t\t}\n\t\t}\n\t\tmemset(shoki,-1,sizeof(shoki));\n\t\tqx.push(dx + zero),qy.push(dy + zero);\n\t\tshoki[dy + zero][dx + zero] = 0;\n\t\twhile(shoki[0][0] == -1 || shoki[MAXNUM][MAXNUM] == -1 || shoki[MAXNUM][0] == -1 || shoki[0][MAXNUM] == -1){\n\t\t\twhile(qx.size()){\n\t\t\t\tx = qx.front();\n\t\t\t\ty = qy.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\t\tif(x + ddx[i] + zero >= 0 && x + ddx[i] + zero <= MAXNUM && y + ddy[i] + zero >= 0 && y + ddy[i] + zero <= MAXNUM && shoki[y + ddy[i] + zero][x + ddx[i] + zero] == -1){\n\t\t\t\t\t\tqx.push(x + ddx[i] + zero),qy.push(y + ddy[i] + zero);\n\t\t\t\t\t\tshoki[y + ddy[i] + zero][x + ddx[i] + zero] = shoki[y + zero][x + zero] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(solve(-1))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX], ok;\nbool dp[1<<MAX][MAX];\n\nbool rec(int S, int v, double total_dist){\n  if(ok) return true;\n  if(total_dist >= dist(d, crystal[v])){\n    return false;\n  }\n\n  //if(dp[S][v]) return true;\n  if(S == (1 << N) - 1){\n    ok = true;\n    return dp[S][v] = true;\n  }\n  bool res = false;\n  for(int u = 0 ; u < N ; u++){\n    Segment s = Segment(crystal[v], crystal[u]);\n    if(s.distanceSP(d) < total_dist) return false;\n    if(!(S >> u & 1)){\n      res = rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]));\n    }\n  }\n  return dp[S][v] = res;\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n  for(int i = 0 ; i < N ; i++){\n    ok = false;\n    memset(used, false, sizeof(used));\n    if(rec(0, i, dist(h, crystal[i]))){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#define LT(x,y) ((x)-(y)<-EPS)\n\n#include <complex>\ntypedef complex<double> P;\n\nstruct state {\n\tint s, v;\n\tdouble d;\n\tstate(int s, int v, double d) : s(s), v(v), d(d) {};\n};\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile(cin >> n >> hx >> hy >> dx >> dy, n) {\n\t\tP h(hx, hy), d(dx, dy);\n\t\tvector<P> c(n);\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tc[i] = P(x, y);\n\t\t}\n\n\t\tstack<state> S;\n\t\tREP(i, n) {\n\t\t\tif(LT(abs(h-c[i]), abs(d-c[i]))) {\n\t\t\t\tS.push(state(1<<i, i, abs(h-c[i])));\n\t\t\t}\n\t\t}\n\n\t\tbool ok = false;\n\t\twhile(!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\n\t\t\tif(st.s == (1<<n)-1) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(i, n) {\n\t\t\t\tint ns = st.s|(1<<i);\n\t\t\t\tif(st.s != ns) {\n\t\t\t\t\tdouble nd = st.d + abs(c[st.v]-c[i]);\n\t\t\t\t\tREP(j, n) {\n\t\t\t\t\t\tif(!(ns&(1<<j)) && LT(abs(d-c[j]), nd)) {\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(LT(nd, abs(d-c[i]))) {\n\t\t\t\t\t\tS.push(state(ns, i, nd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext:;\n\t\t\t}\n\t\t}\n\n\t\tcout << (ok ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint n;\nint cx[22];\nint cy[22];\nbool f[22];\ndouble l[22][22];\nint s = 0;\ndouble d;\n\nint kansu( int x , int y ){\n\ts++;\n\tif ( s == n + 1 ) return 1;\n\td += l[x][y];\n\tf[y] = true;\n\tbool flag = true;\n\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\tif ( f[i] ) continue;\n\t\tif ( d + l[y][i] >= l[1][i] ) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ( flag ) {\n\t\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\t\tif ( f[i] ) continue;\n\t\t\tif ( kansu( y , i ) ) return 1;\n\t\t}\n\t}\n\ts--;\n\td -= l[x][y];\n\tf[y] = false;\n\treturn 0;\n}\n\nint main(){\n\twhile(true) {\n\t\tcin >> n >> cx[0] >> cy[0] >> cx[1] >> cy[1];\n\t\tif ( n == 0 ) break;\n\t\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tf[i] = false;\n\t\t}\n\t\tfor ( int i = 0; i < n + 1; i++ ) {\n\t\t\tfor ( int j = i + 1; j < n + 2; j++ ) {\n\t\t\t\tint x = cx[i]-cx[j];\n\t\t\t\tint y = cy[i]-cy[j];\n\t\t\t\tdouble z = x*x + y*y;\n\t\t\t\tl[i][j] = sqrt( z );\n\t\t\t\tl[j][i] = l[i][j];\n\t\t\t}\n\t\t}\n\t\ts = 0;\n\t\td = 0.00;\n\t\tl[0][0] = 0.00;\n\t\tif ( kansu( 0 , 0 ) ) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\n\n// n := クリスタルの個数 \nint n;\n// (hx,hy) := 勇者の初期位置\n// (dx,dy) := 魔王の位置\nint hx, hy, dx ,dy;\n// (cx[i],cy[i]) := i 番目のクリスタルの位置\nint cx[21], cy[21];\n// done[i] := i 番目のクリスタルを回収したかどうか\nbool done[21];\n// 答え\nbool ans;\n\n// 2 点間の距離\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\n\n// 枝刈り探索\n// t := 経過時間[s], (x,y) := 勇者の位置\nvoid solve(double t, int x, int y){\n    if( ans ) return ;\n    \n    // cnt := 現在回収したクリスタルの個数\n    int cnt=0;\n    for(int i=0 ; i < n ; i++ ){\n        if( done[i] ) cnt++;\n    }\n    // n 個のクリスタルを回収したとき\n    if( cnt == n ){\n        ans = true;\n        return;\n    }\n    \n    // 回収できないクリスタルがあるか調べる\n    for(int i=0 ; i < n ; i++ ){\n        if( done[i] ) continue;\n\t\t\n        double next_time = t + dist( x , y , cx[i] , cy[i] );\n        // すでに回収できないクリスタルがあったら探索打ち切り\n        if ( dist( dx , dy , cx[i] , cy[i] ) < next_time + EPS ){ \n            return; \n        }\n    }\n    for(int i=0 ; i < n ; i++ ){\n        if( done[i] ) continue;\n \n        double next_time = t + dist( x , y , cx[i] , cy[i] );\n        done[i] = true;\n        solve( next_time , cx[i] , cy[i] );\n        done[i] = false;\n    }\n}\n \nint main(){\n    while( cin >> n >> hx >> hy >> dx >> dy , (n || hx || hy || dx || dy) ){\n    \t// (cx[i],cy[i]) := i 番目のクリスタルの位置\n        for(int i=0 ; i < n ; i++ ){\n            cin >> cx[i] >> cy[i];\n        }\n        \n        // 初期化\n        for(int i=0 ; i < 21 ; i++ ){\n            done[i] = false;\n        }\n        \n        ans = false;\n        solve( 0.0 , hx , hy );\n        if( ans ){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\ndouble dist(int x1, int y1, int x2, int y2)\n{\n\tint x = x1 - x2, y = y1 - y2;\n\treturn sqrt(0.0 + x*x + y*y);\n}\nint main()\n{\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n)\n\t{\n\t\tint x[32], y[32];\n\t\trep (i, n)\n\t\t\tcin >> x[i] >> y[i];\n\t\tx[n] = hx, y[n] = hy;\n\t\tx[n + 1] = dx, y[n + 1] = dy;\n\t\tfloat dis[32][32];\n\t\tfor (int i = 0; i <= n + 1; ++i)\n\t\t\tfor (int j = 0; j <= n + 1; ++j)\n\t\t\t\tdis[i][j] = dist(x[i], y[i], x[j], y[j]);\n\n\n\t\tstatic float dp[1 << 20][20];\n\t\tconst float INF = 1e9;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tdp[i][j] = INF;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (dis[n][i] < dis[n + 1][i])\n\t\t\t\tdp[1 << i][i] = dis[n][i];\n\n\t\tfor (int s = 0; s < 1 << n; ++s)\n\t\t{\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tif (!(s >> i & 1) || dp[s][i] == INF)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (s >> j & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tfloat t = dp[s][i] + dis[i][j];\n\t\t\t\t\tif (t < dis[n + 1][j])\n\t\t\t\t\t\tmin_swap(dp[s | 1 << j][j], t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (dp[(1 << n) - 1][i] + 1e-9 < dis[n + 1][i])\n\t\t\t\tres = true;\n\t\tcout << (res ? \"YES\" : \"NO\") << endl;\n\t\t//cout.precision(9);\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//\tcout << dp[(1 << n) - 1][i] << \" / \" << dis[n + 1][i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8;\n\nint n, hx, hy, dx, dy;\nvector<int> cx, cy;\nvector<double> dd;\nvector<vector<double> > d;\n\nbool check(int vis, int k, double t){\n    rep(i, n)if(!(vis >> i & 1) && dd[i] <= d[k][i] + t + eps)return false;\n    return true;\n}\n\nbool dfs(int vis, int k, double t){\n    if(vis == (1 << n) - 1)return true;\n    if(!check(vis, k, t))return false;\n    rep(i, n){\n        if(vis >> i & 1 || dd[i] <= d[k][i] + t + eps)continue;\n        if(dfs(vis | 1 << i, i, t + d[k][i]))return true;\n    }\n    return false;\n}\n\nint main(){\n    while(cin >> n >> hx >> hy >> dx >> dy, n|hx|hy|dx|dy){\n        cx.assign(n, 0); cy.assign(n, 0); dd.assign(n, 0);\n        d.assign(n + 1, vector<double>(n + 1, 0));\n        rep(i, n){\n            cin >> cx[i] >> cy[i];\n            dd[i] = hypot(cx[i] - dx, cy[i] - dy);\n            d[i][n] = d[n][i] = hypot(cx[i] - hx, cy[i] - hy);\n            rep(j, i)d[i][j] = d[j][i] = hypot(cx[i] - cx[j], cy[i] - cy[j]);\n        }\n        cout << (dfs(0, n, 0.)? \"YES\\n\": \"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\n// 1: a,b,cが反時計周りの順に並ぶ\n//-1: a,b,cが時計周りの順に並ぶ\n// 2: c,a,bの順に直線に並ぶ\n//-2: a,b,cの順に直線に並ぶ\n// 0: a,c,bの順に直線に並ぶ\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.b - l.a) / norm(l.a - l.b);\n\treturn l.a + t * (l.b - l.a);\n}\n\n//線対象の位置にある点\nPoint reflect(const Line &l, const Point &p) {\n\tPoint pr = proj(l, p);\n\treturn pr * 2.l - p;\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// 直線と直線の交点\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// 線分と線分の交点\n//　重なってる部分あるとassert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//先にisis_ssしてね\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// 線分と線分の交点\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine line_bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n//点と点の垂直二等分線　aを左に見ながら\nLine point_bisection(const Point&a, const Point&b) {\n\tconst Point cen((a + b) / 2.l);\n\tconst Point vec = (b - a)*Point(0, 1);\n\treturn Line(cen, cen + vec);\n}\n\n//三つの点からなる外心\nPoint outer_center(const vector<Point>&ps) {\n\tassert(ps.size() == 3);\n\tLine l1 = point_bisection(ps[0], ps[1]);\n\tLine l2 = point_bisection(ps[1], ps[2]);\n\n\treturn is_ll(l1, l2);\n}\n\n\n//三つの直線からなる内心\n//三つの直線が並行でないことは確かめといてね\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(line_bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(line_bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//三つの直線からなる傍心\n//三つの直線が並行でないことは確かめといてね\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(line_bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(line_bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:並行\n//c:並行でない\n//三つの直線から同距離の位置を求める。\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(line_bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(line_bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(line_bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n/*\n点が円の中にいるか\n0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const  Point& p, const Circle &cir) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n/*\n円lcが円rcの中にいるか\n0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//二つの円の重なり面積\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n\n\n//多角形(複数の点)の最小包含円をO(N=頂点数)で求めるアルゴリズム\n//同一直線上に三つの点がないこと\n#include<random>\nCircle welzl(vector<Point>ps) {\n\tstruct solver {\n\t\tCircle solve(vector<Point>&ps, vector<Point>&rs) {\n\t\t\tif (ps.empty() || rs.size() == 3) {\n\t\t\t\tif (rs.size() == 1) {\n\t\t\t\t\treturn Circle(Point(rs[0]), 0);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 2) {\n\t\t\t\t\treturn Circle((rs[0] + rs[1]) / 2.0l, abs(rs[1] - rs[0]) / 2);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 3) {\n\t\t\t\t\tvector<Line> ls(3);\n\t\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\t\tls[i] = Line(rs[i], rs[(i + 1) % 3]);\n\t\t\t\t\t}\n\t\t\t\t\tPoint center = outer_center(rs);\n\t\t\t\t\treturn Circle(center, abs(center - rs[0]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn Circle(Point(), 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tPoint p_ba = ps.back();\n\t\t\t\tps.pop_back();\n\t\t\t\tCircle d = solve(ps, rs);\n\t\t\t\tps.push_back(p_ba);\n\t\t\t\tif (is_in_Circle(d, p_ba)) {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trs.push_back(p_ba);\n\t\t\t\t\tps.pop_back();\n\t\t\t\t\tauto ans = solve(ps, rs);\n\t\t\t\t\tps.push_back(p_ba);\n\t\t\t\t\trs.pop_back();\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}so;\n\tstd::random_device rd;\n\tstd::mt19937 mt(rd());\n\tshuffle(ps.begin(), ps.end(), mt);\n\tvector<Point>rs;\n\tCircle ans = so.solve(ps, rs);\n\treturn ans;\n}\n// 面積\nld get_area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tfor (int j = 0; j<n; ++j) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n//点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\n\n\nint main() {\n\twhile (true) {\n\t\tint N; Point start_po;\n\t\tvector<Point>pos;\n\t\t{\n\t\t\tld Hx, Hy, Sx, Sy;\n\t\t\tcin >> N >> Hx >> Hy >> Sx >> Sy;\n\t\t\tif(!N)return 0;\n\t\t\tstart_po = Point(Hx - Sx, Hy - Sy);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tld x, y; cin >> x >> y;\n\t\t\t\tpos.emplace_back(x - Sx, y - Sy);\n\t\t\t}\n\t\t}\n\t\tvector<vector<ld>>memo(N, vector<ld>(1 << N, 1e18));\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tld atime = abs(pos[i] - start_po);\n\t\t\tif (atime + eps < abs(pos[i])) {\n\t\t\t\tbitset<20>bs;\n\t\t\t\tbs[i] = true;\n\t\t\t\tmemo[i][bs.to_ulong()] = atime;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << N); ++i) {\n\t\t\tfor (int now = 0; now < N; ++now) {\n\t\t\t\tif (memo[now][i]>1e17)continue;\n\n\t\t\t\tbitset<20>bs(i);\n\t\t\t\tfor (int next = 0; next < N; ++next) {\n\t\t\t\t\tif (!bs[next]) {\n\t\t\t\t\t\tbs[next] = true;\n\n\t\t\t\t\t\tld next_time = abs(pos[next] - pos[now]) + memo[now][i];\n\t\t\t\t\t\tif (next_time + eps < abs(pos[next])) {\n\t\t\t\t\t\t\tmemo[next][bs.to_ulong()] = min(memo[next][bs.to_ulong()], next_time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbs[next] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (memo[i][(1 << N) - 1]<1e17)ok = true;\n\t\t}\n\t\tif (ok)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble hero[20];\nbool visited[20]={false};\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if ( visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    visited[i]=true;\n    if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  //return (x*x+y*y);\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n    hero[i]=dist(mx-x[i],my-y[i]);\n    if ( hero[i]>=adj[MAOU][i])return false;\n    visited[i]=false;\n  }\n  \n  rep(i,n){\n    visited[i]=true;\n    if ( backTrack(i,hero[i],1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(scanf(\"%d%d%d%d%d\",&n,&mx,&my,&rx,&ry) && n){\n    int x[n],y[n];\n    rep(i,n)scanf(\"%d%d\",&x[i],&y[i]);\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define MAXNUM 22\n\nstruct status{\n\tdouble d;\n\tint c;\n};\n\ndouble dist(double x1,double y1,double x2,double y2){\n\tdouble ret = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n\treturn ret;\n}\n\nint main(void){\n\tint i, j, n;\n\tdouble hx, hy, dx, dy, cx[MAXNUM],cy[MAXNUM];\n\tstruct status dp[1 << MAXNUM];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tscanf(\"%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0.0 && hy == 0.0 && dx == 0.0 && dy == 0.0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < 1 << MAXNUM;i++)\n\t\t\tdp[i].d = -1;\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tdp[1 << i].d = dist(hx,hy,cx[i],cy[i]);\n\t\t\tdp[1 << i].c = i;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i].d != -1){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & (1 << j) && ((dp[i | (1 << j)].d == -1) || (dp[i | (1 << j)].d > dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j])))){\n\t\t\t\t\t\tdp[i | (1 << j)].d = dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]);\n\t\t\t\t\t\tdp[i | (1 << j)].c = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist(dx,dy,cx[dp[(1 << n) - 1].c],cy[dp[(1 << n) - 1].c]) > dp[(1 << n) - 1].d)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return (conj(a)*b).real();}\nFP crs(P a,P b){return (conj(a)*b).imag();}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgtin(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lftin(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frtin(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bckin(T a){return shift(a,TOP,FRT,BTM,BCK);}\n\nint n;\nint hx,hy,mx,my;\n\nbool vis[1<<20][20];\nint cx[20],cy[20];\n\nvoid solve(){\n  CLR(vis);\n  cin >> hx >> hy >> mx >> my;\n  rep(i,n) cin >> cx[i] >> cy[i];\n  priority_queue<pair<double,PI > > q;\n  rep(i,n)q.push(mp(-abs(pt(hx,hy)-pt(cx[i],cy[i])),mp(i,1<<i)));\n  \n  while(!q.empty()){\n    double cc=-q.top().F;\n    int cv=q.top().S.F;\n    int vi=q.top().S.S;\n    q.pop();\n    if(cc+EPS>abs(pt(cx[cv],cy[cv])-pt(mx,my))) continue;\n    if(vis[vi][cv]) continue;\n    if(vi==(1<<n)-1){\n      cout << \"YES\" << endl;\n      return;\n    }\n    if(SZ(q)>1000000) break;\n    vis[vi][cv]=true;\n    bool ok=true;\n    rep(i,n){\n      if((vi>>i)&1) continue;\n      ok&=\n        abs(pt(cx[i],cy[i])-pt(mx,my))+EPS>\n        cc+abs(pt(cx[i],cy[i])-pt(cx[cv],cy[cv]));\n    }\n    if(!ok) continue;\n    rep(i,n){\n      if((vi>>i)&1) continue;\n      q.push(mp(-cc-abs(pt(cx[i],cy[i])-pt(cx[cv],cy[cv])),\n                mp(i,vi|(1<<i))));\n    }\n  }\n  \n  cout << \"NO\" << endl;\n}\n\nint main(int argc, char *argv[]){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\ntemplate <class T>\nT next_combination(T combi)\n{\n\tT leastBit = combi & -combi;\n\tT mostBits = combi + leastBit;\n\tT leastSequentialBits = combi & ~mostBits;\n\treturn mostBits | ((leastSequentialBits / leastBit) >> 1);\n}\nfloat dist(int x1, int y1, int x2, int y2)\n{\n\tint x = x1 - x2, y = y1 - y2;\n\treturn sqrt(0.0 + x*x + y*y);\n}\nint main()\n{\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n)\n\t{\n\t\tint x[32], y[32];\n\t\trep (i, n)\n\t\t\tcin >> x[i] >> y[i];\n\t\tx[n] = hx, y[n] = hy;\n\t\tx[n + 1] = dx, y[n + 1] = dy;\n\t\tfloat dis[32][32];\n\t\tfor (int i = 0; i <= n + 1; ++i)\n\t\t\tfor (int j = 0; j <= n + 1; ++j)\n\t\t\t\tdis[i][j] = dist(x[i], y[i], x[j], y[j]);\n\n\n\t\tstatic float dp[1 << 20][20], dp2[1 << 20][20];\n\t\tconst float INF = 1e9;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tdp[i][j] = dp2[i][j] = INF;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tdp[1 << i][i] = dis[n][i];\n\t\t\tdp2[1 << i][i] = 0;\n\t\t}\n\n\t\tstatic float fastest_devil[1 << 20];\n\t\tfastest_devil[0] = 0;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t{\n\t\t\tfastest_devil[i] = INF;\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (i >> j & 1)\n\t\t\t\t\tmin_swap(fastest_devil[i], dis[n + 1][j]);\n\t\t}\n\n\n\t\tbool res = false;\n\t\tfor (int bits = 2; bits <= n; ++bits)\n\t\t{\n\t\t\tbool alive = false;\n\t\t\tfor (int s = (1 << bits) - 1; s < 1 << n; s = next_combination(s))\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s >> i & 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin_swap(dp[s][i], dp[s ^ 1 << i][j] + dis[j][i]);\n\t\t\t\t\t\t\tmin_swap(dp2[s][i], dp2[s ^ 1 << i][j] + dis[j][i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dp[s][i] > dis[n + 1][i])\n\t\t\t\t\t\tdp[s][i] = INF;\n\n\t\t\t\t\tif (dp[s][i] != INF)\n\t\t\t\t\t\talive = true;\n\t\t\t\t}\n\n\t\t\t\tif (!alive)\n\t\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tif (bits >= n - bits)\n\t\t\t{\n\t\t\t\tconst int all = (1 << n) - 1;\n\t\t\t\tfor (int s = (1 << bits) - 1; s < 1 << n; s = next_combination(s))\n\t\t\t\t{\n\t\t\t\t\tint no_visit = s ^ all;\n\t\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!(s >> i & 1))\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (no_visit >> j & 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (dp[s][i] + dp2[no_visit][j] + dis[i][j] < fastest_devil[no_visit])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tres = true;\n\t\t\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (dp[(1 << n) - 1][i] < dis[n + 1][i])\n\t\t\t\tres = true;\n\nend:\n\t\tcout << (res ? \"YES\" : \"NO\") << endl;\n\n\t\t//cout.precision(9);\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//\tcout << dp[(1 << n) - 1][i] << \" / \" << dis[n + 1][i] << endl;\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//\tcout << dp2[(1 << n) - 1][i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  if ( now == n)return true;\n  rep(i,n){\n    if ( visited[i]==true)continue;\n    if ( r+adj[last][i] < adj[MAOU][i]){\n      visited[i]=true;\n      if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    REP(j,i+1,n)adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n  }\n  \n  bool visited[20]={true};\n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i]) < dist(rx-mx,ry-my)){\n      visited[i]=true;\n      if ( backTrack(i,dist(mx-x[i],my-y[i]),1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(cin>>n>>mx>>my>>rx>>ry && n){\n    int x[n],y[n];\n    rep(i,n)cin>>x[i]>>y[i];\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\n\nconst D EPS = 1e-8;\n\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\n\nP cr[21], d;\nint n;\nD dis[21][21], limit[20];\n\nbool solve(int bit, int p, D t) {\n  if (bit == 0) return true;\n  rep (i, n) if (bit & 1 << i) {\n    rep (j, n) if (bit & 1 << j) {\n      if (sig(t + dis[p][i], limit[j]) >= 0) goto next;\n    }\n    if (solve(bit ^ 1 << i, i, t + dis[p][i])) return true;\n  next:;\n  }\n  return false;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    cin  >> cr[n].X >> cr[n].Y >> d.X >> d.Y;\n    if (n == 0) break;\n    rep (i, n) cin >> cr[i].X >> cr[i].Y;\n    rep (i, n + 1) rep (j, n + 1) dis[i][j] = abs(cr[i] - cr[j]);\n    rep (i, n) limit[i] = abs(cr[i] - d);\n    cout << (solve((1 << n) - 1, n, 0) ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nstruct pos{\n\tint x;\n\tint y;\n};\nstruct rel{\n\tint to;\n\tint dis;\n};\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy){\n\t\tvector<pos> p;\n\t\tREP(k, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp.push_back({ x, y });\n\t\t}\n\t\tvector<vector<int>> r(n + 1, vector<int>(n + 1));\n\t\tvector<int> dr(n);\n\t\tREP(i, n + 1){\n\t\t\tif (i != n)\n\t\t\t\tdr[i] = (dx - p[i].x)*(dx - p[i].x) + (dy - p[i].y)*(dy - p[i].y);\n\n\t\t\tfor (int j = 0; j < n + 1; j++){\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (i != n  && j != n)r[i][j] = (p[i].x - p[j].x)*(p[i].x - p[j].x) + (p[i].y - p[j].y)*(p[i].y - p[j].y);\n\t\t\t\telse if (i == n)r[i][j] = (hx - p[j].x)*(hx - p[j].x) + (hy - p[j].y)*(hy - p[j].y);\n\t\t\t\telse if (j == n)r[i][j] = (p[i].x - hx)*(p[i].x - hx) + (p[i].y - hy)*(p[i].y - hy);\n\t\t\t}\n\t\t}\n\n\t\tbool b[21] = { false };\n\t\tREP(i, n)b[i] = true;\n\t\tint b_n = n;\n\t\tbool flag = false;\n\t\tfunction<void(double dis, int from)> f = [&](double dis, int from){\n\t\t\tif (flag)return;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (b[i] && (dis + sqrt(r[from][i]) + 1e-8) >= sqrt(dr[i]))return;\n\t\t\t}\n\t\t\t\n\t\t\tif (b_n != 0){\n\t\t\t\tfor (int i = 0; i < n && !flag; i++){\n\t\t\t\t\tif (b[i] && (dis + sqrt(r[from][i]))+1e-8<sqrt(dr[i])){\n\t\t\t\t\t\tb[i] = false;\n\t\t\t\t\t\tb_n--;\n\t\t\t\t\t\tf(dis + sqrt(r[from][i]), i);\n\t\t\t\t\t\tb[i] = true;\n\t\t\t\t\t\tb_n++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tflag = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn;\n\t\t};\n\t\tf(0.0, n); \n\t\tcout << (flag ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint n;\nint cx[22];\nint cy[22];\nbool f[22];\ndouble l[22][22];\nint s = 0;\ndouble d;\n\nint kansu( int x , int y ){\n\ts++;\n\tif ( s == n + 1 ) return 1;\n\td += l[x][y];\n\tf[y] = true;\n\tf[1] = true;\n\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\tif ( d + l[y][i] >= l[1][i] ) {\n\t\t\tf[1] = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ( f[1] ) {\n\t\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\t\tif ( f[i] ) continue;\n\t\t\tif ( kansu( y , i ) ) return 1;\n\t\t}\n\t}\n\ts--;\n\td -= l[x][y];\n\tf[y] = false;\n\treturn 0;\n}\n\nint main(){\n\twhile(true) {\n\t\tcin >> n >> cx[0] >> cy[0] >> cx[1] >> cy[1];\n\t\tif ( n == 0 ) break;\n\t\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tf[i] = false;\n\t\t}\n\t\tfor ( int i = 0; i < n + 1; i++ ) {\n\t\t\tfor ( int j = i + 1; j < n + 2; j++ ) {\n\t\t\t\tint x = cx[i]-cx[j];\n\t\t\t\tint y = cy[i]-cy[j];\n\t\t\t\tdouble z = x*x + y*y;\n\t\t\t\tl[i][j] = sqrt( z );\n\t\t\t\tl[j][i] = l[i][j];\n\t\t\t}\n\t\t}\n\t\ts = 0;\n\t\td = 0.00;\n\t\tl[0][0] = 0.00;\n\t\tf[0] = false;\n\t\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\t\tif ( kansu( 0 , 0 ) ) {\n\t\t\t\tf[0] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( f[0] ) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h> //pow , sqrt\nusing namespace std;\nstruct node{int x, y, limit;};\nint N, hx, hy, dx, dy;\nnode C[32];\nbool used[32];\n\nbool solve(double t, int p){\n  if (p == N) return true;\n  \n  for (int i = 0; i < N; i++){\n    if (!used[i]){\n      int newt = t + sqrt(pow(C[i].x-hx, 2) + pow(C[i].y-hy, 2));\n      if (newt >= C[i].limit) return false;\n      used[i] = true;\n      if (solve(newt, p+1)) return true;\n      used[i] = false;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while (1){\n    cin >> N >> hx >> hy >> dx >> dy;\n    if (!N) break;\n    for (int i = 0; i < N; i++){\n      cin >> C[i].x >> C[i].y;\n      C[i].limit = sqrt(pow(C[i].x-dx, 2) + pow(C[i].y-dy, 2));\n    }\n    fill_n(used, N, false);\n    if (solve(0, 0)){\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 20\n#define EPS 1e-9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX], ok;\nbool rec(int now, double total_dist, int depth){\n  if(ok) return true;\n  if(total_dist >= dist(d, crystal[now])){\n    return false;\n  }\n  if(depth == N){\n    ok = true;\n    return true;\n  }\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      Segment s = Segment(crystal[now], crystal[i]);\n      if(s.distanceSP(d) < total_dist) return false;\n      used[i] = true;\n      if(!ok && rec(i, total_dist + dist(crystal[now],crystal[i]), depth+1)){\n        return true;\n      }\n      used[i] = false;\n    }\n  }\n  return false;\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n  for(int i = 0 ; i < N ; i++){\n    ok = false;\n    memset(used, false, sizeof(used));\n    if(rec(i, dist(h, crystal[i]), 0)){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint n;\nint cx[22];\nint cy[22];\nbool f[22];\ndouble l[22][22];\nint s = 0;\ndouble d;\n\nint kansu( int x , int y ){\n\ts++;\n\tif ( s == n ) return 1;\n\td += l[x][y];\n\tf[y] = true;\n\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\tif ( f[i] ) continue;\n\t\tif ( d + l[y][i] >= l[1][i] ) break;\n\t\tif ( kansu( y , i ) ) return 1;\n\t}\n\ts--;\n\td -= l[x][y];\n\tf[y] = false;\n\treturn 0;\n}\n\nint main(){\n\twhile(true) {\n\t\tcin >> n >> cx[0] >> cy[0] >> cx[1] >> cy[1];\n\t\tif ( n == 0 ) break;\n\t\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tf[i] = false;\n\t\t}\n\t\tfor ( int i = 0; i < n + 1; i++ ) {\n\t\t\tfor ( int j = i + 1; j < n + 2; j++ ) {\n\t\t\t\tint x = cx[i]-cx[j];\n\t\t\t\tint y = cy[i]-cy[j];\n\t\t\t\tdouble z = x*x + y*y;\n\t\t\t\tl[i][j] = sqrt( z );\n\t\t\t\tl[j][i] = l[i][j];\n\t\t\t}\n\t\t}\n\t\ts = 0;\n\t\td = 0.00;\n\t\tf[0] = false;\n\t\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\t\tif ( kansu( 0 , i ) ) {\n\t\t\t\tf[0] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( f[0] ) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define INF (1<<30)\n#define EPS (double)(1e-5)\nusing namespace std;\nint n,hx,hy,dx,dy;\nint cx[22],cy[22];\n\ndouble L(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nbool solve(int m,int bit,double l){\n  if(bit == (1<<n)-1) return true;\n  for(int i = 1; i < n; i++){\n    if(bit&(1<<i))continue;\n    if( L(cx[m]-cx[i],cy[m]-cy[i]) + l + EPS > L(cx[i]-dx,cy[i]-dy)) return false;\n  }\n  for(int i = 1; i < n; i++){\n    if(bit&(1<<i))continue;\n    if(solve(i,bit|(1<<i),l+L(cx[m]-cx[i],cy[m]-cy[i]))) return true;\n  }\n  return false;\n}\n\nint main(void){\n  while(cin >> n >> cx[0] >> cy[0] >> dx >> dy && n){\n    n++;\n    for(int i = 1; i < n; i++){\n      cin >> cx[i] >> cy[i];\n    }\n    if( solve(0,1,0) ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *  Author: mizo0203\n *  Problem: 2008\n *  Status: Time Limit Exceeded\n *  Submission Date: 2012/04/14 23:23:19\n *\n *  方策：再帰関数による幅優先探索\n */\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint n; // (0 < n <= 20)\nint hx, hy, dx, dy;\nint cx[20], cy[20]; // (-1000 <= h, d, c <= 1000)\n\nvoid init() {\n}\n\nbool input() {\n  int i;\n\n  scanf(\"%d %d %d %d %d\", &n, &hx, &hy, &dx, &dy);\n  if (!n && !hx && !hy && !dx && !dy)\n    return false;\n  for (i = 0; i < n; i++)\n    scanf(\"%d %d\", &cx[i], &cy[i]);\n\n  return true;\n}\n\n// sum: 勇者の総移動距離^2 == 瘴気の半径^2\nbool recursive(long l, int x, int y, double sum) {\n  int i;\n  double dis;\n\n  for (i = 0; i < n; i++)\n    if (~l & 1 << i)\n      break;\n  if (i == n)\n    return true;\n\n  for (i = 0; i < n; i++) {\n    if (l & 1 << i)\n      continue;\n    dis = sqrt(pow(cx[i] - x, 2) + pow(cy[i] - y, 2));\n    //printf(\"%f %f\\n\", sum + dis, sqrt(pow(cx[i] - dx, 2) + pow(cy[i] - dy, 2)));\n    if (sum + dis >= sqrt(pow(cx[i] - dx, 2) + pow(cy[i] - dy, 2)))\n      continue;\n    if (recursive(l |= 1 << i, cx[i], cy[i], sum + dis))\n      return true;\n  }\n\n  return false;\n}\n\nint main() {\n  int i;\n\n  init();\n  while (input()) {\n    int pmt[20];\n    // [0, 1, 2, ....]というサイズnの配列を作成\n    for (i = 0; i < n; i++)\n      pmt[i] = i;\n    // 全ての順列を出力\n    if (recursive(0, hx, hy, 0))\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define EPS (1e-10)\n\nusing namespace std;\n\nint n;\ndouble hx, hy, dx, dy, cx[20], cy[20];\nbool got[20];\n\ndouble Dist( double xx, double yy )\n{\n\treturn sqrt(xx*xx + yy*yy);\n}\n\nbool search( int count, double t )\n{\n\tif(count == n) return true;\n\tbool hit = true;\n\tfor(int i=0; i < n; ++i) {\n\t\tif(got[i]) continue;\n\t\tdouble dist = (Dist(hx-cx[i], hy-cy[i]) + t);\n\t\thit &= (Dist(dx-cx[i], dy-cy[i]) > dist + EPS);\n\t}\n\tif(!hit) return false;\n\tdouble tx = hx, ty = hy;\n\tfor(int i=0; i < n; ++i) {\n\t\tif(got[i]) continue;\n\t\tgot[i] = true;\n\t\thx = cx[i]; hy = cy[i];\n\t\thit |= search(count + 1, (Dist(tx-cx[i], ty-cy[i]) + t));\n\t\tgot[i] = false;\n\t}\n\treturn hit;\n}\n\nint main( void )\n{\n\twhile(cin >> n >> hx >> hy >> dx >> dy) {\n\t\tif((int)(n + hx + hy + dx + dy) == 0) break;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tgot[i] = false;\n\t\t}\n\t\tif(search(0, 0))\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *  Author: mizo0203\n *  Problem: 2008\n *  Status: Time Limit Exceeded\n *  Submission Date: 2012/04/14 23:23:19\n *\n *  方策：next_permutation()を用いて全ての順列を試みる．\n *  結果：クリスタルが20個の場合，計算量が膨大になり，答えが出ない．\n *  20! = 2.43290201 × 10^18\n */\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint n; // (0 < n <= 20)\nint hx, hy, dx, dy;\nint cx[20], cy[20]; // (-1000 <= h, d, c <= 1000)\n\nvoid init() {\n}\n\nbool input() {\n  int i;\n\n  scanf(\"%d %d %d %d %d\", &n, &hx, &hy, &dx, &dy);\n  if (!n && !hx && !hy && !dx && !dy)\n    return false;\n  for (i = 0; i < n; i++)\n    scanf(\"%d %d\", &cx[i], &cy[i]);\n\n  return true;\n}\n\n// sum: 勇者の総移動距離^2 == 瘴気の半径^2\nbool manage(int m, long l, int x, int y, double sum) {\n  int i;\n  double dis;\n\n  /*\n   for (i = 0; i < n; i++) {\n   if (l & 1 << i)\n   printf(\"1\");\n   else\n   printf(\"0\");\n   }\n   printf(\" %ld\\n\", l);\n   */\n\n  if (n == m)\n    return true;\n\n  for (i = 0; i < n; i++) {\n    if (l & 1 << i)\n      continue;\n    dis = sqrt(pow(cx[i] - x, 2) + pow(cy[i] - y, 2));\n    // printf(\"%f %f\\n\", sum + dis, sqrt(pow(cx[i] - dx, 2) + pow(cy[i] - dy, 2)));\n    if (sum + dis >= sqrt(pow(cx[i] - dx, 2) + pow(cy[i] - dy, 2)))\n      continue;\n    if (manage(m + 1, l |= 1 << i, cx[i], cy[i], sum + dis))\n      return true;\n  }\n\n  return false;\n}\n\nint main() {\n  int i;\n\n  init();\n  while (input()) {\n    int pmt[20];\n    // [0, 1, 2, ....]というサイズnの配列を作成\n    for (i = 0; i < n; i++)\n      pmt[i] = i;\n    // 全ての順列を出力\n    if (manage(0, 0, hx, hy, 0))\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <functional>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<double, int> R;\ntypedef pair<P, R> Q;\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\tdouble r;\n\twhile (cin >> n >> hx >> hy >> dx >> dy) {\n\t\tif (n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) {\n\t\t\tbreak;\n\t\t}\n\t\thx -= dx;\n\t\thy -= dy;\n\t\tvector<P> data;\n\t\tint x, y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\tdata.push_back(P(x, y));\n\t\t}\n\t\tqueue<Q> q;\n\t\tq.push(Q(P(hx, hy), R(0.0, 0)));\n\t\tbool hantei = false;\n\t\twhile (!q.empty()) {\n\t\t\tQ p = q.front();\n\t\t\tq.pop();\n\t\t\tP xy = p.first;\n\t\t\tR limit = p.second;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tbool hantei2 = true;\n\t\t\t\tif ((limit.second & (1<<i)) == 0) {\n\t\t\t\t\tdouble dead = limit.first+sqrt(pow(data[i].first-xy.first, 2)+pow(data[i].second-xy.second, 2));\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif ((limit.second & (1<<j)) == 0) {\n\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead) {\n\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) > sqrt(pow(xy.first, 2)+pow(xy.second, 2))) {\n\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\tint k = limit.second | (1<<i);\n\t\t\t\t\t\tif (k == (1<<n)-1) {\n\t\t\t\t\t\t\thantei = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tif ((k & (1<<j)) == 0) {\n\t\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead+sqrt(pow(data[i].first-data[j].first, 2)+pow(data[i].second-data[j].second, 2))) {\n\t\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\t\tq.push(Q(data[i], R(dead, k)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hantei) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\n#define fi first\n#define se second\n\nint N;\nint hx, hy, mx, my;\ntypedef pair<double, double> P;\nP cs[21];\n\n#define SQ(x) ((x)*(x))\ninline double dist(P a, P b) {\n  return sqrt(SQ(a.fi-b.fi) + SQ(a.se-b.se));\n}\n\nunordered_map<int, double> umap;\n\ndouble G[22][22];\nbool dfs(int S, int now, double cost) {\n  \n  if(S == (1<<N)-1) {\n    return true;\n  }\n  \n  umap[S] = cost;\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(G[i][N+1] <= cost+G[now][i]) return false;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(umap.count(S|(1<<i)) && umap[S|(1<<i)] <= cost+G[now][i]) continue;\n    if(dfs(S|(1<<i), i, cost+G[now][i])) return true;\n  }\n  \n  return false;\n}\n\nbool solve() {\n  \n  for(int i=0; i<N; i++) {\n    for(int j=i+1; j<N; j++) {\n      G[i][j] = G[j][i] = dist(cs[i], cs[j]);\n    }\n    G[N][i] = G[i][N] = dist(P(hx, hy), cs[i]);\n    G[N+1][i] = G[i][N+1] = dist(P(mx, my), cs[i]);\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(dfs(1<<i, i, 0.)) return true;\n  }\n  \n  return false;\n}\n\nint main() {\n  while(1) {\n    cin >> N >> hx >> hy >> mx >> my;\n    if(!N) break;\n    for(int i=0; i<N; i++) {\n      cin >> cs[i].fi >> cs[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\n#define EPS 1e-9 //許容される誤差の程度\n\nint n;\ndouble hx, hy, gx, gy;\ndouble cry[2][1000];\nbool visit[1000];\n\nbool solve(int crynum, double radius, double x, double y)\n{\n\tif(crynum >= n)\n\t{\n\t\treturn true;\n\t}\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(!visit[i]\n\t\t\t&&( hypot(cry[0][i]-gx, cry[1][i]-gy) < hypot(cry[0][i]-x, cry[1][i]-y) + EPS))\n\t\t\treturn false;\n\t}\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tbool res = false;\n\t\t\n\t\tif(!visit[i])\n\t\t{\n\t\t\tvisit[i] = true;\n\t\t\tres = solve(crynum+1, radius + hypot(cry[0][i]-x, cry[1][i]-y), cry[0][i], cry[1][i]);\n\t\t\tvisit[i] = false;\n\t\t}\n\t\t\n\t\tif(res)\n\t\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> n >> hx >> hy >> gx >> gy, n)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tcry[0][i] = x;\n\t\t\tcry[1][i] = y;\n\t\t}\n\t\t\n\t\tmemset(visit, false, sizeof(visit));\n\t\tcout << (solve(0, 0, hx, hy)?\"YES\":\"NO\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nstruct pos{\n\tint x;\n\tint y;\n};\nstruct rel{\n\tint to;\n\tint dis;\n};\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy){\n\t\tvector<pos> p;\n\t\tREP(k, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp.push_back({ x, y });\n\t\t}\n\t\tvector<vector<int>> r(n + 1, vector<int>(n + 1));\n\t\tvector<int> dr(n);\n\t\tREP(i, n + 1){\n\t\t\tif (i != n)\n\t\t\t\tdr[i] = (dx - p[i].x)*(dx - p[i].x) + (dy - p[i].y)*(dy - p[i].y);\n\n\t\t\tfor (int j = 0; j < n + 1; j++){\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (i != n  && j != n)r[i][j] = (p[i].x - p[j].x)*(p[i].x - p[j].x) + (p[i].y - p[j].y)*(p[i].y - p[j].y);\n\t\t\t\telse if (i == n)r[i][j] = (hx - p[j].x)*(hx - p[j].x) + (hy - p[j].y)*(hy - p[j].y);\n\t\t\t\telse if (j == n)r[i][j] = (p[i].x - hx)*(p[i].x - hx) + (p[i].y - hy)*(p[i].y - hy);\n\t\t\t}\n\t\t}\n\n\t\tbool b[21] = { false };\n\t\tREP(i, n)b[i] = true;\n\t\tint b_n = n;\n\t\tbool flag = false;\n\t\tfunction<bool(double dis, int from)> f = [&](double dis, int from){\n\t\t\tif (flag)return true;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (b[i] && (dis + sqrt(r[from][i]))>=sqrt(dr[i]))return false;\n\t\t\t}\n\t\t\t\n\t\t\tif (b_n != 0){\n\t\t\t\tfor (int i = 0; i < n && !flag; i++){\n\t\t\t\t\tif (b[i] && (dis + sqrt(r[from][i]))<sqrt(dr[i])){\n\t\t\t\t\t\tb[i] = false;\n\t\t\t\t\t\tb_n--;\n\t\t\t\t\t\tf(dis + sqrt(r[from][i]), i);\n\t\t\t\t\t\tb[i] = true;\n\t\t\t\t\t\tb_n++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tflag = true;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn flag;\n\t\t};\n\t\tf(0.0, n); \n\t\tcout << (flag ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n  }\n  if ( now == n)return true;\n  \n  if ( fabs(r-adj[MAOU][last])<eps){\n    bool flag=true;\n    double val=0;\n    int farthest=-1;\n    rep(i,n){\n      if ( visited[i]==false && adj[last][i]>val)val=adj[last][i],farthest=i;\n    }\n    rep(i,n){\n      if (visited[i]==true)continue;\n      if ( adj[last][i]+adj[farthest][i]>adj[i][farthest])return false;\n    }\n    return true;\n  }  \n\n    rep(i,n){\n    if ( visited[i]==true)continue;\n    if ( r+adj[last][i] < adj[MAOU][i]){\n      visited[i]=true;\n      if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n  }\n  \n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i])+eps>dist(rx-x[i],ry-y[i]))return false;\n  }\n\n\n  bool visited[20]={false};\n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i]) < dist(rx-x[i],ry-y[i])){\n      visited[i]=true;\n      if ( backTrack(i,dist(mx-x[i],my-y[i]),1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(cin>>n>>mx>>my>>rx>>ry && n){\n    int x[n],y[n];\n    rep(i,n)cin>>x[i]>>y[i];\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cfloat>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n \nusing namespace std;\n \n#define fi first\n#define se second\ntypedef pair<double,double> P;\n \n#define MAX (21)\n#define INF (DBL_MAX/4)\n \ndouble G[MAX][MAX];\n \nint n;\nvector<P> crys;\nP h, d;\n \ndouble dist(P p1, P p2){\n  return sqrt(pow(p1.fi-p2.fi, 2.) + pow(p1.se-p2.se, 2.));\n}\n \nvoid makeEdge() {\n  for(int i=0; i<n; i++) {\n    G[i][i] = 0;\n    for(int j=i+1; j<n; j++) {\n      G[i][j] = G[j][i] = dist(crys[i], crys[j]);\n    }\n  }\n}\n \n\nvoid printbit(int x){\n  for(int i=0;i<n;i++){\n    cout<<((x>>i)&1);\n\n  }\n  cout<<endl;\n}\n\n \ntypedef unsigned long long ull;\nunordered_map<ull, double> dp;\n\nbool dfs(int S, int idx, double cost) {\n  \n  if(S==(1<<n)-1) {\n    return true;\n  }\n  \n  dp[S] = cost;\n  \n  bool ok = true;\n  for(int i=0; i<n; i++) {\n    ok = ok && cost + G[idx][i] < dist(crys[i], d);\n  }\n  if(!ok) return false;\n  \n  for(int i=0; i<n; i++){\n    if((S>>i)&1) continue;\n    double ncost = cost + G[idx][i];\n    double nS = S|(1<<i);\n    if(ncost >= dist(crys[i], d)) return false;\n    else {\n      if(dp.count(nS) && dp[nS] < ncost) continue;\n      if(dfs(nS, i, ncost)) return true;\n    }\n  }\n  \n  return false;\n}\n \nbool solve() {\n   \n  makeEdge();\n  \n  dp.clear();\n  dp[0] = INF;\n  for(int i=0; i<n; i++) {\n    if(dist(h, crys[i]) >= dist(crys[i], d)) continue;\n    if(dfs(1<<i, i, dist(h, crys[i]))) {\n      return true;\n    }\n  }\n  return false;\n}\n \nint main(){\n  while(true){\n    crys.clear();\n    cin >> n >> h.fi >> h.se >> d.fi >> d.se;\n    if(!n && !h.fi && !h.se && !d.fi && !d.se){\n      break;\n    }\n    crys.resize(n);\n    for(int i=0; i<n; i++){\n      cin >> crys[i].fi >> crys[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct { int x, y; } pt;\n\nint n;\npt hero, dragon;\n\ndouble eps = 1e-6;\n\nvector<pt> targets;\n\ndouble dist(pt& a, pt& b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\nbool nearer_from_hero(const pt& a, const pt& b) {\n    return dist(a, hero) < dist(b, hero);\n}\n\nbool can_visit(double d, map<int, bool>& visited, int k) {\n    // cerr << \"VISIT d=\" << d << \" k=\" << k << endl;\n\n    if (d >= dist(targets[k], dragon)) {\n        // cerr << \"NG \" << d << \" \" << targets[k].x << \",\" << targets[k].y << \" \" << dragon.x << \",\" << dragon.y << endl;\n        return false;\n    }\n\n    bool all_visited = true;\n    bool ok = false;\n\n    for (int i = 1; i <= n; ++i) {\n        if (i == k || visited[i]) {\n            continue;\n        }\n\n        all_visited = false;\n\n        visited[i] = true;\n        double delta = dist(targets[i], targets[k]);\n        if (can_visit(d + delta, visited, i)) {\n            ok = true;\n        }\n        visited[i] = false;\n        if (ok) break;\n    }\n\n    return all_visited || ok;\n}\n\nbool nearer_dragon(pt a, pt b) {\n    return dist(a, dragon) < dist(b, dragon);\n}\n\nint main() {\n    while (true) {\n        cin >> n >> hero.x >> hero.y >> dragon.x >> dragon.y;\n        if (n == 0) break;\n\n        bool ng = false;\n        targets.clear();\n\n        int s = 0;\n        map< pair<int, int>, bool > seen;\n        for (int i = 0; i < n; ++i) {\n            pt t;\n            cin >> t.x >> t.y;\n            if (seen[make_pair(t.x, t.y)]) {\n                s++;\n                continue;\n            }\n\n            seen[make_pair(t.x, t.y)] = true;\n\n            if (dist(t, hero) >= dist(t, dragon) - eps) {\n                ng = true;\n            }\n\n            targets.push_back(t);\n        }\n        sort(targets.begin(), targets.end(), nearer_from_hero);\n        targets.insert(targets.begin(), hero);\n\n        n -= s;\n\n        map<int, bool> v;\n        for (int i = 0; i <= n; ++i) {\n            v[i] = false;\n        }\n        cout << (!ng && can_visit(0, v, 0) ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define INF 0x7FFFFFFF\n#define dist(x1,y1,x2,y2) sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))\n\nint n;\ndouble cx[20], cy[20], hx, hy, dx, dy, S[1 << 10];\n\nint solve(double x,double y,int bit,double sum){\n\tint i;\n\tif(S[bit] > sum)\n\t\tS[bit] = sum;\n\telse\n\t\treturn 0;\n\tif(bit == 0) // すべてのクリスタルを集めたら\n\t\treturn 1;\n/*\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & bit) && sum >= dist(cx[i],cy[i],dx,dy)) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}*/\n\tfor(i = 0;i < n;i++){\n\t\tif(((1 << i) & bit) && sum + dist(x,y,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i]) && solve(cx[i],cy[i],bit ^ (1 << i),sum + dist(x,y,cx[i],cy[i])))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(void){\n\tint i;\n\twhile(1){\n\t\tscanf(\"%d%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tS[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tif(solve(hx,hy,(1 << n) - 1,0))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nvi x,y;\nint n,a,b,c,d;\nbool f(int q,int nx,int ny,double t){\n\tif(q==(1<<n)-1)return 1;\n\trep(i,n)if((q&1<<i)==0&&(hypot(nx-x[i],ny-y[i])+t+EPS>hypot(c-x[i],d-y[i])))return 0;\n\trep(i,n)if((q&1<<i)==0&&f(q^1<<i,x[i],y[i],t+hypot(nx-x[i],ny-y[i])))return 1;\n\treturn 0;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tcin>>a>>b>>c>>d;\n\t\ty=x=vi(n);\n\t\trep(i,n)cin>>x[i]>>y[i];\n\t\tcout<<(f(0,a,b,0)?\"YES\":\"NO\")<<endl;\n\t}\n\tcin>>n>>n>>n>>n;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< double , Pi > Pii;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 55;\n\ndouble dp[1 << 20][20];\nint main(){\n  int n, hx, hy, dx, dy;\n  vector< char > near(1 << 20);\n\n  for(int i = 0; i < 1 << 20; i++){\n    for(int k = 0; k < 20; k++){\n      if((i >> k) & 1) continue;\n      near[i] = k;\n      break;\n    }\n  }\n  while(cin >> n >> hx >> hy >> dx >> dy, n|hx|hy|dx|dy){\n\n    vector< Pii > c(n);\n    for(int i = 0; i < n; i++){\n      cin >> c[i].sc.fr >> c[i].sc.sc;\n      c[i].fr = sqrt( pow( dx - c[i].sc.fr, 2) + pow( dy - c[i].sc.sc, 2));\n    }\n    sort( ALL(c));\n\n    fill_n( *dp, (1 << 20) * 20, 1e9);\n    for(int i = 0; i < n; i++){\n      double dist = sqrt(pow(hx - c[i].sc.fr, 2) + pow(hy - c[i].sc.sc, 2));\n      if(dist < sqrt(pow(dx - c[i].sc.fr, 2) + pow(dy - c[i].sc.sc, 2))){\n        dp[1 << i][i] = dist;\n      }\n    }\n\n    for(int i = 0; i < (1 << n) - 1; i++){\n      for(int j = 0; j < n; j++){ //前のクリスタル\n        if(!((i >> j) & 1) || dp[i][j] == 1e9) continue;\n        if(sqrt( pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) >= dp[i][j]) continue;\n        for(int k = 0; k < n; k++){\n          if((i >> k) & 1) continue;\n          double next = dp[i][j] + sqrt(pow( c[j].sc.fr - c[k].sc.fr, 2) + pow( c[j].sc.sc - c[k].sc.sc, 2));\n          if(next >= dp[i|(1 << k)][k]) continue;\n          //条件に合えば次へ進む\n          bool check = sqrt(pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) > next;\n          if(check) dp[i|(1 << k)][k] = next;\n        }\n      }\n    }\n\n    bool check = n == 0;\n    for(int i = 0; i < n; i++){\n      check |= dp[(1 << n) - 1][i] < 1e9;\n    }\n    if(check) cout << \"YES\" << endl;\n    else cout <<\"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,h,w,d,e,x,y;\ndouble k;\ndouble j(int f,int g){return sqrt(f*f+g*g+0.0);}\nint main(){\n\twhile(1){\n\tcin>>n>>x>>y>>d>>e;\n\tif(!n)break;\n\tcin>>h>>w;\n\tbool o=(k<j(d-x,e-y));\n\tn--,k=j(h-x,w-y);\n\twhile(n--){\n\t\tcin>>x>>y;\n\t\tif(k+j(h-x,w-y)>=j(d-x,e-y))o=0;\n\t}\n\tif(o)cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n  }\n  if ( now == n)return true;\n  rep(i,n){\n    if ( visited[i]==true)continue;\n    if ( r+adj[last][i] < adj[MAOU][i]){\n      visited[i]=true;\n      if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n  }\n  \n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i])+eps>dist(rx-x[i],ry-y[i]))return false;\n  }\n\n\n  bool visited[20]={false};\n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i]) < dist(rx-x[i],ry-y[i])){\n      visited[i]=true;\n      if ( backTrack(i,dist(mx-x[i],my-y[i]),1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(cin>>n>>mx>>my>>rx>>ry && n){\n    int x[n],y[n];\n    rep(i,n)cin>>x[i]>>y[i];\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-14;\n\nint N;\nP D;\nvector<P> ps;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, int p) {\n  double dist = abs(D - ps[p]);\n  return !( equals(dist, t) || dist < t );\n}\n\nbool rec(int state, double t, int p) {\n  if(state == (1<<N)-1) return true;\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    if(!canExist(t+abs(ps[i] - ps[p]), i)) return false;\n  }\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    double nt = t + abs(ps[i] - ps[p]);\n    if(rec(state|(1<<i), nt, i)) return true;\n  }\n  return false;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy\n\t&&(N|hx|hy|dx|dy) ) {\n    D = P(dx, dy);\n    ps.resize(N+1);\n    ps[N-1] = P(hx, hy);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(rec(0, 0.0, N)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define MAXNUM 20\n\nstruct status{\n\tdouble d;\n\tint c;\n};\n\ndouble dist(double x1,double y1,double x2,double y2){\n\treturn sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\nint main(void){\n\tint i, j, n;\n\tdouble hx, hy, dx, dy, cx[MAXNUM],cy[MAXNUM];\n\tstruct status dp[1 << MAXNUM];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tscanf(\"%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0.0 && hy == 0.0 && dx == 0.0 && dy == 0.0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < 1 << MAXNUM;i++)\n\t\t\tdp[i].d = -1;\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tdp[1 << i].d = dist(hx,hy,cx[i],cy[i]);\n\t\t\tdp[1 << i].c = i;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i].d != -1){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & (1 << j) && (dp[i | (1 << j)].d == -1 || dp[i | (1 << j)].d > dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]))){\n\t\t\t\t\t\tdp[i | (1 << j)].d = dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]);\n\t\t\t\t\t\tdp[i | (1 << j)].c = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist(dx,dy,cx[dp[(1 << n) - 1].c],cy[dp[(1 << n) - 1].c]) > dp[(1 << n) - 1].d)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\ntemplate <class T>\nT next_combination(T combi)\n{\n\tT leastBit = combi & -combi;\n\tT mostBits = combi + leastBit;\n\tT leastSequentialBits = combi & ~mostBits;\n\treturn mostBits | ((leastSequentialBits / leastBit) >> 1);\n}\ndouble dist(int x1, int y1, int x2, int y2)\n{\n\tint x = x1 - x2, y = y1 - y2;\n\treturn sqrt(0.0 + x*x + y*y);\n}\nint main()\n{\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n)\n\t{\n\t\tint x[32], y[32];\n\t\trep (i, n)\n\t\t\tcin >> x[i] >> y[i];\n\t\tx[n] = hx, y[n] = hy;\n\t\tx[n + 1] = dx, y[n + 1] = dy;\n\t\tdouble dis[32][32];\n\t\tfor (int i = 0; i <= n + 1; ++i)\n\t\t\tfor (int j = 0; j <= n + 1; ++j)\n\t\t\t\tdis[i][j] = dist(x[i], y[i], x[j], y[j]);\n\n\n\t\tstatic double dp[1 << 20][20], dp2[1 << 20][20];\n\t\tconst double INF = 1e9;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tdp[i][j] = dp2[i][j] = INF;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tdp[1 << i][i] = dis[n][i];\n\t\t\tdp2[1 << i][i] = 0;\n\t\t}\n\n\t\tstatic double fastest_devil[1 << 20];\n\t\tfastest_devil[0] = 0;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t{\n\t\t\tfastest_devil[i] = INF;\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (i >> j & 1)\n\t\t\t\t\tmin_swap(fastest_devil[i], dis[n + 1][j]);\n\t\t}\n\n\n\t\tbool res = false;\n\t\tfor (int bits = 2; bits <= n; ++bits)\n\t\t{\n\t\t\tbool alive = false;\n\t\t\tfor (int s = (1 << bits) - 1; s < 1 << n; s = next_combination(s))\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s >> i & 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin_swap(dp[s][i], dp[s ^ 1 << i][j] + dis[j][i]);\n\t\t\t\t\t\t\tmin_swap(dp2[s][i], dp2[s ^ 1 << i][j] + dis[j][i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dp[s][i] > dis[n + 1][i])\n\t\t\t\t\t\tdp[s][i] = INF;\n\n\t\t\t\t\tif (dp[s][i] != INF)\n\t\t\t\t\t\talive = true;\n\t\t\t\t}\n\n\t\t\t\tif (!alive)\n\t\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tif (bits >= n - bits)\n\t\t\t{\n\t\t\t\tconst int all = (1 << n) - 1;\n\t\t\t\tfor (int s = (1 << bits) - 1; s < 1 << n; s = next_combination(s))\n\t\t\t\t{\n\t\t\t\t\tint no_visit = s ^ all;\n\t\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!(s >> i & 1))\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (no_visit >> j & 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (dp[s][i] + dp2[no_visit][j] + dis[i][j] < fastest_devil[no_visit])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tres = true;\n\t\t\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (dp[(1 << n) - 1][i] < dis[n + 1][i])\n\t\t\t\tres = true;\n\nend:\n\t\tcout << (res ? \"YES\" : \"NO\") << endl;\n\n\t\t//cout.precision(9);\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//\tcout << dp[(1 << n) - 1][i] << \" / \" << dis[n + 1][i] << endl;\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//\tcout << dp2[(1 << n) - 1][i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<int(n); i++)\n#define pii pair<int,int>\n#define fs first\n#define sc second\n\ntypedef pair<pii,int> po;\n\nint n;\n\nbool cmp(po lhs, po rhs) {\n  if(lhs.sc!=rhs.sc) return lhs.sc<rhs.sc;\n  else return lhs.fs.fs<rhs.fs.fs;\n}\n\nbool rec(int bit, int t, const vector<po> c) {\n  rep(k,n){\n    if (t >= c[k].sc && (bit >> k)%2 == 1) return false; \n    else if (!rec(bit^(1<<k), t+1, c)) return false;\n  }\n  return true;\n}\n\nint main(){\n  int hx,hy,dx,dy,x,y;\n  while (cin>>n>>hx>>hy>>dx>>dy && n>0) {\n    vector<po> c(n);\n    rep(i,n){\n      cin >> x >> y;\n      c[i].fs.fs = x;\n      c[i].fs.sc = y;\n      c[i].sc = (x-dx)*(x-dx) + (y-dy)*(y-dy);\n    }\n    sort(c.begin(),c.end(),cmp);\n    bit = (1<<(n+1))-1;\n    if(rec(bit,0,c)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nint n;\nint dx, dy;\nint cx[21], cy[21];\ndouble dist[21][21];\ndouble limit[20];\n\nbool dfs(int pos, int visited, double sum) {\n\tif(visited == (1 << n) - 1)\n\t\treturn true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(visited & (1 << i))\n\t\t\tcontinue;\n\n\t\tconst double next = sum + dist[pos][i];\n\t\tfor(int j = 0; j < n; ++j)\n\t\t\tif(!(visited & (1 << j)) && next + dist[i][j] >= limit[j])\n\t\t\t\tgoto next;\n\n\t\tif(dfs(i, (visited | (1 << i)), next))\n\t\t\treturn true;\n\n\tnext:;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tconst int INF = 0xfffffff;\n\n\twhile(cin >> n, cin >> cx[n] >> cy[n] >> dx >> dy, n) {\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tcin >> cx[i] >> cy[i];\n\n\t\tfor(int i = 0; i <= n; ++i)\n\t\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t\t\tdist[i][j] = dist[j][i] = hypot(cx[i] - cx[j], cy[i] - cy[j]);\n\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tlimit[i] = hypot(cx[i] - dx, cy[i] - dy);\n\n\t\tcout << (dfs(n, 0, 0.0) ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX], ok;\nbool dp[1<<MAX][MAX];\n\nbool rec(int S, int v, double total_dist){\n  if(ok) return true;\n  if(total_dist >= dist(d, crystal[v])){\n    return false;\n  }\n\n  if(dp[S][v]) return true;\n\n  if(S == (1 << N) - 1){\n    return dp[S][v] = ok = true;\n  }\n  bool res = false;\n  for(int u = 0 ; u < N ; u++){\n    Segment s = Segment(crystal[v], crystal[u]);\n    if(s.distanceSP(d) < total_dist) return false;\n    if(total_dist+dist(crystal[v],crystal[u]) >= dist(d, crystal[u])){\n      return false;\n    }\n    if(!(S >> u & 1)){\n      return rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]));\n    }\n  }\n  return dp[S][v] = false;\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n\n  for(int i = 0 ; i < N ; i++){\n    ok = false;\n    memset(dp, false, sizeof(dp));\n    memset(used, false, sizeof(used));\n    if(rec(0, i, dist(h, crystal[i]))){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n}; \n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool rec(int S, int v, double total_dist){\n  if(S == (1 << N) - 1){\n    return true;\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1)){\n      if(total_dist + dist(crystal[v],crystal[u]) >= dist(d, crystal[u])){\n        return false;\n      }\n    }\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1)){\n      if(rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]))){\n        return true;\n      }\n    }\n  }\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    if(rec(0,i,dist(h,crystal[i]))){\n      return true;\n    }\n  }  \n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cmath>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < int(n); ++i)\n\nint x[30], y[30];\ndouble mem[1<<20][21];\n\nint main() {\n  int n, hx, hy, dx, dy;\n  for (;;) {\n    cin >> n >> hx >> hy >> dx >> dy;\n    if (n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) break;\n    rep (i, 1 << n) rep (j, n + 1) mem[i][j] = 1e+10;\n    rep (i, n) cin >> x[i] >> y[i];\n    rep (i, n) x[i] -= dx;\n    rep (i, n) y[i] -= dy;\n    x[n] = hx - dx;\n    y[n] = hy - dy;\n    priority_queue<pair<pair<int, double>, pair<int, int> > > que;\n    que.push(make_pair(make_pair(n, 0), make_pair((1 << n) - 1, n)));\n    while (!que.empty()) {\n      pair<pair<int, double>, pair<int, int> > now = que.top();\n      que.pop();\n      int num = now.first.first;\n      double time = -now.first.second;\n      int bit = now.second.first;\n      int pos = now.second.second;\n      if (bit == 0) {\n\tcout << \"YES\" << endl;\n\tgoto aaa;\n      }\n      if (mem[bit][pos] <= time) continue;\n      mem[bit][pos] = time;\n      //cout << time << \" \" << bit << \" \" << pos << endl;\n      rep (i, n) if (1 << i & bit) {\n\tdouble ntime = time + sqrt(pow(x[pos] - x[i], 2) + pow(x[pos] - x[i], 2));\n\tif (ntime >= sqrt(pow(x[i], 2) + pow(y[i], 2)) - 1e-8) break;\n\tque.push(make_pair(make_pair(num - 1, -ntime), make_pair(bit ^ 1 << i, i)));\n      }\n    }\n    cout << \"NO\" << endl;\n  aaa:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double INF = DBL_MAX / 1000;\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        Point h, d;\n        cin >> n >> h.x >> h.y >> d.x >> d.y;\n        if(n == 0)\n            return 0;\n\n        ++ n;\n        vector<Point> p(n);\n        p[0] = h;\n        for(int i=1; i<n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        vector<double> distDevil(n);\n        for(int i=0; i<n; ++i)\n            distDevil[i] = d.dist(p[i]);\n\n        vector<vector<double> > dist(n, vector<double>(n));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                dist[i][j] = p[i].dist(p[j]);\n            }\n        }\n\n        vector<vector<double> > dp(1<<n, vector<double>(n, INF));\n        dp[1][0] = 0.0;\n        for(int i=0; i<(1<<n); ++i){\n            bitset<21> bs(i);\n            for(int j=0; j<n; ++j){\n                for(int k=0; k<n; ++k){\n                    if(bs[k])\n                        continue;\n                    bs[k] = true;\n                    double t = dp[i][j] + dist[j][k];\n                    if(t < distDevil[k] - EPS)\n                        dp[bs.to_ulong()][k] = t;\n                    bs[k] = false;\n                }\n            }\n        }\n\n        double ret = *min_element(dp[(1<<n)-1].begin(), dp[(1<<n)-1].end());\n        if(ret < INF / 10)\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define MAX 21\n#define INF 10000\n#define EPS 1.0e-10\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point;\ndouble dist(const point &a, const point &b){return std::abs(b-a);}\nbool vis[MAX];\nbool bt(const vector<point> &v, double walk, const point &h, const point &d){\n\tbool bCont = false;\n\n\tfor(unsigned int i = 0; i < v.size(); ++i){/*cout<<vis[i]<<' ';*/if( !vis[i] )bCont=true;}if( !bCont )return true;\n\t//cout << endl;\n\n\tfor(unsigned int i = 0; i < v.size(); ++i){\n\t\tif( !vis[i] ){\n\t\t\tdouble t = walk + dist(h,v[i]);\n\t\t\tif( t < dist(d, v[i]) ){\n\t\t\t\tvis[i] = true;\n\t\t\t\tif( bt( v, t, v[i], d ) )\n\t\t\t\t\treturn true;\n\t\t\t\tvis[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tbool bImpossible = false;\n\t\tint n,hx,hy,dx,dy;\n\t\tpoint hero, daemon;\n\t\tvector< point > vp;\n\n\t\tscanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy);\n\t\tif(!(n||hx||hy||dx||dy))break;\n\t\t\n\t\thero = complex<elem>(hx,hy);\n\t\tdaemon = complex<elem>(dx,dy);\n\t\t\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint cx,cy;scanf(\"%d%d\", &cx, &cy);point p(cx,cy);\n\t\t\tif(cx==hx&&cy==hy)continue;\n\t\t\tvp.push_back( p );\n\t\t\tif( dist(daemon,p) <= dist(hero,p) )bImpossible=true;\n\t\t\tvis[i]=false;\n\t\t}\n\t\t\n\t\tif( !bImpossible && bt( vp, 0.0, hero, daemon ) )\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define INF 0x7FFFFFFF\n#define dist(x1,y1,x2,y2) sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))\n\nint n;\ndouble cx[20], cy[20], hx, hy, dx, dy;\n\nint solve(double x,double y,int bit,double sum){\n\tint i;\n\tif(bit == 0) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & bit) && sum >= dist(cx[i],cy[i],dx,dy)) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(((1 << i) & bit) && sum + dist(x,y,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i]) && solve(cx[i],cy[i],bit ^ (1 << i),sum + dist(x,y,cx[i],cy[i])))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(void){\n\tint i;\n\twhile(1){\n\t\tscanf(\"%d%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tif(solve(hx,hy,(1 << n) - 1,0))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef complex<double> P;\nint n,ans;\nP p[21],s1,s2;\ndouble tx,ty,sx,sy,gx,gy;\nvoid dfs(int v,int now,double t){\n    if(v==(1<<n)-1)ans=1;\n    else{\n        r(i,n)if(!(v&(1<<i))){\n            int flsg=0;\n            r(j,n)if(!(v&(1<<j))&&j!=i&&(abs(s2-p[j])<=abs(s1-p[i])+abs(p[i]-p[j])))flsg++;\n            if(!flsg)dfs(v|(1<<i),i,t+abs(s1-p[i]));\n        }\n    }\n}\nint main(){\n    while(cin>>n>>sx>>sy>>gx>>gy,n){\n        s1=P(sx,sy);\n        s2=P(gx,gy);\n        ans=0;\n        r(i,n){\n            cin>>tx>>ty;\n            p[i]=P(tx,ty);\n        }\n        dfs(0,-1,0);\n        if(ans)cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> x, y;\nvector<int> viewed;\n\ndouble dist(int a, int b){\n    return sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));\n}\n\nbool dfs(int v, double t, int c){\n    if(c == n) return true;\n\n    for(int i=0;i<n;i++){\n        if(viewed[i]) continue;\n        if(t + dist(v, i) >= dist(i, n+1)) return false;\n    }\n\n    for(int i=0;i<n;i++){\n        if(viewed[i]) continue;\n        double nt = t + dist(v, i);\n        if(nt < dist(i, n+1)){\n            viewed[i] = true;\n            if(dfs(i, nt, c+1)) return true;\n            viewed[i] = false;\n        }\n    }\n\n    return false;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        x.assign(n+2, 0);\n        y.assign(n+2, 0);\n        cin >> x[n] >> y[n] >> x[n+1] >> y[n+1];\n        for(int i=0;i<n;i++){\n            cin >> x[i] >> y[i];\n        }\n        viewed.assign(n, 0);\n        if(dfs(n, 0, 0)){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nint n;\nVVD dp;\nVVB done;\nVVD dist;\nVD limit;\nvector<P> p_cristal;\n\ndouble euclid_distance(P p1, P p2)\n{\n\treturn sqrt(norm(p2 - p1));\n}\n\ndouble optimal_time(int status, int position)\n{\n\tif (done[status][position]) {\n\t\treturn dp[status][position];\n\t}\n\tif (!(status & BIT(position))) {\n\t\treturn INF;\n\t}\n\tint prev_status = status ^ BIT(position);\n\tif (prev_status == 0) {\n\t\t// Hero to this position\n\t\tdp[status][position] = dist[dist.size()-1][position];\n\t} else {\n\t\tFOR (prev_position, 0, n) {\n\t\t\tdp[status][position] = min(dp[status][position], optimal_time(prev_status, prev_position) + dist[prev_position][position]);\n\t\t}\n\t}\n\tdone[status][position] = true;\n\tif (dp[status][position] >= limit[position]) {\n\t\treturn dp[status][position] = INF;\n\t} else {\n\t\treturn dp[status][position];\n\t}\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n ^ hx ^ hy ^ dx ^ dy) {\n\t\tp_cristal.clear();\n\t\tREP (_, n) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tp_cristal.PB(P(x, y));\n\t\t}\n\t\tp_cristal.PB(P(hx, hy)); // NOTICE: Push Hero\n\t\tdist = VVD(p_cristal.size(), VD(p_cristal.size()));\n\t\tREP (i, p_cristal.size()) {\n\t\t\tREP (j, p_cristal.size()) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdist[i][j] = euclid_distance(p_cristal[i], p_cristal[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlimit = VD(p_cristal.size(), 0);\n\t\tREP (i, limit.size()) {\n\t\t\tlimit[i] = euclid_distance(p_cristal[i], P(dx, dy));\n\t\t}\n\n\t\tdp = VVD(BIT(n), VD(n, INF));\n\t\tdone = VVB(BIT(n), VB(n, false));\n\t\tFOR (c, 1, n) {\n\t\t\tif (c > 2) {\n\t\t\t\tint comb = (1 << (c-2)) - 1;\n\t\t\t\twhile (comb < 1 << n) {\n\t\t\t\t\t// Release memory\n\t\t\t\t\tdp[comb].clear();\n\t\t\t\t\tint lsb = comb & -comb;\n\t\t\t\t\tint upper = comb + lsb;\n\t\t\t\t\tint downer = ((comb & ~upper) / lsb) >> 1;\n\t\t\t\t\tcomb = upper | downer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint comb = (1 << c) - 1;\n\t\t\twhile (comb < 1 << n) {\n\t\t\t\tdp[comb] = VD(n, INF);\n\t\t\t\tREP (p, n) {\n\t\t\t\t\toptimal_time(comb, p);\n\t\t\t\t}\n\t\t\t\tint lsb = comb & -comb;\n\t\t\t\tint upper = comb + lsb;\n\t\t\t\tint downer = ((comb & ~upper) / lsb) >> 1;\n\t\t\t\tcomb = upper | downer;\n\t\t\t}\n\t\t}\n\n\t\t// Check if possible\n\t\tint final_status = BIT(n) - 1;\n\t\tdouble t_ans = INF;\n\t\tREP (p, n) {\n\t\t\tt_ans = min(t_ans, optimal_time(final_status, p));\n\t\t}\n\t\tif (t_ans != INF) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 20;\nconst double inf = 1e100;\nconst double eps = 1e-8;\n\n\nstruct State {\n  char p;\n  int c;\n  double time;\n  bool operator < (const State &s) const {\n    return time > s.time;\n  }\n};\n\nint N;\nP H, D;\nvector<P> ps;\nbool vis[1<<MAXN][MAXN+1];\ndouble border[1<<MAXN];\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, P p) {\n  double d = abs(D - p);\n  return !equals(d, t) && d > t;\n}\n\nvoid makeBorder() {\n  for(int i = 0; i < (1<<N); ++i) {\n    border[i] = inf;\n    for(int j = 0; j < N; ++j) {\n      if(i & (1<<j)) continue;\n      border[i] = min(border[i], abs(D - ps[j]));\n    }\n  }\n}\n\nbool dijkstra() {\n  priority_queue<State> que;\n  State s = (State){N, 0, 0.0};\n  fill(vis[0], vis[1<<MAXN], false);\n  que.push(s);\n  while(!que.empty()) {\n    s = que.top();\n    que.pop();\n    if(vis[s.c][s.p]) continue;\n    vis[s.c][s.p] = true;\n    if(s.c == (1<<N)-1) {\n      return true;\n    }\n    for(int k = 0; k < N; ++k) {\n      if(s.c & (1<<k)) continue;\n      const P &p = (s.p == N) ? H : ps[s.p];\n      const P &q = ps[k];\n      double dist = abs(q - p);\n      double nt = s.time + dist;\n      if(!canExist(nt, q)) continue;\n      State t = (State){k, s.c|(1<<k), nt};\n      if(vis[t.c][t.p]) continue;\n      if(t.time > border[t.c]+eps) continue;\n      que.push(t);\n    }\n  }\n  return false;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy && \n\t( N | hx | hy | dx | dy ) ) {\n    H = P(hx,hy);\n    D = P(dx,dy);\n    ps.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    makeBorder();\n    if(dijkstra()) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// Dragon Fantasy(2008)\nclass Point\n{\npublic:\n\tint x, y;\n\tdouble d;\n};\n\nclass LessDistance\n{\npublic:\n\tbool operator() (const Point& lhs, const Point& rhs)\n\t{\n\t\treturn lhs.d < rhs.d;\n\t}\n};\n\nconst int cc[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575 };\n\nint n, dx, dy;\n\nbool solve(int hx, int hy, int gc, double r, const vector<Point>& c)\n{\n\tif (gc == cc[n])\n\t\treturn true;\n\n\tbool yes = false;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (gc & (1 << i))\n\t\t\tcontinue;\n\t\tdouble rr = r + sqrt(static_cast<double>((hx-c[i].x)*(hx-c[i].x) + (hy-c[i].y)*(hy-c[i].y)));\n\t\tdouble d = sqrt(static_cast<double>((dx-c[i].x)*(dx-c[i].x) + (dy-c[i].y)*(dy-c[i].y)));\n\t\tif (d <= rr)\n\t\t\treturn false;\n\t\tyes |= solve(c[i].x, c[i].y, gc | (1 << i), rr, c);\n\t\tif (yes)\n\t\t\tbreak;\n\t}\n\treturn yes;\n}\n\nint main()\n{\n\t//freopen(\"2008.txt\", \"r\", stdin);\n\n\tint hx, hy;\n\twhile (scanf(\"%d %d %d %d %d\", &n, &hx, &hy, &dx, &dy) != EOF) {\n\t\tif (n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\n\t\tvector<Point> c(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tscanf(\"%d %d\", &c[i].x, &c[i].y);\n\t\t\tc[i].d = sqrt(static_cast<double>((dx-c[i].x)*(dx-c[i].x) + (dy-c[i].y)*(dy-c[i].y)));\n\t\t}\n\t\tsort(c.begin(), c.end(), LessDistance());\n\n\t\tif (solve(hx, hy, 0, 0.0, c))\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std; \nint n,h1,h2,d1,d2,x,y,s1,s2;\n  \ndouble dist(int a, int b){\n    return sqrt(a*a+b*b+0.0);\n}\n  \nbool solve(){\n    if(dist(h1-s1,h1-s2) + dist(s1-x,s2-x) >= dist(d1-x,d2-x)) return false;\n    return true;\n}\n  \nint main(){\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        cin>>h1>>h2>>d1>>d2;\n\t\tbool ok=true;\n\t\tcin>>s1>>s2;\n\t\tif(dist(h1-s1,h1-s2)>=dist(d1-s1,d2-s2))ok=false;\n        for(int i=0;i<n-1;i++){\n\t\t\tcin>>x>>y;\n\t\t\tif(!solve())ok=false;\n\t\t}\n        if(ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P> PP;\n#define INF (1<<24)\n#define EPS 1e-10\nint n;\ndouble sx,sy,tx,ty,px[20],py[20];\n\ndouble dis(double a,double b,double c,double d)\n{return sqrt((a-c)*(a-c)+(b-d)*(b-d));}\ndouble dis(int a,int b){return dis(px[a],py[a],px[b],py[b]);}\n\nbool dfs(int S,int pos,double cost){\n  if(S==(1<<n)-1)return true;\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(cost+dis(pos,i)>=dis(tx,ty,px[i],py[i]))return false;\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(cost+dis(pos,i)>=dis(tx,ty,px[i],py[i]))continue;\n    if(dfs(S|(1<<i),i,cost+dis(pos,i)))return true;\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i=0;i<n;i++){\n    if(dfs((1<<i),i,dis(sx,sy,px[i],py[i])))return true;\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin>>n>>sx>>sy>>tx>>ty;\n    if(n==0&&sx==0&&sy==0&&tx==0&&ty==0)break;\n    for(int i=0;i<n;i++)cin>>px[i]>>py[i];\n    cout<<(solve()?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#define INF 0x7FFFFFFF\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nint cx[20], cy[20], hx, hy, n, dx, dy, cut[1 << 20];\n\nint solve(int x,int y){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(cut[bit] > sum)\n\t\tcut[bit] = sum;\n\telse\n\t\treturn 0;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= dist(cx[i],cy[i],dx,dy)) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit && dist(x,y,cx[i],cy[i]) + sum < dist(cx[i],cy[i],dx,dy)){\n\t\t\tbit += 1 << i;\n\t\t\tsum += dist(x,y,cx[i],cy[i]);\n\t\t\tif(solve(cx[i],cy[i])){\n\t\t\t\tsum = 0, bit = 0;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tsum -= dist(x,y,cx[i],cy[i]);\n\t\t\tbit -= 1 << i;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint i, j;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tcut[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tif(solve(hx,hy))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <unordered_map>\n#include <iterator>\n#include <functional>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint T, n, m;\ndouble x[21], y[21], t[21], hx, hy, sx ,sy;\n\n\nint solve(double sx, double sy, int b, double ct){\n\tif(b == (1<<n)-1) return 1;\n\tREP(i, n)if(0 == ((b>>i)&1)){\n\t\tdouble nt = ct + hypot(x[i]-sx, y[i]-sy);\n\t\tif(t[i]-EPS < nt) return 0;\n\t}\n\tREP(i, n)if(0 == ((b>>i)&1)){\n\t\tdouble nt = ct + hypot(x[i]-sx, y[i]-sy);\n\t\tif(t[i]-EPS < nt) continue;\n\t\tif(solve(x[i], y[i], b | (1<<i), nt)) return 1;\n\t}\n\treturn 0;\n}\n\n\nint main(int argc, char *argv[]){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> sx >> sy >> hx >> hy, n){\n\t\tREP(i, n){\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tt[i] = hypot(x[i]-hx, y[i] - hy);\n\t\t}\n\t\tcout << (solve(sx, sy, 0, 0) ? \"YES\" : \"NO\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\n#define fi first\n#define se second\n\nint N;\nint hx, hy, mx, my;\ntypedef pair<double, double> P;\nP cs[21];\n\n#define SQ(x) ((x)*(x))\ninline double dist(P a, P b) {\n  return sqrt(SQ(a.fi-b.fi) + SQ(a.se-b.se));\n}\n\nunordered_map<int, double> umap;\n\ndouble G[22][22];\nbool dfs(int S, int now, double cost) {\n  \n  if(S == (1<<N)-1) {\n    return true;\n  }\n  \n  umap[S] = cost;\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(G[i][N+1] <= cost+G[now][i]) return false;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(umap.count(S|(1<<i)) && umap[S|(1<<i)] <= cost+G[now][i]) continue;\n    if(dfs(S|(1<<i), i, cost+G[now][i])) return true;\n  }\n  \n  return false;\n}\n\nbool solve() {\n  \n  umap.clear();\n  \n  for(int i=0; i<N; i++) {\n    for(int j=i+1; j<N; j++) {\n      G[i][j] = G[j][i] = dist(cs[i], cs[j]);\n    }\n    G[N][i] = G[i][N] = dist(P(hx, hy), cs[i]);\n    G[N+1][i] = G[i][N+1] = dist(P(mx, my), cs[i]);\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(G[N+1][i] <= G[N][i]) continue;\n    if(dfs(1<<i, i, G[N][i])) return true;\n  }\n  \n  return false;\n}\n\nint main() {\n  while(1) {\n    cin >> N >> hx >> hy >> mx >> my;\n    if(!N) break;\n    for(int i=0; i<N; i++) {\n      cin >> cs[i].fi >> cs[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<double, int> R;\ntypedef pair<P, R> Q;\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy) {\n\t\tif (n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) {\n\t\t\tbreak;\n\t\t}\n\t\thx -= dx;\n\t\thy -= dy;\n\t\tvector<P> data;\n\t\tint x, y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\tdata.push_back(P(x, y));\n\t\t}\n\t\tqueue<Q> q;\n\t\tq.push(Q(P(hx, hy), R(0.0, 0)));\n\t\tbool hantei = false;\n\t\twhile (!q.empty()) {\n\t\t\tQ p = q.front();\n\t\t\tq.pop();\n\t\t\tP xy = p.first;\n\t\t\tR limit = p.second;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tbool hantei2 = true;\n\t\t\t\tif ((limit.second & (1<<i)) == 0) {\n\t\t\t\t\tdouble dead = limit.first+sqrt(pow(data[i].first-xy.first, 2)+pow(data[i].second-xy.second, 2));\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif ((limit.second & (1<<j)) == 0) {\n\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead) {\n\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\tint k = limit.second | (1<<i);\n\t\t\t\t\t\tif (k == (1<<n)-1) {\n\t\t\t\t\t\t\thantei = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tif ((k & (1<<j)) == 0) {\n\t\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead+sqrt(pow(data[i].first-data[j].first, 2)+pow(data[i].second-data[j].second, 2))) {\n\t\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\t\tq.push(Q(data[i], R(dead, k)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hantei) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\ndouble dist(int x1, int y1, int x2, int y2)\n{\n\tint x = x1 - x2, y = y1 - y2;\n\treturn sqrt(0.0 + x*x + y*y);\n}\nint main()\n{\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n)\n\t{\n\t\tint x[32], y[32];\n\t\trep (i, n)\n\t\t\tcin >> x[i] >> y[i];\n\t\tx[n] = hx, y[n] = hy;\n\t\tx[n + 1] = dx, y[n + 1] = dy;\n\t\tdouble dis[32][32];\n\t\tfor (int i = 0; i <= n + 1; ++i)\n\t\t\tfor (int j = 0; j <= n + 1; ++j)\n\t\t\t\tdis[i][j] = dist(x[i], y[i], x[j], y[j]);\n\n\n\t\tstatic double dp[1 << 20][20];\n\t\tconst double INF = 1e9;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tdp[i][j] = INF;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (dis[n][i] < dis[n + 1][i])\n\t\t\t\tdp[1 << i][i] = dis[n][i];\n\n\t\tfor (int s = 0; s < 1 << n; ++s)\n\t\t{\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tif (!(s >> i & 1) || dp[s][i] == INF)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (s >> j & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tdouble t = dp[s][i] + dis[i][j];\n\t\t\t\t\tif (t < dis[n + 1][j])\n\t\t\t\t\t\tmin_swap(dp[s | 1 << j][j], t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (dp[(1 << n) - 1][i] + 1e-9 < dis[n + 1][i])\n\t\t\t\tres = true;\n\t\tcout << (res ? \"YES\" : \"NO\") << endl;\n\t\t//cout.precision(9);\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//\tcout << dp[(1 << n) - 1][i] << \" / \" << dis[n + 1][i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cfloat>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <unordered_map>\n  \nusing namespace std;\n  \n#define fi first\n#define se second\ntypedef pair<double,double> P;\n  \n#define MAX (21)\n#define INF (DBL_MAX/4)\n  \ndouble G[MAX][MAX];\n  \nint n;\nvector<P> crys;\nP h, d;\n  \ndouble dist(P p1, P p2){\n  return sqrt(pow(p1.fi-p2.fi, 2.) + pow(p1.se-p2.se, 2.));\n}\n  \nvoid makeEdge() {\n  for(int i=0; i<n; i++) {\n    G[i][i] = 0;\n    for(int j=i+1; j<n; j++) {\n      G[i][j] = G[j][i] = dist(crys[i], crys[j]);\n    }\n  }\n}\n  \n//map<int, double> dp;\n// 速度テストさせてください\nunordered_map<unsigned long long, double> dp;\n \nbool dfs(int S, int idx, double cost) {\n   \n  if(S==(1<<n)-1) {\n    return true;\n  }\n   \n  dp[S] = cost;\n   \n  for(int i=0; i<n; i++) {\n    if((S>>i)&1) continue;\n    if(cost + G[idx][i] >= dist(crys[i], d)) return false;\n  }\n   \n  for(int i=0; i<n; i++){\n    if((S>>i)&1) continue;\n    double ncost = cost + G[idx][i];\n    double nS = S|(1<<i);\n    if(ncost >= dist(crys[i], d)) return false;\n    else {\n      if(dp.count(nS) && dp[nS] < ncost) continue;\n      if(dfs(nS, i, ncost)) return true;\n    }\n  }\n   \n  return false;\n}\n  \nbool solve() {\n    \n  makeEdge();\n   \n  dp.clear();\n  for(int i=0; i<n; i++) {\n    if(dist(h, crys[i]) >= dist(crys[i], d)) continue;\n    if(dfs(1<<i, i, dist(h, crys[i]))) {\n      return true;\n    }\n  }\n  return false;\n}\n  \nint main(){\n  while(true){\n    crys.clear();\n    cin >> n >> h.fi >> h.se >> d.fi >> d.se;\n    if(!n && !h.fi && !h.se && !d.fi && !d.se){\n      break;\n    }\n    crys.resize(n);\n    for(int i=0; i<n; i++){\n      cin >> crys[i].fi >> crys[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<math.h>\n//#define DEBUG\n\nusing namespace std;\n#define foreach(i, c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)\n\nint n; int hx, hy; int dx, dy;\ntypedef struct{\n\tdouble limit;\n\tint x;\n\tint y;\n}Cs;\nCs cs[20];\n\ndouble dist(int i, int a, int b){\n\treturn sqrt((cs[i].x - a)*(cs[i].x - a) + (cs[i].y - b)*(cs[i].y - b));\n}\n\nbool solve(int cx, int cy, double t, vector<bool> f){\n\tbool r = false;\n\tbool tmp = true;\n\tfor(int i = 0; i < n; i++){\n\t\ttmp = tmp && f[i];\n\t}\n\tif(tmp)return 1;\n\tvector<bool> fnext;\n\tfor(int i = 0; i < n; i++){\n\t\tdouble d = dist(i, cx, cy);\n\t\tif(!f[i] && cs[i].limit <= t + d)return 0;\n\t}\n\ttmp = false;\n\tfor(int i = 0; i < n; i++){\n\t\t//Ü¾ÆÁÄÈ¢©ÂÔàÉÆêéàÌª éÈçæé\n\t\tif(!f[i]){\n\t\t\tfnext = f;\n\t\t\tfnext[i] = true;\n\t\t\tr = r || solve(cs[i].x, cs[i].y, t+dist(i, cx, cy), fnext);\n\t\t\t// Á½Óç®\n\t\t\ttmp = true;\n\t\t}\n\t}\n\t//È¢ÈçTõI¹\n\tif(!tmp)return 0;\n\treturn r;\n}\n\nint main(){\n\twhile(cin>>n>>hx>>hy>>dx>>dy, n||hx||hy||dx||dy){\n\t\tvector<bool> flag(n);\n\t\t//flag.clear();\n\t\tfor(int i = 0; i < n; i++)flag.push_back(false);\n\t\tbool failure = false;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint cx, cy;\n\t\t\tcin>>cx>>cy;\n\t\t\tcs[i].x = cx, cs[i].y = cy;\n\t\t\tint l, d;\n\t\t\tl = (cx - dx)*(cx - dx) + (cy - dy)*(cy - dy);\n\t\t\td = (cx - hx)*(cx - hx) + (cy - hy)*(cy - hy);\n\t\t\tif(l <= d){\n\t\t\t\tfailure = true;\n\t\t\t}\n\t\t\tcs[i].limit = sqrt(l);\n\t\t}\n\t\tif(failure){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t#ifdef DEBUG\n\t\tfor(int i = 0; i < n; i++)cout<<cs[i].limit<<endl;\n\t\t#endif\n\t\t\n\t\t//STõ\n\t\tfailure = solve(hx, hy, 0, flag);\n\t\tcout<<(failure?\"YES\":\"NO\")<<endl;\n\t\t\n\t\t#ifdef DEBUG\n\t\tcout<<\".\"<<endl;\n\t\t#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nint n,dx,dy,hx,hy;\nint cx[20],cy[20];\nshort dp[1<<20][21];\n\nshort smin(short a,short b){\n\tif(a>b)return b;\n\treturn a;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n+hx+hy+dx+dy==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t\tcx[n]=hx,cy[n]=hy;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0][n]=0;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<1<<n;i++){\n\t\t\tif(flag)continue;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif(dp[i][j]!=-1){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif((i>>k) & 1)continue;\n\t\t\t\t\t\tint move=abs(cx[j]-cx[k])+abs(cy[j]-cy[k]);\n\t\t\t\t\t\tint ng=abs(dx-cx[k])+abs(dy-cy[k]);\n\t\t\t\t\t\tif((short)dp[i][j]+move>=(short)ng)continue;\t\n\t\t\t\t\t\tdp[i|(1<<k)][k]=smin((short)dp[i|(1<<k)][k],(short)dp[i][j]+move);\n\t\t\t\t\t\tif(dp[i|(1<<k)][k]==-1)dp[i|(1<<k)][k]=dp[i][j]+move;\n\t\t\t\t\t\tif(i|(1<<k)==(1<<n)-1)flag=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAXN 20\n\nint n, hx, hy, dx, dy;\nint cx[MAXN], cy[MAXN];\nint dist(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\nint time(int x, int y) {\n    return abs(dx - x) + abs(dy - y);\n}\nstruct P {\n    int x, y, t;\n    P(int x, int y, int t) : x(x), y(y), t(t) {}\n};\nint fx[] = {1, 0, -1, 0},\n    fy[] = {0, 1, 0, -1};\nint move(int s, int d, int t) {\n    int cdt = time(cx[d], cy[d]); // crystal destoyed time\n    int nt = t + dist(cx[s], cy[s], cx[d], cy[d]);\n    return (cdt > nt ? nt : -1);\n    //queue<P> Q;\n    //Q.push(P(cx[s], cy[s], t));\n    //while (!Q.empty()) {\n    //    P p = Q.front(); Q.pop();\n    //    if (p.t >= cdt) {\n    //        return -1; // クリスタルが破壊された\n    //    }\n    //    if (p.t >= time(p.x, p.y)) {\n    //        continue; // 移動できない\n    //    }\n    //    if (p.x == cx[d] && p.y == cy[d]) {\n    //        return p.t;\n    //    }\n    //    for (int i = 0; i < 4; i++) {\n    //        Q.push(P(p.x + fx[i], p.y + fy[i], p.t+1));\n    //    }\n    //}\n    //return -1; // 到達できない\n}\nbool solve(int v, int used, int t) {\n    if (used == (1<<(n+1))-1) {\n        return true;\n    }\n    for (int i = 0; i <= n; i++) {\n        if (used & (1<<i)) {\n            continue;\n        }\n        int rt = move(v, i, t); // reached time\n        if (rt < 0) {\n            continue;\n        }\n        if (solve(i, used | (1<<i), rt)) {\n            return true; // 1つでも解があればOk\n        }\n    }\n    return false;\n}\nint main() {\n    while (cin >> n >> hx >> hy >> dx >> dy, n || hx || hy || dx || dy) {\n        cx[0] = hx, cy[0] = hy;\n        for (int i = 1; i <= n; i++) {\n            cin >> cx[i] >> cy[i];\n        }\n        cout << (solve(0, 1, 0) ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *  Author: mizo0203\n *  Problem: 2008\n *  Status:\n *  Submission Date:\n */\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\nint hx, hy, dx, dy;\nint cx[20], cy[20];\ndouble cdis[20];\n\n// 初期化\nvoid init() {\n}\n\n// 入力\nbool input() {\n  int i;\n\n  scanf(\"%d %d %d %d %d\", &n, &hx, &hy, &dx, &dy);\n  if (!n && !hx && !hy && !dx && !dy)\n    return false;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d %d\", &cx[i], &cy[i]);\n    cdis[i] = hypot(dx - cx[i], dy - cy[i]);\n  }\n  return true;\n}\n\n// 再帰関数\nbool recursive(long bit, double sum, int x, int y) {\n  int i;\n  double minD, maxH;\n\n  for (i = 0; i < n; i++)\n    if (~bit & 1 << i)\n      break;\n  if (i == n)\n    return true;\n  minD = 2000000.0; // INF\n  maxH = -2000000.0; // -INF\n  for (i = 0; i < n; i++) {\n    if (bit & 1 << i)\n      continue;\n    if (minD > cdis[i]) {\n      minD = cdis[i];\n      maxH = hypot(x - cx[i], y - cy[i]) + sum;\n    }\n  }\n  //printf(\"%f >= %fn\", maxH, minD);\n  if (maxH >= minD)\n    return false;\n\n  for (i = 0; i < n; i++) {\n    if (bit & 1 << i)\n      continue;\n    if (recursive(bit | 1 << i, sum + hypot(x - cx[i], y - cy[i]), cx[i], cy[i]))\n      return true;\n  }\n  //printf(\"sum:%fn\", sum);\n  return false;\n}\n\nint main() {\n\n  init(); // 初期化\n  while (input()) { // 入力\n    if (recursive(0, 0.0, hx, hy)) {\n      printf(\"YES\\n\");\n    } else {\n      printf(\"NO\\n\");\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nstruct Point {\n\tint x, y;\n};\n\nconst double EPS = 1E-9;\nPoint h, d, p[20];\nint n;\nbool flag[20];\n\nbool dfs(double t, int s) \n{\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tif (!flag[i]) break;\n\t}\n\tif (i == n) return true;\n\t\n\tPoint pp = (s == -1) ? h : p[s];\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tif (hypot(d.x - p[i].x, d.y - p[i].y) - hypot(pp.x - p[i].x, pp.y - p[i].y) - t < EPS) return false;\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tflag[i] = true;\n\t\tif (dfs(t + hypot(pp.x - p[i].x, pp.y - p[i].y), i)) return true;\n\t\tflag[i] = false;\n\t}\n\t\n\treturn false;\n}\n\nint main()\n{\t\n\twhile (cin >> n >> h.x >> h.y >> d.x >> d.y, n | h.x | h.y | d.x | d.y) {\n\t\tmemset(flag, false, sizeof(flag));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p[i].x >> p[i].y;\n\t\t}\n\t\tcout << (dfs(0, -1) ? \"YES\" : \"NO\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\nconst float EPS=1e-8;\n\nfloat dis(float a,float c,float b,float d){\n\treturn sqrt((a-b)*(a-b)+(c-d)*(c-d));\n}\n\nfloat dp[1<<20][20];\n\nint main(){\n\t\n\tint N;\n\tfloat sx,sy,gx,gy;\n\twhile(cin>>N>>sx>>sy>>gx>>gy,N){\n\t\tvector<float>y(N);\n\t\tvector<float>x(N);\n\t\tvector<float>devil(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>x[i]>>y[i];\n\t\t\tdevil[i]=dis(gx,gy,x[i],y[i]);\n\t\t}\n\t\tvector<vector<float>>dist(N,vector<float>(N));\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tdist[i][j]=dis(x[i],y[i],x[j],y[j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<1<<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tdp[i][j]=MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(devil[i]-EPS>dis(sx,sy,x[i],y[i])){\n\t\t\t\tdp[1<<i][i]=dis(sx,sy,x[i],y[i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<1<<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif(!((i>>j)&1))continue;\n\t\t\t\tif(dp[i][j]>=1000000)continue;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif((i>>k)&1)continue;\n\t\t\t\t\tfloat nx=dp[i][j]+dist[j][k];\n\t\t\t\t\tif(nx<devil[k]-EPS){\n\t\t\t\t\t\tdp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],nx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfloat ans=MOD;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans=min(ans,dp[(1<<N)-1][i]);\n\t\t}\n\t\tif(ans>=10000000){\n\t\t\tcout<<\"NO\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"YES\\n\";\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-12;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \nclass P{\npublic:\n\tdouble x,y;\n\tP(double a,double b){x = a, y = b;};\n};\nclass NODE{\npublic:\n\tint pos,done;\n\tdouble cost;\n\tNODE(int p,double c,int w){\n\t\tpos = p,cost = c;\n\t\tdone = w;\n\t};\n\t\n};\nbool operator<(const NODE&a,const NODE&b){\n\treturn a.cost > b.cost;\n}\n\nbool done[1<<20][20];\n\ndouble dist(P a, P b){\n\ta.x-=b.x , a.y -= b.y;\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\nstring solve(int n, P h, P d, vector<P> item){\n\tpriority_queue<NODE> Q;\n\t\n\trep(i,n){\n\t\tQ.push(NODE(i,dist(h,item[i]),(1<<i)));\n\t}\n\t\n\trep(i,1<<n)rep(j,n)done[i][j] = false;\n\t\n\twhile(Q.size()){\n\t\tNODE q = Q.top(); Q.pop();\n\t\tif(done[q.done][q.pos])continue;\n\t\telse done[q.done][q.pos] = true;\n\t\tif(q.cost + EPS > dist(d,item[q.pos]) )continue;// !!!!! EPS !!!!!\n\t\trep(i,n){\n\t\t\tif(q.done & i )continue;\n\t\t\tif(q.cost+dist(item[q.pos],item[i])+EPS < dist(d,item[i]) )continue;\n\t\t}\n\t\tif(q.done == (1<<n)-1){\n\t\t\treturn \"YES\";\n\t\t}\n\t\trep(i,n){\n\t\t\tif(i & q.done)continue;\n\t\t\tQ.push(NODE(i, q.cost + dist(item[q.pos],item[i]) , q.done | (1<<i) ));\n\t\t}\n\t}\n\treturn \"NO\";\n}\n\nint main(){\n\tint n,x,y;\n\tP h(0,0) , d(0,0);\n\twhile(cin >> n >> h.x >> h.y >> d.x >> d.y , n){\n\t\tvector<P> data;\n\t\trep(i,n)cin >> x >> y , data.push_back(P(x,y));\n\t\tcout << solve(n,h,d,data) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> x, y;\n// vector<int> viewed;\n\ndouble dist(int a, int b){\n    return sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));\n}\n\nbool dfs(int v, double t, int c){\n    if(c == n) return true;\n\n    for(int i=0;i<n;i++){\n        // if(viewed[i]) continue;\n        if(t + dist(v, i) >= dist(i, n+1)) return false;\n    }\n\n    for(int i=0;i<n;i++){\n        // if(viewed[i]) continue;\n        double nt = t + dist(v, i);\n        if(nt < dist(i, n+1)){\n            // viewed[i] = true;\n            if(dfs(i, nt, c+1)) return true;\n            // viewed[i] = false;\n        }\n    }\n\n    return false;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        x.assign(n+2, 0);\n        y.assign(n+2, 0);\n        cin >> x[n] >> y[n] >> x[n+1] >> y[n+1];\n        for(int i=0;i<n;i++){\n            cin >> x[i] >> y[i];\n        }\n        // viewed.assign(n, 0);\n        if(dfs(n, 0, 0)){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define EPS 1e-10\nusing namespace std;\n\nbool visited[21];\nint n,hx,hy,dx,dy,cx[21],cy[21];\n\nbool dfs(int x , double day){ //xツづ債個サツ催敖づ個暗環置\n  visited[x] = true;\n  bool judge = false,t = true;\n  for(int i=0;i<=n;i++)t &= visited[i];\n  if(t) return t;\n  for(int i= 0;i<=n;i++){\n    double dis,d,t;\n    if(visited[i]) continue;\n    t = day + sqrt((cx[i] - cx[x])*(cx[i] - cx[x]) + (cy[i] - cy[x])*(cy[i] - cy[x]));\n    if((dx - cx[i])*(dx - cx[i]) + (dy - cy[i])*(dy - cy[i]) > t*t + EPS){\n      judge |= dfs(i,t);\n      if(judge) break;\n    }\n  }\n  return judge;\n}\n    \nint main(){\n  while(1){\n    cin >> n >> hx >> hy >> dx >> dy;\n    if(!(n|hx|hy|dx|dy)) break;\n    dx -= hx;dy -= hy;\n    cx[0] = cy[0] = 0;\n    for(int i=1;i <= n;i++){\n      int tx,ty;cin >> tx >> ty;\n      cx[i] = tx - hx;cy[i] = ty - hy;\n    }\n    hx = hy = 0;\n    for(int i=0;i<21;i++) visited[i] = false;\n    if(dfs(0,0)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<map>\n\nusing namespace std;\nint n,dx,dy,hx,hy;\nint cx[21],cy[21];\nbool used[21];\nbool flag;\nvoid dfs(int v,int cnt,int cost){\n\tif(cnt==n)flag=true;\n\tif(flag)return;\n\tfor(int i=0;i<v;i++){\n\t\tif(!used[i]){\n\t\t\tint move=abs(cx[v]-cx[i])+abs(cy[v]-cy[i]);\n\t\t\tint ng=abs(dx-cx[i])+abs(dy-cy[i]);\n\t\t\tif(cost+move<ng){\n\t\t\t\tused[i]=true;\n\t\t\t\tdfs(i,cnt+1,cost+move);\n\t\t\t\tused[i]=false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n+hx+hy+dx+dy==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t\tcx[n]=hx,cy[n]=hy;\n\t\tflag=false;\n\t\tdfs(n,0,0);\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *  Author: mizo0203\n *  Problem: 2008\n *  Status: Time Limit Exceeded\n *  Submission Date: 2012/04/14 23:23:19\n *\n *  方策：再帰関数による幅優先探索\n */\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint n; // (0 < n <= 20)\nint hx, hy, dx, dy;\nint cx[20], cy[20]; // (-1000 <= h, d, c <= 1000)\n\nvoid init() {\n}\n\nbool input() {\n  int i;\n\n  scanf(\"%d %d %d %d %d\", &n, &hx, &hy, &dx, &dy);\n  if (!n && !hx && !hy && !dx && !dy)\n    return false;\n  for (i = 0; i < n; i++)\n    scanf(\"%d %d\", &cx[i], &cy[i]);\n\n  return true;\n}\n\n// sum: 勇者の総移動距離^2 == 瘴気の半径^2\nbool recursive(long l, int x, int y, double sum) {\n  int i;\n  double dis;\n\n  for (i = 0; i < n; i++)\n    if (~l & 1 << i)\n      break;\n  if (i == n)\n    return true;\n\n  for (i = 0; i < n; i++) {\n    if (l & 1 << i)\n      continue;\n    dis = sqrt(pow(cx[i] - x, 2) + pow(cy[i] - y, 2));\n    //printf(\"%f %f\\n\", sum + dis, sqrt(pow(cx[i] - dx, 2) + pow(cy[i] - dy, 2)));\n    if (sum + dis >= sqrt(pow(cx[i] - dx, 2) + pow(cy[i] - dy, 2)))\n      continue;\n    if (recursive(l | 1 << i, cx[i], cy[i], sum + dis))\n      return true;\n  }\n\n  return false;\n}\n\nint main() {\n  int i;\n\n  init();\n  while (input()) {\n    int pmt[20];\n    // [0, 1, 2, ....]というサイズnの配列を作成\n    for (i = 0; i < n; i++)\n      pmt[i] = i;\n    // 全ての順列を出力\n    if (recursive(0, hx, hy, 0))\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nint n, hx, hy, dx, dy;\nVVD dist;\nvector<P> cristals;\nVD limits;\n\nbool get_cristal(int status, int position, double time)\n{\n\tif (status == (1 << n) - 1) {\n\t\treturn true;\n\t}\n\n\t// Stop searching if more than one cristal is not to be reached\n\tREP (c, n) {\n\t\tif ((status & (1 << c)) == 0) {\n\t\t\tif (time + dist[position][c] > limits[c] - EPS) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool clear = false;\n\tREP (c, n) {\n\t\tif ((status & (1 << c)) == 0) {\n\t\t\t// Get c-th cristal\n\t\t\tif (get_cristal(status | (1 << c), c, time + dist[position][c])) {\n\t\t\t\tclear = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn clear;\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n | hx | hy | dx | dy) {\n\t\tcristals.clear();\n\t\tREP (i, n) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tcristals.PB(P(x, y));\n\t\t}\n\t\tcristals.PB(P(hx, hy));\n\n\t\tdist = VVD(cristals.size(), VD(cristals.size(), INF));\n\t\tREP (i, cristals.size()) {\n\t\t\tREP (j, cristals.size()) {\n\t\t\t\tdist[i][j] = sqrt(norm(cristals[i] - cristals[j]));\n\t\t\t}\n\t\t}\n\n\t\tlimits = VD(n);\n\t\tREP (i, n) {\n\t\t\tlimits[i] = sqrt(norm(cristals[i] - P(dx, dy)));\n\t\t}\n\t\tlimits.PB(INF);\n\n\t\tif (get_cristal(0, cristals.size() - 1, 0)) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\ndouble dp[1<<21][21];\n\nint main(){\n  int total_cristals;\n  int hero_x;\n  int hero_y;\n  int monster_x;\n  int monster_y;\n  while(~scanf(\"%d %d %d %d %d\",\n               &total_cristals,\n               &hero_x,\n               &hero_y,\n               &monster_x,\n               &monster_y)){\n    if(total_cristals == 0 && hero_x == 0 && hero_y == 0\n       && monster_x == 0 && monster_y == 0) break;\n    vector<P> cristals;\n    cristals.push_back(P(hero_x,hero_y));\n    for(int cristal_i = 0; cristal_i < total_cristals; cristal_i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cristals.push_back(P(x,y));\n    }\n    fill((double*)dp,(double*)dp + (1<<21) * 21,1000000000000);\n    dp[(1<<0)][0] = 0;\n    for(int S = 0; S < (1<<cristals.size()); S++){\n      for(int from = 0; from < cristals.size(); from++){\n        if(!(S & (1<<from))) continue;\n        for(int to = 0; to < cristals.size(); to++){\n          if(S & (1<<to)) continue;\n          double diff_x = cristals[from].first - cristals[to].first;\n          double diff_y = cristals[from].second - cristals[to].second;\n          double dist = sqrt(diff_x * diff_x + diff_y * diff_y); \n\n          double impurity = \n            sqrt((monster_x - cristals[to].first) * (monster_x - cristals[to].first)\n                 + (monster_y - cristals[to].second) * (monster_y - cristals[to].second));\n          if(impurity > dp[S][from] + dist){\n            dp[S | (1<<to)][to] = min(dp[S][from] + dist,\n                                      dp[S | (1<<to)][to]);\n          }\n        }\n      }\n    }\n    \n    bool res = false;\n    for(int to = 0; to < cristals.size(); to++){\n      if(dp[(1<<cristals.size()) - 1][to] < 1000000000000){\n        res = true;\n        break;\n      }\n    }\n\n    printf(\"%s\\n\",res ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\ninline int dbl(int x){ return x * x; }\n\nint main(){\n  while(true){\n    const int n = getInt();\n    const int hx = getInt();\n    const int hy = getInt();\n    const int dx = getInt();\n    const int dy = getInt();\n\n    if(n == 0) break;\n\n    vector<int> cx(n);\n    vector<int> cy(n);\n\n    REP(i,n){\n      cx[i] = getInt();\n      cy[i] = getInt();\n    }\n\n    typedef pair<double, pair<int, int> > data;\n    priority_queue<data, vector<data>, greater<data> > pq;\n    vector<vector<bool> > memo(1 << n, vector<bool>(n));\n\n    pq.push(make_pair(0.0, make_pair((1 << n) - 1, -1)));\n\n    while(pq.size()){\n      const data   d = pq.top(); pq.pop();\n      const double t = d.first;\n      const int    f = d.second.first;\n      const int    p = d.second.second;\n      const int    x = p == -1 ? hx : cx[p];\n      const int    y = p == -1 ? hy : cy[p];\n\n      // printf(\"%f %d %d\\n\", t, f, p);\n\n      if(p >= 0 && memo[f][p]) continue;\n      if(p >= 0) memo[f][p] = true;\n\n      if(f == 0){\n\tputs(\"YES\");\n\tgoto end;\n      }\n\n      vector<data> ds;\n      bool ok = true;\n\n      REP(i,n) if(f & (1 << i)){\n\tconst int xx = cx[i];\n\tconst int yy = cy[i];\n\n\tconst double tm1 = t + sqrt(dbl(x - xx) + dbl(y - yy));\n\tconst double tm2 = sqrt(dbl(dx - xx) + dbl(dy - yy));\n\t// printf(\"%d => %d (%d %d) => (%d %d): %f %f\\n\", p, i, x, y, xx, yy, tm1, tm2);\n\n\tif(tm1 < tm2 - 1e-9){\n\t  ds.push_back(make_pair(tm1, make_pair(f ^ (1 << i), i)));\n\t}else{\n\t  ok = false;\n\t}\n      }\n\n      if(ok) REP(i,ds.size()) if(!memo[ds[i].second.first][ds[i].second.second])\n\t       pq.push(ds[i]);\n    }\n    puts(\"NO\");\n  end:;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< double , Pi > Pii;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 55;\n\ndouble dp[1 << 20];\nint main(){\n  int n, hx, hy, dx, dy;\n  vector< char > near(1 << 20);\n\n  for(int i = 0; i < 1 << 20; i++){\n    for(int k = 0; k < 20; k++){\n      if((i >> k) & 1) continue;\n      near[i] = k;\n      break;\n    }\n  }\n  while(cin >> n >> hx >> hy >> dx >> dy, n|hx|hy|dx|dy){\n\n    vector< Pii > c(n);\n    for(int i = 0; i < n; i++){\n      cin >> c[i].sc.fr >> c[i].sc.sc;\n      c[i].fr = sqrt( pow( dx - c[i].sc.fr, 2) + pow( dy - c[i].sc.sc, 2));\n    }\n    sort( ALL(c));\n\n    fill_n( dp, 1 << 20, 1e9);\n    for(int i = 0; i < n; i++){\n      double dist = sqrt(pow(hx - c[i].sc.fr, 2) + pow(hy - c[i].sc.sc, 2));\n      if(dist < sqrt(pow(dx - c[i].sc.fr, 2) + pow(dy - c[i].sc.sc, 2))){\n        dp[1 << i] = dist;\n      }\n    }\n\n    for(int i = 0; i < (1 << n) - 1; i++){\n      if(dp[i] == 1e9) continue;\n      for(int j = 0; j < n; j++){\n        if(!((i >> j) & 1)) continue;\n        for(int k = 0; k < n; k++){\n          if((i >> k) & 1) continue;\n          double next = dp[i] + sqrt(pow( c[j].sc.fr - c[k].sc.fr, 2) + pow( c[j].sc.sc - c[k].sc.sc, 2));\n          if(next >= dp[i|(1 << k)]) continue;\n          bool check = sqrt(pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) > next;\n          if(check) dp[i|(1 << k)] = next;\n        }\n      }\n    }\n\n    bool check = n == 0;\n    check |= dp[(1 << n) - 1] < 1e9;\n    if(check) cout << \"YES\" << endl;\n    else cout <<\"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nint n,dx,dy,hx,hy;\nint cx[20],cy[20];\nint dp[1<<20][22];\nclass data{\npublic:\n\tint bit,v,cost;\n\tdata(int ibit,int iv,int icost){\n\t\tbit=ibit;\n\t\tv=iv;\n\t\tcost=icost;\n\t}\n\n\tbool operator<(const data& d1)const{\n\t\treturn d1.cost<cost;\n\t}\n};\n\nbool check(){\n\tpriority_queue<data> que;\n\tque.push(data(0,n,0));\n\tmemset(dp,-1,sizeof(dp));\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.bit][q.v]>q.cost && dp[q.bit][q.v]!=-1)continue;\n\t\tdp[q.bit][q.v]=q.cost;\n\t\tif(q.bit==(1<<n)-1)return true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((q.bit>>i) & 1)continue;\n\t\t\tint move=abs(cx[q.v]-cx[i])+abs(cy[q.v]-cy[i]);\n\t\t\tint ng=abs(dx-cx[i])+abs(dy-cy[i]);\n\t\t\tif(move+q.cost>=ng)continue;\n\t\t\tif(dp[q.bit|(1<<i)][i]>q.cost+move || dp[q.bit|(1<<i)][i]==-1){\n\t\t\t\tdp[q.bit|(1<<i)][i]=q.cost+move;\n\t\t\t\tque.push(data(q.bit|(1<<i),i,q.cost+move));\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n+hx+hy+dx+dy==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t\tcx[n]=hx,cy[n]=hy;\n\t\tprintf(\"%s\\n\",check()?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return (conj(a)*b).real();}\nFP crs(P a,P b){return (conj(a)*b).imag();}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgtin(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lftin(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frtin(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bckin(T a){return shift(a,TOP,FRT,BTM,BCK);}\n\nint n;\nint hx,hy,mx,my;\n\nbool vis[1<<20][20];\nint cx[20],cy[20];\n\nvoid solve(){\n  CLR(vis);\n  cin >> hx >> hy >> mx >> my;\n  rep(i,n) cin >> cx[i] >> cy[i];\n  priority_queue<pair<double,PI > > q;\n  rep(i,n)q.push(mp(-abs(pt(hx,hy)-pt(cx[i],cy[i])),mp(i,1<<i)));\n  \n  while(!q.empty()){\n    double cc=-q.top().F;\n    int cv=q.top().S.F;\n    int vi=q.top().S.S;\n    q.pop();\n    if(cc+EPS>abs(pt(cx[cv],cy[cv])-pt(mx,my))) continue;\n    if(vis[vi][cv]) continue;\n    if(vi==(1<<n)-1){\n      cout << \"YES\" << endl;\n      return;\n    }\n    vis[vi][cv]=true;\n    bool ok=true;\n    rep(i,n){\n      if((vi>>i)&1) continue;\n      ok&=\n        abs(pt(cx[i],cy[i])-pt(mx,my))+EPS>\n        cc+abs(pt(cx[i],cy[i])-pt(cx[cv],cy[cv]));\n    }\n    if(!ok) continue;\n    rep(i,n){\n      if((vi>>i)&1) continue;\n      q.push(mp(-cc-abs(pt(cx[i],cy[i])-pt(cx[cv],cy[cv])),\n                mp(i,vi|(1<<i))));\n    }\n  }\n\n  cout << \"NO\" << endl;\n}\n\nint main(int argc, char *argv[]){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define MAX 21\n#define INF 10000\n#define EPS 1.0e-10\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point;\ndouble dist(const point &a, const point &b){return std::abs(b-a);}\nbool vis[MAX];\nbool bt(const vector<point> &v, double walk, const point &h, const point &d){\n\tbool bCont = false;\n\n\tfor(unsigned int i = 0; i < v.size(); ++i){/*cout<<vis[i]<<' ';*/if( !vis[i] )bCont=true;}if( !bCont )return true;\n\t//cout << endl;\n\n\tfor(unsigned int i = 0; i < v.size(); ++i){\n\t\tif( !vis[ i ] ){\n\t\t\tdouble t = walk + dist(h,v[i]);\n\t\t\tif( t < dist(d, v[i]) ){\n\t\t\t\tvis[ i ] = true;\n\t\t\t\tif( bt( v, t, h, d ) )\n\t\t\t\t\treturn true;\n\t\t\t\tvis[ i ] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tbool bImpossible = false;\n\t\tint n,hx,hy,dx,dy;\n\t\tpoint hero, daemon;\n\t\tvector< point > vp;\n\n\t\tscanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy);\n\t\tif(!(n||hx||hy||dx||dy))break;\n\t\t\n\t\thero = complex<elem>(hx,hy);\n\t\tdaemon = complex<elem>(dx,dy);\n\t\t\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint cx,cy;scanf(\"%d%d\", &cx, &cy);point p(cx,cy);\n\t\t\tif(cx==hx&&cy==hy)continue;\n\t\t\tvp.push_back( p );\n\t\t\tif( dist(daemon,p) <= dist(hero,p) )bImpossible=true;\n\t\t\tvis[i]=false;\n\t\t}\n\t\t\n\t\tif( !bImpossible && bt( vp, 0.0, hero, daemon ) )\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nstruct pos{\n\tint x;\n\tint y;\n};\nstruct rel{\n\tint to;\n\tint dis;\n};\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy){\n\t\tvector<pos> p;\n\t\tREP(k, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp.push_back({ x, y });\n\t\t}\n\t\tvector<vector<double>> r(n + 1, vector<double>(n + 1));\n\t\tvector<double> dr(n);\n\t\tREP(i, n + 1){\n\t\t\tif (i != n)\n\t\t\t\tdr[i] = hypot(dx - p[i].x,dy - p[i].y);\n\n\t\t\tfor (int j = 0; j < n + 1; j++){\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (i != n  && j != n)r[i][j] = hypot(p[i].x - p[j].x,p[i].y - p[j].y);\n\t\t\t\telse if (i == n)r[i][j] = hypot(hx - p[j].x,hy - p[j].y);\n\t\t\t\telse if (j == n)r[i][j] = hypot(p[i].x - hx,p[i].y - hy);\n\t\t\t}\n\t\t}\n\n\t\tbool b[21] = { false };\n\t\tREP(i, n)b[i] = true;\n\t\tint b_n = n;\n\t\tbool flag = false;\n\t\tfunction<void(double dis, int from)> f = [&](double dis, int from){\n\t\t\tif (flag)return;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (b[i] && (dis + r[from][i] + 1e-8) >= dr[i])return;\n\t\t\t}\n\t\t\t\n\t\t\tif (b_n != 0){\n\t\t\t\tfor (int i = 0; i < n && !flag; i++){\n\t\t\t\t\tif (b[i] && (dis + r[from][i])+1e-8<dr[i]){\n\t\t\t\t\t\tb[i] = false;\n\t\t\t\t\t\tb_n--;\n\t\t\t\t\t\tf(dis + r[from][i], i);\n\t\t\t\t\t\tb[i] = true;\n\t\t\t\t\t\tb_n++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tflag = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn;\n\t\t};\n\t\tf(0.0, n); \n\t\tcout << (flag ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n \nusing namespace std;\n \n#define MAX 20\n#define EPS 1e-9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX];\nbool rec(int now, double total_dist, int depth){\n  if(total_dist >= dist(d, crystal[now])){\n    return false;\n  }\n  if(depth == N){\n    return true;\n  }\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      Segment s = Segment(crystal[now], crystal[i]);\n      if(s.distanceSP(d) < 1) return false;\n      used[i] = true;\n      if(rec(i, total_dist + dist(crystal[now],crystal[i]), depth+1)){\n        return true;\n      }\n      used[i] = false;\n    }\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    memset(used, false, sizeof(used));\n    if(rec(i, dist(h, crystal[i]), 0)){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;int n,x,y,h,w,d,e,s,v;double j(int a,int b){return sqrt(a*a+b*b+0.0);}int main(){while(1){bool ok=1;cin>>n>>h>>w>>d>>e;if(!n)break;cin>>s>>v;if(j(h-s,w-v)>=j(d-s,e-v))ok=0;for(int i=1;i<n;i++){cin>>x>>y;if(j(h-s,w-v)+j(s-x,v-y)>=j(d-x,e-y))ok=0;}if(ok) cout << \"YES\" << endl;else cout << \"NO\" << endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nPoint operator+(Point a,Point b){return Point(a.x+b.x,a.y+b.y);}\nPoint operator-(Point a,Point b){return Point(a.x-b.x,a.y-b.y);}\ndouble abs(Point p){return sqrt(p.x*p.x+p.y*p.y);}\n\nint dfs(double t,Point cur,Point devil,const vector<Point>& cs,int flg)\n{\n\tint n=cs.size(),res=0;\n\trep(i,n) if(!(flg>>i&1)){\n\t\tdouble spend=abs(cs[i]-cur);\n\t\tif(abs(cs[i]-devil)<t+spend+EPS) return 0;\n\t\tres=max(res,1+dfs(t+spend,cs[i],devil,cs,flg|1<<i));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tPoint h,d; cin>>h.x>>h.y>>d.x>>d.y;\n\t\tvector<Point> cs(n);\n\t\tfor(auto& c:cs) cin>>c.x>>c.y;\n\t\tcout<<(dfs(0,h,d,cs,0)==n?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nint abs(int n){\n\tif(n < 0)\n\t\tn = -n;\n\treturn n;\n}\n\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 20], dp[1 << 20];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){\n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tloc[1 << i] = i;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i != n){\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i] != INF){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & 1 << j && dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j]) && dp[i | 1 << j] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i]){\n\t\t\t\t\t\tdp[i | 1 << j] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];\n\t\t\t\t\t\tloc[i | 1 << j] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[1 << n] != -1)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\ndouble mx,my;\ndouble x[21],y[21];\nbool endFlag;\nbool input(){\n    scanf(\"%d\",&N);\n    scanf(\"%lf%lf%lf%lf\",&x[N],&y[N],&mx,&my);\n    if(!(N||x[N]||y[N]||mx||my))return false;\n    for(int i=0;i<N;i++)scanf(\"%lf%lf\",&x[i],&y[i]);\n    return true;\n}\n\nvoid dfs(int S,int pos,double total){\n    if(S==(1<<N)-1){\n        endFlag=true;\n        return;\n    }\n    if(endFlag)return;\n\n    for(int i=0;i<N;i++){\n        if((S>>i)&1)continue;\n        double mao=hypot(mx-x[i],my-y[i]);\n        double yu=hypot(x[pos]-x[i],y[pos]-y[i]);\n        if(yu+total>=mao)return;\n        dfs(S|(1<<i),i,total+yu);\n    }\n\n\n    for(int i=0;i<N;i++){\n        if((S>>i)&1)continue;\n        double yu=hypot(x[pos]-x[i],y[pos]-y[i]);\n        dfs(S|(1<<i),i,total+yu);\n    }\n}\nvoid solve(){\n    endFlag=false;\n    dfs(0,N,0);\n    puts(endFlag?\"YES\":\"NO\");\n}\nint main(){\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cfloat>\n#include <cmath>\n#include <vector>\n#include <map>\n \nusing namespace std;\n \n#define fi first\n#define se second\ntypedef pair<double,double> P;\n \n#define MAX (21)\n#define INF (DBL_MAX/4)\n \ndouble G[MAX][MAX];\n \nint n;\nvector<P> crys;\nP h, d;\n \ndouble dist(P p1, P p2){\n  return sqrt(pow(p1.fi-p2.fi, 2.) + pow(p1.se-p2.se, 2.));\n}\n \nvoid make_Edge() {\n  for(int i=0; i<n; i++) {\n    G[i][i] = 0;\n    for(int j=i+1; j<n; j++) {\n      G[i][j] = G[j][i] = dist(crys[i], crys[j]);\n    }\n  }\n}\n \n\nvoid printbit(int x){\n  for(int i=0;i<n;i++){\n    cout<<((x>>i)&1);\n\n  }\n  cout<<endl;\n}\n\n \ntypedef unsigned long long ull;\nmap<ull, double> dp;\n\ndouble dfs(int S, int idx, double cost) {\n  \n  if(S==(1<<n)-1) {\n    return dp[S] = cost;\n  }\n  \n  dp[S] = cost;\n  \n  for(int i=0; i<n; i++){\n    if((S>>i)&1) continue;\n    double ncost = cost + G[idx][i];\n    double nS = S|(1<<i);\n    if(ncost >= dist(crys[i], d)) continue;\n    else {\n      if(dp.count(nS) && dp[nS] < ncost) continue;\n      dp[S] = min(dp[S], dfs(nS, i, ncost));\n    }\n  }\n  \n  return dp[S];\n}\n \nbool solve() {\n   \n  make_Edge();\n  \n  dp.clear();\n  dp[0] = INF;\n  for(int i=0; i<n; i++) {\n    if(dist(h, crys[i]) >= dist(crys[i], d)) continue;\n    dp[0] = min(dfs(1<<i, i, dist(h, crys[i])), dp[0]);\n  }\n  if(!dp.count((1<<n)-1)) return false;\n  if(dp[0]>=INF) return false;\n  return true;\n}\n \nint main(){\n  while(true){\n    crys.clear();\n    cin >> n >> h.fi >> h.se >> d.fi >> d.se;\n    if(!n && !h.fi && !h.se && !d.fi && !d.se){\n      break;\n    }\n    crys.resize(n);\n    for(int i=0; i<n; i++){\n      cin >> crys[i].fi >> crys[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n  }\n  if ( now == n)return true;\n  rep(i,n){\n    if ( visited[i]==true)continue;\n    if ( r+adj[last][i] < adj[MAOU][i]){\n      visited[i]=true;\n      if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n  }\n\n\n  bool visited[20]={false};\n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i]) < dist(rx-mx,ry-my)){\n      visited[i]=true;\n      if ( backTrack(i,dist(mx-x[i],my-y[i]),1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(cin>>n>>mx>>my>>rx>>ry && n){\n    int x[n],y[n];\n    rep(i,n)cin>>x[i]>>y[i];\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,j) for (int (i)=0;(i)<(int)(j);++(i))\n#define put(i) cout << (i) << endl\nusing namespace std;\ntypedef long long ll;\n\ndouble eps = 1e-10;\nvector<int> f;\nbool ret=0;\n\ndouble dist(int xa, int ya, int xb, int yb) {\n    return sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb));\n}\n\nbool inCircle(int da, int db, int xa, int yb, int t) {\n    return dist(da,db,xa,yb)<=t+eps;\n}\n\nbool bfs(vector<pair<int,int>> c, int x, int y, int dx, int dy, int t) {\n    int n = c.size();\n    if (ret) return true;\n    rep(i,n) {\n        bool chk=1;\n        rep(j,n) {\n            if (f[j] == 0) {\n                chk=0;\n                double p=dist(x,y,c[j].first,c[j].second);\n                int dt=p+(p-(int)p>0+eps?1:0);\n                if (!inCircle(dx,dy,c[j].first,c[j].second,t+dt)) {\n                    f[j] = 1;\n                    bfs(c,c[j].first,c[j].second,dx,dy,t+dt);\n                    f[j] = 0;\n                }\n                else {\n                    return ret;\n                }\n            }\n        }\n        if (chk) {\n            ret=1;\n            return ret;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int n, hx, hy, dx, dy;\n    while (scanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy), (n||hx||hy||dx||dy)) {\n        f.assign(n,0);\n        ret=0;\n        vector<pair<int, int>> c(n);\n        rep(i,n) cin >> c[i].first >> c[i].second;\n        if (bfs(c,hx,hy,dx,dy,0)) put(\"YES\"); else put(\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\nconst float EPS=1e-8;\n\nfloat dis(float a,float c,float b,float d){\n\treturn sqrt((a-b)*(a-b)+(c-d)*(c-d));\n}\n\nfloat dp[1<<20][20];\n\nint main(){\n\t\n\tint N;\n\tdouble sx,sy,gx,gy;\n\twhile(cin>>N>>sx>>sy>>gx>>gy,N){\n\t\tvector<float>y(N);\n\t\tvector<float>x(N);\n\t\tvector<float>devil(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>x[i]>>y[i];\n\t\t\tdevil[i]=dis(gx,gy,x[i],y[i]);\n\t\t}\n\t\tvector<vector<float>>dist(N,vector<float>(N));\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tdist[i][j]=dis(x[i],y[i],x[j],y[j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<1<<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tdp[i][j]=MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(devil[i]-EPS>dis(sx,sy,x[i],y[i])){\n\t\t\t\tdp[1<<i][i]=dis(sx,sy,x[i],y[i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<1<<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif(!((i>>j)&1))continue;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif((i>>k)&1)continue;\n\t\t\t\t\tfloat nx=dp[i][j]+dist[j][k];\n\t\t\t\t\tif(nx<devil[k]-EPS){\n\t\t\t\t\t\tdp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],nx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfloat ans=MOD;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans=min(ans,dp[(1<<N)-1][i]);\n\t\t}\n\t\tif(ans>=10000000){\n\t\t\tcout<<\"NO\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"YES\\n\";\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define MAX 20\ntypedef pair<double,double> P;\ntypedef pair<double,P> Q;\n\nint N;\nP h, d, crystal[MAX];\n\ndouble dist(P a, P b){\n  return sqrt(pow(a.fi-b.fi,2) + pow(a.se-b.se,2));\n}\n\nbool solve(){\n  vector<Q> dd;\n  P p[MAX];\n\n  for(int i = 0 ; i < N ; i++){\n    dd.push_back(Q(dist(h, crystal[i]), crystal[i]));\n  }\n  sort(dd.begin(), dd.end());\n  for(int i = 0 ; i < N ; i++){\n    p[i] = dd[i].se; \n  }\n\n  double total_dist = 0;\n  for(int i = 0 ; i < N ; i++){\n    total_dist += dist(h,p[i]);\n    if(total_dist >= dist(d, p[i])){\n      return false;\n    }\n    h = p[i];\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> N >> h.fi >> h.se >> d.fi >> d.se, (N + h.fi + h.se + d.fi + d.se)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].fi >> crystal[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second \n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n\ndouble cost[22][22];\ndouble tlimit[22];\nint xx[22];\nint cx[22], cy[22];\nint n;\n\nbool DFS(int pos, int vis, double dis){\n\tif(vis == ((1<<(n+1))-1))return true;\n\t//枝狩り\n\tFOR(i, 1, n+1)if((vis&xx[i])==0 && (dis+cost[pos][i] > tlimit[i]+EPS))return false;\n\tFOR(i, 1, n+1){\n\t\tif((vis&xx[i])==0){\n\t\t\tif(DFS(i, vis|xx[i], dis+cost[pos][i])){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tREP(i,22)xx[i] = 1<<i;\n\twhile(1){\n\t\tint dx,dy;\n\t\tcin>>n>>cx[0]>>cy[0]>>dx>>dy;\n\t\tFOR(i,1,n+1)cin >> cx[i] >> cy[i];\n\t\tREP(i, n+1){\n\t\t\ttlimit[i] = sqrt(pow(cx[i]*1.0-dx*1.0,2.0)+pow(cy[i]*1.0-dy*1.0,2.0));\n\t\t\tREP(j,n+1){\n\t\t\t\tcost[i][j] = sqrt(pow(cx[i]*1.0-cx[j]*1.0,2.0)+pow(cy[i]*1.0-cy[j]*1.0,2.0));\n\t\t\t}\n\t\t}\n\t\tif(DFS(0, 1, 0.0))cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint N;\nP H,D;\nP C[22];\n\nint getK(P a,P b){\n  return (a.F-b.F) * (a.F-b.F) +  (a.S-b.S) * (a.S-b.S);\n}\nint sum(int a,int b){\n  return a+b+(int)(2.0*sqrt((double)a)*sqrt((double)b));\n}\n\nbool solve(int id,int st,int ky){\n  if( st == (1<<N)-1 ){\n    return true;\n  }\n\n  for(int i=0;i<N;i++){\n    if( (1<<i) & st ) continue;\n    int sm = sum(ky,getK(C[id],C[i]));\n    int r = getK(D,C[i]);\n    if( sm < r ){\n      if( solve( i, st | (1<<i) , sm ) ) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >>N >> H.F >> H.S >> D.F >> D.S;\n    if( !N && !H.F && !H.S && !D.F && !D.S) break;\n    for(int i=0;i<N;i++) {\n      cin >> C[i].F >> C[i].S;\n    }\n    bool f=false;\n    for(int i=0;i<N;i++){\n      int r = getK(D,C[i]);\n      int me = getK(H,C[i]);\n      if( me < r ){\n\tif( solve(i,(1<<i),me) ) f=true;\n\tif( f ) break;\n      }\n    }\n    if( f )cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define MAX 20\ntypedef pair<double,double> P;\n\nint N;\nP h, d, crystal[MAX];\n\ndouble dist(P a, P b){\n  return sqrt(pow(a.fi-b.fi,2) + pow(a.se-b.se,2));\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n\n  double total_dist = 0;\n  for(int i = 0 ; i < N ; i++){\n    total_dist += dist(h, crystal[i]);\n    if(total_dist >= dist(d, crystal[i])){\n      return false;\n    }\n    h = crystal[i];\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> N >> h.fi >> h.se >> d.fi >> d.se, (N + h.fi + h.se + d.fi + d.se)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].fi >> crystal[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-12;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \nclass P{\npublic:\n\tdouble x,y;\n\tP(double a,double b){x = a, y = b;};\n};\nclass NODE{\npublic:\n\tint pos,done;\n\tdouble cost;\n\tNODE(int p,double c,int w){\n\t\tpos = p,cost = c;\n\t\tdone = w;\n\t};\n\t\n};\nbool operator<(const NODE&a,const NODE&b){\n\treturn a.cost > b.cost;\n}\n\ndouble dist(P a, P b){\n\ta.x-=b.x , a.y -= b.y;\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\nstring solve(int n, P h, P d, vector<P> item){\n\tpriority_queue<NODE> Q;\n\t\n\trep(i,n){\n\t\tQ.push(NODE(i,dist(h,item[i]),(1<<i)));\n\t}\n\tbool done[1<<n][n];\n\trep(i,1<<n)rep(j,n)done[i][j] = false;\n\t\n\twhile(Q.size()){\n\t\tNODE q = Q.top(); Q.pop();\n\t\tif(done[q.done][q.pos])continue;\n\t\telse done[q.done][q.pos] = true;\n\t\tif(q.cost + EPS > dist(d,item[q.pos]) )continue;// !!!!! EPS !!!!!\n\t\tif(q.done == (1<<n)-1){\n\t\t\treturn \"YES\";\n\t\t}\n\t\trep(i,n){\n\t\t\tif(i & q.done)continue;\n\t\t\tQ.push(NODE(i, q.cost + dist(item[q.pos],item[i]) , q.done | (1<<i) ));\n\t\t}\n\t}\n\treturn \"NO\";\n}\n\nint main(){\n\tint n,x,y;\n\tP h(0,0) , d(0,0);\n\twhile(cin >> n >> h.x >> h.y >> d.x >> d.y , n){\n\t\tvector<P> data;\n\t\trep(i,n)cin >> x >> y , data.push_back(P(x,y));\n\t\tcout << solve(n,h,d,data) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <queue>\n#define MAXNUM 2000\n#define zero 1000 // (1000,1000)が原点\nusing namespace std;\n\nconst int ddx[] = {-1,0,1,0} ,ddy[] = {0,-1,0,1};\nint shoki[MAXNUM + 1][MAXNUM + 1], p[20][20], cx[20], cy[20], hx, hy, n;\n\nint dist(int x1,int y1,int x2,int y2){\n\tint cul;\n\tcul = abs(x1 - x2) + abs(y1 - y2);\n\treturn cul;\n}\n\nint solve(int pre){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= shoki[cy[i] + zero][cx[i] + zero]) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit){ // 未探索の位置にあるクリスタル\n\t\t\tif(pre == -1 && dist(hx,hy,cx[i],cy[i]) + sum < shoki[cy[i] + zero][cx[i] + zero]){ // １つ目のクリスタルをとる\n\t\t\t\tsum += dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tbit += 1 << i;\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbit -= 1 << i;\n\t\t\t\tsum -= dist(hx,hy,cx[i],cy[i]);\n\t\t\t}\n\t\t\telse if(pre != -1 && p[pre][i] + sum < shoki[cy[i] + zero][cx[i] + zero]){ // ２〜ｎつ目のクリスタルを取る\n\t\t\t\tbit += 1 << i;\n\t\t\t\tsum += p[pre][i];\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tsum -= p[pre][i];\n\t\t\t\tbit -= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint  dx, dy, x, y, i, j;\n\tqueue<int> qx, qy;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(i == j)\n\t\t\t\t\tp[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tp[i][j] = dist(cx[i],cy[i],cx[j],cy[j]);\n\t\t\t}\n\t\t}\n\t\tmemset(shoki,-1,sizeof(shoki));\n\t\tqx.push(dx + zero),qy.push(dy + zero);\n\t\tshoki[dy + zero][dx + zero] = 0;\n\t\twhile(shoki[0][0] == -1 || shoki[MAXNUM][MAXNUM] == -1 || shoki[MAXNUM][0] == -1 || shoki[0][MAXNUM] == -1){\n\t\t\twhile(qx.size()){\n\t\t\t\tx = qx.front();\n\t\t\t\ty = qy.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\t\tif(x + ddx[i] + zero >= 0 && x + ddx[i] + zero <= MAXNUM && y + ddy[i] + zero >= 0 && y + ddy[i] + zero <= MAXNUM && shoki[y + ddy[i] + zero][x + ddx[i] + zero] == -1){\n\t\t\t\t\t\tqx.push(x + ddx[i] + zero),qy.push(y + ddy[i] + zero);\n\t\t\t\t\t\tshoki[y + ddy[i] + zero][x + ddx[i] + zero] = shoki[y + zero][x + zero] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(solve(-1))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n \nusing namespace std;\n \n#define MAX 20\n#define EPS 1e-10\ntypedef pair<double,double> P;\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n \nbool solve(){\n  sort(crystal, crystal+N);\n\n  double total_dist = 0;\n  for(int i = 0 ; i < N ; i++){\n    Segment s = Segment(h, crystal[i]);\n    if(s.distanceSP(d) <= 1) return false;\n    total_dist += dist(h, crystal[i]);\n    if(total_dist >= dist(d, crystal[i])){\n      return false;\n    }\n    h = crystal[i];\n  }\n\n  return true;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\nstatic const double EPS = 1e-8;\n\nint n,hx,hy,dx,dy;\nint x[20],y[20];\nbool flag;\n\nvoid dfs(int unvisit, int cx, int cy, double t){\n   if(flag)return;\n  \n   if(unvisit==0)flag = true;\n   \n   else{\n      //枝刈り\n      rep(i,n){\n\t if(!((unvisit >> i) & 1))continue;\n\t if(hypot(dx-x[i], dy-y[i]) < t + hypot(cx-x[i], cy-y[i]) + EPS)return;\n      }\n\n      rep(i,n){\n\t if(!((unvisit >> i) & 1))continue;\n\t dfs((unvisit & ~(1 << i)), x[i], y[i], t + hypot(cx-x[i], cy-y[i]));\n      }\n   }\n}\n\nstring solve(){\n   flag = false;\n   dfs((1<<n)-1, hx, hy, 0);\n   return (flag) ? \"YES\" : \"NO\";\n}\n\nint main(){\n   while(cin >> n >> hx >> hy >> dx >> dy){\n      if((n|hx|hy|dx|dy)==0)break;\n   \n      rep(i,n){\n\t cin >> x[i] >> y[i];\n      }\n      \n      cout << solve() << endl;\n   }\n   return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct { int x, y; } pt;\n\nint n;\npt hero, dragon;\n\ndouble eps = 1e-6;\n\nvector<pt> targets;\n\ndouble dist(pt& a, pt& b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\nbool nearer_from_hero(pt& a, pt& b) {\n    return dist(a, hero) < dist(b, hero);\n}\n\nbool can_visit(double d, map<int, bool>& visited, int k) {\n    // cerr << \"VISIT d=\" << d << \" k=\" << k << endl;\n\n    if (d >= dist(targets[k], dragon)) {\n        // cerr << \"NG \" << d << \" \" << targets[k].x << \",\" << targets[k].y << \" \" << dragon.x << \",\" << dragon.y << endl;\n        return false;\n    }\n\n    bool all_visited = true;\n    bool ok = false;\n\n    for (int i = 1; i <= n; ++i) {\n        if (i == k || visited[i]) {\n            continue;\n        }\n\n        all_visited = false;\n\n        visited[i] = true;\n        double delta = dist(targets[i], targets[k]);\n        if (can_visit(d + delta, visited, i)) {\n            ok = true;\n        }\n        visited[i] = false;\n        if (ok) break;\n    }\n\n    return all_visited || ok;\n}\n\nbool nearer_dragon(pt a, pt b) {\n    return dist(a, dragon) < dist(b, dragon);\n}\n\nint main() {\n    while (true) {\n        cin >> n >> hero.x >> hero.y >> dragon.x >> dragon.y;\n        if (n == 0) break;\n\n        bool ng = false;\n        targets.clear();\n\n        int s = 0;\n        map< pair<int, int>, bool > seen;\n        for (int i = 0; i < n; ++i) {\n            pt t;\n            cin >> t.x >> t.y;\n            if (seen[make_pair(t.x, t.y)]) {\n                s++;\n                continue;\n            }\n\n            seen[make_pair(t.x, t.y)] = true;\n\n            if (dist(t, hero) >= dist(t, dragon) - eps) {\n                ng = true;\n            }\n\n            targets.push_back(t);\n        }\n        sort(targets.begin(), targets.end(), nearer_from_hero);\n        targets.insert(targets.begin(), hero);\n\n        n -= s;\n\n        map<int, bool> v;\n        for (int i = 0; i <= n; ++i) {\n            v[i] = false;\n        }\n        cout << (!ng && can_visit(0, v, 0) ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nint N;\nP D;\nvector<P> ps;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, int p) {\n  double dist = abs(D - ps[p]);\n  return !( dist < t + eps );\n}\n\nbool rec(int state, double t, int p) {\n  if(state == (1<<N)-1) return true;\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    if(!canExist(t + abs(ps[i] - ps[p]), i)) return false;\n  }\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    double nt = t + abs(ps[i] - ps[p]);\n    if(rec(state|(1<<i), nt, i)) return true;\n  }\n  return false;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy\n\t&&(N|hx|hy|dx|dy) ) {\n    D = P(dx, dy);\n    ps.resize(N+1);\n    ps[N-1] = P(hx, hy);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(rec(0, 0.0, N)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\ndouble INF=1e16;\ndouble EPS=1e-9;\nclass Main{\n\tpublic:\n\n\n\tint n;double hx,hy,dx,dy;\n\tvector<double> cx,cy;\n\tvector<vector<double>> ds;\n\n\tbool dfs(int v,int bit,double t){\n\t\tif(bit==(1<<n)-1)return true;\n\t\tbool ok=false;\n\t\t//cut \n\t\tREP(i,n)if(!((bit>>i)&1)){\n\t\t\tdouble d=hypot(cx[i]-cx[v],cy[i]-cx[v]);\n\t\t\tif(!(d+t+EPS<hypot(cx[i]-dx,cy[i]-dy)))return false;\t\t\t\n\t\t}\t\n\t\tREP(i,n)if(!((bit>>i)&1)){\n\t\t\tdouble d=hypot(cx[i]-cx[v],cy[i]-cx[v]);\n\t\t\tif(d+t+EPS<hypot(cx[i]-dx,cy[i]-dy))ok|=dfs(i,bit|1<<i,d+t);\n\t\t}\n\t\treturn ok;\n\t}\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){ cin >> n >> hx >> hy >> dx >> dy;if(n==0)break;\n\t\t\tcx=vector<double>(n);cy=vector<double>(n);REP(i,n) cin >> cx[i] >> cy[i];\n\n\t\t\tbool ok=false;\n\t\t\tREP(i,n){\n\t\t\t\tdouble d=hypot(cx[i]-hx,cy[i]-hy);\n\t\t\t\tif(d+EPS<hypot(cx[i]-dx,cy[i]-dy))ok|=dfs(i,1<<i,d);\n\t\t\t}\n\t\t\tcout << (ok?\"YES\":\"NO\")<<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <algorithm>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair<int, int> P;\nint n, hx, hy, dx, dy;\nP c[1001];\nbool used[1001];\nint main() {\n    while (scanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy)) {\n        if (!n&&!hx&&!hy&&!dx&&!dy) break;\n        for (int i=0; i<n; i++) scanf(\"%d%d\",&c[i].x,&c[i].y);\n        memset(used, 0, sizeof(used));\n        bool res=true;\n        double time=0.0, px=hx, py=hy;\n        while (true) {\n            int pos=-1;\n            double len=1000000.0;\n            for (int i=0; i<n; i++) {\n                if (used[i]) continue;\n                double x=c[i].x-px, y=c[i].y-py;\n                if (len>sqrt(x*x+y*y)) {\n                    len=sqrt(x*x+y*y);\n                    pos=i;\n                }\n            }\n            if (pos==-1) break;\n            time+=len;\n            double x=c[pos].x-dx, y=c[pos].y-dy;\n            used[pos]=true;\n//            printf(\"%f %f\\n\",sqrt(x*x+y*y),time);\n            if (sqrt(x*x+y*y)<=time) {\n                res=false;\n                break;\n            }\n        }\n        if (res) puts(\"YES\");\n        else puts(\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nint n, hx, hy, dx, dy;\nint cx[20], cy[20];\n\nbool dfs(int bit, int x, int y, double t) {\n    if (bit == (1 << n) - 1) return true;\n    REP (i, n) if (!(bit >> i & 1)) {\n        if (hypot(x - cx[i], y - cy[i]) > hypot(dx - cx[i], dy - cy[i]) - t) {\n            return false;\n        }\n    }\n    REP (i, n) if (!(bit >> i & 1)) {\n        if (hypot(x - cx[i], y - cy[i]) < hypot(dx - cx[i], dy - cy[i]) - t) {\n            if (dfs(bit | (1 << i), cx[i], cy[i], t + hypot(x - cx[i], y - cy[i]))) return true;\n        }\n    }\n    return false;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    while (cin >> n >> hx >> hy >> dx >> dy, n) {\n        REP (i, n) cin >> cx[i] >> cy[i];\n        cout << (dfs(0, hx, hy, 0) ? \"YES\" : \"NO\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//56\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\n#define S(X) ((X)*(X))\n\nint n,hx,hy,dx,dy;\ndouble d[21][21];\ndouble l[21];\n\nbool dfs(int s,double t,int g){\n  if(g==(1<<n+1)-1)return true;\n  double ub=0;\n  for(int i=1;i<=n;i++){\n    if(!(g&1<<i)&&ub<l[i]){\n      ub=l[i];\n    }\n  }\n  double lb=1<<30;\n  for(int i=0;i<=n;i++){\n    if(!(g&1<<i)&&lb>d[s][i]){\n      lb=d[s][i]+t;\n    }\n  }\n  if(lb>ub)return false;\n  for(int i=1;i<=n;i++){\n    if(!(g&1<<i)&&t+d[s][i]<l[i]){\n      if(dfs(i,t+d[s][i],g|1<<i))return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin>>n>>hx>>hy>>dx>>dy,n|hx|hy|dx|dy){\n    int cx[21]={hx},cy[21]={hy};\n    for(int i=1;i<=n;i++){\n      cin>>cx[i]>>cy[i];\n    }\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\td[i][j]=sqrt(S(cx[i]-cx[j])+S(cy[i]-cy[j]));\n      }\n    }\n    for(int i=1;i<=n;i++){\n      l[i]=sqrt(S(dx-cx[i])+S(dy-cy[i]));\n    }\n    cout<<(dfs(0,0,1)?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-12;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \nclass P{\npublic:\n\tdouble x,y;\n\tP(double a,double b){x = a, y = b;};\n};\nclass NODE{\npublic:\n\tint pos,done;\n\tdouble cost;\n\tNODE(int p,double c,int w){\n\t\tpos = p,cost = c;\n\t\tdone = w;\n\t};\n\t\n};\nbool operator<(const NODE&a,const NODE&b){\n\treturn a.cost > b.cost;\n}\n\nbool done[1<<20][20];\n\ndouble dist(P a, P b){\n\ta.x-=b.x , a.y -= b.y;\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\nstring solve(int n, P h, P d, vector<P> item){\n\tpriority_queue<NODE> Q;\n\t\n\trep(i,n){\n\t\tQ.push(NODE(i,dist(h,item[i]),(1<<i)));\n\t}\n\t\n\trep(i,1<<n)rep(j,n)done[i][j] = false;\n\t\n\twhile(Q.size()){\n\t\tNODE q = Q.top(); Q.pop();\n\t\tif(done[q.done][q.pos])continue;\n\t\telse done[q.done][q.pos] = true;\n\t\tif(q.cost + EPS > dist(d,item[q.pos]) )continue;// !!!!! EPS !!!!!\n\t\t\n\t\tbool f = false;\n\t\trep(i,n){\n\t\t\tif(q.done & (1<<i) )continue;\n\t\t\tif(q.cost+dist(item[q.pos],item[i])+EPS > dist(d,item[i]) ){f = true;break;}\n\t\t}\n\t\tif(f)continue;\n\t\tif(q.done == (1<<n)-1){\n\t\t\treturn \"YES\";\n\t\t}\n\t\trep(i,n){\n\t\t\tif((1<<i) & q.done)continue;\n\t\t\tQ.push(NODE(i, q.cost + dist(item[q.pos],item[i]) , q.done | (1<<i) ));\n\t\t}\n\t}\n\treturn \"NO\";\n}\n\nint main(){\n\tint n,x,y;\n\tP h(0,0) , d(0,0);\n\twhile(cin >> n >> h.x >> h.y >> d.x >> d.y , n){\n\t\tvector<P> data;\n\t\trep(i,n)cin >> x >> y , data.push_back(P(x,y));\n\t\tcout << solve(n,h,d,data) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint N;\nP H,D;\nP C[22];\nint K[22][22];\nint dc[22];\nint hc[22];\nint deadK;\n\nint getK(P a,P b){\n  return (a.F - b.F)* (a.F - b.F) + (a.S - b.S)* (a.S - b.S);\n}\n\nint sumK(int a,int b){\n  return a + b + 2*sqrt(a)*sqrt(b);\n}\n\nint solve(int id,int ky,int st){\n  if( st == (1<<N)-1 ) return true;\n\n  bool ret = true;\n  int sum[22];\n  for(int i=0;i<N;i++){\n    if( st & (1<<i) ) continue;\n    sum[i] = sumK(ky,K[id][i]);\n    if( sum[i] >= deadK ) ret = false;\n  }\n  if( ret ){\n    for(int i=0;i<N;i++){\n      if( st & (1<<i) ) continue;\n      if( sum[i] < deadK )\n\tif( solve(i,sum[i],st|(1<<i)) ) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >> N >> H.F >> H.S >> D.F >> D.S;\n    if( !N && !H.F && !H.S && !D.F && !D.S ) break;\n    for(int i=0;i<N;i++) cin >> C[i].F >> C[i].S;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tK[i][j] = getK(C[i],C[j]);\n    deadK = (1<<29);\n    for(int i=0;i<N;i++){\n      hc[i] = getK(C[i],H);\n      deadK = min(deadK,getK(C[i],D));\n    }\n    bool res = true;\n    for(int i=0;i<N;i++){\n      if( hc[i] >= deadK ){\n\tres = false;\n      }\n    }\n    if( res ) {\n      res = false;\n      for(int i=0;i<N;i++){\n\tif( hc[i] < deadK ){\n\t  if( solve(i,hc[i],(1<<i)) )  res = true;\n\t}\n\tif( res ) break;\n      }\n    }\n    if( res ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble hero[20];\nbool visited[20]={false};\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if ( visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    visited[i]=true;\n    if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n    hero[i]=dist(mx-x[i],my-y[i]);\n    if ( hero[i]+eps>adj[MAOU][i])return false;\n    visited[i]=false;\n  }\n  \n  rep(i,n){\n    visited[i]=true;\n    if ( backTrack(i,hero[i],1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(scanf(\"%d%d%d%d%d\",&n,&mx,&my,&rx,&ry) && n){\n    int x[n],y[n];\n    rep(i,n)scanf(\"%d%d\",&x[i],&y[i]);\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\nbool visited[20]={false};\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if ( visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    visited[i]=true;\n    if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n    if ( dist(mx-x[i],my-y[i])+eps>dist(rx-x[i],ry-y[i]))return false;\n    visited[i]=false;\n  }\n  \n  rep(i,n){\n    visited[i]=true;\n    if ( backTrack(i,dist(mx-x[i],my-y[i]),1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(scanf(\"%d%d%d%d%d\",&n,&mx,&my,&rx,&ry) && n){\n    int x[n],y[n];\n    rep(i,n)scanf(\"%d%d\",&x[i],&y[i]);\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint n,hx,hy,mx,my,cx[20],cy[20];\n\nbool dfs(int t,int x,int y,bool *vis){\n\tif(abs(x-mx)+abs(y-my)<=t) return false;\n\tif(count(vis,vis+n,true)==n) return true;\n\n\trep(i,n) if(!vis[i]) {\n\t\tif(abs(x-cx[i])+abs(y-cy[i])>abs(mx-cx[i])+abs(my-cy[i])-t) return false;\n\t}\n\n\trep(i,n) if(!vis[i]) {\n\t\tvis[i]=true;\n\t\tif(dfs(t+abs(x-cx[i])+abs(y-cy[i]),cx[i],cy[i],vis)) return true;\n\t\tvis[i]=false;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&hx,&hy,&mx,&my),n;){\n\t\trep(i,n) scanf(\"%d%d\",cx+i,cy+i);\n\n\t\tbool ok=false,vis[20]={};\n\t\trep(i,n) if(dfs(0,hx,hy,vis)) { ok=true; break; }\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include <queue>\nusing namespace std;\n#define MAX_N 20\n#define OVER 9999999\n\nint syo[MAX_N];\nint isi_x[MAX_N];\nint isi_y[MAX_N];\nint edge[MAX_N][MAX_N];\nint dp[1<<MAX_N][MAX_N];\nint hx,hy,n;\nbool chack;\n\nstruct node{\n  int S,v,cost;\n  node(int s, int vv,int c): S(s), v(vv),cost(c){}\n  bool operator >(const node &e) const{\n    return cost > e.cost;\n  }\n};\n\n/*\nbool rec(int S, int v,int t)\n{\n  if(chack)\n    return true;\n  // cout<<v<<endl;\n\n  \n  if(S==0)\n    cout<<\"0\";\n  for(int i=S;i!=0;)\n    {\n      cout<<i%2;\n      i=i/2;\n    } \n  printf(\" %d %d\\n\",v,t);  \n  \n  //  if(S==0)\n  //    dp[1<<v][v]=t;\n  if(dp[S][v]<t)\n    return false;\n  dp[S][v]=t;\n  if(t>=syo[v])\n    return false;\n  // cout<<\"ALL:\"<<(1<<n)-1<<endl;\n  if(S==(1<<n)-1)\n    {\n      chack=true;\n      return true;\n    }\n  //int res=OVER;\n  for(int i=0;i<n;i++)\n    {\n      if(!(S>>i&1))\n\t{\n\t  rec(S|1<<i,i,t+edge[v][i]);\n\t}\n    }\n  return false;\n}\n*/\n\nint main()\n{\n  int dx,dy;\n\n  for(;cin>>n>>hx>>hy>>dx>>dy,n;)\n    {\n      bool chack=false;\n      //memset(dp,false,sizeof(dp));\n      for(int i=0;i<n;i++)\n\t{\n\t  cin>>isi_x[i]>>isi_y[i];\n\t  syo[i]=abs(dx-isi_x[i])+abs(dy-isi_y[i])-1;\n\t}\n      for(int i=0;i<n;i++)    \n\tfor(int j=0;j<n;j++)  \n\t  edge[i][j]=abs(isi_x[i]-isi_x[j])+abs(isi_y[i]-isi_y[j]);\n      \n      // cout<<\"aaa\"<<endl;\n      //     int ans = OVER;\n      priority_queue<node, vector<node>, greater<node> > P;\n      // priority_queue<node> P;\n      for(int i=0;i<n;i++)\n\t{\n\t  P.push(node(1<<i,i,abs(isi_x[i]-hx)+abs(isi_y[i]-hy)));\n\t  //\t if(!chack)\n\t  //   rec(1<<i,i,abs(isi_x[i]-hx)+abs(isi_y[i]-hy));\n\t}\n      for(;!P.empty();)\n\t{\n\t  node s = P.top();\n\t  P.pop();\n\t  \n\t  if(s.cost>=syo[s.v])\n\t    continue;\n\t  \n\t  if(s.S==(1<<n)-1)\n\t    {\n\t      chack=true;\n\t      break;\n\t    }\n\t  for(int i=0;i<n;i++)\n\t    {\n\t      if(!(s.S>>i&1))\n\t\t{\n\t\t  P.push(node(s.S|1<<i,i,s.cost+edge[s.v][i]));\n\t\t}\n\t    }\n\t  \n\t}\n\n     if(chack)\n       cout<<\"YES\"<<endl;\n     else\n       cout<<\"NO\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< double , Pi > Pii;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 55;\n\ndouble dp[1 << 20];\nint main(){\n  int n, hx, hy, dx, dy;\n  vector< char > near(1 << 20);\n  for(int i = 0; i < 1 << 20; i++){\n    for(int k = 0; k < 20; k++){\n      if((i >> k) & 1) continue;\n      near[i] = k;\n      break;\n    }\n  }\n\n  \n  while(cin >> n >> hx >> hy >> dx >> dy, n|hx|hy|dx|dy){\n\n    vector< Pii > c(n);\n    for(int i = 0; i < n; i++){\n      cin >> c[i].sc.fr >> c[i].sc.sc;\n      c[i].fr = sqrt( pow( dx - c[i].sc.fr, 2) + pow( dy - c[i].sc.sc, 2));\n    }\n    sort( ALL(c));\n\n    fill_n( dp, 1 << 20, 1e9);\n\n    queue< int > nexter;\n\n    for(int i = 0; i < n; i++){\n      double dist = sqrt(pow(hx - c[i].sc.fr, 2) + pow(hy - c[i].sc.sc, 2));\n      if(dist < sqrt(pow(dx - c[i].sc.fr, 2) + pow(dy - c[i].sc.sc, 2))){\n        dp[1 << i] = dist;\n        nexter.push(1 << i);\n      }\n    }\n\n    while(!nexter.empty()){\n      int i = nexter.front(); nexter.pop();\n      if(dp[i] == 1e9 || sqrt( pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) <= dp[i]) continue;\n      for(int j = 0; j < n; j++){\n        if(!((i >> j) & 1)) continue;\n        for(int k = 0; k < n; k++){\n          if((i >> k) & 1) continue;\n          double next = dp[i] + sqrt(pow( c[j].sc.fr - c[k].sc.fr, 2) + pow( c[j].sc.sc - c[k].sc.sc, 2));\n          if(next >= dp[i|(1 << k)]) continue;\n          bool check = sqrt(pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) > next;\n          if(check){\n            dp[i|(1 << k)] = next;\n            nexter.push( i|(1 << k));\n          }\n        }\n      }\n    }\n\n    bool check = n == 0;\n    check |= dp[(1 << n) - 1] < 1e9;\n    if(check) cout << \"YES\" << endl;\n    else cout <<\"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 20\n#define EPS 1e-9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX];\nbool rec(int now, double total_dist, int depth){\n  if(total_dist >= dist(d, crystal[now])){\n    return false;\n  }\n  if(depth == N){\n    return true;\n  }\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      Segment s = Segment(crystal[now], crystal[i]);\n      if(s.distanceSP(d) < total_dist) return false;\n      used[i] = true;\n      if(rec(i, total_dist + dist(crystal[now],crystal[i]), depth+1)){\n        return true;\n      }\n      used[i] = false;\n    }\n  }\n  return false;\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n  for(int i = 0 ; i < N ; i++){\n    memset(used, false, sizeof(used));\n    if(rec(i, dist(h, crystal[i]), 0)){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n\n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(const Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n\n  bool intersectSP(const Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(const Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nSegment s;\nbool rec(int S, int v, double total_dist){\n  if(S == (1 << N) - 1){\n    return true;\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1)){\n      s = Segment(crystal[v], crystal[u]);\n      if(s.distanceSP(d) < total_dist) return false;\n      if(total_dist+dist(crystal[v],crystal[u]) >= dist(d, crystal[u])){\n        return false;\n      }\n    }\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1)){\n      if(rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]))){\n\treturn true;\n      }\n    }\n  }\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    if(rec(0, i, dist(h, crystal[i]))){\n      return true;\n    }\n  }  \n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0;i < n ;i++)\n#define EPS 1e-8\n\nint n,hx,hy,dx,dy;\nint x[30],y[30];\n\nbool flag;\n\nvoid dfs(int unvisit,int cx,int cy,double t)\n{\n\tif(flag) return;\n\tif(unvisit == 0)flag = true;\n\t\n\telse\n\t{\n\t\tREP(i,n)\n\t\t{\n\t\t\tif(!((unvisit >> i) & 1))continue;\n\t\t\tif(hypot(dx-x[i],dy-y[i]) <= t + hypot(cx-x[i],cy-y[i]))return;\n\t\t}\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tif(!((unvisit >> i) & 1))continue;\n\t\t\tdfs((unvisit & ~(1 << i)),x[i],y[i],t + hypot(cx-x[i],cy-y[i]));\n\t\t}\n\t}\n}\n\nstring solve()\n{\n\tflag = false;\n\tdfs((1<<n)-1,hx,hy,0);\n\treturn (flag)?\"YES\":\"NO\";\n}\n\nint main()\n{\n\twhile(cin >> n >> hx >> hy >> dx >> dy,n)\n\t{\n\t\tREP(i,n)\n\t\t{\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble  cost[20][20];\nconst double INF = 10000000;\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n  }\n  if ( now == n)return true;\n  \n  //\n  visited[last]=false;\n  rep(i,n){\n    if (visited[i]==true)cost[i][i]=INF;\n    else cost[i][i]=0;\n    REP(j,i+1,n){\n      if (visited[i]==true ||visited[j]==true)cost[i][j]=cost[j][i]=INF;\n      else cost[i][j]=cost[j][i]=adj[i][j];\n    }\n  }\n  visited[last]=true;\n  rep(k,n)rep(i,n)rep(j,n)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n  rep(i,n)if( visited[i]==false && r+cost[last][i] >=adj[MAOU][i])return false;\n\n  //\n\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    if ( r+adj[last][i] < adj[MAOU][i]){\n      visited[i]=true;\n      if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n      visited[i]=false;\n    }else return false;\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n  }\n  \n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i])+eps>dist(rx-x[i],ry-y[i]))return false;\n  }\n\n\n  bool visited[20]={false};\n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i]) < dist(rx-x[i],ry-y[i])){\n      visited[i]=true;\n      if ( backTrack(i,dist(mx-x[i],my-y[i]),1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(cin>>n>>mx>>my>>rx>>ry && n){\n    int x[n],y[n];\n    rep(i,n)cin>>x[i]>>y[i];\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\nconst int INF=100000000;\n\n\nint n;\nint hx,hy;\nint dx,dy;\nint cx[21],cy[21];\n\n\ndouble dist(int _x0,int _y0,int _x1,int _y1) {\n\tdouble d = (_x0-_x1)*(_x0-_x1) + (_y0-_y1)*(_y0-_y1);\n\treturn sqrt(d);\n}\n\nint pow2(int a) {\n\treturn a*a;\n}\n\nbool check(int x,int y,int d,int ind) {\n    return dist(x,y,cx[ind],cy[ind]) < (dist(dx,dy,cx[ind],cy[ind]) - d);\n}\n\nbool dfs(int x,int y,int d,int S) {\n    //printf(\"[debug] %d,%d,%d,%d\\n\",x,y,d,S);\n\tif(S==(1<<n)-1) return true;\n\trep(i,n) {\n\t\tif(!((S>>i)&1)) {\n\t\t\t//d += (int)dist(x,y,cx[i],cy[i]) + 1;\n\t\t\tif(check(x,y,d,i)) {\n\t\t\t\treturn dfs(cx[i],cy[i],d+dist(x,y,cx[i],cy[i]) + 1,S|(1<<i));\n\t\t\t}\n            else {\n                return false;\n            }\n\t\t}\n\t}\n\n\treturn false;\n\n}\n\n\nvoid solve() {\n\trep(i,n) cin>>cx[i]>>cy[i];\n\tif(dfs(hx,hy,0,0)) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\n}\n\nint main() {\n\twhile (cin>>n>>hx>>hy>>dx>>dy)\n\t{\n\t\tif(n+hx+hy+dx+dy==0) return 0;\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <functional>\ninline double dist(int x, int y) {\n\treturn std::sqrt(x * x + y * y);\n}\ninline double dist(std::pair<int, int> pos) {\n\treturn std::sqrt(pos.first * pos.first + pos.second * pos.second);\n}\ninline double dist(int x, int y, std::pair<int, int> pos) {\n\treturn std::sqrt((x - pos.first) * (x - pos.first) + (y - pos.second) * (y - pos.second));\n}\n\nstd::vector<std::pair<int, int>> crystal;\nint n, x, y, mx, my;\nbool Solve(double day = 0, std::vector<std::pair<int, int>> got = {});\nbool isClear = false;\nint main()\n{\n\tstd::vector<std::string> results;\n\twhile (1) {\n\t\tstd::cin >> n >> x >> y >> mx >> my;\n\t\tif (!x && !y && !n && !mx && !my) break;\n\t\tcrystal.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint cx, cy;\n\t\t\tstd::cin >> cx >> cy;\n\t\t\tcx -= mx; cy -= my;\n\t\t\tcrystal.push_back(std::make_pair(cx, cy));\n\t\t}\n\t\tx -= mx; y -= my;\n\t\tmx = 0; my = 0;\n\t\tisClear = false;\n\t\tSolve();\n\t\tresults.push_back(isClear ? \"YES\" : \"NO\");\n\t}\n\n\tfor (auto& x : results) {\n\t\tstd::cout << x << std::endl;\n\t}\n\n\treturn 0;\n}\n\nbool Solve(double day, std::vector<std::pair<int, int>> got)\n{\n\tif (isClear) return true;\n\tbool ok = false;\n\tint posX, posY;\n\tif (got.empty()) {\n\t\tposX = x;\n\t\tposY = y;\n\t}\n\telse {\n\t\tposX = got.back().first;\n\t\tposY = got.back().second;\n\t}\n\t//??¨??£??????????????´?????¨??????????????????????????£?????????\n\tfor (auto& x : crystal) {\n\t\t//???????????????????¨????(?????¢???????????????????????????)\n\t\tdouble pass = dist(posX, posY, x);\n\t\tdouble next = day + pass;\n\t\t//?????£?????????crystal?????????????????????????????????????????????\n\t\tif (next < dist(x)) {\n\t\t\t//??´?°????????????¨??????????¨????\n\t\t\tif (std::find(got.begin(), got.end(), x) == got.end()) {\n\t\t\t\tgot.push_back(x);\n\t\t\t\tif (got.size() == n) {\n\t\t\t\t\tisClear = true;\n\t\t\t\t}\n\t\t\t\tok = ok | Solve(next, got);\n\t\t\t}\n\t\t}\n\t}\n\treturn ok;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define EPS (1e-10)\n\nusing namespace std;\n\nint n;\ndouble hx, hy, dx, dy, cx[20], cy[20];\nbool got[20];\n\ndouble Dist( double xx, double yy )\n{\n\treturn sqrt(xx*xx + yy*yy);\n}\n\nbool search( int count, double t )\n{\n\tif(count == n) return true;\n\tfor(int i=0; i < n; ++i) {\n\t\tif(got[i]) continue;\n\t\tdouble dist = (Dist(hx-cx[i], hy-cy[i]) + t);\n\t\tif((Dist(dx-cx[i], dy-cy[i]) <= dist + EPS)) return false;\n\t}\n\tbool hit = false;\n\tdouble tx = hx, ty = hy;\n\tfor(int i=0; i < n && !hit; ++i) {\n\t\tif(got[i]) continue;\n\t\tgot[i] = true;\n\t\thx = cx[i]; hy = cy[i];\n\t\thit |= search(count + 1, (Dist(tx-cx[i], ty-cy[i]) + t));\n\t\tgot[i] = false;\n\t}\n\treturn hit;\n}\n\nint main( void )\n{\n\twhile(cin >> n >> hx >> hy >> dx >> dy) {\n\t\tif((int)(n + hx + hy + dx + dy) == 0) break;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tgot[i] = false;\n\t\t}\n\t\tif(search(0, 0))\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n//const int INF = INT_MAX/10;\nconst double INF = DBL_MAX/10;\n\n#define LT(x,y) ((x)-(y)<EPS)\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<double> vd;\n\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile(cin >> n >> hx >> hy >> dx >> dy, n) {\n\t\tP h(hx, hy), d(dx, dy);\n\t\tvector<P> c(n);\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tc[i] = P(x, y);\n\t\t}\n\n\t\tvector<vd> dist(n, vd(n, INF));\n\t\tREP(i, n) {\n\t\t\tFOR(j, i+1, n-1) {\n\t\t\t\tdist[i][j] = dist[j][i] = abs(c[i]-c[j]);\n\t\t\t}\n\t\t}\n\t\tvd sdist(n);\n\t\tREP(i, n) {\n\t\t\tsdist[i] = abs(c[i]-h);\t\n\t\t}\n\n\t\tvector<vd> dp(1<<n, vd(n, INF));\n\t\tREP(i, n) {\n\t\t\tif(i == 0) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tdp[1<<j][j] = sdist[j];\n\t\t\t\t\tif(LT(abs(d-c[j]), dp[1<<j][j])) {\n\t\t\t\t\t\tdp[1<<j][j] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tif(!(i&(1<<j))) {\n\t\t\t\t\t\tREP(k, n) {\n\t\t\t\t\t\t\tdp[i|(1<<j)][j] = min(dp[i|(1<<j)][j], dp[i][k]+dist[k][j]);\n\t\t\t\t\t\t\tif(LT(abs(d-c[j]), dp[i|(1<<j)][j])) {\n\t\t\t\t\t\t\t\tdp[i|(1<<j)][j] = INF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok = false;\n\t\tREP(i, n) {\n\t\t\tif(dp[(1<<n)-1][i] != INF) {\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcout << (ok ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\n\nconst D EPS = 1e-8;\n\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\n\ntypedef pair<D, pair<int, int> > State;\n\nP cr[21], d;\nint n;\nD dis[1 << 20][21];\n\nint main() {\n  while (true) {\n    cin >> n;\n    cin  >> cr[n].X >> cr[n].Y >> d.X >> d.Y;\n    if (n == 0) break;\n    rep (i, n) cin >> cr[i].X >> cr[i].Y;\n    priority_queue<State, vector<State>, greater<State> > que;\n    que.push(make_pair(0, make_pair((1 << n) - 1, n)));\n    rep (i, 1 << n) rep (j, n + 1) dis[i][j] = 1e100;\n    bool ok = false;\n    while (!que.empty()) {\n      State now = que.top();\n      que.pop();\n      if (now.second.first == 0) {\n\tok = true;\n\tbreak;\n      }\n      if (sig(dis[now.second.first][now.second.second], now.first) <= 0) continue;\n      dis[now.second.first][now.second.second] = now.first;\n      rep (i, n) if (now.second.first & 1 << i) {\n\tif (sig(now.first + abs(cr[now.second.second] - cr[i]), abs(cr[i] - d)) < 0) {\n\t  que.push(make_pair(now.first + abs(cr[now.second.second] - cr[i]), make_pair(now.second.first ^ 1 << i, i)));\n\t}\n      }\n    }\n    cout << (ok ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\nconst int INF=100000000;\n\n\nint n;\nint hx,hy;\nint dx,dy;\nint cx[21],cy[21];\nbool flag[21];\n\ndouble dist(int x0,int y0,int x1,int y1) {\n\tdouble d = (x0-x1)*(x0-x1) + (y0-y1)*(y0-y1);\n\treturn sqrt(d);\n}\n\nint pow2(int a) {\n\treturn a*a;\n}\n\n//クリスタルの位置と何日目からとることができるか\nbool check(int x,int y,int d) {\n\treturn (pow2(dx-x)+pow2(dy-y)) > pow2(d);\n}\n\n//現在位置,何日目\nbool dfs(int x,int y,int d,int cnt) {\n\t//printf(\"[debug] %d,%d,%d,%d\\n\",x,y,d,cnt);\n\tif(cnt==n) return true;\n\trep(i,n) {\n\t\tif(!flag[i]) {\n\t\t\tflag[i]=true;\n\t\t\td += (int)dist(x,y,cx[i],cy[i])+1;\n\t\t\tif(check(cx[i],cy[i],d)) {\n\t\t\t\treturn dfs(cx[i],cy[i],d,cnt+1);\n\t\t\t}\n\t\t\tflag[i]=false;\n\t\t}\n\t}\n\treturn false;\n\n\n}\n\n\nvoid solve() {\n\trep(i,n) cin>>cx[i]>>cy[i];\n\trep(i,21) flag[i]=false;\n\n\tif(dfs(hx,hy,0,0)) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n}\n\nint main() {\n\twhile (cin>>n>>hx>>hy>>dx>>dy)\n\t{\n\t\tif(n+hx+hy+dx+dy==0) return 0;\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint N;\nP H,D;\nP C[22];\nint K[22][22];\nint dc[22];\nint hc[22];\nint deadK;\n\nint getK(P a,P b){\n  return (a.F - b.F)* (a.F - b.F) + (a.S - b.S)* (a.S - b.S);\n}\n\nint sumK(int a,int b){\n  return a + b + 2*sqrt(a)*sqrt(b);\n}\n\nint solve(int id,int ky,int st){\n  if( st == (1<<N)-1 ) return true;\n  for(int i=0;i<N;i++){\n    if( st & (1<<i) ) continue;\n    int sum = sumK(ky,K[id][i]);\n    if( sum < deadK )\n      if( solve(i,sum,st|(1<<i)) ) return true;\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >> N >> H.F >> H.S >> D.F >> D.S;\n    if( !N && !H.F && !H.S && !D.F && !D.S ) break;\n    for(int i=0;i<N;i++) cin >> C[i].F >> C[i].S;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tK[i][j] = getK(C[i],C[j]);\n    deadK = (1<<29);\n    for(int i=0;i<N;i++){\n      dc[i] = getK(C[i],D);\n      hc[i] = getK(C[i],H);\n      deadK = min(deadK,dc[i]);\n    }\n    bool res = false;\n    for(int i=0;i<N;i++){\n      if( hc[i] < deadK ){\n\tif( solve(i,hc[i],(1<<i)) )  res = true;\n      }\n      if( res ) break;\n    }\n    if( res ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nint n,sx,sy,mx,my;\nint xi[22],yi[22];\nbool used[22];\nconst double eps = 1e-8;\ninline double sc(double a){return a*a;}\n#define R(a,b) (sqrt(sc(a)+sc(b)))\n\nbool solve(int a,int p,double t,double x,double y)\n{\n  //printf(\"%d %f %f %f\\n\",a,t,x,y);\n  if( a == n ) return true;\n  for(int i = 0; i < n; i++) {\n    if(!used[i]) {\n      if( R(xi[i]-mx,yi[i]-my) < t+R(x-xi[i],y-yi[i])+eps ) {\n        return false;\n      }\n    }\n  }\n  for(int i = 0; i < n; i++) {\n    if(!used[i]) {\n      used[i]=true;\n      if(solve(a+1,i,t+R(x-xi[i],y-yi[i]),xi[i],yi[i]))return true;\n      used[i]=false;\n    }\n  }\n  return false;\n}\n\nint main(void)\n{\n  for(;;) {\n    scanf(\"%d%d%d%d%d\",&n,&sx,&sy,&mx,&my); if(!n)break;\n    for(int i = 0; i < n; i++) {\n      used[i] = false;\n      scanf(\"%d%d\",xi+i,yi+i);\n    }\n    bool res = solve(0,-1,0,sx,sy);\n    puts(res ? \"YES\" : \"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8;\n\nint n, hx, hy, dx, dy;\nvector<int> cx, cy;\nvector<double> dd;\nvector<vector<double> > d;\n\nbool check(int vis, int k, double t){\n    rep(i, n)if(!(vis >> i & 1) && dd[i] <= d[k][i] + t + eps)return false;\n    return true;\n}\n\nbool dfs(int vis, int k, double t){\n    if(vis == (1 << n) - 1)return true;\n    if(!check(vis, k, t))return false;\n    rep(i, n)if(!(vis >> i & 1) && dfs(vis | 1 << i, i, t + d[k][i]))return true;\n    return false;\n}\n\nint main(){\n    while(cin >> n >> hx >> hy >> dx >> dy, n|hx|hy|dx|dy){\n        cx.assign(n, 0); cy.assign(n, 0); dd.assign(n, 0);\n        d.assign(n + 1, vector<double>(n + 1, 0));\n        rep(i, n){\n            cin >> cx[i] >> cy[i];\n            dd[i] = hypot(cx[i] - dx, cy[i] - dy);\n            d[i][n] = d[n][i] = hypot(cx[i] - hx, cy[i] - hy);\n            rep(j, i)d[i][j] = d[j][i] = hypot(cx[i] - cx[j], cy[i] - cy[j]);\n        }\n        cout << (dfs(0, n, 0.)? \"YES\\n\": \"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n\n#define EPS\t1.0e-10\n#define MAX_CRYSTAL\t32\n#define rep(idx, max)\tfor(int idx = 0, idx##Max = max; idx < idx##Max; idx ++)\n\ntypedef struct _POINT\n{\n\tint x, y;\n\n\t_POINT() {}\n\t_POINT(int _x, int _y) : x(_x), y(_y) {}\n} POINT;\n\nint g_crystalNum;\nPOINT\tg_hero, g_devil;\nPOINT\tg_crystals[MAX_CRYSTAL];\n\nint\tg_bSolved;\nint\tg_bReached[MAX_CRYSTAL];\nint\tg_reachedCount;\n\ndouble Distance(const POINT &src1, const POINT &src2)\n{\n\tdouble x = src1.x - src2.x;\n\tdouble y = src1.y - src2.y;\n\treturn( ::sqrt(x * x + y * y) );\n}\n\nvoid Solve(const POINT &pt, const double time)\n{\n\t//std::cout << time << std::endl;\n\tif (g_bSolved) { return; }\n\n\tif (g_reachedCount == g_crystalNum)\n\t{\n\t\tg_bSolved = true;\n\t\treturn;\n\t}\n\n\trep(n, g_crystalNum)\n\t{\n\t\tif (g_bReached[n]) { continue; }\n\t\tdouble r = time + ::Distance(pt, g_crystals[n]);\t// Elapsed time of hero\n\t\tif (r - ::Distance(g_devil, g_crystals[n]) > EPS) { return; }\t// Could not reached (You are too late :P)\n\t}\n\n\trep(n, g_crystalNum)\n\t{\n\t\tdouble r = time + ::Distance(pt, g_crystals[n]);\n\n\t\tg_bReached[n] = true;\n\t\tg_reachedCount++;\n\t\t::Solve(g_crystals[n], r);\n\t\tg_bReached[n] = false;\n\t\tg_reachedCount--;\n\t}\n}\n\nint main(int nArgs, char **lplpszArgs)\n{\n\twhile (std::cin >> g_crystalNum, g_crystalNum)\n\t{\n\t\tstd::cin >> g_hero.x >> g_hero.y >> g_devil.x >> g_devil.y;\n\t\trep(i, g_crystalNum)\n\t\t{\n\t\t\tPOINT &pt = g_crystals[i];\n\t\t\tstd::cin >> pt.x >> pt.y;\n\t\t}\n\n\t\t::printf(\"Hero: (%d, %d), Devil: (%d, %d)\\n\", g_hero.x, g_hero.y, g_devil.x, g_devil.y);\n\n\t\tg_bSolved = false;\n\t\t::memset(g_bReached, 0, sizeof(g_bReached));\n\t\tg_reachedCount = 0;\n\t\t::Solve(g_hero, 0);\n\t\tstd::cout << (g_bSolved ? \"YES\" : \"NO\") << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; ++i)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define P complex<double>\n#define Y real()\n#define X imag()\n\nint n;\nP h, d;\nvector<double> lim;\nvector<P> v;\nvector< vector<double> > dis;\n\nbool isOK(vector<bool> &visited){\n  REP(i, visited.size()) if(!visited[i]) return false;\n  return true;\n}\nbool isEnd(vector<bool> &visited, double time){\n  REP(i, n){\n    if(visited[i]) continue;\n    if(lim[i] <= time) return true;\n  }\n  return false;\n}\nbool check(int now, double time, vector<bool> visited){\n  if(isOK(visited)) return true;\n  if(isEnd(visited, time)) return false;\n\n  //debug\n  //cout <<\"-----------\" <<endl;\n  //cout <<v[now].Y <<\", \" <<v[now].X <<\", \" <<time <<endl;\n  //REP(i, visited.size()) cout <<visited[i] <<\", \";\n  //cout <<endl;\n\n  bool ret = false;\n  REP(i, v.size()){\n    if(visited[i]) continue;\n    double next_time = dis[now][i] + time;\n    //debug\n    //cout <<\"! \" <<i <<endl;\n    //cout <<v[i].Y <<\", \" <<v[i].X <<endl;\n    //cout <<next_time <<\", \" <<lim[i] <<endl;\n\n    if(next_time < lim[i]){\n      visited[i] = true;\n      if(check(i, next_time, visited)){\n        ret = true;\n        break;\n      }\n      visited[i] = false;\n    }\n  }\n  //cout <<ret <<\"---------ret\" <<endl;\n  return ret;\n}\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >>n >>hx >>hy >>dx >>dy && n != 0){\n    h = P(hy, hx);\n    d = P(dy, dx);\n    v = vector<P>(n);\n    REP(i, n){\n      int a, b;\n      cin >>a >>b;\n      v[i] = P(b, a);\n    }\n\n    lim = vector<double>(n);\n    REP(i, n){\n      //debug\n      //cout <<i <<endl;\n      //cout <<abs(d - v[i]) <<endl;\n      lim[i] = abs(d - v[i]);\n    }\n\n    dis = vector< vector<double> >(n, vector<double>(n));\n    REP(i, n) REP(j, n) dis[i][j] = abs(v[i] - v[j]);\n\n    bool ok = false;\n    REP(i, n){\n      if(lim[i] <= abs(v[i] - h)) continue;\n      if(check(i, abs(v[i] - h), vector<bool>(n))){\n        ok = true;\n        break;\n      }\n    }\n    cout <<(ok ? \"YES\" : \"NO\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define INF 1<<30\n#define EPS 1e-10\nusing namespace std;\nint n,hx,hy,dx,dy;\nint cx[22],cy[22];\n\ndouble L(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\ndouble dp[22][1<<22];\ndouble solve(int m,int bit){\n  if(bit == (1<<n)-1) return L(cx[m]-hx,cy[m]-hy);\n  if(dp[m][bit] > 0) return dp[m][bit];\n\n  double ret = INF;\n  for(int i = 0; i < n; i++){\n    if(bit&(1<<i)) continue;\n    double l = solve(i,bit|(1<<i));\n    if(m < n) l += L(cx[m]-cx[i],cy[m]-cy[i]);\n    if(l+EPS < L(cx[i]-dx,cy[i]-dy)) ret = min(ret,l);\n  }\n  return dp[m][bit] = ret;\n}\n\nint main(void){\n  while(cin >> n >> hx >> hy >> dx >> dy && n){\n    for(int i = 0; i < n; i++){\n      cin >> cx[i] >> cy[i];\n    }\n    for(int j = 0; j < 22; j++){\n      for(int i = 0; i < 1<<22; i++){\n\tdp[j][i] = -1;\n      }\n    }\n    if(solve(n,0) > 1<<28) cout << \"NO\" << endl;\n    else cout << \"YES\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\nconst int INF=100000000;\n\n\nint n;\nint hx,hy;\nint dx,dy;\nint cx[21],cy[21];\n\n\ndouble dist(int _x0,int _y0,int _x1,int _y1) {\n\tdouble d = (_x0-_x1)*(_x0-_x1) + (_y0-_y1)*(_y0-_y1);\n\treturn sqrt(d);\n}\n\nint pow2(int a) {\n\treturn a*a;\n}\n\n//&#131;N&#131;&#138;&#131;X&#131;^&#131;&#139;&#130;&#204;&#136;&#202;&#146;u&#130;&#198;&#137;&#189;&#147;&#250;&#150;&#218;&#130;&#169;&#130;&#231;&#130;&#198;&#130;&#233;&#130;賊&#130;&#198;&#130;&#170;&#130;&#197;&#130;&#171;&#130;&#233;&#130;&#169;\nbool check(int x,int y,int d) {\n\treturn (pow2(dx-x)+pow2(dy-y)) > pow2(d);\n}\n\n//&#140;&#187;&#141;&#221;&#136;&#202;&#146;u,&#137;&#189;&#147;&#250;&#150;&#218;,&#143;W&#141;&#135;\nbool dfs(int x,int y,int d,int S) {\n    //printf(\"[debug] %d,%d,%d,%d\\n\",x,y,d,S);\n\tif(S==(1<<n)-1) return true;\n\trep(i,n) {\n\t\tif(!((S>>i)&1)) {\n\t\t\td += (int)dist(x,y,cx[i],cy[i]) + 1;\n\t\t\tif(check(cx[i],cy[i],d)) {\n\t\t\t\treturn dfs(cx[i],cy[i],d,S|(1<<i));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n\n}\n\n\nvoid solve() {\n\trep(i,n) cin>>cx[i]>>cy[i];\n\tif(dfs(hx,hy,0,0)) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\n}\n\nint main() {\n\twhile (cin>>n>>hx>>hy>>dx>>dy)\n\t{\n\t\tif(n+hx+hy+dx+dy==0) return 0;\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\n\n// n := クリスタルの個数 \nint n;\n// (hx,hy) := 勇者の初期位置\n// (dx,dy) := 魔王の位置\nint hx, hy, dx ,dy;\n// (cx[i],cy[i]) := i 番目のクリスタルの位置\nint cx[21], cy[21];\n// done[i] := i 番目のクリスタルを回収したかどうか\nbool done[21];]\n// 答え\nbool ans;\n\n// 2 点間の距離\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\n\n// 枝刈り探索\n// t := 経過時間[s], (x,y) := 勇者の位置\nvoid solve(double t, int x, int y){\n    if( ans ) return ;\n    \n    // cnt := 現在回収したクリスタルの個数\n    int cnt=0;\n    for(int i=0 ; i < n ; i++ ){\n        if( done[i] ) cnt++;\n    }\n    // n 個のクリスタルを回収したとき\n    if( cnt == n ){\n        ans = true;\n        return;\n    }\n    \n    // 回収できないクリスタルがあるか調べる\n    for(int i=0 ; i < n ; i++ ){\n        if( done[i] ) continue;\n\t\t\n        double next_time = t + dist( x , y , cx[i] , cy[i] );\n        // すでに回収できないクリスタルがあったら探索打ち切り\n        if ( dist( dx , dy , cx[i] , cy[i] ) < next_time + EPS ){ \n            return; \n        }\n    }\n    for(int i=0 ; i < n ; i++ ){\n        if( done[i] ) continue;\n \n        double next_time = t + dist( x , y , cx[i] , cy[i] );\n        done[i] = true;\n        solve( next_time , cx[i] , cy[i] );\n        done[i] = false;\n    }\n}\n \nint main(){\n    while( cin >> n >> hx >> hy >> dx >> dy , (n || hx || hy || dx || dy) ){\n    \t// (cx[i],cy[i]) := i 番目のクリスタルの位置\n        for(int i=0 ; i < n ; i++ ){\n            cin >> cx[i] >> cy[i];\n        }\n        \n        // 初期化\n        for(int i=0 ; i < 21 ; i++ ){\n            done[i] = false;\n        }\n        \n        ans = false;\n        solve( 0.0 , hx , hy );\n        if( ans ){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint N;\nP H,D;\nP C[22];\n\nint getK(P a,P b){\n  return (a.F-b.F) * (a.F-b.F) +  (a.S-b.S) * (a.S-b.S);\n}\nint sum(int a,int b){\n  return a*b+2*sqrt(a)*sqrt(b);\n}\n\nbool solve(int id,int st,int ky){\n  if( st == (1<<N)-1 ){\n    return true;\n  }\n\n  for(int i=0;i<N;i++){\n    if( (1<<i) & st ) continue;\n    int sm = sum(ky,getK(C[id],C[i]));\n    int r = getK(D,C[i]);\n    if( sm < r ){\n      if( solve( i, st | (1<<i) , sm ) ) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >>N >> H.F >> H.S >> D.F >> D.S;\n    if( !N && !H.F && !H.S && !D.F && !D.S) break;\n    for(int i=0;i<N;i++) {\n      cin >> C[i].F >> C[i].S;\n    }\n    bool f=false;\n    for(int i=0;i<N;i++){\n      int r = getK(D,C[i]);\n      int me = getK(H,C[i]);\n      if( me < r ){\n\tif( solve(i,(1<<i),me) ) f=true;\n\tif( f ) break;\n      }\n    }\n    if( f )cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<string.h>\nusing namespace std;\n\nint n,dx,dy,hx,hy;\nbool done[20];\nint cx[20],cy[20];\n\ndouble calc(int x1,int y1,int x2,int y2){\n\treturn sqrt((double)(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nbool dfs(int x,int y,int now,double time,int k){\n//\tcout<<now<<\" \";\n//\tcout<<time<<endl;\n\tif(now>=0 && calc(cx[now],cy[now],dx,dy)<=time) return false;\n\tif(k==n) return true;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(done[i]) true;\n\t\tif(time+calc(cx[i],cy[i],x,y)+0.000001>=calc(cx[i],cy[i],dx,dy)) return false;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tif(done[i]) continue;\n\t\tdone[i]=true;\n\t\tif(dfs(cx[i],cy[i],i,time+calc(cx[i],cy[i],x,y),k+1)) return true;\n\t\tdone[i]=false;\n\t}\n\treturn false;\n}\n\n\nint main()\n{\n\twhile(cin>>n>>hx>>hy>>dx>>dy && n!=0){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>cx[i]>>cy[i];\n\t\tmemset(done,false,sizeof(done));\n\t\tif(dfs(hx,hy,-1,0.0,0)) cout<<\"YES\\n\";\n\t\telse cout<<\"NO\\n\";\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//56\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\n#define S(X) ((X)*(X))\n\nint n,hx,hy,dx,dy;\ndouble d[21][21];\ndouble l[21];\n\nbool dfs(int s,double t,int g){\n  if(g==(1<<n+1)-1)return true;\n  for(int i=1;i<=n;i++){\n    if(!(g&1<<i)&&t+d[s][i]<l[i]){\n      if(dfs(i,t+d[s][i],g|1<<i))return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin>>n>>hx>>hy>>dx>>dy,n|hx|hy|dx|dy){\n    int cx[21]={hx},cy[21]={hy};\n    for(int i=1;i<=n;i++){\n      cin>>cx[i]>>cy[i];\n    }\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\td[i][j]=sqrt(S(cx[i]-cx[j])+S(cy[i]-cy[j]));\n      }\n    }\n    for(int i=1;i<=n;i++){\n      l[i]=sqrt(S(dx-cx[i])+S(dy-cy[i]));\n    }\n    cout<<(dfs(0,0,1)?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nstruct pos{\n\tint x;\n\tint y;\n};\nstruct rel{\n\tint to;\n\tint dis;\n};\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy){\n\t\tvector<pos> p;\n\t\tREP(k, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp.push_back({ x, y });\n\t\t}\n\t\tvector<vector<int>> r(n + 1, vector<int>(n + 1));\n\t\tvector<int> dr(n);\n\t\tREP(i, n + 1){\n\t\t\tif (i != n)\n\t\t\t\tdr[i] = (dx - p[i].x)*(dx - p[i].x) + (dy - p[i].y)*(dy - p[i].y);\n\n\t\t\tfor (int j = 0; j < n + 1; j++){\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (i != n  && j != n)r[i][j] = (p[i].x - p[j].x)*(p[i].x - p[j].x) + (p[i].y - p[j].y)*(p[i].y - p[j].y);\n\t\t\t\telse if (i == n)r[i][j] = (hx - p[j].x)*(hx - p[j].x) + (hy - p[j].y)*(hy - p[j].y);\n\t\t\t\telse if (j == n)r[i][j] = (p[i].x - hx)*(p[i].x - hx) + (p[i].y - hy)*(p[i].y - hy);\n\t\t\t}\n\t\t}\n\n\t\tbool b[21] = { false };\n\t\tREP(i, n)b[i] = true;\n\t\tint b_n = n;\n\t\tbool flag = false;\n\t\tfunction<void(double dis, int from)> f = [&](double dis, int from){\n\t\t\tif (flag)return;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (b[i] && (dis + sqrt(r[from][i]))>=sqrt(dr[i]))return;\n\t\t\t}\n\t\t\t\n\t\t\tif (b_n != 0){\n\t\t\t\tfor (int i = 0; i < n && !flag; i++){\n\t\t\t\t\tif (b[i] && (dis + sqrt(r[from][i]))<sqrt(dr[i])){\n\t\t\t\t\t\tb[i] = false;\n\t\t\t\t\t\tb_n--;\n\t\t\t\t\t\tf(dis + sqrt(r[from][i]), i);\n\t\t\t\t\t\tb[i] = true;\n\t\t\t\t\t\tb_n++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tflag = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn;\n\t\t};\n\t\tf(0.0, n); \n\t\tcout << (flag ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\nconst int INF=100000000;\ntypedef complex<double> P;\n// e_ÔÌ£\ndouble dist[22][22];\n// e_ÌÀW\nvector<P> points;\nint n,hx,hy,dx,dy;\nbool ok=false;\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\n// »ÝÌê©çßÄÂ\\ÈÅ¬ÊßbðÔ·\nvoid dfs(int s,int cp,double passedSec){\n    if(ok)\n        return;\n    else if(s==0){\n        ok=true;\n        return;\n    }\n    for(int i = 0; i < n; i++){\n        // Ü¾rbgª1ÈçÎ\n        if((s>>i)&1){\n            // áCªB·éOÉTõÂ\\©Ç¤©ð`FbN\n            double dt=dist[cp][i];\n            // ¤©çÚ®æÖÌ¼aðæ¾\n            double r=dist[n+1][i];\n            // àµ¼aªz¦Ä¢½ç,}ëè\n            if(dt+passedSec>r||EQ(dt+passedSec,r))\n                return;\n        }\n    }\n    for(int i = 0; i < n; i++){\n        // Ü¾rbgª1ÈçÎ\n        if((s>>i)&1){\n            // áCªB·éOÉTõÂ\\©Ç¤©ð`FbN\n            double dt=dist[cp][i];\n            // ¤©çÚ®æÖÌ¼aðæ¾\n            double r=dist[n+1][i];\n            dfs((s&(~(1<<i))),i,dt+passedSec);\n        }\n    }\n}\n\n\nint main(){\n    while(cin>>n>>hx>>hy>>dx>>dy&&!(n==0&&hx==0&&hy==0&&dx==0&&dy==0)){\n        points.clear();\n        ok=false;\n        // EÒÌúÊu\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            P p=P(x,y);\n            points.push_back(p);\n        }\n        points.push_back(P(hx,hy));\n        points.push_back(P(dx,dy));\n        for(int i = 0; i < points.size(); i++){\n            for(int j = 0; j < points.size(); j++){\n                //dist[i][j]=sqrt((double)(points[i].first-points[j].first)*(points[i].first-points[j].first)\n                //    +(points[i].second-points[j].second)*(points[i].second-points[j].second));\n                dist[i][j]=abs(points[i]-points[j]);\n            }\n        }\n        dfs(((1<<n)-1),n,0.0);\n        if(ok)\n            cout<<\"YES\"<<endl;\n        else\n            cout<<\"NO\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<string.h>\nusing namespace std;\n\nint n,dx,dy,hx,hy;\nbool done[20];\nint cx[20],cy[20];\n\ndouble calc(int x1,int y1,int x2,int y2){\n\treturn sqrt((double)(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nbool dfs(int x,int y,int now,double time,int k){\n//\tcout<<now<<\" \";\n//\tcout<<time<<endl;\n\tif(now>=0 && calc(cx[now],cy[now],dx,dy)<=time) return false;\n\tif(k==n) return true;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(done[i]) true;\n\t\tif(time+calc(cx[i],cy[i],x,y)>=calc(cx[i],cy[i],dx,dy)) return false;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tif(done[i]) continue;\n\t\tdone[i]=true;\n\t\tif(dfs(cx[i],cy[i],i,time+calc(cx[i],cy[i],x,y),k+1)) return true;\n\t\tdone[i]=false;\n\t}\n\treturn false;\n}\n\n\nint main()\n{\n\twhile(cin>>n>>hx>>hy>>dx>>dy && n!=0){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>cx[i]>>cy[i];\n\t\tmemset(done,false,sizeof(done));\n\t\tif(dfs(hx,hy,-1,0.0,0)) cout<<\"YES\\n\";\n\t\telse cout<<\"NO\\n\";\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint n;\ndouble hx, hy, dx, dy;\nvector<double>cx, cy;\n\ndouble dist(double ax, double ay, double bx, double by){\n  return sqrt((ax-bx)*(ax-bx) + (ay-by)*(ay-by));\n}\n\nint dfs(int c, double t, double x, double y, int *used){\n  //  printf(\"%d %lf %lf %lf\\n\", c, t, x, y);\n  if(c == n) return 1;\n\n  rep(i, n){\n    if(used[i]) continue;\n    double nt = dist(x, y, cx[i], cy[i]);\n    //    printf(\"x:%lf y:%lf nt:%lf\\n\", x, y, nt);\n    //    printf(\"dx;%lf dy:%lf cx:%lf cy:%lf\\n\", dx, dy, cx[i], cy[i]);\n    //    printf(\"%lf %lf\\n\", t + nt + EPS, dist(dx, dy, cx[i], cy[i]));\n    if(t + nt + EPS > dist(dx, dy, cx[i], cy[i])) continue;\n    used[i] = 1;\n    if(dfs(c+1, t + nt, cx[i], cy[i], used)) return 1;\n    used[i] = 0;\n  }\n  return 0;\n}\n\nint main(){\n  while(scanf(\"%d%lf%lf%lf%lf\", &n, &hx, &hy, &dx, &dy) && n+hx+hy+dx+dy){\n    cx.clear(); cy.clear();\n    rep(i, n){\n      double a, b;\n      scanf(\"%lf%lf\", &a, &b);\n      cx.PB(a); cy.PB(b);\n    }\n\n    int used[20];\n    memset(used, 0, sizeof(used));\n    if(dfs(0, 0, hx, hy, used)) puts(\"YES\");\n    else puts(\"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< double , Pi > Pii;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 55;\n\nfloat dp[1 << 20][20];\nint main(){\n  int n, hx, hy, dx, dy;\n  vector< char > near(1 << 20);\n\n  for(int i = 0; i < 1 << 20; i++){\n    for(int k = 0; k < 20; k++){\n      if((i >> k) & 1) continue;\n      near[i] = k;\n      break;\n    }\n  }\n  while(cin >> n >> hx >> hy >> dx >> dy, n|hx|hy|dx|dy){\n\n    vector< Pii > c(n);\n    for(int i = 0; i < n; i++){\n      cin >> c[i].sc.fr >> c[i].sc.sc;\n      c[i].fr = sqrt( pow( dx - c[i].sc.fr, 2) + pow( dy - c[i].sc.sc, 2));\n    }\n    sort( ALL(c));\n\n    fill_n( *dp, (1 << 20) * 20, 1e9);\n    for(int i = 0; i < n; i++){\n      double dist = sqrt(pow(hx - c[i].sc.fr, 2) + pow(hy - c[i].sc.sc, 2));\n      if(dist < sqrt(pow(dx - c[i].sc.fr, 2) + pow(dy - c[i].sc.sc, 2))){\n        dp[1 << i][i] = dist;\n      }\n    }\n\n    for(int i = 0; i < (1 << n) - 1; i++){\n      for(int j = 0; j < n; j++){ //前のクリスタル\n        if(!((i >> j) & 1) || dp[i][j] == 1e9) continue;\n        if(sqrt( pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) >= dp[i][j]) continue;\n        for(int k = 0; k < n; k++){\n          if((i >> k) & 1) continue;\n          double next = dp[i][j] + sqrt(pow( c[j].sc.fr - c[k].sc.fr, 2) + pow( c[j].sc.sc - c[k].sc.sc, 2));\n          if(next >= dp[i|(1 << k)][k]) continue;\n          //条件に合えば次へ進む\n          bool check = sqrt(pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) > next;\n          if(check) dp[i|(1 << k)][k] = next;\n        }\n      }\n    }\n\n    bool check = n == 0;\n    for(int i = 0; i < n; i++){\n      check |= dp[(1 << n) - 1][i] < 1e9;\n    }\n    if(check) cout << \"YES\" << endl;\n    else cout <<\"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//56\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\n#define S(X) ((X)*(X))\n\nint n,hx,hy,dx,dy;\ndouble d[21][21];\ndouble l[21];\n\nbool dfs(int s,double t,int g){\n  if(g==(1<<n+1)-1)return true;\n  double ll=1<<30;\n  for(int i=1;i<=n;i++){\n    if(!(g&1<<i)&&ll>l[i]){\n      ll=l[i];\n    }\n  }\n  double lb=1<<30;\n  for(int i=0;i<=n;i++){\n    if(!(g&1<<i)&&lb>d[s][i]+t){\n      lb=d[s][i]+t;\n    }\n  }\n  if(ll<lb)return false;\n  for(int i=1;i<=n;i++){\n    if(!(g&1<<i)&&t+d[s][i]<l[i]){\n      if(dfs(i,t+d[s][i],g|1<<i))return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin>>n>>hx>>hy>>dx>>dy,n|hx|hy|dx|dy){\n    int cx[21]={hx},cy[21]={hy};\n    for(int i=1;i<=n;i++){\n      cin>>cx[i]>>cy[i];\n    }\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\td[i][j]=sqrt(S(cx[i]-cx[j])+S(cy[i]-cy[j]));\n      }\n    }\n    for(int i=1;i<=n;i++){\n      l[i]=sqrt(S(dx-cx[i])+S(dy-cy[i]));\n    }\n    cout<<(dfs(0,0,1)?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-9;\n\ntypedef pair<xy_t, bool> dat;\n\nnamespace std{\n\tbool operator < (const xy_t &a, const xy_t &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nint n, hx, hy, dx, dy;\nxy_t points[21];\ndouble dis[1 << 21];\nmap<P, bool> bad;\n\nbool dfs(double t, int v, int st){\n\tif(st == (1 << (n + 1)) - 1) return true;\n\tif(bad[P(v, st)]) return false;\n\tif(dis[st] < t){\n\t\tbad[P(v, st)] = true;\n\t\treturn false;\n\t}\n\n\tbool res = false;\n\tfor(int i = 1; i < n + 1; i++){\n\t\tif(!(st & (1 << i))){\n\t\t\tdouble nt = t + abs(points[i] - points[v]);\n\t\t\tif(nt < abs(points[i] - xy_t(dx, dy))) res |= dfs(nt, i, st | (1 << i));\n\t\t}\n\t\tif(res) return true;\n\t}\n\tbad[P(v, st)] = true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> n >> hx >> hy >> dx >> dy && (n || hx || hy || dx || dy)){\n\t\tbad.clear();\n\t\tpoints[0] = xy_t(hx, hy);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints[i] = xy_t(x, y);\n\t\t}\n\t\tfor(int i = 1; i < (1 <<( n + 1)); i++){\n\t\t\tdouble d = 1e10;\n\t\t\tfor(int j = 0; j < n + 1; j++){\n\t\t\t\tif(!(i & (1 << j))) d = min(d, abs(points[j] - xy_t(dx, dy)));\n\t\t\t}\n\t\t\tdis[i] = d;\n\t\t}\n\t\tif(dfs(0.0, 0, 1)) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nstruct Point {\n\tint x, y;\n};\n\nconst double EPS = 1E-8;\nPoint h, d, p[20];\nint n;\nbool flag[20];\n\nbool dfs(double t, int s) \n{\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tif (!flag[i]) break;\n\t}\n\tif (i == n) return true;\n\t\n\tPoint pp = (s == -1) ? h : p[s];\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tif (hypot(d.x - p[i].x, d.y - p[i].y) - hypot(pp.x - p[i].x, pp.y - p[i].y) - t < EPS) return false;\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tflag[i] = true;\n\t\tif (dfs(t + hypot(pp.x - p[i].x, pp.y - p[i].y), i)) return true;\n\t\tflag[i] = false;\n\t}\n\t\n\treturn false;\n}\n\nint main()\n{\t\n\twhile (cin >> n >> h.x >> h.y >> d.x >> d.y, n | h.x | h.y | d.x | d.y) {\n\t\tmemset(flag, false, sizeof(flag));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p[i].x >> p[i].y;\n\t\t}\n\t\tcout << (dfs(0, -1) ? \"YES\" : \"NO\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define INF 10000\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point;\ndouble dist(const point &a, const point &b){return std::abs(b-a);}\nint main(){\n\twhile(true){\n\t\tbool bSafe = true;\n\t\tint n,hx,hy,dx,dy;\n\t\tdouble walk=0.0;\n\t\tpoint hero, daemon;\n\t\tvector< point > vp;\n\t\tscanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy);\n\t\tif(!(n||hx||hy||dx||dy))break;\n\t\thero = complex<elem>(hx,hy);\n\t\tdaemon = complex<elem>(dx,dy);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint cx,cy;\n\t\t\tscanf(\"%d%d\", &cx, &cy);\n\t\t\tpoint p(cx,cy);\n\t\t\tvp.push_back( p );\n\t\t}\n\t\twhile( vp.size()>0 ){\n\t\t\tdouble min_dist=INF;\n\t\t\tint min_cristal = -1;\n\t\t\tfor(unsigned int i=0;i<vp.size();++i){\n\t\t\t\t//cout << \"DAEMON: \" << daemon << \" CRISTAL: \" << vp[i] << \" DIST: \" << dist( daemon, vp[i] ) << endl;\n\t\t\t\tif( min_dist > dist( daemon, vp[i] ) ){\n\t\t\t\t\tmin_dist = dist( daemon, vp[i] );\n\t\t\t\t\tmin_cristal = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\twalk+=dist(hero,vp[min_cristal]);\n\t\t\t//cout<<\"MINDIS: \" << min_dist << \"WALKED: \" << walk << endl;\n\t\t\tif(walk>=min_dist){\n\t\t\t\tbSafe=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvp.erase(vp.begin()+min_cristal);\n\t\t}\n\t\tif( bSafe )\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,j) for (int i=0;i<j;++i)\n\nint main() {\n    int n, px, py, nx, ny;\n    while (cin >> n >> px >> py >> nx >> ny, (n||px||py||nx||ny)) {\n\n        vector<pair<int, int>> pos;\n        vector<double> pu;\n        vector<double> nu;\n\n        rep(i,n) {\n            int tx, ty;\n            cin >> tx >> ty;\n            pos.push_back({tx, ty});\n            pu.push_back(sqrt(pow(nx-tx+0.0, 2.0)+pow(ny-ty+0.0, 2.0)));\n            nu.push_back(sqrt(pow(px-tx+0.0, 2.0)+pow(py-ty+0.0, 2.0)));\n        }\n\n        int idx = 0;\n        double dm = pu[0];\n        for (int i = 1; i < pu.size(); ++i) {\n            if (dm > pu[i]) {\n                idx = i;\n                dm = pu[i];\n            }\n        }\n\n        if (pu[idx] > nu[idx]) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P> PP;\n#define INF (1<<24)\n#define EPS 1e-10\nint n;\ndouble sx,sy,tx,ty,px[20],py[20];\ndouble tab[(1<<20)];\n\ndouble dis(double a,double b,double c,double d)\n{return sqrt((a-c)*(a-c)+(b-d)*(b-d));}\ndouble dis(int a,int b){return dis(px[a],py[a],px[b],py[b]);}\n\nint main(){\n  while(1){\n    cin>>n>>sx>>sy>>tx>>ty;\n    if(n==0&&sx==0&&sy==0&&tx==0&&ty==0)break;\n    for(int i=0;i<n;i++)cin>>px[i]>>py[i];\n    for(int i=0;i<(1<<n);i++)\n      tab[i]=INF;\n    priority_queue<PP> Q;\n    for(int i=0;i<n;i++){\n      Q.push( PP(dis(sx,sy,px[i],py[i]),P((1<<i),i) ) );\n      tab[(1<<i)]=dis(sx,sy,px[i],py[i]);\n    }\n\n    while(!Q.empty()){\n      PP tmp=Q.top();Q.pop();\n      double total=tmp.first;\n      int S=tmp.second.first,pos=tmp.second.second;\n\n      bool flg=false;    \n      for(int i=0;i<n;i++)\n\tif(total+dis(pos,i)>dis(tx,ty,px[i],py[i]))flg=true;\n      if(flg)continue;\n      \n      for(int i=0;i<n;i++){\n\tif((S>>i)&1)continue;\n\tif(total+dis(pos,i)>tab[S|(1<<i)])continue;\n\tif(total+dis(pos,i)>=dis(tx,ty,px[i],py[i]))continue;\n\ttab[S|(1<<i)]=total+dis(pos,i);\n\tQ.push( PP(total+dis(pos,i),P(S|(1<<i),i)) );\n      }\n    }\n    \n    bool flag=false;\n    if(tab[(1<<n)-1]!=INF)flag=true;\n    cout<<(flag?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\ninline double sq(double a) { return a*a; }\n#define INF (1e100)\n#define EPS (1e-9)\n\nint n;\ndouble hx, hy, mx, my, xs[32], ys[32], ds[32], ws[32][32];\npair<double, int> ns[32];\n\nbool rec(int b, int at, double t) {\n    if (b == (1<<n)-1) return true;\n    rep (i, n) {\n        const int ix = ns[i].second;\n        if (b&(1<<ix)) continue;\n        double nt = t + ws[at][ix];\n        if (nt > ds[ix]-EPS) return false;\n        if (rec(b|(1<<ix), ix, nt)) return true;\n    }\n    return false;\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%lf%lf%lf%lf\", &n, &hx, &hy, &mx, &my);\n        if (n == 0) return 0;\n        rep (i, n) scanf(\"%lf%lf\", xs+i, ys+i);\n        rep (i, n) ds[i] = sqrt(sq(xs[i]-mx) + sq(ys[i]-my));\n        rep (i, n) ns[i] = mp(ds[i], i);\n        sort(ns, ns+n);\n        rep (i, n) rep (j, n) {\n            ws[i][j] = sqrt(sq(xs[i]-xs[j]) + sq(ys[i]-ys[j]));\n        }\n        bool ans = false;\n        rep (i, n) {\n            double t = sqrt(sq(xs[i]-hx) + sq(ys[i]-hy));\n            if (t < ds[i]-EPS && rec(1<<i, i, t)) { ans = true; break; }\n        }\n        puts(ans ? \"YES\" : \"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<map>\n#include<cmath>\n#include<algorithm>\n#define X real()\n#define Y imag()\nusing namespace std;\n\ntypedef complex<double> P;\n\nint n;\nP ph,pd;\nvector<P>items;\n\ndouble dist(P p1,P p2){\n  P p = p1 - p2;\n  return sqrt(p.X * p.X + p.Y * p.Y);\n}\n\nbool dfs(P p,int state,int time){\n  if(__builtin_popcount(state) == n)return true;\n  for(int i = 0 ; i < n ; i++){\n    if((state >> i)&1)continue;\n    int nstate = state | (1 << i);\n    double d = dist(p,items[i]);\n    int ntime = time + ceil(d);\n    if(ntime >= dist(pd,items[i]))continue;\n    if(dfs(items[i],nstate,ntime))return true;\n  }\n  return false;\n}\n\nvoid input(){\n  items.clear();\n  for(int i = 0 ; i < n ; i++){\n    P p;\n    cin >> p.X >> p.Y;\n    items.push_back(p);\n  }\n}\n\nint main(){\n  while(1){\n    cin >> n >> ph.X >> ph.Y >> pd.X >> pd.Y;\n    if(n == 0 && ph.X == 0 && ph.Y == 0 && pd.X == 0 && pd.Y == 0)break;\n    input();\n    cout << (dfs(ph,0,0)?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n\n#define EPS\t1.0e-10\n#define MAX_CRYSTAL\t32\n#define rep(idx, max)\tfor(int idx = 0, idx##Max = max; idx < idx##Max; idx ++)\n\ntypedef struct _POINT\n{\n\tint x, y;\n\n\t_POINT() {}\n\t_POINT(int _x, int _y) : x(_x), y(_y) {}\n} POINT;\n\nint g_crystalNum;\nPOINT\tg_hero, g_devil;\nPOINT\tg_crystals[MAX_CRYSTAL];\n\nint\tg_bSolved;\nint\tg_bReached[MAX_CRYSTAL];\nint\tg_reachedCount;\n\ndouble Distance(const POINT &src1, const POINT &src2)\n{\n\tdouble x = src1.x - src2.x;\n\tdouble y = src1.y - src2.y;\n\treturn( ::sqrt(x * x + y * y) );\n}\n\nvoid Solve(const POINT &pt, const double time)\n{\n\t//std::cout << time << std::endl;\n\tif (g_bSolved) { return; }\n\n\tif (g_reachedCount == g_crystalNum)\n\t{\n\t\tg_bSolved = true;\n\t\treturn;\n\t}\n\n\trep(n, g_crystalNum)\n\t{\n\t\tif (g_bReached[n]) { continue; }\n\t\tdouble r = time + ::Distance(pt, g_crystals[n]);\t// Elapsed time of hero\n//\t\tif (r - ::Distance(g_devil, g_crystals[n]) > EPS) { return; }\t// Could not reached (You are too late :P)\n\t\tif (::Distance(g_devil, g_crystals[n]) < r + EPS) { return; }\t// Could not reached (You are too late :P)\n\t}\n\n\trep(n, g_crystalNum)\n\t{\n\t\tif (g_bReached[n]) { continue; }\n\n\t\tg_bReached[n] = true;\n\t\tg_reachedCount++;\n\t\t::Solve(g_crystals[n], time + ::Distance(pt, g_crystals[n]));\n\t\tg_bReached[n] = false;\n\t\tg_reachedCount--;\n\t}\n}\n\nint main(int nArgs, char **lplpszArgs)\n{\n\twhile (std::cin >> g_crystalNum)\n\t{\n\t\tstd::cin >> g_hero.x >> g_hero.y >> g_devil.x >> g_devil.y;\n\t\tif (g_crystalNum == 0) { break; }\n\t\trep(i, g_crystalNum)\n\t\t{\n\t\t\tPOINT &pt = g_crystals[i];\n\t\t\tstd::cin >> pt.x >> pt.y;\n\t\t}\n\n\t\t//::printf(\"Hero: (%d, %d), Devil: (%d, %d)\\n\", g_hero.x, g_hero.y, g_devil.x, g_devil.y);\n\n\t\tg_bSolved = false;\n\t\t::memset(g_bReached, 0, sizeof(g_bReached));\n\t\tg_reachedCount = 0;\n\t\t::Solve(g_hero, 0);\n\t\tstd::cout << (g_bSolved ? \"YES\" : \"NO\") << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nbool used[21];\nint n,hx,hy,dx,dy;\nvector<int> cx(21),cy(21);\nvector<double> dist(21);\ndouble pointdistance(int x1, int y1, int x2, int y2){\n  return sqrt( (x1-x2)*(x1-x2) +(y1-y2)*(y1-y2) );\n}\nint dfs(int x, int y, int t,double s){\n  if(t==n) return true;\n  double nexts;\n  REP(i,n){\n    if(!used[i]){\n      nexts = s + pointdistance(x,y,cx[i],cy[i]);\n      if(nexts > dist[i] - EPS) return false; \n    }\n  }\n  REP(i,n){\n    if(!used[i]){\n      nexts = s + pointdistance(x,y,cx[i],cy[i]);\n      used[i] = true;\n      if(dfs(cx[i],cy[i],t+1,nexts)) return true;\n      used[i] = false;\n    }\n  }\n  return false;\n}\n\nint main(void){\n  while(cin>>n>>hx>>hy>>dx>>dy,n){\n    REP(i,n)cin>>cx[i]>>cy[i];\n    REP(i,n)dist[i] = sqrt((cx[i]-dx)*(cx[i]-dx) +(cy[i]-dy)*(cy[i]-dy) );\n    memset(used,0,sizeof(used));\n    if(dfs(hx,hy,0,0.0)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\nint n;\ndouble dis[32][32];\nbool dfs(int unvisit, int cur, double time)\n{\n\tif (unvisit == 0)\n\t\treturn true;\n\n\tfor (int i = 0; i < n; ++i)\n\t\tif (unvisit >> i & 1 && time + dis[cur][i] > dis[n + 1][i])\n\t\t\treturn false;\n\n\tfor (int i = 0; i < n; ++i)\n\t\tif (unvisit >> i & 1 && time + dis[cur][i] < dis[n + 1][i])\n\t\t\tif (dfs(unvisit ^ 1 << i, i, time + dis[cur][i]))\n\t\t\t\treturn true;\n\n\treturn false;\n}\nint main()\n{\n\tint  hx, hy, dx, dy;\n\twhile (scanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy), n)\n\t{\n\t\tint  x[32], y[32];\n\t\trep (i, n)\n\t\t\tscanf(\"%d%d\", x + i, y + i);\n\t\tx[n] = hx, y[n] = hy;\n\t\tx[n + 1] = dx, y[n + 1] = dy;\n\n\t\tfor (int i = 0; i <= n + 1; ++i)\n\t\t\tfor (int j = 0; j <= n + 1; ++j)\n\t\t\t\tdis[i][j] = hypot(x[i] - x[j], y[i] - y[j]);\n\n\t\tputs(dfs((1 << n) - 1, n, 0) ? \"YES\" : \"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\n// 1: a,b,cが反時計周りの順に並ぶ\n//-1: a,b,cが時計周りの順に並ぶ\n// 2: c,a,bの順に直線に並ぶ\n//-2: a,b,cの順に直線に並ぶ\n// 0: a,c,bの順に直線に並ぶ\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.b - l.a) / norm(l.a - l.b);\n\treturn l.a + t * (l.b - l.a);\n}\n\n//線対象の位置にある点\nPoint reflect(const Line &l, const Point &p) {\n\tPoint pr = proj(l, p);\n\treturn pr * 2. - p;\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// 直線と直線の交点\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// 線分と線分の交点\n//　重なってる部分あるとassert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//先にisis_ssしてね\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// 線分と線分の交点\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine line_bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n//点と点の垂直二等分線　aを左に見ながら\nLine point_bisection(const Point&a, const Point&b) {\n\tconst Point cen((a + b) / 2.);\n\tconst Point vec = (b - a)*Point(0, 1);\n\treturn Line(cen, cen + vec);\n}\n\n//三つの点からなる外心\nPoint outer_center(const vector<Point>&ps) {\n\tassert(ps.size() == 3);\n\tLine l1 = point_bisection(ps[0], ps[1]);\n\tLine l2 = point_bisection(ps[1], ps[2]);\n\n\treturn is_ll(l1, l2);\n}\n\n\n//三つの直線からなる内心\n//三つの直線が並行でないことは確かめといてね\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(line_bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(line_bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//三つの直線からなる傍心\n//三つの直線が並行でないことは確かめといてね\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(line_bisection(Line(vertics[i], vertics[i] * 2.0 - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(line_bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0 - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:並行\n//c:並行でない\n//三つの直線から同距離の位置を求める。\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(line_bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(line_bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(line_bisection(Line(vertics[0], 2.*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n/*\n点が円の中にいるか\n0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const  Point& p, const Circle &cir) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n/*\n円lcが円rcの中にいるか\n0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//二つの円の重なり面積\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n\n\n//多角形(複数の点)の最小包含円をO(N=頂点数)で求めるアルゴリズム\n//同一直線上に三つの点がないこと\n#include<random>\nCircle welzl(vector<Point>ps) {\n\tstruct solver {\n\t\tCircle solve(vector<Point>&ps, vector<Point>&rs) {\n\t\t\tif (ps.empty() || rs.size() == 3) {\n\t\t\t\tif (rs.size() == 1) {\n\t\t\t\t\treturn Circle(Point(rs[0]), 0);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 2) {\n\t\t\t\t\treturn Circle((rs[0] + rs[1]) / 2.0, abs(rs[1] - rs[0]) / 2);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 3) {\n\t\t\t\t\tvector<Line> ls(3);\n\t\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\t\tls[i] = Line(rs[i], rs[(i + 1) % 3]);\n\t\t\t\t\t}\n\t\t\t\t\tPoint center = outer_center(rs);\n\t\t\t\t\treturn Circle(center, abs(center - rs[0]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn Circle(Point(), 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tPoint p_ba = ps.back();\n\t\t\t\tps.pop_back();\n\t\t\t\tCircle d = solve(ps, rs);\n\t\t\t\tps.push_back(p_ba);\n\t\t\t\tif (is_in_Circle(d, p_ba)) {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trs.push_back(p_ba);\n\t\t\t\t\tps.pop_back();\n\t\t\t\t\tauto ans = solve(ps, rs);\n\t\t\t\t\tps.push_back(p_ba);\n\t\t\t\t\trs.pop_back();\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}so;\n\tstd::random_device rd;\n\tstd::mt19937 mt(rd());\n\tshuffle(ps.begin(), ps.end(), mt);\n\tvector<Point>rs;\n\tCircle ans = so.solve(ps, rs);\n\treturn ans;\n}\n// 面積\nld get_area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tfor (int j = 0; j<n; ++j) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n//点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\n\n\nint main() {\n\twhile (true) {\n\t\tint N; Point start_po;\n\t\tvector<Point>pos;\n\t\t{\n\t\t\tld Hx, Hy, Sx, Sy;\n\t\t\tcin >> N >> Hx >> Hy >> Sx >> Sy;\n\t\t\tif(!N)return 0;\n\t\t\tstart_po = Point(Hx - Sx, Hy - Sy);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tld x, y; cin >> x >> y;\n\t\t\t\tpos.emplace_back(x - Sx, y - Sy);\n\t\t\t}\n\t\t}\n\t\tvector<vector<ld>>memo(N, vector<ld>(1 << N, 1e18));\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tld atime = abs(pos[i] - start_po);\n\t\t\tif (atime + eps < abs(pos[i])) {\n\t\t\t\tbitset<20>bs;\n\t\t\t\tbs[i] = true;\n\t\t\t\tmemo[i][bs.to_ulong()] = atime;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << N); ++i) {\n\t\t\tfor (int now = 0; now < N; ++now) {\n\t\t\t\tif (memo[now][i]>1e17)continue;\n\n\t\t\t\tbitset<20>bs(i);\n\t\t\t\tfor (int next = 0; next < N; ++next) {\n\t\t\t\t\tif (!bs[next]) {\n\t\t\t\t\t\tbs[next] = true;\n\n\t\t\t\t\t\tld next_time = abs(pos[next] - pos[now]) + memo[now][i];\n\t\t\t\t\t\tif (next_time + eps < abs(pos[next])) {\n\t\t\t\t\t\t\tmemo[next][bs.to_ulong()] = min(memo[next][bs.to_ulong()], next_time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbs[next] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (memo[i][(1 << N) - 1]<1e17)ok = true;\n\t\t}\n\t\tif (ok)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint n,hx,hy,dx,dy;\n\nfloat dist[21][21];\nstruct Crystal{\n    int x,y;\n    float dist;\n    bool visited;\n};\nCrystal crystals[21];//[0]????????????????????????????????????\n\nbool rec(int s,float t){\n    crystals[s].visited=true;\n    for(int i=0;i<n;i++){\n        if(crystals[i].visited) continue;\n        if(dist[i][s]+t<crystals[i].dist){\n            if(rec(i,dist[i][s]+t)){\n                return true;\n            }else{\n                continue;\n            }\n        }else{\n            //???????????????????????????????????£??????\n            crystals[s].visited=false;\n            return false;\n        }\n    }\n    //??¨???????????????????????????????????????\n    return true;\n}\n\nint main(void){\n    while(cin >> n >> crystals[0].x >> crystals[0].y >> dx >> dy,n){\n        for(int i=1;i<=n;i++){\n            cin >> crystals[i].x >> crystals[i].y;\n            crystals[i].dist=sqrt(pow(crystals[i].x-dx,2)+pow(crystals[i].y-dy,2));\n        }\n        sort(crystals+1,crystals+n+1,[](const Crystal& a, const Crystal& b){return (a.dist==b.dist)?(a.x<b.x):(a.dist)<(b.dist);});\n        for(int i=0;i<=n;i++){\n            crystals[i].visited=false;\n            for(int k=i+1;k<=n;k++){\n                dist[i][k]=dist[k][i]=sqrt(pow(crystals[i].x-crystals[k].x,2)+pow(crystals[i].y-crystals[k].y,2));\n            }\n        }\n        if(rec(0,0)){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define INF (1 << 16)\n#define REP(i, j) for(int i = 0; i < j; ++i)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define PB push_back\n#define P complex<double>\n#define Y real()\n#define X imag()\n\nclass C{\n  public:\n    int now;\n    double time;\n    vector<bool> visited;\n    C(int _n, double _t, vector<bool> _v){now  = _n; time = _t; visited = _v;}\n    bool operator>(const C &c) const {return time > c.time;}\n};\n\nbool isEnd(vector<bool> &visited, vector<double> &lim, double next_time, int n){\n  REP(i, n){\n    if(visited[i]) continue;\n    if(lim[i] <= next_time) return true;\n  }\n  return false;\n}\n\nint main() {\n  int n;\n  while(cin >>n && n != 0){\n    int hx, hy, dx, dy; cin >>hx >>hy >>dx >>dy;\n    P h(hy, hx), d(dy, dx);\n    vector<P> v;\n    REP(i, n){\n      int x, y; cin >>x >>y;\n      v.PB(P(y, x));\n    }\n    vector<double> lim(n);\n    //REP(i, n) lim[i] = (int)(ceil(abs(d - v[i])));\n    REP(i, n) lim[i] = abs(d - v[i]);\n    vector< vector<double> > dis(n + 1, vector<double>(n + 1));\n    REP(i, n) REP(j, n) dis[i][j] = abs(v[i] - v[j]);\n    REP(i, n){\n      dis[n][i] = abs(h - v[i]);\n      dis[i][n] = dis[n][i];\n    }\n\n    priority_queue<C, vector<C>, greater<C> > open;\n    open.push(C(n, 0.0, vector<bool>(n, false)));\n    vector< vector<double> > closed(n + 1, vector<double>(n, INF));\n    bool ok = false;\n\n    while(!open.empty()){\n      C now = open.top();\n      open.pop();\n      int tre = count(now.visited.begin(), now.visited.end(), true);\n\n      //debug\n      //cout <<\"---------------\" <<endl;\n      //cout <<now.now <<\", \" <<now.time <<endl;\n      //REP(i, n) cout <<now.visited[i] <<\", \";\n      //cout <<endl;\n\n      if(tre >= n){\n        ok  = true;\n        break;\n      }\n\n      if(now.now == n) ;\n      else if(closed[tre][now.now] <= now.time) continue;\n      else closed[tre][now.now] = now.time;\n\n      //debug\n      //cout <<\"ok\" <<endl;\n\n      REP(i, n){\n        if(now.visited[i]) continue;\n        double next_time = now.time + dis[i][now.now];\n\n        //debug\n        //cout <<\"next \" <<next_time <<endl;\n        //cout <<\"lim \" <<lim[i] <<endl;\n\n        if(isEnd(now.visited, lim, next_time, n)) continue;\n\n        now.visited[i] = true;\n        open.push(C(i, next_time, now.visited));\n        now.visited[i] = false;\n      }\n    }\n    cout <<(ok ? \"YES\" : \"NO\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX], ok;\nbool dp[1<<MAX][MAX];\n\nbool rec(int S, int v, double total_dist){\n  if(ok) return true;\n  if(total_dist >= dist(d, crystal[v])){\n    return false;\n  }\n\n  if(dp[S][v]) return true;\n\n  if(S == (1 << N) - 1){\n    return dp[S][v] = ok = true;\n  }\n  bool res = false;\n  for(int u = 0 ; u < N ; u++){\n    Segment s = Segment(crystal[v], crystal[u]);\n    if(s.distanceSP(d) < total_dist) return false;\n    if(total_dist+dist(crystal[v],crystal[u]) >= dist(d, crystal[v])){\n      return false;\n    }\n    if(!(S >> u & 1)){\n      return rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]));\n    }\n  }\n  return dp[S][v] = false;\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n\n  for(int i = 0 ; i < N ; i++){\n    ok = false;\n    memset(dp, false, sizeof(dp));\n    memset(used, false, sizeof(used));\n    if(rec(0, i, dist(h, crystal[i]))){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\ntypedef pair<double, int> R;\ntypedef pair<P, R> Q;\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy) {\n\t\tif (n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) {\n\t\t\tbreak;\n\t\t}\n\t\thx -= dx;\n\t\thy -= dy;\n\t\tvector<P> data;\n\t\tint x, y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\tdata.push_back(P(x, y));\n\t\t}\n\t\tqueue<Q> q;\n\t\tq.push(Q(P(hx, hy), R(0.0, 0)));\n\t\tbool hantei = false;\n\t\twhile (!q.empty()) {\n\t\t\tQ p = q.front();\n\t\t\tq.pop();\n\t\t\tP xy = p.first;\n\t\t\tR limit = p.second;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tbool hantei2 = true;\n\t\t\t\tif ((limit.second & (1<<i)) == 0) {\n\t\t\t\t\tdouble dead = limit.first+sqrt(pow(data[i].first-xy.first, 2)+pow(data[i].second-xy.second, 2));\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif ((limit.second & (1<<j)) == 0) {\n\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead) {\n\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\tint k = limit.second | (1<<i);\n\t\t\t\t\t\tif (k == (1<<n)-1) {\n\t\t\t\t\t\t\thantei = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int j = 0; j < 20; j++) {\n\t\t\t\t\t\t\tif ((k & (1<<j)) == 0) {\n\t\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead+sqrt(pow(data[i].first-data[j].first, 2)+pow(data[i].second-data[j].second, 2))) {\n\t\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\t\tq.push(Q(data[i], R(dead, k)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hantei) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <tr1/unordered_map.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n\nint N;\nint hx, hy, mx, my;\ntypedef pair<double, double> P;\nP cs[21];\n\n#define SQ(x) ((x)*(x))\ninline double dist(P a, P b) {\n  return sqrt(SQ(a.fi-b.fi) + SQ(a.se-b.se));\n}\n\nunordered_map<int, double> umap;\n\ndouble G[22][22];\nbool dfs(int S, int now, double cost) {\n  \n  if(S == (1<<N)-1) {\n    return true;\n  }\n  \n  umap[S] = cost;\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(G[i][N+1] <= cost+G[now][i]) return false;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(umap.count(S|(1<<i)) && umap[S|(1<<i)] <= cost+G[now][i]) continue;\n    if(dfs(S|(1<<i), i, cost+G[now][i])) return true;\n  }\n  \n  return false;\n}\n\nbool solve() {\n  \n  for(int i=0; i<N; i++) {\n    for(int j=i+1; j<N; j++) {\n      G[i][j] = G[j][i] = dist(cs[i], cs[j]);\n    }\n    G[N][i] = G[i][N] = dist(P(hx, hy), cs[i]);\n    G[N+1][i] = G[i][N+1] = dist(P(mx, my), cs[i]);\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(dfs(1<<i, i, 0.)) return true;\n  }\n  \n  return false;\n}\n\nint main() {\n  while(1) {\n    cin >> N >> hx >> hy >> mx >> my;\n    if(!N) break;\n    for(int i=0; i<N; i++) {\n      cin >> cs[i].fi >> cs[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint N;\nP H,D;\nP C[22];\n\nint getK(P a,P b){\n  return (a.F-b.F) * (a.F-b.F) +  (a.S-b.S) * (a.S-b.S);\n}\nint sum(int a,int b){\n  return a*b+2*sqrt(a)*sqrt(b);\n}\n\nbool solve(int id,int st,int ky){\n  if( st == (1<<N)-1 ){\n    return true;\n  }\n\n  for(int i=0;i<N;i++){\n    if( (1<<i) & st ) continue;\n    int sm = sum(ky,getK(C[id],C[i]));\n    int r = getK(D,C[i]);\n    if( sm < r ){\n      if( solve( i, st | (1<<i) , sm ) ) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >>N >> H.F >> H.S >> D.F >> D.S;\n    if( !N && !H.F && !H.S && !D.F && !D.S) break;\n    for(int i=0;i<N;i++) {\n      cin >> C[i].F >> C[i].S;\n    }\n    bool f=false;\n    for(int i=0;i<N;i++){\n      if( solve(i,(1<<i),getK(H,C[i])) ) f=true;\n      if( f ) break;\n    }\n    if( f )cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\n#define fi first\n#define se second\n\nint N;\nint hx, hy, mx, my;\ntypedef pair<double, double> P;\nP cs[21];\n\n#define SQ(x) ((x)*(x))\ninline double dist(P a, P b) {\n  return sqrt(SQ(a.fi-b.fi) + SQ(a.se-b.se));\n}\n\nunordered_map<int, double> umap;\n\ndouble G[22][22];\nbool dfs(int S, int now, double cost) {\n  \n  if(S == (1<<N)-1) {\n    return true;\n  }\n  \n  umap[S] = cost;\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(G[i][N+1] <= cost+G[now][i]) return false;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(umap.count(S|(1<<i)) && umap[S|(1<<i)] <= cost+G[now][i]) continue;\n    if(dfs(S|(1<<i), i, cost+G[now][i])) return true;\n  }\n  \n  return false;\n}\n\nbool solve() {\n  \n  for(int i=0; i<N; i++) {\n    for(int j=i+1; j<N; j++) {\n      G[i][j] = G[j][i] = dist(cs[i], cs[j]);\n    }\n    G[N][i] = G[i][N] = dist(P(hx, hy), cs[i]);\n    G[N+1][i] = G[i][N+1] = dist(P(mx, my), cs[i]);\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(dfs(1<<i, i, 0.)) return true;\n  }\n  \n  return false;\n}\n\nint main() {\n  while(1) {\n    cin >> N >> hx >> hy >> mx >> my;\n    if(!N) break;\n    for(int i=0; i<N; i++) {\n      cin >> cs[i].fi >> cs[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<math.h>\nusing namespace std;\n#define INF 10000000.0\n\nint n,hx,hy,dx,dy;\nint cx[20],cy[20];\ndouble dp[20][1<<20];\n\nint main()\n{\n\twhile(cin>>n>>hx>>hy>>dx>>dy && n!=0){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>cx[i]>>cy[i];\n\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int b=0;b<(1<<n);b++)\n\t\t\t\tdp[i][b]=INF;\n\n\t\tfor(int i=0;i<n;i++)\n\t\t\tdp[i][0]=0;\n\n\t\tfor(int bit=0;bit<(1<<n);bit++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble time=dp[i][bit];\n\t\t\t\tif(time>=INF) continue;\n\t\t\t\tint x=cx[i],y=cy[i];\n\t\t\t\tif(bit==0){x=0;y=0;}\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(bit & (1<<k)) continue;\n\t\t\t\t\ttime+=sqrt((double)(x-cx[k])*(x-cx[k])+(y-cy[k])*(y-cy[k]));\n\t\t\t\t\tif(time>=sqrt((double)(dx-cx[k])*(dx-cx[k])+(dy-cy[k])*(dy-cy[k]))) continue;\n\t\t\t\t\tdp[k][bit | (1<<k)]=min(dp[k][bit | (1<<k)],time);\n//\t\t\t\t\tcout<<dp[k][bit | (1<<k)]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int i=0;i<n;i++){\n//\t\t\tcout<<\"a \"<<dp[i][(1<<n)-1]<<endl;\n\t\t\tif(dp[i][(1<<n)-1]<INF)\n\t\t\t\tok=true;\n\t\t}\n\t\tif(ok) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nconst double inf = 1e4;\n\nint n;\nint x[22];\nint y[22];\ndouble d[22][22];\ndouble dp[1 << 20][20];\n\ndouble dfs(int s, int t){\n\tif(dp[s][t] != -1){\n\t\treturn dp[s][t];\n\t}\n\tint u = s - (1 << t);\n\tif(u == 0){\n\t\treturn dp[s][t] = d[n][t] < d[n + 1][t] ? d[n][t] : inf;\n\t}\n\tdouble p = inf;\n\trep(i, n){\n\t\tif(u & (1 << i)){\n\t\t\tdouble q = dfs(u, i) + d[i][t];\n\t\t\tif(q < d[n + 1][t]){\n\t\t\t\tp = min(q, p);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s][t] = p;\n}\n\nvoid init(){\n\trep(i, n + 2){\n\t\trep(j, n + 2){\n\t\t\tdouble dx = x[i] - x[j];\n\t\t\tdouble dy = y[i] - y[j];\n\t\t\td[i][j] = sqrt(dx * dx + dy * dy);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\trep(i, 2){\n\t\t\tscanf(\"%d%d\", x + n + i, y + n + i);\n\t\t}\n\t\trep(i, n){\n\t\t\tscanf(\"%d%d\", x + i, y + i);\n\t\t}\n\t\tinit();\n\t\trep(i, 1 << n){\n\t\t\tfill_n(dp[i], n, -1);\n\t\t}\n\t\tbool ans = false;\n\t\trep(i, n){\n\t\t\tif(dfs((1 << n) - 1, i) != inf){\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", ans ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\nint n;\ndouble dis[32][32];\nbool dfs(int unvisit, int cur, double time)\n{\n\tif (unvisit == 0)\n\t\treturn true;\n\n\tfor (int i = 0; i < n; ++i)\n\t\tif (unvisit >> i & 1 && time  > dis[n + 1][i])\n\t\t\treturn false;\n\n\tfor (int i = 0; i < n; ++i)\n\t\tif (unvisit >> i & 1 && time + dis[cur][i] < dis[n + 1][i])\n\t\t\tif (dfs(unvisit ^ 1 << i, i, time + dis[cur][i]))\n\t\t\t\treturn true;\n\n\treturn false;\n}\nint main()\n{\n\tint  hx, hy, dx, dy;\n\twhile (scanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy), n)\n\t{\n\t\tint  x[32], y[32];\n\t\trep (i, n)\n\t\t\tscanf(\"%d%d\", x + i, y + i);\n\t\tx[n] = hx, y[n] = hy;\n\t\tx[n + 1] = dx, y[n + 1] = dy;\n\n\t\tfor (int i = 0; i <= n + 1; ++i)\n\t\t\tfor (int j = 0; j <= n + 1; ++j)\n\t\t\t\tdis[i][j] = hypot(x[i] - x[j], y[i] - y[j]);\n\n\t\tputs(dfs((1 << n) - 1, n, 0) ? \"YES\" : \"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< double , Pi > Pii;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 55;\n\ndouble dp[1 << 20];\nint main(){\n  int n, hx, hy, dx, dy;\n  vector< char > near(1 << 20);\n\n  for(int i = 0; i < 1 << 20; i++){\n    for(int k = 0; k < 20; k++){\n      if((i >> k) & 1) continue;\n      near[i] = k;\n      break;\n    }\n  }\n  while(cin >> n >> hx >> hy >> dx >> dy, n|hx|hy|dx|dy){\n\n    vector< Pii > c(n);\n    for(int i = 0; i < n; i++){\n      cin >> c[i].sc.fr >> c[i].sc.sc;\n      c[i].fr = sqrt( pow( dx - c[i].sc.fr, 2) + pow( dy - c[i].sc.sc, 2));\n    }\n    sort( ALL(c));\n\n    fill_n( dp, 1 << 20, 1e9);\n    for(int i = 0; i < n; i++){\n      double dist = sqrt(pow(hx - c[i].sc.fr, 2) + pow(hy - c[i].sc.sc, 2));\n      if(dist < sqrt(pow(dx - c[i].sc.fr, 2) + pow(dy - c[i].sc.sc, 2))){\n        dp[1 << i] = dist;\n      }\n    }\n\n    for(int i = 0; i < (1 << n) - 1; i++){\n      if(dp[i] == 1e9 || sqrt( pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) <= dp[i]) continue;\n      for(int j = 0; j < n; j++){\n        if(!((i >> j) & 1)) continue;\n        for(int k = 0; k < n; k++){\n          if((i >> k) & 1) continue;\n          double next = dp[i] + sqrt(pow( c[j].sc.fr - c[k].sc.fr, 2) + pow( c[j].sc.sc - c[k].sc.sc, 2));\n          if(next >= dp[i|(1 << k)]) continue;\n          bool check = sqrt(pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) > next;\n          if(check) dp[i|(1 << k)] = next;\n        }\n      }\n    }\n\n    bool check = n == 0;\n    check |= dp[(1 << n) - 1] < 1e9;\n    if(check) cout << \"YES\" << endl;\n    else cout <<\"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#define sd(i)hypot(sx-x[i],sy-y[i])\n#define md(i)hypot(mx-x[i],my-y[i])\nusing namespace std;\nint n;\nint x[20],y[20];\nint sx,sy,mx,my;\ndouble dp[20][1<<20];\nmain()\n{\n\twhile(cin>>n>>sx>>sy>>mx>>my,n)\n\t{\n\t\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n\t\tfor(int i=0;i<1<<n;i++)for(int j=0;j<n;j++)dp[i][j]=1e9;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tdouble a=sd(i);\n\t\t\tdouble b=md(i);\n\t\t\tif(a<b)dp[1<<i][i]=a;\n\t\t}\n\t\tfor(int i=0;i<1<<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][j]==1e9)continue;\n\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(i&(1<<k))continue;\n\t\t\t\t\tdouble d=hypot(x[j]-x[k],y[j]-y[k])+dp[i][j];\n\t\t\t\t\tdouble b=md(k);\n\t\t\t\t\tif(d<b)dp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=0;\n\t\tfor(int i=0;i<n;i++)f|=dp[(1<<n)-1][i]<1e9;\n\t\tcout<<(f?\"YES\":\"NO\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX], ok;\nbool dp[1<<MAX][MAX];\n\nbool rec(int S, int v, double total_dist){\n  if(ok) return true;\n  if(total_dist >= dist(d, crystal[v])){\n    return false;\n  }\n\n  if(dp[S][v]) return true;\n  if(S == (1 << N) - 1){\n    ok = true;\n    return dp[S][v] = true;\n  }\n  bool res = false;\n  for(int u = 0 ; u < N ; u++){\n    Segment s = Segment(crystal[v], crystal[u]);\n    if(s.distanceSP(d) < total_dist) return false;\n    if(!(S >> u & 1)){\n      res = rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]));\n    }\n  }\n  return dp[S][v] = res;\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n  for(int i = 0 ; i < N ; i++){\n    ok = false;\n    memset(dp, false, sizeof(dp));\n    memset(used, false, sizeof(used));\n    if(rec(0, i, dist(h, crystal[i]))){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n \nstruct Point{\n    double x, y;\n}; \n \nint N;\nPoint h, d, crystal[MAX];\n  \ndouble dist(Point a, Point b){\n    return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n \nbool rec(int S, int v, double total_dist){\n    if(S == (1 << N) - 1){\n\treturn true;\n    }\n    for(int u = 0 ; u < N ; u++){\n\tif(!(S >> u & 1)){\n\t    if(total_dist + dist(crystal[v],crystal[u]) >= dist(d, crystal[u])){\n\t\treturn false;\n\t    }\n\t}\n    }\n    for(int u = 0 ; u < N ; u++){\n\tif(!(S >> u & 1)){\n\t    if(rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]))){\n\t\treturn true;\n\t    }\n\t}\n    }\n}\n \nbool solve(){\n    for(int i = 0 ; i < N ; i++){\n\tif(rec(0,i,dist(h,crystal[i]))){\n\t    return true;\n\t}\n    }  \n    return false;\n}\n  \nint main(){\n    while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> crystal[i].x >> crystal[i].y;\n\t}\n\tcout << (solve() ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nint n,sx,sy,mx,my;\nint xi[22],yi[22];\nbool used[22];\nconst double eps = 1e-8;\n\nbool solve(int a,double t,double x,double y)\n{\n  //printf(\"%d %f %f %f\\n\",a,t,x,y);\n  if( a == n ) return true;\n  for(int i = 0; i < n; i++) {\n    if( hypot(xi[i]-mx,yi[i]-my) < t+hypot(x-xi[i],y-yi[i])+eps ) return false;\n  }\n  for(int i = 0; i < n; i++) {\n    if(!used[i]) {\n      used[i]=true;\n      if(solve(a+1,t+hypot(x-xi[i],y-yi[i]),xi[i],yi[i]))return true;\n      used[i]=false;\n    }\n  }\n  return false;\n}\n\nint main(void)\n{\n  for(;;) {\n    scanf(\"%d%d%d%d%d\",&n,&sx,&sy,&mx,&my); if(!n)break;\n    for(int i = 0; i < n; i++) {\n      used[i] = false;\n      scanf(\"%d%d\",xi+i,yi+i);\n    }\n    bool res = solve(0,0,sx,sy);\n    puts(res ? \"YES\" : \"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\ndouble dist(int x1, int y1, int x2, int y2)\n{\n\tint x = x1 - x2, y = y1 - y2;\n\treturn sqrt(0.0 + x*x + y*y);\n}\nint main()\n{\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n)\n\t{\n\t\tint x[32], y[32];\n\t\trep (i, n)\n\t\t\tcin >> x[i] >> y[i];\n\t\tx[n] = hx, y[n] = hy;\n\t\tx[n + 1] = dx, y[n + 1] = dy;\n\t\tdouble dis[32][32];\n\t\tfor (int i = 0; i <= n + 1; ++i)\n\t\t\tfor (int j = 0; j <= n + 1; ++j)\n\t\t\t\tdis[i][j] = dist(x[i], y[i], x[j], y[j]);\n\n\n\t\tstatic double dp[1 << 20][20];\n\t\tconst double INF = 1e9;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tdp[i][j] = INF;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\t//if (dis[n][i] < dis[n + 1][i])\n\t\t\t\tdp[1 << i][i] = dis[n][i];\n\n\t\tfor (int s = 0; s < 1 << n; ++s)\n\t\t{\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tif (!(s >> i & 1))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (!(s >> j & 1))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tmin_swap(dp[s][i], dp[s ^ 1 << i][j] + dis[j][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (dp[(1 << n) - 1][i] + 1e-9 < dis[n + 1][i])\n\t\t\t\tres = true;\n\t\tcout << (res ? \"YES\" : \"NO\") << endl;\n\t\t//cout.precision(9);\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//\tcout << dp[(1 << n) - 1][i] << \" / \" << dis[n + 1][i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\ninline double sq(double a) { return a*a; }\n#define INF (1e100)\n#define EPS (1e-9)\n\nint n;\ndouble hx, hy, mx, my, xs[32], ys[32], ds[32], ws[32][32];\npair<double, int> ns[32];\nmap<pair<int, int>, double> mem;\n\nbool rec(int b, int at, double t) {\n    if (b == (1<<n)-1) return true;\n    if (mem.count(mp(b, at)) && mem[mp(b, at)] < t) return false;\n    mem[mp(b, at)] = t;\n    rep (i, n) {\n        const int ix = ns[i].second;\n        if (b&(1<<ix)) continue;\n        double nt = t + ws[at][ix];\n        if (nt > ds[ix]-EPS) return false;\n        if (rec(b|(1<<ix), ix, nt)) return true;\n    }\n    return false;\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%lf%lf%lf%lf\", &n, &hx, &hy, &mx, &my);\n        if (n == 0) return 0;\n        rep (i, n) scanf(\"%lf%lf\", xs+i, ys+i);\n        rep (i, n) ds[i] = sqrt(sq(xs[i]-mx) + sq(ys[i]-my));\n        rep (i, n) ns[i] = mp(ds[i], i);\n        sort(ns, ns+n);\n        rep (i, n) rep (j, n) {\n            ws[i][j] = sqrt(sq(xs[i]-xs[j]) + sq(ys[i]-ys[j]));\n        }\n        mem.clear();\n        bool ans = false;\n        rep (i, n) {\n            double t = sqrt(sq(xs[i]-hx) + sq(ys[i]-hy));\n            if (t < ds[i]-EPS && rec(1<<i, i, t)) { ans = true; break; }\n        }\n        puts(ans ? \"YES\" : \"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nint n;\nint hx, hy, dx, dy;\nint cx[20], cy[20];\ndouble dist[20][20];\ndouble limit[20];\n\nbool dfs(int pos, int visited, double sum) {\n\tfor(int i = 0; i < n; ++i)\n\t\tif(!(visited & (1 << i)) && sum >= limit[i])\n\t\t\treturn false;\n\n\tif(visited == (1 << n) - 1)\n\t\treturn true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(visited & (1 << i))\n\t\t\tcontinue;\n\n\t\tconst double d = dist[pos][i];\n\t\tif(sum + d < limit[i] && dfs(i, visited | (1 << i), sum + d))\n\t\t   return true;\t\t\t\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tconst int INF = 0xfffffff;\n\n\twhile(cin >> n >> hx >> hy >> dx >> dy, n) {\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tcin >> cx[i] >> cy[i];\n\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = i + 1; j < n; ++j)\n\t\t\t\tdist[i][j] = dist[j][i] = hypot(cx[i] - cx[j], cy[i] - cy[j]);\n\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tlimit[i] = hypot(cx[i] - dx, cy[i] - dy);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tconst double d = hypot(cx[i] - hx, cy[i] - hy);\n\t\t\tif(d < limit[i] && dfs(i, (1 << i), d)) {\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\n\t\tcout << \"NO\" << endl;\n\tnext:;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef complex<double> P;\n\nP syoki, maou;\nP houseki[20];\nint n;\nvector<bool> v;\n\nbool rec(int now, double time) {\n  // REP(i,n) {\n  //   cout << v[i];\n  // }cout << endl;\n  // printf(\"now=%d, time=%f\\n\",now,time);\n  bool ff = 0;\n  REP(i,n) {\n    if (!v[i]) {\n//      cout << i << \" \" << abs(maou-houseki[i]) << \", \" << time+abs(houseki[i]-houseki[now]) << endl;\n      if (abs(maou-houseki[i]) <= time+abs(houseki[i]-houseki[now])) {\n        return false;\n      }\n      ff = 1;\n    }\n  }\n  if (!ff) {                    // ツ全ツ閉板づづつス\n    return true;\n  }\n\n  REP(i,n) {\n    if (!v[i]) {\n      v[i] = 1;\n      if (rec(i, time+abs(houseki[i]-houseki[now])))\n        return true;\n      v[i] = 0;\n      ff = 1;\n    }\n  }\n}\n\nint main() {\n  int hx,hy,dx,dy;\n  while(cin>>n>>hx>>hy>>dx>>dy,n||hx||hy||dx||dy) {\n    syoki = P(hx,hy);\n    maou = P(dx,dy);\n    REP(i,n) {\n      double x,y;\n      cin >> x >> y;\n      houseki[i] = P(x,y);\n    }\n    v = vector<bool>(n);\n    bool f = 0;\n    REP(i,n) {\n      v[i] = 1;\n      if (rec(i, abs(houseki[i]-syoki))) {\n        f = 1;\n        break;\n      }\n      v[i] = 0;\n    }\n    if (f)\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n \nusing namespace std;\n \n#define MAX 20\n#define EPS 1e-10\ntypedef pair<double,double> P;\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n \nbool solve(){\n  sort(crystal, crystal+N);\n\n  double total_dist = 0;\n  for(int i = 0 ; i < N ; i++){\n    Point tmp;\n    double min_dist = 10000000;\n    int num;\n    for(int j = i ; j < N ; j++){\n      if(dist(h, crystal[j]) < min_dist){\n        min_dist = dist(h, crystal[i]);\n        num = j;\n      } \n      tmp = crystal[i];\n      crystal[i] = crystal[num];\n      crystal[num] = tmp;\n    }\n    Segment s = Segment(h, crystal[i]);\n    if(s.distanceSP(d) <= 1) return false;\n    total_dist += dist(h, crystal[i]);\n    if(total_dist >= dist(d, crystal[i])){\n      return false;\n    }\n    h = crystal[i];\n  }\n\n  return true;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-9;\n\ntypedef pair<xy_t, bool> dat;\n\nnamespace std{\n\tbool operator < (const xy_t &a, const xy_t &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nint n, hx, hy, dx, dy;\nxy_t points[21];\ndouble dis[1 << 21];\n\nbool dfs(double t, int v, int st){\n\tif(st == (1 << (n + 1)) - 1) return true;\n\tif(dis[st] < t) return false;\n\tbool res = false;\n\tfor(int i = 1; i < n + 1; i++){\n\t\tif(!(st & (1 << i))){\n\t\t\tdouble nt = t + abs(points[i] - points[v]);\n\t\t\tif(nt < abs(points[i] - xy_t(dx, dy))) res |= dfs(nt, i, st | (1 << i));\n\t\t}\n\t\tif(res) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> n >> hx >> hy >> dx >> dy && (n || hx || hy || dx || dy)){\n\t\t\n\t\tpoints[0] = xy_t(hx, hy);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints[i] = xy_t(x, y);\n\t\t}\n\t\tfor(int i = 1; i < (1 << n + 1); i++){\n\t\t\tdouble d = 1e10;\n\t\t\tfor(int j = 0; j < n + 1; j++){\n\t\t\t\tif(!(i & (1 << j))) d = min(d, abs(points[j] - xy_t(dx, dy)));\n\t\t\t}\n\t\t\tdis[i] = d;\n\t\t}\n\t\tif(dfs(0.0, 0, 1)) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// ????????????????????????±?????????±???\n \nint n;\nint x[30], y[30];\n \ndouble dist(int a, int b){\n    return sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));\n}\n \nbool solve(){\n    for(int i=0;i<n;i++){\n        if(dist(n, 0) + dist(0, i) >= dist(n+1, i)) return false;\n    }\n    return true;\n}\n \nint main(){\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        cin >> x[n] >> y[n] >> x[n+1] >> y[n+1];\n        for(int i=0;i<n;i++){\n            cin >> x[i] >> y[i];\n        }\n \n        if(solve()) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-10;\n\nint N;\nP D;\nvector<P> ps;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, int p) {\n  double dist = abs(D - ps[p]);\n  return !(equals(dist, t) || dist < t);\n}\n\nbool rec(int state, double t, int p) {\n  if(state == (1<<N)-1) return true;\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    if(!canExist(t+abs(ps[i] - ps[p]), i)) return false;\n  }\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    double nt = t + abs(ps[i] - ps[p]);\n    if(rec(state|(1<<i), nt, i)) return true;\n  }\n  return false;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy\n\t&&(N|hx|hy|dx|dy) ) {\n    D = P(dx, dy);\n    ps.resize(N+1);\n    ps[N-1] = P(hx, hy);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(rec(0, 0.0, N)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble  cost[20][20];\nconst double INF = 10000000;\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n  }\n  if ( now == n)return true;\n  \n  //\n  visited[last]=false;\n  rep(i,n){\n    if (visited[i]==true)cost[i][i]=INF;\n    else cost[i][i]=0;\n    cost[i][i]=0;\n    REP(j,i+1,n){\n      if (visited[i]==true ||visited[j]==true)cost[i][j]=cost[j][i]=INF;\n      else cost[i][j]=cost[j][i]=adj[i][j];\n    }\n  }\n  visited[last]=true;\n  rep(k,n)rep(i,n)rep(j,n)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n  rep(i,n)if( visited[i]==false && r+cost[last][i] >=adj[MAOU][i])return false;\n\n  //\n\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    if ( r+adj[last][i] < adj[MAOU][i]){\n      visited[i]=true;\n      if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n  }\n  \n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i])+eps>dist(rx-x[i],ry-y[i]))return false;\n  }\n\n\n  bool visited[20]={false};\n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i]) < dist(rx-x[i],ry-y[i])){\n      visited[i]=true;\n      if ( backTrack(i,dist(mx-x[i],my-y[i]),1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(cin>>n>>mx>>my>>rx>>ry && n){\n    int x[n],y[n];\n    rep(i,n)cin>>x[i]>>y[i];\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX], ok;\n\nvoid rec(int S, int v, double total_dist){\n  if(ok) return;\n\n  if(S == (1 << N) - 1){\n    ok = true;\n    return;\n  }\n  for(int u = 0 ; u < N ; u++){\n    Segment s = Segment(crystal[v], crystal[u]);\n    if(s.distanceSP(d) < total_dist) return;\n    if(total_dist+dist(crystal[v],crystal[u]) >= dist(d, crystal[u])){\n      return;\n    }\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1)){\n      rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]));\n    }\n  }\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n\n  for(int i = 0 ; i < N ; i++){\n    ok = false;\n    memset(used, false, sizeof(used));\n    rec(0, i, dist(h, crystal[i]));\n    if(ok){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 20;\nconst float inf = 1000000000.0f;\nconst double eps = 1e-5;\n\nint N;\nP H, D;\nvector<P> ps;\nfloat dp[1<<MAXN][MAXN+1];\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, P p) {\n  double d = abs(D - p);\n  return !equals(d, t) && d > t;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy && \n\t( N | hx | hy | dx | dy ) ) {\n    H = P(hx,hy);\n    D = P(dx,dy);\n    ps.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    fill(dp[0], dp[1<<MAXN], inf);\n    dp[0][N] = 0;\n    for(int i = 0; i < (1<<N); ++i) {\n      for(int j = 0; j <= N; ++j) {\n\tif(dp[i][j] == inf) continue;\n\tfor(int k = 0; k < N; ++k) {\n\t  if(i & (1<<k)) continue;\n\t  P s = (j == N) ? H : ps[j];\n\t  P &t = ps[k];\n\t  double dist = abs(t - s);\n\t  double nt = dp[i][j] + dist;\n\t  if(!canExist(nt, t)) continue;\n\t  dp[i|(1<<k)][k] = min((double)dp[i|(1<<k)][k], nt);\n\t}\n      }\n    }\n    string res = \"NO\";\n    for(int i = 0; i < N; ++i) {\n      if(dp[(1<<N)-1][i] != inf) {\n\tres = \"YES\";\n\tbreak;\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <tr1/unordered_map>\n\n#define fi first\n#define se second\n\nint N;\nint hx, hy, mx, my;\ntypedef pair<double, double> P;\nP cs[21];\n\n#define SQ(x) ((x)*(x))\ninline double dist(P a, P b) {\n  return sqrt(SQ(a.fi-b.fi) + SQ(a.se-b.se));\n}\n\nunordered_map<int, double> umap;\n\ndouble G[22][22];\nbool dfs(int S, int now, double cost) {\n  \n  if(S == (1<<N)-1) {\n    return true;\n  }\n  \n  dp[S] = cost;\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(G[i][N+1] <= cost+G[now][i]) return false;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(dp.count(S|(1<<i)) && dp[S|(1<<i)] <= cost+G[now][i]) continue;\n    if(dfs(S|(1<<i), i, cost+G[now][i]) return true;\n  }\n  \n  return false;\n}\n\nbool solve() {\n  \n  for(int i=0; i<N; i++) {\n    for(int j=i+1; j<N; j++) {\n      G[i][j] = G[j][i] = dist(cs[i], cs[j]);\n    }\n    G[N][i] = G[i][N] = dist(P(hx, hy), cs[i]);\n    G[N+1][i] = G[i][N+1] = dist(P(mx, my), cs[i]);\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(dfs(1<<i, i, 0.)) return true;\n  }\n  \n  return false;\n}\n\nint main() {\n  while(1) {\n    cin >> N >> hx >> hy >> mx >> my;\n    if(!N) break;\n    for(int i=0; i<N; i++) {\n      cin >> cs[i].fi >> cs[i].se << endl;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nint n;\ndouble x[22];\ndouble y[22];\ndouble d[22][22];\n\nbool dfs(int k, int x, double c){\n\tif(x == (1 << n) - 1){\n\t\treturn true;\n\t}\n\trep(i, n){\n\t\tif(\n\t\t\t!(x & (1 << i)) &&\n\t\t\tc + d[k][i] >= d[i][n + 1]\n\t\t){\n\t\t\treturn false;\n\t\t}\n\t}\n\trep(i, n){\n\t\tif(\n\t\t\t!(x & (1 << i)) &&\n\t\t\tdfs(i, x | (1 << i), c + d[k][i])\n\t\t){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%lf%lf%lf%lf\", x + n, y + n,  x + n + 1, y + n + 1);\n\t\trep(i, n){\n\t\t\tscanf(\"%lf%lf\", x + i, y + i);\n\t\t}\n\t\trep(i, n + 2){\n\t\t\trep(j, n + 2){\n\t\t\t\tdouble dx = x[i] - x[j];\n\t\t\t\tdouble dy = y[i] - y[j];\n\t\t\t\td[i][j] = sqrt(dx * dx + dy * dy);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", dfs(n, 0, 0) ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define MAXNUM 25\n\nstruct status{\n\tdouble d;\n\tint c;\n};\n\ndouble dist(double x1,double y1,double x2,double y2){\n\tdouble ret = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n\treturn ret;\n}\n\nint main(void){\n\tint i, j, n;\n\tdouble hx, hy, dx, dy, cx[MAXNUM],cy[MAXNUM];\n\tstruct status dp[1 << MAXNUM];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tscanf(\"%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0.0 && hy == 0.0 && dx == 0.0 && dy == 0.0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < 1 << MAXNUM;i++)\n\t\t\tdp[i].d = -1;\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tdp[1 << i].d = dist(hx,hy,cx[i],cy[i]);\n\t\t\tdp[1 << i].c = i;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i].d != -1){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & (1 << j) && ((dp[i | (1 << j)].d == -1) || (dp[i | (1 << j)].d > dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j])))){\n\t\t\t\t\t\tdp[i | (1 << j)].d = dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]);\n\t\t\t\t\t\tdp[i | (1 << j)].c = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist(dx,dy,cx[dp[(1 << n) - 1].c],cy[dp[(1 << n) - 1].c]) > dp[(1 << n) - 1].d)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\nconst int INF=100000000;\n\n\nint n;\nint hx,hy;\nint dx,dy;\nint cx[21],cy[21];\n\n\ndouble dist(int _x0,int _y0,int _x1,int _y1) {\n\tdouble d = (_x0-_x1)*(_x0-_x1) + (_y0-_y1)*(_y0-_y1);\n\treturn sqrt(d);\n}\n\nint pow2(int a) {\n\treturn a*a;\n}\n\n//&#131;N&#131;&#138;&#131;X&#131;^&#131;&#139;&#130;&#204;&#136;&#202;&#146;u&#130;&#198;&#137;&#189;&#147;&#250;&#150;&#218;&#130;&#169;&#130;&#231;&#130;&#198;&#130;&#233;&#130;賊&#130;&#198;&#130;&#170;&#130;&#197;&#130;&#171;&#130;&#233;&#130;&#169;\nbool check(int x,int y,int d) {\n\treturn (pow2(dx-x)+pow2(dy-y)) > pow2(d);\n}\n\n//&#140;&#187;&#141;&#221;&#136;&#202;&#146;u,&#137;&#189;&#147;&#250;&#150;&#218;,&#143;W&#141;&#135;\nbool dfs(int x,int y,int d,int S) {\n    //printf(\"[debug] %d,%d,%d,%d\\n\",x,y,d,S);\n\tif(S==(1<<n)-1) return true;\n\trep(i,n) {\n\t\tif(!((S>>i)&1)) {\n\t\t\td += (int)dist(x,y,cx[i],cy[i]) + 1;\n\t\t\tif(check(cx[i],cy[i],d)) {\n\t\t\t\treturn dfs(cx[i],cy[i],d,S|(1<<i));\n\t\t\t}\n            else {\n                return false;\n            }\n\t\t}\n\t}\n\n\treturn false;\n\n}\n\n\nvoid solve() {\n\trep(i,n) cin>>cx[i]>>cy[i];\n\tif(dfs(hx,hy,0,0)) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\n}\n\nint main() {\n\twhile (cin>>n>>hx>>hy>>dx>>dy)\n\t{\n\t\tif(n+hx+hy+dx+dy==0) return 0;\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n// Area of Polygon //\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\n// Totsuhou! Andrew's Monotone Chain //\n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n \n \nP getPedal(L l, P p){\n\tdouble A;\n\tif(abs(l[1].real()-l[0].real()) < EPS){\n\t\treturn P(l[1].real(),p.imag()); // important\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A , b = 1 , c = A*l[0].real() - l[0].imag();\n\tdouble t = (a*p.real() + b*p.imag() + c)/(a*a+b*b);\n\treturn p-t * P(a,b);\n}\n\n  \nvector<P> crosspointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS)return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nP getCircumcenter(P a,P b,P c){\n\tdouble A1 = 2 * ( b.real() - a.real() );\n\tdouble B1 = 2 * ( b.imag() - a.imag() );\n\tdouble C1 = pow(a.real(),2)-pow(b.real(),2) + pow(a.imag(),2)-pow(b.imag(),2);\n\tdouble A2 = 2 * ( c.real() - a.real() );\n\tdouble B2 = 2 * ( c.imag() - a.imag() );\n\tdouble C2 = pow(a.real(),2)-pow(c.real(),2) + pow(a.imag(),2)-pow(c.imag(),2);\n\tdouble X = (B1 * C2 - B2 * C1) / (A1 * B2 - A2 * B1);\n\tdouble Y = (C1 * A2 - C2 * A1) / (A1 * B2 - A2 * B1);\n\treturn P(X,Y);\n}\n \ndouble AreaOfPolygon(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*　多角形の面積公式 (反時計回りの場合) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\n\nint N;\ndouble dist[21][21];\ndouble fast[21][21];\n\nP h,d,p[20];\n\n\nbool dfs(int n,int bit,double cur){\n\tif( bit == (1<<N)-1 ) return true;\n\n\tfor(int i = 0 ; i < N ; i++){\n\t\tif( !(bit >> i & 1) ){\n\t\t\tif( cur > abs(d-p[i]) - EPS) return false;\n\t\t}\n\t}\n\tvector< pair<double,int> > S;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tS.push_back( make_pair(  abs(p[n]-p[i]) , i ) );\n\t}\n\tsort(S.begin(),S.end());\n\tfor(int I = 0 ; I < N ; I++){\n\t\tint i = S[I].second;\n\t\tif( !(bit >> i & 1) ){\n\t\t\tdouble lim = dist[n][i] - cur;\n\t\t\tif( fast[n][i] > lim - EPS ) continue;\n\t\t\tdouble nextTime = cur + abs(p[n]-p[i]);\n\t\t\tif( abs(d-p[i]) - EPS < nextTime ) continue;\n\t\t\tif( dfs(i,bit|(1<<i),nextTime) ) return true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tN = n;\n\t\tcin >> h.real() >> h.imag();\n\t\tcin >> d.real() >> d.imag();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> p[i].real() >> p[i].imag();\t\n\t\t}\n\t\tfor(int i = 0 ; i <= n ; i++){\n\t\t\tfor(int j = 0 ; j <= n ; j++){\n\t\t\t\tif( i == j ) continue;\n\t\t\t\tP a = (i==n?h:p[i]);\n\t\t\t\tP b = (j==n?h:p[j]);\n\t\t\t\tdist[i][j] = distanceSP(L(a,b),d);\n\t\t\t\tfast[i][j] = intersectSP(L(a,b),getPedal(L(a,b),d)) ? abs(a-getPedal(L(a,b),d)) : 1e10;\n\t\t\t}\n\t\t}\n\t\tcout << (dfs(n,0,0)?\"YES\":\"NO\") << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n//const int INF = INT_MAX/10;\nconst double INF = 1.7e+308/10;\n\n#define LT(x,y) ((x)-(y)<EPS)\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<double> vd;\n\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile(cin >> n >> hx >> hy >> dx >> dy, n) {\n\t\tP h(hx, hy), d(dx, dy);\n\t\tvector<P> c(n);\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tc[i] = P(x, y);\n\t\t}\n\n\t\tvector<vd> dist(n, vd(n, INF));\n\t\tREP(i, n) {\n\t\t\tFOR(j, i+1, n-1) {\n\t\t\t\tdist[i][j] = dist[j][i] = abs(c[i]-c[j]);\n\t\t\t}\n\t\t}\n\t\tvd sdist(n);\n\t\tREP(i, n) {\n\t\t\tsdist[i] = abs(c[i]-h);\t\n\t\t}\n\n\t\tvector<vd> dp(1<<n, vd(n, INF));\n\t\tREP(i, n) {\n\t\t\tif(i == 0) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tdp[1<<j][j] = sdist[j];\n\t\t\t\t\tif(LT(abs(d-c[j]), dp[1<<j][j])) {\n\t\t\t\t\t\tdp[1<<j][j] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tif(!(i&(1<<j))) {\n\t\t\t\t\t\tREP(k, n) {\n\t\t\t\t\t\t\tdp[i|(1<<j)][j] = min(dp[i|(1<<j)][j], dp[i][k]+dist[k][j]);\n\t\t\t\t\t\t\tif(LT(abs(d-c[j]), dp[i|(1<<j)][j])) {\n\t\t\t\t\t\t\t\tdp[i|(1<<j)][j] = INF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok = false;\n\t\tREP(i, n) {\n\t\t\tif(dp[(1<<n)-1][i] != INF) {\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcout << (ok ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\nusing namespace std;\n#define INF 10000000.0\n\nint n,hx,hy,dx,dy;\nint cx[20],cy[20];\ndouble dp[20][1<<20];\n\nint main()\n{\n\twhile(cin>>n>>hx>>hy>>dx>>dy && n!=0){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>cx[i]>>cy[i];\n\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int b=0;b<(1<<n);b++)\n\t\t\t\tdp[i][b]=INF;\n\n\t\tfor(int i=0;i<n;i++)\n\t\t\tdp[i][0]=0;\n\n\t\tfor(int bit=0;bit<(1<<n);bit++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble time=dp[i][bit];\n\t\t\t\tif(time>=INF) continue;\n\t\t\t\tint x=cx[i],y=cy[i];\n\t\t\t\tif(bit==0){x=0;y=0;}\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(bit & (1<<k)) continue;\n\t\t\t\t\ttime+=sqrt((double)(x-cx[k])*(x-cx[k])+(y-cy[k])*(y-cy[k]));\n\t\t\t\t\tif(time>=sqrt((double)(dx-cx[k])*(dx-cx[k])+(dy-cy[k])*(dy-cy[k]))) continue;\n\t\t\t\t\tdp[k][bit | (1<<k)]=min(dp[k][bit | (1<<k)],time);\n//\t\t\t\t\tcout<<dp[k][bit | (1<<k)]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int i=0;i<n;i++){\n//\t\t\tcout<<\"a \"<<dp[i][(1<<n)-1]<<endl;\n\t\t\tif(dp[i][(1<<n)-1]<INF)\n\t\t\t\tok=true;\n\t\t}\n\t\tif(ok) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<double, int> R;\ntypedef pair<P, R> Q;\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy) {\n\t\tif (n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) {\n\t\t\tbreak;\n\t\t}\n\t\thx -= dx;\n\t\thy -= dy;\n\t\tvector<P> data;\n\t\tint x, y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\tdata.push_back(P(x, y));\n\t\t}\n\t\tqueue<Q> q;\n\t\tq.push(Q(P(hx, hy), R(0.0, 0)));\n\t\tbool hantei = false;\n\t\twhile (!q.empty()) {\n\t\t\tQ p = q.front();\n\t\t\tq.pop();\n\t\t\tP xy = p.first;\n\t\t\tR limit = p.second;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tbool hantei2 = true;\n\t\t\t\tif ((limit.second & (1<<i)) == 0) {\n\t\t\t\t\tdouble dead = limit.first+sqrt(pow(data[i].first-xy.first, 2)+pow(data[i].second-xy.second, 2));\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif ((limit.second & (1<<j)) == 0) {\n\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead) {\n\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\tint k = limit.second | (1<<i);\n\t\t\t\t\t\tif (k == (1<<n)-1) {\n\t\t\t\t\t\t\thantei = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(Q(data[i], R(dead, k)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hantei) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nstruct pos{\n\tint x;\n\tint y;\n};\nstruct rel{\n\tint to;\n\tint dis;\n};\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n|hx|hy|dx|dy){\n\t\tvector<pos> p;\n\t\tREP(k, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp.push_back({ x, y });\n\t\t}\n\t\tvector<vector<double>> r(n + 1, vector<double>(n + 1));\n\t\tvector<double> dr(n);\n\t\tREP(i, n + 1){\n\t\t\tif (i != n)\n\t\t\t\tdr[i] = hypot(dx - p[i].x,dy - p[i].y);\n\n\t\t\tfor (int j = 0; j < n + 1; j++){\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (i != n  && j != n)r[i][j] = hypot(p[i].x - p[j].x,p[i].y - p[j].y);\n\t\t\t\telse if (i == n)r[i][j] = hypot(hx - p[j].x,hy - p[j].y);\n\t\t\t\telse if (j == n)r[i][j] = hypot(p[i].x - hx,p[i].y - hy);\n\t\t\t}\n\t\t}\n\n\t\tbool b[21] = { false };\n\t\tREP(i, n)b[i] = true;\n\t\tint b_n = n;\n\t\tbool flag = false;\n\t\tfunction<void(double dis, int from)> f = [&](double dis, int from){\n\t\t\tif (flag)return;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (b[i] && (dis + r[from][i] + 1e-8) >= dr[i])return;\n\t\t\t}\n\t\t\t\n\t\t\tif (b_n != 0){\n\t\t\t\tfor (int i = 0; i < n && !flag; i++){\n\t\t\t\t\tif (b[i]){\n\t\t\t\t\t\tb[i] = false;\n\t\t\t\t\t\tb_n--;\n\t\t\t\t\t\tf(dis + r[from][i], i);\n\t\t\t\t\t\tb[i] = true;\n\t\t\t\t\t\tb_n++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tflag = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn;\n\t\t};\n\t\tf(0.0, n); \n\t\tcout << (flag ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str(); }\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX / 10;\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<P> vp;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n#define LT(x,y) ((x)-(y)<=-EPS)\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct state {\n\tint p, s;\n\tdouble d;\n\tstate(int p, int s, double d) : p(p), s(s), d(d) {};\n};\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n) {\n\t\tvp crystal(n);\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tcrystal[i] = P(x, y);\n\t\t}\n\n\t\tvvd dist(n, vd(n));\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tdist[i][j] = abs(crystal[i] - crystal[j]);\n\t\t\t}\n\t\t}\n\n\t\tP h(hx, hy), d(dx, dy);\n\t\tvector<double> hd(n), dd(n);\n\t\tREP(i, n) {\n\t\t\thd[i] = abs(h - crystal[i]);\n\t\t\tdd[i] = abs(d - crystal[i]);\n\t\t}\n\n\t\tstack<state> S;\n\t\tREP(i, n) {\n\t\t\tif (LT(hd[i], dd[i])) {\n\t\t\t\tS.push(state(i, (1 << i), hd[i]));\n\t\t\t}\n\t\t}\n\n\t\tbool success = false;\n\t\twhile (!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\n\t\t\tif (st.s == ((1 << n) - 1)) {\n\t\t\t\tsuccess = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(i, n) {\n\t\t\t\tif ((st.s&(1 << i)) == 0) {\n\t\t\t\t\tint ns = (st.s | (1 << i));\n\t\t\t\t\tdouble nd = st.d + dist[st.p][i];\n\t\t\t\t\tREP(j, n) {\n\t\t\t\t\t\tif ((st.s&(1 << j)) == 0) {\n\t\t\t\t\t\t\tif(!LT(nd, dd[j])) {\n\t\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tS.push(state(i, ns, nd));\n\t\t\t\t}\n\t\t\tnext:;\n\t\t\t}\n\t\t}\n\n\t\tcout << (success ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nstruct Point {\n\tint x, y;\n};\n\nconst double EPS = 1E-8;\nPoint h, d, p[20];\nint n;\nbool flag[20];\n\nbool dfs(double t, int s) \n{\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tif (!flag[i]) break;\n\t}\n\tif (i == n) return true;\n\t\n\tPoint pp = (s == -1) ? h : p[s];\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tif (hypot(d.x - p[i].x, d.y - p[i].y) - hypot(pp.x - p[i].x, pp.y - p[i].y) < EPS) return false;\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tflag[i] = true;\n\t\tif (dfs(hypot(pp.x - p[i].x, pp.y - p[i].y), i)) return true;\n\t\tflag[i] = false;\n\t}\n\t\n\treturn false;\n}\n\nint main()\n{\t\n\twhile (cin >> n >> h.x >> h.y >> d.x >> d.y, n | h.x | h.y | d.x | d.y) {\n\t\tmemset(flag, false, sizeof(flag));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p[i].x >> p[i].y;\n\t\t}\n\t\tcout << (dfs(0, -1) ? \"YES\" : \"NO\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint main() {\n\twhile(true) {\n\t\tint n, hx, hy, dx, dy;\n\t\tcin >> n >> hx >> hy >> dx >> dy;\n\n\t\tif(!n && !hx && !hy && !dx && !dy) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< pair< int, int > > crys;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tcrys.push_back(make_pair(x, y));\n\t\t}\n\n\t\tvector< pair< double, double> > u;\n\t\tvector< bool > use(n, true);\n\t\tint tmp = 1000, idx = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tu.push_back(make_pair(sqrt((double)(crys[i].first - dx) * (crys[i].first - dx) + (double)(crys[i].second - dy) * (crys[i].second - dy)), sqrt((double)(crys[i].first - hx) * (crys[i].first - hx) + (double)(crys[i].second - hy) * (crys[i].second - hy))));\n\t\t\tif(tmp > u[i].first) {\n\t\t\t\ttmp = u[i].first;\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t}\n\n\n\t\tsort(u.begin(), u.end());\n\t\tuse[idx] = false;\n\n\t\tint ans = u[0].first - u[0].second;\n\t\tpair< int, int > now;\n\t\tnow.first = crys[idx].first; now.second = crys[idx].second;\n\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttmp = 10000;\n\t\t\tvector< pair< double, double> > h;\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(!use[j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\th.push_back(make_pair(sqrt((double)(crys[j].first - now.first) * (crys[j].first - now.first) + (double)(crys[j].second - now.second) * (crys[j].second - now.second)), sqrt((double)(crys[j].first - now.first) * (crys[j].first - now.first) + (double)(crys[j].second - now.second) * (crys[j].second - now.second))));\n\t\t\t\tif(tmp > h[j].first) {\n\t\t\t\t\ttmp = h[j].first;\n\t\t\t\t\tidx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(h.begin(), h.end());\n\t\t\tif(!h.size()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans += (h[0].first - h[0].second);\n\t\t\tnow.first = crys[idx].first; now.second = crys[idx].second;\n\t\t\t\n\t\t\tuse[idx] = false;\n\n\t\t\tif(ans <= 0) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(flag){\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n\n\nP getPedal(L l, P p){\n\tdouble A;\n\tif(abs(l[1].real()-l[0].real()) < EPS){\n\t\treturn P(l[1].real(),p.imag()); // important\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A , b = 1 , c = A*l[0].real() - l[0].imag();\n\tdouble t = (a*p.real() + b*p.imag() + c)/(a*a+b*b);\n\treturn p-t * P(a,b);\n}\n \nvector<P> crosspointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS)return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n\nP c[20];\nint okflag;\n\nint n,hx,hy,dx,dy;\n\nint check(L l,double tim){\n\tdouble dist = abs(l[0]-l[1]);\n\tif( abs(l[0]-P(dx,dy)) <= tim+EPS || abs(l[1]-P(dx,dy)) <= tim+dist+EPS ) return false;\n\t\n\tP p = getPedal(l,P(dx,dy));\n\t\n\tif( intersectSP(l,p) == false ){\n\t\treturn true;\n\t}\n\t//if( abs(p-P(dx,dy)) <= tim+abs(l[0]-p) + EPS ) return false;\n\t\n\treturn true;\n}\n\nint test(int bit,P pos,double tim){\n\tif( bit == (1<<n) - 1 ){\n\t\tokflag = 1;\n\t\treturn false;\n\t}\n\tif(okflag) return false;\n\t\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !(bit >> i & 1) ){\n\t\t\tif( !check(L(pos,c[i]),tim) ) return false;\n\t\t}\n\t}\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !(bit >> i & 1) ){\n\t\t\ttest( bit | (1<<i) , c[i] , tim + abs(pos-c[i]) );\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin >> n >> hx >> hy >> dx >> dy && n){\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\t}\n\t\t\n\t\tokflag = 0;\n\t\ttest(0,P(hx,hy),0);\n\t\tif(okflag){\n\t\t\tcout << \"YES\" << endl;\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define MAXNUM 20\n\nstruct status{\n\tdouble d;\n\tint c;\n};\n\ndouble dist(double x1,double y1,double x2,double y2){\n\tdouble ret = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n\treturn ret;\n}\n\nint main(void){\n\tint i, j, n;\n\tdouble hx, hy, dx, dy, cx[MAXNUM],cy[MAXNUM];\n\tstruct status dp[1 << MAXNUM];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tscanf(\"%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0.0 && hy == 0.0 && dx == 0.0 && dy == 0.0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < 1 << MAXNUM;i++)\n\t\t\tdp[i].d = -1;\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tdp[1 << i].d = dist(hx,hy,cx[i],cy[i]);\n\t\t\tdp[1 << i].c = i;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i].d != -1){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & (1 << j) && (dp[i | (1 << j)].d == -1 || dp[i | (1 << j)].d > dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]))){\n\t\t\t\t\t\tdp[i | (1 << j)].d = dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]);\n\t\t\t\t\t\tdp[i | (1 << j)].c = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist(dx,dy,cx[dp[(1 << n) - 1].c],cy[dp[(1 << n) - 1].c]) > dp[(1 << n) - 1].d)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#define MAX_NUM 100000000\n\ndouble dist(int x,int y){\n\treturn sqrt((double)(x * x + y * y));\n}\n\ndouble min(double a, double b){\n\tif(a > b)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\n\nint n, cx[20], cy[20], dx, dy;\n\ndouble dfs(int now,double sum,int bit){\n\tint i;\n\tdouble ret = MAX_NUM;\n\tfor(i = 0;i < n;i++)\n\t\tif(~bit & (1 << i) && sum + dist(cx[now] - cx[i],cy[now] - cy[i]) >= dist(dx - cx[i],dy - cy[i])) return ret;\n\tif(sum >= dist(dx - cx[now],dy - cy[now])) return ret;\n\tif(bit == (1 << n) - 1) return sum;\n\tfor(i = 0;i < n;i++){\n\t\tif(~bit & (1 << i)){\n\t\t\tret = min(dfs(i,sum + dist(cx[i] - cx[now],cy[i] - cy[now]),bit | (1 << i)),ret);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(void){\n\tint hx, hy, i;\n\tdouble ans;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tans = MAX_NUM;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tans = min(ans,dfs(i,dist(cx[i] - hx,cy[i] - hy),1 << i));\n\t\tif(ans != MAX_NUM)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nPoint operator+(Point a,Point b){return Point(a.x+b.x,a.y+b.y);}\nPoint operator-(Point a,Point b){return Point(a.x-b.x,a.y-b.y);}\ndouble abs(Point p){return sqrt(p.x*p.x+p.y*p.y);}\n\nint dfs(double t,Point cur,Point devil,const vector<Point>& cs,int flg)\n{\n\tint n=cs.size(),res=0;\n\trep(i,n) if(!(flg>>i&1)){\n\t\tdouble spend=abs(cs[i]-cur);\n\t\tif(abs(cs[i]-devil)<t+spend+EPS) return 0;\n\t\tres=max(res,1+dfs(t+spend,cs[i],devil,cs,flg|1<<i));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tPoint h,d; cin>>h.x>>h.y>>d.x>>d.y;\n\t\tvector<Point> cs(n);\n\t\tfor(auto& c:cs) cin>>c.x>>c.y;\n\t\tcout<<(dfs(0,h,d,cs,0)==n?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <tr1/unordered_map>\n\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<double, double> P;\nint N;\nP h, d, cs[20];\n\n#define SQ(x) ((x)*(x))\n\ninline double getDist(P a, P b) {\n  return sqrt(SQ(a.fi-b.fi) + SQ(a.se-b.se));\n}\n\ndouble dist[22][22];\n\nusing namespace tr1;\nunordered_map<int, double> mp;\n\nbool dfs(int S, int now, double cost) {\n  \n  if(S == (1<<N)-1) {\n    return true;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(dist[i][N+1] <= cost + dist[now][i]) return false;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(mp.count(S+(1<<i)) && mp[S+(1<<i)] <= cost+dist[now][i]) continue;\n    mp[S+(1<<i)] = cost+dist[now][i];\n    if(dfs(S+(1<<i), i, cost+dist[now][i])) return true;\n  }\n  \n  return false;\n}\n\nbool solve() {\n  \n  mp.clear();\n  \n  for(int i=0; i<N; i++) {\n    for(int j=i+1; j<N; j++) {\n      dist[i][j] = dist[j][i] = getDist(cs[i], cs[j]);\n    }\n    dist[i][N] = dist[N][i] = getDist(cs[i], h);\n    dist[i][N+1] = dist[N+1][i] = getDist(cs[i], d);\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(dist[i][N+1] <= dist[i][N]) continue;\n    if(dfs(1<<i, i, dist[N][i])) return true;\n  }\n  return false;\n}\n\nint main() {\n  \n  while(cin >> N >> h.fi >> h.se >> d.fi >> d.se && (N)) {\n    for(int i=0; i<N; i++) {\n      cin >> cs[i].fi >> cs[i].se;\n    }\n    \n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<double, double> P;\nint N;\nP h, d, cs[20];\n\n#define SQ(x) ((x)*(x))\n\ninline bool getDist(P a, P b) {\n  return sqrt(SQ(a.fi-b.fi) + SQ(a.se-b.se));\n}\n\ndouble dist[22][22];\n\nmap<int, double> mp;\n\nbool dfs(int S, int now, double cost) {\n  \n  if(S = (1<<N)-1) {\n    return true;\n  }\n  \n  mp[S] = cost;\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(dist[N+1][i] <= cost + dist[now][i]) return false;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(mp.count(S+(1<<i)) && mp[S+(1<<i)] <= cost+dist[now][i]) continue;\n    if(dfs(S+(1<<i), i, cost+dist[now][i])) return true;\n  }\n  \n  return false;\n}\n\nbool solve() {\n  \n  mp.clear();\n  \n  for(int i=0; i<N; i++) {\n    for(int j=i+1; j<N; j++) {\n      dist[i][j] = dist[j][i] = getDist(cs[i], cs[j]);\n    }\n    dist[i][N] = dist[N][i] = getDist(cs[i], h);\n    dist[i][N+1] = dist[N+1][i] = getDist(cs[i], m);\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(dist[i][N+1] <= dist[i][N]) continue;\n    if(dfs(1<<i, i, dist[N][i])) return true;\n  }\n  return false;\n}\n\nint main() {\n  \n  while(cin >> N >> h.fi >> h.se >> d.fi >> d.se && (N)) {\n    for(int i=0; i<N; i++) {\n      cin >> cs[i].fi >> cs[i].se;\n    }\n    \n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> dP;\n\nconst int INF = 100000000;\nconst double EPS = 1e-10;\n\nvector<vector<double> > edge;\ndouble dist(P &a, P &b){\n\treturn sqrt(double(a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y));\n}\n\nbool dfs(vector<P> &c, bitset<20> &b, int hi, int di, double t){\n\tif(edge[hi][di] <= t+EPS) return false;\n\tif(b.count() == 20) return true;\n\trep(i, c.size()-2){\n\t\tif(b[i]) continue;\n\t\tif(edge[i][di] <= t+edge[i][hi]+EPS) return false;\n\t}\n\trep(i, c.size()-2){\n\t\tif(b[i]) continue;\n\t\tb[i] = true;\n\t\tif(dfs(c, b, i, di, t+edge[i][hi])) return true;\n\t\tb[i] = false;\n\t}\n\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(!n)break;\n\t\tP h, d;\n\t\tcin >> h.X >> h.Y >> d.X >> d.Y;\n\t\tvector<P> c(n);\n\t\trep(i, n){\n\t\t\tcin >> c[i].X >> c[i].Y;\n\t\t}\n\t\tbitset<20> bits;\n\t\tbits = ~bits;\n\t\trep(i, n){\n\t\t\tbits[i] = false;\n\t\t}\n\t\tc.push_back(h);\n\t\tc.push_back(d);\n\t\tedge.resize(n+2);\n\t\trep(i, n+2){\n\t\t\tedge[i].resize(n+2);\n\t\t}\n\t\trep(i, n+2){\n\t\t\tfor(int j = i; j < n+2; j++){\n\t\t\t\tif(i == j){\n\t\t\t\t\tedge[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tedge[i][j] = edge[j][i] = dist(c[i], c[j]);\n\t\t\t}\n\t\t}\n\n\t\tcout << (dfs(c, bits, n, n+1, 0)?\"YES\":\"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n// Area of Polygon //\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\n// Totsuhou! Andrew's Monotone Chain //\n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n \n \nP getPedal(L l, P p){\n\tdouble A;\n\tif(abs(l[1].real()-l[0].real()) < EPS){\n\t\treturn P(l[1].real(),p.imag()); // important\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A , b = 1 , c = A*l[0].real() - l[0].imag();\n\tdouble t = (a*p.real() + b*p.imag() + c)/(a*a+b*b);\n\treturn p-t * P(a,b);\n}\n\n  \nvector<P> crosspointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS)return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nP getCircumcenter(P a,P b,P c){\n\tdouble A1 = 2 * ( b.real() - a.real() );\n\tdouble B1 = 2 * ( b.imag() - a.imag() );\n\tdouble C1 = pow(a.real(),2)-pow(b.real(),2) + pow(a.imag(),2)-pow(b.imag(),2);\n\tdouble A2 = 2 * ( c.real() - a.real() );\n\tdouble B2 = 2 * ( c.imag() - a.imag() );\n\tdouble C2 = pow(a.real(),2)-pow(c.real(),2) + pow(a.imag(),2)-pow(c.imag(),2);\n\tdouble X = (B1 * C2 - B2 * C1) / (A1 * B2 - A2 * B1);\n\tdouble Y = (C1 * A2 - C2 * A1) / (A1 * B2 - A2 * B1);\n\treturn P(X,Y);\n}\n \ndouble AreaOfPolygon(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*　多角形の面積公式 (反時計回りの場合) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\n\nint N;\ndouble dist[21][21];\ndouble fast[21][21];\nP h,d,p[20];\n\nbool dfs(int n,int bit,double cur){\n\tif( bit == (1<<N)-1 ) return true;\n\n\tfor(int i = 0 ; i < N ; i++){\n\t\tif( !(bit >> i & 1) ){\n\t\t\tif( cur > abs(d-p[i]) - EPS) return false;\n\t\t}\n\t}\n\t\n\tfor(int i = 0 ; i < N ; i++){\n\t\tif( !(bit >> i & 1) ){\n\t\t\tdouble lim = dist[n][i] - cur;\n\t\t\tif( fast[n][i] > lim - EPS ) continue;\n\t\t\tdouble nextTime = cur + abs(p[n]-p[i]);\n\t\t\tif( abs(d-p[i]) - EPS < nextTime ) continue;\n\t\t\tif( dfs(i,bit|(1<<i),nextTime) ) return true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tN = n;\n\t\tcin >> h.real() >> h.imag();\n\t\tcin >> d.real() >> d.imag();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> p[i].real() >> p[i].imag();\t\n\t\t}\n\n\t\tfor(int i = 0 ; i <= n ; i++){\n\t\t\tfor(int j = 0 ; j <= n ; j++){\n\t\t\t\tif( i == j ) continue;\n\t\t\t\tP a = (i==n?h:p[i]);\n\t\t\t\tP b = (j==n?h:p[j]);\n\t\t\t\tdist[i][j] = distanceSP(L(a,b),d);\n\t\t\t\tfast[i][j] = intersectSP(L(a,b),getPedal(L(a,b),d)) ? abs(a-getPedal(L(a,b),d)) : 0;\n\t\t\t}\n\t\t}\n\t\tcout << (dfs(n,0,0)?\"YES\":\"NO\") << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint n;\nint hx, hy, dx, dy;\nvector<int>cx, cy;\n\ndouble dist(double ax, double ay, double bx, double by){\n  return sqrt((ax-bx)*(ax-bx) + (ay-by)*(ay-by));\n}\n\nint dfs(int c, double t, int x, int y, int *used){\n  //  printf(\"%d %lf %lf %lf\\n\", c, t, x, y);\n  if(c == n) return 1;\n\n  rep(i, n){\n    if(used[i]) continue;\n    double nt = dist(x, y, cx[i], cy[i]);\n    //    printf(\"x:%lf y:%lf nt:%lf\\n\", x, y, nt);\n    //    printf(\"dx;%lf dy:%lf cx:%lf cy:%lf\\n\", dx, dy, cx[i], cy[i]);\n    //    printf(\"%lf %lf\\n\", t + nt + EPS, dist(dx, dy, cx[i], cy[i]));\n    if(t + nt + EPS > dist(dx, dy, cx[i], cy[i])) continue;\n    used[i] = 1;\n    if(dfs(c+1, t + nt, cx[i], cy[i], used)) return 1;\n    used[i] = 0;\n  }\n  return 0;\n}\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy) && n+hx+hy+dx+dy){\n    cx.clear(); cy.clear();\n    rep(i, n){\n      int  a, b;\n      scanf(\"%d%d\", &a, &b);\n      cx.PB(a); cy.PB(b);\n    }\n\n    int used[20];\n    memset(used, 0, sizeof(used));\n    if(dfs(0, 0, hx, hy, used)) puts(\"YES\");\n    else puts(\"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\ndouble dist(int x1, int y1, int x2, int y2)\n{\n\tint x = x1 - x2, y = y1 - y2;\n\treturn sqrt(0.0 + x*x + y*y);\n}\nint main()\n{\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n)\n\t{\n\t\tint x[32], y[32];\n\t\trep (i, n)\n\t\t\tcin >> x[i] >> y[i];\n\t\tx[n] = hx, y[n] = hy;\n\t\tx[n + 1] = dx, y[n + 1] = dy;\n\t\tdouble dis[32][32];\n\t\tfor (int i = 0; i <= n + 1; ++i)\n\t\t\tfor (int j = 0; j <= n + 1; ++j)\n\t\t\t\tdis[i][j] = dist(x[i], y[i], x[j], y[j]);\n\n\n\t\tstatic double dp[1 << 20][20];\n\t\tconst double INF = 1e9;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tdp[i][j] = INF;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (dis[n][i] < dis[n + 1][i])\n\t\t\t\tdp[1 << i][i] = dis[n][i];\n\n\t\tfor (int s = 0; s < 1 << n; ++s)\n\t\t{\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tif (!(s >> i & 1) || dp[s][i] == INF)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (s >> j & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tmin_swap(dp[s | 1 << j][j], dp[s][i] + dis[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (dp[(1 << n) - 1][i] + 1e-9 < dis[n + 1][i])\n\t\t\t\tres = true;\n\t\tcout << (res ? \"YES\" : \"NO\") << endl;\n\t\t//cout.precision(9);\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//\tcout << dp[(1 << n) - 1][i] << \" / \" << dis[n + 1][i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n\n#define EPS\t1.0e-10\n#define MAX_CRYSTAL\t32\n#define rep(idx, max)\tfor(int idx = 0, idx##Max = max; idx < idx##Max; idx ++)\n\ntypedef struct _POINT\n{\n\tint x, y;\n\n\t_POINT() {}\n\t_POINT(int _x, int _y) : x(_x), y(_y) {}\n} POINT;\n\nint g_crystalNum;\nPOINT\tg_hero, g_devil;\nPOINT\tg_crystals[MAX_CRYSTAL];\n\nint\tg_bSolved;\nint\tg_bReached[MAX_CRYSTAL];\nint\tg_reachedCount;\n\ndouble Distance(const POINT &src1, const POINT &src2)\n{\n\tdouble x = src1.x - src2.x;\n\tdouble y = src1.y - src2.y;\n\treturn( ::sqrt(x * x + y * y) );\n}\n\nvoid Solve(const POINT &pt, const double time)\n{\n\t//std::cout << time << std::endl;\n\tif (g_bSolved) { return; }\n\n\tif (g_reachedCount == g_crystalNum)\n\t{\n\t\tg_bSolved = true;\n\t\treturn;\n\t}\n\n\trep(n, g_crystalNum)\n\t{\n\t\tif (g_bReached[n]) { continue; }\n\t\tdouble r = time + ::Distance(pt, g_crystals[n]);\t// Elapsed time of hero\n\t\tif (r - ::Distance(g_devil, g_crystals[n]) > EPS) { return; }\t// Could not reached (You are too late :P)\n\t}\n\n\trep(n, g_crystalNum)\n\t{\n\t\tdouble r = time + ::Distance(pt, g_crystals[n]);\n\n\t\tg_bReached[n] = true;\n\t\tg_reachedCount++;\n\t\t::Solve(g_crystals[n], r);\n\t\tg_bReached[n] = false;\n\t\tg_reachedCount--;\n\t}\n}\n\nint main(int nArgs, char **lplpszArgs)\n{\n\twhile (std::cin >> g_crystalNum, g_crystalNum)\n\t{\n\t\tstd::cin >> g_hero.x >> g_hero.y >> g_devil.x >> g_devil.y;\n\t\trep(i, g_crystalNum)\n\t\t{\n\t\t\tPOINT &pt = g_crystals[i];\n\t\t\tstd::cin >> pt.x >> pt.y;\n\t\t}\n\n\t\t::printf(\"Hero: (%d, %d), Devil: (%d, %d)\\n\", g_hero.x, g_hero.y, g_devil.x, g_devil.y);\n\n\t\tg_bSolved = false;\n\t\t::memset(g_bReached, 0, sizeof(g_bReached));\n\t\tg_reachedCount = 0;\n\t\t::Solve(g_hero, 0);\n\t\tstd::cout << (g_bSolved ? \"YES\" : \"NO\") << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nstruct pos{\n\tint x;\n\tint y;\n};\nstruct rel{\n\tint to;\n\tint dis;\n};\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy){\n\t\tvector<pos> p;\n\t\tREP(k, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp.push_back({ x, y });\n\t\t}\n\t\tvector<vector<int>> r(n + 1, vector<int>(n + 1));\n\t\tvector<int> dr(n);\n\t\tREP(i, n + 1){\n\t\t\tif (i != n)\n\t\t\t\tdr[i] = (dx - p[i].x)*(dx - p[i].x) + (dy - p[i].y)*(dy - p[i].y);\n\n\t\t\tfor (int j = 0; j < n + 1; j++){\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (i != n  && j != n)r[i][j] = (p[i].x - p[j].x)*(p[i].x - p[j].x) + (p[i].y - p[j].y)*(p[i].y - p[j].y);\n\t\t\t\telse if (i == n)r[i][j] = (hx - p[j].x)*(hx - p[j].x) + (hy - p[j].y)*(hy - p[j].y);\n\t\t\t\telse if (j == n)r[i][j] = (p[i].x - hx)*(p[i].x - hx) + (p[i].y - hy)*(p[i].y - hy);\n\t\t\t}\n\t\t}\n\n\t\tbool b[21] = { false };\n\t\tREP(i, n)b[i] = true;\n\t\tint b_n = n;\n\t\tbool flag = false;\n\t\tfunction<bool(int dis, int from)> f = [&](int dis, int from){\n\t\t\tif (flag)return true;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (b[i] && (sqrt(dis) + sqrt(r[from][i]))>=sqrt(dr[i]))return false;\n\t\t\t}\n\t\t\t\n\t\t\tif (b_n != 0){\n\t\t\t\tfor (int i = 0; i < n && !flag; i++){\n\t\t\t\t\tif (b[i] && (sqrt(dis) + sqrt(r[from][i]))<sqrt(dr[i])){\n\t\t\t\t\t\tb[i] = false;\n\t\t\t\t\t\tb_n--;\n\t\t\t\t\t\tf(dis + r[from][i], i);\n\t\t\t\t\t\tb[i] = true;\n\t\t\t\t\t\tb_n++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tflag = true;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn flag;\n\t\t};\n\t\tf(0, n); \n\t\tcout << (flag ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cmath>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < int(n); ++i)\n\nint x[30], y[30];\ndouble mem[1<<20][21];\n\nint main() {\n  int n, hx, hy, dx, dy;\n  for (;;) {\n    cin >> n >> hx >> hy >> dx >> dy;\n    if (n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) break;\n    rep (i, 1 << n) rep (j, n + 1) mem[i][j] = 1e+10;\n    rep (i, n) cin >> x[i] >> y[i];\n    rep (i, n) x[i] -= dx;\n    rep (i, n) y[i] -= dy;\n    x[n] = hx - dx;\n    y[n] = hy - dy;\n    priority_queue<pair<double, pair<int, int> > > que;\n    que.push(make_pair(0, make_pair((1 << n) - 1, n)));\n    while (!que.empty()) {\n      pair<double, pair<int, int> > now = que.top();\n      que.pop();\n      double time = now.first;\n      int bit = now.second.first;\n      int pos = now.second.second;\n      if (bit == 0) {\n\tcout << \"YES\" << endl;\n\tgoto aaa;\n      }\n      if (mem[bit][pos] <= time) continue;\n      mem[bit][pos] = time;\n      //cout << time << \" \" << bit << \" \" << pos << endl;\n      rep (i, n) if (1 << i & bit) {\n\tdouble ntime = time + sqrt(pow(x[pos] - x[i], 2) + pow(x[pos] - x[i], 2));\n\tif (ntime >= sqrt(pow(x[i], 2) + pow(y[i], 2)) - 1e-8) break;\n\tque.push(make_pair(ntime, make_pair(bit ^ 1 << i, i)));\n      }\n    }\n    cout << \"NO\" << endl;\n  aaa:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n};\n\nint n;\nvector<double> distDevil;\nvector<vector<double> > dist;\n\nbool solve(int curr, bitset<21> visited, double t)\n{\n    if(visited.to_ulong() == (1<<n)-1)\n        return true;\n\n    for(int i=0; i<n; ++i){\n        if(!visited[i] && t + dist[curr][i] > distDevil[i] - EPS)\n            return false;\n    }\n\n    for(int i=0; i<n; ++i){\n        if(!visited[i]){\n            visited[i] = true;\n            if(solve(i, visited, t + dist[curr][i]))\n                return true;\n            visited[i] = false;\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        Point h, d;\n        cin >> n >> h.x >> h.y >> d.x >> d.y;\n        if(n == 0)\n            return 0;\n\n        ++ n;\n        vector<Point> p(n);\n        p[0] = h;\n        for(int i=1; i<n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        distDevil.resize(n);\n        for(int i=0; i<n; ++i)\n            distDevil[i] = d.dist(p[i]);\n\n        dist.assign(n, vector<double>(n));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                dist[i][j] = p[i].dist(p[j]);\n            }\n        }\n\n        if(solve(0, 1, 0.0))\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 20\n\nstruct P{\n  double x, y;\n}; \n\nint N;\nP h, d, c[MAX];\n \ndouble dist(P a, P b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX];\nbool rec(int now, double sum, int dep){\n  if(dep == N){\n    return true;\n  }\n\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      if(sum + dist(c[now],c[i]) >= dist(d,c[i])){\n        return false;\n      }\n    }\n  }\n\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      used[i] = true;\n      if(rec(i, sum+dist(c[now],c[i]),dep+1)){\n        return true;\n      }\n      used[i] = false;\n    }\n  }\n  return false;\n}\n\nvoid solve(){\n  for(int i = 0 ; i < N ; i++){\n    memset(used, false, sizeof(used));\n    if(rec(i, dist(h,c[i]), 0)){\n      puts(\"YES\");\n      return;\n    }\n  }\n  puts(\"NO\");\n}\n \nint main(){\n  while(scanf(\"%d%lf%lf%lf%lf\" ,&N, &h.x, &h.y, &d.x, &d.y)\n        , (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      scanf(\"%lf%lf\" ,&c[i].x, &c[i].y);\n    }\n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint x,y;\n};\n\nint N,POW[21];\nInfo start,enemy,info[21];\ndouble dist_table[21][21],poison_TIME[20];\nbool FLG;\n\ndouble calc_Time(Info from,Info to){\n\treturn sqrt((from.x-to.x)*(from.x-to.x)+(from.y-to.y)*(from.y-to.y));\n}\n\nvoid dfs(int node_id,int count,double total_time,int state){\n\n\tif(count == N){\n\t\tFLG = true;\n\t}\n\tif(FLG)return;\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(state & (1 << i)){\n\t\t\t//Do nothing\n\t\t}else{\n\t\t\tdouble next_time = total_time+dist_table[node_id][i];\n\t\t\tif(next_time >= poison_TIME[i])return;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(state & (1 << i)){\n\t\t\t//Do nothing\n\t\t}else{\n\t\t\tdouble next_time = total_time+dist_table[node_id][i];\n\t\t\tint next_state = state + POW[i];\n\t\t\tdfs(i,count+1,next_time,next_state);\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].x,&info[i].y);\n\t\tpoison_TIME[i] = calc_Time(info[i],enemy);\n\t}\n\tinfo[N].x = start.x;\n\tinfo[N].y = start.y;\n\n\tdouble tmp;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = i+1; k <= N; k++){\n\t\t\ttmp = calc_Time(info[i],info[k]);\n\t\t\tdist_table[i][k] = tmp;\n\t\t\tdist_table[k][i] = tmp;\n\t\t}\n\t}\n\n\tFLG = false;\n\n\tdfs(N,0,0,0);\n\n\tif(FLG){\n\t\tprintf(\"YES\\n\");\n\t}else{\n\t\tprintf(\"NO\\n\");\n\t}\n}\n\nint main(void){\n\n\tfor(int i = 0; i <= 20; i++)POW[i] = pow(2,i);\n\n    while(true){\n    \tscanf(\"%d %d %d %d %d\",&N,&start.x,&start.y,&enemy.x,&enemy.y);\n\n    \tif(N == 0)break;\n\n    \tfunc();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define MAXNUM 21\n\ntypedef struct s{\n\tdouble d;\n\tint c;\n}status;\n\ndouble dist(double x1,double y1,double x2,double y2){\n\treturn sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\nvoid printB(int n){\n\tint i = 0, a[MAXNUM];\n\tfor(i = 0;i < MAXNUM;i++){\n\t\ta[MAXNUM - 1 - i] = n % 2;\n\t\tn /= 2;\n\t}\n\tfor(i = 0;i < MAXNUM;i++){\n\t\tprintf(\"%d\",a[i]);\n\t}\n}\n\nint main(void){\n\tint i, j, n;\n\tdouble hx, hy, dx, dy, cx[MAXNUM],cy[MAXNUM];\n\tstatus dp[1 << MAXNUM];\n\twhile(1){\n\t\tscanf(\"%d%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(!n && !hx && !hy && !dx && !dy)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i].d = -1;\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tdp[1 << i].d = dist(hx,hy,cx[i],cy[i]);\n\t\t\tdp[1 << i].c = i;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i].d != -1){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & 1 << j && (dp[i | 1 << j].d == -1 || dp[i | 1 << j].d > dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]))){\n\t\t\t\t\t\tdp[i | 1 << j].d = dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]);\n\t\t\t\t\t\tdp[i | 1 << j].c = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist(dx,dy,cx[dp[(1 << n) - 1].c],cy[dp[(1 << n) - 1].c]) > dp[(1 << n) - 1].d)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n/*\t\tfor(i = 0;i < (1 << n);i++){\n\t\t\tprintf(\"dp[\");\n\t\t\tprintB(i);\n\t\t\tprintf(\"] = %f\\n\",dp[i].d);\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint cx[20],cy[20];\ndouble lim[20];\ndouble dd[20][20];\nbool memo[20][1<<20];\n\n#define DBL(x) ((x)*(x))\n\ninline double dist(int x1, int y1, int x2, int y2){\n  return sqrt(DBL(x1-x2) + DBL(y1-y2));\n}\n\ninline int b2i(unsigned int bit){\n  int ans=0;\n  if(!(bit&0x0000FFFF)){ans+=16;bit>>=16;}\n  if(!(bit&0x000000FF)){ans+= 8;bit>>= 8;}\n  if(!(bit&0x0000000F)){ans+= 4;bit>>= 4;}\n  if(!(bit&0x00000003)){ans+= 2;bit>>= 2;}\n  if(!(bit&0x00000001)){ans+= 1;         }\n  return ans;\n}\n\nbool solve(int pos, int f, double time){\n  //printf(\"solve(%d,%d,%d) : lim = %d\\n\",pos,f,time,lim[pos]);\n}\n\nint main(){\n  while(true){\n    int n,hx,hy,dx,dy;\n    n = getInt(); hx = getInt(); hy = getInt();\n    dx = getInt(); dy = getInt();\n    if(!(n+hx+hy+dx+dy)) break;\n    memset(memo, 0, sizeof(memo));\n    REP(i,n){ cx[i] = getInt(); cy[i] = getInt(); }\n    REP(i,n){ lim[i] = dist(dx,dy,cx[i],cy[i]); }\n    REP(i,n) REP(j,n) dd[i][j] = dist(cx[i],cy[i],cx[j],cy[j]);\n\n    bool ans = false;\n\n    typedef pair<double,pair<int,int> > data;\n    priority_queue<data,vector<data>,greater<data> > pq;\n\n    REP(i,n) pq.push(mp(dist(hx,hy,cx[i],cy[i]), mp(i, (((1<<n)-1)^(1<<i)))));\n\n    while(pq.size()){\n      data d = pq.top(); pq.pop();\n      double time = d.f;\n      int pos = d.s.f;\n      int f = d.s.s;\n\n      if(time >= lim[pos]) continue;\n      if(memo[pos][f]) continue;\n      if(f == 0){\n        ans = true;\n        break;\n      }\n\n      memo[pos][f] = true;\n\n      while(f){\n        int ff = f & (-f);\n        int next = b2i(ff);\n        f ^= ff;\n        pq.push(mp(time + dd[pos][next], mp(next, f)));\n      }\n    }\n\n    puts(ans ? \"YES\" : \"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nstruct pos{\n\tint x;\n\tint y;\n};\nstruct rel{\n\tint to;\n\tint dis;\n};\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy){\n\t\tvector<pos> p;\n\t\tREP(k, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp.push_back({ x, y });\n\t\t}\n\t\tvector<vector<int>> r(n + 1, vector<int>(n + 1));\n\t\tvector<int> dr(n);\n\t\tREP(i, n + 1){\n\t\t\tif (i != n)\n\t\t\t\tdr[i] = (dx - p[i].x)*(dx - p[i].x) + (dy - p[i].y)*(dy - p[i].y);\n\n\t\t\tfor (int j = 0; j < n + 1; j++){\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (i != n  && j != n)r[i][j] = (p[i].x - p[j].x)*(p[i].x - p[j].x) + (p[i].y - p[j].y)*(p[i].y - p[j].y);\n\t\t\t\telse if (i == n)r[i][j] = (hx - p[j].x)*(hx - p[j].x) + (hy - p[j].y)*(hy - p[j].y);\n\t\t\t\telse if (j == n)r[i][j] = (p[i].x - hx)*(p[i].x - hx) + (p[i].y - hy)*(p[i].y - hy);\n\t\t\t}\n\t\t}\n\n\t\tbool b[21] = { false };\n\t\tREP(i, n)b[i] = true;\n\t\tint b_n = n;\n\t\tbool flag = false;\n\t\tfunction<bool(int dis, int from)> f = [&](int dis, int from){\n\t\t\tif (flag)return true;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (b[i] && (sqrt(dis) + sqrt(r[from][i]))>sqrt(dr[i]))return false;\n\t\t\t}\n\t\t\t\n\t\t\tif (b_n != 0){\n\t\t\t\tfor (int i = 0; i < n && !flag; i++){\n\t\t\t\t\tif (b[i] && (sqrt(dis) + sqrt(r[from][i]))<sqrt(dr[i])){\n\t\t\t\t\t\tb[i] = false;\n\t\t\t\t\t\tb_n--;\n\t\t\t\t\t\tf(dis + r[from][i], i);\n\t\t\t\t\t\tb[i] = true;\n\t\t\t\t\t\tb_n++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tflag = true;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn flag;\n\t\t};\n\t\tf(0, n); \n\t\tcout << (flag ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nPoint operator+(Point a,Point b){return Point(a.x+b.x,a.y+b.y);}\nPoint operator-(Point a,Point b){return Point(a.x-b.x,a.y-b.y);}\ndouble abs(Point p){return sqrt(p.x*p.x+p.y*p.y);}\n\nint dfs(double t,Point cur,Point devil,const vector<Point>& cs,int flg)\n{\n\tint n=cs.size();\n\tint res=0;\n\trep(i,n){\n\t\tif(flg>>i&1) continue;\n\t\tdouble spend=abs(cs[i]-cur);\n\t\tif(abs(cs[i]-devil)<t+spend+EPS) continue;\n\t\tres=max(res,1+dfs(t+spend,cs[i],devil,cs,flg|1<<i));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tPoint h,d; cin>>h.x>>h.y>>d.x>>d.y;\n\t\tvector<Point> cs(n);\n\t\tfor(auto& c:cs) cin>>c.x>>c.y;\n\t\tcout<<(dfs(0,h,d,cs,0)==n?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <string>\n#include <cmath>\ninline double dist(int x, int y) {\n\treturn std::sqrt(x * x + y * y);\n}\ninline double dist(std::pair<int, int> pos) {\n\treturn std::sqrt(pos.first * pos.first + pos.second * pos.second);\n}\ninline double dist(int x, int y, std::pair<int, int> pos) {\n\treturn std::sqrt((x - pos.first) * (x - pos.first) + (y - pos.second) * (y - pos.second));\n}\n\nstd::vector<std::pair<int, int>> crystal;\nint n, x, y, mx, my;\nbool Solve(double day = 0, std::vector<std::pair<int, int>> got = {});\nbool isClear = false;\nint main()\n{\n\tstd::vector<std::string> results;\n\twhile (1) {\n\t\tstd::cin >> n >> x >> y >> mx >> my;\n\t\tif (!x && !y && !n && !mx && !my) break;\n\t\tcrystal.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint cx, cy;\n\t\t\tstd::cin >> cx >> cy;\n\t\t\tcx -= mx; cy -= my;\n\t\t\tcrystal.push_back(std::make_pair(cx, cy));\n\t\t}\n\t\tx -= mx; y -= my;\n\t\tmx = 0; my = 0;\n\t\tisClear = false;\n\t\tSolve();\n\t\tresults.push_back(isClear ? \"YES\" : \"NO\");\n\t}\n\n\tfor (auto& x : results) {\n\t\tstd::cout << x << std::endl;\n\t}\n\n\treturn 0;\n}\n\nbool Solve(double day, std::vector<std::pair<int, int>> got)\n{\n\tif (isClear) return true;\n\tbool ok = false;\n\tint posX, posY;\n\tif (got.empty()) {\n\t\tposX = x;\n\t\tposY = y;\n\t}\n\telse {\n\t\tposX = got.back().first;\n\t\tposY = got.back().second;\n\t}\n\t//??¨??£??????????????´?????¨??????????????????????????£?????????\n\tfor (auto& x : crystal) {\n\t\t//???????????????????¨????(?????¢???????????????????????????)\n\t\tdouble pass = dist(posX, posY, x);\n\t\tdouble next = day + pass;\n\t\t//?????£?????????crystal?????????????????????????????????????????????\n\t\tif (next < dist(x)) {\n\t\t\t//??´?°????????????¨??????????¨????\n\t\t\tif (std::find(got.begin(), got.end(), x) == got.end()) {\n\t\t\t\tgot.push_back(x);\n\t\t\t\tif (got.size() == n) {\n\t\t\t\t\tisClear = true;\n\t\t\t\t}\n\t\t\t\tok = ok | Solve(next, got);\n\t\t\t}\n\t\t}\n\t}\n\treturn ok;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define REP(i, n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nint n, dx, dy, hx, hy;\nint cx[20], cy[20];\n\ndouble dist(int x1, int y1, int x2, int y2){\n  int dx = x1 - x2;\n  int dy = y1 - y2;\n  return sqrt((double)dx * dx + dy * dy);\n}\n\nbool dfs(int x, int y, double time, int k){\n  if(time >= dist(x, y, dx, dy)) return false;\n  if(k == n) return true;\n  \n  REP(i, n){\n    if(time + dist(x, y, cx[i], cy[i]) >= dist(cx[i], cy[i], dx, dy)) return false;\n  }\n  REP(i, n){\n    if(dfs(cx[i], cy[i], time + dist(cx[i], cy[i], x, y), k + 1)){ return true;\n    }\n  }\n  return false;\n}\n\nint main(void){\n  while(true){\n    scanf(\" %d %d %d %d %d\", &n, &hx, &hy, &dx, &dy);\n    if(n == 0) break;\n    REP(i, n){\n      scanf(\" %d %d\", &cx[i], &cy[i]);\n    }\n    if(dfs(hx, hy, 0.0, 0)) printf(\"YES\\n\");\n    else printf(\"NO\\n\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-14;\n\nint N;\nP D;\nvector<P> ps;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, int p) {\n  double dist = abs(D - ps[p]);\n  return !( dist <= t );\n}\n\nbool rec(int state, double t, int p) {\n  if(state == (1<<N)-1) return true;\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    if(!canExist(t+abs(ps[i] - ps[p]), i)) return false;\n  }\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    double nt = t + abs(ps[i] - ps[p]);\n    if(rec(state|(1<<i), nt, i)) return true;\n  }\n  return false;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy\n\t&&(N|hx|hy|dx|dy) ) {\n    D = P(dx, dy);\n    ps.resize(N+1);\n    ps[N-1] = P(hx, hy);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(rec(0, 0.0, N)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\ndouble eps=1e-9;\nint x[23];\nint y[23];\ndouble dist[23][23];\nint n;\nint solve(int a,int b,double s){\n\tif(a==(1<<n)-1)return 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(a&(1<<i))continue;\n\t\tif(s+dist[b][i]+eps>dist[n+1][i])return 0;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(a&(1<<i))continue;\n\t\t\n\t\tif(solve(a+(1<<i),i,s+dist[b][i]))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,hx,hy,dx,dy;\n\twhile(scanf(\"%d%d%d%d%d\",&a,&hx,&hy,&dx,&dy),a){\n\t\tn=a;\n\t\tfor(int i=0;i<a;i++)scanf(\"%d%d\",x+i,y+i);\n\t\tx[a]=hx;x[a+1]=dx;\n\t\ty[a]=hy;y[a+1]=dy;\n\t\tfor(int i=0;i<a+2;i++)for(int j=0;j<a+2;j++)\n\t\t\tdist[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\tif(solve(0,a,0))printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nclass Compare {\n  int monster_x;\n  int monster_y;\npublic:\n  Compare(int monster_x,int monster_y)\n    : monster_x(monster_x), monster_y(monster_y) {}\n  bool operator()(const P& ci,const P& cj) const{\n    int dist_i = (ci.first - monster_x) * (ci.first - monster_x)\n      + (ci.second - monster_y) * (ci.second - monster_y);\n    int dist_j = (cj.first - monster_x) * (cj.first - monster_x)\n      + (cj.second - monster_y) * (cj.second - monster_y);\n    return dist_i < dist_j;\n  }\n};\n\nclass State{\n  int x;\n  int y;\n  double dist;\n};\n\nbool dfs(int hero_x,\n         int hero_y,\n         double current_time,\n         int S,\n         int monster_x,\n         int monster_y,\n         const vector<P>& cristals){\n  bool res = false;\n\n  if(S == (1<<cristals.size()) - 1) return true;\n  for(int i=0;i<cristals.size();i++){\n    if(S & (1<<i)) continue;\n    double add_time = sqrt((hero_x - cristals[i].first) * (hero_x - cristals[i].first)\n                           + (hero_y - cristals[i].second) * (hero_y - cristals[i].second));\n    \n    double tmp_current_time = current_time + add_time;\n    double impurity_arrive_time = sqrt((monster_x - cristals[i].first) * (monster_x - cristals[i].first)\n                                       + (monster_y - cristals[i].second) * (monster_y - cristals[i].second));\n    if(tmp_current_time >= impurity_arrive_time){\n      return false;\n    }\n    \n    res |= dfs(cristals[i].first,cristals[i].second,tmp_current_time,\n               S | (1<<i),monster_x,monster_y,cristals);\n  }\n  return res;\n}\n\nint main(){\n  int total_cristals;\n  int hero_x;\n  int hero_y;\n  int monster_x;\n  int monster_y;\n  while(~scanf(\"%d %d %d %d %d\",\n               &total_cristals,\n               &hero_x,\n               &hero_y,\n               &monster_x,\n               &monster_y)){\n    if(total_cristals == 0 && hero_x == 0 && hero_y == 0\n       && monster_x == 0 && monster_y == 0) break;\n    vector<P> cristals;\n    for(int cristal_i = 0; cristal_i < total_cristals; cristal_i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cristals.push_back(P(x,y));\n    }\n    Compare comp(monster_x,monster_y);\n    sort(cristals.begin(),cristals.end(),comp);\n    printf(\"%s\\n\", dfs(hero_x,hero_y,0,0,monster_x,monster_y,cristals)\n           ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n\ndouble cost[22][22];\ndouble tlimit[22];\nint xx[22];\nint cx[22], cy[22];\nint n;\n\nbool DFS(int pos, int vis, double dis){\n\tif(vis == ((1<<(n+1))-1))return true;\n\t//枝狩り\n\tFOR(i, 1, n+1)if((vis&xx[i])==0 && (dis+cost[pos][i] > tlimit[i]+EPS))return false;\n\tFOR(i, 1, n+1){\n\t\tif(!(vis&xx[i])){\n\t\t\tif(DFS(i, vis|xx[i], dis+cost[pos][i])){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tREP(i,22)xx[i] = 1<<i;\n\twhile(1){\n\t\tint dx,dy;\n\t\tcin>>n>>cx[0]>>cy[0]>>dx>>dy;\n\t\tif(n==0)return 0;\n\t\tFOR(i,1,n+1)scanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tREP(i, n+1){\n\t\t\ttlimit[i] = sqrt(pow(cx[i]*1.0-dx*1.0,2.0)+pow(cy[i]*1.0-dy*1.0,2.0));\n\t\t\tREP(j,i+1){\n\t\t\t\tcost[i][j] = sqrt(pow(cx[i]*1.0-cx[j]*1.0,2.0)+pow(cy[i]*1.0-cy[j]*1.0,2.0));\n\t\t\t\tcost[j][i] = cost[i][j];\n\t\t\t}\n\t\t}\n\t\tif(DFS(0, 1, 0.0))cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\nint n,h,w,d,e,x,y;\ndouble k;\ndouble j(int f,int g){return sqrt(f*f+g*g+0.0);}\nint main(){\n\twhile(1){\n\tcin>>n>>x>>y>>d>>e;\n\tif(!n)break;\n\tcin>>h>>w;\n\tn--,k=j(h-x,w-y);\n\tbool o=1;\n\tif(k>=j(d-x,e-y))o=0;\n\twhile(n--){\n\t\tcin>>x>>y;\n\t\tif(k+j(h-x,w-y)>=j(d-x,e-y))o=0;\n\t}\n\tif(o)cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define MAX 21\n#define INF 10000\n#define EPS 1.0e-10\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point;\ndouble dist(const point &a, const point &b){return std::abs(b-a);}\nbool vis[MAX];\nbool bt(const vector<point> &v, double walk, const point &h, const point &d){\n\tbool bCont = false;\n\n\tfor(unsigned int i = 0; i < v.size(); ++i){\n\t\tif( !vis[i] )bCont=true;\n\t}\n\tif( !bCont )return true;\n\n\n\tfor(unsigned int i = 0; i < v.size(); ++i){\n\t\tif( !vis[i] ){\n\t\t\tdouble t = walk + dist(h,v[i]);\n\t\t\tif( t < dist(d, v[i]) ){\n\t\t\t\tvis[i] = true;\n\t\t\t\tif( bt( v, t, v[i], d ) )\n\t\t\t\t\treturn true;\n\t\t\t\tvis[i] = false;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tbool bImpossible = false;\n\t\tint n,hx,hy,dx,dy;\n\t\tpoint hero, daemon;\n\t\tvector< point > vp;\n\n\t\tscanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy);\n\t\tif(!(n||hx||hy||dx||dy))break;\n\t\t\n\t\thero = complex<elem>(hx,hy);\n\t\tdaemon = complex<elem>(dx,dy);\n\t\t\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint cx,cy;scanf(\"%d%d\", &cx, &cy);point p(cx,cy);\n\t\t\tif(cx==hx&&cy==hy)continue;\n\t\t\tvp.push_back( p );\n\t\t\tif( dist(daemon,p) <= dist(hero,p) )bImpossible=true;\n\t\t\tvis[i]=false;\n\t\t}\n\t\t\n\t\tif( !bImpossible && bt( vp, 0.0, hero, daemon ) )\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <functional>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<double, int> R;\ntypedef pair<P, R> Q;\ntypedef pair<double, Q> K;\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\tdouble r;\n\twhile (cin >> n >> hx >> hy >> dx >> dy) {\n\t\tif (n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) {\n\t\t\tbreak;\n\t\t}\n\t\thx -= dx;\n\t\thy -= dy;\n\t\tvector<P> data;\n\t\tint x, y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\tdata.push_back(P(x, y));\n\t\t}\n\t\tpriority_queue<K, vector<K>, greater<K> > q;\n\t\tq.push(K(0.0, Q(P(hx, hy), R(0.0, 0))));\n\t\tbool hantei = false;\n\t\twhile (!q.empty()) {\n\t\t\tK p = q.top();\n\t\t\tq.pop();\n\t\t\tP xy = (p.second).first;\n\t\t\tR limit = (p.second).second;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tbool hantei2 = true;\n\t\t\t\tif ((limit.second & (1<<i)) == 0) {\n\t\t\t\t\tdouble dead = limit.first+sqrt(pow(data[i].first-xy.first, 2)+pow(data[i].second-xy.second, 2));\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif ((limit.second & (1<<j)) == 0) {\n\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead) {\n\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\tint k = limit.second | (1<<i);\n\t\t\t\t\t\tif (k == (1<<n)-1) {\n\t\t\t\t\t\t\thantei = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble MIN = 1<<30;\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tif ((k & (1<<j)) == 0) {\n\t\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead+sqrt(pow(data[i].first-data[j].first, 2)+pow(data[i].second-data[j].second, 2))) {\n\t\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tMIN = min(MIN, sqrt(pow(data[i].first-data[j].first, 2)+pow(data[i].second-data[j].second, 2)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\t\tq.push(K(MIN, Q(data[i], R(dead, k))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hantei) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nPoint operator+(Point a,Point b){return Point(a.x+b.x,a.y+b.y);}\nPoint operator-(Point a,Point b){return Point(a.x-b.x,a.y-b.y);}\ndouble abs(Point p){return sqrt(p.x*p.x+p.y*p.y);}\n\nint dfs(double t,Point cur,Point devil,const vector<Point>& cs,int flg)\n{\n\tint n=cs.size();\n\trep(i,n) if(!(flg>>i&1)){\n\t\tdouble spend=abs(cs[i]-cur);\n\t\tif(abs(cs[i]-devil)<t+spend+EPS) return 0;\n\t}\n\tint res=0;\n\trep(i,n) if(!(flg>>i&1)){\n\t\tdouble spend=abs(cs[i]-cur);\n\t\tres=max(res,1+dfs(t+spend,cs[i],devil,cs,flg|1<<i));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tPoint h,d; cin>>h.x>>h.y>>d.x>>d.y;\n\t\tvector<Point> cs(n);\n\t\tfor(auto& c:cs) cin>>c.x>>c.y;\n\t\tcout<<(dfs(0,h,d,cs,0)==n?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\n#define fi first\n#define se second\n\nint N;\nint hx, hy, mx, my;\ntypedef pair<double, double> P;\nP cs[21];\n\n#define SQ(x) ((x)*(x))\ninline double dist(P a, P b) {\n  return sqrt(SQ(a.fi-b.fi) + SQ(a.se-b.se));\n}\n\nunordered_map<int, double> umap;\n\ndouble G[22][22];\nbool dfs(int S, int now, double cost) {\n  \n  if(S == (1<<N)-1) {\n    return true;\n  }\n  \n  umap[S] = cost;\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(G[i][N+1] <= cost+G[now][i]) return false;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(umap.count(S|(1<<i)) && umap[S|(1<<i)] <= cost+G[now][i]) continue;\n    if(dfs(S|(1<<i), i, cost+G[now][i])) return true;\n  }\n  \n  return false;\n}\n\nbool solve() {\n  \n  umap.clear();\n  \n  for(int i=0; i<N; i++) {\n    for(int j=i+1; j<N; j++) {\n      G[i][j] = G[j][i] = dist(cs[i], cs[j]);\n    }\n    G[N][i] = G[i][N] = dist(P(hx, hy), cs[i]);\n    G[N+1][i] = G[i][N+1] = dist(P(mx, my), cs[i]);\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(dfs(1<<i, i, G[N][i])) return true;\n  }\n  \n  return false;\n}\n\nint main() {\n  while(1) {\n    cin >> N >> hx >> hy >> mx >> my;\n    if(!N) break;\n    for(int i=0; i<N; i++) {\n      cin >> cs[i].fi >> cs[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\ndouble INF=1e16;\ndouble EPS=1e-9;\nclass Main{\n\tpublic:\n\n\n\tint n;double hx,hy,dx,dy;\n\tvector<double> cx,cy;\n\tvector<vector<double>> ds;\n\n\tbool dfs(int v,int bit,double t){\n\t\tif(bit==(1<<n)-1)return true;\n\t\t//cut \n\t\tREP(i,n)if(!((bit>>i)&1)){\n\t\t\tdouble d=hypot(cx[i]-cx[v],cy[i]-cy[v]);\n\t\t\tif(!(d+t<hypot(cx[i]-dx,cy[i]-dy)))return false;\n\t\t}\n\n\t\tbool ok=false;\n\t\tREP(i,n)if(!((bit>>i)&1)){\n\t\t\tdouble d=hypot(cx[i]-cx[v],cy[i]-cy[v]);\n\t\t\tif(d+t<hypot(cx[i]-dx,cy[i]-dy))ok|=dfs(i,bit|1<<i,d+t);\n\t\t}\n\t\treturn ok;\n\t}\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tcin >> n >> hx >> hy >> dx >> dy;if(n==0)break;\n\t\t\tcx=vector<double>(n);cy=vector<double>(n);REP(i,n) cin >> cx[i] >> cy[i];\n\n\t\t\tbool ok=false;\n\t\t\tREP(i,n){\n\t\t\t\tdouble d=hypot(cx[i]-hx,cy[i]-hy);\n\t\t\t\tif(d<hypot(cx[i]-dx,cy[i]-dy))ok|=dfs(i,1<<i,d);\n\t\t\t}\n\t\t\tcout << (ok?\"YES\":\"NO\")<<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nint n, hx, hy, dx, dy;\nVVD dist;\nvector<P> cristals;\nVD limits;\n\nbool get_cristal(int status, int position, double time)\n{\n\tif (time > limits[position] - EPS) {\n\t\treturn false;\n\t}\n\tif (status == (1 << n) - 1) {\n\t\treturn true;\n\t}\n\tbool clear = false;\n\tREP (c, n) {\n\t\tif ( (status & (1 << c)) == 0) {\n\t\t\t// Get c-th cristal\n\t\t\tif (get_cristal(status | (1 << c), c, time + dist[position][c])) {\n\t\t\t\tclear = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn clear;\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n | hx | hy | dx | dy) {\n\t\tcristals.clear();\n\t\tREP (i, n) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tcristals.PB(P(x, y));\n\t\t}\n\t\tcristals.PB(P(hx, hy));\n\n\t\tdist = VVD(cristals.size(), VD(cristals.size(), INF));\n\t\tREP (i, cristals.size()) {\n\t\t\tREP (j, cristals.size()) {\n\t\t\t\tdist[i][j] = sqrt(norm(cristals[i] - cristals[j]));\n\t\t\t}\n\t\t}\n\n\t\tlimits = VD(n);\n\t\tREP (i, n) {\n\t\t\tlimits[i] = sqrt(norm(cristals[i] - P(dx, dy)));\n\t\t}\n\t\tlimits.PB(INF);\n\n\t\tif (get_cristal(0, cristals.size() - 1, 0)) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str(); }\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX / 10;\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<P> vp;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n#define LT(x,y) ((x)-(y)<=-EPS)\n\nstruct state {\n\tP p;\n\tint c;\n\tdouble d;\n\tstate(P p, int c, double d) : p(p), c(c), d(d) {};\n};\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n) {\n\t\tvp crystal(n);\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tcrystal[i] = P(x, y);\n\t\t}\n\t\tP d(dx, dy);\n\n\t\tstack<state> S;\n\t\tS.push(state(P(hx, hy), 0, 0));\n\t\tbool success = false;\n\t\twhile (!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\n\t\t\tif (st.c == (1 << n) - 1) {\n\t\t\t\tsuccess = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(i, n) {\n\t\t\t\tif ((st.c&(1<<i)) == 0) {\n\t\t\t\t\tdouble nd = st.d + abs(st.p - crystal[i]);\n\t\t\t\t\tdouble dd = abs(d - crystal[i]);\n\t\t\t\t\tif (LT(nd, dd)) {\n\t\t\t\t\t\tS.push(state(crystal[i], st.c | (1 << i), nd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (success ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\ndouble INF=1e16;\ndouble EPS=1e-9;\nclass Main{\n\tpublic:\n\n\n\tint n;double hx,hy,dx,dy;\n\tvector<double> cx,cy;\n\tvector<vector<double>> ds;\n\n\tbool dfs(int v,int bit,double t){\n\t\tif(bit==(1<<n)-1)return true;\n\t\tbool ok=false;\n\t\t//cut \n\t\tREP(i,n)if(!((bit>>i)&1)){\n\t\t\tdouble d=hypot(cx[i]-cx[v],cy[i]-cx[v]);\n\t\t\tif(!(d+t<hypot(cx[i]-dx,cy[i]-dy)))return false;\t\t\t\n\t\t}\n\t\tREP(i,n)if(!((bit>>i)&1)){\n\t\t\tdouble d=hypot(cx[i]-cx[v],cy[i]-cx[v]);\n\t\t\tif(d+t<hypot(cx[i]-dx,cy[i]-dy))ok|=dfs(i,bit|1<<i,d+t);\n\t\t}\n\t\treturn ok;\n\t}\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){ cin >> n >> hx >> hy >> dx >> dy;if(n==0)break;\n\t\t\tcx=vector<double>(n);cy=vector<double>(n);REP(i,n) cin >> cx[i] >> cy[i];\n\n\t\t\tbool ok=false;\n\t\t\tREP(i,n){\n\t\t\t\tdouble d=hypot(cx[i]-hx,cy[i]-hy);\n\t\t\t\tif(d<hypot(cx[i]-dx,cy[i]-dy))ok|=dfs(i,1<<i,d);\n\t\t\t}\n\t\t\tcout << (ok?\"YES\":\"NO\")<<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\nint abs(int n){\n    if(n < 0)\n\t\tn = -1 * n;\n    return n;\n}\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 10], dp[1 << 10];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) \n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF; \n\t\tfor(i = 0;i < n;i++) \n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]); \n\t\tfor(i = 0;i < n;i++){ \n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){ \n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]); \n\t\t\t\tloc[1 << i] = i; \n\t\t\t} \n\t\t\telse  \n\t\t\t\tbreak; \n\t\t}  \n\t\tif(i != n){  \n\t\t\tprintf(\"NO\\n\"); \n\t\t\tcontinue;  \n\t\t}  \n\t\tfor(i = 0;i < 1 << n;i++){ \n\t\t\tif(dp[i] != INF){  \n\t\t\t\tfor(j = 0;j < n;j++){  \n\t\t\t\t\tif(~i & 1 << j && dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j]) && dp[i ^ (1 << j)] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i]){ \n\t\t\t\t\t\tdp[i ^ (1 << j)] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];  \n\t\t\t\t\t\tloc[i ^ (1 << j)] = j; \n\t\t\t\t\t}  \n\t\t\t\t}  \n\t\t\t}  \n\t\t}   \n\t\tif(dp[(1 << n) - 1] != INF) \n\t\t\tprintf(\"YES\\n\");  \n\t\telse  \n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<double, pair<int, P> > bfp;\nint n, hx, hy, dx, dy;\nP c[1001];\ndouble len[1001];\nint main() {\n    while (scanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy)) {\n        if (!n&&!hx&&!hy&&!dx&&!dy) break;\n        for (int i=0; i<n; i++) {\n            scanf(\"%d%d\",&c[i].x,&c[i].y);\n            double x=c[i].x-dx, y=c[i].y-dy;\n            len[i]=sqrt(x*x+y*y);\n        }\n        queue<bfp> que;\n        que.push(bfp(0.0, make_pair(0,P(hx,hy))));\n        bool res=false;\n        while (!que.empty()) {\n            bfp b=que.front(); que.pop();\n            double t=b.first;\n            int stat=b.second.first;\n            P np=b.second.second;\n            bool flag=true;\n            for (int i=0; i<n; i++) {\n                if (!(stat>>i&1)) {\n                    flag=false;\n                    double x=c[i].x-np.x, y=c[i].y-np.y;\n                    double nt=t+sqrt(x*x+y*y);\n                    int nst=stat|1<<i;\n                    bool isq=true;\n                    for (int j=0; j<n; j++) {\n                        if ((nst>>j&1)&&len[j]<=nt) {\n                            isq=false;\n                            break;\n                        }\n                    }\n                    if (isq) que.push(bfp(nt,make_pair(nst,P(c[i].x,c[i].y))));\n                }\n            }\n            if (flag) {\n                res=true;\n            }\n        }\n        if (res) puts(\"YES\");\n        else puts(\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<string.h>\nusing namespace std;\n\nint n,dx,dy,hx,hy;\nbool done[20];\nint cx[20],cy[20];\n\ndouble calc(int x1,int y1,int x2,int y2){\n\treturn sqrt((double)(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nbool dfs(int x,int y,double time,int k){\n\tif(time>=calc(x,y,dx,dy)) return false;\n\tif(k==n) return true;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(done[i]) continue;\n\t\tif(time+calc(x,y,cx[i],cy[i])>=calc(cx[i],cy[i],dx,dy)) return false;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tif(done[i]) continue;\n\t\tif(dfs(cx[i],cy[i],time+calc(cx[i],cy[i],x,y),k+1)) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin>>n>>hx>>hy>>dx>>dy && n!=0){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>cx[i]>>cy[i];\n\t\tmemset(done,false,sizeof(done));\n\t\tif(dfs(hx,hy,0.0,0)) cout<<\"YES\\n\";\n\t\telse cout<<\"NO\\n\";\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint n;\nint x[20],y[20];\nint sx,sy,mx,my;\nbool c[20];\nbool f(int u,double d)\n{\n\tint cnt=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(c[i])\n\t\t{\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble a=hypot(x[u]-x[i],y[u]-y[i])+d;\n\t\tdouble b=hypot(mx-x[i],my-y[i]);\n\t\tif(b>a)\n\t\t{\n\t\t\tc[i]=1;\n\t\t\tif(f(i,a))return true;\n\t\t\tc[i]=0;\n\t\t}\n\t\telse return false;\n\t}\n\treturn cnt==n;\n}\nmain()\n{\n\twhile(cin>>n>>sx>>sy>>mx>>my,n)\n\t{\n\t\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n\t\tfor(int i=0;i<n;i++)c[i]=0;\n\t\tbool fl=0;\n\t\tfor(int i=0;!fl&&i<n;i++)\n\t\t{\n\t\t\tdouble a=hypot(sx-x[i],sy-y[i]);\n\t\t\tdouble b=hypot(mx-x[i],my-y[i]);\n\t\t\tif(a<b)\n\t\t\t{\n\t\t\t\tc[i]=1;\n\t\t\t\tfl|=f(i,a);\n\t\t\t\tc[i]=0;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tcout<<(fl?\"YES\":\"NO\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 5/26 19:25 ~ 5/28 11:58\n * Status: Wrong Answer\n */\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint iN;\nint iHx;\nint iHy;\nint iDx;\nint iDy;\nint iCx[20];\nint iCy[20];\ndouble dCd[20];\n\n// ú»\nvoid init() {\n}\n\ndouble getDis(double x1, double y1, double x2, double y2) {\n  return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n}\n\n// üÍ + I¹»è\nbool input() {\n  int i;\n\n  // üÍ + I¹»è\n  scanf(\"%d %d %d %d %d\", &iN, &iHx, &iHy, &iDx, &iDy);\n  if (iN == 0 && iHx == 0 && iHy == 0 && iDx == 0 && iDy == 0)\n    return false;\n  for (i = 0; i < iN; i++) {\n    scanf(\"%d %d\", &iCx[i], &iCy[i]);\n    dCd[i] = getDis(iCx[i], iCy[i], iDx, iDy);\n  }\n  return true;\n}\n\nvoid pri(bool nFlag[]) {\n  int i;\n  for (i = 0; i < iN; i++) {\n    printf(\"%d \", nFlag[i]);\n  }\n  printf(\"\\n\");\n}\n// ÄAÄÑoµ\nbool recur(bool nFlag[], double sum) {\n  int i;\n  double minD, maxH;\n\n  //pri(nFlag);\n  for (i = 0; i < iN; i++) {\n    if (!nFlag[i]) {\n      break;\n    }\n  }\n  if (i == iN)\n    return true;\n  minD = 2000000.0; // INF\n  maxH = -2000000.0; // -INF\n  for (i = 0; i < iN; i++) {\n    if (nFlag[i])\n      continue;\n    /*\n     if (minD > dCd[i]) {\n     minD = dCd[i];\n     }\n     if (maxH < getDis(iCx[i], iCy[i], iHx, iHy) + sum) {\n     maxH = getDis(iCx[i], iCy[i], iHx, iHy) + sum;\n     }\n     */\n    if (minD > dCd[i]) {\n      minD = dCd[i];\n      maxH = getDis(iCx[i], iCy[i], iHx, iHy) + sum;\n    }\n  }\n  //printf(\"%f >= %f\\n\", maxH, minD);\n  if (maxH >= minD) {\n    return false;\n  }\n  //\n  for (i = 0; i < iN; i++) {\n    int tmpx, tmpy;\n    if (nFlag[i])\n      continue;\n    nFlag[i] = true;\n    tmpx = iHx;\n    iHx = iCx[i];\n    tmpy = iHy;\n    iHy = iCy[i];\n    if (recur(nFlag, sum + getDis(iCx[i], iCy[i], tmpx, tmpy))) {\n      return true;\n    }\n    nFlag[i] = false;\n    iHx = tmpx;\n    iHy = tmpy;\n  }\n  //printf(\"sum:%f\\n\", sum);\n  return false;\n}\n\n// \nvoid manage() {\n  bool nFlag[iN];\n\n  fill(nFlag, nFlag + iN, false);\n\n  if (recur(nFlag, 0.0)) {\n    printf(\"YES\\n\");\n  } else {\n    printf(\"NO\\n\");\n  }\n}\n\n// mainÖÍCÂlIÉSâè¤Ê\nint main() {\n  init(); // ú»\n  while (true) {\n    if (!input()) // üÍ + I¹»è\n      break; // I¹\n    manage(); // \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 20;\nconst double inf = 1e100;\nconst double eps = 1e-8;\n\n\nstruct State {\n  char p;\n  int c;\n  double time;\n  bool operator < (const State &s) const {\n    return time > s.time;\n  }\n};\n\nint N;\nP H, D;\nvector<P> ps;\nbool vis[1<<MAXN][MAXN+1];\ndouble border[1<<MAXN];\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, P p) {\n  double d = abs(D - p);\n  return !equals(d, t) && d > t;\n}\n\nvoid makeBorder() {\n  for(int i = 0; i < (1<<N); ++i) {\n    border[i] = inf;\n    for(int j = 0; j < N; ++j) {\n      if(i & (1<<j)) continue;\n      border[i] = min(border[i], abs(D - ps[i]));\n    }\n  }\n}\n\nbool dijkstra() {\n  priority_queue<State> que;\n  State s = (State){N, 0, 0.0};\n  fill(vis[0], vis[1<<MAXN], false);\n  que.push(s);\n  while(!que.empty()) {\n    s = que.top();\n    que.pop();\n    if(vis[s.c][s.p]) continue;\n    vis[s.c][s.p] = true;\n    if(s.c == (1<<N)-1) {\n      return true;\n    }\n    for(int k = 0; k < N; ++k) {\n      if(s.c & (1<<k)) continue;\n      const P &p = (s.p == N) ? H : ps[s.p];\n      const P &q = ps[k];\n      double dist = abs(q - p);\n      double nt = s.time + dist;\n      if(!canExist(nt, q)) continue;\n      State t = (State){k, s.c|(1<<k), nt};\n      if(vis[t.c][t.p]) continue;\n      if(t.time > border[t.c]+eps) continue;\n      que.push(t);\n    }\n  }\n  return false;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy && \n\t( N | hx | hy | dx | dy ) ) {\n    H = P(hx,hy);\n    D = P(dx,dy);\n    ps.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    makeBorder();\n    if(dijkstra()) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define INF (1<<30)\n#define EPS (double)(1e-5)\nusing namespace std;\nint n,hx,hy,dx,dy;\nint cx[22],cy[22];\n\ndouble L(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nbool solve(int m,int bit,double l){\n  if(bit == (1<<n)-1) return true;\n  for(int i = 1; i < n; i++){\n    if(bit&(1<<i))continue;\n    if( L(cx[m]-cx[i],cy[m]-cy[i]) + l + EPS > L(cx[i]-dx,cy[i]-dy)) return false;\n    if(solve(i,bit|(1<<i),l+L(cx[m]-cx[i],cy[m]-cy[i]))) return true;\n  }\n  return false;\n}\n\nint main(void){\n  while(cin >> n >> cx[0] >> cy[0] >> dx >> dy && n){\n    n++;\n    for(int i = 1; i < n; i++){\n      cin >> cx[i] >> cy[i];\n    }\n    if( solve(0,1,0) ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nint n,dx,dy,hx,hy;\nint cx[20],cy[20];\nint dp[1<<20][21];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n+hx+hy+dx+dy==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t\tcx[n]=hx,cy[n]=hy;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0][n]=0;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<1<<n;i++){\n\t\t\tif(flag)continue;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif(dp[i][j]!=-1){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif((i>>k) & 1)continue;\n\t\t\t\t\t\tint move=abs(cx[j]-cx[k])+abs(cy[j]-cy[k]);\n\t\t\t\t\t\tint ng=abs(dx-cx[k])+abs(dy-cy[k]);\n\t\t\t\t\t\tif(dp[i][j]+move>=ng)continue;\t\n\t\t\t\t\t\tdp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],dp[i][j]+move);\n\t\t\t\t\t\tif(dp[i|(1<<k)][k]==-1)dp[i|(1<<k)][k]=dp[i][j]+move;\n\t\t\t\t\t\tif(i|(1<<k)==(1<<n)-1)flag=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-12;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \nclass P{\npublic:\n\tdouble x,y;\n\tP(double a,double b){x = a, y = b;};\n};\nclass NODE{\npublic:\n\tint pos,done;\n\tdouble cost;\n\tNODE(int p,double c,int w){\n\t\tpos = p,cost = c;\n\t\tdone = w;\n\t};\n\t\n};\nbool operator<(const NODE&a,const NODE&b){\n\treturn a.cost > b.cost;\n}\n\nvector<vector<bool> > done(1<<20,vector<bool>(20));\n\ndouble dist(P a, P b){\n\ta.x-=b.x , a.y -= b.y;\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\nstring solve(int n, P h, P d, vector<P> item){\n\tpriority_queue<NODE> Q;\n\t\n\trep(i,n){\n\t\tQ.push(NODE(i,dist(h,item[i]),(1<<i)));\n\t}\n\t\n\trep(i,1<<n)rep(j,n)done[i][j] = false;\n\t\n\twhile(Q.size()){\n\t\tNODE q = Q.top(); Q.pop();\n\t\tif(done[q.done][q.pos])continue;\n\t\telse done[q.done][q.pos] = true;\n\t\tif(q.cost + EPS > dist(d,item[q.pos]) )continue;// !!!!! EPS !!!!!\n\t\tif(q.done == (1<<n)-1){\n\t\t\treturn \"YES\";\n\t\t}\n\t\trep(i,n){\n\t\t\tif(i & q.done)continue;\n\t\t\tQ.push(NODE(i, q.cost + dist(item[q.pos],item[i]) , q.done | (1<<i) ));\n\t\t}\n\t}\n\treturn \"NO\";\n}\n\nint main(){\n\tint n,x,y;\n\tP h(0,0) , d(0,0);\n\twhile(cin >> n >> h.x >> h.y >> d.x >> d.y , n){\n\t\tvector<P> data;\n\t\trep(i,n)cin >> x >> y , data.push_back(P(x,y));\n\t\tcout << solve(n,h,d,data) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\n#define EPS 1e-9 //許容される誤差の程度\n\nint n;\ndouble hx, hy, dx, dy;\ndouble cry[2][1000];\nbool visit[1000];\n\nbool solve(int crynum, double radius, double x, double y)\n{\n\tif(crynum >= n){\n\t\treturn true;\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tif(!visit[i]\n\t\t\t&&( hypot(cry[0][i]-dx, cry[1][i]-dy) < radius + hypot(cry[0][i]-x, cry[1][i]-y) + EPS))\n\t\t\treturn false;\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\n\t\tbool res = false;\n\t\t\n\t\tif(!visit[i]){\n\t\t\tvisit[i] = true;\n\t\t\tres = solve(crynum+1, radius + hypot(cry[0][i]-x, cry[1][i]-y), cry[0][i], cry[1][i]);\n\t\t\tvisit[i] = false;\n\t\t}\n\t\t\n\t\tif(res)\n\t\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> n >> hx >> hy >> dx >> dy, n){\n\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tcry[0][i] = x;\n\t\t\tcry[1][i] = y;\n\t\t}\n\t\t\n\t\tmemset(visit, false, sizeof(visit));\n\t\tcout << (solve(0, 0, hx, hy)?\"YES\":\"NO\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< double , Pi > Pii;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 55;\n\nint main(){\n  int n, hx, hy, dx, dy;\n  vector< int > near(1 << 20);\n  for(int i = 0; i < 1 << 20; i++){\n    for(int k = 0; k < 20; k++){\n      if((i >> k) & 1) continue;\n      near[i] = k;\n      break;\n    }\n  }\n  while(cin >> n >> hx >> hy >> dx >> dy, n|hx|hy|dx|dy){\n\n    vector< Pii > c(n);\n    for(int i = 0; i < n; i++){\n      cin >> c[i].sc.fr >> c[i].sc.sc;\n      c[i].fr = sqrt( pow( dx - c[i].sc.fr, 2) + pow( dy - c[i].sc.sc, 2));\n    }\n    sort( ALL(c));\n\n    vector< vector< double > > dp(1 << n, vector< double >( n, 1e9));\n    for(int i = 0; i < n; i++){\n      double dist = sqrt(pow(hx - c[i].sc.fr, 2) + pow(hy - c[i].sc.sc, 2));\n      if(dist < sqrt(pow(dx - c[i].sc.fr, 2) + pow(dy - c[i].sc.sc, 2))){\n        dp[1 << i][i] = dist;\n      }\n    }\n\n    for(int i = 0; i < (1 << n) - 1; i++){\n      for(int j = 0; j < n; j++){ //前のクリスタル\n        if(!((i >> j) & 1) || dp[i][j] == 1e9) continue;\n        if(sqrt( pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) >= dp[i][j]) continue;\n        for(int k = 0; k < n; k++){\n          if((i >> k) & 1) continue;\n          double next = dp[i][j] + sqrt(pow( c[j].sc.fr - c[k].sc.fr, 2) + pow( c[j].sc.sc - c[k].sc.sc, 2));\n          if(next >= dp[i|(1 << k)][k]) continue;\n          //条件に合えば次へ進む\n          bool check = sqrt(pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) > next;\n          if(check) dp[i|(1 << k)][k] = next;\n        }\n      }\n    }\n\n    bool check = n == 0;\n    for(int i = 0; i < n; i++){\n      check |= dp[(1 << n) - 1][i] < 1e9;\n    }\n    if(check) cout << \"YES\" << endl;\n    else cout <<\"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 55;\n\nint main(){\n  int n, hx, hy, dx, dy;\n  while(cin >> n >> hx >> hy >> dx >> dy, n|hx|hy|dx|dy){\n\n    vector< Pii > c(n);\n    for(int i = 0; i < n; i++){\n      cin >> c[i].sc.fr >> c[i].sc.sc;\n    }\n\n    vector< vector< double > > dp(1 << n, vector< double >( n, 1e9));\n    for(int i = 0; i < n; i++){\n      double dist = sqrt(pow(hx - c[i].sc.fr, 2) + pow(hy - c[i].sc.sc, 2));\n      if(dist < sqrt(pow(dx - c[i].sc.fr, 2) + pow(dy - c[i].sc.sc, 2))){\n        dp[1 << i][i] = dist;\n      }\n    }\n    for(int i = 0; i < (1 << n) - 1; i++){\n      for(int j = 0; j < n; j++){ //前のクリスタル\n        if(!((i >> j) & 1) || dp[i][j] == 1e9) continue;\n        for(int k = 0; k < n; k++){\n          if((i >> k) & 1) continue;\n          double next = dp[i][j] + sqrt(pow( c[j].sc.fr - c[k].sc.fr, 2) + pow( c[j].sc.sc - c[k].sc.sc, 2));\n          if(next >= dp[i|(1 << k)][k]) continue;\n          //条件に合えば次へ進む\n          bool check = true;\n          for(int l = 0; l < n; l++){\n            if((i >> l) & 1) continue;\n            check &= sqrt(pow( dx - c[l].sc.fr, 2) + pow( dy - c[l].sc.sc, 2)) > next;\n          }\n          if(check) dp[i|(1 << k)][k] = next;\n        }\n      }\n    }\n\n    bool check = n == 0;\n    for(int i = 0; i < n; i++){\n      check |= dp[(1 << n) - 1][i] < 1e9;\n    }\n    if(check) cout << \"YES\" << endl;\n    else cout <<\"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint cx[20],cy[20];\ndouble lim[20];\ndouble dd[20][20];\nbool memo[20][1<<20];\n\n#define DBL(x) ((x)*(x))\n\ninline double dist(int x1, int y1, int x2, int y2){\n  return sqrt(DBL(x1-x2) + DBL(y1-y2));\n}\n\ninline int b2i(unsigned int bit){\n  int ans=0;\n  if(!(bit&0x0000FFFF)){ans+=16;bit>>=16;}\n  if(!(bit&0x000000FF)){ans+= 8;bit>>= 8;}\n  if(!(bit&0x0000000F)){ans+= 4;bit>>= 4;}\n  if(!(bit&0x00000003)){ans+= 2;bit>>= 2;}\n  if(!(bit&0x00000001)){ans+= 1;         }\n  return ans;\n}\n\nint main(){\n  while(true){\n    int n,hx,hy,dx,dy;\n    n = getInt(); hx = getInt(); hy = getInt();\n    dx = getInt(); dy = getInt();\n    if(!(n+hx+hy+dx+dy)) break;\n    memset(memo, 0, sizeof(memo));\n    REP(i,n){ cx[i] = getInt(); cy[i] = getInt(); }\n    REP(i,n){ lim[i] = dist(dx,dy,cx[i],cy[i]); }\n    REP(i,n) REP(j,n) dd[i][j] = dist(cx[i],cy[i],cx[j],cy[j]);\n\n    bool ans = false;\n\n    typedef pair<double,pair<int,int> > data;\n    priority_queue<data,vector<data>,greater<data> > pq;\n\n    REP(i,n) pq.push(mp(dist(hx,hy,cx[i],cy[i]), mp(i, (((1<<n)-1)^(1<<i)))));\n\n    while(pq.size()){\n      data d = pq.top(); pq.pop();\n      double time = d.f;\n      int pos = d.s.f;\n      int f = d.s.s;\n\n      //printf(\"solve(%d,%d,%f) : lim = %f\\n\",pos,f,time,lim[pos]);\n      if(time + 1e-10 >= lim[pos]) continue;\n      if(memo[pos][f]) continue;\n      if(f == 0){\n        ans = true;\n        break;\n      }\n\n      memo[pos][f] = true;\n\n      while(f){\n        int ff = f & (-f);\n        int next = b2i(ff);\n        f ^= ff;\n        pq.push(mp(time + dd[pos][next], mp(next, f)));\n      }\n    }\n\n    puts(ans ? \"YES\" : \"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint cx[20],cy[20];\ndouble lim[20];\ndouble dd[20][20];\nbool memo[20][1<<20];\n\n#define DBL(x) ((x)*(x))\n\ninline double dist(int x1, int y1, int x2, int y2){\n  return sqrt(DBL(x1-x2) + DBL(y1-y2));\n}\n\ninline int b2i(unsigned int bit){\n  int ans=0;\n  if(!(bit&0x0000FFFF)){ans+=16;bit>>=16;}\n  if(!(bit&0x000000FF)){ans+= 8;bit>>= 8;}\n  if(!(bit&0x0000000F)){ans+= 4;bit>>= 4;}\n  if(!(bit&0x00000003)){ans+= 2;bit>>= 2;}\n  if(!(bit&0x00000001)){ans+= 1;         }\n  return ans;\n}\n\nint main(){\n  while(true){\n    int n,hx,hy,dx,dy;\n    n = getInt(); hx = getInt(); hy = getInt();\n    dx = getInt(); dy = getInt();\n    if(!(n+hx+hy+dx+dy)) break;\n    memset(memo, 0, sizeof(memo));\n    REP(i,n){ cx[i] = getInt(); cy[i] = getInt(); }\n    REP(i,n){ lim[i] = dist(dx,dy,cx[i],cy[i]); }\n    REP(i,n) REP(j,n) dd[i][j] = dist(cx[i],cy[i],cx[j],cy[j]);\n\n    bool ans = false;\n\n    typedef pair<double,pair<int,int> > data;\n    priority_queue<data,vector<data>,greater<data> > pq;\n\n    REP(i,n) pq.push(mp(dist(hx,hy,cx[i],cy[i]), mp(i, (((1<<n)-1)^(1<<i)))));\n\n    while(pq.size()){\n      data d = pq.top(); pq.pop();\n      double time = d.f;\n      int pos = d.s.f;\n      int f = d.s.s;\n\n      //printf(\"solve(%d,%d,%f) : lim = %f\\n\",pos,f,time,lim[pos]);\n      if(time + 1e-10 >= lim[pos]) continue;\n      if(memo[pos][f]) continue;\n      if(f == 0){\n        ans = true;\n        break;\n      }\n\n      memo[pos][f] = true;\n\n      int tmpf = f;\n      while(f){\n        int ff = f & (-f);\n        int next = b2i(ff);\n        f ^= ff;\n        if(!memo[next][tmpf^ff]) pq.push(mp(time + dd[pos][next], mp(next, tmpf^ff)));\n      }\n    }\n\n    puts(ans ? \"YES\" : \"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\nint n,h,w,d,e,x,y;\ndouble k;\ndouble j(int f,int g){return sqrt(f*f+g*g+0.0);}\nint main(){\n\twhile(1){\n\tcin>>n>>x>>y>>d>>e;\n\tif(!n)break;\n\tcin>>h>>w;\n\tbool o=(k<j(d-x,e-y));\n\tn--,k=j(h-x,w-y);\n\twhile(n--){\n\t\tcin>>x>>y;\n\t\tif(k+j(h-x,w-y)>=j(d-x,e-y))o=0;\n\t}\n\tif(o)cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define INF 1<<30\n#define EPS 1e-5\nusing namespace std;\nint n,hx,hy,dx,dy;\nint cx[22],cy[22];\n\ndouble L(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nfloat dp[21][1<<20];\ndouble solve(int m,int bit){\n  if(bit == (1<<n)-1) return L(cx[m]-hx,cy[m]-hy);\n  if(dp[m][bit] > 0) return dp[m][bit];\n\n  double ret = INF;\n  for(int i = 0; i < n; i++){\n    if(bit&(1<<i)) continue;\n    double l = solve(i,bit|(1<<i));\n    if(m < n) l += L(cx[m]-cx[i],cy[m]-cy[i]);\n    if(l+EPS < L(cx[i]-dx,cy[i]-dy)) ret = min(ret,l);\n  }\n  return dp[m][bit] = ret;\n}\n\nint main(void){\n  while(cin >> n >> hx >> hy >> dx >> dy && n){\n    for(int i = 0; i < n; i++){\n      cin >> cx[i] >> cy[i];\n    }\n    for(int j = 0; j < 21; j++){\n      for(int i = 0; i < 1<<20; i++){\n\tdp[j][i] = -1;\n      }\n    }\n    if(solve(n,0) > 1<<28) cout << \"NO\" << endl;\n    else cout << \"YES\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct { int x, y; } pt;\n\nint n;\npt hero, dragon;\n\ndouble eps = 1e-6;\n\nvector<pt> targets;\n\ndouble dist(pt& a, pt& b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\nbool nearer_from_hero(pt& a, pt& b) {\n    return dist(a, hero) < dist(b, hero);\n}\n\nbool can_visit(double d, map<int, bool>& visited, int k) {\n    // cerr << \"VISIT d=\" << d << \" k=\" << k << endl;\n\n    if (d >= dist(targets[k], dragon)) {\n        // cerr << \"NG \" << d << \" \" << targets[k].x << \",\" << targets[k].y << \" \" << dragon.x << \",\" << dragon.y << endl;\n        return false;\n    }\n\n    bool all_visited = true;\n    bool ok = false;\n\n    for (int i = 1; i <= n; ++i) {\n        if (i == k || visited[i]) {\n            continue;\n        }\n\n        all_visited = false;\n\n        visited[i] = true;\n        double delta = dist(targets[i], targets[k]);\n        if (can_visit(d + delta, visited, i)) {\n            ok = true;\n        }\n        visited[i] = false;\n        if (ok) break;\n    }\n\n    return all_visited || ok;\n}\n\nbool nearer_dragon(pt a, pt b) {\n    return dist(a, dragon) < dist(b, dragon);\n}\n\nint main() {\n    while (true) {\n        cin >> n >> hero.x >> hero.y >> dragon.x >> dragon.y;\n        if (n == 0) break;\n\n        bool ng = false;\n        targets.clear();\n\n        int s = 0;\n        map< pair<int, int>, bool > seen;\n        for (int i = 0; i < n; ++i) {\n            pt t;\n            cin >> t.x >> t.y;\n            if (seen[make_pair(t.x, t.y)]) {\n                s++;\n                continue;\n            }\n\n            seen[make_pair(t.x, t.y)] = true;\n\n            if (dist(t, hero) >= dist(t, dragon) - eps) {\n                ng = true;\n            }\n\n            targets.push_back(t);\n        }\n        // sort(targets.begin(), targets.end(), nearer_from_hero);\n        targets.insert(targets.begin(), hero);\n\n        n -= s;\n\n        map<int, bool> v;\n        for (int i = 0; i <= n; ++i) {\n            v[i] = false;\n        }\n        cout << (!ng && can_visit(0, v, 0) ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nint n,dx,dy,hx,hy;\nint cx[20],cy[20];\nint dp[1<<20][21];\nclass data{\npublic:\n\tint bit,v,cost;\n\tdata(int ibit,int iv,int icost){\n\t\tbit=ibit;\n\t\tv=iv;\n\t\tcost=icost;\n\t}\n\n\tbool operator<(const data& d1)const{\n\t\treturn d1.cost<cost;\n\t}\n};\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n+hx+hy+dx+dy==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t\tcx[n]=hx,cy[n]=hy;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0][n]=0;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<1<<n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif(dp[i][j]!=-1){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif((i>>k) & 1)continue;\n\t\t\t\t\t\tint move=abs(cx[j]-cx[k])+abs(cy[j]-cy[k]);\n\t\t\t\t\t\tint ng=abs(dx-cx[k])+abs(dy-cy[k]);\n\t\t\t\t\t\tif(dp[i][j]+move>=ng)continue;\t\n\t\t\t\t\t\tdp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],dp[i][j]+move);\n\t\t\t\t\t\tif(dp[i|(1<<k)][k]==-1)dp[i|(1<<k)][k]=dp[i][j]+move;\n\t\t\t\t\t\tif(i|(1<<k)==(1<<n)-1)flag=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<map>\n\nusing namespace std;\nint n,dx,dy,hx,hy;\nint cx[20],cy[20];\nbool used[21];\nbool flag;\nvoid dfs(int v,int cnt,int cost){\n\tif(cnt==n)flag=true;\n\tif(flag)return;\n\tfor(int i=0;i<v;i++){\n\t\tif(!used[i]){\n\t\t\tint move=abs(cx[v]-cx[i])+abs(cy[v]-cy[i]);\n\t\t\tint ng=abs(dx-cx[i])+abs(dy-cy[i]);\n\t\t\tif(cost+move<ng){\n\t\t\t\tused[i]=true;\n\t\t\t\tdfs(i,cnt+1,cost+move);\n\t\t\t\tused[i]=false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n+hx+hy+dx+dy==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t\tcx[n]=hx,cy[n]=hy;\n\t\tflag=false;\n\t\tdfs(n,0,0);\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<map>\n\nusing namespace std;\nint n,dx,dy,hx,hy;\nint cx[21],cy[21];\nbool used[21];\nbool flag;\nvoid dfs(int v,int cnt,int cost){\n\tif(cnt==n)flag=true;\n\tif(flag)return;\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tint move=abs(cx[v]-cx[i])+abs(cy[v]-cy[i]);\n\t\t\tint ng=abs(dx-cx[i])+abs(dy-cy[i]);\n\t\t\tif(cost+move>=ng)return;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tint move=abs(cx[v]-cx[i])+abs(cy[v]-cy[i]);\n\t\t\tused[i]=true;\n\t\t\tdfs(i,cnt+1,cost+move);\n\t\t\tused[i]=false;\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n+hx+hy+dx+dy==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t\tcx[n]=hx,cy[n]=hy;\n\t\tflag=false;\n\t\tdfs(n,0,0);\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 20\n#define EPS 1e-9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX];\nbool rec(int now, double total_dist, int depth){\n  if(total_dist >= dist(d, crystal[now])){\n    return false;\n  }\n  if(depth == N){\n    return true;\n  }\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      Segment s = Segment(crystal[now], crystal[i]);\n      if(s.distanceSP(d) < total_dist) return false;\n      used[i] = true;\n      if(rec(i, total_dist + dist(crystal[now],crystal[i]), depth+1)){\n        return true;\n      }\n      used[i] = false;\n    }\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    memset(used, false, sizeof(used));\n    if(rec(i, dist(h, crystal[i]), 0)){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nint n;\nVVD dp;\nVVB done;\nVVD dist;\nVD limit;\nvector<P> p_cristal;\n\ndouble euclid_distance(P p1, P p2)\n{\n\treturn sqrt(norm(p2 - p1));\n}\n\ndouble optimal_time(int status, int position)\n{\n\tif (done[status][position]) {\n\t\treturn dp[status][position];\n\t}\n\tif (!(status & BIT(position))) {\n\t\treturn INF;\n\t}\n\tint prev_status = status ^ BIT(position);\n\tif (prev_status == 0) {\n\t\t// Hero to this position\n\t\tdp[status][position] = dist[dist.size()-1][position];\n\t} else {\n\t\tFOR (prev_position, 0, n) {\n\t\t\tdp[status][position] = min(dp[status][position], optimal_time(prev_status, prev_position) + dist[prev_position][position]);\n\t\t}\n\t}\n\tdone[status][position] = true;\n\tif (dp[status][position] >= limit[position]) {\n\t\treturn dp[status][position] = INF;\n\t} else {\n\t\treturn dp[status][position];\n\t}\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n ^ hx ^ hy ^ dx ^ dy) {\n\t\tp_cristal.clear();\n\t\tREP (_, n) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tp_cristal.PB(P(x, y));\n\t\t}\n\t\tp_cristal.PB(P(hx, hy)); // NOTICE: Push Hero\n\t\tdist = VVD(p_cristal.size(), VD(p_cristal.size()));\n\t\tREP (i, p_cristal.size()) {\n\t\t\tREP (j, p_cristal.size()) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdist[i][j] = euclid_distance(p_cristal[i], p_cristal[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlimit = VD(p_cristal.size(), 0);\n\t\tREP (i, limit.size()) {\n\t\t\tlimit[i] = euclid_distance(p_cristal[i], P(dx, dy));\n\t\t}\n\n\t\tdp = VVD(BIT(n));\n\t\tdone = VVB(BIT(n), VB(n, false));\n\t\tFOR (c, 1, n) {\n\t\t\tif (c > 2) {\n\t\t\t\tint comb = (1 << (c-2)) - 1;\n\t\t\t\twhile (comb < 1 << n) {\n\t\t\t\t\t// Release memory\n\t\t\t\t\tdp[comb].clear();\n\t\t\t\t\tint lsb = comb & -comb;\n\t\t\t\t\tint upper = comb + lsb;\n\t\t\t\t\tint downer = ((comb & ~upper) / lsb) >> 1;\n\t\t\t\t\tcomb = upper | downer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint comb = (1 << c) - 1;\n\t\t\twhile (comb < 1 << n) {\n\t\t\t\tdp[comb].assign(n, INF);\n\t\t\t\tREP (p, n) {\n\t\t\t\t\toptimal_time(comb, p);\n\t\t\t\t}\n\t\t\t\tint lsb = comb & -comb;\n\t\t\t\tint upper = comb + lsb;\n\t\t\t\tint downer = ((comb & ~upper) / lsb) >> 1;\n\t\t\t\tcomb = upper | downer;\n\t\t\t}\n\t\t}\n\n\t\t// Check if possible\n\t\tint final_status = BIT(n) - 1;\n\t\tdp[final_status].assign(n, INF);\n\t\tdouble t_ans = INF;\n\t\tREP (p, n) {\n\t\t\tt_ans = min(t_ans, optimal_time(final_status, p));\n\t\t}\n\t\tif (t_ans != INF) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 20;\n\n/* typedef */\n\ntemplate <typename T>\nstruct Pt {\n  T x, y;\n\n  Pt() {}\n  Pt(T _x, T _y) : x(_x), y(_y) {}\n  Pt(const Pt& pt) : x(pt.x), y(pt.y) {}\n\n  Pt operator+(const Pt pt) const { return Pt(x + pt.x, y + pt.y); }\n  Pt operator-() const { return Pt(-x, -y); }\n  Pt operator-(const Pt pt) const { return Pt(x - pt.x, y - pt.y); }\n  Pt operator*(T t) const { return Pt(x * t, y * t); }\n  Pt operator/(T t) const { return Pt(x / t, y / t); }\n  T dot(Pt v) { return x * v.x + y * v.y; }\n  T cross(Pt v) { return x * v.y - y * v.x; }\n  Pt mid(const Pt pt) { return Pt((x + pt.x) / 2, (y + pt.y) / 2); }\n  T d2() { return x * x + y * y; }\n  double d() { return sqrt(d2()); }\n\n  Pt rot(double th) {\n    double c = cos(th), s = sin(th);\n    return Pt(c * x - s * y, s * x + c * y);\n  }\n\n  bool operator<(const Pt& pt) const {\n    return x < pt.x || (x == pt.x && y < pt.y);\n  }\n  \n  void print(string format) {\n    printf((\"(\" + format + \", \" + format + \")\\n\").c_str(), x, y);\n  }\n};\n\ntypedef Pt<double> pt;\n\n/* global variables */\n\nint n;\npt hpt, dpt;\npt pts[MAX_N + 1];\nbool used[MAX_N + 1];\ndouble ddists[MAX_N + 1], pdists[MAX_N + 1][MAX_N + 1];\n\n/* subroutines */\n\nbool rec(int k, int i, double t) {\n  //printf(\"rec(%d, %d, %f\\n\", k, i, t);\n  if (k == n) return true;\n\n  for (int j = 1; j <= n; j++)\n    if (! used[j]) {\n      double t0 = t + pdists[i][j];\n      if (t0 < ddists[j]) {\n\tused[j] = true;\n\tif (rec(k + 1, j, t0)) return true;\n\tused[j] = false;\n      }\n    }\n\n  return false;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n >> hpt.x >> hpt.y >> dpt.x >> dpt.y;\n    if (n == 0) break;\n\n    pts[0] = hpt;\n    for (int i = 1; i <= n; i++) cin >> pts[i].x >> pts[i].y;\n\n    for (int i = 0; i <= n; i++) {\n      ddists[i] = (pts[i] - dpt).d();\n      pdists[i][i] = 0.0;\n      for (int j = i + 1; j <= n; j++)\n\tpdists[i][j] = pdists[j][i] = (pts[i] - pts[j]).d();\n    }\n\n    memset(used, false, sizeof(used));\n    used[0] = true;\n    \n    int tf = rec(0, 0, 0.0);\n    cout << (tf ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef complex<double> P;\n\nP syoki, maou;\nP houseki[20];\nint n;\nvector<bool> v;\n\nbool rec(int now, double time) {\n  // REP(i,n) {\n  //   cout << v[i];\n  // }cout << endl;\n  // printf(\"now=%d, time=%f\\n\",now,time);\n  bool ff = 0;\n  REP(i,n) {\n    if (!v[i]) {\n//      cout << i << \" \" << abs(maou-houseki[i]) << \", \" << time+abs(houseki[i]-houseki[now]) << endl;\n      if (abs(maou-houseki[i]) <= time+abs(houseki[i]-houseki[now])) {\n        return false;\n      }\n      ff = 1;\n    }\n  }\n  if (!ff) {                    // ツ全ツ閉板づづつス\n    return true;\n  }\n\n  REP(i,n) {\n    if (!v[i]) {\n      v[i] = 1;\n      if (rec(i, time+abs(houseki[i]-houseki[now])))\n        return true;\n      v[i] = 0;\n      ff = 1;\n    }\n  }\n}\n\nint main() {\n  int hx,hy,dx,dy;\n  while(cin>>n>>hx>>hy>>dx>>dy,n||hx||hy||dx||dy) {\n    syoki = P(hx,hy);\n    maou = P(dx,dy);\n    REP(i,n) {\n      double x,y;\n      cin >> x >> y;\n      houseki[i] = P(x,y);\n    }\n    v = vector<bool>(n);\n    bool f = 0;\n    REP(i,n) {\n      v[i] = 1;\n      if (abs(houseki[i]-syoki) < abs(houseki[i]-maou))\n        if (rec(i, abs(houseki[i]-syoki))) {\n          f = 1;\n          break;\n        }\n      v[i] = 0;\n    }\n    if (f)\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\nint abs(int n){\n    if(n < 0)\n\t\tn = -1 * n;\n    return n;\n}\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 20], dp[1 << 20];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) \n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF; \n\t\tfor(i = 0;i < n;i++) \n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]); \n\t\tfor(i = 0;i < n;i++){ \n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){ \n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]); \n\t\t\t\tloc[1 << i] = i; \n\t\t\t} \n\t\t\telse  \n\t\t\t\tbreak; \n\t\t}  \n\t\tif(i != n){  \n\t\t\tprintf(\"NO\\n\"); \n\t\t\tcontinue;  \n\t\t}  \n\t\tfor(i = 0;i < 1 << n;i++){ \n\t\t\tif(dp[i] != INF){  \n\t\t\t\tfor(j = 0;j < n;j++){  \n\t\t\t\t\tif(i & 1 << j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j]) && dp[i ^ (1 << j)] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i]){ \n\t\t\t\t\t\tdp[i ^ (1 << j)] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];  \n\t\t\t\t\t\tloc[i ^ (1 << j)] = j; \n\t\t\t\t\t}  \n\t\t\t\t}  \n\t\t\t}  \n\t\t}   \n\t\tif(dp[(1 << n) - 1] != INF) \n\t\t\tprintf(\"YES\\n\");  \n\t\telse  \n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\nint n;\nint x,y,h1,h2,d1,d2,s1,s2;\n  \ndouble dist(int a, int b){\n    return sqrt(a*a+b*b+0.0);\n}  \nint main(){\n    while(1){\n\t\tbool ok=true;\n        cin >> n;\n        if(n == 0) break;\n        cin >>h1>>h2>>d1>>d2>>s1>>s2;\n\t\tif(dist(h1-s1,h2-s2)>= dist(d1-s1,d2-s2))ok=false;\n        for(int i=1;i<n;i++){\n            cin>>x>>y;\n\t\t\tif(dist(h1-s1,h2-s2)+dist(s1-x,s2-y) >= dist(d1-x,d2-y))ok=false;\n        }\n  \n        if(ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n#define EPS 1e-10\nint n;\ndouble sx,sy,tx,ty,px[20],py[20];\n\ndouble dis(double a,double b,double c,double d)\n{return sqrt((a-c)*(a-c)+(b-d)*(b-d));}\ndouble dis(int a,int b){return dis(px[a],py[a],px[b],py[b]);}\n\nbool dfs(int S,int pos,double cost){\n  if(S==(1<<n)-1)return true;\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(cost+dis(pos,i)>=dis(tx,ty,px[i],py[i]))return false;\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(cost+dis(pos,i)>=dis(tx,ty,px[i],py[i]))continue;\n    if( dfs(S|(1<<i),i,cost+dis(pos,i)) )return true;\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i=0;i<n;i++){\n    if( dfs((1<<i),i,dis(sx,sy,px[i],py[i])) )return true;\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin>>n>>sx>>sy>>tx>>ty;\n    if(n==0&&sx==0&&sy==0&&tx==0&&ty==0)break;\n    for(int i=0;i<n;i++)cin>>px[i]>>py[i];\n    cout<<(solve()?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<int(n); i++)\n#define pii pair<int,int>\n#define fs first\n#define sc second\n\ntypedef pair<pii,int> po;\n\nint n;\n\nbool cmp(po lhs, po rhs) {\n  if(lhs.sc!=rhs.sc) return lhs.sc<rhs.sc;\n  else return lhs.fs.fs<rhs.fs.fs;\n}\n\nbool rec(int bit, int t, const vector<po> c) {\n  rep(k,n){\n    if (t >= c[k].sc && (bit >> k)%2 == 1) return false; \n    else if (!rec(bit^(1<<k), t+1, c)) return false;\n  }\n  return true;\n}\n\nint main(){\n  int hx,hy,dx,dy,x,y;\n  while (cin>>n>>hx>>hy>>dx>>dy && n>0) {\n    vector<po> c(n);\n    rep(i,n){\n      cin >> x >> y;\n      c[i].fs.fs = x;\n      c[i].fs.sc = y;\n      c[i].sc = (x-dx)*(x-dx) + (y-dy)*(y-dy);\n    }\n    sort(c.begin(),c.end(),cmp);\n    int bit = (1<<(n+1))-1;\n    if(rec(bit,0,c)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble  cost[20][20];\nconst double INF = 10000000;\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if (visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  //\n  /*\n  visited[last]=false;\n  rep(i,n){\n    if (visited[i]==true)cost[i][i]=INF;\n    else cost[i][i]=0;\n    REP(j,i+1,n){\n      if (visited[i]==true ||visited[j]==true)cost[i][j]=cost[j][i]=INF;\n      else cost[i][j]=cost[j][i]=adj[i][j];\n    }\n  }\n  visited[last]=true;\n  rep(k,n)rep(i,n)rep(j,n)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n  rep(i,n)if( visited[i]==false && r+cost[last][i] >=adj[MAOU][i])return false;\n  */\n  //\n\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    if ( r+adj[last][i] < adj[MAOU][i]){\n      visited[i]=true;\n      if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n      visited[i]=false;\n    }//else return false;\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n  }\n  \n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i])+eps>dist(rx-x[i],ry-y[i]))return false;\n  }\n\n\n  bool visited[20]={false};\n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i]) < dist(rx-x[i],ry-y[i])){\n      visited[i]=true;\n      if ( backTrack(i,dist(mx-x[i],my-y[i]),1,n,visited))return true;\n      visited[i]=false;\n    }else return false;\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(cin>>n>>mx>>my>>rx>>ry && n){\n    int x[n],y[n];\n    rep(i,n)cin>>x[i]>>y[i];\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cmath>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,int> PD;\n#define EPS (1e-10)\n\nP map[20];\nbool done[20];\nint donenum;\nint N;\nint dx,dy;\nset<PD> distlist;\n\nvoid makedist(){\n     distlist.clear();\n     for(int i=0;i<N;i++){\n\t  double x=dx-map[i].first;\n\t  double y=dy-map[i].second;\n\t  distlist.insert(PD(sqrt(x*x+y*y),i));\n\t  //cout<<x*x+y*y<<endl;\n     }\n}\n\nbool dead(double time){\n     set<PD>::iterator itr=distlist.begin();\n     while(itr!=distlist.end()){\n\t  if(done[itr->second]){\n\t       itr++;\n\t       continue;\n\t  }\n\t  if(time<itr->first)return false;\n\t  return true;\n     }\n}\n\nbool rec(int n,int x,int y,double t){\n     //if(donenum==N)return true;\n     int nx=map[n].first;\n     int ny=map[n].second;\n     double dist=sqrt((nx-x)*(nx-x)+(ny-y)*(ny-y));\n     //cout<<dist<<endl;\n     if(dead(t+dist))return false;\n     done[n]=true;\n     ++donenum;\n     if(donenum==N)return true;\n     //cout<<n<<endl;\n     for(int i=0;i<N;i++){\n\t  if(done[i])continue;\n\t  if(rec(i,nx,ny,t+dist))return true;\n     }\n     done[n]=false;\n     --donenum;\n     return false;\n}\n\nint main(){\n     int hx,hy;\n     while(cin>>N>>hx>>hy>>dx>>dy,N||hx||hy||dx||dy){\n\t  if(N==0){\n\t       cout<<\"YES\"<<endl;\n\t  }\n\t  for(int i=0;i<N;i++){\n\t       done[i]=false;\n\t  }\n\t  donenum=0;\n\t  for(int i=0;i<N;i++){\n\t       int a,b;\n\t       cin>>a>>b;\n\t       map[i]=P(a,b);\n\t  }\n\t  makedist();\n\t  bool ok=false;\n\t  for(int i=0;i<N;i++){\n\t       if(rec(i,hx,hy,0)){\n\t\t    ok=true;\n\t\t    break;\n\t       }\n\t  }\n\t  if(ok)cout<<\"YES\"<<endl;\n\t  else cout<<\"NO\"<<endl;\n     }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cfloat>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <unordered_map>\n \nusing namespace std;\n \n#define fi first\n#define se second\ntypedef pair<double,double> P;\n \n#define MAX (21)\n#define INF (DBL_MAX/4)\n \ndouble G[MAX][MAX];\n \nint n;\nvector<P> crys;\nP h, d;\n \ndouble dist(P p1, P p2){\n  return sqrt(pow(p1.fi-p2.fi, 2.) + pow(p1.se-p2.se, 2.));\n}\n \nvoid makeEdge() {\n  for(int i=0; i<n; i++) {\n    G[i][i] = 0;\n    for(int j=i+1; j<n; j++) {\n      G[i][j] = G[j][i] = dist(crys[i], crys[j]);\n    }\n  }\n}\n \n//map<ull, double> dp;\nunordered_map<int, double> dp;\n\nbool dfs(int S, int idx, double cost) {\n  \n  if(S==(1<<n)-1) {\n    return true;\n  }\n  \n  dp[S] = cost;\n  \n  for(int i=0; i<n; i++) {\n    if((S>>i)&1) continue;\n    if(cost + G[idx][i] >= dist(crys[i], d)) return false;\n  }\n  \n  for(int i=0; i<n; i++){\n    if((S>>i)&1) continue;\n    double ncost = cost + G[idx][i];\n    double nS = S|(1<<i);\n    if(ncost >= dist(crys[i], d)) return false;\n    else {\n      if(dp.count(nS) && dp[nS] < ncost) continue;\n      if(dfs(nS, i, ncost)) return true;\n    }\n  }\n  \n  return false;\n}\n \nbool solve() {\n   \n  makeEdge();\n  \n  dp.clear();\n  for(int i=0; i<n; i++) {\n    if(dist(h, crys[i]) >= dist(crys[i], d)) continue;\n    if(dfs(1<<i, i, dist(h, crys[i]))) {\n      return true;\n    }\n  }\n  return false;\n}\n \nint main(){\n  while(true){\n    crys.clear();\n    cin >> n >> h.fi >> h.se >> d.fi >> d.se;\n    if(!n && !h.fi && !h.se && !d.fi && !d.se){\n      break;\n    }\n    crys.resize(n);\n    for(int i=0; i<n; i++){\n      cin >> crys[i].fi >> crys[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n}; \n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool ok;\n\nvoid rec(int S, int v, double total_dist){\n  if(ok) return;\n\n  if(S == (1 << N) - 1){\n    ok = true;\n    return;\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1)){\n      if(total_dist + dist(crystal[v],crystal[u]) >= dist(d, crystal[u])){\n\treturn;\n      }\n    }\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1) && !ok){\n      rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]));\n    }\n  }\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    ok = false;\n    rec(0, i, dist(h, crystal[i]));\n    if(ok){\n      return true;\n    }\n  }  \n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *  Author: mizo0203\n *  Problem: 2008\n *  Status: Time Limit Exceeded\n *  Submission Date: 2012/04/14 23:23:19\n *\n *  方策：再帰関数による幅優先探索\n */\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint n; // (0 < n <= 20)\nint hx, hy, dx, dy;\nint cx[20], cy[20]; // (-1000 <= h, d, c <= 1000)\n\nvoid init() {\n}\n\nbool input() {\n  int i;\n\n  scanf(\"%d %d %d %d %d\", &n, &hx, &hy, &dx, &dy);\n  if (!n && !hx && !hy && !dx && !dy)\n    return false;\n  for (i = 0; i < n; i++)\n    scanf(\"%d %d\", &cx[i], &cy[i]);\n\n  return true;\n}\n\n// sum: 勇者の総移動距離^2 == 瘴気の半径^2\nbool recursive(int m, long l, int x, int y, double sum) {\n  int i;\n  double dis;\n\n  /*\n   for (i = 0; i < n; i++) {\n   if (l & 1 << i)\n   printf(\"1\");\n   else\n   printf(\"0\");\n   }\n   printf(\" %ld\\n\", l);\n   */\n\n  if (n == m)\n    return true;\n\n  for (i = 0; i < n; i++) {\n    if (l & 1 << i)\n      continue;\n    dis = sqrt(pow(cx[i] - x, 2) + pow(cy[i] - y, 2));\n    //printf(\"%f %f\\n\", sum + dis, sqrt(pow(cx[i] - dx, 2) + pow(cy[i] - dy, 2)));\n    if (sum + dis >= sqrt(pow(cx[i] - dx, 2) + pow(cy[i] - dy, 2)))\n      continue;\n    if (recursive(m + 1, l |= 1 << i, cx[i], cy[i], sum + dis))\n      return true;\n  }\n\n  return false;\n}\n\nint main() {\n  int i;\n\n  init();\n  while (input()) {\n    int pmt[20];\n    // [0, 1, 2, ....]というサイズnの配列を作成\n    for (i = 0; i < n; i++)\n      pmt[i] = i;\n    // 全ての順列を出力\n    if (recursive(0, 0, hx, hy, 0))\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 20;\nconst double inf = 1e100;\nconst double eps = 1e-8;\n\n\nstruct State {\n  int p;\n  int c;\n  double time;\n  bool operator < (const State &s) const {\n    return time > s.time;\n  }\n};\n\nint N;\nP H, D;\nvector<P> ps;\nbool vis[1<<MAXN][MAXN+1];\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, P p) {\n  double d = abs(D - p);\n  return !equals(d, t) && d > t;\n}\n\nbool dijkstra() {\n  priority_queue<State> que;\n  State s = (State){N, 0, 0.0};\n  fill(vis[0], vis[1<<MAXN], false);\n  que.push(s);\n  while(!que.empty()) {\n    s = que.top();\n    que.pop();\n    if(vis[s.c][s.p]) continue;\n    vis[s.c][s.p] = true;\n    if(s.c == (1<<N)-1) {\n      return true;\n    }\n    for(int k = 0; k < N; ++k) {\n      if(s.c & (1<<k)) continue;\n      const P &p = (s.p == N) ? H : ps[s.p];\n      const P &q = ps[k];\n      double dist = abs(q - p);\n      double nt = s.time + dist;\n      if(!canExist(nt, q)) continue;\n      State t = (State){k, s.c|(1<<k), nt};\n      if(vis[t.c][t.p]) continue;\n      que.push(t);\n    }\n  }\n  return false;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy && \n\t( N | hx | hy | dx | dy ) ) {\n    H = P(hx,hy);\n    D = P(dx,dy);\n    ps.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(dijkstra()) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< double , Pi > Pii;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 55;\n\nint main(){\n  int n, hx, hy, dx, dy;\n  vector< char > near(1 << 20);\n  double dp[1 << 20][20];\n\n  for(int i = 0; i < 1 << 20; i++){\n    for(int k = 0; k < 20; k++){\n      if((i >> k) & 1) continue;\n      near[i] = k;\n      break;\n    }\n  }\n  while(cin >> n >> hx >> hy >> dx >> dy, n|hx|hy|dx|dy){\n\n    vector< Pii > c(n);\n    for(int i = 0; i < n; i++){\n      cin >> c[i].sc.fr >> c[i].sc.sc;\n      c[i].fr = sqrt( pow( dx - c[i].sc.fr, 2) + pow( dy - c[i].sc.sc, 2));\n    }\n    sort( ALL(c));\n\n    fill_n( *dp, (1 << 20) * 20, 1e9);\n    for(int i = 0; i < n; i++){\n      double dist = sqrt(pow(hx - c[i].sc.fr, 2) + pow(hy - c[i].sc.sc, 2));\n      if(dist < sqrt(pow(dx - c[i].sc.fr, 2) + pow(dy - c[i].sc.sc, 2))){\n        dp[1 << i][i] = dist;\n      }\n    }\n\n    for(int i = 0; i < (1 << n) - 1; i++){\n      for(int j = 0; j < n; j++){ //前のクリスタル\n        if(!((i >> j) & 1) || dp[i][j] == 1e9) continue;\n        if(sqrt( pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) >= dp[i][j]) continue;\n        for(int k = 0; k < n; k++){\n          if((i >> k) & 1) continue;\n          double next = dp[i][j] + sqrt(pow( c[j].sc.fr - c[k].sc.fr, 2) + pow( c[j].sc.sc - c[k].sc.sc, 2));\n          if(next >= dp[i|(1 << k)][k]) continue;\n          //条件に合えば次へ進む\n          bool check = sqrt(pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) > next;\n          if(check) dp[i|(1 << k)][k] = next;\n        }\n      }\n    }\n\n    bool check = n == 0;\n    for(int i = 0; i < n; i++){\n      check |= dp[(1 << n) - 1][i] < 1e9;\n    }\n    if(check) cout << \"YES\" << endl;\n    else cout <<\"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nint cx[20], cy[20], hx, hy, n, dx, dy;\n\nint solve(int x,int y){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= dist(cx[i],cy[i],dx,dy)) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit && dist(x,y,cx[i],cy[i]) + sum < dist(cx[i],cy[i],dx,dy)){\n\t\t\tbit += 1 << i;\n\t\t\tsum += dist(x,y,cx[i],cy[i]);\n\t\t\tif(solve(cx[i],cy[i])){\n\t\t\t\tsum = 0, bit = 0;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tsum -= dist(x,y,cx[i],cy[i]);\n\t\t\tbit -= 1 << i;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint i, j;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tif(solve(hx,hy))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nstruct pos{\n\tint x;\n\tint y;\n};\nstruct rel{\n\tint to;\n\tint dis;\n};\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy){\n\t\tvector<pos> p;\n\t\tREP(k, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp.push_back({ x, y });\n\t\t}\n\t\tvector<vector<int>> r(n + 1, vector<int>(n + 1));\n\t\tvector<int> dr(n);\n\t\tREP(i, n + 1){\n\t\t\tif (i != n)\n\t\t\t\tdr[i] = (dx - p[i].x)*(dx - p[i].x) + (dy - p[i].y)*(dy - p[i].y);\n\n\t\t\tfor (int j = 0; j < n + 1; j++){\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (i != n  && j != n)r[i][j] = (p[i].x - p[j].x)*(p[i].x - p[j].x) + (p[i].y - p[j].y)*(p[i].y - p[j].y);\n\t\t\t\telse if (i == n)r[i][j] = (hx - p[j].x)*(hx - p[j].x) + (hy - p[j].y)*(hy - p[j].y);\n\t\t\t\telse if (j == n)r[i][j] = (p[i].x - hx)*(p[i].x - hx) + (p[i].y - hy)*(p[i].y - hy);\n\t\t\t}\n\t\t}\n\n\t\tbool b[21] = { false };\n\t\tREP(i, n)b[i] = true;\n\t\tint b_n = n;\n\t\tbool flag = false;\n\t\tfunction<bool(int dis, int from)> f = [&](int dis, int from){\n\t\t\tif (b_n != 0){\n\t\t\t\tfor (int i = 0; i < n && !flag; i++){\n\t\t\t\t\tif (b[i] && (sqrt(dis) + sqrt(r[from][i]))<sqrt(dr[i])){\n\t\t\t\t\t\tb[i] = false;\n\t\t\t\t\t\tb_n--;\n\t\t\t\t\t\tf(dis + r[from][i], i);\n\t\t\t\t\t\tb[i] = true;\n\t\t\t\t\t\tb_n++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tflag = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn flag;\n\t\t};\n\t\tf(0, n); \n\t\tcout << (flag ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n//const int INF = INT_MAX/10;\nconst double INF = 1.7e+308/10;\n\n#define LT(x,y) ((x)-(y)<EPS)\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<double> vd;\n\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile(cin >> n >> hx >> hy >> dx >> dy, n) {\n\t\tP h(hx, hy), d(dx, dy);\n\t\tvector<P> c(n);\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tc[i] = P(x, y);\n\t\t}\n\n\t\tvector<vd> dp(1<<n, vd(n, INF));\n\t\tREP(i, n) {\n\t\t\tif(i == 0) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tdp[1<<j][j] = abs(h-c[j]);\n\t\t\t\t\tif(LT(abs(d-c[j]), dp[1<<j][j])) {\n\t\t\t\t\t\tdp[1<<j][j] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tif(!(i&(1<<j))) {\n\t\t\t\t\t\tREP(k, n) {\n\t\t\t\t\t\t\tdp[i|(1<<j)][j] = min(dp[i|(1<<j)][j], dp[i][k]+abs(c[k]-c[j]));\n\t\t\t\t\t\t\tif(LT(abs(d-c[j]), dp[i|(1<<j)][j])) {\n\t\t\t\t\t\t\t\tdp[i|(1<<j)][j] = INF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok = false;\n\t\tREP(i, n) {\n\t\t\tif(dp[(1<<n)-1][i] != INF) {\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcout << (ok ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h> //pow , sqrt\n#include <stdlib.h> //abs\nusing namespace std;\nstruct node{int x, y; double limit;};\nint N, hx, hy, dx, dy;\nnode C[32];\nbool used[32];\n\nbool solve(double t, int p){\n  if (p == N) return true;\n  \n  for (int i = 0; i < N; i++){\n    if (!used[i]){\n      double newt = t + sqrt(pow(C[i].x-hx, 2) + pow(C[i].y-hy, 2));\n      if (newt >= C[i].limit){\n\treturn false;\n      }\n      used[i] = true;\n      if (solve(newt, p+1)) return true;\n      used[i] = false;\n    }\n  }\n  return false;\n}\nint main(){\n  while (1){\n    cin >> N >> hx >> hy >> dx >> dy;\n    if (!N) break;\n    for (int i = 0; i < N; i++){\n      cin >> C[i].x >> C[i].y;\n      C[i].limit = sqrt(pow(C[i].x-dx, 2) + pow(C[i].y-dy, 2));\n    }\n    fill_n(used, N, false);\n    if (solve(0.0, 0)){\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 20;\n\n/* typedef */\n\ntemplate <typename T>\nstruct Pt {\n  T x, y;\n\n  Pt() {}\n  Pt(T _x, T _y) : x(_x), y(_y) {}\n  Pt(const Pt& pt) : x(pt.x), y(pt.y) {}\n\n  Pt operator+(const Pt pt) const { return Pt(x + pt.x, y + pt.y); }\n  Pt operator-() const { return Pt(-x, -y); }\n  Pt operator-(const Pt pt) const { return Pt(x - pt.x, y - pt.y); }\n  Pt operator*(T t) const { return Pt(x * t, y * t); }\n  Pt operator/(T t) const { return Pt(x / t, y / t); }\n  T dot(Pt v) { return x * v.x + y * v.y; }\n  T cross(Pt v) { return x * v.y - y * v.x; }\n  Pt mid(const Pt pt) { return Pt((x + pt.x) / 2, (y + pt.y) / 2); }\n  T d2() { return x * x + y * y; }\n  double d() { return sqrt(d2()); }\n\n  Pt rot(double th) {\n    double c = cos(th), s = sin(th);\n    return Pt(c * x - s * y, s * x + c * y);\n  }\n\n  bool operator<(const Pt& pt) const {\n    return x < pt.x || (x == pt.x && y < pt.y);\n  }\n  \n  void print(string format) {\n    printf((\"(\" + format + \", \" + format + \")\\n\").c_str(), x, y);\n  }\n};\n\ntypedef Pt<double> pt;\n\n/* global variables */\n\nint n;\npt hpt, dpt;\npt pts[MAX_N + 1];\nbool used[MAX_N + 1];\ndouble ddists[MAX_N + 1], pdists[MAX_N + 1][MAX_N + 1];\n\n/* subroutines */\n\nbool rec(int k, int i, double t) {\n  //printf(\"rec(%d, %d, %f\\n\", k, i, t);\n  if (t >= ddists[i]) return false;\n  if (k >= n) return true;\n\n  for (int j = 0; j <= n; j++)\n    if (! used[j] && t + pdists[i][j] >= ddists[j]) return false;\n  \n  for (int j = 0; j <= n; j++)\n    if (! used[j]) {\n      used[j] = true;\n      if (rec(k + 1, j, t + pdists[i][j])) return true;\n      used[j] = false;\n    }\n\n  return false;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n >> hpt.x >> hpt.y >> dpt.x >> dpt.y;\n    if (n == 0) break;\n\n    pts[0] = hpt;\n    for (int i = 1; i <= n; i++) cin >> pts[i].x >> pts[i].y;\n\n    for (int i = 0; i <= n; i++) {\n      ddists[i] = (pts[i] - dpt).d();\n      pdists[i][i] = 0.0;\n      for (int j = i + 1; j <= n; j++)\n\tpdists[i][j] = pdists[j][i] = (pts[i] - pts[j]).d();\n    }\n\n    memset(used, false, sizeof(used));\n    used[0] = true;\n    \n    int tf = rec(0, 0, 0.0);\n    cout << (tf ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\n\nint abs(int n){\n\tif(n < 0)\n\t\tn = -n;\n\treturn n;\n}\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 20], dp[1 << 20];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){\n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tloc[1 << i] = i;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i != n){\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i] != INF){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & 1 << j && dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j]) && dp[i | 1 << j] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i]){\n\t\t\t\t\t\tdp[i | 1 << j] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];\n\t\t\t\t\t\tloc[i | 1 << j] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[1 << n] != INF)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-9;\n\ntypedef pair<xy_t, bool> dat;\n\nnamespace std{\n\tbool operator < (const xy_t &a, const xy_t &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nint n, hx, hy, dx, dy;\nxy_t points[21];\ndouble dis[1 << 21];\ndouble adj[21][21];\ndouble adjd[21];\nmap<P, bool> bad;\nmap<P, int> mp;\n\nbool dfs(double t, int v, int st){\n\tif(st == (1 << (n + 1)) - 1) return true;\n\tif(bad[P(v, st)]) return false;\n\tif(mp[P(v, st)] != 0 && (int)t > mp[P(v, st)]) return false;\n\tmp[P(v, st)] = (int)t;\n\n\n\tbool res = false;\n\tfor(int i = 1; i < n + 1; i++){\n\t\tif(!(st & (1 << i))){\n\t\t\tdouble nt = t + adj[v][i];\n\t\t\tif(nt < adjd[i] && nt < dis[st | (1 << i)]) res |= dfs(nt, i, st | (1 << i));\n\t\t}\n\t\tif(res) return true;\n\t}\n\tbad[P(v, st)] = true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> n >> hx >> hy >> dx >> dy && (n || hx || hy || dx || dy)){\n\t\tbad.clear();\n\t\tmp.clear();\n\t\tpoints[0] = xy_t(hx, hy);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints[i] = xy_t(x, y);\n\t\t}\n\t\tfor(int i = 0; i < n + 1; i++){\n\t\t\tadjd[i] = abs(points[i] - xy_t(dx, dy));\n\t\t\tfor(int j = 0; j < n + 1; j++)\n\t\t\t\tadj[i][j] = abs(points[i] - points[j]);\n\t\t}\n\n\t\tfor(int i = 1; i < (1 <<( n + 1)); i++){\n\t\t\tdouble d = 1e10;\n\t\t\tfor(int j = 0; j < n + 1; j++){\n\t\t\t\tif(!(i & (1 << j))) d = min(d, abs(points[j] - xy_t(dx, dy)));\n\t\t\t}\n\t\t\tdis[i] = d;\n\t\t}\n\t\tif(dfs(0.0, 0, 1)) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define MAX 21\n#define INF 10000\n#define EPS 1.0e-10\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point;\ndouble dist(const point &a, const point &b){return std::abs(b-a);}\nbool vis[MAX];\nbool bt(const vector<point> &v, double walk, const point &h, const point &d){\n\tbool bCont = false;\n\n\tfor(unsigned int i = 0; i < v.size(); ++i){\n\t\tif( !vis[i] )bCont=true;\n\t}\n\tif( !bCont )return true;\n\n\tfor(unsigned int i = 0; i < v.size(); ++i){\n\t\tif( !vis[i] ){\n\t\t\tdouble t = walk + dist(h,v[i]);\n\t\t\tif( t < dist(d, v[i]) ){\n\t\t\t\tvis[i] = true;\n\t\t\t\tif( bt( v, t, v[i], d ) )\n\t\t\t\t\treturn true;\n\t\t\t\tvis[i] = false;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tbool bImpossible = false;\n\t\tint n,hx,hy,dx,dy;\n\t\tpoint hero, daemon;\n\t\tvector< point > vp;\n\n\t\tscanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy);\n\t\tif(!(n||hx||hy||dx||dy))break;\n\t\t\n\t\thero = complex<elem>(hx,hy);\n\t\tdaemon = complex<elem>(dx,dy);\n\t\t\n\t\tfor(int i=0;i<n;++i){\n\t\t\tbool bInserted = false;\n\t\t\tint cx,cy;scanf(\"%d%d\", &cx, &cy);point p(cx,cy);\n\t\t\tif(cx==hx&&cy==hy)continue;\n\t\t\tfor(unsigned int j = 0; j < vp.size() && !bInserted; ++j){\n\t\t\t\tif( dist( daemon, vp[j] ) > dist( daemon, p ) ){\n\t\t\t\t\tvp.insert( vp.begin()+j, p );\n\t\t\t\t\tbInserted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !bInserted ){\n\t\t\t\tvp.push_back( p );\n\t\t\t}\n\t\t\tif( dist(daemon,p) <= dist(hero,p) )bImpossible=true;\n\t\t\tvis[i]=false;\n\t\t}\n\t\t/*for(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tcout<<vp[i]<< ' ';\n\t\t}\n\t\tcout << endl;*/\n\t\t\n\t\tif( !bImpossible && bt( vp, 0.0, hero, daemon ) )\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint n;\ndouble item_dist[21][21];\ndouble boss_dist[20];\n\ndouble distance(pii a, pii b) {\n    return hypot(a.first - b.first, a.second - b.second);\n}\n\nbool dfs(int p, double t, int remain) {\n    if (remain == 0) return true;\n    REP(i, n) {\n        if (remain & (1 << i)) {\n            double next_t = t + item_dist[i][p];\n            bool reachable = true;\n            REP(j, n) {\n                if (remain & (1 << j) && boss_dist[j] <= next_t + item_dist[i][j]) {\n                    reachable = false;\n                    break;\n                }\n            }\n            if (reachable && dfs(i, next_t, remain & ~(1 << i))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int x, y, hx, hy;\n    while (cin >> n >> x >> y >> hx >> hy, n|x|y|hx|hy) {\n        fill_n((int *)item_dist, 21*21, 0);\n        fill_n((int *)boss_dist, 21*21, 0);\n\n        vector<pii> items;\n        REP(i, n) {\n            int a, b;\n            cin >> a >> b;\n            items.push_back({a, b});\n        }\n        items.push_back({x, y});\n        REP(i, n+1) {\n            FOR(j, i+1, n+1) {\n                item_dist[i][j] = item_dist[j][i] = distance(items[i], items[j]);\n            }\n        }\n        REP(i, n) {\n            boss_dist[i] = distance(items[i], {hx, hy});\n        }\n\n        if (dfs(n, 0.0, (1 << n)-1)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P> PP;\n#define INF (1<<24)\n#define EPS 1e-10\nint n;\ndouble sx,sy,tx,ty,px[20],py[20];\n\ndouble dis(double a,double b,double c,double d)\n{return sqrt((a-c)*(a-c)+(b-d)*(b-d));}\ndouble dis(int a,int b){return dis(px[a],py[a],px[b],py[b]);}\n\nbool dfs(int S,int pos,double cost){\n  if(S==(1<<n)-1)return true;\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(cost+dis(pos,i)+EPS>dis(tx,ty,px[i],py[i]))return false;\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(cost+dis(pos,i)+EPS>dis(tx,ty,px[i],py[i]))continue;\n    if( dfs(S|(1<<i),i,cost+dis(pos,i)) )return true;\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i=0;i<n;i++){\n    if(dfs((1<<i),i,dis(sx,sy,px[i],py[i])))return true;\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin>>n>>sx>>sy>>tx>>ty;\n    if(n==0&&sx==0&&sy==0&&tx==0&&ty==0)break;\n    for(int i=0;i<n;i++)cin>>px[i]>>py[i];\n    cout<<(solve()?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\n// 1: a,b,cが反時計周りの順に並ぶ\n//-1: a,b,cが時計周りの順に並ぶ\n// 2: c,a,bの順に直線に並ぶ\n//-2: a,b,cの順に直線に並ぶ\n// 0: a,c,bの順に直線に並ぶ\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.b - l.a) / norm(l.a - l.b);\n\treturn l.a + t * (l.b - l.a);\n}\n\n//線対象の位置にある点\nPoint reflect(const Line &l, const Point &p) {\n\tPoint pr = proj(l, p);\n\treturn pr * 2. - p;\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// 直線と直線の交点\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// 線分と線分の交点\n//　重なってる部分あるとassert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//先にisis_ssしてね\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// 線分と線分の交点\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine line_bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n//点と点の垂直二等分線　aを左に見ながら\nLine point_bisection(const Point&a, const Point&b) {\n\tconst Point cen((a + b) / 2.);\n\tconst Point vec = (b - a)*Point(0, 1);\n\treturn Line(cen, cen + vec);\n}\n\n//三つの点からなる外心\nPoint outer_center(const vector<Point>&ps) {\n\tassert(ps.size() == 3);\n\tLine l1 = point_bisection(ps[0], ps[1]);\n\tLine l2 = point_bisection(ps[1], ps[2]);\n\n\treturn is_ll(l1, l2);\n}\n\n\n//三つの直線からなる内心\n//三つの直線が並行でないことは確かめといてね\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(line_bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(line_bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//三つの直線からなる傍心\n//三つの直線が並行でないことは確かめといてね\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(line_bisection(Line(vertics[i], vertics[i] * 2.0 - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(line_bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0 - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:並行\n//c:並行でない\n//三つの直線から同距離の位置を求める。\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(line_bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(line_bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(line_bisection(Line(vertics[0], 2.*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n/*\n点が円の中にいるか\n0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const  Point& p, const Circle &cir) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n/*\n円lcが円rcの中にいるか\n0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//二つの円の重なり面積\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n\n\n//多角形(複数の点)の最小包含円をO(N=頂点数)で求めるアルゴリズム\n//同一直線上に三つの点がないこと\n#include<random>\nCircle welzl(vector<Point>ps) {\n\tstruct solver {\n\t\tCircle solve(vector<Point>&ps, vector<Point>&rs) {\n\t\t\tif (ps.empty() || rs.size() == 3) {\n\t\t\t\tif (rs.size() == 1) {\n\t\t\t\t\treturn Circle(Point(rs[0]), 0);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 2) {\n\t\t\t\t\treturn Circle((rs[0] + rs[1]) / 2.0, abs(rs[1] - rs[0]) / 2);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 3) {\n\t\t\t\t\tvector<Line> ls(3);\n\t\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\t\tls[i] = Line(rs[i], rs[(i + 1) % 3]);\n\t\t\t\t\t}\n\t\t\t\t\tPoint center = outer_center(rs);\n\t\t\t\t\treturn Circle(center, abs(center - rs[0]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn Circle(Point(), 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tPoint p_ba = ps.back();\n\t\t\t\tps.pop_back();\n\t\t\t\tCircle d = solve(ps, rs);\n\t\t\t\tps.push_back(p_ba);\n\t\t\t\tif (is_in_Circle(d, p_ba)) {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trs.push_back(p_ba);\n\t\t\t\t\tps.pop_back();\n\t\t\t\t\tauto ans = solve(ps, rs);\n\t\t\t\t\tps.push_back(p_ba);\n\t\t\t\t\trs.pop_back();\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}so;\n\tstd::random_device rd;\n\tstd::mt19937 mt(rd());\n\tshuffle(ps.begin(), ps.end(), mt);\n\tvector<Point>rs;\n\tCircle ans = so.solve(ps, rs);\n\treturn ans;\n}\n// 面積\nld get_area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tfor (int j = 0; j<n; ++j) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n//点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\n\n\nint main() {\n\twhile (true) {\n\t\tint N; Point start_po;\n\t\tvector<Point>pos;\n\t\t{\n\t\t\tld Hx, Hy, Sx, Sy;\n\t\t\tcin >> N >> Hx >> Hy >> Sx >> Sy;\n\t\t\tif(!N)return 0;\n\t\t\tstart_po = Point(Hx - Sx, Hy - Sy);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tld x, y; cin >> x >> y;\n\t\t\t\tpos.emplace_back(x - Sx, y - Sy);\n\t\t\t}\n\t\t}\n\t\tvector<vector<ld>>memo(N, vector<ld>(1 << N, 1e18));\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tld atime = abs(pos[i] - start_po);\n\t\t\tif (atime + eps < abs(pos[i])) {\n\t\t\t\tbitset<20>bs;\n\t\t\t\tbs[i] = true;\n\t\t\t\tmemo[i][bs.to_ulong()] = atime;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << N); ++i) {\n\t\t\tfor (int now = 0; now < N; ++now) {\n\t\t\t\tif (memo[now][i]>1e17)continue;\n\n\t\t\t\tbitset<20>bs(i);\n\t\t\t\tfor (int next = 0; next < N; ++next) {\n\t\t\t\t\tif (!bs[next]) {\n\t\t\t\t\t\tbs[next] = true;\n\n\t\t\t\t\t\tld next_time = abs(pos[next] - pos[now]) + memo[now][i];\n\t\t\t\t\t\tif (next_time + eps < abs(pos[next])) {\n\t\t\t\t\t\t\tmemo[next][bs.to_ulong()] = min(memo[next][bs.to_ulong()], next_time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbs[next] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (memo[i][(1 << N) - 1]<1e17)ok = true;\n\t\t}\n\t\tif (ok)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\nint n;\ndouble dis[32][32];\nbool dfs(int no_visit, int cur, double time)\n{\n\tif (no_visit == 0)\n\t\treturn true;\n\n\tfor (int i = 0; i < n; ++i)\n\t\tif (no_visit >> i & 1 && time > dis[n + 1][i])\n\t\t\treturn false;\n\n\tfor (int i = 0; i < n; ++i)\n\t\tif (no_visit >> i & 1 && time + dis[cur][i] < dis[n + 1][i])\n\t\t\tif (dfs(no_visit ^ 1 << i, i, time + dis[cur][i]))\n\t\t\t\treturn true;\n\n\treturn false;\n}\nint main()\n{\n\tdouble hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n)\n\t{\n\t\tdouble x[32], y[32];\n\t\trep (i, n)\n\t\t\tcin >> x[i] >> y[i];\n\t\tx[n] = hx, y[n] = hy;\n\t\tx[n + 1] = dx, y[n + 1] = dy;\n\n\t\tfor (int i = 0; i <= n + 1; ++i)\n\t\t\tfor (int j = 0; j <= n + 1; ++j)\n\t\t\t\tdis[i][j] = hypot(x[i] - x[j], y[i] - y[j]);\n\n\t\tcout << (dfs((1 << n) - 1, n, 0) ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\ninline int dbl(int x){ return x * x; }\n\nint main(){\n  while(true){\n    const int n = getInt();\n    const int hx = getInt();\n    const int hy = getInt();\n    const int dx = getInt();\n    const int dy = getInt();\n\n    if(n == 0) break;\n\n    vector<int> cx(n);\n    vector<int> cy(n);\n\n    REP(i,n){\n      cx[i] = getInt();\n      cy[i] = getInt();\n    }\n\n    typedef pair<double, pair<int, int> > data;\n    priority_queue<data, vector<data>, greater<data> > pq;\n    vector<vector<bool> > memo(1 << n, vector<bool>(n));\n\n    pq.push(make_pair(0.0, make_pair((1 << n) - 1, -1)));\n\n    while(pq.size()){\n      const data   d = pq.top(); pq.pop();\n      const double t = d.first;\n      const int    f = d.second.first;\n      const int    p = d.second.second;\n      const int    x = p == -1 ? hx : cx[p];\n      const int    y = p == -1 ? hy : cy[p];\n\n      // printf(\"%f %d %d\\n\", t, f, p);\n\n      if(p >= 0 && memo[f][p]) continue;\n      if(p >= 0) memo[f][p] = true;\n\n      if(f == 0){\n\tputs(\"YES\");\n\tgoto end;\n      }\n\n      vector<data> ds;\n      bool ok = true;\n\n      REP(i,n) if(f & (1 << i)){\n\tconst int xx = cx[i];\n\tconst int yy = cy[i];\n\n\tconst double tm1 = t + sqrt(dbl(x - xx) + dbl(y - yy));\n\tconst double tm2 = sqrt(dbl(dx - xx) + dbl(dy - yy));\n\t// printf(\"%d => %d (%d %d) => (%d %d): %f %f\\n\", p, i, x, y, xx, yy, tm1, tm2);\n\n\tif(tm1 < tm2 - 1e-9){\n\t  ds.push_back(make_pair(tm1, make_pair(f ^ (1 << i), i)));\n\t}else{\n\t  ok = false;\n\t}\n      }\n\n      if(ok) REP(i,ds.size()) if(!memo[ds[i].second.first][ds[i].second.second])\n\t       pq.push(ds[i]);\n\n      if(pq.size() * (8 + 4 + 4) > 16 * 1000 * 1000){\n\tpriority_queue<data, vector<data>, greater<data> > pq2;\n\n\twhile(pq.size()){\n\t  data d = pq.top(); pq.pop();\n\t  if(!memo[d.second.first][d.second.second])\n\t    pq2.push(d);\n\t}\n\n\tpq = pq2;\n      }\n\n    }\n    puts(\"NO\");\n  end:;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-9;\n\ntypedef pair<xy_t, bool> dat;\n\nnamespace std{\n\tbool operator < (const xy_t &a, const xy_t &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nint n, hx, hy, dx, dy;\nxy_t points[21];\ndouble dis[1 << 21];\ndouble adj[21][21];\ndouble adjd[21];\nmap<P, bool> bad;\nmap<P, int> mp;\n\nbool dfs(double t, int v, int st){\n\tif(st == (1 << (n + 1)) - 1) return true;\n\tif(bad[P(v, st)]) return false;\n\tif(mp[P(v, st)] != 0 && (int)t > mp[P(v, st)]) return false;\n\tmp[P(v, st)] = (int)t;\n\n\n\tbool res = false;\n\tfor(int i = 1; i < n + 1; i++){\n\t\tif(!(st & (1 << i))){\n\t\t\tdouble nt = t + adj[v][i];\n\t\t\tif(nt < adjd[i] && nt < dis[st | (1 << i)]) res |= dfs(nt, i, st | (1 << i));\n\t\t}\n\t\tif(res) return true;\n\t}\n\tbad[P(v, st)] = true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> n >> hx >> hy >> dx >> dy && (n || hx || hy || dx || dy)){\n\t\tbad.clear();\n\t\tpoints[0] = xy_t(hx, hy);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints[i] = xy_t(x, y);\n\t\t}\n\t\tfor(int i = 0; i < n + 1; i++){\n\t\t\tadjd[i] = abs(points[i] - xy_t(dx, dy));\n\t\t\tfor(int j = 0; j < n + 1; j++)\n\t\t\t\tadj[i][j] = abs(points[i] - points[j]);\n\t\t}\n\n\t\tfor(int i = 1; i < (1 <<( n + 1)); i++){\n\t\t\tdouble d = 1e10;\n\t\t\tfor(int j = 0; j < n + 1; j++){\n\t\t\t\tif(!(i & (1 << j))) d = min(d, abs(points[j] - xy_t(dx, dy)));\n\t\t\t}\n\t\t\tdis[i] = d;\n\t\t}\n\t\tif(dfs(0.0, 0, 1)) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n\twhile(true) {\n\t\tint n, hx, hy, dx, dy;\n\t\tcin >> n >> hx >> hy >> dx >> dy;\n\n\t\tif(!n && !hx && !hy && !dx && !dy) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< pair< int, int > > crys;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tcrys.push_back(make_pair(x, y));\n\t\t}\n\n\t\tvector< pair< double, double> > u;\n\t\tvector< bool > use(n, true);\n\t\tdouble tmp = 1000, idx = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tu.push_back(make_pair(sqrt((double)(crys[i].first - dx) * (crys[i].first - dx) + (double)(crys[i].second - dy) * (crys[i].second - dy)), sqrt((double)(crys[i].first - hx) * (crys[i].first - hx) + (double)(crys[i].second - hy) * (crys[i].second - hy))));\n\t\t\tif(tmp > u[i].first) {\n\t\t\t\ttmp = u[i].first;\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t}\n\n\t\tvector< pair< double, int > > day_limit;\n\t\tvector< pair< double, int > > h_time;\n\t\tfor(int i = 0; i < u.size(); i++) {\n\t\t\tday_limit.push_back(make_pair(u[i].first, i));\n\t\t\th_time.push_back(make_pair(u[i].second, i));\n\t\t}\n\n\t\tsort(day_limit.begin(), day_limit.end());\n\n\t\tdouble max_day = day_limit[day_limit.size() - 1].first;\n\n\t\t//for(int i = 0; i < day_limit.size(); i++) {\n\t\t//\tcout << day_limit[i].first << \"  ->  \" << day_limit[i].second << endl;\n\t\t//\tcout << h_time[i].first << \"  ->  \" << h_time[i].second << endl;\n\t\t//}\n\t\t//cout << \"\\n\\n\\n\";\n\n\t\tpair< int, int > now = make_pair(hx, hy);\n\n\t\tdouble ans = 0;\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < day_limit.size(); i++) {\n\t\t\t//cout << sqrt((double)(crys[day_limit[i].second].first - now.first) * (crys[day_limit[i].second].first - now.first) + (double)(crys[day_limit[i].second].second - now.second) * (crys[day_limit[i].second].second - now.second)) << endl; cout << now.first << \"   \" << now.second << endl;\n\t\t\tans += sqrt((double)(crys[day_limit[i].second].first - now.first) * (crys[day_limit[i].second].first - now.first) + (double)(crys[day_limit[i].second].second - now.second) * (crys[day_limit[i].second].second - now.second));//cout << ans << \"   \" << max_day << endl;\n\t\t\tif(ans >= day_limit[i].first) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnow.first = crys[day_limit[i].second].first; now.second = crys[day_limit[i].second].second;\n\t\t}\n\n\t\t\n\n\t\tif((int)ans < (int)max_day && flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool f = false;\nint cx[20];\nint cy[20];\nbool used[20];\nint n, hx, hy, dx, dy;\n\ndouble distance(int x1, int y1, int x2, int y2){\n\tdouble dx = x2 - x1;\n\tdouble dy = y2 - y1;\n\treturn sqrt(dx*dx+dy*dy);\n}\n\nvoid move(int x, int y, int n, double time){\n\tif(n == 0){\n\t\tf = true;\n\t}\n\tcout << x << \" \" << y << \" \" << n << endl;\n\tif(f) return;\n\tfor(int i = 0; i < n; i++){\n\t\tif(!used[i] && distance(cx[i], cy[i], x, y) + time < distance(cx[i], cy[i], dx, dy)){\n\t\t\tused[i] = true;\n\t\t\tmove(cx[i], cy[i], n - 1, time + distance(x, y, cx[i], cy[i]));\n\t\t\tused[i] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> n >> hx >> hy >> dx >> dy){\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tused[i] = false;\n\t\t}\n\t\tf = false;\n\t\tmove(hx, hy, n, 0);\n\t\tif(f) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define ex 1e-5\n#include<cmath>\n//S \nusing namespace std;\nint cx[30],cy[30],n,hx,hy,dx,dy;\nbool func(int S,int y,int x,double time){\n\tif(S==(1<<n)-1)\n\t\treturn 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(!(S&(1<<i))){\n\t\t\tdouble pre=(double)sqrt((x-cx[i])*(x-cx[i])+(y-cy[i])*(y-cy[i]));\n\t\t\tdouble dis=(double)sqrt((cx[i]-dx)*(cx[i]-dx)+(cy[i]-dy)*(cy[i]-dy));\n\t\t\tcout<<pre+time<<' '<<dis<<endl;\n\t\t\tif(pre+time<dis&&func(S|(1<<i),cy[i],cx[i],time+pre))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin>>n>>hx>>hy>>dx>>dy,n||hx||hy||dx||dy){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>cx[i]>>cy[i];\n\t\tif(func(0,hy,hx,0.0))\n\t\t\tcout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nstruct Point {\n\tint x, y;\n};\n\nconst double EPS = 1E-8;\nPoint h, d, p[20];\nint n;\nbool flag[20];\n\nbool dfs(double t, int s) \n{\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tif (!flag[i]) break;\n\t}\n\tif (i == n) return true;\n\t\n\tPoint pp = (s == -1) ? h : p[s];\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tif (hypot(d.x - p[i].x, d.y - p[i].y) - hypot(pp.x - p[i].x, pp.y - p[i].y) < EPS) return false;\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tflag[i] = true;\n\t\tif (dfs(hypot(pp.x - p[i].x, pp.y - p[i].y), i)) return true;\n\t\tflag[i] = false;\n\t}\n\t\n\treturn false;\n}\n\nint main()\n{\t\n\twhile (cin >> n >> h.x >> h.y >> d.x >> d.y, n | h.x | h.y | d.x | d.y) {\n\t\tmemset(flag, false, sizeof(flag));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p[i].x >> p[i].y;\n\t\t}\n\t\tcout << (dfs(0, -1) ? \"YES\" : \"NO\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<double, pair<int, P> > bfp;\nint n, hx, hy, dx, dy;\nP c[1001];\ndouble len[1001];\nint main() {\n    while (scanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy)) {\n        if (!n&&!hx&&!hy&&!dx&&!dy) break;\n        for (int i=0; i<n; i++) {\n            scanf(\"%d%d\",&c[i].x,&c[i].y);\n            double x=c[i].x-dx, y=c[i].y-dy;\n            len[i]=sqrt(x*x+y*y);\n        }\n        queue<bfp> que;\n        que.push(bfp(0.0, make_pair(0,P(hx,hy))));\n        bool res=false;\n        while (!que.empty()) {\n            bfp b=que.front(); que.pop();\n            double t=b.first;\n            int stat=b.second.first;\n            P np=b.second.second;\n            bool flag=true;\n            for (int i=0; i<n; i++) {\n                if ((stat>>i&1)&&len[i]<=t) {\n                    flag=false;\n                    break;\n                }\n            }\n            if (!flag) continue;\n            for (int i=0; i<n; i++) {\n                if (!(stat>>i&1)) {\n                    flag=false;\n                    double x=c[i].x-np.x, y=c[i].y-np.y;\n                    que.push(bfp(t+sqrt(x*x+y*y),make_pair(stat|1<<i,P(c[i].x,c[i].y))));\n                }\n            }\n            if (flag) {\n                res=true;\n                break;\n            }\n        }\n        if (res) puts(\"YES\");\n        else puts(\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second \n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n\ndouble tt[1<<20][22];\ndouble cost[22][22];\ndouble tlimit[22];\nint xx[22];\nint cx[22], cy[22];\nint det[22];\nint n;\n\nbool DFS(int pos, int vis, double dis){\n\tif(vis == ((1<<(n+1))-1))return true;\n\t//枝狩り\n\tFOR(i, 1, n+1)if((vis&xx[i])==0 && dis+cost[pos][i] > tlimit[i]+EPS)return false;\n\tFOR(i, 1, n+1){\n\t\tif((vis&xx[i])==0 && (dis+cost[pos][i]+EPS < tlimit[i])){\n\t\t\tif(DFS(i, vis|xx[i], dis+cost[pos][i])){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tREP(i,22){\n\t\txx[i] = 1<<i;\n\t}\n\twhile(1){\n\t\tint dx,dy;\n\t\tcin>>n>>cx[0]>>cy[0]>>dx>>dy;\n\t\tmemset(tt,0, sizeof(tt));\n\t\tmemset(det,0, sizeof(det));\n\t\tFOR(i,1,n+1)cin >> cx[i] >> cy[i];\n\t\tREP(i, n+1){\n\t\t\ttlimit[i] = sqrt(pow(cx[i]*1.0-dx*1.0,2.0)+pow(cy[i]*1.0-dy*1.0,2.0));\n\t\t\tREP(j,n+1){\n\t\t\t\tcost[i][j] = sqrt(pow(cx[i]*1.0-cx[j]*1.0,2.0)+pow(cy[i]*1.0-cy[j]*1.0,2.0));\n\t\t\t}\n\t\t}\n\t\tif(DFS(0, 1, 0.0))cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint cx[20],cy[20];\ndouble lim[20];\ndouble dd[20][20];\nbool memo[20][1<<20];\n\n#define DBL(x) ((x)*(x))\n\ninline double dist(int x1, int y1, int x2, int y2){\n  return sqrt(DBL(x1-x2) + DBL(y1-y2));\n}\n\ninline int b2i(unsigned int bit){\n  int ans=0;\n  if(!(bit&0x0000FFFF)){ans+=16;bit>>=16;}\n  if(!(bit&0x000000FF)){ans+= 8;bit>>= 8;}\n  if(!(bit&0x0000000F)){ans+= 4;bit>>= 4;}\n  if(!(bit&0x00000003)){ans+= 2;bit>>= 2;}\n  if(!(bit&0x00000001)){ans+= 1;         }\n  return ans;\n}\n\nbool solve(int pos, int f, double time){\n  //printf(\"solve(%d,%d,%d) : lim = %d\\n\",pos,f,time,lim[pos]);\n  if(time >= lim[pos]) return false;\n  if(memo[pos][f]) return false;\n  if(f == 0) return true;\n  memo[pos][f] = true;\n\n  while(f){\n    int ff = f & (-f);\n    int next = b2i(ff);\n    f ^= ff;\n    if(solve(next, f, time + dd[pos][next])) return true;\n  }\n  return false;\n}\n\nint main(){\n  while(true){\n    int n,hx,hy,dx,dy;\n    n = getInt(); hx = getInt(); hy = getInt();\n    dx = getInt(); dy = getInt();\n    if(!(n+hx+hy+dx+dy)) break;\n    memset(memo, 0, sizeof(memo));\n    REP(i,n){ cx[i] = getInt(); cy[i] = getInt(); }\n    REP(i,n){ lim[i] = dist(dx,dy,cx[i],cy[i]); }\n    REP(i,n) REP(j,n) dd[i][j] = dist(cx[i],cy[i],cx[j],cy[j]);\n\n    bool ans = false;\n    REP(i,n){\n      if(solve(i,(((1<<n)-1)^(1<<i)),dist(hx,hy,cx[i],cy[i]))){\n        ans = true;\n        break;\n      }\n    }\n    puts(ans ? \"YES\" : \"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define INF 0x7FFFFFFF\n#define dist(x1,y1,x2,y2) sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))\n\nint n;\ndouble cx[20], cy[20], hx, hy, dx, dy, S[1 << 20];\n\nint solve(double x,double y,int bit,double sum){\n\tint i;\n\tif(S[bit] > sum)\n\t\tS[bit] = sum;\n\telse\n\t\treturn 0;\n\tif(bit == 0) // すべてのクリスタルを集めたら\n\t\treturn 1;\n/*\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & bit) && sum >= dist(cx[i],cy[i],dx,dy)) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}*/\n\tfor(i = 0;i < n;i++){\n\t\tif(((1 << i) & bit) && sum + dist(x,y,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i]) && solve(cx[i],cy[i],bit ^ (1 << i),sum + dist(x,y,cx[i],cy[i])))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(void){\n\tint i;\n\twhile(1){\n\t\tscanf(\"%d%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tS[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tif(solve(hx,hy,(1 << n) - 1,0))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\ntypedef struct { int x, y; } pt;\n\nint n;\npt hero, dragon;\n\nvector<pt> targets;\n\ndouble distance(pt a, pt b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool can_visit(double d, map<int, bool>& visited, int k) {\n    if (d >= distance(targets[k], dragon)) {\n        return false;\n    }\n\n    bool all_visited = true;\n    bool ok = false;\n\n    for (int i = 1; i <= n; ++i) {\n        if (visited[i]) {\n            continue;\n        }\n\n        all_visited = false;\n\n        visited[i] = true;\n        double delta = distance(targets[i], targets[k]);\n        if (can_visit(d + delta, visited, i)) {\n            ok = true;\n        }\n        visited[i] = false;\n    }\n\n    return all_visited || ok;\n}\n\nint main() {\n    while (true) {\n        cin >> n >> hero.x >> hero.y >> dragon.x >> dragon.y;\n        if (n == 0) break;\n\n        targets.clear();\n        targets.push_back(hero);\n        for (int i = 0; i < n; ++i) {\n            pt t;\n            cin >> t.x >> t.y;\n\n            targets.push_back(t);\n        }\n\n        map<int, bool> v;\n        cout << (can_visit(0, v, 0) ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\n\nint n, hx, hy, dx ,dy;\nint cx[21], cy[21];\nbool done[21];\nbool ans;\n\ndouble D(double x1, double y1, double x2, double y2){\n\treturn sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\nvoid solve(double t, int x, int y){\n\tif( ans ) return ;\n\n\tint cnt=0;\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tif( done[i] ) cnt++;\n\t}\n\tif( cnt == n ){\n\t\tans = true;\n\t\treturn;\n\t}\n\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tif( done[i] ) continue;\n\n\t\tdouble next_time = t + D( x , y , cx[i] , cy[i] );\n\t\tif ( D( dx , dy , cx[i] , cy[i] ) < next_time + EPS ){ \n\t\t\treturn; \n\t\t}\n\t}\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tif( done[i] ) continue;\n\n\t\tdouble next_time = t + D( x , y , cx[i] , cy[i] );\n\t\tdone[i] = true;\n\t\tsolve( next_time , cx[i] , cy[i] );\n\t\tdone[i] = false;\n\t}\n}\n\nint main(){\n\twhile( cin >> n >> hx >> hy >> dx >> dy , (n || hx || hy || dx || dy) ){\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t}\n\n\t\tfor(int i=0 ; i < 21 ; i++ ){\n\t\t\tdone[i] = false;\n\t\t}\n\t\tans = false;\n\t\tsolve( 0.0 , hx , hy );\n\t\tif( ans ){\n\t\t\tcout << \"YES\" << endl;\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\n\nconst D EPS = 1e-8;\n\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\n\ntypedef pair<D, pair<int, int> > State;\n\nP cr[21], d;\nint n;\nD dis[1 << 20][21];\n\nD solve(int bit, int p) {\n  if (dis[bit][p] < 1e95) return dis[bit][p];\n  if (bit == 0) {\n    D ds = abs(cr[p] - cr[n]);\n    if (sig(ds, abs(cr[p] - d)) >= 0) return dis[bit][p] = 1e92;\n    else return dis[bit][p] = ds;\n  }\n  rep (i, n) if (bit & 1 << i) {\n    dis[bit][p] = min(dis[bit][p], solve(bit ^ 1 << i, i) + abs(cr[p] - cr[i]));\n  }\n  if (sig(dis[bit][p], abs(cr[p] - d)) >= 0) return dis[bit][p] = 1e92;\n  return dis[bit][p];\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    cin  >> cr[n].X >> cr[n].Y >> d.X >> d.Y;\n    if (n == 0) break;\n    rep (i, n) cin >> cr[i].X >> cr[i].Y;\n    priority_queue<State, vector<State>, greater<State> > que;\n    que.push(make_pair(0, make_pair((1 << n) - 1, n)));\n    rep (i, 1 << n) rep (j, n) dis[i][j] = 1e100;\n    bool ok = false;\n    rep (i, n) if (solve(((1 << n) - 1) ^ (1 << i), i) < 1e90) {\n      ok = true;\n      break;\n    }\n    cout << (ok ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\ndouble mx,my;\ndouble x[21],y[21];\nbool input(){\n    scanf(\"%d\",&N);\n    scanf(\"%lf%lf%lf%lf\",&x[N],&y[N],&mx,&my);\n    if(!(N||x[N]||y[N]||mx||my))return false;\n    for(int i=0;i<N;i++)scanf(\"%lf%lf\",&x[i],&y[i]);\n    return true;\n}\n\nbool dfs(int S,int pos,double total){\n    if(S==(1<<N)-1)return true;\n    bool ret=false;\n    for(int i=0;i<N;i++){\n        if((S>>i)&1)continue;\n        double mao=hypot(mx-x[i],my-y[i]);\n        double yu=hypot(x[pos]-x[i],y[pos]-y[i]);\n        if(yu+total>=mao)return false;\n        ret|=dfs(S|(1<<i),i,total+yu);\n    }\n    return ret;\n}\nvoid solve(){\n\n    bool ans=false;\n    puts(dfs(0,N,0)?\"YES\":\"NO\");\n}\nint main(){\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nint n,dx,dy,hx,hy;\nint cx[20],cy[20];\nshort dp[1<<20][21];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n+hx+hy+dx+dy==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t\tcx[n]=hx,cy[n]=hy;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0][n]=0;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<1<<n;i++){\n\t\t\tif(flag)continue;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif(dp[i][j]!=-1){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif((i>>k) & 1)continue;\n\t\t\t\t\t\tint move=abs(cx[j]-cx[k])+abs(cy[j]-cy[k]);\n\t\t\t\t\t\tint ng=abs(dx-cx[k])+abs(dy-cy[k]);\n\t\t\t\t\t\tif(dp[i][j]+move>=ng)continue;\t\n\t\t\t\t\t\tdp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],dp[i][j]+move);\n\t\t\t\t\t\tif(dp[i|(1<<k)][k]==-1)dp[i|(1<<k)][k]=dp[i][j]+move;\n\t\t\t\t\t\tif(i|(1<<k)==(1<<n)-1)flag=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define MAXNUM 20\ntypedef struct s{\n\tdouble d;\n\tint c;\n}status;\n\ndouble dist(double x1,double y1,double x2,double y2){\n\treturn sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\nvoid printB(int n){\n\tint i = 0, a[MAXNUM];\n\tfor(i = 0;i < MAXNUM;i++){\n\t\ta[MAXNUM - 1 - i] = n % 2;\n\t\tn /= 2;\n\t}\n\tfor(i = 0;i < MAXNUM;i++){\n\t\tprintf(\"%d\",a[i]);\n\t}\n}\n\nint main(void){\n\tint i, j, n;\n\tdouble hx, hy, dx, dy, cx[MAXNUM],cy[MAXNUM];\n\tstatus dp[1 << MAXNUM];\n\twhile(1){\n\t\tscanf(\"%d%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(!n && !hx && !hy && !dx && !dy)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i].d = -1;\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tdp[1 << i].d = dist(hx,hy,cx[i],cy[i]);\n\t\t\tdp[1 << i].c = i;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i].d != -1){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & 1 << j && (dp[i | 1 << j].d > dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]) || dp[i | 1 << j].d == -1)){\n\t\t\t\t\t\tdp[i | 1 << j].d = dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]);\n\t\t\t\t\t\tdp[i | 1 << j].c = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist(dx,dy,cx[dp[(1 << n) - 1].c],cy[dp[(1 << n) - 1].c]) > dp[(1 << n) - 1].d)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n/*\t\tfor(i = 0;i < (1 << n);i++){\n\t\t\tprintf(\"dp[\");\n\t\t\tprintB(i);\n\t\t\tprintf(\"] = %f\\n\",dp[i].d);\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nint n;\nint hx, hy, dx, dy;\nint cx[20], cy[20];\ndouble dist[20][20];\ndouble limit[20];\n\nbool dfs(int pos, int visited, double sum) {\n\tif(visited == (1 << n) - 1)\n\t\treturn true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(visited & (1 << i))\n\t\t\tcontinue;\n\n\t\tconst double d = hypot(cx[pos] - cx[i], cy[pos] - cy[i]);\n\t\tif(sum + d < limit[i] && dfs(i, visited | (1 << i), sum + d))\n\t\t   return true;\t\t\t\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tconst int INF = 0xfffffff;\n\n\twhile(cin >> n >> hx >> hy >> dx >> dy, n) {\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tcin >> cx[i] >> cy[i];\n\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = i + 1; j < n; ++j)\n\t\t\t\tdist[i][j] = dist[j][i] = hypot(cx[i] - cx[j], cy[i] - cy[j]);\n\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tlimit[i] = hypot(cx[i] - dx, cy[i] - dy);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tconst double d = hypot(cx[i] - hx, cy[i] - hy);\n\t\t\tif(d < limit[i] && dfs(i, (1 << i), d)) {\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\n\t\tcout << \"NO\" << endl;\n\tnext:;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\ndouble INF=1e16;\ndouble EPS=1e-9;\nclass Main{\n\tpublic:\n\n\n\tint n;double hx,hy,dx,dy;\n\tvector<double> cx,cy;\n\tvector<vector<double>> ds;\n\n\tbool dfs(int v,int bit,double t){\n\t\tif(bit==(1<<n)-1)return true;\n\t\t//cut \n\t\tREP(i,n)if(!((bit>>i)&1)){\n\t\t\tdouble d=v!=-1?hypot(cx[i]-cx[v],cy[i]-cy[v]):hypot(cx[i]-hx,cy[i]-hy);\n\t\t\tif(!(d+t<hypot(cx[i]-dx,cy[i]-dy)))return false;\n\t\t}\n\n\t\tREP(i,n)if(!((bit>>i)&1)){\n\t\t\tdouble d=v!=-1?hypot(cx[i]-cx[v],cy[i]-cy[v]):hypot(cx[i]-hx,cy[i]-hy);\n\t\t\tif(d+t<hypot(cx[i]-dx,cy[i]-dy))\n\t\t\t\tif(dfs(i,bit|1<<i,d+t))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tcin >> n >> hx >> hy >> dx >> dy;if(n==0)break;\n\t\t\tcx=vector<double>(n);cy=vector<double>(n);REP(i,n) cin >> cx[i] >> cy[i];\n\n\t\t\tbool ok=false;\n\t\t\tok=dfs(-1,0,0);\n\t\t\tcout << (ok?\"YES\":\"NO\")<<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 20], dp[1 << 20];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){\n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tloc[1 << i] = i;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i != n){\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i] != INF){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & 1 << j && dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j]) && dp[i | 1 << j] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i]){\n\t\t\t\t\t\tdp[i | 1 << j] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];\n\t\t\t\t\t\tloc[i | 1 << j] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[1 << n] != -1)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define MAX 20\ntypedef pair<double,double> P;\n\nint N;\nP h, d, crystal[MAX];\n\ndouble dist(P a, P b){\n  return sqrt(pow(a.fi-b.fi,2) + pow(a.se-b.se,2));\n}\n\nbool solve(){\n  sort(crystal, crystal+N,greater<P>());\n\n  double total_dist = 0;\n  for(int i = 0 ; i < N ; i++){\n    total_dist += dist(h, crystal[i]);\n    if(total_dist >= dist(d, crystal[i])){\n      return false;\n    }\n    h = crystal[i];\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> N >> h.fi >> h.se >> d.fi >> d.se, (N + h.fi + h.se + d.fi + d.se)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].fi >> crystal[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <algorithm>\n#define INF 0x7FFFFFFF\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\nusing namespace std;\nint cx[20], cy[20], hx, hy, n, dx, dy, cut[1 << 20];\n\nint solve(int x,int y){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(cut[bit] > sum)\n\t\tcut[bit] = sum;\n\telse\n\t\treturn 0;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= dist(cx[i],cy[i],dx,dy)) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit && dist(x,y,cx[i],cy[i]) + sum < dist(cx[i],cy[i],dx,dy)){\n\t\t\tbit += 1 << i;\n\t\t\tsum += dist(x,y,cx[i],cy[i]);\n\t\t\tif(solve(cx[i],cy[i])){\n\t\t\t\tsum = 0, bit = 0;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tsum -= dist(x,y,cx[i],cy[i]);\n\t\t\tbit -= 1 << i;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint i, j;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfill(cut,cut + (1 << 20),INF);\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tif(solve(hx,hy))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nclass Compare {\n  int monster_x;\n  int monster_y;\npublic:\n  Compare(int monster_x,int monster_y)\n    : monster_x(monster_x), monster_y(monster_y) {}\n  bool operator()(const P& ci,const P& cj) const{\n    int dist_i = (ci.first - monster_x) * (ci.first - monster_x)\n      + (ci.second - monster_y) * (ci.second - monster_y);\n    int dist_j = (cj.first - monster_x) * (cj.first - monster_x)\n      + (cj.second - monster_y) * (cj.second - monster_y);\n    return dist_i < dist_j;\n  }\n};\n\nclass State{\n  int x;\n  int y;\n  double dist;\n};\n\nbool dfs(int hero_x,\n         int hero_y,\n         double current_time,\n         int S,\n         int monster_x,\n         int monster_y,\n         const vector<P>& cristals){\n  bool res = false;\n\n  if(S == (1<<cristals.size()) - 1) return true;\n  for(int i=0;i<cristals.size();i++){\n    if(S & (1<<i)) continue;\n    double add_time = sqrt((hero_x - cristals[i].first) * (hero_x - cristals[i].first)\n                           + (hero_y - cristals[i].second) * (hero_y - cristals[i].second));\n    \n    double tmp_current_time = current_time + add_time;\n    double impurity_arrive_time = sqrt((monster_x - cristals[i].first) * (monster_x - cristals[i].first)\n                                       + (monster_y - cristals[i].second) * (monster_y - cristals[i].second));\n    if(tmp_current_time >= impurity_arrive_time){\n      return false;\n    }\n    \n    res |= dfs(cristals[i].first,cristals[i].second,tmp_current_time,\n               S | (1<<i),monster_x,monster_y,cristals);\n  }\n  return res;\n}\n\nint main(){\n  int total_cristals;\n  int hero_x;\n  int hero_y;\n  int monster_x;\n  int monster_y;\n  while(~scanf(\"%d %d %d %d %d\",\n               &total_cristals,\n               &hero_x,\n               &hero_y,\n               &monster_x,\n               &monster_y)){\n    if(total_cristals == 0 && hero_x == 0 && hero_y == 0\n       && monster_x == 0 && monster_y == 0) break;\n    vector<P> cristals;\n    for(int cristal_i = 0; cristal_i < total_cristals; cristal_i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cristals.push_back(P(x,y));\n    }\n    // Compare comp(monster_x,monster_y);\n    // sort(cristals.begin(),cristals.end(),comp);\n    printf(\"%s\\n\", dfs(hero_x,hero_y,0,0,monster_x,monster_y,cristals)\n           ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\nstruct status{\n\tdouble d;\n\tint c;\n};\n\ndouble dist(double x1,double y1,double x2,double y2){\n\tdouble ret = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n\treturn ret;\n}\n\nint main(void){\n\tint i, j, n;\n\tdouble hx, hy, dx, dy, cx[20], cy[20];\n\tstruct status dp[1 << 20];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tscanf(\"%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0.0 && hy == 0.0 && dx == 0.0 && dy == 0.0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i].d = -1;\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tdp[1 << i].d = dist(hx,hy,cx[i],cy[i]);\n\t\t\tdp[1 << i].c = i;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i].d != -1){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & (1 << j) && ((dp[i | (1 << j)].d == -1) || (dp[i | (1 << j)].d > dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j])))){\n\t\t\t\t\t\tdp[i | (1 << j)].d = dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]);\n\t\t\t\t\t\tdp[i | (1 << j)].c = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist(dx,dy,cx[dp[(1 << n) - 1].c],cy[dp[(1 << n) - 1].c]) > dp[(1 << n) - 1].d)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble  cost[20][20];\nconst double INF = 10000000;\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if (visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  //\n  /*\n  visited[last]=false;\n  rep(i,n){\n    if (visited[i]==true)cost[i][i]=INF;\n    else cost[i][i]=0;\n    REP(j,i+1,n){\n      if (visited[i]==true ||visited[j]==true)cost[i][j]=cost[j][i]=INF;\n      else cost[i][j]=cost[j][i]=adj[i][j];\n    }\n  }\n  visited[last]=true;\n  rep(k,n)rep(i,n)rep(j,n)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n  rep(i,n)if( visited[i]==false && r+cost[last][i] >=adj[MAOU][i])return false;\n  */\n  //\n\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    if ( r+adj[last][i] < adj[MAOU][i]){\n      visited[i]=true;\n      if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n      visited[i]=false;\n    }//else return false;\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n  }\n  \n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i])+eps>dist(rx-x[i],ry-y[i]))return false;\n  }\n\n\n  bool visited[20]={false};\n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i]) < dist(rx-x[i],ry-y[i])){\n      visited[i]=true;\n      if ( backTrack(i,dist(mx-x[i],my-y[i]),1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(cin>>n>>mx>>my>>rx>>ry && n){\n    int x[n],y[n];\n    rep(i,n)cin>>x[i]>>y[i];\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//56\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\n#define S(X) ((X)*(X))\n\nint n,hx,hy,dx,dy;\ndouble d[21][21];\ndouble l[21];\n\nbool dfs(int s,double t,int g){\n  if(g==(1<<n+1)-1)return true;\n  double ub=0;\n  for(int i=1;i<=n;i++){\n    if(!(g&1<<i)&&ub<l[i]){\n      ub=l[i];\n    }\n  }\n  double lb=1<<30;\n  for(int i=0;i<=n;i++){\n    if(!(g&1<<i)&&lb>d[s][i]){\n      lb=d[s][i];\n    }\n  }\n  if(lb>ub)return false;\n  for(int i=1;i<=n;i++){\n    if(!(g&1<<i)&&t+d[s][i]<l[i]){\n      if(dfs(i,t+d[s][i],g|1<<i))return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin>>n>>hx>>hy>>dx>>dy,n|hx|hy|dx|dy){\n    int cx[21]={hx},cy[21]={hy};\n    for(int i=1;i<=n;i++){\n      cin>>cx[i]>>cy[i];\n    }\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\td[i][j]=sqrt(S(cx[i]-cx[j])+S(cy[i]-cy[j]));\n      }\n    }\n    for(int i=1;i<=n;i++){\n      l[i]=sqrt(S(dx-cx[i])+S(dy-cy[i]));\n    }\n    cout<<(dfs(0,0,1)?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\ntemplate <class T>\nT next_combination(T combi)\n{\n\tT leastBit = combi & -combi;\n\tT mostBits = combi + leastBit;\n\tT leastSequentialBits = combi & ~mostBits;\n\treturn mostBits | ((leastSequentialBits / leastBit) >> 1);\n}\ndouble dist(int x1, int y1, int x2, int y2)\n{\n\tint x = x1 - x2, y = y1 - y2;\n\treturn sqrt(0.0 + x*x + y*y);\n}\nint main()\n{\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n)\n\t{\n\t\tint x[32], y[32];\n\t\trep (i, n)\n\t\t\tcin >> x[i] >> y[i];\n\t\tx[n] = hx, y[n] = hy;\n\t\tx[n + 1] = dx, y[n + 1] = dy;\n\t\tdouble dis[32][32];\n\t\tfor (int i = 0; i <= n + 1; ++i)\n\t\t\tfor (int j = 0; j <= n + 1; ++j)\n\t\t\t\tdis[i][j] = dist(x[i], y[i], x[j], y[j]);\n\n\n\t\tstatic double dp[1 << 20][20];\n\t\tconst double INF = 1e9;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tdp[i][j] = INF;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (dis[n][i] < dis[n + 1][i])\n\t\t\t\tdp[1 << i][i] = dis[n][i];\n\n\t\tfor (int bits = 1; bits <= n; ++bits)\n\t\t{\n\t\t\tfor (int s = (1 << bits) - 1; s < 1 << n; s = next_combination(s))\n\t\t\t{\n\t\t\t\tbool alive = false;\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t{\n\t\t\t\t\tif (!(s >> i & 1) || dp[s][i] == INF)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\talive = true;\n\t\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s >> j & 1)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdouble t = dp[s][i] + dis[i][j];\n\t\t\t\t\t\tif (t < dis[n + 1][j])\n\t\t\t\t\t\t\tmin_swap(dp[s | 1 << j][j], t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!alive)\n\t\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\nend:\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (dp[(1 << n) - 1][i] + 1e-9 < dis[n + 1][i])\n\t\t\t\tres = true;\n\t\tcout << (res ? \"YES\" : \"NO\") << endl;\n\t\t//cout.precision(9);\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//\tcout << dp[(1 << n) - 1][i] << \" / \" << dis[n + 1][i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//56\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\n#define S(X) ((X)*(X))\n\nint n,hx,hy,dx,dy;\ndouble d[21][21];\ndouble l[21];\n\nbool dfs(int s,double t,int g){\n  if(g==(1<<n+1)-1)return true;\n  for(int i=1;i<=n;i++){\n    if(!(g&1<<i)){\n      if(l[i]<t+d[s][i])return false;\n    }\n  }\n  for(int i=1;i<=n;i++){\n    if(!(g&1<<i)&&t+d[s][i]<l[i]){\n      if(dfs(i,t+d[s][i],g|1<<i))return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin>>n>>hx>>hy>>dx>>dy,n|hx|hy|dx|dy){\n    int cx[21]={hx},cy[21]={hy};\n    for(int i=1;i<=n;i++){\n      cin>>cx[i]>>cy[i];\n    }\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\td[i][j]=sqrt(S(cx[i]-cx[j])+S(cy[i]-cy[j]));\n      }\n    }\n    for(int i=1;i<=n;i++){\n      l[i]=sqrt(S(dx-cx[i])+S(dy-cy[i]));\n    }\n    cout<<(dfs(0,0,1)?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nint n;\nVVD dp;\nVVB done;\nVVD dist;\nVD limit;\nvector<P> p_cristal;\n\ndouble euclid_distance(P p1, P p2)\n{\n\treturn sqrt(norm(p2 - p1));\n}\n\ndouble optimal_time(int status, int position)\n{\n\tif (done[status][position]) {\n\t\treturn dp[status][position];\n\t}\n\tif (!(status & BIT(position))) {\n\t\treturn INF;\n\t}\n\tint prev_status = status ^ BIT(position);\n\tif (prev_status == 0) {\n\t\t// Hero to this position\n\t\tdp[status][position] = dist[dist.size()-1][position];\n\t} else {\n\t\tFOR (prev_position, 0, n) {\n\t\t\tdp[status][position] = min(dp[status][position], optimal_time(prev_status, prev_position) + dist[prev_position][position]);\n\t\t}\n\t}\n\tdone[status][position] = true;\n\tif (dp[status][position] >= limit[position]) {\n\t\treturn dp[status][position] = INF;\n\t} else {\n\t\treturn dp[status][position];\n\t}\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n ^ hx ^ hy ^ dx ^ dy) {\n\t\tp_cristal.clear();\n\t\tREP (_, n) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tp_cristal.PB(P(x, y));\n\t\t}\n\t\tp_cristal.PB(P(hx, hy)); // NOTICE: Push Hero\n\t\tdist = VVD(p_cristal.size(), VD(p_cristal.size()));\n\t\tREP (i, p_cristal.size()) {\n\t\t\tREP (j, p_cristal.size()) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdist[i][j] = euclid_distance(p_cristal[i], p_cristal[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlimit = VD(p_cristal.size(), 0);\n\t\tREP (i, limit.size()) {\n\t\t\tlimit[i] = euclid_distance(p_cristal[i], P(dx, dy));\n\t\t}\n\n\t\tdp = VVD(BIT(n));\n\t\tdone = VVB(BIT(n), VB(n, false));\n\t\tFOR (c, 1, n) {\n\t\t\tif (c > 2) {\n\t\t\t\tint comb = (1 << (c-2)) - 1;\n\t\t\t\twhile (comb < 1 << n) {\n\t\t\t\t\t// Release memory\n\t\t\t\t\tVD tmp;\n\t\t\t\t\tdp[comb].swap(tmp);\n\t\t\t\t\tint lsb = comb & -comb;\n\t\t\t\t\tint upper = comb + lsb;\n\t\t\t\t\tint downer = ((comb & ~upper) / lsb) >> 1;\n\t\t\t\t\tcomb = upper | downer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint comb = (1 << c) - 1;\n\t\t\twhile (comb < 1 << n) {\n\t\t\t\tdp[comb].assign(n, INF);\n\t\t\t\tREP (p, n) {\n\t\t\t\t\toptimal_time(comb, p);\n\t\t\t\t}\n\t\t\t\tint lsb = comb & -comb;\n\t\t\t\tint upper = comb + lsb;\n\t\t\t\tint downer = ((comb & ~upper) / lsb) >> 1;\n\t\t\t\tcomb = upper | downer;\n\t\t\t}\n\t\t}\n\n\t\t// Check if possible\n\t\tint final_status = BIT(n) - 1;\n\t\tdp[final_status].assign(n, INF);\n\t\tdouble t_ans = INF;\n\t\tREP (p, n) {\n\t\t\tt_ans = min(t_ans, optimal_time(final_status, p));\n\t\t}\n\t\tif (t_ans != INF) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\nint n;\nint x[30], y[30],h1,h2,d1,d2;\n  \ndouble dist(int a, int b){\n    return sqrt(a*a+b*b+0.0);\n}  \nint main(){\n    while(1){\n\t\tbool ok=true;\n        cin >> n;\n        if(n == 0) break;\n        cin >>h1>>h2>>d1>>d2;\n        for(int i=0;i<n;i++){\n            cin >> x[i] >> y[i];\n\t\t\tif(dist(h1-x[0],h2-y[0])+dist(x[0]-x[i],y[0]-y[i]) >= dist(d1-x[i],d2-y[i]))ok=false;\n        }\n  \n        if(ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define MAXNUM 20\n\ntypedef struct s{\n\tdouble d;\n\tint c;\n}status;\n\ndouble dist(double x1,double y1,double x2,double y2){\n\treturn sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\nvoid printB(int n){\n\tint i = 0, a[MAXNUM];\n\tfor(i = 0;i < MAXNUM;i++){\n\t\ta[MAXNUM - 1 - i] = n % 2;\n\t\tn /= 2;\n\t}\n\tfor(i = 0;i < MAXNUM;i++){\n\t\tprintf(\"%d\",a[i]);\n\t}\n}\n\nint main(void){\n\tint i, j, n;\n\tdouble hx, hy, dx, dy, cx[MAXNUM],cy[MAXNUM];\n\tstatus dp[1 << MAXNUM];\n\twhile(1){\n\t\tscanf(\"%d%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(!n && !hx && !hy && !dx && !dy)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i].d = -1;\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tdp[1 << i].d = dist(hx,hy,cx[i],cy[i]);\n\t\t\tdp[1 << i].c = i;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i].d != -1){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & (1 << j) && (dp[i | (1 << j)].d == -1 || dp[i | (1 << j)].d > dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]))){\n\t\t\t\t\t\tdp[i | (1 << j)].d = dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]);\n\t\t\t\t\t\tdp[i | (1 << j)].c = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist(dx,dy,cx[dp[(1 << n) - 1].c],cy[dp[(1 << n) - 1].c]) > dp[(1 << n) - 1].d)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n/*\t\tfor(i = 0;i < (1 << MAXNUM);i++){\n\t\t\tprintf(\"dp[\");\n\t\t\tprintB(i);\n\t\t\tprintf(\"] = %f\\n\",dp[i].d);\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <tr1/unordered_map>\n\nusing namespace std;\n\n#define fi first\n#define se second\n\nint N;\nint hx, hy, mx, my;\ntypedef pair<double, double> P;\nP cs[21];\n\n#define SQ(x) ((x)*(x))\ninline double dist(P a, P b) {\n  return sqrt(SQ(a.fi-b.fi) + SQ(a.se-b.se));\n}\n\nunordered_map<int, double> umap;\n\ndouble G[22][22];\nbool dfs(int S, int now, double cost) {\n  \n  if(S == (1<<N)-1) {\n    return true;\n  }\n  \n  dp[S] = cost;\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(G[i][N+1] <= cost+G[now][i]) return false;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(dp.count(S|(1<<i)) && dp[S|(1<<i)] <= cost+G[now][i]) continue;\n    if(dfs(S|(1<<i), i, cost+G[now][i]) return true;\n  }\n  \n  return false;\n}\n\nbool solve() {\n  \n  for(int i=0; i<N; i++) {\n    for(int j=i+1; j<N; j++) {\n      G[i][j] = G[j][i] = dist(cs[i], cs[j]);\n    }\n    G[N][i] = G[i][N] = dist(P(hx, hy), cs[i]);\n    G[N+1][i] = G[i][N+1] = dist(P(mx, my), cs[i]);\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(dfs(1<<i, i, 0.)) return true;\n  }\n  \n  return false;\n}\n\nint main() {\n  while(1) {\n    cin >> N >> hx >> hy >> mx >> my;\n    if(!N) break;\n    for(int i=0; i<N; i++) {\n      cin >> cs[i].fi >> cs[i].se << endl;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define MAX 20\ntypedef pair<double,double> P;\ntypedef pair<double,P> Q;\n\nint N;\nP h, d, crystal[MAX];\n\ndouble dist(P a, P b){\n  return sqrt(pow(a.fi-b.fi,2) + pow(a.se-b.se,2));\n}\n\nbool solve(){\n  vector<Q> dd;\n  P p[MAX];\n\n  for(int i = 0 ; i < N ; i++){\n    dd.push_back(Q(dist(h, crystal[i]), crystal[i]));\n  }\n  sort(dd.begin(), dd.end());\n  for(int i = 0 ; i < N ; i++){\n    p[i] = dd[i].se; \n  }\n\n  double total_dist = 0;\n  for(int i = 0 ; i < N ; i++){\n    total_dist += dist(h,p[i]);\n    if(total_dist >= dist(d, p[i])){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> N >> h.fi >> h.se >> d.fi >> d.se, (N + h.fi + h.se + d.fi + d.se)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].fi >> crystal[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator >> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// 内積（ドット積）\ndouble dot( const Point &a, const Point &b )\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\n// 外積（クロス積）\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\n// 点 p と直線 ( q1, q2 ) の距離\n// include : cross\ndouble distancePL( const Point &p, const Point &q1, const Point &q2 )\n{\n\treturn abs( cross( q2 - q1, p - q1 ) ) / abs( ( q2 - q1 ) );\n}\n\n// 点 p と線分 ( q1, q2 ) の距離\n// include : dot, distancePL\ndouble distancePS( const Point p, const Point &q1, const Point &q2 )\n{\n\tif ( EPS < dot( q2 - q1, p - q1 ) && EPS < dot( q1 - q2, p - q2 ) ) // 垂線が交わる\n\t{\n\t\treturn distancePL( q1, q2, p );\n\t}\n\telse\n\t{\n\t\treturn min( abs( q1 - p ), abs( q2 - p ) );\n\t}\n}\n\nconstexpr double INF = DBL_MAX / 10;\n\nbool ok( const double stime, const Point &p1, const Point &p2, const Point &q )\n{\n\tif ( abs( p2 - q ) - EPS <= stime + abs( p1 - p2 ) )\n\t{\n\t\treturn false;\n\t}\n\n\tif ( !( EPS < dot( p2 - p1, q - p1 ) && EPS < dot( p1 - p2, q - p2 ) ) )\n\t{\n\t\treturn true;\n\t}\n\n\tconst double d = sqrt( pow( abs( q - p1 ), 2. ) - pow( distancePS( q, p1, p2 ), 2. ) );\n\treturn stime + d + EPS < distancePS( q, p1, p2 );\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tPoint h, d;\n\tfor ( int n; cin >> n >> h >> d, n; )\n\t{\n\t\tvector<Point> cs( n );\n\t\tFOR( c, cs )\n\t\t{\n\t\t\tcin >> c;\n\t\t}\n\n\t\tvector< vector<double> > dp( 1 << n, vector<double>( n, INF ) );\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tif ( abs( cs[i] - h ) + EPS < abs( cs[i] - d ) && ok( 0, h, cs[i], d ) )\n\t\t\t{\n\t\t\t\tdp[ 1 << i ][i] = abs( cs[i] - h );\n\t\t\t}\n\t\t}\n\n\t\tREP( bits, 1, 1 << n )\n\t\t{\n\t\t\tREP( i, 0, n )\n\t\t\t{\n\t\t\t\tREP( j, 0, n )\n\t\t\t\t{\n\t\t\t\t\tif ( dp[ bits ][i] + abs( cs[j] - cs[i] ) + EPS < abs( cs[j] - d ) && ok( dp[ bits ][i], cs[i], cs[j], d ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[ bits | 1 << j ][j] = min( dp[ bits | 1 << j ][j], dp[ bits ][i] + abs( cs[i] - cs[j] ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ( *min_element( ALL( dp.back() ) ) != INF ? \"YES\" : \"NO\" ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX], ok;\n\nvoid rec(int S, int v, double total_dist){\n  if(ok) return;\n\n  if(S == (1 << N) - 1){\n    ok = true;\n    return;\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1)){\n      Segment s = Segment(crystal[v], crystal[u]);\n      if(s.distanceSP(d) < total_dist) return;\n      if(total_dist+dist(crystal[v],crystal[u]) >= dist(d, crystal[u])){\n\treturn;\n      }\n    }\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(ok) return;\n    if(!(S >> u & 1)){\n      rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]));\n    }\n  }\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n\n  ok = false;\n  memset(used, false, sizeof(used));\n  rec(0, 0, dist(h, crystal[0]));\n  if(ok){\n    return true;\n  }\n  \n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// ????????????????????????±?????????±???\n??\nint n;\nint x[30], y[30];\n??\ndouble dist(int a, int b){\n????????return sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));\n}\n??\nbool solve(){\n????????for(int i=0;i<n;i++){\n????????????????if(dist(n, 0) + dist(0, i) >= dist(n+1, i)) return false;\n????????}\n????????return true;\n}\n??\nint main(){\n????????while(1){\n????????????????cin >> n;\n????????????????if(n == 0) break;\n????????????????cin >> x[n] >> y[n] >> x[n+1] >> y[n+1];\n????????????????for(int i=0;i<n;i++){\n????????????????????????cin >> x[i] >> y[i];\n????????????????}\n??\n????????????????if(solve()) cout << \"YES\" << endl;\n????????????????else cout << \"NO\" << endl;\n????????}\n????????return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define MAX 20\n#define EPS 1e-5\ntypedef pair<double,double> P;\n\nint N;\nP h, d, crystal[MAX];\n\ndouble dist(P a, P b){\n  return sqrt(pow(a.fi-b.fi,2) + pow(a.se-b.se,2));\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n\n  double total_dist = 0;\n  for(int i = 0 ; i < N ; i++){\n    total_dist += dist(h, crystal[i]);\n    if(total_dist+EPS >= dist(d, crystal[i])){\n      return false;\n    }\n    h = crystal[i];\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> N >> h.fi >> h.se >> d.fi >> d.se, (N + h.fi + h.se + d.fi + d.se)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].fi >> crystal[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cmath>\n//S \nusing namespace std;\ntypedef pair<int,int> P;\nint cx[30],cy[30],n,hx,hy,dx,dy;\nmap<P,double> mp;\nbool func(int S,int now,double time){\n\tif(S==(1<<n)-1)\n\t\treturn 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(!(S&(1<<i))){\n\t\t\tdouble pre=mp[P(now,i)];\n\t\t\tdouble dis=mp[P(i,n+1)];\n\t\t\tif(pre+time<dis&&func(S|(1<<i),i,time+pre))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin>>n>>hx>>hy>>dx>>dy,n||hx||hy||dx||dy){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>cx[i]>>cy[i];\n\t\tcx[n]=hx;\n\t\tcy[n]=hy;\n\t\tcx[n+1]=dx;\n\t\tcy[n+1]=dy;\n\t\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\tmp[P(i,j)]=sqrt((cx[i]-cx[j])*(cx[i]-cx[j])+(cy[i]-cy[j])*(cy[i]-cy[j]));\n\t\tif(func(0,n,0.0))\n\t\t\tcout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t\tmp.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *  Author: mizo0203\n *  Problem: 2008\n *  Status: Accepted\n *  Submission Date: 2012/04/17 18:28:54\n *\n *  方策：幅優先による全探索+枝刈り\n */\n#include <stdio.h>\n#include <math.h>\n\nint n;\nint hx, hy, dx, dy;\nint cx[20], cy[20];\ndouble cdis[20]; // 魔王とクリスタルの距離\n\n// 初期化\nvoid init() {\n}\n\n// 入力\nbool input() {\n  int i;\n\n  scanf(\"%d %d %d %d %d\", &n, &hx, &hy, &dx, &dy);\n  if (!n && !hx && !hy && !dx && !dy)\n    return false;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d %d\", &cx[i], &cy[i]);\n    cdis[i] = hypot(dx - cx[i], dy - cy[i]); // 魔王とクリスタルの距離を算出\n  }\n  return true;\n}\n\n// 再帰関数\n// bit:クリスタルの回収状況 sum:勇者の総移動距離 x,y:勇者の現在地\nbool recursive(long bit, double sum, int x, int y) {\n  int i;\n  double minD = 2000000.0; // 魔王と魔王に最も近いクリスタルの距離\n  double maxH = -1.0; // 勇者の総移動距離+勇者と魔王に最も近いクリスタルの距離\n\n\n  /* 【探索終了】\n   * 全てのbitが立つとクリスタルの収集が完了したため\n   * 探索を終了する\n   */\n  for (i = 0; i < n; i++)\n    if (~bit & 1 << i) // 未回収のクリスタルがあるならば\n      break;\n  if (i == n) // クリスタルの回収完了\n    return true;\n\n  /* 【枝刈り】\n   * 「勇者の総移動距離+勇者と魔王に最も近いクリスタルの距離」が\n   * 「魔王と魔王に最も近いクリスタルの距離」以上長いならば\n   * 勇者は魔王に最も近いクリスタルが回収不能のため\n   * それ以上の探索をしない\n   */\n  for (i = 0; i < n; i++) { // 魔王に最も近いクリスタルを探索\n    if (bit & 1 << i) // 回収済みのクリスタルはスルー\n      continue;\n    if (minD > cdis[i]) {\n      minD = cdis[i];\n      maxH = hypot(x - cx[i], y - cy[i]) + sum;\n    }\n  }\n  if (maxH >= minD) // 枝刈り発生\n    return false;\n\n  /* 【幅優先探索】\n   * 未回収のクリスタルを回収する\n   * 全ての順列を試みる\n   */\n  for (i = 0; i < n; i++) {\n    if (bit & 1 << i) // 回収済みのクリスタルはスルー\n      continue;\n    if (recursive(bit | 1 << i, sum + hypot(x - cx[i], y - cy[i]), cx[i], cy[i]))\n      return true; // 回収完了したらならば探索終了\n  }\n\n  return false;\n}\n\nint main() {\n\n  init(); // 初期化\n  while (input()) { // 入力\n    if (recursive(0, 0.0, hx, hy)) { // 再帰関数\n      printf(\"YES\\n\");\n    } else {\n      printf(\"NO\\n\");\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nbool used[21];\nint n,hx,hy,dx,dy;\nvector<int> cx(21),cy(21);\nvector<double> dist(21);\ndouble pointdistance(int x1, int y1, int x2, int y2){\n  return sqrt( (x1-x2)*(x1-x2) +(y1-y2)*(y1-y2) );\n}\nint dfs(int x, int y, int t,double s){\n  if(t==n) return true;\n  REP(i,n){\n    if(!used[i]){\n      double nexts = s + pointdistance(x,y,cx[i],cy[i]);\n      if(nexts > dist[i] - EPS) return false; \n      else {\n        used[i] = true;\n        if(dfs(cx[i],cy[i],t+1,nexts)) return true;\n        used[i] = false;\n      }\n    }\n  }\n  return false;\n}\n\nint main(void){\n  while(cin>>n>>hx>>hy>>dx>>dy,n){\n    REP(i,n)cin>>cx[i]>>cy[i];\n    REP(i,n)dist[i] = sqrt((cx[i]-dx)*(cx[i]-dx) +(cy[i]-dy)*(cy[i]-dy) );\n    memset(used,0,sizeof(used));\n    if(dfs(hx,hy,0,0.0)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAXN 21\n\nint n, hx, hy, dx, dy;\nint cx[MAXN], cy[MAXN];\nint dist(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\nint time(int x, int y) {\n    return abs(dx - x) + abs(dy - y);\n}\nstruct P {\n    int x, y, t;\n    P(int x, int y, int t) : x(x), y(y), t(t) {}\n};\nint fx[] = {1, 0, -1, 0},\n    fy[] = {0, 1, 0, -1};\nint move(int s, int d, int t) {\n    int cdt = time(cx[d], cy[d]); // crystal destoyed time\n    int nt = t + dist(cx[s], cy[s], cx[d], cy[d]);\n    return (cdt > nt ? nt : -1);\n    //queue<P> Q;\n    //Q.push(P(cx[s], cy[s], t));\n    //while (!Q.empty()) {\n    //    P p = Q.front(); Q.pop();\n    //    if (p.t >= cdt) {\n    //        return -1; // クリスタルが破壊された\n    //    }\n    //    if (p.t >= time(p.x, p.y)) {\n    //        continue; // 移動できない\n    //    }\n    //    if (p.x == cx[d] && p.y == cy[d]) {\n    //        return p.t;\n    //    }\n    //    for (int i = 0; i < 4; i++) {\n    //        Q.push(P(p.x + fx[i], p.y + fy[i], p.t+1));\n    //    }\n    //}\n    //return -1; // 到達できない\n}\nbool solve(int v, int used, int t) {\n    if (used == (1<<(n+1))-1) {\n        return true;\n    }\n    for (int i = 0; i <= n; i++) {\n        if (used & (1<<i)) {\n            continue;\n        }\n        int rt = move(v, i, t); // reached time\n        if (rt < 0) {\n            continue;\n        }\n        if (solve(i, used | (1<<i), rt)) {\n            return true; // 1つでも解があればOk\n        }\n    }\n    return false;\n}\nint main() {\n    while (cin >> n >> hx >> hy >> dx >> dy, n || hx || hy || dx || dy) {\n        cx[0] = hx, cy[0] = hy;\n        for (int i = 1; i <= n; i++) {\n            cin >> cx[i] >> cy[i];\n        }\n        cout << (solve(0, 1, 0) ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ndouble lim[20],limbit[1<<20],inf=1e9,eps=1e-9,limit[21][21];\nint n,hx,hy,mx,my,cx[21],cy[21];\nvoid calc(){\n\trep(i,n+1) rep(j,n+1){\n\t\tif(i==j) limit[i][j]=0;\n\t\tdouble sx=cx[i],sy=cy[i],tx=cx[j],ty=cy[j],d=sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy)),dx=(tx-sx)/d,dy=(ty-sy)/d,x=sx-mx,y=sy-my;\n\t\tdouble b=2*d,c=-(x*x+y*y+2*d*(x*dx+y*dy));\n\t\tlimit[i][j]=(-b+sqrt(b*b-4*c))/2;\n\t}\n}\nbool dfs(int bit,int v,double t){\n\tif(bit==(1<<n)-1) return true;\n\tif(t+eps>limbit[bit]) return false;\n\trep(i,n){\n\t\tif((bit>>i)&1) continue;\n\t\tif(t+eps>limit[v][i]) return false;\n\t}\n\trep(i,n){\n\t\tif((bit>>i)&1) continue;\n\t\tif(dfs(bit+(1<<i),i,t+sqrt((cx[i]-cx[v])*(cx[i]-cx[v])+(cy[i]-cy[v])*(cy[i]-cy[v])))) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d%d%d%d\",&n,&cx[n],&cy[n],&mx,&my);\n\t\tif(n==0) break;\n\t\trep(i,n){\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\t\tlim[i]=sqrt((cx[i]-mx)*(cx[i]-mx)+(cy[i]-my)*(cy[i]-my));\n\t\t}\n\t\trep(i,1<<n){\n\t\t\tlimbit[i]=inf;\n\t\t\trep(j,n){\n\t\t\t\tif((i<<j)&1==0) limbit[i]=min(limbit[i],lim[j]);\n\t\t\t}\n\t\t}\n\t\tcalc();\n\t\tcout << (dfs(0,n,0) ? \"YES\\n\" : \"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAXN 20\n\nint n, hx, hy, dx, dy;\nint cx[MAXN], cy[MAXN];\nint time(int x, int y) {\n    return abs(dx - x) + abs(dy - y);\n}\nstruct P {\n    int x, y, t;\n    P(int x, int y, int t) : x(x), y(y), t(t) {}\n};\nint fx[] = {1, 0, -1, 0},\n    fy[] = {0, 1, 0, -1};\nint move(int s, int d, int t) {\n    int cdt = time(cx[d], cy[d]); // crystal destoyed time\n    queue<P> Q;\n    Q.push(P(cx[s], cy[s], t));\n    while (!Q.empty()) {\n        P p = Q.front(); Q.pop();\n        if (p.t >= cdt) {\n            return -1; // クリスタルが破壊された\n        }\n        if (p.t >= time(p.x, p.y)) {\n            continue; // 移動できない\n        }\n        if (p.x == cx[d] && p.y == cy[d]) {\n            return p.t;\n        }\n        for (int i = 0; i < 4; i++) {\n            Q.push(P(p.x + fx[i], p.y + fy[i], p.t+1));\n        }\n    }\n    return -1; // 到達できない\n}\nbool solve(int v, int used, int t) {\n    if (used == (1<<(n+1))-1) {\n        return true;\n    }\n    for (int i = 0; i <= n; i++) {\n        if (used & (1<<i)) {\n            continue;\n        }\n        int rt = move(v, i, t); // reached time\n        if (rt < 0) {\n            continue;\n        }\n        if (solve(i, used | (1<<i), rt)) {\n            return true; // 1つでも解があればOk\n        }\n    }\n    return false;\n}\nint main() {\n    while (cin >> n >> hx >> hy >> dx >> dy, n || hx || hy || dx || dy) {\n        cx[0] = hx, cy[0] = hy;\n        for (int i = 1; i <= n; i++) {\n            cin >> cx[i] >> cy[i];\n        }\n        cout << (solve(0, 1, 0) ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second \n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n\ndouble cost[22][22];\ndouble tlimit[22];\nint xx[22];\nint cx[22], cy[22];\nint n;\n\nbool DFS(int pos, int vis, double dis){\n\tif(vis == ((1<<(n+1))-1))return true;\n\t//枝狩り\n\tFOR(i, 1, n+1)if((vis&xx[i])==0 && (dis+cost[pos][i] > tlimit[i]+EPS))return false;\n\tFOR(i, 1, n+1){\n\t\tif((vis&xx[i])==0 && (dis+cost[pos][i]+EPS < tlimit[i])){\n\t\t\tif(DFS(i, vis|xx[i], dis+cost[pos][i])){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tREP(i,22){\n\t\txx[i] = 1<<i;\n\t}\n\twhile(1){\n\t\tint dx,dy;\n\t\tcin>>n>>cx[0]>>cy[0]>>dx>>dy;\n\t\tFOR(i,1,n+1)cin >> cx[i] >> cy[i];\n\t\tREP(i, n+1){\n\t\t\ttlimit[i] = sqrt(pow(cx[i]*1.0-dx*1.0,2.0)+pow(cy[i]*1.0-dy*1.0,2.0));\n\t\t\tREP(j,n+1){\n\t\t\t\tcost[i][j] = sqrt(pow(cx[i]*1.0-cx[j]*1.0,2.0)+pow(cy[i]*1.0-cy[j]*1.0,2.0));\n\t\t\t}\n\t\t}\n\t\tif(DFS(0, 1, 0.0))cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<double, double> P;\nint N;\nP h, d, cs[20];\n\n#define SQ(x) ((x)*(x))\n\ninline double getDist(P a, P b) {\n  return sqrt(SQ(a.fi-b.fi) + SQ(a.se-b.se));\n}\n\ndouble dist[22][22];\n\nmap<int, double> mp;\n\nbool dfs(int S, int now, double cost) {\n  \n  if(S == (1<<N)-1) {\n    return true;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(dist[i][N+1] <= cost + dist[now][i]) return false;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(mp.count(S+(1<<i)) && mp[S+(1<<i)] <= cost+dist[now][i]) continue;\n    mp[S+(1<<i)] = cost+dist[now][i];\n    if(dfs(S+(1<<i), i, cost+dist[now][i])) return true;\n  }\n  \n  return false;\n}\n\nbool solve() {\n  \n  mp.clear();\n  \n  for(int i=0; i<N; i++) {\n    for(int j=i+1; j<N; j++) {\n      dist[i][j] = dist[j][i] = getDist(cs[i], cs[j]);\n    }\n    dist[i][N] = dist[N][i] = getDist(cs[i], h);\n    dist[i][N+1] = dist[N+1][i] = getDist(cs[i], d);\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(dist[i][N+1] <= dist[i][N]) continue;\n    if(dfs(1<<i, i, dist[N][i])) return true;\n  }\n  return false;\n}\n\nint main() {\n  \n  while(cin >> N >> h.fi >> h.se >> d.fi >> d.se && (N)) {\n    for(int i=0; i<N; i++) {\n      cin >> cs[i].fi >> cs[i].se;\n    }\n    \n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include <queue>\nusing namespace std;\n#define MAX_N 20\n#define OVER 9999999\n\nint syo[MAX_N];\nint isi_x[MAX_N];\nint isi_y[MAX_N];\nint edge[MAX_N][MAX_N];\nint dp[1<<MAX_N][MAX_N];\nint hx,hy,n;\nbool chack;\n\nstruct node{\n  int S,v,cost;\n  node(int s, int vv,int c): S(s), v(vv),cost(c){}\n  bool operator >(const node &e) const{\n    return cost > e.cost;\n  }\n};\n\n/*\n  bool rec(int S, int v,int t)\n  {\n  if(chack)\n  return true;\n  // cout<<v<<endl;\n\n  \n  if(S==0)\n  cout<<\"0\";\n  for(int i=S;i!=0;)\n  {\n  cout<<i%2;\n  i=i/2;\n  } \n  printf(\" %d %d\\n\",v,t);  \n  \n  //  if(S==0)\n  //    dp[1<<v][v]=t;\n  if(dp[S][v]<t)\n  return false;\n  dp[S][v]=t;\n  if(t>=syo[v])\n  return false;\n  // cout<<\"ALL:\"<<(1<<n)-1<<endl;\n  if(S==(1<<n)-1)\n  {\n  chack=true;\n  return true;\n  }\n  //int res=OVER;\n  for(int i=0;i<n;i++)\n  {\n  if(!(S>>i&1))\n  {\n  rec(S|1<<i,i,t+edge[v][i]);\n  }\n  }\n  return false;\n  }\n*/\n\nint main()\n{\n  int dx,dy;\n\n  for(;cin>>n>>hx>>hy>>dx>>dy,n;)\n    {\n      bool chack=false;\n      //memset(dp,false,sizeof(dp));\n      for(int i=0;i<n;i++)\n\t{\n\t  cin>>isi_x[i]>>isi_y[i];\n\t  syo[i]=abs(dx-isi_x[i])+abs(dy-isi_y[i])-1;\n\t}\n      for(int i=0;i<n;i++)    \n\tfor(int j=0;j<n;j++)  \n\t  edge[i][j]=abs(isi_x[i]-isi_x[j])+abs(isi_y[i]-isi_y[j]);\n      \n      // cout<<\"aaa\"<<endl;\n      //     int ans = OVER;\n      priority_queue<node, vector<node>, greater<node> > P;\n      // priority_queue<node> P;\n      for(int i=0;i<n;i++)\n\t{\n\t  P.push(node(1<<i,i,abs(isi_x[i]-hx)+abs(isi_y[i]-hy)));\n\t  //\t if(!chack)\n\t  //   rec(1<<i,i,abs(isi_x[i]-hx)+abs(isi_y[i]-hy));\n\t}\n      for(;!P.empty();)\n\t{\n\t  node s = P.top();\n\t  P.pop();\n\n\t  for(int i=0;i<n;i++)\n\t    {\n\t      if((!(s.S>>i&1) && s.cost>=syo[i]))\n\t\t{\n\t\t  P = priority_queue<node, vector<node>, greater<node> >();\n\t\t  s.cost=OVER;\n\t\t  break;\n\t\t}\n\t    }\n\t  \n\t  if(s.cost>=syo[s.v])\n\t    break;\n\t  \n\t  if(s.S==(1<<n)-1)\n\t    {\n\t      chack=true;\n\t\t  break;\n\t    }\n\t  for(int i=0;i<n;i++)\n\t    {\n\t      if(!(s.S>>i&1))\n\t\t{\n\t\t  P.push(node(s.S|1<<i,i,s.cost+edge[s.v][i]));\n\t\t}\n\t    }\n\t}\n      if(chack)\n\tcout<<\"YES\"<<endl;\n      else\n\tcout<<\"NO\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define X first\n#define Y second\n\ntemplate<typename T> istream& operator>>(istream& is, pair<T, T>& p) {\n\tcin >> p.X >> p.Y;\n\treturn is;\n}\n\ninline double dist(const pair<int, int>& a, const pair<int, int>& b) {\n\tint diffX = a.X - b.X, diffY = a.Y - b.Y;\n\treturn sqrt(diffX * diffX + diffY * diffY);\n}\n\nint n;\npair<int, int> hero, demon;\nvector<pair<int, int> > crystal;\n\nbool dfs(pair<int, int> pos = hero, int day = 0, int visited = 0) {\n\tif(visited == (1 << n) - 1)\n\t\treturn true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif((visited >> i) & 1)\n\t\t\tcontinue;\n\n\t\tconst int next = ceil(dist(pos, crystal[i])) + day;\n\t\tif(next >= dist(crystal[i], demon))\n\t\t\treturn false;\n\n\t\tif(dfs(crystal[i], next, (visited | (1 << i))))\n\t\t   return true;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n >> hero >> demon, n) {\n\t\tcrystal.resize(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tcin >> crystal[i];\n\n\t\tcout << (dfs() ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P> PP;\n#define INF (1<<24)\n#define EPS 1e-10\nint n;\ndouble sx,sy,tx,ty,px[20],py[20];\ndouble tab[(1<<20)][20];\n\ndouble dis(double a,double b,double c,double d)\n{return sqrt((a-c)*(a-c)+(b-d)*(b-d));}\ndouble dis(int a,int b){return dis(px[a],py[a],px[b],py[b]);}\n\nint main(){\n  while(1){\n    cin>>n>>sx>>sy>>tx>>ty;\n    if(n==0&&sx==0&&sy==0&&tx==0&&ty==0)break;\n    for(int i=0;i<n;i++)cin>>px[i]>>py[i];\n    for(int i=0;i<(1<<n);i++)\n      for(int j=0;j<n;j++)tab[i][j]=INF;\n    priority_queue<PP> Q;\n    for(int i=0;i<n;i++){\n      Q.push( PP(dis(sx,sy,px[i],py[i]),P((1<<i),i) ) );\n      tab[(1<<i)][i]=dis(sx,sy,px[i],py[i]);\n    }\n\n    while(!Q.empty()){\n      PP tmp=Q.top();Q.pop();\n      double total=tmp.first;\n      int S=tmp.second.first,pos=tmp.second.second;\n\n      bool flg=false;    \n      for(int i=0;i<n;i++)\n\tif(total+dis(pos,i)>dis(tx,ty,px[i],py[i]))flg=true;\n      if(flg)continue;\n      \n      for(int i=0;i<n;i++){\n\tif((S>>i)&1)continue;\n\tif(total+dis(pos,i)>=tab[S|(1<<i)][i])continue;\n\tif(total+dis(pos,i)>=dis(tx,ty,px[i],py[i]))continue;\n\ttab[S|(1<<i)][i]=total+dis(pos,i);\n\tQ.push( PP(total+dis(pos,i),P(S|(1<<i),i)) );\n      }\n    }\n    \n    bool flag=false;\n    for(int i=0;i<n;i++)if(tab[(1<<n)-1][i]!=INF)flag=true;\n    cout<<(flag?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ndouble lim[20],inf=1e9,eps=1e-9;\nint n,hx,hy,mx,my,cx[21],cy[21];\nbool isok(double sx,double sy,double tx,double ty,double t0){\n\tdouble d=sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy)),dx=(tx-sx)/d,dy=(ty-sy)/d,x=sx-mx,y=sy-my;\n\tdouble a=dx*dx+dy*dy-1,b=2*(x*dx+y*dy-t0),c=x*x+y*y-t0*t0;\n\tif(abs(b)<eps){\n\t\tif(abs(c)>eps) return false;\n\t\treturn true;\n\t}\n\treturn !(0<-c/b+eps && -c/b<d+eps);\n}\nbool dfs(int bit,int v,double t){\n\tif(bit==(1<<n)-1) return true;\n\trep(j,n) if( ((bit>>j)&1) && t+eps>lim[j]) return false;\n\trep(i,n){\n\t\tif((bit>>i)&1) continue;\n\t\tif(!isok(cx[v],cy[v],cx[i],cy[i],t)) continue;\n\t\tif(dfs(bit+(1<<i),i,t+sqrt((cx[i]-cx[v])*(cx[i]-cx[v])+(cy[i]-cy[v])*(cy[i]-cy[v])))) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> cx[n] >> cy[n] >> mx >> my;\n\t\tif(n==0) break;\n\t\trep(i,n){\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tlim[i]=sqrt((cx[i]-mx)*(cx[i]-mx)+(cy[i]-my)*(cy[i]-my));\n\t\t}\n\t\tcout << (dfs(0,n,0) ? \"YES\\n\" : \"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\nint adj[21][21];\nint hero[20];\nbool visited[20]={false};\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if ( visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    visited[i]=true;\n    if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\nint dist(int x,int y){\n  return (x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n    hero[i]=dist(mx-x[i],my-y[i]);\n    if ( hero[i]>=adj[MAOU][i])return false;\n    visited[i]=false;\n  }\n  \n  rep(i,n){\n    visited[i]=true;\n    if ( backTrack(i,hero[i],1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(scanf(\"%d%d%d%d%d\",&n,&mx,&my,&rx,&ry) && n){\n    int x[n],y[n];\n    rep(i,n)scanf(\"%d%d\",&x[i],&y[i]);\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 20\n#define EPS 1e-9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX];\nbool rec(int now, double total_dist, int depth){\n  if(total_dist >= dist(d, crystal[now])){\n    return false;\n  }\n  if(depth == N){\n    return true;\n  }\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      Segment s = Segment(crystal[now], crystal[i]);\n      Point np = d + crystal[i];\n      if(s.distanceSP(np) < 1) return false;\n      used[i] = true;\n      if(rec(i, total_dist + dist(crystal[now],crystal[i]), depth+1)){\n        return true;\n      }\n      used[i] = false;\n    }\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    memset(used, false, sizeof(used));\n    if(rec(i, dist(h, crystal[i]), 0)){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> x, y;\n\ndouble dist(int a, int b){\n    return sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));\n}\n\nbool solve(){\n    for(int i=0;i<n;i++){\n        if(dist(n, i) >= dist(n+1, i)) return false;\n    }\n    return true;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        x.assign(n+2, 0);\n        y.assign(n+2, 0);\n        cin >> x[n] >> y[n] >> x[n+1] >> y[n+1];\n        for(int i=0;i<n;i++){\n            cin >> x[i] >> y[i];\n        }\n\n        if(solve()){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\ndouble INF=1e16;\ndouble EPS=1e-9;\nclass Main{\n\tpublic:\n\n\n\tint n;double hx,hy,dx,dy;\n\tvector<double> cx,cy;\n\tvector<vector<double>> ds;\n\n\tbool dfs(int v,int bit,double t){\n\t\tif(bit==(1<<n)-1)return true;\n\t\t//cut \n\t\tREP(i,n)if(!((bit>>i)&1)){\n\t\t\tdouble d=v!=-1?hypot(cx[i]-cx[v],cy[i]-cy[v]):hypot(cx[i]-hx,cy[i]-hy);\n\t\t\tif(!(d+t<hypot(cx[i]-dx,cy[i]-dy)))return false;\n\t\t}\n\n\t\tbool ok=false;\n\t\tREP(i,n)if(!((bit>>i)&1)){\n\t\t\tdouble d=v!=-1?hypot(cx[i]-cx[v],cy[i]-cy[v]):hypot(cx[i]-hx,cy[i]-hy);\n\t\t\tif(d+t<hypot(cx[i]-dx,cy[i]-dy))ok|=dfs(i,bit|1<<i,d+t);\n\t\t}\n\t\treturn ok;\n\t}\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tcin >> n >> hx >> hy >> dx >> dy;if(n==0)break;\n\t\t\tcx=vector<double>(n);cy=vector<double>(n);REP(i,n) cin >> cx[i] >> cy[i];\n\n\t\t\tbool ok=false;\n\t\t\tok=dfs(-1,0,0);\n\t\t\tcout << (ok?\"YES\":\"NO\")<<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define MAXNUM 20\n\nstruct status{\n\tdouble d;\n\tint c;\n};\n\ndouble dist(double x1,double y1,double x2,double y2){\n\tdouble ret = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n\treturn ret;\n}\n\nint main(void){\n\tint i, j, n;\n\tdouble hx, hy, dx, dy, cx[MAXNUM],cy[MAXNUM];\n\tstruct status dp[1 << MAXNUM];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tscanf(\"%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0.0 && hy == 0.0 && dx == 0.0 && dy == 0.0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < 1 << MAXNUM;i++)\n\t\t\tdp[i].d = -1;\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tdp[1 << i].d = dist(hx,hy,cx[i],cy[i]);\n\t\t\tdp[1 << i].c = i;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i].d != -1){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & (1 << j) && ((dp[i | (1 << j)].d == -1) || (dp[i | (1 << j)].d > dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j])))){\n\t\t\t\t\t\tdp[i | (1 << j)].d = dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]);\n\t\t\t\t\t\tdp[i | (1 << j)].c = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist(dx,dy,cx[dp[(1 << n) - 1].c],cy[dp[(1 << n) - 1].c]) > dp[(1 << n) - 1].d)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#define sd(i)hypot(sx-x[i],sy-y[i])\n#define md(i)hypot(mx-x[i],my-y[i])\nusing namespace std;\nint n;\nint x[20],y[20];\nint sx,sy,mx,my;\ndouble dp[20][1<<20];\nmain()\n{\n\twhile(cin>>n>>sx>>sy>>mx>>my,n)\n\t{\n\t\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n\t\tfor(int i=0;i<1<<n;i++)for(int j=0;j<n;j++)dp[j][i]=1e9;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tdouble a=sd(i);\n\t\t\tdouble b=md(i);\n\t\t\tif(a<b)dp[i][1<<i]=a;\n\t\t}\n\t\tfor(int i=0;i<1<<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(dp[j][i]==1e9)continue;\n\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(i&(1<<k))continue;\n\t\t\t\t\tdouble d=hypot(x[j]-x[k],y[j]-y[k])+dp[j][i];\n\t\t\t\t\tdouble b=md(k);\n\t\t\t\t\tif(d<b)dp[k][i|(1<<k)]=min(dp[k][i|(1<<k)],d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=0;\n\t\tfor(int i=0;i<n;i++)f|=dp[i][(1<<n)-1]<1e9;\n\t\tcout<<(f?\"YES\":\"NO\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\n#define fi first\n#define se second\n\nint N;\nint hx, hy, mx, my;\ntypedef pair<double, double> P;\nP cs[21];\n\n#define SQ(x) ((x)*(x))\ninline double dist(P a, P b) {\n  return sqrt(SQ(a.fi-b.fi) + SQ(a.se-b.se));\n}\n\nunordered_map<int, double> umap;\n\ndouble G[22][22];\nbool dfs(int S, int now, double cost) {\n  \n  if(S == (1<<N)-1) {\n    return true;\n  }\n  \n  umap[S] = cost;\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(G[i][N+1] <= cost+G[now][i]) return false;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(umap.count(S|(1<<i)) && umap[S|(1<<i)] <= cost+G[now][i]) continue;\n    if(dfs(S|(1<<i), i, cost+G[now][i])) return true;\n  }\n  \n  return false;\n}\n\nbool solve() {\n  \n  for(int i=0; i<N; i++) {\n    for(int j=i+1; j<N; j++) {\n      G[i][j] = G[j][i] = dist(cs[i], cs[j]);\n    }\n    G[N][i] = G[i][N] = dist(P(hx, hy), cs[i]);\n    G[N+1][i] = G[i][N+1] = dist(P(mx, my), cs[i]);\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(dfs(1<<i, i, G[N][i])) return true;\n  }\n  \n  return false;\n}\n\nint main() {\n  while(1) {\n    cin >> N >> hx >> hy >> mx >> my;\n    if(!N) break;\n    for(int i=0; i<N; i++) {\n      cin >> cs[i].fi >> cs[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n\nstatic const double EPS = 1e-8;\n\nint n, hx, hy, dx, dy;\nint x[20], y[20];\nbool flag;\n\nvoid dfs(int unvisit, int cx, int cy, double t){\n    if (flag) return;\n    if (unvisit == 0) flag = true;\n    else {\n\tfor (int i = 0; i < n; i++){\n\t    if (!(unvisit >> i) & 1) continue;\n\t    if (hypot(dx-x[i], dy-y[i]) < t + hypot(cx-x[i], cy-y[i]) + EPS) return;\n\t}\n\n\tfor (int i = 0; i < n; i++){\n\t    if (!((unvisit >> i) & 1)) continue;\n\t    dfs((unvisit & ~(1 << i)), x[i], y[i], t + hypot(cx-x[i], cy-y[i]));\n\t}\n    }\n}\n\n\nstring solve(){\n    flag = false;\n    dfs((1 << n) - 1, hx, hy, 0);\n    return (flag)? \"YES\" : \"NO\";\n}\n\nint main(){\n    while (cin >> n >> hx >> hy >> dx >> dy){\n\tif ((n | hx | hy | dx | dy) == 0) break;\n\tfor (int i = 0; i < n; i++){\n\t    cin >> x[i] >> y[i];\n\t}\n\n\tcout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\n\nint abs(int n){\n\tif(n < 0)\n\t\tn = -n;\n\treturn n;\n}\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 20], dp[1 << 20];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){\n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tloc[1 << i] = i;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i != n){\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i] != INF){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & 1 << j && dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j]) && dp[i | 1 << j] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i]){\n\t\t\t\t\t\tdp[i | 1 << j] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];\n\t\t\t\t\t\tloc[i | 1 << j] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[(1 << n) - 1] != INF)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double INF = DBL_MAX / 1000;\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        Point h, d;\n        cin >> n >> h.x >> h.y >> d.x >> d.y;\n        if(n == 0)\n            return 0;\n\n        ++ n;\n        vector<Point> p(n);\n        p[0] = h;\n        for(int i=1; i<n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        vector<double> distDevil(n);\n        for(int i=0; i<n; ++i)\n            distDevil[i] = d.dist(p[i]);\n\n        vector<vector<double> > dist(n, vector<double>(n));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                dist[i][j] = p[i].dist(p[j]);\n            }\n        }\n\n        vector<vector<double> > dp(1<<n, vector<double>(n, INF));\n        dp[1][0] = 0.0;\n        for(int i=0; i<(1<<n); ++i){\n            bitset<21> bs(i);\n            for(int j=0; j<n; ++j){\n                if(!bs[j])\n                    continue;\n                for(int k=0; k<n; ++k){\n                    if(bs[k])\n                        continue;\n\n                    bs[k] = true;\n                    double t = dp[i][j] + dist[j][k];\n                    if(t < distDevil[k] - EPS)\n                        dp[bs.to_ulong()][k] = t;\n                    bs[k] = false;\n                }\n            }\n        }\n\n        double ret = *min_element(dp[(1<<n)-1].begin(), dp[(1<<n)-1].end());\n        if(ret < INF / 10)\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<double, pair<int, P> > bfp;\nint n, hx, hy, dx, dy;\nP c[1001];\ndouble len[1001];\nint main() {\n    while (scanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy)) {\n        if (!n&&!hx&&!hy&&!dx&&!dy) break;\n        for (int i=0; i<n; i++) {\n            scanf(\"%d%d\",&c[i].x,&c[i].y);\n            double x=c[i].x-dx, y=c[i].y-dy;\n            len[i]=sqrt(x*x+y*y);\n        }\n        queue<bfp> que;\n        que.push(bfp(0.0, make_pair(0,P(hx,hy))));\n        bool res=false;\n        while (!que.empty()) {\n            bfp b=que.front(); que.pop();\n            double t=b.first;\n            int stat=b.second.first;\n            P np=b.second.second;\n            bool flag=true;\n            for (int i=0; i<n; i++) {\n                if (!(stat>>i&1)) {\n                    flag=false;\n                    double x=c[i].x-np.x, y=c[i].y-np.y;\n                    double nt=t+sqrt(x*x+y*y);\n                    int nst=stat|1<<i;\n                    bool isq=true;\n                    for (int j=0; j<n; j++) {\n                        if ((nst>>j&1)&&len[j]<=nt) {\n                            isq=false;\n                            break;\n                        }\n                    }\n                    if (isq)\n                        que.push(bfp(nt,make_pair(nst,P(c[i].x,c[i].y))));\n                }\n            }\n            if (flag) {\n                res=true;\n                break;\n            }\n        }\n        if (res) puts(\"YES\");\n        else puts(\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return (conj(a)*b).real();}\nFP crs(P a,P b){return (conj(a)*b).imag();}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgtin(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lftin(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frtin(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bckin(T a){return shift(a,TOP,FRT,BTM,BCK);}\n\nint n;\nint hx,hy,mx,my;\n\nbool vis[1<<20][20];\nint cx[20],cy[20];\n\nvoid solve(){\n  CLR(vis);\n  cin >> hx >> hy >> mx >> my;\n  rep(i,n) cin >> cx[i] >> cy[i];\n  priority_queue<pair<double,PI > > q;\n  rep(i,n)q.push(mp(-abs(pt(hx,hy)-pt(cx[i],cy[i])),mp(i,1<<i)));\n  \n  while(!q.empty()){\n    double cc=-q.top().F;\n    int cv=q.top().S.F;\n    int vi=q.top().S.S;\n    q.pop();\n    if(cc+EPS>abs(pt(cx[cv],cy[cv])-pt(mx,my))) continue;\n    if(vis[vi][cv]) continue;\n    if(vi==(1<<n)-1){\n      cout << \"YES\" << endl;\n      return;\n    }\n    if(SZ(q)>100000) break;\n    vis[vi][cv]=true;\n    bool ok=true;\n    rep(i,n){\n      if((vi>>i)&1) continue;\n      ok&=\n        abs(pt(cx[i],cy[i])-pt(mx,my))+EPS>\n        cc+abs(pt(cx[i],cy[i])-pt(cx[cv],cy[cv]));\n    }\n    if(!ok) continue;\n    rep(i,n){\n      if((vi>>i)&1) continue;\n      q.push(mp(-cc-abs(pt(cx[i],cy[i])-pt(cx[cv],cy[cv])),\n                mp(i,vi|(1<<i))));\n    }\n  }\n  \n  cout << \"NO\" << endl;\n}\n\nint main(int argc, char *argv[]){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint N;\nP H,D;\nP C[22];\nint K[22][22];\nint dc[22];\nint hc[22];\nint deadK;\n\nint getK(P a,P b){\n  return (a.F - b.F)* (a.F - b.F) + (a.S - b.S)* (a.S - b.S);\n}\n\nint sumK(int a,int b){\n  return a + b + 2*sqrt(a)*sqrt(b);\n}\n\nint solve(int id,int ky,int st){\n  if( st == (1<<N)-1 ) return true;\n  for(int i=0;i<N;i++){\n    if( st & (1<<i) ) continue;\n    int sum = sumK(ky,K[id][i]);\n    if( sum < deadK )\n      if( solve(i,sum,st|(1<<i)) ) return true;\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >> N >> H.F >> H.S >> D.F >> D.S;\n    if( !N && !H.F && !H.S && !D.F && !D.S ) break;\n    for(int i=0;i<N;i++) cin >> C[i].F >> C[i].S;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tK[i][j] = getK(C[i],C[j]);\n    deadK = (1<<29);\n    for(int i=0;i<N;i++){\n      hc[i] = getK(C[i],H);\n      deadK = min(deadK,getK(C[i],D));\n    }\n    bool res = true;\n    for(int i=0;i<N;i++){\n      if( hc[i] >= deadK ){\n\tres = false;\n      }\n    }\n    if( res ) {\n      res = false;\n      for(int i=0;i<N;i++){\n\tif( hc[i] < deadK ){\n\t  if( solve(i,hc[i],(1<<i)) )  res = true;\n\t}\n\tif( res ) break;\n      }\n    }\n    if( res ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> x, y;\n\ndouble dist(int a, int b){\n    return sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));\n}\n\nbool solve(){\n    for(int i=0;i<n;i++){\n        if(dist(n, 0) + dist(0, i) >= dist(n+1, i)) return false;\n    }\n    return true;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        x.assign(n+2, 0);\n        y.assign(n+2, 0);\n        cin >> x[n] >> y[n] >> x[n+1] >> y[n+1];\n        for(int i=0;i<n;i++){\n            cin >> x[i] >> y[i];\n        }\n\n        if(solve()){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 20\n\nstruct P{\n  double x, y;\n}; \n\nint N;\nP h, d, c[MAX];\n \ndouble dist(P a, P b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX];\nbool rec(int now, double sum, int dep){\n  if(dep == N){\n    return true;\n  }\n\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      if(sum + dist(c[now],c[i]) >= dist(d,c[i])){\n        return false;\n      }\n    }\n  }\n\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      used[i] = true;\n      if(rec(i, sum+dist(c[now],c[i]),dep+1)){\n        return true;\n      }\n      used[i] = false;\n    }\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    memset(used, false, sizeof(used));\n    if(rec(i, dist(h,c[i]), 0)){\n      return true;\n    }\n  }\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i].x >> c[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint n;\nint x[20],y[20];\nint sx,sy,mx,my;\nbool c[20];\nbool f(int u,double d)\n{\n\tint cnt=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(c[i])\n\t\t{\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble a=hypot(x[u]-x[i],y[u]-y[i])+d;\n\t\tdouble b=hypot(mx-x[i],my-y[i]);\n\t\tif(b<=a)return false;\n\t}\n\tif(cnt==n)return true;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(c[i])continue;\n\t\tdouble a=hypot(x[u]-x[i],y[u]-y[i])+d;\n\t\tdouble b=hypot(mx-x[i],my-y[i]);\n\t\tif(b>a)\n\t\t{\n\t\t\tc[i]=1;\n\t\t\tif(f(i,a))return true;\n\t\t\tc[i]=0;\n\t\t}\n\t}\n\treturn false;\n}\nmain()\n{\n\twhile(cin>>n>>sx>>sy>>mx>>my,n)\n\t{\n\t\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n\t\tfor(int i=0;i<n;i++)c[i]=0;\n\t\tbool fl=0;\n\t\tfor(int i=0;!fl&&i<n;i++)\n\t\t{\n\t\t\tdouble a=hypot(sx-x[i],sy-y[i]);\n\t\t\tdouble b=hypot(mx-x[i],my-y[i]);\n\t\t\tif(a<b)\n\t\t\t{\n\t\t\t\tc[i]=1;\n\t\t\t\tfl|=f(i,a);\n\t\t\t\tc[i]=0;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tcout<<(fl?\"YES\":\"NO\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\ndouble eps=1e-9;\nint x[23];\nint y[23];\ndouble dist[23][23];\nint n;\nint solve(int a,int b,double s){\n    if(a==(1<<n)-1)return 1;\n    for(int i=0;i<n;i++){//枝切り\n        if(a&(1<<i))continue;\n        if(s+dist[b][i]+eps>dist[n+1][i])return 0;\n    }\n    for(int i=0;i<n;i++){\n        if(a&(1<<i))continue;\n        \n        if(solve(a+(1<<i),i,s+dist[b][i]))return 1;\n    }\n    return 0;\n}\nint main(){\n    int a,hx,hy,dx,dy;\n    while(scanf(\"%d%d%d%d%d\",&a,&hx,&hy,&dx,&dy),a){\n        n=a;\n        for(int i=0;i<a;i++)scanf(\"%d%d\",x+i,y+i);\n        x[a]=hx;x[a+1]=dx;\n        y[a]=hy;y[a+1]=dy;\n        for(int i=0;i<a+2;i++)for(int j=0;j<a+2;j++)\n            dist[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n        if(solve(0,a,0))printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// ??????????????????????????±????????±???\n\nint n;\nint x[30], y[30];\n\ndouble dist(int a, int b){\n    return sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));\n}\n\nbool solve(){\n    for(int i=0;i<n;i++){\n        if(dist(n, 0) + dist(0, i) >= dist(n+1, i)) return false;\n    }\n    return true;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        cin >> x[n] >> y[n] >> x[n+1] >> y[n+1];\n        for(int i=0;i<n;i++){\n            cin >> x[i] >> y[i];\n        }\n\n        if(solve()) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX], ok;\nbool dp[1<<MAX][MAX];\n\nbool rec(int S, int v, double total_dist){\n  if(ok) return true;\n\n  if(dp[S][v]) return true;\n\n  if(S == (1 << N) - 1){\n    return dp[S][v] = ok = true;\n  }\n  for(int u = 0 ; u < N ; u++){\n    Segment s = Segment(crystal[v], crystal[u]);\n    if(s.distanceSP(d) < total_dist) return false;\n    if(total_dist+dist(crystal[v],crystal[u]) >= dist(d, crystal[u])){\n      return false;\n    }\n    if(!(S >> u & 1)){\n      if(rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]))){\n\treturn true;\n      }\n    }\n  }\n  return dp[S][v] = false;\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n\n  for(int i = 0 ; i < N ; i++){\n    ok = false;\n    memset(dp, false, sizeof(dp));\n    memset(used, false, sizeof(used));\n    if(rec(0, i, dist(h, crystal[i]))){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n#include <complex>\n\n#define INF 1145141919\n#define EPS 1e-9\n#define Pi acos(-1)\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define MAX_N 20\n\nint N;\nint hx, hy, dx, dy;\nint cx[MAX_N], cy[MAX_N];\n\nvector<string> ans_list;\n\ndouble dist(int x1, int y1, int x2, int y2){\n\treturn sqrt((x1 - x2) * (x1 - x2) + (y1 - y2)* (y1 - y2));\n}\n\nbool dfs(int S, int nowx, int nowy, double t){\n\t\n\tif (S == (1 << N) - 1)\n\t\treturn true;\n\n\t//枝狩り\n\tfor (int i = 0; i < N; i++){\n\t\tif (!(S >> i & 1) && dist(dx, dy, cx[i], cy[i]) - t <= dist(nowx, nowy, cx[i], cy[i]))\n\t\t\treturn false;\n\t}\n\n\t//探索\n\tfor (int i = 0; i < N; i++){\n\t\tif (!(S >> i & 1)){\n\t\t\tif (dfs(S | (1 << i), cx[i], cy[i], t + dist(nowx, nowy, cx[i], cy[i])))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n\n}\n\nint main(){\n\n\twhile (cin >> N >> hx >> hy >> dx >> dy, N){\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t}\n\n\t\tif (dfs(0, hx, hy, 0))\n\t\t\tans_list.push_back(\"YES\");\n\t\telse\n\t\t\tans_list.push_back(\"NO\");\n\n\t}\n\n\tfor (int i = 0; i < ans_list.size(); i++){\n\t\tcout << ans_list[i] << endl;\n\t}\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n#include <complex>\n\n#define INF 1145141919\n#define EPS 1e-9\n#define Pi acos(-1)\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define MAX_N 20\n\nint N;\nint hx, hy, dx, dy;\nint cx[MAX_N], cy[MAX_N];\n\nvector<string> ans_list;\n\nint dist(int x1, int y1, int x2, int y2){\n\treturn abs(x1 - x2) + abs(y1 - y2);\n}\n\nbool dfs(int S, int nowx, int nowy, int t){\n\t\n\tif (S == (1 << N) - 1)\n\t\treturn true;\n\n\t//枝狩り\n\tfor (int i = 0; i < N; i++){\n\t\tif (!(S >> i & 1) && dist(dx, dy, cx[i], cy[i]) - t <= dist(nowx, nowy, cx[i], cy[i]))\n\t\t\treturn false;\n\t}\n\n\t//探索\n\tfor (int i = 0; i < N; i++){\n\t\tif (!(S >> i & 1)){\n\t\t\tif (dfs(S | (1 << i), cx[i], cy[i], t + dist(nowx, nowy, cx[i], cy[i])))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n\n}\n\nint main(){\n\n\twhile (cin >> N >> hx >> hy >> dx >> dy, N){\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t}\n\n\t\tif (dfs(0, hx, hy, 0))\n\t\t\tans_list.push_back(\"YES\");\n\t\telse\n\t\t\tans_list.push_back(\"NO\");\n\n\t}\n\n\tfor (int i = 0; i < ans_list.size(); i++){\n\t\tcout << ans_list[i] << endl;\n\t}\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint n,ans,got[20];\ndouble hx,hy,dx,dy,cx[20],cy[20];\n\nvoid dfs(double t,double x,double y){\n\tif(ans)return;\n\tint m=0;\n\trep(i,n)m+=got[i];\n\tif(m==n){ans=1;return;}\n\trep(i,n)if(!got[i]&&t+sqrt((cx[i]-x)*(cx[i]-x)+(cy[i]-y)*(cy[i]-y))+EPS>sqrt((cx[i]-dx)*(cx[i]-dx)+(cy[i]-dy)*(cy[i]-dy)))return;\n\trep(i,n)if(!got[i]){\n\t\tgot[i]=1;\n\t\tdfs(t+sqrt((cx[i]-x)*(cx[i]-x)+(cy[i]-y)*(cy[i]-y)),cx[i],cy[i]);\n\t\tgot[i]=0;\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>hx>>hy>>dx>>dy&&(n||hx||hy||dx||dy)){\n\t\trep(i,n)fill(got,got+n,0);\n\t\trep(i,n)cin>>cx[i]>>cy[i];\n\t\tans=0;\n\t\tdfs(0.0,hx,hy);\n\t\tcout<<(ans?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\n\nconst D EPS = 1e-8;\n\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\n\nP cr[21], d;\nint n;\nD dis[21][21], limit[20];\n\nbool solve(int bit, int p, D t) {\n  if (bit == 0) return true;\n  rep (i, n) if (bit & 1 << i) {\n    rep (j, n) if (bit & 1 << j) {\n      if (sig(t + dis[p][i] + dis[i][j], limit[j]) >= 0) goto next;\n    }\n    if (solve(bit ^ 1 << i, i, t + dis[p][i])) return true;\n  next:;\n  }\n  return false;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    cin  >> cr[n].X >> cr[n].Y >> d.X >> d.Y;\n    if (n == 0) break;\n    rep (i, n) cin >> cr[i].X >> cr[i].Y;\n    rep (i, n + 1) rep (j, n + 1) dis[i][j] = abs(cr[i] - cr[j]);\n    rep (i, n) limit[i] = abs(cr[i] - d);\n    cout << (solve((1 << n) - 1, n, 0) ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<double,int> P;\n\nint xs[21];\nint ys[21];\ndouble h[21];\nint n;\nbool ok(int x, int y, int done, double t)\n{\n\tif(done+1==(1<<n))\n\t{\n\t\treturn true;\n\t}\n\n\tvector<P> q;\n\tfor(int i=0;i<n;i++){\n\t\tif(done&(1<<i))continue;\n\t\tdouble d=t+hypot(xs[i]-x,ys[i]-y);\n\t\tif(d>=h[i]){\n\t\t\treturn false;\n\t\t}\n\t\tq.push_back(P(d,i));\n\t}\n\tsort(q.begin(),q.end());\n\tfor(auto p : q)\n\t{\n\t\tint i=p.second;\n\t\tif(ok(xs[i],ys[i],done|(1<<i),p.first)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid exec()\n{\n\tint hx,hy,dx,dy;\n\tcin >> n >> hx >> hy >> dx >> dy;\n\tif((n|hx|hy|dx|dy)==0){\n\t\texit(1);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin >> xs[i] >> ys[i];\n\t\th[i]=hypot(xs[i]-dx,ys[i]-dy);\n\t}\n\tif(ok(hx,hy,0,0)){\n\t\tcout << \"YES\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"NO\" << endl;\n\t}\n}\nint main() {\n\twhile(1)exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\nconst int INF=100000000;\n\n\nint n;\nint hx,hy;\nint dx,dy;\nint cx[21],cy[21];\n\n\ndouble dist(int _x0,int _y0,int _x1,int _y1) {\n\tdouble d = (_x0-_x1)*(_x0-_x1) + (_y0-_y1)*(_y0-_y1);\n\treturn sqrt(d);\n}\n\nint pow2(int a) {\n\treturn a*a;\n}\n\n//&#131;N&#131;&#138;&#131;X&#131;^&#131;&#139;&#130;&#204;&#136;&#202;&#146;u&#130;&#198;&#137;&#189;&#147;&#250;&#150;&#218;&#130;&#169;&#130;&#231;&#130;&#198;&#130;&#233;&#130;賊&#130;&#198;&#130;&#170;&#130;&#197;&#130;&#171;&#130;&#233;&#130;&#169;\nbool check(int x,int y,int d) {\n\treturn (pow2(dx-x)+pow2(dy-y)) >= pow2(d);\n}\n\n//&#140;&#187;&#141;&#221;&#136;&#202;&#146;u,&#137;&#189;&#147;&#250;&#150;&#218;,&#143;W&#141;&#135;\nbool dfs(int x,int y,int d,int S) {\n    //printf(\"[debug] %d,%d,%d,%d\\n\",x,y,d,S);\n\tif(S==(1<<n)-1) return true;\n\trep(i,n) {\n\t\tif(!((S>>i)&1)) {\n\t\t\td += (int)dist(x,y,cx[i],cy[i]) + 1;\n\t\t\tif(check(cx[i],cy[i],d)) {\n\t\t\t\treturn dfs(cx[i],cy[i],d,S|(1<<i));\n\t\t\t}\n            else {\n                return false;\n            }\n\t\t}\n\t}\n\n\treturn false;\n\n}\n\n\nvoid solve() {\n\trep(i,n) cin>>cx[i]>>cy[i];\n\tif(dfs(hx,hy,0,0)) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\n}\n\nint main() {\n\twhile (cin>>n>>hx>>hy>>dx>>dy)\n\t{\n\t\tif(n+hx+hy+dx+dy==0) return 0;\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nconstexpr double eps = 1e-6;\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n  if (n == 0) return 1;\n\n  std::vector<std::pair<int, int>> c(n+1);\n  int dx, dy;\n  scanf(\"%d %d %d %d\", &c[0].first, &c[0].second, &dx, &dy);\n\n  for (size_t i = 1; i <= n; ++i)\n    scanf(\"%d %d\", &c[i].first, &c[i].second);\n\n  size_t m = 1 << n;\n  double inf = 1e12;\n  std::vector<std::vector<double>> dp(m, std::vector<double>(n+1, inf));\n  dp[1][0] = 0;\n\n  for (size_t i = 0; i < m; ++i) {\n    for (size_t j = 0; j <= n; ++j) {\n      if (!(i >> j & 1)) continue;\n      for (size_t k = 0; k <= n; ++k) {\n        if (i >> k & 1) continue;\n        double next = dp[i][j] + hypot(c[j].first-c[k].first, c[j].second-c[k].second);\n        if (!(next+eps < hypot(c[k].first-dx, c[k].second-dy))) continue;\n\n        size_t ni = i | 1 << (k-1);\n        dp[ni][k] = std::min(dp[ni][k], dp[i][j]+next);\n      }\n    }\n  }\n\n  double res = *std::min_element(dp[m-1].begin(), dp[m-1].end());\n  puts((res < inf)? \"YES\":\"NO\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int INF=100000000;\n// e_ÔÌ£\ndouble dist[22][22];\n// e_ÌÀW\nvector<pair<int,int> > points;\nint n,hx,hy,dx,dy;\nbool ok=false;\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\n// »ÝÌê©çßÄÂ\\ÈÅ¬ÊßbðÔ·\nvoid dfs(int s,int cp,double passedSec){\n    if(ok)\n        return;\n    else if(s==0){\n        ok=true;\n        return;\n    }\n    for(int i = 0; i < n; i++){\n        // Ü¾rbgª1ÈçÎ\n        if((s>>i)&1){\n            // áCªB·éOÉTõÂ\\©Ç¤©ð`FbN\n            double dt=dist[cp][i];\n            // ¤©çÚ®æÖÌ¼aðæ¾\n            double r=dist[n+1][i];\n            // àµ¼aªz¦Ä¢½ç\n            if(dt+passedSec>r||EQ(dt+passedSec,r))\n                continue;\n            dfs((s&(~(1<<i))),i,dt+passedSec);\n        }\n    }\n}\n\n\nint main(){\n    while(cin>>n>>hx>>hy>>dx>>dy&&!(n==0&&hx==0&&hy==0&&dx==0&&dy==0)){\n        points.clear();\n        ok=false;\n        // EÒÌúÊu\n        for(int i = 0; i < n; i++){\n            pair<int,int> p;\n            cin>>p.second>>p.first;\n            points.push_back(p);\n        }\n        points.push_back(make_pair(hy,hx));\n        points.push_back(make_pair(dy,dx));\n\n        for(int i = 0; i < points.size(); i++){\n            for(int j = 0; j < points.size(); j++){\n                dist[i][j]=sqrt((double)(points[i].first-points[j].first)*(points[i].first-points[j].first)\n                    +(points[i].second-points[j].second)*(points[i].second-points[j].second));\n            }\n        }\n        dfs(((1<<n)-1),n,0);\n        if(ok)\n            cout<<\"YES\"<<endl;\n        else\n            cout<<\"NO\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define INF 10000\n#define EPS 1.0e-10\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point;\ndouble dist(const point &a, const point &b){return std::abs(b-a);}\nint main(){\n\twhile(true){\n\t\tbool bSafe = true;\n\t\tint n,hx,hy,dx,dy;\n\t\tdouble walk=0.0;\n\t\tpoint hero, daemon;\n\t\tvector< point > vp;\n\n\t\tscanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy);\n\t\tif(!(n||hx||hy||dx||dy))break;\n\t\thero = complex<elem>(hx,hy);\n\t\tdaemon = complex<elem>(dx,dy);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint cx,cy;\n\t\t\tscanf(\"%d%d\", &cx, &cy);\n\t\t\tpoint p(cx,cy);\n\t\t\tvp.push_back( p );\n\t\t}\n\t\twhile( vp.size()>0 ){\n\t\t\tdouble min_dist=INF;\n\t\t\tdouble min_dist_hero=INF;\n\t\t\tint min_cristal = -1;\n\t\t\tfor(unsigned int i=0;i<vp.size();++i){\n\t\t\t\tif( min_dist > dist( daemon, vp[i] ) && min_dist_hero > dist( hero, vp[i] ) ){\n\t\t\t\t\tmin_dist = dist( daemon, vp[i] );\n\t\t\t\t\tmin_dist_hero = dist( hero, vp[i] );\n\t\t\t\t\tmin_cristal = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\twalk+=dist(hero,vp[min_cristal]);\n\t\t\tif(walk>=min_dist-EPS){\n\t\t\t\tbSafe=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvp.erase(vp.begin()+min_cristal);\n\t\t}\n\t\tif( bSafe )\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\ndouble mx,my;\ndouble x[21],y[21];\nbool endFlag;\n\nconst double EPS=1e-8;\nbool input(){\n    scanf(\"%d\",&N);\n    scanf(\"%lf%lf%lf%lf\",&x[N],&y[N],&mx,&my);\n    if(!(N||x[N]||y[N]||mx||my))return false;\n    for(int i=0;i<N;i++)scanf(\"%lf%lf\",&x[i],&y[i]);\n    return true;\n}\n\nvoid dfs(int S,int pos,double total){\n    if(S==(1<<N)-1){\n        endFlag=true;\n        return;\n    }\n    if(endFlag)return;\n\n    for(int i=0;i<N;i++){\n        if((S>>i)&1)continue;\n        double mao=hypot(mx-x[i],my-y[i]);\n        double yu=hypot(x[pos]-x[i],y[pos]-y[i]);\n        if(yu+total+EPS>mao)return;\n    }\n\n\n    for(int i=0;i<N;i++){\n        if((S>>i)&1)continue;\n        double yu=hypot(x[pos]-x[i],y[pos]-y[i]);\n        dfs(S|(1<<i),i,total+yu);\n    }\n}\nvoid solve(){\n    endFlag=false;\n    dfs(0,N,0);\n    puts(endFlag?\"YES\":\"NO\");\n}\nint main(){\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-9;\n\nint n;\ndouble d[21][21];\n\nbool dfs(double t,int i,bool *vis){\n\tif(d[i][n]<t+EPS) return false;\n\tif(count(vis,vis+n,true)==n) return true;\n\n\trep(j,n) if(!vis[j] && d[i][j]+EPS>d[j][n]-t) return false;\n\n\trep(j,n) if(!vis[j]) {\n\t\tvis[j]=true;\n\t\tif(dfs(t+d[i][j],j,vis)) return true;\n\t\tvis[j]=false;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(int hx,hy,mx,my;scanf(\"%d%d%d%d%d\",&n,&hx,&hy,&mx,&my),n;){\n\t\tint cx[20],cy[20];\n\t\trep(i,n) scanf(\"%d%d\",cx+i,cy+i);\n\t\trep(i,n){\n\t\t\trep(j,n) d[i][j]=hypot(cx[i]-cx[j],cy[i]-cy[j]);\n\t\t\td[i][n]=hypot(cx[i]-mx,cy[i]-my);\n\t\t}\n\n\t\tbool ok=false,vis[20]={};\n\t\trep(i,n){\n\t\t\tvis[i]=true;\n\t\t\tif(dfs(hypot(hx-cx[i],hy-cy[i]),i,vis)) { ok=true; break; }\n\t\t\tvis[i]=false;\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint n;\nint cx[22];\nint cy[22];\nbool f[22];\ndouble l[22][22];\nint s = 0;\ndouble d;\n\nint kansu( int x , int y ){\n\ts++;\n\tif ( s == n + 1 ) return 1;\n\td += l[x][y];\n\tf[y] = true;\n\tf[1] = true;\n\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\tif ( d + l[y][i] >= l[1][i] ) {\n\t\t\tf[1] = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ( f[1] ) {\n\t\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\t\tif ( f[i] ) continue;\n\t\t\tif ( kansu( y , i ) ) return 1;\n\t\t}\n\t}\n\ts--;\n\td -= l[x][y];\n\tf[y] = false;\n\treturn 0;\n}\n\nint main(){\n\twhile(true) {\n\t\tcin >> n >> cx[0] >> cy[0] >> cx[1] >> cy[1];\n\t\tif ( n == 0 ) break;\n\t\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tf[i] = false;\n\t\t}\n\t\tfor ( int i = 0; i < n + 1; i++ ) {\n\t\t\tfor ( int j = i + 1; j < n + 2; j++ ) {\n\t\t\t\tint x = cx[i]-cx[j];\n\t\t\t\tint y = cy[i]-cy[j];\n\t\t\t\tdouble z = x*x + y*y;\n\t\t\t\tl[i][j] = sqrt( z );\n\t\t\t\tl[j][i] = l[i][j];\n\t\t\t}\n\t\t}\n\t\ts = 0;\n\t\td = 0.00;\n\t\tl[0][0] = 0.00;\n\t\tif ( kansu( 0 , 0 ) ) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ndouble lim[20],limbit[1<<20],inf=1e9,eps=1e-9,limit[21][21];\nint n,hx,hy,mx,my,cx[21],cy[21];\nvoid calc(){\n\trep(i,n+1) rep(j,n+1){\n\t\tif(i==j) limit[i][j]=0;\n\t\tdouble sx=cx[i],sy=cy[i],tx=cx[j],ty=cy[j],d=sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy)),dx=(tx-sx)/d,dy=(ty-sy)/d,x=sx-mx,y=sy-my;\n\t\tdouble b=2*d,c=-(x*x+y*y+2*d*(x*dx+y*dy));\n\t\tlimit[i][j]=(-b+sqrt(b*b-4*c))/2;\n\t}\n}\nbool dfs(int bit,int v,double t){\n\tif(bit==(1<<n)-1) return true;\n\tif(t+eps>limbit[bit]) return false;\n\trep(i,n){\n\t\tif((bit>>i)&1) continue;\n\t\tif(t+eps>limit[v][i]) return false;\n\t\tif(dfs(bit+(1<<i),i,t+sqrt((cx[i]-cx[v])*(cx[i]-cx[v])+(cy[i]-cy[v])*(cy[i]-cy[v])))) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d%d%d%d\",&n,&cx[n],&cy[n],&mx,&my);\n\t\tif(n==0) break;\n\t\trep(i,n){\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\t\tlim[i]=sqrt((cx[i]-mx)*(cx[i]-mx)+(cy[i]-my)*(cy[i]-my));\n\t\t}\n\t\trep(i,1<<n){\n\t\t\tlimbit[i]=inf;\n\t\t\trep(j,n){\n\t\t\t\tif((i<<j)&1==0) limbit[i]=min(limbit[i],lim[j]);\n\t\t\t}\n\t\t}\n\t\tcalc();\n\t\tcout << (dfs(0,n,0) ? \"YES\\n\" : \"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\n#define EPS 1e-10\n\nstruct Point{double x,y,d;};\nint n;\nPoint hero,demon;\nvector<Point>crystal;\nbool ok;\n\ndouble dist(Point a,Point b)\n{\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nvoid solve(int now,double time,vector<bool>visited){\n  int i;\n  bool f=true;\n  if(time-crystal[now].d>-EPS)return;\n  for(i=0;i<n;i++){\n    if(visited[i])continue;\n    visited[i]=true;\n    solve(i,time+dist(crystal[now],crystal[i]),visited);\n    visited[i]=false;\n    f=false;\n  }\n  if(f)ok=true;\n  return;\n}\n\nint main()\n{\n  vector<bool>visited;\n  int i;\n  double hx,hy,dx,dy,x,y;\n  double time;\n  while(cin>>n>>hx>>hy>>dx>>dy,hx||hy||dx||dy){\n    hero.x=hx;\n    hero.y=hy;\n    demon.x=dx;\n    demon.y=dy;\n    crystal.clear();\n    visited.resize(n);\n    fill(visited.begin(),visited.end(),false);\n    for(i=0;i<n;i++){\n      cin>>x>>y;\n      Point p={x,y,0};\n      p.d=dist(p,demon);\n      crystal.push_back(p);\n    }\n    ok=false;\n    for(i=0;i<n;i++){\n      time=dist(hero,crystal[i]);\n      visited[i]=true;\n      solve(i,time,visited);\n      visited[i]=false;\n      if(ok)break;\n    }\n    puts(ok?\"YES\":\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *  Author: mizo0203\n *  Problem: 2008\n *  Status: Wrong Answer\n *  Submission Date: 2012/04/17 18:33:39\n *\n *  方策：再帰関数による幅優先探索\n */\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint n; // (0 < n <= 20)\nint hx, hy, dx, dy;\nint cx[20], cy[20]; // (-1000 <= h, d, c <= 1000)\n\nvoid init() {\n}\n\nbool input() {\n  int i;\n\n  scanf(\"%d %d %d %d %d\", &n, &hx, &hy, &dx, &dy);\n  if (!n && !hx && !hy && !dx && !dy)\n    return false;\n  for (i = 0; i < n; i++)\n    scanf(\"%d %d\", &cx[i], &cy[i]);\n\n  return true;\n}\n\n// sum: 勇者の総移動距離^2 == 瘴気の半径^2\nbool recursive(int m, long bit, int x, int y, double sum) {\n  int i;\n  double dis;\n\n  if (n == m) // クリスタル収集完了（※）\n    return true;\n\n  for (i = 0; i < n; i++) {\n    if (bit & 1 << i)\n      continue;\n    dis = sqrt(pow(cx[i] - x, 2) + pow(cy[i] - y, 2));\n    //printf(\"%f %f\\n\", sum + dis, sqrt(pow(cx[i] - dx, 2) + pow(cy[i] - dy, 2)));\n    if (sum + dis >= sqrt(pow(cx[i] - dx, 2) + pow(cy[i] - dy, 2)))\n      continue;\n    if (recursive(m + 1, bit | 1 << i, cx[i], cy[i], sum + dis)) // bit |= 1 << i になってた\n      return true;\n  }\n\n  return false;\n}\n\nint main() {\n  int i;\n\n  init();\n  while (input()) {\n    int pmt[20];\n    // [0, 1, 2, ....]というサイズnの配列を作成\n    for (i = 0; i < n; i++)\n      pmt[i] = i;\n    // 全ての順列を出力\n    if (recursive(0, 0, hx, hy, 0))\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nint n;\nint hx, hy, dx, dy;\nint cx[20], cy[20];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tconst int INF = 0xfffffff;\n\n\twhile(cin >> n >> hx >> hy >> dx >> dy, n) {\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tcin >> cx[i] >> cy[i];\n\n\t\tvector<vector<double> > dist(n, vector<double>(n));\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = i + 1; j < n; ++j)\n\t\t\t\tdist[i][j] = dist[j][i] = hypot(cx[i] - cx[j], cy[i] - cy[j]);\n\n\t\tvector<vector<double> > dp(n, vector<double>(1 << n, INF));\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tdp[i][1 << i] = hypot(cx[i] - hx, cy[i] - hy);\n\n\t\tfor(int i = 1; i < n; ++i) {\n\t\t\tfor(int j = 1; j < (1 << n); ++j) {\n\t\t\t\tif(__builtin_popcount(j) != i)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor(int k = 0; k < n; ++k) {\n\t\t\t\t\tif(!(j & (1 << k)))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tfor(int l = 0; l < n; ++l)\n\t\t\t\t\t\tif(!(j & (1 << l)))\n\t\t\t\t\t\t\tchmin(dp[l][j | (1 << l)], dp[k][j] + dist[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(dp[i][(1 << n) - 1] < hypot(cx[i] - dx, cy[i] - dy)) {\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\tcout << \"NO\" << endl;\n\tnext:;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n}; \n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool rec(int S, int v, double total_dist){\n  if(S == (1 << N) - 1){\n    return true;\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1)){\n      if(total_dist + dist(crystal[v],crystal[u]) >= dist(d, crystal[u])){\n        return false;\n      }\n    }\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1)){\n      if(rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]))){\n        return true;\n      }\n    }\n  }\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    if(rec(0,i,dist(h,crystal[i]))){\n      return true;\n    }\n  }  \n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cfloat>\n#include <cmath>\n#include <vector>\n#include <map>\n \nusing namespace std;\n \n#define fi first\n#define se second\ntypedef pair<double,double> P;\n \n#define MAX (21)\n#define INF (DBL_MAX/4)\n \ndouble G[MAX][MAX];\n \nint n;\nvector<P> crys;\nP h, d;\n \ndouble dist(P p1, P p2){\n  return sqrt(pow(p1.fi-p2.fi, 2.) + pow(p1.se-p2.se, 2.));\n}\n \nvoid make_Edge() {\n  for(int i=0; i<n; i++) {\n    G[i][i] = 0;\n    for(int j=i+1; j<n; j++) {\n      G[i][j] = G[j][i] = dist(crys[i], crys[j]);\n    }\n  }\n}\n \n\nvoid printbit(int x){\n  for(int i=0;i<n;i++){\n    cout<<((x>>i)&1);\n\n  }\n  cout<<endl;\n}\n\n \ntypedef unsigned long long ull;\nmap<ull, double> dp;\n\ndouble dfs(int S, int idx, double cost) {\n  \n  if(S==(1<<n)-1) {\n    return dp[S] = cost;\n  }\n  \n  double res = INF;\n  \n  for(int i=0; i<n; i++){\n    if((S>>i)&1) continue;\n    double ncost = cost + G[idx][i];\n    double nS = S|(1<<i);\n    if(ncost >= dist(crys[i], d)) continue;\n    else {\n      if(dp.count(nS) && dp[nS] < ncost) continue;\n      res = min(res, dfs(nS, i, ncost));\n    }\n  }\n  \n  return dp[S] = res;\n}\n \nbool solve() {\n   \n  make_Edge();\n  \n  dp.clear();\n  dp[0] = INF;\n  for(int i=0; i<n; i++) {\n    if(dist(h, crys[i]) >= dist(crys[i], d)) continue;\n    dp[0] = min(dfs(1<<i, i, dist(h, crys[i])), dp[0]);\n  }\n  if(!dp.count((1<<n)-1)) return false;\n  if(dp[0]>=INF) return false;\n  return true;\n}\n \nint main(){\n  while(true){\n    crys.clear();\n    cin >> n >> h.fi >> h.se >> d.fi >> d.se;\n    if(!n && !h.fi && !h.se && !d.fi && !d.se){\n      break;\n    }\n    crys.resize(n);\n    for(int i=0; i<n; i++){\n      cin >> crys[i].fi >> crys[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define INF 0x7FFFFFFF\n#define dist(x1,y1,x2,y2) sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))\n\nint n, dc[20];\ndouble cx[20], cy[20], hx, hy, dx, dy, S[1 << 20];\n\nint solve(double x,double y,int bit,double sum){\n\tint i;\n\tif(S[bit] > sum)\n\t\tS[bit] = sum;\n\telse\n\t\treturn 0;\n\tif(bit == 0) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & bit) && sum >= dc[i]) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(((1 << i) & bit) && sum + dist(x,y,cx[i],cy[i]) < dc[i] && solve(cx[i],cy[i],bit ^ (1 << i),sum + dist(x,y,cx[i],cy[i])))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(void){\n\tint i;\n\twhile(1){\n\t\tscanf(\"%d%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tS[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++)\n\t\t\tdc[i] = dist(dx,dy,cx[i],cy[i]);\n\t\tif(solve(hx,hy,(1 << n) - 1,0))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#define zero 1000 // (1000,1000)が原点\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nconst int ddx[] = {-1,0,1,0} ,ddy[] = {0,-1,0,1};\nint p[20][20], cx[20], cy[20], hx, hy, n, dx, dy;\n\nint solve(int pre){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= dist(cx[i],cy[i],dx,dy)) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit){ // 未探索の位置にあるクリスタル\n\t\t\tif(pre == -1 && dist(hx,hy,cx[i],cy[i]) + sum < dist(cx[i],cy[i],dx,dy)){ // １つ目のクリスタルをとる\n\t\t\t\tsum += dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tbit += 1 << i;\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbit -= 1 << i;\n\t\t\t\tsum -= dist(hx,hy,cx[i],cy[i]);\n\t\t\t}\n\t\t\telse if(pre != -1 && p[pre][i] + sum < dist(cx[i],cy[i],dx,dy)){ // ２〜ｎつ目のクリスタルを取る\n\t\t\t\tbit += 1 << i;\n\t\t\t\tsum += p[pre][i];\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tsum -= p[pre][i];\n\t\t\t\tbit -= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint i, j;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(i == j)\n\t\t\t\t\tp[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tp[i][j] = dist(cx[i],cy[i],cx[j],cy[j]);\n\t\t\t}\n\t\t}\n\t\tif(solve(-1))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N;\nP H;\nP D;\nP C[22];\nint kyo[22][22];\n\nint bai(int a){ return a*a; }\n\nint getK(P a,P b){\n  return bai(a.first - b.first) + bai(a.second - b.second);\n}\n\nint dp[(1<<20)][21];\n#define INF ( 1<<30 )\nint main(){\n  while(1){\n    cin >> N >> H.first >> H.second >> D.first >> D.second;\n    if( !N && !H.first && !H.second && !D.first &&!D.second ) break;\n    for(int i=0;i<N;i++){\n      cin >> C[i].first >> C[i].second;\n    }\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n\tif( i == j ) continue;\n\tkyo[i][j] = getK(C[i],C[j]);\n      }\n    }\n    fill(dp[0],dp[(1<<N)],INF);\n    for(int i=0;i<N;i++){\n      int r = getK(H,C[i]);\n      if( getK(D,C[i]) > r ){\n\tdp[(1<<i)][i] = r;\n      }\n    }\n    for(int i=0;i<(1<<N);i++){\n      for(int j=0;j<N;j++){\n\tif( dp[i][j] == INF ) continue; \n\tfor(int k=0;k<N;k++){\n\t  if( i & (1<<k) ) continue;\n\t  int r = kyo[j][k] + dp[i][j] + 2 * sqrt(kyo[j][k])*sqrt(dp[i][j]);\n\t  if( getK(D,C[k]) > r ){\n\t    //\t    printf(\"%d %d %d\\n\",k,getK(D,C[k]),r);\n\t    dp[i|(1<<k)][k] = min( dp[i|(1<<k)][k], r);\n\t  }\n\t}\n      }\n    }\n    bool result = false;\n    for(int i=0;i<N;i++){\n      //  printf(\"%d\\n\",dp[(1<<N)-1][i]);\n      if( dp[(1<<N)-1][i] != INF )result = true;\n    }\n    if ( result ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> x, y;\nvector<bool> viewed;\n\ndouble dist(int a, int b){\n    return sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));\n}\n\nbool dfs(int v, double t, int c){\n    if(c == n) return true;\n\n    for(int i=0;i<n;i++){\n        if(viewed[i]) continue;\n        if(t + dist(v, i) >= dist(i, n+1)) return false;\n    }\n\n    for(int i=0;i<n;i++){\n        if(viewed[i]) continue;\n        double nt = t + dist(v, i);\n        if(nt < dist(i, n+1)){\n            viewed[i] = true;\n            if(dfs(i, nt, c+1)) return true;\n            viewed[i] = false;\n        }\n    }\n\n    return false;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        x.assign(n+2, 0);\n        y.assign(n+2, 0);\n        cin >> x[n] >> y[n] >> x[n+1] >> y[n+1];\n        for(int i=0;i<n;i++){\n            cin >> x[i] >> y[i];\n        }\n        viewed.assign(n, false);\n        if(dfs(n, 0, 0)){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n\n\nP getPedal(L l, P p){\n\tdouble A;\n\tif(abs(l[1].real()-l[0].real()) < EPS){\n\t\treturn P(l[1].real(),p.imag()); // important\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A , b = 1 , c = A*l[0].real() - l[0].imag();\n\tdouble t = (a*p.real() + b*p.imag() + c)/(a*a+b*b);\n\treturn p-t * P(a,b);\n}\n \nvector<P> crosspointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS)return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n\nP c[20];\nint okflag;\n\nint n,hx,hy,dx,dy;\n\nint check(L l,double tim){\n\tdouble dist = abs(l[0]-l[1]);\n\tif( abs(l[0]-P(dx,dy)) <= tim+EPS || abs(l[1]-P(dx,dy)) <= tim+dist+EPS ) return false;\n\t\n\tP p = getPedal(l,P(dx,dy));\n\t\n\tif( intersectSP(l,p) == false ){\n\t\treturn true;\n\t}\n\tif( abs(p-P(dx,dy)) <= tim+abs(l[0]-p) + EPS ) return false;\n\t\n\treturn true;\n}\n\nint test(int bit,P pos,double tim){\n\tif( bit == (1<<n) - 1 ){\n\t\tokflag = 1;\n\t\treturn false;\n\t}\n\tif(okflag) return false;\n\t\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !(bit >> i & 1) ){\n\t\t\tif( !check(L(pos,c[i]),tim) ) return false;\n\t\t}\n\t}\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !(bit >> i & 1) ){\n\t\t\ttest( bit | (1<<i) , c[i] , tim + abs(pos-c[i]) );\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin >> n >> hx >> hy >> dx >> dy && n){\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> c[i].real() >> c[i].imag();\n\t\t}\n\t\t\n\t\tokflag = 0;\n\t\ttest(0,P(hx,hy),0);\n\t\tif(okflag){\n\t\t\tcout << \"YES\" << endl;\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 20\n#define EPS 1e-9\n\nstruct Point{\n  double x, y;\n}; \n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX];\nbool rec(int now, double total_dist, int depth){\n  if(depth == N){\n    return true;\n  }\n\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      if(total_dist + dist(crystal[now],crystal[i]) >= dist(d,crystal[i])){\n        return false;\n      }\n    }\n  }\n\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      used[i] = true;\n      if(rec(i, total_dist + dist(crystal[now],crystal[i]), depth+1)){\n        return true;\n      }\n      used[i] = false;\n    }\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    memset(used, false, sizeof(used));\n    if(rec(i, dist(h, crystal[i]), 0)){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ndouble dp[1<<20][20],inf=1e9,eps=1e-9;\nint n,hx,hy,mx,my,cx[20],cy[20];\nbool isok(double sx,double sy,double tx,double ty,double t0){\n\tdouble d=sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy)),dx=(tx-sx)/d,dy=(ty-sy)/d,x=sx-mx,y=sy-my;\n\tdouble a=dx*dx+dy*dy-1,b=2*(x*dx+y*dy-t0),c=x*x+y*y-t0*t0;\n\tif(abs(b)<eps){\n\t\tif(abs(c)>eps) return false;\n\t\treturn true;\n\t}\n\treturn !(0<-c/b+eps && -c/b<d+eps);\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> hx >> hy >> mx >> my;\n\t\tif(n==0) break;\n\t\trep(i,n) cin >> cx[i] >> cy[i];\n\t\trep(i,1<<n) rep(j,n) dp[i][j]=inf;\n\t\trep(i,1<<n){\n\t\t\tif(i==0){\n\t\t\t\trep(k,n){\n\t\t\t\t\tdouble sx=hx,sy=hy,tx=cx[k],ty=cy[k],t0=0;\n\t\t\t\t\tdouble d=sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy));\n\t\t\t\t\tif(isok(sx,sy,tx,ty,t0)) dp[i+(1<<k)][k]=d;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(j,n){\n\t\t\t\tif((i>>j)&1==0) continue;\n\t\t\t\trep(k,n){\n\t\t\t\t\tif((i>>k)&1==1 || k==j) continue;\n\t\t\t\t\tdouble sx=cx[j],sy=cy[j],tx=cx[k],ty=cy[k],t0=dp[i][j];\n\t\t\t\t\tdouble d=sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy));\n\t\t\t\t\tif(isok(sx,sy,tx,ty,t0)) dp[i+(1<<k)][k]=min(dp[i+(1<<k)][k],dp[i][j]+d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\trep(j,n) if(dp[(1<<n)-1][j]!=inf) ok=true;\n\t\tcout << (ok ? \"YES\\n\" : \"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h> //pow , sqrt\nusing namespace std;\nstruct node{int x, y; double limit;};\nint N, dx, dy;\nnode C[32];\nbool used[32];\n\nbool solve(int hx, int hy, double t, int p){\n  if (p == N) return true;\n  \n  for (int i = 0; i < N; i++){\n    if (!used[i]){\n      double newt = t + sqrt(pow(C[i].x-hx, 2) + pow(C[i].y-hy, 2));\n      if (newt >= C[i].limit) return false;\n      used[i] = true;\n      if (solve(C[i].x, C[i].y, newt, p+1)) return true;\n      used[i] = false;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while (1){\n    int hx, hy;\n    cin >> N >> hx >> hy >> dx >> dy;\n    if (!N) break;\n    for (int i = 0; i < N; i++){\n      cin >> C[i].x >> C[i].y;\n      C[i].limit = sqrt(pow(C[i].x-dx, 2) + pow(C[i].y-dy, 2));\n    }\n    fill_n(used, N, false);\n    if (solve(hx, hy, 0.0, 0)){\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 10], dp[1 << 10];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){\n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tloc[1 << i] = i;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i != n){\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i] != INF){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & 1 << j && dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j]) && dp[i | 1 << j] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i]){\n\t\t\t\t\t\tdp[i | 1 << j] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];\n\t\t\t\t\t\tloc[i | 1 << j] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[1 << n] != -1)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<string.h>\nusing namespace std;\n\nint n,dx,dy,hx,hy;\nbool done[20];\nint cx[20],cy[20];\n\nbool dfs(int x,int y,int now,double time,int k){\n//\tcout<<now<<\" \";\n//\tcout<<time<<endl;\n\tif(now>=0 && sqrt((double)(dx-cx[now])*(dx-cx[now])+(dy-cy[now])*(dy-cy[now]))<=time) return false;\n\tif(k==n) return true;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(done[i]) true;\n\t\tif(sqrt((double)(dx-cx[i])*(dx-cx[i])+(dy-cy[i])*(dy-cy[i]))<=time) return false;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tif(done[i]) continue;\n\t\tdone[i]=true;\n\t\tif(dfs(cx[i],cy[i],i,time+sqrt((double)(x-cx[i])*(x-cx[i])+(y-cy[i])*(y-cy[i])),k+1)) return true;\n\t\tdone[i]=false;\n\t}\n\treturn false;\n}\n\n\nint main()\n{\n\twhile(cin>>n>>hx>>hy>>dx>>dy && n!=0){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>cx[i]>>cy[i];\n\t\tmemset(done,false,sizeof(done));\n\t\tif(dfs(0,0,-1,0.0,0)) cout<<\"YES\\n\";\n\t\telse cout<<\"NO\\n\";\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n#define EPS 1e-10\nint n;\ndouble sx,sy,tx,ty,px[20],py[20];\n\ndouble dis(double a,double b,double c,double d)\n{return sqrt((a-c)*(a-c)+(b-d)*(b-d));}\ndouble dis(int a,int b){return dis(px[a],py[a],px[b],py[b]);}\n\nbool dfs(int S,int pos,double cost){\n  if(S==(1<<n)-1)return true;\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(cost+dis(pos,i)>dis(tx,ty,px[i],py[i]))return false;\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(cost+dis(pos,i)>=dis(tx,ty,px[i],py[i]))continue;\n    if( dfs(S|(1<<i),i,cost+dis(pos,i)) )return true;\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i=0;i<n;i++){\n    if( dfs((1<<i),i,dis(sx,sy,px[i],py[i])) )return true;\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin>>n>>sx>>sy>>tx>>ty;\n    if(n==0)break;\n    for(int i=0;i<n;i++)cin>>px[i]>>py[i];\n    cout<<(solve()?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define MAXNUM 20\n\nstruct status{\n\tdouble d;\n\tint c;\n};\n\ndouble dist(double x1,double y1,double x2,double y2){\n\treturn sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\nvoid printB(int n){\n\tint i,a[MAXNUM];\n\tfor(i = 0;i < MAXNUM;i++){\n\t\ta[MAXNUM - 1 - i] = n % 2;\n\t\tn /= 2;\n\t}\n\tfor(i = 0;i < MAXNUM;i++)\n\t\tprintf(\"%d\",a[i]);\n}\n\nint main(void){\n\tint i, j, n;\n\tdouble hx, hy, dx, dy, cx[MAXNUM],cy[MAXNUM];\n\tstruct status dp[1 << MAXNUM];\n\twhile(1){\n\t\tscanf(\"%d%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(!n && !hx && !hy && !dx && !dy)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < 1 << MAXNUM;i++)\n\t\t\tdp[i].d = -1;\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tdp[1 << i].d = dist(hx,hy,cx[i],cy[i]);\n\t\t\tdp[1 << i].c = i;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i].d != -1){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & (1 << j) && (dp[i | (1 << j)].d == -1 || dp[i | (1 << j)].d > dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]))){\n\t\t\t\t\t\tdp[i | (1 << j)].d = dp[i].d + dist(cx[dp[i].c],cy[dp[i].c],cx[j],cy[j]);\n\t\t\t\t\t\tdp[i | (1 << j)].c = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist(dx,dy,cx[dp[(1 << n) - 1].c],cy[dp[(1 << n) - 1].c]) > dp[(1 << n) - 1].d)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\nconst float EPS=1e-8;\n\nfloat dis(float a,float c,float b,float d){\n\treturn sqrt((a-b)*(a-b)+(c-d)*(c-d));\n}\n\nfloat dp[1<<20][20];\n\nint main(){\n\n\tint N;\n\tfloat sx,sy,gx,gy;\n\twhile(cin>>N>>sx>>sy>>gx>>gy,N){\n\t\tvector<float>y(N);\n\t\tvector<float>x(N);\n\t\tvector<float>devil(N);\n\t\tbool f = true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>x[i]>>y[i];\n\t\t\tdevil[i]=dis(gx,gy,x[i],y[i]);\n\t\t\tif (devil[i] < dis(sx,sy,x[i],y[i])) {\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\tcout << \"NO\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<float>>dist(N,vector<float>(N));\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tdist[i][j]=dis(x[i],y[i],x[j],y[j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<1<<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tdp[i][j]=MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(devil[i]-EPS>dis(sx,sy,x[i],y[i])){\n\t\t\t\tdp[1<<i][i]=dis(sx,sy,x[i],y[i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<1<<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif(!((i>>j)&1))continue;\n\t\t\t\tif(dp[i][j]>=1000000)continue;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif((i>>k)&1)continue;\n\t\t\t\t\tfloat nx=dp[i][j]+dist[j][k];\n\t\t\t\t\tif(nx<devil[k]-EPS){\n\t\t\t\t\t\tdp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],nx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfloat ans=MOD;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans=min(ans,dp[(1<<N)-1][i]);\n\t\t}\n\t\tif(ans>=10000000){\n\t\t\tcout<<\"NO\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"YES\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n// Area of Polygon //\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\n// Totsuhou! Andrew's Monotone Chain //\n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n \n \nP getPedal(L l, P p){\n\tdouble A;\n\tif(abs(l[1].real()-l[0].real()) < EPS){\n\t\treturn P(l[1].real(),p.imag()); // important\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A , b = 1 , c = A*l[0].real() - l[0].imag();\n\tdouble t = (a*p.real() + b*p.imag() + c)/(a*a+b*b);\n\treturn p-t * P(a,b);\n}\n\n  \nvector<P> crosspointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS)return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nP getCircumcenter(P a,P b,P c){\n\tdouble A1 = 2 * ( b.real() - a.real() );\n\tdouble B1 = 2 * ( b.imag() - a.imag() );\n\tdouble C1 = pow(a.real(),2)-pow(b.real(),2) + pow(a.imag(),2)-pow(b.imag(),2);\n\tdouble A2 = 2 * ( c.real() - a.real() );\n\tdouble B2 = 2 * ( c.imag() - a.imag() );\n\tdouble C2 = pow(a.real(),2)-pow(c.real(),2) + pow(a.imag(),2)-pow(c.imag(),2);\n\tdouble X = (B1 * C2 - B2 * C1) / (A1 * B2 - A2 * B1);\n\tdouble Y = (C1 * A2 - C2 * A1) / (A1 * B2 - A2 * B1);\n\treturn P(X,Y);\n}\n \ndouble AreaOfPolygon(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*　多角形の面積公式 (反時計回りの場合) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\n\ndouble dp[1<<20][20];\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tP h,d,p[20];\n\t\tcin >> h.real() >> h.imag();\n\t\tcin >> d.real() >> d.imag();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> p[i].real() >> p[i].imag();\t\n\t\t}\n\t\tdouble dist[21][21];\n\t\tdouble fast[21][21];\n\t\tfor(int i = 0 ; i <= n ; i++){\n\t\t\tfor(int j = 0 ; j <= n ; j++){\n\t\t\t\tif( i == j ) continue;\n\t\t\t\tP a = (i==n?h:p[i]);\n\t\t\t\tP b = (j==n?h:p[j]);\n\t\t\t\tdist[i][j] = distanceSP(L(a,b),d);\n\t\t\t\tfast[i][j] = intersectSP(L(a,b),getPedal(L(a,b),d)) ? abs(a-getPedal(L(a,b),d)) : 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < (1<<n) ; i++)\n\t\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\t\tdp[i][j] = 1e10;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble lim = dist[n][i];\n\t\t\tif( fast[n][i] > lim - EPS ) continue;\n\t\t\tdouble nextTime = abs(h-p[i]);\n\t\t\tif( abs(d-p[i]) + EPS < nextTime ) continue;\n\t\t\tdp[(1<<i)][i] = nextTime;\n\t\t}\n\t\tfor(int i = 0 ; i < (1<<n) ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif((i>>j&1) && dp[i][j] < 1e9){\n\t\t\t\t\tfor(int k = 0 ; k < n ; k++){\n\t\t\t\t\t\tdouble lim = dist[j][k] - dp[i][j];\n\t\t\t\t\t\tif( fast[i][j] > lim - EPS ) continue;\n\t\t\t\t\t\tdouble nextTime = dp[i][j] + abs(p[j]-p[k]);\n\t\t\t\t\t\tif( abs(d-p[k]) - EPS < nextTime ) continue;\n\t\t\t\t\t\tdp[i|(1<<k)][j] = min(dp[i|(1<<k)][k],nextTime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint f = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tf |= dp[(1<<n)-1][i] < 1e9;\n\t\t\t//cout << dp[(1<<n)-1][i] << endl;\n\t\t}\n\t\tcout << (f?\"YES\":\"NO\") << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\nint n,h,w,d,e,x,y;\ndouble k;\ndouble j(int f,int g){return sqrt(f*f+g*g+0.0);}\nint main(){\n\twhile(1){\n\tcin>>n>>x>>y>>d>>e;\n\tif(!n)break;\n\tcin>>h>>w;\n\tn--,k=j(h-x,w-y);\n\tbool o=(k<j(d-x,e-y));\n\twhile(n--){\n\t\tcin>>x>>y;\n\t\tif(k+j(h-x,w-y)>=j(d-x,e-y))o=0;\n\t}\n\tif(o)cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-9;\n\ntypedef pair<xy_t, bool> dat;\n\nnamespace std{\n\tbool operator < (const xy_t &a, const xy_t &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nint n, hx, hy, dx, dy;\nxy_t points[21];\ndouble dis[1 << 21];\ndouble adj[21][21];\ndouble adjd[21];\n\nbool dfs(double t, int v, int st){\n\t\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(!(st & (1 << i)) && (adjd[i] <= t || adjd[i] <= t + adj[v][i])) return false;\n\t}\n\tif(st == (1 << (n + 1) ) - 1) return true;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(st & (1 << i)) continue;\n\t\tif(dfs(t + adj[v][i], i, st | (1 << i))) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> n >> hx >> hy >> dx >> dy && (n || hx || hy || dx || dy)){\n\t\t\n\t\tpoints[0] = xy_t(hx, hy);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints[i] = xy_t(x, y);\n\t\t}\n\n\t\tfor(int i = 0; i < n + 1; i++){\n\t\t\tadjd[i] = abs(points[i] - xy_t(dx, dy));\n\t\t\t\n\t\t\tfor(int j = 0; j < n + 1; j++)\n\t\t\t\tadj[i][j] = abs(points[i] - points[j]);\n\t\t}\n\n\t\tif(dfs(0.0, 0, 1)) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\nint n;\nint x[30], y[30],h1,h2,d1,d2;\n  \ndouble dist(int a, int b){\n    return sqrt(a*a+b*b+0.0);\n}\n  \nbool solve(){\n    for(int i=0;i<n;i++){\n        if(dist(h1-x[0],h2-y[0])+dist(x[0]-x[i],y[0]-y[i]) >= dist(d1-x[i],d2-y[i])) return false;\n    }\n    return true;\n}\n  \nint main(){\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        cin >>h1>>h2>>d1>>d2;\n        for(int i=0;i<n;i++){\n            cin >> x[i] >> y[i];\n        }\n  \n        if(solve()) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble hero[20];\nbool visited[20]={false};\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if ( visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    visited[i]=true;\n    if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n    hero[i]=dist(mx-x[i],my-y[i]);\n    if ( hero[i]+eps>adj[MAOU][i])return false;\n    visited[i]=false;\n  }\n  \n  rep(i,n){\n    visited[i]=true;\n    if ( backTrack(i,hero[i],1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(scanf(\"%d%d%d%d%d\",&n,&mx,&my,&rx,&ry) && n){\n    int x[n],y[n];\n    rep(i,n)scanf(\"%d%d\",&x[i],&y[i]);\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< double , Pi > Pii;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 55;\n\ndouble dp[1 << 20];\nint main(){\n  int n, hx, hy, dx, dy;\n  vector< char > near(1 << 20);\n  static vector< int > next[1 << 20];\n  for(int i = 0; i < 1 << 20; i++){\n    for(int k = 0; k < 20; k++){\n      if((i >> k) & 1) continue;\n      near[i] = k;\n      break;\n    }\n  }\n  for(int i = 0; i < 1 << 20; i++){\n    for(int k = 0; k < 20; k++){\n      if((i >> k) & 1) continue;\n      next[i].push_back(i|(1 << k));\n    }\n  }\n\n  \n  while(cin >> n >> hx >> hy >> dx >> dy, n|hx|hy|dx|dy){\n\n    vector< Pii > c(n);\n    for(int i = 0; i < n; i++){\n      cin >> c[i].sc.fr >> c[i].sc.sc;\n      c[i].fr = sqrt( pow( dx - c[i].sc.fr, 2) + pow( dy - c[i].sc.sc, 2));\n    }\n    sort( ALL(c));\n\n    fill_n( dp, 1 << 20, 1e9);\n\n    queue< int > nexter;\n\n    for(int i = 0; i < n; i++){\n      double dist = sqrt(pow(hx - c[i].sc.fr, 2) + pow(hy - c[i].sc.sc, 2));\n      if(dist < sqrt(pow(dx - c[i].sc.fr, 2) + pow(dy - c[i].sc.sc, 2))){\n        dp[1 << i] = dist;\n        nexter.push(1 << i);\n      }\n    }\n\n    while(!nexter.empty()){\n      int value = nexter.front(); nexter.pop();\n      for(int i = 0; i < next[value].size(); i++){\n        if(dp[i] == 1e9 || sqrt( pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) <= dp[i]) continue;\n        for(int j = 0; j < n; j++){\n          if(!((i >> j) & 1)) continue;\n          for(int k = 0; k < n; k++){\n            if((i >> k) & 1) continue;\n            double next = dp[i] + sqrt(pow( c[j].sc.fr - c[k].sc.fr, 2) + pow( c[j].sc.sc - c[k].sc.sc, 2));\n            if(next >= dp[i|(1 << k)]) continue;\n            bool check = sqrt(pow( dx - c[near[i]].sc.fr, 2) + pow( dy - c[near[i]].sc.sc, 2)) > next;\n            if(check){\n              dp[i|(1 << k)] = next;\n              nexter.push( i|(1 << k));\n            }\n          }\n        }\n      }\n    }\n\n    bool check = n == 0;\n    check |= dp[(1 << n) - 1] < 1e9;\n    if(check) cout << \"YES\" << endl;\n    else cout <<\"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n\nconst double EPS = 1e-9;\n\nconst int INF = 100000000;\n\ndouble kyo(pair<int,int> a,pair<int,int> b){\n    return sqrt((a.first-b.first)*(a.first-b.first) + (a.second-b.second)*(a.second-b.second));\n}\n\nbool solve(int ind,double zikan,set<int> &rest,const vector<vector<double> > &kyori,const vector<double> &mao){\n    if(rest.size() == 0) return true;\n    bool allok = true;\n    for(set<int>::iterator it = rest.begin();it!=rest.end();++it){\n        allok = allok and (zikan + kyori[ind][*it] < mao[*it]-EPS);\n    }\n    if(allok){\n        bool any = false;\n        for(set<int>::iterator it = rest.begin();it!=rest.end();++it){\n            rest.erase(*it);\n            any = any or solve(*it,zikan+kyori[ind][*it],rest,kyori,mao);\n            rest.insert(*it);\n        }\n        return any;\n    }else{\n        return false;\n    }\n}\n\ntemplate<class T>\nvoid cerr_vec(vector<T> vec){\n    for(int i=0;i<vec.size();i++){\n        cerr << vec[i] << \" \";\n    }\n    cerr << endl;\n}\n\nint main(){\n    while(true){\n        int n,hx,hy,dx,dy;\n        cin >> n >> hx >> hy >> dx >> dy;\n        if(n == 0) break;\n        vector<pair<int,int> > chi(n);\n        pair<int,int> m = make_pair(dx,dy);\n        pair<int,int> y = make_pair(hx,hy);\n\n        vector<double> yusya(n);\n        vector<double> mao(n);\n        vector<vector<double> > kyori(n,vector<double>(n));\n\n        set<int> rest;\n        for(int i=0;i<n;i++){\n            cin >> chi[i].first >> chi[i].second;\n            mao[i] = kyo(chi[i],m);\n            yusya[i] = kyo(chi[i],y);\n            rest.insert(i);\n        }\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                kyori[i][j] = kyo(chi[i],chi[j]);\n            }\n        }\n\n        bool any = false;\n        for(int i=0;i<n;i++){\n            rest.erase(i);\n            if(yusya[i] < mao[i]-EPS){\n                any = any or solve(i,yusya[i],rest,kyori,mao);\n            }\n            rest.insert(i);\n        }\n        if(any){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\nconst float EPS=1e-8;\n\nfloat dis(float a,float c,float b,float d){\n\treturn sqrt((a-b)*(a-b)+(c-d)*(c-d));\n}\n\nfloat dp[1<<20][20];\n\nint main(){\n\n\tint N;\n\tfloat sx,sy,gx,gy;\n\twhile(cin>>N>>sx>>sy>>gx>>gy,N){\n\t\tvector<float>y(N);\n\t\tvector<float>x(N);\n\t\tvector<float>devil(N);\n\t\tbool f = true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>x[i]>>y[i];\n\t\t\tdevil[i]=dis(gx,gy,x[i],y[i]);\n\t\t\tif (devil[i] < dis(sx,sy,x[i],y[i])) {\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\tcout << \"NO\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<float>>dist(N,vector<float>(N));\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tdist[i][j]=dis(x[i],y[i],x[j],y[j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<1<<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tdp[i][j]=MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(devil[i]-EPS>dis(sx,sy,x[i],y[i])){\n\t\t\t\tdp[1<<i][i]=dis(sx,sy,x[i],y[i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<1<<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif(!((i>>j)&1))continue;\n\t\t\t\tif(dp[i][j]>=1000000)continue;\n\t\t\t\tbool hoge = false;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif((i>>k)&1)continue;\n\t\t\t\t\tif(dp[i][j]+dist[j][k] > devil[k] + EPS)hoge = true;\n\t\t\t\t}\n\n\t\t\t\tif(hoge)continue;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif((i>>k)&1)continue;\n\t\t\t\t\tfloat nx=dp[i][j]+dist[j][k];\n\t\t\t\t\tif(nx<devil[k]-EPS){\n\t\t\t\t\t\tdp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],nx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfloat ans=MOD;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans=min(ans,dp[(1<<N)-1][i]);\n\t\t}\n\t\tif(ans>=10000000){\n\t\t\tcout<<\"NO\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"YES\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second \n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n\ndouble cost[22][22];\ndouble tlimit[22];\nint xx[22];\nint cx[22], cy[22];\nint n;\n\nbool DFS(int pos, int vis, double dis){\n\tif(vis == ((1<<(n+1))-1))return true;\n\t//枝狩り\n\tFOR(i, 1, n+1)if((vis&xx[i])==0 && (dis+cost[pos][i] > tlimit[i]+EPS))return false;\n\tFOR(i, 1, n+1){\n\t\tif((vis&xx[i])==0 && (dis+cost[pos][i]+EPS < tlimit[i])){\n\t\t\tif(DFS(i, vis|xx[i], dis+cost[pos][i])){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tREP(i,22)xx[i] = 1<<i;\n\twhile(1){\n\t\tint dx,dy;\n\t\tcin>>n>>cx[0]>>cy[0]>>dx>>dy;\n\t\tif(n==0)return 0;\n\t\tFOR(i,1,n+1)cin >> cx[i] >> cy[i];\n\t\tREP(i, n+1){\n\t\t\ttlimit[i] = sqrt(pow(cx[i]*1.0-dx*1.0,2.0)+pow(cy[i]*1.0-dy*1.0,2.0));\n\t\t\tREP(j,n+1){\n\t\t\t\tcost[i][j] = sqrt(pow(cx[i]*1.0-cx[j]*1.0,2.0)+pow(cy[i]*1.0-cy[j]*1.0,2.0));\n\t\t\t}\n\t\t}\n\t\tif(DFS(0, 1, 0.0))cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <queue>\n#define MAXNUM 2000\n#define zero 1000 // (1000,1000)が原点\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\nusing namespace std;\n\nconst int ddx[] = {-1,0,1,0} ,ddy[] = {0,-1,0,1};\nint shoki[MAXNUM + 1][MAXNUM + 1], p[20][20], cx[20], cy[20], hx, hy, n;\n\nint solve(int pre){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= shoki[cy[i] + zero][cx[i] + zero]) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit){ // 未探索の位置にあるクリスタル\n\t\t\tif(pre == -1 && dist(hx,hy,cx[i],cy[i]) + sum < shoki[cy[i] + zero][cx[i] + zero]){ // １つ目のクリスタルをとる\n\t\t\t\tsum += dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tbit += 1 << i;\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbit -= 1 << i;\n\t\t\t\tsum -= dist(hx,hy,cx[i],cy[i]);\n\t\t\t}\n\t\t\telse if(pre != -1 && p[pre][i] + sum < shoki[cy[i] + zero][cx[i] + zero]){ // ２〜ｎつ目のクリスタルを取る\n\t\t\t\tbit += 1 << i;\n\t\t\t\tsum += p[pre][i];\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tsum -= p[pre][i];\n\t\t\t\tbit -= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint  dx, dy, x, y, i, j;\n\tqueue<int> qx, qy;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(i == j)\n\t\t\t\t\tp[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tp[i][j] = dist(cx[i],cy[i],cx[j],cy[j]);\n\t\t\t}\n\t\t}\n\t\tmemset(shoki,-1,sizeof(shoki));\n\t\tqx.push(dx + zero),qy.push(dy + zero);\n\t\tshoki[dy + zero][dx + zero] = 0;\n\t\twhile(shoki[0][0] == -1 || shoki[MAXNUM][MAXNUM] == -1 || shoki[MAXNUM][0] == -1 || shoki[0][MAXNUM] == -1){\n\t\t\twhile(qx.size()){\n\t\t\t\tx = qx.front();\n\t\t\t\ty = qy.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\t\tif(x + ddx[i] >= 0 && x + ddx[i] <= MAXNUM && y + ddy[i] >= 0 && y + ddy[i] <= MAXNUM && shoki[y + ddy[i]][x + ddx[i]] == -1){\n\t\t\t\t\t\tqx.push(x + ddx[i]),qy.push(y + ddy[i]);\n\t\t\t\t\t\tshoki[y + ddy[i]][x + ddx[i]] = shoki[y][x] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(solve(-1))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <queue>\n#define MAXNUM 2000\n#define zero 1000 // (1000,1000)が原点\nusing namespace std;\n\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nconst int ddx[] = {-1,0,1,0} ,ddy[] = {0,-1,0,1};\nint shoki[MAXNUM + 1][MAXNUM + 1], p[20][20], cx[20], cy[20], hx, hy, n;\n\nint solve(int pre){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= shoki[cy[i] + zero][cx[i] + zero]) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit){ // 未探索の位置にあるクリスタル\n\t\t\tif(pre == -1 && dist(hx,hy,cx[i],cy[i]) + sum < shoki[cy[i] + zero][cx[i] + zero]){ // １つ目のクリスタルをとる\n\t\t\t\tsum += dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tbit += 1 << i;\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbit -= 1 << i;\n\t\t\t\tsum -= dist(hx,hy,cx[i],cy[i]);\n\t\t\t}\n\t\t\telse if(pre != -1 && p[pre][i] + sum < shoki[cy[i] + zero][cx[i] + zero]){ // ２〜ｎつ目のクリスタルを取る\n\t\t\t\tbit += 1 << i;\n\t\t\t\tsum += p[pre][i];\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tsum -= p[pre][i];\n\t\t\t\tbit -= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint  dx, dy, x, y, i, j;\n\tqueue<int> qx, qy;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(i == j)\n\t\t\t\t\tp[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tp[i][j] = dist(cx[i],cy[i],cx[j],cy[j]);\n\t\t\t}\n\t\t}\n\t\tmemset(shoki,-1,sizeof(shoki));\n\t\tqx.push(dx + zero),qy.push(dy + zero);\n\t\tshoki[dy + zero][dx + zero] = 0;\n\t\twhile(shoki[0][0] == -1 || shoki[MAXNUM][MAXNUM] == -1 || shoki[MAXNUM][0] == -1 || shoki[0][MAXNUM] == -1){\n\t\t\twhile(qx.size()){\n\t\t\t\tx = qx.front();\n\t\t\t\ty = qy.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\t\tif(x + ddx[i] + zero >= 0 && x + ddx[i] + zero <= MAXNUM && y + ddy[i] + zero >= 0 && y + ddy[i] + zero <= MAXNUM && shoki[y + ddy[i] + zero][x + ddx[i] + zero] == -1){\n\t\t\t\t\t\tqx.push(x + ddx[i] + zero),qy.push(y + ddy[i] + zero);\n\t\t\t\t\t\tshoki[y + ddy[i] + zero][x + ddx[i] + zero] = shoki[y + zero][x + zero] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(solve(-1))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint cx[20],cy[20];\nint lim[20];\nint dd[20][20];\nbool memo[20][1<<20];\n\n#define ABS(x) ((x) < 0 ? -(x) : (x))\n\ninline int dist(int x1, int y1, int x2, int y2){\n  return ABS(x1-x2) + ABS(y1-y2);\n}\n\ninline int b2i(unsigned int bit){\n  int ans=0;\n  if(!(bit&0x0000FFFF)){ans+=16;bit>>=16;}\n  if(!(bit&0x000000FF)){ans+= 8;bit>>= 8;}\n  if(!(bit&0x0000000F)){ans+= 4;bit>>= 4;}\n  if(!(bit&0x00000003)){ans+= 2;bit>>= 2;}\n  if(!(bit&0x00000001)){ans+= 1;         }\n  return ans;\n}\n\nbool solve(int pos, int f, int time){\n  //printf(\"solve(%d,%d,%d) : lim = %d\\n\",pos,f,time,lim[pos]);\n  if(time >= lim[pos]) return false;\n  if(memo[pos][f]) return false;\n  if(f == 0) return true;\n  memo[pos][f] = true;\n\n  while(f){\n    int ff = f & (-f);\n    int next = b2i(ff);\n    f ^= ff;\n    if(solve(next, f, time + dd[pos][next])) return true;\n  }\n  return false;\n}\n\nint main(){\n  while(true){\n    int n,hx,hy,dx,dy;\n    n = getInt(); hx = getInt(); hy = getInt();\n    dx = getInt(); dy = getInt();\n    if(!(n+hx+hy+dx+dy)) break;\n    memset(memo, 0, sizeof(memo));\n    REP(i,n){ cx[i] = getInt(); cy[i] = getInt(); }\n    REP(i,n){ lim[i] = dist(dx,dy,cx[i],cy[i]); }\n    REP(i,n) REP(j,n) dd[i][j] = dist(cx[i],cy[i],cx[j],cy[j]);\n\n    bool ans = false;\n    REP(i,n){\n      if(solve(i,(((1<<n)-1)^(1<<i)),dist(hx,hy,cx[i],cy[i]))){\n        ans = true;\n        break;\n      }\n    }\n    puts(ans ? \"YES\" : \"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define pf push_front\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint n,hx,hy,dx,dy;\nvector<P> vec;\nint LIM;\nbool Found;\nconst double EPS = (1>>10);\n\nvoid print(int used)\n{\n  rep(i,n)\n\t{\n\t  if(used>>i&1)\n\t    cout << \"1\";\n\t  else\n\t    cout << \"0\";\n\t}\n      cout << endl;\n}\n\nbool Input()\n{\n  cin >> n >> hx >> hy >> dx >> dy;\n  if(n+hx+hy+dx+dy == 0)\n    return true;\n  \n  vec.clear(),LIM = 0,Found = false;\n  rep(i,n)\n    {\n      int X,Y;\n      cin >> X >> Y;\n      vec.pb(P(X,Y));\n      LIM = LIM|(1<<i);\n    }\n  return false;\n}\n\nbool isCan(P my,double ene,P p,int used)\n{\n\n  double cost = sqrt(pow(p.F-my.F,2)+pow(p.S-my.S,2));\n \n  rep(i,n)\n    {\n      if((used>>i)&1)\n\tcontinue;\n\n      double dist = sqrt(pow(vec[i].F-dx,2)+pow(vec[i].S-dy,2));\n\n      //cout << \"circle : \" << ene+cost << \" , dist : \" << dist << endl;\n      if(ene+cost >= dist)\n\treturn false;\n    }\n  return true;\n}\n\nvoid rec(P my,double cir,int used)\n{\n  if(Found)\n    return;\n\n  //print(used);\n\n  if(used == LIM)\n    {\n      Found = true;\n      return;\n    }\n\n  rep(i,n)\n    {\n      if((used>>i)&1)\n\tcontinue;\n      if(isCan(my,cir,vec[i],used))\n\t{\n\t  rec(vec[i],cir+sqrt(pow(vec[i].F-my.F,2)+pow(vec[i].S-my.S,2)),(used|1<<i));\n\t}\n    }\n\n}\n\nint main(){\n  while(true)\n    {\n      if(Input())\n\tbreak;\n    \n \n      rec(P(hx,hy),0,0);\n      Found?cout << \"YES\" << endl:cout << \"NO\" << endl;\n    }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ndouble lim[20],limbit[1<<20],inf=1e9,eps=1e-9,limit[21][21];\nint n,hx,hy,mx,my,cx[21],cy[21];\nvoid calc(){\n\trep(i,n+1) rep(j,n+1){\n\t\tif(i==j) limit[i][j]=0;\n\t\tdouble sx=cx[i],sy=cy[i],tx=cx[j],ty=cy[j],d=sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy)),dx=(tx-sx)/d,dy=(ty-sy)/d,x=sx-mx,y=sy-my;\n\t\tdouble b=2*d,c=-(x*x+y*y+2*d*(x*dx+y*dy));\n\t\tlimit[i][j]=(-b+sqrt(b*b-4*c))/2;\n\t}\n}\nbool dfs(int bit,int v,double t){\n\tif(bit==(1<<n)-1) return true;\n\tif(t+eps>limbit[bit]) return false;\n\trep(i,n){\n\t\tif((bit>>i)&1) continue;\n\t\tif(t+eps>limit[v][i]) return false;\n\t}\n\trep(i,n){\n\t\tif((bit>>i)&1) continue;\n\t\tif(dfs(bit+(1<<i),i,t+sqrt((cx[i]-cx[v])*(cx[i]-cx[v])+(cy[i]-cy[v])*(cy[i]-cy[v])))) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tcin >> cx[n] >> cy[n] >> mx >> my;\n\t\tif(n==0) break;\n\t\trep(i,n){\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tlim[i]=sqrt((cx[i]-mx)*(cx[i]-mx)+(cy[i]-my)*(cy[i]-my));\n\t\t}\n\t\trep(i,1<<n){\n\t\t\tlimbit[i]=inf;\n\t\t\trep(j,n){\n\t\t\t\tif((i<<j)&1==0) limbit[i]=min(limbit[i],lim[j]);\n\t\t\t}\n\t\t}\n\t\tcalc();\n\t\tcout << (dfs(0,n,0) ? \"YES\\n\" : \"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n#define EPS 10e-12\n\nint n, hx, hy, dx, dy;\nint cx[22], cy[22];\n//double c[21];\nbool flag;\n\ndouble dstnc(int ax, int ay, int bx, int by){\n    return sqrt((double)((bx-ax)*(bx-ax) + (by-ay)*(by-ay)));\n}\n\nint dfs(int S, double t, int v){\n    for(int i = 0; i < n; i++){\n        if(!(S & (1<<i)) && (dstnc(cx[v],cy[v],cx[i],cy[i]) + t + EPS > dstnc(dx,dy,cx[i],cy[i]))) return 0;\n    }\n    int flag1 = false;\n    for(int i = 0; i < n; i++){\n        if(!(S & (1<<i))) flag1 = true;\n    }\n    if(!flag1) return 1;\n    int ret = 0;\n    for(int i = 0; i < n; i++){\n        if(!(S & (1<<i))) ret = dfs(S | (1<<i), t + dstnc(cx[v],cy[v],cx[i],cy[i]), i);\n        if(ret) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    \n    while(cin >> n >> hx >> hy >> dx >> dy, n){\n        for(int i = 0; i < n; i++) cin >> cx[i] >> cy[i];\n        //for(int i = 0; i < n; i++) c[i] = sqrt((double)((dx-cx[i])*(dx-cx[i]) + (dy-cy[i])*(dy-cy[i])));\n        cx[21] = hx;\n        cy[21] = hy;\n        flag = dfs(0,0,21);\n        \n        \n        if(flag)cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\nint abs(int n){\n    if(n < 0)\n\t\tn = -1 * n;\n    return n;\n}\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 21], dp[1 << 21];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) \n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF; \n\t\tfor(i = 0;i < n;i++) \n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]); \n\t\tfor(i = 0;i < n;i++){ \n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){ \n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]); \n\t\t\t\tloc[1 << i] = i; \n\t\t\t} \n\t\t\telse  \n\t\t\t\tbreak; \n\t\t}  \n\t\tif(i != n){  \n\t\t\tprintf(\"NO\\n\"); \n\t\t\tcontinue;  \n\t\t}  \n\t\tfor(i = 0;i < 1 << n;i++){ \n\t\t\tif(dp[i] != INF){  \n\t\t\t\tfor(j = 0;j < n;j++){  \n\t\t\t\t\tif(~i & 1 << j && dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j]) && dp[i | 1 << j] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i]){ \n\t\t\t\t\t\tdp[i | 1 << j] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];  \n\t\t\t\t\t\tloc[i | 1 << j] = j; \n\t\t\t\t\t}  \n\t\t\t\t}  \n\t\t\t}  \n\t\t}   \n\t\tif(dp[(1 << n) - 1] != INF) \n\t\t\tprintf(\"YES\\n\");  \n\t\telse  \n\t\t\tprintf(\"NO\\n\");\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i] == INF)\n\t\t\t\tprintf(\"☆ \");\n\t\t\telse\n\t\t\t\tprintf(\"%d \",dp[i]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint n;\nint cx[20],cy[20];\nint dx,dy;\n\ndouble dist(int x1,int y1,int x2,int y2){\n\treturn sqrt((double)((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\nbool check(double t,int s,int x,int y){\n\tfor(int i=0;i<n;i++){\n\t\tif(s>>i&1)continue;\n\t\tif(dist(dx,dy,cx[i],cy[i])-1e-8 < t+dist(x,y,cx[i],cy[i]))return false;\n\t}\n\treturn true;\n}\nbool dfs(double t,int s,int x,int y){\n\tif((1<<n)-1==s)return true;\n\tif(!check(t,s,x,y))return false;\n\tfor(int i=0;i<n;i++){\n\t\tif(s>>i&1)continue;\n\t\tif(dfs(t+dist(x,y,cx[i],cy[i]),s|1<<i,cx[i],cy[i]))return true;\n\t}\n\treturn false;\n}\nint main(){\n\tint hx,hy;\n\twhile(cin>>n>>hx>>hy>>dx>>dy,n|hx|hy|dx|dy){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>cx[i]>>cy[i];\n\t\t}\n\t\tcout<<(dfs(0,0,hx,hy)?\"YES\":\"NO\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 20\n\nstruct P{\n  double x, y;\n}; \n\nint N;\nP h, d, c[MAX];\n \ndouble dist(P a, P b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX];\nbool rec(int now, double sum, int dep){\n  if(dep == N){\n    return true;\n  }\n\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      if(sum + dist(c[now],c[i]) >= dist(d,c[i])){\n        return false;\n      }\n    }\n  }\n\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      used[i] = true;\n      if(rec(i, sum+dist(c[now],c[i]),dep+1)){\n        return true;\n      }\n      used[i] = false;\n    }\n  }\n  return false;\n}\n\nvoid solve(){\n  for(int i = 0 ; i < N ; i++){\n    memset(used, false, sizeof(used));\n    if(rec(i, dist(h,c[i]), 0)){\n      puts(\"YES\");\n      return;\n    }\n  }\n  puts(\"NO\");\n}\n \nint main(){\n  while(scanf(\"%d%lf%lf%lf%lf\" ,&N, &h.x, &h.y, &d.x, &d.y)\n        , (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      scanf(\"%lf%lf\" ,&c[i].x, &c[i].y);\n    }\n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n// Area of Polygon //\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\n// Totsuhou! Andrew's Monotone Chain //\n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n \n \nP getPedal(L l, P p){\n\tdouble A;\n\tif(abs(l[1].real()-l[0].real()) < EPS){\n\t\treturn P(l[1].real(),p.imag()); // important\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A , b = 1 , c = A*l[0].real() - l[0].imag();\n\tdouble t = (a*p.real() + b*p.imag() + c)/(a*a+b*b);\n\treturn p-t * P(a,b);\n}\n\n  \nvector<P> crosspointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS)return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nP getCircumcenter(P a,P b,P c){\n\tdouble A1 = 2 * ( b.real() - a.real() );\n\tdouble B1 = 2 * ( b.imag() - a.imag() );\n\tdouble C1 = pow(a.real(),2)-pow(b.real(),2) + pow(a.imag(),2)-pow(b.imag(),2);\n\tdouble A2 = 2 * ( c.real() - a.real() );\n\tdouble B2 = 2 * ( c.imag() - a.imag() );\n\tdouble C2 = pow(a.real(),2)-pow(c.real(),2) + pow(a.imag(),2)-pow(c.imag(),2);\n\tdouble X = (B1 * C2 - B2 * C1) / (A1 * B2 - A2 * B1);\n\tdouble Y = (C1 * A2 - C2 * A1) / (A1 * B2 - A2 * B1);\n\treturn P(X,Y);\n}\n \ndouble AreaOfPolygon(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*　多角形の面積公式 (反時計回りの場合) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\n\nfloat dp[1<<20][20];\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tP h,d,p[20];\n\t\tcin >> h.real() >> h.imag();\n\t\tcin >> d.real() >> d.imag();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> p[i].real() >> p[i].imag();\t\n\t\t}\n\t\tdouble dist[21][21];\n\t\tdouble fast[21][21];\n\t\tfor(int i = 0 ; i <= n ; i++){\n\t\t\tfor(int j = 0 ; j <= n ; j++){\n\t\t\t\tif( i == j ) continue;\n\t\t\t\tP a = (i==n?h:p[i]);\n\t\t\t\tP b = (j==n?h:p[j]);\n\t\t\t\tdist[i][j] = distanceSP(L(a,b),d);\n\t\t\t\tfast[i][j] = intersectSP(L(a,b),getPedal(L(a,b),d)) ? abs(a-getPedal(L(a,b),d)) : 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < (1<<n) ; i++)\n\t\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\t\tdp[i][j] = 1e10;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble lim = dist[n][i];\n\t\t\tif( fast[n][i] > lim - EPS ) continue;\n\t\t\tdouble nextTime = abs(h-p[i]);\n\t\t\tif( abs(d-p[i]) + EPS < nextTime ) continue;\n\t\t\tdp[(1<<i)][i] = nextTime;\n\t\t}\n\t\tfor(int i = 0 ; i < (1<<n) ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif((i>>j&1) && dp[i][j] < 1e9){\n\t\t\t\t\tfor(int k = 0 ; k < n ; k++){\n\t\t\t\t\t\tdouble lim = dist[j][k] - dp[i][j];\n\t\t\t\t\t\tif( fast[i][j] > lim - EPS ) continue;\n\t\t\t\t\t\tdouble nextTime = dp[i][j] + abs(p[j]-p[k]);\n\t\t\t\t\t\tif( abs(d-p[k]) - EPS < nextTime ) continue;\n\t\t\t\t\t\tdp[i|(1<<k)][j] = min<float>(dp[i|(1<<k)][k],nextTime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint f = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tf |= dp[(1<<n)-1][i] < 1e9;\n\t\t\t//cout << dp[(1<<n)-1][i] << endl;\n\t\t}\n\t\tcout << (f?\"YES\":\"NO\") << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\n\nint abs(int n){\n\tif(n < 0)\n\t\tn = -n;\n\treturn n;\n}\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 10], dp[1 << 10];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){\n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tloc[1 << i] = i;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i != n){\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i] != INF){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & 1 << j && dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j]) && dp[i | 1 << j] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i]){\n\t\t\t\t\t\tdp[i | 1 << j] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];\n\t\t\t\t\t\tloc[i | 1 << j] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[1 << n - 1] != INF)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n\ndouble cost[22][22];\ndouble tlimit[22];\nint xx[22];\nint cx[22], cy[22];\nint n;\n\nbool DFS(int pos, int vis, double dis){\n\tif(vis == ((1<<(n+1))-1))return true;\n\t//枝狩り\n\tFOR(i, 1, n+1)if((vis&xx[i])==0 && (dis+cost[pos][i] > tlimit[i]+EPS))return false;\n\tFOR(i, 1, n+1){\n\t\tif(!(vis&xx[i])){\n\t\t\tif(DFS(i, vis|xx[i], dis+cost[pos][i])){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tREP(i,22)xx[i] = 1<<i;\n\twhile(1){\n\t\tint dx,dy;\n\t\tcin>>n>>cx[0]>>cy[0]>>dx>>dy;\n\t\tif(n==0)return 0;\n\t\tFOR(i,1,n+1)scanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tREP(i, n+1){\n\t\t\ttlimit[i] = sqrt(pow(cx[i]*1.0-dx*1.0,2.0)+pow(cy[i]*1.0-dy*1.0,2.0));\n\t\t\tREP(j,i+1){\n\t\t\t\tcost[i][j] = sqrt(pow(cx[i]*1.0-cx[j]*1.0,2.0)+pow(cy[i]*1.0-cy[j]*1.0,2.0));\n\t\t\t\tcost[j][i] = cost[i][j];\n\t\t\t}\n\t\t}\n\t\tif(DFS(0, 1, 0.0))cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint n,hx,hy,dx,dy;\n\nfloat dist[21][21];\nstruct Crystal{\n    int x,y;\n    float dist;\n    bool visited;\n};\nCrystal crystals[21];//[0]????????????????????????????????????\n\nbool rec(int s,float t){\n    crystals[s].visited=true;\n    for(int i=0;i<n;i++){\n        if(crystals[i].visited) continue;\n        if(dist[i][s]+t<crystals[i].dist){\n            if(rec(i,dist[i][s]+t)){\n                return true;\n            }else{\n                continue;\n            }\n        }else{\n            //???????????????????????????????????£??????\n            crystals[s].visited=false;\n            return false;\n        }\n    }\n    //??¨???????????????????????????????????????\n    return true;\n}\n\nint main(void){\n    while(cin >> n >> crystals[0].x >> crystals[0].y >> dx >> dy,n){\n        for(int i=1;i<=n;i++){\n            cin >> crystals[i].x >> crystals[i].y;\n            crystals[i].dist=sqrt(pow(crystals[i].x-dx,2)+pow(crystals[i].y-dy,2));\n        }\n        sort(crystals+1,crystals+n+1,[](const Crystal& a, const Crystal& b){return (a.dist==b.dist)?(a.x<b.x):(a.dist)<(b.dist);});\n        for(int i=0;i<=n;i++){\n            crystals[i].visited=false;\n            for(int k=i+1;k<=n;k++){\n                dist[i][k]=dist[k][i]=sqrt(pow(crystals[i].x-crystals[k].x,2)+pow(crystals[i].y-crystals[k].y,2));\n            }\n        }\n        if(rec(0,0)){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\ndouble eps=1e-9;\nint x[23];\nint y[23];\ndouble dist[23][23];\nint n;\nint solve(int a,int b,double s){\n\tif(a==(1<<n)-1)return 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(a&(1<<i))continue;\n\t\tif(s+dist[b][i]+eps>dist[n+1][i])return 0;\n\t\tif(solve(a+(1<<i),i,s+dist[b][i]))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,hx,hy,dx,dy;\n\twhile(scanf(\"%d%d%d%d%d\",&a,&hx,&hy,&dx,&dy),a){\n\t\tn=a;\n\t\tfor(int i=0;i<a;i++)scanf(\"%d%d\",x+i,y+i);\n\t\tx[a]=hx;x[a+1]=dx;\n\t\ty[a]=hy;y[a+1]=dy;\n\t\tfor(int i=0;i<a+2;i++)for(int j=0;j<a+2;j++)\n\t\t\tdist[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\tif(solve(0,a,0))printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\nint abs(int n){\n    if(n < 0)\n\t\tn = -1 * n;\n    return n;\n}\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 21], dp[1 << 21];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) \n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF; \n\t\tfor(i = 0;i < n;i++) \n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]); \n\t\tfor(i = 0;i < n;i++){ \n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){ \n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]); \n\t\t\t\tloc[1 << i] = i; \n\t\t\t} \n\t\t\telse  \n\t\t\t\tbreak; \n\t\t}  \n\t\tif(i != n){  \n\t\t\tprintf(\"NO\\n\"); \n\t\t\tcontinue;  \n\t\t}  \n\t\tfor(i = 0;i < 1 << n;i++){ \n\t\t\tif(dp[i] != INF){  \n\t\t\t\tfor(j = 0;j < n;j++){  \n\t\t\t\t\tif(~i & 1 << j && dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j]) && dp[i | 1 << j] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i]){ \n\t\t\t\t\t\tdp[i | 1 << j] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];  \n\t\t\t\t\t\tloc[i | 1 << j] = j; \n\t\t\t\t\t}  \n\t\t\t\t}  \n\t\t\t}  \n\t\t}   \n\t\tif(dp[(1 << n) - 1] != INF) \n\t\t\tprintf(\"YES\\n\");  \n\t\telse  \n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ndouble lim[20],limbit[1<<20],inf=1e9,eps=1e-9,limit[21][21];\nint n,hx,hy,mx,my,cx[21],cy[21];\nvoid calc(){\n\trep(i,n+1) rep(j,n+1){\n\t\tif(i==j) limit[i][j]=0;\n\t\tdouble sx=cx[i],sy=cy[i],tx=cx[j],ty=cy[j],d=sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy)),dx=(tx-sx)/d,dy=(ty-sy)/d,x=sx-mx,y=sy-my;\n\t\tdouble b=2*d,c=-(x*x+y*y+2*d*(x*dx+y*dy));\n\t\tlimit[i][j]=(-b+sqrt(b*b-4*c))/2;\n\t}\n}\nbool dfs(int bit,int v,double t){\n\tif(bit==(1<<n)-1) return true;\n\tif(t+eps>limbit[bit]) return false;\n\trep(i,n){\n\t\tif((bit>>i)&1) continue;\n\t\tif(t+eps>limit[v][i]) continue;\n\t\tif(dfs(bit+(1<<i),i,t+sqrt((cx[i]-cx[v])*(cx[i]-cx[v])+(cy[i]-cy[v])*(cy[i]-cy[v])))) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> cx[n] >> cy[n] >> mx >> my;\n\t\tif(n==0) break;\n\t\trep(i,n){\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tlim[i]=sqrt((cx[i]-mx)*(cx[i]-mx)+(cy[i]-my)*(cy[i]-my));\n\t\t}\n\t\trep(i,1<<n){\n\t\t\tlimbit[i]=inf;\n\t\t\trep(j,n){\n\t\t\t\tif((i<<j)&1==0) limbit[i]=min(limbit[i],lim[j]);\n\t\t\t}\n\t\t}\n\t\tcalc();\n\t\tcout << (dfs(0,n,0) ? \"YES\\n\" : \"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#define MAX_NUM 100000000\n\ndouble dist(int x,int y){\n\treturn sqrt((double)(x * x + y * y));\n}\n\ndouble min(double a, double b){\n\tif(a > b)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\n\nint n, cx[20], cy[20], dx, dy;\n\ndouble dfs(int now,double sum,int bit){\n\tint i;\n\tdouble ret = MAX_NUM;\n\tif(sum >= dist(dx - cx[now],dy - cy[now])) return ret;\n\tif(bit == (1 << n) - 1) return sum;\n\tfor(i = 0;i < n;i++){\n\t\tif(~bit & (1 << i)){\n\t\t\tret = min(dfs(i,sum + dist(cx[i] - cx[now],cy[i] - cy[now]),bit | (1 << i)),ret);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(void){\n\tint hx, hy, i;\n\tdouble ans;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tans = MAX_NUM;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tans = min(ans,dfs(i,dist(cx[i] - hx,cy[i] - hy),1 << i));\n\t\tif(ans != MAX_NUM)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ndouble lim[20],inf=1e9,eps=1e-9,limit[21][21];\nint n,hx,hy,mx,my,cx[21],cy[21];\nvoid calc(){\n\trep(i,n+1) rep(j,n+1){\n\t\tif(i==j) limit[i][j]=0;\n\t\tdouble sx=cx[i],sy=cy[i],tx=cx[j],ty=cy[j],d=sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy)),dx=(tx-sx)/d,dy=(ty-sy)/d,x=sx-mx,y=sy-my;\n\t\tdouble b=2*d,c=-(x*x+y*y+2*d*(x*dx+y*dy));\n\t\tlimit[i][j]=(-b+sqrt(b*b-4*c))/2;\n\t}\n}\nbool dfs(int bit,int v,double t){\n\tif(bit==(1<<n)-1) return true;\n\trep(j,n) if( ((bit>>j)&1) && t+eps>lim[j]) return false;\n\trep(i,n){\n\t\tif((bit>>i)&1) continue;\n\t\tif(t+eps>limit[v][i]) continue;\n\t\tif(dfs(bit+(1<<i),i,t+sqrt((cx[i]-cx[v])*(cx[i]-cx[v])+(cy[i]-cy[v])*(cy[i]-cy[v])))) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> cx[n] >> cy[n] >> mx >> my;\n\t\tif(n==0) break;\n\t\trep(i,n){\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tlim[i]=sqrt((cx[i]-mx)*(cx[i]-mx)+(cy[i]-my)*(cy[i]-my));\n\t\t}\n\t\tcalc();\n\t\tcout << (dfs(0,n,0) ? \"YES\\n\" : \"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include <queue>\nusing namespace std;\n#define MAX_N 20\n#define OVER 9999999\n\nint syo[MAX_N];\nint isi_x[MAX_N];\nint isi_y[MAX_N];\nint edge[MAX_N][MAX_N];\nint dp[1<<MAX_N][MAX_N];\nint hx,hy,n;\nbool chack;\n\nstruct node{\n  int S,v,cost;\n  node(int s, int vv,int c): S(s), v(vv),cost(c){}\n  bool operator >(const node &e) const{\n    return cost > e.cost;\n  }\n};\n\n/*\nbool rec(int S, int v,int t)\n{\n  if(chack)\n    return true;\n  // cout<<v<<endl;\n\n  \n  if(S==0)\n    cout<<\"0\";\n  for(int i=S;i!=0;)\n    {\n      cout<<i%2;\n      i=i/2;\n    } \n  printf(\" %d %d\\n\",v,t);  \n  \n  //  if(S==0)\n  //    dp[1<<v][v]=t;\n  if(dp[S][v]<t)\n    return false;\n  dp[S][v]=t;\n  if(t>=syo[v])\n    return false;\n  // cout<<\"ALL:\"<<(1<<n)-1<<endl;\n  if(S==(1<<n)-1)\n    {\n      chack=true;\n      return true;\n    }\n  //int res=OVER;\n  for(int i=0;i<n;i++)\n    {\n      if(!(S>>i&1))\n\t{\n\t  rec(S|1<<i,i,t+edge[v][i]);\n\t}\n    }\n  return false;\n}\n*/\n\nint main()\n{\n  int dx,dy;\n\n  for(;cin>>n>>hx>>hy>>dx>>dy,n;)\n    {\n      bool chack=false;\n      //memset(dp,false,sizeof(dp));\n      for(int i=0;i<n;i++)\n\t{\n\t  cin>>isi_x[i]>>isi_y[i];\n\t  syo[i]=abs(dx-isi_x[i])+abs(dy-isi_y[i])-1;\n\t}\n      for(int i=0;i<n;i++)    \n\tfor(int j=0;j<n;j++)  \n\t  edge[i][j]=abs(isi_x[i]-isi_x[j])+abs(isi_y[i]-isi_y[j]);\n      \n      // cout<<\"aaa\"<<endl;\n      //     int ans = OVER;\n      priority_queue<node, vector<node>, greater<node> > P;\n      // priority_queue<node> P;\n      for(int i=0;i<n;i++)\n\t{\n\t  P.push(node(1<<i,i,abs(isi_x[i]-hx)+abs(isi_y[i]-hy)));\n\t  //\t if(!chack)\n\t  //   rec(1<<i,i,abs(isi_x[i]-hx)+abs(isi_y[i]-hy));\n\t}\n      for(;!P.empty();)\n\t{\n\t  node s = P.top();\n\t  P.pop();\n\t  \n\t  if(s.cost>=syo[s.v])\n\t    break;\n\t  \n\t  if(s.S==(1<<n)-1)\n\t    {\n\t      chack=true;\n\t      break;\n\t    }\n\t  for(int i=0;i<n;i++)\n\t    {\n\t      if(!(s.S>>i&1))\n\t\t{\n\t\t  P.push(node(s.S|1<<i,i,s.cost+edge[s.v][i]));\n\t\t}\n\t    }\n\t  \n\t}\n\n     if(chack)\n       cout<<\"YES\"<<endl;\n     else\n       cout<<\"NO\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-5;\n\nint N;\nP D;\nvector<P> ps;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, int p) {\n  double dist = abs(D - ps[p]);\n  return !(equals(dist, t) || dist < t);\n}\n\nbool rec(int state, double t, int p) {\n  if(state == (1<<N)-1) return true;\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    if(!canExist(t+abs(ps[i] - ps[p]), i)) return false;\n  }\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    double nt = t + abs(ps[i] - ps[p]);\n    if(rec(state|(1<<i), nt, i)) return true;\n  }\n  return false;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy\n\t&&(N|hx|hy|dx|dy) ) {\n    D = P(dx, dy);\n    ps.resize(N+1);\n    ps[N-1] = P(hx, hy);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(rec(0, 0.0, N)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\nint abs(int n){\n    if(n < 0)\n        n = -n;\n    return n;\n}\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n int main(void){\n    int n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 20], dp[1 << 20];\n    while(1){\n        scanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n        if(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) \n           break;\n        for(i = 0;i < 1 << n;i++)\n            dp[i] = INF; \n       for(i = 0;i < n;i++) \n           scanf(\"%d%d\",&cx[i],&cy[i]); \n       for(i = 0;i < n;i++){ \n           if(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){ \n               dp[1 << i] = dist(hx,hy,cx[i],cy[i]); \n               loc[1 << i] = i; \n           } \n           else  \n              break; \n       }  \n      if(i != n){  \n          printf(\"NO\\n\"); \n           continue;  \n      }  \n      for(i = 0;i < 1 << n;i++){ \n           if(dp[i] != INF){  \n              for(j = 0;j < n;j++){  \n                  if(~i & 1 << j && dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j]) && dp[i | 1 << j] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i]){ \n                       dp[i | 1 << j] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];  \n                      loc[i | 1 << j] = j; \n                   }  \n              }  \n          }  \n      }   \n     if(dp[(1 << n) - 1] != INF) \n           printf(\"YES\\n\");  \n      else  \n          printf(\"NO\\n\"); \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <random>\n#include <cmath>\n#include <climits>\n#include <iomanip>\n#include <cfloat>\n#include <set>\n#include <map>\n#include <tuple>\nstruct Point {\n\tfloat x, y;\n\tfloat distance(const Point &that) const {\n\t\treturn std::sqrt((x - that.x) * (x - that.x) + (y - that.y) * (y - that.y));\n\t}\n};\n\nvoid solve() {\n\tint n;\n\tfloat hx, hy, dx, dy; std::cin >> n >> hx >> hy >> dx >> dy;\n\tstd::vector<std::vector<float>> memo(20, std::vector<float>(1 << 20, FLT_MAX));\n\twhile (n != 0) {\n\t\tauto is_end = false;\n\t\tPoint start{ hx, hy }, mao{ dx, dy };\n\t\tfor (auto &m : memo)std::fill(m.begin(), m.end(), FLT_MAX);\n\t\tstd::vector<Point> crystal(n); for (auto &c : crystal) std::cin >> c.x >> c.y;\n\t\tstd::priority_queue<std::tuple<int, int, int>, std::vector<std::tuple<int, int, int>>, std::function<bool(const std::tuple<int, int, int> &, const std::tuple<int, int, int> &)>> queue([n, &memo](const std::tuple<int, int, int> &a, const std::tuple<int, int, int> &b) {return (std::get<2>(a) == std::get<2>(b)) ? memo[std::get<0>(a)][std::get<1>(a)] > memo[std::get<0>(b)][std::get<1>(b)] : std::get<2>(a) < std::get<2>(b); });\n\t\tfor (auto i = 0; i < n && !is_end; ++i) {\n\t\t\tif (start.distance(crystal[i]) < mao.distance(crystal[i])) {\n\t\t\t\tmemo[i][1 << i] = start.distance(crystal[i]);\n\t\t\t\tqueue.push(std::make_tuple(i, 1 << i, 1));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::cout << \"NO\\n\";\n\t\t\t\tis_end = true;\n\t\t\t}\n\t\t}\n\t\tbool can = true;\n\t\twhile (!queue.empty() && !is_end) {\n\t\t\tauto current = std::get<0>(queue.top());\n\t\t\tauto flag = std::get<1>(queue.top());\n\t\t\tauto count = std::get<2>(queue.top());\n\t\t\tauto distance = memo[current][flag];\n\t\t\tqueue.pop();\n\t\t\t\tcan = true;\n\t\t\t\tfor (auto i = 0; i < n && can; ++i) {\n\t\t\t\t\tif ((flag & (1 << i)) == 0 && distance + crystal[current].distance(crystal[i]) >= mao.distance(crystal[i])) {\n\t\t\t\t\t\tcan = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (can) for (auto i = 0; i < n && !is_end; ++i) {\n\t\t\t\t\tif ((flag & (1 << i)) == 0) {\n\t\t\t\t\t\tif (memo[i][flag | (1 << i)] > distance + crystal[current].distance(crystal[i])) {\n\t\t\t\t\t\t\tif (count + 1 == n) {\n\t\t\t\t\t\t\t\tstd::cout << \"YES\\n\";\n\t\t\t\t\t\t\t\tis_end = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemo[i][flag | (1 << i)] = distance + crystal[current].distance(crystal[i]);\n\t\t\t\t\t\t\tqueue.push(std::make_tuple(i, flag | (1 << i), count + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tif (!is_end) {\n\t\t\tif (std::any_of(memo.begin(), memo.end(), [n](const std::vector<float> &v) {return v[(1 << n) - 1] != FLT_MAX; })) {\n\t\t\t\tstd::cout << \"YES\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::cout << \"NO\\n\";\n\t\t\t}\n\t\t}\n\t\tstd::cin >> n >> hx >> hy >> dx >> dy;\n\t}\n}\nint main() {\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool f = false;\nint cx[20];\nint cy[20];\ndouble dis[20];\nbool used[20];\nint n, hx, hy, dx, dy;\n\ndouble distance(int x1, int y1, int x2, int y2){\n\tdouble dx = x2 - x1;\n\tdouble dy = y2 - y1;\n\treturn sqrt(dx*dx+dy*dy);\n}\n\nvoid move(int x, int y, int n, double time){\n\tif(n == 0){\n\t\tf = true;\n\t}\n\tif(f) return;\n\tfor(int i = 0; i < n; i++){\n\t\tdouble M_dis = 100000000;\n\t\tdouble T_dis = 100000000;\n\t\tif(!used[i] && distance(cx[i], cy[i], x, y) + time < dis[i]\n\t\t\t&& (dis[i] < M_dis || distance(x, y, cx[i], cy[i]) < T_dis)){\n\t\t\tused[i] = true;\n\t\t\tmove(cx[i], cy[i], n - 1, time + distance(cx[i],cy[i], x, y));\n\t\t\tM_dis = dis[i];\n\t\t\tT_dis = distance(x, y, cx[i], cy[i]);\n\t\t\tused[i] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> n >> hx >> hy >> dx >> dy){\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tused[i] = false;\n\t\t\tdis[i] = distance(cx[i], cy[i], dx, dy);\n\t\t}\n\t\tf = false;\n\t\tmove(hx, hy, n, 0);\n\t\tif(f) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n#define pdd pair<double,double>\n#define fi first\n#define se second\nconst double inf = 1e12;\nconst double eps = 1e-9;\n\ndouble d[22][22];\nint n,hx,hy,dx,dy,i,x,y,j;\nbool flag;\n\ndouble dist(double ax,double ay,double bx,double by) {\n  return sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by));\n}\n\nbool rec(int npos,int visited,double time,int vc) {\n  //cout<<npos<<\" \"<<time<<\" \"<<vc<<\" \"<<n<<endl;\n\n  for(int k=2; k<n+2; ++k) {\n    if((1<<k) & visited) continue;\n    if(d[npos][k]+time - d[1][k] >= -eps) return false;\n  }\n  if(vc >= n) return true;\n  for(int k=2; k<n+2; ++k) {\n    if((1<<k) & visited) continue;\n    if(d[npos][k]+time - d[1][k] >= -eps) break;\n    if(rec(k, visited|(1<<k), d[npos][k]+time, vc+1)) return true;\n  }\n  return false;\n}\n\nint main() {\n  while(cin>>n>>hx>>hy>>dx>>dy, n|hx|hy|dx|dy) {\n    vector<pdd > in;\n    in.push_back(pdd(hx,hy));\n    in.push_back(pdd(dx,dy));\n    rep(i,n) {\n      cin>>x>>y;\n      in.push_back(pdd(x,y));\n    }\n\n    rep(i,22) rep(j,22) d[i][j] = inf;\n    rep(i,n+2) rep(j,n+2) {\n      if(i == j) d[i][j] = 0.0;\n      d[i][j] = dist(in[i].fi, in[i].se, in[j].fi, in[j].se);\n    }\n\n    if(rec(0,0,0.0,0)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  if ( now == n)return true;\n  rep(i,n){\n    if ( visited[i]==true)continue;\n    if ( r+adj[last][i] < adj[MAOU][i]){\n      visited[i]=true;\n      if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n  }\n\n\n  bool visited[20]={false};\n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i]) < dist(rx-mx,ry-my)){\n      visited[i]=true;\n      if ( backTrack(i,dist(mx-x[i],my-y[i]),1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(cin>>n>>mx>>my>>rx>>ry && n){\n    int x[n],y[n];\n    rep(i,n)cin>>x[i]>>y[i];\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <functional>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<double, int> R;\ntypedef pair<P, R> Q;\ntypedef pair<double, Q> K;\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\tdouble r;\n\twhile (cin >> n >> hx >> hy >> dx >> dy) {\n\t\tif (n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) {\n\t\t\tbreak;\n\t\t}\n\t\thx -= dx;\n\t\thy -= dy;\n\t\tvector<P> data;\n\t\tint x, y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\tdata.push_back(P(x, y));\n\t\t}\n\t\tpriority_queue<K, vector<K>, less<K> > q;\n\t\tq.push(K(0.0, Q(P(hx, hy), R(0.0, 0))));\n\t\tbool hantei = false;\n\t\twhile (!q.empty()) {\n\t\t\tK p = q.top();\n\t\t\tq.pop();\n\t\t\tP xy = (p.second).first;\n\t\t\tR limit = (p.second).second;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tbool hantei2 = true;\n\t\t\t\tif ((limit.second & (1<<i)) == 0) {\n\t\t\t\t\tdouble dead = limit.first+sqrt(pow(data[i].first-xy.first, 2)+pow(data[i].second-xy.second, 2));\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif ((limit.second & (1<<j)) == 0) {\n\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead) {\n\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\tint k = limit.second | (1<<i);\n\t\t\t\t\t\tif (k == (1<<n)-1) {\n\t\t\t\t\t\t\thantei = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tif ((k & (1<<j)) == 0) {\n\t\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead+sqrt(pow(data[i].first-data[j].first, 2)+pow(data[i].second-data[j].second, 2))) {\n\t\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble MIN = 0.0;\n\t\t\t\t\t\tif (pow(data[i].first, 2)+pow(data[i].second, 2) < pow(xy.first, 2)+pow(xy.second, 2)) {\n\t\t\t\t\t\t\tMIN = sqrt(pow(data[i].first, 2)+pow(data[i].second, 2));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tMIN = -sqrt(pow(data[i].first, 2)+pow(data[i].second, 2));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\t\tq.push(K(MIN, Q(data[i], R(dead, k))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hantei) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble  cost[20][20];\nconst double INF = 10000000;\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if ( visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    visited[i]=true;\n    if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n    if ( dist(mx-x[i],my-y[i])+eps>dist(rx-x[i],ry-y[i]))return false;\n  }\n  \n  bool visited[20]={false};\n  rep(i,n){\n    visited[i]=true;\n    if ( backTrack(i,dist(mx-x[i],my-y[i]),1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(cin>>n>>mx>>my>>rx>>ry && n){\n    int x[n],y[n];\n    rep(i,n)cin>>x[i]>>y[i];\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\nconst int INF=100000000;\n\n\nint n;\nint hx,hy;\nint dx,dy;\nint cx[21],cy[21];\nbool flag[21];\n\ndouble dist(int _x0,int _y0,int _x1,int _y1) {\n\tdouble d = (_x0-_x1)*(_x0-_x1) + (_y0-_y1)*(_y0-_y1);\n\treturn sqrt(d);\n}\n\nint pow2(int a) {\n\treturn a*a;\n}\n\n//クリスタルの位置と何日目からとることができるか\nbool check(int x,int y,int d) {\n\treturn (pow2(dx-x)+pow2(dy-y)) > pow2(d);\n}\n\n//現在位置,何日目\nbool dfs(int x,int y,int d,int cnt) {\n\t//printf(\"[debug] %d,%d,%d,%d\\n\",x,y,d,cnt);\n\tif(cnt==n) return true;\n\trep(i,n) {\n\t\tif(!flag[i]) {\n\t\t\tflag[i]=true;\n\t\t\td += (int)dist(x,y,cx[i],cy[i])+1;\n\t\t\tif(check(cx[i],cy[i],d)) {\n\t\t\t\treturn dfs(cx[i],cy[i],d,cnt+1);\n\t\t\t}\n\t\t\tflag[i]=false;\n\t\t}\n\t}\n\treturn false;\n\n}\n\n\nvoid solve() {\n\trep(i,n) cin>>cx[i]>>cy[i];\n\trep(i,21) flag[i]=false;\n\n\tif(dfs(hx,hy,0,0)) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n}\n\nint main() {\n\twhile (cin>>n>>hx>>hy>>dx>>dy)\n\t{\n\t\tif(n+hx+hy+dx+dy==0) return 0;\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX], ok;\n\nvoid rec(int S, int v, double total_dist){\n  if(ok) return;\n\n  if(S == (1 << N) - 1){\n    ok = true;\n    return;\n  }\n  for(int u = 0 ; u < N ; u++){\n    Segment s = Segment(crystal[v], crystal[u]);\n    if(s.distanceSP(d) < total_dist) return;\n    if(total_dist+dist(crystal[v],crystal[u])+EPS > dist(d, crystal[u])){\n      return;\n    }\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(ok) return;\n    if(!(S >> u & 1)){\n      rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]));\n    }\n  }\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n\n  ok = false;\n  for(int i = 0 ; i < N ; i++){\n    memset(used, false, sizeof(used));\n    rec(0, i, dist(h, crystal[i]));\n    if(ok){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX], ok;\nbool dp[1<<MAX][MAX];\n\nbool rec(int S, int v, double total_dist){\n  if(ok) return true;\n  if(total_dist >= dist(d, crystal[v])){\n    return false;\n  }\n\n  if(dp[S][v]) return true;\n\n  if(S == (1 << N) - 1){\n    return dp[S][v] = ok = true;\n  }\n  bool res = false;\n  for(int u = 0 ; u < N ; u++){\n    Segment s = Segment(crystal[v], crystal[u]);\n    // if(s.distanceSP(d) < total_dist) return false;\n    if(total_dist+dist(crystal[v],crystal[u]) >= dist(d, crystal[v])){\n      return false;\n    }\n    if(!(S >> u & 1)){\n      return rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]));\n    }\n  }\n  return dp[S][v] = false;\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n\n  for(int i = 0 ; i < N ; i++){\n    ok = false;\n    memset(dp, false, sizeof(dp));\n    memset(used, false, sizeof(used));\n    if(rec(0, i, dist(h, crystal[i]))){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef complex<double> P;\n\nint main() {\n  int n,hx,hy,dx,dy;\n  while(cin>>n>>hx>>hy>>dx>>dy,n||hx||hy||dx||dy) {\n    P syoki = P(hx,hy);\n    P maou = P(dx,dy);\n    P houseki[n];\n    REP(i,n) {\n      double x,y;\n      cin >> x >> y;\n      houseki[i] = P(x,y);\n    }\n    double dp[1<<n][n];\n    REP(i,1<<n) REP(j,n+1)dp[i][j] = INF;\n\n    REP(i,n) {\n      if (abs(houseki[i]-syoki) < abs(houseki[i]-maou))\n        dp[1<<i][i] = abs(houseki[i]-syoki);\n    }\n    REP(S, 1<<n) {\n      REP(i,n) {\n        // cout << bitset<2>(S) << endl;\n        // cout << i << \" \" << dp[S][i] << endl;\n        REP(j,n) {\n          if (S>>j&1) continue;\n          if (dp[S][i] + abs(houseki[i]-houseki[j]) < abs(maou-houseki[j]))\n            dp[S|1<<j][j] = min(dp[S|1<<j][j], dp[S][i] + abs(houseki[i]-houseki[j]));\n        }\n      }\n    }\n    double res = *min_element(dp[(1<<n)-1], dp[(1<<n)-1]);\n    if (res != INF)\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\"<< endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nstruct Point {\n\tint x, y;\n};\n\nconst double EPS = 1E-9;\nPoint h, d, p[20];\nint n;\nbool flag[20];\n\nbool dfs(double t, int s) \n{\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tif (!flag[i]) break;\n\t}\n\tif (i == n) return true;\n\t\n\tPoint pp = (s == -1) ? h : p[s];\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tif (hypot(d.x - p[i].x, d.y - p[i].y) - hypot(pp.x - p[i].x, pp.y - p[i].y) < EPS) return false;\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tflag[i] = true;\n\t\tif (dfs(hypot(pp.x - p[i].x, pp.y - p[i].y), i)) return true;\n\t\tflag[i] = false;\n\t}\n\t\n\treturn false;\n}\n\nint main()\n{\t\n\twhile (cin >> n >> h.x >> h.y >> d.x >> d.y, n | h.x | h.y | d.x | d.y) {\n\t\tmemset(flag, false, sizeof(flag));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p[i].x >> p[i].y;\n\t\t}\n\t\tcout << (dfs(0, -1) ? \"YES\" : \"NO\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n  /* \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n  */\n}; \n/*\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector &s, Vector &t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n*/\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool ok;\n\nvoid rec(int S, int v, double total_dist){\n  if(ok) return;\n\n  if(S == (1 << N) - 1){\n    ok = true;\n    return;\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1)){\n      /*\n      Segment s = Segment(crystal[v], crystal[u]);\n      if(s.distanceSP(d) < total_dist) return;\n      */\n      if(total_dist+dist(crystal[v],crystal[u]) >= dist(d, crystal[u])){\n\treturn;\n      }\n    }\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1) && !ok){\n      rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]));\n    }\n  }\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    ok = false;\n    rec(0, 0, dist(h, crystal[0]));\n    if(ok){\n      return true;\n    }\n  }  \n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint n;\nint hx, hy, dx, dy, cx[21], cy[21];\n\ndouble dist(double ax, double ay, double bx, double by){\n  return sqrt((ax-bx)*(ax-bx) + (ay-by)*(ay-by));\n}\n\nint dfs(int c, double t, int x, int y, int *used){\n  //  printf(\"%d %lf %lf %lf\\n\", c, t, x, y);\n  if(c == n) return 1;\n\n  rep(i, n){\n    if(used[i]) continue;\n    double nt = dist(x, y, cx[i], cy[i]);\n    //    printf(\"x:%lf y:%lf nt:%lf\\n\", x, y, nt);\n    //    printf(\"dx;%lf dy:%lf cx:%lf cy:%lf\\n\", dx, dy, cx[i], cy[i]);\n    //    printf(\"%lf %lf\\n\", t + nt + EPS, dist(dx, dy, cx[i], cy[i]));\n    if(t + nt + EPS > dist(dx, dy, cx[i], cy[i])) return 0;\n    used[i] = 1;\n    if(dfs(c+1, t + nt, cx[i], cy[i], used)) return 1;\n    used[i] = 0;\n  }\n  return 0;\n}\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy) && n+hx+hy+dx+dy){\n    rep(i, n)\n      scanf(\"%d%d\", cx+i, cy+i);;\n\n    int used[21];\n    memset(used, 0, sizeof(used));\n    if(dfs(0, 0, hx, hy, used)) puts(\"YES\");\n    else puts(\"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\nint abs(int n){\n    if(n < 0)\n\t\tn = -1 * n;\n    return n;\n}\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 20], dp[1 << 20];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) \n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF; \n\t\tfor(i = 0;i < n;i++) \n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]); \n\t\tfor(i = 0;i < n;i++){ \n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){ \n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]); \n\t\t\t\tloc[1 << i] = i; \n\t\t\t} \n\t\t\telse  \n\t\t\t\tbreak; \n\t\t}  \n\t\tif(i != n){  \n\t\t\tprintf(\"NO\\n\"); \n\t\t\tcontinue;  \n\t\t}  \n\t\tfor(i = 0;i < 1 << n;i++){ \n\t\t\tif(dp[i] != INF){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif((~i & (1 << j)) && (dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j])) && (dp[i ^ (1 << j)] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i])){ \n\t\t\t\t\t\tdp[i ^ (1 << j)] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];  \n\t\t\t\t\t\tloc[i ^ (1 << j)] = j; \n\t\t\t\t\t}  \n\t\t\t\t}\n\t\t\t}  \n\t\t}   \n\t\tif(dp[(1 << n) - 1] != INF) \n\t\t\tprintf(\"YES\\n\");  \n\t\telse  \n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define INF (1<<30)\n#define EPS (double)(1e-5)\nusing namespace std;\nint n,hx,hy,dx,dy;\nint cx[22],cy[22];\n\ndouble L(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nbool solve(int m,int bit,double l){\n  if(bit == (1<<n)-1) return true;\n  for(int i = 1; i < n; i++){\n    if(bit&(1<<i))continue;\n    if( L(cx[m]-cx[i],cy[m]-cy[i]) + l + EPS > L(cx[i]-dx,cy[i]-dy)) continue;\n    if(solve(i,bit|(1<<i),l+L(cx[m]-cx[i],cy[m]-cy[i]))) return true;\n  }\n  return false;\n}\n\nint main(void){\n  while(cin >> n >> cx[0] >> cy[0] >> dx >> dy && n){\n    n++;\n    for(int i = 1; i < n; i++){\n      cin >> cx[i] >> cy[i];\n    }\n    if( solve(0,1,0) ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 20;\n\n/* typedef */\n\ntemplate <typename T>\nstruct Pt {\n  T x, y;\n\n  Pt() {}\n  Pt(T _x, T _y) : x(_x), y(_y) {}\n  Pt(const Pt& pt) : x(pt.x), y(pt.y) {}\n\n  Pt operator+(const Pt pt) const { return Pt(x + pt.x, y + pt.y); }\n  Pt operator-() const { return Pt(-x, -y); }\n  Pt operator-(const Pt pt) const { return Pt(x - pt.x, y - pt.y); }\n  Pt operator*(T t) const { return Pt(x * t, y * t); }\n  Pt operator/(T t) const { return Pt(x / t, y / t); }\n  T dot(Pt v) { return x * v.x + y * v.y; }\n  T cross(Pt v) { return x * v.y - y * v.x; }\n  Pt mid(const Pt pt) { return Pt((x + pt.x) / 2, (y + pt.y) / 2); }\n  T d2() { return x * x + y * y; }\n  double d() { return sqrt(d2()); }\n\n  Pt rot(double th) {\n    double c = cos(th), s = sin(th);\n    return Pt(c * x - s * y, s * x + c * y);\n  }\n\n  bool operator<(const Pt& pt) const {\n    return x < pt.x || (x == pt.x && y < pt.y);\n  }\n  \n  void print(string format) {\n    printf((\"(\" + format + \", \" + format + \")\\n\").c_str(), x, y);\n  }\n};\n\ntypedef Pt<double> pt;\n\n/* global variables */\n\nint n;\npt hpt, dpt;\npt pts[MAX_N + 1];\nbool used[MAX_N + 1];\ndouble ddists[MAX_N + 1], pdists[MAX_N + 1][MAX_N + 1];\n\n/* subroutines */\n\nbool rec(int k, int i, double t) {\n  //printf(\"rec(%d, %d, %f\\n\", k, i, t);\n  if (k == n) return true;\n\n  for (int j = 1; j <= n; j++)\n    if (! used[j]) {\n      double t0 = t + pdists[i][j];\n      if (t0 < ddists[j]) {\n\tused[j] = true;\n\tif (rec(k + 1, j, t0)) return true;\n\tused[j] = false;\n      }\n    }\n\n  return false;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n >> hpt.x >> hpt.y >> dpt.x >> dpt.y;\n    if (n == 0) break;\n\n    pts[0] = hpt;\n    for (int i = 1; i <= n; i++) cin >> pts[i].x >> pts[i].y;\n\n    for (int i = 0; i <= n; i++) {\n      ddists[i] = (pts[i] - dpt).d();\n      pdists[i][i] = 0.0;\n      for (int j = i + 1; j <= n; j++)\n\tpdists[i][j] = pdists[j][i] = (pts[i] - pts[j]).d();\n    }\n\n    memset(used, false, sizeof(used));\n    used[0] = true;\n    \n    int tf = rec(0, 0, 0.0);\n    cout << (tf ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <map>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef complex<double> P;\nnamespace std {\n    bool operator<(const P& a, const P& b){\n        if(a.real() != b.real()) return a.real() < b.real();\n        return a.imag() < b.imag();\n    }\n}\n\nstruct L {\n    L(const P&a, const P&b) : p({a,b}) {}\n    P p[2];\n    P & operator[](int i){\n        return p[i];\n    }\n    const P & operator[](int i) const {\n        return p[i];\n    }\n};\n\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ninline int ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;\n    if (cross(b, c) < 0)   return -1;\n    if (dot(b, c) < 0)     return +2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nint all,n;\nvector<P> v;\n\nvoid pr(int m){\n    for(int i=n-1; i>=0; i--){\n        cout << ((m>>i)&1);\n    }\n    cout << endl;\n}\n\ndouble dis[30][30]={};\n\nint c;\nbool dfs(int at, int vis, double t){\n    c++;\n    vis |= (1<<at);\n    //pr(vis);\n    if(vis == all){\n        return true;\n    }\n    rep(next,n){\n        if(vis& (1<<next)) continue;\n        P proj = projection(L(v[at], v[next]), v[n]);\n        bool out = abs(ccw(v[at], v[next], proj)) == 2;\n        if(t + dis[at][next] < dis[next][n] &&\n           (out || t + abs(proj - v[at]) < abs(proj - v[n]))){\n            if(dfs(next, vis, t + dis[next][at])){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main(){\n    while(cin>>n, n){\n        n++;\n        c = 0;\n        all = (1<<n)-1;\n        double a1,a2,a3,a4; cin>>a1>>a2>>a3>>a4;\n        v.resize(n+1);\n        v[0] = P(a1,a2);\n        v[n] = P(a3,a4);\n        rep(i,n-1){\n            double x,y; cin>>x>>y;\n            v[i+1] = P(x,y);\n        }\n        rep(i,n+1)rep(j,i){\n            dis[i][j] = dis[j][i] = abs(v[i] - v[j]);\n        }\n        // sort(v.begin()+1, v.end(), [=](const P& a, const P& b){\n        //         return norm(a-v[n]) < norm(b-v[n]);\n        //     });\n        cout << (dfs(0,0,0) ? \"YES\" : \"NO\") << endl;\n        // cout << c << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\nconst int INF=100000000;\n\n\nint n;\nint hx,hy;\nint dx,dy;\nint cx[21],cy[21];\n\n\ndouble dist(int _x0,int _y0,int _x1,int _y1) {\n\tdouble d = (_x0-_x1)*(_x0-_x1) + (_y0-_y1)*(_y0-_y1);\n\treturn sqrt(d);\n}\n\nint pow2(int a) {\n\treturn a*a;\n}\n\nbool check(int x,int y,int d,int ind) {\n    return dist(x,y,cx[ind],cy[ind]) < (dist(dx,dy,cx[ind],cy[ind]) - d);\n}\n\nbool dfs(int x,int y,int d,int S) {\n    //printf(\"[debug] %d,%d,%d,%d\\n\",x,y,d,S);\n\tif(S==(1<<n)-1) return true;\n\trep(i,n) {\n\t\tif(!((S>>i)&1)) {\n\t\t\t//d += (int)dist(x,y,cx[i],cy[i]) + 1;\n\t\t\tif(check(x,y,d,i)) {\n\t\t\t\treturn dfs(cx[i],cy[i],d+ceil(dist(x,y,cx[i],cy[i])),S|(1<<i));\n\t\t\t}\n            else {\n                return false;\n            }\n\t\t}\n\t}\n\n\treturn false;\n\n}\n\n\nvoid solve() {\n\trep(i,n) cin>>cx[i]>>cy[i];\n\tif(dfs(hx,hy,0,0)) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\n}\n\nint main() {\n\twhile (cin>>n>>hx>>hy>>dx>>dy)\n\t{\n\t\tif(n+hx+hy+dx+dy==0) return 0;\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#define LT(x,y) ((x)-(y)<EPS)\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<double> vd;\n\ndouble dp[1<<20][20];\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile(cin >> n >> hx >> hy >> dx >> dy, n) {\n\t\tP h(hx, hy), d(dx, dy);\n\t\tvector<P> c(n);\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tc[i] = P(x, y);\n\t\t}\n\n\t\tREP(i, 1<<n) {\n\t\t\tREP(j, n) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tREP(i, n) {\n\t\t\tif(i == 0) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tdp[1<<j][j] = abs(h-c[j]);\n\t\t\t\t\tif(LT(abs(d-c[j]), dp[1<<j][j])) {\n\t\t\t\t\t\tdp[1<<j][j] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tif(!(i&(1<<j))) {\n\t\t\t\t\t\tREP(k, n) {\n\t\t\t\t\t\t\tdp[i|(1<<j)][j] = min(dp[i|(1<<j)][j], dp[i][k]+abs(c[k]-c[j]));\n\t\t\t\t\t\t\tif(LT(abs(d-c[j]), dp[i|(1<<j)][j])) {\n\t\t\t\t\t\t\t\tdp[i|(1<<j)][j] = INF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok = false;\n\t\tREP(i, n) {\n\t\t\tif(dp[(1<<n)-1][i] != INF) {\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcout << (ok ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> x, y;\n\ndouble dist(int a, int b){\n    return sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));\n}\n\nbool solve(){\n    for(int i=0;i<n;i++){\n        if(dist(n, i) >= dist(n+1, i)) return false;\n    }\n\n    for(int i=0;i<n;i++){\n        if(dist(n, 0) + dist(0, i) >= dist(n+1, i)) return false;\n    }\n    return true;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        x.assign(n+2, 0);\n        y.assign(n+2, 0);\n        cin >> x[n] >> y[n] >> x[n+1] >> y[n+1];\n        for(int i=0;i<n;i++){\n            cin >> x[i] >> y[i];\n        }\n\n        if(solve()){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nfloat dp[1<<20][20],inf=1e9,eps=1e-9;\nint n,hx,hy,mx,my,cx[20],cy[20];\nbool isok(float sx,float sy,float tx,float ty,float t0){\n\tfloat d=sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy)),dx=(tx-sx)/d,dy=(ty-sy)/d,x=sx-mx,y=sy-my;\n\tfloat a=dx*dx+dy*dy-1,b=2*(x*dx+y*dy-t0),c=x*x+y*y-t0*t0;\n\tif(abs(b)<eps){\n\t\tif(abs(c)>eps) return false;\n\t\treturn true;\n\t}\n\treturn !(0<-c/b+eps && -c/b<d+eps);\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> hx >> hy >> mx >> my;\n\t\tif(n==0) break;\n\t\trep(i,n) cin >> cx[i] >> cy[i];\n\t\trep(i,1<<n) rep(j,n) dp[i][j]=inf;\n\t\trep(i,1<<n){\n\t\t\tif(i==0){\n\t\t\t\trep(k,n){\n\t\t\t\t\tfloat sx=hx,sy=hy,tx=cx[k],ty=cy[k],t0=0;\n\t\t\t\t\tfloat d=sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy));\n\t\t\t\t\tif(isok(sx,sy,tx,ty,t0)) dp[i+(1<<k)][k]=d;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(j,n){\n\t\t\t\tif((i>>j)&1==0) continue;\n\t\t\t\trep(k,n){\n\t\t\t\t\tif((i>>k)&1==1 || k==j) continue;\n\t\t\t\t\tfloat sx=cx[j],sy=cy[j],tx=cx[k],ty=cy[k],t0=dp[i][j];\n\t\t\t\t\tfloat d=sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy));\n\t\t\t\t\tif(isok(sx,sy,tx,ty,t0)) dp[i+(1<<k)][k]=min(dp[i+(1<<k)][k],dp[i][j]+d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\trep(j,n) if(dp[(1<<n)-1][j]!=inf) ok=true;\n\t\tcout << (ok ? \"YES\\n\" : \"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define MAX 21\n#define INF 10000\n#define EPS 1.0e-10\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point;\ndouble dist(const point &a, const point &b){return std::abs(b-a);}\nbool vis[MAX];\nbool bt(const vector<point> &v, double walk, const point &h, const point &d){\n\tbool bCont = false;\n\n\tfor(unsigned int i = 0; i < v.size(); ++i){/*cout<<vis[i]<<' ';*/if( !vis[i] )bCont=true;}if( !bCont )return true;\n\t//cout << endl;\n\n\tfor(unsigned int i = 0; i < v.size(); ++i){\n\t\tif( !vis[ i ] ){\n\t\t\tdouble t = walk + dist(h,v[i]);\n\t\t\tif( t < dist(d, v[i]) ){\n\t\t\t\tvis[ i ] = true;\n\t\t\t\tif( bt( v, t, h, d ) )\n\t\t\t\t\treturn true;\n\t\t\t\tvis[ i ] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tint n,hx,hy,dx,dy;\n\t\tpoint hero, daemon;\n\t\tvector< point > vp;\n\n\t\tscanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy);\n\t\tif(!(n||hx||hy||dx||dy))break;\n\t\t\n\t\thero = complex<elem>(hx,hy);\n\t\tdaemon = complex<elem>(dx,dy);\n\t\t\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint cx,cy;scanf(\"%d%d\", &cx, &cy);point p(cx,cy);\n\t\t\tif(cx==hx&&cy==hy)continue;\n\t\t\tvp.push_back( p );\n\t\t\tvis[i]=false;\n\t\t}\n\t\t\n\t\tif( bt( vp, 0.0, hero, daemon ) )\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\nint abs(int n){\n    if(n < 0)\n\t\tn = -1 * n;\n    return n;\n}\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 10], dp[1 << 10];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) \n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF; \n\t\tfor(i = 0;i < n;i++) \n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]); \n\t\tfor(i = 0;i < n;i++){ \n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){ \n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]); \n\t\t\t\tloc[1 << i] = i; \n\t\t\t} \n\t\t\telse  \n\t\t\t\tbreak; \n\t\t}  \n\t\tif(i != n){  \n\t\t\tprintf(\"NO\\n\"); \n\t\t\tcontinue;  \n\t\t}  \n\t\tfor(i = 0;i < 1 << n;i++){ \n\t\t\tif(dp[i] != INF){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & 1 << j && dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j]) && dp[i ^ (1 << j)] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i]){ \n\t\t\t\t\t\tdp[i ^ (1 << j)] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];  \n\t\t\t\t\t\tloc[i ^ (1 << j)] = j; \n\t\t\t\t\t}  \n\t\t\t\t}\n\t\t\t}  \n\t\t}   \n\t\tif(dp[(1 << n) - 1] != INF) \n\t\t\tprintf(\"YES\\n\");  \n\t\telse  \n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nvi x,y;\nint n,a,b,c,d;\nbool f(int q,int nx,int ny,double t){\n\tif(q==(1<<n)-1)return 1;\n\trep(i,n)if((q&1<<i)==0&&(hypot(nx-x[i],ny-y[i])+EPS>t+hypot(c-x[i],d-y[i])))return 0;\n\trep(i,n)if((q&1<<i)==0&&f(q^1<<i,x[i],y[i],t+hypot(nx-x[i],ny-y[i])))return 1;\n\treturn 0;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tcin>>a>>b>>c>>d;\n\t\ty=x=vi(n);\n\t\trep(i,n)cin>>x[i]>>y[i];\n\t\tcout<<(f(0,a,b,0)?\"YES\":\"NO\")<<endl;\n\t}\n\tcin>>n>>n>>n>>n;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n#define pdd pair<double,double>\n#define fi first\n#define se second\nconst double inf = 1e12;\n\ndouble d[22][22];\nint n,hx,hy,dx,dy,i,x,y,j;\n\ndouble dist(double ax,double ay,double bx,double by) {\n  return sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by));\n}\n\nbool rec(int npos,int visited,double time,int vc) {\n  bool ans = false;\n  if(vc >= n-2) return true;\n  REP(i,2,n+2) {\n    if(visited>>i & 1) continue;\n    if(npos == i) continue;\n    if(time+d[npos][i] > d[1][i]) {\n      continue;\n    }\n    ans |= rec(i,(visited|(1<<i)),time+d[npos][i],vc+1);\n  }\n  return ans;\n}\n\nint main() {\n  while(cin>>n>>hx>>hy>>dx>>dy, n|hx|hy|dx|dy) {\n    vector<pdd > in;\n    in.push_back(pdd(hx,hy));\n    in.push_back(pdd(dx,dy));\n    rep(i,n) {\n      cin>>x>>y;\n      in.push_back(pdd(x,y));\n    }\n\n    n += 2;\n    rep(i,22) rep(j,22) d[i][j] = inf;\n    rep(i,n) rep(j,n) {\n      if(i == j) d[i][j] = 0.0;\n      d[i][j] = dist(in[i].fi, in[i].se, in[j].fi, in[j].se);\n    }\n\n    if(rec(0,0,0,0)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str(); }\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX / 10;\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\n#define LT(x,y) ((x)-(y)<=-EPS)\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n) {\n\t\tP h(hx, hy), d(dx, dy);\n\t\t\n\t\tvp crystal(n);\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tcrystal[i] = P(x, y);\n\t\t}\n\n\t\tvd hd(n), dd(n);\n\t\tREP(i, n) {\n\t\t\thd[i] = abs(h - crystal[i]);\n\t\t\tdd[i] = abs(d - crystal[i]);\n\t\t}\n\n\t\tvvd dist(n, vd(n));\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tdist[i][j] = abs(crystal[i] - crystal[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap<int, double> dp;\n\t\tstack<pii> S;\n\t\tREP(i, n) {\n\t\t\tif (LT(hd[i], dd[i])) {\n\t\t\t\tS.push(make_pair(i, (1 << i)));\n\t\t\t\tdp[1 << i] = hd[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool success = false;\n\t\twhile (!S.empty()) {\n\t\t\tpii p = S.top();\n\t\t\tS.pop();\n\n\t\t\tif (p.second == (1 << n) - 1) {\n\t\t\t\tsuccess = true;\n\t\t\t}\n\n\t\t\tREP(i, n) {\n\t\t\t\tint ns = p.second | (1 << i);\n\t\t\t\tif (ns != p.second) {\n\t\t\t\t\tdouble nd = dp[p.second] + dist[p.first][i];\n\t\t\t\t\tif (LT(nd, dd[i])) {\n\t\t\t\t\t\tS.push(make_pair(i, ns));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (success ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\nstatic const double EPS = 1e-8;\n\nint n,hx,hy,dx,dy;\nint x[20],y[20];\nbool flag;\n\nvoid dfs(int unvisit, int cx, int cy, double t){\n   if(flag)return;\n  \n   if(unvisit==0)flag = true;\n   \n   else{\n      //枝刈り\n      rep(i,n){\n\t if(!((unvisit >> i) & 1))continue;\n\t if(hypot(dx-x[i], dy-y[i]) < t + hypot(cx-x[i], cy-y[i]) + EPS)return;\n      }\n\n      rep(i,n){\n\t if(!((unvisit >> i) & 1))continue;\n\t dfs((unvisit & ~(1 << i)), x[i], y[i], t + hypot(cx-x[i], cy-y[i]));\n      }\n   }\n}\n\nstring solve(){\n   flag = false;\n   dfs((1<<n)-1, hx, hy, 0);\n   return (flag) ? \"YES\" : \"NO\";\n}\n\nint main(){\n   while(cin >> n >> hx >> hy >> dx >> dy){\n      if((n|hx|hy|dx|dy)==0)break;\n   \n      rep(i,n){\n\t cin >> x[i] >> y[i];\n      }\n      \n      cout << solve() << endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<double, double> P;\nint N;\nP h, d, cs[20];\n\n#define SQ(x) ((x)*(x))\n\ninline bool getDist(P a, P b) {\n  return sqrt(SQ(a.fi-b.fi) + SQ(a.se-b.se));\n}\n\ndouble dist[22][22];\n\nmap<int, double> mp;\n\nbool dfs(int S, int now, double cost) {\n  \n  if(S = (1<<N)-1) {\n    return true;\n  }\n  \n  mp[S] = cost;\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(dist[N+1][i] <= cost + dist[now][i]) return false;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(mp.count(S+(1<<i)) && mp[S+(1<<i)] <= cost+dist[now][i]) continue;\n    if(dfs(S+(1<<i), i, cost+dist[now][i])) return true;\n  }\n  \n  return false;\n}\n\nbool solve() {\n  \n  mp.clear();\n  \n  for(int i=0; i<N; i++) {\n    for(int j=i+1; j<N; j++) {\n      dist[i][j] = dist[j][i] = getDist(cs[i], cs[j]);\n    }\n    dist[i][N] = dist[N][i] = getDist(cs[i], h);\n    dist[i][N+1] = dist[N+1][i] = getDist(cs[i], d);\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(dist[i][N+1] <= dist[i][N]) continue;\n    if(dfs(1<<i, i, dist[N][i])) return true;\n  }\n  return false;\n}\n\nint main() {\n  \n  while(cin >> N >> h.fi >> h.se >> d.fi >> d.se && (N)) {\n    for(int i=0; i<N; i++) {\n      cin >> cs[i].fi >> cs[i].se;\n    }\n    \n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-9;\n\ntypedef pair<xy_t, bool> dat;\n\nnamespace std{\n\tbool operator < (const xy_t &a, const xy_t &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nint n, hx, hy, dx, dy;\nxy_t points[21];\ndouble dis[1 << 21];\nmap<P, bool> bad;\n\nbool dfs(double t, int v, int st){\n\tif(st == (1 << (n + 1)) - 1) return true;\n\tif(bad[P(v, st)]) return false;\n\n\tbool res = false;\n\tfor(int i = 1; i < n + 1; i++){\n\t\tif(!(st & (1 << i))){\n\t\t\tdouble nt = t + abs(points[i] - points[v]);\n\t\t\tif(nt < abs(points[i] - xy_t(dx, dy)) && nt < dis[st | (1 << i)]) res |= dfs(nt, i, st | (1 << i));\n\t\t}\n\t\tif(res) return true;\n\t}\n\tbad[P(v, st)] = true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> n >> hx >> hy >> dx >> dy && (n || hx || hy || dx || dy)){\n\t\tbad.clear();\n\t\tpoints[0] = xy_t(hx, hy);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints[i] = xy_t(x, y);\n\t\t}\n\t\tfor(int i = 1; i < (1 <<( n + 1)); i++){\n\t\t\tdouble d = 1e10;\n\t\t\tfor(int j = 0; j < n + 1; j++){\n\t\t\t\tif(!(i & (1 << j))) d = min(d, abs(points[j] - xy_t(dx, dy)));\n\t\t\t}\n\t\t\tdis[i] = d;\n\t\t}\n\t\tif(dfs(0.0, 0, 1)) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nstruct pos{\n\tint x;\n\tint y;\n};\nstruct rel{\n\tint to;\n\tint dis;\n};\nint dist(int x, int y){ return x*x + y*y; }\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy){\n\t\tvector<pos> p;\n\t\tREP(k, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp.push_back({ x, y });\n\t\t}\n\t\tvector<vector<pos>> r(n + 1, vector<pos>(n + 1));\n\t\tvector<pos> dr(n);\n\t\tREP(i, n + 1){\n\t\t\tif (i != n)\n\t\t\t\tdr[i].x = dx - p[i].x;\n\t\t\tdr[i].y = dy - p[i].y;\n\n\t\t\tfor (int j = 0; j < n + 1; j++){\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (i != n  && j != n){\n\t\t\t\t\tr[i][j].x = (p[i].x - p[j].x);\n\t\t\t\t\tr[i][j].y = (p[i].y - p[j].y);\n\t\t\t\t}\n\t\t\t\telse if (i == n){\n\t\t\t\t\tr[i][j].x = (hx - p[j].x);\n\t\t\t\t\tr[i][j].y = (hy - p[j].y);\n\t\t\t\t}\n\t\t\t\telse if (j == n){\n\t\t\t\t\tr[i][j].x = (p[i].x - hx);\n\t\t\t\t\tr[i][j].y = (p[i].y - hy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool b[21] = { false };\n\t\tREP(i, n)b[i] = true;\n\t\tint b_n = n;\n\t\tbool flag = false;\n\t\tfunction<bool(int dis, int from)> f = [&](int dis, int from){\n\t\t\tif (flag)return true;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (b[i] && (dis + dist(dr[i].x, dr[i].y)) >= dist(dr[i].x, dr[i].y))return false;\n\t\t\t}\n\n\t\t\tif (b_n != 0){\n\t\t\t\tfor (int i = 0; i < n && !flag; i++){\n\t\t\t\t\tif (b[i] && (dis + dist(dr[i].x, dr[i].y)) < dist(dr[i].x, dr[i].y)){\n\t\t\t\t\t\tb[i] = false;\n\t\t\t\t\t\tb_n--;\n\t\t\t\t\t\tf(dis + dist(dr[i].x, dr[i].y), i);\n\t\t\t\t\t\tb[i] = true;\n\t\t\t\t\t\tb_n++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tflag = true;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn flag;\n\t\t};\n\t\tf(0, n);\n\t\tcout << (flag ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ndouble lim[1<<20],inf=1e9,eps=1e-9,limit[21][21];\nint n,hx,hy,mx,my,cx[21],cy[21];\nvoid calc(){\n\trep(i,n+1) rep(j,n+1){\n\t\tif(i==j) limit[i][j]=0;\n\t\tdouble sx=cx[i],sy=cy[i],tx=cx[j],ty=cy[j],d=sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy)),dx=(tx-sx)/d,dy=(ty-sy)/d,x=sx-mx,y=sy-my;\n\t\tdouble b=2*d,c=-(x*x+y*y+2*d*(x*dx+y*dy));\n\t\tlimit[i][j]=(-b+sqrt(b*b-4*c))/2;\n\t}\n}\nbool dfs(int bit,int v,double t){\n\tif(bit==(1<<n)-1) return true;\n\trep(j,n) if( ((bit>>j)&1)==0 && t+eps>lim[j]) return false;\n\trep(i,n){\n\t\tif((bit>>i)&1) continue;\n\t\tif(t+eps>limit[v][i]) continue;\n\t\tif(dfs(bit+(1<<i),i,t+sqrt((cx[i]-cx[v])*(cx[i]-cx[v])+(cy[i]-cy[v])*(cy[i]-cy[v])))) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> cx[n] >> cy[n] >> mx >> my;\n\t\tif(n==0) break;\n\t\trep(i,n){\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tlim[i]=sqrt((cx[i]-mx)*(cx[i]-mx)+(cy[i]-my)*(cy[i]-my));\n\t\t}\n\t\tcalc();\n\t\tcout << (dfs(0,n,0) ? \"YES\\n\" : \"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cfloat>\n#include <cmath>\n#include <vector>\n#include <map>\n \nusing namespace std;\n \n#define fi first\n#define se second\ntypedef pair<double,double> P;\n \n#define MAX (21)\n#define INF (DBL_MAX/4)\n \ndouble G[MAX][MAX];\n \nint n;\nvector<P> crys;\nP h, d;\n \ndouble dist(P p1, P p2){\n  return sqrt(pow(p1.fi-p2.fi, 2.) + pow(p1.se-p2.se, 2.));\n}\n \nvoid makeEdge() {\n  for(int i=0; i<n; i++) {\n    G[i][i] = 0;\n    for(int j=i+1; j<n; j++) {\n      G[i][j] = G[j][i] = dist(crys[i], crys[j]);\n    }\n  }\n}\n \n\nvoid printbit(int x){\n  for(int i=0;i<n;i++){\n    cout<<((x>>i)&1);\n\n  }\n  cout<<endl;\n}\n\n \ntypedef unsigned long long ull;\nmap<ull, double> dp;\n\ndouble dfs(int S, int idx, double cost) {\n  \n  if(S==(1<<n)-1) {\n    return dp[S] = cost;\n  }\n  \n  dp[S] = cost;\n  \n  bool ok = true;\n  for(int i=0; i<n; i++) {\n    ok = ok && cost + G[idx][i] < dist(crys[i], d);\n  }\n  if(!ok) return dp[S] = INF;\n  \n  for(int i=0; i<n; i++){\n    if((S>>i)&1) continue;\n    double ncost = cost + G[idx][i];\n    double nS = S|(1<<i);\n    if(ncost >= dist(crys[i], d)) return dp[S] = INF;\n    else {\n      if(dp.count(nS) && dp[nS] < ncost) continue;\n      dp[nS] = INF;\n      dp[nS] = min(dp[nS], dfs(nS, i, ncost));\n      if(dp[nS]==INF) return INF;\n    }\n  }\n  \n  return dp[S];\n}\n \nbool solve() {\n   \n  makeEdge();\n  \n  dp.clear();\n  dp[0] = INF;\n  for(int i=0; i<n; i++) {\n    if(dist(h, crys[i]) >= dist(crys[i], d)) continue;\n    dp[0] = min(dfs(1<<i, i, dist(h, crys[i])), dp[0]);\n  }\n  if(!dp.count((1<<n)-1)) return false;\n  if(dp[0]>=INF) return false;\n  return true;\n}\n \nint main(){\n  while(true){\n    crys.clear();\n    cin >> n >> h.fi >> h.se >> d.fi >> d.se;\n    if(!n && !h.fi && !h.se && !d.fi && !d.se){\n      break;\n    }\n    crys.resize(n);\n    for(int i=0; i<n; i++){\n      cin >> crys[i].fi >> crys[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\ntemplate <class T>\nT next_combination(T combi)\n{\n\tT leastBit = combi & -combi;\n\tT mostBits = combi + leastBit;\n\tT leastSequentialBits = combi & ~mostBits;\n\treturn mostBits | ((leastSequentialBits / leastBit) >> 1);\n}\ndouble dist(int x1, int y1, int x2, int y2)\n{\n\tint x = x1 - x2, y = y1 - y2;\n\treturn sqrt(0.0 + x*x + y*y);\n}\nint main()\n{\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n)\n\t{\n\t\tint x[32], y[32];\n\t\trep (i, n)\n\t\t\tcin >> x[i] >> y[i];\n\t\tx[n] = hx, y[n] = hy;\n\t\tx[n + 1] = dx, y[n + 1] = dy;\n\t\tdouble dis[32][32];\n\t\tfor (int i = 0; i <= n + 1; ++i)\n\t\t\tfor (int j = 0; j <= n + 1; ++j)\n\t\t\t\tdis[i][j] = dist(x[i], y[i], x[j], y[j]);\n\n\n\t\tstatic double dp[1 << 20][20];\n\t\tconst double INF = 1e9;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tdp[i][j] = INF;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (dis[n][i] < dis[n + 1][i])\n\t\t\t\tdp[1 << i][i] = dis[n][i];\n\n\t\tfor (int bits = 1; bits < n; ++bits)\n\t\t{\n\t\t\tfor (int s = (1 << bits) - 1; s < 1 << n; s = next_combination(s))\n\t\t\t{\n\t\t\t\tbool alive = false;\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t{\n\t\t\t\t\tif (!(s >> i & 1) || dp[s][i] == INF)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\talive = true;\n\t\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s >> j & 1)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdouble t = dp[s][i] + dis[i][j];\n\t\t\t\t\t\tif (t < dis[n + 1][j])\n\t\t\t\t\t\t\tmin_swap(dp[s | 1 << j][j], t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!alive)\n\t\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\nend:\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (dp[(1 << n) - 1][i] < dis[n + 1][i])\n\t\t\t\tres = true;\n\t\tcout << (res ? \"YES\" : \"NO\") << endl;\n\t\t//cout.precision(9);\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//\tcout << dp[(1 << n) - 1][i] << \" / \" << dis[n + 1][i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n#include <complex>\n\n#define INF 1145141919\n#define EPS 1e-9\n#define Pi acos(-1)\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define MAX_N 20\n\nint N;\nint hx, hy, dx, dy;\nint cx[MAX_N], cy[MAX_N];\n\nint dir[30][30]; //N:勇者 N+1:魔王\n\nvector<string> ans_list;\n\nvoid init(){\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = 0; j < N; j++){\n\t\t\tdir[i][j] = abs(cx[i] - cx[j]) + abs(cy[i] - cy[j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++){\n\t\tdir[i][N] = dir[N][i] = abs(cx[i] - hx) + abs(cy[i] - hy);\n\t\tdir[i][N + 1] = dir[N + 1][i] = abs(cx[i] - dx) + abs(cy[i] - dy);\n\t}\n\n}\n\nbool dfs(int S, int now, int t){\n\t\n\tif (S == (1 << N) - 1)\n\t\treturn true;\n\n\t//枝狩り\n\tfor (int i = 0; i < N; i++){\n\t\tif (!(S >> i & 1) && dir[now][i] >= dir[N + 1][i] - t){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t//探索\n\tfor (int i = 0; i < N; i++){\n\t\tif (!(S >> i & 1)){\n\t\t\tif (dfs(S | (1 << i), i, t + dir[now][i]))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n\n}\n\nint main(){\n\n\twhile (cin >> N >> hx >> hy >> dx >> dy, N){\n\t\t\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t}\n\n\t\tinit();\n\n\t\tif (dfs(0, N, 0))\n\t\t\tans_list.push_back(\"YES\");\n\t\telse\n\t\t\tans_list.push_back(\"NO\");\n\n\t}\n\n\tfor (int i = 0; i < ans_list.size(); i++){\n\t\tcout << ans_list[i] << endl;\n\t}\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <cstring>\nusing namespace std;\n\ntypedef complex<int> C;\n#define EPS (1e-8)\n\nint n, hx, hy, dx, dy;\nbool possible, used[21];\nC c[21];\n\ndouble dist(int x, int y) {\n\treturn sqrt((double)x*x + (double)y*y);\n}\n\nvoid dfs(double ct, int x, int y) {\n\tif (possible) return;\n\t\n\tbool end_flag = true;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!used[i]) {\n\t\t\tend_flag = false; break;\n\t\t}\n\t}\n\tif (end_flag) {\n\t\tpossible = true; return;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i]) continue;\n\n\t\tdouble h2c = dist(x-c[i].real(), y-c[i].imag());\n\t\tdouble d2c = dist(dx-c[i].real(), dy-c[i].imag()) - ct;\n\t\tif (h2c + EPS > d2c) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i]) continue;\n\n\t\tused[i] = true;\n\t\tdouble h2c = ct + dist(x-c[i].real(), y-c[i].imag());\n\t\tdfs(h2c, c[i].real(), c[i].imag());\n\t\tused[i] = false;\n\t}\n}\n\nvoid solve() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>c[i].real()>>c[i].imag();\n\t}\n\n\tfill(used, used+n, false);\t\n\t//memset(used, false, sizeof used);\n\tpossible = false;\n\n\tdfs(0, hx, hy);\n\n\tif (possible) {\n\t\tcout<<\"YES\";\n\t} else {\n\t\tcout<<\"NO\";\n\t}\n\tcout<<endl;\n}\n\nint main(int argc, const char *argv[]) {\n\twhile (cin>>n>>hx>>hy>>dx>>dy, n) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint N;\nP H,D;\nP C[22];\nint K[22][22];\nint dc[22];\nint hc[22];\nint deadK;\n\nint getK(P a,P b){\n  return (a.F - b.F)* (a.F - b.F) + (a.S - b.S)* (a.S - b.S);\n}\n\nint sumK(int a,int b){\n  return a + b + 2*sqrt(a)*sqrt(b);\n}\n\nint solve(int id,int ky,int st){\n  if( st == (1<<N)-1 ) return true;\n\n  bool ret = true;\n  int sum[22];\n  for(int i=0;i<N;i++){\n    if( st & (1<<i) ) continue;\n    sum[i] = sumK(ky,K[id][i]);\n    if( sum[i] >= dc[i] ) ret = false;\n  }\n  if( ret ){\n    for(int i=0;i<N;i++){\n      if( st & (1<<i) ) continue;\n      if( sum[i] < dc[i] )\n\tif( solve(i,sum[i],st|(1<<i)) ) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >> N >> H.F >> H.S >> D.F >> D.S;\n    if( !N && !H.F && !H.S && !D.F && !D.S ) break;\n    for(int i=0;i<N;i++) cin >> C[i].F >> C[i].S;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tK[i][j] = getK(C[i],C[j]);\n    for(int i=0;i<N;i++){\n      hc[i] = getK(C[i],H);\n      dc[i] = getK(C[i],D);\n    }\n    bool res = true;\n    for(int i=0;i<N;i++){\n      if( hc[i] >= dc[i] ){\n\tres = false;\n      }\n    }\n    if( res ) {\n      res = false;\n      for(int i=0;i<N;i++){\n\tif( hc[i] < dc[i] ){\n\t  if( solve(i,hc[i],(1<<i)) )  res = true;\n\t}\n\tif( res ) break;\n      }\n    }\n    if( res ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef complex<double> P;\nstruct L {\n    L(const P&a, const P&b) : p({a,b}) {}\n    P p[2];\n    P & operator[](int i){\n        return p[i];\n    }\n    const P & operator[](int i) const {\n        return p[i];\n    }\n};\n\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;\n    if (cross(b, c) < 0)   return -1;\n    if (dot(b, c) < 0)     return +2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nint all,n;\nP d;\nvector<P> v;\n\nvoid pr(int m){\n    for(int i=n-1; i>=0; i--){\n        cout << ((m>>i)&1);\n    }\n    cout << endl;\n}\n\nint c;\nbool dfs(int at, int vis, double t){\n    c++;\n    vis |= (1<<at);\n    //pr(vis);\n    if(vis == all){\n        return true;\n    }\n    rep(next,n){\n        if(vis& (1<<next)) continue;\n        P proj = projection(L(v[at], v[next]), d);\n        bool out = abs(ccw(v[at], v[next], proj)) == 2;\n        if(t + abs(v[next]-v[at]) < abs(v[next]-d) &&\n           (out || t + abs(proj-v[at]) < abs(proj-d))){\n            // cout << v[at] << v[next] << proj << endl;\n            if(dfs(next, vis, t + abs(v[next]-v[at]))){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main(){\n    while(cin>>n, n){\n        n++;\n        c = 0;\n        all = (1<<n)-1;\n        double a1,a2,a3,a4; cin>>a1>>a2>>a3>>a4;\n        v.resize(n);\n        v[0] = P(a1,a2);\n        d = P(a3,a4);\n        rep(i,n-1){\n            double x,y; cin>>x>>y;\n            v[i+1] = P(x,y);\n        }\n        sort(v.begin()+1, v.end(), [=](const P& a, const P& b){\n                return norm(a-d) < norm(b-d);\n            });\n        cout << (dfs(0,0,0) ? \"YES\" : \"NO\") << endl;\n        // cout << c << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <unordered_map>\n#include <iterator>\n#include <functional>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint T, n, m;\ndouble x[21], y[21], t[21], hx, hy, sx ,sy;\n\ndouble hypot(double x, double y){\n\treturn sqrt(x*x+y*y);\n}\nint solve(double sx, double sy, int b, double ct){\n\tif(b == (1<<n)-1) return 1;\n\tREP(i, n)if(0 == ((b>>i)&1)){\n\t\tdouble nt = ct + hypot(x[i]-sx, y[i]-sy);\n\t\tif(t[i]-EPS < nt) return 0;\n\t}\n\tREP(i, n)if(0 == ((b>>i)&1)){\n\t\tdouble nt = ct + hypot(x[i]-sx, y[i]-sy);\n\t\tif(t[i]-EPS < nt) continue;\n\t\tif(solve(x[i], y[i], b | (1<<i), nt)) return 1;\n\t}\n\treturn 0;\n}\n\n\nint main(int argc, char *argv[]){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> sx >> sy >> hx >> hy, n){\n\t\tREP(i, n){\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tt[i] = hypot(x[i]-hx, y[i] - hy);\n\t\t}\n\t\tcout << (solve(sx, sy, 0, 0) ? \"YES\" : \"NO\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<map>\n#include<cmath>\n#include<algorithm>\n#define X first\n#define Y second\nusing namespace std;\n\ntypedef pair<double,double> P;\n\n\nint n;\nP ph,pd;\nvector<P>items;\n\ndouble dist(P p1,P p2){\n  P p = P(p1.X - p2.X,p1.Y - p2.Y);\n  return sqrt(p.X * p.X + p.Y * p.Y);\n}\n\nint memo[1 << 20];\nconst int INF = 1e8;\n\nbool dfs(P p,int state,int time){\n  if(__builtin_popcount(state) == n)return true;\n  for(int i = 0 ; i < n ; i++){\n    if((state >> i)&1)continue;\n    int nstate = state | (1 << i);\n    double d = dist(p,items[i]);\n    int ntime = time + ceil(d);\n\n    bool f = false;\n    for(int j = 0 ; j < n ; j++){\n      if((state >> j)&1)continue;\n      if(ntime >= dist(pd,items[j])){f = true;break;};\n    }\n    if(f)continue;\n\n    if(memo[nstate] < ntime)continue;\n    memo[nstate] = ntime;\n    \n    if(dfs(items[i],nstate,ntime))return true;\n  }\n  return false;\n}\n\nvoid init(){\n  items.clear();\n  for(int i = 0 ; i < (1 << n) ; i++){\n    memo[i] = INF;\n  }\n}\n\nvoid input(){\n\n  for(int i = 0 ; i < n ; i++){\n    P p;\n    cin >> p.X >> p.Y;\n    items.push_back(p);\n  }\n}\n\nint main(){\n  while(1){\n    cin >> n >> ph.X >> ph.Y >> pd.X >> pd.Y;\n    if(n == 0 && ph.X == 0 && ph.Y == 0 && pd.X == 0 && pd.Y == 0)break;\n    init();\n    input();\n    cout << (dfs(ph,0,0)?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-14;\n\nint N;\nP D;\nvector<P> ps;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, int p) {\n  double dist = abs(D - ps[p]);\n  return !( dist < t + eps );\n}\n\nbool rec(int state, double t, int p) {\n  if(state == (1<<N)-1) return true;\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    if(!canExist(t+abs(ps[i] - ps[p]), i)) return false;\n  }\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    double nt = t + abs(ps[i] - ps[p]);\n    if(rec(state|(1<<i), nt, i)) return true;\n  }\n  return false;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy\n\t&&(N|hx|hy|dx|dy) ) {\n    D = P(dx, dy);\n    ps.resize(N+1);\n    ps[N-1] = P(hx, hy);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(rec(0, 0.0, N)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\nint n;\nint x[30], y[30],h1,h2,d1,d2;\n  \ndouble dist(int a, int b){\n    return sqrt(a*a+b*b+0.0);\n}  \nint main(){\n    while(1){\n\t\tbool ok=true;\n        cin >> n;\n        if(n == 0) break;\n        cin >>h1>>h2>>d1>>d2>>x[0]>>y[0];\n\t\tif(dist(h1-x[0],h2-y[0])>= dist(d1-x[0],d2-y[0]))ok=false;\n        for(int i=1;i<n;i++){\n            cin >> x[i] >> y[i];\n\t\t\tif(dist(h1-x[0],h2-y[0])+dist(x[0]-x[i],y[0]-y[i]) >= dist(d1-x[i],d2-y[i]))ok=false;\n        }\n  \n        if(ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nint N;\nP D;\nvector<P> ps;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, int p) {\n  double dist = abs(D - ps[p]);\n  return !(equals(dist, t) || dist < t);\n}\n\nbool rec(int state, double t, int p) {\n  if(state == (1<<N)-1) return true;\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    if(!canExist(t+abs(ps[i] - ps[p]), i)) return false;\n  }\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    double nt = t + abs(ps[i] - ps[p]);\n    if(rec(state|(1<<i), nt, i)) return true;\n  }\n  return false;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy\n\t&&(N|hx|hy|dx|dy) ) {\n    D = P(dx, dy);\n    ps.resize(N+1);\n    ps[N-1] = P(hx, hy);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(rec(0, 0.0, N)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//56\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\n#define S(X) ((X)*(X))\n\nint n,hx,hy,dx,dy;\ndouble d[21][21];\ndouble l[21];\n\nbool dfs(int s,double t,int g){\n  if(g==(1<<n+1)-1)return true;\n  double ub=0;\n  for(int i=1;i<=n;i++){\n    if(!(g&1<<i)&&ub<l[i]){\n      ub=l[i];\n    }\n  }\n  double lb=1<<30;\n  for(int i=0;i<=n;i++){\n    for(int j=i+1;j<=n;j++){\n      if(!((g&1<<i)&&(g&1<<j))&&lb>d[i][j]){\n\tlb=d[i][j];\n      }\n    }\n  }\n  if(lb>ub)return false;\n  for(int i=1;i<=n;i++){\n    if(!(g&1<<i)&&t+d[s][i]<l[i]){\n      if(dfs(i,t+d[s][i],g|1<<i))return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin>>n>>hx>>hy>>dx>>dy,n|hx|hy|dx|dy){\n    int cx[21]={hx},cy[21]={hy};\n    for(int i=1;i<=n;i++){\n      cin>>cx[i]>>cy[i];\n    }\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\td[i][j]=sqrt(S(cx[i]-cx[j])+S(cy[i]-cy[j]));\n      }\n    }\n    for(int i=1;i<=n;i++){\n      l[i]=sqrt(S(dx-cx[i])+S(dy-cy[i]));\n    }\n    cout<<(dfs(0,0,1)?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble  cost[20][20];\nconst double INF = 10000000;\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if (visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  //\n  \n  visited[last]=false;\n  rep(i,n){\n    if (visited[i]==true)cost[i][i]=INF;\n    else cost[i][i]=0;\n    REP(j,i+1,n){\n      if (visited[i]==true ||visited[j]==true)cost[i][j]=cost[j][i]=INF;\n      else cost[i][j]=cost[j][i]=adj[i][j];\n    }\n  }\n  visited[last]=true;\n  rep(k,n)rep(i,n)rep(j,n)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n  rep(i,n)if( visited[i]==false && r+cost[last][i] >=adj[MAOU][i])return false;\n  \n  //\n\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    if ( r+adj[last][i] < adj[MAOU][i]){\n      visited[i]=true;\n      if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n      visited[i]=false;\n    }//else return false;\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n  }\n  \n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i])+eps>dist(rx-x[i],ry-y[i]))return false;\n  }\n\n\n  bool visited[20]={false};\n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i]) < dist(rx-x[i],ry-y[i])){\n      visited[i]=true;\n      if ( backTrack(i,dist(mx-x[i],my-y[i]),1,n,visited))return true;\n      visited[i]=false;\n    }else return false;\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(cin>>n>>mx>>my>>rx>>ry && n){\n    int x[n],y[n];\n    rep(i,n)cin>>x[i]>>y[i];\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 20\n#define EPS 1e-9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX];\nbool rec(int now, double total_dist, int depth){\n  if(total_dist >= dist(d, crystal[now])){\n    return false;\n  }\n  if(depth == N){\n    return true;\n  }\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      Segment s = Segment(crystal[now], crystal[i]);\n      if(s.distanceSP(d) < 1) return false;\n      used[i] = true;\n      if(rec(i, total_dist + dist(crystal[now],crystal[i]), depth+1)){\n        return true;\n      }\n      used[i] = false;\n    }\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    memset(used, false, sizeof(used));\n    if(rec(i, dist(h, crystal[i]), 0)){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool f = false;\nint cx[20];\nint cy[20];\ndouble dis[20];\nbool used[20];\nint n, hx, hy, dx, dy;\n\ndouble distance(int x1, int y1, int x2, int y2){\n\tdouble dx = x2 - x1;\n\tdouble dy = y2 - y1;\n\treturn sqrt(dx*dx+dy*dy);\n}\n\nvoid move(int x, int y, int n, double time){\n\tif(n == 0){\n\t\tf = true;\n\t}\n\tif(f) return;\n\tbool f2 = false;\n\tfor(int i = 0; i < n; i++){\n\t\tif(!used[i]){\n\t\t\tif(time + distance(x, y, cx[i], cy[i]) > dis[i] + 0.0000001){\n\t\t\t\tf2 = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(f2) return;\n\tfor(int i = 0; i < n; i++){\n\t\tdouble d = distance(cx[i], cy[i], x, y);\n\t\tif(!used[i] && d + time < dis[i] - 0.000000001){\n\t\t\tused[i] = true;\n\t\t\tmove(cx[i], cy[i], n - 1, time + distance(cx[i],cy[i], x, y));\n\t\t\tused[i] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> n >> hx >> hy >> dx >> dy){\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tused[i] = false;\n\t\t\tdis[i] = distance(cx[i], cy[i], dx, dy);\n\t\t}\n\t\tf = false;\n\t\tmove(hx, hy, n, 0);\n\t\tif(f) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint n,hx,hy,mx,my,cx[20],cy[20];\n\nbool dfs(int t,int x,int y,bool *vis){\n\tif(abs(x-mx)+abs(y-my)<=t) return false;\n\tif(count(vis,vis+n,true)==n) return true;\n\n\trep(i,n) if(!vis[i]) {\n\t\tvis[i]=true;\n\t\tif(dfs(t+abs(x-cx[i])+abs(y-cy[i]),cx[i],cy[i],vis)) return true;\n\t\tvis[i]=false;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&hx,&hy,&mx,&my),n;){\n\t\trep(i,n) scanf(\"%d%d\",cx+i,cy+i);\n\n\t\tbool ok=false,vis[20]={};\n\t\trep(i,n) if(dfs(0,hx,hy,vis)) { ok=true; break; }\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; ++i)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define P complex<double>\n#define Y real()\n#define X imag()\n\nint n;\nP h, d;\n\nbool isEnd(vector<bool> &v){\n  REP(i, v.size()) if(!v[i]) return false;\n  return true;\n}\nbool check(P now, int time, vector<bool> visited, vector<P> v){\n  if(isEnd(visited)) return true;\n\n  //debug\n  //cout <<\"-----------\" <<endl;\n  //cout <<now.Y <<\", \" <<now.X <<\", \" <<time <<endl;\n  //REP(i, visited.size()) cout <<visited[i] <<\", \";\n  //cout <<endl;\n\n  bool ret = false;\n  REP(i, v.size()){\n    if(visited[i]) continue;\n    int cnt = (int)(ceil(abs(now - v[i])));\n    //debug\n    //cout <<\"! \" <<i <<endl;\n    //cout <<v[i].Y <<\", \" <<v[i].X <<endl;\n    //cout <<abs(now - v[i]) <<\", \" <<cnt <<\", \" <<time + cnt <<\", \" <<abs(d - v[i]) <<endl;\n    \n    if(time + cnt < abs(d - v[i])){\n      visited[i] = true;\n      ret = max(ret, check(v[i], time + cnt, visited, v));\n      visited[i] = false;\n    }\n  }\n  //cout <<ret <<\"---------ret\" <<endl;\n  return ret;\n}\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >>n >>hx >>hy >>dx >>dy && n != 0){\n    h = P(hy, hx);\n    d = P(dy, dx);\n    vector<P> v(n);\n    REP(i, n){\n      int a, b;\n      cin >>a >>b;\n      v[i] = P(b, a);\n    }\n    cout <<(check(h, 0, vector<bool>(n), v) ? \"YES\" : \"NO\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nint n,sx,sy,mx,my;\nint xi[22],yi[22];\nbool used[22];\nconst double eps = 1e-8;\ninline double sc(double a){return a*a;}\n#define R(a,b) (sqrt(sc(a)+sc(b)))\n\nbool solve(int a,int p,double t,double x,double y)\n{\n  //printf(\"%d %f %f %f\\n\",a,t,x,y);\n  if( a == n ) return true;\n  for(int i = 0; i < n; i++) {\n    if( R(xi[i]-mx,yi[i]-my) < t+R(x-xi[i],y-yi[i])+eps ) {\n      return false;\n    }\n  }\n  for(int i = 0; i < n; i++) {\n    if(!used[i]) {\n      used[i]=true;\n      if(solve(a+1,i,t+R(x-xi[i],y-yi[i]),xi[i],yi[i]))return true;\n      used[i]=false;\n    }\n  }\n  return false;\n}\n\nint main(void)\n{\n  for(;;) {\n    scanf(\"%d%d%d%d%d\",&n,&sx,&sy,&mx,&my); if(!n)break;\n    for(int i = 0; i < n; i++) {\n      used[i] = false;\n      scanf(\"%d%d\",xi+i,yi+i);\n    }\n    bool res = solve(0,-1,0,sx,sy);\n    puts(res ? \"YES\" : \"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint n;\nint cx[22];\nint cy[22];\nbool f[22];\ndouble l[22][22];\nint s = 0;\ndouble d;\n\nint kansu( int x , int y ){\n\ts++;\n\tif ( s == n + 1 ) return 1;\n\td += l[x][y];\n\tf[y] = true;\n\tbool flag = true;\n\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\tif ( d + l[y][i] >= l[1][i] ) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ( flag ) {\n\t\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\t\tif ( f[i] ) continue;\n\t\t\tif ( kansu( y , i ) ) return 1;\n\t\t}\n\t}\n\ts--;\n\td -= l[x][y];\n\tf[y] = false;\n\treturn 0;\n}\n\nint main(){\n\twhile(true) {\n\t\tcin >> n >> cx[0] >> cy[0] >> cx[1] >> cy[1];\n\t\tif ( n == 0 ) break;\n\t\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tf[i] = false;\n\t\t}\n\t\tfor ( int i = 0; i < n + 1; i++ ) {\n\t\t\tfor ( int j = i + 1; j < n + 2; j++ ) {\n\t\t\t\tint x = cx[i]-cx[j];\n\t\t\t\tint y = cy[i]-cy[j];\n\t\t\t\tdouble z = x*x + y*y;\n\t\t\t\tl[i][j] = sqrt( z );\n\t\t\t\tl[j][i] = l[i][j];\n\t\t\t}\n\t\t}\n\t\ts = 0;\n\t\td = 0.00;\n\t\tl[0][0] = 0.00;\n\t\tif ( kansu( 0 , 0 ) ) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define INF 0x7FFFFFFF\n#define dist(x1,y1,x2,y2) sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))\n\nint n;\ndouble cx[20], cy[20], hx, hy, dx, dy, S[1 << 20];\n\nint solve(double x,double y,int bit,double sum){\n\tint i;\n\tif(S[bit] > sum)\n\t\tS[bit] = sum;\n\telse\n\t\treturn 0;\n\tif(bit == 0)\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & bit) && sum >= dist(cx[i],cy[i],dx,dy))\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(((1 << i) & bit) && sum + dist(x,y,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i]) && solve(cx[i],cy[i],bit ^ (1 << i),sum + dist(x,y,cx[i],cy[i])))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(void){\n\tint i;\n\twhile(1){\n\t\tscanf(\"%d%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tS[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tif(solve(hx,hy,(1 << n) - 1,0))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define INF 0x7FFFFFFF\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nint cx[20], cy[20], hx, hy, n, dx, dy, cut[1 << 20];\n\nint pow(int m, int n){\n\tint sum = 1, i;\n\tfor(i = 0;i < n;i++)\n\t\tsum *= m;\n\treturn sum;\n}\n\nint solve(int x,int y){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(cut[bit] > sum)\n\t\tcut[bit] = sum;\n\telse\n\t\treturn 0;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= dist(cx[i],cy[i],dx,dy)) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit && dist(x,y,cx[i],cy[i]) + sum < dist(cx[i],cy[i],dx,dy)){\n\t\t\tbit += 1 << i;\n\t\t\tsum += dist(x,y,cx[i],cy[i]);\n\t\t\tif(solve(cx[i],cy[i])){\n\t\t\t\tsum = 0, bit = 0;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tsum -= dist(x,y,cx[i],cy[i]);\n\t\t\tbit -= 1 << i;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint i, j;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tcut[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tif(solve(hx,hy))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\nconst double EPS=1e-8;\n\ndouble dis(double a,double c,double b,double d){\n\treturn sqrt((a-b)*(a-b)+(c-d)*(c-d));\n}\n\nint main(){\n\t\n\tint N;\n\tdouble sx,sy,gx,gy;\n\twhile(cin>>N>>sx>>sy>>gx>>gy,N){\n\t\tvector<double>y(N);\n\t\tvector<double>x(N);\n\t\tvector<double>devil(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>x[i]>>y[i];\n\t\t\tdevil[i]=dis(gx,gy,x[i],y[i]);\n\t\t}\n\t\tvector<vector<double>>dist(N,vector<double>(N));\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tdist[i][j]=dis(x[i],y[i],x[j],y[j]);\n\t\t\t}\n\t\t}\n\t\tvector<vector<double>>dp(1<<N,vector<double>(N,MOD));\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(devil[i]-EPS>dis(sx,sy,x[i],y[i])){\n\t\t\t\tdp[1<<i][i]=dis(sx,sy,x[i],y[i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<1<<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif((i>>k)&1)continue;\n\t\t\t\t\tdouble nx=dp[i][j]+dist[j][k];\n\t\t\t\t\tif(nx<devil[k]-EPS){\n\t\t\t\t\t\tdp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],nx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble ans=MOD;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans=min(ans,dp.back()[i]);\n\t\t}\n\t\tif(ans>=10000000){\n\t\t\tcout<<\"NO\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"YES\\n\";\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n#define EPS 1e-10\nint n;\ndouble sx,sy,tx,ty,px[20],py[20];\n\ndouble dis(double a,double b,double c,double d)\n{return sqrt((a-c)*(a-c)+(b-d)*(b-d));}\ndouble dis(int a,int b){return dis(px[a],py[a],px[b],py[b]);}\n\nbool dfs(int S,int pos,double cost){\n  if(S==(1<<n)-1)return true;\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(cost+dis(pos,i)>dis(tx,ty,px[i],py[i]))return false;\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(cost+dis(pos,i)>=dis(tx,ty,px[i],py[i]))continue;\n    if( dfs(S|(1<<i),i,cost+dis(pos,i)) )return true;\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i=0;i<n;i++){\n    if( dfs((1<<i),i,dis(sx,sy,px[i],py[i])) )return true;\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin>>n>>sx>>sy>>tx>>ty;\n    if(n==0&&sx==0&&sy==0&&tx==0&&ty==0)break;\n    for(int i=0;i<n;i++)cin>>px[i]>>py[i];\n    cout<<(solve()?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\nconst int INF=100000000;\n\n\nint n;\nint hx,hy;\nint dx,dy;\nint cx[21],cy[21];\n\n\ndouble dist(int _x0,int _y0,int _x1,int _y1) {\n\tdouble d = (_x0-_x1)*(_x0-_x1) + (_y0-_y1)*(_y0-_y1);\n    //printf(\"[dist debug] %d %d %d %d %d\\n\",_x0,_y0,_x1,_y1,(int)(d));\n\treturn sqrt(d);\n}\n\nint pow2(int a) {\n\treturn a*a;\n}\n\nbool check(int x,int y,double d,int ind) {\n    return dist(x,y,cx[ind],cy[ind]) < (dist(dx,dy,cx[ind],cy[ind]) - d);\n}\n\nbool dfs(int x,int y,double d,int S) {\n    //printf(\"[debug] %d,%d,%lf,%d\\n\",x,y,d,S);\n\tif(S==(1<<n)-1) return true;\n\trep(i,n) {\n\t\tif(!((S>>i)&1)) {\n\t\t\tif(check(x,y,d,i)) {\n\t\t\t\treturn dfs(cx[i],cy[i],d+(dist(x,y,cx[i],cy[i])),S|(1<<i));\n\t\t\t}\n            else {\n                return false;\n            }\n\t\t}\n\t}\n\n\treturn false;\n\n}\n\n\nvoid solve() {\n\trep(i,n) cin>>cx[i]>>cy[i];\n\tif(dfs(hx,hy,0.0,0)) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\n}\n\nint main() {\n\twhile (cin>>n>>hx>>hy>>dx>>dy)\n\t{\n\t\tif(n+hx+hy+dx+dy==0) return 0;\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <functional>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<double, int> R;\ntypedef pair<P, R> Q;\ntypedef pair<double, Q> K;\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\tdouble r;\n\twhile (cin >> n >> hx >> hy >> dx >> dy) {\n\t\tif (n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) {\n\t\t\tbreak;\n\t\t}\n\t\thx -= dx;\n\t\thy -= dy;\n\t\tvector<P> data;\n\t\tint x, y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\tdata.push_back(P(x, y));\n\t\t}\n\t\tpriority_queue<K, vector<K>, greater<K> > q;\n\t\tq.push(K(0.0, Q(P(hx, hy), R(0.0, 0))));\n\t\tbool hantei = false;\n\t\twhile (!q.empty()) {\n\t\t\tK p = q.top();\n\t\t\tq.pop();\n\t\t\tP xy = (p.second).first;\n\t\t\tR limit = (p.second).second;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tbool hantei2 = true;\n\t\t\t\tif ((limit.second & (1<<i)) == 0) {\n\t\t\t\t\tdouble dead = limit.first+sqrt(pow(data[i].first-xy.first, 2)+pow(data[i].second-xy.second, 2));\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif ((limit.second & (1<<j)) == 0) {\n\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead) {\n\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\tint k = limit.second | (1<<i);\n\t\t\t\t\t\tif (k == (1<<n)-1) {\n\t\t\t\t\t\t\thantei = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble MIN = 1<<30;\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tif ((k & (1<<j)) == 0) {\n\t\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead+sqrt(pow(data[i].first-data[j].first, 2)+pow(data[i].second-data[j].second, 2))) {\n\t\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tMIN = min(MIN, sqrt(pow(data[i].first, 2)+pow(data[i].second, 2)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\t\tq.push(K(MIN, Q(data[i], R(dead, k))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hantei) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\n\nint abs(int n){\n\tif(n < 0)\n\t\tn = -n;\n\treturn n;\n}\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 20], dp[1 << 20];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){\n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tloc[1 << i] = i;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i != n){\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i] != INF){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif(~i & 1 << j && dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j]) && dp[i | 1 << j] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i]){\n\t\t\t\t\t\tdp[i | 1 << j] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];\n\t\t\t\t\t\tloc[i | 1 << j] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[1 << n] != -1)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nstruct Point {\n\tint x, y;\n};\n\nconst double EPS = 1E-10;\nPoint h, d, p[20];\nint n;\nbool flag[20];\n\nbool dfs(double t, int s) \n{\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tif (!flag[i]) break;\n\t}\n\tif (i == n) return true;\n\t\n\tPoint pp = (s == -1) ? h : p[s];\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tif (hypot(d.x - p[i].x, d.y - p[i].y) - hypot(pp.x - p[i].x, pp.y - p[i].y) - t < EPS) return false;\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tflag[i] = true;\n\t\tif (dfs(t + hypot(pp.x - p[i].x, pp.y - p[i].y), i)) return true;\n\t\tflag[i] = false;\n\t}\n\t\n\treturn false;\n}\n\nint main()\n{\t\n\twhile (cin >> n >> h.x >> h.y >> d.x >> d.y, n | h.x | h.y | d.x | d.y) {\n\t\tmemset(flag, false, sizeof(flag));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p[i].x >> p[i].y;\n\t\t}\n\t\tcout << (dfs(0, -1) ? \"YES\" : \"NO\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\ninline double sq(double a) { return a*a; }\n#define INF (1e100)\n#define EPS (1e-9)\n\nint n;\ndouble hx, hy, mx, my, xs[32], ys[32], ds[32], ws[32][32];\ndouble dp[1<<20][20];\n\nint main() {\n    for (;;) {\n        scanf(\"%d%lf%lf%lf%lf\", &n, &hx, &hy, &mx, &my);\n        if (n == 0) return 0;\n        rep (i, n) scanf(\"%lf%lf\", xs+i, ys+i);\n        rep (i, n) ds[i] = sqrt(sq(xs[i]-mx) + sq(ys[i]-my));\n        rep (i, n) rep (j, n) {\n            ws[i][j] = sqrt(sq(xs[i]-xs[j]) + sq(ys[i]-ys[j]));\n        }\n        const int nn = 1<<n;\n        rep (i, nn) rep (j, n) dp[i][j] = INF;\n        rep (i, n) {\n            double t = sqrt(sq(xs[i]-hx) + sq(ys[i]-hy));\n            if (t < ds[i]-EPS) dp[1<<i][i] = t;\n        }\n        rep (b, nn) rep (k, n) if (dp[b][k] < INF) {\n            rep (i, n) if ((b & (1<<i)) == 0) {\n                double t = dp[b][k] + ws[k][i];\n                if (t < ds[i]-EPS) dp[b|1<<i][i] = min(dp[b|1<<i][i], t);\n            }\n        }\n        bool ans = false;\n        rep (k, n) if (dp[nn-1][k] < INF) ans = true;\n        puts(ans ? \"YES\" : \"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint n;\nint hx, hy, dx, dy, cx[21], cy[21];\n\ndouble dist(double ax, double ay, double bx, double by){\n  return sqrt((ax-bx)*(ax-bx) + (ay-by)*(ay-by));\n}\n\nint dfs(int c, double t, int x, int y, int *used){\n  //  printf(\"%d %lf %lf %lf\\n\", c, t, x, y);\n  if(c == n) return 1;\n\n  rep(i, n){\n    if(used[i]) continue;\n    if(t + dist(x, y, cx[i], cy[i]) + EPS > dist(dx, dy, cx[i], cy[i])) return 0;\n  }\n\n  rep(i, n){\n    if(used[i]) continue;\n    double nt = dist(x, y, cx[i], cy[i]);\n    //    printf(\"x:%lf y:%lf nt:%lf\\n\", x, y, nt);\n    //    printf(\"dx;%lf dy:%lf cx:%lf cy:%lf\\n\", dx, dy, cx[i], cy[i]);\n    //    printf(\"%lf %lf\\n\", t + nt + EPS, dist(dx, dy, cx[i], cy[i]));\n    if(t + nt + EPS > dist(dx, dy, cx[i], cy[i])) return 0;\n    used[i] = 1;\n    if(dfs(c+1, t + nt, cx[i], cy[i], used)) return 1;\n    used[i] = 0;\n  }\n  return 0;\n}\n\nint main(){\n  while(scanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy) && n+hx+hy+dx+dy){\n    rep(i, n)\n      scanf(\"%d%d\", cx+i, cy+i);;\n\n    int used[21];\n    memset(used, 0, sizeof(used));\n    if(dfs(0, 0, hx, hy, used)) puts(\"YES\");\n    else puts(\"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\nint n;\nint x[30], y[30],h1,h2,d1,d2,s1,s2;\n  \ndouble dist(int a, int b){\n    return sqrt(a*a+b*b+0.0);\n}  \nint main(){\n    while(1){\n\t\tbool ok=true;\n        cin >> n;\n        if(n == 0) break;\n        cin >>h1>>h2>>d1>>d2>>s1>>s2;\n\t\tif(dist(h1-s1,h2-s2)>= dist(d1-s1,d2-s2))ok=false;\n        for(int i=1;i<n;i++){\n            cin >> x[i] >> y[i];\n\t\t\tif(dist(h1-s1,h2-s2)+dist(s1-x[i],s2-y[i]) >= dist(d1-x[i],d2-y[i]))ok=false;\n        }\n  \n        if(ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nint N;\nP D;\nvector<P> ps;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, int p) {\n  double dist = abs(D - ps[p]);\n  return !(equals(dist, t) || dist < t);\n}\n\nbool rec(int state, double t, int p) {\n  if(state == (1<<N)-1) return true;\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    if(!canExist(t, i)) return false;\n  }\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    double nt = t + abs(ps[i] - ps[p]);\n    if(!canExist(nt, i)) continue;\n    if(rec(state|(1<<i), nt, i)) return true;\n  }\n  return false;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy\n\t&&(N|hx|hy|dx|dy) ) {\n    D = P(dx, dy);\n    ps.resize(N+1);\n    ps[N-1] = P(hx, hy);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(rec(0, 0.0, N)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\ndouble INF=1e16;\ndouble EPS=1e-9;\nclass Main{\n\tpublic:\n\n\n\tint n;double hx,hy,dx,dy;\n\tvector<double> cx,cy;\n\tvector<vector<double>> ds;\n\n\tdouble dfs(int v,int bit){\n\t\tif(ds[v][bit]!=INF)return ds[v][bit];\n\t\t\n\t\tdouble mv=INF;\n\t\tREP(i,n)if((bit>>i&1)==1 && (bit>>v&1)==1){\n\t\t\tdouble pred=dfs(i,bit-(1<<v));\n\t\t\tif(pred>=INF)continue;\n\t\t\tdouble d=hypot(cx[v]-cx[i],cy[v]-cy[i]);\n\t\t//\tDUMP(v);DUMP(bit);DUMP(hypot(cx[v]-dx,cy[v]-dy));DUMP(pred);DUMP(pred+d);DUMP(BR);\n\t\t\tif(hypot(cx[v]-dx,cy[v]-dy)>pred+d+EPS){\n\t\t\t\tmv=min(mv,pred+d);\n\t\t\t}\n\t\t}\n\t\treturn ds[v][bit]=mv;\n\t}\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){ cin >> n >> hx >> hy >> dx >> dy;if(n==0)break;\n\t\t\tcx=vector<double>(n);cy=vector<double>(n);REP(i,n) cin >> cx[i] >> cy[i];\n\t\t\tbool ok=false;\n\t\t\tREP(g,n){\n\t\t\t\tds=vector<vector<double>>(n,vector<double>(1<<n,INF));\n\t\t\t\t//一手目\n\t\t\t\tREP(i,n){\n\t\t\t\t\tdouble d=hypot(cx[i]-hx,cy[i]-hy);\n\t\t\t\t\tif(hypot(cx[i]-dx,cy[i]-dy)>d+EPS)ds[i][1<<i]=min(ds[i][1<<i],d);\n\t\t\t\t}\n\t\t\t\tif(dfs(g,(1<<n)-1)<INF)ok=true;\n\t\t\t}\n\t\t\tcout << (ok?\"YES\":\"NO\")<<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  if ( now == n)return true;\n  rep(i,n){\n    if ( visited[i]==true)continue;\n    if ( r+adj[last][i] < adj[MAOU][i]){\n      visited[i]=true;\n      if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    double mini;\n    adj[i][i]=0;\n    mini=adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n      mini=min(adj[i][j],mini);\n    }\n    if ( mini >adj[MAOU][i])return false;\n  }\n\n\n  bool visited[20]={true};\n  rep(i,n){\n    if ( dist(mx-x[i],my-y[i]) < dist(rx-mx,ry-my)){\n      visited[i]=true;\n      if ( backTrack(i,dist(mx-x[i],my-y[i]),1,n,visited))return true;\n      visited[i]=false;\n    }\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(cin>>n>>mx>>my>>rx>>ry && n){\n    int x[n],y[n];\n    rep(i,n)cin>>x[i]>>y[i];\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\n#define EPS 1e-10\n\nstruct Point{double x,y,d;};\nint n;\nPoint hero,demon;\nvector<Point>crystal;\nbool ok;\n\ndouble dist(Point a,Point b)\n{\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nvoid solve(int now,double time,vector<bool>visited){\n  int i;\n  bool f=true;\n  if(time-crystal[now].d>-EPS)return;\n  for(i=0;i<n;i++){\n    if(visited[i])continue;\n    if(time+dist(crystal[now],crystal[i])-crystal[i].d>EPS)return;\n  }\n  for(i=0;i<n;i++){\n    if(visited[i])continue;\n    visited[i]=true;\n    solve(i,time+dist(crystal[now],crystal[i]),visited);\n    visited[i]=false;\n    f=false;\n  }\n  if(f)ok=true;\n  return;\n}\n\nint main()\n{\n  vector<bool>visited;\n  int i;\n  double hx,hy,dx,dy,x,y;\n  double time;\n  while(cin>>n>>hx>>hy>>dx>>dy,hx||hy||dx||dy){\n    hero.x=hx;\n    hero.y=hy;\n    demon.x=dx;\n    demon.y=dy;\n    crystal.clear();\n    visited.resize(n);\n    fill(visited.begin(),visited.end(),false);\n    for(i=0;i<n;i++){\n      cin>>x>>y;\n      Point p={x,y,0};\n      p.d=dist(p,demon);\n      crystal.push_back(p);\n    }\n    ok=false;\n    for(i=0;i<n;i++){\n      time=dist(hero,crystal[i]);\n      visited[i]=true;\n      solve(i,time,visited);\n      visited[i]=false;\n      if(ok)break;\n    }\n    puts(ok?\"YES\":\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n\nconst double EPS = 1e-9;\n\nconst int INF = 100000000;\n\ndouble kyo(pair<int,int> a,pair<int,int> b){\n    return sqrt((a.first-b.first)*(a.first-b.first) + (a.second-b.second)*(a.second-b.second));\n}\n\nbool solve(int ind,double zikan,set<int> &rest,const vector<vector<double> > &kyori,const vector<double> &mao){\n    if(rest.size() == 0) return true;\n    bool allok = true;\n    for(set<int>::iterator it = rest.begin();it!=rest.end();++it){\n        allok = allok and (zikan + kyori[ind][*it] +EPS < mao[*it]);\n    }\n    if(allok){\n        bool any = false;\n        for(set<int>::iterator it = rest.begin();it!=rest.end();++it){\n            rest.erase(*it);\n            any = any or solve(*it,zikan+kyori[ind][*it],rest,kyori,mao);\n            rest.insert(*it);\n        }\n        return any;\n    }else{\n        return false;\n    }\n}\n\nint main(){\n    while(true){\n        int n,hx,hy,dx,dy;\n        cin >> n >> hx >> hy >> dx >> dy;\n        if(n == 0) break;\n        vector<pair<int,int> > chi(n);\n        pair<int,int> m = make_pair(dx,dy);\n        pair<int,int> y = make_pair(hx,hy);\n\n        vector<double> yusya(n);\n        vector<double> mao(n);\n        vector<vector<double> > kyori(n,vector<double>(n));\n\n        set<int> rest;\n        for(int i=0;i<n;i++){\n            cin >> chi[i].first >> chi[i].second;\n            mao[i] = kyo(chi[i],m);\n            yusya[i] = kyo(chi[i],y);\n            rest.insert(i);\n        }\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                kyori[i][j] = kyo(chi[i],chi[j]);\n            }\n        }\n\n        bool any = false;\n        for(int i=0;i<n;i++){\n            rest.erase(i);\n            any = any or solve(i,yusya[i],rest,kyori,mao);\n            rest.insert(i);\n        }\n        if(any){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 20\n#define EPS 1e-9\ntypedef pair<double,double> P;\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX];\nbool rec(int now, double total_dist, int depth){\n  if(total_dist >= dist(d, crystal[now])){\n    return false;\n  }\n  if(depth == N){\n    return true;\n  }\n  for(int i = 0 ; i < N ; i++){\n    if(!used[i]){\n      Segment s = Segment(crystal[now], crystal[i]);\n      if(s.distanceSP(d) <= 1) return false;\n      used[i] = true;\n      if(rec(i, total_dist + dist(crystal[now],crystal[i]), depth+1)){\n        return true;\n      }\n      used[i] = false;\n    }\n  }\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    memset(used, false, sizeof(used));\n    if(rec(i, dist(h, crystal[i]), 0)){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef complex<double> P;\n\nP syoki, maou;\nP houseki[20];\nint n;\nvector<bool> v;\n\nbool rec(int now, double time) {\n  bool ff = 0;\n  REP(i,n) {\n    if (!v[i]) {\n      if (abs(maou-houseki[i]) < time+abs(houseki[i]-houseki[now]))\n        return false;\n      ff = 1;\n    }\n  }\n  if (!ff) {                    // ツ全ツ閉板づづつス\n    return true;\n  }\n\n  REP(i,n) {\n    if (!v[i]) {\n      v[i] = 1;\n      if (rec(i, time+abs(houseki[i]-houseki[now])))\n        return true;\n      v[i] = 0;\n      ff = 1;\n    }\n  }\n}\n\nint main() {\n  int hx,hy,dx,dy;\n  while(cin>>n>>hx>>hy>>dx>>dy,n||hx||hy||dx||dy) {\n    syoki = P(hx,hy);\n    maou = P(dx,dy);\n    REP(i,n) {\n      double x,y;\n      cin >> x >> y;\n      houseki[i] = P(x,y);\n    }\n    v = vector<bool>(n);\n    bool f = 0;\n    REP(i,n) {\n      v[i] = 1;\n      if (rec(i, abs(houseki[i]-syoki))) {\n        f = 1;\n        break;\n      }\n      v[i] = 0;\n    }\n    if (f)\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\nint n,x,y,h,w,d,e,s,v;\n  \ndouble j(int a,int b){return sqrt(a*a+b*b+0.0);}\nint main(){\n    while(1){\n\t\tbool ok=1;\n        cin>>n>>h>>w>>d>>e;\n        if(!n)break;\n\t\tcin>>s>>v;\n\t\tif(j(h-s,w-v)>=j(d-s,e-v))ok=0;\n        for(int i=1;i<n;i++){\n            cin>>x>>y;\n\t\t\tif(j(h-s,w-v)+j(s-x,v-y)>=j(d-x,e-y))ok=0;\n        }\n        if(ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<map>\n#include<cmath>\nusing namespace std;\nint n,dx,dy,hx,hy;\nint cx[21],cy[21];\nbool used[21];\nbool flag;\nvoid dfs(int v,int cnt,double cost){\n\tif(cnt==n)flag=true;\n\tif(flag)return;\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tdouble move=sqrt(pow(cx[v]-cx[i],2)+pow(cy[v]-cy[i],2));\n\t\t\tdouble ng=sqrt(pow(dx-cx[i],2)+pow(dy-cy[i],2));\n\t\t\tif(cost+move>=ng)return;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tdouble move=sqrt(pow(cx[v]-cx[i],2)+pow(cy[v]-cy[i],2));\n\t\t\tused[i]=true;\n\t\t\tdfs(i,cnt+1,cost+move);\n\t\t\tused[i]=false;\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n+hx+hy+dx+dy==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t\tcx[n]=hx,cy[n]=hy;\n\t\tflag=false;\n\t\tdfs(n,0,0);\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return (conj(a)*b).real();}\nFP crs(P a,P b){return (conj(a)*b).imag();}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n/*\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgtin(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lftin(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frtin(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bckin(T a){return shift(a,TOP,FRT,BTM,BCK);}\n*/\n\nint n;\nint hx,hy,mx,my;\nint cx[20],cy[20];\nmap<PI,double> cost;\n\nbool dfs(int cv,int vis,double cc){\n  if(cost.count(mp(cv,vis)) &&\n     cost[mp(cv,vis)]<=cc+EPS) return false;\n  if(vis==(1<<n)-1) return true;\n  //cout << cv << ' ' << vis << ' ' << cc << endl;\n  cost[mp(cv,vis)] = cc;\n  rep(i,n){\n    if((vis>>i)&1) continue;\n    if(cc+abs(pt(cx[i],cy[i])-pt(cx[cv],cy[cv]))+EPS>\n       abs(pt(cx[i],cy[i])-pt(mx,my))) return false;\n  }\n  \n  rep(i,n){\n    if((vis>>i)&1) continue;\n    if(dfs(i,vis|1<<i,cc+abs(P(cx[cv],cy[cv])-P(cx[i],cy[i]))))\n      return true;\n  }\n    \n  return false;\n}\n\nvoid solve(){\n  cin >> hx >> hy >> mx >> my;\n  rep(i,n) cin >> cx[i] >> cy[i];\n  //rep(i,n)rep(j,(1<<n)) cost[i][j] = 1<<20;\n  cost.clear();\n  rep(i,n){\n    if(abs(P(mx,my)-P(cx[i],cy[i]))>\n       abs(P(cx[i],cy[i])-P(hx,hy))+EPS &&\n       dfs(i,1<<i,abs(P(cx[i],cy[i])-P(hx,hy)))){\n      cout << \"YES\" << endl;\n      return;\n    }\n  }\n  cout << \"NO\" << endl;\n}\n\nint main(int argc, char *argv[]){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define fi first\n#define se second\n#define MAX 20\n#define EPS 1e-10\ntypedef pair<double,double> P;\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n \nbool solve(){\n  sort(crystal, crystal+N);\n\n  double total_dist = 0;\n  for(int i = 0 ; i < N ; i++){\n    Segment s = Segment(h, crystal[i]);\n    if(s.distanceSP(d) <= 1) continue;\n    total_dist += dist(h, crystal[i]);\n    if(total_dist >= dist(d, crystal[i])){\n      return false;\n    }\n    h = crystal[i];\n  }\n\n  return true;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 10000000\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\nint abs(int n){\n    if(n < 0)\n\t\tn = -1 * n;\n    return n;\n}\nint main(void){\n\tint n, hx, hy, dx, dy, cx[20], cy[20], i, j, loc[1 << 20], dp[1 << 20];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) \n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tdp[i] = INF; \n\t\tfor(i = 0;i < n;i++) \n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]); \n\t\tfor(i = 0;i < n;i++){ \n\t\t\tif(dist(hx,hy,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i])){ \n\t\t\t\tdp[1 << i] = dist(hx,hy,cx[i],cy[i]); \n\t\t\t\tloc[1 << i] = i; \n\t\t\t} \n\t\t\telse  \n\t\t\t\tbreak; \n\t\t}  \n\t\tif(i != n){  \n\t\t\tprintf(\"NO\\n\"); \n\t\t\tcontinue;  \n\t\t}  \n\t\tfor(i = 0;i < 1 << n;i++){ \n\t\t\tif(dp[i] != INF){\n\t\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\t\tif((~i & (1 << j)) && (dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i] < dist(dx,dy,cx[j],cy[j])) && (dp[i ^ (1 << j)] > dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i])){ \n\t\t\t\t\t\tdp[i ^ (1 << j)] = dist(cx[loc[i]],cy[loc[i]],cx[j],cy[j]) + dp[i];  \n\t\t\t\t\t\tloc[i ^ (1 << j)] = j; \n\t\t\t\t\t}  \n\t\t\t\t}\n\t\t\t}  \n\t\t}   \n\t\tif(dp[(1 << n) - 1] != INF) \n\t\t\tprintf(\"YES\\n\");  \n\t\telse  \n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define MAX 20\ntypedef pair<double,double> P;\ntypedef pair<double,P> Q;\n\nint N;\nP h, d, crystal[MAX];\n\ndouble dist(P a, P b){\n  return sqrt(pow(a.fi-b.fi,2) + pow(a.se-b.se,2));\n}\n\nbool solve(){\n  vector<Q> dd;\n  P p[MAX];\n\n  for(int i = 0 ; i < N ; i++){\n    P np = crystal[i];\n    np.fi = -np.fi; np.se = -np.se;\n    dd.push_back(Q(dist(h, crystal[i]), np));\n  }\n  sort(dd.begin(), dd.end());\n  for(int i = 0 ; i < N ; i++){\n    P np = dd[i].se;\n    np.fi = -np.fi; np.se = -np.se;\n    p[i] = np; \n  }\n\n  double total_dist = 0;\n  for(int i = 0 ; i < N ; i++){\n    total_dist += dist(h,p[i]);\n    if(total_dist >= dist(d, p[i])){\n      return false;\n    }\n    h = p[i];\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> N >> h.fi >> h.se >> d.fi >> d.se, (N + h.fi + h.se + d.fi + d.se)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].fi >> crystal[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define INF 10000\n#define EPS 1.0e-10\nusing namespace std;\ntypedef double elem;\ntypedef complex<elem> point;\ndouble dist(const point &a, const point &b){return std::abs(b-a);}\nint main(){\n\twhile(true){\n\t\tbool bSafe = true;\n\t\tint n,hx,hy,dx,dy;\n\t\tdouble walk=0.0;\n\t\tpoint hero, daemon;\n\t\tvector< point > vp;\n\n\t\tscanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy);\n\t\tif(!(n||hx||hy||dx||dy))break;\n\t\thero = complex<elem>(hx,hy);\n\t\tdaemon = complex<elem>(dx,dy);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint cx,cy;\n\t\t\tscanf(\"%d%d\", &cx, &cy);\n\t\t\tpoint p(cx,cy);\n\t\t\tif(cx==hx&&cy==hy)continue;\n\t\t\tvp.push_back( p );\n\t\t}\n\t\twhile( vp.size()>0 ){\n\t\t\tdouble min_dist=INF;\n\t\t\tdouble min_dist_hero=INF;\n\t\t\tint min_cristal = -1;\n\t\t\tfor(unsigned int i=0;i<vp.size();++i){\n\t\t\t\tif( min_dist > dist( daemon, vp[i] ) && min_dist_hero > dist( hero, vp[i] ) ){\n\t\t\t\t\tmin_dist = dist( daemon, vp[i] );\n\t\t\t\t\tmin_dist_hero = dist( hero, vp[i] );\n\t\t\t\t\tmin_cristal = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\twalk+=dist(hero,vp[min_cristal]);\n\t\t\tif(walk>=min_dist-EPS){\n\t\t\t\tbSafe=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thero = vp[min_cristal];\n\t\t\tvp.erase(vp.begin()+min_cristal);\n\t\t}\n\t\tif( bSafe )\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return (conj(a)*b).real();}\nFP crs(P a,P b){return (conj(a)*b).imag();}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgtin(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lftin(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frtin(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bckin(T a){return shift(a,TOP,FRT,BTM,BCK);}\n\nint n;\nint hx,hy,mx,my;\n\nbool vis[1<<20][20];\nint cx[20],cy[20];\n\nvoid solve(){\n  CLR(vis);\n  cin >> hx >> hy >> mx >> my;\n  rep(i,n) cin >> cx[i] >> cy[i];\n  priority_queue<pair<double,PI > > q;\n  rep(i,n) q.push(mp(-abs(pt(hx,hy)-pt(cx[i],cy[i])),mp(i,1<<i)));\n  \n  while(!q.empty()){\n    double cc=-q.top().F;\n    int cv=q.top().S.F;\n    int vi=q.top().S.S;\n    q.pop();\n    if(cc+EPS>abs(pt(cx[cv],cy[cv])-pt(mx,my))) continue;\n    if(vis[vi][cv]) continue;\n    if(vi==(1<<n)-1){\n      cout << \"YES\" << endl;\n      return;\n    }\n    vis[vi][cv]=true;\n    bool ok=true;\n    rep(i,n){\n      if((vi>>i)&1) continue;\n      ok&=\n        abs(pt(cx[i],cy[i])-pt(mx,my))+EPS>\n        cc+abs(pt(cx[i],cy[i])-pt(cx[cv],cy[cv]));\n    }\n    if(!ok) continue;\n    int nokcnt=0;\n    rep(i,n){\n      if((vi>>i)&1) continue;\n      bool ok=false;\n      rep(j,n){\n        if(i==j) continue;\n        if((vi>>j)&1) continue;\n        ok|=\n          abs(pt(cx[i],cy[i])-pt(mx,my))+EPS>\n          cc+abs(pt(cx[i],cy[i])-pt(cx[j],cy[j]))+\n          abs(pt(cx[i],cy[i])-pt(cx[cv],cy[cv]));\n      }\n      nokcnt += !ok;\n    }\n    \n    if(nokcnt>1) continue;\n\n    rep(i,n){\n      if((vi>>i)&1) continue;\n      q.push(mp(-cc-abs(pt(cx[i],cy[i])-pt(cx[cv],cy[cv])),\n                mp(i,vi|(1<<i))));\n    }\n  }\n  \n  cout << \"NO\" << endl;\n}\n\nint main(int argc, char *argv[]){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator >> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// 内積（ドット積）\ndouble dot( const Point &a, const Point &b )\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\n// 外積（クロス積）\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\n// 点 p と直線 ( q1, q2 ) の距離\n// include : cross\ndouble distancePL( const Point &p, const Point &q1, const Point &q2 )\n{\n\treturn abs( cross( q2 - q1, p - q1 ) ) / abs( ( q2 - q1 ) );\n}\n\n// 点 p と線分 ( q1, q2 ) の距離\n// include : dot, distancePL\ndouble distancePS( const Point p, const Point &q1, const Point &q2 )\n{\n\tif ( EPS < dot( q2 - q1, p - q1 ) && EPS < dot( q1 - q2, p - q2 ) ) // 垂線が交わる\n\t{\n\t\treturn distancePL( q1, q2, p );\n\t}\n\telse\n\t{\n\t\treturn min( abs( q1 - p ), abs( q2 - p ) );\n\t}\n}\n\nconstexpr double INF = DBL_MAX / 10;\n\nbool ok( const double stime, const Point &p1, const Point &p2, const Point &q )\n{\n\tif ( abs( p2 - q ) - EPS <= stime + abs( p1 - p2 ) )\n\t{\n\t\treturn false;\n\t}\n\n\tif ( !( EPS < dot( p2 - p1, q - p1 ) && EPS < dot( p1 - p2, q - p2 ) ) )\n\t{\n\t\treturn true;\n\t}\n\n\tconst double d = sqrt( pow( abs( q - p1 ), 2. ) - pow( distancePS( q, p1, p2 ), 2. ) );\n\treturn stime + d + EPS < distancePS( q, p1, p2 );\n}\n\nstruct Solver\n{\n\tconst int N;\n\tconst Point h, d;\n\t\n\tvector<Point> cs;\n\tbool res;\n\n\n\tSolver( const int n, const Point &h, const Point &d ) : N( n ), h( h ), d( d )\n\t{\n\t\tcs = vector<Point>( n + 1, h );\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tcin >> cs[ i + 1 ];\n\t\t}\n\t\treturn;\n\t}\n\n\toperator string()\n\t{\n\t\tres = false;\n\t\tdfs( 1, 0, 0 );\n\t\treturn res ? \"YES\" : \"NO\";\n\t}\n\n\tvoid dfs( int visited, double stime, int cur )\n\t{\n\t\tif ( visited + 1 == 1 << cs.size() )\n\t\t{\n\t\t\tres = true;\n\t\t\treturn;\n\t\t}\n\n\t\tREP( i, 0, cs.size() )\n\t\t{\n\t\t\tif ( visited & 1 << i )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( abs( cs[i] - d ) - EPS <= stime + abs( cs[i] - cs[ cur ] ) )\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tREP( i, 0, cs.size() )\n\t\t{\n\t\t\tif ( visited & 1 << i )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( stime + abs( cs[i] - cs[ cur ] ) - EPS < abs( cs[i] - d ) && ok( stime, cs[ cur ], cs[i], d ) )\n\t\t\t{\n\t\t\t\tdfs( visited | 1 << i, stime + abs( cs[i] - cs[ cur ] ), i );\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n};\n\n\t\t\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tPoint h, d;\n\tfor ( int n; cin >> n >> h >> d, n; )\n\t{\n\t\tcout << (string)Solver( n, h, d ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 20\n#define EPS 1e-10\ntypedef pair<double,double> P;\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x > p.x : y > p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n \nbool solve(){\n  sort(crystal, crystal+N);\n\n  double total_dist = 0;\n  for(int i = 0 ; i < N ; i++){\n    Segment s = Segment(h, crystal[i]);\n    if(s.distanceSP(d) <= 1) continue;\n    total_dist += dist(h, crystal[i]);\n    if(total_dist >= dist(d, crystal[i])){\n      return false;\n    }\n    h = crystal[i];\n  }\n\n  return true;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble hero[20];\nbool visited[20]={false};\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if ( visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    visited[i]=true;\n    if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\ninline double dist(int x,int y){\n  return x*x+y*y;\n}\n\ninline int solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n    hero[i]=dist(mx-x[i],my-y[i]);\n    if ( hero[i]+eps>adj[MAOU][i])return false;\n    visited[i]=false;\n  }\n  \n  rep(i,n){\n    visited[i]=true;\n    if ( backTrack(i,hero[i],1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(scanf(\"%d%d%d%d%d\",&n,&mx,&my,&rx,&ry) && n){\n    int x[n],y[n];\n    rep(i,n)scanf(\"%d%d\",&x[i],&y[i]);\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\nint n,x,y,h1,h2,d1,d2,s1,s2;\n \ndouble dist(int a, int b){\n    return sqrt(a*a+b*b+0.0);\n}\n \nbool solve(){\n    if(dist(h1-s1,h2-s2) + dist(x-s1,y-s2) >= dist(d1-x,d2-y)) return false;\n    return true;\n}\n \nint main(){\n    while(1){\n        cin >> n;\n        if(!n) break;\n        cin>>h1>>h2>>d1>>d2>>s1>>s2;\n\t\tbool ok=true;\n\t\tif(dist(h1-s1,h2-s2)>=dist(d1-x,d2-y))ok=false;\n\t\tn--;\n\t\twhile(n--){\n\t\t\tcin>>x>>y;\n\t\t\tif(!solve())ok=false;\n\t\t}\n\n \n        if(ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint n;\ndouble item_dist[21][21];\ndouble boss_dist[20];\n\ndouble distance(pii a, pii b) {\n    return hypot(a.first - b.first, a.second - b.second);\n}\n\nbool dfs(int p, double t, int remain) {\n    if (remain == 0) return true;\n    REP(i, n) {\n        if (remain & (1 << i)) {\n            double next_t = t + item_dist[i][p];\n            bool reachable = true;\n            REP(j, n) {\n                if (remain & (1 << j)) {\n                    if (boss_dist[j] <= next_t + item_dist[i][j]) {\n                        reachable = false;\n                        break;\n                    }\n                }\n            }\n            if (reachable && dfs(i, next_t, remain & ~(1 << i))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int x, y, hx, hy;\n    while (cin >> n >> x >> y >> hx >> hy, n|x|y|hx|hy) {\n        fill_n((int *)item_dist, 21*21, 0);\n        fill_n((int *)boss_dist, 21*21, 0);\n\n        vector<pii> items;\n        REP(i, n) {\n            int a, b;\n            cin >> a >> b;\n            items.push_back({a, b});\n        }\n        items.push_back({x, y});\n        REP(i, n+1) {\n            REP(j, n+1) {\n                item_dist[i][j] = item_dist[j][i] = distance(items[i], items[j]);\n            }\n            boss_dist[i] = distance(items[i], {hx, hy});\n        }\n\n        if (dfs(n, 0.0, (1 << n)-1)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n// Area of Polygon //\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\n// Totsuhou! Andrew's Monotone Chain //\n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n \n \nP getPedal(L l, P p){\n\tdouble A;\n\tif(abs(l[1].real()-l[0].real()) < EPS){\n\t\treturn P(l[1].real(),p.imag()); // important\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A , b = 1 , c = A*l[0].real() - l[0].imag();\n\tdouble t = (a*p.real() + b*p.imag() + c)/(a*a+b*b);\n\treturn p-t * P(a,b);\n}\n\n  \nvector<P> crosspointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS)return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nP getCircumcenter(P a,P b,P c){\n\tdouble A1 = 2 * ( b.real() - a.real() );\n\tdouble B1 = 2 * ( b.imag() - a.imag() );\n\tdouble C1 = pow(a.real(),2)-pow(b.real(),2) + pow(a.imag(),2)-pow(b.imag(),2);\n\tdouble A2 = 2 * ( c.real() - a.real() );\n\tdouble B2 = 2 * ( c.imag() - a.imag() );\n\tdouble C2 = pow(a.real(),2)-pow(c.real(),2) + pow(a.imag(),2)-pow(c.imag(),2);\n\tdouble X = (B1 * C2 - B2 * C1) / (A1 * B2 - A2 * B1);\n\tdouble Y = (C1 * A2 - C2 * A1) / (A1 * B2 - A2 * B1);\n\treturn P(X,Y);\n}\n \ndouble AreaOfPolygon(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*　多角形の面積公式 (反時計回りの場合) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\n\nint N;\ndouble dist[21][21];\ndouble fast[21][21];\n\nP h,d,p[20];\n\n\nbool dfs(int n,int bit,double cur){\n\tif( bit == (1<<N)-1 ) return true;\n\n\tfor(int i = 0 ; i < N ; i++){\n\t\tif( !(bit >> i & 1) ){\n\t\t\tif( cur > abs(d-p[i]) - EPS) return false;\n\t\t}\n\t}\n\tvector< pair<double,int> > S;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tS.push_back( make_pair(  abs(p[n]-p[i]) , i ) );\n\t}\n\tsort(S.begin(),S.end());\n\tfor(int I = 0 ; I < N ; I++){\n\t\tint i = S[I].second;\n\t\tif( !(bit >> i & 1) ){\n\t\t\tdouble lim = dist[n][i] - cur;\n\t\t\tif( fast[n][i] > lim - EPS ) continue;\n\t\t\tdouble nextTime = cur + abs(p[n]-p[i]);\n\t\t\tif( abs(d-p[i]) - EPS < nextTime ) continue;\n\t\t\tif( dfs(i,bit|(1<<i),nextTime) ) return true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tN = n;\n\t\tcin >> h.real() >> h.imag();\n\t\tcin >> d.real() >> d.imag();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> p[i].real() >> p[i].imag();\t\n\t\t}\n\t\tfor(int i = 0 ; i <= n ; i++){\n\t\t\tfor(int j = 0 ; j <= n ; j++){\n\t\t\t\tif( i == j ) continue;\n\t\t\t\tP a = (i==n?h:p[i]);\n\t\t\t\tP b = (j==n?h:p[j]);\n\t\t\t\tdist[i][j] = distanceSP(L(a,b),d);\n\t\t\t\tfast[i][j] = intersectSP(L(a,b),getPedal(L(a,b),d)) ? abs(a-getPedal(L(a,b),d)) : 0;\n\t\t\t}\n\t\t}\n\t\tcout << (dfs(n,0,0)?\"YES\":\"NO\") << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 20;\nconst double inf = 1e100;\nconst double eps = 1e-8;\n\n\nstruct State {\n  char p;\n  int c;\n  double time;\n  bool operator < (const State &s) const {\n    return time > s.time;\n  }\n};\n\nint N;\nP H, D;\nvector<P> ps;\nbool vis[1<<MAXN][MAXN+1];\ndouble border[1<<MAXN];\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, P p) {\n  double d = abs(D - p);\n  return !equals(d, t) && d > t;\n}\n\nvoid makeBorder() {\n  for(int i = 0; i < (1<<N); ++i) {\n    border[i] = inf;\n    for(int j = 0; j < N; ++j) {\n      if(i & (1<<j)) continue;\n      border[i] = min(border[i], abs(D - ps[j]));\n    }\n  }\n}\n\nbool dijkstra() {\n  priority_queue<State> que;\n  State s = (State){N, 0, 0.0};\n  fill(vis[0], vis[1<<MAXN], false);\n  que.push(s);\n  while(!que.empty()) {\n    s = que.top();\n    que.pop();\n    if(vis[s.c][s.p]) continue;\n    vis[s.c][s.p] = true;\n    for(int k = 0; k < N; ++k) {\n      if(s.c & (1<<k)) continue;\n      const P &p = (s.p == N) ? H : ps[s.p];\n      const P &q = ps[k];\n      double dist = abs(q - p);\n      double nt = s.time + dist;\n      if(!canExist(nt, q)) continue;\n      State t = (State){k, s.c|(1<<k), nt};\n      if(vis[t.c][t.p]) continue;\n      if(t.time > border[t.c]+eps) continue;\n      if(t.c == (1<<N)-1) {\n\treturn true;\n      }\n      que.push(t);\n    }\n  }\n  return false;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy && \n\t( N | hx | hy | dx | dy ) ) {\n    H = P(hx,hy);\n    D = P(dx,dy);\n    ps.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    makeBorder();\n    if(dijkstra()) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nint n, hx, hy, dx, dy;\nVVD dist;\nvector<P> cristals;\nVD limits;\n\nbool get_cristal(int status, int position, double time)\n{\n\tif (time > limits[position] - EPS) {\n\t\treturn false;\n\t}\n\tif (status == (1 << n) - 1) {\n\t\treturn true;\n\t}\n\tREP (c, n) {\n\t\tif ( (status & (1 << c)) == 0) {\n\t\t\t// Get c-th cristal\n\t\t\treturn get_cristal(status | (1 << c), c, time + dist[position][c]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n | hx | hy | dx | dy) {\n\t\tcristals.clear();\n\t\tREP (i, n) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tcristals.PB(P(x, y));\n\t\t}\n\t\tcristals.PB(P(hx, hy));\n\n\t\tdist = VVD(cristals.size(), VD(cristals.size(), INF));\n\t\tREP (i, cristals.size()) {\n\t\t\tREP (j, cristals.size()) {\n\t\t\t\tdist[i][j] = sqrt(norm(cristals[i] - cristals[j]));\n\t\t\t}\n\t\t}\n\n\t\tlimits = VD(n);\n\t\tREP (i, n) {\n\t\t\tlimits[i] = sqrt(norm(cristals[i] - P(dx, dy)));\n\t\t}\n\t\tlimits.PB(INF);\n\n\t\tif (get_cristal(0, cristals.size() - 1, 0)) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nint n;\nVVD dp;\nVVB done;\nVVD dist;\nVD limit;\nvector<P> p_cristal;\n\ndouble euclid_distance(P p1, P p2)\n{\n\treturn sqrt(norm(p2 - p1));\n}\n\ndouble optimal_time(int status, int position)\n{\n\tif (done[status][position]) {\n\t\treturn dp[status][position];\n\t}\n\tif (!(status & BIT(position))) {\n\t\treturn INF;\n\t}\n\tint prev_status = status ^ BIT(position);\n\tif (prev_status == 0) {\n\t\t// Hero to this position\n\t\tdp[status][position] = dist[dist.size()-1][position];\n\t} else {\n\t\tFOR (prev_position, 0, n) {\n\t\t\tdp[status][position] = min(dp[status][position], optimal_time(prev_status, prev_position) + dist[prev_position][position]);\n\t\t}\n\t}\n\tdone[status][position] = true;\n\tif (dp[status][position] >= limit[position]) {\n\t\treturn dp[status][position] = INF;\n\t} else {\n\t\treturn dp[status][position];\n\t}\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n ^ hx ^ hy ^ dx ^ dy) {\n\t\tp_cristal.clear();\n\t\tREP (_, n) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tp_cristal.PB(P(x, y));\n\t\t}\n\t\tp_cristal.PB(P(hx, hy)); // NOTICE: Push Hero\n\t\tdist = VVD(p_cristal.size(), VD(p_cristal.size()));\n\t\tREP (i, p_cristal.size()) {\n\t\t\tREP (j, p_cristal.size()) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdist[i][j] = euclid_distance(p_cristal[i], p_cristal[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlimit = VD(p_cristal.size(), 0);\n\t\tREP (i, limit.size()) {\n\t\t\tlimit[i] = euclid_distance(p_cristal[i], P(dx, dy));\n\t\t}\n\n\t\tdp = VVD(BIT(n), VD(n, INF));\n\t\tdone = VVB(BIT(n), VB(n, false));\n\t\tint final_status = BIT(n) - 1;\n\t\tdouble t_ans = INF;\n\t\tREP (p, n) {\n\t\t\tt_ans = min(t_ans, optimal_time(final_status, p));\n\t\t}\n\t\tif (t_ans != INF) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\n#define EPS 1e-9 //許容される誤差の程度\n\nint n;\ndouble hx, hy, dx, dy;\ndouble cry[2][1000];\nbool visit[1000];\n\nbool solve(int crynum, double radius, double x, double y)\n{\n\tif(crynum >= n)\n\t{\n\t\treturn true;\n\t}\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(!visit[i]\n\t\t\t&&( hypot(cry[0][i]-dx, cry[1][i]-dy) < radius + hypot(cry[0][i]-x, cry[1][i]-y) + EPS))\n\t\t\treturn false;\n\t}\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tbool res = false;\n\t\t\n\t\tif(!visit[i])\n\t\t{\n\t\t\tvisit[i] = true;\n\t\t\tres = solve(crynum+1, radius + hypot(cry[0][i]-x, cry[1][i]-y), cry[0][i], cry[1][i]);\n\t\t\tvisit[i] = false;\n\t\t}\n\t\t\n\t\tif(res)\n\t\t\treturn true;\n\t}\n\t\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#define LT(x,y) ((x)-(y)<-EPS)\n\n#include <complex>\ntypedef complex<double> P;\n\nstruct state {\n\tint s, v;\n\tdouble d;\n\tstate(int s, int v, double d) : s(s), v(v), d(d) {};\n};\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile(cin >> n >> hx >> hy >> dx >> dy, n) {\n\t\tP h(hx, hy), d(dx, dy);\n\t\tvector<P> c(n);\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tc[i] = P(x, y);\n\t\t}\n\n\t\tstack<state> S;\n\t\tREP(i, n) {\n\t\t\tif(LT(abs(h-c[i]), abs(d-c[i]))) {\n\t\t\t\tS.push(state(1<<i, i, abs(h-c[i])));\n\t\t\t}\n\t\t}\n\n\t\tbool ok = false;\n\t\twhile(!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\n\t\t\tif(st.s == (1<<n)-1) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(i, n) {\n\t\t\t\tint ns = st.s|(1<<i);\n\t\t\t\tif(st.s != ns) {\n\t\t\t\t\tdouble nd = st.d + abs(c[st.v]-c[i]);\n\t\t\t\t\tif(LT(nd, abs(d-c[i]))) {\n\t\t\t\t\t\tS.push(state(ns, i, nd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (ok ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\ntypedef struct { int x, y; } pt;\n\nint n;\npt hero, dragon;\n\nvector<pt> targets;\n\ndouble dist(pt a, pt b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool can_visit(double d, map<int, bool>& visited, int k) {\n    if (d >= dist(targets[k], dragon)) {\n        return false;\n    }\n\n    bool all_visited = true;\n    bool ok = false;\n\n    for (int i = 1; i <= n; ++i) {\n        if (visited[i]) {\n            continue;\n        }\n\n        all_visited = false;\n\n        visited[i] = true;\n        double delta = dist(targets[i], targets[k]);\n        if (can_visit(d + delta, visited, i)) {\n            ok = true;\n        }\n        visited[i] = false;\n    }\n\n    return all_visited || ok;\n}\n\nint main() {\n    while (true) {\n        cin >> n >> hero.x >> hero.y >> dragon.x >> dragon.y;\n        if (n == 0) break;\n\n        targets.clear();\n        targets.push_back(hero);\n        for (int i = 0; i < n; ++i) {\n            pt t;\n            cin >> t.x >> t.y;\n\n            targets.push_back(t);\n        }\n\n        map<int, bool> v;\n        cout << (can_visit(0, v, 0) ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\nconst int INF=100000000;\n\n\nint n;\nint hx,hy;\nint dx,dy;\nint cx[21],cy[21];\n\n\ndouble dist(int _x0,int _y0,int _x1,int _y1) {\n\tdouble d = (_x0-_x1)*(_x0-_x1) + (_y0-_y1)*(_y0-_y1);\n    //printf(\"[dist debug] %d %d %d %d %d\\n\",_x0,_y0,_x1,_y1,(int)(d));\n\treturn sqrt(d);\n}\n\nint pow2(int a) {\n\treturn a*a;\n}\n\nbool check(int x,int y,double d,int ind) {\n    return dist(x,y,cx[ind],cy[ind]) < (dist(dx,dy,cx[ind],cy[ind]) - d);\n}\n\nbool dfs(int x,int y,double d,int S) {\n    //printf(\"[debug] %d,%d,%d,%d\\n\",x,y,d,S);\n\tif(S==(1<<n)-1) return true;\n\trep(i,n) {\n\t\tif(!((S>>i)&1)) {\n\t\t\t//d += (int)dist(x,y,cx[i],cy[i]) + 1;\n            //printf(\"[debug] %d\\n\",(int)ceil(dist(x,y,cx[i],cy[i])));\n\t\t\tif(check(x,y,d,i)) {\n\t\t\t\treturn dfs(cx[i],cy[i],d+(dist(x,y,cx[i],cy[i]))+1e-10,S|(1<<i));\n\t\t\t}\n            else {\n                return false;\n            }\n\t\t}\n\t}\n\n\treturn false;\n\n}\n\n\nvoid solve() {\n\trep(i,n) cin>>cx[i]>>cy[i];\n\tif(dfs(hx,hy,0,0)) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\n}\n\nint main() {\n\twhile (cin>>n>>hx>>hy>>dx>>dy)\n\t{\n\t\tif(n+hx+hy+dx+dy==0) return 0;\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,j) for (int (i)=0;(i)<(int)(j);++(i))\n#define put(i) cout << (i) << endl\nusing namespace std;\ntypedef long long ll;\n\ndouble eps = 1e-10;\nvector<int> f;\nbool ret=0;\n\ndouble dist(int xa, int ya, int xb, int yb) {\n    return sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb));\n}\n\nbool inCircle(int da, int db, int xa, int yb, int t) {\n    return dist(da,db,xa,yb)<=t+eps;\n}\n\nbool bfs(vector<pair<int,int>> c, int x, int y, int dx, int dy, int t) {\n    int n = c.size();\n    rep(i,n) {\n        bool chk=1;\n        rep(j,n) {\n            if (f[j] == 0) {\n                chk=0;\n                double p=dist(x,y,c[j].first,c[j].second);\n                int dt=p+(p-(int)p>0+eps?1:0);\n                if (!inCircle(dx,dy,c[j].first,c[j].second,t+dt)) {\n                    f[j] = 1;\n                    bfs(c,c[j].first,c[j].second,dx,dy,t+dt);\n                    f[j] = 0;\n                }\n                else {\n                    return ret;\n                }\n            }\n        }\n        if (chk) {\n            ret=1;\n            return ret;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int n, hx, hy, dx, dy;\n    while (scanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy), (n||hx||hy||dx||dy)) {\n        f.assign(n,0);\n        ret=0;\n        vector<pair<int, int>> c(n);\n        rep(i,n) cin >> c[i].first >> c[i].second;\n        if (bfs(c,hx,hy,dx,dy,0)) put(\"YES\"); else put(\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n\nusing Point=complex<ld>;\n\n\n\nint main() {\n\twhile (true) {\n\t\tint N; Point start_po;\n\t\tvector<Point>pos;\n\t\t{\n\t\t\tld Hx, Hy, Sx, Sy;\n\t\t\tcin >> N >> Hx >> Hy >> Sx >> Sy;\n\t\t\tif(!N)return 0;\n\t\t\tstart_po = Point(Hx - Sx, Hy - Sy);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tld x, y; cin >> x >> y;\n\t\t\t\tpos.emplace_back(x - Sx, y - Sy);\n\t\t\t}\n\t\t}\n\t\tvector<vector<ld>>memo(N, vector<ld>(1 << N, 1e18));\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tld atime = abs(pos[i] - start_po);\n\t\t\tif (atime + eps < abs(pos[i])) {\n\t\t\t\tbitset<20>bs;\n\t\t\t\tbs[i] = true;\n\t\t\t\tmemo[i][bs.to_ulong()] = atime;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << N); ++i) {\n\t\t\tfor (int now = 0; now < N; ++now) {\n\t\t\t\tif (memo[now][i]>1e17)continue;\n\n\t\t\t\tbitset<20>bs(i);\n\t\t\t\tfor (int next = 0; next < N; ++next) {\n\t\t\t\t\tif (!bs[next]) {\n\t\t\t\t\t\tbs[next] = true;\n\n\t\t\t\t\t\tld next_time = abs(pos[next] - pos[now]) + memo[now][i];\n\t\t\t\t\t\tif (next_time + eps < abs(pos[next])) {\n\t\t\t\t\t\t\tmemo[next][bs.to_ulong()] = min(memo[next][bs.to_ulong()], next_time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbs[next] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (memo[i][(1 << N) - 1]<1e17)ok = true;\n\t\t}\n\t\tif (ok)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <queue>\n#define MAXNUM 2000\n#define zero 1000 // (1000,1000)が原点\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\nusing namespace std;\n\nconst int ddx[] = {-1,0,1,0} ,ddy[] = {0,-1,0,1};\nint shoki[MAXNUM + 1][MAXNUM + 1], p[20][20], cx[20], cy[20], hx, hy, n;\n\nint solve(int pre){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= shoki[cy[i] + zero][cx[i] + zero]) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit){ // 未探索の位置にあるクリスタル\n\t\t\tif(pre == -1 && dist(hx,hy,cx[i],cy[i]) + sum < shoki[cy[i] + zero][cx[i] + zero]){ // １つ目のクリスタルをとる\n\t\t\t\tsum += dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tbit += 1 << i;\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbit -= 1 << i;\n\t\t\t\tsum -= dist(hx,hy,cx[i],cy[i]);\n\t\t\t}\n\t\t\telse if(pre != -1 && p[pre][i] + sum < shoki[cy[i] + zero][cx[i] + zero]){ // ２〜ｎつ目のクリスタルを取る\n\t\t\t\tbit += 1 << i;\n\t\t\t\tsum += p[pre][i];\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tsum -= p[pre][i];\n\t\t\t\tbit -= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint  dx, dy, x, y, i, j;\n\tqueue<int> qx, qy;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(i == j)\n\t\t\t\t\tp[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tp[i][j] = dist(cx[i],cy[i],cx[j],cy[j]);\n\t\t\t}\n\t\t}\n\t\tmemset(shoki,-1,sizeof(shoki));\n\t\tqx.push(dx + zero),qy.push(dy + zero);\n\t\tshoki[dy + zero][dx + zero] = 0;\n\t\twhile(shoki[0][0] == -1 || shoki[MAXNUM][MAXNUM] == -1 || shoki[MAXNUM][0] == -1 || shoki[0][MAXNUM] == -1){\n\t\t\twhile(qx.size()){\n\t\t\t\tx = qx.front();\n\t\t\t\ty = qy.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\t\tif(x + ddx[i] + zero >= 0 && x + ddx[i] + zero <= MAXNUM && y + ddy[i] + zero >= 0 && y + ddy[i] + zero <= MAXNUM && shoki[y + ddy[i] + zero][x + ddx[i] + zero] == -1){\n\t\t\t\t\t\tqx.push(x + ddx[i] + zero),qy.push(y + ddy[i] + zero);\n\t\t\t\t\t\tshoki[y + ddy[i] + zero][x + ddx[i] + zero] = shoki[y + zero][x + zero] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(solve(-1))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<string.h>\nusing namespace std;\n\nint n,dx,dy,hx,hy;\nbool done[20];\nint cx[20],cy[20];\n\ndouble calc(int x1,int y1,int x2,int y2){\n\treturn sqrt((double)(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nbool dfs(int x,int y,int now,double time,int k){\n//\tcout<<now<<\" \";\n//\tcout<<time<<endl;\n\tif(now>=0 && calc(cx[now],cy[now],dx,dy)<=time) return false;\n\tif(k==n) return true;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(done[i]) true;\n\t\tif(calc(cx[i],cy[i],dx,dy)<=time) return false;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tif(done[i]) continue;\n\t\tdone[i]=true;\n\t\tif(dfs(cx[i],cy[i],i,time+calc(cx[i],cy[i],x,y),k+1)) return true;\n\t\tdone[i]=false;\n\t}\n\treturn false;\n}\n\n\nint main()\n{\n\twhile(cin>>n>>hx>>hy>>dx>>dy && n!=0){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>cx[i]>>cy[i];\n\t\tmemset(done,false,sizeof(done));\n\t\tif(dfs(hx,hy,-1,0.0,0)) cout<<\"YES\\n\";\n\t\telse cout<<\"NO\\n\";\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nclass Compare {\n  int monster_x;\n  int monster_y;\npublic:\n  Compare(int monster_x,int monster_y)\n    : monster_x(monster_x), monster_y(monster_y) {}\n  bool operator()(const P& ci,const P& cj) const{\n    int dist_i = (ci.first - monster_x) * (ci.first - monster_x)\n      + (ci.second - monster_y) * (ci.second - monster_y);\n    int dist_j = (cj.first - monster_x) * (cj.first - monster_x)\n      + (cj.second - monster_y) * (cj.second - monster_y);\n    return dist_i < dist_j;\n  }\n};\n\nclass State{\n  int x;\n  int y;\n  double dist;\n};\n\nbool dfs(int hero_x,\n         int hero_y,\n         double current_time,\n         int S,\n         int monster_x,\n         int monster_y,\n         const vector<P>& cristals){\n  bool res = false;\n\n  if(S == (1<<cristals.size()) - 1) return true;\n  for(int i=0;i<cristals.size();i++){\n    if(S & (1<<i)) continue;\n    double add_time = sqrt((hero_x - cristals[i].first) * (hero_x - cristals[i].first)\n                           + (hero_y - cristals[i].second) * (hero_y - cristals[i].second));\n    \n    double impurity_arrive_time = sqrt((monster_x - cristals[i].first) * (monster_x - cristals[i].first)\n                                       + (monster_y - cristals[i].second) * (monster_y - cristals[i].second));\n    if(current_time + add_time >= impurity_arrive_time){\n      return false;\n    }\n    \n    res |= dfs(cristals[i].first,cristals[i].second,current_time + add_time,\n               S | (1<<i),monster_x,monster_y,cristals);\n    if(res) return res;\n  }\n  return res;\n}\n\nint main(){\n  int total_cristals;\n  int hero_x;\n  int hero_y;\n  int monster_x;\n  int monster_y;\n  while(~scanf(\"%d %d %d %d %d\",\n               &total_cristals,\n               &hero_x,\n               &hero_y,\n               &monster_x,\n               &monster_y)){\n    if(total_cristals == 0 && hero_x == 0 && hero_y == 0\n       && monster_x == 0 && monster_y == 0) break;\n    vector<P> cristals;\n    for(int cristal_i = 0; cristal_i < total_cristals; cristal_i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cristals.push_back(P(x,y));\n    }\n    Compare comp(monster_x,monster_y);\n    sort(cristals.begin(),cristals.end(),comp);\n    printf(\"%s\\n\", dfs(hero_x,hero_y,0,0,monster_x,monster_y,cristals)\n           ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nint cx[20], cy[20], hx, hy, n, dx, dy;\n\nint solve(int x,int y){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= dist(cx[i],cy[i],dx,dy)) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit){ // 未探索の位置にあるクリスタル\n\t\t\tif(dist(x,y,cx[i],cy[i]) + sum < dist(cx[i],cy[i],dx,dy)){\n\t\t\t\tbit += 1 << i;\n\t\t\t\tsum += dist(x,y,cx[i],cy[i]);\n\t\t\t\tif(solve(cx[i],cy[i])){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tsum -= dist(x,y,cx[i],cy[i]);\n\t\t\t\tbit -= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint i, j;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tif(solve(hx,hy))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble hero[20];\nbool visited[20]={false};\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if ( visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    visited[i]=true;\n    if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return x*x+y*y;\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n    hero[i]=dist(mx-x[i],my-y[i]);\n    if ( hero[i]>=adj[MAOU][i])return false;\n    visited[i]=false;\n  }\n  \n  rep(i,n){\n    visited[i]=true;\n    if ( backTrack(i,hero[i],1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(scanf(\"%d%d%d%d%d\",&n,&mx,&my,&rx,&ry) && n){\n    int x[n],y[n];\n    rep(i,n)scanf(\"%d%d\",&x[i],&y[i]);\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<double,int> P;\n\nint xs[21];\nint ys[21];\ndouble h[21];\nint n;\ndouble Hypot(int x, int y)\n{\n\treturn sqrt(x*x+y*y);\n}\nbool ok(int x, int y, int done, double t)\n{\n\tif(done+1==(1<<n))\n\t{\n\t\treturn true;\n\t}\n\n\tvector<P> q;\n\tfor(int i=0;i<n;i++){\n\t\tif(done&(1<<i))continue;\n\t\tdouble d=t+Hypot(xs[i]-x,ys[i]-y);\n\t\tif(d>=h[i]){\n\t\t\treturn false;\n\t\t}\n\t\tq.push_back(P(d,i));\n\t}\n\tsort(q.begin(),q.end());\n\tfor(auto p : q)\n\t{\n\t\tint i=p.second;\n\t\tif(ok(xs[i],ys[i],done|(1<<i),p.first)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid exec()\n{\n\tint hx,hy,dx,dy;\n\tcin >> n >> hx >> hy >> dx >> dy;\n\tif((n|hx|hy|dx|dy)==0){\n\t\texit(0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin >> xs[i] >> ys[i];\n\t\th[i]=Hypot(xs[i]-dx,ys[i]-dy);\n\t}\n\tif(ok(hx,hy,0,0)){\n\t\tcout << \"YES\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"NO\" << endl;\n\t}\n}\nint main() {\n\twhile(1)exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int INF=100000000;\n// e_ÔÌ£\ndouble dist[22][22];\n// e_ÌÀW\nvector<pair<int,int> > points;\nint n,hx,hy,dx,dy;\nbool ok=false;\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\n// »ÝÌê©çßÄÂ\\ÈÅ¬ÊßbðÔ·\nvoid dfs(int s,int cp,double passedSec){\n    if(ok)\n        return;\n    else if(s==0){\n        ok=true;\n        return;\n    }\n    for(int i = 0; i < n; i++){\n        // Ü¾rbgª1ÈçÎ\n        if((s>>i)&1){\n            // áCªB·éOÉTõÂ\\©Ç¤©ð`FbN\n            double dt=dist[cp][i];\n            // ¤©çÚ®æÖÌ¼aðæ¾\n            double r=dist[n+1][i];\n            // àµ¼aªz¦Ä¢½ç\n            if(dt+passedSec>r||EQ(dt+passedSec,r))\n                continue;\n            dfs((s&(~(1<<i))),i,dt+passedSec);\n        }\n    }\n}\n\n\nint main(){\n    while(cin>>n>>hx>>hy>>dx>>dy&&!(n==0&&hx==0&&hy==0&&dx==0&&dy==0)){\n        points.clear();\n        ok=false;\n        // EÒÌúÊu\n        for(int i = 0; i < n; i++){\n            pair<int,int> p;\n            cin>>p.second>>p.first;\n            points.push_back(p);\n        }\n        points.push_back(make_pair(hy,hx));\n        points.push_back(make_pair(dy,dx));\n\n        for(int i = 0; i < points.size(); i++){\n            for(int j = 0; j < points.size(); j++){\n                dist[i][j]=sqrt((double)(points[i].first-points[j].first)*(points[i].first-points[j].first)\n                    +(points[i].second-points[j].second)*(points[i].second-points[j].second));\n            }\n        }\n        dfs(((1<<n)-1),n,0);\n        if(ok)\n            cout<<\"YES\"<<endl;\n        else\n            cout<<\"NO\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble hero[20];\nbool visited[20]={false};\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if ( visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    visited[i]=true;\n    if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\ninline double dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\ninline int solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n    hero[i]=dist(mx-x[i],my-y[i]);\n    if ( hero[i]+eps>adj[MAOU][i])return false;\n    visited[i]=false;\n  }\n  \n  rep(i,n){\n    visited[i]=true;\n    if ( backTrack(i,hero[i],1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(scanf(\"%d%d%d%d%d\",&n,&mx,&my,&rx,&ry) && n){\n    int x[n],y[n];\n    rep(i,n)scanf(\"%d%d\",&x[i],&y[i]);\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble hero[20];\nbool visited[20]={false};\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if ( visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    visited[i]=true;\n    if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\ninline double mysqrt(double val){\n  double l=0,r=4000000,ret,mid=0;\n  while(l+eps<r){\n    mid=(l+r)/2;\n    if ( val-mid*mid>0)l=mid+eps;\n    else r=mid-eps,ret=mid;\n  }\n  return ret;\n}\n\ninline double dist(int x,int y){\n  //return (x*x+y*y);\n  return mysqrt(x*x+y*y);\n}\n\ninline int solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n    hero[i]=dist(mx-x[i],my-y[i]);\n    if ( hero[i]>=adj[MAOU][i])return false;\n    visited[i]=false;\n  }\n  \n  rep(i,n){\n    visited[i]=true;\n    if ( backTrack(i,hero[i],1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(scanf(\"%d%d%d%d%d\",&n,&mx,&my,&rx,&ry) && n){\n    int x[n],y[n];\n    rep(i,n)scanf(\"%d%d\",&x[i],&y[i]);\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n  //cout << mysqrt(2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint n,hx,hy,dx,dy;\n\nfloat dist[21][21];\nstruct Crystal{\n    int x,y;\n    float dist;\n    bool visited;\n};\nCrystal crystals[21];//[0]????????????????????????????????????\n\nbool rec(int s,float t){\n    crystals[s].visited=true;\n    bool b=true;\n    for(int i=1;i<=n;i++){\n        if(crystals[i].visited) continue;\n        if(dist[i][s]+t<crystals[i].dist){\n            if(rec(i,dist[i][s]+t)){\n                //cout << s << \",\";\n                return true;\n            }else{\n                b=false;\n            }\n        }else{\n            //???????????????????????????????????£??????\n            crystals[s].visited=false;\n            return false;\n        }\n    }\n    //??¨???????????????????????????????????????\n    //cout << s << \",\";\n    crystals[s].visited=false;\n    return b;\n}\n\nint main(void){\n    while(cin >> n >> crystals[0].x >> crystals[0].y >> dx >> dy,n){\n        for(int i=1;i<=n;i++){\n            cin >> crystals[i].x >> crystals[i].y;\n            crystals[i].dist=sqrt(pow(crystals[i].x-dx,2)+pow(crystals[i].y-dy,2));\n        }\n        sort(crystals+1,crystals+n+1,[](const Crystal& a, const Crystal& b){return (a.dist==b.dist)?(a.x<b.x):(a.dist)<(b.dist);});\n        for(int i=0;i<=n;i++){\n            crystals[i].visited=false;\n            for(int k=i+1;k<=n;k++){\n                dist[i][k]=dist[k][i]=sqrt(pow(crystals[i].x-crystals[k].x,2)+pow(crystals[i].y-crystals[k].y,2));\n            }\n        }\n        if(rec(0,0)){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int INF=100000000;\n// e_ÔÌ£\ndouble dist[22][22];\n// e_ÌÀW\nvector<pair<int,int> > points;\nint n,hx,hy,dx,dy;\nbool ok=false;\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\n// »ÝÌê©çßÄÂ\\ÈÅ¬ÊßbðÔ·\nvoid dfs(int s,int cp,double passedSec){\n    if(ok)\n        return;\n    else if(s==0){\n        ok=true;\n        return;\n    }\n    for(int i = 0; i < n; i++){\n        // Ü¾rbgª1ÈçÎ\n        if((s>>i)&1){\n            // áCªB·éOÉTõÂ\\©Ç¤©ð`FbN\n            double dt=dist[cp][i];\n            // ¤©çÚ®æÖÌ¼aðæ¾\n            double r=dist[n+1][i];\n            // àµ¼aªz¦Ä¢½ç\n            if(dt+passedSec>r||EQ(dt+passedSec,r))\n                return;\n            dfs((s&(~(1<<i))),i,dt+passedSec);\n        }\n    }\n}\n\n\nint main(){\n    while(cin>>n>>hx>>hy>>dx>>dy&&!(n==0&&hx==0&&hy==0&&dx==0&&dy==0)){\n        points.clear();\n        ok=false;\n        // EÒÌúÊu\n        for(int i = 0; i < n; i++){\n            pair<int,int> p;\n            cin>>p.second>>p.first;\n            points.push_back(p);\n        }\n        points.push_back(make_pair(hy,hx));\n        points.push_back(make_pair(dy,dx));\n\n        for(int i = 0; i < points.size(); i++){\n            for(int j = 0; j < points.size(); j++){\n                dist[i][j]=sqrt((double)(points[i].first-points[j].first)*(points[i].first-points[j].first)\n                    +(points[i].second-points[j].second)*(points[i].second-points[j].second));\n            }\n        }\n        dfs(((1<<n)-1),n,0);\n        if(ok)\n            cout<<\"YES\"<<endl;\n        else\n            cout<<\"NO\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <tr1/unordered_map>\n\nusing namespace std;\n\n#define fi first\n#define se second\n\nint N;\nint hx, hy, mx, my;\ntypedef pair<double, double> P;\nP cs[21];\n\n#define SQ(x) ((x)*(x))\ninline double dist(P a, P b) {\n  return sqrt(SQ(a.fi-b.fi) + SQ(a.se-b.se));\n}\n\nunordered_map<int, double> umap;\n\ndouble G[22][22];\nbool dfs(int S, int now, double cost) {\n  \n  if(S == (1<<N)-1) {\n    return true;\n  }\n  \n  umap[S] = cost;\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(G[i][N+1] <= cost+G[now][i]) return false;\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(S >> i & 1) continue;\n    if(umap.count(S|(1<<i)) && umap[S|(1<<i)] <= cost+G[now][i]) continue;\n    if(dfs(S|(1<<i), i, cost+G[now][i])) return true;\n  }\n  \n  return false;\n}\n\nbool solve() {\n  \n  for(int i=0; i<N; i++) {\n    for(int j=i+1; j<N; j++) {\n      G[i][j] = G[j][i] = dist(cs[i], cs[j]);\n    }\n    G[N][i] = G[i][N] = dist(P(hx, hy), cs[i]);\n    G[N+1][i] = G[i][N+1] = dist(P(mx, my), cs[i]);\n  }\n  \n  for(int i=0; i<N; i++) {\n    if(dfs(1<<i, i, 0.)) return true;\n  }\n  \n  return false;\n}\n\nint main() {\n  while(1) {\n    cin >> N >> hx >> hy >> mx >> my;\n    if(!N) break;\n    for(int i=0; i<N; i++) {\n      cin >> cs[i].fi >> cs[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n\nconst int MAXN = 20;\nconst double inf = 1e100;\nconst double eps = 1e-8;\n\nint N;\nP H, D;\nvector<P> ps;\ndouble dp[1<<MAXN][MAXN+1];\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, P p) {\n  double d = abs(D - p);\n  return !equals(d, t) && d > t;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy && \n\t( N | hx | hy | dx | dy ) ) {\n    H = P(hx,hy);\n    D = P(dx,dy);\n    ps.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    fill(dp[0], dp[1<<MAXN], inf);\n    dp[0][N] = 0;\n    for(int i = 0; i < (1<<N); ++i) {\n      for(int j = 0; j <= N; ++j) {\n\tif(dp[i][j] == inf) continue;\n\tfor(int k = 0; k < N; ++k) {\n\t  if(i & (1<<k)) continue;\n\t  P s = (j == N) ? H : ps[j];\n\t  P &t = ps[k];\n\t  double dist = abs(t - s);\n\t  double nt = dp[i][j] + dist;\n\t  if(!canExist(nt, t)) continue;\n\t  dp[i|(1<<k)][k] = min(dp[i|(1<<k)][k], nt);\n\t}\n      }\n    }\n    string res = \"NO\";\n    for(int i = 0; i < N; ++i) {\n      if(dp[(1<<N)-1][i] != inf) {\n\tres = \"YES\";\n\tbreak;\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <queue>\n#define MAXNUM 2000\n#define zero 1000 // (1000,1000)が原点\nusing namespace std;\n\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\n\nconst int ddx[] = {-1,0,1,0} ,ddy[] = {0,-1,0,1};\nint shoki[MAXNUM + 1][MAXNUM + 1], p[20][20], cx[20], cy[20], hx, hy, n;\n\nint solve(int pre){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= shoki[cy[i] + zero][cx[i] + zero]) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit){ // 未探索の位置にあるクリスタル\n\t\t\tif(pre == -1 && dist(hx,hy,cx[i],cy[i]) + sum < shoki[cy[i] + zero][cx[i] + zero]){ // １つ目のクリスタルをとる\n\t\t\t\tsum += dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tbit += 1 << i;\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbit -= 1 << i;\n\t\t\t\tsum -= dist(hx,hy,cx[i],cy[i]);\n\t\t\t}\n\t\t\telse if(pre != -1 && p[pre][i] + sum < shoki[cy[i] + zero][cx[i] + zero]){ // ２〜ｎつ目のクリスタルを取る\n\t\t\t\tbit += 1 << i;\n\t\t\t\tsum += p[pre][i];\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tsum -= p[pre][i];\n\t\t\t\tbit -= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint  dx, dy, x, y, count, i, j, k;\n\tqueue<int> qx, qy;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(i == j)\n\t\t\t\t\tp[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tp[i][j] = dist(cx[i],cy[i],cx[j],cy[j]);\n\t\t\t}\n\t\t}\n\t\tmemset(shoki,-1,sizeof(shoki));\n\t\tqx.push(dx + zero),qy.push(dy + zero);\n\t\tshoki[dy + zero][dx + zero] = 0;\n\t\twhile(shoki[0][0] == -1 || shoki[MAXNUM][MAXNUM] == -1 || shoki[MAXNUM][0] == -1 || shoki[0][MAXNUM] == -1){\n\t\t\twhile(qx.size()){\n\t\t\t\tx = qx.front();\n\t\t\t\ty = qy.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\t\tif(x + ddx[i] + zero >= 0 && x + ddx[i] + zero <= MAXNUM && y + ddy[i] + zero >= 0 && y + ddy[i] + zero <= MAXNUM && shoki[y + ddy[i] + zero][x + ddx[i] + zero] == -1){\n\t\t\t\t\t\tqx.push(x + ddx[i] + zero),qy.push(y + ddy[i] + zero);\n\t\t\t\t\t\tshoki[y + ddy[i] + zero][x + ddx[i] + zero] = shoki[y + zero][x + zero] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(solve(-1))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second \n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n\ndouble tt[1<<20][22];\ndouble cost[22][22];\ndouble tlimit[22];\nint xx[22];\nint cx[22], cy[22];\nint det[22];\n\nint main(){\n\tREP(i,22){\n\t\txx[i] = 1<<i;\n\t}\n\twhile(1){\n\t\tint dx,dy,n;\n\t\tcin>>n>>cx[0]>>cy[0]>>dx>>dy;\n\t\tmemset(tt,0, sizeof(tt));\n\t\tmemset(det,0, sizeof(det));\n\t\tint all = (1<<(n+1))-1;\n\t\tFOR(i,1,n+1)cin >> cx[i] >> cy[i];\n\t\tREP(i, n+1){\n\t\t\ttlimit[i] = sqrt(pow(cx[i]*1.0-dx*1.0,2.0)+pow(cy[i]*1.0-dy*1.0,2.0));\n\t\t\tREP(j,n+1){\n\t\t\t\tcost[i][j] = sqrt(pow(cx[i]*1.0-cx[j]*1.0,2.0)+pow(cy[i]*1.0-cy[j]*1.0,2.0));\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<double, pair<int, int> >, vector<pair<double, pair<int, int> > >, greater<pair<double, pair<int, int> > > > q;\n\t\tq.push(MT(0.0, 1, 0));\n\t\tint flag = 0;\n\t\twhile(!q.empty()){\n\t\t\tpair<double, PII> tmp = q.top();\n\t\t\tif(tt[tmp.T2][tmp.T3] != 0)continue;\n\t\t\ttt[tmp.T2][tmp.T3] = tmp.T1;\n\t\t\tq.pop();\n\t\t\tFOR(i,1,n+1){\n\t\t\t\tif(!(tmp.T2 & xx[i])){\n\t\t\t\t\tif(tmp.T1+cost[tmp.T3][i]-tlimit[i]+EPS<0){\n\t\t\t\t\t\tif((tmp.T2|xx[i]) == all){\n\t\t\t\t\t\t\tflag = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse q.push(MT(tmp.T1+cost[tmp.T3][i], tmp.T2|xx[i], i));\n\t\t\t\t\t}\n\t\t\t\t\tif((tmp.T2|xx[i]) == all)flag++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==-1 || flag == n)break;\n\t\t}\n\t\tif(flag == -1)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return (conj(a)*b).real();}\nFP crs(P a,P b){return (conj(a)*b).imag();}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgtin(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lftin(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frtin(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bckin(T a){return shift(a,TOP,FRT,BTM,BCK);}\n\nint n;\nint hx,hy,mx,my;\nint cx[20],cy[20];\ndouble cost[20][1<<20];\n\nbool dfs(int cv,int vis,double cc){\n  if(cost[cv][vis]<=cc+EPS) return false;\n  if(vis==(1<<n)-1) return true;\n  //cout << cv << ' ' << vis << ' ' << cc << endl;\n  cost[cv][vis] = cc;\n  rep(i,n){\n    if((vis>>i)&1) continue;\n    if(cc+abs(pt(cx[i],cy[i])-pt(cx[cv],cy[cv]))+EPS>\n       abs(pt(cx[i],cy[i])-pt(mx,my))) return false;\n  }\n  \n  rep(i,n){\n    if((vis>>i)&1) continue;\n    if(dfs(i,vis|1<<i,cc+abs(P(cx[cv],cy[cv])-P(cx[i],cy[i]))))\n      return true;\n  }\n    \n  return false;\n}\n\nvoid solve(){\n  cin >> hx >> hy >> mx >> my;\n  rep(i,n) cin >> cx[i] >> cy[i];\n  rep(i,n)rep(j,(1<<n)) cost[i][j] = 1<<20;\n  rep(i,n){\n    if(abs(P(mx,my)-P(cx[i],cy[i]))>\n       abs(P(cx[i],cy[i])-P(hx,hy))+EPS &&\n       dfs(i,1<<i,abs(P(cx[i],cy[i])-P(hx,hy)))){\n      cout << \"YES\" << endl;\n      return;\n    }\n  }\n  cout << \"NO\" << endl;\n}\n\nint main(int argc, char *argv[]){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nclass Compare {\n  int monster_x;\n  int monster_y;\npublic:\n  Compare(int monster_x,int monster_y)\n    : monster_x(monster_x), monster_y(monster_y) {}\n  bool operator()(const P& ci,const P& cj) const{\n    int dist_i = (ci.first - monster_x) * (ci.first - monster_x)\n      + (ci.second - monster_y) * (ci.second - monster_y);\n    int dist_j = (cj.first - monster_x) * (cj.first - monster_x)\n      + (cj.second - monster_y) * (cj.second - monster_y);\n    return dist_i < dist_j;\n  }\n};\n\nclass State{\n  int x;\n  int y;\n  double dist;\n};\n\nbool dfs(int hero_x,\n         int hero_y,\n         double current_time,\n         int S,\n         int monster_x,\n         int monster_y,\n         const vector<P>& cristals){\n  bool res = false;\n\n  if(S == (1<<cristals.size()) - 1) return true;\n  for(int i=0;i<cristals.size();i++){\n    if(S & (1<<i)) continue;\n    double add_time = sqrt((hero_x - cristals[i].first) * (hero_x - cristals[i].first)\n                           + (hero_y - cristals[i].second) * (hero_y - cristals[i].second));\n    \n    double impurity_arrive_time = sqrt((monster_x - cristals[i].first) * (monster_x - cristals[i].first)\n                                       + (monster_y - cristals[i].second) * (monster_y - cristals[i].second));\n    if(current_time + add_time >= impurity_arrive_time){\n      return false;\n    }\n    \n    res |= dfs(cristals[i].first,cristals[i].second,current_time + add_time,\n               S | (1<<i),monster_x,monster_y,cristals);\n    if(res) return res;\n  }\n  return res;\n}\n\nint main(){\n  int total_cristals;\n  int hero_x;\n  int hero_y;\n  int monster_x;\n  int monster_y;\n  while(~scanf(\"%d %d %d %d %d\",\n               &total_cristals,\n               &hero_x,\n               &hero_y,\n               &monster_x,\n               &monster_y)){\n    if(total_cristals == 0 && hero_x == 0 && hero_y == 0\n       && monster_x == 0 && monster_y == 0) break;\n    vector<P> cristals;\n    for(int cristal_i = 0; cristal_i < total_cristals; cristal_i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cristals.push_back(P(x,y));\n    }\n    // Compare comp(monster_x,monster_y);\n    // sort(cristals.begin(),cristals.end(),comp);\n    printf(\"%s\\n\", dfs(hero_x,hero_y,0,0,monster_x,monster_y,cristals)\n           ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<double,int> P;\n\nint xs[21];\nint ys[21];\ndouble h[21];\nint n;\ndouble Hypot(int x, int y)\n{\n\treturn sqrt(x*x+y*y);\n}\nbool ok(int x, int y, int done, double t)\n{\n\tif(done+1==(1<<n))\n\t{\n\t\treturn true;\n\t}\n\n\tvector<P> q;\n\tfor(int i=0;i<n;i++){\n\t\tif(done&(1<<i))continue;\n\t\tdouble d=t+Hypot(xs[i]-x,ys[i]-y);\n\t\tif(d>=h[i]){\n\t\t\treturn false;\n\t\t}\n\t\tq.push_back(P(d,i));\n\t}\n\tsort(q.begin(),q.end());\n\tfor(auto p : q)\n\t{\n\t\tint i=p.second;\n\t\tif(ok(xs[i],ys[i],done|(1<<i),p.first)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid exec()\n{\n\tint hx,hy,dx,dy;\n\tcin >> n >> hx >> hy >> dx >> dy;\n\tif((n|hx|hy|dx|dy)==0){\n\t\texit(1);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin >> xs[i] >> ys[i];\n\t\th[i]=Hypot(xs[i]-dx,ys[i]-dy);\n\t}\n\tif(ok(hx,hy,0,0)){\n\t\tcout << \"YES\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"NO\" << endl;\n\t}\n}\nint main() {\n\twhile(1)exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint n;\ndouble item_dist[21][21];\ndouble boss_dist[20];\n\ndouble distance(pii a, pii b) {\n    return hypot(a.first - b.first, a.second - b.second);\n}\n\nbool dfs(int p, double t, int remain) {\n    if (remain == 0) return true;\n    REP(i, n) {\n        if (remain & (1 << i)) {\n            double next_t = t + item_dist[i][p];\n            bool reachable = true;\n            REP(j, n) {\n                if (remain & (1 << j)) {\n                    if (boss_dist[j] <= next_t + item_dist[i][j]) {\n                        reachable = false;\n                        break;\n                    }\n                }\n            }\n            if (reachable && dfs(i, next_t, remain & ~(1 << i))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int x, y, hx, hy;\n    while (cin >> n >> x >> y >> hx >> hy, n|x|y|hx|hy) {\n        fill_n((int *)item_dist, 21*21, 0);\n        fill_n((int *)boss_dist, 21*21, 0);\n\n        vector<pii> items;\n        REP(i, n) {\n            int a, b;\n            cin >> a >> b;\n            items.push_back({a, b});\n        }\n        items.push_back({x, y});\n        REP(i, n+1) {\n            FOR(j, i+1, n+1) {\n                item_dist[i][j] = item_dist[j][i] = distance(items[i], items[j]);\n            }\n            boss_dist[i] = distance(items[i], {hx, hy});\n        }\n\n        if (dfs(n, 0.0, (1 << n)-1)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\n// 1: a,b,cが反時計周りの順に並ぶ\n//-1: a,b,cが時計周りの順に並ぶ\n// 2: c,a,bの順に直線に並ぶ\n//-2: a,b,cの順に直線に並ぶ\n// 0: a,c,bの順に直線に並ぶ\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.b - l.a) / norm(l.a - l.b);\n\treturn l.a + t * (l.b - l.a);\n}\n\n//線対象の位置にある点\nPoint reflect(const Line &l, const Point &p) {\n\tPoint pr = proj(l, p);\n\treturn pr * 2.l - p;\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// 直線と直線の交点\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// 線分と線分の交点\n//　重なってる部分あるとassert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//先にisis_ssしてね\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// 線分と線分の交点\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine line_bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n//点と点の垂直二等分線　aを左に見ながら\nLine point_bisection(const Point&a, const Point&b) {\n\tconst Point cen((a + b) / 2.l);\n\tconst Point vec = (b - a)*Point(0, 1);\n\treturn Line(cen, cen + vec);\n}\n\n//三つの点からなる外心\nPoint outer_center(const vector<Point>&ps) {\n\tassert(ps.size() == 3);\n\tLine l1 = point_bisection(ps[0], ps[1]);\n\tLine l2 = point_bisection(ps[1], ps[2]);\n\n\treturn is_ll(l1, l2);\n}\n\n\n//三つの直線からなる内心\n//三つの直線が並行でないことは確かめといてね\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(line_bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(line_bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//三つの直線からなる傍心\n//三つの直線が並行でないことは確かめといてね\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(line_bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(line_bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:並行\n//c:並行でない\n//三つの直線から同距離の位置を求める。\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(line_bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(line_bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(line_bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n/*\n点が円の中にいるか\n0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const  Point& p, const Circle &cir) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n/*\n円lcが円rcの中にいるか\n0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//二つの円の重なり面積\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n\n\n//多角形(複数の点)の最小包含円をO(N=頂点数)で求めるアルゴリズム\n//同一直線上に三つの点がないこと\n#include<random>\nCircle welzl(vector<Point>ps) {\n\tstruct solver {\n\t\tCircle solve(vector<Point>&ps, vector<Point>&rs) {\n\t\t\tif (ps.empty() || rs.size() == 3) {\n\t\t\t\tif (rs.size() == 1) {\n\t\t\t\t\treturn Circle(Point(rs[0]), 0);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 2) {\n\t\t\t\t\treturn Circle((rs[0] + rs[1]) / 2.0l, abs(rs[1] - rs[0]) / 2);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 3) {\n\t\t\t\t\tvector<Line> ls(3);\n\t\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\t\tls[i] = Line(rs[i], rs[(i + 1) % 3]);\n\t\t\t\t\t}\n\t\t\t\t\tPoint center = outer_center(rs);\n\t\t\t\t\treturn Circle(center, abs(center - rs[0]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn Circle(Point(), 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tPoint p_ba = ps.back();\n\t\t\t\tps.pop_back();\n\t\t\t\tCircle d = solve(ps, rs);\n\t\t\t\tps.push_back(p_ba);\n\t\t\t\tif (is_in_Circle(d, p_ba)) {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trs.push_back(p_ba);\n\t\t\t\t\tps.pop_back();\n\t\t\t\t\tauto ans = solve(ps, rs);\n\t\t\t\t\tps.push_back(p_ba);\n\t\t\t\t\trs.pop_back();\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}so;\n\tstd::random_device rd;\n\tstd::mt19937 mt(rd());\n\tshuffle(ps.begin(), ps.end(), mt);\n\tvector<Point>rs;\n\tCircle ans = so.solve(ps, rs);\n\treturn ans;\n}\n// 面積\nld get_area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tfor (int j = 0; j<n; ++j) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n//点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\n\n\nint main() {\n\twhile (true) {\n\t\tint N; Point start_po;\n\t\tvector<Point>pos;\n\t\t{\n\t\t\tld Hx, Hy, Sx, Sy;\n\t\t\tcin >> N >> Hx >> Hy >> Sx >> Sy;\n\t\t\tif(!N)return 0;\n\t\t\tstart_po = Point(Hx - Sx, Hy - Sy);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tld x, y; cin >> x >> y;\n\t\t\t\tpos.emplace_back(x - Sx, y - Sy);\n\t\t\t}\n\t\t}\n\t\tvector<vector<ld>>memo(N, vector<ld>(1 << N, 1e18));\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tld atime = abs(pos[i] - start_po);\n\t\t\tif (atime + eps < abs(pos[i])) {\n\t\t\t\tbitset<20>bs;\n\t\t\t\tbs[i] = true;\n\t\t\t\tmemo[i][bs.to_ulong()] = atime;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << N); ++i) {\n\t\t\tfor (int now = 0; now < N; ++now) {\n\t\t\t\tif (memo[now][i]>1e17)continue;\n\n\t\t\t\tbitset<20>bs(i);\n\t\t\t\tfor (int next = 0; next < N; ++next) {\n\t\t\t\t\tif (!bs[next]) {\n\t\t\t\t\t\tbs[next] = true;\n\n\t\t\t\t\t\tld next_time = abs(pos[next] - pos[now]) + memo[now][i];\n\t\t\t\t\t\tif (next_time + eps < abs(pos[next])) {\n\t\t\t\t\t\t\tmemo[next][bs.to_ulong()] = min(memo[next][bs.to_ulong()], next_time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbs[next] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (memo[i][(1 << N) - 1]<1e17)ok = true;\n\t\t}\n\t\tif (ok)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define EPS 1e-10\nusing namespace std;\n\nbool visited[21];\nint n,hx,hy,dx,dy,cx[21],cy[21];\n\nbool dfs(int x , double day , int count){ //xツづ債個サツ催敖づ個暗環置\n  bool judge = false;\n  visited[x] = true;\n  if(count == n) return true;\n  count++;\n  for(int i= 0;i<=n;i++){\n    double t;\n    if(visited[i]) continue;\n    t = day + sqrt((cx[i] - cx[x])*(cx[i] - cx[x]) + (cy[i] - cy[x])*(cy[i] - cy[x]));\n    if((dx - cx[i])*(dx - cx[i]) + (dy - cy[i])*(dy - cy[i]) < t*t + EPS ) return false;\n  }    \n  for(int i= 0;i<=n;i++){\n    double d,t;\n    if(visited[i]) continue;\n    t = day + sqrt((cx[i] - cx[x])*(cx[i] - cx[x]) + (cy[i] - cy[x])*(cy[i] - cy[x]));\n    judge |= dfs(i,t,count);\n    visited[i] = false;\n    if(judge) break;\n  }\n  return judge;\n}\n    \nint main(){\n  while(1){\n    cin >> n >> hx >> hy >> dx >> dy;\n    if(!(n|hx|hy|dx|dy)) break;\n    dx -= hx;dy -= hy;\n    cx[0] = cy[0] = 0;\n    for(int i=1;i <= n;i++){\n      int tx,ty;cin >> tx >> ty;\n      cx[i] = tx - hx;cy[i] = ty - hy;\n    }\n    hx = hy = 0;\n    for(int i=0;i<21;i++) visited[i] = false;\n    if(dfs(0,0,0)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<map>\n#include<cmath>\n#include<algorithm>\n#define X real()\n#define Y imag()\nusing namespace std;\n\ntypedef complex<double> P;\n\nint n;\nP ph,pd;\nvector<P>items;\n\ndouble dist(P p1,P p2){\n  P p = p1 - p2;\n  return sqrt(p.X * p.X + p.Y * p.Y);\n}\n\nbool dfs(P p,int state,int time){\n  if(__builtin_popcount(state) == n)return true;\n  for(int i = 0 ; i < n ; i++){\n    if((state >> i)&1)continue;\n    int nstate = state | (1 << i);\n    double d = dist(p,items[i]);\n    int ntime = time + ceil(d);\n\n    bool f = false;\n    for(int j = 0 ; j < n ; j++){\n      if((state >> j)&1)continue;\n      if(ntime >= dist(pd,items[j])){f = true;break;};\n    }\n    if(f)break;\n\n    if(dfs(items[i],nstate,ntime))return true;\n  }\n  return false;\n}\n\nvoid input(){\n  items.clear();\n  for(int i = 0 ; i < n ; i++){\n    P p;\n    cin >> p.X >> p.Y;\n    items.push_back(p);\n  }\n}\n\nint main(){\n  while(1){\n    cin >> n >> ph.X >> ph.Y >> pd.X >> pd.Y;\n    if(n == 0 && ph.X == 0 && ph.Y == 0 && pd.X == 0 && pd.Y == 0)break;\n    input();\n    cout << (dfs(ph,0,0)?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define INF 0x7FFFFFFF\n#define dist(x1,y1,x2,y2) sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))\n\nint n;\ndouble cx[20], cy[20], hx, hy, dx, dy, S[1 << 20];\n\nint solve(double x,double y,int bit,double sum){\n\tint i;\n\tif(S[bit] > sum)\n\t\tS[bit] = sum;\n\telse\n\t\treturn 0;\n\tif(bit == 0) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & bit) && sum >= dist(cx[i],cy[i],dx,dy)) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(((1 << i) & bit) && sum + dist(x,y,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i]) && solve(cx[i],cy[i],bit ^ (1 << i),sum + dist(x,y,cx[i],cy[i])))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(void){\n\tint i;\n\twhile(1){\n\t\tscanf(\"%d%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < 1 << n;i++)\n\t\t\tS[i] = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tif(solve(hx,hy,(1 << n) - 1,0))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\ndouble INF=1e16;\ndouble EPS=1e-9;\nclass Main{\n\tpublic:\n\n\n\tint n;double hx,hy,dx,dy;\n\tvector<double> cx,cy;\n\tvector<vector<double>> ds;\n\n\tbool dfs(int v,int bit,double t){\n\t\tif(bit==(1<<n)-1)return true;\n\t\tbool ok=false;\n\t\t\n\t\tREP(i,n)if(!((bit>>i)&1)){\n\t\t\tdouble d=hypot(cx[i]-cx[v],cy[i]-cx[v]);\n\t\t\tif(d+t+EPS<hypot(cx[i]-dx,cy[i]-dy))ok|=dfs(i,bit|1<<i,d+t);\n\t\t}\n\t\treturn ok;\n\t}\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){ cin >> n >> hx >> hy >> dx >> dy;if(n==0)break;\n\t\t\tcx=vector<double>(n);cy=vector<double>(n);REP(i,n) cin >> cx[i] >> cy[i];\n\n\t\t\tbool ok=false;\n\t\t\tREP(i,n){\n\t\t\t\tdouble d=hypot(cx[i]-hx,cy[i]-hy);\n\t\t\t\tif(d+EPS<hypot(cx[i]-dx,cy[i]-dy))ok|=dfs(i,1<<i,d);\n\t\t\t}\n\t\t\tcout << (ok?\"YES\":\"NO\")<<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\nconst int INF=100000000;\n\n\nint n;\nint hx,hy;\nint dx,dy;\nint cx[21],cy[21];\nbool flag[21];\n\ndouble dist(int x0,int y0,int x1,int y1) {\n\tdouble d = (x0-x1)*(x0-x1) + (y0-y1)*(y0-y1);\n\treturn sqrt(d);\n}\n\nint pow2(int a) {\n\treturn a*a;\n}\n\n//クリスタルの位置と何日目からとることができるか\nbool check(int x,int y,int d) {\n\treturn (pow2(dx-x)+pow2(dy-y)) > pow2(d);\n}\n\n//現在位置,何日目\nbool dfs(int x,int y,int d,int cnt) {\n\t//printf(\"[debug] %d,%d,%d,%d\\n\",x,y,d,cnt);\n\tif(cnt==n) return true;\n\trep(i,n) {\n\t\tif(!flag[i]) {\n\t\t\tflag[i]=true;\n\t\t\td += (int)dist(x,y,cx[i],cy[i])+1;\n\t\t\tif(check(cx[i],cy[i],d)) {\n\t\t\t\treturn dfs(cx[i],cy[i],d,cnt+1);\n\t\t\t}\n\t\t\tflag[i]=false;\n\t\t}\n\t}\n\treturn false;\n\n\n}\n\n\nvoid solve() {\n\trep(i,n) cin>>cx[i]>>cy[i];\n\trep(i,21) flag[i]=false;\n\n\tif(dfs(hx,hy,0,0)) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n}\n\nint main() {\n\twhile (cin>>n>>hx>>hy>>dx>>dy)\n\t{\n\t\tif(n+hx+hy+dx+dy==0) return 0;\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nbool f = false;\nstruct crystal{\n\tint cx;\n\tint cy;\n\tdouble dis;\n};\nbool used[20];\ncrystal cs[20];\nint n, hx, hy, dx, dy;\n\ndouble distance(int x1, int y1, int x2, int y2){\n\tdouble dx = x2 - x1;\n\tdouble dy = y2 - y1;\n\treturn sqrt(dx*dx+dy*dy);\n}\n\nvoid move(int x, int y, int n, double time){\n\tif(n == 0){\n\t\tf = true;\n\t}\n\tif(f) return;\n\tbool f2 = false;\n\tfor(int i = 0; i < n; i++){\n\t\tif(!used[i]){\n\t\t\tif(time + distance(x, y, cs[i].cx, cs[i].cy) > cs[i].dis - 0.0000001){\n\t\t\t\tf2 = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(f2) return;\n\tfor(int i = 0; i < n; i++){\n\t\tdouble d = distance(cs[i].cx , cs[i].cy, x, y);\n\t\tif(!used[i]){\n\t\t\tused[i] = true;\n\t\t\tmove(cs[i].cx, cs[i].cy, n - 1, time + distance(cs[i].cx, cs[i].cy, x, y));\n\t\t\tused[i] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> n >> hx >> hy >> dx >> dy){\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> cs[i].cx >> cs[i].cy;\n\t\t\tused[i] = false;\n\t\t\tcs[i].dis = distance(cs[i].cx, cs[i].cy, dx, dy);\n\t\t}\n\t\tf = false;\n\t\tmove(hx, hy, n, 0);\n\t\tif(f) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps=1e-10;\ndouble adj[21][21];\ndouble hero[20];\nbool visited[20]={false};\n#define MAOU 20\n\nbool backTrack(int last,double r,int now,int n,\n\t   bool *visited){\n  rep(i,n){\n    if ( visited[i]==false && adj[MAOU][i]<=r)return false;\n    if ( visited[i]==false &&  adj[MAOU][i]<=r+adj[last][i])return false;\n  }\n  if ( now == n)return true;\n  \n  rep(i,n){\n    if ( visited[i]==true)continue;\n    visited[i]=true;\n    if ( backTrack(i,r+adj[last][i],now+1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\ndouble dist(int x,int y){\n  return sqrt(x*x+y*y);\n}\n\nint solve(int n,int *x,int *y,int rx,int ry,int mx,int my){\n  rep(i,n){\n    adj[i][i]=0;\n    adj[MAOU][i]=adj[i][MAOU]=dist(x[i]-rx,y[i]-ry);\n    REP(j,i+1,n){\n      adj[i][j]=adj[j][i]=dist(x[i]-x[j],y[i]-y[j]);\n    }\n    hero[i]=dist(mx-x[i],my-y[i]);\n    if ( hero[i]>=adj[MAOU][i])return false;\n    visited[i]=false;\n  }\n  \n  rep(i,n){\n    visited[i]=true;\n    if ( backTrack(i,hero[i],1,n,visited))return true;\n    visited[i]=false;\n  }\n  return false;\n}\n\nmain(){\n  int n,mx,my,rx,ry;\n  while(scanf(\"%d%d%d%d%d\",&n,&mx,&my,&rx,&ry) && n){\n    int x[n],y[n];\n    rep(i,n)scanf(\"%d%d\",&x[i],&y[i]);\n    if ( solve(n,x,y,rx,ry,mx,my))puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cfloat>\n#include <cmath>\n#include <vector>\n#include <map>\n \nusing namespace std;\n \n#define fi first\n#define se second\ntypedef pair<double,double> P;\n \n#define MAX (21)\n#define INF (DBL_MAX/4)\n \ndouble G[MAX][MAX];\n \nint n;\nvector<P> crys;\nP h, d;\n \ndouble dist(P p1, P p2){\n  return sqrt(pow(p1.fi-p2.fi, 2.) + pow(p1.se-p2.se, 2.));\n}\n \nvoid makeEdge() {\n  for(int i=0; i<n; i++) {\n    G[i][i] = 0;\n    for(int j=i+1; j<n; j++) {\n      G[i][j] = G[j][i] = dist(crys[i], crys[j]);\n    }\n  }\n}\n \n\nvoid printbit(int x){\n  for(int i=0;i<n;i++){\n    cout<<((x>>i)&1);\n\n  }\n  cout<<endl;\n}\n\n \ntypedef unsigned long long ull;\nmap<ull, double> dp;\n\ndouble dfs(int S, int idx, double cost) {\n  \n  if(S==(1<<n)-1) {\n    return dp[S] = cost;\n  }\n  \n  dp[S] = cost;\n  \n  for(int i=0; i<n; i++){\n    if((S>>i)&1) continue;\n    double ncost = cost + G[idx][i];\n    double nS = S|(1<<i);\n    if(ncost >= dist(crys[i], d)) return dp[S] = INF;\n    else {\n      if(dp.count(nS) && dp[nS] < ncost) continue;\n      dp[S] = min(dp[S], dfs(nS, i, ncost));\n      if(dp[S]==INF) return INF;\n    }\n  }\n  \n  return dp[S];\n}\n \nbool solve() {\n   \n  makeEdge();\n  \n  dp.clear();\n  dp[0] = INF;\n  for(int i=0; i<n; i++) {\n    if(dist(h, crys[i]) >= dist(crys[i], d)) continue;\n    dp[0] = min(dfs(1<<i, i, dist(h, crys[i])), dp[0]);\n  }\n  if(!dp.count((1<<n)-1)) return false;\n  if(dp[0]>=INF) return false;\n  return true;\n}\n \nint main(){\n  while(true){\n    crys.clear();\n    cin >> n >> h.fi >> h.se >> d.fi >> d.se;\n    if(!n && !h.fi && !h.se && !d.fi && !d.se){\n      break;\n    }\n    crys.resize(n);\n    for(int i=0; i<n; i++){\n      cin >> crys[i].fi >> crys[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-9;\n\ntypedef pair<xy_t, bool> dat;\n\nnamespace std{\n\tbool operator < (const xy_t &a, const xy_t &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nint n, hx, hy, dx, dy;\nxy_t points[21];\ndouble dis[1 << 21];\nmap<P, bool> bad;\nmap<P, int> mp;\n\nbool dfs(double t, int v, int st){\n\tif(st == (1 << (n + 1)) - 1) return true;\n\tif(bad[P(v, st)]) return false;\n\tif(mp[P(v, st)] != 0 && (int)t > mp[P(v, st)]) return false;\n\tmp[P(v, st)] = (int)t;\n\n\n\tbool res = false;\n\tfor(int i = 1; i < n + 1; i++){\n\t\tif(!(st & (1 << i))){\n\t\t\tdouble nt = t + abs(points[i] - points[v]);\n\t\t\tif(nt < abs(points[i] - xy_t(dx, dy)) && nt < dis[st | (1 << i)]) res |= dfs(nt, i, st | (1 << i));\n\t\t}\n\t\tif(res) return true;\n\t}\n\tbad[P(v, st)] = true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> n >> hx >> hy >> dx >> dy && (n || hx || hy || dx || dy)){\n\t\tbad.clear();\n\t\tpoints[0] = xy_t(hx, hy);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoints[i] = xy_t(x, y);\n\t\t}\n\t\tfor(int i = 1; i < (1 <<( n + 1)); i++){\n\t\t\tdouble d = 1e10;\n\t\t\tfor(int j = 0; j < n + 1; j++){\n\t\t\t\tif(!(i & (1 << j))) d = min(d, abs(points[j] - xy_t(dx, dy)));\n\t\t\t}\n\t\t\tdis[i] = d;\n\t\t}\n\t\tif(dfs(0.0, 0, 1)) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cmath>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < int(n); ++i)\n\nint x[30], y[30];\ndouble mem[1<<20][21];\n\nint main() {\n  int n, hx, hy, dx, dy;\n  for (;;) {\n    cin >> n >> hx >> hy >> dx >> dy;\n    if (n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) break;\n    rep (i, 1 << n) rep (j, n + 1) mem[i][j] = 1e+10;\n    rep (i, n) cin >> x[i] >> y[i];\n    rep (i, n) x[i] -= dx;\n    rep (i, n) y[i] -= dy;\n    x[n] = hx - dx;\n    y[n] = hy - dy;\n    priority_queue<pair<double, pair<int, int> > > que;\n    que.push(make_pair(0, make_pair((1 << n) - 1, n)));\n    while (!que.empty()) {\n      pair<double, pair<int, int> > now = que.top();\n      que.pop();\n      double time = -now.first;\n      int bit = now.second.first;\n      int pos = now.second.second;\n      if (bit == 0) {\n\tcout << \"YES\" << endl;\n\tgoto aaa;\n      }\n      if (mem[bit][pos] <= time) continue;\n      mem[bit][pos] = time;\n      //cout << time << \" \" << bit << \" \" << pos << endl;\n      rep (i, n) if (1 << i & bit) {\n\tdouble ntime = time + sqrt(pow(x[pos] - x[i], 2) + pow(x[pos] - x[i], 2));\n\tif (ntime >= sqrt(pow(x[i], 2) + pow(y[i], 2)) - 1e-8) break;\n\tque.push(make_pair(-ntime, make_pair(bit ^ 1 << i, i)));\n      }\n    }\n    cout << \"NO\" << endl;\n  aaa:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n#define EPS 1e-10\nint n;\ndouble sx,sy,tx,ty,px[20],py[20];\n\ndouble dis(double a,double b,double c,double d)\n{return sqrt((a-c)*(a-c)+(b-d)*(b-d));}\ndouble dis(int a,int b){return dis(px[a],py[a],px[b],py[b]);}\n\nbool dfs(int S,int pos,double cost){\n  if(S==(1<<n)-1)return true;\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(cost+dis(pos,i)>=dis(tx,ty,px[i],py[i]))return false;\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(cost+dis(pos,i)>=dis(tx,ty,px[i],py[i]))continue;\n    if( dfs(S|(1<<i),i,cost+dis(pos,i)) )return true;\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i=0;i<n;i++){\n    if(dis(sx,sy,px[i],py[i])>=dis(tx,ty,px[i],py[i]))continue;\n    if( dfs((1<<i),i,dis(sx,sy,px[i],py[i])) )return true;\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin>>n>>sx>>sy>>tx>>ty;\n    if(n==0)break;\n    for(int i=0;i<n;i++)cin>>px[i]>>py[i];\n    cout<<(solve()?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<map>\n\nusing namespace std;\nint n,dx,dy,hx,hy;\nint cx[21],cy[21];\nbool used[21];\nbool flag;\nvoid dfs(int v,int cnt,int cost){\n\tif(cnt==n)flag=true;\n\tif(flag)return;\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tint move=abs(cx[v]-cx[i])+abs(cy[v]-cy[i]);\n\t\t\tint ng=abs(dx-cx[i])+abs(dy-cy[i]);\n\t\t\tif(cost+move<ng){\n\t\t\t\tused[i]=true;\n\t\t\t\tdfs(i,cnt+1,cost+move);\n\t\t\t\tused[i]=false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n+hx+hy+dx+dy==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t\tcx[n]=hx,cy[n]=hy;\n\t\tflag=false;\n\t\tdfs(n,0,0);\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<string.h>\nusing namespace std;\n\nint n,dx,dy,hx,hy;\nbool done[20];\nint cx[20],cy[20];\n\nbool dfs(int x,int y,int now,double time,int k){\n//\tcout<<now<<\" \";\n//\tcout<<time<<endl;\n\tif(now>=0 && sqrt((double)(dx-cx[now])*(dx-cx[now])+(dy-cy[now])*(dy-cy[now]))<=time) return false;\n\tif(k==n) return true;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(done[i]) true;\n\t\tif(sqrt((double)(dx-cx[i])*(dx-cx[i])+(dy-cy[i])*(dy-cy[i]))<=time) return false;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tif(done[i]) continue;\n\t\tdone[i]=true;\n\t\tif(dfs(cx[i],cy[i],i,time+sqrt((double)(x-cx[i])*(x-cx[i])+(y-cy[i])*(y-cy[i])),k+1)) return true;\n\t\tdone[i]=false;\n\t}\n\treturn false;\n}\n\n\nint main()\n{\n\twhile(cin>>n>>hx>>hy>>dx>>dy && n!=0){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>cx[i]>>cy[i];\n\t\tmemset(done,false,sizeof(done));\n\t\tif(dfs(hx,hy,-1,0.0,0)) cout<<\"YES\\n\";\n\t\telse cout<<\"NO\\n\";\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<float> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<float> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nint n;\nVVD dp;\nVVB done;\nVVD dist;\nVD limit;\nvector<P> p_cristal;\n\nfloat euclid_distance(P p1, P p2)\n{\n\treturn sqrt(norm(p2 - p1));\n}\n\nfloat optimal_time(int status, int position)\n{\n\tif (done[status][position]) {\n\t\treturn dp[status][position];\n\t}\n\tif (!(status & BIT(position))) {\n\t\treturn INF;\n\t}\n\tint prev_status = status ^ BIT(position);\n\tif (prev_status == 0) {\n\t\t// Hero to this position\n\t\tdp[status][position] = dist[dist.size()-1][position];\n\t} else {\n\t\tFOR (prev_position, 0, n) {\n\t\t\tdp[status][position] = min(dp[status][position], optimal_time(prev_status, prev_position) + dist[prev_position][position]);\n\t\t}\n\t}\n\tdone[status][position] = true;\n\tif (dp[status][position] >= limit[position]) {\n\t\treturn dp[status][position] = INF;\n\t} else {\n\t\treturn dp[status][position];\n\t}\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n ^ hx ^ hy ^ dx ^ dy) {\n\t\tp_cristal.clear();\n\t\tREP (_, n) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tp_cristal.PB(P(x, y));\n\t\t}\n\t\tp_cristal.PB(P(hx, hy)); // NOTICE: Push Hero\n\t\tdist = VVD(p_cristal.size(), VD(p_cristal.size()));\n\t\tREP (i, p_cristal.size()) {\n\t\t\tREP (j, p_cristal.size()) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdist[i][j] = euclid_distance(p_cristal[i], p_cristal[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlimit = VD(p_cristal.size(), 0);\n\t\tREP (i, limit.size()) {\n\t\t\tlimit[i] = euclid_distance(p_cristal[i], P(dx, dy));\n\t\t}\n\n\t\tdp = VVD(BIT(n));\n\t\tdone = VVB(BIT(n), VB(n, false));\n\t\tFOR (c, 1, n) {\n\t\t\tif (c > 2) {\n\t\t\t\tint comb = (1 << (c-2)) - 1;\n\t\t\t\twhile (comb < 1 << n) {\n\t\t\t\t\t// Release memory\n\t\t\t\t\tVD().swap(dp[comb]);\n\t\t\t\t\tint lsb = comb & -comb;\n\t\t\t\t\tint upper = comb + lsb;\n\t\t\t\t\tint downer = ((comb & ~upper) / lsb) >> 1;\n\t\t\t\t\tcomb = upper | downer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint comb = (1 << c) - 1;\n\t\t\twhile (comb < 1 << n) {\n\t\t\t\tdp[comb].assign(n, INF);\n\t\t\t\tREP (p, n) {\n\t\t\t\t\toptimal_time(comb, p);\n\t\t\t\t}\n\t\t\t\tint lsb = comb & -comb;\n\t\t\t\tint upper = comb + lsb;\n\t\t\t\tint downer = ((comb & ~upper) / lsb) >> 1;\n\t\t\t\tcomb = upper | downer;\n\t\t\t}\n\t\t}\n\n\t\t// Check if possible\n\t\tint final_status = BIT(n) - 1;\n\t\tdp[final_status].assign(n, INF);\n\t\tfloat t_ans = INF;\n\t\tREP (p, n) {\n\t\t\tt_ans = min(t_ans, optimal_time(final_status, p));\n\t\t}\n\t\tif (t_ans != INF) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define INF 0x7FFFFFFF\n#define dist(x1,y1,x2,y2) sqrt(pow(x2 - x1,2.0) + pow(y2 - y1,2.0))\n\nint n;\ndouble cx[20], cy[20], hx, hy, dx, dy;\n\nint solve(double x,double y,int bit,double sum){\n\tint i;\n\tif(bit == 0) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & bit) && sum >= dist(cx[i],cy[i],dx,dy)) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(((1 << i) & bit) && sum + dist(x,y,cx[i],cy[i]) < dist(dx,dy,cx[i],cy[i]) && solve(cx[i],cy[i],bit ^ (1 << i),sum + dist(x,y,cx[i],cy[i])))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(void){\n\tint i;\n\twhile(1){\n\t\tscanf(\"%d%lf%lf%lf%lf\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf\",&cx[i],&cy[i]);\n\t\tif(solve(hx,hy,(1 << n) - 1,0))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nint N;\nP D;\nvector<P> ps;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool canExist(double t, int p) {\n  double dist = abs(D - ps[p]);\n  return !( equals(dist, t) || dist < t );\n}\n\nbool rec(int state, double t, int p) {\n  if(state == (1<<N)-1) return true;\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    if(!canExist(t + abs(ps[i] - ps[p]), i)) return false;\n  }\n  for(int i = 0; i < N; ++i) {\n    if(state & (1<<i)) continue;\n    double nt = t + abs(ps[i] - ps[p]);\n    if(rec(state|(1<<i), nt, i)) return true;\n  }\n  return false;\n}\n\nint main() {\n  int hx, hy, dx, dy;\n  while(cin >> N >> hx >> hy >> dx >> dy\n\t&&(N|hx|hy|dx|dy) ) {\n    D = P(dx, dy);\n    ps.resize(N+1);\n    ps[N] = P(hx, hy);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(rec(0, 0.0, N)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <functional>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<double, int> R;\ntypedef pair<P, R> Q;\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\tdouble r;\n\twhile (cin >> n >> hx >> hy >> dx >> dy) {\n\t\tif (n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) {\n\t\t\tbreak;\n\t\t}\n\t\thx -= dx;\n\t\thy -= dy;\n\t\tvector<P> data;\n\t\tint x, y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\tdata.push_back(P(x, y));\n\t\t}\n\t\tvector< vector<double> > data2(n, vector<double>(n));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tdata2[i][j] = data2[j][i] = sqrt(pow(data[i].first-data[j].first, 2)+pow(data[i].second-data[j].second, 2));\n\t\t\t}\n\t\t}\n\t\tvector<double> data3(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdata3[i] = sqrt(pow(data[i].first, 2)+pow(data[i].second, 2));\n\t\t}\n\t\tqueue<Q> q;\n\t\tq.push(Q(P(hx, hy), R(0.0, 0)));\n\t\tbool hantei = false;\n\t\twhile (!q.empty()) {\n\t\t\tQ p = q.front();\n\t\t\tq.pop();\n\t\t\tP xy = p.first;\n\t\t\tR limit = p.second;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tbool hantei2 = true;\n\t\t\t\tif ((limit.second & (1<<i)) == 0) {\n\t\t\t\t\tdouble dead = limit.first+sqrt(pow(data[i].first-xy.first, 2)+pow(data[i].second-xy.second, 2));\n\t\t\t\t\tif (data3[i] > dead) {\n\t\t\t\t\t\tint k = limit.second | (1<<i);\n\t\t\t\t\t\tif (k == (1<<n)-1) {\n\t\t\t\t\t\t\thantei = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tif ((k & (1<<j)) == 0) {\n\t\t\t\t\t\t\t\tif (data3[j] <= dead+data2[i][j]) {\n\t\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\t\tq.push(Q(data[i], R(dead, k)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hantei) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <queue>\n#define MAXNUM 2000\n#define zero 1000 // (1000,1000)が原点\nusing namespace std;\n\n#define dist(x1,y1,x2,y2) abs((double)x1 - x2) + abs((double)y1 - y2)\n\nconst int ddx[] = {-1,0,1,0} ,ddy[] = {0,-1,0,1};\nint shoki[MAXNUM + 1][MAXNUM + 1], p[20][20], cx[20], cy[20], hx, hy, n;\n\nint solve(int pre){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= shoki[cy[i] + zero][cx[i] + zero]) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit){ // 未探索の位置にあるクリスタル\n\t\t\tif(pre == -1 && dist(hx,hy,cx[i],cy[i]) + sum < shoki[cy[i] + zero][cx[i] + zero]){ // １つ目のクリスタルをとる\n\t\t\t\tsum += dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tbit += 1 << i;\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbit -= 1 << i;\n\t\t\t\tsum -= dist(hx,hy,cx[i],cy[i]);\n\t\t\t}\n\t\t\telse if(pre != -1 && p[pre][i] + sum < shoki[cy[i] + zero][cx[i] + zero]){ // ２〜ｎつ目のクリスタルを取る\n\t\t\t\tbit += 1 << i;\n\t\t\t\tsum += p[pre][i];\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tsum -= p[pre][i];\n\t\t\t\tbit -= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint  dx, dy, x, y, count, i, j, k;\n\tqueue<int> qx, qy;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(i == j)\n\t\t\t\t\tp[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tp[i][j] = dist(cx[i],cy[i],cx[j],cy[j]);\n\t\t\t}\n\t\t}\n\t\tmemset(shoki,-1,sizeof(shoki));\n\t\tqx.push(dx + zero),qy.push(dy + zero);\n\t\tshoki[dy + zero][dx + zero] = 0;\n\t\twhile(shoki[0][0] == -1 || shoki[MAXNUM][MAXNUM] == -1 || shoki[MAXNUM][0] == -1 || shoki[0][MAXNUM] == -1){\n\t\t\twhile(qx.size()){\n\t\t\t\tx = qx.front();\n\t\t\t\ty = qy.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\t\tif(x + ddx[i] + zero >= 0 && x + ddx[i] + zero <= MAXNUM && y + ddy[i] + zero >= 0 && y + ddy[i] + zero <= MAXNUM && shoki[y + ddy[i] + zero][x + ddx[i] + zero] == -1){\n\t\t\t\t\t\tqx.push(x + ddx[i] + zero),qy.push(y + ddy[i] + zero);\n\t\t\t\t\t\tshoki[y + ddy[i] + zero][x + ddx[i] + zero] = shoki[y + zero][x + zero] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(solve(-1))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0;i < n ;i++)\n#define EPS 1e-8\n\nint n,hx,hy,dx,dy;\nint x[30],y[30];\n\nbool flag;\n\nvoid dfs(int unvisit,int cx,int cy,double t)\n{\n\tif(flag) return;\n\tif(unvisit == 0)flag = true;\n\t\n\telse\n\t{\n\t\tREP(i,n)\n\t\t{\n\t\t\tif(!((unvisit >> i) & 1))continue;\n\t\t\tif(hypot(dx-x[i],dy-y[i]) < t + hypot(cx-x[i],cy-y[i]))return;\n\t\t}\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tif(!((unvisit >> i) & 1))continue;\n\t\t\tdfs((unvisit & ~(1 << i)),x[i],y[i],t + hypot(cx-x[i],cy-y[i]));\n\t\t}\n\t}\n}\n\nstring solve()\n{\n\tflag = false;\n\tdfs((1<<n)-1,hx,hy,0);\n\treturn (flag)?\"YES\":\"NO\";\n}\n\nint main()\n{\n\twhile(cin >> n >> hx >> hy >> dx >> dy,n)\n\t{\n\t\tREP(i,n)\n\t\t{\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nclass Compare {\n  int monster_x;\n  int monster_y;\npublic:\n  Compare(int monster_x,int monster_y)\n    : monster_x(monster_x), monster_y(monster_y) {}\n  bool operator()(const P& ci,const P& cj) const{\n    int dist_i = (ci.first - monster_x) * (ci.first - monster_x)\n      + (ci.second - monster_y) * (ci.second - monster_y);\n    int dist_j = (cj.first - monster_x) * (cj.first - monster_x)\n      + (cj.second - monster_y) * (cj.second - monster_y);\n    return dist_i < dist_j;\n  }\n};\n\nclass State{\n  int x;\n  int y;\n  double dist;\n};\n\nint main(){\n  int total_cristals;\n  int hero_x;\n  int hero_y;\n  int monster_x;\n  int monster_y;\n  while(~scanf(\"%d %d %d %d %d\",\n               &total_cristals,\n               &hero_x,\n               &hero_y,\n               &monster_x,\n               &monster_y)){\n    if(total_cristals == 0 && hero_x == 0 && hero_y == 0\n       && monster_x == 0 && monster_y == 0) break;\n    vector<P> cristals;\n    for(int cristal_i = 0; cristal_i < total_cristals; cristal_i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cristals.push_back(P(x,y));\n    }\n    Compare comp(monster_x,monster_y);\n    sort(cristals.begin(),cristals.end(),comp);\n    \n    double current_time = 0.0;\n    bool isok = true;\n    for(int i=0;i<cristals.size();i++){\n      double add_time = sqrt((hero_x - cristals[i].first) * (hero_x - cristals[i].first)\n                              + (hero_y - cristals[i].second) * (hero_y - cristals[i].second));\n      current_time += add_time;\n      double impurity_arrive_time = sqrt((monster_x - cristals[i].first) * (monster_x - cristals[i].first)\n                                         + (monster_y - cristals[i].second) * (monster_y - cristals[i].second));\n      if(current_time >= impurity_arrive_time){\n        isok = false;\n        break;\n      }\n      hero_x = cristals[i].first;\n      hero_y = cristals[i].second;\n    }\n\n    printf(\"%s\\n\", isok ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define EPS 1e-10\nusing namespace std;\n\nbool visited[21];\nint n,hx,hy,dx,dy,cx[21],cy[21];\n\nbool dfs(int x , double day){ //xツづ債個サツ催敖づ個暗環置\n  visited[x] = true;\n  bool judge = false,t = true;\n  for(int i=0;i<=n;i++)t &= visited[i];\n  if(t) return t;\n  for(int i= 0;i<=n;i++){\n    double dis,d,t;\n    if(visited[i]) continue;\n    t = day + sqrt((cx[i] - cx[x])*(cx[i] - cx[x]) + (cy[i] - cy[x])*(cy[i] - cy[x]));\n    if((dx - cx[i])*(dx - cx[i]) + (dy - cy[i])*(dy - cy[i]) > t*t ){\n      judge |= dfs(i,t);\n      if(judge) break;\n    }\n  }\n  return judge;\n}\n    \nint main(){\n  while(1){\n    cin >> n >> hx >> hy >> dx >> dy;\n    if(!(n|hx|hy|dx|dy)) break;\n    dx -= hx;dy -= hy;\n    cx[0] = cy[0] = 0;\n    for(int i=1;i <= n;i++){\n      int tx,ty;cin >> tx >> ty;\n      cx[i] = tx - hx;cy[i] = ty - hy;\n    }\n    hx = hy = 0;\n    for(int i=0;i<21;i++) visited[i] = false;\n    if(dfs(0,0)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n\n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector &s, Vector &t) : s(s), t(t) {}\n \n  Point Projection(const Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n\n  bool intersectSP(const Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(const Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nSegment s;\nbool rec(int S, int v, double total_dist){\n  if(S == (1 << N) - 1){\n    return true;\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1)){\n      s = Segment(crystal[v], crystal[u]);\n      if(s.distanceSP(d) < total_dist) return false;\n      if(total_dist+dist(crystal[v],crystal[u]) >= dist(d, crystal[u])){\n        return false;\n      }\n    }\n  }\n  for(int u = 0 ; u < N ; u++){\n    if(!(S >> u & 1)){\n      if(rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]))){\n\treturn true;\n      }\n    }\n  }\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    if(rec(0, i, dist(h, crystal[i]))){\n      return true;\n    }\n  }  \n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n\twhile(true) {\n\t\tint n, hx, hy, dx, dy;\n\t\tcin >> n >> hx >> hy >> dx >> dy;\n\n\t\tif(!n && !hx && !hy && !dx && !dy) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< pair< int, int > > crys;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tcrys.push_back(make_pair(x, y));\n\t\t}\n\n\t\tvector< pair< double, double> > u;\n\t\tvector< bool > use(n, true);\n\t\tint tmp = 1000, idx = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tu.push_back(make_pair(sqrt((double)(crys[i].first - dx) * (crys[i].first - dx) + (double)(crys[i].second - dy) * (crys[i].second - dy)), sqrt((double)(crys[i].first - hx) * (crys[i].first - hx) + (double)(crys[i].second - hy) * (crys[i].second - hy))));\n\t\t\tif(tmp > u[i].first) {\n\t\t\t\ttmp = u[i].first;\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t}\n\n\n\t\tsort(u.begin(), u.end());\n\t\tuse[idx] = false;\n\n\t\tint ans = u[0].first - u[0].second;\n\t\tpair< int, int > now;\n\t\tnow.first = crys[idx].first; now.second = crys[idx].second;\n\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttmp = 10000;\n\t\t\tvector< pair< double, double> > h;\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(!use[j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\th.push_back(make_pair(sqrt((double)(crys[j].first - now.first) * (crys[j].first - now.first) + (double)(crys[j].second - now.second) * (crys[j].second - now.second)), sqrt((double)(crys[j].first - now.first) * (crys[j].first - now.first) + (double)(crys[j].second - now.second) * (crys[j].second - now.second))));\n\t\t\t\tif(tmp > h[j].first) {\n\t\t\t\t\ttmp = h[j].first;\n\t\t\t\t\tidx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(h.begin(), h.end());\n\t\t\tif(!h.size()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans += (h[0].first - h[0].second);\n\t\t\tnow.first = crys[idx].first; now.second = crys[idx].second;\n\t\t\t\n\t\t\tuse[idx] = false;\n\n\t\t\tif(ans <= 0) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(flag){\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\ninline int dbl(int x){ return x * x; }\n\nint main(){\n  while(true){\n    const int n = getInt();\n    const int hx = getInt();\n    const int hy = getInt();\n    const int dx = getInt();\n    const int dy = getInt();\n\n    if(n == 0) break;\n\n    vector<int> cx(n);\n    vector<int> cy(n);\n\n    REP(i,n){\n      cx[i] = getInt();\n      cy[i] = getInt();\n    }\n\n    typedef pair<double, pair<int, int> > data;\n    priority_queue<data, vector<data>, greater<data> > pq;\n    vector<vector<bool> > memo(1 << n, vector<bool>(n));\n\n    pq.push(make_pair(0.0, make_pair((1 << n) - 1, -1)));\n\n    while(pq.size()){\n      const data   d = pq.top(); pq.pop();\n      const double t = d.first;\n      const int    f = d.second.first;\n      const int    p = d.second.second;\n      const int    x = p == -1 ? hx : cx[p];\n      const int    y = p == -1 ? hy : cy[p];\n\n      // printf(\"%f %d %d\\n\", t, f, p);\n\n      if(p >= 0 && memo[f][p]) continue;\n      if(p >= 0) memo[f][p] = true;\n\n      if(f == 0){\n\tputs(\"YES\");\n\tgoto end;\n      }\n\n      REP(i,n) if((f & (1 << i)) && !memo[f ^ (1 << i)][i]){\n\tconst int xx = cx[i];\n\tconst int yy = cy[i];\n\n\tconst double tm1 = t + sqrt(dbl(x - xx) + dbl(y - yy));\n\tconst double tm2 = sqrt(dbl(dx - xx) + dbl(dy - yy));\n\t// printf(\"%d => %d (%d %d) => (%d %d): %f %f\\n\", p, i, x, y, xx, yy, tm1, tm2);\n\n\tif(tm1 < tm2 - 1e-9){\n\t  pq.push(make_pair(tm1, make_pair(f ^ (1 << i), i)));\n\t}\n      }\n    }\n    puts(\"NO\");\n  end:;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint n;\nint cx[22];\nint cy[22];\nbool f[22];\ndouble l[22][22];\nint s = 0;\ndouble d;\n\nint kansu( int x , int y ){\n\tif ( d + l[x][y] >= l[1][y] ) return 0;\n\ts++;\n\tif ( s == n ) return 1;\n\td += l[x][y];\n\tf[y] = true;\n\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\tif ( f[i] ) continue;\n\t\tif ( kansu( y , i ) ) return 1;\n\t}\n\ts--;\n\td -= l[x][y];\n\tf[y] = false;\n\treturn 0;\n}\n\nint main(){\n\twhile(true) {\n\t\tcin >> n >> cx[0] >> cy[0] >> cx[1] >> cy[1];\n\t\tif ( n == 0 ) break;\n\t\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\tf[i] = false;\n\t\t}\n\t\tfor ( int i = 0; i < n + 1; i++ ) {\n\t\t\tfor ( int j = i + 1; j < n + 2; j++ ) {\n\t\t\t\tint x = cx[i]-cx[j];\n\t\t\t\tint y = cy[i]-cy[j];\n\t\t\t\tdouble z = x*x + y*y;\n\t\t\t\tl[i][j] = sqrt( z );\n\t\t\t\tl[j][i] = l[i][j];\n\t\t\t}\n\t\t}\n\t\ts = 0;\n\t\td = 0.00;\n\t\tf[0] = false;\n\t\tfor ( int i = 2; i < n + 2; i++ ) {\n\t\t\tif ( kansu( 0 , i ) ) {\n\t\t\t\tf[0] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( f[0] ) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ2008.cpp\n *\n *  Created on: 2012/04/09\n *      Author: mizo0203\n */\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint n; // (0 < n <= 20)\nint hx, hy, dx, dy;\nint cx[20], cy[20]; // (-1000 <= h, d, c <= 1000)\n\nvoid init() {\n}\n\nbool input() {\n  int i;\n\n  scanf(\"%d %d %d %d %d\", &n, &hx, &hy, &dx, &dy);\n  if (!n && !hx && !hy && !dx && !dy)\n    return false;\n  for (i = 0; i < n; i++)\n    scanf(\"%d %d\", &cx[i], &cy[i]);\n\n  return true;\n}\n\nint main() {\n  int i;\n  int x, y;\n  double sum; // 勇者の総移動距離^2 == 瘴気の半径^2\n\n  init();\n  while (input()) {\n    int pmt[20];\n    // [0, 1, 2, ....]というサイズnの配列を作成\n    for (i = 0; i < n; i++)\n      pmt[i] = i;\n    // 全ての順列を出力\n    do {\n      sum = 0;\n      x = hx;\n      y = hy;\n      for (i = 0; i < n; i++) {\n        sum += sqrt(pow(cx[pmt[i]] - x, 2) + pow(cy[pmt[i]] - y, 2));\n        if (sum + 1 >= sqrt(pow(cx[pmt[i]] - dx, 2) + pow(cy[pmt[i]] - dy, 2)))\n          break;\n        x = cx[pmt[i]];\n        y = cy[pmt[i]];\n      }\n      if (i == n)\n        break;\n    } while (next_permutation(pmt, pmt + n));\n    if (i == n)\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nclass Compare {\n  int monster_x;\n  int monster_y;\npublic:\n  Compare(int monster_x,int monster_y)\n    : monster_x(monster_x), monster_y(monster_y) {}\n  bool operator()(const P& ci,const P& cj) const{\n    int dist_i = (ci.first - monster_x) * (ci.first - monster_x)\n      + (ci.second - monster_y) * (ci.second - monster_y);\n    int dist_j = (cj.first - monster_x) * (cj.first - monster_x)\n      + (cj.second - monster_y) * (cj.second - monster_y);\n    return dist_i < dist_j;\n  }\n};\n\nclass State{\n  int x;\n  int y;\n  double dist;\n};\n\nbool dfs(int hero_x,\n         int hero_y,\n         double current_time,\n         int S,\n         int monster_x,\n         int monster_y,\n         const vector<P>& cristals){\n  bool res = false;\n\n  if(S == (1<<cristals.size()) - 1) return true;\n  for(int i=0;i<cristals.size();i++){\n    if(S & (1<<i)) continue;\n    double add_time = sqrt((hero_x - cristals[i].first) * (hero_x - cristals[i].first)\n                           + (hero_y - cristals[i].second) * (hero_y - cristals[i].second));\n    \n    double impurity_arrive_time = sqrt((monster_x - cristals[i].first) * (monster_x - cristals[i].first)\n                                       + (monster_y - cristals[i].second) * (monster_y - cristals[i].second));\n    if(current_time + add_time >= impurity_arrive_time){\n      return false;\n    }\n    \n    res |= dfs(cristals[i].first,cristals[i].second,current_time + add_time,\n               S | (1<<i),monster_x,monster_y,cristals);\n  }\n  return res;\n}\n\nint main(){\n  int total_cristals;\n  int hero_x;\n  int hero_y;\n  int monster_x;\n  int monster_y;\n  while(~scanf(\"%d %d %d %d %d\",\n               &total_cristals,\n               &hero_x,\n               &hero_y,\n               &monster_x,\n               &monster_y)){\n    if(total_cristals == 0 && hero_x == 0 && hero_y == 0\n       && monster_x == 0 && monster_y == 0) break;\n    vector<P> cristals;\n    for(int cristal_i = 0; cristal_i < total_cristals; cristal_i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cristals.push_back(P(x,y));\n    }\n    Compare comp(monster_x,monster_y);\n    sort(cristals.begin(),cristals.end(),comp);\n    printf(\"%s\\n\", dfs(hero_x,hero_y,0,0,monster_x,monster_y,cristals)\n           ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint n;\ndouble item_dist[21][21];\ndouble boss_dist[20];\n\ndouble distance(pii a, pii b) {\n    return hypot(a.first - b.first, a.second - b.second);\n}\n\nbool dfs(int p, double t, int remain) {\n    if (remain == 0) return true;\n    REP(i, n) {\n        if (remain & (1 << i)) {\n            double next_t = t + item_dist[i][p];\n            REP(j, n) {\n                if(remain & (1 << j) && next_t + item_dist[i][j] >= boss_dist[j]) goto next;\n            }\n            if(dfs(i, next_t, remain & ~(1 << i))) return true;\n        next : {}\n        }\n    }\n    return false;\n}\n\nint main() {\n    int x, y, hx, hy;\n    while (cin >> n >> x >> y >> hx >> hy, n|x|y|hx|hy) {\n        fill_n((int *)item_dist, 21*21, 0);\n        fill_n((int *)boss_dist, 21*21, 0);\n\n        vector<pii> items;\n        REP(i, n) {\n            int a, b;\n            cin >> a >> b;\n            items.push_back({a, b});\n        }\n        items.push_back({x, y});\n        REP(i, n+1) {\n            FOR(j, i+1, n+1) {\n                item_dist[i][j] = item_dist[j][i] = distance(items[i], items[j]);\n            }\n        }\n        REP(i, n) {\n            boss_dist[i] = distance(items[i], {hx, hy});\n        }\n\n        if (dfs(n, 0.0, (1 << n)-1)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <functional>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<double, int> R;\ntypedef pair<P, R> Q;\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\tdouble r;\n\twhile (cin >> n >> hx >> hy >> dx >> dy) {\n\t\tif (n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0) {\n\t\t\tbreak;\n\t\t}\n\t\thx -= dx;\n\t\thy -= dy;\n\t\tvector<P> data;\n\t\tint x, y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\tdata.push_back(P(x, y));\n\t\t}\n\t\tqueue<Q> q;\n\t\tq.push(Q(P(hx, hy), R(0.0, 0)));\n\t\tbool hantei = false;\n\t\twhile (!q.empty()) {\n\t\t\tQ p = q.front();\n\t\t\tq.pop();\n\t\t\tP xy = p.first;\n\t\t\tR limit = p.second;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tbool hantei2 = true;\n\t\t\t\tif ((limit.second & (1<<i)) == 0) {\n\t\t\t\t\tdouble dead = limit.first+sqrt(pow(data[i].first-xy.first, 2)+pow(data[i].second-xy.second, 2));\n\t\t\t\t\tif (sqrt(pow(data[i].first, 2)+pow(data[i].second, 2)) <= dead) {\n\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\tint k = limit.second | (1<<i);\n\t\t\t\t\t\tif (k == (1<<n)-1) {\n\t\t\t\t\t\t\thantei = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tif ((k & (1<<j)) == 0) {\n\t\t\t\t\t\t\t\tif (sqrt(pow(data[j].first, 2)+pow(data[j].second, 2)) <= dead+sqrt(pow(data[i].first-data[j].first, 2)+pow(data[i].second-data[j].second, 2))) {\n\t\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\t\tq.push(Q(data[i], R(dead, k)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hantei) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nclass Compare {\n  int monster_x;\n  int monster_y;\npublic:\n  Compare(int monster_x,int monster_y)\n    : monster_x(monster_x), monster_y(monster_y) {}\n  bool operator()(const P& ci,const P& cj) const{\n    int dist_i = (ci.first - monster_x) * (ci.first - monster_x)\n      + (ci.second - monster_y) * (ci.second - monster_y);\n    int dist_j = (cj.first - monster_x) * (cj.first - monster_x)\n      + (cj.second - monster_y) * (cj.second - monster_y);\n    return dist_i < dist_j;\n  }\n};\n\nclass State{\n  int x;\n  int y;\n  double dist;\n};\n\nbool dfs(int hero_x,\n         int hero_y,\n         double current_time,\n         int S,\n         int monster_x,\n         int monster_y,\n         const vector<P>& cristals){\n  bool res = false;\n\n  if(S == (1<<cristals.size()) - 1) return true;\n  for(int i=0;i<cristals.size();i++){\n    if(S & (1<<i)) continue;\n    double add_time = sqrt((hero_x - cristals[i].first) * (hero_x - cristals[i].first)\n                           + (hero_y - cristals[i].second) * (hero_y - cristals[i].second));\n    \n    double tmp_current_time = current_time + add_time;\n    double impurity_arrive_time = sqrt((monster_x - cristals[i].first) * (monster_x - cristals[i].first)\n                                       + (monster_y - cristals[i].second) * (monster_y - cristals[i].second));\n    if(tmp_current_time >= impurity_arrive_time){\n      return false;\n    }\n    \n    res |= dfs(cristals[i].first,cristals[i].second,tmp_current_time,\n               S | (1<<i),monster_x,monster_y,cristals);\n  }\n  return res;\n}\n\nint main(){\n  int total_cristals;\n  int hero_x;\n  int hero_y;\n  int monster_x;\n  int monster_y;\n  while(~scanf(\"%d %d %d %d %d\",\n               &total_cristals,\n               &hero_x,\n               &hero_y,\n               &monster_x,\n               &monster_y)){\n    if(total_cristals == 0 && hero_x == 0 && hero_y == 0\n       && monster_x == 0 && monster_y == 0) break;\n    vector<P> cristals;\n    for(int cristal_i = 0; cristal_i < total_cristals; cristal_i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cristals.push_back(P(x,y));\n    }\n    Compare comp(monster_x,monster_y);\n    sort(cristals.begin(),cristals.end(),comp);\n    printf(\"%s\\n\", dfs(hero_x,hero_y,0,0,monster_x,monster_y,cristals)\n           ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include<vector>\n#include<map>\n\nusing namespace std;\nint n,dx,dy,hx,hy;\nint cx[20],cy[20];\nmap<int,map<int,int> > dp;\n\nshort smin(short a,short b){\n\tif(a>b)return b;\n\treturn a;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n+hx+hy+dx+dy==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t\tdp.clear();\n\t\tcx[n]=hx,cy[n]=hy;\n\t\tbool flag=false;\n\t\tdp[0][n]=-1;\n\t\tfor(int i=0;i<1<<n;i++){\n\t\t\tif(flag)continue;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif(dp[i][j]!=0){\n\t\t\t\t\tif(dp[i][j]==-1)dp[i][j]=0;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif((i>>k) & 1)continue;\n\t\t\t\t\t\tint move=abs(cx[j]-cx[k])+abs(cy[j]-cy[k]);\n\t\t\t\t\t\tint ng=abs(dx-cx[k])+abs(dy-cy[k]);\n\t\t\t\t\t\tif(dp[i][j]+move>=ng)continue;\t\n\t\t\t\t\t\tdp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],dp[i][j]+move);\n\t\t\t\t\t\tif(dp[i|(1<<k)][k]==0)dp[i|(1<<k)][k]=dp[i][j]+move;\n\t\t\t\t\t\tif(i|(1<<k)==(1<<n)-1)flag=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint N, hx, hy, dx, dy;\nvector<PII> pos;\nvector<double> visited;\ndouble dist[30][30];\n\nvoid init(){\n  REP(i,N) REP(j,N)\n\tdist[i][j] =\n\tsqrt((pos[i].first - pos[j].first)*(pos[i].first - pos[j].first)\n\t\t + (pos[i].second - pos[j].second)*(pos[i].second - pos[j].second));\n\n  REP(i,N){\n \tdist[i][N] = dist[N][i]\n\t  = sqrt((pos[i].first - hx)*(pos[i].first - hx)\n\t\t\t + (pos[i].second - hy)*(pos[i].second - hy));\n \tdist[i][N+1] = dist[N+1][i]\n\t  = sqrt((pos[i].first - dx)*(pos[i].first - dx)\n\t\t\t + (pos[i].second - dy)*(pos[i].second - dy));\n  }\n}\n\nbool dfs(int idx, int cnt){\n  if(cnt == 0) return true;\n  for(int i=0;i<N;++i){\n\tif(visited[i] >= 0) continue;\n\tif(visited[idx] + dist[i][idx] >= dist[i][N+1]){\n\t  return false;\n\t}\n  }\n\n  for(int i=0;i<N;++i){\n\tif(visited[i] > 0) continue;\n\tvisited[i] = visited[idx] + dist[i][idx];\n\tif(dfs(i, cnt-1)) return true;\n\tvisited[i] = -1;\n  }\n  \n  return false;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin >> N >> hx >> hy >> dx >> dy, N){\n\tPII m(dx, dy);\n\tpos.assign(N, PII());\n\tvisited.assign(N+1, -1);\n\tvisited[N] = 0;\n\t\n\tfill((double*) dist,(double*)dist+30*30, 0);\n\tREP(i,N){\n\t  cin >> pos[i].first >> pos[i].second;\n\t}\n\tinit();\n\t\n\tbool ok = false;\n\tif(dfs(N, N)){\n\t  ok = true;\n\t}\n\n\tcout << (ok? \"YES\": \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nint n,sx,sy,mx,my;\nint xi[22],yi[22];\nbool used[22];\nconst double eps = 1e-8;\n\nbool solve(int a,double t,double x,double y)\n{\n  //printf(\"%d %f %f %f\\n\",a,t,x,y);\n  if( a == n ) return true;\n  for(int i = 0; i < n; i++) {\n    if( hypot(xi[i]-mx,yi[i]-my) < t+hypot(x-xi[i],y-yi[i])+eps ) return false;\n    if(!used[i]) {\n      used[i]=true;\n      if(solve(a+1,t+hypot(x-xi[i],y-yi[i]),xi[i],yi[i]))return true;\n      used[i]=false;\n    }\n  }\n  return false;\n}\n\nint main(void)\n{\n  for(;;) {\n    scanf(\"%d%d%d%d%d\",&n,&sx,&sy,&mx,&my); if(!n)break;\n    for(int i = 0; i < n; i++) {\n      used[i] = false;\n      scanf(\"%d%d\",xi+i,yi+i);\n    }\n    bool res = solve(0,0,sx,sy);\n    puts(res ? \"YES\" : \"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define MAX 20\ntypedef pair<double,double> P;\n\nint N;\nP h, d, crystal[MAX];\n\ndouble dist(P a, P b){\n  return sqrt(pow(a.fi-b.fi,2) + pow(a.se-b.se,2));\n}\n\nbool solve(){\n  for(int i = 0 ; i < N ; i++){\n    if(dist(h, crystal[i]) >= dist(d, crystal[i])){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  while(cin >> N >> h.fi >> h.se >> d.fi >> d.se, (N + h.fi + h.se + d.fi + d.se)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].fi >> crystal[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\nint n,hx,hy,dx,dy,cx[25], cy[25];\nint ans;\nconst double inf = 999999999.9;\ndouble dist[25][25], start[25], dead[25];\nbool used[25];\ndouble memo[1<<20];\n\ndouble sqr(int x){ return (double)x*x; }\n\n\nvoid solve(int node, int cnt, double cost, int S){\n    int i,j;\n\n    //printf(\"cost = %lf, dead[%d] = %lf\\n\",cost ,node, dead[node]);\n    if( cost >= dead[node] || memo[S] <= cost ) return;\n\n    ans = max(ans, cnt);\n    memo[S] = cost;\n    if( cnt == n ) return;\n\n    /*\n      »Ýn©çÜ¾EÁÄ¢È¢NX^Ì¤¿AêÂÅàæêÈ¢Ìª éÈçOUT\n     */\n    rep(i,n){\n        if( !used[i] ){\n            if( cost + dist[node][i] >= dead[i] ) return;\n        }\n    }\n\n    //printf(\"cnt = %d, node = %d, cost = %lf\\n\",cnt, node, cost);\n\n    rep(i,n){\n        if( !used[i] ){\n            used[i] = true;\n            solve(i, cnt + 1, cost + dist[node][i], S|(1<<i));\n            used[i] = false;\n            if( ans == n ) return;\n        }\n    }\n}\n\n\nint main(){\n    int i,j;\n\n    while( cin >> n >> hx >> hy >> dx >> dy, n|hx|hy|dx|dy ){\n        // init\n        ans = 0;\n        rep(i,25) rep(j,25) dist[i][j] = inf;\n        rep(i,1<<n) memo[i] = inf;\n        memset(used, false, sizeof(used));\n\n        // input\n        set<pair<int,int> > sc;\n        rep(i,n){\n            int x,y; cin >> x >> y;\n            sc.insert(make_pair(x,y));\n        }\n\n        j = 0;\n        foreach(it,sc){\n            cx[j] = it->first, cy[j] = it->second;\n            j++;\n        }\n        n = j;\n\n        // start -> other crystal\n        rep(i,n) start[i] = sqrt( sqr(hx - cx[i]) + sqr(hy - cy[i]) );\n\n        // dead line\n        rep(i,n) dead[i] = sqrt( sqr(dx - cx[i]) + sqr(dy - cy[i]) );\n\n        // crystal -> crystal\n        rep(i,n){\n            REP(j,i+1,n){\n                double d = sqrt( sqr(cx[i] - cx[j]) + sqr(cy[i] - cy[j]) );\n                dist[i][j] = dist[j][i] = d;\n            }\n        }\n\n        rep(i,n){\n            used[i] = true;\n            solve(i, 1, start[i], 1<<i);\n            used[i] = false;\n        }\n\n        puts( ans == n ? \"YES\" : \"NO\" );\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cmath>\n//S \nusing namespace std;\ntypedef pair<int,int> P;\nint cx[30],cy[30],n,hx,hy,dx,dy;\nmap<P,double> mp;\nbool func(int S,int now,double time){\n\tif(S==(1<<n)-1)\n\t\treturn 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(!(S&(1<<i))){\n\t\t\tif(mp[P(now,i)]+time>=mp[P(i,n+1)])\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!(S&(1<<i))){\n\t\t\tdouble pre=mp[P(now,i)];\n\t\t\tdouble dis=mp[P(i,n+1)];\n\t\t\tif(pre+time<dis&&func(S|(1<<i),i,time+pre))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin>>n>>hx>>hy>>dx>>dy,n||hx||hy||dx||dy){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>cx[i]>>cy[i];\n\t\tcx[n]=hx;\n\t\tcy[n]=hy;\n\t\tcx[n+1]=dx;\n\t\tcy[n+1]=dy;\n\t\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\tmp[P(i,j)]=sqrt((cx[i]-cx[j])*(cx[i]-cx[j])+(cy[i]-cy[j])*(cy[i]-cy[j]));\n\t\tif(func(0,n,0.0))\n\t\t\tcout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t\tmp.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <queue>\n#define MAXNUM 2000\n#define zero 1000 // (1000,1000)が原点\n#define dist(x1,y1,x2,y2) abs(x1 - x2) + abs(y1 - y2)\nusing namespace std;\n\nconst int ddx[] = {-1,0,1,0} ,ddy[] = {0,-1,0,1};\nint shoki[MAXNUM + 1][MAXNUM + 1], p[20][20], cx[20], cy[20], hx, hy, n;\n\nint solve(int pre){\n\tstatic int bit = 0, sum = 0;\n\tint i;\n\tif(bit == pow(2.0,n) - 1) // すべてのクリスタルを集めたら\n\t\treturn 1;\n\tfor(i = 0;i < n;i++){\n\t\tif((1 << i & ~bit) && sum >= shoki[cy[i] + zero][cx[i] + zero]) // 取っていないクリスタルの位置に瘴気がくる\n\t\t\treturn 0;\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tif(1 << i & ~bit){ // 未探索の位置にあるクリスタル\n\t\t\tif(pre == -1 && dist(hx,hy,cx[i],cy[i]) + sum < shoki[cy[i] + zero][cx[i] + zero]){ // １つ目のクリスタルをとる\n\t\t\t\tsum += dist(hx,hy,cx[i],cy[i]);\n\t\t\t\tbit += 1 << i;\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbit -= 1 << i;\n\t\t\t\tsum -= dist(hx,hy,cx[i],cy[i]);\n\t\t\t}\n\t\t\telse if(pre != -1 && p[pre][i] + sum < shoki[cy[i] + zero][cx[i] + zero]){ // ２〜ｎつ目のクリスタルを取る\n\t\t\t\tbit += 1 << i;\n\t\t\t\tsum += p[pre][i];\n\t\t\t\tif(solve(i)){\n\t\t\t\t\tsum = 0, bit = 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tsum -= p[pre][i];\n\t\t\t\tbit -= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(void){\n\tint  dx, dy, x, y, i, j;\n\tqueue<int> qx, qy;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n == 0 && hx == 0 && hy == 0 && dx == 0 && dy == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&cx[i],&cy[i]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(i == j)\n\t\t\t\t\tp[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tp[i][j] = dist(cx[i],cy[i],cx[j],cy[j]);\n\t\t\t}\n\t\t}\n\t\tmemset(shoki,-1,sizeof(shoki));\n\t\tqx.push(dx + zero),qy.push(dy + zero);\n\t\tshoki[dy + zero][dx + zero] = 0;\n\t\twhile(shoki[0][0] == -1 || shoki[MAXNUM][MAXNUM] == -1 || shoki[MAXNUM][0] == -1 || shoki[0][MAXNUM] == -1){\n\t\t\twhile(qx.size()){\n\t\t\t\tx = qx.front();\n\t\t\t\ty = qy.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\t\tif(x + ddx[i] + zero >= 0 && x + ddx[i] + zero <= MAXNUM && y + ddy[i] + zero >= 0 && y + ddy[i] + zero <= MAXNUM && shoki[y + ddy[i] + zero][x + ddx[i] + zero] == -1){\n\t\t\t\t\t\tqx.push(x + ddx[i] + zero),qy.push(y + ddy[i] + zero);\n\t\t\t\t\t\tshoki[y + ddy[i] + zero][x + ddx[i] + zero] = shoki[y + zero][x + zero] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(solve(-1))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint n;\ndouble item_dist[21][21];\ndouble boss_dist[20];\n\ndouble distance(pii a, pii b) {\n    return hypot(a.first - b.first, a.second - b.second);\n}\n\nbool dfs(int p, double t, int remain) {\n    if (remain == 0) return true;\n    REP(i, n) {\n        if (remain & (1 << i)) {\n            double next_t = t + item_dist[i][p];\n            REP(j, n) {\n                if(remain & (1 << j) && next_t + item_dist[i][j] >= boss_dist[j]) goto next;\n            }\n            if(dfs(i, next_t, remain & ~(1 << i))) return true;\n        next : {}\n        }\n    }\n    return false;\n}\n\nint main() {\n    int x, y, hx, hy;\n    while (cin >> n >> x >> y >> hx >> hy, n|x|y|hx|hy) {\n        fill_n((int *)item_dist, 21*21, 0);\n        fill_n((int *)boss_dist, 21*21, 0);\n\n        vector<pii> items;\n        REP(i, n) {\n            int a, b;\n            cin >> a >> b;\n            items.push_back({a, b});\n        }\n        items.push_back({x, y});\n        REP(i, n+1) {\n            FOR(j, i+1, n+1) {\n                item_dist[i][j] = item_dist[j][i] = distance(items[i], items[j]);\n            }\n            boss_dist[i] = distance(items[i], {hx, hy});\n        }\n\n        if (dfs(n, 0.0, (1 << n)-1)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <string>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\n\n/*\n  dist[0]ÍEÒ\n */\nint n,hx,hy,dx,dy;\nint cx[32],cy[32];\ndouble dist[32][32]; // [1][0]  1base and 0base\ndouble maoo[32];\ndouble inf = 999999999.0;\n\ndouble sqr(int x){ return (double)x*x; }\n\nbool solve(int now, int S, double cost){\n#if DEB\n  printf(\"now:%d  S:%d  cost:%lf\\n\",now,S,cost);\n#endif\n\n  if( S==((1<<n)-1) ) return true;\n  rep(i,n)if( !((1<<i)&S) ){\n#if DEB\n    printf(\"i:%d  %lf < %lf\\n\",i, cost+dist[now][i], maoo[i]);\n#endif\n    if( cost + dist[now][i] < maoo[i] ){\n      if( solve(i+1, S|(1<<i), cost + dist[now][i]) ) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin>>n>>hx>>hy>>dx>>dy, n|hx|hy|dx|dy){\n    rep(i,32)rep(j,32)dist[i][j] = inf;\n    set<pair<int,int> > si;\n    vector<int> v;\n    rep(i,n){\n      cin>>cx[i]>>cy[i];\n      if( si.find(make_pair(cx[i],cy[i])) != si.end() ) continue;\n      si.insert(make_pair(cx[i],cy[i]));\n      v.push_back(i);\n    }\n    n = v.size();\n    rep(i,n){\n      dist[0][i] = sqrt(sqr(hx-cx[v[i]])+sqr(hy-cy[v[i]]));\n      maoo[i] = sqrt(sqr(dx-cx[v[i]])+sqr(dy-cy[v[i]]));\n    }\n    // eXÌNX^©çÊÌNX^ÖÌ£vZ\n    REP(i,1,n+1){\n      REP(j,i+1,n+1){\n\tdist[i][j-1] = dist[j][i-1] = sqrt(sqr(cx[i-1]-cx[j-1]) + sqr(cy[i-1]-cy[j-1]));\n      }\n    }\n#if DEB\n    rep(i,n+1){\n      rep(j,n+1){\n\tprintf(\"%9lf \",dist[i][j]==inf ? -1 : dist[i][j]);\n      }\n      puts(\"\");\n    }\n#endif\n    if( solve(0,0,0.0) ){\n      puts(\"YES\");\n    }else{\n      puts(\"NO\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\n\nconst D EPS = 1e-8;\n\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\n\ntypedef pair<D, pair<int, int> > State;\n\nP cr[21], d;\nint n;\nD dis[1 << 20][21];\n\nint main() {\n  while (true) {\n    cin >> n;\n    cin  >> cr[n].X >> cr[n].Y >> d.X >> d.Y;\n    if (n == 0) break;\n    rep (i, n) cin >> cr[i].X >> cr[i].Y;\n    priority_queue<State, vector<State>, greater<State> > que;\n    que.push(make_pair(0, make_pair((1 << n) - 1, n)));\n    rep (i, 1 << n) rep (j, n + 1) dis[i][j] = 1e100;\n    bool ok = false;\n    while (!que.empty()) {\n      State now = que.top();\n      que.pop();\n      if (now.second.first == 0) {\n\tok = true;\n\tbreak;\n      }\n      if (sig(dis[now.second.first][now.second.second], now.first) < 0) continue;\n      dis[now.second.first][now.second.second] = now.first;\n      rep (i, n) if (now.second.first & 1 << i) {\n\tif (sig(now.first + abs(cr[now.second.second] - cr[i]), abs(cr[i] - d)) < 0 &&\n\t    sig(dis[now.second.first ^ 1 << i][i], now.first + abs(cr[now.second.second] - cr[i])) > 0) {\n\t  que.push(make_pair(now.first + abs(cr[now.second.second] - cr[i]), make_pair(now.second.first ^ 1 << i, i)));\n\t  dis[now.second.first ^ 1 << i][i] = now.first + abs(cr[now.second.second] - cr[i]);\n\t}\n      }\n    }\n    cout << (ok ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cfloat>\n#include <cmath>\n#include <vector>\n#include <map>\n \nusing namespace std;\n \n#define fi first\n#define se second\ntypedef pair<double,double> P;\n \n#define MAX (21)\n#define INF (DBL_MAX/4)\n \ndouble G[MAX][MAX];\n \nint n;\nvector<P> crys;\nP h, d;\n \ndouble dist(P p1, P p2){\n  return sqrt(pow(p1.fi-p2.fi, 2.) + pow(p1.se-p2.se, 2.));\n}\n \nvoid makeEdge() {\n  for(int i=0; i<n; i++) {\n    G[i][i] = 0;\n    for(int j=i+1; j<n; j++) {\n      G[i][j] = G[j][i] = dist(crys[i], crys[j]);\n    }\n  }\n}\n \n\nvoid printbit(int x){\n  for(int i=0;i<n;i++){\n    cout<<((x>>i)&1);\n\n  }\n  cout<<endl;\n}\n\n \ntypedef unsigned long long ull;\nmap<ull, double> dp;\n\ndouble dfs(int S, int idx, double cost) {\n  \n  if(S==(1<<n)-1) {\n    return dp[S] = cost;\n  }\n  \n  dp[S] = cost;\n  \n  for(int i=0; i<n; i++){\n    if((S>>i)&1) continue;\n    double ncost = cost + G[idx][i];\n    double nS = S|(1<<i);\n    if(ncost >= dist(crys[i], d)) return dp[S] = INF;\n    else {\n      if(dp.count(nS) && dp[nS] < ncost) continue;\n      dp[S] = min(dp[S], dfs(nS, i, ncost));\n    }\n  }\n  \n  return dp[S];\n}\n \nbool solve() {\n   \n  makeEdge();\n  \n  dp.clear();\n  dp[0] = INF;\n  for(int i=0; i<n; i++) {\n    if(dist(h, crys[i]) >= dist(crys[i], d)) continue;\n    dp[0] = min(dfs(1<<i, i, dist(h, crys[i])), dp[0]);\n  }\n  if(!dp.count((1<<n)-1)) return false;\n  if(dp[0]>=INF) return false;\n  return true;\n}\n \nint main(){\n  while(true){\n    crys.clear();\n    cin >> n >> h.fi >> h.se >> d.fi >> d.se;\n    if(!n && !h.fi && !h.se && !d.fi && !d.se){\n      break;\n    }\n    crys.resize(n);\n    for(int i=0; i<n; i++){\n      cin >> crys[i].fi >> crys[i].se;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> dP;\n\nconst int INF = 100000000;\nconst double EPS = 1e-10;\n\nvector<vector<double> > edge;\ndouble dist(P &a, P &b){\n\treturn sqrt(double(a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y));\n}\n\nbool dfs(vector<P> &c, bitset<20> &b, int hi, int di, double t){\n\tif(edge[hi][di] <= t+EPS) return false;\n\tif(b.count() == 20) return true;\n\trep(i, c.size()-2){\n\t\tif(b[i]) continue;\n\t\tif(edge[i][di] <= t+edge[i][hi]+EPS) return false;\n\t}\n\trep(i, c.size()-2){\n\t\tif(b[i]) continue;\n\t\tb[i] = true;\n\t\tif(dfs(c, b, i, di, t+edge[i][hi])) return true;\n\t\tb[i] = false;\n\t}\n\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(!n)break;\n\t\tP h, d;\n\t\tcin >> h.X >> h.Y >> d.X >> d.Y;\n\t\tvector<P> c(n);\n\t\trep(i, n){\n\t\t\tcin >> c[i].X >> c[i].Y;\n\t\t}\n\t\tbitset<20> bits;\n\t\tbits = ~bits;\n\t\trep(i, n){\n\t\t\tbits[i] = false;\n\t\t}\n\t\tc.push_back(h);\n\t\tc.push_back(d);\n\t\tedge.resize(n+2);\n\t\trep(i, n+2){\n\t\t\tedge[i].resize(n+2);\n\t\t}\n\t\trep(i, n+2){\n\t\t\tfor(int j = i; j < n+2; j++){\n\t\t\t\tif(i == j){\n\t\t\t\t\tedge[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tedge[i][j] = edge[j][i] = dist(c[i], c[j]);\n\t\t\t}\n\t\t}\n\n\t\tcout << (dfs(c, bits, n, n+1, 0)?\"YES\":\"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nstruct Point {\n\tint x, y;\n};\n\nconst double EPS = 1E-10;\nPoint h, d, p[20];\nint n;\nbool flag[20];\n\nbool dfs(double t, int s) \n{\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tif (!flag[i]) break;\n\t}\n\tif (i == n) return true;\n\t\n\tPoint pp = (s == -1) ? h : p[s];\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tif (hypot(d.x - p[i].x, d.y - p[i].y) - hypot(pp.x - p[i].x, pp.y - p[i].y) < EPS) return false;\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tif (flag[i]) continue;\n\t\tflag[i] = true;\n\t\tif (dfs(hypot(pp.x - p[i].x, pp.y - p[i].y), i)) return true;\n\t\tflag[i] = false;\n\t}\n\t\n\treturn false;\n}\n\nint main()\n{\t\n\twhile (cin >> n >> h.x >> h.y >> d.x >> d.y, n | h.x | h.y | d.x | d.y) {\n\t\tmemset(flag, false, sizeof(flag));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p[i].x >> p[i].y;\n\t\t}\n\t\tcout << (dfs(0, -1) ? \"YES\" : \"NO\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int INF=100000000;\n// e_ÔÌ£\ndouble dist[22][22];\n// e_ÌÀW\nvector<pair<int,int> > points;\nint n,hx,hy,dx,dy;\nbool ok=false;\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\n// »ÝÌê©çßÄÂ\\ÈÅ¬ÊßbðÔ·\nvoid dfs(int s,int cp,double passedSec){\n    if(ok)\n        return;\n    else if(s==0){\n        ok=true;\n        return;\n    }\n    for(int i = 0; i < n; i++){\n        // Ü¾rbgª1ÈçÎ\n        if((s>>i)&1){\n            // áCªB·éOÉTõÂ\\©Ç¤©ð`FbN\n            double dt=dist[cp][i];\n            // ¤©çÚ®æÖÌ¼aðæ¾\n            double r=dist[n+1][i];\n            // àµ¼aªz¦Ä¢½ç,}ëè\n            if(dt+passedSec>r||EQ(dt+passedSec,r))\n                return;\n        }\n    }\n\n    for(int i = 0; i < n; i++){\n        // Ü¾rbgª1ÈçÎ\n        if((s>>i)&1){\n            // áCªB·éOÉTõÂ\\©Ç¤©ð`FbN\n            double dt=dist[cp][i];\n            // ¤©çÚ®æÖÌ¼aðæ¾\n            double r=dist[n+1][i];\n            dfs((s&(~(1<<i))),i,dt+passedSec);\n        }\n    }\n}\n\n\nint main(){\n    while(cin>>n>>hx>>hy>>dx>>dy&&!(n==0&&hx==0&&hy==0&&dx==0&&dy==0)){\n        points.clear();\n        ok=false;\n        // EÒÌúÊu\n        for(int i = 0; i < n; i++){\n            pair<int,int> p;\n            cin>>p.second>>p.first;\n            points.push_back(p);\n        }\n        points.push_back(make_pair(hy,hx));\n        points.push_back(make_pair(dy,dx));\n        for(int i = 0; i < points.size(); i++){\n            for(int j = 0; j < points.size(); j++){\n                dist[i][j]=sqrt((double)(points[i].first-points[j].first)*(points[i].first-points[j].first)\n                    +(points[i].second-points[j].second)*(points[i].second-points[j].second));\n            }\n        }\n        dfs(((1<<n)-1),n,0.0);\n        if(ok)\n            cout<<\"YES\"<<endl;\n        else\n            cout<<\"NO\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint N;\nP H,D;\nP C[22];\nint K[22][22];\nint dc[22];\nint hc[22];\n\nint getK(P a,P b){\n  return (a.F - b.F)* (a.F - b.F) + (a.S - b.S)* (a.S - b.S);\n}\n\nint sumK(int a,int b){\n  return a + b + 2*sqrt(a)*sqrt(b);\n}\n\nint solve(int id,int ky,int st){\n  if( st == (1<<N)-1 ) return true;\n  for(int i=0;i<N;i++){\n    if( st & (1<<i) ) continue;\n    int sum = sumK(ky,K[id][i]);\n    if( sum < dc[i] )\n      if( solve(i,sum,st|(1<<i)) ) return true;\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >> N >> H.F >> H.S >> D.F >> D.S;\n    if( !N && !H.F && !H.S && !D.F && !D.S ) break;\n    for(int i=0;i<N;i++) cin >> C[i].F >> C[i].S;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tK[i][j] = getK(C[i],C[j]);\n    for(int i=0;i<N;i++){\n      dc[i] = getK(C[i],D);\n      hc[i] = getK(C[i],H);\n    }\n    bool res = false;\n    for(int i=0;i<N;i++){\n      if( hc[i] < dc[i] ){\n\tif( solve(i,hc[i],(1<<i)) )  res = true;\n      }\n      if( res ) break;\n    }\n    if( res ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// ???????????????????????±????????±???\n\nint n;\nint x[30], y[30];\n\ndouble dist(int a, int b){\n    return sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));\n}\n\nbool solve(){\n    for(int i=0;i<n;i++){\n        if(dist(n, 0) + dist(0, i) >= dist(n+1, i)) return false;\n    }\n    return true;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        cin >> x[n] >> y[n] >> x[n+1] >> y[n+1];\n        for(int i=0;i<n;i++){\n            cin >> x[i] >> y[i];\n        }\n\n        if(solve()) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define pf push_front\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint n,hx,hy,dx,dy;\nvector<P> vec;\nint LIM;\nbool Found;\nconst double EPS = 1e-10;\n\nvoid print(int used)\n{\n  rep(i,n)\n\t{\n\t  if(used>>i&1)\n\t    cout << \"1\";\n\t  else\n\t    cout << \"0\";\n\t}\n      cout << endl;\n}\n\nbool Input()\n{\n  cin >> n >> hx >> hy >> dx >> dy;\n  if(n+hx+hy+dx+dy == 0)\n    return true;\n  \n  vec.clear(),LIM = 0,Found = false;\n  rep(i,n)\n    {\n      int X,Y;\n      cin >> X >> Y;\n      vec.pb(P(X,Y));\n      LIM = LIM|(1<<i);\n    }\n  return false;\n}\n\nbool isCan(P my,double ene,P p,int used)\n{\n\n  double cost = sqrt(pow(p.F-my.F,2)+pow(p.S-my.S,2));\n \n  rep(i,n)\n    {\n      if((used>>i)&1)\n\tcontinue;\n\n      double dist = sqrt(pow(vec[i].F-dx,2)+pow(vec[i].S-dy,2));\n\n      //cout << \"circle : \" << ene+cost << \" , dist : \" << dist << endl;\n      if(ene+cost >= dist)\n\treturn false;\n    }\n  return true;\n}\n\nbool check(int used,P my,double cost)\n{\n  rep(i,n)\n    {\n      if(used>>i&1)\n\tcontinue;\n      if(hypot(vec[i].F-dx,vec[i].S-dy) - (hypot(vec[i].F-my.F,vec[i].S-my.S)+cost) < EPS)\n\t{\n\t  return false;\n\t}\n    }\n  return true;\n}\n\nvoid rec(P my,double cir,int used)\n{\n  if(Found)\n    return;\n\n  if(used == LIM)\n    {\n      Found = true;\n      return;\n    }\n \n  if(!check(used,my,cir))\n    return;\n\n  rep(i,n)\n    {\n      if((used>>i)&1)\n\tcontinue;\n      rec(vec[i],cir+hypot(vec[i].F-my.F,vec[i].S-my.S),used|(1<<i));\n    }\n\n}\n\nint main(){\n  while(true)\n    {\n      if(Input())\n\tbreak;\n    \n \n      rec(P(hx,hy),0,0);\n      Found?cout << \"YES\" << endl:cout << \"NO\" << endl;\n    }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n#define EPS 10e-9\n\nint n, hx, hy, dx, dy;\nint cx[22], cy[22];\n//double c[21];\nbool flag;\n\ndouble dstnc(int ax, int ay, int bx, int by){\n    return sqrt((double)((bx-ax)*(bx-ax) + (by-ay)*(by-ay)));\n}\n\nint dfs(int S, double t, int v){\n    for(int i = 0; i < n; i++){\n        if(!(S & (1<<i)) && (dstnc(cx[v],cy[v],cx[i],cy[i]) + t + EPS > dstnc(dx,dy,cx[i],cy[i]))) return 0;\n    }\n    if(~S) return 1;\n    int ret = 0;\n    for(int i = 0; i < n; i++){\n        if(!(S & (1<<i))) ret = dfs(S | (1<<i), t + dstnc(cx[v],cy[v],cx[i],cy[i]), i);\n        if(ret) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    \n    while(cin >> n >> hx >> hy >> dx >> dy, n){\n        for(int i = 0; i < n; i++) cin >> cx[i] >> cy[i];\n        //for(int i = 0; i < n; i++) c[i] = sqrt((double)((dx-cx[i])*(dx-cx[i]) + (dy-cy[i])*(dy-cy[i])));\n        cx[21] = hx;\n        cy[21] = hy;\n        flag = dfs(0,0,21);\n        \n        \n        if(flag)cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <cstring>\nusing namespace std;\n\ntypedef complex<int> C;\n#define EPS (1e-8)\n\nint n, hx, hy, dx, dy;\nbool possible, used[21];\nC c[21];\n\ndouble dist(int x, int y) {\n\treturn sqrt( (double)x*x + (double)y*y);\n}\n\nvoid dfs(double ct, int x, int y) {\n\tif (possible) return;\n\t\n\tbool end_flag = true;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!used[i]) {\n\t\t\tend_flag = false; break;\n\t\t}\n\t}\n\tif (end_flag) {\n\t\tpossible = true; return;\n\t}\n\n\tbool flag = true;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i]) continue;\n\n\t\tdouble h2c = dist(x-c[i].real(), y-c[i].imag());\n\t\tdouble d2c = dist(dx-c[i].real(), y-c[i].imag()) + ct;\n\t\tif (h2c + EPS > d2c) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i]) continue;\n\n\t\tused[i] = true;\n\t\tdouble h2c = ct + dist(x-c[i].real(), y-c[i].imag());\n\t\tdfs(h2c, c[i].real(), c[i].imag());\n\t\tused[i] = false;\n\t}\n}\n\nvoid solve() {\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>c[i].real()>>c[i].imag();\n\t}\n\n\tmemset(used, false, sizeof used);\n\tpossible = false;\n\n\tdfs(0, hx, hy);\n\n\tif (possible) {\n\t\tcout<<\"YES\";\n\t} else {\n\t\tcout<<\"NO\";\n\t}\n\tcout<<endl;\n}\n\nint main(int argc, const char *argv[]) {\n\twhile (cin>>n>>hx>>hy>>dx>>dy, n) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef complex<double> P;\nstruct L {\n    L(const P&a, const P&b) : p({a,b}) {}\n    P p[2];\n    P & operator[](int i){\n        return p[i];\n    }\n    const P & operator[](int i) const {\n        return p[i];\n    }\n};\n\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;\n    if (cross(b, c) < 0)   return -1;\n    if (dot(b, c) < 0)     return +2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nint all,n;\nP d;\nvector<P> v;\n\nvoid pr(int m){\n    for(int i=n-1; i>=0; i--){\n        cout << ((m>>i)&1);\n    }\n    cout << endl;\n}\n\n\nbool dfs(int at, int vis, double t){\n    vis |= (1<<at);\n    if(vis == all){\n        return true;\n    }\n    rep(next,n){\n        if(vis& (1<<next)) continue;\n        P proj = projection(L(v[at], v[next]), d);\n        bool out = abs(ccw(v[at], v[next], proj)) == 2;\n        if(t + abs(v[next]-v[at]) < abs(v[next]-d) &&\n           (out || t + abs(proj-v[at]) < abs(proj-d))){\n            // cout << v[at] << v[next] << proj << endl;\n            if(dfs(next, vis, t + abs(v[next]-v[at]))){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main(){\n    while(cin>>n, n){\n        n++;\n        all = (1<<n)-1;\n        double a1,a2,a3,a4; cin>>a1>>a2>>a3>>a4;\n        v.resize(n);\n        v[0] = P(a1,a2);\n        d = P(a3,a4);\n        rep(i,n-1){\n            double x,y; cin>>x>>y;\n            v[i+1] = P(x,y);\n        }\n        sort(v.begin()+1, v.end(), [=](const P& a, const P& b){\n                return norm(a-d) < norm(b-d);\n            });\n        cout << (dfs(0,0,0) ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\n\n/*\n  dist[0]ÍEÒ\n */\nint n,hx,hy,dx,dy;\nint cx[32],cy[32];\ndouble dist[32][32]; // [1][0]  1base and 0base\ndouble maoo[32];\ndouble inf = 999999999.0;\n\ndouble sqr(int x){ return (double)x*x; }\n\nbool solve(int now, int S, double cost){\n#if DEB\n  printf(\"now:%d  S:%d  cost:%lf\\n\",now,S,cost);\n#endif\n\n  if( S==((1<<n)-1) ) return true;\n  rep(i,n)if( !((1<<i)&S) ){\n#if DEB\n    printf(\"i:%d  %lf < %lf\\n\",i, cost+dist[now][i], maoo[i]);\n#endif\n    if( cost + dist[now][i] < maoo[i] ){\n      if( solve(i+1, S|(1<<i), cost + dist[now][i]) ) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin>>n>>hx>>hy>>dx>>dy, n|hx|hy|dx|dy){\n    rep(i,32)rep(j,32)dist[i][j] = inf;\n    rep(i,n){\n      cin>>cx[i]>>cy[i];\n      dist[0][i] = sqrt(sqr(hx-cx[i])+sqr(hy-cy[i]));\n      maoo[i] = sqrt(sqr(dx-cx[i])+sqr(dy-cy[i]));\n    }\n    // eXÌNX^©çÊÌNX^ÖÌ£vZ\n    REP(i,1,n+1){\n      REP(j,i+1,n+1){\n\tdist[i][j-1] = dist[j][i-1] = sqrt(sqr(cx[i-1]-cx[j-1]) + sqr(cy[i-1]-cy[j-1]));\n      }\n    }\n#if DEB\n    rep(i,n+1){\n      rep(j,n+1){\n\tprintf(\"%9lf \",dist[i][j]==inf ? -1 : dist[i][j]);\n      }\n      puts(\"\");\n    }\n#endif\n    if( solve(0,0,0.0) ){\n      puts(\"YES\");\n    }else{\n      puts(\"NO\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str(); }\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX / 10;\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<P> vp;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n#define LT(x,y) ((x)-(y)<=-EPS)\n\nstruct state {\n\tP p;\n\tint c;\n\tdouble d;\n\tstate(P p, int c, double d) : p(p), c(c), d(d) {};\n};\n\nint main() {\n\tint n, hx, hy, dx, dy;\n\twhile (cin >> n >> hx >> hy >> dx >> dy, n) {\n\t\tvp crystal(n);\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tcrystal[i] = P(x, y);\n\t\t}\n\t\tP d(dx, dy);\n\n\t\tstack<state> S;\n\t\tS.push(state(P(hx, hy), 0, 0));\n\t\tbool success = false;\n\t\twhile (!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\n\t\t\tif (st.c == (1 << n) - 1) {\n\t\t\t\tsuccess = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(i, n) {\n\t\t\t\tif ((st.c&(1 << i)) == 0) {\n\t\t\t\t\tint nc = st.c | (1 << i);\n\t\t\t\t\tdouble nd = st.d + abs(st.p - crystal[i]);\n\t\t\t\t\tdouble dd = abs(d - crystal[i]);\n\t\t\t\t\tREP(j, n) {\n\t\t\t\t\t\tif ((nc&(1 << j)) == 0) {\n\t\t\t\t\t\t\tif (LT(abs(d - crystal[j]), dd)) {\n\t\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (LT(nd, dd)) {\n\t\t\t\t\t\tS.push(state(crystal[i], st.c | (1 << i), nd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tnext:;\n\t\t\t}\n\t\t}\n\n\t\tcout << (success ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 21\n#define EPS 1e-9\n#define INF 1e9\n\nstruct Point{\n  double x, y;\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n \n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n \n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n \n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n \n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n  double Abs(){\n    return sqrt(norm());\n  }\n}; \n\ntypedef Point Vector;\n \nstruct Segment{\n  Vector s, t;\n \n  Segment(){}\n  Segment(Vector s, Vector t) : s(s), t(t) {}\n \n  Point Projection(Point &p){\n    Vector base = t - s;\n    double t = (p-s).dot(base) / base.norm();\n    return s + base*t;\n  }\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool intersectSP(Point &p){\n    return (((s-p).Abs() + (t-p).Abs() - (t-s).Abs()) < EPS);\n  }\n\n  double distanceSP(Point &p){\n    Point r = Projection(p);\n    if(intersectSP(r)) return (r-p).Abs();\n    return min((s-p).Abs(), (t-p).Abs());\n  }\n};\n\nint N;\nPoint h, d, crystal[MAX];\n \ndouble dist(Point a, Point b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nbool used[MAX], ok;\n\nvoid rec(int S, int v, double total_dist){\n  if(ok) return;\n\n  if(S == (1 << N) - 1){\n    ok = true;\n    return;\n  }\n  for(int u = 0 ; u < N ; u++){\n    Segment s = Segment(crystal[v], crystal[u]);\n    if(s.distanceSP(d) < total_dist) return;\n    if(total_dist+dist(crystal[v],crystal[u]) >= dist(d, crystal[u])){\n      return;\n    }\n    if(!(S >> u & 1)){\n      rec(S | 1 << u, u, total_dist + dist(crystal[v],crystal[u]));\n    }\n  }\n}\n\nbool solve(){\n  sort(crystal, crystal+N);\n\n  for(int i = 0 ; i < N ; i++){\n    ok = false;\n    memset(used, false, sizeof(used));\n    rec(0, i, dist(h, crystal[i]));\n    if(ok){\n      return true;\n    }\n  }\n\n  return false;\n}\n \nint main(){\n  while(cin >> N >> h.x >> h.y >> d.x >> d.y, (N + h.x + h.y + d.x + d.y)){\n    for(int i = 0 ; i < N ; i++){\n      cin >> crystal[i].x >> crystal[i].y;\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2008 \n  Title:Dragon Fansy\n  @kankichi573\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#define sqr(x) ((x)*(x))\n\nint n,hx,hy,dx,dy;\nstruct xtal_st\n{\n        int x;\n        int y;\n        double dist;\n} xtal[20];\ndouble calc_dist(int x1,int y1,int x2,int y2)\n{\n        return(sqrt((double)(sqr(x1-x2)+sqr(y1-y2))));\n}\nint solve()\n{\n        int i;\n        double acc;\n        acc=calc_dist(hx,hy,xtal[0].x,xtal[0].y);\n        for(i=0;i<n;i++)\n        {\n                //printf(\"%lf,%lf\\n\",acc,xtal[i].dist);\n\n                if(acc >= xtal[i].dist)\n                        return(0);\n                acc += calc_dist(xtal[i].x,xtal[i].y,xtal[i+1].x,xtal[i+1].y);\n        }\n        return(1);\n}\n\nint comp_(const void *a, const void *b)\n{\n        return (((struct xtal_st *)b)->dist - ((struct xtal_st *)a)->dist);\n}\n\n\n\nvoid set_dist(struct xtal_st *xtal)\n{\n        int i;\n        for(i=0;i<n;i++)\n                xtal->dist=sqrt(sqr(xtal->x-dx)+sqr(xtal->y-dy));\n}\nmain()\n{\n        int i;\n\n        while(EOF!=scanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy) &&  \n              (n||hx||hy||dx||dy))\n        {\n                for(i=0;i<n;i++)\n                {\n                        scanf(\"%d %d\",&xtal[i].x,&xtal[i].y);\n                        set_dist(&xtal[i]);\n                }\n                qsort(xtal,n,sizeof(struct xtal_st),comp_);\n                printf(\"%s\\n\",solve()?\"YES\":\"NO\");\n        }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define MAX 20\n#define INF 1E10\n\nfloat DP[1 << MAX][MAX];\nint points[MAX][2];\nfloat adj[MAX][MAX];\n\nint main(int argc, char* argv[]){\n  \n Loop:\n  for(;;){\n    int n, i, j, k, S;\n    long h_x, h_y, g_x, g_y;\n    \n    scanf(\"%d\", &n);\n    if(n == 0){\n      break;\n    }\n    \n    scanf(\"%ld %ld %ld %ld\", &h_x, &h_y, &g_x, &g_y);\n\n    for(i = 0; i < n; i++){\n      scanf(\"%ld %ld\", &points[i][0], &points[i][1]);\n    }\n    \n    for(i = 0; i < n; i++){\n      for(j = i + 1; j < n; j++){\n\tadj[i][j] = adj[j][i] = sqrt(\n\t  (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) +\n\t  (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]));\n      }\n    }\n\n    for(S = 0; S < 1 << n; S++){\n      for(i = 0; i < n; i++){\n\tDP[S][i] = INF;\n      }\n    }\n\n    for(i = 0; i < n; i++){\n      DP[1 << i][i] = sqrt(\n\t  (points[i][0] - h_x) * (points[i][0] - h_x) +\n\t  (points[i][1] - h_y) * (points[i][1] - h_y));\n    }\n    \n    for(S = 0; S < 1 << n; S++){\n      for(i = 0; i < n; i++){\n\tif((S & (1 << i)) == 0){\n\t  continue;\n\t}else if(DP[S][i] == INF){\n\t  continue;\n\t}\n\n\tfor(j = 0; j < n; j++){\n\t  if((S & (1 << j)) != 0){\n\t    continue;\n\t  }\n\t  \n\t  {\n\t    double cost = DP[S][i] + adj[i][j];\n\t    double time = sqrt(\n\t      (points[j][0] - g_x) * (points[j][0] - g_x) +\n\t      (points[j][1] - g_y) * (points[j][1] - g_y));\n\n\t    if(time > cost && DP[S | (1 << j)][i] > cost){\n\t      DP[S | (1 << j)][i] = cost;\n\t    }\n\t  }\n\t}\n      }\n    }\n    \n    for(i = 0; i < n; i++){\n      if(DP[(1 << n) - 1][i] != INF){\n\tprintf(\"YES\\n\");\n\tgoto Loop;\n      }\n    }\n\n    printf(\"NO\\n\");\n  }\n  \n  return 0;\n}\n\t "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\n#define MAX_CRY_NUM 1000\n\nint main(){\n    int crystal_num, crystal_num_org;\n    int hero_x, hero_y;\n    int mao_x, mao_y;\n    int temp_x, temp_y;\n    int i, min_i;\n    int min_update_flg;\n    int crystal_x[MAX_CRY_NUM];\n    int crystal_y[MAX_CRY_NUM];\n    char check_need_flg[MAX_CRY_NUM];\n    double min, dist, total_hero_dist, mao_dist;\n\n\n    while(1){\n        /* initiallize */\n        total_hero_dist = 0;\n        for(i = 0; i < MAX_CRY_NUM; i++){\n            check_need_flg[i] = 0;\n        }\n\n        /* get num of crystal */\n        scanf(\"%d\", &crystal_num);\n        \n        /* get addr of hero */\n        scanf(\"%d\", &hero_x);\n        scanf(\"%d\", &hero_y);\n        \n        /* get addr of mao */\n        scanf(\"%d\", &mao_x);\n        scanf(\"%d\", &mao_y);\n        \n        /* end condition */\n        if((crystal_num == 0) && (hero_x == 0) && (hero_y == 0) && (mao_x == 0) && (mao_y == 0)){\n            break;\n        }\n\n        /* get addr of crystal */\n        for(i = 0; i < crystal_num; i++){\n            scanf(\"%d\", &crystal_x[i]);\n            scanf(\"%d\", &crystal_y[i]);\n            check_need_flg[i] = 1;\n        }\n\n        crystal_num_org = crystal_num;\n\n        /*  */\n        while(1){\n            min = 0xFFFFFFFF;\n            min_update_flg = 0;\n            for(i = 0; i < crystal_num_org; i++){\n                if(check_need_flg[i] == 1){\n                    dist = sqrt(((crystal_x[i] - hero_x) * (crystal_x[i] - hero_x)) + ((crystal_y[i] - hero_y) * (crystal_y[i] - hero_y)));\n                    if(min > dist){\n                        min = dist;\n                        min_i = i;\n                        temp_x = crystal_x[i];\n                        temp_y = crystal_y[i];\n                        min_update_flg = 1;\n                    }\n                }\n            }\n            if(min_update_flg == 1){\n                hero_x = temp_x;\n                hero_y = temp_y;\n                total_hero_dist += min;\n                check_need_flg[min_i] = 0;\n            }\n\n            crystal_num--;\n            if(crystal_num == 0){\n                break;\n            }\n            \n        }\n\n        /* calc mao dist to last hero point */\n        mao_dist = sqrt(((mao_x - hero_x) * (mao_x - hero_x)) + ((mao_y - hero_y) * (mao_y - hero_y)));\n\n        if(total_hero_dist >= mao_dist){\n            /* output No if hero is in mao area */\n            printf(\"No\\n\");\n        }\n        else{\n            /* output Yes if hero is out of mao area */\n            printf(\"Yes\\n\");\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint n,hx,hy,dx,dy;\nint cx[20],cy[20],flag[20];\nint i,j;\n\nint check(int c,double rsum,int hx,int hy){\n    double r;\n    if(c==n)return 1;\n    for(i=0;i<n;i++){\n        if(flag[i]==0){\n            r=rsum+sqrt((hx-cx[i])*(hx-cx[i])+(hy-cy[i])*(hy-cy[i]));\n            if(r+1e-8>sqrt((dx-cx[i])*(dx-cx[i])+(dy-cy[i])*(dy-cy[i])))return 0;\n        }\n    }\n    for(i=0;i<n;i++){\n        if(flag[i]==0){\n            flag[i]=1;\n            r=rsum+sqrt((hx-cx[i])*(hx-cx[i])+(hy-cy[i])*(hy-cy[i]));\n            if(check(c+1,r,cx[i],cy[i])==0)flag[i]=0;\n            else return 2;\n        }\n    }\n    return 0;\n}\n\nint main(void){\n    while(1){\n        scanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n        if(n==0 && hx==0 && hy==0 && dx==0 && dy==0)break;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&cx[i],&cy[i]);\n            flag[i]=0;\n        }\n        if(check(0,0.0,hx,hy)==2)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2008: Dragon Fantasy\n// 2017.11.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\nint cx[22], cy[22], n;\ndouble dh[22], dd[22];\ndouble dc[22][22];\n\ndouble dist(int x1, int y1, int x2, int y2)\n{\n\treturn hypot(x1-x2, y1-y2);\n}\n\nint rec(int i, int s, double d)\n{\n\tint j, jj;\n\n\tif (s == (1<<n) - 1) return 1;\n\tfor (jj = 1, j = 0; j < n; j++, jj <<= 1) {\n\t\tif (s & jj) continue;\n\t\tif (dd[j] < d + dc[i][j]) return 0;\n\t}\n\tfor (jj = 1, j = 0; j < n; j++, jj <<= 1) {\n\t\tif (s & jj) continue;\n\t\tif (dd[j] > d + dc[i][j] && rec(j, s | jj, d + dc[i][j])) return 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, hx, hy, dx, dy;\n\n\twhile (scanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy) && n > 0) {\n\t\tn++;\n\t\tcx[0] = hx, cy[0] = hy;\tfor (i = 1; i < n; i++) scanf(\"%d%d\", cx+i, cy+i);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tdd[i] = dist(cx[i], cy[i], dx, dy);\n\t\t\tdh[i] = dist(cx[i], cy[i], hx, hy);\n\t\t\tdc[i][i] = 0;\n\t\t\tfor (j = i+1; j < n; j++) {\n\t\t\t\tdc[i][j] = dc[j][i] = dist(cx[i], cy[i], cx[j], cy[j]);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 1; i < n; i++) if (dh[i] > dd[i]) break;\n\t\tif (i < n) puts(\"NO\");\n\t\telse puts(rec(0, 0, 0) ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2008: Dragon Fantasy\n// 2017.11.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define R 100\ntypedef long long ll;\n#define dist(x, y)\t((ll)(hypot(x, y)))\n\nint cx[22], cy[22], n, lim;\nll dd[22];\nll dc[22][22];\n\nint rec(int i, int s, double d)\n{\n\tint j, jj;\n\n\tif (s == lim) return 1;\n\tfor (jj = 1, j = 0; j < n; j++, jj <<= 1) {\n\t\tif (s & jj) continue;\n\t\tif (dd[j] <= d + dc[i][j]) return 0;\n\t}\n\tfor (jj = 1, j = 0; j < n; j++, jj <<= 1) {\n\t\tif (s & jj) continue;\n\t\tif (rec(j, s | jj, d + dc[i][j])) return 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, hx, hy, dx, dy, x, y;\n\n\twhile (scanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy) && n > 0) {\n\t\thx *= R, hy *= R, dx *= R, dy *= R;\n\t\tn++; lim = (1<<n)-1;\n\t\tcx[0] = hx, cy[0] = hy;\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y), cx[i] = x*R, cy[i] = y*R;\n\t\t}\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tdd[i] = dist(cx[i]-dx, cy[i]-dy);\n\t\t\tfor (j = i+1; j < n; j++) {\n\t\t\t\tdc[i][j] = dc[j][i] = dist(cx[i]-cx[j], cy[i]-cy[j]);\n\t\t\t}\n\t\t}\n\t\tputs(rec(0, 0, 0) ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define MAX 20\n#define INF 1E15\n\nfloat DP[1 << MAX][MAX];\nlong points[MAX][2];\ndouble adj[MAX][MAX];\n\nint main(int argc, char* argv[]){\n  \n Loop:\n  for(;;){\n    int n, i, j, k, S;\n    long h_x, h_y, g_x, g_y;\n    \n    scanf(\"%d\", &n);\n    if(n == 0){\n      break;\n    }\n    \n    scanf(\"%ld %ld %ld %ld\", &h_x, &h_y, &g_x, &g_y);\n\n    for(i = 0; i < n; i++){\n      scanf(\"%ld %ld\", &points[i][0], &points[i][1]);\n    }\n    \n    for(i = 0; i < n; i++){\n      for(j = i + 1; j < n; j++){\n\tadj[i][j] = adj[j][i] = sqrt(\n\t  (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) +\n\t  (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]));\n      }\n    }\n\n    for(S = 0; S < 1 << n; S++){\n      for(i = 0; i < n; i++){\n\tDP[S][i] = INF;\n      }\n    }\n\n    for(i = 0; i < n; i++){\n      DP[1 << i][i] = sqrt(\n\t  (points[i][0] - h_x) * (points[i][0] - h_x) +\n\t  (points[i][1] - h_y) * (points[i][1] - h_y));\n    }\n    \n    for(S = 0; S < 1 << n; S++){\n      for(i = 0; i < n; i++){\n\tif((S & (1 << i)) == 0){\n\t  continue;\n\t}else if(DP[S][i] == INF){\n\t  continue;\n\t}\n\n\tfor(j = 0; j < n; j++){\n\t  if((S & (1 << j)) != 0){\n\t    continue;\n\t  }\n\t  \n\t  {\n\t    double cost = DP[S][i] + adj[i][j];\n\t    double time = sqrt(\n\t      (points[j][0] - g_x) * (points[j][0] - g_x) +\n\t      (points[j][1] - g_y) * (points[j][1] - g_y));\n\n\t    if(time > cost && DP[S | (1 << j)][i] > cost){\n\t      DP[S | (1 << j)][i] = cost;\n\t    }\n\t  }\n\t}\n      }\n    }\n    \n    for(i = 0; i < n; i++){\n      if(DP[(1 << n) - 1][i] != INF){\n\tprintf(\"YES\\n\");\n\tgoto Loop;\n      }\n    }\n\n    printf(\"NO\\n\");\n  }\n  \n  return 0;\n}\n\t "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct{\n    int x, y;\n}point;\n\npoint c[21];\npoint hero;\npoint demon;\n\nint n;\nint c_len[21];\nint done[21];\n\nint solve(int no, int day)\n{\n    int i;\n    //if(no)\n    //    printf(\"day %d: got crystal no %d\\n\", day, no);\n\n    for(i = 1; i <= n; i++)\n        if(!done[i])\n            break;\n\n    if(i == (n + 1))\n        return 1;\n\n    for(i = 1; i <= n; i++)\n        if(c_len[i] <= day * day && !done[i])\n            return 0;\n\n    int ret = 0;\n    for(i = 1; i <= n; i++){\n        if(done[i])\n            continue;\n\n        int dx = c[i].x - c[no].x;\n        int dy = c[i].y - c[no].y;\n        double len = dx * dx + dy * dy;\n        double plen = sqrt(c_len[i]);\n        plen -= day;\n        len = sqrt(len);\n\n        //printf(\"%d to %d: %lf\\n\", no, i, len);\n        //printf(\"poison circle to %d: %lf\\n\", i, plen);\n\n        if(len >= plen)\n            continue;\n        double temp = fmod(plen, 1);\n\n        int take;\n        if(temp <= 1E-10)\n            take = (int)len;\n        else\n            take = (int)len + 1;\n\n        done[i] = 1;\n        ret = solve(i, day + take);\n        done[i] = 0;\n\n        if(ret == 1)\n            break;\n    }\n\n    return ret;\n}\n\nint main(void)\n{\n    while(1){\n        scanf(\"%d %d %d %d %d\", &n, &(hero.x), &(hero.y), &(demon.x), &(demon.y));\n        if(n == 0 && hero.x == 0 && hero.y == 0 && demon.x == 0 && demon.y == 0)\n            break;\n\n        c[0].x = hero.x;\n        c[0].y = hero.y;\n\n        int i;\n        for(i = 1; i <= n; i++){\n            int dx, dy;\n            done[i] = 0;\n            scanf(\"%d %d\", &(c[i].x), &(c[i].y));\n            dx = demon.x - c[i].x;\n            dy = demon.y - c[i].y;\n            c_len[i] = dx * dx + dy * dy;\n        }\n\n        int res = solve(0, 0);\n        if(res)\n            printf(\"YES\\n\");\n        else\n            printf(\"NO\\n\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define MAX 20\n#define INF 1E15\n\ndouble DP[1 << MAX][MAX];\nlong points[MAX][2];\ndouble adj[MAX][MAX];\n\nint main(int argc, char* argv[]){\n  \n Loop:\n  for(;;){\n    int n, i, j, k, S;\n    long h_x, h_y, g_x, g_y;\n    \n    scanf(\"%d\", &n);\n    if(n == 0){\n      break;\n    }\n    \n    scanf(\"%ld %ld %ld %ld\", &h_x, &h_y, &g_x, &g_y);\n\n    for(i = 0; i < n; i++){\n      scanf(\"%ld %ld\", &points[i][0], &points[i][1]);\n    }\n    \n    for(i = 0; i < n; i++){\n      for(j = i + 1; j < n; j++){\n\tadj[i][j] = adj[j][i] = sqrt(\n\t  (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) +\n\t  (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]));\n      }\n    }\n\n    for(S = 0; S < 1 << n; S++){\n      for(i = 0; i < n; i++){\n\tDP[S][i] = INF;\n      }\n    }\n\n    for(i = 0; i < n; i++){\n      DP[1 << i][i] = sqrt(\n\t  (points[i][0] - h_x) * (points[i][0] - h_x) +\n\t  (points[i][1] - h_y) * (points[i][1] - h_y));\n    }\n    \n    for(S = 0; S < 1 << n; S++){\n      for(i = 0; i < n; i++){\n\tif((S & (1 << i)) == 0){\n\t  continue;\n\t}else if(DP[S][i] == INF){\n\t  continue;\n\t}\n\n\tfor(j = 0; j < n; j++){\n\t  if((S & (1 << j)) != 0){\n\t    continue;\n\t  }\n\t  \n\t  {\n\t    double cost = DP[S][i] + adj[i][j];\n\t    double time = sqrt(\n\t      (points[j][0] - g_x) * (points[j][0] - g_x) +\n\t      (points[j][1] - g_y) * (points[j][1] - g_y));\n\n\t    if(time > cost && DP[S | (1 << j)][i] > cost){\n\t      DP[S | (1 << j)][i] = cost;\n\t    }\n\t  }\n\t}\n      }\n    }\n    \n    for(i = 0; i < n; i++){\n      if(DP[(1 << n) - 1][i] != INF){\n\tprintf(\"YES\\n\");\n\tgoto Loop;\n      }\n    }\n\n    printf(\"NO\\n\");\n  }\n  \n  return 0;\n}\n\t "
  },
  {
    "language": "C",
    "code": "// AOJ 2008: Dragon Fantasy\n// 2017.11.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\nint cx[22], cy[22], n;\ndouble dc[22][22], dd[22];\n\ndouble dist(int x1, int y1, int x2, int y2)\n{\n\treturn hypot(x1-x2, y1-y2);\n}\n\nint rec(int i, int s, double d)\n{\n\tint j, jj;\n\n\tif (s == (1<<n) - 1) return 1;\n\tfor (jj = 1, j = 0; j < n; j++, jj <<= 1) {\n\t\tif (s & jj) continue;\n\t\tif (dd[j] < d + dc[i][j]) return 0;\n\t}\n\tfor (jj = 1, j = 0; j < n; j++, jj <<= 1) {\n\t\tif (s & jj) continue;\n\t\tif (dd[j] > d + dc[i][j] && rec(j, s | jj, d + dc[i][j])) return 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, dx, dy;\n\n\twhile (scanf(\"%d%d%d%d%d\", &n, cx, cy, &dx, &dy) && n > 0) {\n\t\tn++;\n\t\tfor (i = 1; i < n; i++) scanf(\"%d%d\", cx+i, cy+i);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tdd[i] = dist(cx[i], cy[i], dx, dy);\n\t\t\tdc[i][i] = 0;\n\t\t\tfor (j = i+1; j < n; j++) {\n\t\t\t\tdc[i][j] = dc[j][i] = dist(cx[i], cy[i], cx[j], cy[j]);\n\t\t\t}\n\t\t}\n\t\tputs(rec(0, 0, 0) ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define EPS (1e-10)\n\nint used[20];\nint cx[20],cy[20];\nint dx,dy;\nint n;\nint tmp;\n\nvoid dragon(int c,double sum,int hx,int hy)\n{\n\tint i;\n\tdouble r;\n\t\n\tif(tmp)return;\n\n\tif(c==n){\n\t\ttmp = 1;\n\t\treturn;\n\t}\n\t\n\tfor(i=0;i<n;i++){\n\t\tif(used[i]==0){\n\t\t  r = sum + sqrt((hx-cx[i])*(hx-cx[i])+(hy-cy[i])*(hy-cy[i]));\n\t\t\tif(r + EPS > sqrt((dx-cx[i])*(dx-cx[i])+(dy-cy[i])*(dy-cy[i])) )return;\n\t\t}\n\t}\n\t\n\tfor(i=0;i<n;i++){\n\t\tif(used[i]==0){\n\t\t\tused[i]=1;\n\t\t\tr = sum + sqrt((hx-cx[i])*(hx-cx[i])+(hy-cy[i])*(hy-cy[i]));\n\t\t\tdragon(c+1,r,cx[i],cy[i]);\n\t\t\tused[i]=0;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint i,j,c;\n\tint hx,hy;\n\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n==0 && hx==0 && hy==0 && dx==0 && dy==0)break;\n\t\t\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t  \n\t\tfor(i=0;i<n;i++){\n\t\t\tused[i]=0;\n\t\t}\n    \n    tmp = 0;\n    dragon(0.0,hx,hy);\n\t\tif(tmp){\n\t\t\tprintf(\"YES\\n\");\n\t\t}else{\n\t\t\tprintf(\"NO\\n\");\n\t\t}\n\t\t\n\t}\n\treturn 0;\n\t\n}\t\n\n\n\t\t"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX_CRY_NUM 1000\n\nint main(){\n    int crystal_num, crystal_num_org;\n    int hero_x, hero_y;\n    int mao_x, mao_y;\n    int temp_x, temp_y;\n    int i;\n    int crystal_x[MAX_CRY_NUM];\n    int crystal_y[MAX_CRY_NUM];\n    char check_need_flg[MAX_CRY_NUM];\n    unsigned long min, dist, total_hero_dist, mao_dist;\n\n\n    while(1){\n        /* initiallize */\n        total_hero_dist = 0;\n        for(i = 0; i < MAX_CRY_NUM; i++){\n            check_need_flg[i] = 0;\n        }\n\n        /* get num of crystal */\n        scanf(\"%d\", &crystal_num);\n        \n        /* get addr of hero */\n        scanf(\"%d\", &hero_x);\n        scanf(\"%d\", &hero_y);\n        \n        /* get addr of mao */\n        scanf(\"%d\", &mao_x);\n        scanf(\"%d\", &mao_y);\n        \n        /* end condition */\n        if((crystal_num == 0) && (hero_x == 0) && (hero_y == 0) && (mao_x == 0) && (mao_y == 0)){\n            break;\n        }\n\n        /* get addr of crystal */\n        for(i = 0; i < crystal_num; i++){\n            scanf(\"%d\", &crystal_x[i]);\n            scanf(\"%d\", &crystal_y[i]);\n            check_need_flg[i] = 1;\n        }\n\n        crystal_num_org = crystal_num;\n\n        /*  */\n        while(1){\n            min = 0xFFFFFFFF;\n            for(i = 0; i < crystal_num_org; i++){\n                if(check_need_flg[i] == 1){\n                    dist = ((crystal_x[i] - hero_x) ^ 2) + ((crystal_y[i] - hero_y) ^ 2);\n                    if(min > dist){\n                        min = dist;\n                        temp_x = crystal_x[i];\n                        temp_y = crystal_y[i];\n                    }\n                }\n            }\n            hero_x = temp_x;\n            hero_y = temp_y;\n            total_hero_dist += min;\n\n            crystal_num--;\n            if(crystal_num == 0){\n                break;\n            }\n            \n        }\n\n        /* calc mao dist to last hero point */\n        mao_dist = ((mao_x - hero_x) ^ 2) + ((mao_y - hero_y) ^ 2);\n\n        if(total_hero_dist < mao_dist){\n            /* output No if hero is in mao area */\n            printf(\"No\\n\");\n        }\n        else{\n            /* output Yes if hero is out of mao area */\n            printf(\"Yes\\n\");\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct{\n    int x, y;\n}point;\n\npoint c[21];\npoint hero;\npoint demon;\n\nint n;\nint c_len[21];\nint done[21];\n\nint solve(int no, int day)\n{\n    int i;\n    for(i = 1; i <= n; i++)\n        if(!done[i])\n            break;\n\n    if(i == (n + 1))\n        return 1;\n\n    for(i = 1; i <= n; i++)\n        if(c_len[i] <= day * day)\n            return 0;\n\n    int ret = 0;\n    for(i = 1; i <= n; i++){\n        if(done[i])\n            continue;\n\n        int dx = c[i].x - c[no].x;\n        int dy = c[i].y - c[no].y;\n        double len = dx * dx + dy * dy;\n        double plen = sqrt(c_len[i]);\n        plen -= day;\n        len = sqrt(len);\n\n        if(len >= plen)\n            continue;\n\n        int take = (int)len + 1;\n\n        done[i] = 1;\n        ret = solve(i, day + take);\n        done[i] = 0;\n\n        if(ret == 1)\n            break;\n    }\n\n    return ret;\n}\n\nint main(void)\n{\n    while(1){\n        scanf(\"%d %d %d %d %d\", &n, &(hero.x), &(hero.y), &(demon.x), &(demon.y));\n        if(n == 0 && hero.x == 0 && hero.y == 0 && demon.x == 0 && demon.y == 0)\n            break;\n\n        c[0].x = hero.x;\n        c[0].y = hero.y;\n\n        int i;\n        for(i = 1; i <= n; i++){\n            int dx, dy;\n            scanf(\"%d %d\", &(c[i].x), &(c[i].y));\n            dx = demon.x - c[i].x;\n            dy = demon.y - c[i].y;\n            c_len[i] = dx * dx + dy * dy;\n        }\n\n        int res = solve(0, 0);\n        if(res)\n            printf(\"YES\\n\");\n        else\n            printf(\"NO\\n\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define MAX 20\n#define INF 1E10\n\nfloat DP[1 << MAX][MAX];\nlong points[MAX][2];\ndouble adj[MAX][MAX];\n\nint main(int argc, char* argv[]){\n  \n Loop:\n  for(;;){\n    int n, i, j, k, S;\n    long h_x, h_y, g_x, g_y;\n    \n    scanf(\"%d\", &n);\n    if(n == 0){\n      break;\n    }\n    \n    scanf(\"%ld %ld %ld %ld\", &h_x, &h_y, &g_x, &g_y);\n\n    for(i = 0; i < n; i++){\n      scanf(\"%ld %ld\", &points[i][0], &points[i][1]);\n    }\n    \n    for(i = 0; i < n; i++){\n      for(j = i + 1; j < n; j++){\n\tadj[i][j] = adj[j][i] = sqrt(\n\t  (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) +\n\t  (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]));\n      }\n    }\n\n    for(S = 0; S < 1 << n; S++){\n      for(i = 0; i < n; i++){\n\tDP[S][i] = INF;\n      }\n    }\n\n    for(i = 0; i < n; i++){\n      DP[1 << i][i] = sqrt(\n\t  (points[i][0] - h_x) * (points[i][0] - h_x) +\n\t  (points[i][1] - h_y) * (points[i][1] - h_y));\n    }\n    \n    for(S = 0; S < 1 << n; S++){\n      for(i = 0; i < n; i++){\n\tif((S & (1 << i)) == 0){\n\t  continue;\n\t}else if(DP[S][i] == INF){\n\t  continue;\n\t}\n\n\tfor(j = 0; j < n; j++){\n\t  if((S & (1 << j)) != 0){\n\t    continue;\n\t  }\n\t  \n\t  {\n\t    double cost = DP[S][i] + adj[i][j];\n\t    double time = sqrt(\n\t      (points[j][0] - g_x) * (points[j][0] - g_x) +\n\t      (points[j][1] - g_y) * (points[j][1] - g_y));\n\n\t    if(time > cost && DP[S | (1 << j)][i] > cost){\n\t      DP[S | (1 << j)][i] = cost;\n\t    }\n\t  }\n\t}\n      }\n    }\n    \n    for(i = 0; i < n; i++){\n      if(DP[(1 << n) - 1][i] != INF){\n\tprintf(\"YES\\n\");\n\tgoto Loop;\n      }\n    }\n\n    printf(\"NO\\n\");\n  }\n  \n  return 0;\n}\n\t "
  },
  {
    "language": "C",
    "code": "// AOJ 2008: Dragon Fantasy\n// 2017.11.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define dist(x, y)\t(hypot(x, y))\n\nint cx[22], cy[22], n, lim;\ndouble dd[22];\ndouble dc[22][22];\n\nint rec(int i, int s, double d)\n{\n\tint j, jj;\n\n\tif (s == lim) return 1;\n\tfor (jj = 1, j = 0; j < n; j++, jj <<= 1) {\n\t\tif (s & jj) continue;\n\t\tif (dd[j] <= d + dc[i][j]) return 0;\n\t}\n\tfor (jj = 1, j = 0; j < n; j++, jj <<= 1) {\n\t\tif (s & jj) continue;\n\t\tif (rec(j, s | jj, d + dc[i][j])) return 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, hx, hy, dx, dy;\n\n\twhile (scanf(\"%d%d%d%d%d\", &n, &hx, &hy, &dx, &dy) && n > 0) {\n\t\tn++; lim = (1<<n)-1;\n\t\tcx[0] = hx, cy[0] = hy;\n\t\tfor (i = 1; i < n; i++) scanf(\"%d%d\", cx+i, cy+i);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tdd[i] = dist(cx[i]-dx, cy[i]-dy);\n\t\t\tfor (j = i+1; j < n; j++) {\n\t\t\t\tdc[i][j] = dc[j][i] = dist(cx[i]-cx[j], cy[i]-cy[j]);\n\t\t\t}\n\t\t}\n\t\tputs(rec(0, 0, 0) ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define EPS (1e-10)\n\nint used[20];\nint cx[20],cy[20];\nint dx,dy;\nint n;\nint tmp;\n\nvoid dragon(int c,double sum,int hx,int hy)\n{\n\tint i;\n\tdouble r;\n\t\n\tif(tmp)return;\n\n\tif(c==n){\n\t\ttmp = 1;\n\t\treturn;\n\t}\n\t\n\tfor(i=0;i<n;i++){\n\t\tif(used[i]==0){\n\t\t  r = sum + sqrt((hx-cx[i])*(hx-cx[i])+(hy-cy[i])*(hy-cy[i]));\n\t\t\tif(r + EPS > sqrt((dx-cx[i])*(dx-cx[i])+(dy-cy[i])*(dy-cy[i])) )return;\n\t\t}\n\t}\n\t\n\tfor(i=0;i<n;i++){\n\t\tif(used[i]==0){\n\t\t\tused[i]=1;\n\t\t\tr = sum + sqrt((hx-cx[i])*(hx-cx[i])+(hy-cy[i])*(hy-cy[i]));\n\t\t\tdragon(c+1,r,cx[i],cy[i]);\n\t\t\tused[i]=0;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint i,j,c;\n\tint hx,hy;\n\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n==0 && hx==0 && hy==0 && dx==0 && dy==0)break;\n\t\t\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t  \n\t\tfor(i=0;i<n;i++){\n\t\t\tused[i]=0;\n\t\t}\n    \n    tmp = 0;\n    dragon(0,0.0,hx,hy);\n\t\tif(tmp){\n\t\t\tprintf(\"YES\\n\");\n\t\t}else{\n\t\t\tprintf(\"NO\\n\");\n\t\t}\n\t\t\n\t}\n\treturn 0;\n\t\n}\t\n\n\n\t\t"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint n,hx,hy,dx,dy;\nint cx[20],cy[20],flag[20];\nint i,j;\n\nint check(int c,double rsum,int hx,int hy){\n    double r;\n    if(c==n)return 1;\n    for(i=0;i<n;i++){\n        if(flag[i]==0){\n            r=rsum+sqrt((hx-cx[i])*(hx-cx[i])+(hy-cy[i])*(hy-cy[i]));\n            if(r+0.0001>sqrt((dx-cx[i])*(dx-cx[i])+(dy-cy[i])*(dy-cy[i])))return 0;\n        }\n    }\n    for(i=0;i<n;i++){\n        if(flag[i]==0){\n            flag[i]=1;\n            r=rsum+sqrt((hx-cx[i])*(hx-cx[i])+(hy-cy[i])*(hy-cy[i]));\n            if(check(c+1,r,cx[i],cy[i])==0)flag[i]=0;\n            else return 2;\n        }\n    }\n    return 0;\n}\n\nint main(void){\n    while(1){\n        scanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n        if(n==0 && hx==0 && hy==0 && dx==0 && dy==0)break;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&cx[i],&cy[i]);\n            flag[i]=0;\n        }\n        if(check(0,0.0,hx,hy)==2)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint n,hx,hy,dx,dy;\nint cx[20],cy[20],flag[20];\n\nint check(int c,double rsum,int hx,int hy){\n    int i;\n    double r;\n    if(c==n)return 1;\n    for(i=0;i<n;i++){\n        if(flag[i]==0){\n            r=rsum+sqrt((hx-cx[i])*(hx-cx[i])+(hy-cy[i])*(hy-cy[i]));\n            if(r+1e-8>sqrt((dx-cx[i])*(dx-cx[i])+(dy-cy[i])*(dy-cy[i])))return 0;\n        }\n    }\n    for(i=0;i<n;i++){\n        if(flag[i]==0){\n            flag[i]=1;\n            r=rsum+sqrt((hx-cx[i])*(hx-cx[i])+(hy-cy[i])*(hy-cy[i]));\n            if(check(c+1,r,cx[i],cy[i])==0)flag[i]=0;\n            else return 2;\n        }\n    }\n    return 0;\n}\n\nint main(void){\n    int i;\n    while(1){\n        scanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n        if(n==0 && hx==0 && hy==0 && dx==0 && dy==0)break;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&cx[i],&cy[i]);\n            flag[i]=0;\n        }\n        if(check(0,0.0,hx,hy)==2)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2008 \n  Title:Dragon Fansy\n  @kankichi573\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#define sqr(x) ((x)*(x))\n\nint n,hx,hy,dx,dy;\nstruct xtal_st\n{\n        int x;\n        int y;\n        double dist;\n} xtal[20];\ndouble calc_dist(int x1,int y1,int x2,int y2)\n{\n        return(sqrt((double)(sqr(x1-x2)+sqr(y1-y2))));\n}\nint solve()\n{\n        int i;\n        double acc;\n        acc=calc_dist(hx,hy,xtal[0].x,xtal[0].y);\n        for(i=0;i<n;i++)\n        {\n                //printf(\"%lf,%lf\\n\",acc,xtal[i].dist);\n\n                if(acc >= xtal[i].dist)\n                        return(0);\n                acc += calc_dist(xtal[i].x,xtal[i].y,xtal[i+1].x,xtal[i+1].y);\n        }\n        return(1);\n}\n\nint comp_(const void *a, const void *b)\n{\n        return (((struct xtal_st *)b)->dist - ((struct xtal_st *)a)->dist);\n}\n\n\n\nvoid set_dist(struct xtal_st *xtal)\n{\n        int i;\n        for(i=0;i<n;i++)\n                xtal->dist=sqrt(sqr(xtal->x-dx)+sqr(xtal->y-dy));\n}\nmain()\n{\n        int i;\n\n        while(EOF!=scanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy) &&  \n              (n||hx||hy||dx||dy))\n        {\n                for(i=0;i<n;i++)\n                {\n                        scanf(\"%d %d\",&xtal[i].x,&xtal[i].y);\n                        set_dist(&xtal[i]);\n                }\n                qsort(xtal,n,sizeof(struct xtal_st),comp_);\n                printf(\"%s\\n\",solve()?\"yes\":\"no\");\n        }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define EPS (1e-10)\n\nint used[20];\nint cx[20],cy[20];\nint dx,dy;\nint n;\nint tmp;\n\nvoid dragon(double sum,int hx,int hy)\n{\n\tint i,c;\n\tdouble r;\n\t\n\tif(tmp)return;\n\t\n\tc=0;\n\tfor(i=0;i<n;i++){\n\t\tif(used[i])c++;\n\t}\n\tif(c==n){\n\t\ttmp = 1;\n\t\treturn;\n\t}\n\t\n\tfor(i=0;i<n;i++){\n\t\tif(used[i]==0){\n\t\t  r = sum + sqrt((hx-cx[i])*(hx-cx[i])+(hy-cy[i])*(hy-cy[i]));\n\t\t\tif(r + EPS > sqrt((dx-cx[i])*(dx-cx[i])+(dy-cy[i])*(dy-cy[i])) )return;\n\t\t}\n\t}\n\t\n\tfor(i=0;i<n;i++){\n\t\tif(used[i]==0){\n\t\t\tused[i]=1;\n\t\t\tr = sum + sqrt((hx-cx[i])*(hx-cx[i])+(hy-cy[i])*(hy-cy[i]));\n\t\t\tdragon(r,cx[i],cy[i]);\n\t\t\tused[i]=0;\n\t\t}\n\t}\n}\n\n\n\nint main(void)\n{\n\tint i,j,c;\n\tint hx,hy;\n\n\n\n\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d %d %d %d\",&n,&hx,&hy,&dx,&dy);\n\t\tif(n==0 && hx==0 && hy==0 && dx==0 && dy==0)break;\n\t\t\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&cx[i],&cy[i]);\n\t\t}\n\t  \n\t\tfor(i=0;i<n;i++){\n\t\t\tused[i]=0;\n\t\t}\n    \n    tmp = 0;\n    dragon(0.0,hx,hy);\n\t\tif(tmp){\n\t\t\tprintf(\"YES\\n\");\n\t\t}else{\n\t\t\tprintf(\"NO\\n\");\n\t\t}\n\t\t\n\t}\n\treturn 0;\n\t\n}\t\n\n\n\t\t"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] s, d;\n\tint[][] ps;\n\tint n;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\ts = new int[2]; d = new int[2];\n\t\t\ts[0] = sc.nextInt(); s[1] = sc.nextInt();\n\t\t\td[0] = sc.nextInt(); d[1] = sc.nextInt();\n\t\t\tif( (n|s[0]|s[1]|d[0]|d[1]) == 0 ) break;\n\t\t\tps = new int[n][2];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tps[i][0] = sc.nextInt();\n\t\t\t\tps[i][1] = sc.nextInt();\n\t\t\t}\n\t\t\tSystem.out.println((dijkstra()? \"YES\": \"NO\"));\n\t\t}\n\t}\n\t\n\tboolean dijkstra() {\n\t\tPriorityQueue<E> que = new PriorityQueue<E>();\n\t\tque.add(new E(new int[]{s[0], s[1]}, 0, 0));\n\t\tint[] mem = new int[1<<n];\n\t\tfill(mem, INF);\n\t\tmem[0] = 0;\n\t\twhile(!que.isEmpty()) {\n\t\t\tE now = que.poll();\n\t\t\tif( now.S == (1<<n) - 1) return true;\n\t\t\tif(mem[now.S] != now.t) continue;\n\t\t\tfor(int i=0;i<n;i++) if( ( (now.S>>i) & 1 )== 0 ) {\n\t\t\t\tint distp = abs(now.p[0]-ps[i][0]) + abs(now.p[1]-ps[i][1]);\n\t\t\t\tint distd = abs(d[0]-ps[i][0]) + abs(d[1]-ps[i][1]) - now.t;\n\t\t\t\tif( distp < distd && mem[now.S|(1<<i)] > distp + now.t ) {\n\t\t\t\t\tmem[now.S|(1<<i)] = distp + now.t;\n\t\t\t\t\tque.add(new E(ps[i], now.S|(1<<i), distp+now.t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tclass E implements Comparable<E> {\n\t\tint[] p;\n\t\tint S, t;\n\t\tE(int[] p, int S, int t) {\n\t\t\tthis.p = p.clone();\n\t\t\tthis.S = S;\n\t\t\tthis.t = t;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(E o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn t - o.t;\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class C2005{\n\n    int n;\n    int hx,hy,dx,dy;\n    int[] x,y;\n    double[][] distY;\n    double[] distM;\n    int[] collect;\n    boolean can;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    n = sc.nextInt();\n\t    hx = sc.nextInt();\n\t    hy = sc.nextInt();\n\t    dx = sc.nextInt();\n\t    dy = sc.nextInt();\n\t    if(n==0 && hx==0 && hy==0 && dx==0 && dy==0) break;\n\t    x = new int[n];\n\t    y = new int[n];\n\t    for(int i=0; i<n; i++){\n\t\tx[i] = sc.nextInt();\n\t\ty[i] = sc.nextInt();\n\t    }\n\t    \n\t    distY = new double[n+1][n+1];\n\t    distM = new double[n];\n\t    for(int i=0; i<n; i++){\n\t\tdouble dist = Math.sqrt((hx-x[i])*(hx-x[i])+(hy-y[i])*(hy-y[i]));\n\t\tdistY[0][i+1] = dist;\n\t\tdistY[i+1][0] = dist;\n\t\tdist = Math.sqrt((dx-x[i])*(dx-x[i])+(dy-y[i])*(dy-y[i]));\n\t\tdistM[i] = dist;\n\t    }\n\t    for(int i=0; i<n; i++){\n\t\tfor(int j=i+1; j<n; j++){\n\t\t    double dist = Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\t    distY[i+1][j+1] = dist;\n\t\t    distY[j+1][i+1] = dist;\n\t\t}\n\t    }\n\n\t    collect = new int[n];\n\t    can = false;\n\t    dfs(0,0,0);\n\t    \n\t    if(can){\n\t\tSystem.out.println(\"YES\");\n\t    }else{\n\t\tSystem.out.println(\"NO\");\n\t    }\n\t}\n    }\n\n    void dfs(int point, int cnt, double d){\n\tif(can) return;\n\tif(cnt==n){\n\t    can = true;\n\t    return;\n\t}\n\n\tfor(int i=0; i<n; i++){\n\t    if(collect[i]==0){\n\t\tif(d>=distM[i]){\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n\tfor(int i=0; i<n; i++){\n\t    if(collect[i]==0){\n\t\tdouble newD = d+distY[point][i+1];\n\t\tif(newD>=distM[i]) continue;\n\t\tcollect[i] = 1;\n\t\tdfs(i+1, cnt+1, newD);\n\t\tcollect[i] = 0;\n\t    }\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew C2005().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n, dx, dy;\n\tstatic int[] cx, cy;\n\tstatic double[] cdis;\n\tstatic int[] cgot;\n\t\n\tprivate static Boolean safe(double day)\n\t{\n\t\tint i;\n\t\tfor(i = 0;i < n;i++)\n\t\t{\n\t\t\tif(cgot[i] == 0 && day >= cdis[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static Boolean check(double hx, double hy, double day, int num)\n\t{\n\t\tint i;\n\t\tdouble move;\n\t\t\n\t\tfor(i = 0;i < n;i++)\n\t\t{\n\t\t\tif(cgot[i] == 1) continue;\n\t\t\t\n\t\t\tmove = distance(hx, hy, cx[i], cy[i]);\n\t\t\tif(!safe(day + move)) continue;\n\t\t\t\n\t\t\tif(num == 1) return true;\n\t\t\t\n\t\t\tcgot[i] = 1;\n\t\t\tif(check(cx[i], cy[i], day + move, num - 1)) return true;\n\t\t\tcgot[i] = 0;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate static double distance(double ax, double ay, double bx, double by)\n\t{\n\t\tdouble dx = ax - bx;\n\t\tdouble dy = ay - by;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tint hx, hy;\n\t\t\t\n\t\t\tn = sca.nextInt();\n\t\t\thx = sca.nextInt();\n\t\t\thy = sca.nextInt();\n\t\t\tdx = sca.nextInt();\n\t\t\tdy = sca.nextInt();\n\t\t\t\n\t\t\tif(n == 0) break;\n\t\t\t\n\t\t\tcx = new int[n];\n\t\t\tcy = new int[n];\n\t\t\tcdis = new double[n];\n\t\t\tcgot = new int[n];\n\t\t\t\n\t\t\tint i;\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\tcx[i] = sca.nextInt();\n\t\t\t\tcy[i] = sca.nextInt();\n\t\t\t\tcdis[i] = distance(cx[i], cy[i], dx, dy);\n\t\t\t\tcgot[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tif(check(hx, hy, 0, n))\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.in;\nimport static java.lang.System.out;\nimport static java.lang.Math.*;\n\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\n\npublic class Main {\n\n\tpublic static Scanner sc=new Scanner(in);\n\n\tstatic int INF=1<<30;\n\tvoid run(){\n\t\twhile(true){\n\t\t\tint n=sc.nextInt(),hx=sc.nextInt(),hy=sc.nextInt(),dx=sc.nextInt(),dy=sc.nextInt();\n\t\t\tif(n==0)return;\n\n\t\t\tint[] cxs=new int[n+1],cys=new int[n+1];\n\t\t\tcxs[0]=hx;cys[0]=hy;\n\t\t\tfor(int i=1;i<n+1;i++){\n\t\t\t\tcxs[i]=sc.nextInt();\n\t\t\t\tcys[i]=sc.nextInt();\n\t\t\t}\n\t\t\tint[][] dist=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<n+1;i++)for(int j=0;j<n+1;j++){\n\t\t\t\tdist[i][j]=abs(cxs[i]-cxs[j])+abs(cys[i]-cys[j]);\n\t\t\t}\n\t\t\tint[] dmax=new int[n+1];\n\t\t\tfor(int i=0;i<n+1;i++)\n\t\t\t\tdmax[i]=abs(cxs[i]-dx)+abs(cys[i]-dy);\n\n\t\t\tint[][] dp=new int[n+1][1<<(1+n)];//pos\n\t\t\tfor(int j=0;j<n+1;j++)Arrays.fill(dp[j],INF);\n\t\t\tfor(int j=0;j<n+1;j++){\n\t\t\t\tdp[j][0]=0;\n\t\t\t\tfor(int i=0;i<(1<<(1+n));i++){\n\t\t\t\t\tif((dp[j][i]& 1)==1)dp[j][i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<n+1;j++)dp[j][(1<<j)]=dist[0][j];\n\t\t\tfor(int i=0;i<(1<<(1+n));i++){\n\t\t\t\tfor(int next=0;next<n+1;next++){\n\t\t\t\t\tint mv=dp[next][i];\n\t\t\t\t\tif(((i>>next) & 1)==0)continue;\n\t\t\t\t\tfor(int prev=0;prev<n+1;prev++){\n\t\t\t\t\t\tif(((i>>prev) & 1)==0)continue;\n\t\t\t\t\t\tif(next==prev)continue;\n\t\t\t\t\t\tif(mv>dp[prev][(i-(1<<next))]+dist[prev][next])\n\t\t\t\t\t\t\tmv=dp[prev][(i-(1<<next))]+dist[prev][next];\n\t\t\t\t\t}\n\t\t\t\t\tif(mv>=dmax[next])mv=INF;\n\t\t\t\t\tdp[next][i]=mv;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint mv=INF;\n\t\t\tfor(int i=0;i<n+1;i++){\n\t\t\t\tif(mv>dp[i][1<<(n+1)-1])\n\t\t\t\t\tmv=dp[i][1<<(n+1)-1];\n\t\t\t}\n\t\t\tln(str(mv!=INF));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX = 20;\n\tpublic static final double INF = Double.MAX_VALUE;\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tdouble[][] dp = new double[1 << MAX][MAX];\n\t\tlong[][] points = new long[MAX][2];\n\t\tdouble[][] adj = new double[MAX][MAX];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal long h_x = sc.nextInt();\n\t\t\tfinal long h_y = sc.nextInt();\n\t\t\tfinal long g_x = sc.nextInt();\n\t\t\tfinal long g_y = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 1; j++){\n\t\t\t\t\tpoints[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int size = n;\n\t\t\tfinal int limit = 1 << size;\n\t\t\t\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tfor(int j = i + 1; j < size; j++){\n\t\t\t\t\tlong sum = 0;\n\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\tsum += (points[i][k] - points[j][k]) * (points[i][k] - points[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tadj[i][j] = adj[j][i] = Math.sqrt(sum);\n\t\t\t\t\t//System.out.println(adj[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int S = 0; S < limit; S++){\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tdp[S][i] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tlong sum = 0;\n\t\t\t\tsum += (points[i][0] - h_x) * (points[i][0] - h_x);\n\t\t\t\tsum += (points[i][1] - h_y) * (points[i][1] - h_y);\n\t\t\t\t\n\t\t\t\tdp[1 << i][i] = Math.sqrt(sum);\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int S = 0; S < limit; S++){\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tif((S & (1 << i)) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(dp[S][i] == INF){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\t\t\tif((S & (1 << j)) != 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal double cost = dp[S][i] + adj[i][j];\n\t\t\t\t\t\tfinal double time = Math.sqrt(\n\t\t\t\t\t\t\t\t(points[j][0] - g_x) * (points[j][0] - g_x) + \n\t\t\t\t\t\t\t\t(points[j][1] - g_y) * (points[j][1] - g_y));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(time > cost - 1e-7){\n\t\t\t\t\t\t\tdp[S | (1 << j)][j] = Math.min(dp[S | (1 << j)][j], cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdouble min = INF;\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t//System.out.print(dp[limit - 1][i] + \" \");\n\t\t\t\tmin = Math.min(min, dp[limit - 1][i]);\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(min);\n\t\t\t\n\t\t\tSystem.out.println(min == INF ? \"NO\" : \"YES\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n    \npublic class Main_TLE {\n        \n    public static final int MAX = 20;\n    public static final double INF = Double.MAX_VALUE;\n        \n        \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n            \n        double[][] dp = new double[1 << MAX][MAX];\n        long[][] points = new long[MAX][2];\n        double[][] adj = new double[MAX][MAX];\n            \n        while(true){\n            final int n = sc.nextInt();\n                \n            if(n == 0){\n                break;\n            }\n                \n            final long h_x = sc.nextInt();\n            final long h_y = sc.nextInt();\n            final long g_x = sc.nextInt();\n            final long g_y = sc.nextInt();\n                \n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < 2; j++){\n                    points[i][j] = sc.nextInt();\n                }\n            }\n                \n            final int size = n;\n            final int limit = 1 << size;\n                \n            for(int i = 0; i < size; i++){\n                for(int j = i + 1; j < size; j++){\n                    long sum = 0;\n                    for(int k = 0; k < 2; k++){\n                        sum += (points[i][k] - points[j][k]) * (points[i][k] - points[j][k]);\n                    }\n                        \n                    adj[i][j] = adj[j][i] = Math.sqrt(sum);\n                    //System.out.println(adj[i][j]);\n                }\n            }\n                \n            for(int S = 0; S < limit; S++){\n                for(int i = 0; i < size; i++){\n                    dp[S][i] = INF;\n                }\n            }\n            for(int i = 0; i < n; i++){\n            \tfinal double h_time = Math.sqrt(\n                        (points[i][0] - h_x) * (points[i][0] - h_x) + \n                        (points[i][1] - h_y) * (points[i][1] - h_y));\n            \t\n            \tfinal double g_time = Math.sqrt(\n                        (points[i][0] - g_x) * (points[i][0] - g_x) + \n                        (points[i][1] - g_y) * (points[i][1] - g_y));\n                \n                dp[1 << i][i] = h_time < g_time ? h_time : INF; \n            }\n                \n            for(int S = 0; S < limit; S++){\n               LOOP: \n               for(int i = 0; i < size; i++){\n                    if((S & (1 << i)) == 0){\n                        continue;\n                    }else if(dp[S][i] == INF){\n                        continue;\n                    }\n                        \n                    for(int j = 0; j < size; j++){\n                        if((S & (1 << j)) != 0){\n                            continue;\n                        }\n                           \n                        final double time = Math.sqrt(\n                                (points[j][0] - g_x) * (points[j][0] - g_x) + \n                                (points[j][1] - g_y) * (points[j][1] - g_y));\n                        final double cost = dp[S][i] + adj[i][j];  \n                            \n                        if(time <= cost){\n                           continue LOOP;\n                        }\n                    }\n                       \n                    for(int j = 0; j < size; j++){\n                         if((S & (1 << j)) != 0){\n                            continue;\n                        }\n                                \n                        final double cost = dp[S][i] + adj[i][j];\n                            \n                        dp[S | (1 << j)][j] = Math.min(dp[S | (1 << j)][j], cost);\n                    }\n                }\n            }\n                \n            double min = INF;\n            for(int i = 0; i < size; i++){\n                //System.out.print(dp[limit - 1][i] + \" \");\n                min = Math.min(min, dp[limit - 1][i]);\n            }\n                \n            //System.out.println(min);\n                \n            System.out.println(min == INF ? \"NO\" : \"YES\");\n        }\n    }\n    \n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.in;\nimport static java.lang.System.out;\nimport static java.lang.Math.*;\n\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\n\npublic class Main {\n\n\tpublic static Scanner sc=new Scanner(in);\n\n\tstatic int INF=1<<30;\n\tvoid run(){\n\t\twhile(true){\n\t\t\tint n=sc.nextInt(),hx=sc.nextInt(),hy=sc.nextInt(),dx=sc.nextInt(),dy=sc.nextInt();\n\t\t\tif(n==0)return;\n\n\t\t\tint[] cxs=new int[n+1],cys=new int[n+1];\n\t\t\tcxs[0]=hx;cys[0]=hy;\n\t\t\tfor(int i=1;i<n+1;i++){\n\t\t\t\tcxs[i]=sc.nextInt();\n\t\t\t\tcys[i]=sc.nextInt();\n\t\t\t}\n\t\t\tint[][] dist=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<n+1;i++)for(int j=0;j<n+1;j++){\n\t\t\t\tdist[i][j]=abs(cxs[i]-cxs[j])+abs(cys[i]-cys[j]);\n\t\t\t}\n\t\t\tint[] dmax=new int[n+1];\n\t\t\tfor(int i=0;i<n+1;i++)\n\t\t\t\tdmax[i]=abs(cxs[i]-dx)+abs(cys[i]-dy);\n\n\t\t\tint[][] dp=new int[n+1][1<<(1+n)];//pos\n\t\t\tfor(int j=0;j<n+1;j++)Arrays.fill(dp[j],INF);\n\t\t\tfor(int j=0;j<n+1;j++){\n\t\t\t\tdp[j][0]=0;\n\t\t\t\tfor(int i=0;i<(1<<(1+n));i++){\n\t\t\t\t\tif((dp[j][i]& 1)==1)dp[j][i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<n+1;j++)dp[j][(1<<j)]=dist[0][j];\n\t\t\tfor(int i=0;i<(1<<(1+n));i++){\n\t\t\t\tfor(int next=0;next<n+1;next++){\n\t\t\t\t\tint mv=dp[next][i];\n\t\t\t\t\tif(((i>>next) & 1)==0)continue;\n\t\t\t\t\tfor(int prev=0;prev<n+1;prev++){\n\t\t\t\t\t\tif(((i>>prev) & 1)==0)continue;\n\t\t\t\t\t\tif(next==prev)continue;\n\t\t\t\t\t\tif(mv>dp[prev][(i-(1<<next))]+dist[prev][next])\n\t\t\t\t\t\t\tmv=dp[prev][(i-(1<<next))]+dist[prev][next];\n\t\t\t\t\t}\n\t\t\t\t\tif(mv>=dmax[next])mv=INF;\n\t\t\t\t\tdp[next][i]=mv;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint mv=INF;\n\t\t\tfor(int i=0;i<n+1;i++){\n\t\t\t\tif(mv>dp[i][1<<(n+1)-1])\n\t\t\t\t\tmv=dp[i][1<<(n+1)-1];\n\t\t\t}\n\t\t\tln(str(mv!=INF));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic String str(double o){\n\t\treturn String.format(\"%.8f\",o);\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((boolean)o);\n\t\tif(c.equals(Double.class))return str((double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n\t\tlong startCpuTime = threadMXBean.getCurrentThreadCpuTime(), stopCpuTime = 0;\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\2008-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint n = scan.nextInt();\n\t\t\tint hx = scan.nextInt();\n\t\t\tint hy = scan.nextInt();\n\t\t\tint dx = scan.nextInt();\n\t\t\tint dy = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tMap mp = new Map(n, hx, hy, dx, dy);\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmp.add(i, scan.nextInt(), scan.nextInt());\n\t\t\tif (mp.result(0, n, hx, hy))\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t// stopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\n\t\t}\n\n\t\tscan.close();\n\t\t// stopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\t\t// System.out.println(\"CPU=\" + (stopCpuTime - startCpuTime) / 1000000);\n\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Map {\n\tint Dx, Dy;\n\tint[] Cx, Cy;\n\tboolean[] Cs;\n\tdouble[] Ct;\n\n\tpublic Map(int n, int hx, int hy, int dx, int dy) {\n\n\t\tDx = dx;\n\t\tDy = dy;\n\t\tCx = new int[n];\n\t\tCy = new int[n];\n\t\tCs = new boolean[n];\n\t\tCt = new double[n];\n\t}\n\n\tpublic boolean result(double t, int n, int hx, int hy) {\n\t\t// System.out.println(n + \":\" + hx + \" \" + hy);\n\t\tif (n == 0)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < Cs.length; i++)\n\t\t\tif (Cs[i]) {\n\t\t\t\tdouble nt = Math.sqrt(Math.pow(Cx[i] - hx, 2) + Math.pow(Cy[i] - hy, 2));\n\t\t\t\tif (t + nt >= Ct[i])\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\tfor (int i = 0; i < Cs.length; i++)\n\t\t\tif (Cs[i]) {\n\t\t\t\tdouble nt = Math.sqrt(Math.pow(Cx[i] - hx, 2) + Math.pow(Cy[i] - hy, 2));\n\t\t\t\tCs[i] = false;\n\t\t\t\tif (result(t + nt, n - 1, Cx[i], Cy[i]))\n\t\t\t\t\treturn true;\n\t\t\t\tCs[i] = true;\n\t\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic void add(int i, int cx, int cy) {\n\t\tCx[i] = cx;\n\t\tCy[i] = cy;\n\t\tCs[i] = true;\n\t\tCt[i] = Math.sqrt(Math.pow(cx - Dx, 2) + Math.pow(cy - Dy, 2));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Dragon Fantasy\npublic class Main{\n\n\tint n, hx, hy, dx, dy;\n\tR[] p;\n\tdouble EPS = 1e-8;\n\t\n\tclass R implements Comparable<R>{\n\t\tint x, y;\n\t\tdouble r;\n\t\tpublic R(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tr = Math.hypot(dx-x, dy-y);\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn (int) Math.signum(r-o.r);\n\t\t}\n\t}\n\t\n\tboolean dfs(int k, int S, double t){\n\t\tif(S==(1<<n)-1)return true;\n\t\tint x = k==-1?hx:p[k].x, y = k==-1?hy:p[k].y;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(((S>>i)&1)>0)continue;\n\t\t\tif(p[i].r<t+Math.hypot(x-p[i].x, y-p[i].y)+EPS)return false;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(((S>>i)&1)>0)continue;\n\t\t\tif(p[i].r>t+Math.hypot(x-p[i].x, y-p[i].y)){\n\t\t\t\tif(dfs(i, S+(1<<i), t+Math.hypot(x-p[i].x, y-p[i].y)))return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt(); hx = sc.nextInt(); hy = sc.nextInt(); dx = sc.nextInt(); dy = sc.nextInt();\n\t\t\tif((n|hx|hy|dx|dy)==0)break;\n\t\t\tp = new R[n];\n\t\t\tfor(int i=0;i<n;i++)p[i] = new R(sc.nextInt(), sc.nextInt());\n\t\t\tArrays.sort(p);\n\t\t\tSystem.out.println(dfs(-1, 0, 0)?\"YES\":\"NO\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tshort[] s, d;\n\tshort[][] ps;\n\tint n;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\ts = new short[2]; d = new short[2];\n\t\t\ts[0] = sc.nextShort(); s[1] = sc.nextShort();\n\t\t\td[0] = sc.nextShort(); d[1] = sc.nextShort();\n\t\t\tif( (n|s[0]|s[1]|d[0]|d[1]) == 0 ) break;\n\t\t\tps = new short[n][2];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tps[i][0] = sc.nextShort();\n\t\t\t\tps[i][1] = sc.nextShort();\n\t\t\t}\n\t\t\tSystem.out.println((dijkstra()? \"YES\": \"NO\"));\n\t\t}\n\t}\n\t\n\tboolean dijkstra() {\n\t\tPriorityQueue<E> que = new PriorityQueue<E>();\n\t\tque.add(new E(new short[]{s[0], s[1]}, 0, (short)0));\n\t\tshort[] mem = new short[1<<n];\n\t\tfill(mem, (short)(1<<14));\n\t\tmem[0] = 0;\n\t\twhile(!que.isEmpty()) {\n\t\t\tE now = que.poll();\n\t\t\tif( now.S == (1<<n) - 1) return true;\n\t\t\tif(mem[now.S] != now.t) continue;\n\t\t\tfor(int i=0;i<n;i++) if( ( (now.S>>i) & 1 ) == 0 ) {\n\t\t\t\tint distp = abs(now.p[0]-ps[i][0]) + abs(now.p[1]-ps[i][1]);\n\t\t\t\tint distd = abs(d[0]-ps[i][0]) + abs(d[1]-ps[i][1]) - now.t;\n\t\t\t\tif( distp < distd && mem[now.S|(1<<i)] > distp + now.t ) {\n\t\t\t\t\tmem[now.S|(1<<i)] = (short)(distp + now.t);\n\t\t\t\t\tque.add(new E(ps[i], now.S|(1<<i), (short)(distp + now.t)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tclass E implements Comparable<E> {\n\t\tshort[] p;\n\t\tshort t;\n\t\tint S;\n\t\tE(short[] p, int S, short t) {\n\t\t\tthis.p = p.clone();\n\t\t\tthis.S = S;\n\t\t\tthis.t = t;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(E o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn t - o.t;\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Dragon Fantasy\npublic class Main{\n\n\tint n, hx, hy, dx, dy;\n\tint[][] p;\n\tdouble[] r;\n\tdouble[][] d;\n\tdouble EPS = 1e-8;\n\t\n\tboolean dfs(int k, int S, double t){\n\t\tif(S==(1<<n)-1)return true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(((S>>i)&1)>0)continue;\n\t\t\tif(r[i]<t+d[k][i]+EPS)return false;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(((S>>i)&1)>0)continue;\n\t\t\tif(r[i]>t+d[k][i]){\n\t\t\t\tif(dfs(i, S+(1<<i), t+d[k][i]))return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt(); hx = sc.nextInt(); hy = sc.nextInt(); dx = sc.nextInt(); dy = sc.nextInt();\n\t\t\tif((n|hx|hy|dx|dy)==0)break;\n\t\t\tp = new int[n][2];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<2;j++)p[i][j]=sc.nextInt();\n\t\t\tr = new double[n];\n\t\t\tfor(int i=0;i<n;i++)r[i]=Math.hypot(p[i][0]-dx, p[i][1]-dy);\n\t\t\td = new double[n+1][n+1];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[n][i] = d[i][n] = Math.hypot(hx-p[i][0], hy-p[i][1]);\n\t\t\t\tfor(int j=i+1;j<n;j++)d[i][j] = d[j][i] = Math.hypot(p[i][0]-p[j][0], p[i][1]-p[j][1]);\n\t\t\t}\n\t\t\tSystem.out.println(dfs(n, 0, 0)?\"YES\":\"NO\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Dragon Fantasy\npublic class Main{\n\n\tint n, hx, hy, dx, dy;\n\tint[][] p;\n\tdouble[] r;\n\tdouble EPS = 1e-8;\n\t\n\tboolean dfs(int k, int S, double t){\n\t\tif(S==(1<<n)-1)return true;\n\t\tint x = k==-1?hx:p[k][0], y = k==-1?hy:p[k][1];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(((S>>i)&1)>0)continue;\n\t\t\tif(r[i]<t+Math.hypot(x-p[i][0], y-p[i][1])+EPS)return false;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(((S>>i)&1)>0)continue;\n\t\t\tif(r[i]>t+Math.hypot(x-p[i][0], y-p[i][1])){\n\t\t\t\tif(dfs(i, S+(1<<i), t+Math.hypot(x-p[i][0], y-p[i][1])))return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt(); hx = sc.nextInt(); hy = sc.nextInt(); dx = sc.nextInt(); dy = sc.nextInt();\n\t\t\tif((n|hx|hy|dx|dy)==0)break;\n\t\t\tp = new int[n][2];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<2;j++)p[i][j]=sc.nextInt();\n\t\t\tr = new double[n];\n\t\t\tfor(int i=0;i<n;i++)r[i]=Math.hypot(p[i][0]-dx, p[i][1]-dy);\n\t\t\tSystem.out.println(dfs(-1, 0, 0)?\"YES\":\"NO\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX = 20;\n\tpublic static final double INF = Double.MAX_VALUE;\n\t\n\t\n\tpublic static boolean can_all(final int n, int cur, int bit, double time, double[][] adj){\n\t\tif(bit == (1 << n) - 1){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int next = 0; next < n; next++){\n\t\t\tif((bit & (1 << next)) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfinal double g_time = adj[next][n];\n\t\t\tfinal double next_time = time + adj[cur][next];\n\t\t\t\n\t\t\tif(g_time <= next_time){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int next = 0; next < n; next++){\n\t\t\tif((bit & (1 << next)) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfinal double next_time = time + adj[cur][next];\n\t\t\t\n\t\t\tif(can_all(n, next, bit | (1 << next), next_time, adj)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tlong[][] points = new long[MAX + 2][2];\n\t\tdouble[][] adj = new double[MAX + 2][MAX + 2];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal long h_x = sc.nextInt();\n\t\t\tfinal long h_y = sc.nextInt();\n\t\t\tfinal long g_x = sc.nextInt();\n\t\t\tfinal long g_y = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\tpoints[i + 1][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpoints[0][0] = h_x;\n\t\t\tpoints[0][1] = h_y;\n\t\t\tpoints[n + 1][0] = g_x;\n\t\t\tpoints[n + 1][1] = g_y;\n\t\t\t\n\t\t\tfinal int size = n + 1;\n\t\t\t\n\t\t\tfor(int i = 0; i <= size; i++){\n\t\t\t\tfor(int j = i + 1; j <= size; j++){\n\t\t\t\t\tlong sum = 0;\n\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\tsum += (points[i][k] - points[j][k]) * (points[i][k] - points[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tadj[i][j] = adj[j][i] = Math.sqrt(sum);\n\t\t\t\t\t//System.out.println(adj[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(min);\n\t\t\t\n\t\t\tSystem.out.println(can_all(size, 0, 1, 0, adj) ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[][] map = new int[21][21];\n\tstatic double[] d = new double[21];\n\tstatic int n;\n\tstatic HashSet<Integer> hash = new HashSet<Integer>();\n\tpublic static void main(String[] args) {\n\t\tsolve();\n\t}\n\n\tprivate static void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pr = new PrintWriter(System.out);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tfor(int s=0;s<21;s++){\n\t\t\t\tfor(int t=0;t<21;t++){\n\t\t\t\t\tmap[s][t] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint hx = sc.nextInt();\n\t\t\tint hy = sc.nextInt();\n\t\t\tint dx = sc.nextInt();\n\t\t\tint dy = sc.nextInt();\n\t\t\tif(n==0&&hx==0&&hy==0&&dx==0&&dy==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] x = new int[n];\n\t\t\tint[] y = new int[n];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tx[k] = sc.nextInt();\n\t\t\t\ty[k] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tmap[0][k+1] = (hx-x[k])*(hx-x[k])+(hy-y[k])*(hy-y[k]);\n\t\t\t}\n\t\t\tfor(int s=0;s<n;s++){\n\t\t\t\tfor(int t=0;t<n;t++){\n\t\t\t\t\tmap[s+1][t+1] = (x[s]-x[t])*(x[s]-x[t])+(y[s]-y[t])*(y[s]-y[t]);\n\t\t\t\t}\n\t\t\t}\n\t\t\td[0] = Integer.MAX_VALUE;\n\t\t\tfor(int k=1;k<n+1;k++){\n\t\t\t\td[k] = Math.sqrt((dx-x[k-1])*(dx-x[k-1])+(dy-y[k-1])*(dy-y[k-1]));\n\t\t\t}\n\t\t\tif(dfs(0,0)<Integer.MAX_VALUE){\n\t\t\t\tpr.println(\"YES\");\n\t\t\t}else{\n\t\t\t\tpr.println(\"NO\");\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\tpr.flush();\n\t\tsc.close();\n\t}\n\n\tprivate static double dfs(double i,int node) {\n\t\tif(i>=d[node]) return Integer.MAX_VALUE;\n\t\tif(hash.size()==n) return i;\n\t\tfor(int k=1;k<n+1;k++){\n\t\t\tif(map[node][k]<Integer.MAX_VALUE&&hash.contains(k)!=true){\n\t\t\t\thash.add(k);\n\t\t\t\tif(i+Math.sqrt(map[node][k])>=d[k]){\n\t\t\t\t\thash.remove(k);\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\tif(dfs(i+Math.sqrt(map[node][k]),k)<Integer.MAX_VALUE){\n\t\t\t\t\thash.remove(k);\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t\thash.remove(k);\n\t\t\t}\n\t\t}\n\t\treturn Integer.MAX_VALUE;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX = 20;\n\tpublic static final double INF = Double.MAX_VALUE;\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tdouble[][] dp = new double[1 << MAX][MAX];\n\t\tlong[][] points = new long[MAX][2];\n\t\tdouble[][] adj = new double[MAX][MAX];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal long h_x = sc.nextInt();\n\t\t\tfinal long h_y = sc.nextInt();\n\t\t\tfinal long g_x = sc.nextInt();\n\t\t\tfinal long g_y = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\tpoints[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int size = n;\n\t\t\tfinal int limit = 1 << size;\n\t\t\t\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tfor(int j = i + 1; j < size; j++){\n\t\t\t\t\tlong sum = 0;\n\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\tsum += (points[i][k] - points[j][k]) * (points[i][k] - points[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tadj[i][j] = adj[j][i] = Math.sqrt(sum);\n\t\t\t\t\t//System.out.println(adj[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int S = 0; S < limit; S++){\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tdp[S][i] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tlong sum = 0;\n\t\t\t\tsum += (points[i][0] - h_x) * (points[i][0] - h_x);\n\t\t\t\tsum += (points[i][1] - h_y) * (points[i][1] - h_y);\n\t\t\t\t\n\t\t\t\tdp[1 << i][i] = Math.sqrt(sum);\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int S = 0; S < limit; S++){\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tif((S & (1 << i)) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(dp[S][i] == INF){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\t\t\tif((S & (1 << j)) != 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal double cost = dp[S][i] + adj[i][j];\n\t\t\t\t\t\tfinal double time = Math.sqrt(\n\t\t\t\t\t\t\t\t(points[j][0] - g_x) * (points[j][0] - g_x) + \n\t\t\t\t\t\t\t\t(points[j][1] - g_y) * (points[j][1] - g_y));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(time > cost){\n\t\t\t\t\t\t\tdp[S | (1 << j)][j] = Math.min(dp[S | (1 << j)][j], cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdouble min = INF;\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t//System.out.print(dp[limit - 1][i] + \" \");\n\t\t\t\tmin = Math.min(min, dp[limit - 1][i]);\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(min);\n\t\t\t\n\t\t\tSystem.out.println(min == INF ? \"NO\" : \"YES\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tint n;\n\tP h, d;\n\tP[] c;\n\tint INF = 1<<28;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt(); d = new P(sc.nextInt(), sc.nextInt()); h = new P(sc.nextInt(), sc.nextInt());\n\t\t\tif( (n|h.x|h.y|d.x|d.y) == 0 ) break;\n\t\t\t\n\t\t\tc = new P[n];\n\t\t\tfor(int i=0;i<n;i++) c[i] = new P(sc.nextInt(), sc.nextInt());\n\t\t\tSystem.out.println((solve()? \"YES\": \"NO\"));\n\t\t}\n\t}\n\t\n\tboolean solve() {\n\t\tint[] mem = new int[1<<n];\n\t\tfill(mem, INF); mem[0] = 0;\n\t\tPriorityQueue<P> que = new PriorityQueue<P>();\n\t\tque.add(d);\n\t\tfor(;!que.isEmpty();) {\n\t\t\tP cur = que.remove();\n\t\t\tdebug(cur.x, cur.y, cur.t, Integer.toString(cur.b, 2));\n\t\t\tif( mem[cur.b] != cur.t ) continue;\n\t\t\tif( cur.b == (1<<n)-1 ) return true;\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<n;i++) if(((cur.b>>i)&1) == 0) {\n\t\t\t\tint ht = abs(c[i].x - h.x) + abs(c[i].y-h.y);\n\t\t\t\tint dt = abs(c[i].x - cur.x) + abs(c[i].y-cur.y) + cur.t;\n\t\t\t\tdebug(ht, dt);\n\t\t\t\tf &= ht > dt;\n\t\t\t}\n\t\t\tif( !f ) continue;\n\t\t\tfor(int i=0;i<n;i++) if(((cur.b>>i)&1) == 0) {\n\t\t\t\tint dt = abs(c[i].x - cur.x) + abs(c[i].y-cur.y) + cur.t;\n\t\t\t\tif( mem[cur.b | 1<<i] > dt ) {\n\t\t\t\t\tmem[cur.b | 1<<i] = dt;\n\t\t\t\t\tque.add(new P( c[i].x, c[i].y, dt, cur.b |= 1<<i ));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tclass P implements Comparable<P>{\n\t\tint x, y, t, b;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tt = 0;\n\t\t\tb = 0;\n\t\t}\n\t\t\n\t\tP(int x, int y, int t, int b) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n\t\tpublic int compareTo(P p) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn t - p.t;\n\t\t}\n\t}\n\t\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[][] map = new int[21][21];\n\tstatic double[] d = new double[21];\n\tstatic int n;\n\tstatic HashSet<Integer> hash = new HashSet<Integer>();\n\tpublic static void main(String[] args) {\n\t\tsolve();\n\t}\n\n\tprivate static void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pr = new PrintWriter(System.out);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tfor(int s=0;s<21;s++){\n\t\t\t\tfor(int t=0;t<21;t++){\n\t\t\t\t\tmap[s][t] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint hx = sc.nextInt();\n\t\t\tint hy = sc.nextInt();\n\t\t\tint dx = sc.nextInt();\n\t\t\tint dy = sc.nextInt();\n\t\t\tif(n==0&&hx==0&&hy==0&&dx==0&&dy==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] x = new int[n];\n\t\t\tint[] y = new int[n];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tx[k] = sc.nextInt();\n\t\t\t\ty[k] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tmap[0][k+1] = (hx-x[k])*(hx-x[k])+(hy-y[k])*(hy-y[k]);\n\t\t\t}\n\t\t\tfor(int s=0;s<n;s++){\n\t\t\t\tfor(int t=0;t<n;t++){\n\t\t\t\t\tmap[s+1][t+1] = (x[s]-x[t])*(x[s]-x[t])+(y[s]-y[t])*(y[s]-y[t]);\n\t\t\t\t}\n\t\t\t}\n\t\t\td[0] = Integer.MAX_VALUE;\n\t\t\tfor(int k=1;k<n+1;k++){\n\t\t\t\td[k] = Math.sqrt((dx-x[k-1])*(dx-x[k-1])+(dy-y[k-1])*(dy-y[k-1]));\n\t\t\t}\n\t\t\tif(dfs(0,0)<Integer.MAX_VALUE){\n\t\t\t\tpr.println(\"YES\");\n\t\t\t}else{\n\t\t\t\tpr.println(\"NO\");\n\t\t\t}\n\n\t\t}\n\t\tpr.flush();\n\t\tsc.close();\n\t}\n\n\tprivate static double dfs(double i,int node) {\n\t\tif(i>=d[node]) return Integer.MAX_VALUE;\n\t\tif(hash.size()==n) return i;\n\t\tfor(int k=1;k<n+1;k++){\n\t\t\tif(map[node][k]<Integer.MAX_VALUE&&hash.contains(k)!=true){\n\t\t\t\thash.add(k);\n\t\t\t\tif (i + Math.sqrt(map[node][k]) >= d[k]) {\n\t\t\t\t\thash.remove(k);\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\thash.remove(k);\n\t\t\t}\n\t\t}\n\t\tfor(int k=1;k<n+1;k++){\n\t\t\tif(map[node][k]<Integer.MAX_VALUE&&hash.contains(k)!=true){\n\t\t\t\thash.add(k);\n\t\t\t\tif(dfs(i+Math.sqrt(map[node][k]),k)<Integer.MAX_VALUE){\n\t\t\t\t\thash.remove(k);\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t\thash.remove(k);\n\t\t\t}\n\t\t}\n\t\treturn Integer.MAX_VALUE;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n    \npublic class Main {\n        \n    public static final int MAX = 20;\n    public static final double INF = Double.MAX_VALUE;\n        \n        \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n            \n        double[][] dp = new double[1 << MAX][MAX];\n        long[][] points = new long[MAX][2];\n        double[][] adj = new double[MAX][MAX];\n            \n        while(true){\n            final int n = sc.nextInt();\n                \n            if(n == 0){\n                break;\n            }\n                \n            final long h_x = sc.nextInt();\n            final long h_y = sc.nextInt();\n            final long g_x = sc.nextInt();\n            final long g_y = sc.nextInt();\n                \n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < 2; j++){\n                    points[i][j] = sc.nextInt();\n                }\n            }\n                \n            final int size = n;\n            final int limit = 1 << size;\n                \n            for(int i = 0; i < size; i++){\n                for(int j = i + 1; j < size; j++){\n                    long sum = 0;\n                    for(int k = 0; k < 2; k++){\n                        sum += (points[i][k] - points[j][k]) * (points[i][k] - points[j][k]);\n                    }\n                        \n                    adj[i][j] = adj[j][i] = Math.sqrt(sum);\n                    //System.out.println(adj[i][j]);\n                }\n            }\n                \n            for(int S = 0; S < limit; S++){\n                for(int i = 0; i < size; i++){\n                    dp[S][i] = INF;\n                }\n            }\n            for(int i = 0; i < n; i++){\n            \tfinal double h_time = Math.sqrt(\n                        (points[i][0] - h_x) * (points[i][0] - h_x) + \n                        (points[i][1] - h_y) * (points[i][1] - h_y));\n            \t\n            \tfinal double g_time = Math.sqrt(\n                        (points[i][0] - g_x) * (points[i][0] - g_x) + \n                        (points[i][1] - g_y) * (points[i][1] - g_y));\n                \n                dp[1 << i][i] = h_time < g_time ? h_time : INF; \n            }\n                \n            for(int S = 0; S < limit; S++){\n               LOOP: \n               for(int i = 0; i < size; i++){\n                    if((S & (1 << i)) == 0){\n                        continue;\n                    }else if(dp[S][i] == INF){\n                        continue;\n                    }\n                        \n                    for(int j = 0; j < size; j++){\n                        if((S & (1 << j)) != 0){\n                            continue;\n                        }\n                           \n                        final double time = Math.sqrt(\n                                (points[j][0] - g_x) * (points[j][0] - g_x) + \n                                (points[j][1] - g_y) * (points[j][1] - g_y));\n                        final double cost = dp[S][i] + adj[i][j];  \n                            \n                        if(time <= cost){\n                           continue LOOP;\n                        }\n                    }\n                       \n                    for(int j = 0; j < size; j++){\n                         if((S & (1 << j)) != 0){\n                            continue;\n                        }\n                                \n                        final double cost = dp[S][i] + adj[i][j];\n                            \n                        dp[S | (1 << j)][j] = Math.min(dp[S | (1 << j)][j], cost);\n                    }\n                }\n            }\n                \n            double min = INF;\n            for(int i = 0; i < size; i++){\n                //System.out.print(dp[limit - 1][i] + \" \");\n                min = Math.min(min, dp[limit - 1][i]);\n            }\n                \n            //System.out.println(min);\n                \n            System.out.println(min == INF ? \"NO\" : \"YES\");\n        }\n    }\n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n, dx, dy;\n\tstatic int[] cx, cy;\n\tstatic double[] cdis;\n\tstatic int[] cgot;\n\tstatic Boolean flag;\n\t\n\t// a <= bと同じ\n\tprivate static Boolean bigger(double a, double b)\n\t{\n\t\treturn a <= b;\n\t}\n\t\n\tprivate static void check(double hx, double hy, double day, int num)\n\t{\n\t\tint i;\n\t\tdouble move;\n\t\t\n\t\tfor(i = 0;i < n;i++)\n\t\t{\n\t\t\tmove = distance(hx, hy, cx[i], cy[i]);\n\t\t\tif(cgot[i] == 1) continue;\n\t\t\tif(bigger(cdis[i], day + move)) return;\n\t\t}\n\t\t\n\t\tfor(i = 0;i < n;i++)\n\t\t{\n\t\t\tif(cgot[i] == 1) continue;\n\t\t\t\n\t\t\tmove = distance(hx, hy, cx[i], cy[i]);\n\t\t\tif(num == 1)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tcgot[i] = 1;\n\t\t\tcheck(cx[i], cy[i], day + move, num - 1);\n\t\t\tif(flag) return;\n\t\t\tcgot[i] = 0;\n\t\t}\n\t}\n\t\n\tprivate static double distance(double ax, double ay, double bx, double by)\n\t{\n\t\tdouble dx = ax - bx;\n\t\tdouble dy = ay - by;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tint hx, hy;\n\t\t\t\n\t\t\tn = sca.nextInt();\n\t\t\thx = sca.nextInt();\n\t\t\thy = sca.nextInt();\n\t\t\tdx = sca.nextInt();\n\t\t\tdy = sca.nextInt();\n\t\t\t\n\t\t\tif(n == 0) break;\n\t\t\t\n\t\t\tcx = new int[n];\n\t\t\tcy = new int[n];\n\t\t\tcdis = new double[n];\n\t\t\tcgot = new int[n];\n\t\t\t\n\t\t\tint i;\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\tcx[i] = sca.nextInt();\n\t\t\t\tcy[i] = sca.nextInt();\n\t\t\t\tcdis[i] = distance(cx[i], cy[i], dx, dy);\n\t\t\t\tcgot[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tflag = false;\n\t\t\tcheck(hx, hy, 0, n);\n\t\t\tif(flag)\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.Point2D;\n\npublic class Main {\n\tstatic int n;\n\tstatic Point2D d;\n\tstatic HashMap<Point2D,Boolean> c;\n\n\tstatic boolean dfs(Point2D p,double sum,int time){\n\t\t//if(sum >= d.distance(p)) return false;\n\t\tif(time == n) return true;\n\t\t\n\t\tfor(Point2D pp : c.keySet()){\n\t\t\tif(c.get(pp)) continue;\n\t\t\tif(sum+p.distance(pp) >= d.distance(pp)) return false;\n\t\t}\n\t\tc.put(p, true);\n\t\tfor(Point2D pp : c.keySet()){\n\t\t\tif(c.get(pp)) continue;\n\t\t\tif(dfs(pp,sum+p.distance(pp),time+1)) return true;\n\t\t}\n\t\tc.put(p, false);\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tPoint2D h = new Point2D.Double(sc.nextDouble(), sc.nextDouble());\n\t\t\td = new Point2D.Double(sc.nextDouble(), sc.nextDouble());\n\t\t\tif(n == 0) break;\n\n\t\t\tc = new HashMap<Point2D,Boolean>();\n\t\t\tc.put(h, false);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tc.put(new Point2D.Double(sc.nextDouble(),sc.nextDouble()), false);\n\t\t\t}\n\t\t\n\t\t\tSystem.out.println(dfs(h,0,0) ? \"YES\" : \"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int n;\n    int hx,hy,dx,dy;\n    int[] x,y;\n    double[][] distY;\n    double[] distM;\n    int[] collect;\n    boolean can;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    n = sc.nextInt();\n\t    hx = sc.nextInt();\n\t    hy = sc.nextInt();\n\t    dx = sc.nextInt();\n\t    dy = sc.nextInt();\n\t    if(n==0 && hx==0 && hy==0 && dx==0 && dy==0) break;\n\t    x = new int[n];\n\t    y = new int[n];\n\t    for(int i=0; i<n; i++){\n\t\tx[i] = sc.nextInt();\n\t\ty[i] = sc.nextInt();\n\t    }\n\t    \n\t    distY = new double[n+1][n+1];\n\t    distM = new double[n];\n\t    for(int i=0; i<n; i++){\n\t\tdouble dist = Math.sqrt((hx-x[i])*(hx-x[i])+(hy-y[i])*(hy-y[i]));\n\t\tdistY[0][i+1] = dist;\n\t\tdistY[i+1][0] = dist;\n\t\tdist = Math.sqrt((dx-x[i])*(dx-x[i])+(dy-y[i])*(dy-y[i]));\n\t\tdistM[i] = dist;\n\t    }\n\t    for(int i=0; i<n; i++){\n\t\tfor(int j=i+1; j<n; j++){\n\t\t    double dist = Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\t    distY[i+1][j+1] = dist;\n\t\t    distY[j+1][i+1] = dist;\n\t\t}\n\t    }\n\n\t    collect = new int[n];\n\t    can = false;\n\t    dfs(0,0,0);\n\t    \n\t    if(can){\n\t\tSystem.out.println(\"YES\");\n\t    }else{\n\t\tSystem.out.println(\"NO\");\n\t    }\n\t}\n    }\n\n    void dfs(int point, int cnt, double d){\n\tif(can) return;\n\tif(cnt==n){\n\t    can = true;\n\t    return;\n\t}\n\n\tfor(int i=0; i<n; i++){\n\t    if(collect[i]==0){\n\t\tif(d+distY[point][i+1]>=distM[i]){\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n\tfor(int i=0; i<n; i++){\n\t    if(collect[i]==0){\n\t\tdouble newD = d+distY[point][i+1];\n\t\tcollect[i] = 1;\n\t\tdfs(i+1, cnt+1, newD);\n\t\tcollect[i] = 0;\n\t    }\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int n;\n    int hx,hy,dx,dy;\n    int[] x,y;\n    double[][] distY;\n    double[] distM;\n    int[] collect;\n    boolean can;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    n = sc.nextInt();\n\t    hx = sc.nextInt();\n\t    hy = sc.nextInt();\n\t    dx = sc.nextInt();\n\t    dy = sc.nextInt();\n\t    if(n==0 && hx==0 && hy==0 && dx==0 && dy==0) break;\n\t    x = new int[n];\n\t    y = new int[n];\n\t    for(int i=0; i<n; i++){\n\t\tx[i] = sc.nextInt();\n\t\ty[i] = sc.nextInt();\n\t    }\n\t    \n\t    distY = new double[n+1][n+1];\n\t    distM = new double[n];\n\t    for(int i=0; i<n; i++){\n\t\tdouble dist = Math.sqrt((hx-x[i])*(hx-x[i])+(hy-y[i])*(hy-y[i]));\n\t\tdistY[0][i+1] = dist;\n\t\tdistY[i+1][0] = dist;\n\t\tdist = Math.sqrt((dx-x[i])*(dx-x[i])+(dy-y[i])*(dy-y[i]));\n\t\tdistM[i] = dist;\n\t    }\n\t    for(int i=0; i<n; i++){\n\t\tfor(int j=i+1; j<n; j++){\n\t\t    double dist = Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\t    distY[i+1][j+1] = dist;\n\t\t    distY[j+1][i+1] = dist;\n\t\t}\n\t    }\n\n\t    collect = new int[n];\n\t    can = false;\n\t    dfs(0,0,0);\n\t    \n\t    if(can){\n\t\tSystem.out.println(\"YES\");\n\t    }else{\n\t\tSystem.out.println(\"NO\");\n\t    }\n\t}\n    }\n\n    void dfs(int point, int cnt, double d){\n\tif(can) return;\n\tif(cnt==n){\n\t    can = true;\n\t    return;\n\t}\n\n\tfor(int i=0; i<n; i++){\n\t    if(collect[i]==0){\n\t\tif(d>=distM[i]){\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n\tfor(int i=0; i<n; i++){\n\t    if(collect[i]==0){\n\t\tdouble newD = d+distY[point][i+1];\n\t\tif(newD>=distM[i]) continue;\n\t\tcollect[i] = 1;\n\t\tdfs(i+1, cnt+1, newD);\n\t\tcollect[i] = 0;\n\t    }\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[][] map = new int[21][21];\n\tstatic double[] d = new double[21];\n\tstatic int n;\n\tstatic HashSet<Integer> hash = new HashSet<Integer>();\n\tpublic static void main(String[] args) {\n\t\tsolve();\n\t}\n\n\tprivate static void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pr = new PrintWriter(System.out);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tfor(int s=0;s<21;s++){\n\t\t\t\tfor(int t=0;t<21;t++){\n\t\t\t\t\tmap[s][t] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint hx = sc.nextInt();\n\t\t\tint hy = sc.nextInt();\n\t\t\tint dx = sc.nextInt();\n\t\t\tint dy = sc.nextInt();\n\t\t\tif(n==0&&hx==0&&hy==0&&dx==0&&dy==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] x = new int[n];\n\t\t\tint[] y = new int[n];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tx[k] = sc.nextInt();\n\t\t\t\ty[k] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tmap[0][k+1] = (hx-x[k])*(hx-x[k])+(hy-y[k])*(hy-y[k]);\n\t\t\t}\n\t\t\tfor(int s=0;s<n;s++){\n\t\t\t\tfor(int t=0;t<n;t++){\n\t\t\t\t\tmap[s+1][t+1] = (x[s]-x[t])*(x[s]-x[t])+(y[s]-y[t])*(y[s]-y[t]);\n\t\t\t\t}\n\t\t\t}\n\t\t\td[0] = Integer.MAX_VALUE;\n\t\t\tfor(int k=1;k<n+1;k++){\n\t\t\t\td[k] = Math.sqrt((dx-x[k-1])*(dx-x[k-1])+(dy-y[k-1])*(dy-y[k-1]));\n\t\t\t}\n\t\t\tif(dfs(0,0)<Integer.MAX_VALUE){\n\t\t\t\tpr.println(\"YES\");\n\t\t\t}else{\n\t\t\t\tpr.println(\"NO\");\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\tpr.flush();\n\t\tsc.close();\n\t}\n\n\tprivate static double dfs(double i,int node) {\n\t\tfor(int k=1;k<n+1;k++){\n\t\t\tif(i>=d[k]&&hash.contains(k)!=true){\n\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tif(i>=d[node]) return Integer.MAX_VALUE;\n\t\tif(hash.size()==n) return i;\n\t\tfor(int k=1;k<n+1;k++){\n\t\t\tif(map[node][k]<Integer.MAX_VALUE&&hash.contains(k)!=true){\n\t\t\t\thash.add(k);\n\t\t\t\tif(i+Math.sqrt(map[node][k])>=d[k]){\n\t\t\t\t\thash.remove(k);\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\tif(dfs(i+Math.sqrt(map[node][k]),k)<Integer.MAX_VALUE){\n\t\t\t\t\thash.remove(k);\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t\thash.remove(k);\n\t\t\t}\n\t\t}\n\t\treturn Integer.MAX_VALUE;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n\t\tlong startCpuTime = threadMXBean.getCurrentThreadCpuTime(), stopCpuTime = 0;\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\0545-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint n = scan.nextInt();\n\t\t\tint hx = scan.nextInt();\n\t\t\tint hy = scan.nextInt();\n\t\t\tint dx = scan.nextInt();\n\t\t\tint dy = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tMap mp = new Map(n, hx, hy, dx, dy);\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmp.add(i, scan.nextInt(), scan.nextInt());\n\t\t\tif (mp.result(0, n, hx, hy))\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t// stopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\n\t\t}\n\n\t\tscan.close();\n\t\t// stopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\t\t// System.out.println(\"CPU=\" + (stopCpuTime - startCpuTime) / 1000000);\n\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Map {\n\tint Dx, Dy;\n\tint[] Cx, Cy;\n\tboolean[] Cs;\n\tdouble[] Ct;\n\n\tpublic Map(int n, int hx, int hy, int dx, int dy) {\n\n\t\tDx = dx;\n\t\tDy = dy;\n\t\tCx = new int[n];\n\t\tCy = new int[n];\n\t\tCs = new boolean[n];\n\t\tCt = new double[n];\n\t}\n\n\tpublic boolean result(double t, int n, int hx, int hy) {\n\t\t// System.out.println(n + \":\" + hx + \" \" + hy);\n\t\tif (n == 0)\n\t\t\treturn true;\n\t\tfor (int i = 0; i < Cs.length; i++)\n\t\t\tif (Cs[i]) {\n\t\t\t\tdouble nt = Math.sqrt(Math.pow(Cx[i] - hx, 2) + Math.pow(Cy[i] - hy, 2));\n\t\t\t\tif (t + nt >= Ct[i])\n\t\t\t\t\treturn false;\n\t\t\t\telse {\n\t\t\t\t\tCs[i] = false;\n\t\t\t\t\tif (result(t + nt, n - 1, Cx[i], Cy[i]))\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tCs[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void add(int i, int cx, int cy) {\n\t\tCx[i] = cx;\n\t\tCy[i] = cy;\n\t\tCs[i] = true;\n\t\tCt[i] = Math.sqrt(Math.pow(cx - Dx, 2) + Math.pow(cy - Dy, 2));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[][] map = new int[21][21];\n\tstatic double[] d = new double[21];\n\tstatic int n;\n\tstatic HashSet<Integer> hash = new HashSet<Integer>();\n\tpublic static void main(String[] args) {\n\t\tsolve();\n\t}\n\n\tprivate static void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pr = new PrintWriter(System.out);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tfor(int s=0;s<21;s++){\n\t\t\t\tfor(int t=0;t<21;t++){\n\t\t\t\t\tmap[s][t] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint hx = sc.nextInt();\n\t\t\tint hy = sc.nextInt();\n\t\t\tint dx = sc.nextInt();\n\t\t\tint dy = sc.nextInt();\n\t\t\tif(n==0&&hx==0&&hy==0&&dx==0&&dy==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] x = new int[n];\n\t\t\tint[] y = new int[n];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tx[k] = sc.nextInt();\n\t\t\t\ty[k] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tmap[0][k+1] = (hx-x[k])*(hx-x[k])+(hy-y[k])*(hy-y[k]);\n\t\t\t}\n\t\t\tfor(int s=0;s<n;s++){\n\t\t\t\tfor(int t=0;t<n;t++){\n\t\t\t\t\tmap[s+1][t+1] = (x[s]-x[t])*(x[s]-x[t])+(y[s]-y[t])*(y[s]-y[t]);\n\t\t\t\t}\n\t\t\t}\n\t\t\td[0] = Integer.MAX_VALUE;\n\t\t\tfor(int k=1;k<n+1;k++){\n\t\t\t\td[k] = Math.sqrt((dx-x[k-1])*(dx-x[k-1])+(dy-y[k-1])*(dy-y[k-1]));\n\t\t\t}\n\t\t\tif(dfs(0,0)<Integer.MAX_VALUE){\n\t\t\t\tpr.println(\"YES\");\n\t\t\t}else{\n\t\t\t\tpr.println(\"NO\");\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\tpr.flush();\n\t\tsc.close();\n\t}\n\n\tprivate static double dfs(double i,int node) {\n\t\tif(i>=d[node]) return Integer.MAX_VALUE;\n\t\tif(hash.size()==n) return i;\n\t\tfor(int k=1;k<n+1;k++){\n\t\t\tif(map[node][k]<Integer.MAX_VALUE&&hash.contains(k)!=true){\n\t\t\t\thash.add(k);\n\t\t\t\tif(dfs(i+Math.sqrt(map[node][k]),k)<Integer.MAX_VALUE){\n\t\t\t\t\thash.remove(k);\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t\thash.remove(k);\n\t\t\t}\n\t\t}\n\t\treturn Integer.MAX_VALUE;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n   \npublic class Main {\n       \n    public static final int MAX = 20;\n    public static final double INF = Double.MAX_VALUE;\n       \n       \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n           \n        double[][] dp = new double[1 << MAX][MAX];\n        long[][] points = new long[MAX][2];\n        double[][] adj = new double[MAX][MAX];\n           \n        while(true){\n            final int n = sc.nextInt();\n               \n            if(n == 0){\n                break;\n            }\n               \n            final long h_x = sc.nextInt();\n            final long h_y = sc.nextInt();\n            final long g_x = sc.nextInt();\n            final long g_y = sc.nextInt();\n               \n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < 2; j++){\n                    points[i][j] = sc.nextInt();\n                }\n            }\n               \n            final int size = n;\n            final int limit = 1 << size;\n               \n            for(int i = 0; i < size; i++){\n                for(int j = i + 1; j < size; j++){\n                    long sum = 0;\n                    for(int k = 0; k < 2; k++){\n                        sum += (points[i][k] - points[j][k]) * (points[i][k] - points[j][k]);\n                    }\n                       \n                    adj[i][j] = adj[j][i] = Math.sqrt(sum);\n                    //System.out.println(adj[i][j]);\n                }\n            }\n               \n            for(int S = 0; S < limit; S++){\n                for(int i = 0; i < size; i++){\n                    dp[S][i] = INF;\n                }\n            }\n            for(int i = 0; i < n; i++){\n                long sum = 0;\n                sum += (points[i][0] - h_x) * (points[i][0] - h_x);\n                sum += (points[i][1] - h_y) * (points[i][1] - h_y);\n                   \n                dp[1 << i][i] = Math.sqrt(sum);\n                       \n            }\n               \n            for(int S = 0; S < limit; S++){\n               LOOP: \n               for(int i = 0; i < size; i++){\n                    if((S & (1 << i)) == 0){\n                        continue;\n                    }else if(dp[S][i] == INF){\n                        continue;\n                    }\n                       \n                    for(int j = 0; j < size; j++){\n                        if((S & (1 << j)) != 0){\n                            continue;\n                        }\n                          \n                        final double time = Math.sqrt(\n                                (points[j][0] - g_x) * (points[j][0] - g_x) + \n                                (points[j][1] - g_y) * (points[j][1] - g_y));\n                        final double cost = dp[S][i] + adj[i][j];  \n                           \n                        if(time <= cost){\n                           continue LOOP;\n                        }\n                    }\n                      \n                    for(int j = 0; j < size; j++){\n                         if((S & (1 << j)) != 0){\n                            continue;\n                        }\n                               \n                        final double cost = dp[S][i] + adj[i][j];\n                        final double time = Math.sqrt(\n                                (points[j][0] - g_x) * (points[j][0] - g_x) + \n                                (points[j][1] - g_y) * (points[j][1] - g_y));\n                           \n                           \n                        dp[S | (1 << j)][j] = Math.min(dp[S | (1 << j)][j], cost);\n                        \n                    }\n                }\n            }\n               \n            double min = INF;\n            for(int i = 0; i < size; i++){\n                //System.out.print(dp[limit - 1][i] + \" \");\n                min = Math.min(min, dp[limit - 1][i]);\n            }\n               \n            //System.out.println(min);\n               \n            System.out.println(min == INF ? \"NO\" : \"YES\");\n        }\n    }\n   \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n  \npublic class Main {\n      \n    public static final int MAX = 20;\n    public static final double INF = Double.MAX_VALUE;\n      \n      \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n          \n        double[][] dp = new double[1 << MAX][MAX];\n        long[][] points = new long[MAX][2];\n        double[][] adj = new double[MAX][MAX];\n          \n        while(true){\n            final int n = sc.nextInt();\n              \n            if(n == 0){\n                break;\n            }\n              \n            final long h_x = sc.nextInt();\n            final long h_y = sc.nextInt();\n            final long g_x = sc.nextInt();\n            final long g_y = sc.nextInt();\n              \n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < 2; j++){\n                    points[i][j] = sc.nextInt();\n                }\n            }\n              \n            final int size = n;\n            final int limit = 1 << size;\n              \n            for(int i = 0; i < size; i++){\n                for(int j = i + 1; j < size; j++){\n                    long sum = 0;\n                    for(int k = 0; k < 2; k++){\n                        sum += (points[i][k] - points[j][k]) * (points[i][k] - points[j][k]);\n                    }\n                      \n                    adj[i][j] = adj[j][i] = Math.sqrt(sum);\n                    //System.out.println(adj[i][j]);\n                }\n            }\n              \n            for(int S = 0; S < limit; S++){\n                for(int i = 0; i < size; i++){\n                    dp[S][i] = INF;\n                }\n            }\n            for(int i = 0; i < n; i++){\n                long sum = 0;\n                sum += (points[i][0] - h_x) * (points[i][0] - h_x);\n                sum += (points[i][1] - h_y) * (points[i][1] - h_y);\n                  \n                dp[1 << i][i] = Math.sqrt(sum);\n                      \n            }\n              \n            for(int S = 0; S < limit; S++){\n               LOOP: \n               for(int i = 0; i < size; i++){\n                    if((S & (1 << i)) == 0){\n                        continue;\n                    }else if(dp[S][i] == INF){\n                        continue;\n                    }\n                      \n                    for(int j = 0; j < size; j++){\n                        if((S & (1 << j)) != 0){\n                            continue;\n                        }\n                         \n                        final double time = Math.sqrt(\n                                (points[j][0] - g_x) * (points[j][0] - g_x) + \n                                (points[j][1] - g_y) * (points[j][1] - g_y));\n                        final double cost = dp[S][i] + adj[i][j];  \n                          \n                        if(time <= cost){\n                           continue LOOP;\n                        }\n                    }\n                     \n                    for(int j = 0; j < size; j++){\n                         if((S & (1 << j)) != 0){\n                            continue;\n                        }\n                              \n                        final double cost = dp[S][i] + adj[i][j];\n                        final double time = Math.sqrt(\n                                (points[j][0] - g_x) * (points[j][0] - g_x) + \n                                (points[j][1] - g_y) * (points[j][1] - g_y));\n                          \n                          \n                        if(time > cost){\n                            dp[S | (1 << j)][j] = Math.min(dp[S | (1 << j)][j], cost);\n                        }else{\n                            Arrays.fill(dp[S], INF);\n                            break;\n                        }\n                    }\n                }\n            }\n              \n            double min = INF;\n            for(int i = 0; i < size; i++){\n                //System.out.print(dp[limit - 1][i] + \" \");\n                min = Math.min(min, dp[limit - 1][i]);\n            }\n              \n            //System.out.println(min);\n              \n            System.out.println(min == INF ? \"NO\" : \"YES\");\n        }\n    }\n  \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n \npublic class Main {\n     \n    public static final int MAX = 20;\n    public static final double INF = Double.MAX_VALUE;\n     \n     \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n         \n        double[][] dp = new double[1 << MAX][MAX];\n        long[][] points = new long[MAX][2];\n        double[][] adj = new double[MAX][MAX];\n         \n        while(true){\n            final int n = sc.nextInt();\n             \n            if(n == 0){\n                break;\n            }\n             \n            final long h_x = sc.nextInt();\n            final long h_y = sc.nextInt();\n            final long g_x = sc.nextInt();\n            final long g_y = sc.nextInt();\n             \n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < 2; j++){\n                    points[i][j] = sc.nextInt();\n                }\n            }\n             \n            final int size = n;\n            final int limit = 1 << size;\n             \n            for(int i = 0; i < size; i++){\n                for(int j = i + 1; j < size; j++){\n                    long sum = 0;\n                    for(int k = 0; k < 2; k++){\n                        sum += (points[i][k] - points[j][k]) * (points[i][k] - points[j][k]);\n                    }\n                     \n                    adj[i][j] = adj[j][i] = Math.sqrt(sum);\n                    //System.out.println(adj[i][j]);\n                }\n            }\n             \n            for(int S = 0; S < limit; S++){\n                for(int i = 0; i < size; i++){\n                    dp[S][i] = INF;\n                }\n            }\n            for(int i = 0; i < n; i++){\n                long sum = 0;\n                sum += (points[i][0] - h_x) * (points[i][0] - h_x);\n                sum += (points[i][1] - h_y) * (points[i][1] - h_y);\n                 \n                dp[1 << i][i] = Math.sqrt(sum);\n                     \n            }\n             \n            for(int S = 0; S < limit; S++){\n               LOOP: \n               for(int i = 0; i < size; i++){\n                    if((S & (1 << i)) == 0){\n                        continue;\n                    }else if(dp[S][i] == INF){\n                        continue;\n                    }\n                     \n                    for(int j = 0; j < size; j++){\n                        if((S & (1 << j)) != 0){\n                            continue;\n                        }\n                        \n                        final double time = Math.sqrt(\n                                (points[j][0] - g_x) * (points[j][0] - g_x) + \n                                (points[j][1] - g_y) * (points[j][1] - g_y));\n                         \n                         \n                        if(time <= cost){\n                           continue LOOP;\n                        }\n                    }\n                    \n                    for(int j = 0; j < size; j++){\n                         if((S & (1 << j)) != 0){\n                            continue;\n                        }\n                             \n                        final double cost = dp[S][i] + adj[i][j];\n                        final double time = Math.sqrt(\n                                (points[j][0] - g_x) * (points[j][0] - g_x) + \n                                (points[j][1] - g_y) * (points[j][1] - g_y));\n                         \n                         \n                        if(time > cost){\n                            dp[S | (1 << j)][j] = Math.min(dp[S | (1 << j)][j], cost);\n                        }else{\n                            Arrays.fill(dp[S], INF);\n                            break;\n                        }\n                    }\n                }\n            }\n             \n            double min = INF;\n            for(int i = 0; i < size; i++){\n                //System.out.print(dp[limit - 1][i] + \" \");\n                min = Math.min(min, dp[limit - 1][i]);\n            }\n             \n            //System.out.println(min);\n             \n            System.out.println(min == INF ? \"NO\" : \"YES\");\n        }\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int n;\n    int hx,hy,dx,dy;\n    int[] x,y;\n    double[][] distY;\n    double[] distM;\n    int[] collect;\n    boolean can;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    n = sc.nextInt();\n\t    hx = sc.nextInt();\n\t    hy = sc.nextInt();\n\t    dx = sc.nextInt();\n\t    dy = sc.nextInt();\n\t    if(n==0 && hx==0 && hy==0 && dx==0 && dy==0) break;\n\t    x = new int[n];\n\t    y = new int[n];\n\t    for(int i=0; i<n; i++){\n\t\tx[i] = sc.nextInt();\n\t\ty[i] = sc.nextInt();\n\t    }\n\t    \n\t    distY = new double[n+1][n+1];\n\t    distM = new double[n];\n\t    for(int i=0; i<n; i++){\n\t\tdouble dist = Math.sqrt((hx-x[i])*(hx-x[i])+(hy-y[i])*(hy-y[i]));\n\t\tdistY[0][i+1] = dist;\n\t\tdistY[i+1][0] = dist;\n\t\tdist = Math.sqrt((dx-x[i])*(dx-x[i])+(dy-y[i])*(dy-y[i]));\n\t\tdistM[i] = dist;\n\t    }\n\t    for(int i=0; i<n; i++){\n\t\tfor(int j=i; j<n; j++){\n\t\t    double dist = Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\t    distY[i+1][j+1] = dist;\n\t\t    distY[j+1][i+1] = dist;\n\t\t}\n\t    }\n\n\t    collect = new int[n];\n\t    can = false;\n\t    dfs(0,0,0);\n\t    \n\t    if(can){\n\t\tSystem.out.println(\"YES\");\n\t    }else{\n\t\tSystem.out.println(\"NO\");\n\t    }\n\t}\n    }\n\n    void dfs(int point, int cnt, double d){\n\tif(can) return;\n\tif(cnt==n){\n\t    can = true;\n\t    return;\n\t}\n\n\tfor(int i=0; i<n; i++){\n\t    if(collect[i]==0){\n\t\tdouble newD = d+distY[point][i+1];\n\t\tif(newD>=distM[i]) continue;\n\t\tcollect[i] = 1;\n\t\tdfs(i+1, cnt+1, newD);\n\t\tcollect[i] = 0;\n\t    }\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    static String mark;\n    static int[][] crys;\n    static int n;\n    static int[] findMark;\n    static double[] distA;\n    static double[][] distY;\n\n    public static void main(String[] args){\n\tScanner sc = new Scanner(System.in);\n\n\tn = sc.nextInt();\n\tint hx = sc.nextInt();\n\tint hy = sc.nextInt();\n\tint dx = sc.nextInt();\n\tint dy = sc.nextInt();\n\n\twhile(n!=0){\n\t    crys = new int[n][2];\n\t    distA = new double[n];\n\t    for(int i=0; i<n; i++){\n\t\tcrys[i][0] = sc.nextInt();\n\t\tcrys[i][1] = sc.nextInt();\n\t\tdistA[i] = getDistance(dx,dy,i);\n\t    }\n\n\t    distY = new double[n+1][n];\n\t    for(int i=1; i<=n; i++){\n\t\tdistY[0][i-1] = getDistance(hx,hy,i-1);\n\t\tfor(int j=0; j<n; j++){\n\t\t    distY[i][j] = getDistance(crys[i-1][0],crys[i-1][1],j);\n\t\t}\n\t    }\n\n\t    findMark = new int[n];\n\t    mark = \"NO\";\n\t    solve(-1,0,0.0);\n\t    System.out.println(mark);\n\n\t    n = sc.nextInt();\n\t    hx = sc.nextInt();\n\t    hy = sc.nextInt();\n\t    dx = sc.nextInt();\n\t    dy = sc.nextInt();\n\t}\n    }\n\n    public static void solve(int pos, int findNum, double radius){\n\tif(mark.equals(\"YES\")){return;}\n\tif(findNum==n){mark = \"YES\"; return;}\n\n\tfor(int i=0; i<findMark.length; i++){\n\t    if(findMark[i]==0 && distY[pos+1][i] >= distA[i]-radius){return;}\n\t}\n\n\tfor(int i=0; i<findMark.length; i++){\n\t    if(findMark[i]==0){\n\t\tif(distY[pos+1][i]<distA[i]-radius){\n\t\t    findMark[i] = 1;\t\n\t\t    solve(i,findNum+1,distY[pos+1][i]+radius);\n\t\t    if(mark==\"YES\")break;\n\t\t    findMark[i] = 0;\n\t\t}else return;\n\t    }\n\t}\n    }\n\n    public static double getDistance(int x, int y, int i){\n\treturn  Math.sqrt((x-crys[i][0])*(x-crys[i][0])+(y-crys[i][1])*(y-crys[i][1]));\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tshort[] s, d;\n\tshort[][] ps;\n\tint n;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\ts = new short[2]; d = new short[2];\n\t\t\ts[0] = sc.nextShort(); s[1] = sc.nextShort();\n\t\t\td[0] = sc.nextShort(); d[1] = sc.nextShort();\n\t\t\tif( (n|s[0]|s[1]|d[0]|d[1]) == 0 ) break;\n\t\t\tps = new short[n][2];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tps[i][0] = sc.nextShort();\n\t\t\t\tps[i][1] = sc.nextShort();\n\t\t\t}\n\t\t\tSystem.out.println((dijkstra()? \"YES\": \"NO\"));\n\t\t}\n\t}\n\t\n\tboolean dijkstra() {\n\t\tPriorityQueue<E> que = new PriorityQueue<E>();\n\t\tque.add(new E(new short[]{s[0], s[1]}, 0, (short)0));\n\t\tshort[] mem = new short[1<<n];\n\t\tfill(mem, (short)(1<<14));\n\t\tmem[0] = 0;\n\t\twhile(!que.isEmpty()) {\n\t\t\tE now = que.poll();\n\t\t\tif( now.S == (1<<n) - 1) return true;\n\t\t\tif(mem[now.S] != now.t) continue;\n\t\t\tfor(int i=0;i<n;i++) if( ( (now.S>>i) & 1 ) == 0 ) {\n\t\t\t\t\n\t\t\t\tint distp = abs(now.p[0]-ps[i][0]) + abs(now.p[1]-ps[i][1]);\n\t\t\t\tint distd = abs(d[0]-ps[i][0]) + abs(d[1]-ps[i][1]) - now.t;\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int j=0;j<n;j++) if(i != j && ( (now.S>>j) & 1 ) == 0 ) {\n\t\t\t\t\tif(abs(d[0]-ps[j][0]) + abs(d[1]-ps[j][1]) - now.t - distp < 0)\n\t\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t\tif(!flg) continue;\n\t\t\t\tif( distp < distd && mem[now.S|(1<<i)] > distp + now.t ) {\n\t\t\t\t\tmem[now.S|(1<<i)] = (short)(distp + now.t);\n\t\t\t\t\tque.add(new E(ps[i], now.S|(1<<i), (short)(distp + now.t)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tclass E implements Comparable<E> {\n\t\tshort[] p;\n\t\tshort t;\n\t\tint S;\n\t\tE(short[] p, int S, short t) {\n\t\t\tthis.p = p.clone();\n\t\t\tthis.S = S;\n\t\t\tthis.t = t;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(E o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn t - o.t;\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX = 20 + 2;\n\tpublic static final double INF = Double.MAX_VALUE;\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tdouble[][] dp = new double[1 << (MAX - 1)][(MAX - 1)];\n\t\tlong[][] points = new long[MAX][2];\n\t\tdouble[][] adj = new double[MAX ][MAX];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int h_x = sc.nextInt();\n\t\t\tfinal int h_y = sc.nextInt();\n\t\t\tfinal int g_x = sc.nextInt();\n\t\t\tfinal int g_y = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 1; j++){\n\t\t\t\t\tpoints[i+1][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpoints[0][0] = h_x;\n\t\t\tpoints[0][1] = h_y;\n\t\t\tpoints[n + 1][0] = g_x;\n\t\t\tpoints[n + 1][1] = g_y;\n\t\t\t\n\t\t\tfinal int size = n + 1;\n\t\t\tfinal int limit = 1 << size;\n\t\t\t\n\t\t\tfor(int i = 0; i <= size; i++){\n\t\t\t\tfor(int j = i + 1; j <= size; j++){\n\t\t\t\t\tlong sum = 0;\n\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\tsum += (points[i][k] - points[j][k]) * (points[i][k] - points[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tadj[i][j] = adj[j][i] = Math.sqrt(sum);\n\t\t\t\t\t//System.out.println(adj[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int S = 0; S < limit; S++){\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tdp[S][i] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[1][0] = 0;\n\t\t\t\n\t\t\tfor(int S = 0; S < limit; S++){\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tif((S & (1 << i)) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(dp[S][i] == INF){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\t\t\tif((S & (1 << j)) != 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal double cost = dp[S][i] + adj[i][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(adj[size][j] > cost){\n\t\t\t\t\t\t\tdp[S | (1 << j)][j] = Math.min(dp[S | (1 << j)][j], cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdouble min = INF;\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t//System.out.print(dp[limit - 1][i] + \" \");\n\t\t\t\tmin = Math.min(min, dp[limit - 1][i]);\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(min);\n\t\t\t\n\t\t\tSystem.out.println(min == INF ? \"NO\" : \"YES\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX = 20;\n\tpublic static final double INF = Double.MAX_VALUE;\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tdouble[][] dp = new double[1 << MAX][MAX];\n\t\tlong[][] points = new long[MAX][2];\n\t\tdouble[][] adj = new double[MAX][MAX];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal long h_x = sc.nextInt();\n\t\t\tfinal long h_y = sc.nextInt();\n\t\t\tfinal long g_x = sc.nextInt();\n\t\t\tfinal long g_y = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 1; j++){\n\t\t\t\t\tpoints[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int size = n;\n\t\t\tfinal int limit = 1 << size;\n\t\t\t\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tfor(int j = i + 1; j < size; j++){\n\t\t\t\t\tlong sum = 0;\n\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\tsum += (points[i][k] - points[j][k]) * (points[i][k] - points[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tadj[i][j] = adj[j][i] = Math.sqrt(sum);\n\t\t\t\t\t//System.out.println(adj[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int S = 0; S < limit; S++){\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tdp[S][i] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tlong sum = 0;\n\t\t\t\tsum += (points[i][0] - h_x) * (points[i][0] - h_x);\n\t\t\t\tsum += (points[i][1] - h_y) * (points[i][1] - h_y);\n\t\t\t\t\n\t\t\t\tdp[1 << i][i] = Math.sqrt(sum);\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int S = 0; S < limit; S++){\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tif((S & (1 << i)) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(dp[S][i] == INF){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\t\t\tif((S & (1 << j)) != 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal double cost = dp[S][i] + adj[i][j];\n\t\t\t\t\t\tfinal double time = Math.sqrt(\n\t\t\t\t\t\t\t\t(points[j][0] - g_x) * (points[j][0] - g_x) + \n\t\t\t\t\t\t\t\t(points[j][1] - g_y) * (points[j][1] - g_y));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(time > cost){\n\t\t\t\t\t\t\tdp[S | (1 << j)][j] = Math.min(dp[S | (1 << j)][j], cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdouble min = INF;\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t//System.out.print(dp[limit - 1][i] + \" \");\n\t\t\t\tmin = Math.min(min, dp[limit - 1][i]);\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(min);\n\t\t\t\n\t\t\tSystem.out.println(min == INF ? \"NO\" : \"YES\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX = 20;\n\tpublic static final double INF = Double.MAX_VALUE;\n\t\n\t\n\tpublic static boolean can_all(final int n, int cur, int bit, double time, double[][] adj){\n\t\tif(bit == (1 << n) - 1){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int next = 0; next < n; next++){\n\t\t\tif((bit & (1 << next)) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfinal double g_time = adj[next][n];\n\t\t\tfinal double next_time = time + adj[cur][next];\n\t\t\t\n\t\t\tif(g_time > next_time && can_all(n, next, bit | (1 << next), next_time, adj)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tlong[][] points = new long[MAX + 2][2];\n\t\tdouble[][] adj = new double[MAX + 2][MAX + 2];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal long h_x = sc.nextInt();\n\t\t\tfinal long h_y = sc.nextInt();\n\t\t\tfinal long g_x = sc.nextInt();\n\t\t\tfinal long g_y = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\tpoints[i + 1][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpoints[0][0] = h_x;\n\t\t\tpoints[0][1] = h_y;\n\t\t\tpoints[n + 1][0] = g_x;\n\t\t\tpoints[n + 1][1] = g_y;\n\t\t\t\n\t\t\tfinal int size = n + 1;\n\t\t\t\n\t\t\tfor(int i = 0; i <= size; i++){\n\t\t\t\tfor(int j = i + 1; j <= size; j++){\n\t\t\t\t\tlong sum = 0;\n\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\tsum += (points[i][k] - points[j][k]) * (points[i][k] - points[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tadj[i][j] = adj[j][i] = Math.sqrt(sum);\n\t\t\t\t\t//System.out.println(adj[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(min);\n\t\t\t\n\t\t\tSystem.out.println(can_all(size, 0, 1, 0, adj) ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX = 20;\n\tpublic static final double INF = Double.MAX_VALUE;\n\t\n\t\n\tpublic static boolean can_all(final int n, int cur, int bit, double time, double[][] adj){\n\t\tif(bit == (1 << n) - 1){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int next = 0; next < n; next++){\n\t\t\tif((bit & (1 << next)) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfinal double g_time = adj[next][n];\n\t\t\tfinal double next_time = time + adj[cur][next];\n\t\t\t\n\t\t\tif(g_time <= next_time){\n\t\t\t\treturn false;\n\t\t\t}else if(can_all(n, next, bit | (1 << next), next_time, adj)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tlong[][] points = new long[MAX + 2][2];\n\t\tdouble[][] adj = new double[MAX + 2][MAX + 2];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal long h_x = sc.nextInt();\n\t\t\tfinal long h_y = sc.nextInt();\n\t\t\tfinal long g_x = sc.nextInt();\n\t\t\tfinal long g_y = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\tpoints[i + 1][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpoints[0][0] = h_x;\n\t\t\tpoints[0][1] = h_y;\n\t\t\tpoints[n + 1][0] = g_x;\n\t\t\tpoints[n + 1][1] = g_y;\n\t\t\t\n\t\t\tfinal int size = n + 1;\n\t\t\t\n\t\t\tfor(int i = 0; i <= size; i++){\n\t\t\t\tfor(int j = i + 1; j <= size; j++){\n\t\t\t\t\tlong sum = 0;\n\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\tsum += (points[i][k] - points[j][k]) * (points[i][k] - points[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tadj[i][j] = adj[j][i] = Math.sqrt(sum);\n\t\t\t\t\t//System.out.println(adj[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(min);\n\t\t\t\n\t\t\tSystem.out.println(can_all(size, 0, 1, 0, adj) ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2008\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int hx = int.Parse(str1[1]); \n\t\t  int hy = int.Parse(str1[2]); \n\t\t  int dx = int.Parse(str1[3]); \n\t\t  int dy = int.Parse(str1[4]); \n\n\t\t  if(n == 0) break;\n\t\t  \n\t\t  int[] acx = new int[n];\n\t\t  int[] acy = new int[n];\n\t\t  \n\t\t  for(int i=0; i<n; i++) {\n\t\t\tstring[] str2 = Console.ReadLine().Split(' ');\n\t\t\tacx[i] = int.Parse(str2[0]); \n\t\t\tacy[i] = int.Parse(str2[1]); \n\t\t}\n\t\t\n\t\t  //Console.WriteLine(\"改行あり N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,hx,hy,dx,dy,acx,acy));\n\t\t\n\t\t\n\t\t}\n\n\t}\n\n  public static string calc(int n,int hx,int hy,int dx,int dy,int[] acx,int[] acy) {\n\t  SortedList<int, int> dcs = new SortedList<int, int>();\n\t  for(int i=0;i<n;i++) {\n\t\tint idx = ((dx-acx[i])*(dx-acx[i])+(dy-acy[i])*(dy-acy[i]))*20;\n\t\twhile(dcs.ContainsKey(idx)) idx++;\n\t\tdcs[idx] = i;\n\t  }\n\n\t  double[] dcr = new double[n];\n\t  for(int i=0;i<n;i++) dcr[i] = Math.Sqrt(dcs.Keys[i]/20);\n\t  double[] hcr = new double[n];\n\t  for(int i=0;i<n;i++) hcr[i] = Math.Sqrt((hx-acx[dcs.Values[i]])*(hx-acx[dcs.Values[i]])+(hy-acy[dcs.Values[i]])*(hy-acy[dcs.Values[i]]));\n\t  double[][] ccr = new double[n][];\n\t  for(int i=0;i<n;i++) ccr[i] = new double[n];\n\t  for(int j=0;j<n-1;j++) {\n\t\tfor(int i=j+1;i<n;i++) {\n\t\t\tccr[j][i] = Math.Sqrt((acx[dcs.Values[j]]-acx[dcs.Values[i]])*(acx[dcs.Values[j]]-acx[dcs.Values[i]])+(acy[dcs.Values[j]]-acy[dcs.Values[i]])*(acy[dcs.Values[j]]-acy[dcs.Values[i]]));\n\t\t\tccr[i][j] = ccr[j][i];\n\t\t}\n\t  }\n\t  \n\t  //Console.WriteLine(\"A = {0} B = {1} C = {2}\", String.Join(\"\", aa), String.Join(\"\", bb), String.Join(\"\", cc));\n/*\n\t  List<byte[][]> met = new List<byte[][]>();\n\t  met.Add(new byte[][]{aa.ToArray(),bb.ToArray(),cc.ToArray()});\n\t  \n\t  int t = calc_sub_dbg(0, m, aa, bb, cc, met);\n\n\t  foreach(byte[][] d in met) {\n\t    Console.WriteLine(\"==========\");\n\t    foreach(byte[] e in d) Console.WriteLine(String.Join(\" \", e));\n\t  }\n\t  Console.WriteLine(\"==========\");\n*/\n\n\t  List<int[]> ret = calc_sub(dcr,hcr,ccr,new List<int>(),0);\n\n\t  return ((ret.Count==0) ? \"NO\" : \"YES\");\n  }\n  \n  \n  public static List<int[]> calc_sub(double[] dcr,double[] hcr,double[][] ccr, List<int> order, double time) {\n\tList<int[]> ret = new List<int[]>();\n\t\n\tif(order.Count==0){\n\t  \tfor(int i=0; i<dcr.Length; i++) if(dcr[i]<=hcr[i]) return ret;\n\n\t  \tfor(int i=0; i<dcr.Length; i++){\n\t\t\tdouble t = hcr[i];\n\t\t\tif(t<dcr[i]) {\n\t\t\t\tList<int> a = new List<int>();\n\t\t\t\ta.Add(i);\n\t\t\t\tret.AddRange(calc_sub(dcr,hcr,ccr,a, t));\n\t\t\t\tif(0<ret.Count) break;\n\t\t\t}\n\t\t}\n\t} else if (order.Count==dcr.Length){\n\t\tret.Add(order.ToArray());\n\t} else {\n\t\tdouble[] lidx = ccr[order[order.Count-1]];\n\t\t\n\t  \tfor(int i=0; i<dcr.Length; i++){\n\t\t\tif(order.Contains(i)) continue;\n\t\t\tif(dcr[i]<=(time+lidx[i])) return ret;\n\t\t}\n\t\t\n\t  \tfor(int i=0; i<dcr.Length; i++){\n\t\t\tif(order.Contains(i)) continue;\n\t\t\t\n\t\t\tdouble t = time+lidx[i];\n\t\t\t\n//\t\t\tif(Math.Abs(dcr[i]-t)<0.001) Console.WriteLine(\"==========\");\n\t\t\t\n\t\t\tif(t<dcr[i]) {\n\t\t\t\tList<int> a = new List<int>(order);\n\t\t\t\ta.Add(i);\n\t\t\t\tret.AddRange(calc_sub(dcr,hcr,ccr,a, t));\n\t\t\t\tif(0<ret.Count) break;\n\t\t\t}\n\t\t}\n\t}\n  \n  \treturn ret;\n  }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp\n\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int hx = int.Parse(str1[1]); \n\t\t  int hy = int.Parse(str1[2]); \n\t\t  int dx = int.Parse(str1[3]); \n\t\t  int dy = int.Parse(str1[4]); \n\n\t\t  if(n == 0) break;\n\t\t  \n\t\t  int[] acx = new int[n];\n\t\t  int[] acy = new int[n];\n\t\t  \n\t\t  for(int i=0; i<n; i++) {\n\t\t\tstring[] str2 = Console.ReadLine().Split(' ');\n\t\t\tacx[i] = int.Parse(str2[0]); \n\t\t\tacy[i] = int.Parse(str2[1]); \n\t\t}\n\t\t\n\t\t  //Console.WriteLine(\"改行あり N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,hx,hy,dx,dy,acx,acy));\n\t\t\n\t\t\n\t\t}\n\n\t}\n\n  public static string calc(int n,int hx,int hy,int dx,int dy,int[] acx,int[] acy) {\n\t  SortedList<int, int> dcs = new SortedList<int, int>();\n\t  for(int i=0;i<n;i++) {\n\t\tint idx = ((dx-acx[i])*(dx-acx[i])+(dy-acy[i])*(dy-acy[i]))*10;\n\t\twhile(dcs.ContainsKey(idx)) idx++;\n\t\tdcs[idx] = i;\n\t  }\n\n\t  double[] dcr = new double[n];\n\t  for(int i=0;i<n;i++) dcr[i] = Math.Sqrt(dcs.Keys[i]/10);\n\t  double[] hcr = new double[n];\n\t  for(int i=0;i<n;i++) hcr[i] = Math.Sqrt((hx-acx[dcs.Values[i]])*(hx-acx[dcs.Values[i]])+(hy-acy[dcs.Values[i]])*(hy-acy[dcs.Values[i]]));\n\t  double[][] ccr = new double[n][];\n\t  for(int i=0;i<n;i++) ccr[i] = new double[n];\n\t  for(int j=0;j<n-1;j++) {\n\t\tfor(int i=j+1;i<n;i++) {\n\t\t\tccr[j][i] = Math.Sqrt((acx[dcs.Values[j]]-acx[dcs.Values[i]])*(acx[dcs.Values[j]]-acx[dcs.Values[i]])+(acy[dcs.Values[j]]-acy[dcs.Values[i]])*(acy[dcs.Values[j]]-acy[dcs.Values[i]]));\n\t\t\tccr[i][j] = ccr[j][i];\n\t\t}\n\t  }\n\t  \n\t  //Console.WriteLine(\"A = {0} B = {1} C = {2}\", String.Join(\"\", aa), String.Join(\"\", bb), String.Join(\"\", cc));\n/*\n\t  List<byte[][]> met = new List<byte[][]>();\n\t  met.Add(new byte[][]{aa.ToArray(),bb.ToArray(),cc.ToArray()});\n\t  \n\t  int t = calc_sub_dbg(0, m, aa, bb, cc, met);\n\n\t  foreach(byte[][] d in met) {\n\t    Console.WriteLine(\"==========\");\n\t    foreach(byte[] e in d) Console.WriteLine(String.Join(\" \", e));\n\t  }\n\t  Console.WriteLine(\"==========\");\n*/\n\n\t  List<int> ret = calc_sub(dcr,hcr,ccr,new List<int>(),0);\n\n\t  return ((ret==null) ? \"NO\" : \"YES\");\n  }\n  \n  \n  public static List<int> calc_sub(double[] dcr,double[] hcr,double[][] ccr, List<int> order, double time) {\n\tif(order.Count==0){\n\t  \tfor(int i=0; i<hcr.Length; i++){\n\t\t\tif(hcr[i]<dcr[i]) {\n\t\t\t\tList<int> a = new List<int>();\n\t\t\t\ta.Add(i);\n\t\t\t\treturn calc_sub(dcr,hcr,ccr,a, hcr[i]);\n\t\t\t}\n\t\t}\n\t} else if (order.Count==hcr.Length){\n\t\treturn order;\n\t} else {\n\t\tint lidx = order[order.Count-1];\n\t  \tfor(int i=0; i<dcr.Length; i++){\n\t\t\tif(order.Contains(i)) continue;\n\t\t\t\n\t\t\tdouble t = time+ccr[lidx][i];\n\t\t\tif(t<dcr[i]) {\n\t\t\t\tList<int> a = new List<int>(order);\n\t\t\t\ta.Add(i);\n\t\t\t\treturn calc_sub(dcr,hcr,ccr,a, t);\n\t\t\t}\n\t\t}\n\t}\n  \n  \treturn null;\n  }\n\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\ndef dfs(bits, pos, s)\n  return true if bits == (1<<$n) - 1\n  $n.times do |i|\n    unless bits & (1<<i) == 1<<i\n      return false if $dist[i][$n+1] < s + $dist[pos][i] + EPS\n    end\n  end\n  $n.times do |i|\n    unless bits & (1<<i) == 1<<i\n      return true if dfs(bits | (1<<i), i, s + $dist[pos][i])\n    end\n  end\n  false\nend\n \nwhile l = gets\n  $n, x0, y0, x1, y1 = l.split.map(&:to_i)\n  break if $n == 0\n  ps = $n.times.map { gets.split.map(&:to_i) }\n  $ps = [*ps, [x0, y0], [x1, y1]]\n  $dist = $ps.map { |x0, y0| $ps.map { |x1, y1| Math.sqrt((x1 - x0) ** 2 + (y1 - y0) ** 2) } }\n  $used = [false] * $n\n  puts dfs(0, $n, 0) ? 'YES' : 'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "loop {\n    n, hx, hy, dx, dy = gets.split.map &:to_i\n    break if n == 0\n\n    points = [[hx, hy]] + (1..n).map { gets.split.map &:to_i }\n\n    dist = (0..n).map{|i|\n        (0..n).map{|j|\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            sqrt((x1-x2)**2 + (y1-y2)**2)\n        }\n    }\n\n    deadline = points.map{|x, y|\n        sqrt((x - dx)**2 + (y - dy)**2)\n    }\n\n    stack = [[0, 0] + (1..n).to_a]\n    success = false\n    until stack.empty?\n        t, i, *unreached = stack.pop\n        if unreached == [] \n            success = true\n            break\n        end\n        next if unreached.any?{|j| t + dist[i][j] >= deadline[j]}\n        unreached.each{|j|\n            stack << [t + dist[i][j], j, *(unreached - [j])]\n        }\n    end\n    puts success ? 'YES' : 'NO'\n}"
  },
  {
    "language": "Ruby",
    "code": "def dfs(pos, dx, dy, t)\n  if ($x1 - $ps[pos][0]) ** 2 + ($y1 - $ps[pos][1]) ** 2 > dx ** 2 + dy ** 2\n    $used[pos] = true\n    t += 1\n  else\n    return false\n  end\n  return true if t == $n + 1\n  ($n + 1).times do |i|\n    unless $used[i]\n      return true if dfs(i, dx + ($ps[pos][0] - $ps[i][0]).abs, dy + ($ps[pos][1] - $ps[i][1]).abs, t)\n    end\n  end\n  $used[pos] = false\n  false\nend\n\nwhile l = gets\n  $n, x0, y0, $x1, $y1 = l.split.map(&:to_i)\n  break if $n == 0\n  ps = $n.times.map { gets.split.map(&:to_i) }\n  $ps = [[x0, y0], *ps]\n  $used = [false] * ($n + 1)\n  puts dfs(0, 0, 0, 0) ? 'YES' : 'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "include Math\n\nloop {\n    n, hx, hy, dx, dy = gets.split.map &:to_i\n    break if n == 0\n\n    points = [[hx, hy]] + (1..n).map { gets.split.map &:to_i }\n\n    dist = (0..n).map{|i|\n        (0..n).map{|j|\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            sqrt((x1-x2)**2 + (y1-y2)**2)\n        }\n    }\n\n    deadline = points.map{|x, y|\n        sqrt((x - dx)**2 + (y - dy)**2)\n    }\n\n    stack = [[0, 0] + (1..n).to_a]\n    success = false\n    until stack.empty?\n        t, i, *unreached = stack.pop\n        if unreached == [] \n            success = true\n            break\n        end\n        next if unreached.any?{|j| t + dist[i][j] >= deadline[j]}\n        unreached.each{|j|\n            stack << [t + dist[i][j], j, *(unreached - [j])]\n        }\n    end\n    puts success ? 'YES' : 'NO'\n}"
  },
  {
    "language": "Ruby",
    "code": "include Math\n\nloop {\n    n, hx, hy, dx, dy = gets.split.map &:to_i\n    break if n == 0\n\n    points = [[hx, hy]] + (1..n).map { gets.split.map &:to_i }\n\n    dist = (0..n).map{|i|\n        (0..n).map{|j|\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            hypot(x1 - x2, y1 - y2)\n        }\n    }\n\n    deadline = points.map{|x, y| hypot(x - dx, y - dy)}\n    \n    stack = [[0, 0] + (1..n).to_a]\n    success = false \n    until stack.empty?\n        t, i, *unreached = stack.pop\n        if unreached == [] \n            success = true \n            break\n        end \n        next if unreached.any?{|j| t + dist[i][j] >= deadline[j]}\n        unreached.each{|j|\n            stack << [t + dist[i][j], j, *(unreached - [j])]\n        }   \n    end\n    puts success ? 'YES' : 'NO'\n}"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\ndef dfs(pos, s, t)\n  return true if t == $n\n  (1..$n).each do |i|\n    unless $used[i]\n      return false if $dist[i][$n+1] < s + $dist[pos][i] + EPS\n    end\n  end\n  (1..$n).each do |i|\n    unless $used[i]\n      $used[i] = true\n      return true if dfs(i, s + $dist[pos][i], t + 1)\n      $used[i] = false\n    end\n  end\n  false\nend\n \nwhile l = gets\n  $n, x0, y0, x1, y1 = l.split.map(&:to_i)\n  break if $n == 0\n  ps = $n.times.map { gets.split.map(&:to_i) }\n  $ps = [[x0, y0], *ps, [x1, y1]]\n  $dist = $ps.map { |x0, y0| $ps.map { |x1, y1| Math.sqrt((x1 - x0) ** 2 + (y1 - y0) ** 2) } }\n  $used = [false] * ($n + 1)\n  puts dfs(0, 0, 0) ? 'YES' : 'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "loop {\n    n, hx, hy, dx, dy = gets.split.map &:to_i\n    break if n == 0\n\n    points = [[hx, hy]] + (1..n).map { gets.split.map &:to_i }\n\n    dist = (0..n).map{|i|\n        (0..n).map{|j|\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            sqrt((x1-x2)**2 + (y1-y2)**2)\n        }\n    }\n\n    deadline = points.map{|x, y|\n        sqrt((x - dx)**2 + (y - dy)**2)\n    }\n\n    stack = [[0, 0] + (1..n).to_a]\n    success = false\n    until stack.empty?\n        t, i, *unreached = stack.pop\n        if unreached == [] \n            success = true\n            break\n        end\n        next if unreached.any?{|j| t + dist[i][j] >= deadline[j]}\n        unreached.each{|j|\n            stack << [t + dist[i][j], j, *(unreached - [j])]\n        }\n    end\n    puts success ? 'YES' : 'NO'\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static float[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (v < 16) {\n                if (cache[v].get(used, cast(float)1e4) <= t) return false;\n                cache[v][used] = t;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        auto cache = new double[int][N + 1];\n        bool dfs(int v, int used, double t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, 1e9) <= t) return false;\n            cache[v][used] = t;\n            foreach (i; 0 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        auto cache = new double[int][N + 1];\n        double T = 1e9;\n        foreach (i; 1 .. N) {\n            T = min(T, Distance(i, N + 1));\n        }\n        bool dfs(int v, int used, double t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (t >= T) return false;\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, 1e9) <= t) return false;\n            cache[v][used] = t;\n            foreach (i; 0 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint popcnt(int x) {\n    int r = 0;\n    foreach (i; 0 .. 22) if (x & (1 << i)) r++;\n    return r;\n}\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        bool dfs(int v, int used, double t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b %f\", v, used, t);\n            if (used == (1 << (N + 1)) - 1) return true;\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static float[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (v < 17) {\n                if (cache[v].get(used, cast(float)1e4) <= t) return false;\n                cache[v][used] = t;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N];\n        X = new int[N];\n        foreach (i; 0 .. N) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        return true;\n    }\n    double Distance(double y1, double x1, double y2, double x2) {\n        double dy = y1 - y2,\n               dx = x1 - x2;\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static float[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << N) - 1) return true;\n            if (cache[v].get(used, cast(float)1e4) <= t) return false;\n            import core.bitop;\n            if (used.popcnt < 16) {\n                cache[v][used] = t;\n            }\n            foreach (i; 0 .. N) {\n                if (used & (1 << i)) continue;\n                if (Distance(Y[v], X[v], Y[i], X[i]) + t >= Distance(Dy, Dx, Y[i], X[i])) return false;\n            }\n            foreach (i; 0 .. N) {\n                if (dfs(i, used | 1 << i, t + Distance(Y[v], X[v], Y[i], X[i]))) return true;\n            }\n            return false;\n        }\n        foreach (i; 0 .. N) {\n            if (Distance(Hy, Hx, Y[i], X[i]) >= Distance(Y[i], X[i], Dy, Dx)) {\n                writeln(\"NO\"); return;\n            }\n        }\n        foreach (i; 0 .. N) {\n            if (dfs(i, 1 << i, Distance(Hy, Hx, Y[i], X[i]))) {\n                writeln(\"YES\"); return;\n            }\n        }\n        writeln(\"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint popcnt(int x) {\n    int r = 0;\n    foreach (i; 0 .. 22) if (x & (1 << i)) r++;\n    return r;\n}\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static float[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b %f\", v, used, t);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, cast(float)1e4) <= t) return false;\n            if (used.popcnt <= N - 5) {\n                cache[v][used] = t;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        auto cache = new double[int][N + 1];\n        double T = 1e9;\n        bool dfs(int v, int used, double t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, 1e9) <= t) return false;\n            cache[v][used] = t;\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static double[int] cache[20];\n        cache.clear;\n        bool dfs(int v, int used, double t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (v > 0 && cache[v - 1].get(used, 1e9) <= t) return false;\n            if (v > 0) cache[v - 1][used] = t;\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        foreach (i; 0 .. N) {\n            if (dfs(i, 1 << i, Distance(0, i + 1))) {\n                writeln(\"YES\"); return;\n            }\n        }\n        writeln(\"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        auto cache = new float[int][N + 1];\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, cast(float)1e9) <= t) return false;\n            cache[v][used] = t;\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint popcnt(int x) {\n    int r = 0;\n    foreach (i; 0 .. 22) if (x & (1 << i)) r++;\n    return r;\n}\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static double[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, double t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b %f\", v, used, t);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, 1e4) <= t) return false;\n            if (v <= N - 8) {\n                cache[v][used] = t;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        auto cache = new double[][](N + 1, 1 << (N + 1));\n        foreach (ref L; cache) L[] = 1e9;\n        bool dfs(int v, int used, double t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v][used] <= t) return false;\n            cache[v][used] = t;\n            foreach (i; 0 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) continue;\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static float[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (v < 19) {\n                if (cache[v].get(used, cast(float)1e4) <= t) return false;\n                cache[v][used] = t;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint popcnt(int x) {\n    int r = 0;\n    foreach (i; 0 .. 22) if (x & (1 << i)) r++;\n    return r;\n}\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static float[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b %f\", v, used, t);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, cast(float)1e4) <= t) return false;\n            if (used.popcnt >= 3) {\n                cache[v][used] = t;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint popcnt(int x) {\n    int r = 0;\n    foreach (i; 0 .. 22) {\n        if (x & (1 << i)) r++;\n    }\n    return r;\n}\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N];\n        X = new int[N];\n        foreach (i; 0 .. N) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        return true;\n    }\n    double Distance(double y1, double x1, double y2, double x2) {\n        double dy = y1 - y2,\n               dx = x1 - x2;\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        auto cache = new double[int][N];\n        bool dfs(int v, int used, double t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << N) - 1) return true;\n            if (cache[v].get(used, 1e4) <= t) return false;\n            cache[v][used] = t;\n            foreach (i; 0 .. N) {\n                if (used & (1 << i)) continue;\n                if (Distance(Y[v], X[v], Y[i], X[i]) + t >= Distance(Dy, Dx, Y[i], X[i])) return false;\n            }\n            foreach (i; 0 .. N) {\n                if (dfs(i, used | 1 << i, t + Distance(Y[v], X[v], Y[i], X[i]))) return true;\n            }\n            return false;\n        }\n        foreach (i; 0 .. N) {\n            if (Distance(Hy, Hx, Y[i], X[i]) >= Distance(Y[i], X[i], Dy, Dx)) {\n                writeln(\"NO\"); return;\n            }\n        }\n        foreach (i; 0 .. N) {\n            if (dfs(i, 1 << i, Distance(Hy, Hx, Y[i], X[i]))) {\n                writeln(\"YES\"); return;\n            }\n        }\n        writeln(\"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        auto cache = new double[int][N + 1];\n        bool dfs(int v, int used, double t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, 1e9) <= t) return false;\n            cache[v][used] = t;\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n        import core.memory;\n        GC.collect;\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static float[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, cast(float)1e4) <= t) return false;\n            cache[v][used] = t;\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static double[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, double t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, 1e9) <= t) return false;\n            cache[v][used] = t;\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint popcnt(int x) {\n    int r = 0;\n    foreach (i; 0 .. 22) if (x & (1 << i)) r++;\n    return r;\n}\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static float[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b %f\", v, used, t);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, cast(float)1e4) <= t) return false;\n            if (v <= N - 5) {\n                cache[v][used] = t;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint popcnt(int x) {\n    int r = 0;\n    foreach (i; 0 .. 22) if (x & (1 << i)) r++;\n    return r;\n}\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static float[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b %f\", v, used, t);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, cast(float)1e4) <= t) return false;\n            if (used.popcnt <= N - 10) {\n                cache[v][used] = t;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint popcnt(int x) {\n    int r = 0;\n    foreach (i; 0 .. 22) {\n        if (x & (1 << i)) r++;\n    }\n    return r;\n}\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N];\n        X = new int[N];\n        foreach (i; 0 .. N) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        return true;\n    }\n    double Distance(double y1, double x1, double y2, double x2) {\n        double dy = y1 - y2,\n               dx = x1 - x2;\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static float[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << N) - 1) return true;\n            if (cache[v].get(used, cast(float)1e4) <= t) return false;\n            if (used.popcnt < 16) {\n                cache[v][used] = t;\n            }\n            foreach (i; 0 .. N) {\n                if (used & (1 << i)) continue;\n                if (Distance(Y[v], X[v], Y[i], X[i]) + t >= Distance(Dy, Dx, Y[i], X[i])) return false;\n            }\n            foreach (i; 0 .. N) {\n                if (dfs(i, used | 1 << i, t + Distance(Y[v], X[v], Y[i], X[i]))) return true;\n            }\n            return false;\n        }\n        foreach (i; 0 .. N) {\n            if (Distance(Hy, Hx, Y[i], X[i]) >= Distance(Y[i], X[i], Dy, Dx)) {\n                writeln(\"NO\"); return;\n            }\n        }\n        foreach (i; 0 .. N) {\n            if (dfs(i, 1 << i, Distance(Hy, Hx, Y[i], X[i]))) {\n                writeln(\"YES\"); return;\n            }\n        }\n        writeln(\"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static float[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (v < 18) {\n                if (cache[v].get(used, cast(float)1e4) <= t) return false;\n                cache[v][used] = t;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint popcnt(int x) {\n    int r = 0;\n    foreach (i; 0 .. 22) if (x & (1 << i)) r++;\n    return r;\n}\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static float[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b %f\", v, used, t);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, cast(float)1e4) <= t) return false;\n            if (v <= N - 8) {\n                cache[v][used] = t;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N];\n        X = new int[N];\n        foreach (i; 0 .. N) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        return true;\n    }\n    double Distance(double y1, double x1, double y2, double x2) {\n        double dy = y1 - y2,\n               dx = x1 - x2;\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        static float[int] cache[22];\n        cache.clear;\n        bool dfs(int v, int used, float t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << N) - 1) return true;\n            if (cache[v].get(used, cast(float)1e4) <= t) return false;\n            cache[v][used] = t;\n            foreach (i; 0 .. N) {\n                if (used & (1 << i)) continue;\n                if (Distance(Y[v], X[v], Y[i], X[i]) + t >= Distance(Dy, Dx, Y[i], X[i])) return false;\n            }\n            foreach (i; 0 .. N) {\n                if (dfs(i, used | 1 << i, t + Distance(Y[v], X[v], Y[i], X[i]))) return true;\n            }\n            return false;\n        }\n        foreach (i; 0 .. N) {\n            if (Distance(Hy, Hx, Y[i], X[i]) >= Distance(Y[i], X[i], Dy, Dx)) {\n                writeln(\"NO\"); return;\n            }\n        }\n        foreach (i; 0 .. N) {\n            if (dfs(i, 1 << i, Distance(Hy, Hx, Y[i], X[i]))) {\n                writeln(\"YES\"); return;\n            }\n        }\n        writeln(\"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint popcnt(int x) {\n    int r = 0;\n    foreach (i; 0 .. 22) {\n        if (x & (1 << i)) r++;\n    }\n    return r;\n}\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        struct P {\n            int v, used;\n            double t;\n        }\n        bool bfs() {\n            DList!P Q;\n            Q.insert(P(0, 1, 0));\n            int pcount = 0;\n            double[int] cache;\n            while (!Q.empty) {\n                auto c = Q.front; Q.removeFront;\n                if (c.used == (1 << (N + 1)) - 1) { return true; }\n                if (pcount < c.used.popcnt) {\n                    cache.clear;\n                    pcount = c.used.popcnt;\n                }\n                if (cache.get(c.used, 1e4) <= c.t) continue;\n                cache[c.used] = c.t;\n                foreach (i; 1 .. N + 1) {\n                    if (c.used & (1 << i)) continue;\n                    if (Distance(c.v, i) + c.t >= Distance(N + 1, i)) {\n                        goto NEXT;\n                    }\n                }\n                foreach (i; 1 .. N + 1) {\n                    Q.insert(P(i, c.used | 1 << i, Distance(c.v, i) + c.t));\n                }\nNEXT:;\n            }\n            return false;\n        }\n        writeln(bfs ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        auto cache = new float[int][N + 1];\n        double T = 1e9;\n        bool dfs(int v, int used, double t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b\", v, used);\n            if (used == (1 << (N + 1)) - 1) return true;\n            if (cache[v].get(used, 1e9) <= t) return false;\n            cache[v][used] = t;\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint popcnt(int x) {\n    int r = 0;\n    foreach (i; 0 .. 22) if (x & (1 << i)) r++;\n    return r;\n}\n\nvoid main() {\n    int N, Hx, Hy, Dx, Dy;\n    int[] Y, X;\n    bool input() {\n        scanf(\"%d %d %d %d %d\\n\", &N, &Hx, &Hy, &Dx, &Dy);\n        if (N == 0) return false;\n        Y = new int[N + 2];\n        X = new int[N + 2];\n        Y[0] = Hy;\n        X[0] = Hx;\n        foreach (i; 1 .. N + 1) {\n            scanf(\"%d %d\\n\", &X[i], &Y[i]);\n        }\n        Y[N + 1] = Dy;\n        X[N + 1] = Dx;\n        return true;\n    }\n    double Distance(int a, int b) {\n        double dy = Y[a] - Y[b],\n               dx = X[a] - X[b];\n        return sqrt(dy * dy + dx * dx);\n    }\n    void solve() {\n        //static double[int] cache[22];\n        //cache.clear;\n        bool dfs(int v, int used, double t) {\n            //writefln(\"%d %0\" ~ (N + 2).to!string ~ \"b %f\", v, used, t);\n            if (used == (1 << (N + 1)) - 1) return true;\n            //if (cache[v].get(used, 1e4) <= t) return false;\n            //if (v <= N - 8) {\n            //    cache[v][used] = t;\n            //}\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (Distance(v, i) + t >= Distance(N + 1, i)) return false;\n            }\n            foreach (i; 1 .. N + 1) {\n                if (used & (1 << i)) continue;\n                if (dfs(i, used | 1 << i, t + Distance(v, i))) return true;\n            }\n            return false;\n        }\n        writeln(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from math import sqrt\n    from sys import stdin\n    f_i = stdin\n    \n    def dfs(point, remain, elapsed):\n        if not remain:\n            return True\n        \n        next_c = set()\n        for c in remain:\n            new_elapsed = elapsed + adj[point][c]\n            if new_elapsed >= from_d[c]:\n                return False\n            next_c.add((c, new_elapsed))\n        \n        for c, new_elapsed in next_c:\n            remain.remove(c)\n            if dfs(c, remain, new_elapsed):\n                return True\n            remain.add(c)\n        \n        return False\n    \n    while True:\n        n, hx, hy, dx, dy = map(int, f_i.readline().split())\n        if n == 0:\n            break\n        \n        C = [tuple(map(int, f_i.readline().split())) for i in range(n)]\n        from_d = tuple(sqrt((cx - dx) ** 2 + (cy - dy) ** 2) for cx, cy in C)\n        C.append((hx, hy))\n        adj = tuple(tuple(sqrt((px - qx) ** 2 + (py - qy) ** 2) for qx, qy in C) for px, py in C)\n        \n        if dfs(n, set(range(n)), 0):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nEPS = 10**(-10)\n\ndef solve(t,x,y):\n    global ans\n    global done\n    if ans: return\n\n    cnt = 0\n    for i in xrange(len(c)):\n        if done[i]: cnt += 1\n\n    if cnt is n:\n        ans = True\n        return\n    \n    for i in xrange(len(c)):\n        if done[i]: continue\n        nt = t + math.hypot(c[i][0]-x, c[i][1]-y)\n        if math.hypot(dx-c[i][0], dy-c[i][1]) < nt + EPS: return\n\n    for i in xrange(len(c)-1, -1, -1):\n        if done[i]: continue\n        #print sys.stderr, i,c[i],len(c)\n        done[i] = True\n        nt = t + math.hypot(c[i][0]-x, c[i][1]-y)\n        solve(nt,c[i][0],c[i][1])\n        done[i] = False\n\nwhile 1:\n    n,hx,hy,dx,dy = map(int, raw_input().split())\n    if not(n or hx or hy or dx or dy): break\n    c = []\n    ans = False\n    for i in xrange(n):\n        x,y = map(int, raw_input().split())\n        c.append((x,y))\n    done = [False for i in xrange(len(c))]\n    solve(0.0,hx,hy)\n    if ans: print 'YES'\n    else: print 'NO'"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\n\n\ndef dfs(remains, elapsed, hx, hy, prev):\n    global crystals, dc\n\n    if not remains:\n        return True\n\n    remains_c = set()\n    for i in remains:\n        cx, cy, dfd = crystals[i]\n        new_elapsed = elapsed + dc[prev][i]\n        if dfd <= new_elapsed:\n            return False\n        remains_c.add((i, cx, cy, new_elapsed))\n\n    for i, cx, cy, new_elapsed in remains_c:\n        remains.remove(i)\n        if dfs(remains, new_elapsed, cx, cy, i):\n            return True\n        remains.add(i)\n\n    return False\n\n\nwhile True:\n    n, hx, hy, dx, dy = map(int, input().split())\n    if n == 0: break\n\n    crystals_in = [tuple(map(int, input().split())) for _ in range(n)]\n    crystals = [(cx, cy, sqrt((cx - dx) ** 2 + (cy - dy) ** 2)) for cx, cy in crystals_in]\n    crystals_in += [(hx, hy)]\n    dc = [[sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) for x2, y2 in crystals_in] for x1, y1 in crystals_in]\n\n    print('YES' if dfs(set(range(n)), 0, hx, hy, n) else 'NO')"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nEPS = 10**(-10)\n\ndef solve(t,x,y,c):\n    global ans\n    if ans: return\n\n    for i in xrange(len(c)):\n        #print sys.stderr, i\n        nt = t + math.hypot(c[i][0]-x, c[i][1]-y)\n        if math.hypot(dx-c[i][0], dy-c[i][1]) < nt + EPS: return\n\n    for i in xrange(len(c)-1, -1, -1):\n        if ans: return\n        #print sys.stderr, i,c[i],len(c)\n        nt = t + math.hypot(c[i][0]-x, c[i][1]-y)\n        c.remove((c[i][0],c[i][1]))\n        #print sys.stderr, c\n        if c == []:\n            ans = True\n            return\n        solve(nt,x,y,c)\n\nwhile 1:\n    n,hx,hy,dx,dy = map(int, raw_input().split())\n    if not(n or hx or hy or dx or dy): break\n    c = []\n    ans = False\n    for i in xrange(n):\n        x,y = map(int, raw_input().split())\n        c.append((x,y))\n    solve(0.0,hx,hy,c)\n    if ans: print 'YES'\n    else: print 'NO'"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\n\n\ndef dfs(remains, elapsed, hx, hy):\n    global crystals\n\n    if not remains:\n        return True\n\n    remains_c = set()\n    for i in remains:\n        cx, cy, dfd = crystals[i]\n        dfh = sqrt((cx - hx) ** 2 + (cy - hy) ** 2)\n        new_elapsed = elapsed + dfh\n        if dfd <= new_elapsed:\n            return False\n        remains_c.add((i, cx, cy, new_elapsed))\n\n    for i, cx, cy, new_elapsed in remains_c:\n        remains.discard(i)\n        if dfs(remains, new_elapsed, cx, cy):\n            return True\n        remains.add(i)\n\n    return False\n\n\nwhile True:\n    n, hx, hy, dx, dy = map(int, input().split())\n    if n == 0: break\n\n    crystals = [(cx, cy, sqrt((cx - dx) ** 2 + (cy - dy) ** 2)) for cx, cy in\n                (map(int, input().split()) for _ in range(n))]\n\n    print('YES' if dfs(set(range(n)), 0, hx, hy) else 'NO')"
  },
  {
    "language": "Python",
    "code": "def distance(pos_a,pos_b):\n    total = 0\n    total += abs(pos_a[0] - pos_b[0])\n    total += abs(pos_a[1] - pos_b[1])\n    return total\n\nwhile True:\n    crystal = []\n    n,yx,yy,mx,my = map(int,raw_input().split())\n    if(n == 0 and yx == 0 and yy == 0 and mx == 0 and my == 0):\n        break\n    for i in xrange(n):\n        crystal.append(map(int,raw_input().split()))\n    success = True\n    for crystal_position in crystal:\n        if(distance([mx,my],crystal_position) < distance([yx,yy],crystal_position)):\n            success = False\n    if(success == True):\n        print \"YES\"\n    else:\n        print \"NO\""
  },
  {
    "language": "Python",
    "code": "def distance(pos_a,pos_b):\n    total = 0\n    total += abs(pos_a[0] - pos_b[0])\n    total += abs(pos_a[1] - pos_b[1])\n    return total\n\nwhile True:\n    crystal = []\n    n,yx,yy,mx,my = map(int,raw_input().split())\n    if(n == 0 and yx == 0 and yy == 0 and mx == 0 and my == 0):\n        break\n    for i in xrange(n):\n        crystal.append(map(int,raw_input().split()))\n    success = True\n    for crystal_position in crystal:\n        if(distance([mx,my],crystal_position) <= distance([yx,yy],crystal_position)):\n            success = False\n    if(success == True):\n        print \"YES\"\n    else:\n        print \"NO\""
  },
  {
    "language": "Python",
    "code": "from math import sqrt\n\n\ndef dfs(remains, elapsed, hx, hy):\n    global crystals\n\n    if not remains:\n        return True\n\n    remains_c = set()\n    for i in remains:\n        cx, cy, dfd = crystals[i]\n        new_elapsed = elapsed + sqrt((cx - hx) ** 2 + (cy - hy) ** 2)\n        if dfd <= new_elapsed:\n            return False\n        remains_c.add((i, cx, cy, new_elapsed))\n\n    for i, cx, cy, new_elapsed in remains_c:\n        remains.remove(i)\n        if dfs(remains, new_elapsed, cx, cy):\n            return True\n        remains.add(i)\n\n    return False\n\n\nwhile True:\n    n, hx, hy, dx, dy = map(int, input().split())\n    if n == 0: break\n\n    crystals = [(cx, cy, sqrt((cx - dx) ** 2 + (cy - dy) ** 2))\n                for cx, cy in (map(int, input().split()) for _ in range(n))]\n\n    print('YES' if dfs(set(range(n)), 0, hx, hy) else 'NO')"
  },
  {
    "language": "Rust",
    "code": "use std::io::{Read, StdinLock};\nuse std::str::{from_utf8, FromStr};\nuse std::vec::Vec;\n\nconst EPS: f64 = 1e-6;\n\nstruct StdinReader<'a> { reader: StdinLock<'a> }\n\nimpl<'a> StdinReader<'a> {\n    pub fn new(reader: StdinLock<'a>) -> StdinReader { StdinReader { reader: reader } }\n    pub fn read<T: FromStr>(&mut self) -> T {\n        fn is_space(ch: u8) -> bool { ch == 0x20 || ch == 0x0a || ch == 0x0d }\n        let b: Vec<u8> = self.reader.by_ref().bytes().map(|ch| ch.unwrap())\n            .skip_while(|ch| is_space(*ch)).take_while(|ch| !is_space(*ch)).collect();\n        let s = from_utf8(&b).unwrap();\n        s.parse().unwrap_or_else(|_| panic!(format!(\"failed to parse: {}\", s)))\n    }\n}\n\nfn distance(p1: (f64, f64), p2: (f64, f64)) -> f64 {\n    let dx = p1.0 - p2.0;\n    let dy = p1.1 - p2.1;\n    (dx * dx + dy * dy).sqrt()\n}\n\nfn dfs(visited: u32, p: (f64, f64), t: f64, crystals: &[(f64, f64)]) -> bool {\n    let n = crystals.len();\n    if visited == (1 << n) - 1 {\n        return true;\n    }\n\n    // すべての頂点に到達可能かどうかをチェック\n    for v in 0..n {\n        if visited & (1 << v) != 0 { continue; }\n        let q = crystals[v];\n        let d = distance(p, q);\n        if t + d >= distance(q, (0.0, 0.0)) - EPS {\n            return false;\n        }\n    }\n\n    for v in 0..n {\n        if visited & (1 << v) != 0 { continue; }\n        let q = crystals[v];\n        let d = distance(p, q);\n        if dfs(visited ^ (1 << v), q, t + d, crystals) {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let stdin = std::io::stdin();\n    let mut reader = StdinReader::new(stdin.lock());\n\n    loop {\n        let n: usize = reader.read();\n        let hx: f64 = reader.read();\n        let hy: f64 = reader.read();\n        let dx: f64 = reader.read();\n        let dy: f64 = reader.read();\n        let start = (hx - dx, hy - dy);\n        if n == 0 { break; }\n\n        let mut crystals: Vec<(f64, f64)> = Vec::new();\n        for _ in 0..n {\n            let cx = reader.read::<f64>() - dx;\n            let cy = reader.read::<f64>() - dy;\n            crystals.push((cx, cy));\n        }\n\n        let ok = dfs(0, start, 0.0, &crystals);\n\n        println!(\"{}\", if ok { \"YES\" } else { \"NO\" });\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{Read, StdinLock};\nuse std::ops::{Add, Mul, Sub};\nuse std::str::{from_utf8, FromStr};\nuse std::vec::Vec;\n\nstruct StdinReader<'a> {\n    reader: StdinLock<'a>,\n}\n\nimpl<'a> StdinReader<'a> {\n    pub fn new(reader: StdinLock<'a>) -> StdinReader {\n        StdinReader { reader: reader }\n    }\n\n    pub fn read<T: FromStr>(&mut self) -> T {\n        fn is_whitespace(ch: u8) -> bool {\n            ch == 0x20 || ch == 0x0a || ch == 0x0d\n        }\n\n        let token: Vec<u8> = self.reader\n            .by_ref()\n            .bytes()\n            .map(|ch| ch.expect(\"failed to read a byte\"))\n            .skip_while(|ch| is_whitespace(*ch))\n            .take_while(|ch| !is_whitespace(*ch))\n            .collect();\n        let token_str = from_utf8(&token)\n            .unwrap_or_else(|_| panic!(format!(\"invalid utf8 sequence: {:?}\", token)));\n        token_str\n            .parse()\n            .unwrap_or_else(|_| panic!(format!(\"failed to parse input: {}\", token_str)))\n    }\n}\n\nconst EPS: f64 = 1e-10;\n\n#[derive(Debug, Copy, Clone)]\nstruct Complex {\n    pub re: f64,\n    pub im: f64,\n}\n\nimpl Complex {\n    fn new(re: f64, im: f64) -> Complex { Complex { re: re, im: im } }\n}\n\nimpl Add<Complex> for Complex {\n    type Output = Complex;\n    fn add(self, other: Complex) -> Complex { Complex::new(self.re + other.re, self.im + other.im) }\n}\n\nimpl Sub<Complex> for Complex {\n    type Output = Complex;\n    fn sub(self, other: Complex) -> Complex { Complex::new(self.re - other.re, self.im - other.im) }\n}\n\nimpl Mul<f64> for Complex {\n    type Output = Complex;\n    fn mul(self, other: f64) -> Complex { Complex::new(self.re * other, self.im * other) }\n}\n\nimpl Mul<Complex> for Complex {\n    type Output = Complex;\n    fn mul(self, other: Complex) -> Complex {\n        Complex::new(self.re * other.re - self.im * other.im,\n                     self.re * other.im + self.im * other.re)\n    }\n}\n\nimpl Complex {\n    fn conj(&self) -> Complex { Complex::new(self.re, -self.im) }\n    fn norm_sqr(&self) -> f64 { self.re * self.re + self.im * self.im }\n    fn norm(&self) -> f64 { self.norm_sqr().sqrt() }\n    /*\n    fn inv(&self) -> Complex {\n        let d = self.norm_sqr();\n        Complex::new(self.re / d, -self.im / d)\n    }\n    */\n    fn dot(&self, other: Complex) -> f64 {\n        (self.conj() * other).re\n    }\n    /*\n    fn cross(&self, other: Complex) -> f64 {\n        (self.conj() * other).im\n    }\n    */\n}\n\n/*\nfn ccw(a: Complex, b: Complex, c: Complex) -> i32 {\n    let p = b - a;\n    let q = c - a;\n    if p.cross(q) > 0.0 { return 1; }\n    if p.cross(q) < 0.0 { return -1; }\n    if p.dot(q) < 0.0 { return 2; }\n    if p.norm_sqr() < q.norm_sqr() { return -2; }\n    return 0;\n}\n*/\n\nfn projection(a: Complex, b: Complex, p: Complex) -> Complex {\n    let t = (p - a).dot(a - b) / (a - b).norm();\n    a + (a - b) * t\n}\n\nfn intersect_sp(a: Complex, b: Complex, p: Complex) -> bool {\n    (a - p).norm() + (b - p).norm() - (b - a).norm() < EPS\n}\n\n/*\nfn distance_sp(a: Complex, b: Complex, p: Complex) -> f64 {\n    let r = projection(a, b, p);\n    if intersect_sp(a, b, p) {\n        (r - p).norm()\n    } else {\n        (a - p).norm().min((b - p).norm())\n    }\n}\n*/\n\nfn main() {\n    let zero = Complex::new(0.0, 0.0);\n\n    let stdin = std::io::stdin();\n    let mut reader = StdinReader::new(stdin.lock());\n\n    loop {\n        // 入力\n        let n: usize = reader.read();\n        let hx: f64 = reader.read();\n        let hy: f64 = reader.read();\n        let dx: f64 = reader.read();\n        let dy: f64 = reader.read();\n        let start = Complex::new(hx - dx, hy - dy);\n        if n == 0 { break; }\n\n        let mut crystals: Vec<Complex> = Vec::new();\n        for _ in 0..n {\n            let cx = reader.read::<f64>() - dx;\n            let cy = reader.read::<f64>() - dy;\n            crystals.push(Complex::new(cx, cy));\n        }\n\n        let mut distance = vec![vec![0.0; n]; n];\n        let mut time_limit = vec![vec![0.0; n]; n];\n\n        for i in 0..n {\n            for j in 0..n {\n                if i != j {\n                    let p1 = crystals[i];\n                    let p2 = crystals[j];\n                    let t1 = p1.norm();\n                    let t2 = p2.norm() - (p2 - p1).norm();\n                    let r = projection(p1, p2, zero);\n                    let t3 = if intersect_sp(p1, p2, zero) {\n                        r.norm() - (r - p1).norm()\n                    } else {\n                        1e10\n                    };\n                    time_limit[i][j] = t1.min(t2.min(t3));\n                    distance[i][j] = (p1 - p2).norm();\n                }\n            }\n        }\n\n        // dp[S][v] = Sのすべての頂点を訪れた後にvを訪れるときの最小の時刻\n        let mut dp = vec![vec![0.0; n]; 1 << n];\n        for v in 0..n {\n            dp[0][v] = (crystals[v] - start).norm();\n        }\n        for set in 1..(1 << n) {\n            for v in 0..n {\n                if set & (1 << v) != 0 { continue; }\n                let mut min_time: f64 = 1e10;\n                for u in 0..n {\n                    if set & (1 << u) == 0 { continue; }\n                    let t = dp[set ^ (1 << u)][u];\n                    if t < time_limit[u][v] {\n                        min_time = min_time.min(t + distance[u][v]);\n                    }\n                }\n                dp[set][v] = min_time;\n            }\n        }\n\n        let mut ok = false;\n        for v in 0..n {\n            let set = (1 << n) - 1;\n            if dp[set ^ (1 << v)][v] < 1e10 {\n                ok = true;\n            }\n        }\n        println!(\"{}\", if ok { \"YES\" } else { \"NO\" })\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{Read, StdinLock};\nuse std::str::{from_utf8, FromStr};\nuse std::vec::Vec;\n\nconst EPS: f64 = 1e-6;\n\nstruct StdinReader<'a> {\n    reader: StdinLock<'a>,\n}\n\nimpl<'a> StdinReader<'a> {\n    pub fn new(reader: StdinLock<'a>) -> StdinReader {\n        StdinReader { reader: reader }\n    }\n\n    pub fn read<T: FromStr>(&mut self) -> T {\n        fn is_whitespace(ch: u8) -> bool {\n            ch == 0x20 || ch == 0x0a || ch == 0x0d\n        }\n\n        let token: Vec<u8> = self.reader\n            .by_ref()\n            .bytes()\n            .map(|ch| ch.expect(\"failed to read a byte\"))\n            .skip_while(|ch| is_whitespace(*ch))\n            .take_while(|ch| !is_whitespace(*ch))\n            .collect();\n        let token_str = from_utf8(&token)\n            .unwrap_or_else(|_| panic!(format!(\"invalid utf8 sequence: {:?}\", token)));\n        token_str\n            .parse()\n            .unwrap_or_else(|_| panic!(format!(\"failed to parse input: {}\", token_str)))\n    }\n}\n\nfn distance(p1: (f64, f64), p2: (f64, f64)) -> f64 {\n    let dx = p1.0 - p2.0;\n    let dy = p1.1 - p2.1;\n    (dx * dx + dy * dy).sqrt()\n}\n\nfn dfs(visited: u32, p: (f64, f64), t: f64, crystals: &[(f64, f64)]) -> bool {\n    let n = crystals.len();\n    if visited == (1 << n) - 1 {\n        return true;\n    }\n\n    for v in 0..n {\n        if visited & (1 << v) != 0 { continue; }\n        let q = crystals[v];\n        let d = distance(p, q);\n        if t + d >= distance(q, (0.0, 0.0)) - EPS { continue; }\n        if dfs(visited ^ (1 << v), q, t + d, crystals) {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let stdin = std::io::stdin();\n    let mut reader = StdinReader::new(stdin.lock());\n\n    loop {\n        let n: usize = reader.read();\n        let hx: f64 = reader.read();\n        let hy: f64 = reader.read();\n        let dx: f64 = reader.read();\n        let dy: f64 = reader.read();\n        let start = (hx - dx, hy - dy);\n        if n == 0 { break; }\n\n        let mut crystals: Vec<(f64, f64)> = Vec::new();\n        for _ in 0..n {\n            let cx = reader.read::<f64>() - dx;\n            let cy = reader.read::<f64>() - dy;\n            crystals.push((cx, cy));\n        }\n\n        let ok = dfs(0, start, 0.0, &crystals);\n\n        println!(\"{}\", if ok { \"YES\" } else { \"NO\" });\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{Read, StdinLock};\nuse std::str::{from_utf8, FromStr};\nuse std::vec::Vec;\n\nconst EPS: f64 = 1e-6;\n\nstruct StdinReader<'a> {\n    reader: StdinLock<'a>,\n}\n\nimpl<'a> StdinReader<'a> {\n    pub fn new(reader: StdinLock<'a>) -> StdinReader {\n        StdinReader { reader: reader }\n    }\n\n    pub fn read<T: FromStr>(&mut self) -> T {\n        fn is_whitespace(ch: u8) -> bool {\n            ch == 0x20 || ch == 0x0a || ch == 0x0d\n        }\n\n        let token: Vec<u8> = self.reader\n            .by_ref()\n            .bytes()\n            .map(|ch| ch.expect(\"failed to read a byte\"))\n            .skip_while(|ch| is_whitespace(*ch))\n            .take_while(|ch| !is_whitespace(*ch))\n            .collect();\n        let token_str = from_utf8(&token)\n            .unwrap_or_else(|_| panic!(format!(\"invalid utf8 sequence: {:?}\", token)));\n        token_str\n            .parse()\n            .unwrap_or_else(|_| panic!(format!(\"failed to parse input: {}\", token_str)))\n    }\n}\n\nfn distance(p1: (f64, f64), p2: (f64, f64)) -> f64 {\n    let dx = p1.0 - p2.0;\n    let dy = p1.1 - p2.1;\n    (dx * dx + dy * dy).sqrt()\n}\n\nfn dfs(visited: u32, p: (f64, f64), t: f64, crystals: &[(f64, f64)]) -> bool {\n    let n = crystals.len();\n    if visited == (1 << n) - 1 {\n        return true;\n    }\n\n    // すべての頂点に到達可能かどうかをチェック\n    for v in 0..n {\n        if visited & (1 << v) != 0 { continue; }\n        let q = crystals[v];\n        let d = distance(p, q);\n        if t + d >= distance(q, (0.0, 0.0)) - EPS {\n            return false;\n        }\n    }\n\n    for v in 0..n {\n        if visited & (1 << v) != 0 { continue; }\n        let q = crystals[v];\n        let d = distance(p, q);\n        if dfs(visited ^ (1 << v), q, t + d, crystals) {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let stdin = std::io::stdin();\n    let mut reader = StdinReader::new(stdin.lock());\n\n    loop {\n        let n: usize = reader.read();\n        let hx: f64 = reader.read();\n        let hy: f64 = reader.read();\n        let dx: f64 = reader.read();\n        let dy: f64 = reader.read();\n        let start = (hx - dx, hy - dy);\n        if n == 0 { break; }\n\n        let mut crystals: Vec<(f64, f64)> = Vec::new();\n        for _ in 0..n {\n            let cx = reader.read::<f64>() - dx;\n            let cy = reader.read::<f64>() - dy;\n            crystals.push((cx, cy));\n        }\n\n        let ok = dfs(0, start, 0.0, &crystals);\n\n        println!(\"{}\", if ok { \"YES\" } else { \"NO\" });\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{Read, StdinLock};\nuse std::ops::{Add, Mul, Sub};\nuse std::str::{from_utf8, FromStr};\nuse std::vec::Vec;\n\nstruct StdinReader<'a> {\n    reader: StdinLock<'a>,\n}\n\nimpl<'a> StdinReader<'a> {\n    pub fn new(reader: StdinLock<'a>) -> StdinReader {\n        StdinReader { reader: reader }\n    }\n\n    pub fn read<T: FromStr>(&mut self) -> T {\n        fn is_whitespace(ch: u8) -> bool {\n            ch == 0x20 || ch == 0x0a || ch == 0x0d\n        }\n\n        let token: Vec<u8> = self.reader\n            .by_ref()\n            .bytes()\n            .map(|ch| ch.expect(\"failed to read a byte\"))\n            .skip_while(|ch| is_whitespace(*ch))\n            .take_while(|ch| !is_whitespace(*ch))\n            .collect();\n        let token_str = from_utf8(&token)\n            .unwrap_or_else(|_| panic!(format!(\"invalid utf8 sequence: {:?}\", token)));\n        token_str\n            .parse()\n            .unwrap_or_else(|_| panic!(format!(\"failed to parse input: {}\", token_str)))\n    }\n}\n\nconst EPS: f64 = 1e-6;\n\n#[derive(Debug, Copy, Clone)]\nstruct Complex {\n    pub re: f64,\n    pub im: f64,\n}\n\nimpl Complex {\n    fn new(re: f64, im: f64) -> Complex { Complex { re: re, im: im } }\n}\n\nimpl Add<Complex> for Complex {\n    type Output = Complex;\n    fn add(self, other: Complex) -> Complex { Complex::new(self.re + other.re, self.im + other.im) }\n}\n\nimpl Sub<Complex> for Complex {\n    type Output = Complex;\n    fn sub(self, other: Complex) -> Complex { Complex::new(self.re - other.re, self.im - other.im) }\n}\n\nimpl Mul<f64> for Complex {\n    type Output = Complex;\n    fn mul(self, other: f64) -> Complex { Complex::new(self.re * other, self.im * other) }\n}\n\nimpl Mul<Complex> for Complex {\n    type Output = Complex;\n    fn mul(self, other: Complex) -> Complex {\n        Complex::new(self.re * other.re - self.im * other.im,\n                     self.re * other.im + self.im * other.re)\n    }\n}\n\nimpl Complex {\n    fn conj(&self) -> Complex { Complex::new(self.re, -self.im) }\n    fn norm_sqr(&self) -> f64 { self.re * self.re + self.im * self.im }\n    fn norm(&self) -> f64 { self.norm_sqr().sqrt() }\n    /*\n    fn inv(&self) -> Complex {\n        let d = self.norm_sqr();\n        Complex::new(self.re / d, -self.im / d)\n    }\n    */\n    fn dot(&self, other: Complex) -> f64 {\n        (self.conj() * other).re\n    }\n    /*\n    fn cross(&self, other: Complex) -> f64 {\n        (self.conj() * other).im\n    }\n    */\n}\n\n/*\nfn ccw(a: Complex, b: Complex, c: Complex) -> i32 {\n    let p = b - a;\n    let q = c - a;\n    if p.cross(q) > 0.0 { return 1; }\n    if p.cross(q) < 0.0 { return -1; }\n    if p.dot(q) < 0.0 { return 2; }\n    if p.norm_sqr() < q.norm_sqr() { return -2; }\n    return 0;\n}\n*/\n\nfn projection(a: Complex, b: Complex, p: Complex) -> Complex {\n    let t = (p - a).dot(a - b) / (a - b).norm();\n    a + (a - b) * t\n}\n\nfn intersect_sp(a: Complex, b: Complex, p: Complex) -> bool {\n    (a - p).norm() + (b - p).norm() - (b - a).norm() < EPS\n}\n\n/*\nfn distance_sp(a: Complex, b: Complex, p: Complex) -> f64 {\n    let r = projection(a, b, p);\n    if intersect_sp(a, b, p) {\n        (r - p).norm()\n    } else {\n        (a - p).norm().min((b - p).norm())\n    }\n}\n*/\n\nfn calculate_time_limit(p1: Complex, p2: Complex) -> f64 {\n    let zero = Complex::new(0.0, 0.0);\n    let t1 = p1.norm();\n    let t2 = p2.norm() - (p2 - p1).norm();\n    let r = projection(p1, p2, zero);\n    let t3 = if intersect_sp(p1, p2, zero) {\n        r.norm() - (r - p1).norm()\n    } else {\n        1e10\n    };\n    t1.min(t2.min(t3))\n}\n\nfn main() {\n    let stdin = std::io::stdin();\n    let mut reader = StdinReader::new(stdin.lock());\n\n    loop {\n        // 入力\n        let n: usize = reader.read();\n        let hx: f64 = reader.read();\n        let hy: f64 = reader.read();\n        let dx: f64 = reader.read();\n        let dy: f64 = reader.read();\n        let start = Complex::new(hx - dx, hy - dy);\n        if n == 0 { break; }\n\n        let mut crystals: Vec<Complex> = Vec::new();\n        for _ in 0..n {\n            let cx = reader.read::<f64>() - dx;\n            let cy = reader.read::<f64>() - dy;\n            crystals.push(Complex::new(cx, cy));\n        }\n\n        let mut distance = vec![vec![0.0; n]; n];\n        let mut time_limit = vec![vec![0.0; n]; n];\n\n        for i in 0..n {\n            for j in 0..n {\n                if i != j {\n                    let p1 = crystals[i];\n                    let p2 = crystals[j];\n                    time_limit[i][j] = calculate_time_limit(p1, p2);\n                    distance[i][j] = (p1 - p2).norm();\n                }\n            }\n        }\n\n        // dp[S][v] = Sのすべての頂点を訪れた後にvを訪れるときの最小の時刻\n        let mut dp: Vec<Vec<f32>> = vec![vec![0.0; n]; 1 << n];\n        for v in 0..n {\n            let t = calculate_time_limit(start, crystals[v]);\n            dp[0][v] = if t > EPS { (crystals[v] - start).norm() as f32 } else { 1e8 };\n        }\n        for set in 1..(1 << n) {\n            for v in 0..n {\n                if set & (1 << v) != 0 { continue; }\n                let mut min_time: f64 = 1e8;\n                for u in 0..n {\n                    if set & (1 << u) == 0 { continue; }\n                    let t = dp[set ^ (1 << u)][u] as f64;\n                    if t - time_limit[u][v] < -EPS {\n                        min_time = min_time.min(t + distance[u][v]);\n                    }\n                }\n                dp[set][v] = min_time as f32;\n            }\n        }\n\n        let mut ok = false;\n        for v in 0..n {\n            let set = (1 << n) - 1;\n            let t = dp[set ^ (1 << v)][v];\n            if t < 2000.0 {\n                ok = true;\n            }\n        }\n        println!(\"{}\", if ok { \"YES\" } else { \"NO\" })\n    }\n}\n\n"
  }
]