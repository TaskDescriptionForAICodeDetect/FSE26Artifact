[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    string A(n, '-');\n    for(auto& e : A) cin >> e;\n\n    vector<vector<vll>> dp(n + 1, vector<vll>(n + 1, vll(n + 1)));\n    dp[0][0][0] = 1;\n\n    rep(i, n){\n        rep(j, n){ // null rank\n            rep(k, n){ // person stock\n                int cur = dp[i][j][k];\n                if(cur == 0) continue;\n\n                auto& nvec = dp[i + 1];\n                if(A[i] == 'U'){\n                    nvec[j + 1][k + 1] = ADD(nvec[j + 1][k + 1], cur, mod);\n                    if(k > 0){\n                        nvec[j][k] = ADD(nvec[j][k], MUL(cur, k, mod), mod);\n                    }\n                }\n                else if(A[i] == 'D'){\n                    if(j > 0){\n                        nvec[j][k] = ADD(nvec[j][k], MUL(cur, j, mod), mod);\n                        if(k > 0){\n                            nvec[j - 1][k - 1] = ADD(nvec[j - 1][k - 1], MUL(cur, j * k, mod), mod);\n                        }\n                    }\n                }\n                else { // A[i] == '-'\n                    nvec[j][k] = ADD(nvec[j][k], cur, mod);\n                }\n            }\n        }\n    }\n\n    cout << dp[n][0][0] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int mod = 1e9 + 7;\nint64_t dp[220][220];\nint main() {\n  int n;\n  cin >> n;\n\n  vector<bool> ud;\n  for (int i = 0; i < n; ++i) {\n    char c;\n    cin >> c;\n    if (c == '-') continue;\n    ud.push_back(c == 'U');\n  }\n\n  dp[0][0] = 1;\n  n = ud.size();\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (ud[i]) {\n        (dp[i + 1][j + 1] += dp[i][j]) %= mod;\n        (dp[i + 1][j] += j * dp[i][j]) %= mod;\n      } else {\n        if (j) (dp[i + 1][j - 1] += j * j * dp[i][j]) %= mod;\n        (dp[i + 1][j] += j * dp[i][j]) %= mod;\n      }\n    }\n  }\n\n  cout << dp[n][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nll dp[128][128][128];\n\nint main(){\n    int n;\n    int const mod=1000000007;\n    while(cin>>n && n){\n        memset(dp,0,sizeof(dp));\n        dp[0][0][0]=1;\n        for(int k=0;k<n;k++){\n            char c;cin>>c;\n            if(c=='-'){\n                for(int x=0;x<=k;x++){\n                    for(int y=0;y<=k;y++){\n                        dp[k+1][x][y]+=dp[k][x][y];\n                    }\n                }\n            }\n\n            if(c=='D'){\n                for(int x=1;x<=k;x++){\n                    for(int y=1;y<=k;y++){\n                        dp[k+1][x-1][y-1]+=dp[k][x][y]*x*y;\n                        dp[k+1][x-1][y-1]%=mod;\n                    }\n                }\n                for(int x=0;x<=k;x++){\n                    for(int y=0;y<=k;y++){\n                        dp[k+1][x][y]+=dp[k][x][y]*y;\n                        dp[k+1][x][y]%=mod;\n                    }\n                }\n            }\n            \n            if(c=='U'){\n                for(int x=0;x<=k;x++){\n                    for(int y=0;y<=k;y++){\n                        dp[k+1][x][y]+=dp[k][x][y]*x;\n                        dp[k+1][x][y]%=mod;\n                    }\n                }\n                for(int x=0;x<=k;x++){\n                    for(int y=0;y<=k;y++){\n                        dp[k+1][x+1][y+1]+=dp[k][x][y];\n                        dp[k+1][x+1][y+1]%=mod;\n                    }\n                }            \n            }\n        }\n\n        for(int i=0;i<=n;i++){\n            for(int j=0;j<=n;j++){\n                cout<<dp[n][i][j]<<\" \";\n                if(j==n)cout<<endl;\n            }\n        }\n        cout<<dp[n][0][0]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint n,dp[211][211];\nstring s;\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tint N;\n\tcin>>N;\n\trep(i,N){\n\t\tchar c;cin>>c;\n\t\tif(c!='-')s+=c;\n\t}\n\tn=sz(s);\n\tdp[0][0]=1;\n\trep(i,n){\n\t\trep(j,n+1){\n\t\t\tif(s[i]=='U'){\n\t\t\t\tdp[i+1][j] += dp[i][j]*j;\n\t\t\t\tdp[i+1][j]%=MOD;\n\t\t\t\tdp[i+1][j+1] += dp[i][j];\n\t\t\t\tdp[i+1][j+1]%=MOD;\n\t\t\t}else{\n\t\t\t\tdp[i+1][j] += dp[i][j]*j;\n\t\t\t\tdp[i+1][j]%=MOD;\n\t\t\t\tif(j>0){\n\t\t\t\t\tdp[i+1][j-1] += dp[i][j]*j%MOD*j;\n\t\t\t\t\tdp[i+1][j-1]%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#define M 1000000007\nusing namespace std;\nvector<int> a;\nint l[200];\nint r[200];\nlong long dp[200][200];\n\nint main(){\n\tint n,i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tchar c;\n\t\tscanf(\" %c\",&c);\n\t\tif(c=='U')a.push_back(1);\n\t\tif(c=='D')a.push_back(0);\n\t}\n\tn=a.size();\n\tif(n==0){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tint s=0;\n\tfor(i=n-1;i>=0;i--){\n\t\tr[i]=s;\n\t\tif(a[i]==0)s++;\n\t}\n\ts=0;\n\tfor(i=0;i<n;i++){\n\t\tl[i]=s;\n\t\tif(a[i]==1)s++;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<s;j++){\n\t\t\tlong long res=0;\n\t\t\tlong long sum=1;\n\t\t\tfor(k=i-1;k>=0;k--){\n\t\t\t\tif(j>0)res=(res+dp[k][j-1]*sum)%M;\n\t\t\t\tsum=sum*(r[k]-((n-k-1)-(s-j)))%M;\n\t\t\t}\n\t\t\tif(j>0)dp[i][j]=res*(l[i]-j)%M;\n\t\t\telse dp[i][j]=sum*l[i]%M;\n\t\t}\n\t}\n\tlong long ans=0;\n\tlong long sum=1;\n\tfor(i=n-1;i>=0;i--){\n\t\tans=(ans+dp[i][s-1]*sum)%M;\n\t\tsum=sum*(r[i]-(n-i-1))%M;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b) : value(((a% b) + 2 * b) % b), mod(b) {\n\n    }\n    modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n#define int long long\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> inputs;\n    REP(i, n) {\n        string s;\n        cin >> s;\n        if (s == \"U\") {\n            inputs.push_back(0);\n        }\n        else if (s == \"D\") {\n            inputs.push_back(1);\n        }\n    }\n    vector<vector<modint>> dp(n + 2, vector<modint>(n + 2, modint(0, MAX_MOD)));\n    dp[0][0] = modint(1, MAX_MOD);\n    for (int i = 0; i < inputs.size(); ++i) {\n        for (int q = 0; q <= i; ++q) {\n            if (inputs[i] == 1) {\n                //down, required to connect.\n                dp[i + 1][q + 1] += dp[i][q] * modint(i - q, MAX_MOD);\n                dp[i + 1][q + 2] += dp[i][q] * modint(i - q, MAX_MOD) * modint(i - q, MAX_MOD);\n            }\n            else {\n\n                dp[i + 1][q] += dp[i][q];\n                dp[i + 1][q + 1] += dp[i][q] * modint(i - q, MAX_MOD);\n            }\n        }\n    }\n    cout << dp[inputs.size()][inputs.size()] << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=7+1e9;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b);\n\telse if(arrays[n]==-1) DP[n][a][b]=ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b));\n\telse return DP[n][a][b]=ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b));\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E) REPS(i, S, E)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, S, E) DEPS(i, S, E)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll Size(vector<T> &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 1000000007LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\n\n\nvoid solve()\n{\n\tll n;  cin >> n;\n\tvector<char> c = cinv<char>(n);\n\tdep(i, 0, n-1){\n\t\tif (c[i] == '-') c.erase(c.begin()+i);\n\t}\n\tn = Size(c);\n\tif (n==0) bye(1);\n\tif (n==1) bye(0);\n\tif (c[0]=='D') bye(0);\n\n\tll M = n/2+2;\n\tvvmll dp(n, vmll(M));\n\tauto Dp = [&](ll i, ll j)->mll&{\n\t\tstatic mll dmy = 0;\n\t\tif (j<0||M<=j) return dmy;\n\t\treturn dp[i][j];\n\t};\n\tDp(0, 1) = 1;\n\n\trep(i, 0, n-2)rep(j, 0, min(i+1,M-1)){\n\t\tll ii = i+1;\n\n\t\tif (c[ii]=='D'){\n\t\t\tDp(ii, j-1) += Dp(i, j)*j*j;\n\t\t\tDp(ii, j)   += Dp(i, j)*j;\n\t\t}\n\t\telse{\n\t\t\tDp(ii, j)   += Dp(i, j)*j;\n\t\t\tDp(ii, j+1) += Dp(i, j);\n\t\t}\n\t}\n\tmll ans = Dp(n-1, 0);\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n\nlong long MOD = 1000000007;\n\nint main()\n{\n  int n;\n  std::cin >> n;\n  std::vector<char> c(n + 1);\n  for (int i = 1; i <= n; ++i)\n    std::cin >> c[i];\n\n  // dp[i][j] = 割り当ての二部グラフにおいて\n  //            上から i 行までみて\n  //            左右ともに j 個保留している場合の総数\n\n  std::vector<std::vector<long long>> dp(n + 1);\n  for (int i = 0; i <= n; ++i)\n    dp[i].assign(n + 1, 0);\n\n  dp[0][0] = 1;\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j <= i; ++j) {\n      if (c[i + 1] == '-') {\n        (dp[i + 1][j] += dp[i][j]) %= MOD;\n      } else if (c[i + 1] == 'U') {\n        (dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n        (dp[i + 1][j] += dp[i][j] * j) %= MOD;\n      } else {\n        (dp[i + 1][j] += dp[i][j] * j) %= MOD;\n        if (j >= 1)\n          (dp[i + 1][j - 1] += dp[i][j] * j * j) %= MOD;\n      }\n    }\n  }\n\n  std::cout << dp[n][0] << std::endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n// #define DEBUG_IS_VALID\n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline void chmax(T& a,T const& b){a=max(a,b);}\ntemplate<class T> inline void chmin(T& a,T const& b){a=min(a,b);}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-12,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntemplate<typename T, int FAC_MAX> struct Comb { vector<T> fac, ifac;\n    Comb(){fac.resize(FAC_MAX,1);ifac.resize(FAC_MAX,1); for(int i = 1; i < FAC_MAX; i++)fac[i]=fac[i-1]*i;\n        ifac[FAC_MAX-1]=T(1)/fac[FAC_MAX-1];for(int i = FAC_MAX-2; i >= 1; i--)ifac[i]=ifac[i+1]*T(i+1);}\n    T aPb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b]; }\n    T aCb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b] * ifac[b]; }\n    T nHk(int n, int k) { if (n == 0 && k == 0) return T(1); if (n <= 0 || k < 0) return 0;\n        return aCb(n + k - 1, k); }}; // nHk = (n+k-1)Ck : n is separator\ntypedef ModInt<1000000007> mint;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int N; cin >> N ;\n  string s = \"\";\n  rep(i,N){\n    string ss; cin >> ss ;\n    s += ss;\n  }\n  vector<vector<mint>> dp(N+1,vector<mint>(N+1));\n  dp[0][0] = 1;\n  rep(i,N) rep(x,N){\n    if(s[i]=='U'){\n      dp[i+1][x+1] += dp[i][x];\n      dp[i+1][x] += mint(x) * dp[i][x];\n    }else if(s[i]=='D'){\n      if(x-1>=0) dp[i+1][x-1] += mint(x*x) * dp[i][x];\n      dp[i+1][x] += mint(x) * dp[i][x];\n    }else{\n      dp[i+1][x] = dp[i][x];\n    }\n  }\n  cout << dp[N][0] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// repetition\n#define FOR(i, a, b) for (ll i = (a); i < (b); ++i)\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n\n// container util\n#define all(x) (x).begin(), (x).end()\n\n// typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n// conversion\ninline int toInt(string s) {\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ninline ll toLL(string s) {\n  ll v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T> inline string toString(T x) {\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\n\nconst ll MOD = 1e9 + 7;\nll dp[201][201][201];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  char rank[n];\n  rep(i, n) { cin >> rank[i]; }\n  dp[0][0][0] = 1;\n\n  // dp[i番目までみる]['U'を使わないといけない数][前回までに保留されている'U'の数]\n  rep(i, n) {\n    rep(j, i + 1) {\n      rep(k, i + 1) {\n        if (rank[i] == 'U') {\n          // iの場所を保留して、以前の'U'を使う\n          (dp[i + 1][j][k] += dp[i][j][k] * j) %= MOD;\n          // iの場所は保留 & 以前の'U'を使わない\n          (dp[i + 1][j + 1][k + 1] += dp[i][j][k]) %= MOD;\n        } else if (rank[i] == 'D') {\n          // iの場所を保留して、以前の'U'で空けた順位を使う\n          if (k) {\n            (dp[i + 1][j][k] += dp[i][j][k] * k) %= MOD;\n            if (j) {\n              // iの場所を保留して、以前の'U'で空けた順位を使う\n              (dp[i + 1][j - 1][k - 1] += (dp[i][j][k] * j % MOD) * k) %= MOD;\n            }\n          }\n        } else {\n          (dp[i + 1][j][k] += dp[i][j][k]) %= MOD;\n        }\n      }\n    }\n  }\n  cout << dp[n][0][0] << \"\\n\";\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma warning(disable : 4996)\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#define __builtin_popcountll __popcnt64\n#endif\n\n#include <limits.h>\n#include <math.h>\n#include <time.h>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define REPR(i, n) for (int i = n - 1; i >= 0; --i)\n#define FOR(i, m, n) for (int i = m; i < n; ++i)\n#define FORR(i, m, n) for (int i = m - 1; i >= n; --i)\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v, n) reverse(v, v + n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define print(x) cout << (x) << '\\n'\n#define pe(x) cout << (x) << \" \"\n#define DEBUG(x) cout << #x << \": \" << x << endl\n#define lb(v, n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v, n) upper_bound(v.begin(), v.end(), (n))\n#define int long long\n#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i, v.size()) cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) {if (a > b) a = b;}\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) {if (a < b) a = b;}\nvoid fail() { cout << -1 << endl; exit(0); }\n\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr ll MOD = 998244353;\nconstexpr int MAX = 500050;\nconst double pi = acos(-1);\nconstexpr double EPS = 1e-8;\nconstexpr ll LINF = 1e18 + 1;\nconstexpr int INF = 1e9 + 1;\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\nstruct mint {\n\tll x; // typedef long long ll;\n\tmint(ll x = 0) :x((x%mod + mod) % mod) {}\n\tmint operator-() const { return mint(-x); }\n\tmint& operator+=(const mint a) {\n\t\tif ((x += a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint a) {\n\t\tif ((x += mod - a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint a) { (x *= a.x) %= mod; return *this; }\n\tmint operator+(const mint a) const { return mint(*this) += a; }\n\tmint operator-(const mint a) const { return mint(*this) -= a; }\n\tmint operator*(const mint a) const { return mint(*this) *= a; }\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime mod\n\tmint inv() const { return pow(mod - 2); }\n\tmint& operator/=(const mint a) { return *this *= a.inv(); }\n\tmint operator/(const mint a) const { return mint(*this) /= a; }\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x; }\nostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\n\n\nmint dp[201][201][201];//dp[i][j][k]=上からi番目まで見て、未確定のチームがjチーム、空位の順位がk個あるときの場合の数\nint type[201];\nvoid solve() {\n\tint N; cin >> N;\n\tvector<bool>up;\n\tREP(i, N) {\n\t\tchar c; cin >> c;\n\t\tif (c == 'U')up.push_back(1);\n\t\telse if (c == 'D')up.push_back(0);\n\t}\n\tdp[0][0][0] = 1;\n\tint n = up.size();\n\tREP(i,n) {\n\t\tREP(j, n) {\n\t\t\tREP(k, n) {\n\t\t\t\tif (up[i]) {\n\t\t\t\t\tdp[i + 1][j + 1][k + 1] += dp[i][j][k];//完全に放置\n\t\t\t\t\tdp[i + 1][j][k] += dp[i][j][k] * j;//未確定のチームを1つ選んでi位に入れる\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i + 1][j][k] += dp[i][j][k] * k;//空位から1つ選んでチームiを入れる\n\t\t\t\t\tif (j&&k)dp[i + 1][j - 1][k - 1] += dp[i][j][k] * j*k;//空位から1つ選んでチームiを入れ、未確定のチームを1つ選んでi位に入れる\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint(dp[n][0][0]);\n}\n\n\n\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tmt.seed((int)(time(0)));\n\t//int q;\n\t//cin >> q;\n\t//while (q--)\n\tsolve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n#define MOD 1000000007\n\ntypedef long long int ll;\n\nusing namespace std;\n\nlong long int dp[201][201];\n\nint main(){\n\n    long long int ans = 0;\n    char s[201];\n    int n;\n    memset(dp,0,sizeof(dp));\n    dp[0][0] = 1;\n    cin >> n;\n    for(int i=0;i<n;i++){\n\tcin >> s[i];\n    }\n\n    for(int i=0;i<n;i++){\n\tif(s[i] == '-'){\n\t    for(int j=0;j<=i;j++) dp[i+1][j] = dp[i][j];\n\t}else if(s[i] == 'D'){\n\t    for(int j=1;j<=i+1;j++){\n\t\tdp[i+1][j-1] = (dp[i+1][j-1] + dp[i][j] * j * j )% MOD;\n\t\tdp[i+1][j] = (dp[i+1][j] + dp[i][j] * j) % MOD;\n\t    }\n\t}else if(s[i] == 'U'){\n\t    for(int j=0;j<=i;j++){\n\t\tdp[i+1][j] = (dp[i+1][j] + dp[i][j] * j )% MOD;\n\t\tdp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % MOD;\n\t    }\n\t}\n    }\n    cout << dp[n][0] << endl;;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\nll dp[MAX_N][MAX_N];\n\nll add(ll x,ll y)\n{\n    return (x + y)%MOD;\n}\n\nll sub(ll x,ll y)\n{\n    return (x+MOD-y)%MOD;\n}\n\nll mul(ll x,ll y)\n{\n    return x*y%MOD;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<char> vec(n);\n    rep(i,n){\n        cin >> vec[i];\n    }\n    // svec(vec);\n    dp[0][0] = 1;\n    rep(i,n){\n        rep(j,i+1){\n            if(vec[i] == '-'){\n                dp[i+1][j] = add(dp[i+1][j],dp[i][j]);\n            }else if(vec[i] == 'D'){\n                dp[i+1][j] = add(dp[i+1][j],mul(j,dp[i][j]));\n                if(j != 0){\n                    dp[i+1][j-1] = add(dp[i+1][j-1],mul(j*j,dp[i][j]));\n                }\n            }else{\n                dp[i+1][j] = add(dp[i+1][j],mul(j,dp[i][j]));\n                dp[i+1][j+1] = add(dp[i+1][j+1],dp[i][j]);\n            }\n        }\n    }\n    // rep(i,n+1){\n    //     rep(j,i+1){\n    //         cout << i << \" \" << j << \" \" << dp[i][j] << \"\\n\";\n    //     }\n    // }\n    cout << dp[n][0] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\nusing mint = Fp<1000000007>;\nmint dp[210][210];\n\nint main() {\n    int N; cin >> N;\n    vector<char> v(N);\n    for (int i = 0; i < N; ++i) cin >> v[i];\n\n    dp[0][0] = 1;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j <= N; ++j) {\n            if (v[i] == '-') {\n                dp[i+1][j+1] += dp[i][j];\n            }\n            else if (v[i] == 'U') {\n                dp[i+1][j+1] += dp[i][j] * (i - j);\n                dp[i+1][j] += dp[i][j];\n            }\n            else {\n                dp[i+1][j+2] += dp[i][j] * (i - j) * (i - j);\n                dp[i+1][j+1] += dp[i][j] * (i - j);\n            }\n        }\n    }\n    cout << dp[N][N] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tstring s;\n\tint n; cin >> n;\n\twhile (n--) {\n\t\tchar c; cin >> c;\n\t\tif (c != '-') s.push_back(c);\n\t}\n\tn = s.length();\n\tint u = 0;\n\tvector<int> dp(n + 1);\n\tdp[0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == 'D')\n\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\tdp[j] = (ll)dp[j] * (u - j) % MOD;\n\t\tfor (int j = n - 1; j >= 0; j--)\n\t\t\tdp[j + 1] = dp[j + 1] + (ll)dp[j] * (u - j) % MOD;\n\t\tif (s[i] == 'U') u++;\n\t}\n\tcout << dp[u] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nstruct I{I(){ios::sync_with_stdio(false);cin.tie(0);}}init;\ntypedef long long LL;\ntypedef vector<LL> V;\nconst LL MOD=1e9+7;\nint main(){\n    int n;cin>>n;\n    V dp(n+1,0);\n    dp[0]=1;\n    for(int i=0;i<n;i++){\n        string s;cin>>s;\n        if(s==\"-\")continue;\n        V nxt(n+1,0);\n            for(int k=0;k<n;k++){\n                if(s==\"D\"){\n                    if(k==0)continue;\n                    (nxt[k]+=dp[k]*k%MOD)%=MOD;          \n                    (nxt[k-1]+=dp[k]*k*k%MOD)%=MOD;\n                }\n                else{\n                    (nxt[k+1]+=dp[k])%=MOD;\n                    if(k>0)(nxt[k]+=dp[k]*k%MOD)%=MOD;\n\n                }\n            }\n        swap(dp,nxt);\n    }\n    cout<<dp[0]<<endl;\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint dp[210][210][210];\n\nstring s[210];\n\nint M[210];\nint Dcnt,Ucnt;\nint D[210];\nint U[210];\nint n;\n\n// x: ??????\n// a: ???????????¨????????°\n// b: ?????£?????????U?????°\n\n\n// U\n\nint mod = 1000000007;\nint dfs(int x,int a,int b){\n\tif( x == n ){\n\t\treturn a == 0 && b == 0;\n\t}\n\tif( dp[x][a][b] != -1 ) return dp[x][a][b];\n\tif( s[x] == \"-\" ) return dfs(x+1,a,b);\n\tint ans = 0;\n\tif( s[x] == \"U\" ){\n\t\t//??????????????´???\n\t\tans += dfs(x+1,a+1,b+1);\n\t\tif(b) ans += dfs(x+1,a,b) * b;\n\t}else{\n\t\t// D????????£??? U???????????????\n\t\tif(a) ans += dfs(x+1,a,b) * a;\n\t\t//?????£?????????\n\t\tif(a&&b){\n\t\t\tans += dfs(x+1,a-1,b-1) * a * b;\n\t\t}\n\t}\n\tans %= mod;\n\treturn dp[x][a][b] = ans;\n}\n\n\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tcin >> n;\n\tint cnt = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tcin >> s[i];\n\t}\n\tcout << dfs(0,0,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define MOD 1000000007\nll dp[300][300];\nint n;\nchar c[300];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)cin >> c[i];\n\tdp[0][0]=1ll;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(c[i]=='-')for(int j=0;j<=n;j++)dp[i+1][j]=dp[i][j];\n\t\tif(c[i]=='D')\n\t\t{\n\t\t\tfor(int j=0;j<=i;j++)\n\t\t\t{\n\t\t\t\tif(j>0)dp[i+1][j-1] = (dp[i+1][j-1]+(((dp[i][j]*j)%MOD)*j%MOD))%MOD;\n\t\t\t\tdp[i+1][j] = (dp[i+1][j]+((dp[i][j]*j)%MOD))%MOD;\n\t\t\t}\n\t\t}\n\t\tif(c[i]=='U')\n\t\t{\n\t\t\tfor(int j=0;j<=i;j++)\n\t\t\t{\n\t\t\t\tdp[i+1][j+1] = (dp[i+1][j+1]+dp[i][j])%MOD;\n\t\t\t\tdp[i+1][j] = (dp[i+1][j]+((dp[i][j]*j)%MOD))%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long dp[1000][1000];\nint mod=1000000007;\nchar str[2];\nint val[1000];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tint n=0;\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s\",str);\n\t\tif(str[0]=='U')val[n++]=1;\n\t\tif(str[0]=='D')val[n++]=2;\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(val[i]==2){\n\t\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][j]*j)%mod;\n\t\t\t\tif(j)dp[i+1][j-1]=(dp[i+1][j-1]+dp[i][j]*j*j)%mod;\n\t\t\t}else{\n\t\t\t\tdp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%mod;\n\t\t\t\tif(j)dp[i+1][j]=(dp[i+1][j]+dp[i][j]*j)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  const int mod = 1000000007;\n\n  int n;\n  long long dp[201][201] = {{}};\n  char c[200];\n\n  cin >> n;\n  for(int i = 0; i < n; i++){\n    cin >> c[i];\n  }\n  dp[0][0] = 1;\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j <= i; j++){\n      if(c[i] == '-'){\n        dp[i + 1][j] = dp[i][j];\n      } else if(c[i] == 'U') {\n        (dp[i + 1][j] += dp[i][j] * j) %= mod;\n        (dp[i + 1][j + 1] += dp[i][j]) %= mod;\n      } else {\n        (dp[i + 1][j] += dp[i][j] * j) %= mod;\n        if(j) (dp[i + 1][j - 1] += dp[i][j] * j * j) %= mod;\n      }\n    }\n  }\n  cout << dp[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[202][202];\n\nint main(void){\n\n  fill(dp[0],dp[202],0);\n\n  int n;\n  cin >> n;\n\n  string c;\n\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  dp[0][0]=1;\n\n  for(int k=0;k<n;k++){\n    for(int i=0;i<=k;i++){\n      if(c[k]=='-')dp[k+1][i]+=dp[k][i];\n      else if(c[k]=='D'){\n        if(i>0){\n          dp[k+1][i-1]+=dp[k][i]*i*i;\n          dp[k+1][i-1]%=MOD;\n        }\n        dp[k+1][i]+=dp[k][i]*i;\n      }\n      else if(c[k]=='U'){\n        dp[k+1][i]+=dp[k][i]*i;\n        dp[k+1][i+1]+=dp[k][i];\n        dp[k+1][i+1]%=MOD;\n      }\n      dp[k+1][i]%=MOD;\n    }\n  }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 210\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nchar C[N];\n\nint mem[N][N][N],used[N][N][N];\nint dfs(int idx,int num,int num2){\n  if(num < 0 || num2 < 0) return 0;\n  if(idx == n) return (idx-num == 0) * (num2 == 0);\n  if(used[idx][num][num2]++) return mem[idx][num][num2];\n  int res = 0; \n  if(C[idx] == 'U'){\n    res = dfs(idx+1,num,num2+1);\n    res += num2 * dfs(idx+1,num+1,num2);\n  }\n  if(C[idx] == 'D'){\n    if(idx - num > 0 )res = (idx - num) * num2 * dfs(idx+1,num+2,num2-1);\n    res += (idx - num) * dfs(idx+1,num+1,num2);\n  }\n  return mem[idx][num][num2] = res %mod;\n}\n\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>C[i];\n    if(C[i] == '-')n--,i--;\n  }\n  cout<<dfs(0,0,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=7+1e9;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b)%p;\n\telse if(arrays[n]==-1) DP[n][a][b]=ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n\telse return DP[n][a][b]=ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nconst int MOD = 1000000007;\nll dp[210][210];\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    string s = \"\";\n    rep(i, n){\n        char c; cin >> c;\n        if(c == '-') continue;\n        s += c;\n    }\n    n = s.size();\n    memset(dp, 0, sizeof(dp));\n    if(s[0] == 'D') goto fail;\n    dp[0][1] = 1;\n    REP(i, 1, n){\n        rep(j, i + 2){\n            if(s[i] == 'D'){\n                dp[i][j] += (dp[i - 1][j] * j) % MOD;\n                dp[i][j] += (dp[i - 1][j + 1] * (j + 1) * (j + 1)) % MOD;\n            }else{\n                dp[i][j] += dp[i - 1][j - 1];\n                dp[i][j] += (dp[i - 1][j] * j) % MOD;\n            }\n            dp[i][j] %= MOD;\n        }\n    }\n    printf(\"%d\\n\", dp[n - 1][0]);\n    return 0;\n  fail:\n    puts(\"0\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=1000000007;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b);\n\telse if(arrays[n]==-1) DP[n][a][b]=(ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b)));\n\telse return DP[n][a][b]=(ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p);\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nint i, j, n, dp[202][202], mod = 1e9+7;\nchar c[202];\n\nsigned main() {\n\tcin >> n;\n\tfor(i=0; i<n; i++) {\n\t\tcin >> c[i];\n\t\tif (c[i]=='-') i--, n--;\n\t}\n\tdp[0][0] = 1;\n\tfor(i=0; i<n; i++) for(j=0; j<n; j++) {\n\t\tif (c[i]=='D') {\n\t\t\tif (j) (dp[i+1][j-1] += dp[i][j]*j %mod *j) %= mod;\n\t\t\t(dp[i+1][j] += dp[i][j]*j) %= mod;\n\t\t}\n\t\telse {\n\t\t\t(dp[i+1][j] += dp[i][j]*j) %= mod;\n\t\t\t(dp[i+1][j+1] += dp[i][j]) %= mod;\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\n\nint main()\n{\n    int n;\n    char c[222];\n    cin >> n;\n    input(c, n);\n\n    // dp[i + 1][j] (iまでみた, iまでで、空いている順位の数(== まだ決定してないチームの数))\n    ll dp[222][222] = {};\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0; j <= i; ++j)\n        {\n            if (c[i] == 'U')\n            {\n                // ↑\n                (dp[i + 1][j] += dp[i][j] * j) %= mod;\n                // ↓\n                (dp[i + 1][j + 1] += dp[i][j]) %= mod;\n            }\n            else if (c[i] == 'D')\n            {\n                // ↑\n                if (j >= 1)\n                    (dp[i + 1][j - 1] += dp[i][j] * j * j) %= mod;\n                // ↓\n                (dp[i + 1][j] += dp[i][j] * j) %= mod;\n            }\n            else\n                dp[i + 1][j] = dp[i][j];\n        }\n    }\n    cout << dp[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nll dp[225][225];\n\nint main(void){\n\tint n,i,j;\n\tchar c;\n\tcin >> n;\n\tdp[0][0] = 1ll;\n\tfor(i=0; i<n; ++i){\n\t\tcin >> c;\n\t\tfor(j=0; j<=n; ++j){\n\t\t\tif(c=='U'){\n\t\t\t\tadd_mod(dp[i+1][j],dp[i][j]*j%MOD);\n\t\t\t\tif(j<n){\n\t\t\t\t\tadd_mod(dp[i+1][j+1],dp[i][j]);\n\t\t\t\t}\n\t\t\t}else if(c=='D'){\n\t\t\t\tadd_mod(dp[i+1][j],dp[i][j]*(j)%MOD);\n\t\t\t\tif(j>0){\n\t\t\t\t\tadd_mod(dp[i+1][j-1],(dp[i][j]*(j)%MOD)*(j)%MOD);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[i+1][j] = dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 1000000007;\n\nint main(){\n\tint n;\n\tchar c[202];\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"\\n%c\",&c[i]);\n\t}\n\t\n\tvector<int> U,D;\n\trep(i,n){\n\t\tif(c[i] == 'U')U.pb(i);\n\t\tif(c[i] == 'D')D.pb(i);\n\t}\n\tsor(U);\n\tsor(D);\n\t\n\tll dp[2][202];\n\tint t = 0 , t_ = 1;\n\trep(i,202)dp[0][i] = 0;\n\tdp[0][0] = 1;\n\tint cnt = 0;\n\trep(i,n){\n\t\tif(c[i] == '-'){ cnt ++; continue; }\n\t\trep(j,U.size()+1){\n\t\t\tdp[t_][j] = 0;\n\t\t\tif(j > 0)dp[t_][j] += dp[t][j-1]*max(0LL,(ll)(lb(U,i)-U.begin())-j+1);\n\t\t\tdp[t_][j] += dp[t][j]*max(0LL,(ll)(D.begin()-ub(D,i))+i-cnt-j+1);\n\t\t\tdp[t_][j] %= M;\n\t\t}\n\t\tswap(t,t_);\n\t}\n\t\n\tcout << dp[t][U.size()] << endl;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\ninline void add(int &x, int v) { x += v; if (x >= MOD) x -= MOD; }\n\nint N;\nstring S;\nint dp[201][201];\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) {\n    char c;\n    cin >> c;\n    if (c != '-') S += c;\n  }\n  N = S.length();\n\n  dp[0][0] = 1;\n  rep(i, N) {\n    if (S[i] == 'U') {\n      rep(j, N) add(dp[i+1][j+1], dp[i][j]);\n      rep(j, N) add(dp[i+1][j], (1LL*j*dp[i][j])%MOD);\n    }\n    else {\n      rep(j, N) if (j) add(dp[i+1][j-1], (1LL*j*j*dp[i][j])%MOD);\n      rep(j, N) add(dp[i+1][j], (1LL*j*dp[i][j])%MOD);\n    }\n  }\n  cout << dp[N][0] << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\nusing Graph = vector<vector<int> >;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//#define int long long\n\n//順列をマッチングとみる\n//dp[i][j] = (1,.,i)と(1,..,i)同士のみを考えてときj箇所でマッチングしているような場合の数\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<char> c(n);\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tll dp[220][220];\n\trep(i, n + 1) {\n\t\trep(j, n + 1) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\tdp[0][0] = 1LL;\n\trep(i, n) {\n\t\trep(j, i + 1) {\n\t\t\tif(c[i] == '-') {\n\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t} else if(c[i] == 'U') {\n\t\t\t\t(dp[i + 1][j + 1] += dp[i][j] * (i - j) ) %= mod;\n\t\t\t\t(dp[i + 1][j] += dp[i][j]) %= mod;\n\t\t\t} else if(c[i] == 'D') {\n\t\t\t\t(dp[i + 1][j + 2] += dp[i][j] * (i - j) * (i - j)) %= mod;\n\t\t\t\t(dp[i + 1][j + 1] += dp[i][j] * (i - j)) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[n][n] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//cout << \"finish\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1<<18,INF=1<<30;\n\nint main(){\n\n    int N;cin>>N;\n    vector<char> S(N);\n    for(int i=0;i<N;i++) cin>>S[i];\n    \n    ll dp[N+1][N+1];\n    memset(dp,0,sizeof(dp));\n    \n    dp[0][0]=1;\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<=i;j++){\n            if(S[i]=='-'){\n                dp[i+1][j+1]+=dp[i][j];\n                dp[i+1][j+1]%=mod;\n            }else if(S[i]=='U'){\n                dp[i+1][j+1]+=dp[i][j]*(i-j);\n                dp[i+1][j]+=dp[i][j];\n                \n                dp[i+1][j+1]%=mod;\n                dp[i+1][j]%=mod;\n            }else if(S[i]=='D'){\n                dp[i+1][j+2]+=dp[i][j]*(i-j)*(i-j);\n                dp[i+1][j+1]+=dp[i][j]*(i-j);\n                \n                dp[i+1][j+2]%=mod;\n                dp[i+1][j+1]%=mod;\n            }\n        }\n    }\n    \n    cout<<dp[N][N]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(int i = (a); i > (b); --i)\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) __builtin_clzll(x)\n#define SZ(x) ((long long)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n#define cinfast() cin.tie(0), ios::sync_with_stdio(false)\n#define PERM(c)                                                                \\\n    sort(All(c));                                                              \\\n    for(bool cp = true; cp; cp = next_permutation(All(c)))\n#define MKORDER(n)                                                             \\\n    vector<int> od(n);                                                         \\\n    iota(All(od), 0LL);\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    long long __VA_ARGS__;                                                     \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\nconst double PI = atan(1.0) * 4.0;\nconst ll dw[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dh[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.141592653589793238\n\n// 1000000007 で割ったあまりを扱う構造体\ntemplate <int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if(val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator-() const noexcept { return val ? MOD - val : 0; }\n    constexpr Fp operator+(const Fp &r) const noexcept {\n        return Fp(*this) += r;\n    }\n    constexpr Fp operator-(const Fp &r) const noexcept {\n        return Fp(*this) -= r;\n    }\n    constexpr Fp operator*(const Fp &r) const noexcept {\n        return Fp(*this) *= r;\n    }\n    constexpr Fp operator/(const Fp &r) const noexcept {\n        return Fp(*this) /= r;\n    }\n    constexpr Fp &operator+=(const Fp &r) noexcept {\n        val += r.val;\n        if(val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp &operator-=(const Fp &r) noexcept {\n        val -= r.val;\n        if(val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp &operator*=(const Fp &r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp &operator/=(const Fp &r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while(b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        val = val * u % MOD;\n        if(val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator==(const Fp &r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator!=(const Fp &r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream &operator<<(ostream &os, const Fp<MOD> &x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream &operator>>(istream &is, Fp<MOD> &x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if(n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if(n & 1) t = t * a;\n        return t;\n    }\n};\n\nusing mint = Fp<MOD>;\n\nmint dp[2][202];\n\nsigned main() {\n    cinfast();\n    LCIN(N);\n    ll now = 0, next = 1;\n    dp[now][0] = 1;\n    REP(i, N) {\n        CCIN(c);\n        Fill(dp[next], 0);\n        if(c == '-')\n            continue;\n        else if(c == 'D') {\n            REP(j, i + 2) {\n                //注目ボールを保留箱にわりあてる\n                dp[next][j] += dp[now][j] * j;\n                //注目箱に保留ボールを割り当て、かつ注目ボールを保留箱にわりあてる。\n                dp[next][j] += dp[now][j + 1] * (j + 1) * (j + 1);\n            }\n        } else {\n            REP(j, i + 2) {\n                //保留\n                if(j) dp[next][j] += dp[now][j - 1];\n                //注目箱に保留ボールを入れる\n                dp[next][j] += dp[now][j] * j;\n            }\n        }\n        swap(now, next);\n    }\n    cout << dp[now][0] << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    string c(n, ' ');\n    for(int i=0; i<n; ++i)\n        cin >> c[i];\n\n    vector<vector<long long> > dp(n+1, vector<long long>(n+1, 0));\n    dp[0][0] = 1;\n    for(int i=0; i<n; ++i){\n        if(c[i] == 'D'){\n            for(int j=1; j<n; ++j){\n                dp[i+1][j] += dp[i][j] * j;\n                dp[i+1][j] %= MOD;\n                dp[i+1][j-1] += dp[i][j] * j * j;\n                dp[i+1][j-1] %= MOD;\n            }\n        }else if(c[i] == 'U'){\n            for(int j=0; j<n; ++j){\n                dp[i+1][j+1] += dp[i][j];\n                dp[i+1][j+1] %= MOD;\n                dp[i+1][j] += dp[i][j] * j;\n                dp[i+1][j] %= MOD;\n            }\n        }else{\n            for(int j=0; j<n; ++j)\n                dp[i+1][j] = dp[i][j];\n        }\n    }\n\n    cout << dp[n][0] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-12;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n//AGCばちゃ 1700~\n/*\n010\n101\n010\n*/\nint main(void){\n\tcout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\tllint i,j,n;cin>>n;\n\tvector<llint>dp(n+1);dp[0]=1;\n\tfor(i=0;i<n;i++){\n\t\tchar c;cin>>c;\n\t\tif(c=='-'){continue;}\n\t\tif(c=='D'){\n\t\t\tfor(j=0;j<n;j++){dp[j]=(dp[j]*j+dp[j+1]*(j+1)*(j+1))%mod;}dp[n]=0;\n\t\t}else{\n\t\t\tfor(j=n;j>0;j--){dp[j]=(dp[j]*j+dp[j-1])%mod;}dp[0]=0;\n\t\t}\n\t\t//for(j=0;j<=n;j++){cerr<<dp[j]<<\" \";}cerr<<endl;\n\t}\n\tcout<<dp[0]<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,s,e) for(int i=(s); i<(e);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n)\n#define repe(i,n) for(auto &&i:n)\n#define all(v) (v).begin(),(v).end()\n#define decimal fixed<<setprecision(20)\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\nusing namespace std;\nusing LL = long long;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst int INF = 1e9;\nconst LL LLINF = 1e16;\n\ntemplate<int mod>\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n    ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const{\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int e){\n        long long a = 1, p = x;\n        while(e > 0) {\n            if(e%2 == 0) {p = (p*p) % mod; e /= 2;}\n            else {a = (a*p) % mod; e--;}\n        }\n        return ModInt(a);\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt<mod> &p) {\n        return os << p.x;\n    }\n    friend istream &operator>>(istream &is, ModInt<mod> &a) {\n        long long x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return (is);\n    }\n};\n\nconst int mod = 1e9 + 7;\nusing modint = ModInt<mod>;\n\n// i番目まで見て、左j個、右k個が未確定\nmodint dp[222][222][222];\n\nint main(){\n    fastcin();\n\n    int n;\n    cin >> n;\n    vector<char> c(n);\n    rep(i, n) cin >> c[i];\n    dp[0][0][0] = 1;\n    rep(i, n)rep(j, n)rep(k, n){\n        if(c[i] == '-'){\n            dp[i+1][j][k] += dp[i][j][k];\n        }else if(c[i] == 'D'){\n            // i+1番目について、右側は必ず残っている左側j個から選ぶ j通り j -> j-1\n\n            // 左側の行き先を決める 残っている左側k通り k -> k-1\n            if(j>0 && k>0) dp[i+1][j-1][k-1] += dp[i][j][k]*j*k;\n            // 左側の行き先を決めない k -> k で、左の未確定+1 (j -> j)\n            dp[i+1][j][k] += dp[i][j][k]*j;\n        }else{\n            // i+1番目について、右側は未確定にしておくしかない k -> k+1\n\n            // 左側の行き先を決める k通り 決めると一つ減るので k -> k\n            dp[i+1][j][k] += dp[i][j][k]*k;\n            // 左側の行き先を決めない 左の未確定+1 (j -> j+1)\n            dp[i+1][j+1][k+1] += dp[i][j][k];\n        }\n    }\n    cout << dp[n][0][0] << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tll dp[2][220] = {};\n\tll *dp0 = dp[0]+1, *dp1 = dp[1]+1;\n\tdp1[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tchar c; cin >> c;\n        if (c == '-') continue;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tif (c == 'U') {\n\t\t\t\tdp0[j] = j*dp1[j];\n\t\t\t\tdp0[j] += dp1[j-1];\n\t\t\t} else {\n\t\t\t\tdp0[j] = (j+1)*(j+1)*dp1[j+1] + j*dp1[j];\n\t\t\t}\n\t\t\tdp0[j] %= (ll)(1e9+7);\n\t\t}\n\t\tswap(dp0, dp1);\n\t}\n\tcout << dp1[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = double;\nusing ldb = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\nusing pdi = pair<double, int>;\nusing pdd = pair<double, double>;\ntemplate <class T> using vct = vector<T>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)1024;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double Pi = 3.1415926535897932384626433832795028841971;\nconstexpr long double Golden = 1.61803398874989484820;\nconstexpr long double eps = 1e-15;\n\n#define iostream_untie true\n#define mod 1000000007LL\n#define stdout_precision 10\n#define stderr_precision 6\n#define itrep(i,v) for(auto i = begin(v); i != end(v); ++i)\n#define ritrep(i,v) for(auto i = rbegin(v); i != rend(v); ++i)\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nnamespace setup {\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                std::cout.tie(nullptr);\n                std::cerr.tie(nullptr);\n            }\n            std::cout << fixed << setprecision(stdout_precision);\n            std::cerr << fixed << setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(\"input.txt\",\"rt\",stdin)) {\n                cerr << \"Failed to open the input file.\\n\"; exit(EXIT_FAILURE);\n            }\n            // if(!freopen(\"output.txt\",\"wt\",stdout)) {\n            //     cerr << \"Failed to open the output file.\\n\"; exit(EXIT_FAILURE);\n            // }\n            // std::cerr << \"\\n---stderr---\\n\";\n            // auto print_atexit = []() {\n            //     std::cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\";\n            //     std::cerr << \"------------\\n\";\n            // };\n            // atexit((void(*)())print_atexit);\n            // atexit((void(*)())fclose(stdin));\n    #endif\n        }\n    } __setupper;\n}\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) s << (i ? \" \" : \"\") << v[i]; return s;\n}\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T = i64> T read() { T x; return cin >> x, x; }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\n\nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T> static bool chmax(T &x, const T &y) { return x < y ? x = y,true : false; }\n    template <class T> static bool chmin(T &x, const T &y) { return x > y ? x = y,true : false; }\n};\nusing updater::add;\nusing updater::chmax;\nusing updater::chmin;\n\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool bit(i64 n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\ntemplate <class F> int_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(T i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\ntemplate <class F> void for_subset(uint_fast64_t s, const F &fn) {\n    uint_fast64_t tmp = s;\n    do { fn(tmp); } while((--tmp &= s) != s);\n}\n\n\n/* The main code follows. */\n\nint n;\nstring str;\ni64 dp[210][210][210];\n\nsigned main() {\n    cin>>n;\n    for(int i=1; i<=n; ++i) {\n        char c; cin>>c; \n        if(c!='-') {\n            str+=c;\n        }\n    }\n    n=str.size();\n    dp[0][0][0]=1;\n    int down=0;\n    int up=0;\n    for(int i=0; i<n; ++i) {\n        auto now=dp[i];\n        auto nxt=dp[i+1];\n        for(int k=0; k<=up; ++k) {\n            for(int l=0; l<=down; ++l) {\n                if(!now[k][l]) continue;\n                if(str[i]=='U') {\n                    (nxt[k+1][l]+=now[k][l])%=mod;\n                    (nxt[k+1][l]+=now[k][l]*(up-k))%=mod;\n                    (nxt[k][l]+=now[k][l]*k%mod)%=mod;\n                    (nxt[k+1][l]+=now[k][l]*l)%=mod;\n                    (nxt[k+1][l+1]+=now[k][l]*(down-l)%mod)%=mod;\n                } else {\n                    (nxt[k][l+1]+=now[k][l])%=mod;\n                    if(k) (nxt[k-1][l]+=now[k][l]*k%mod)%=mod;\n                    (nxt[k][l]+=now[k][l]*(up-k)%mod)%=mod;\n                    (nxt[k][l+1]+=now[k][l]*(down-l)%mod)%=mod;\n                    (nxt[k][l]+=now[k][l]*l%mod)%=mod;\n                }\n            }\n        }\n        if(str[i]=='U') {\n            up++;\n        } else {\n            down++;\n        }\n    }\n    esc(dp[n][0][0]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <limits>\n#include <iterator>\n#include <functional>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\nusing ll = long long;\nusing ull = uint64_t;\nusing P = pair<int, int>;\nconstexpr double EPS = 1e-9;\nconstexpr int INF = 1001001001;\nconstexpr int mod = 1000000007;\n// constexpr int mod = 998244353;\n\ntemplate<class T>\ninline bool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate<int mod>\nstruct ModInt{\n    int x;\n\n    ModInt() : x(0) {}\n    \n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    \n    ModInt &operator+=(const ModInt &p){\n        if((x += p.x) >= mod)   x -= mod;\n        return *this;\n    }\n    \n    ModInt &operator-=(const ModInt &p){\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &p){\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt &operator/=(const ModInt &p){\n        *this *= p.inverse();\n        return *this;\n    }\n    \n    ModInt operator-() const {return ModInt(-x);}\n\n    ModInt operator+(const ModInt &p) const {return ModInt(*this) += p;}\n\n    ModInt operator-(const ModInt &p) const {return ModInt(*this) -= p;}\n\n    ModInt operator*(const ModInt &p) const {return ModInt(*this) *= p;}\n\n    ModInt operator/(const ModInt &p) const {return ModInt(*this) /= p;}\n\n    bool operator==(const ModInt &p) const {return x == p.x;}\n\n    bool operator!=(const ModInt &p) const {return x != p.x;}\n\n    ModInt inverse() const{\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0){\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const{\n        ModInt ret(1), mul(x);\n        while(n > 0){\n            if(n & 1)   ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p){\n        return os << p.x;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a){\n        int64_t t;\n        is >> t;\n        a = ModInt<mod>(t);\n        return (is);\n    }\n\n    static int get_mod() {return mod;}\n};\n\nusing modint = ModInt<mod>;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n    // dp[i][j] := i 人目まで見たときに j 人保留している場合の数\n    vector<vector<modint>> dp(n + 1, vector<modint>(n + 1));\n    dp[0][0] = 1;\n    for(int i = 0; i < n; ++i){\n        char c;\n        cin >> c;\n        if(c == 'U'){\n            for(int j = 0; j <= i; ++j){\n                if(dp[i][j] == 0)   continue;\n                dp[i + 1][j + 1] += dp[i][j];\n                dp[i + 1][j] += dp[i][j] * j;\n            }\n        }\n        else if(c == 'D'){\n            for(int j = 0; j <= i; ++j){\n                if(dp[i][j] == 0)   continue;\n                dp[i + 1][j] += dp[i][j] * j;\n                if(j > 0)   dp[i + 1][j - 1] += dp[i][j] * j * j;\n            }\n        }\n        else{\n            for(int j = 0; j <= i; ++j){\n                dp[i + 1][j] += dp[i][j];\n            }\n        }\n    }\n    cout << dp[n][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    unsigned long n;\n    cin >> n;\n    vector<unsigned long> dp{1};\n    for(unsigned long i = 0; i < n; ++i){\n        char c;\n        cin >> c;\n        if(c == 'U'){\n            dp.push_back(dp.back());\n            for(unsigned long i = dp.size() - 2; i > 0; --i)dp[i] = dp[i] * i + dp[i - 1];\n            dp[0] = 0;\n        }else if(c == 'D'){\n            for(unsigned long i = 0; i < dp.size(); ++i)dp[i] = dp[i + 1] * (i + 1) * (i + 1) + dp[i] * i;\n        }else continue;\n        for(auto& i : dp)i %= 1000000007;\n    }\n    cout << dp[0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\nconst int mod = 1000000007;\nll dp[11][1<<11];\n\nint main() {\n    int n;\n    string in;\n    dp[0][0] = 1;\n    cin>>n;\n    for (int i=0; i<n; ++i) {\n        cin>>in;\n        if (in == \"-\") {\n            for (int S=0; S<(1<<n); ++S) {\n                if ((1<<i)&S) continue;\n                dp[i+1][(1<<i)|S] += dp[i][S];\n                dp[i+1][(1<<i)|S] %= mod;\n            }\n        } else if (in == \"D\") {\n            for (int S=0; S<(1<<n); ++S) {\n                for (int k=0; k<i; ++k) {\n                    if ((1<<k)&S) continue;\n                    dp[i+1][(1<<k)|S] += dp[i][S];\n                    dp[i+1][(1<<k)|S] %= mod;\n                }\n            }\n        } else if (in == \"U\") {\n            for (int S=0; S<(1<<n); ++S) {\n                for (int k=i+1; k<n; ++k) {\n                    if ((1<<k)&S) continue;\n                    dp[i+1][(1<<k)|S] += dp[i][S];\n                    dp[i+1][(1<<k)|S] %= mod;\n                }\n            }\n        }\n    }\n\n    cout<<dp[n][(1<<n)-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=1000000007;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b)%p;\n\telse if(arrays[n]==-1) DP[n][a][b]=(((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b)))%p;\n\telse return DP[n][a][b]=(ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p);\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n////////////\n// ModInt //\n////////////\n\n// 四則演算の最も左に存在する値がModIntでなければキャストでバグる\n// 例えばx = mint * 1000;やx = ModInt(1000) * mint;はいいがx = 1000 * mint;は駄目。\ntemplate<int64_t mod_ = 1'000'000'007>\nclass ModInt {\nprivate:\n\tint64_t integer_;\n\npublic:\n\tconstexpr ModInt(const int64_t initial_number = 0)\n\t\t: integer_(initial_number){}\n\t\n\t// 四則演算\n\tconstexpr ModInt operator+(const ModInt& operand) const\n\t{\n\t\tModInt ret{this->integer_ + operand.integer_};\n\t\tif (ret.integer_ >= mod_)\n\t\t\tret.integer_ -= mod_;\n\t\treturn ret;\n\t}\n\tconstexpr ModInt operator-(const ModInt& operand) const\n\t{\n\t\tModInt ret{this->integer_ - operand.integer_};\n\t\tif (ret.integer_ < 0)\n\t\t\tret.integer_ += mod_;\n\t\treturn ret;\n\t}\n\tconstexpr ModInt operator*(const ModInt& operand) const\n\t{\n\t\treturn {this->integer_ * operand.integer_ % mod_};\n\t}\n\tconstexpr ModInt operator/(const ModInt& operand) const\n\t{\n\t\treturn *this * (operand ^ (mod_ - 2));\n\t}\n\n\t// 累乗\n\tconstexpr ModInt operator^(const int64_t operand) const\n\t{\n\t\tModInt ret{1}, pow_ope{this->integer_};\n\t\tfor (int64_t pow{operand}; pow > 0; pow >>= 1)\n\t\t{\n\t\t\tif (pow & 1) ret *= pow_ope;\n\t\t\tpow_ope *= pow_ope;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// 代入\n\tconstexpr ModInt& operator=(const ModInt& operand)\n\t{\n\t\tthis->integer_ = operand.integer_;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator+=(const ModInt& operand)\n\t{\n\t\t*this = *this + operand;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator-=(const ModInt& operand)\n\t{\n\t\t*this = *this - operand;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator*=(const ModInt& operand)\n\t{\n\t\t*this = *this * operand;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator/=(const ModInt& operand)\n\t{\n\t\t*this = *this / operand;\n\t\treturn *this;\n\t}\n\n\t// その他\n\tconstexpr operator int64_t() { return integer_; }\n\n\tconstexpr ModInt getOne() const\n\t{\n\t\treturn ModInt(1ll);\n\t}\n\tconstexpr ModInt getZero() const\n\t{\n\t\treturn ModInt(0ll);\n\t}\n};\nusing Mint = ModInt<>;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tstd::vector<char> change;\n\tfor (int i{}; i < n; i++)\n\t{\n\t\tchar tmp;\n\t\tscanf(\" %c\", &tmp);\n\t\tif (tmp != '-') change.push_back(tmp);\n\t}\n\tn = (int)change.size();\n\tusing vi = std::vector<Mint>;\n\tusing vvi = std::vector<vi>;\n\tvvi dp(n + 1, vi(n + 1));\n\tdp[0][0] = Mint(1ll);\n\tfor (int i{}; i < n; i++)\n\t{\n\t\tif (change[i] == 'D')\n\t\t{\n\t\t\t// 使う使う\n\t\t\tfor (int unused{1}; unused <= n; unused++)\n\t\t\t\tdp[i + 1][unused - 1] += Mint(unused) * Mint(unused) * dp[i][unused];\n\t\t\t// 使う保留\n\t\t\tfor (int unused{1}; unused <= n; unused++)\n\t\t\t\tdp[i + 1][unused] += Mint(unused) * dp[i][unused];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 保留使う\n\t\t\tfor (int unused{1}; unused <= n; unused++)\n\t\t\t\tdp[i + 1][unused] += Mint(unused) * dp[i][unused];\n\t\t\t// 保留保留\n\t\t\tfor (int unused{}; unused < n; unused++)\n\t\t\t\tdp[i + 1][unused + 1] += dp[i][unused];\n\t\t}\n\t}\n\tstd::cout << dp[n][0] << std::endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REPR(i,n) for (int i=(int)(n)-1;i>=0;--i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>basic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>&os,\nconst C& c){os<<'[';for(auto i=begin(c);i!=end(c);++i)os<<(i==begin(c)?\"\":\" \")<<*i;return os<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)cout<<a[i]<<(i!=n-1?',':'\\n');}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\ntemplate<class T>bool inputs(T *a, int n) { REP(i,n) if(!input(a[i])) return 0; return 1;}\n\ntemplate<int MOD>\nstruct ModInt {\n  int x;\n  constexpr ModInt() : x(0) {}\n  ModInt(ll s) { if ((x = s % MOD) < 0) x += MOD; }\n  ModInt operator+=(ModInt rhs) { if ((x+=rhs.x) >= MOD) x -= MOD; return *this; }\n  ModInt operator-=(ModInt rhs) { if ((x-=rhs.x) < 0) x += MOD; return *this; }\n  ModInt operator*=(ModInt rhs) { x = (ll)x*rhs.x % MOD; return *this; }\n  ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n  ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n  ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n  ModInt operator/=(ModInt rhs) {\n    static const ll inv2 = ModInt(2).inv().x; // 2で割るのは特別に保存してみる\n    ll i = (rhs.x == 2 ? inv2 : rhs.inv().x);\n    x = x*i%MOD; return *this;\n  }\n  ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n  ModInt inv() { return pow(MOD-2); }\n  ModInt pow(ll n) const {\n    ModInt r = 1, t = x;\n    for (;n;n>>=1,t*=t) if (n&1) r *= t;\n    return r;\n  }\n  static ModInt strnum(const string &n) {ModInt a = 0; for (char c:n) a = a*10+c-'0'; return a;}\n  friend ostream& operator<<(ostream &os, const ModInt rhs){ return os << rhs.x; }\n};\ntypedef ModInt<int(1e9+7)> mint;\n\nmint dp[300][300];\n\nchar c[300];\n\nint main() {\n  int n;\n  while(cin >> n) {\n    REP(i,n) cin >> c[i];\n    memset(dp,0,sizeof(dp));\n    dp[0][0] = 1;\n    REP(i,n) {\n      REP(j,n) {\n        auto ch = c[i];\n        if (ch == 'U') {\n          dp[i+1][j+1] += dp[i][j];\n          dp[i+1][j] += dp[i][j] * j;\n        } else if (ch == 'D') {\n          dp[i+1][j] += dp[i][j] * j;\n          if (j)\n            dp[i+1][j-1] += dp[i][j] * j * j;\n        } else {\n          dp[i+1][j] += dp[i][j];\n        }\n      }\n    }\n    cout << dp[n][0] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n; cin >> n;\n  vector<char> v;\n  for(int i=0;i<n;++i) {\n    char tmp; cin >> tmp;\n    if(tmp != '-') {\n      v.push_back(tmp);\n    }\n  }\n  n = (int)(v.size());\n  vector<vvll> dp(n+1, vvll(n+1, vll(n+1, 0)));\n  dp[0][0][0] = 1;\n  for(int i=0;i<n;++i) {\n    for(int j=0;j<n;++j) {\n      for(int k=0;k<n;++k) {\n        if(v[i] == 'D') {\n          if(j && k) {\n            dp[i+1][j-1][k-1] += dp[i][j][k] * j * k;\n            dp[i+1][j-1][k-1] %= MOD;\n          }\n          dp[i+1][j][k] += dp[i][j][k] * j;\n          dp[i+1][j][k] %= MOD;\n        } else {\n          dp[i+1][j][k] += dp[i][j][k] * k;\n          dp[i+1][j][k] %= MOD;\n          dp[i+1][j+1][k+1] += dp[i][j][k];\n          dp[i+1][j+1][k+1] %= MOD;\n        }\n      }\n    }\n  }\n  cout << dp[n][0][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\n\nint N;\nchar c[202];\n\nll dp[202][202];\n\nvoid add(ll &a,ll b){\n    a=(a+b)%MOD;\n}\n\nint main(){\n  cin>>N;\n  rep(i,N) cin>>c[i];\n\n  dp[0][0]=1;\n  for(int i=0;i<N;i++){\n      for(int j=0;j<=i;j++){\n          if(c[i]=='-') add(dp[i+1][j],dp[i][j]);\n          else if(c[i]=='D'){\n              add(dp[i+1][j],dp[i][j]*j);\n              if(j>=1) add(dp[i+1][j-1],dp[i][j]*j*j);\n          }else{\n              add(dp[i+1][j+1],dp[i][j]);\n              if(j>=1) add(dp[i+1][j],dp[i][j]*j);\n          }\n      }\n  }\n\n  cout<<dp[N][0]<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n#define mod 1000000007\n\nint n;\nll dp[205][205];\nll inv[205];\nstring s[205];\n\nlong long modpow(long long x,long long n){\n\tlong long res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nint main() {\n  cin >> n;\n  for(int i=1;i<=n;i++) cin >> s[i];\n  dp[0][0]=1;\n  for(int i=1;i<=200;i++) inv[i]=modpow(1ll*i,mod-2ll);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=n;j++){\n      if(!dp[i][j]) continue;\n      //cout << dp[i][j] <<\" \" << i << \" \" << j << endl;\n      if(s[i+1]==\"-\"){\n        dp[i+1][j] = (dp[i+1][j]+((dp[i][j]*1LL*(n-i-j))%mod*inv[n-i])%mod)%mod;\n      }\n      else if(s[i+1]==\"D\")\n      {\n  \t\tdp[i+1][j] = (dp[i+1][j]+((dp[i][j]*1LL*j*(n-i-j))%mod*inv[n-i])%mod)%mod;\n  \t\tif(j) dp[i+1][j-1] = (dp[i+1][j-1]+((dp[i][j]*1LL*j*j)%mod*inv[n-i])%mod)%mod;\n      }\n      else\n      {\n      \tdp[i+1][j] = (dp[i+1][j]+((dp[i][j]*1LL*j*(n-i-j))%mod*inv[n-i])%mod)%mod;\n        dp[i+1][j+1] = (dp[i+1][j+1]+((dp[i][j]*1LL*(n-i-j)*(n-i-j-1))%mod*inv[n-i])%mod)%mod;\n      }\n      \n    }\n  }\n  cout << dp[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 1000000007\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n\ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<ll Mod>\nstruct ModInt{\n    long long x;\n    ModInt():x(0){}\n    ModInt(long long y):x(y>=0?y%Mod:(Mod-(-y)%Mod)%Mod){}\n    ModInt &operator+=(const ModInt &p){\n        if((x+=p.x)>=Mod) x-=Mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p){\n        if((x+=Mod-p.x)>=Mod)x-=Mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p){\n        x=(int)(1ll*x*p.x%Mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p){\n        (*this)*=p.inverse();\n        return *this;\n    }\n    ModInt operator-()const{return ModInt(x);}\n    ModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n    ModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n    ModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n    ModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n    ModInt operator==(const ModInt &p)const{return x==p.x;}\n    ModInt operator!=(const ModInt &p)const{return x!=p.x;}\n    ModInt inverse()const{\n        int a=x,b=Mod,u=1,v=0,t;\n        while(b>0){\n            t=a/b;\n            swap(a-=t*b,b);swap(u-=t*v,v);\n        }\n        return ModInt(u);\n    }\n    ModInt pow(long long n)const{\n        ModInt ret(1),mul(x);\n        while(n>0){\n            if(n&1) ret*=mul;\n            mul*=mul;n>>=1;\n        }\n        return ret;\n    }\n    friend ostream &operator<<(ostream &os,const ModInt &p){return os<<p.x;}\n    friend istream &operator>>(istream &is,ModInt &a){long long t;is>>t;a=ModInt<Mod>(t);return (is);}\n    static int get_mod(){return Mod;}\n};\nusing mint=ModInt<mod>;\n \ntemplate<int MAX>\nstruct comcalc{\n    vector<mint> fact,finv,inv;\n    comcalc():fact(MAX),finv(MAX),inv(MAX){\n        fact[0]=mint(1),fact[1]=mint(1),finv[0]=mint(1),finv[1]=mint(1),inv[1]=mint(1);\n        for(int i=2;i<MAX;i++){\n            fact[i]=fact[i-1]*mint(i);\n            inv[i]=mint(0)-inv[mod%i]*(mint(mod/i));\n            finv[i]=finv[i-1]*inv[i];\n        }\n    }\n    mint com(int n,int k){\n        if(n<k) return mint(0);\n        if(n<0 or k<0) return mint(0);\n        return fact[n]*(finv[k]*finv[n-k]);\n    }\n    mint fac(int n){\n        return fact[n];\n    }\n    // 重複組み合わせ:n種類の物から重複を許し，k個選ぶ\n    mint nHk(int n,int k){\n        return com(n+k-1,k);\n    }\n    // 玉n区別，箱k区別，各箱1個以上O(k)\n    mint F12_dis_dis_one(int n,int k){\n        mint ret=1;\n        for(int i=0;i<=k;i++){\n            mint add=com(k,i)*(mint(i).pow(n));\n            if((k-i)%2) ret-=add;\n            else        ret+=add;\n        }\n        return ret;\n    }\n};\nmint pow_mod(mint x,ll n){\n    return x.pow(n);\n}\nmint inv_mod(mint x){\n    return x.inverse();\n}\n// O(n)\nmint fact_mod(ll n){\n    mint ret=1;\n    for(int i=2;i<=n;i++) ret*=mint(i);\n    return ret;\n}\n// O(r)\nmint comb_mod(ll n,ll r){\n    if(r>n-r) r=n-r;\n    if(r==0) return 1;\n    mint a=1,b=mint(fact_mod(r)).inverse();\n    for(int i=0;i<r;i++)a*=mint(n-i);\n    return a*b;\n}\n \nconst int MAX=4010000;\nusing cominit=comcalc<MAX>;\n\nvoid hakone(){\n    int n;cin>>n;\n    vector<char> s;\n    rep(i,n){\n        char c;cin>>c;\n        if(c!='-')s.push_back(c);\n    }\n    n=(int)s.size();\n    \n    mint dp[n+1][n+1];\n    rep(i,n+1)rep(j,n+1)dp[i][j]=0;\n    dp[0][0]=1;\n\n    rep(i,n){\n        rep(j,n){\n            mint src=dp[i][j];\n            // 空きと保留中の個数は一致．それはそう\n            if(s[i]=='U'){\n                // iを空き場所へ入れる\n                // iを保留する\n                dp[i+1][j]+=src*j;\n                if(j+1<=n)dp[i+1][j+1]+=src;\n            }else{\n                // 保留したものを今見てる場所に入れ，iを保留\n                // 保留したものを今見てる場所に入れ，iを空きへ入れる\n                dp[i+1][j]+=src*j;\n                if(j) dp[i+1][j-1]+=src*j*j;\n            }\n        }\n    }\n    cout<<dp[n][0]<<endl;\n}\n\nsigned main(){\n    hakone();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// AOJ Hakone\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n#define int long long\n\ntemplate <uint_fast64_t Modulus> class mint {\n    using u64 = uint_fast64_t;\n    u64 a;\npublic:\n\n    constexpr mint(const u64 a = 0) noexcept : a((a % Modulus + Modulus) % Modulus) {}\n\n    constexpr u64& value() noexcept {\n        return a;\n    }\n\n    constexpr mint& operator +=(const mint& rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) a -= Modulus;\n        return *this;\n    }\n\n    constexpr mint& operator -=(const mint& rhs) noexcept {\n        a += Modulus - rhs.a;\n        if (a >= Modulus) a -= Modulus;\n        return *this;\n    }\n\n    constexpr mint& operator *=(const mint& rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n\n    constexpr mint operator +(const mint rhs) const noexcept {\n        return mint(*this) += rhs;\n    }\n\n    constexpr mint operator -(const mint rhs) const noexcept {\n        return mint(*this) -= rhs;\n    }\n\n    constexpr mint operator *(const mint &rhs) const noexcept {\n        return mint(*this) *= rhs;\n    }\n\n    constexpr mint pow(u64 t) const noexcept {\n        if (!t) return 1;\n        mint<Modulus> ret = pow(t >> 1u);\n        ret *= ret;\n        if (t & 1) ret *= *this;\n        return ret;\n    }\n\n    constexpr mint inv() const noexcept {\n        return pow(Modulus - 2);\n    }\n\n    constexpr mint operator /=(const mint rhs) {\n        return (*this) *= rhs.inv();\n    }\n\n    constexpr mint operator /(const mint &rhs) const noexcept {\n        return mint(*this) /= rhs;\n    }\n};\n\nconst int MOD = 1000000007;\nconst int MAX_N = 205;\n// dp[i][j] = 上からi個のうち、j個のペアを作る場合の数\nusing mi = mint<MOD>;\nmi dp[MAX_N][MAX_N];\n\nsigned main() {\n    int N;\n    cin >> N;\n    vector<char> chars(N);\n    for (int i = 0; i < N; i++) {\n        cin >> chars[i];\n    }\n    dp[0][0] = 1;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= N; j++) {\n            if (chars[i] == 'D') {\n                if (j <= i) dp[i+1][j+2] += dp[i][j] * (i-j) * (i-j);\n                if (j <= i) dp[i+1][j+1] += dp[i][j] * (i-j);\n            } else if (chars[i] == 'U') {\n                if (j <= i) dp[i+1][j+1] += dp[i][j] * (i-j);\n                dp[i+1][j] += dp[i][j];\n            } else {\n                dp[i+1][j+1] += dp[i][j];\n            }\n        }\n    }\n\n    cout << dp[N][N].value() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\nlong long MOD = 1000000007LL;\n\nlong long dp[210][210][210];\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tdp[0][0][0] = 1;\n\tvector<char> v(n);\n\trep(i, n) {\n\t\tcin >> v[i];\n\t\tif(v[i] == '-') {\n\t\t\tn--;\n\t\t\ti--;\n\t\t}\n\t}\n\tv.erase(v.begin()+n, v.end());\n\n\trep(i, n) {\n\t\tchar t = v[i];\n\t\trep(j, n) {\n\t\t\trep(k, n) {\n\t\t\t\tif(t == 'U') {\n\t\t\t\t\tif(j>0) (dp[i + 1][j][k] += j*dp[i][j][k]%MOD) %= MOD;\n\t\t\t\t\t(dp[i + 1][j + 1][k + 1] += dp[i][j][k]) %= MOD;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(j - 1 >= 0 && k - 1 >= 0) (dp[i + 1][j - 1][k - 1] += j*k*dp[i][j][k]) %= MOD;\n\t\t\t\t\tif(j>0) (dp[i + 1][j][k] += k*dp[i][j][k]) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n+1){\n\t\trep(j,n){\n\t\t\trep(k,n){\n\t\t\t\t// cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<dp[i][j][k]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing ll = long long int;\nusing P = std::pair<int, int>;\n\n#define rep(i, n) for (int i = 1; i <= n; ++i)\n\nconstexpr ll mod = 1e9 + 7;\n\nclass mint\n{\n    ll num = 0;\n\npublic:\n    mint(ll x = 0) : num(x) {}\n\n    mint operator+(const mint &rhs) const\n    {\n        return (num + rhs.num) % mod;\n    }\n    mint operator+=(const mint &rhs)\n    {\n        return num = (num + rhs.num) % mod;\n    }\n    mint operator*(const mint &rhs) const\n    {\n        return num * rhs.num % mod;\n    }\n    mint operator-(const mint &rhs) const\n    {\n        return (num + rhs.num + mod) % mod;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mint &rhs);\n};\n\nstd::ostream &operator<<(std::ostream &os, const mint &rhs)\n{\n\n    os << rhs.num;\n\n    return os;\n}\n\nint main()\n{\n    int n;\n\n    std::cin >> n;\n\n    std::vector<char> cs(n + 1);\n\n    rep(i, n)\n    {\n        std::cin >> cs[i];\n    }\n\n    std::vector<std::vector<std::vector<mint>>> cnt(n + 1, std::vector<std::vector<mint>>(n + 1, std::vector<mint>(n + 1)));\n\n    if (cs[1] == '-')\n        cnt[1][0][0] = 1;\n    else if (cs[1] == 'U')\n        cnt[1][1][1] = 1;\n\n    for (int i = 2; i <= n; ++i)\n    {\n        for (int j = 0; j < n; ++j)\n        {\n            for (int k = 0; k < n; ++k)\n            {\n                if (cs[i] == '-')\n                    cnt[i][j][k] = cnt[i - 1][j][k];\n                else if (cs[i] == 'U')\n                {\n                    cnt[i][j][k] = mint(k) * cnt[i - 1][j][k];\n                    if (j >= 1 && k >= 1)\n                        cnt[i][j][k] += cnt[i - 1][j - 1][k - 1];\n                }\n                else if (cs[i] == 'D')\n                {\n                    cnt[i][j][k] = mint((k + 1) * (j + 1)) * cnt[i - 1][j + 1][k + 1] + mint(j) * cnt[i - 1][j][k];\n                }\n            }\n        }\n    }\n\n    std::cout << cnt[n][0][0] << std::endl;\n\n    /*rep(i, n)\n    {\n        std::cerr << cnt[i][0][0] << ' ' << cnt[i][1][1] << ' ' << cnt[i][2][2] << std::endl;\n    }*/\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define reps(i, n) for (int i = 1; i <= (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), end(x))\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int DX[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\n// Hakone考察中\n// '-'の分は考えなくて良い\n// 上から見ていったときに、その順位がまだ残っているかどうかが重要？\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nusing mint = mod_int<>;\nint n;\nchar c[220];\nmint dp[220][220];\nsigned main() {\n    cin >> n;\n    vint cv;\n    rep(i, n) {\n        cin >> c[i];\n        if (c[i] != '-') { cv.push_back(c[i]); }\n    }\n    dp[0][0] = 1;\n    int m = cv.size();\n    rep(i, m) {\n        for (int j = 0; j <= i; j++) {\n            if (cv[i] == 'D') {\n                if (j > 0) { dp[i + 1][j - 1] += dp[i][j] * j * j / (m - i); }\n                dp[i + 1][j] += dp[i][j] * j * (m - i - j) / (m - i);\n            }\n            if (cv[i] == 'U') {\n                dp[i + 1][j] += dp[i][j] * (m - i - j) * j / (m - i);\n                dp[i + 1][j + 1] += dp[i][j] * (m - i - j - 1) * (m - i - j) / (m - i);\n            }\n        }\n    }\n    cout << dp[cv.size()][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\ntypedef long long int ll;\nusing namespace std;\n\n// @@ !! LIM(mod)\n// --> f:gcd mod\n// ---- inserted function gcd from util.cc\n// g = eGCD(a, b, s, t)  --->  sa + tb = g\nconstexpr ll eGCD(ll a, ll b, ll& s, ll& t) {\n  if (a == 0) {\n    s = 0;\n    t = 1;\n    return b;\n  }\n  ll u = 0;\n  ll g = eGCD(b % a, a, t, u);\n  s = u - (b / a) * t;\n  return g;\n}\n\nconstexpr ll gcd(ll a, ll b) {\n  ll dummy1 = 0;\n  ll dummy2 = 0;\n  return eGCD(a, b, dummy1, dummy2);\n}\n// ---- end gcd\n// ---- inserted library file mod.cc\n\nll MOD = 1e9 + 7;\n// ll MOD = 998244353;\n\nstruct Fp {\n  ll val;\n\n  Fp(ll t = 0) {\n    if      (t >= MOD)  val = t % MOD;\n    else if (t >= 0)    val = t;\n    else if (t >= -MOD) val = t + MOD;\n    else {\n      ll v = t % MOD;\n      if (v == 0) val = 0;\n      else        val = v + MOD;\n    }\n  }\n\n  Fp& operator +=(const Fp& t) {\n    val += t.val;\n    if (val >= MOD) val -= MOD;\n    return *this;\n  }\n\n  Fp& operator -=(const Fp& t) {\n    val -= t.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n\n  Fp& operator *=(const Fp& t) {\n    val = (val * t.val) % MOD;\n    return *this;\n  }\n\n  Fp inv() const {\n    if (val == 0) {\n      cerr << \"inv() is called for zero.\" << endl;\n      exit(1);\n    }\n    ll u = 0;\n    ll v = 0;\n    eGCD(val, MOD, u, v);\n    return Fp(u);\n  }\n\n  Fp& operator /=(const Fp& t) {\n    return (*this) *= t.inv();\n  }\n\n  Fp operator +(const Fp& t) const { return Fp(val) += t; }\n  Fp operator -(const Fp& t) const { return Fp(val) -= t; }\n  Fp operator *(const Fp& t) const { return Fp(val) *= t; }\n  Fp operator /(const Fp& t) const { return Fp(val) /= t; }\n  Fp operator -() const { return Fp(-val); }\n\n  bool operator ==(const Fp& t) const { return val == t.val; }\n  bool operator !=(const Fp& t) const { return val != t.val; }\n  \n  operator ll() const { return val; }\n\n};\n\nclass Comb {\n  int nMax;\n  vector<Fp> vFact;\n  vector<Fp> vInvFact;\npublic:\n  Comb(int nm) : nMax(nm), vFact(nm+1), vInvFact(nm+1) {\n    vFact.at(0) = 1;\n    for (int i = 1; i <= nMax; i++) vFact.at(i) = i * vFact.at(i-1);\n    vInvFact.at(nMax) = vFact.at(nMax).inv();\n    for (int i = nMax; i >= 1; i--) vInvFact.at(i-1) = i * vInvFact.at(i);\n  }\n  Fp fact(int n) { return vFact.at(n); }\n  Fp comb(int n, int r) {\n    return vFact.at(n) * vInvFact.at(r) * vInvFact.at(n-r);\n  }\n  // The number of permutation extracting r from n.\n  Fp perm(int n, int r) {\n    return vFact.at(n) * vInvFact.at(n-r);\n  }\n};\n\n// ---- end mod.cc\n// @@ !! LIM  -- end mark --\n\nint main(int argc, char *argv[]) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << setprecision(20);\n\n  ll N; cin >> N;\n  vector<Fp> prev(N+1), cur;\n  prev.at(0) = 1;\n  for (ll i = 0; i < N; i++) {\n    cur = vector<Fp>(N+1);\n    char c; cin >> c;\n    if (c == '-') {\n      copy(prev.begin(), prev.end(), cur.begin());\n    }else if (c == 'U') {\n      for (ll j = 0; j < N; j++) {\n\tFp v = prev.at(j);\n\tcur.at(j+1) += v;\n\tcur.at(j)   += Fp(j) * v;\n      }\n    }else if (c == 'D') {\n      for (ll j = 1; j <= N; j++) {\n\tFp v = prev.at(j);\n\tcur.at(j)   += Fp(j) * v;\n\tcur.at(j-1) += Fp(j) * Fp(j) * v;\n      }\n    }else assert(0);\n    prev = move(cur);\n  }\n  cout << prev.at(0) << endl;\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n#define MOD 1000000007\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint dp[201][201];\n\nint main(){\n\n    long long int ans = 0;\n    char s[201];\n    int n;\n    memset(dp,0,sizeof(dp));\n    dp[0][0] = 1;\n    cin >> n;\n    for(int i=0;i<n;i++){\n\tcin >> s[i];\n    }\n\n    for(int i=0;i<n;i++){\n\tif(s[i] == '-'){\n\t    for(int j=0;j<=i;j++) dp[i+1][j] = dp[i][j];\n\t}else if(s[i] == 'D'){\n\t    for(int j=1;j<=i+1;j++){\n\t\tdp[i+1][j-1] += dp[i][j] * j * j % MOD;\n\t\tdp[i+1][j] += dp[i][j] * j % MOD;\n\t    }\n\t}else if(s[i] == 'U'){\n\t    for(int j=0;j<=i;j++){\n\t\tdp[i+1][j] += dp[i][j] * j % MOD;\n\t\tdp[i+1][j+1] += dp[i][j];\n\t    }\n\t}\n    }\n    cout << dp[n][0] << endl;;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\n//#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[202][202];\nll MOD=1000000007;\n\nint main(void){\n\n  fill(dp[0],dp[202],0);\n\n  int n;\n  cin >> n;\n\n  string c;\n\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  dp[0][0]=1;\n\n  for(int k=0;k<n;k++){\n    for(int i=0;i<=k;i++){\n      if(c[k]=='-')dp[k+1][i]=dp[k][i];\n      else if(c[k]=='D'){\n        if(i>0){\n          dp[k+1][i-1]+=((dp[k][i]*i)%MOD*i)%MOD;\n        }\n        dp[k+1][i]+=(dp[k][i]*i)%MOD;\n      }\n      else if(c[k]=='U'){\n        dp[k+1][i]+=(dp[k][i]*i)%MOD;\n        dp[k+1][i+1]+=dp[k][i];\n        dp[k+1][i+1]%=MOD;\n      }\n      dp[k+1][i]%=MOD;\n    }\n  }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint dp[210][210];\nsigned main() {\n    int N; cin >> N;\n    vector<int> v;\n    for(int i=0; i<N; i++) {\n        char c; cin >> c;\n        if(c == 'U') v.push_back(1);\n        if(c == 'D') v.push_back(0);\n    }\n\n    N = v.size();\n    dp[0][0] = 1;\n    for(int i=0; i<N; i++) {\n        int p = v[i];\n        for(int j=0; j<=i; j++) {\n            if(p == 0) {\n                // DOWN (その人を空いている場所に / 保留していた人をそこに入れても良い)\n                if(j > 0) (dp[i+1][j-1] += dp[i][j] * j * j) %= MOD;\n                (dp[i+1][j  ] += dp[i][j] * j) %= MOD;\n            }\n            if(p == 1) {\n                // UP (その人は保留に / 保留していた人をそこに入れても良い)\n                (dp[i+1][j+1] += dp[i][j]) %= MOD;\n                (dp[i+1][j  ] += dp[i][j] * j) %= MOD;\n            }\n        }\n    }\n    cout << dp[N][0] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nint dp[210][210][210];\n\nstring s[210];\n\nint M[210];\nint Dcnt,Ucnt;\nint D[210];\nint U[210];\nint n;\n\n// x: ??????\n// a: ???????????¨????????°\n// b: ?????£?????????U?????°\n\n\n// U\n\nint mod = 1000000007;\nint dfs(int x,int a,int b){\n\tif( x == n ){\n\t\treturn a == 0 && b == 0;\n\t}\n\tif( dp[x][a][b] != -1 ) return dp[x][a][b];\n\tif( s[x] == \"-\" ) return dfs(x+1,a,b);\n\tint ans = 0;\n\tif( s[x] == \"U\" ){\n\t\t//??????????????´???\n\t\tans += dfs(x+1,a+1,b+1);\n\t\tif(b) ans += dfs(x+1,a,b) * b;\n\t}else{\n\t\t// D????????£??? U???????????????\n\t\tif(a) ans += dfs(x+1,a,b) * a;\n\t\t//?????£?????????\n\t\tif(a&&b){\n\t\t\tans += dfs(x+1,a-1,b-1) * a * b;\n\t\t}\n\t}\n\tans %= mod;\n\treturn dp[x][a][b] = ans;\n}\n\n\nsigned main(){\n\tmemset(dp,-1,sizeof(dp));\n\tcin >> n;\n\tint cnt = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tcin >> s[i];\n\t}\n\tcout << dfs(0,0,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\n\nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nmap< vector<int> , ll > dp[201][201];\nstring S;\n\nll rec(int dep,int cnt,vector<int> v){\n  for(int i=0;i<(int)v.size();i++){\n    if(v[i]<0)return 0;\n  if(dep==(int)S.size())return 1;\n  if(dep>0&&S[dep-1]=='U')cnt++;\n  if(dp[ dep ][ cnt ].count(v) )return dp[dep][cnt][v];\n  ll res=0;\n  if( (v.empty() || v[0]>0) && cnt> 0){\n    vector<int> next=v;\n    for(int i=0;i<(int)v.size();i++)next[i]--;\n    res=add(res, mul(cnt,rec(dep+1,cnt-1,next) ) );\n  }\n  for(int i=0;i<(int)v.size();i++){\n\n    vector<int> next;\n    for(int j=0;j<(int)v.size();j++){\n      if(i!=j)next.push_back(v[j]-1);\n    }\n    sort(next.begin(),next.end());\n    if(!next.empty() && next[0]<0)continue;    \n    res=add(res, rec(dep+1,cnt,next) );\n  }\n  return dp[dep][cnt][v]=res;\n}\n\nint solve(string str){\n  if(str==\"\")return 1;\n  vector<int> vec;\n  int cnt=0;\n  for(int i=0;i<(int)str.size();i++){\n    if(str[i]=='D')vec.push_back(i-1);\n  }\n  S=str;\n  return rec( 0, cnt, vec );\n}\n\nint main(){\n  int n;\n  cin>>n;\n  string str=\"\";\n  for(int i=0;i<n;i++){\n    char ch;\n    cin>>ch;\n    if(ch=='-')continue;\n    str+=ch;\n  }\n  cout<<solve(str)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n#define M 1000000007\nint n,x[205];\nll dp[2][205];\nint main(void){\n    cin>>n;\n    for(int i=0;i<n;){\n        char c;\n        cin>>c;\n        if(c=='U')x[i++]=1;\n        else if(c=='D')i++;\n        else n--;\n    }\n    dp[0][0]=1;\n    for(int i=0,u=1;i<n;i++,u++){\n        for(ll j=0;j<=n;j++){\n            if(x[i]==1){\n                if(j>0)dp[u%2][j]=(dp[i%2][j]*j+dp[i%2][j-1])%M;\n                else dp[u%2][j]=dp[i%2][j]*j%M;\n            }else{\n                dp[u%2][j]=(dp[i%2][j+1]*(j+1)*(j+1)+dp[i%2][j]*j)%M;\n            }\n        }\n    }\n    cout<<dp[n%2][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define MOD 1000000007\nll dp[300][300];\nint n;\nchar c[300];\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)cin >> c[i];\n    dp[0][0]=1ll;\n    for(int i=0;i<n;i++)\n    {\n        if(c[i]=='-')for(int j=0;j<=n;j++)dp[i+1][j]=dp[i][j];\n        if(c[i]=='D')\n        {\n            for(int j=0;j<=i;j++)\n            {\n                if(j>0)dp[i+1][j-1] = (dp[i+1][j-1]+(((dp[i][j]*j)%MOD)*j%MOD))%MOD;\n                dp[i+1][j] = (dp[i+1][j]+((dp[i][j]*j)%MOD))%MOD;\n            }\n        }\n        if(c[i]=='U')\n        {\n            for(int j=0;j<=i;j++)\n            {\n                dp[i+1][j+1] = (dp[i+1][j+1]+dp[i][j])%MOD;\n                dp[i+1][j] = (dp[i+1][j]+((dp[i][j]*j)%MOD))%MOD;\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define pb(e) push_back(e)\n#define foreach(c, i) for(iter(c) i = (c).begin(); i != c.end(); ++i)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nll mod = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 210;\nll dp[sz][sz][sz]; \n//dp[i][j][k]:=(上位i人目まで見たときにj人の元の順位が決まっておらず、元の上位i人目まででk人の順位が決まっていない場合の数)\n\nint main(){\n  int N;\n  cin >> N;\n  dp[0][0][0] = 1;\n  \n  rep(i, N){\n    char c;  \n    cin >> c;\n    rep(j, N){\n      rep(k, N){\n\t//cout << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << endl;\n\tswitch(c){\n\tcase '-':\n\t  dp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k]) % mod;\n\t  break;\n\tcase 'U':\n\t  dp[i+1][j+1][k+1] = (dp[i+1][j+1][k+1] + dp[i][j][k]) % mod;\n\t  dp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k] * j) % mod;\n\t  break;\n\tcase 'D':\n\t  dp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k] * k) % mod;\n\t  if(j > 0 && k > 0){\n\t    dp[i+1][j-1][k-1] = (dp[i+1][j-1][k-1] + dp[i][j][k] * j * k) % mod;\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dp[N][0][0] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int MOD = 1000000007;\n\nint main(){\n    int n;\n    while(cin >> n){\n        vector<string> s(n);\n        REP(i, n) cin >> s[i];\n        array<LL, 222> dp = {};\n        dp[0] = 1;\n        int down = 0;\n        int eq = 0;\n        int up = 0;\n        for(int i = 0; i < n; i++) {\n            //REP(i, 10) cout << dp[i] << \" \"; cout << endl;\n            if(s[i] == \"-\") {\n                eq++;\n                continue;\n            }\n\n            if(s[i] == \"D\") {\n                for(int j = 0; j <= n; j++) {\n                    int rest = i - eq - up - j;\n                    //printf(\"i = %d eq = %d up = %d j = %d rest = %d dp[j] = %lld\\n\", i, eq, up, j, rest, dp[j]);\n                    if(rest > 0) {\n                        dp[j] *= rest;\n                        dp[j] %= MOD;\n                    } else {\n                        dp[j] = 0;\n                    }\n                }\n            }\n\n            array<LL, 222> ndp = {};\n            for(int j = 0; j <= n; j++) {\n                int rest = down - j;\n                if(rest >= 1) {\n                    ndp[j + 1] += dp[j] * rest;\n                    ndp[j + 1] %= MOD;\n                }\n                ndp[j] += dp[j];\n                ndp[j] %= MOD;\n            }\n\n            if(s[i] == \"U\") down++;\n            if(s[i] == \"D\") up++;\n            dp = ndp;\n        }\n        //REP(i, 10) cout << dp[i] << \" \"; cout << endl;\n        cout << dp[down] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=7+1e9;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b);\n\telse if(arrays[n]==-1) DP[n][a][b]=ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b));\n\telse return DP[n][a][b]=ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b));\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tif(p!=(1000000007)) return 0;\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\ntypedef long long i64;\n\ntemplate <i64 MOD> struct ModInt {\n  i64 value;\n\n  ModInt(i64 v = 0) { value = v % MOD; }\n\n  operator i64() { return value; }\n  ModInt<MOD> operator+(int v) { return (value + v) % MOD; }\n  ModInt<MOD> operator+(i64 v) { return (value + v) % MOD; }\n\n  ModInt<MOD> operator-(i64 v) {\n    v %= MOD;\n    return (MOD + value - v) % MOD;\n  }\n\n  ModInt<MOD> operator*(i64 v) { return (value * v) % MOD; }\n};\n\nint n;\n\nvector<int> c;\nconst i64 mod = 1e9 + 7;\nvector<vector<ModInt<mod>>> dp(404,vector<ModInt<mod>>(404));\nint main(){\n    cin >> n;\n    for(int i = 0;i < n;i++){\n\t\tchar u;\n\t\tcin >> u;\n\t\tif(u == 'U') c.push_back(-1);\n\t\tif(u == 'D') c.push_back(1);\n    }\n\tdp[0][0] = 1;\n\tn = c.size();\n\tfor(i64 i = 0;i < n;i++){\n\t\tfor(i64 j = 0;j <= n;j++){\n\t\t\tif(c[i]==1){\n\t\t\t\tdp[i + 1][j] = dp[i + 1][j] + dp[i][j] * j;\n\t\t\t\tif(j > 0) dp[i + 1][j - 1] = dp[i + 1][j - 1] + dp[i + 1][j] * j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i + 1][j] = dp[i + 1][j] + dp[i][j] * j;\n\t\t\t\tdp[i + 1][j + 1] = dp[i + 1][j + 1] + dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=1000000007;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b)%p;\n\telse if(arrays[n]==-1) DP[n][a][b]=(ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b)))%p;\n\telse return DP[n][a][b]=(ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p);\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long Int;\nconst int MOD = 1000000007;\n\nInt dp[201][201];\n\nint main()\n{\n    int N;\n    char s[256];\n\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) scanf(\"%s\", &s[i]);\n\n    dp[0][0] = 1;\n\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j <= N; j++){\n            if (s[i] == '-'){\n                dp[i + 1][j] += dp[i][j];\n                dp[i + 1][j] %= MOD;\n            }\n            if (s[i] == 'U'){\n                dp[i + 1][j] += dp[i][j] * j;\n                dp[i][j] %= MOD;\n                if (j < N){\n                    dp[i + 1][j + 1] += dp[i][j];\n                    dp[i + 1][j + 1] %= MOD;\n                }\n            }\n            if (s[i] == 'D'){\n                dp[i + 1][j] += dp[i][j] * j;\n                dp[i + 1][j] %= MOD;\n                if (j > 0){\n                    dp[i + 1][j - 1] += dp[i][j] * j * j;\n                    dp[i + 1][j - 1] %= MOD;\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", dp[N][0]);\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int mod = (int)(1e9 + 7)>\nstruct ModInt {\n  int x;\n  constexpr ModInt() : x(0) {}\n  constexpr ModInt(int64_t y)\n      : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n  constexpr ModInt &operator+=(const ModInt &p) noexcept {\n    if ((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n  constexpr ModInt &operator-=(const ModInt &p) noexcept {\n    if ((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n  constexpr ModInt &operator*=(const ModInt &p) noexcept {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n  constexpr ModInt &operator/=(const ModInt &p) noexcept {\n    *this *= p.inverse();\n    return *this;\n  }\n  constexpr ModInt operator-() const { return ModInt(-x); }\n  constexpr ModInt operator+(const ModInt &p) const noexcept {\n    return ModInt(*this) += p;\n  }\n  constexpr ModInt operator-(const ModInt &p) const noexcept {\n    return ModInt(*this) -= p;\n  }\n  constexpr ModInt operator*(const ModInt &p) const noexcept {\n    return ModInt(*this) *= p;\n  }\n  constexpr ModInt operator/(const ModInt &p) const noexcept {\n    return ModInt(*this) /= p;\n  }\n  constexpr bool operator==(const ModInt &p) const noexcept { return x == p.x; }\n  constexpr bool operator!=(const ModInt &p) const noexcept { return x != p.x; }\n  constexpr ModInt inverse() const noexcept {\n    int a = x, b = mod, u = 1, v = 0, t = 0;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n  constexpr ModInt pow(int64_t n) const {\n    ModInt res(1), mul(x);\n    while (n) {\n      if (n & 1) res *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return res;\n  }\n  friend constexpr ostream &operator<<(ostream &os, const ModInt &p) noexcept {\n    return os << p.x;\n  }\n  friend constexpr istream &operator>>(istream &is, ModInt &a) noexcept {\n    int64_t t = 0;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n  constexpr int get_mod() { return mod; }\n};\n\nlong long n;\nstring s;\nvector<vector<ModInt<>>> dp;\n\nModInt<> solve();\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    char x;\n    cin >> x;\n    if (x != '-') s += x;\n  }\n  n = s.size();\n  cout << solve() << endl;\n  return 0;\n}\n\nModInt<> solve() {\n  dp.assign(n + 1, vector<ModInt<>>(n + 1, 0));\n  dp[0][0] = 1;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j <= i + 1; ++j) {\n      if (s[i] == 'U') {\n        if (j != 0) dp[i + 1][j] += dp[i][j - 1];\n        dp[i + 1][j] += dp[i][j] * j;\n      } else {\n        if (j != n) dp[i + 1][j] += dp[i][j + 1] * (j + 1) * (j + 1);\n        dp[i + 1][j] += dp[i][j] * j;\n      }\n    }\n  return dp[n][0];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi up;\n\t\trep(i,n){\n\t\t\tchar c; cin>>c;\n\t\t\tif(c=='U') up.push_back(1);\n\t\t\tif(c=='D') up.push_back(0);\n\t\t}\n\t\tn=up.size();\n\t\t\n\t\tvvl dp(n+1,vl(n+1));\n\t\tdp[0][0]=1;\n\t\trep(i,n) rep(j,i+1){\n\t\t\tif(up[i]){\n\t\t\t\t(dp[i+1][j]+=dp[i][j]*j)%=MOD;\n\t\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t(dp[i+1][j]+=dp[i][j]*j)%=MOD;\n\t\t\t\tif(j>0) (dp[i+1][j-1]+=dp[i][j]*j*j)%=MOD;\n\t\t\t}\n\t\t}\n\t\tcout<<dp[n][0]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nint d[212][212],n,M=1e9+7,i,j,a,*b;main(){std::cin>>n;char c;**d=1;for(i=0;std::cin>>c;++i)for(j=0;a=d[i][j],b=d[i+1],j<n;j++)if(c&8)b[j]=a;else if(c&1)(b[j]+=a*j)%=M,(b[j+1]+=a)%=M;else(b[j]+=a*j)%=M,(b[j-1]+=a*j*j)%=M;std::cout<<*d[n]<<\"\\n\";}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <random>\n#include <tuple>\n#include <iomanip>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n//typedef pair<int,int> Pint;\n//typedef pair<ll, ll> P;\ntypedef pair<ll, pair<ll, ll>> P;\n//typedef tuple<int,int,int> T;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n-1); i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\nconst ll INFL = 1LL << 60;//10^18 = 2^60\nconst int INF = 1 << 30;//10^9\nconst ll MOD = 1e9 + 7;\n//const ll MOD  = 998244353;\nvector<ll> dy = {0, 0, 1, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, -1, 0, 0, 1, -1, 1, -1, 0};\n\nll max(ll a, ll b){return (a > b) ? a : b;}\nll min(ll a, ll b){return (a < b) ? a : b;}\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x;\n    k /= 2;\n  }\n  return res;\n}\nll pow_mod(ll x, ll k){\n  x %= MOD; x += MOD; x %= MOD;\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\n//最大公約数\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\n//最小公倍数\nll lcm(ll x, ll y){return x / gcd(x, y) * y;};\n\n//コンビネーション\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nll dp[210][210];\n\nint main(){\n\n  ll N;\n  cin >> N;\n  vector<char> C(N);\n  rep(i, N) cin >> C[i];\n  dp[0][0] = 1;\n  for(ll i = 1; i <= N; i++){\n    if(C[i-1] == '-'){\n      for(ll j = 0; j <= N; j++){\n        dp[i][j] += dp[i-1][j];\n      }\n    }else if(C[i-1] == 'U'){\n      for(ll j = 0; j <= N; j++){\n        dp[i][j] += dp[i-1][j] * j;\n        if(j >= 1) dp[i][j] += dp[i-1][j-1];\n        dp[i][j] %= MOD;\n      }\n    }else{\n      for(ll j = 0; j <= N; j++){\n        dp[i][j] += dp[i-1][j+1] * (j+1) * (j+1);\n        dp[i][j] += dp[i-1][j] * j;\n        dp[i][j] %= MOD;\n      }\n    }\n  }\n  cout << dp[N][0] << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// {{{\nnamespace unolight {\n#define SZ(x) ((int)(x).size())\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP1(i,a,b) for (int i = a; i <= (int)(b); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define PB push_back\n#define MP make_pair\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\ntemplate<class T> inline bool chmax( T &a, const T &b ) { return b>a ? a=b,true : false; }\ntemplate<class T> inline bool chmin( T &a, const T &b ) { return b<a ? a=b,true : false; }\ntemplate <class T, class F = less<T>>\nvoid sort_uniq(vector<T> &v, F f = F()) {\n    sort(begin(v), end(v), f);\n    v.resize(unique(begin(v), end(v)) - begin(v));\n}\n\nconst int MOD=1000000007;\nint n;\nLL dp[201][201]; // before i, j items not matched\nvoid main() {\n    cin >> n;\n    vector<char> s(n);\n    REP(i,n) cin >> s[i];\n    dp[0][0]=1;\n    REP(i,n) REP(j,i+1) {\n        if ( s[i]=='-' ) { // i match i\n            dp[i+1][j]+=dp[i][j];\n            dp[i+1][j]%=MOD;\n        } else if ( s[i]=='U' ) { // left i not match\n            // right i match with left j (j<i)\n            dp[i+1][j]+=dp[i][j]*j%MOD;\n            dp[i+1][j+1]%=MOD;\n            // right not match\n            dp[i+1][j+1]+=dp[i][j];\n            dp[i+1][j+1]%=MOD;\n        } else { // left i match\n            // right i match with left j (j<i)\n            dp[i+1][j-1]+=dp[i][j]*j%MOD*j%MOD;\n            dp[i+1][j-1]%=MOD;\n            // right not match\n            dp[i+1][j]+=dp[i][j]*j%MOD;\n            dp[i+1][j]%=MOD;\n        }\n    }\n    cout << dp[n][0] << '\\n';\n}\n// }}}\n} int main(){\n    ios::sync_with_stdio(0); cin.tie(0);\n    unolight::main(); return 0;\n} \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n#define mod 1000000007\n\nint n;\nll dp[205][205];\nll inv[205];\nstring s[205];\n\nlong long modpow(long long x,long long n){\n\tlong long res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nint main() {\n  cin >> n;\n  for(int i=1;i<=n;i++) cin >> s[i];\n  dp[0][0]=1;\n  for(int i=1;i<=200;i++) inv[i]=modpow(1ll*i,mod-2ll);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=n-i;j++){\n      if(!dp[i][j]) continue;\n      if(s[i+1]==\"-\"){\n        dp[i+1][j] = (dp[i+1][j]+dp[i][j]*1LL*j*inv[n-i])%mod;\n        dp[i+1][j+1] = (dp[i+1][j+1]+dp[i][j]*(n-i-j)*1LL*inv[n-i]);\n      }\n      else if(s[i+1]==\"D\")\n      {\n  \t\tdp[i+1][j] = (dp[i+1][j]+dp[i][j]*j*(n-i-j)*1LL*inv[n-i])%mod;\n  \t\tif(j) dp[i+1][j-1] = (dp[i+1][j-1]+dp[i][j]*1LL*j*j*inv[n-i])%mod;\n      }\n      else\n      {\n      \tdp[i+1][j] = (dp[i+1][j]+dp[i][j]*1LL*j*(n-i-j)*inv[n-i])%mod;\n        dp[i+1][j+1] = (dp[i+1][j+1]+dp[i][j]*1LL*(n-i-j)*(n-i-j-1)*inv[n-i])%mod;\n      }\n    }\n  }\n  cout << dp[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst long long int MOD = 1000000007LL;\nlong long int dp[210][210];\nint main() {\n  int N; cin >> N;\n\n  dp[0][0] = 1;\n  for(int i=0; i<N; i++) {\n    char c; cin >> c;\n    for(int j=0; j<=i; j++) { \n      if(c == '-') {\n        dp[i+1][j] = dp[i][j];\n      }\n      else {\n        if(c == 'D') {\n          (dp[i+1][j] += dp[i][j] * j) %= MOD;\n        }\n\n        int is_u = (c == 'U');\n        (dp[i+1][j] += dp[i][j - 1 + is_u]) %= MOD;\n        (dp[i+1][j] += dp[i][j     + is_u] * (j + is_u)) %= MOD;\n      }\n    }\n  }\n\n  for(int i=1; i<=N; i++) {\n    for(int j=0; j<=N; j++) {\n      cout << dp[i][j] << \" \";\n    }\n    cout << endl;\n  }\n\n  \n  cout << dp[N][0] << endl;\n  return 0;\n}\n\n5\nU\nU\n-\nD\nD\n1 0 0 0 0 0 \n1 0 0 0 0 0 \n1 0 0 0 0 0 \n0 1 0 0 0 0 \n0 2 1 0 0 0 \n0\n\n3\n-\nU\nD\n1 0 0 0 \n1 0 0 0 \n0 1 0 0 \n0\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nconst int mod = 1000000007;\nint n;\nchar c[200];\nint dp[201][201];\n\nvoid input() {\n\tcin >> n;\t\n\tint sz = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tchar p; cin >> p;\n\t\tif (p == '-') continue;\n\t\tc[sz++] = p;\n\t}\n\tn = sz;\n}\n\nsigned main() {\n\tinput();\n\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tif (c[i] == 'U') {\n\t\t\t\tdp[i + 1][j + 1] += dp[i][j]; dp[i + 1][j + 1] %= mod;\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j; dp[i + 1][j] %= mod;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j; dp[i + 1][j] %= mod;\n\t\t\t\tif (j > 0) {\n\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j] * j * j; dp[i + 1][j - 1] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 1000000007;\nll inv[1000000];\nll FactorialInv[1000000];\nll Factorial[1000000];\nll beki(ll a, ll b){\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\nvoid init_combination(){\n    inv[1] = 1;\n    FactorialInv[1] = 1;\n    Factorial[1] = 1;\n    Factorial[0] = 1;\n    FactorialInv[0] = 1;\n    inv[0] = 1;\n    for(int i = 2; i < 1000000; i++){\n        inv[i] = beki(i, mod - 2);\n        Factorial[i] = Factorial[i - 1] * i % mod;\n        FactorialInv[i] = FactorialInv[i - 1] * inv[i] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\nll n;\nstring S = \"#\";\n\nll dp[205][205][205];\n//dp[i][j][k]:i人目まで見たとき\n//未使用のUがj人\n//使用しているDがk人\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init_combination();\n    cin >> n;\n    for(int i = 1; i <= n; i++) {\n        char in;\n        cin >> in;\n        if(in == '-') {\n            n--;\n            i--;\n            continue;\n        }\n        S.push_back(in);\n    }\n    dp[0][0][0] = 1;\n    //cout << S << endl;\n    for(ll i = 1; i <= n; i++) {\n        for(ll j = 0; j <= i; j++) {\n            for(ll k = 0; k <= i; k++) {\n                if(S[i] == 'U') {\n                    if(true) {\n                        dp[i][j][k] += dp[i-1][j][k] * j;\n                    }\n                    if(j >= 1) {\n                        dp[i][j][k] += dp[i-1][j-1][k-1];\n                    }\n                } else if(S[i] == 'D') {\n                    if(true) {\n                        dp[i][j][k] += dp[i-1][j+1][k+1] * (j+1) * (k + 1);\n                    }\n                    if(true) {\n                        dp[i][j][k] += dp[i-1][j][k] * k;\n                    }\n                }\n                dp[i][j][k] %= mod;\n                //cerr << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << endl;\n            }\n        }\n    }\n    cout << dp[n][0][0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long;\nconst i64 MOD = 1e9 + 7;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<char> a(n);\n    for(auto& x : a) cin >> x;\n    vector<i64> dp(n, 0LL);\n    dp[0] = 1LL;\n    for(int i : in(n)) {\n        char c = a[i];\n        if(c == '-') continue;\n        vector<i64> dp_(n, 0LL);\n        if(c == 'D') {\n            for(i64 j : in(i + 2)) {\n                (dp_[j] += dp[j] * j) %= MOD;\n                (dp_[j] += dp[j + 1] * (j + 1) * (j + 1)) %= MOD;\n            }\n        }\n        else {\n            for(i64 j : in(i + 2)) {\n                if(j > 0) (dp_[j] += dp[j - 1]) %= MOD;\n                (dp_[j] += dp[j] * j) %= MOD;\n            }\n        }\n        dp = dp_;\n    }\n    cout << dp[0] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define M 1000000007\nint n,x[205];\nll dp[205][205][205];\nint main(void){\n    cin>>n;\n    for(int i=0;i<n;){\n        char c;\n        cin>>c;\n        if(c=='U')x[i++]=1;\n        else if(c=='D')i++;\n        else n--;\n    }\n    dp[0][0][0]=1;\n    for(ll i=0;i<n;i++){\n        for(ll j=0;j<=n;j++){\n            for(ll k=0;k<=n;k++){\n                if(x[i]==1){\n                    if(j>0)dp[i+1][j][k]=(dp[i][j][k]*j%M+dp[i][j-1][k-1])%M;\n                    else dp[i+1][j][k]=dp[i][j][k]*j%M;\n                }else{\n                    dp[i+1][j][k]=(dp[i][j+1][k+1]*(k+1)*(j+1)%M+dp[i][j][k]*k)%M;\n                }\n            }\n        }\n    }\n    cout<<dp[n][0][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\nint n;\nll dp[202][202];\nchar c[300];\n\nint main(void){\n\tscanf(\"%d%*c\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%c%*c\",&c[i]);\n\t}\n\tdp[0][0]=1;\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<=i;j++){\n\t\t\tif(c[i]=='-')dp[i+1][j]=(dp[i+1][j]+dp[i][j])%MOD;\n\t\t\tif(c[i]=='U'){\n\t\t\t\tdp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%MOD;\n\t\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][j]*j)%MOD;\n\t\t\t}\n\t\t\tif(c[i]=='D'){\n\t\t\t\tif(j>0){\n\t\t\t\t\tdp[i+1][j-1]=(dp[i+1][j-1]+dp[i][j]*j*j)%MOD;\n\t\t\t\t}\n\t\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][j]*j)%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nint main()\n{\n    int n; cin>>n;\n    string s;\n    for(int i=0; i<n; i++){\n        char c; cin>>c;\n        if(c!='-') s+=c;\n    }\n    n=s.size();\n    ll dp[202][202]={};\n    dp[0][0]=1;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<=i; j++){\n            if(s[i]=='U'){\n                (dp[i+1][j]+=j*dp[i][j])%=MOD;\n                (dp[i+1][j+1]+=dp[i][j])%=MOD;\n            }else{\n                (dp[i+1][j]+=j*dp[i][j])%=MOD;\n                if(j) (dp[i+1][j-1]+=j*j*dp[i][j])%=MOD;\n            }\n        }\n    }\n    cout<<dp[n][0]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define INT(a) int((a)+1e-9)\n\n#define HOU 1000000007\n\n#define SUPL 205\n\nint L;\nchar us[SUPL];\n\nlong rss[SUPL][SUPL];\n\n\nint solve(){\n\tFOR(l,0,L+1) FOR(m,0,L+1) rss[l][m]=0;\n\trss[0][0]=1;\n\tFOR(l,0,L+1) FOR(m,0,L+1){\n\t\trss[l][m] = rss[l][m] % HOU;\n\t\tif(l<m) continue;\n\t\tif(us[l]=='D'){\n\t\t\trss[l+1][m+1]+=rss[l][m]*(l-m);\n\t\t\trss[l+1][m+2]+=rss[l][m]*(l-m)*(l-m);\n\t\t\tcontinue;\n\t\t}\n\t\tif(us[l]=='U'){\n\t\t\trss[l+1][m]+=rss[l][m];\n\t\t\trss[l+1][m+1]+=rss[l][m]*(l-m);\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn rss[L][L];\n}\n\n\n\nint main(){\n\tint inpL;\n\tcin >> inpL;\n\tint i=0;\n\tREP(gomi,inpL){\n\t\tcin>>us[i];\n\t\tif(us[i]!='-') i++;\n\t}\n\tL=i;\n\n\n\tcout<<solve()<<endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//const int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nconst int mod = 1000000000+7;\nint N;\nchar field[210];\nll dp[210][210][210];\n\nll dfs(int pos,int u,int d){\n  if(dp[pos][u][d]>=0)return dp[pos][u][d];\n  ll res = 0;\n  if(pos == N){\n    if(u == 0 && d == 0)res = 1;\n  }\n  else{\n    if(field[pos] == '-')res = dfs(pos+1,u,d);\n    else if(field[pos]=='U'){\n      // ここに割り当て可能なのは、ここより下にあるDと、ここより上にあるUのうちどれかひとつ\n      if(u>0)res = (res + (dfs(pos+1,u-1+1,d)*u)%mod )%mod;\n      // ここで割り当てるDは下にあるDのうちどれか一つ\n      res = (res + (dfs(pos+1,u+1,d+1))%mod)%mod;\n    }\n    else if(field[pos]=='D'){\n      // ここに割り当て可能なのは、ここより下にあるDと、ここより上にあるU\n      // このdは消化されたものとして扱う\n      if(d>0){\n        // 今回のパターンは、どれに割り当てられたかで場合分けが必要\n        if(u>0)res = (res + (dfs(pos+1,u-1,d-1)*u)%mod)%mod;\n        res = (res + (dfs(pos+1,u,d))%mod)%mod;\n        res = (res * d) % mod;\n      }\n    }\n  }\n  return dp[pos][u][d] = res;\n}\n\nint main(){\n\n  cin>>N;\n  for(int i=0;i<N;i++)cin>>field[i];\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,0)<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nint d[212][212],n,M=1e9+7,i,j,a,*b;main(){std::cin>>n;char c;**d=1;for(i=0;std::cin>>c;++i)for(j=0;a=d[i][j],b=d[i+1],j<n;j++)if(c&8)b[j]=a;else if(c&1)(b[j]+=a*j%M)%=M,(b[j+1]+=a)%=M;else(b[j]+=a*j%M)%=M,(b[j-1]+=a*j*j%M)%=M;std::cout<<*d[n]<<\"\\n\";}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\nconst int BASE = 200;\n\nint add(int x,int y)\n{\n    return (x + y)%MOD;\n}\n\nint sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\nint mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\nint dp[201][201];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vs s(n);\n    rep(i,n){\n        cin >> s[i];\n    }\n    dp[0][0] = 1;\n    rep(i,n){\n        rep(j,i+1){\n            if(!dp[i][j]) continue;\n            if(s[i] == \"U\"){\n                dp[i+1][j] = add(dp[i+1][j],dp[i][j]);\n                dp[i+1][j+1] = add(dp[i+1][j+1],mul(dp[i][j],i-j));\n            }else if(s[i] == \"D\"){\n                dp[i+1][j+1] = add(dp[i+1][j+1],mul(dp[i][j],i-j));\n                dp[i+1][j+2] = add(dp[i+1][j+2],mul(dp[i][j],mul(i-j,i-j)));\n            }else{\n                dp[i+1][j+1] = add(dp[i+1][j+1],dp[i][j]);\n            }\n        }\n    }\n    cout << dp[n][n] << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst long long int MOD = 1000000007LL;\nlong long int dp[210][210];\nint main() {\n  int N; cin >> N;\n\n  dp[0][0] = 1;\n  for(int i=0; i<N; i++) {\n    char c; cin >> c;\n    for(int j=0; j<=i+1; j++) { \n      if(c == '-') {\n        dp[i+1][j] = dp[i][j];\n      }\n      else {\n        if(c == 'D') {\n          (dp[i+1][j] += dp[i][j] * j) %= MOD;\n        }\n\n        int is_u = (c == 'U');\n        (dp[i+1][j] += dp[i][j     - is_u]) %= MOD;\n        (dp[i+1][j] += dp[i][j + 1 - is_u] * (j + 1 - is_u)) %= MOD;\n      }\n    }\n  }\n\n  for(int i=1; i<=N; i++) {\n    for(int j=0; j<=N; j++) {\n      cout << dp[i][j] << \" \";\n    }\n    cout << endl;\n  }\n\n  \n  cout << dp[N][0] << endl;\n  return 0;\n}\n\n/*\n5\nU\nU\n-\nD\nD\n1 0 0 0 0 0 \n1 0 0 0 0 0 \n1 0 0 0 0 0 \n0 1 0 0 0 0 \n0 2 1 0 0 0 \n0\n\n3\n-\nU\nD\n1 0 0 0 \n1 0 0 0 \n0 1 0 0 \n0\n\n*/\n\n8\nU\nD\nD\nD\nD\nD\nD\nD\n0 1 0 0 0 0 0 0 0 \n1 2 0 0 0 0 0 0 0 \n3 4 0 0 0 0 0 0 0 \n7 8 0 0 0 0 0 0 0 \n15 16 0 0 0 0 0 0 0 \n31 32 0 0 0 0 0 0 0 \n63 64 0 0 0 0 0 0 0 \n127 128 0 0 0 0 0 0 0 \n127\n\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nconst size_t SIZE = 210;\nconst ll mod = 1e9 + 7;\n\n// space, people to down\nll dp_buf[2][SIZE];\nll *dp[] = { dp_buf[0], dp_buf[1] };\n\nint main() {\n    ll N;\n    cin >> N;\n    string S(N, '.');\n    for (int i = 0; i < N; i++) {\n        char c;\n        cin >> c;\n        S[i] = c;\n    }\n\n    dp[0][0] = 1;\n    for (ll i = 0; i < N; i++) {\n        fill(dp[1], dp[1] + SIZE, 0);\n        for (ll j = 0; j <= i; j++) {\n            if (S[i] == '-') {\n                dp[1][j] = dp[0][j];\n            } else if (S[i] == 'D') {\n                if (j == 0) continue;\n                (dp[1][j] += j * dp[0][j] % mod) %= mod;\n                if (0 < j) (dp[1][j - 1] += j * j * dp[0][j]) %= mod;\n            } else {\n                (dp[1][j + 1] += dp[0][j]) %= mod;\n                if (0 < j) (dp[1][j] += j * dp[0][j] % mod) %= mod;\n            }\n        }\n        swap(dp[0], dp[1]);\n    }\n\n    cout << dp[0][0] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\nint main() {\n#ifdef _WIN32\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0); // cin??¨cout?????£????????????\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\tll n; cin >> n;\n\tvector<char> c(n); REP(i, n) cin >> c[i];\n\n\t// dp[0~i???][??°????????????????????????????£???°][??°????????????????????????????£???°]\n\tvector<vvl> dp(n+1, vvl(n+1, vl(n+1, 0))); dp[0][0][0] = 1;\n\tll mod = TEN(9) + 7;\n\tREP(i, n) REP(j, n) REP(k, n) {\n\t\tif (c[i] == '-') {\n\t\t\t(dp[i+1][j][k] += dp[i][j][k]) %= mod;\n\t\t}  else if (c[i] == 'U') {\n\t\t\t(dp[i+1][j+1][k+1] += dp[i][j][k]) %= mod;          // ????????§?????????????????£?????????????????°??????????????´???\n\t\t\tif(j!=0) (dp[i+1][j][k] += dp[i][j][k] * j) %= mod; // ????????§?????????????????£?????????????????°??????????????´???\n\t\t} else if (c[i] == 'D' && k > 0){\n\t\t\t(dp[i+1][j][k] += dp[i][j][k] * k) %= mod;                  // ????????§?????????????????£?????????????????°??????????????´???\n\t\t\tif(j!=0) (dp[i+1][j-1][k-1] += dp[i][j][k] * k * j) %= mod; // ????????§?????????????????£?????????????????°??????????????´???\n\t\t}\n\t}\n\n\tcout << dp[n][0][0] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  Int n;\n  cin>>n;\n  string s(n,'-');\n  for(Int i=0;i<n;i++) cin>>s[i];\n  static Int dp[222][222];\n  memset(dp,0,sizeof(dp));\n  dp[0][0]=1;\n  const Int MOD=1000000007;\n  for(Int i=0;i<n;i++){\n    for(Int j=0;j<=n;j++){\n      if(s[i]=='-'){\n\tdp[i+1][j]+=dp[i][j];\n\tdp[i+1][j]%=MOD;\n      }\n      if(s[i]=='D'){\n\tif(j){\n\t  dp[i+1][j-1]+=(dp[i][j]*j%MOD)*j%MOD;\n\t  dp[i+1][j-1]%=MOD;\n\t}\n\tdp[i+1][j]+=dp[i][j]*j%MOD;\n\tdp[i+1][j]%=MOD;\n      }\n      if(s[i]=='U'){\n\tdp[i+1][j]+=dp[i][j]*j%MOD;\n\tdp[i+1][j]%=MOD;\n\t  \n\tdp[i+1][j+1]+=dp[i][j];\n\tdp[i+1][j+1]%=MOD;\n      }\n    }\n  }\n  cout<<dp[n][0]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\ncnt=0;\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i+1][j-cnt]+=dp[i][j-cnt]*(j-cnt);\n      if(j)dp[i+1][j-1-cnt]+=dp[i][j-cnt]*(j-cnt)*(j-cnt);\n      dp[i+1][j-cnt]%=Prime;\n      if(j)dp[i+1][j-1-cnt]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1][j+1-cnt]+=dp[i][j-cnt];\n      dp[i+1][j-cnt]+=dp[i][j-cnt]*(j-cnt);\n      dp[i+1][j+1-cnt]%=Prime;\n      dp[i+1][j-cnt]%=Prime;\n    }else{\n      cnt++;\n    }\n  }}\n  printf(\"%d\\n\",dp[i][0]);\n  return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst long long int MOD = 1000000007LL;\nlong long int dp[210][210];\nint main() {\n  int N; cin >> N;\n\n  dp[0][0] = 1;\n  for(int i=0; i<N; i++) {\n    char c; cin >> c;\n    for(int j=0; j<=i+1; j++) { \n      if(c == '-') {\n        dp[i+1][j] = dp[i][j];\n      }\n      else {\n        if(c == 'D') {\n          (dp[i+1][j] += dp[i][j] * j) %= MOD;\n        }\n        else {\n          dp[i+1][j] = 1;\n        }\n\n        int is_u = (c == 'U');\n        long long int add = 0;\n        (add += dp[i][j     - is_u]) %= MOD;\n        (add += dp[i][j + 1 - is_u] * (j + 1 - is_u)) %= MOD;\n\n        (dp[i+1][j] *= add) %= MOD;\n      }\n    }\n  }\n\n  for(int i=1; i<=N; i++) {\n    for(int j=0; j<=N; j++) {\n      cout << dp[i][j] << \" \";\n    }\n    cout << endl;\n  }\n\n  \n  cout << dp[N][0] << endl;\n  return 0;\n}\n\n/*\n5\nU\nU\n-\nD\nD\n1 0 0 0 0 0 \n1 0 0 0 0 0 \n1 0 0 0 0 0 \n0 1 0 0 0 0 \n0 2 1 0 0 0 \n0\n\n3\n-\nU\nD\n1 0 0 0 \n1 0 0 0 \n0 1 0 0 \n0\n\n*/\n\n8 \nU\nD\nD\nD\nD\nD\nD\nD\n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n; cin >> n;\n    vector<ll> a;\n    rep(i, n) {\n        char c; cin >> c;\n        if (c == 'U') {\n            a.pb(0);\n        } else if (c == 'D') {\n            a.pb(1);\n        }\n    }\n\n    n = a.size();\n    ll dp[n+1][n+1];\n    rep(i, n+1) rep(j, n+1) \n        dp[i][j] = 0;\n    dp[0][0] = 1;\n\n    rep(i, n) rep(j, n) {\n        if (a[i] == 0) {\n            // keep\n            (dp[i+1][j+1] += dp[i][j]) %= mo;\n            // load\n            (dp[i+1][j+0] += dp[i][j] * j) %= mo;\n        } else {\n            // use\n            (dp[i+1][j+0] += dp[i][j] * j) %= mo;\n            // double use\n            (dp[i+1][j-1] += dp[i][j] * j * j) %= mo;\n        }\n    }\n    cout << dp[n][0] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nll n, dp[222][222];\nstring s;\n\nint main()\n{\n\tMS(dp, 0);\n\tcin >> n;\n\tREP(i, n)\n\t{\n\t\tchar c; cin >> c;\n\t\tif (c != '-') s += c;\n\t}\n\tn = s.size();\n\tdp[0][0] = 1;\n\tREP(i, n)\n\t{\n\t\tif (s[i] == 'U')\n\t\t{\n\t\t\tREP(j, n + 1)\n\t\t\t{\n\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\tdp[i + 1][j + 1] %= MOD;\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j;\n\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREP(j, n + 1)\n\t\t\t{\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j;\n\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t\tdp[i + 1][j - 1] += dp[i][j] * j* j;\n\t\t\t\tdp[i + 1][j - 1] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[201][201];\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  string c;\n\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  dp[0][0]=1;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=n;j++){\n      if(c[i]=='U'){\n        dp[i+1][j]+=dp[i][j]*j;\n        dp[i+1][j+1]+=dp[i][j];\n        dp[i+1][j]%=MOD;\n        dp[i+1][j+1]%=MOD;\n      }\n      else if(c[i]=='D'){\n        if(j-1>=0)dp[i+1][j-1]+=dp[i][j]*j*j;\n        dp[i+1][j]+=dp[i][j]*j;\n        dp[i+1][j]%=MOD;\n        if(j-1>=0)dp[i+1][j-1]%=MOD;\n      }\n      else if(c[i]=='-'){\n        dp[i+1][j]=dp[i][j];\n        dp[i+1][j]%=MOD;\n      }\n    }\n  }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll memo[200][201][201];\nll sumu=0,sumd=0;\nll acm_u[200];\nll acm_d[200];\nstring t=\"\";\nll n;\n\nll dfs(ll pos, ll tsukatta, ll okeru) {\n\tif(pos==n) {\n\t\tif(tsukatta==0&&okeru==0) return 1;\n\t\telse return 0;\n\t}\n\tif(memo[pos][tsukatta][okeru]!=-1) return memo[pos][tsukatta][okeru];\n\tif(t[pos]=='U') {\n\t\tll nokori_u=acm_u[pos]-(pos-((sumd-acm_d[pos])+tsukatta))-1;\n\t\tll nokori_d=acm_d[pos]-tsukatta;\n\t\tll ret=0;\n\t\tif(nokori_u>0) ret+=nokori_u*dfs(pos+1,tsukatta,okeru);\n\t\tif(nokori_d>0) ret+=dfs(pos+1,tsukatta+1,okeru+1);\n\t\treturn memo[pos][tsukatta][okeru]=ret%MOD;\n\t} else {\n\t\tll nokori_u=acm_u[pos]-(pos-((sumd-acm_d[pos])+tsukatta));\n\t\tll nokori_d=acm_d[pos]-tsukatta;\n\t\tif(okeru==0) return 0;\n\t\tll ret=0;\n\t\tif(nokori_u>0) ret+=nokori_u*dfs(pos+1,tsukatta-1,okeru-1);\n\t\tif(nokori_d>0) ret+=dfs(pos+1,tsukatta,okeru);\n\t\treturn memo[pos][tsukatta][okeru]=(ret*okeru)%MOD;\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tvector<char> c(n);\n\tREP(i,n) cin>>c[i];\n\tREP(i,n) if(c[i]!='-') t+=c[i];\n\tn =(ll)t.size();\n\tREP(i,n) {\n\t\tif(t[i]=='U') sumu++;\n\t\tif(t[i]=='D') sumd++;\n\t}\n\tREP(i,200) REP(j,201) REP(k,201) memo[i][j][k]=-1;\n\tREP(i,n) {\n\t\tif(t[i]=='U') acm_u[i]++;\n\t\tif(i>0) acm_u[i]+=acm_u[i-1];\n\t}\n\tfor(ll i=n-1; i>=0; i--) {\n\t\tif(t[i]=='D') acm_d[i]++;\n\t\tif(i<n-1) acm_d[i]+=acm_d[i+1];\n\t}\n\tcout<<dfs(0,0,0)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"vector\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"algorithm\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<long long int>>dp(N + 1, vector<long long int>(N + 1));\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == '-') {\n\t\t\tfor (int j = 0; j <= N; j++)dp[i][j] = dp[i - 1][j];\n\t\t}\n\t\telse if (c == 'D') {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tdp[i][j - 1] += dp[i - 1][j] * j*j;\n\t\t\t\tdp[i][j - 1] %= MOD;\n\t\t\t}\n\t\t\tfor (int j = 0; j <= N; j++) {\n\t\t\t\tdp[i][j] += dp[i - 1][j] * j;\n\t\t\t\tdp[i][j] %= MOD;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j <= N; j++) {\n\t\t\t\tdp[i][j] += dp[i - 1][j] * j;\n\t\t\t\tdp[i][j] %= MOD;\n\t\t\t}\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tdp[i][j + 1] += dp[i - 1][j];\n\t\t\t\tdp[i][j] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[N][0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\ntemplate<ll MOD>\nstruct modint {\n    ll x;\n    modint(): x(0) {}\n    modint(ll y) : x(y>=0 ? y%MOD : y%MOD+MOD) {}\n    static constexpr ll mod() { return MOD; }\n    // e乗\n    modint pow(ll e) {\n        ll a = 1, p = x;\n        while(e > 0) {\n            if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n            else {a = (a*p) % MOD; e--;}\n        }\n        return modint(a);\n    }\n    modint inv() const {\n        ll a=x, b=MOD, u=1, y=1, v=0, z=0;\n        while(a) {\n            ll q = b/a;\n            swap(z -= q*u, u);\n            swap(y -= q*v, v);\n            swap(b -= q*a, a);\n        }\n        return z;\n    }\n    // Comparators\n    bool operator <(modint b) { return x < b.x; }\n    bool operator >(modint b) { return x > b.x; }\n    bool operator<=(modint b) { return x <= b.x; }\n    bool operator>=(modint b) { return x >= b.x; }\n    bool operator!=(modint b) { return x != b.x; }\n    bool operator==(modint b) { return x == b.x; }\n    // Basic Operations\n    modint operator+(modint r) const { return modint(*this) += r; }\n    modint operator-(modint r) const { return modint(*this) -= r; }\n    modint operator*(modint r) const { return modint(*this) *= r; }\n    modint operator/(modint r) const { return modint(*this) /= r; }\n    modint &operator+=(modint r) {\n        if((x += r.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint &operator-=(modint r) {\n        if((x -= r.x) < 0) x += MOD;\n        return *this;\n    }\n    modint &operator*=(modint r) {\n    #if !defined(_WIN32) || defined(_WIN64)\n        x = x * r.x % MOD; return *this;\n    #endif\n        unsigned long long y = x * r.x;\n        unsigned xh = (unsigned) (y >> 32), xl = (unsigned) y, d, m;\n        asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (MOD)\n        );\n        x = m;\n        return *this;\n    }\n    modint &operator/=(modint r) { return *this *= r.inv(); }\n    // increment, decrement\n    modint operator++() { x++; return *this; }\n    modint operator++(signed) { modint t = *this; x++; return t; }\n    modint operator--() { x--; return *this; }\n    modint operator--(signed) { modint t = *this; x--; return t; }\n    // 平方剰余のうち一つを返す なければ-1\n    friend modint sqrt(modint a) {\n        if(a == 0) return 0;\n        ll q = MOD-1, s = 0;\n        while((q&1)==0) q>>=1, s++;\n        modint z=2;\n        while(1) {\n            if(z.pow((MOD-1)/2) == MOD-1) break;\n            z++;\n        }\n        modint c = z.pow(q), r = a.pow((q+1)/2), t = a.pow(q);\n        ll m = s;\n        while(t.x>1) {\n            modint tp=t;\n            ll k=-1;\n            FOR(i, 1, m) {\n                tp *= tp;\n                if(tp == 1) { k=i; break; }\n            }\n            if(k==-1) return -1;\n            modint cp=c;\n            REP(i, m-k-1) cp *= cp;\n            c = cp*cp, t = c*t, r = cp*r, m = k;\n        }\n        return r.x;\n    }\n\n    template<class T>\n    friend modint operator*(T l, modint r) { return modint(l) *= r; }\n    template<class T>\n    friend modint operator+(T l, modint r) { return modint(l) += r; }\n    template<class T>\n    friend modint operator-(T l, modint r) { return modint(l) -= r; }\n    template<class T>\n    friend modint operator/(T l, modint r) { return modint(l) /= r; }\n    template<class T>\n    friend bool operator==(T l, modint r) { return modint(l) == r; }\n    template<class T>\n    friend bool operator!=(T l, modint r) { return modint(l) != r; }\n    // Input/Output\n    friend ostream &operator<<(ostream& os, modint a) { return os << a.x; }\n    friend istream &operator>>(istream& is, modint &a) { \n        is >> a.x;\n        a.x = ((a.x%MOD)+MOD)%MOD;\n        return is;\n    }\n    friend string to_frac(modint v) {\n        static map<ll, PII> mp;\n        if(mp.empty()) {\n            mp[0] = mp[MOD] = {0, 1};\n            FOR(i, 2, 1001) FOR(j, 1, i) if(__gcd(i, j) == 1) {\n                mp[(modint(i) / j).x] = {i, j};\n            }\n        }\n        auto itr = mp.lower_bound(v.x);\n        if(itr != mp.begin() && v.x - prev(itr)->first < itr->first - v.x) --itr;\n        string ret = to_string(itr->second.first + itr->second.second * ((int)v.x - itr->first));\n        if(itr->second.second > 1) {\n            ret += '/';\n            ret += to_string(itr->second.second);\n        }\n        return ret;\n    }\n};\nusing mint = modint<1000000007>;\n\nmint dp[205][205];\nint main(void) {\n    ll n;\n    cin >> n;\n    vector<char> v;\n    REP(i, n) {\n        char c;\n        cin >> c;\n        if(c != '-') v.push_back(c);\n    }\n    n = v.size();\n\n    dp[0][0] = 1;\n    REP(i, n) REP(j, n) {\n        if(v[i] == 'U') {\n            // 右が必ず保留\n            if(j+1 <= i+1) dp[i+1][j+1] += dp[i][j] * (i-j); // 左をマッチング\n            if(j <= i+1) dp[i+1][j] += dp[i][j]; // 左も保留\n        } else {\n            // 右は必ずマッチング\n            if(j+1 <= i+1) dp[i+1][j+1] += dp[i][j] * (i-j); // 左は保留\n            if(j+2 <= i+1) dp[i+1][j+2] += dp[i][j] * (i-j)*(i-j); // 左もマッチング\n        }\n    }\n\n    cout << dp[n][n] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, m, n) for(int(i) = (int)(m); i < (int)(n); ++i)\n#define rep2(i, m, n) for(int(i) = (int)(n)-1; i >= (int)(m); --i)\n#define REP(i, n) rep(i, 0, n)\n#define REP2(i, n) rep2(i, 0, n)\n#define all(hoge) (hoge).begin(), (hoge).end()\n#define en '\\n'\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate <class T>\nusing vvec = vector<vec<T>>;\ntypedef pair<ll, ll> P;\nconstexpr long long INF = 1LL << 60;\nconstexpr int INF_INT = 1 << 25;\nconstexpr long long MOD = (ll)1e9 + 7;\n//constexpr long long MOD = 998244353LL;\nusing ld = long double;\nstatic const ld pi = 3.141592653589793L;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstruct Edge {\n    ll to, rev;\n    long double cap;\n    Edge(ll _to, long double _cap, ll _rev) {\n        to = _to;\n        cap = _cap;\n        rev = _rev;\n    }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvoid add_edge(Graph &G, ll from, ll to, long double cap, bool revFlag,\n              long double revCap) {\n    G[from].push_back(Edge(to, cap, (ll)G[to].size()));\n    if(revFlag)\n        G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));\n}\n\ntemplate <int mod>\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod)\n            x -= mod;\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod)\n            x -= mod;\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt &p) const { return x == p.x; }\n\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while(n > 0) {\n            if(n & 1)\n                ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt<mod>(t);\n        return (is);\n    }\n\n    static int get_mod() { return mod; }\n};\n\nusing mint = ModInt<MOD>;\n\nmint dp[210][210];\nvoid solve() {\n    ll n;\n    cin >> n;\n    vec<ll> a;\n    REP(i, n) {\n        string s;\n        cin >> s;\n        if(s == \"U\")\n            a.push_back(1);\n        else if(s == \"D\")\n            a.push_back(0);\n    }\n    n = a.size();\n\n    dp[0][0] = 1; //i人目まで見て、j人保留した時\n\n    REP(i, n) {\n        REP(j, n) {\n            if(a[i]) {\n                dp[i + 1][j + 1] += dp[i][j]; //保留\n                dp[i + 1][j] += dp[i][j] * j; //i番目にj人のどれかを当てはめる\n            } else {\n                dp[i + 1][j] += dp[i][j] * j; //i番目にj人の誰かを当てはめる\n                if(j > 0)\n                    dp[i + 1][j - 1] += dp[i][j] * j * j; //i番目にj人の誰かを当てはめる かつ i人目をjこの空席のどれかに当てはめる\n            }\n        }\n    }\n    cout << dp[n][0] << en;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    solve();\n    /*\n    ll t;\n    cin >> t;\n    REP(i, t)\n    solve();\n    */\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define rnd(d) (ll)((double)(d) + (d >= 0 ? 0.5 : -0.5))\n#define floorsqrt(x) ((ll)sqrt((double)x) + ((ll)sqrt((double)x) * (ll)sqrt((double)x) <= (ll)(x) ? 0 : -1))\n#define ceilsqrt(x) ((ll)sqrt((double)x) + ((ll)x <= (ll)sqrt((double)x) * (ll)sqrt((double)x) ? 0 : 1))\n#define ceildiv(a, b) ((ll)(a) / (ll)(b) + ((ll)(a) % (ll)(b) == 0 ? 0 : 1))\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n\n/*******************************************************/\n\nnamespace mod_op {\n\n\tconst ll MOD = (ll)1e9 + 7;\n\n\tclass Extended_Euclid {\n\tprivate:\n\t\tll m, n;\n\t\tvvll mx_multiply(vvll mx1, vvll mx2) {\n\t\t\tvvll ret(mx1.size(), vll(mx2[0].size(), 0));\n\t\t\tLoop(i, mx1.size()) {\n\t\t\t\tLoop(j, mx1[0].size()) {\n\t\t\t\t\tLoop(k, mx2[0].size()) {\n\t\t\t\t\t\tret[i][j] += mx1[i][k] * mx2[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\tpublic:\n\t\t// solve x, y s.t. mx + ny = gcd(m,n)\n\t\tll x, y, gcd;\n\t\tExtended_Euclid(ll M, ll N) {\n\t\t\tm = M;\n\t\t\tn = N;\n\t\t\tvll r(100), k(100);\n\t\t\tbool swapflag = false, m_negflag = false, n_negflag = false;\n\t\t\tif (m < n) { swap(m, n); swapflag = true; }\n\t\t\tif (m < 0) { m *= -1; m_negflag = true; }\n\t\t\tif (n < 0) { n *= -1; n_negflag = true; }\n\t\t\tr[0] = m;\n\t\t\tr[1] = n;\n\t\t\tint h = 1;\n\t\t\twhile (1) {\n\t\t\t\tk[h - 1] = r[h - 1] / r[h];\n\t\t\t\tr[h + 1] = r[h - 1] % r[h];\n\t\t\t\tif (r[h + 1] == 0) break;\n\t\t\t\th++;\n\t\t\t}\n\t\t\tgcd = r[h];\n\t\t\tvvll mx1 = { { 0, 1 },{ 1, (-1) * k[h - 1] } };\n\t\t\tLoopr(i, h - 1) {\n\t\t\t\tvvll mx2 = { { 0, 1 },{ 1, (-1) * k[i] } };\n\t\t\t\tmx1 = mx_multiply(mx1, mx2);\n\t\t\t}\n\t\t\tx = mx1[0][0];\n\t\t\ty = mx1[0][1];\n\t\t\tif (n_negflag) { n *= -1; y *= -1; }\n\t\t\tif (m_negflag) { m *= -1; x *= -1; }\n\t\t\tif (swapflag) { swap(m, n); swap(x, y); }\n\t\t}\n\t};\n\n\tclass modll {\n\tprivate:\n\t\tll val;\n\t\tinline ll modify(ll x) { ll ret = x % MOD; if (ret < 0) ret += MOD; return ret; }\n\t\tinline ll inv(ll x) { if (x == 0) return 1 / x; Extended_Euclid ee(x, -MOD); return modify(ee.x); }\n\tpublic:\n\t\tmodll(ll init = 0) { val = modify(init); return; }\n\t\tmodll(const modll& another) { val = another.val; return; }\n\t\tinline modll& operator=(const modll &another) { val = another.val; return *this; }\n\t\tinline modll operator+(const modll &x) { return (val + x.val) % MOD; }\n\t\tinline modll operator-(const modll &x) { return (val - x.val) % MOD; }\n\t\tinline modll operator*(const modll &x) { return (val * x.val) % MOD; }\n\t\tinline modll operator/(const modll &x) { return (val * inv(x.val)) % MOD; }\n\t\tinline modll& operator+=(const modll &x) { val = (val + x.val) % MOD; return *this; }\n\t\tinline modll& operator-=(const modll &x) { val = (val - x.val) % MOD; return *this; }\n\t\tinline modll& operator*=(const modll &x) { val = (val * x.val) % MOD; return *this; }\n\t\tinline modll& operator/=(const modll &x) { val = (val * inv(x.val)) % MOD; return *this; }\n\t\tfriend inline istream& operator >> (istream &is, modll& x) { is >> x.val; return is; }\n\t\tfriend inline ostream& operator << (ostream &os, modll& x) { os << x.val; return os; }\n\t\tll get_val() { return val; }\n\t};\n\n\tmodll pow(modll n, ll p) {\n\t\tmodll ret;\n\t\tif (p == 0) ret = 1;\n\t\telse if (p == 1) ret = n;\n\t\telse {\n\t\t\tret = pow(n, p / 2);\n\t\t\tret *= ret;\n\t\t\tif (p % 2 == 1) ret *= n;\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nusing namespace mod_op;\ntypedef vector<modll> vmodll;\ntypedef vector<vector<modll>> vvmodll;\n\nint main() {\n\tconst int N = 6;\n\tint n; cin >> n;\n\tvector<char> a(n);\n\tLoop(i, n) cin >> a[i];\n\tvvmodll dp(N, vmodll(N, 0));\n\tdp[0][0] = 1;\n\tLoop(i, n) {\n\t\tvvmodll dpbuf(N, vmodll(N, 0));\n\t\tLoop(j, N) {\n\t\t\tLoop(k, N) {\n\t\t\t\tif (a[i] == 'U') {\n\t\t\t\t\tif (j > 0) dpbuf[j][k] += dp[j][k] * j;\n\t\t\t\t\tif (j + 1 < N && k + 1 < N) dpbuf[j + 1][k + 1] += dp[j][k];\n\t\t\t\t}\n\t\t\t\telse if (a[i] == 'D') {\n\t\t\t\t\tif (j - 1 >= 0 && k - 1 >= 0) dpbuf[j - 1][k - 1] += dp[j][k] * j * k;\n\t\t\t\t\tif (k > 0) dpbuf[j][k] += dp[j][k] * k;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdpbuf[j][k] = dp[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp = dpbuf;\n\t}\n\tcout << dp[0][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T1, class T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"[\";\n    for (auto it = mp.begin(); it != mp.end(); ++it) {\n        if (it != mp.begin()) {\n            os << \", \";\n        }\n        os << *it;\n    }\n    return os << \"]\";\n}\n\n// edit\n\nint add(ll x, ll y) {\n    return (x + y) % MOD;\n}\n\nint mul(ll x, ll y) {\n    return (x * y) % MOD;\n}\n\nvoid print_dp(vector<vector<ll>> dp) {\n    int n = dp.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << dp[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << \"---------------------------\" << endl;\n}\n\nint calc(vector<char> c) {\n    int n = c.size();\n\n    vector<vector<ll>> dp(n + 1, vector<ll>(n + 1)), dp_new(n + 1, vector<ll>(n + 1));\n    dp[0][0] = 1;\n//    print_dp(dp);\n\n    for (int i = 0; i < n; ++i) {\n        for (int p = 0; p < n; ++p) {\n            for (int q = 0; q < n; ++q) {\n                if (c[i] == 'U') {\n                    {\n                        dp_new[p][q] += p * dp[p][q] % MOD;\n                        dp_new[p][q] %= MOD;\n                    }\n                    {\n                        dp_new[p + 1][q + 1] += dp[p][q];\n                        dp_new[p + 1][q + 1] %= MOD;\n                    }\n                }\n\n                if (c[i] == 'D') {\n                    if (p > 0 && q > 0) {\n                        dp_new[p - 1][q - 1] += p * q * dp[p][q] % MOD;\n                        dp_new[p - 1][q - 1] %= MOD;\n                    }\n                    {\n                        dp_new[p][q] += q * dp[p][q] % MOD;\n                        dp_new[p][q] %= MOD;\n                    }\n                }\n            }\n        }\n\n        swap(dp, dp_new);\n\n        for (int j = 0; j < dp_new.size(); ++j) {\n            fill(all(dp_new[j]), 0);\n        }\n//        print_dp(dp);\n    }\n\n    return (int) (dp[0][0] % MOD);\n\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<char> c;\n    REP(i, n) {\n        char tmp;\n        cin >> tmp;\n        if (tmp != '-') {\n            c.push_back(tmp);\n        }\n    }\n\n    int ans = calc(c);\n    cout << ans << endl;\n\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define each(it,n) for(__typeof((n).begin()) it=(n).begin();it!=(n).end();++it)\n\nusing namespace std;\n\ntypedef long long ll;\n\nll MOD = 1000000007;\nstring str;\n\nll memo[205][205][205];\n\nll rec(ll index, ll up, ll down) {\n    if (up < 0 || down < 0) return 0;\n    if (index == 0) return up == 0 && down == 0;\n    index--;\n\n    if (memo[index][up][down] >= 0) return memo[index][up][down];\n    \n    long long ans = 0;\n    if (str[index] == 'U') {\n        ans += rec(index, up, down) * up;\n        ans += rec(index, up - 1, down - 1);\n    } else if (str[index] == 'D') {\n        ans += rec(index, up + 1, down + 1) * (up + 1) * (down + 1);\n        ans += rec(index, up, down) * down;\n    } else {\n        ans = rec(index, up, down);\n    }\n    //cerr << index << \" \" << up << \" \" << down << \" \" << ans << endl;\n    return memo[index][up][down] = ans % MOD;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    rep(i, 205) rep(j, 205) rep(k, 205) memo[i][j][k] = -1;\n\n    rep(i, n) {\n        char c;\n        cin >> c;\n        str += c;\n    }\n\n    cout << rec(n, 0, 0) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\n\nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nmap< vector<int> , ll > dp[201][201];\nstring S;\n\nll rec(int dep,int cnt,vector<int> v){\n  for(int i=0;i<(int)v.size();i++)\n    if(v[i]<0)return 0;\n  if(dep==(int)S.size())return 1;\n  if(dep>0&&S[dep-1]=='U')cnt++;\n  if(dp[ dep ][ cnt ].count(v) )return dp[dep][cnt][v];\n  ll res=0;\n  if( (v.empty() || v[0]>0) && cnt> 0){\n    vector<int> next=v;\n    for(int i=0;i<(int)v.size();i++)next[i]--;\n    res=add(res, mul(cnt,rec(dep+1,cnt-1,next) ) );\n  }\n  for(int i=0;i<(int)v.size();i++){\n\n    vector<int> next;\n    for(int j=0;j<(int)v.size();j++){\n      if(i!=j)next.push_back(v[j]-1);\n    }\n    sort(next.begin(),next.end());\n    if(!next.empty() && next[0]<0)continue;    \n    res=add(res, rec(dep+1,cnt,next) );\n  }\n  return dp[dep][cnt][v]=res;\n}\n\nint solve(string str){\n  if(str==\"\")return 1;\n  vector<int> vec;\n  int cnt=0;\n  for(int i=0;i<(int)str.size();i++){\n    if(str[i]=='D')vec.push_back(i-1);\n  }\n  S=str;\n  return rec( 0, cnt, vec );\n}\n\nint main(){\n  int n;\n  cin>>n;\n  string str=\"\";\n  for(int i=0;i<n;i++){\n    char ch;\n    cin>>ch;\n    if(ch=='-')continue;\n    str+=ch;\n  }\n  cout<<solve(str)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<long long mod>\nclass modint{\nprivate:\n  long long a;\npublic:\n  constexpr modint(const long long x = 0) noexcept : a(x%mod) {}\n  constexpr long long& value() noexcept { return a; }\n  constexpr const long long& value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint& operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if(a >= mod) a -= mod;\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if(a < rhs.a) a += mod;\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint& operator*=(const modint rhs) noexcept {\n    a = a*rhs.a%mod;\n    return *this;\n  }\n  constexpr modint& operator/=(modint rhs) noexcept {\n    long long k = mod-2;\n    while(k > 0){\n      if(k&1){\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      k /= 2;\n    }\n    return *this;\n  }\n  friend ostream& operator<<(ostream &os, const modint &X){\n    return os << X.a;\n  }\n  friend istream& operator>>(istream &is, modint &X){\n    is >> X.a;\n    X.a %= mod;\n    if(X.a < 0) X.a += mod;\n    return is;\n  }\n};\n\nint main(){\n  using mint = modint<(int)1e9+7>;\n  int n;\n  cin >> n;\n  vector<vector<mint>> dp(n+1,vector<mint>(n+1));\n  dp[0][0] = 1;\n  for(int i = 0; i < n; ++i){\n    vector<vector<mint>> dp_(n+1,vector<mint>(n+1));\n    char c;\n    cin >> c;\n    if(c == '-') continue;\n    for(int j = 0; j <= n; ++j){\n      for(int k = 0; k <= n; ++k){\n        if(c == 'D'){\n          dp_[j][k] += dp[j][k]*j;\n          if(k > 0 and j > 0)\n            dp_[j-1][k-1] += dp[j][k]*j*k;\n        }\n        if(c == 'U'){\n          dp_[j][k] += dp[j][k]*k;\n          if(j < n and k < n)\n            dp_[j+1][k+1] += dp[j][k];\n        }\n      }\n    }\n    swap(dp,dp_);\n  }\n  cout << dp[0][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint n;\nvector<string> ud;\nvector<map<int,LL> >memo;\n//memo[ind][down]\nconst LL p=1000000007;\nLL solve(int ind,int up){\n  if(up<0) return 0;\n  if(ind==n)\n    if(up==0) return 1;\n    else return 0;\n  if(memo[ind].count(up)) return memo[ind][up];\n  if(ud[ind]==\"-\") return solve(ind+1,up);\n  if(ud[ind]==\"U\"){\n    LL answer=(up+1)*solve(ind+1,up+1);\n    answer+=up*solve(ind+1,up);//baton\n    answer%=p;\n    memo[ind][up]=answer;\n  }\n  if(ud[ind]==\"D\"){\n    LL answer=up*solve(ind+1,up-1);\n    answer+=up*solve(ind+1,up);//baton\n    answer%=p;\n    memo[ind][up]=answer;\n  }\n  return memo[ind][up];\n}\n\nint main(void)\n{\n  cin >> n;\n  ud.resize(n);\n  memo.assign(n,map<int,LL>());\n  REP(i,n) cin >> ud[i];\n  cout << solve(0,0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nint main(){\n    int n;cin >> n;\n    vector<char> c;\n    for (int i = 0; i < n; i++) {\n        char cc;cin >> cc;\n        if(cc!='-') c.pb(cc);\n    }\n    n=c.size();\n    vector<vector<LL>> dp(n+1,vector<LL> (n+1,0));\n    dp[0][0]=1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if(c[i]=='D'){\n                if(j) dp[i+1][j-1]=(dp[i+1][j-1]+dp[i][j]*j*j)%mod;\n                dp[i+1][j]=(dp[i+1][j]+dp[i][j]*j)%mod;\n            }\n            else{\n                dp[i+1][j]=(dp[i+1][j]+dp[i][j]*j)%mod;\n                dp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%mod;\n            }\n        }\n    }\n    cout << dp[n][0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) (a).begin(),(a).end()\ntypedef pair<int, int> P;\nconst long long mod = 1000000007;\nint dp[205][205];\nsigned main() {\n\tint n; cin >> n;\n\tstring s;\n\trep(i, n) {\n\t\tchar c; cin >> c;\n\t\tif (c != '-')s.push_back(c);\n\t}\n\tn = s.size();\n\tdp[0][0] = 1;\n\trep(i, n) {\n\t\trep(j, i + 1) {\n\t\t\tif (s[i] == 'U') {\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j;\n\t\t\t\tdp[i + 1][j] %= mod;\n\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\tdp[i + 1][j + 1] %= mod;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j%mod;\n\t\t\t\tdp[i + 1][j] %= mod;\n\t\t\t\tif (j) {\n\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j] * j*j%mod;\n\t\t\t\t\tdp[i + 1][j - 1] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MN = 220;\nconst ll MD = 1e9+7;\n\nint n;\nstring s[MN];\nll dp[MN][MN];\n\nll solve(int i, int j) {\n    if (i == 0) {\n        if (j == 0) return 1;\n        return 0;\n    }\n    if (dp[i][j] != -1) return dp[i][j];\n    ll &res = dp[i][j];\n    if (s[i] == \"-\") {\n        res = solve(i-1, j);\n    } else if (s[i] == \"U\") {\n        res = (solve(i-1, j-1)+j*solve(i-1, j)) % MD;\n    } else {\n        res = ((j+1)*(j+1)*solve(i-1, j+1) + j*solve(i-1, j)) % MD;\n    }\n    return res;\n}\n\nint main() {\n    memset(dp, -1, sizeof(dp));\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> s[i];\n    }\n    cout << solve(n, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n; cin >> n;\n    vector<ll> a;\n    rep(i, n) {\n        char c; cin >> c;\n        if (c == 'U') {\n            a.pb(0);\n        } else if (c == 'D') {\n            a.pb(1);\n        }\n    }\n\n    n = a.size();\n    ll dp[n+1][n+1];\n    rep(i, n+1) rep(j, n+1) \n        dp[i][j] = 0;\n    dp[0][0] = 1;\n\n    rep(i, n) rep(j, n) {\n        if (a[i] == 0) {\n            // keep\n            (dp[i+1][j+1] += dp[i][j]) %= mo;\n            // load\n            (dp[i+1][j+0] += dp[i][j] * j) %= mo;\n        } else {\n            // use\n            (dp[i+1][j+0] += dp[i][j] * j) %= mo;\n            // double use\n            (dp[i+1][j-1] += dp[i][j] * j * j) %= mo;\n        }\n    }\n    cout << dp[n][0] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=1000000007;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b);\n\telse if(arrays[n]==-1) DP[n][a][b]=ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b));\n\telse return DP[n][a][b]=ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b));\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MOD = 1e9 + 7;\nusing fint64 = int_fast64_t;\ntemplate<fint64 MOD>\nstruct ModInt {\n\tfint64 x;\n\tModInt():x(0){}\n\tModInt(fint64 x):\n\t\tx(x>=0?x%MOD:(MOD-(-x)%MOD)%MOD)\n\t\t{}\n\t// 負号\n\tModInt operator -() const{\n\t\treturn ModInt(-x);\n\t}\n\t// 加算\n\tModInt &operator +=(const ModInt &rhs){\n\t\tx+=rhs.x;\n\t\tif(x>=MOD) x-=MOD;\n\t\treturn (*this);\n\t}\n\tModInt operator +(const ModInt &rhs) const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\t// 減算\n\tModInt &operator -=(const ModInt &rhs){\n\t\tx+=MOD-rhs.x;\n\t\tif(x>=MOD) x-=MOD;\n\t\treturn (*this);\n\t}\n\tModInt operator -(const ModInt &rhs) const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\t// 乗算\n\tModInt &operator *=(const ModInt &rhs){\n\t\tx*=rhs.x;\n\t\tif(x>=MOD) x%=MOD;\n\t\treturn (*this);\n\t}\n\tModInt operator *(const ModInt &rhs) const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\t// 除算\n\tModInt &operator /=(const ModInt &rhs){\n\t\t(*this)*=rhs.inverse();\n\t\treturn (*this);\n\t}\n\tModInt operator /(const ModInt &rhs) const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\t// 等号\n\tbool operator ==(const ModInt &rhs){\n\t\treturn x==rhs.x;\n\t}\n\tbool operator !=(const ModInt &rhs){\n\t\treturn x!=rhs.x;\n\t}\n\t// 累乗\n\tModInt pow(fint64 n) const{\n\t\tfint64 tmp=x;\n\t\tfint64 ret=1;\n\t\twhile(n>0){\n\t\t\tif(n&1) ret=ret*tmp%MOD;\n\t\t\ttmp=tmp*tmp%MOD;\n\t\t\tn>>=1ll;\n\t\t}\n\t\treturn ModInt(ret);\n\t}\n\t// 逆元\n\tModInt inverse() const{\n\t\tfint64 a=x,b=MOD,s=1,t=0;\n\t\twhile(b>0){\n\t\t\tfint64 u=a/b;\n\t\t\ta-=u*b;\n\t\t\ts-=u*t;\n\t\t\tswap(a,b);\n\t\t\tswap(s,t);\n\t\t}\n\t\treturn ModInt(s);\n\t}\n\t// 入出力\n\tfriend istream &operator >>(istream &lhs,ModInt<MOD> &rhs){\n\t\tfint64 x; lhs>>x;\n\t\trhs=ModInt<MOD>(x);\n\t\treturn lhs;\n\t}\n\tfriend ostream &operator <<(ostream &lhs,const ModInt<MOD> &rhs){\n\t\treturn lhs<<rhs.x;\n\t}\n};\nusing mint = ModInt<MOD>;\n\n// dp[i][j][k] := i人操作，未定j人，k枠空位\nmint dp[310][310][310];\nint main() {\n\tint n; cin >> n;\n\tvector<char> c;\n\tfor(int i = 0; i < n; ++i) {\n\t\tchar cc; cin >> cc;\n\t\tif(cc != '-') {\n\t\t\tc.push_back(cc);\n\t\t}\n\t}\n\tn = c.size();\n\tdp[0][0][0] = 1;\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j <= n; ++j) {\n\t\t\tfor(int k = 0; k <= n; ++k) {\n\t\t\t\tif(c[i] == 'U') {\n\t\t\t\t\tdp[i + 1][j][k] += dp[i][j][k] * j;\n\t\t\t\t\tdp[i + 1][j + 1][k + 1] += dp[i][j][k];\n\t\t\t\t}\n\t\t\t\tif(c[i] == 'D') {\n\t\t\t\t\tif(j - 1 >= 0 and k - 1 >= 0) dp[i + 1][j - 1][k - 1] += dp[i][j][k] * j * k;\n\t\t\t\t\tdp[i + 1][j][k] += dp[i][j][k] * k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0][0] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nconst int mod = 1000000007;\nint n, a[209], dp[209][209]; string b;\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> b;\n\t\tif (b == \"D\") a[i] = -1;\n\t\tif (b == \"U\") a[i] = 1;\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= i + 1; j++) {\n\t\t\tif (a[i] == 0) dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % mod;\n\t\t\tif (a[i] == -1 && j >= 1) {\n\t\t\t\tdp[i + 1][j] = (dp[i + 1][j] + 1LL * dp[i][j] * j) % mod;\n\t\t\t\tdp[i + 1][j - 1] = (dp[i + 1][j - 1] + 1LL * dp[i][j] * j * j) % mod;\n\t\t\t}\n\t\t\tif (a[i] == 1 && j <= i) {\n\t\t\t\tdp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % mod;\n\t\t\t\tdp[i + 1][j] = (dp[i + 1][j] + 1LL * dp[i][j] * j) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\nint cnt;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\ncnt=0;\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i+1][j-cnt]+=dp[i][j-cnt]*(j-cnt);\n      if(j)dp[i+1][j-1-cnt]+=dp[i][j-cnt]*(j-cnt)*(j-cnt);\n      dp[i+1][j-cnt]%=Prime;\n      if(j)dp[i+1][j-1-cnt]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1][j+1-cnt]+=dp[i][j-cnt];\n      dp[i+1][j-cnt]+=dp[i][j-cnt]*(j-cnt);\n      dp[i+1][j+1-cnt]%=Prime;\n      dp[i+1][j-cnt]%=Prime;\n    }else{\n      cnt++;\n    }\n  }}\n  printf(\"%d\\n\",dp[i][0]);\n  return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=1000000007;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b)%p;\n\telse if(arrays[n]==-1) DP[n][a][b]=ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n\telse return DP[n][a][b]=ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\ntypedef long long ll;\n\n#define MOD 1000000007\n#define MAX_N 200\n\nll dp[MAX_N][MAX_N+1] = {0}; // dp[n][rest U] = ??´????????°\n\nint main() {\n\tint N;\n\tchar v[MAX_N];\n\tchar buf[100];\n\tint sz = 0;\n\tll ans = -1;\n\tint i, j;\n\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; ++i) {\n\t\tscanf(\"%s\", buf);\n\t\tif (buf[0] != '-') v[sz++] = buf[0];\n\t}\n\tN = sz;\n\n\tif (N == 0) {\n\t\tans = 1;\n\t}\n\telse if (v[0] == 'D') {\n\t\tans = 0;\n\t}\n\telse {\n\t\tdp[0][1] = 1; // v[0] : 'U'\n\t\tfor (i = 0; i < N-1; ++i) {\n\t\t\tfor (j = 0; j < N; ++j) {\n\t\t\t\tif (v[i+1] == 'U') {\n\t\t\t\t\tdp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % MOD;\n\t\t\t\t\tif (j >= 1) {\n\t\t\t\t\t\tdp[i+1][j] = (dp[i+1][j] + j * dp[i][j]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { // D\n\t\t\t\t\tif (j >= 1) {\n\t\t\t\t\t\tdp[i+1][j] = (dp[i+1][j] + j * dp[i][j]) % MOD;\n\t\t\t\t\t\tdp[i+1][j-1] = (dp[i+1][j-1] + j * j * dp[i][j]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = dp[N-1][0];\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\nll dp[210][210];\n\nint main(){\n\tll m;\n\tcin >> m;\n\tvector<int> v;\n\tv.push_back(0);\n\tfor(ll i=0;i<m;i++){\n\t\tchar s;\n\t\tcin >> s;\n\t\tif(s=='U'){\n\t\t\tv.push_back(-1);\n\t\t}\n\t\tif(s=='D'){\n\t\t\tv.push_back(1);\n\t\t}\n\t}\n\tint n = v.size()-1;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(v[i]==-1){\n\t\t\t\tdp[i][j] = (dp[i][j]+dp[i-1][j]*j)%mod;\n\t\t\t\tif(j>=1)dp[i][j] = (dp[i][j]+dp[i-1][j-1])%mod;\n\t\t\t}else{\n\t\t\t\tdp[i][j] = (dp[i][j]+dp[i-1][j]*j)%mod;\n\t\t\t\tdp[i][j] = (dp[i][j]+dp[i-1][j+1]*(j+1)*(j+1))%mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 210\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint n;\nchar C[N];\n\nint mem[N][N][N],used[N][N][N];\nint dfs(int idx,int num,int num2){\n  if(num < 0 || num2 < 0) return 0;\n  if(idx == n) return (idx-num == 0) * (num2 == 0);\n  if(used[idx][num][num2]++) return mem[idx][num][num2];\n  int res = 0; \n  if(C[idx] == 'U'){\n    res = dfs(idx+1,num,num2+1);\n    res += num2 * dfs(idx+1,num+1,num2);\n  }\n  if(C[idx] == 'D'){\n    if(idx - num > 0 )res = (idx - num) * num2 * dfs(idx+1,num+2,num2-1);\n    res += (idx - num) * dfs(idx+1,num+1,num2);\n  }\n  return mem[idx][num][num2] = res %mod;\n}\n\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>C[i];\n    if(C[i] == '-')n--,i--;\n  }\n  cout<<dfs(0,0,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long Int;\nconst int MOD = 1000000007;\n\nInt dp[201][201];\n\nint main()\n{\n    int N;\n    char s[256];\n\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) scanf(\"%s\", &s[i]);\n\n    dp[0][0] = 1;\n\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j <= N; j++){\n            if (s[i] == '-'){\n                dp[i + 1][j] += dp[i][j];\n                dp[i + 1][j] %= MOD;\n            }\n            if (s[i] == 'U'){\n                dp[i + 1][j] += dp[i][j] * j;\n                dp[i + 1][j] %= MOD;\n                if (j < N){\n                    dp[i + 1][j + 1] += dp[i][j];\n                    dp[i + 1][j + 1] %= MOD;\n                }\n            }\n            if (s[i] == 'D'){\n                dp[i + 1][j] += dp[i][j] * j;\n                dp[i + 1][j] %= MOD;\n                if (j > 0){\n                    dp[i + 1][j - 1] += dp[i][j] * j * j;\n                    dp[i + 1][j - 1] %= MOD;\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", dp[N][0]);\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long;\nconst i64 MOD = 1e9 + 7;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<char> a(n);\n    for(auto& x : a) cin >> x;\n    vector<i64> dp(n + 1, 0LL);\n    dp[0] = 1LL;\n    for(int i : in(n)) {\n        char c = a[i];\n        if(c == '-') continue;\n        vector<i64> dp_(n + 1, 0LL);\n        if(c == 'D') {\n            for(i64 j : in(i + 2)) {\n                (dp_[j] += dp[j] * j) %= MOD;\n                (dp_[j] += dp[j + 1] * (j + 1) * (j + 1)) %= MOD;\n            }\n        }\n        else {\n            for(i64 j : in(i + 2)) {\n                if(j > 0) (dp_[j] += dp[j - 1]) %= MOD;\n                (dp_[j] += dp[j] * j) %= MOD;\n            }\n        }\n        dp = dp_;\n    }\n    cout << dp[0] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint N;\nstring s,t;\nll dp[202][202];\n\nint main(){\n  cin>>N;\n  rep(i,N){\n    char c;\n    cin>>c;\n    s+=c;\n  }\n  rep(i,N){\n    if(s[i]=='-')continue;\n    t+=s[i];\n  }\n  s=t;\n  N=s.size();\n  dp[0][0]=1;\n  rep(i,N){\n    rep(j,N){\n      if(s[i]=='U'){\n        (dp[i+1][j]+=dp[i][j]*j%mod)%=mod;\n        (dp[i+1][j+1]+=dp[i][j])%=mod;\n      }else if(s[i]=='D'){\n        if(j>0)(dp[i+1][j-1]+=dp[i][j]*j*j%mod)%=mod;\n        (dp[i+1][j]+=dp[i][j]*j)%=mod;\n      }\n    }\n  }\n  cout<<dp[N][0]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll dp[222][222][222];\n\nvoid mod_add(ll &a, ll b){\n\ta += b;\n\ta %= MOD;\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tll n;cin >> n;\n\tdp[0][0][0] = 1;\n\tREP(i, n){\n\t\tchar c;cin >> c;\n\t\tREP(j, 222){\n\t\t\tREP(k, 222){\n\t\t\t\tif(dp[i][j][k] == 0)continue;\n\t\t\t\tif(c == '-'){\n\t\t\t\t\tmod_add(dp[i+1][j][k], dp[i][j][k]);\n\t\t\t\t}\n\t\t\t\telse if(c == 'U'){\n\t\t\t\t\tif(j > 0) {\n\t\t\t\t\t\tmod_add(dp[i+1][j][k], dp[i][j][k] * j % MOD);\n\t\t\t\t\t}\n\t\t\t\t\tmod_add(dp[i+1][j+1][k+1], dp[i][j][k]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(j > 0 && k > 0){\n\t\t\t\t\t\tmod_add(dp[i+1][j-1][k-1], (dp[i][j][k] * j % MOD) * k % MOD);\n\t\t\t\t\t}\n\t\t\t\t\tif(k > 0){\n\t\t\t\t\t\tmod_add(dp[i+1][j][k], dp[i][j][k] * k % MOD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[n][0][0] << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[202][202];\n\nint main(void){\n\n  fill(dp[0],dp[202],0);\n\n  int n;\n  cin >> n;\n\n  string c;\n\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  dp[0][0]=1;\n\n  for(int k=0;k<n;k++){\n    for(int i=0;i<=k;i++){\n      if(c[k]=='-')dp[k+1][i]=dp[k][i];\n      else if(c[k]=='D'){\n        if(i>0){\n          dp[k+1][i-1]+=dp[k][i]*i*i;\n          dp[k+1][i-1]%=MOD;\n        }\n        dp[k+1][i]+=dp[k][i]*i;\n      }\n      else if(c[k]=='U'){\n        dp[k+1][i]+=dp[k][i]*i;\n        dp[k+1][i+1]+=dp[k][i];\n        dp[k+1][i+1]%=MOD;\n      }\n      dp[k+1][i]%=MOD;\n    }\n  }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=1000000007;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=(LL)solve(n-1,a,b)%p;\n\telse if(arrays[n]==-1) DP[n][a][b]=(LL)ans*(LL)((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n\telse return DP[n][a][b]=(LL)ans*(LL)(b*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\n \nconstexpr ll M = 1e9 + 7;\n \nint main() {\n    int n;\n    cin >> n;\n    string rank;\n    for(int i = 0; i < n; ++i) {\n        char c;\n        cin >> c;\n        if(c != '-') {\n            rank += c;\n        }\n    }\n    n = rank.size();\n\n    vector<vector<ll>> dp(n + 1, vector<ll>(n + 1));\n    dp[0][0] = 1;\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(rank[i] == 'U') {\n                (dp[i + 1][j] += dp[i][j] * j) %= M;\n                (dp[i + 1][j + 1] += dp[i][j]) %= M;\n            } else {\n                (dp[i + 1][j] += dp[i][j] * j) %= M;\n                (dp[i + 1][j - 1] += dp[i][j] * j * j) %= M;\n            }\n        }\n    }\n    cout << dp[n][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1e9+7;\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<char> s(n); repeat (i,n) scanf(\" %c\", &s[i]);\n    vector<vector<ll> > cur(n+1, vector<ll>(n+1)); // dp : (requiring-up) \\times (dangling-down) \\to (count)\n    vector<vector<ll> > prv(n+1, vector<ll>(n+1));\n    cur[0][0] = 1;\n    for (char c : s) {\n        cur.swap(prv);\n        repeat (i,n+1) repeat (j,n+1) {\n            if (c == '-') {\n                cur[i][j] = prv[i][j];\n            } else if (c == 'U') {\n                cur[i][j] = 0;\n                ;                          cur[i][j] += prv[i][j] * i; // up\n                if (i-1 >= 0 and j-1 >= 0) cur[i][j] += prv[i-1][j-1]; // down\n                cur[i][j] %= mod;\n            } else if (c == 'D') {\n                cur[i][j] = 0;\n                if (i+1 < n+1 and j+1 < n+1) cur[i][j] += prv[i+1][j+1] * (i+1) * (j+1); // up\n                ;                            cur[i][j] += prv[i][j] * j; // down\n                cur[i][j] %= mod;\n            }\n        }\n    }\n    printf(\"%lld\\n\", cur[0][0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=7;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b)%p;\n\telse if(arrays[n]==-1) DP[n][a][b]=ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n\telse return DP[n][a][b]=ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint main() {\n    int n; cin >> n;\n\tll dp[201][201] = {};\n\tdp[0][0] = 1;\n\tvector<char> v;\n\trep(i, n) {\n\t\tchar t;cin >> t;\n\t\tif (t != '-')v.push_back(t);\n\t}\n\tint len = v.size();\n\trep(i, len) {\n\t\trep(j, len+1) {\n\t\t\tif (v[i] == 'U') {\n\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\tdp[i + 1][j + 1] %= MOD;\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j;\n\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j;\n\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t\tif (j - 1 >= 0) {\n\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j] * j*j;\n\t\t\t\t\tdp[i + 1][j - 1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[len][0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pii pair<int, int>\n#define eb emplace_back\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep3(i, l, n) for (int i = l; i < (n); ++i)\n#define sz(v) (int)v.size()\nconst int inf = 1e9 + 7;\nconst ll INF = 1e18;\nconst int mod = 1000000007;\n#define abs(x) (x >= 0 ? x : -(x))\n#define lb(v, x) (int)(lower_bound(all(v), x) - v.begin())\n#define ub(v, x) (int)(upper_bound(all(v), x) - v.begin())\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<typename T> T gcd(T a, T b) { if (b == 0) return a; return gcd(b, a % b); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\ntemplate<typename T> T pow(T a, int b) { return b ? pow(a * a, b / 2) * (b % 2 ? a : 1) : 1; }\nll modpow(ll a, ll b, ll _mod) { return b ? modpow(a * a % _mod, b / 2, _mod) * (b % 2 ? a : 1) % _mod : 1; }\ntemplate<class T> ostream& operator << (ostream& os, const vector<T>& vec) { for (auto &vi: vec) os << vi << \" \"; return os; }\ntemplate<class T, class U> ostream& operator << (ostream& os, const pair<T, U>& p) { os << p.F << \" \" << p.S; return os; }\ntemplate<typename T >inline istream& operator >> (istream& is, vector<T>& v) { rep(j, sz(v)) is >> v[j]; return is; }\ntemplate<class T> inline void add(T &a, int b) { a += b; if (a >= mod) a -= mod; }\n\n\nvoid solve();\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout << fixed << setprecision(10);\n\n    int T;\n    // cin >> T;\n    T = 1;\n\n    while (T--) {\n        solve();\n    }\n}\n\n// https://drken1215.hatenablog.com/entry/2019/10/05/173700\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<char> a(n);\n  cin >> a;\n\n  // 上から i 段目, すでに j 個マッチングしてる\n  int dp[300][300];\n  fill_n(*dp, 300 * 300, 0);\n  dp[0][0] = 1;\n\n  rep(i, n) rep(j, n + 1) {\n    if (a[i] == '-') {\n      add(dp[i + 1][j + 1], dp[i][j]);\n    } else if (a[i] == 'D') {\n      // 頂点 D からは, 上に上がってる (相方 (前回の中継所) からが下がってる)\n      // ペアは上がるか下がるか\n\n      // i-j : 上にあるのが i 個\n      add(dp[i + 1][j + 2], 1LL * dp[i][j] * (i - j) * (i - j) % mod);\n      add(dp[i + 1][j + 1], 1LL * dp[i][j] * (i - j) % mod);\n    } else {\n      add(dp[i + 1][j], dp[i][j]);\n      add(dp[i + 1][j + 1], 1LL * dp[i][j] * (i - j) % mod);\n    }\n  }\n  cout << dp[n][n] << endl;\n  // rep(i, n + 1) { rep(j, n + 1) cout << dp[i][j] << \" \"; cout << endl; }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[202][202];\nll MOD=1000000007;\n\nint main(void){\n\n  fill(dp[0],dp[202],0);\n\n  int n;\n  cin >> n;\n\n  char c[202];\n\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  dp[0][0]=1;\n\n  for(int k=0;k<n;k++){\n    for(int i=0;i<=k;i++){\n      if(c[k]=='-')dp[k+1][i]=dp[k][i];\n      else if(c[k]=='D'){\n        if(i>0){\n          dp[k+1][i-1]+=((dp[k][i]*i)%MOD*i)%MOD;\n        }\n        dp[k+1][i]+=(dp[k][i]*i)%MOD;\n      }\n      else if(c[k]=='U'){\n        dp[k+1][i]+=(dp[k][i]*i)%MOD;\n        dp[k+1][i+1]+=dp[k][i];\n        dp[k+1][i+1]%=MOD;\n      }\n      dp[k+1][i]%=MOD;\n    }\n  }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \": \" << x << '\\n';\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst int INF = (int)1e9;\nconst int MOD = (int)1e9 + 7;\n\n#ifndef MOD_INT\n#define MOD_INT\ntemplate<int mod>\nstruct ModInt{\n  int x;\n\n  ModInt() : x(0){}\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod){}\n\n  ModInt &operator+=(const ModInt &p){\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt &p){\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt &p){\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n  ModInt &operator/=(const ModInt &p){\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const {return ModInt(-x);}\n  ModInt operator+(const ModInt &p) const {return ModInt(*this) += p;}\n  ModInt operator-(const ModInt &p) const {return ModInt(*this) -= p;}\n  ModInt operator*(const ModInt &p) const {return ModInt(*this) *= p;}\n  ModInt operator/(const ModInt &p) const {return ModInt(*this) /= p;}\n  bool operator==(const ModInt &p) const {return x == p.x;}\n  bool operator!=(const ModInt &p) const {return x != p.x;}\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p){\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a){\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod(){return mod;}\n};\n\nusing mint = ModInt<MOD>;\n#endif\n\nmint dp[201][201];\n\nint main(void){\n    int n;\n    cin >> n;\n    vector<char> c(n);\n    for(int i = 0; i < n; i++) cin >> c[i];\n\n    dp[0][0] = 1;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= i; j++){\n            if(c[i] == 'U'){\n                { // 2\n                    int nj = j;\n                    mint x = j;\n                    dp[i+1][nj] += dp[i][j] * x;\n                }\n                { // 3\n                    int nj = j+1;\n                    dp[i+1][nj] += dp[i][j];\n                }\n            }else if(c[i] == 'D'){\n                { //2\n                    int nj = j;\n                    mint x = j;\n                    dp[i+1][nj] += dp[i][j] * x;\n                }\n                if(j >= 1){ // 4\n                    int nj = j-1;\n                    mint x = j*j;\n                    dp[i+1][nj] += dp[i][j] * x;\n                }\n            }else if(c[i] == '-'){\n                { //1\n                    int nj= j;\n                    dp[i+1][nj] += dp[i][j];\n                }\n            }\n        }\n    }\n\n    cout << dp[n][0] << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst ll mod=1000000007;\nll dp[210][210][210];\nchar c[210];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n) cin >> c[i];\n\tdp[0][0][0]=1LL;\n\trep(i,n)rep(x,n+1)rep(y,n+1){\n\t\tif(dp[i][x][y]==0) continue;\n\t\tswitch(c[i]){\n\t\t\tcase 'U':\n\t\t\t\tdp[i+1][x][y]+=dp[i][x][y]*x;\n\t\t\t\tdp[i+1][x][y]%=mod;\n\t\t\t\tdp[i+1][x+1][y+1]+=dp[i][x][y];\n\t\t\t\tdp[i+1][x+1][y+1]%=mod;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdp[i+1][x][y]+=dp[i][x][y];\n\t\t\t\tdp[i+1][x][y]%=mod;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tdp[i+1][x][y]+=dp[i][x][y]*y;\n\t\t\t\tdp[i+1][x][y]%=mod;\n\t\t\t\tif(x-1>=0&&y-1>=0){\n\t\t\t\t\tdp[i+1][x-1][y-1]+=dp[i][x][y]*x*y;\n\t\t\t\t\tdp[i+1][x-1][y-1]%=mod;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tcout << dp[n][0][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nll dp[128][128][128];\n\nint main(){\n    int n;\n    int const mod=1000000007;\n    while(cin>>n && n){\n        memset(dp,0,sizeof(dp));\n        dp[0][0][0]=1;\n        for(int k=0;k<n;k++){\n            char c;cin>>c;\n            if(c=='-'){\n                for(int x=0;x<=k;x++){\n                    for(int y=0;y<=k;y++){\n                        dp[k+1][x][y]+=dp[k][x][y];\n                    }\n                }\n            }\n\n            if(c=='D'){\n                for(int x=1;x<=k;x++){\n                    for(int y=1;y<=k;y++){\n                        dp[k+1][x-1][y-1]+=dp[k][x][y]*x*y;\n                        dp[k+1][x-1][y-1]%=mod;\n                    }\n                }\n                for(int x=0;x<=k;x++){\n                    for(int y=0;y<=k;y++){\n                        dp[k+1][x][y]+=dp[k][x][y]*y;\n                        dp[k+1][x][y]%=mod;\n                    }\n                }\n            }\n            \n            if(c=='U'){\n                for(int x=0;x<=k;x++){\n                    for(int y=0;y<=k;y++){\n                        dp[k+1][x][y]+=dp[k][x][y]*x;\n                        dp[k+1][x][y]%=mod;\n                    }\n                }\n                for(int x=0;x<=k;x++){\n                    for(int y=0;y<=k;y++){\n                        dp[k+1][x+1][y+1]+=dp[k][x][y];\n                        dp[k+1][x+1][y+1]%=mod;\n                    }\n                }            \n            }\n        }\n\n        // for(int i=0;i<=n;i++){\n        //     for(int j=0;j<=n;j++){\n        //         cout<<dp[n][i][j]<<\" \";\n        //         if(j==n)cout<<endl;\n        //     }\n        // }\n        cout<<dp[n][0][0]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MOD 1000000007\n\ntypedef long long ll;\n\nll dp[201][201][201] = {0}; // dp[n][rest U][rest empty box] = ??´????????°\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> v;\n\tfor (int i = 0; i < N; ++i) {\n\t\tchar c; cin >> c;\n\t\tif (c != '-') {\n\t\t\tv.push_back(c);\n\t\t}\n\t}\n\tN = v.size();\n\n\tif (N == 0) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (v[0] == 'D') {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tdp[0][1][1] = 1; // v[0] = 'U'\n\tfor (int i = 0; i < N-1; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (v[i+1] == 'U') {\n\t\t\t\t\tdp[i+1][j+1][k+1] = (dp[i+1][j+1][k+1] + dp[i][j][k]) % MOD;\n\t\t\t\t\tif (j >= 1) {\n\t\t\t\t\t\tdp[i+1][j][k] = (dp[i+1][j][k] + j * dp[i][j][k]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { // D\n\t\t\t\t\tif (k >= 1) {\n//\t\t\t\t\t\tif (dp[i][j][k]) cout << i << \" \" << j << \" \" << k << \" : \" << dp[i][j][k] << endl;\n\t\t\t\t\t\tdp[i+1][j][k] = (dp[i+1][j][k] + k * dp[i][j][k]) % MOD;\n\t\t\t\t\t\tif (j >= 1) {\n\t\t\t\t\t\t\tdp[i+1][j-1][k-1] = (dp[i+1][j-1][k-1] + j * k * dp[i][j][k]) % MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[N-1][0][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>{\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b,QF &&qf) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1,qf);\n\t}*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l,int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nclass Lowlink {\n\tvector<vector<int>> G;\n\tvector<int> order;\n\tvector<pair<int, int>> bridge_;\n\tvector<int> articulation_;\n\tint next = 0;\n\tint dfs(int v, int prev) {\n\t\tint res = order[v] = next++;\n\t\tbool is_articulation = 0;\n\t\tint d = 0;\n\t\tfor (auto to : G[v]) {\n\t\t\tif (to == prev)continue;\n\t\t\tif (order[to] >= 0)res = min(res, order[to]);\n\t\t\telse {\n\t\t\t\tint low = dfs(to, v);\n\t\t\t\tif (low > order[v])bridge_.emplace_back(v, to);\n\t\t\t\tif (prev >= 0 && low >= order[v])is_articulation = 1;\n\t\t\t\tres = min(res, low);\n\t\t\t\td++;\n\t\t\t}\n\t\t}\n\t\tif (prev < 0 && d >= 2)is_articulation = 1;\n\t\tif (is_articulation)articulation_.push_back(v);\n\t\treturn res;\n\t}\npublic:\n\tLowlink(int size) :G(size + 1) {}\n\tvoid add_edge(int from, int to) {\n\t\tG[from].push_back(to);\n\t}\n\tvoid solve(int start = 0) {\n\t\tdfs(start, -1);\n\t}\n\tconst auto& bridge() {\n\t\treturn bridge_;\n\t}\n\tconst auto& articulation() {\n\t\treturn articulation_;\n\t}\n};\nclass SCC {\n\tint V;\n\tint solved = -1;\n\tvector<vector<int>> G, rG;\n\tvector<int> vs;\n\tvector<char> used;\n\tvector<int> cmp;\n\tvoid dfs(int v) {\n\t\tused[v] = 1;\n\t\tfor (auto a : G[v])if (!a)dfs(a);\n\t\tvs.push_back(v);\n\t}\n\tvoid rdfs(int v, int k) {\n\t\tused[v] = 1;\n\t\tcmp[v] = k;\n\t\tfor (auto a : rG[v])if (used[a])rdfs(a, k);\n\t}\npublic:\n\tSCC(int size) :V(size + 1), G(size + 1), rG(size + 1), vs(size + 1), used(size + 1), cmp(size + 1) {}\n\tvoid add_edge(int from, int to) {\n\t\tsolved = -1;\n\t\tG[from].push_back(to);\n\t\trG[to].push_back(from);\n\t}\n\tint scc() {\n\t\tif (solved != -1)return solved;\n\t\tfill(ALL(used), 0);\n\t\tvs.clear();\n\t\tfor (int i = 0; i < V; i++)if (!used[i])dfs(i);\n\t\tfill(ALL(used), 0);\n\t\tint k = 0;\n\t\tfor (int i = vs.size() - 1; i >= 0; i--)if (!used[vs[i]])rdfs(vs[i], k++);\n\t\tsolved = k;\n\t\treturn k;\n\t}\n\tconst auto& group() {\n\t\treturn cmp;\n\t}\n};\numap<pair<int, int>, int> m;\nint f(int a, int b) {\n\tb &= (2ll << a - 1);\n\tif (m.find(pii(a, b)) != m.end())return m[pii(a, b)];\n\tset<int> s;\n\trep1(i, a) {\n\t\tif (b & 1 << i)continue;\n\t\ts.insert(f(a - i, b | 1 << i));\n\t}\n\trep(i, 60) {\n\t\tif (s.find(i) == s.end()) {\n\t\t\tm[pii(a, b)] = i;\n\t\t\treturn i;\n\t\t}\n\t}\n}\ntemplate<class T>\nclass lazysegtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse {\n\t\t\tT ret(e);\n\t\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t\treturn ret.merge(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t\t}\n\t}\n\ttemplate<class Param>\n\tT update(int a, int b, int k, int l, int r, const Param& param) {\n\t\tif (r <= a || b <= l)return obj[k];\n\t\tif (a <= l && r <= b) {\n\t\t\tobj[k].update(param);\n\t\t\treturn obj[k];\n\t\t}\n\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\treturn obj[k].merge(update(a, b, k * 2 + 1, l, (l + r) / 2, param), update(a, b, k * 2 + 2, (l + r) / 2, r, param));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\ttemplate<class Param>\n\tvoid update(int a, int b, Param&& param) {\n\t\tupdate(a, b, 0, 0, offset + 1, param);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i].merge(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\t/*\n\tvoid update(int k, T &a) {\n\tk += offset;\n\tobj[k] = a;\n\twhile (k) {\n\tk = k - 1 >> 1;\n\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t}\n\t}*/\n\tlazysegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tlazysegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nclass lazyRMQ_t {\n\tint min, add;\npublic:\n\tint getmin() {\n\t\treturn min;\n\t}\n\tlazyRMQ_t() {\n\t\tmin = numeric_limits<int>::max()/2; add = 0;\n\t}\n\tlazyRMQ_t(int a,int b=0) {\n\t\tmin = a; add = b;\n\t}\n\tvoid propagate(lazyRMQ_t &a, lazyRMQ_t &b) {\n\t\ta.min += add;\n\t\tb.min += add;\n\t\ta.add += add;\n\t\tb.add += add;\n\t\tadd = 0;\n\t}\n\tlazyRMQ_t& merge(const lazyRMQ_t &a,const lazyRMQ_t &b) {\n\t\tmin = std::min(a.min, b.min);\n\t\tadd = 0;\n\t\treturn *this;\n\t}\n\tlazyRMQ_t& update(int k) {\n\t\tmin += k;\n\t\tadd += k;\n\t\treturn *this;\n\t}\n};\nint dp[201][201];\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<char> c(n);\n\trep(i, n)cin >> c[i];\n\tdp[0][0] = 1;\n\trep(i, n){\n\t\trep(j, n) {\n\t\t\tswitch (c[i]) {\n\t\t\tcase '-':\n\t\t\t\t(dp[i + 1][j] += dp[i][j]) %= mod;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\t(dp[i + 1][j] += (ll)dp[i][j] * j%mod) %= mod;\n\t\t\t\t(dp[i + 1][j + 1] += dp[i][j]) %= mod;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\t(dp[i + 1][j] += (ll)dp[i][j] * j%mod) %= mod;\n\t\t\t\tif (j == 0)break;\n\t\t\t\t(dp[i + 1][j - 1] += (ll)dp[i][j] * j*j) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <math.h>\n#include <string>\n#include <math.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\n\nconst ll mod = 1000000007;\nconst ll INF = 1000000000000;\n\nll N, K, dp[210][210];\nchar change[210];\n\nint main()\n{\n\tcin >> N;\n\n\tfor (int i = 1; i <= N; i++)\n\t{\n\t\tcin >> change[i];\n\t}\n\n\tif (change[1] == '-')\n\t{\n\t\tdp[1][0] = 1;\n\t}\n\tif (change[1] == 'U')\n\t{\n\t\tdp[1][1] = 1;\n\t}\n\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tfor (int j = 0; j <= i; j++)\n\t\t{\n\t\t\tif (change[i + 1] == '-')\n\t\t\t{\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t}\n\t\t\telse if (change[i + 1] == 'U')\n\t\t\t{\n\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j % mod;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j % mod;\n\t\t\t\tif (j != 0)\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j - 1] += j * j * dp[i][j] % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[N][0] << endl;\n\n\tint www;\n\tcin >> www;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MOD = 1000000007LL;\nconst int INF = LLONG_MAX;\nint dp[210][210][210] = {};\n\nsigned main(){\n    \n    int n; cin >> n;\n\n    // 上から i 番目までみて、左は j 個、右は k 個余ってる時の通り数\n    dp[0][0][0] = 1;\n\n    // - は無視\n    vector<char> v;\n    for(int i = 0; i < n; i++){\n        char c; cin >> c;\n        if(c == '-') continue;\n        v.push_back(c);\n    }\n\n    // マッチングの問題に帰着\n\n    n = (int)v.size();\n\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            for(int k = 0; k < n; k++){\n                if(dp[i][j][k] == 0) continue;\n\n                if(v[i] == 'D'){\n                    // 右は j 個のうち一つと必ず結ぶ\n\n                    int mul = 1;\n                    // 左をどこかと結ぶ\n                    mul *= j;\n                    mul %= MOD;\n                    mul *= k;\n                    mul %= MOD;\n                    dp[i + 1][j - 1][k - 1] += dp[i][j][k] * mul;\n                    dp[i + 1][j - 1][k - 1] %= MOD;\n\n                    // 左を保留にする\n                    mul = 1;\n                    mul *= j;\n                    mul %= MOD;\n                    dp[i + 1][j][k] += dp[i][j][k] * mul;\n                    dp[i + 1][j][k] %= MOD;\n\n                }else{\n\n                    // 右は保留確定\n\n                    int mul = 1;\n                    // 左をどこかと結ぶ\n                    mul *= k;\n                    mul %= MOD;\n                    dp[i + 1][j][k] += dp[i][j][k] * mul;\n                    dp[i + 1][j][k] %= MOD;\n\n                    // 左を保留にする\n                    dp[i + 1][j + 1][k + 1] += dp[i][j][k];\n                    dp[i + 1][j + 1][k + 1] %= MOD;\n                }\n            }\n        }\n    }\n\n    cout << dp[n][0][0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=7+1e9;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b)%p;\n\telse if(arrays[n]==-1) DP[n][a][b]=ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n\telse return DP[n][a][b]=ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  ModInt() : v(0) {}\n  ModInt(auto x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool) *this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t) v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  M pow(auto n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  friend M operator*(auto l, M r) { return M(l) *= r; }\n  friend M operator/(auto l, M r) { return M(l) /= r; }\n  friend M operator+(auto l, M r) { return M(l) += r; }\n  friend M operator-(auto l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  friend bool operator==(auto l, M r) { return M(l) == r; }\n  friend bool operator!=(auto l, M r) { return !(l == r); }\n};\nusing Mint = ModInt<(unsigned) 1e9 + 7>;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<Mint> dp(n + 1, V<Mint>(n + 1));\n  dp[0][0] = 1;\n  for (int i = 0; i < n; ++i) {\n    char c; cin >> c;\n    if (c == 'D') {\n      for (int x = 0; x <= i; ++x) {\n        dp[i + 1][x] += dp[i][x] * x;\n        if (x) dp[i + 1][x - 1] += dp[i][x] * x * x;\n      }\n    } else if (c == 'U') {\n      for (int x = 0; x <= i; ++x) {\n        dp[i + 1][x + 1] += dp[i][x];\n        dp[i + 1][x] += dp[i][x] * x;\n      }\n    } else {\n      for (int x = 0; x <= i; ++x) {\n        dp[i + 1][x] += dp[i][x];\n      }\n    }\n  }\n  cout << dp[n][0] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007LL;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\nll dp[201][201];\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<string> c;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (s != \"-\") c.push_back(s);\n\t}\n\tn = c.size();\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tif (c[i] == \"U\") {\n\t\t\t\t(dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n\t\t\t\t(dp[i + 1][j] += (dp[i][j] * j) % MOD) %= MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(dp[i + 1][j - 1] += (dp[i][j] * j*j) % MOD) %= MOD;\n\t\t\t\t(dp[i + 1][j] += (dp[i][j] * j) % MOD) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; std::swap(a, m);\n    u -= t * v; std::swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass modular {\n  private:\n    int value;\n  public:\n    constexpr modular() = default;\n    constexpr modular(const modular&) = default;\n    constexpr modular(modular&&) = default;\n    modular& operator=(const modular&) = default;\n    modular& operator=(modular&&) = default;\n\n    template <typename U>\n    modular (const U& x) {value = normalize(x);}\n\n    template <typename U>\n    static auto normalize(const U& x) {\n      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());\n      if (v < 0) v += mod();\n      return v;\n    }\n\n    auto const& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static auto mod() { return T::value; }\n\n    auto& operator+=(const modular& other) {\n      if ((value += other.value) >= mod()) value -= mod();\n      return *this;\n    }\n    auto& operator-=(const modular& other) {\n      if ((value -= other.value) < 0) value += mod();\n      return *this;\n    }\n    template <typename U>\n    auto& operator+=(const U& other) {return *this += modular(other); }\n    template <typename U>\n    auto& operator-=(const U& other) {return *this -= modular(other); }\n    auto operator-() const { return modular(-value); }\n    auto& operator++() {return *this += 1;}\n    auto& operator--() {return *this -= 1;}\n    auto\toperator++(int) {modular result(*this); operator++(); return result;}\n    auto\toperator--(int) {modular result(*this); operator--(); return result;}\n  \n    template <typename U = T>\n    auto& operator*=(const modular& rhs) {\n      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n      return *this;\n    }\n    auto& operator/=(const modular& other) {\n      return *this *= modular(inverse(other.value, mod()));\n    }\n};\ntemplate <typename T> struct is_modular : std::false_type {};\ntemplate <typename T> struct is_modular <modular<T>> : std::true_type{};\ntemplate <typename T> constexpr bool is_modular_v = is_modular<T>::value;\n\ntemplate <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\n\ntemplate <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nmodular<T> pow (const modular<T>& a, U b) {\n  assert(b >= 0);\n  modular<T> x = a, ret = 1;\n  for (; b > 0; b /= 2) {\n    if (b % 2 == 1) ret *= x;\n    x *= x;\n  }\n  return ret;\n}\n\ntemplate <typename T>\nstd::string to_string(const modular<T>& a) {\n  return std::to_string(a());\n}\ntemplate <typename T>\nauto operator<<(std::ostream& os, const T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::ostream&>{\n    return os << a();\n  }\ntemplate <typename T>\nauto operator>>(std::istream& is, T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::istream&> {\n  long long x; is >> x;\n  a = T(x);\n  return is;\n}\n\n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 1'000'000'007;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(md)>, md>>;\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  std::vector<char> a(n);\n  for (auto& x : a) std::cin >> x;\n  a.erase(std::remove(a.begin(), a.end(), '-'), a.end());\n  n = a.size();\n  auto zero = std::vector<mint>(n + 1, 0);\n  auto dp = zero;\n  dp.at(0) = 1;\n  auto renew = [&] (char c) {\n    auto new_dp = zero;\n    if (c == 'U') {\n      for (int i = 0; i < n; i++) {\n        if (1 <= i)     new_dp.at(i) += dp.at(i) * i;\n        if (i + 1 <= n) new_dp.at(i + 1) += dp.at(i);\n      }\n    } else if (c == 'D') {\n      for (int i = 0; i < n; i++) {\n        if (1 <= i) new_dp.at(i - 1) += dp.at(i) * i * i;\n        if (1 <= i) new_dp.at(i) += dp.at(i) * i;\n      }\n    } else {\n      abort();\n    }\n    dp = new_dp;\n  };\n  for (int i = 0; i < n; i++) renew(a.at(i));\n  std::cout << dp.at(0) << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 1000000007;\n\nint main(){\n\tint n;\n\tchar c[202];\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"\\n%c\",&c[i]);\n\t}\n\t\n\tvector<int> U,D;\n\trep(i,n){\n\t\tif(c[i] == 'U')U.pb(i);\n\t\tif(c[i] == 'D')D.pb(i);\n\t}\n\tsor(U);\n\tsor(D);\n\t\n\tll dp[2][202];\n\tint t = 0 , t_ = 1;\n\trep(i,202)dp[0][i] = 0;\n\tdp[0][0] = 1;\n\tint cnt = 0;\n\trep(i,n){\n\t\tif(c[i] == '-'){ cnt ++; continue; }\n\t\trep(j,n){\n\t\t\tdp[t_][j] = 0;\n\t\t\tif(j > 0)dp[t_][j] += dp[t][j-1]*max(0LL,(ll)(lb(U,i)-U.begin())-j+1);\n\t\t\tdp[t_][j] += dp[t][j]*max(0LL,(ll)(D.begin()-ub(D,i))+i-cnt-j+1);\n\t\t\tdp[t_][j] %= M;\n\t\t}\n\t\tswap(t,t_);\n\t}\n\t\n\tcout << dp[t][U.size()] << endl;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<int mod=1000000007>\nclass ModInt {\n  int x;\npublic:\n  ModInt() : x(0) {}\n  ModInt(const ModInt &y): x(y.x) {}\n  ModInt(int64_t y){ x = y % mod; if(x < 0) x += mod; }\n  ModInt &operator += (const ModInt &p){ x += p.x; if(x >= mod) x -= mod; return *this; }\n  ModInt &operator -= (const ModInt &p){ x -= p.x; if(x < 0) x += mod; return *this; }\n  ModInt &operator *= (const ModInt &p){ x = (int) (1LL * x * p.x % mod); return *this; }\n  ModInt &operator /= (const ModInt &p){ *this *= p.inverse(); return *this; }\n  ModInt operator -() const { return ModInt(-x); }\n  ModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n  ModInt operator ^ (const int64_t y) const { return pow(y); }\n  bool operator == (const ModInt &p) const { return x == p.x; }\n  bool operator != (const ModInt &p) const { return x != p.x; }\n  ModInt operator = (const int64_t y) { return *this = ModInt(y); }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0){\n      t = a/b; a -= t*b; swap(a, b);\n      u -= t*v; swap(u, v);\n    }\n    return ModInt(u);\n  }\n  ModInt pow(int64_t y) const {\n    if(x==0) return ModInt(0);\n    int64_t r = 1, t = x;\n    while(y > 0){\n      if(y&1) r = r*t%mod;\n      t = t*t%mod; y >>= 1;\n    }\n    return ModInt(r);\n  }\n  friend ostream &operator << (ostream &os, const ModInt<mod> &p) { return os<<p.x; }\n  friend istream &operator >> (istream &is, ModInt<mod> &a) { int64_t x; is>>x; a = ModInt<mod>(x); return is; }\n};\nusing Int = ModInt<>;\n\nint main(){\n  int n;\n  cin>>n;\n  vector<char> v;\n  rep(i,n){\n    string s;\n    cin>>s;\n    if(s[0]=='-') continue;\n    else v.push_back(s[0]);\n  }\n\n  n = v.size();\n\n  if(n==0){\n    cout << 1 << endl;\n    return 0;\n  }\n\n  int cu = 0, cd = 0;\n  for(auto c : v){\n    if(c=='U') cu++;\n    else cd++;\n  }\n\n  vector<Int> dp(n+2, 0);\n  dp[1] = 1;\n\n  rep(i,1,n){\n    vector<Int> nxt(n+2, 0);\n\n    rep(j, n+1) if(dp[j] != 0) {\n      if(v[i]=='U') {\n        if(j+1 <= cu && j+1 <= cd) nxt[j+1] += dp[j];\n        nxt[j] += dp[j] * j;\n      }\n      else { // 'D'\n        nxt[j] += dp[j] * j;\n        if(j-1>=0) nxt[j-1] += dp[j] * j * j;\n      }\n    }\n\n    swap(dp, nxt);\n  }\n\n  cout << dp[0] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//const int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nconst int mod = 100000000+7;\nint N;\nchar field[210];\nll dp[210][210][210];\n\nll dfs(int pos,int u,int d){\n  if(dp[pos][u][d]>=0)return dp[pos][u][d];\n  ll res = 0;\n  if(pos == N){\n    if(u == 0 && d == 0)res = 1;\n  }\n  else{\n    if(field[pos] == '-')res = dfs(pos+1,u,d);\n    else if(field[pos]=='U'){\n      // ここに割り当て可能なのは、ここより下にあるDと、ここより上にあるUのうちどれかひとつ\n      if(u>0)res = (res + (dfs(pos+1,u-1+1,d)*u)%mod )%mod;\n      // ここで割り当てるDは下にあるDのうちどれか一つ\n      res = (res + (dfs(pos+1,u+1,d+1))%mod)%mod;\n    }\n    else if(field[pos]=='D'){\n      // ここに割り当て可能なのは、ここより下にあるDと、ここより上にあるU\n      // このdは消化されたものとして扱う\n      if(d>0){\n        // 今回のパターンは、どれに割り当てられたかで場合分けが必要\n        if(u>0)res = (res + (dfs(pos+1,u-1,d-1)*u)%mod)%mod;\n        res = (res + (dfs(pos+1,u,d))%mod)%mod;\n        res = (res * d) % mod;\n      }\n    }\n  }\n  return dp[pos][u][d] = res;\n}\n\nint main(){\n\n  cin>>N;\n  for(int i=0;i<N;i++)cin>>field[i];\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,0)<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\nll dp[201][201];\nint N;\nint junni[200];\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == '-')junni[i] = 0;\n\t\telse if (c == 'U')junni[i] = 1;\n\t\telse junni[i] = 2;\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tdp[i][j] %= MOD;\n\n\t\t\tif (junni[i] == 0) {\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t}\n\t\t\telse if (junni[i] == 1) {\n\t\t\t\t//U\n\t\t\t\tif(j < N)\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\tif(j > 0)\n\t\t\t\t\tdp[i + 1][j] += dp[i][j] * j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//D\n\t\t\t\tif(j > 0)\n\t\t\t\t\tdp[i + 1][j] += dp[i][j] * j;\n\t\t\t\tif (j >= 1)\n\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j] * j * j;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[N][0] % MOD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntemplate <class T> int size(const T &x) { return x.size(); }\nconst int INF = 2147483647;\n#define rep(i,a,b) for (__typeof(a) i=(a); i<(b); ++i)\n#define iter(it,c) for (__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\n\nchar arr[1000];\nll mem[1000][1000];\nll mod = 1000000007;\nint n;\nll dp(int at, int open) {\n    if (at == n) {\n        return open == 0 ? 1 : 0;\n    }\n    if (mem[at][open] != -1)\n        return mem[at][open];\n    if (arr[at] == '-') {\n        return mem[at][open] = dp(at+1,open);\n    }\n    if (arr[at] == 'U') {\n        return mem[at][open] = (dp(at+1, open+1) + dp(at+1,open) * open % mod) % mod;\n    }\n    if (arr[at] == 'D') {\n        return mem[at][open] = (dp(at+1,open) * open % mod + dp(at+1,open-1) * open % mod * open % mod) % mod;\n    }\n    assert(false);\n}\n\nint main() {\n    memset(mem,-1,sizeof(mem));\n    cin >> n;\n    rep(i,0,n) {\n        cin >> arr[i];\n    }\n    cout << dp(0,0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nint d[212][212],n,M=1e9+7,i,j,a,*b;main(){std::cin>>n;char c;**d=1;for(i=0;std::cin>>c;++i)for(j=0;a=d[i][j],b=d[i+1],j<n;j++)if(c&8)b[j]=a;else if(c&1)(b[j]+=a*j)%=M,(b[j+1]+=a)%=M;else(b[j]+=a*j)%=M,(b[j-1]+=a*j*j)%=M;std::cout<<*d[n];}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll dp[222][222][222];\n\nint main(){\n\t\n\tint n;cin >> n;\n\tvector<char> v(n);\n\tREP(i,n)cin >> v[i];\n\t\n\tdp[0][0][0] = 1;\n\t\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tREP(k,n){\n\t\t\t\tif(dp[i][j][k]){\n\t\t\t\t\tDBG(cout << \"ijk ; \" << i << ' ' << j << ' ' << k  << ' ' << dp[i][j][k] << endl;)\n\t\t\t\t\tif(v[i] == '-'){\n\t\t\t\t\t\tdp[i+1][j][k] += dp[i][j][k];\n\t\t\t\t\t\tdp[i+1][j][k] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\telse if(v[i] == 'U'){\n\t\t\t\t\t\tif(k > 0){\n\t\t\t\t\t\t\tdp[i+1][j][k] += dp[i][j][k] * k;\n\t\t\t\t\t\t\tdp[i+1][j][k] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i+1][j+1][k+1] += dp[i][j][k];\n\t\t\t\t\t\tdp[i+1][j+1][k+1] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(j > 0){\n\t\t\t\t\t\t\tdp[i+1][j][k] += dp[i][j][k] * j;\n\t\t\t\t\t\t\tdp[i+1][j][k] %= MOD;\n\t\t\t\t\t\t\tif(k > 0){\n\t\t\t\t\t\t\t\tdp[i+1][j-1][k-1] += dp[i][j][k] * j * k;\n\t\t\t\t\t\t\t\tdp[i+1][j-1][k-1] %= MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[n][0][0] << endl;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=7+1e9;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b);\n\telse if(arrays[n]==-1) DP[n][a][b]=ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b));\n\telse return DP[n][a][b]=ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b));\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tif(p!=(7+1e9)) return 0;\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n\nll n, x[200], dp[2][201][201], mod = 1000000007;\n\nint main() {\n  scanf(\"%lld\", &n);\n  char s[10]; ll m = 0;\n  for (ll i = 0; i < n; i++) {\n    scanf(\"%s\", s);\n    if (s[0] == 'U') x[m++] = 1;\n    else if (s[0] == 'D') x[m++] = 0;\n  }\n  if (m == 0) {\n    printf(\"1\\n\");\n    return 0;\n  }\n  if (x[0] == 0) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  dp[0][1][1] = 1;\n  for (ll i = 1; i < m; i++) {\n    if (x[i] == 1) {\n      for (ll j = 1; j <= i+1; j++) {\n        for (ll k = 1; k <= i+1; k++) {\n          dp[i&1][j][k] = (dp[!(i&1)][j-1][k-1] + dp[!(i&1)][j][k] * k) % mod;\n        }\n      }\n    } else {\n      for (ll j = 0; j < i+1; j++) {\n        for (ll k = 0; k < i+1; k++) {\n          dp[i&1][j][k] = (dp[!(i&1)][j][k] * j + dp[!(i&1)][j+1][k+1] * (j + 1) * (k + 1)) % mod;\n        }\n      }\n    }\n    for (ll j = 0; j <= m; j++) {\n      for (ll k = 0; k <= m; k++) {\n        dp[!(i&1)][j][k] = 0;\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[!(m&1)][0][0]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef long long ll;\n\nchar s[400];\nll dp[300][300];\n\nint main(){\n\tint n;cin>>n;\n\trep(i,n)cin>>s[i];\n\tdp[0][0]=1;\n\trep(i,n)rep(j,i+1){\n\t\tif(dp[i][j]==0)continue;\n\t\tif(s[i]=='U'){\n\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t\tif(j)(dp[i+1][j]+=dp[i][j]*j)%=MOD;\n\t\t}\n\t\tif(s[i]=='D'){\n\t\t\tif(j){\n\t\t\t\t(dp[i+1][j-1]+=dp[i][j]*j*j)%=MOD;\n\t\t\t\t(dp[i+1][j]+=dp[i][j]*j)%=MOD;\n\t\t\t}\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\t(dp[i+1][j]+=dp[i][j])%=MOD;\n\t\t}\n\t}\n\tcout<<dp[n][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <limits.h>\n#include <stack>\n#include <complex>\n#include <stdlib.h>\n#include <stdio.h>\n#include <functional>\n#include <cfloat>\n#include <math.h>\n\n\n#define fs first\n#define sc second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst ll mod = 1000000007;\nll fact[200200];\nll invfact[200200];\n\ninline ll take_mod(ll a){\n    return (a % mod + mod) % mod;\n}\n\ninline ll add(ll a, ll b){\n    return take_mod(a+b);\n}\n\ninline ll sub(ll a, ll b){\n    return take_mod(a-b);\n}\n\n\ninline ll mul(ll a, ll b){\n    return take_mod(a * b);\n}\n\ninline ll pow(ll x, ll n){\n    ll res = 1LL;\n    while(n > 0){\n        if(n & 1) res = mul(res, x);\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n\nll mod_inv(ll x){\n    return pow(x, mod-2);\n}\n\n// nは上限\nvoid make_fact(ll n){\n    fact[0] = 1;\n    ll res = 1;\n    for(int i = 1; i <= n; i++){\n        fact[i] = res;\n        res = mul(res, i+1);\n    }\n}\n\n// nは上限\nvoid make_invfact(ll n){\n    invfact[0] = 1;\n    invfact[n] = mod_inv(fact[n]);\n    for(int i = n-1; i >= 1; i--){\n        invfact[i] = mul(invfact[i + 1], i + 1);\n    }\n}\n\nll perm(ll n, ll k){\n    return mul(fact[n], invfact[n-k]);\n}\n\nll comb(ll n, ll k){\n    return mul(mul(fact[n], invfact[n-k]), invfact[k]);\n}\n\n\nint main(){\n    ll dp[210][210];\n    int a[210];\n\n    int n;\n    cin >> n;\n    int x = 0;\n    for(int i = 0; i < n; i++){\n        char c; cin >> c;\n        if(c == 'U'){\n            a[x++] = 0;\n        }\n        else if(c == 'D'){\n            a[x++] = 1;\n        }\n\n    }\n\n    for(int i = 0; i < 210; i++){\n        for(int j = 0; j < 210; j++){\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = 1;\n\n    for(int i = 1; i <= x; i++){\n        for(int j = 0; j <= x; j++){\n            if(a[i-1] == 0){\n                dp[i][j] = add(dp[i][j], mul(j, dp[i-1][j]));\n                dp[i][j+1] = add(dp[i][j+1], dp[i-1][j]);\n            }\n            else{\n                if(j-1 >= 0){\n                    dp[i][j-1] = add(dp[i][j-1], mul(j, mul(j, dp[i-1][j])));\n                }\n                dp[i][j] = add(dp[i][j], mul(dp[i-1][j], j));\n            }\n        }\n    }\n\n    cout << dp[x][0] << endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\ntemplate<int64_t mod>\nstruct modint {\n    using LL = int64_t;\n    LL val;\n    modint(LL val=0) : val(((val % mod) + mod) % mod) {}\n\n    const modint operator+() const { return *this; }\n    const modint operator-() const { return (-val + mod) % mod; }\n    const modint inv() const { return pow(mod-2); }\n\n    modint& operator+=(const modint& rhs) {\n        (val += rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator-=(const modint& rhs) {\n        return *this += -rhs;\n    }\n    modint& operator*=(const modint& rhs) {\n        (val *= rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator/=(const modint& rhs) {\n        return *this *= rhs.inv();\n    }\n\n    const modint operator+(const modint& rhs) const {\n        return modint(*this) += rhs;\n    }\n    const modint operator-(const modint& rhs) const {\n        return modint(*this) -= rhs;\n    }\n    const modint operator*(const modint& rhs) const {\n        return modint(*this) *= rhs;\n    }\n    const modint operator/(const modint& rhs) const {\n        return modint(*this) /= rhs;\n    }\n\n    const modint pow(LL n) const {\n        modint ret = 1, tmp = val;\n        while (n > 0) {\n            if (n & 1) ret *= tmp;\n            tmp *= tmp; n >>= 1;\n        }\n        return ret;\n    }\n\n    bool operator==(const modint& rhs) const { return val == rhs.val; }\n    bool operator!=(const modint& rhs) const { return !(*this == rhs); }\n\n    friend const modint operator+(const LL& lhs, const modint& rhs) {\n        return modint(lhs) + rhs;\n    }\n    friend const modint operator-(const LL& lhs, const modint& rhs) {\n        return modint(lhs) - rhs;\n    }\n    friend const modint operator*(const LL& lhs, const modint& rhs) {\n        return modint(lhs) * rhs;\n    }\n    friend const modint operator/(const LL& lhs, const modint& rhs) {\n        return modint(lhs) / rhs;\n    }\n\n    friend bool operator==(const LL& lhs, const modint& rhs) {\n        return modint(lhs) == rhs;\n    }\n    friend bool operator!=(const LL& lhs, const modint& rhs) {\n        return modint(lhs) != rhs;\n    }\n\n    friend ostream& operator<<(ostream& os, const modint& a) {\n        return os << a.val;\n    }\n    friend istream& operator>>(istream& is, modint& a) {\n        LL tmp; is >> tmp;\n        a = tmp;\n        return is;\n    }\n};\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n; cin >> n;\n    vector<char> c(n); cin >> c;\n\n    using Int = modint<MOD>;\n\n    auto dp = make_v<Int>(n+1, n);\n    dp[0][0] = 1;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (c[i] == '-') {\n                dp[i+1][j] += dp[i][j];\n            }\n            if (c[i] == 'U') {\n                if (j+1 < n) dp[i+1][j+1] += dp[i][j];\n                dp[i+1][j] += dp[i][j] * j;\n            }\n            if (c[i] == 'D') {\n                dp[i+1][j] += dp[i][j] * j;\n                if (j-1 >= 0) dp[i+1][j-1] += dp[i][j] * j * j;\n            }\n        }\n    }\n    cout << dp[n][0] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MOD = 1e9+7;\nll dp[222][222][222];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n        int N;\n    cin >> N;\n    string s;\n    for (int i = 0; i < N; i++) {\n        char c;\n        cin >> c;\n        if (c != '-') s += c;\n    }\n    N = s.size();\n    dp[0][0][0] = 1;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= i; j++) for (int k = 0; k <= i; k++) {\n            if (s[i] == 'D') {\n                dp[i+1][j][k] += dp[i][j][k] * j % MOD;\n                if (j > 0 && k > 0) dp[i+1][j-1][k-1] += dp[i][j][k] * j * k % MOD;\n            } else {\n                dp[i+1][j+1][k+1] += dp[i][j][k];\n                dp[i+1][j][k] += dp[i][j][k] * k % MOD;\n            }\n        }\n        for (int j = 0; j <= i+1; j++) for (int k = 0; k <= i+1; k++) {\n            dp[i+1][j][k] %= MOD;\n        }\n    }\n    cout << dp[N][0][0] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 222;\nconst int MOD = 1e9+7;\nll dp[MAXN][MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    string s;\n    for (int i = 0; i < N; i++) {\n        char c;\n        cin >> c;\n        if (c != '-') s += c;\n    }\n    N = s.size();\n    dp[0][0] = 1;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (s[i] == 'D') {\n                dp[i+1][j] += dp[i][j] * j % MOD;\n                if (j) dp[i+1][j-1] += dp[i][j] * j * j % MOD;\n            } else {\n                dp[i+1][j+1] += dp[i][j];\n                dp[i+1][j] += dp[i][j] * j;\n            }\n        }\n        for (int j = 0; j <= i+1; j++)\n            dp[i+1][j] %= MOD;\n    }\n    cout << dp[N][0] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n){\n\t\tvector<vector<ll> > dp(2, vector<ll>(n+1));\n\t\tdp[0][0] = 1;\n\t\tREP(i, n){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tdp[1&i^1] = vector<ll>(n+1);\n\t\t\tif(c == 'U'){\n\t\t\t\tREP(j, n){\n\t\t\t\t\t(dp[1&i^1][j+1] += dp[1&i][j]) %= MOD;\n\t\t\t\t\t(dp[1&i^1][j] += dp[1&i][j]*j) %= MOD;\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tREP(j, n){\n\t\t\t\t\t(dp[1&i^1][j] += dp[1&i][j+1]*(j+1) % MOD*(j+1)) %= MOD;\n\t\t\t\t\t(dp[1&i^1][j+1] += dp[1&i][j+1]*(j+1)) %= MOD;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[1&i^1] = dp[1&i];\n\t\t\t}\n\t\t}\n\t\tcout << dp[n&1][0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nll dp[212][212];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k;\n  int n;\n  ll MOD=1e9+7;\n  cin>>n;\n  vector<char> cs(n);\n  rep(i,n)\n    cin>>cs[i];\n  dp[0][0]=1;\n  rep(i,n){\n    rep(j,n){\n      if(cs[i]=='-'){\n\tdp[i+1][j]=dp[i][j];\n      }else if(cs[i]=='U'){\n\t(dp[i+1][j]+=dp[i][j]*j%MOD)%=MOD;\n\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n      }else{\n\t(dp[i+1][j]+=dp[i][j]*j%MOD)%=MOD;\n\tif(j)\n\t  (dp[i+1][j-1]+=dp[i][j]*j%MOD*j%MOD)%=MOD;\n      }\n    }\n  }\n  //  rep(i,n+1){rep(j,n+1)cout<<dp[i][j]<<\",\";cout<<endl;}\n  cout<<dp[n][0]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nll dp[256][256][256];\n\nint main(){\n    int n;\n    int const mod=1000000007;\n    while(cin>>n && n){\n        memset(dp,0,sizeof(dp));\n        dp[0][0][0]=1;\n        for(int k=0;k<n;k++){\n            char c;cin>>c;\n            if(c=='-'){\n                for(int x=0;x<=k;x++){\n                    for(int y=0;y<=k;y++){\n                        dp[k+1][x][y]+=dp[k][x][y];\n                    }\n                }\n            }\n\n            if(c=='D'){\n                for(int x=1;x<=k;x++){\n                    for(int y=1;y<=k;y++){\n                        dp[k+1][x-1][y-1]+=dp[k][x][y]*x*y;\n                        dp[k+1][x-1][y-1]%=mod;\n                    }\n                }\n                for(int x=0;x<=k;x++){\n                    for(int y=0;y<=k;y++){\n                        dp[k+1][x][y]+=dp[k][x][y]*y;\n                        dp[k+1][x][y]%=mod;\n                    }\n                }\n            }\n            \n            if(c=='U'){\n                for(int x=0;x<=k;x++){\n                    for(int y=0;y<=k;y++){\n                        dp[k+1][x][y]+=dp[k][x][y]*x;\n                        dp[k+1][x][y]%=mod;\n                    }\n                }\n                for(int x=0;x<=k;x++){\n                    for(int y=0;y<=k;y++){\n                        dp[k+1][x+1][y+1]+=dp[k][x][y];\n                        dp[k+1][x+1][y+1]%=mod;\n                    }\n                }            \n            }\n        }\n\n        // for(int i=0;i<=n;i++){\n        //     for(int j=0;j<=n;j++){\n        //         cout<<dp[n][i][j]<<\" \";\n        //         if(j==n)cout<<endl;\n        //     }\n        // }\n        cout<<dp[n][0][0]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<1000000007> mint;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N;\nchar C[202];\nvector<char> A;\nmint dp[202][202][202];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) cin >> C[i];\n    rep(i, 0, N) if (C[i] != '-') A.push_back(C[i]);\n    N = A.size();\n\n    dp[0][0][0] = 1;\n    rep(i, 0, N) rep(a, 0, N + 1) rep(b, 0, N + 1) {\n        if (A[i] == 'U') {\n            // 何もしない\n            dp[i + 1][a + 1][b + 1] += dp[i][a][b];\n            // ←を使う\n            dp[i + 1][a][b] += dp[i][a][b] * b;\n        } else {\n            // →を使う\n            dp[i + 1][a][b] += dp[i][a][b] * a;\n            // ↔を使う\n            if (a and b) dp[i + 1][a - 1][b - 1] += dp[i][a][b] * a * b;\n        }\n    }\n    cout << dp[N][0][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define P 1000000007\n\nmain(){\n\tint a[202]={};\n\tint b[202]={};\n\tint nn;\n\tscanf(\"%d \",&nn);\n\tint n=0;\n\tint c[202];\n\tfor(int i=0;i<nn;i++){\n\t\tchar buf[10];\n\t\tscanf(\"%s\",buf);\n\t\tif(buf[0]!='-')c[n++]=buf[0];\n\t}\n\tint k=0,l=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(c[i]=='U'){\n\t\t\tfor(int j=i+1;j<n;j++)a[j]++;\n\t\t\tk++;\n\t\t}else{\n\t\t\tfor(int j=0;j<i;j++)b[j]++;\n\t\t\tl++;\n\t\t}\n\t}\n\tlong long dp[202][202];\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=0;p<=i;p++){\n\t\t\tdp[i][p]=(p>0?dp[i-1][p-1]*(a[i-1]-p+1):0)+(p<i?dp[i-1][p]*(b[i-1]-l+(i-p)):0);\n\t\t\tdp[i][p]%=P;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][k]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\n\nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nmap< vector<int> , ll > dp[201][201];\nstring S;\n\nll rec(int dep,int cnt,vector<int> v){\n  if(dep==(int)S.size())return 1;\n  if(dep>0&&S[dep-1]=='U')cnt++;\n  if(dp[ dep ][ cnt ].count(v) )return dp[dep][cnt][v];\n  ll res=0;\n  if( (v.empty() || v[0]>0) && cnt> 0){\n    vector<int> next=v;\n    for(int i=0;i<(int)v.size();i++)next[i]--;\n    res=add(res, mul(cnt,rec(dep+1,cnt-1,next) ) );\n  }\n  for(int i=0;i<(int)v.size();i++){\n    vector<int> next;\n    for(int j=0;j<(int)v.size();j++){\n      if(i!=j)next.push_back(v[j]-1);\n    }\n    sort(next.begin(),next.end());\n    if(!next.empty() && next[0]<0)continue;    \n    res=add(res, rec(dep+1,cnt,next) );\n  }\n  return dp[dep][cnt][v]=res;\n}\n\nint solve(string str){\n  if(str==\"\")return 1;\n  vector<int> vec;\n  int cnt=0;\n  for(int i=0;i<(int)str.size();i++){\n    if(str[i]=='D')vec.push_back(i-1);\n  }\n  S=str;\n  return rec( 0, cnt, vec );\n}\n\nint main(){\n  int n;\n  cin>>n;\n  string str=\"\";\n  for(int i=0;i<n;i++){\n    char ch;\n    cin>>ch;\n    if(ch=='-')continue;\n    str+=ch;\n  }\n  cout<<solve(str)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n//これは、頭が悪く競プロが世界で一番できないHIR180が\n//IOI2014日本代表になるまでのN日間の記録である。\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define mod 1000000007\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\nll dp[205][205][205];\nchar hoge[205];\nint n;\nvoid add(ll& a,ll b)\n{\n\ta=(a+b)%mod;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\" %c\",&hoge[i]);\n\tdp[0][0][0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(!dp[i][j][k]) continue;\n\t\t\t\tif(hoge[i+1]=='-')\n\t\t\t\t{\n\t\t\t\t\tadd(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t}\n\t\t\t\tif(hoge[i+1]=='D')\n\t\t\t\t{\n\t\t\t\t\tadd(dp[i+1][j][k],dp[i][j][k]*1LL*j%mod);\n\t\t\t\t\tif(j&&k) add(dp[i+1][j-1][k-1],dp[i][j][k]*1LL*j*k%mod);\n\t\t\t\t}\n\t\t\t\tif(hoge[i+1]=='U')\n\t\t\t\t{\n\t\t\t\t\tadd(dp[i+1][j][k],dp[i][j][k]*1LL*k%mod);\n\t\t\t\t\tadd(dp[i+1][j+1][k+1],dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\nint cnt;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\ncnt=0;\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i-cnt+1][j-cnt]+=dp[i-cnt][j-cnt]*(j-cnt);\n      if(j)dp[i+1-cnt][j-1-cnt]+=dp[i-cnt][j-cnt]*(j-cnt)*(j-cnt);\n      dp[i+1-cnt][j-cnt]%=Prime;\n      if(j)dp[i+1-cnt][j-1-cnt]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1-cnt][j+1-cnt]+=dp[i-cnt][j-cnt];\n      dp[i+1-cnt][j-cnt]+=dp[i-cnt][j-cnt]*(j-cnt);\n      dp[i+1-cnt][j+1-cnt]%=Prime;\n      dp[i+1-cnt][j-cnt]%=Prime;\n    }else{\n      cnt++;\n    }\n  }}\n  printf(\"%d\\n\",dp[i][0]);\n  return 0;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<1000000007> mint;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N;\nchar C[202];\nvector<char> A;\nmint dp[202][202];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) cin >> C[i];\n    rep(i, 0, N) if (C[i] != '-') A.push_back(C[i]);\n    N = A.size();\n\n    dp[0][0] = 1;\n    rep(i, 0, N) rep(a, 0, N + 1) {\n        if (A[i] == 'U') {\n            // 何もしない\n            dp[i + 1][a + 1] += dp[i][a];\n            // ←を使う\n            dp[i + 1][a] += dp[i][a] * a;\n        } else {\n            // →を使う\n            dp[i + 1][a] += dp[i][a] * a;\n            // ↔を使う\n            if (a) dp[i + 1][a - 1] += dp[i][a] * a * a;\n        }\n    }\n    cout << dp[N][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\n// clang-format off\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\ntemplate < class T > ostream &operator<<(ostream &o, const stack<T> &a) { o << \"{\"; for(auto tmp = a; tmp.size(); tmp.pop()) o << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top(); o << \"}\"; return o; }\ntemplate <class T, class Container, class Compare > ostream &operator<<(ostream &os, priority_queue<T, Container, Compare> a) { os << \"{ (top) \"; while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\ntemplate <class T, class Container > ostream &operator<<(ostream &os, queue<T, Container> a) { os << \"{ \"; while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n#define DEBUG_OUT cerr\n#endif\n#if !defined(DEBUG_LEFT)\n#define DEBUG_LEFT \"\\e[1;36m\"\n#endif\n#if !defined(DEBUG_RIGHT)\n#define DEBUG_RIGHT \":\\e[m\"\n#endif\n#define dump(...) [&](){auto __debug_tap=make_tuple(__VA_ARGS__);DEBUG_OUT<<DEBUG_LEFT<<__LINE__ << DEBUG_RIGHT << \" \" <<#__VA_ARGS__<<\" = \"<<__debug_tap<<endl;}()\ntemplate < class T > inline void dump2D(T &d, size_t sizey, size_t sizex) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << \"\\t\"; for(size_t j = 0; j < sizex; j++) DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\"); DEBUG_OUT << endl; } }\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { o << \"{\"; for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \", \") << *ite; o << \"}\"; return o; }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \" \") << *ite; return o; }\n#endif\n// clang-format on\n// }}}\n\n\n/// --- ModInt Library {{{ ///\n#include <ostream>\ntemplate < ll mod = (ll) 1e9 + 7 >\nstruct ModInt {\n  // math {{{\n  static inline ll extgcd(ll a, ll b, ll &x, ll &y) {\n    ll d;\n    return b == 0 ? (x = 1, y = 0, a) : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline ll modinv(ll a) {\n    ll x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0) x += mod;\n    return x;\n  }\n  static inline ll modpow(ll a, ll b) {\n    if(b < 0) b = -b, a = modinv(a);\n    ll r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  ll val;\n  constexpr ModInt() : val(0) {}\n  constexpr ModInt(ll t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModInt(ll t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // ModInt <arithmetic-operator>[=] ModInt {{{\n  ModInt operator+(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModInt operator-(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModInt operator*(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModInt operator/(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModInt &operator+=(ModInt const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModInt &operator-=(ModInt const &rhs) { return *this += -rhs; }\n  ModInt &operator*=(ModInt const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModInt &operator/=(ModInt const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModInt operator++(int) {\n    ModInt tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModInt operator--(int) {\n    ModInt tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModInt &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModInt &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModInt operator-() const { return ModInt(val == 0 ? 0 : mod - val, 0); }\n  // ModInt <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModInt operator+(T const &rhs) const {\n      return ModInt(val + rhs % mod);\n    }\n  template < typename T >\n    ModInt operator-(T const &rhs) const {\n      return ModInt(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModInt operator*(T const &rhs) const {\n      return ModInt(val * (rhs % mod));\n    }\n  template < typename T >\n    ModInt operator/(T const &rhs) const {\n      return ModInt(val * modinv(rhs));\n    }\n  template < typename T >\n    ModInt &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator/=(T const &rhs) {\n      val = val * modinv(rhs, mod) % mod;\n      return *this;\n    }\n  // }}}\n  ModInt inv() const { return ModInt(modinv(val), 0); }\n  ModInt operator~() const { return inv(); }\n  friend ostream &operator<<(ostream &os, ModInt const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // T <arithmetic-operator> ModInt {{{\n  friend constexpr ModInt operator+(ll a, ModInt const &mv) {\n    return ModInt(a % mod + mv.val);\n  }\n  friend constexpr ModInt operator-(ll a, ModInt const &mv) {\n    return ModInt(a % mod - mv.val);\n  }\n  friend constexpr ModInt operator*(ll a, ModInt const &mv) {\n    return ModInt((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModInt operator/(ll a, ModInt const &mv) {\n    return ModInt((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModInt operator^(ll x) const { return pow(*this, x); }\n  ModInt &operator^=(ll x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModInt pow(ModInt x, ll y) { return ModInt(modpow(x.val, y), 0); }\n  // }}}\n};\n/// }}}--- ///\n\nusing mint = ModInt<>;\n\nmint dp[201][201]; // [i][j] := i個決めた時，古い順はj個下に繋げられるようになっているときの場合の数\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n = 0, m; cin >> m;\n  vector<int> up;\n  for(int i = 0; i < m; i++) {\n    char c;\n    cin >> c;\n    if(c == 'D') n++, up.emplace_back(1); // 上へと結ぶ，という意味で入れ替わっている\n    if(c == 'U') n++, up.emplace_back(0);\n  }\n\n  dp[0][0] = 1;\n  for(int i = 0; i < n; i++) {\n    for(int j = 0; j <= i; j++) {\n      // jだけ，新しい順位を下につなげられる\n      if(up[i]) {\n        // これ自体はj個から選ぶ\n        if(j >= 1) {\n          // 古い順の (i+1) を\n          // 下に向けるとき\n          dp[i+1][j] += dp[i][j] * j;\n          // 上に向けるとき\n          dp[i+1][j-1] += dp[i][j] * j * j;\n        }\n      } else {\n        // 下に向けるとき\n        dp[i+1][j+1] += dp[i][j];\n        // 上に向けるとき\n        if(j >= 1) dp[i+1][j] += dp[i][j] * j;\n      }\n    }\n  }\n\n  cout << dp[n][0] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll m=1000000007,d[222][222],n;\nint main() {\n  cin>>n;\n  d[0][0]=1;\n  for(ll i=0;i<n;i++){\n    char c;cin>>c;\n    for(ll j=0;j<=n;j++){\n      d[i][j]%=m;\n      if(c=='D'){\n        d[i+1][j]+=d[i][j]*j%m;\n        if(j)d[i+1][j-1]+=d[i][j]*j*j%m;\n      }else if(c=='U'){\n        d[i+1][j]+=d[i][j]*j%m;\n        if(j<n)d[i+1][j+1]+=d[i][j];\n      }else d[i+1][j]+=d[i][j];\n    }\n  }\n  cout<<d[n][0]%m<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint N;\nstring S;\n\nLL dp[1234][1234];\nconst LL MOD = 1000000007;\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; ++i) {\n\t\tchar c[2];\n\t\tcin >> c;\n\t\tif (c[0] != '-')S.push_back(c[0]);\n\t}\n\tN = S.size();\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int a = 0; a <= N; ++a) {\n\t\t\tif (S[i] == 'D') {\n\t\t\t\tdp[i + 1][a] += dp[i][a] * a % MOD;\n\t\t\t\tdp[i + 1][a] %= MOD;\n\t\t\t\tif (a) {\n\t\t\t\t\tdp[i + 1][a - 1] += dp[i][a] * a * a % MOD;\n\t\t\t\t\tdp[i + 1][a - 1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i + 1][a] += dp[i][a] * a;\n\t\t\t\tdp[i + 1][a] %= MOD;\n\t\t\t\tdp[i + 1][a + 1] += dp[i][a];\n\t\t\t\tdp[i + 1][a + 1] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[N][0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nconst int MOD = 1000000007;\nll dp[210][210];\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    string s = \"\";\n    rep(i, n){\n        char c; cin >> c;\n        if(c == '-') continue;\n        s += c;\n    }\n    n = s.size();\n    if(!n) goto one;\n    memset(dp, 0, sizeof(dp));\n    if(s[0] == 'D') goto fail;\n    dp[0][1] = 1;\n    REP(i, 1, n){\n        rep(j, i + 2){\n            if(s[i] == 'D'){\n                dp[i][j] += (dp[i - 1][j] * j) % MOD;\n                dp[i][j] += (dp[i - 1][j + 1] * (j + 1) * (j + 1)) % MOD;\n            }else{\n                dp[i][j] += dp[i - 1][j - 1];\n                dp[i][j] += (dp[i - 1][j] * j) % MOD;\n            }\n            dp[i][j] %= MOD;\n        }\n    }\n    printf(\"%d\\n\", dp[n - 1][0]);\n    return 0;\n  fail:\n    puts(\"0\");\n    return 0;\n  one:\n    puts(\"1\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nconst lli mod = 1e9 +7;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<char> c(n);\n    for(int i=0; i<n; i++){\n        cin >> c[i];\n    }\n\n    //dp[i][j] := i番目までで未確定の個数がj個の場合の数\n    vector<vector<lli> > dp(n+1, vector<lli>(n+2, 0));\n    dp[0][0] = 1;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<=n; j++){\n            if(dp[i][j] == 0) continue;\n            if(c[i] == '-'){\n                dp[i+1][j] = dp[i][j];\n            }\n            if(c[i] == 'U'){\n                //単純に未定が1つ増える\n                dp[i+1][j+1] += dp[i][j];\n                dp[i+1][j+1] %= mod;\n                //未定の一つを今見ている順位で確定する\n                dp[i+1][j] += dp[i][j]*j %mod;\n                dp[i+1][j] %= mod;\n            }\n            if(c[i] == 'D'){\n                //未定のどれかを割り当てる\n                dp[i+1][j] += dp[i][j]*j %mod;\n                dp[i+1][j] %= mod;\n                //さらに未定の一つを今見ている順位で確定する\n                dp[i+1][j-1] += dp[i][j]*j*j %mod;\n                dp[i+1][j-1] %= mod;\n            }\n        }\n    }\n    cout << dp[n][0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tll dp[700] = {}, *dp0 = dp+100, *dp1 = dp+400;\n\tdp1[0] = 1;\n\tint n; cin >> n;\n\twhile (n--) {\n\t\tchar c; cin >> c;\n\t\tif (c == '-') continue;\n\t\tfor (int j = 0; j < 210; j++) {\n\t\t\tdp0[j] = (j*dp1[j] +\n\t\t\t\t((c == 'U') ? dp1[j-1] : (j+1)*(j+1)*dp1[j+1])) % (ll)(1e9+7);\n\t\t}\n\t\tswap(dp0, dp1);\n\t}\n\tcout << dp1[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=7+1e9;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b);\n\telse if(arrays[n]==-1) DP[n][a][b]=ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b));\n\telse return DP[n][a][b]=ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b));\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define rnd(d) (ll)((double)(d) + (d >= 0 ? 0.5 : -0.5))\n#define floorsqrt(x) ((ll)sqrt((double)x) + ((ll)sqrt((double)x) * (ll)sqrt((double)x) <= (ll)(x) ? 0 : -1))\n#define ceilsqrt(x) ((ll)sqrt((double)x) + ((ll)x <= (ll)sqrt((double)x) * (ll)sqrt((double)x) ? 0 : 1))\n#define ceildiv(a, b) ((ll)(a) / (ll)(b) + ((ll)(a) % (ll)(b) == 0 ? 0 : 1))\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n\n/*******************************************************/\n\nnamespace mod_op {\n\n\tconst ll MOD = (ll)1e9 + 7;\n\n\tclass Extended_Euclid {\n\tprivate:\n\t\tll m, n;\n\t\tvvll mx_multiply(vvll mx1, vvll mx2) {\n\t\t\tvvll ret(mx1.size(), vll(mx2[0].size(), 0));\n\t\t\tLoop(i, mx1.size()) {\n\t\t\t\tLoop(j, mx1[0].size()) {\n\t\t\t\t\tLoop(k, mx2[0].size()) {\n\t\t\t\t\t\tret[i][j] += mx1[i][k] * mx2[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\tpublic:\n\t\t// solve x, y s.t. mx + ny = gcd(m,n)\n\t\tll x, y, gcd;\n\t\tExtended_Euclid(ll M, ll N) {\n\t\t\tm = M;\n\t\t\tn = N;\n\t\t\tvll r(100), k(100);\n\t\t\tbool swapflag = false, m_negflag = false, n_negflag = false;\n\t\t\tif (m < n) { swap(m, n); swapflag = true; }\n\t\t\tif (m < 0) { m *= -1; m_negflag = true; }\n\t\t\tif (n < 0) { n *= -1; n_negflag = true; }\n\t\t\tr[0] = m;\n\t\t\tr[1] = n;\n\t\t\tint h = 1;\n\t\t\twhile (1) {\n\t\t\t\tk[h - 1] = r[h - 1] / r[h];\n\t\t\t\tr[h + 1] = r[h - 1] % r[h];\n\t\t\t\tif (r[h + 1] == 0) break;\n\t\t\t\th++;\n\t\t\t}\n\t\t\tgcd = r[h];\n\t\t\tvvll mx1 = { { 0, 1 },{ 1, (-1) * k[h - 1] } };\n\t\t\tLoopr(i, h - 1) {\n\t\t\t\tvvll mx2 = { { 0, 1 },{ 1, (-1) * k[i] } };\n\t\t\t\tmx1 = mx_multiply(mx1, mx2);\n\t\t\t}\n\t\t\tx = mx1[0][0];\n\t\t\ty = mx1[0][1];\n\t\t\tif (n_negflag) { n *= -1; y *= -1; }\n\t\t\tif (m_negflag) { m *= -1; x *= -1; }\n\t\t\tif (swapflag) { swap(m, n); swap(x, y); }\n\t\t}\n\t};\n\n\tclass modll {\n\tprivate:\n\t\tll val;\n\t\tinline ll modify(ll x) { ll ret = x % MOD; if (ret < 0) ret += MOD; return ret; }\n\t\tinline ll inv(ll x) { if (x == 0) return 1 / x; Extended_Euclid ee(x, -MOD); return modify(ee.x); }\n\tpublic:\n\t\tmodll(ll init = 0) { val = modify(init); return; }\n\t\tmodll(const modll& another) { val = another.val; return; }\n\t\tinline modll& operator=(const modll &another) { val = another.val; return *this; }\n\t\tinline modll operator+(const modll &x) { return (val + x.val) % MOD; }\n\t\tinline modll operator-(const modll &x) { return (val - x.val) % MOD; }\n\t\tinline modll operator*(const modll &x) { return (val * x.val) % MOD; }\n\t\tinline modll operator/(const modll &x) { return (val * inv(x.val)) % MOD; }\n\t\tinline modll& operator+=(const modll &x) { val = (val + x.val) % MOD; return *this; }\n\t\tinline modll& operator-=(const modll &x) { val = (val - x.val) % MOD; return *this; }\n\t\tinline modll& operator*=(const modll &x) { val = (val * x.val) % MOD; return *this; }\n\t\tinline modll& operator/=(const modll &x) { val = (val * inv(x.val)) % MOD; return *this; }\n\t\tfriend inline istream& operator >> (istream &is, modll& x) { is >> x.val; return is; }\n\t\tfriend inline ostream& operator << (ostream &os, modll& x) { os << x.val; return os; }\n\t\tll get_val() { return val; }\n\t};\n\n\tmodll pow(modll n, ll p) {\n\t\tmodll ret;\n\t\tif (p == 0) ret = 1;\n\t\telse if (p == 1) ret = n;\n\t\telse {\n\t\t\tret = pow(n, p / 2);\n\t\t\tret *= ret;\n\t\t\tif (p % 2 == 1) ret *= n;\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nusing namespace mod_op;\ntypedef vector<modll> vmodll;\ntypedef vector<vector<modll>> vvmodll;\n\nint main() {\n\tconst int N = 201;\n\tint n; cin >> n;\n\tvector<char> a(n);\n\tLoop(i, n) cin >> a[i];\n\tvvmodll dp(N, vmodll(N, 0));\n\tdp[0][0] = 1;\n\tLoop(i, n) {\n\t\tvvmodll dpbuf(N, vmodll(N, 0));\n\t\tLoop(j, N) {\n\t\t\tLoop(k, N) {\n\t\t\t\tif (a[i] == 'U') {\n\t\t\t\t\tif (j > 0) dpbuf[j][k] += dp[j][k] * j;\n\t\t\t\t\tif (j + 1 < N && k + 1 < N) dpbuf[j + 1][k + 1] += dp[j][k];\n\t\t\t\t}\n\t\t\t\telse if (a[i] == 'D') {\n\t\t\t\t\tif (j - 1 >= 0 && k - 1 >= 0) dpbuf[j - 1][k - 1] += dp[j][k] * j * k;\n\t\t\t\t\tif (k > 0) dpbuf[j][k] += dp[j][k] * k;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdpbuf[j][k] = dp[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp = dpbuf;\n\t}\n\tcout << dp[0][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<int MOD> class Modular {\nprivate:\n  long long value;\npublic:\n  constexpr Modular() : value() {};\n  constexpr Modular(const Modular& other) : value(other.value) {}\n  template <typename U> constexpr Modular(const U& x) { value = normalize(x); }\n\n  template <typename U> static long long normalize(const U& x) {\n    long long v;\n    if (-MOD <= x && x < MOD) v = static_cast<long long>(x);\n    else v = static_cast<long long>(x % MOD);\n    if (v < 0) v += MOD;\n    return v;\n  }\n\n  constexpr long long inverse(long long x) {\n    x = (x % MOD + MOD) % MOD;\n    long long y = MOD, u = 1, v = 0;\n    while(y) {\n      long long t = x / y;\n      x -= t * y; swap(x, y);\n      u -= t * v; swap(u, v);\n    }\n    return (u % MOD + MOD) % MOD;\n  }\n\n  explicit operator long long() const noexcept { return value;}\n \ttemplate <typename U> explicit operator U() const noexcept { return static_cast<U>(value); }\n\n  constexpr Modular& operator=(const Modular& other) & noexcept { value = other.value; return *this; }\n  template <typename U> constexpr Modular& operator=(const U& other) & noexcept { return *this = Modular(other); }\n\n  constexpr Modular& operator+=(const Modular& other) noexcept { if ((value += other.value) >= MOD) value -= MOD; return *this; }\n  template <typename U> constexpr Modular& operator+=(const U& other) noexcept { return *this += Modular(other); }\n\n  constexpr Modular& operator-=(const Modular& other) noexcept { if ((value -= other.value) < 0) value += MOD; return *this; }\n  template <typename U> constexpr Modular& operator-=(const U& other) noexcept { return *this -= Modular(other); }\n\n  constexpr Modular& operator*=(const Modular& other) noexcept { value = value * other.value % MOD; return *this; }\n  template <typename U> constexpr Modular& operator*=(const U& other) noexcept {return *this *= Modular(other); }\n\n  constexpr Modular& operator/=(const Modular& other) noexcept { return *this *= Modular(inverse(other.value)); }\n  template <typename U> constexpr Modular& operator/=(const U& other) noexcept { return *this *= Modular(inverse(normalize(other))); }\n\n  constexpr Modular& operator++() noexcept {return *this += 1; }\n  constexpr Modular operator++(int) noexcept { Modular ret(*this); *this += 1; return ret; }\n\n  constexpr Modular& operator--() noexcept {return *this -= 1; }\n  constexpr Modular operator--(int) noexcept { Modular ret(*this); *this += 1; return ret; }\n\n  constexpr Modular operator-() const { return Modular(-value); }\n\n  friend constexpr bool operator==(const Modular<MOD>& lhs, const Modular<MOD>& rhs) noexcept { return lhs.value == rhs.value; }\n  template <typename U> friend constexpr bool operator==(const Modular<MOD>& lhs, U rhs) noexcept { return lhs == Modular<MOD>(rhs); }\n  template <typename U> friend constexpr bool operator==(U lhs, const Modular<MOD>& rhs) noexcept { return Modular<MOD>(lhs) == rhs; }\n\n  friend constexpr bool operator!=(const Modular<MOD>& lhs, const Modular<MOD>& rhs) noexcept { return !(lhs == rhs); }\n  template <typename U> friend constexpr bool operator!=(const Modular<MOD>& lhs, U rhs) noexcept { return !(lhs == rhs); }\n  template <typename U> friend constexpr bool operator!=(U lhs, const Modular<MOD> rhs) noexcept { return !(lhs == rhs); }\n\n  friend constexpr bool operator<(const Modular<MOD>& lhs, const Modular<MOD>& rhs) noexcept { return lhs.value < rhs.value; }\n  template <typename U> friend constexpr bool operator<(const Modular<MOD> &lhs, U rhs) noexcept { return lhs.value < rhs; }\n  template <typename U> friend constexpr bool operator<(U lhs, const Modular<MOD> &rhs) noexcept { return lhs < rhs.value; }\n\n  friend constexpr bool operator>(const Modular<MOD>& lhs, const Modular<MOD>& rhs) noexcept { return rhs.value < lhs.value; }\n  template <typename U> friend constexpr bool operator>(const Modular<MOD> &lhs, U rhs) noexcept { return rhs.value < lhs; }\n  template <typename U> friend constexpr bool operator>(U lhs, const Modular<MOD> &rhs) noexcept { return rhs < lhs.value; }\n\n  friend constexpr bool operator<=(const Modular<MOD>& lhs, const Modular<MOD>& rhs) noexcept { return !(lhs.value > rhs.value); }\n  template <typename U> friend constexpr bool operator<=(const Modular<MOD> &lhs, U rhs) noexcept { return !(lhs.value > rhs); }\n  template <typename U> friend constexpr bool operator<=(U lhs, const Modular<MOD> &rhs) noexcept { return !(lhs < rhs.value); }\n\n  friend constexpr bool operator>=(const Modular<MOD>& lhs, const Modular<MOD>& rhs) noexcept { return !(lhs.value < rhs.value); }\n  template <typename U> friend constexpr bool operator>=(const Modular<MOD> &lhs, U rhs) noexcept { return !(lhs.value < rhs); }\n  template <typename U> friend constexpr bool operator>=(U lhs, const Modular<MOD> &rhs) noexcept { return !(lhs < rhs.value); }\n\n  friend constexpr Modular<MOD> operator+(const Modular<MOD>& lhs, const Modular<MOD>& rhs) noexcept { return Modular<MOD>(lhs) += rhs; }\n  template <typename U> friend constexpr Modular<MOD> operator+(const Modular<MOD>& lhs, U rhs) noexcept { return Modular<MOD>(lhs) += rhs; }\n  template <typename U> friend constexpr Modular<MOD> operator+(U lhs, const Modular<MOD> &rhs) noexcept { return Modular<MOD>(lhs) += rhs; }\n\n  friend constexpr Modular<MOD> operator-(const Modular<MOD>& lhs, const Modular<MOD>& rhs) noexcept { return Modular<MOD>(lhs) -= rhs; }\n  template <typename U> friend constexpr Modular<MOD> operator-(const Modular<MOD>& lhs, U rhs) noexcept { return Modular<MOD>(lhs) -= rhs; }\n  template <typename U> friend constexpr Modular<MOD> operator-(U lhs, const Modular<MOD> &rhs) noexcept { return Modular<MOD>(lhs) -= rhs; }\n\n  friend constexpr Modular<MOD> operator*(const Modular<MOD>& lhs, const Modular<MOD>& rhs) noexcept { return Modular<MOD>(lhs) *= rhs; }\n  template <typename U> friend constexpr Modular<MOD> operator*(const Modular<MOD>& lhs, U rhs) noexcept { return Modular<MOD>(lhs) *= rhs; }\n  template <typename U> friend constexpr Modular<MOD> operator*(U lhs, const Modular<MOD> &rhs) noexcept { return Modular<MOD>(lhs) *= rhs; }\n\n  friend constexpr Modular<MOD> operator/(const Modular<MOD>& lhs, const Modular<MOD>& rhs) noexcept { return Modular<MOD>(lhs) /= rhs; }\n  template <typename U> friend constexpr Modular<MOD> operator/(const Modular<MOD>& lhs, U rhs) noexcept { return Modular<MOD>(lhs) /= rhs; }\n  template <typename U> friend constexpr Modular<MOD> operator/(U lhs, const Modular<MOD> &rhs) noexcept { return Modular<MOD>(lhs) /= rhs; }\n\n  friend std::ostream& operator<<(std::ostream& stream, const Modular<MOD>& number) noexcept { return stream << number.value; }\n  friend std::istream& operator>>(std::istream& stream, Modular<MOD>& number) { long long in; stream >> in; number.value = Modular<MOD>::normalize(in); return stream; }\n  \n  constexpr int getmod() const { return MOD; }\n};\n\ntemplate<int MOD, typename U> Modular<MOD> power(const Modular<MOD>& x, const U& y) {\n  assert(y >= 0);\n  Modular<MOD> k = x, result = 1;\n  U p = y;\n  while (p > 0) {\n    if (p & 1) result *= k;\n    k *= k;\n    p >>= 1;\n  }\n  return result;\n}\n\ntemplate<int MOD> class BinaryCoefficients {\nprivate:\n  vector<Modular<MOD>> fact_, inv_, finv_;\npublic:\n  constexpr BinaryCoefficients(int n = 2020200) : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n    for (int i = 2; i < n; i++) {\n      fact_[i] = fact_[i - 1] * i;\n      inv_[i] = -inv_[MOD % i] * (MOD / i);\n      finv_[i] = finv_[i - 1] * inv_[i];\n    }\n  }\n  constexpr Modular<MOD> comb(int n, int k) const noexcept { if (n < k || n < 0 || k < 0) return 0; return fact_[n] * finv_[k] * finv_[n - k]; }\n  constexpr Modular<MOD> fact(int n) const noexcept { if (n < 0) return 0; return fact_[n]; }\n  constexpr Modular<MOD> inv(int n) const noexcept { if (n < 0) return 0; return inv_[n]; }\n  constexpr Modular<MOD> finv(int n) const noexcept { if (n < 0) return 0; return finv_[n]; }\n};\n\nconstexpr int mod = 1e9 + 7;\n//constexpr int mod = 998244353;\nusing mint = Modular<mod>;\nusing bicoef = BinaryCoefficients<mod>;\n\nmint dp[222][222];\nint in[222];\n\nsigned main() { \n  ios::sync_with_stdio(false); cin.tie(0);\n  int m;\n  cin >> m;\n  int n = 0;\n  while (m--) {\n    char c;\n    cin >> c;\n    if (c == 'U') in[n++] = 1;\n    if (c == 'D') in[n++] = 2;\n  }\n  dp[0][0] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (in[i] == 1) {\n        dp[i + 1][j + 1] += dp[i][j];\n        dp[i + 1][j] += dp[i][j] * j;\n      } else {\n        dp[i + 1][j] += dp[i][j] * j;\n        dp[i + 1][j - 1] += dp[i][j] * j * j;\n      }\n    }\n  }\n  cout << dp[n][0] << endl;\n  return 0;\n}\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nll mod = 1000000007;\n\nint dp[210][210];\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tint n;\n\tcin >> n;\n\tvector<char> a(n);\n\trep(i, n) cin >> a[i];\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tif (a[i - 1] == '-') {\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t}\n\t\t\telse if (a[i - 1] == 'U') {\n\t\t\t\tif (j != 0) dp[i][j] += dp[i - 1][j - 1];\n\t\t\t\tdp[i][j] += dp[i - 1][j] * j;\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] += dp[i - 1][j] * j;\n\t\t\t\tdp[i][j] += dp[i - 1][j + 1] * (j + 1)*(j + 1);\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pii;\ntypedef complex<double> xy_t;\nconst lint mod = 1e9 + 7;\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    char s[n];\n    rep(i, n) scanf(\" %c\", &s[i]);\n    lint dp[n+1][n+1];\n    rep(i, n+1)rep(j, n+1) dp[i][j] = 0;\n    dp[0][0] = 1;\n    rep(i, n)rep(j, n+1)if(dp[i][j]){\n        if(s[i] == '-') dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % mod;\n        else if(s[i] == 'D'){\n            dp[i+1][j] = (dp[i+1][j] + j*dp[i][j]) % mod;\n            if(j > 0) dp[i+1][j-1] = (dp[i+1][j-1] + j*j*dp[i][j]) % mod;\n        }\n        else{\n            dp[i+1][j] = (dp[i+1][j] + j*dp[i][j]) % mod;\n            if(j < n) dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % mod;\n        }\n    }\n    printf(\"%lld\\n\", dp[n][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n#define mod 1000000007\n\nint n;\nll dp[205][205];\nll inv[205];\nstring s[205];\n\nlong long modpow(long long x,long long n){\n\tlong long res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nint main() {\n  cin >> n;\n  for(int i=1;i<=n;i++) cin >> s[i];\n  dp[0][0]=1;\n  for(int i=1;i<=200;i++) inv[i]=modpow(1ll*i,mod-2ll);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=n;j++){\n      if(!dp[i][j]) continue;\n      //cout << dp[i][j] <<\" \" << i << \" \" << j << endl;\n      if(s[i+1]==\"-\"){\n        dp[i+1][j] = (dp[i+1][j]+dp[i][j]*1LL*(n-i-j)*inv[n-i])%mod;\n      }\n      else if(s[i+1]==\"D\")\n      {\n  \t\tdp[i+1][j] = (dp[i+1][j]+dp[i][j]*1LL*j*(n-i-j)*inv[n-i])%mod;\n  \t\tif(j) dp[i+1][j-1] = (dp[i+1][j-1]+dp[i][j]*1LL*j*j*inv[n-i])%mod;\n      }\n      else\n      {\n      \tdp[i+1][j] = (dp[i+1][j]+dp[i][j]*1LL*j*(n-i-j)*inv[n-i])%mod;\n        dp[i+1][j+1] = (dp[i+1][j+1]+dp[i][j]*1LL*(n-i-j)*(n-i-j-1)*inv[n-i])%mod;\n      }\n      \n    }\n  }\n  cout << dp[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1000000007;\nlong long dp[201][201] = {};\n\nvoid add(long long &a, long long b) {\n    a = (a + b) % MOD;\n}\n\nint main() {\n    int N; cin >> N;\n    vector<char> c;\n    for(int i=0; i<N; ++i) {\n        char tmp; cin >> tmp;\n        if(tmp != '-') c.emplace_back(tmp);\n    }\n\n    N = c.size();\n    dp[0][0] = 1;\n    for(int n=0; n<N; ++n) {\n        for(int x=0; x<=N; ++x) {\n            if(c[n] == 'U') {\n                if(x < N) add(dp[n + 1][x + 1], dp[n][x]);\n                add(dp[n + 1][x], dp[n][x] * x);\n            } else {\n                if(x > 0) add(dp[n + 1][x - 1], dp[n][x] * x * x);\n                add(dp[n + 1][x], dp[n][x] * x);\n            }\n        }\n    }\n    cout << dp[N][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[201][201];\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  string c;\n\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  dp[0][0]=1;\n\n  for(int k=0;k<n;k++){\n    for(int i=0;i<=k;i++){\n      if(c[k]=='-')dp[k+1][i]+=dp[k][i];\n      else if(c[k]=='D'){\n        dp[k+1][i-1]+=dp[k][i]*i*i;\n        dp[k+1][i]+=dp[k][i]*i;\n        dp[k+1][i-1]%=MOD;\n      }\n      else if(c[k]=='U'){\n        dp[k+1][i]+=dp[k][i]*i;\n        dp[k+1][i+1]+=dp[k][i];\n        dp[k+1][i+1]%=MOD;\n      }\n      dp[k+1][i]%=MOD;\n    }\n  }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\nll dp[201][201];\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  INT(n); vector<char> c(n); cin >> c;\n  dp[0][0] = 1;\n  rep(i, n){\n  \trep(j, n + 1){\n\t  \tif(c[i] == '-')dp[i+1][j] = dp[i][j];\n\t  \telse if(c[i] == 'U')dp[i+1][j] = ((j>0?dp[i][j-1]:0) + dp[i][j] * j % mod) % mod;\n\t  \telse if(c[i] == 'D')dp[i+1][j] = (dp[i][j] * j % mod + dp[i][j+1] * (j + 1) * (j + 1) % mod) % mod;\n  \t}\n  }\n  cout << dp[n][0] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//const int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nconst int mod = 100000000+7;\nint N;\nchar field[210];\nint sumd[210];\nint dp[210][210][210];\n\nll dfs(int pos,int u,int d){\n  if(dp[pos][u][d]>=0)return dp[pos][u][d];\n  ll res = 0;\n  if(pos == N){\n    if(u == 0 && d == 0)res = 1;\n  }\n  else{\n    if(field[pos] == '-')res = dfs(pos+1,u,d);\n    else if(field[pos]=='U'){\n      // ここに割り当て可能なのは、ここより下にあるDと、ここより上にあるUのうちどれかひとつ\n      if(u>0)res = (res + (dfs(pos+1,u-1+1,d)*u)%mod )%mod;\n      // ここで割り当てるDは下にあるDのうちどれか一つ\n      res = (res + (dfs(pos+1,u+1,d+1))%mod)%mod;\n    }\n    else if(field[pos]=='D'){\n      // ここに割り当て可能なのは、ここより下にあるDと、ここより上にあるU\n      // このdは消化されたものとして扱う\n      if(d>0){\n        // 今回のパターンは、どれに割り当てられたかで場合分けが必要\n        if(u>0)res = (res + (dfs(pos+1,u-1,d-1)*u)%mod)%mod;\n        res = (res + (dfs(pos+1,u,d))%mod)%mod;\n        res = (res * d) % mod;\n      }\n    }\n  }\n  return dp[pos][u][d] = res;\n}\n\nint main(){\n\n  cin>>N;\n  for(int i=0;i<N;i++)cin>>field[i];\n  memset(dp,-1,sizeof(dp));\n  for(int i=0;i<N;i++)\n    sumd[i+1] = sumd[i] + (field[i] == 'D');\n  cout<<dfs(0,0,0)<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nint main(){\n    int N;\n    char C[200];\n    cin >> N;\n    for(int i=0; i<N; i++) cin >> C[i];\n\n    static int64_t dp[201][201] = {0};\n    dp[0][0] = 1;\n    for(int i=0; i<N; i++) for(int j=0; j<N; j++){\n        if(dp[i][j] == 0) continue;\n        if(C[i] == 'U'){\n            add(dp[i+1][j+1], dp[i][j]);\n            add(dp[i+1][j], dp[i][j] * j);\n        }else if(C[i] == 'D'){\n            add(dp[i+1][j], dp[i][j] * j);\n            if(j > 0) add(dp[i+1][j-1], dp[i][j] * j * j);\n        }else{\n            add(dp[i+1][j], dp[i][j]);\n        }\n    }\n    cout << dp[N][0] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\nint main(){\n    ll n;\n    cin>>n;\n    vector<char> A(n);\n    for(auto &I:A){cin>>I;}\n    vector<ll> dp(n+1,0);\n    vector<ll> next(n+1,0);\n    dp[0]=1;\n    for(auto &I:A){\n        for(auto &T:next){T=0;}\n        if(I=='-'){continue;}\n        if(I=='U'){\n            for(int i=0;i<=n;i++){\n                if(i>0){next[i]+=dp[i]*i%MOD; next[i]%=MOD;}\n                if(i<n){next[i+1]+=dp[i]; next[i+1]%=MOD;}\n            }\n        }\n        else{\n            for(int i=0;i<=n;i++){\n                if(i>0){next[i-1]+=dp[i]*i%MOD*i%MOD; next[i]%=MOD;}\n                next[i]+=dp[i]*i%MOD; next[i]%=MOD;\n            }\n        }\n        dp=next;\n    }\n    cout<<dp[0]<<endl;\n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>{\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b,QF &&qf) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1,qf);\n\t}*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l,int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nclass Lowlink {\n\tvector<vector<int>> G;\n\tvector<int> order;\n\tvector<pair<int, int>> bridge_;\n\tvector<int> articulation_;\n\tint next = 0;\n\tint dfs(int v, int prev) {\n\t\tint res = order[v] = next++;\n\t\tbool is_articulation = 0;\n\t\tint d = 0;\n\t\tfor (auto to : G[v]) {\n\t\t\tif (to == prev)continue;\n\t\t\tif (order[to] >= 0)res = min(res, order[to]);\n\t\t\telse {\n\t\t\t\tint low = dfs(to, v);\n\t\t\t\tif (low > order[v])bridge_.emplace_back(v, to);\n\t\t\t\tif (prev >= 0 && low >= order[v])is_articulation = 1;\n\t\t\t\tres = min(res, low);\n\t\t\t\td++;\n\t\t\t}\n\t\t}\n\t\tif (prev < 0 && d >= 2)is_articulation = 1;\n\t\tif (is_articulation)articulation_.push_back(v);\n\t\treturn res;\n\t}\npublic:\n\tLowlink(int size) :G(size + 1) {}\n\tvoid add_edge(int from, int to) {\n\t\tG[from].push_back(to);\n\t}\n\tvoid solve(int start = 0) {\n\t\tdfs(start, -1);\n\t}\n\tconst auto& bridge() {\n\t\treturn bridge_;\n\t}\n\tconst auto& articulation() {\n\t\treturn articulation_;\n\t}\n};\nclass SCC {\n\tint V;\n\tint solved = -1;\n\tvector<vector<int>> G, rG;\n\tvector<int> vs;\n\tvector<char> used;\n\tvector<int> cmp;\n\tvoid dfs(int v) {\n\t\tused[v] = 1;\n\t\tfor (auto a : G[v])if (!a)dfs(a);\n\t\tvs.push_back(v);\n\t}\n\tvoid rdfs(int v, int k) {\n\t\tused[v] = 1;\n\t\tcmp[v] = k;\n\t\tfor (auto a : rG[v])if (used[a])rdfs(a, k);\n\t}\npublic:\n\tSCC(int size) :V(size + 1), G(size + 1), rG(size + 1), vs(size + 1), used(size + 1), cmp(size + 1) {}\n\tvoid add_edge(int from, int to) {\n\t\tsolved = -1;\n\t\tG[from].push_back(to);\n\t\trG[to].push_back(from);\n\t}\n\tint scc() {\n\t\tif (solved != -1)return solved;\n\t\tfill(ALL(used), 0);\n\t\tvs.clear();\n\t\tfor (int i = 0; i < V; i++)if (!used[i])dfs(i);\n\t\tfill(ALL(used), 0);\n\t\tint k = 0;\n\t\tfor (int i = vs.size() - 1; i >= 0; i--)if (!used[vs[i]])rdfs(vs[i], k++);\n\t\tsolved = k;\n\t\treturn k;\n\t}\n\tconst auto& group() {\n\t\treturn cmp;\n\t}\n};\numap<pair<int, int>, int> m;\nint f(int a, int b) {\n\tb &= (2ll << a - 1);\n\tif (m.find(pii(a, b)) != m.end())return m[pii(a, b)];\n\tset<int> s;\n\trep1(i, a) {\n\t\tif (b & 1 << i)continue;\n\t\ts.insert(f(a - i, b | 1 << i));\n\t}\n\trep(i, 60) {\n\t\tif (s.find(i) == s.end()) {\n\t\t\tm[pii(a, b)] = i;\n\t\t\treturn i;\n\t\t}\n\t}\n}\ntemplate<class T>\nclass lazysegtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse {\n\t\t\tT ret(e);\n\t\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t\treturn ret.merge(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t\t}\n\t}\n\ttemplate<class Param>\n\tT update(int a, int b, int k, int l, int r, const Param& param) {\n\t\tif (r <= a || b <= l)return obj[k];\n\t\tif (a <= l && r <= b) {\n\t\t\tobj[k].update(param);\n\t\t\treturn obj[k];\n\t\t}\n\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\treturn obj[k].merge(update(a, b, k * 2 + 1, l, (l + r) / 2, param), update(a, b, k * 2 + 2, (l + r) / 2, r, param));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\ttemplate<class Param>\n\tvoid update(int a, int b, Param&& param) {\n\t\tupdate(a, b, 0, 0, offset + 1, param);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i].merge(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\t/*\n\tvoid update(int k, T &a) {\n\tk += offset;\n\tobj[k] = a;\n\twhile (k) {\n\tk = k - 1 >> 1;\n\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t}\n\t}*/\n\tlazysegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tlazysegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nclass lazyRMQ_t {\n\tint min, add;\npublic:\n\tint getmin() {\n\t\treturn min;\n\t}\n\tlazyRMQ_t() {\n\t\tmin = numeric_limits<int>::max()/2; add = 0;\n\t}\n\tlazyRMQ_t(int a,int b=0) {\n\t\tmin = a; add = b;\n\t}\n\tvoid propagate(lazyRMQ_t &a, lazyRMQ_t &b) {\n\t\ta.min += add;\n\t\tb.min += add;\n\t\ta.add += add;\n\t\tb.add += add;\n\t\tadd = 0;\n\t}\n\tlazyRMQ_t& merge(const lazyRMQ_t &a,const lazyRMQ_t &b) {\n\t\tmin = std::min(a.min, b.min);\n\t\tadd = 0;\n\t\treturn *this;\n\t}\n\tlazyRMQ_t& update(int k) {\n\t\tmin += k;\n\t\tadd += k;\n\t\treturn *this;\n\t}\n};\nint dp[201][201];\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<char> c(n);\n\trep(i, n)cin >> c[i];\n\tdp[0][0] = 1;\n\trep(i, n){\n\t\trep(j, n) {\n\t\t\tswitch (c[i]) {\n\t\t\tcase '-':\n\t\t\t\t(dp[i + 1][j] += dp[i][j]) %= mod;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\t(dp[i + 1][j] += (ll)dp[i][j] * j%mod) %= mod;\n\t\t\t\t(dp[i + 1][j + 1] += dp[i][j]) %= mod;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\t(dp[i + 1][j] += (ll)dp[i][j] * j%mod) %= mod;\n\t\t\t\tif (j == 0)break;\n\t\t\t\t(dp[i + 1][j - 1] += (ll)dp[i][j] * j*j%mod) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nLL dp[210][210];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n  dp[0][0] = 1;\n  REP(i,N){\n\tchar c;\n\tcin >> c;\n\tif(c == 'U'){\n\t  REP(j,201){\n\t\t(dp[i+1][j+1] += dp[i][j]) %= MOD;\n\t\t(dp[i+1][j] += dp[i][j] * j % MOD) %= MOD;\n\t  }\n\t}\n\telse if(c == 'D'){\n\t  REP(j,201){\n\t\tif(j>0) (dp[i+1][j-1] += dp[i][j] * j * j % MOD) %= MOD;\n\t\t(dp[i+1][j] += dp[i][j] * j % MOD) %= MOD;\n\t  }\n\t}\n\telse{\n\t  REP(j,210) dp[i+1][j] = dp[i][j];\n\t}\n  }\n  cout << dp[N][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n#define MOD 1000000007\nlli dp[205][210]={};\n\nvoid add(lli& p,lli q){\n\tp = (p + q) % MOD;\n}\n\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\tdp[0][0]=1;\n\tint t=0;\n\trep(i,n){\n\t\tchar s[5];\n\t\tscanf(\"%s\",s);\n\t\tif(s[0]=='-')continue;\n\t\trep(j,n+5){\n\t\t\t//printf(\"%lld \",dp[t][j]);\n\t\t\tif(s[0]=='U'){\n\t\t\t\tadd(dp[t+1][j+1],dp[t][j]);\n\t\t\t\tadd(dp[t+1][j],dp[t][j] * j);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tadd(dp[t+1][j],dp[t][j] * j);\n\t\t\t\tif(j>0){\n\t\t\t\t\tadd(dp[t+1][j-1],dp[t][j] * j * j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"\\n\");\n\t\tt++;\n\t}\n\tprintf(\"%d\\n\",dp[t][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nlong long dp[210][210];\n\nint main() {\n    int n;\n    cin >> n;\n    int c[205];\n    for (int i = 0; i < n; ++i) {\n        char cc;\n        cin >> cc;\n        c[i] = cc == 'U' ? 1 : cc == '-' ? 0 : -1;\n    }\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        if (c[i] == 1) {\n            for (int j = 0; j < 205; ++j) {\n                dp[i + 1][j + 1] = (dp[i][j] + dp[i][j + 1]) * (j + 1) % M;\n            }\n        }\n        if (c[i] == 0) {\n            for (int j = 0; j < 205; ++j) {\n                dp[i + 1][j] = dp[i][j];\n            }\n        }\n        if (c[i] == -1) {\n            for (int j = 0; j < 205; ++j) {\n                dp[i + 1][j] = (dp[i][j] * j + dp[i][j + 1] * (j + 1)) % M;\n            }\n        }\n        // for (int j = 0; j < i + 3; ++j) {\n        //     cout << dp[i + 1][j] << \" \";\n        // }\n        // cout << \"\\n\";\n    }\n    cout << dp[n][0] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nll n,dp[211][211];\nstring s;\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tint N;\n\tcin>>N;\n\trep(i,N){\n\t\tchar c;cin>>c;\n\t\tif(c!='-')s+=c;\n\t}\n\tn=sz(s);\n\tdp[0][0]=1;\n\trep(i,n){\n\t\trep(j,n+1){\n\t\t\tif(s[i]=='U'){\n\t\t\t\tdp[i+1][j] += dp[i][j]*j;\n\t\t\t\tdp[i+1][j]%=MOD;\n\t\t\t\tdp[i+1][j+1] += dp[i][j];\n\t\t\t\tdp[i+1][j+1]%=MOD;\n\t\t\t}else{\n\t\t\t\tdp[i+1][j] += dp[i][j]*j;\n\t\t\t\tdp[i+1][j]%=MOD;\n\t\t\t\tif(j>0){\n\t\t\t\t\tdp[i+1][j-1] += dp[i][j]*j%MOD*j;\n\t\t\t\t\tdp[i+1][j-1]%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reprrev(i,a,b) for(int i=b-1;i>=a;i--) // [a, b)\n#define reprev(i,n) reprrev(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst ll mod = 1e9+7;\n\n\nvoid chmod(ll &M){\n    if(M >= mod) M %= mod;\n    else if(M < 0){\n        M += (abs(M)/mod + 1)*mod;\n        M %= mod;\n    }\n}\n\nll modpow(ll x, ll n){\n    if(n==0) return 1;\n    ll res=modpow(x, n/2);\n\n    if(n%2==0) return res*res%mod;\n    else return res*res%mod*x%mod;\n}\n\nint getl(int i, int N) { return i==0? N-1:i-1; };\nint getr(int i, int N) { return i==N-1? 0:i+1; };\n\n// 線分 ab の偏角 返り値は[-π, π]\ndouble argument(const pair<double, double> &a, const pair<double, double> &b){\n    double ax=a.first, ay=a.second, bx=b.first, by=b.second;\n    return atan2(by-ay, bx-ax);\n}\n\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n\n\n/* 注意 \n\n    1LL<<60 * N とかのオーバーフローに気を付けろ\n    制約がヒントになる、ちゃんと全ての制約を見ろ\n\n*/\n\n\nint main(void) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    vector<char> c(n);\n    rep(i, n) cin >> c[i];\n\n    vector<vector<ll>> dp(n+5, vector<ll>(n+5, 0));\n\n    dp[0][0] = 1;\n    rep(i, n) rep(j, i+1) if (dp[i][j]) {\n        if(c[i] == 'U') {\n            (dp[i+1][j+1] += dp[i][j]*(i-j)) %= mod;\n            (dp[i+1][j] += dp[i][j]) %= mod;\n        }\n        if(c[i] == 'D') {\n            (dp[i+1][j+2] += dp[i][j]*(i-j)*(i-j)) %= mod;\n            (dp[i+1][j+1] += dp[i][j]*(i-j)) %= mod;\n        }\n        if(c[i] == '-') {\n            (dp[i+1][j+1] += dp[i][j]) %= mod;\n        }\n    }\n\n    cout << dp[n][n] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define each(x, y) for (auto &x : y)\n#define all(a) (a).begin(), (a).end()\n#define bit32(x) (1 << (x))\n#define bit64(x) (1ll << (x))\n\nusing namespace std;\n\nusing i32 = int;\nusing i64 = long long;\nusing f80 = long double;\nusing vi32 = vector<i32>;\nusing vi64 = vector<i64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\ninline void yes() { cout << \"Yes\" << '\\n'; exit(0); }\ninline void no() { cout << \"No\" << '\\n'; exit(0); }\ninline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }\ninline i64 lcm(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); return a / gcd(a, b) * b; }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> inline void amax(T &x, T y) { if (x < y) x = y; }\ntemplate <typename T> inline void amin(T &x, T y) { if (x > y) x = y; }\ntemplate <typename T> inline T exp(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { each(x, v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\n\ntemplate <int mod>\nstruct ModInt {\n  int x;\n  ModInt(): x(0) {}\n  ModInt(long long a) { x = a % mod; if (x < 0) x += mod; }\n  ModInt &operator+=(ModInt that) { x = (x + that.x) % mod; return *this; }\n  ModInt &operator-=(ModInt that) { x = (x + mod - that.x) % mod; return *this; }\n  ModInt &operator*=(ModInt that) { x = (long long) x * that.x % mod; return *this; }\n  ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n  ModInt inverse() {\n    int a = x, b = mod, u = 1, v = 0;\n    while (b) { int t = a / b; a -= t * b; u -= t * v; swap(a, b); swap(u, v); }\n    return ModInt(u);\n  }\n  #define op(o, p) ModInt operator o(ModInt that) { return ModInt(*this) p that; }\n    op(+, +=) op(-, -=) op(*, *=) op(/, /=)\n  #undef op\n  friend ostream& operator<<(ostream &os, ModInt m) { return os << m.x; }\n};\n\nusing mint = ModInt<1000000007>;\n\nmint dp[210][210];\n\nvoid solve() {\n  dp[0][0] = 1;\n  int n;\n  cin >> n;\n  rep(i, n) {\n    char c;\n    cin >> c;\n    repc(j, 200) {\n      if (c == '-') {\n        dp[i + 1][j] += dp[i][j];\n      } else if (c == 'U') {\n        dp[i + 1][j + 1] += dp[i][j];\n        dp[i + 1][j] += dp[i][j] * j;\n      } else {\n        if (j > 0) dp[i + 1][j - 1] += dp[i][j] * j * j;\n        if (j > 0) dp[i + 1][j] += dp[i][j] * j;\n      }\n    }\n  }\n  cout << dp[n][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF      100000000\n#define EPS      1e-10\n#define MOD      1000000007\nusing namespace std;\ntypedef long long ll;\n\nint n;\nll dp[222][222];\n\nint main(){\n    cin >> n;\n    dp[0][0] = 1;\n    rep(i,n){\n        char x;\n        cin >> x;\n        if(x == '-'){\n            for(int j = 0; j <= n; j++){\n                dp[i+1][j] = dp[i][j];\n            }\n            continue;\n        }\n        if(x == 'U'){\n            for(int j = 0; j <= n; j++){\n                dp[i+1][j+1] = (dp[i+1][j+1]+dp[i][j])%MOD;\n                dp[i+1][j] = (dp[i+1][j]+dp[i][j]*j)%MOD;\n            }\n        } else{\n            for(int j = 0; j <= n; j++){\n                dp[i+1][j-1] = (dp[i+1][j-1]+dp[i][j]*j*j)%MOD;\n                dp[i+1][j] = (dp[i+1][j]+dp[i][j]*j)%MOD;\n            }\n        }\n    }\n    cout << dp[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i+1][j]+=dp[i][j]*j;\n      if(j)dp[i+1][j-1]+=dp[i][j]*j*j;\n      dp[i+1][j]%=Prime;\n      if(j)dp[i+1][j-1]%=Prime;\n    }else{\n      dp[i+1][j+1]+=dp[i][j];\n      dp[i+1][j]+=dp[i][j]*j;\n      dp[i+1][j+1]%=Prime;\n      dp[i+1][j]%=Prime;\n    }\n  }}\n  printf(\"%d\\n\",dp[i][0]);\n  return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MOD 1000000007\n\ntypedef long long ll;\n\nll dp[201][201][201] = {0}; // dp[n][rest U][rest empty box] = ??´????????°\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> v;\n\tfor (int i = 0; i < N; ++i) {\n\t\tchar c; cin >> c;\n\t\tif (c != '-') {\n\t\t\tv.push_back(c);\n\t\t}\n\t}\n\tN = v.size();\n\n\tif (v[0] == 'D') {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tdp[0][1][1] = 1; // v[0] = 'U'\n\tfor (int i = 0; i < N-1; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (v[i+1] == 'U') {\n\t\t\t\t\tdp[i+1][j+1][k+1] = (dp[i+1][j+1][k+1] + dp[i][j][k]) % MOD;\n\t\t\t\t\tif (j >= 1) {\n\t\t\t\t\t\tdp[i+1][j][k] = (dp[i+1][j][k] + j * dp[i][j][k]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { // D\n\t\t\t\t\tif (k >= 1) {\n//\t\t\t\t\t\tif (dp[i][j][k]) cout << i << \" \" << j << \" \" << k << \" : \" << dp[i][j][k] << endl;\n\t\t\t\t\t\tdp[i+1][j][k] = (dp[i+1][j][k] + k * dp[i][j][k]) % MOD;\n\t\t\t\t\t\tif (j >= 1) {\n\t\t\t\t\t\t\tdp[i+1][j-1][k-1] = (dp[i+1][j-1][k-1] + j * k * dp[i][j][k]) % MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[N-1][0][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 INF = 1e18 + 7;\nconst i64 MOD = 1e9 + 7;\n\ntemplate <i64 mod = MOD>\nstruct ModInt{\n    i64 p;\n\n    ModInt() : p(0){}\n    ModInt(i64 x){p = x >= 0 ? x % mod : x + (-x + mod - 1) / mod * mod;}\n\n    ModInt& operator+=(const ModInt& y){p = p + *y - ((p + *y) >= mod ? mod : 0); return *this;}\n    ModInt& operator-=(const ModInt& y){p = p - *y + (p - *y < 0 ? mod : 0); return *this;}\n    ModInt& operator*=(const ModInt& y){p = (p * *y) % mod; return *this;}\n    ModInt& operator%=(const ModInt& y){if(y)p %= *y; return *this;}\n\n    ModInt operator+(const ModInt& y) const{ModInt x = *this; return x += y;}\n    ModInt operator-(const ModInt& y) const{ModInt x = *this; return x -= y;}\n    ModInt operator*(const ModInt& y) const{ModInt x = *this; return x *= y;}\n    ModInt operator%(const ModInt& y) const{ModInt x = *this; return x %= y;}\n\n    friend ostream& operator<<(ostream& stream, const ModInt<mod>& x){\n        stream << *x;\n        return stream;\n    }\n\n    friend ostream& operator>>(ostream& stream, const ModInt<mod>& x){\n        stream >> *x;\n        return stream;\n    }\n\n    ModInt& operator++(){p = (p + 1) % mod; return *this;}\n    ModInt& operator--(){p = (p - 1 + mod) % mod; return *this;}\n\n    bool operator==(const ModInt& y) const{return p == *y;}\n    bool operator!=(const ModInt& y) const{return p != *y;}\n\n    const i64& operator*() const{return p;}\n    i64& operator*(){return p;}\n\n};\n\nusing mint = ModInt<>;\n\n\nsigned main(){\n    int n;\n    cin >> n;\n    vector<int> a(n, 0);\n    for(auto& x : a){\n        char s;\n        cin >> s;\n        if(s == 'U')\n            x = 2;\n        if(s == 'D')\n            x = 1;\n    }\n\n    vector<mint> dp(n + 1, 0);\n    dp[0] = 1;\n    for(int i = 0; i < n; ++i){\n        if(!a[i])\n            continue;\n        vector<mint> nex(n + 1, 0);\n        for(int j = 0; j < n; ++j){\n                if(dp[j] == mint(0))\n                    continue;\n                // up\n                if(a[i] == 1){\n                    // umeru\n                    nex[j] += dp[j] * j;\n                    // umenai\n                    if(j)\n                        nex[j - 1] += dp[j] * j * j;\n                }\n                // down\n                else{\n                    // umeru\n                    nex[j] += dp[j] * j;\n                    // umenai\n                    nex[j + 1] += dp[j];\n                }\n        }\n        dp = move(nex);\n    }\n\n    cout << dp[0] << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\nll nextLong() { ll x; scanf(\"%lld\", &x); return x;}\n\nconst ll MOD = (ll)(1e9 + 7);\nconst int MAX_N = 205;\nll dp[MAX_N][MAX_N];\n\nint main2() {\n  int N = nextInt();\n  string v;\n  REP(i, N) {\n    string s; cin >> s;\n    if (s == \"U\") v.push_back('U');\n    if (s == \"D\") v.push_back('D');\n  }\n  N = v.size();\n  CLR(dp, 0);\n  dp[0][0] = 1;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j <= N; j++) {\n      dp[i][j] %= MOD;\n      if (dp[i][j] == 0) continue;\n      if (v[i] == 'U') {\n        dp[i+1][j] += j * dp[i][j] % MOD;\n        dp[i+1][j+1] += dp[i][j];\n      } else if (v[i] == 'D') {\n        if (j-1 >= 0) dp[i+1][j-1] += j * j * dp[i][j] % MOD;\n        dp[i+1][j] += j * dp[i][j] % MOD;\n      }\n    }\n  }\n  ll ans = dp[N][0] % MOD;\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n\n#ifdef LOCAL\n  for (;!cin.eof();cin>>ws)\n#endif\n    main2();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[201][201];\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  string c;\n\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  dp[0][0]=1;\n\n  for(int k=0;k<n;k++){\n    for(int i=0;i<=k;i++){\n      if(c[k]=='-')dp[k+1][i]+=dp[k][i];\n      else if(c[k]=='D'){\n        if(i>0){\n          dp[k+1][i-1]+=dp[k][i]*i*i;\n          dp[k+1][i-1]%=MOD;\n        }\n        dp[k+1][i]+=dp[k][i]*i;\n      }\n      else if(c[k]=='U'){\n        dp[k+1][i]+=dp[k][i]*i;\n        dp[k+1][i+1]+=dp[k][i];\n        dp[k+1][i+1]%=MOD;\n      }\n      dp[k+1][i]%=MOD;\n    }\n  }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconstexpr int MOD = int(1e9) + 7;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<bool> up;\n    for (int i = 0; i < N; ++i) {\n        char c;\n        cin >> c;\n        cin.ignore();\n\n        if (c == 'U') {\n            up.push_back(true);\n        }\n        else if (c == 'D') {\n            up.push_back(false);\n        }\n    }\n    N = up.size();\n\n    vector<vector<vector<ll>>> dp(N + 1, vector<vector<ll>>(N + 1, vector<ll>(N + 1, 0LL)));\n    dp[0][0][0] = 1;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) for (int k = 0; k < N; ++k) {\n            if (up[i]) {\n                dp[i + 1][j][k] = (dp[i + 1][j][k] + j * dp[i][j][k]) % MOD;\n                dp[i + 1][j + 1][k + 1] = (dp[i + 1][j + 1][k + 1] + dp[i][j][k]) % MOD;\n            }\n            else {\n                if (j > 0 && k > 0) {\n                    dp[i + 1][j - 1][k - 1] = (dp[i + 1][j - 1][k - 1] + (ll)j * k * dp[i][j][k]) % MOD;\n                }\n                if (k > 0) {\n                    dp[i + 1][j][k] = (dp[i + 1][j][k] + k * dp[i][j][k]) % MOD;\n                }\n            }\n        }\n    }\n\n    cout << dp[N][0][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nchar S[200]; int n;\nlong long dp[220][220];\nint main() {\n\tcin >> n; dp[0][0] = 1;\n\tfor (int i = 0; i < n; i++)cin >> S[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (dp[i][j] == 0)continue;\n\t\t\tif (S[i] == '-') {\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t}\n\t\t\tif (S[i] == 'D') {\n\t\t\t\tif (j >= 1)dp[i + 1][j - 1] += dp[i][j] * j*j;\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j;\n\t\t\t}\n\t\t\tif (S[i] == 'U') {\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j;\n\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nDPの典型手法とのことで以下のブログを参考にやった.\nhttps://creep06.hatenablog.com/entry/20180927/1537996410\n箱根DPとか未確定DPとかいうらしい.\n多分このDPはDPによくある「i番目まで見たとき~」という情報に加えて\nまだ未使用のものの数を状態に持たせるようなものであると考えられる.\n今回の問題では, 上記のブログにある図のような二部グラフっぽいものを考えて\nまだペアになっていないような頂点の数を状態として保持させている.\ni番目までの頂点を見た時, 左側の頂点と右側の頂点それぞれをペアにしたり\nしなかったりすることで状態を遷移することでDPをする.\n結局この問題では以下のテーブルを定義することで解ける.\ndp[i][j][k]: i番目の頂点のペアを見て, 左側の頂点がj個, 右側の頂点がk個残っているような場合の通り数\nこれを埋める場合O(N^3)かかるのだが, 左右どちらかの頂点がペアを作るときはその反対側の残っている頂点が\n使用されるためどちらも同時に1減るし, どちらの頂点も使用しないならどちらの頂点の数も+1するため\n状態におけるjとkは同じ値をとることになる.\nそのためj!=kとなるdpテーブルは全て0になるので実際は以下のテーブルで解くことができる.\ndp[i][j]: i番目の頂点のペアを見て, 左右の頂点がj個残っているような場合の数\nこっちの場合はO(N^2)となるためより高速に動作する.\n*/\n#include<iostream>\n#include<vector>\n#include<string>\n#define rep(i, start, end) for (int i = (int)start; i < (int)end; ++i)\n#define rrep(i, start, end) for (int i = (int)start - 1; i >= end; --i)\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\ntemplate<typename T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true;} return 0;}\ntemplate<typename T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true;} return 0;}\n\ntemplate<typename T, long long MOD_VALUE>\nclass ModInt {\n    static constexpr long long MOD = MOD_VALUE;\n    private:\n        T value_;\n    public:\n        ModInt() {}\n        ModInt(const T& value) {if (value >= 0) {value_ = value % MOD;} else {T k = (MOD - 1 - value) / MOD; value_ = (value + k * MOD) % MOD;}}\n        ModInt& operator+=(const ModInt& x)  {value_ += x.value_; if (value_ >= MOD) value_ -= MOD; return *this;}\n        friend ModInt& operator+=(const T& x, const ModInt& y) {ModInt res(x); res.value_ += x.value_; if (res.value_ >= MOD) res.value_ -= MOD; return res;}\n        ModInt& operator-=(const ModInt& x) {if (value_ < x.value_) value_ += MOD; value_ -= x.value_; return *this;}\n        friend ModInt& operator-=(const T& x, const ModInt& y) {ModInt res(x); if (res.value_ < y.value_) res.value_ += MOD; res.value_ -= y.value_; return res;}\n        ModInt& operator*=(const ModInt& x) {value_ = (value_ * x.value_) % MOD; return *this;}\n        friend ModInt& operator*=(const T& x, const ModInt& y) {ModInt res(x); res.value_ = (res.value_ * y.value_) % MOD; return res;}\n        const ModInt operator+(const ModInt& x) const {return ModInt(*this) += x;}\n        friend const ModInt operator+(const T& x, const ModInt& y) {return ModInt(x) += y;}\n        const ModInt operator-(const ModInt& x) const {return ModInt(*this) -= x;}\n        friend const ModInt operator-(const T& x, const ModInt& y) {return ModInt(x) -= y;}\n        const ModInt operator*(const ModInt& x) const {return ModInt(*this) *= x;}\n        friend const ModInt operator*(const T& x, const ModInt& y) {return ModInt(x) *= y;}\n        static ModInt modpow(ModInt x, long long y) {ModInt z = 1; while (y > 0) {if (y & 1) {z *= x;}x *= x; y /= 2;} return z;}\n        ModInt& operator/=(const ModInt& x) {return *this *= modpow(x, MOD - 2);}\n        const ModInt operator/(const ModInt& x) const {return ModInt(*this) /= x;}\n        friend const ModInt operator/(const T& x, const ModInt& y) {return ModInt(x) /= y;}\n        ModInt operator++(int) {ModInt tmp(*this); value_ = (value_ + 1 == MOD ? 0 : value_ + 1); return tmp;}\n        ModInt operator--(int) {ModInt tmp(*this); value_ = (value_ - 1 < 0 ? MOD - 1 : value_ - 1); return tmp;}\n        friend istream& operator>>(istream& stream, ModInt& x) {stream >> x.value_; x.value_ %= MOD; return stream;}\n        friend ostream& operator<<(ostream& stream, const ModInt& x) {stream << x.value_; return stream;}\n};\n\nusing mint = ModInt<ll, 1000000007>;\n\nvoid solve1(int N, const vector<char>& C) {\n    vector<vector<vector<mint>>> dp(N + 1, vector<vector<mint>>(N + 1, vector<mint>(N + 1, 0)));\n    dp[0][0][0] = 1;\n    rep(i, 0, N) rep(j, 0, N + 1) rep(k, 0, N + 1) {\n        if (C[i] == 'D') {\n            if (j >= 1 && k >= 1) {\n                dp[i + 1][j - 1][k - 1] += dp[i][j][k] * j * k;\n            }\n            dp[i + 1][j][k] += dp[i][j][k] * j;\n        }\n        else if (C[i] == 'U') {\n            dp[i + 1][j][k] += dp[i][j][k] * k;\n            if (j < N && k < N) {\n                dp[i + 1][j + 1][k + 1] += dp[i][j][k];\n            }\n        }\n        else {\n            if (j < N && k < N) {\n                dp[i + 1][j][k] += dp[i][j][k];\n            }\n        }\n    }\n    cout << dp[N][0][0] << endl;\n    return;\n}\n\nvoid solve2(int N, const vector<char>& C) {\n    vector<vector<mint>> dp(N + 1, vector<mint>(N + 1, 0));\n    dp[0][0] = 1;\n    rep(i, 0, N) rep(j, 0, N) {\n        if (C[i] == 'D') {\n            if (j >= 1) {\n                dp[i + 1][j - 1] += dp[i][j] * j * j;\n            }\n            dp[i + 1][j] += dp[i][j] * j;\n        }\n        else if (C[i] == 'U') {\n            dp[i + 1][j] += dp[i][j] * j;\n            dp[i + 1][j + 1] += dp[i][j];\n        }\n        else {\n            dp[i + 1][j] += dp[i][j];\n        }\n    }\n    cout << dp[N][0] << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    vector<char> C(N);\n    for (auto& c : C) {\n        cin >> c;\n    }\n    // solve1(N, C);\n    solve2(N, C);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\nint cnt;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\ncnt=0;\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i+cnt+1][j-cnt]+=dp[i+cnt][j-cnt]*(j-cnt);\n      if(j)dp[i+1+cnt][j-1-cnt]+=dp[i+cnt][j-cnt]*(j-cnt)*(j-cnt);\n      dp[i+1+cnt][j-cnt]%=Prime;\n      if(j)dp[i+1+cnt][j-1-cnt]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1+cnt][j+1-cnt]+=dp[i+cnt][j-cnt];\n      dp[i+1+cnt][j-cnt]+=dp[i+cnt][j-cnt]*(j-cnt);\n      dp[i+1+cnt][j+1-cnt]%=Prime;\n      dp[i+1+cnt][j-cnt]%=Prime;\n    }else{\n      cnt++;\n    }\n  }}\n  printf(\"%d\\n\",dp[i][0]);\n  return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\nint main() {\n    int n;\n    cin >> n;\n    char c[n];\n    for(int i=0;i<n;++i){\n        cin >> c[i];\n    }\n\n    vector<vector<ll>> dp(n+1, vector<ll>(n+1, 0));\n    dp[0][0] = 1;\n    for(int i=0;i<n;++i) {\n        for(int j=0;j<=i;++j) {\n            if(!dp[i][j]) continue;\n            if(c[i] == 'U') {\n                dp[i+1][j] += (dp[i][j] * j) % MOD;\n                dp[i+1][j] %= MOD;\n                dp[i+1][j+1] += dp[i][j];\n                dp[i+1][j+1] %= MOD;\n            } else if(c[i] == 'D') {\n                if(j) {\n                    dp[i+1][j-1] += (dp[i][j] * j * j) % MOD;\n                    dp[i+1][j-1] %= MOD;\n                }\n                dp[i+1][j] += (dp[i][j] * j) % MOD;\n                dp[i+1][j] %= MOD;\n            } else {\n                dp[i+1][j] = dp[i][j];\n            }\n                \n        }\n    }\n\n    cout << dp[n][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    using mint = ModInt<MOD>;\n\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // assignment\n    ModInt& operator=(const ModInt& x) {\n        if (this != &x) { this->val = x.val; }\n        return *this;\n    }\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator~() const {\n        // non-recursive extended euclidean algorithm\n        int s = val, t = MOD;\n        mint sx = 1, sy = 0, tx = 0, ty = 1;\n        while (s % t != 0) {\n            int div = s / t;\n            s -= t * div;\n            sx -= tx * div;\n            sy -= ty * div;\n\n            std::swap(s, t);\n            std::swap(sx, tx);\n            std::swap(sy, ty);\n        }\n        return mint(tx);\n    }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= ~x; }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n\n    // I/O\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\nconstexpr int MOD = 1e9 + 7;\nusing mint = ModInt<MOD>;\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<mint> dp(n + 1, 0), ndp(n + 1);\n    dp[0] = 1;\n    for (int i = 0; i < n; ++i) {\n        char c;\n        std::cin >> c;\n        if (c == '-') continue;\n\n        std::fill(ndp.begin(), ndp.end(), 0);\n\n        for (int k = 0; k < n; ++k) {\n            if (c == 'U') {\n                // 埋める\n                ndp[k] += dp[k] * k;\n                // 空ける\n                ndp[k + 1] += dp[k];\n            } else {\n                // 埋める\n                if (k - 1 >= 0) ndp[k - 1] += dp[k] * k * k;\n                // 空ける\n                ndp[k] += dp[k] * k;\n            }\n        }\n\n        std::swap(dp, ndp);\n    }\n\n    std::cout << dp[0] << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std; \nconst int dx[]={1,0,-1,0,1,-1,-1,1}; \nconst int dy[]={0,1,0,-1,1,1,-1,-1}; \nconst int INF = 1e9; \nconst long long LINF = 1e18; \nconst double EPS = 1e-8; \n#define pb push_back\n#define mk make_pair \n#define fr first \n#define sc second \n#define reps(i,j,k) for(ll i = (j); i < (k); ++i) \n#define rep(i,j) reps(i,0,j) \n#define all(a) (a).begin(),(a).end() \n#define MOD 1000000007 \ntypedef pair<int,int> Pii;\ntypedef pair<Pii,int> P;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T>\nostream& operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()){\n\t\tout << v[i] <<\", \";\n\t}\n\treturn out << \"}\" << endl;\n}\nll dp[201][201][201];\nint main(){\n\tint n;\n\tcin >> n;\n\tvi a;\n\trep(i,n){\n\t\tstring c;\n\t\tcin >> c;\n\t\tif(c[0] == 'U'){\n\t\t\ta.pb(1);\n\t\t}\n\t\telse if(c[0] == 'D'){\n\t\t\ta.pb(-1);\n\t\t}\n\t}\n\tn = a.size();\n\tdp[0][0][0] = 1;\n\trep(i,n){\n\t\trep(j,i+1){\n\t\t\trep(k,i+1){\n\t\t\t\tif(a[i] == 1){\n\t\t\t\t\tdp[i+1][j+1][k+1] += dp[i][j][k];\n\t\t\t\t\tdp[i+1][j+1][k+1] %= MOD;\n\t\t\t\t\tdp[i+1][j][k] += dp[i][j][k]*k;\n\t\t\t\t\tdp[i+1][j][k] %= MOD;\n\t\t\t\t}\n\t\t\t\telse if(a[i] == -1){\n\t\t\t\t\tdp[i+1][j][k] += dp[i][j][k] * j;\n\t\t\t\t\tdp[i+1][j][k] %= MOD;\n\t\t\t\t\tif(j > 0 && k > 0){\n\t\t\t\t\t\tdp[i+1][j-1][k-1] += dp[i][j][k] * j * k;\n\t\t\t\t\t\tdp[i+1][j-1][k-1] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\n\nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\n\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll dp[201][201];\n\nll solve(string str){\n  if(str==\"\")return 1;\n  dp[0][0]=1;\n  int n=str.size();\n\n  ll uc=0,dc=0;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      ll a=dp[i][j];\n      if(a==0)continue;\n      //cout<<i<<' '<<j<<' '<<a<<endl;\n      if(str[i]=='U'){\n        dp[i+1][j+1]=add(dp[i+1][j+1],a);\n        dp[i+1][j]=add(dp[i+1][j], mul(a,j));\n      }\n      if(str[i]=='D'){\n        ll k= i-dc-(uc-j);\n        dp[i+1][j]=add(dp[i+1][j], mul(a,k));\n        if(j>0)dp[i+1][j-1]=add(dp[i+1][j-1],mul(j,mul(a,k)));\n      }\n\n    }\n    if(str[i]=='U')uc++;\n    else dc++;\n  }\n  return dp[n][0];\n}\n\nint main(){\n  int n;\n  cin>>n;\n  string str=\"\";\n  for(int i=0;i<n;i++){\n    char ch;\n    cin>>ch;\n    if(ch=='-')continue;\n    str+=ch;\n  }\n  cout<<solve(str)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nconst long long int MOD = 1000000007LL;\nlong long int dp[210][210];\nint main() {\n  int N; cin >> N;\n\n  dp[0][0] = 1;\n  for(int i=0; i<N; i++) {\n    char c; cin >> c;\n    for(int j=0; j<=i+1; j++) { \n      if(c == '-') {\n        dp[i+1][j] = dp[i][j];\n      }\n      else {\n        if(c == 'D') {\n          (dp[i+1][j] += dp[i][j] * j) %= MOD;\n        }\n        else {\n          dp[i+1][j] = 1;\n        }\n\n        int is_u = (c == 'U');\n        long long int add = 0;\n        (add += dp[i][j     - is_u]) %= MOD;\n        (add += dp[i][j + 1 - is_u] * (j + 1 - is_u)) %= MOD;\n\n\n        printf(\"i = %d, j = %d, c = %c, add = %lld\\n\", i, j, c, add);\n        (dp[i+1][j] *= add) %= MOD;\n      }\n    }\n  }\n\n  for(int i=1; i<=N; i++) {\n    for(int j=0; j<=N; j++) {\n      cout << dp[i][j] << \" \";\n    }\n    cout << endl;\n  }\n\n  \n  cout << dp[N][0] << endl;\n  return 0;\n}\n\n/*\n5\nU\nU\n-\nD\nD\n1 0 0 0 0 0 \n1 0 0 0 0 0 \n1 0 0 0 0 0 \n0 1 0 0 0 0 \n0 2 1 0 0 0 \n0\n\n3\n-\nU\nD\n1 0 0 0 \n1 0 0 0 \n0 1 0 0 \n0\n\n*/\n\n8\nU\nD\nD\nD\nD\nD\nD\nD\ni = 0, j = 0, c = U, add = 0\ni = 0, j = 1, c = U, add = 1\ni = 1, j = 0, c = D, add = 1\ni = 1, j = 1, c = D, add = 1\ni = 1, j = 2, c = D, add = 0\ni = 2, j = 0, c = D, add = 1\ni = 2, j = 1, c = D, add = 1\ni = 2, j = 2, c = D, add = 0\ni = 2, j = 3, c = D, add = 0\ni = 3, j = 0, c = D, add = 1\ni = 3, j = 1, c = D, add = 1\ni = 3, j = 2, c = D, add = 0\ni = 3, j = 3, c = D, add = 0\ni = 3, j = 4, c = D, add = 0\ni = 4, j = 0, c = D, add = 1\ni = 4, j = 1, c = D, add = 1\ni = 4, j = 2, c = D, add = 0\ni = 4, j = 3, c = D, add = 0\ni = 4, j = 4, c = D, add = 0\ni = 4, j = 5, c = D, add = 0\ni = 5, j = 0, c = D, add = 1\ni = 5, j = 1, c = D, add = 1\ni = 5, j = 2, c = D, add = 0\ni = 5, j = 3, c = D, add = 0\ni = 5, j = 4, c = D, add = 0\ni = 5, j = 5, c = D, add = 0\ni = 5, j = 6, c = D, add = 0\ni = 6, j = 0, c = D, add = 1\ni = 6, j = 1, c = D, add = 1\ni = 6, j = 2, c = D, add = 0\ni = 6, j = 3, c = D, add = 0\ni = 6, j = 4, c = D, add = 0\ni = 6, j = 5, c = D, add = 0\ni = 6, j = 6, c = D, add = 0\ni = 6, j = 7, c = D, add = 0\ni = 7, j = 0, c = D, add = 1\ni = 7, j = 1, c = D, add = 1\ni = 7, j = 2, c = D, add = 0\ni = 7, j = 3, c = D, add = 0\ni = 7, j = 4, c = D, add = 0\ni = 7, j = 5, c = D, add = 0\ni = 7, j = 6, c = D, add = 0\ni = 7, j = 7, c = D, add = 0\ni = 7, j = 8, c = D, add = 0\n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <math.h>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tchar table[N],buf[2];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",buf);\n\t\ttable[i] = buf[0];\n\t}\n\n\tll dp[N+1][N+1];\n\n\tfor(int i = 0; i <= N; i++){\n\t\tfor(int k = 0; k <= N; k++)dp[i][k] = 0;\n\t}\n\n\tdp[0][0] = 1;\n\n\tfor(int i = 0; i <= N-1; i++){\n\t\tswitch(table[i]){\n\t\tcase '-':\n\t\t\tfor(int k = 0; k <= i; k++){\n\t\t\t\tdp[i+1][k] = dp[i][k];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tfor(int k = 0; k <= i; k++){\n\t\t\t\tdp[i+1][k] += k*dp[i][k];\n\t\t\t\tdp[i+1][k] %= MOD;\n\t\t\t\tif(k == 0)continue;\n\t\t\t\tdp[i+1][k-1] += ((k*dp[i][k])%MOD)*k;\n\t\t\t\tdp[i+1][k-1] %= MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tfor(int k = 0; k <= i; k++){\n\t\t\t\tdp[i+1][k+1] += dp[i][k];\n\t\t\t\tdp[i+1][k+1] %= MOD;\n\t\t\t\tdp[i+1][k] += k*dp[i][k];\n\t\t\t\tdp[i+1][k] %= MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",dp[N][0]%MOD);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[202][202];\nll MOD=1000000007;\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  char c[202];\n\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  dp[0][0]=1;\n\n  for(int k=0;k<n;k++){\n    for(int i=0;i<=k;i++){\n      if(c[k]=='-')dp[k+1][i]=dp[k][i];\n      else if(c[k]=='D'){\n        if(i>0){\n          dp[k+1][i-1]+=dp[k][i]*i*i;\n          dp[k+1][i-1]%=MOD;\n        }\n        dp[k+1][i]+=dp[k][i]*i;\n      }\n      else if(c[k]=='U'){\n        dp[k+1][i]+=dp[k][i]*i;\n        dp[k+1][i+1]+=dp[k][i];\n        dp[k+1][i+1]%=MOD;\n      }\n      dp[k+1][i]%=MOD;\n    }\n  }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=7+(LL)1e9;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b)%p;\n\telse if(arrays[n]==-1) DP[n][a][b]=ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n\telse return DP[n][a][b]=ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#define M 1000000007\nusing namespace std;\nvector<int> a;\nint l[200];\nint r[200];\nlong long dp[200][200];\n\nint main(){\n\tint n,i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tchar c;\n\t\tscanf(\" %c\",&c);\n\t\tif(c=='U')a.push_back(1);\n\t\tif(c=='D')a.push_back(0);\n\t}\n\tn=a.size();\n\tint s=0;\n\tfor(i=n-1;i>=0;i--){\n\t\tr[i]=s;\n\t\tif(a[i]==0)s++;\n\t}\n\ts=0;\n\tfor(i=0;i<n;i++){\n\t\tl[i]=s;\n\t\tif(a[i]==1)s++;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<s;j++){\n\t\t\tlong long res=0;\n\t\t\tlong long sum=1;\n\t\t\tfor(k=i-1;k>=0;k--){\n\t\t\t\tif(j>0)res=(res+dp[k][j-1]*sum)%M;\n\t\t\t\tsum=sum*(r[k]-((n-k-1)-(s-j)))%M;\n\t\t\t}\n\t\t\tif(j>0)dp[i][j]=res*(l[i]-j)%M;\n\t\t\telse dp[i][j]=sum*l[i]%M;\n\t\t}\n\t}\n\tlong long ans=0;\n\tlong long sum=1;\n\tfor(i=n-1;i>=0;i--){\n\t\tans=(ans+dp[i][s-1]*sum)%M;\n\t\tsum=sum*(r[i]-(n-i-1))%M;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[201][201];\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  string c;\n\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  dp[0][0]=1;\n\n  for(int k=0;k<n;k++){\n    for(int i=0;i<=k;i++){\n      if(c[k]=='-')dp[k+1][i]+=dp[k][i];\n      else if(c[k]=='D'){\n        if(i>0)dp[k+1][i-1]+=dp[k][i]*i*i;\n        dp[k+1][i]+=dp[k][i]*i;\n        dp[k+1][i-1]%=MOD;\n      }\n      else if(c[k]=='U'){\n        dp[k+1][i]+=dp[k][i]*i;\n        dp[k+1][i+1]+=dp[k][i];\n        dp[k+1][i+1]%=MOD;\n      }\n      dp[k+1][i]%=MOD;\n    }\n  }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<char> c;\n    for (int i = 0; i < n; i++)\n    {\n        char cc;\n        cin >> cc;\n        if (cc != '-')\n            c.push_back(cc);\n    }\n    n = c.size();\n    vector<vector<ll>> dp(n + 1, vector<ll>(n + 1, 0));\n    dp[0][0] = 1;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (dp[i][j] == 0)\n                continue;\n            if (c[i] == 'D')\n            {\n                dp[i + 1][j] += dp[i][j] * j % MOD;\n                dp[i + 1][j] %= MOD;\n\n                if (j)\n                {\n                    dp[i + 1][j - 1] += dp[i][j] * j * j % MOD;\n                    dp[i + 1][j - 1] %= MOD;\n                }\n            }\n            else\n            {\n                dp[i + 1][j] += dp[i][j] * j % MOD;\n                dp[i + 1][j] %= MOD;\n\n                dp[i + 1][j + 1] += dp[i][j];\n                dp[i + 1][j + 1] %= MOD;\n            }\n        }\n    }\n    cout << dp[n][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n;\nchar state[300];\nconst ll MOD = 1e+9 + 7;\nint memo[210][210][210];\nll calc(int depth, int rest, int down) {\n  if (rest < 0) { return 0; }\n  if (depth == n) {\n    return rest == 0 && down == 0;\n  }\n  if (memo[depth][rest][down] != -1) { return memo[depth][rest][down]; }\n  ll ret = 0;\n  if (state[depth] == '-') {\n    ret = calc(depth + 1, rest, down);\n  } else if (state[depth] == 'D') {\n    if (down > 0) {\n      ret = (ret + calc(depth + 1, rest - 1, down - 1) * rest % MOD * down) % MOD;\n    }\n    ret = (ret + calc(depth + 1, rest, down) * rest) % MOD;\n  } else if (state[depth] == 'U') {\n    if (down > 0) {\n      ret = (ret + calc(depth + 1, rest, down) * down) % MOD;\n    }\n    ret = (ret + calc(depth + 1, rest + 1, down + 1)) % MOD;\n  }\n  return memo[depth][rest][down] = ret;\n}\n\nint main() {\n  while (scanf(\"%d\", &n) > 0) {\n    MEMSET(memo, -1);\n    REP(i, n) {\n      scanf(\" %c \", &state[i]);\n    }\n    cout << calc(0, 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF=1e9,MOD=1e9+7;\nconst long long LINF=1e18;\nusing namespace std;\n#define int long long\n//template\nint dp[300][300];\n//main\nsigned main(){\n  int N;cin>>N;\n  std::vector<char> v(N);\n  std::vector<int> w(300);\n  w[0]=1;for(int i=1;i<300;i++)w[i]=w[i-1]*i%MOD;\n  for(int i=0;i<N;i++)cin>>v[i];\n  memset(dp,0,sizeof(dp));\n  dp[0][0]=1;\n  int now=0;\n  for(int i=0;i<N;i++){\n    if(v[i]=='-')continue;\n    else{\n      for(int j=0;j<N;j++){\n        if(v[i]=='U'){\n          dp[now+1][j+1]+=dp[now][j];\n          dp[now+1][j]+=dp[now][j]*j;\n        }\n        else {\n          dp[now+1][j]+=dp[now][j]*j;\n          if(j)dp[now+1][j-1]+=dp[now][j]*j*j;\n        }\n      }\n      for(int j=0;j<N;j++)dp[now+1][j]%=MOD;\n      now++;\n    }\n  }\n  cout<<dp[now][0]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std; \nconst int dx[]={1,0,-1,0,1,-1,-1,1}; \nconst int dy[]={0,1,0,-1,1,1,-1,-1}; \nconst int INF = 1e9; \nconst long long LINF = 1e18; \nconst double EPS = 1e-8; \n#define pb push_back\n#define mk make_pair \n#define fr first \n#define sc second \n#define ll long long \n#define reps(i,j,k) for(int i = (j); i < (k); ++i) \n#define rep(i,j) reps(i,0,j) \n#define all(a) (a).begin(),(a).end() \n#define MOD 1000000007 \ntypedef pair<int,int> Pii;\ntypedef pair<Pii,int> P;\ntypedef vector<int> vi;\n\ntemplate<class T>\nostream& operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()){\n\t\tout << v[i] <<\", \";\n\t}\n\treturn out << \"}\" << endl;\n}\nint dp[201][201][201];\nint main(){\n\tint n;\n\tcin >> n;\n\tvi a;\n\trep(i,n){\n\t\tstring c;\n\t\tcin >> c;\n\t\tif(c[0] == 'U'){\n\t\t\ta.pb(1);\n\t\t}\n\t\telse if(c[0] == 'D'){\n\t\t\ta.pb(-1);\n\t\t}\n\t}\n\tn = a.size();\n\tdp[0][0][0] = 1;\n\trep(i,n){\n\t\trep(j,i+1){\n\t\t\trep(k,i+1){\n\t\t\t\tif(a[i] == 1){\n\t\t\t\t\tdp[i+1][j+1][k+1] += dp[i][j][k];\n\t\t\t\t\tdp[i+1][j+1][k+1] %= MOD;\n\t\t\t\t\tdp[i+1][j][k] += dp[i][j][k]*k;\n\t\t\t\t\tdp[i+1][j][k] %= MOD;\n\t\t\t\t}\n\t\t\t\telse if(a[i] == -1){\n\t\t\t\t\tdp[i+1][j][k] += dp[i][j][k] * j;\n\t\t\t\t\tdp[i+1][j][k] %= MOD;\n\t\t\t\t\tif(j > 0 && k > 0){\n\t\t\t\t\t\tdp[i+1][j-1][k-1] += dp[i][j][k] * j * k;\n\t\t\t\t\t\tdp[i+1][j-1][k-1] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr double eps = 1e-9;\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T &val) {\n    fill((T *)ary, (T *)(ary + size), val);\n}\n\ntemplate <i64 p>\nclass Fp {\npublic:\n    i64 x;\n    Fp() : x(0) {}\n    Fp(i64 x_) : x((x_ % p + p) % p) {}\n    Fp operator+() const { return Fp(x); }\n    Fp operator-() const { return Fp(-x); }\n    Fp& operator+=(const Fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    Fp& operator-=(const Fp& y) { return *this += -y; }\n    Fp& operator*=(const Fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    Fp& operator/=(const Fp& y) { return *this *= Fp(inverse(y.x)); }\n    Fp operator+(const Fp& y) const { return Fp(x) += y; }\n    Fp operator-(const Fp& y) const { return Fp(x) -= y; }\n    Fp operator*(const Fp& y) const { return Fp(x) *= y; }\n    Fp operator/(const Fp& y) const { return Fp(x) /= y; }\n    bool operator==(const Fp& y) const { return x == y.x; }\n    bool operator!=(const Fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\nvoid solve() {\n    constexpr i64 mod = 1'000'000'007;\n    i64 n;\n    cin >> n;\n    vector<char> c(n);\n    rep(i,0,n) cin >> c[i];\n\n    vector<vector<Fp<mod>>> dp(n,vector<Fp<mod>>(n+1));\n    if(c[0]=='U') dp[0][1]=1;\n    else if(c[0]=='-') dp[0][0]=1;\n    rep(i,0,n-1){\n        rep(j,0,n+1){\n            switch(c[i+1]){\n                case 'D': // 右側は上とつなぐ\n                    // 左側は保留\n                    // 右側は上とつなぐ\n                    {\n                        dp[i+1][j]+=dp[i][j]*j;\n                    }\n                    // 両方とも上とつなぐ\n                    if(j-1>=0){\n                        dp[i+1][j-1]+=dp[i][j]*j*j;\n                    }\n                    break;\n                case 'U': // 右側は保留\n                    // 左側は上とつなぐ\n                    // 右側は保留\n                    {\n                        dp[i+1][j]+=dp[i][j]*j;\n                    }\n                    // 両方とも保留\n                    if(j+1<=n){\n                        dp[i+1][j+1]+=dp[i][j];\n                    }\n                    break;\n\n                case '-': // まっすぐつなぐ\n                    {\n                        dp[i+1][j]+=dp[i][j];\n                    }\n                    break;\n            }\n        }\n    }\n\n    cout << dp[n-1][0].x << endl;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tstring s;\n\tint n; cin >> n;\n\twhile (n--) {\n\t\tchar c; cin >> c;\n\t\tif (c != '-') s.push_back(c);\n\t}\n\tn = s.length();\n\tint u = 0;\n\tvector<int> dp(n + 1);\n\tdp[0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == 'D')\n\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\tdp[j] = (ll)dp[j] * (u - j) % MOD;\n\t\tfor (int j = n - 1; j >= 0; j--)\n\t\t\tdp[j + 1] = (dp[j + 1] + (ll)dp[j] * (u - j)) % MOD;\n\t\tif (s[i] == 'U') u++;\n\t}\n\tcout << dp[u] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2439&lang=jp>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\nconst ll MOD = 1e9+7;\nll solve(){\n    ll res = 0;\n    ll n; cin >> n;\n    vector<char> c;\n    for(int i = 0; i < n;i++){\n        char tmp; cin >> tmp;\n        if(tmp != '-') c.push_back(tmp);\n    }\n    ll sz = c.size();\n    using VLL = vector<ll>;\n    using VVLL = vector<VLL>;\n    using VVVLL = vector<VVLL>;\n    VVVLL dp(sz+1,VVLL(sz+1,VLL(sz+1,0)));\n    dp[0][0][0] = 1;\n    for(int i = 0; i < sz;i++){\n        for(int j = 0; j <= i;j++){\n            for(int k = 0; k <= i;k++){\n                if(dp[i][j][k] == 0) continue;\n                if(c[i] == 'U'){\n                    (dp[i+1][j+1][k+1] += dp[i][j][k])%=MOD; // 割り当てを決めない\n                    (dp[i+1][j][k] += dp[i][j][k]*k)%=MOD; // 今まで割り当てられていない人に割り当てる\n                }else{\n                    (dp[i+1][j][k] += dp[i][j][k]*j)%=MOD; // 今まで未割り当ての人を割り当てる\n                    if(j > 0 && k > 0){ // i番目と今まで割り当てられていない人を同時に決める\n                        (dp[i+1][j-1][k-1] += dp[i][j][k]*j*k)%=MOD;\n                    }\n                }\n            }\n        }\n    }\n    res = dp[sz][0][0];\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=7+1e9;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b);\n\telse if(arrays[n]==-1) DP[n][a][b]=ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b));\n\telse return DP[n][a][b]=ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b));\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n//\tif()\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint n;\nstring s;\nLL dp[202][202];\nconst int mod = 1e9 + 7;\n\nint main(){\n    cin >> n;\n    REP(i, n){\n        char c;\n        cin >> c;\n        if(c != '-')s += c;\n    }\n    n = (int)s.size();\n    dp[0][0] = 1;\n    REP(i, n){\n        REP(j, i + 1){\n            if(s[i] == 'D'){\n                (dp[i + 1][j] += dp[i][j] * j) %= mod;\n                if(j)(dp[i + 1][j - 1] += dp[i][j] *j * j) %= mod;\n            }else{\n                (dp[i + 1][j + 1] += dp[i][j]) %= mod;\n                (dp[i + 1][j] += dp[i][j] * j) %= mod; \n            }\n        }\n    }\n    cout << dp[n][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nconst int mod = 1e9+7;\nvoid add(ll &a, ll b) {\n  a = (a+b) % mod;\n}\nchar c[200];\nll dp[201][202][202];\n// dp[i][j][k] = i番目までみて，まだ順位が決まってないのがjチームで，チームが決まってない順位がk個なときの場合の数\n\nint main() {\n  int n;\n  while(cin >> n) {\n    REP(i,n) cin >> c[i];\n    memset(dp,0,sizeof(dp));\n    dp[0][0][0] = 1;\n    REP(i,n) {\n      REP(j,i+1) {\n        REP(k,i+1) {\n          if (c[i] == 'U') {\n            add(dp[i+1][j+1][k+1], dp[i][j][k]);\n            add(dp[i+1][j][k], dp[i][j][k]*j%mod);\n          } else if (c[i] == 'D') {\n            if (k) {\n              add(dp[i+1][j][k], dp[i][j][k]*k);\n              if (j)\n                 add(dp[i+1][j-1][k-1], dp[i][j][k]*j%mod*k%mod);\n            }\n          } else {\n            add(dp[i+1][j][k], dp[i][j][k]);\n          }\n        }\n      }\n    }\n    cout << dp[n][0][0] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\n//common\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nll MOD =1000000007;\nclass Main{\npublic:\n\n\tvoid run(){\n\t\tint N;cin >> N;\n\t\tvector<char> cs(N);REP(i,N)cin >> cs[i];\n\n\t\tvector<vector<ll>> dp(N+1,vector<ll>(N+1));\n\t\t//dp[n][x] ... [0,n) でx個のペアを確定する組合せ\n\t\tdp[0][0]=1;\n\t\tfor(int n=1;n<=N;n++){\n\t\t\tfor(int x=0;x<=n;x++){\n\t\t\t\tif(cs[n-1]=='-'){\n\t\t\t\t\tif(IN(0,x-1,N+1))dp[n][x]=dp[n-1][x-1];\n\t\t\t\t}else if(cs[n-1]=='U'){\n\t\t\t\t\tdp[n][x]+=dp[n-1][x];\n\t\t\t\t\tif(IN(0,x-1,N+1))dp[n][x]+=dp[n-1][x-1]*((n-1)-(x-1));\n\t\t\t\t}else if(cs[n-1]=='D'){\n\t\t\t\t\tif(IN(0,x-1,N+1))dp[n][x]+=dp[n-1][x-1]*((n-1)-(x-1));\n\t\t\t\t\tif(IN(0,x-2,N+1))dp[n][x]+=dp[n-1][x-2]*((n-1)-(x-2))*((n-1)-(x-2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[N][N] <<endl;\n\t}\n};\n\n int main(){\nios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<char> c(n);\n    rep(i,0,n) cin >> c[i];\n\n    int64_t mod=1e9+7;\n    vector<vector<int64_t>> dp(n,vector<int64_t>(n+1));\n    if(c[0]=='-') dp[0][1]=1;\n    else dp[0][0]=1;\n    rep(i,1,n){\n        rep(j,0,n+1){\n            if(c[i]=='-'){\n                if(j-1>=0) dp[i][j]=dp[i-1][j-1];\n            }\n            if(c[i]=='U'){\n                if(j-1>=0) dp[i][j]=dp[i-1][j-1]*(i-j+1);\n                dp[i][j]+=dp[i-1][j];\n            }\n            if(c[i]=='D'){\n                if(j-2>=0) dp[i][j]=dp[i-1][j-2]*(i-j+2)*(i-j+2);\n                if(j-1>=0) dp[i][j]+=dp[i-1][j-1]*(i-j+1);\n            }\n            dp[i][j]%=mod;\n        }\n    }\n    cout << dp[n-1][n] << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\nll dp[201][201][201]; //現在の順位, 上の空き, 下の数\n\nint main(){\n  int N;\n  char c[200];\n\n  scanf(\"%d\", &N);\n\n  for (int i=0; i<N; i++) {\n    scanf(\" %c\", c+i);\n  }\n\n  dp[0][0][0] = 1;\n\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<=i; j++) {\n      for (int k=0; k<=i; k++) {\n        if (c[i] == '-') {\n          dp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k]) % mod;\n        }\n        if (c[i] == 'D') {\n          if (j > 0)\n            dp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k] * j) % mod;\n          if (j > 0 && k > 0)\n            dp[i+1][j-1][k-1] = (dp[i+1][j-1][k-1] + dp[i][j][k] * j * k) % mod;\n        }\n        if (c[i] == 'U') {\n          dp[i+1][j+1][k+1] = (dp[i+1][j+1][k+1] + dp[i][j][k]) % mod;\n          if (k > 0)\n            dp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k] * k) % mod;\n        }\n      }\n    }\n  }\n\n  printf(\"%lld\\n\", dp[N][0][0]);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define MOD 1000000007\nll dp[300][300];\nint n;\nchar c[300];\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)cin >> c[i];\n    dp[0][0]=1ll;\n    for(int i=0;i<n;i++)\n    {\n        if(c[i]=='-')for(int j=0;j<=n;j++)dp[i+1][j]=dp[i][j];\n        if(c[i]=='D')\n        {\n            for(int j=0;j<=i;j++)\n            {\n                if(j>0)dp[i+1][j-1] = (dp[i+1][j-1]+(((dp[i][j]*j)%MOD)*j%MOD))%MOD;\n                dp[i+1][j] = (dp[i+1][j]+((dp[i][j]*j)%MOD))%MOD;\n            }\n        }\n        if(c[i]=='U')\n        {\n            for(int j=0;j<=i;j++)\n            {\n                dp[i+1][j+1] = (dp[i+1][j+1]+dp[i][j])%MOD;\n                dp[i+1][j] = (dp[i+1][j]+((dp[i][j]*j)%MOD))%MOD;\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  ll n;\n  cin >> n;\n  vector<char> c(n);\n  rep(i, n) cin >> c[i];\n\n  vector<vector<ll>> dp(n + 10, vector<ll>(n + 10, 0));\n  dp[0][0] = 1;\n  rep(i, n) {\n    if (c[i] == 'U') {\n      rep(j, i + 1) {\n        dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % mod;\n        dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j] * (i - j) % mod) % mod;\n      }\n    }\n    else if (c[i] == '-') {\n      rep(j, i + 1) {\n        dp[i + 1][j + 1] = dp[i][j];\n      }\n    }\n    else {\n      rep(j, i + 1) {\n        dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j] * (i - j) % mod) % mod;\n        dp[i + 1][j + 2] = (dp[i + 1][j + 2] + dp[i][j] * (i - j) * (i - j) % mod) % mod;\n      }\n    }\n  }\n  cout << dp[n][n] << '\\n';\n\n\n\n\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <unordered_set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\n#define ALL(v) v.begin(),v.end()\ntemplate < class T > inline bool chmax(T& a, T b) {if (a < b) { a=b; return true; } return false; }\ntemplate < class T > inline bool chmin(T& a, T b) {if (a > b) { a=b; return true; } return false; }\n#define DEBUG_VLL(vec) REP(sz, vec.size()) std::cerr<<vec[sz]<<(sz==vec.size()-1?'\\n':' ');\n\nconst ll MOD = 1000000007;\nconst ll HIGHINF = (ll)1e18;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    V<char> c(n);\n    for (int i = 0; i < n; i++) cin >> c[i];\n\n    vvll dp(n + 1, vll(n + 1, 0));\n    dp[0][0] = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i + 1 < j) break;\n            if (c[i] == '-') {\n                if (j + 1 <= n) {\n                    dp[i + 1][j + 1] += dp[i][j];\n                    if (dp[i + 1][j + 1] >= MOD) dp[i + 1][j + 1] -= MOD;\n                }\n            } else if (c[i] == 'U') {\n                dp[i + 1][j] += dp[i][j];\n                if (dp[i + 1][j] >= MOD) dp[i + 1][j] -= MOD;\n                if (j + 1 <= n) {\n                    dp[i + 1][j + 1] += dp[i][j] * (i - j) % MOD;\n                    if (dp[i + 1][j + 1] >= MOD) dp[i + 1][j + 1] -= MOD;\n                }\n            } else {\n                if (j + 1 <= n) {\n                    dp[i + 1][j + 1] += dp[i][j] * (i - j) % MOD;\n                    if (dp[i + 1][j + 1] >= MOD) dp[i + 1][j + 1] -= MOD;\n                }\n                if (j + 2 <= n) {\n                    dp[i + 1][j + 2] += dp[i][j] * (i - j) * (i - j) % MOD;\n                    if (dp[i + 1][j + 2] >= MOD) dp[i + 1][j + 2] -= MOD;\n                }\n            }\n        }\n    }\n    cout << dp[n][n] << '\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define ln '\\n'\nconstexpr long long MOD = 1000000007LL;\n//constexpr long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef unsigned long long ull; \ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T, class U> inline bool chmax(T &a, U b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T, class U> inline bool chmin(T &a, U b) { if (a > b) { a = b; return true;} return false; }\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\ntemplate <std::uint_fast64_t Modulus> \nstruct ModInt {\n    using u64 = std::uint_fast64_t;\n\n    u64 a;\n\n    constexpr ModInt(const long long x = 0) noexcept : a(x >= 0 ? x % Modulus : (Modulus - (-x) % Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr ModInt operator+(const ModInt rhs) const noexcept {return ModInt(*this) += rhs;}\n    constexpr ModInt operator-(const ModInt rhs) const noexcept {return ModInt(*this) -= rhs;}\n    constexpr ModInt operator*(const ModInt rhs) const noexcept {return ModInt(*this) *= rhs;}\n    constexpr ModInt operator/(const ModInt rhs) const noexcept {return ModInt(*this) /= rhs;}\n    constexpr ModInt operator^(const long long rhs) const noexcept {return ModInt(*this) ^= rhs;}\n    constexpr ModInt &operator+=(const ModInt rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ModInt rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator^=(long long exp) noexcept {\n        ModInt b = a;\n        a = 1;\n        while (exp) {\n            if (exp&1) *this *= b;\n            exp >>= 1;\n            b *= b;\n        }\n        return *this;\n    }\n\n    bool operator==(const ModInt &p) const {return a == p.a;}\n    bool operator!=(const ModInt &p) const {return a != p.a;}\n\n};\n\nusing mint = ModInt<MOD>;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N; cin >> N;\n    vector<char> C(N);\n    rep(i,N) cin >> C[i];\n\n    vector<vector<mint>> dp(N+1, vector<mint>(N+1));\n    dp[0][0] = 1;\n    rep(i,N) {\n        rep(j,N+1) {\n            if (C[i]=='-') {\n                if (j < N) dp[i+1][j+1] += dp[i][j];\n            } else if (C[i]=='D') {\n                if (j < i) dp[i+1][j+1] += dp[i][j]*(i-j);\n                if (j < i) dp[i+1][j+2] += dp[i][j]*(i-j)*(i-j);\n            } else {\n                dp[i+1][j] += dp[i][j];\n                if (j < i) dp[i+1][j+1] += dp[i][j]*(i-j);\n            }\n        }\n    }\n\n    cout << dp[N][N].a << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[202][202];\n\nint main(void){\n\n  fill(dp[0],dp[202],0);\n\n  int n;\n  cin >> n;\n\n  string c;\n\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  dp[0][0]=1;\n\n  for(int k=0;k<n;k++){\n    for(int i=0;i<=k;i++){\n      if(c[k]=='-')dp[k+1][i]=dp[k][i];\n      else if(c[k]=='D'){\n        if(i>0){\n          dp[k+1][i-1]+=((dp[k][i]*i)%MOD*i)%MOD;\n          dp[k+1][i-1]%=MOD;\n        }\n        dp[k+1][i]+=dp[k][i]*i;\n      }\n      else if(c[k]=='U'){\n        dp[k+1][i]+=(dp[k][i]*i)%MOD;\n        dp[k+1][i+1]+=dp[k][i];\n        dp[k+1][i+1]%=MOD;\n      }\n      dp[k+1][i]%=MOD;\n    }\n  }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n\nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433L;\n\ntemplate <class T> vector<T> multivector(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto multivector(size_t N,T... t){return vector<decltype(multivector(t...))>(N,multivector(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\n/*\n * @title ModInt\n */\ntemplate<long long mod> class ModInt {\npublic:\n\tlong long x;\n\tconstexpr ModInt():x(0) {\n\t\t// do nothing\n\t}\n\tconstexpr ModInt(long long y) : x(y>=0?(y%mod): (mod - (-y)%mod)%mod) {\n\t\t// do nothing\n\t}\n\tModInt &operator+=(const ModInt &p) {\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const long long y) {\n\t\tModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const int y) {\n\t\tModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const ModInt &p) {\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const long long y) {\n\t\tModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const int y) {\n\t\tModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const ModInt &p) {\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const long long y) {\n\t\tModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const int y) {\n\t\tModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator^=(const ModInt &p) {\n\t\tx = (x ^ p.x) % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator^=(const long long y) {\n\t\tModInt p(y);\n\t\tx = (x ^ p.x) % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator^=(const int y) {\n\t\tModInt p(y);\n\t\tx = (x ^ p.x) % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const ModInt &p) {\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const long long y) {\n\t\tModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const int y) {\n\t\tModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt operator=(const int y) {\n\t\tModInt p(y);\n\t\t*this = p;\n\t\treturn *this;\n\t}\n\tModInt operator=(const long long y) {\n\t\tModInt p(y);\n\t\t*this = p;\n\t\treturn *this;\n\t}\n\tModInt operator-() const { return ModInt(-x); }\n\tModInt operator++() { \n\t\tx++;\n\t\tif(x>=mod) x-=mod;\n\t\treturn *this; \n\t}\n\tModInt operator--() { \n\t\tx--;\n\t\tif(x<0) x+=mod;\n\t\treturn *this; \n\t}\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\tModInt operator^(const ModInt &p) const { return ModInt(*this) ^= p; }\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\tModInt inv() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile(b > 0) {\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tModInt pow(long long n) const {\n\t\tModInt ret(1), mul(x);\n\t\twhile(n > 0) {\n\t\t\tif(n & 1) ret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tfriend ostream &operator<<(ostream &os, const ModInt &p) {\n\t\treturn os << p.x;\n\t}\n\tfriend istream &operator>>(istream &is, ModInt &a) {\n\t\tlong long t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n};\nusing modint = ModInt<MOD>;\n\nint main() {\n    int N; cin >> N;\n    vector<char> c(N+1);\n    for(int i = 1; i <= N; ++i) cin >> c[i];\n    //dp i番目まで見て,iより上がj個余ってる\n    auto dp = multivector(N+1,N+1,modint(0));\n    dp[0][0]=1;\n    for(int i = 1; i <= N; ++i) {\n        for(int j = 0; j <= i; ++j) {\n            if(c[i]=='-') {\n                dp[i][j] += dp[i-1][j];\n            }\n            if(c[i]=='U') {\n                if(j) dp[i][j] += dp[i-1][j-1];\n                dp[i][j] += dp[i-1][j]*j;\n            }\n            if(c[i]=='D') {\n                dp[i][j] += dp[i-1][j]*j;\n                if(j) dp[i][j-1] += dp[i-1][j]*j*j;\n            }\n        }\n    }\n    cout << dp[N][0] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include<random>\n#include<array>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define rrep(i, a, b) for(int i = b - 1; i >= a; i--)\n#define ALL(a) a.begin(), a.end()\nusing pii = pair<int,int>;\nusing piii = pair<pii,int>;\nusing pll = pair<long long, long long>;\nusing plll = pair<pll, long long>;\n// #pragma GCC optimize(\"Ofast\")\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n#define pb push_back\n#define mp make_pair\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define isSquare(x) (sqrt(x)*sqrt(x) == x)\ntemplate<class T>inline bool chmax(T &a, const T &b) {if(a<b){a = b; return 1;} return 0; };\ntemplate<class T>inline bool chmin(T &a, const T &b) {if(a>b){a = b; return 1;} return 0; };\ninline void in(void){return;}\ntemplate <typename First, typename... Rest> void in(First& first, Rest&... rest){cin >> first;in(rest...);return;}\ninline void out(void){cout << \"\\n\";return;}\ntemplate <typename First, typename... Rest> void out(First first, Rest... rest){cout << first << \" \";out(rest...);return;}\nconst double EPS = 1e-9;\nconst int mod = 1e9 + 7;\n// const int mod = 998244353;\nconst int INF = 1e9;\nconst long long INFLL = 1e18;\nvoid iosetup() {\n    cin.tie(nullptr);ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n}\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n    for(int i = 0; i < (int) v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n    for(T &in : v) is >> in;\n    return is;\n}\ntemplate<class T> vector<T> make_vec(size_t a) {return vector<T>(a); }\ntemplate<class T, class... Ts> auto make_vec(size_t a, Ts... ts){\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first-t.first, s.second-t.second);}\ntemplate<class S, class T> pair<S,T> operator*(const pair<S,T> &s, const S& t){return pair<S,T>(s.first*t, s.second*t);}\ntemplate <typename T> void Exit(T first){cout << first << endl;exit(0); };\ntemplate< int mod > struct ModInt {\n    unsigned x; ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) {if((x += p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator-=(const ModInt &p) {if((x += mod - p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator*=(const ModInt &p) {x = (int) (1LL * x * p.x % mod);return *this;}\n    ModInt &operator/=(const ModInt &p) {*this *= p.inverse();return *this;}\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    ModInt inverse() const {int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); }return ModInt(u);}\n    ModInt pow(int64_t n) const {ModInt ret(1), mul(x); while(n > 0) {if(n & 1) ret *= mul;mul *= mul;n >>= 1;}return ret;}\n    friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x;}\n    friend istream &operator>>(istream &is, ModInt &a) { int64_t t; is >> t; a = ModInt< mod >(t); return (is); }\n    static int get_mod() { return mod; }\n}; using modint = ModInt< mod >;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst pii dxy[4] = {pii(1,0), pii(0, 1), pii(-1, 0), pii(0, -1)};\nbool range(int a, int b, int x){if(a <= x and x < b)return true;else return false;}\nbool range(int a, int b, int c, int d, pii p){if(a <= p.first and p.first < b and c <= p.second and p.second < d) return true;else return false;}\n\n\nint main(){\n    iosetup();\n    int n; cin >> n;\n    vector<char> c(n); cin >> c;\n    auto dp = make_vec<modint>(n+1, n+1);\n    dp[0][0] = 1;\n    rep(i, 0, n){\n        if(c[i] == '-'){\n            rep(j, 0, n){\n                dp[i+1][j+1] = dp[i][j];\n            }\n        }else if(c[i] == 'D'){\n            rep(j, 0, n){\n                if(j+2<=n) dp[i+1][j+2] += dp[i][j] * (i - j) * (i - j);\n                dp[i+1][j+1] += dp[i][j] * (i - j);\n            }\n        }else{\n            rep(j, 0, n + 1){\n                if(j+1<=n) dp[i+1][j+1] += dp[i][j] * (i - j);\n                dp[i+1][j] += dp[i][j];\n            }\n        }\n    }\n    cout << dp[n][n] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nchar S[200]; int n;\nlong long dp[220][220];\nint main() {\n\tcin >> n; dp[0][0] = 1;\n\tfor (int i = 0; i < n; i++)cin >> S[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (dp[i][j] == 0)continue;\n\t\t\tif (S[i] == '-') {\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t}\n\t\t\tif (S[i] == 'D') {\n\t\t\t\tif (j >= 1)dp[i + 1][j - 1] += dp[i][j] * j*j;\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j;\n\t\t\t}\n\t\t\tif (S[i] == 'U') {\n\t\t\t\tdp[i + 1][j] += dp[i][j] * j;\n\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t}\n\t\t\tdp[i + 1][j] %= 1000000007;\n\t\t\tdp[i + 1][j + 1] %= 1000000007;\n\t\t\tdp[i + 1][j - 1] %= 1000000007;\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse(static_cast<ll>(x.v), static_cast<ll>(mod))}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod)))} {}\n    ModInt(const ModInt& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& m) { return v = m(), (*this); }\n    ModInt& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod))), (*this); }\n    friend ModInt operator+(const ModInt& m) { return m; }\n    friend ModInt operator-(const ModInt& m) { return make(norm(mod - m.v)); }\n    friend ModInt operator+(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + m2.v)); }\n    friend ModInt operator-(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + mod - m2.v)); }\n    friend ModInt operator*(const ModInt& m1, const ModInt& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod))); }\n    friend ModInt operator/(const ModInt& m1, const ModInt& m2) { return m1 * inv(m2.v); }\n    friend ModInt operator+(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) - val}; }\n    friend ModInt operator*(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * inv(val)}; }\n    friend ModInt operator+(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ll val, const ModInt& m) { return ModInt{-static_cast<ll>(m.v) + val}; }\n    friend ModInt operator*(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ll val, const ModInt& m) { return ModInt{val * inv(static_cast<ll>(m.v))}; }\n    friend ModInt& operator+=(ModInt& m1, const ModInt& m2) { return m1 = m1 + m2; }\n    friend ModInt& operator-=(ModInt& m1, const ModInt& m2) { return m1 = m1 - m2; }\n    friend ModInt& operator*=(ModInt& m1, const ModInt& m2) { return m1 = m1 * m2; }\n    friend ModInt& operator/=(ModInt& m1, const ModInt& m2) { return m1 = m1 / m2; }\n    friend ModInt& operator+=(ModInt& m, const ll val) { return m = m + val; }\n    friend ModInt& operator-=(ModInt& m, const ll val) { return m = m - val; }\n    friend ModInt& operator*=(ModInt& m, const ll val) { return m = m * val; }\n    friend ModInt& operator/=(ModInt& m, const ll val) { return m = m / val; }\n    friend ModInt operator^(const ModInt& m, const ll n) { return power(m.v, n); }\n    friend ModInt& operator^=(ModInt& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const ModInt& m1, const ModInt& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const ModInt& m1, const ModInt& m2) { return not(m1 == m2); }\n    friend bool operator==(const ModInt& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ModInt& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const ModInt& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ll val, const ModInt& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, ModInt& m)\n    {\n        uint v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& m) { return os << m(); }\n    static std::vector<ModInt> invVec(const std::size_t N)\n    {\n        std::vector<ModInt> ans(N + 1, 1);\n        for (std::size_t i = 2; i <= N; i++) { ans[i] = -ans[mod % i] * (mod / i); }\n        return ans;\n    }\n    uint operator()() const { return v; }\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    using mint = ModInt<MOD>;\n    const int N = read<int>();\n    std::vector<mint> dp(N + 1, 0);\n    dp[0] = 1;\n    for (int i = 0; i < N; i++) {\n        std::vector<mint> nxt(N + 1, 0);\n        const char c = read<char>();\n        for (int j = 0; j <= N; j++) {\n            if (dp[j] == 0) { continue; }\n            if (c == '-') {\n                nxt[j] += dp[j];\n            } else if (c == 'D') {\n                nxt[j] += j * dp[j];\n                if (j >= 1) { nxt[j - 1] += j * j * dp[j]; }\n            } else {\n                nxt[j] += j * dp[j];\n                if (j + 1 <= N) { nxt[j + 1] += dp[j]; }\n            }\n        }\n        dp = nxt;\n    }\n    std::cout << dp[0] << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MN = 220;\nconst ll MD = 1e9+7;\n\nint n;\nint d[MN];\nll dp[MN][MN];\n\nll solve(int i, int j) {\n    if (i == 0) {\n        if (j == 0) return 1;\n        return 0;\n    }\n    if (dp[i][j] != -1) return dp[i][j];\n    ll &res = dp[i][j];\n    if (d[i-1] == 0) {\n        //-\n        return res = solve(i-1, j);\n    } else if (d[i-1] == 1) {\n        //U\n        res = solve(i-1, j-1);\n        res += j*solve(i-1, j);\n        res %= MD;\n        return res;\n    } else {\n        //D\n        res = (j+1)*(j+1)*solve(i-1, j+1);\n        res += j*solve(i-1, j);\n        res %= MD;\n        return res;\n    }\n}\n\nint main() {\n    memset(dp, -1, sizeof(dp));\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        if (s == \"-\") {\n            d[i] = 0;\n        } else if (s == \"U\") {\n            d[i] = 1;\n        } else {\n            d[i] = 2;\n        }\n    }\n    cout << solve(n, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tll dp[420] = {}, *dp0 = dp+1, *dp1 = dp+221;\n\tdp1[0] = 1;\n\tint n; cin >> n;\n\twhile (n--) {\n\t\tchar c; cin >> c;\n\t\tif (c == '-') continue;\n\t\tfor (int j = 0; j < 210; j++) {\n\t\t\tdp0[j] = (j*dp1[j] +\n\t\t\t\t((c == 'U') ? dp1[j-1] : (j+1)*(j+1)*dp1[j+1])) % (ll)(1e9+7);\n\t\t}\n\t\tswap(dp0, dp1);\n\t}\n\tcout << dp1[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll MOD=1e9+7;\nint main(){\n    int n;\n    cin>>n;\n    vector<char> c(n);\n    for(int i=0;i<n;i++) cin>>c[i];\n    vector<vector<ll>> dp(n+1,vector<ll>(n+1,0));\n    dp[0][0]=1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(c[i]=='-'){\n                dp[i+1][j]=dp[i][j];\n            }\n            if(c[i]=='U'){\n                (dp[i+1][j+1]+=dp[i][j])%=MOD;\n                (dp[i+1][j]+=dp[i][j]*j)%=MOD;\n            }\n            if(c[i]=='D'){\n                if(j-1>=0){\n                    (dp[i+1][j]+=dp[i][j]*j)%=MOD;\n                    (dp[i+1][j-1]+=(dp[i][j]*j)%MOD*j)%=MOD;\n                }\n            }\n        }\n    }\n    cout<<dp[n][0]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rrep(i,n) for(int (i)=((n)-1);(i)>=0;(i)--)\n#define itn int\n#define miele(v) min_element(v.begin(), v.end())\n#define maele(v) max_element(v.begin(), v.end())\n#define SUM(v) accumulate(v.begin(), v.end(), 0LL)\n#define lb(a, key) lower_bound(a.begin(),a.end(),key)\n#define ub(a, key) upper_bound(a.begin(),a.end(),key)\n#define COUNT(a, key) count(a.begin(), a.end(), key) \n#define BITCOUNT(x) __builtin_popcount(x)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\nusing P = pair <int,int>;\nusing WeightedGraph = vector<vector <P>>;\nusing UnWeightedGraph = vector<vector<int>>;\nusing Real = long double;\nusing Point = complex<Real>; //Point and Vector2d is the same!\nusing Vector2d = complex<Real>;\nconst long long INF = 1LL << 60;\nconst int MOD = 1000000007;\nconst double EPS = 1e-15;\nconst double PI=3.14159265358979323846;\ntemplate <typename T> \nint getIndexOfLowerBound(vector <T> &v, T x){\n    return lower_bound(v.begin(),v.end(),x)-v.begin();\n}\ntemplate <typename T> \nint getIndexOfUpperBound(vector <T> &v, T x){\n    return upper_bound(v.begin(),v.end(),x)-v.begin();\n}\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n#define DUMPOUT cerr\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\nistream &operator>>(istream &is, Point &p) {\n    Real a, b; is >> a >> b; p = Point(a, b); return is;\n}\ntemplate <typename T, typename U>\nistream &operator>>(istream &is, pair<T,U> &p_var) {\n    is >> p_var.first >> p_var.second;\n    return is;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    DUMPOUT<<'{';\n    os << pair_var.first;\n    DUMPOUT<<',';\n    os << \" \"<< pair_var.second;\n    DUMPOUT<<'}';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> &vec) {\n    DUMPOUT<<'[';\n    for (int i = 0; i < vec.size(); i++) \n    os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    DUMPOUT<<']';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<vector<T>> &df) {\n  for (auto& vec : df) os<<vec;\n  return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    DUMPOUT << \"{\";\n    repi(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) DUMPOUT << \", \";\n        itr--;\n    }\n    DUMPOUT << \"}\";\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    DUMPOUT << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) DUMPOUT << \", \";\n        itr--;\n    }\n    DUMPOUT << \"}\";\n    return os;\n}\nvoid print() {cout << endl;}\ntemplate <class Head, class... Tail>\nvoid print(Head&& head, Tail&&... tail) {\n  cout << head;\n  if (sizeof...(tail) != 0) cout << \" \";\n  print(forward<Tail>(tail)...);\n}\nvoid dump_func() {DUMPOUT << '#'<<endl;}\ntemplate <typename Head, typename... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                              \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                            \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\"        \\\n            << endl                                                            \\\n            << \"    \",                                                         \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<1000000007>;\nsigned main(void) { cin.tie(0); ios::sync_with_stdio(false);\n    int n; cin>>n;\n    vector <char> a(n);\n    cin>>a;\n    vector <vector<mint>> dp(n+1,vector <mint>(n+1));//みてる場所, 保留した場所の数\n    dp[0][0] = 1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            //順位が変わらない時はそのまま\n            if(a[i] == '-') dp[i+1][j] += dp[i][j];\n            else if(a[i] == 'D'){\n                //Dの時は保留はしない。上のどこかに当てる\n                dp[i+1][j] += (mint)j*dp[i][j];\n                if(j != 0){\n                    //上のどこかに当ててさらに保留してきたのをi番目に当てる\n                    dp[i+1][j-1] += (mint)(j*j)*dp[i][j];\n                }\n            }else{\n                //保留するだけ\n                dp[i+1][j+1] += dp[i][j];\n                if(i != 0){\n                    //保留する & 今までに保留してたのを1つ選んで当てる\n                    dp[i+1][j] += (mint)j*dp[i][j];\n                }\n            }\n        }\n    }\n    print(dp[n][0]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Author: Shusuke Ueda\n// AOJ 2439 - 箱根駅伝\n\n#include <iostream>\n#include <vector>\n\nnamespace nt {\n    template <int_fast64_t mod>\n    class ModInt {\n        int_fast64_t val;\n\n      public:\n        ModInt(): val(0) {}\n        ModInt(int_fast64_t init_val): val(init_val >= 0? init_val % mod: mod - (-init_val % mod)) {}\n\n        friend std::istream& operator >> (std::istream& is, ModInt& n) {\n            int_fast64_t init_val;\n            is >> init_val;\n            n = ModInt(init_val);\n            return is;\n        }\n        friend std::ostream& operator << (std::ostream& os, const ModInt n) {\n            os << n.val;\n            return os;\n        }\n\n        ModInt operator -() const {\n            return ModInt(-val);\n        }\n        bool operator !() const {\n            return val == 0;\n        }\n        ModInt& operator ++() {\n            val++;\n            if (val >= mod) {\n                val -= mod;\n            }\n            return *this;\n        }\n        ModInt operator ++(int) {\n            ModInt tmp = *this;\n            val++;\n            if (val >= mod) {\n                val -= mod;\n            }\n            return tmp;\n        }\n        ModInt& operator --() {\n            val--;\n            if (val < 0) {\n                val += mod;\n            }\n            return *this;\n        }\n        ModInt operator --(int) {\n            ModInt tmp = *this;\n            val--;\n            if (val < 0) {\n                val += mod;\n            }\n            return tmp;\n        }\n\n        ModInt& operator += (const ModInt that) {\n            val += that.val;\n            if (val >= mod) {\n                val -= mod;\n            }\n            return *this;\n        }\n        ModInt& operator -= (const ModInt that) {\n            val -= that.val;\n            if (val < 0) {\n                val += mod;\n            }\n            return *this;\n        }\n        ModInt& operator *= (const ModInt that) {\n            val = val * that.val % mod;\n            return *this;\n        }\n        ModInt& operator /= (const ModInt that) {\n            int_fast64_t res = 1, n = that.val, p = mod - 2;\n            while (p > 0) {\n                if (p % 2 == 1) {\n                    res = res * n % mod;\n                }\n                n = n * n % mod;\n                p /= 2;\n            }\n            val = val * res % mod;\n            return *this;\n        }\n\n        ModInt operator + (const ModInt that) const {\n            return ModInt(*this) += that;\n        }\n        ModInt operator - (const ModInt that) const {\n            return ModInt(*this) -= that;\n        }\n        ModInt operator * (const ModInt that) const {\n            return ModInt(*this) *= that;\n        }\n        ModInt operator / (const ModInt that) const {\n            return ModInt(*this) /= that;\n        }\n    };\n\n    using mint = ModInt<1000000007>;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::string s;\n    for (int i = 0; i < n; i++) {\n        char c;\n        std::cin >> c;\n        if (c != '-') {\n            s += c;\n        }\n    }\n    n = s.length();\n    s = '0' + s + '0';\n\n    std::vector<std::vector<nt::mint>> dp(n + 1, std::vector<nt::mint>(n + 2));\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (s[i] == 'U') {\n                if (j > 0) {\n                    dp[i][j] += dp[i - 1][j - 1];\n                }\n                dp[i][j] += dp[i - 1][j] * j;\n            } else {\n                dp[i][j] += dp[i - 1][j] * j + dp[i - 1][j + 1] * (j + 1) * (j + 1);\n            }\n        }\n    }\n\n    std::cout << dp[n][0] << std::endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define mad(a,b) a=(a+b)%mod\n#define N 210\nll dp[N][N][N];\nint main(){\n\tll n;\n\tvector<bool> v;\n\tcin>>n;\n\trep(i,n){\n\t\tchar c; cin>>c;\n\t\tif(c=='D')v.push_back(0);\n\t\tif(c=='U')v.push_back(1);\n\t}\n\tn=v.size();\n\trep(i,N)rep(j,N)rep(k,N)dp[i][j][k]=0;\n\tdp[0][0][0]=1;\n\trep(i,n){\n\t\trep(x,N)rep(y,N){\n\t\t\tif(v[i]==0){\n\t\t\t\tif(x>=1)mad(dp[i+1][x][y],dp[i][x][y]*x);\n\t\t\t\tif(x>=1&&y>=1)mad(dp[i+1][x-1][y-1],dp[i][x][y]*x*y);\n\t\t\t}\n\t\t\tif(v[i]==1){\n\t\t\t\tmad(dp[i+1][x+1][y+1],dp[i][x][y]);\n\t\t\t\tif(y>=1)mad(dp[i+1][x][y],dp[i][x][y]*y);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][0][0]<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<vector<int>> graph(n);\n    rep(i,0,n){\n        char c;\n        cin >> c;\n        if(c=='-') graph[i].push_back(i);\n        if(c=='U') rep(j,i+1,n) graph[i].push_back(j);\n        if(c=='D') rep(j,0,i) graph[i].push_back(j);\n    }\n\n    vector<int> ord;\n    rep(i,0,n/2){\n        ord.push_back(i);\n        ord.push_back(n-i-1);\n    }\n    rep(i,0,n) if(find(ord.begin(),ord.end(),i)==ord.end()) ord.push_back(i);\n\n    const int64_t mod=1e9+7;\n    vector<bool> used(n);\n    function<int64_t(int i)> rec=[&](int i){\n        if(i==n) return int64_t(1);\n        int64_t res=0;\n        int u=ord[i];\n        for(int v:graph[u]){\n            if(used[v]) continue;\n            used[v]=true;\n            res=(res+rec(i+1))%mod;\n            used[v]=false;\n        }\n        return res;\n    };\n\n    cout << rec(0) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nchar c[200];\ntypedef long long ll;\nll mod=1e9+7;\nll dp[210][210][210];\nvoid add(ll &x,ll y){\n\tx+=y;\n\tx%=mod;\n}\nint main(){\n\tint n,nc=0;\n\tcin>>n;\n\trep(i,n){\n\t\tchar cc;\n\t\tcin>>cc;\n\t\tif(cc!='-') c[nc++]=cc;\n\t}\n\tn=nc;\n\tdp[0][0][0]=1;\n\trep(i,n){\n\t\trep(j,n+1){\n\t\t\trep(k,n+1){\n\t\t\t\tif(c[i]=='D'){\n\t\t\t\t\tif(k>0) add(dp[i+1][j+2][k-1],dp[i][j][k]*(i-j)*k);\n\t\t\t\t\tadd(dp[i+1][j+1][k],dp[i][j][k]*(i-j));\n\t\t\t\t}else{\n\t\t\t\t\tif(k>0) add(dp[i+1][j+1][k],dp[i][j][k]*k);\n\t\t\t\t\tadd(dp[i+1][j][k+1],dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][n][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define MOD 1000000007\n\nint n;\nchar c[300];\n\nint memo[300][300];\n\nint dp(int i, int j){\n    if(i == n){\n        return j == 0 ? 1 : 0;\n    }\n\n    if(memo[i][j] != -1) return memo[i][j];\n\n    int ans = 0;\n    if(c[i] == '-'){\n        ans = dp(i+1, j);\n    }else if(c[i] == 'U'){\n        if(j > 0) ans = (dp(i+1, j) * j) % MOD;\n        ans = (ans + (dp(i+1, j+1) % MOD))%MOD;\n    }else{\n        if(j > 0) ans = dp(i+1, j-1) * j % MOD * j % MOD;\n        ans = (ans + (dp(i+1, j) * j) % MOD)%MOD;\n    }\n\n    return memo[i][j] = ans;\n}\n\nsigned main(){\n    cin >> n;\n\n    for(int i = 0;i < n;i++){\n        cin >> c[i];\n    }\n\n    memset(memo, -1, sizeof(memo));\n\n    cout << dp(0, 0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,MOD=1000000007;\n\tcin>>n;\n\tvi in;\n\twhile(n--){\n\t\tchar c;cin>>c;\n\t\tif(c=='U')in.pb(0);\n\t\tif(c=='D')in.pb(1);\n\t}\n\tn=in.size();\n\tvvi dp(n+1,vi(n+1));\n\tdp[0][0]=1;\n\trep(i,n)rep(j,n)if(dp[i][j]){\n\t\tif(in[i]){\n\t\t\t(dp[i+1][j]+=dp[i][j]*j)%=MOD;\n\t\t\tif(j)(dp[i+1][j-1]+=dp[i][j]*j*j)%=MOD;\n\t\t}else{\n\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t\t(dp[i+1][j]+=dp[i][j]*j)%=MOD;\n\t\t}\n\t}\n\tcout<<dp[n][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\nll dp[210][210];\nint U[210], D[210];\nconst ll M = 1e9+7;\n\nint main() {\n\tint n;\n\tvector<int> v;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(s[0] == 'U')\n\t\t\tv.push_back(1);\n\t\telse if(s[0] == 'D')\n\t\t\tv.push_back(-1);\n\t}\n\tif(!v.size()) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\n\tU[0] = v[0] == 1;\n\tD[0] = v[0] == -1;\n\tfor(int i = 1; i < v.size(); i++) {\n\t\tU[i] = U[i-1] + (v[i] == 1);\n\t\tD[i] = D[i-1] + (v[i] == -1);\n\t}\n\n\tdp[0][0] = 1;\n\tfor(int i = 0; i < v.size(); i++) {\n\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t// i+1??????????????????????????¨???\n\t\t\tif(j-1 >= 0) {\n\t\t\t\tll tmp;\n\t\t\t\ttmp = dp[i][j-1];\n\t\t\t\tif(v[i] == -1) {\n\t\t\t\t\ttmp *= max(0,(j-1)-D[i-1]);\n\t\t\t\t\ttmp %= M;\n\t\t\t\t}\n\t\t\t\tdp[i+1][j] += tmp;\n\t\t\t\tdp[i+1][j] %= M;\n\t\t\t}\n\t\t\t// i+1??????????????????????????????\n\t\t\tif(i > 0 && U[i]-(i-j) >= 0) {\n\t\t\t\tll tmp;\n\t\t\t\ttmp = dp[i][j] * (U[i-1] - (i-j)) % M;\n\t\t\t\tif(v[i] == -1) {\n\t\t\t\t\ttmp *= max(0,j-D[i-1]);\n\t\t\t\t\ttmp %= M;\n\t\t\t\t}\n\t\t\t\tdp[i+1][j] += tmp;\n\t\t\t\tdp[i+1][j] %= M;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i = 0; i < 10; i++) {\n\t\tfor(int j = 0; j < 10; j++)\n\t\t\tcout << dp[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\tcout << v.size() << \" \" << D[v.size()-1] << endl;\n\t// */\n\tcout << dp[v.size()][D[v.size()-1]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long int MOD=1e9+7;\n\nint main(){\n  int n;\n  cin>>n;\n  vector<char> c(n);\n  for(int i=0;i<n;i++) cin>>c[i];\n  vector<vector<vector<long long int>>> dp(n+1,vector<vector<long long int>>(n+1,vector<long long int>(n+1,0)));\n  dp[0][0][0]=true;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=n;j++){\n      for(int k=0;k<=n;k++){\n\tif(c[i]=='D'){\n\t  dp[i+1][j][k]=(j+1<=n ? dp[i][j][k] : 0)*j+(j+1<=n && k+1<=n ? dp[i][j+1][k+1]*(j+1)*(k+1):0);\n\t}\n\telse if(c[i]=='U'){\n\t  dp[i+1][j][k]=dp[i][j][k]*k+(j-1>=0 && k-1>=0 ? dp[i][j-1][k-1] : 0);\n\t}\n\telse{\n\t  dp[i+1][j][k]=dp[i][j][k];\n\t}\n\tdp[i+1][j][k]%=MOD;\n\t\n      }\n    }\n  }\n\n  cout<<dp[n][0][0]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst long long mod=1000000007;\n\nlong long dp[220][220][220];\n\nvector<char> ch;\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tchar in[2];\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]!='-') ch.push_back(in[0]);\n\t}\n\tdp[0][0][0]=1;\n\tint s=ch.size();\n\tfor(int n=0;n<s;n++){\n\t\tfor(int i=0;i<=s;i++) for(int j=0;j<=s;j++){\n\t\t\tif(ch[n]=='U'){\n\t\t\t\tdp[n+1][i+1][j+1]+=dp[n][i][j];\n\t\t\t\tdp[n+1][i+1][j+1]%=mod;\n\t\t\t\tdp[n+1][i][j]+=dp[n][i][j]*i;\n\t\t\t\tdp[n+1][i][j]%=mod;\n\t\t\t}else{\n\t\t\t\tif(j>=1){\n\t\t\t\t\tdp[n+1][i][j]+=dp[n][i][j]*j;\n\t\t\t\t\tdp[n+1][i][j]%=mod;\n\t\t\t\t\tif(i>=1){\n\t\t\t\t\t\tdp[n+1][i-1][j-1]+=dp[n][i][j]*i*j;\n\t\t\t\t\t\tdp[n+1][i-1][j-1]%=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[s][0][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst ll MOD = 1000000007;\n\nint main(void){\n    ll res;\n\n    for(int n; cin >> n;){\n        res = 0;\n        string ranks;\n        rep(i, n){\n            char r; cin >> r;\n            ranks.pb(r);\n        }\n\n        vector< vector<ll> > dp(n + 1, vector<ll>(n + 1));\n        dp[0][0] = 1;\n\n        rep(i, n){\n            rep(j, n){\n                if(ranks[i] == '-'){\n                    dp[i + 1][j] = dp[i][j];\n                }\n                else if(ranks[i] == 'U'){\n                   (dp[i + 1][j] += dp[i][j] * j) %= MOD;\n                   (dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n                }\n                else{\n                    (dp[i + 1][j] += dp[i][j] * j) %= MOD;\n                    if(j != 0){\n                       (dp[i + 1][j - 1] += dp[i][j] * j * j) %= MOD;\n                    }\n                }\n            }\n        }\n\n        cout << dp[n][0] << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\nconstexpr int MAX_N = 200;\nconstexpr long long mod = 1000000007;\nlong long dp[MAX_N + 1][MAX_N + 1][MAX_N + 1]; // idx, team, place\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tvector<char> c(n);\n\tfor(auto &e : c) cin >> e;\n\tc.erase(remove(begin(c), end(c), '-'), end(c));\n\tn = c.size();\n\n\tdp[0][0][0] = 1;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(c[i] == 'U') {\n\t\t\tfor(int j = 0; j <= i; ++j) {\n\t\t\t\tfor(int k = 0; k <= i; ++k) {\n\t\t\t\t\tdp[i + 1][j + 1][k + 1] += dp[i][j][k];\n\t\t\t\t\tdp[i + 1][j + 1][k + 1] %= mod;\n\n\t\t\t\t\tif(j) {\n\t\t\t\t\t\tdp[i + 1][j][k] += j * dp[i][j][k];\n\t\t\t\t\t\tdp[i + 1][j][k] %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(c[i] == 'D');\n\t\t\tfor(int j = 0; j <= i; ++j) {\n\t\t\t\tfor(int k = 1; k <= i; ++k) {\n\t\t\t\t\tdp[i + 1][j][k] += k * dp[i][j][k];\n\t\t\t\t\tdp[i + 1][j][k] %= mod;\n\n\t\t\t\t\tif(j) {\n\t\t\t\t\t\tdp[i + 1][j - 1][k - 1] += j * k * dp[i][j][k];\n\t\t\t\t\t\tdp[i + 1][j - 1][k - 1] %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0][0] << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[202][202];\n\nint main(void){\n\n  fill(dp[0],dp[202],0);\n\n  int n;\n  cin >> n;\n\n  string c;\n\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  dp[0][0]=1;\n\n  for(int k=0;k<n;k++){\n    for(int i=0;i<=k;i++){\n      if(c[k]=='-')dp[k+1][i]=dp[k][i];\n      else if(c[k]=='D'){\n        if(i>0){\n          dp[k+1][i-1]+=((dp[k][i]*i)%MOD*i)%MOD;\n          dp[k+1][i-1]%=MOD;\n        }\n        dp[k+1][i]+=(dp[k][i]*i)%MOD;\n      }\n      else if(c[k]=='U'){\n        dp[k+1][i]+=(dp[k][i]*i)%MOD;\n        dp[k+1][i+1]+=dp[k][i];\n        dp[k+1][i+1]%=MOD;\n      }\n      dp[k+1][i]%=MOD;\n    }\n  }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nconst int64_t MOD = 1000000007;\n\nint main() {\n  int64_t n;\n  cin>>n;\n  vector<int> ud;\n  REP(i,n){\n    string d;\n    cin>>d;\n    if(d==\"U\") ud.push_back(1);\n    if(d==\"D\") ud.push_back(0);\n  }\n  int m = ud.size();\n  vector<vector<int64_t>> dp(m+1, vector<int64_t>(m+1, 0));\n  dp[0][0] = 1;\n  REP(i,m) {\n    if (ud[i]) {\n      REP(j,m) {\n        dp[i+1][j] += j * dp[i][j];\n        dp[i+1][j] %= MOD;\n        dp[i+1][j+1] += dp[i][j];\n        dp[i+1][j+1] %= MOD;\n      }\n    } else {\n      FOR(j,1,m) {\n        dp[i+1][j-1] += j * j * dp[i][j];\n        dp[i+1][j-1] %= MOD;\n        dp[i+1][j] += j * dp[i][j];\n        dp[i+1][j] %= MOD;\n      }\n    }\n  }\n  cout << dp[m][0] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\nlong long MOD = 1000000007LL;\n\nlong long dp[210][210];\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tdp[0][0] = 1;\n\tvector<char> v(n);\n\trep(i, n) {\n\t\tcin >> v[i];\n\t\tif(v[i] == '-') {\n\t\t\tn--;\n\t\t\ti--;\n\t\t}\n\t}\n\t// v.erase(v.begin()+n, v.end());\n\n\trep(i, n) {\n\t\tchar t = v[i];\n\t\trep(j, n) {\n\t\t\tif(t == 'U') {\n\t\t\t\tif(j>0) (dp[i + 1][j] += j*dp[i][j]%MOD) %= MOD;\n\t\t\t\t(dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(j - 1 >= 0) (dp[i + 1][j - 1] += j*j*dp[i][j]) %= MOD;\n\t\t\t\tif(j>0) (dp[i + 1][j] += j*dp[i][j]) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n\ninline void sort(string &a) { sort(a.begin(), a.end()); }\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T, class F> inline void sort(vector<T> &a, F f) { sort(a.begin(), a.end(), [&](T l, T r) { return f(l) < f(r); }); };\nenum ___pcomparator {\n    fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd\n};\ninline void sort(vector<P> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });\n            break;\n        case fisd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });\n            break;\n        case fdsi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });\n            break;\n        case fdsd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });\n            break;\n        case sifi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });\n            break;\n        case sifd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });\n            break;\n        case sdfi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });\n            break;\n        case sdfd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });\n            break;\n    }\n};\ninline void sort(vector<T> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });\n            break;\n        case\n            fisd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });\n            break;\n        case\n            fdsi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });\n            break;\n        case\n            fdsd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });\n            break;\n        case\n            sifi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });\n            break;\n        case\n            sifd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });\n            break;\n        case\n            sdfi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });\n            break;\n        case\n            sdfd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });\n            break;\n    }\n};\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U, class F> inline void rsort(vector<U> &a, F f) { sort(a.begin(), a.end(), [&](U l, U r) { return f(l) > f(r); }); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;;\n    }\n};\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, char type) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, type);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void rsortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void rsortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    rsort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");\n    exit(0);\n#endif\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {\n    ll res = b[0];\n    for (auto &&v :b)res = gcd(v, res);\n    return res;\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\ntemplate<class T> void rev(vector<T> &a) {\n    reverse(all(a));\n}\nvoid rev(string &a) {\n    reverse(all(a));\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        debugline(\"ceil\");\n        deb(a, b);\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0) {\n        debugline(\"sqrt\");\n        deb(a);\n        ole();\n    }\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    double lim = std::sqrt(v);\n    for (int i = 1; i <= lim; ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvb isPrime;\nvi primes;\n\nvoid setPrime() {\n    int len = 4010101;\n    isPrime.resize(4010101);\n    fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;\n    fora(v, ret)v = u(v);\n    return ret;\n}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T> T sum(vector<T> &v, int s = 0, int t = inf) {\n    T ret = 0;\n    rep(i, s, min(sz(v), t))ret += v[i];\n    return ret;\n}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    return ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    return ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &m) {\n    for (auto &&v:m) os << v << \" \";\n    return os;\n}\nconstexpr bool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\nll bit(int n) { return (1LL << (n)); }\nll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint mask(int n) { return (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] + a[i];\n    return ret;\n}\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> inline bool chma(const U &b) { return chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> inline bool chmi(const U &b) { return chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\nint max(vi &a) {\n    int res = a[0];\n    fora(v, a) {\n        res = max(res, v);\n    }\n    return res;\n}\nint min(vi &a) {\n    int res = a[0];\n    fora(v, a) {\n        res = min(res, v);\n    }\n    return res;\n}\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi a, b, c;\nvvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\n//@formatter:on\n//nhr n個の場所にr個の物を分ける\n\nint N;\nsigned main() {\n    cin >> N;\n    vc C(N);\n    na(C, N);\n    //i r\n    vector<vector<int>> dp(N + 1, vector<int>(N + 1));\n    dp[0][0] = 1;\n    int MOD = 1e9 + 7;\n    rep(i, N) {\n        rep(r, N + 1) {\n            if (dp[i][r] == 0)continue;\n            if (C[i] == '-') {\n                dp[i + 1][r] += dp[i][r];\n                dp[i + 1][r] %= MOD;\n            } else if (C[i] == 'U') {\n                //l nomi\n                if (r)dp[i + 1][r] += dp[i][r] * r;\n                dp[i + 1][r] %= MOD;\n                //nasi\n                dp[i + 1][r + 1] += dp[i][r];\n                dp[i + 1][r + 1] %= MOD;\n            } else if (C[i] == 'D') {\n                //r nomi\n                if (r)dp[i + 1][r] += dp[i][r] * r;\n                if (r)dp[i + 1][r - 1] += dp[i][r] * r * r;\n                dp[i+1][r]%=MOD;\n                dp[i+1][r-1]%=MOD;\n            }\n        }\n    }\n    rep(i, N) {\n//        deb(dp[i]);\n    }\n    cout << dp[N][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MN = 220;\nconst ll MD = 1e9+7;\n\nint n;\nint d[MN];\nll dp[MN][MN];\n\nll solve(int i, int j) {\n    if (i == 0) {\n        if (j == 0) return 1;\n        return 0;\n    }\n    if (dp[i][j] != -1) return dp[i][j];\n    ll &res = dp[i][j];\n    if (d[i-1] == 0) {\n        res = solve(i-1, j);\n    } else if (d[i-1] == 1) {\n        res = (solve(i-1, j-1)+j*solve(i-1, j)) % MD;\n    } else {\n        res = ((j+1)*(j+1)*solve(i-1, j+1) + j*solve(i-1, j)) % MD;\n    }\n    return res;\n}\n\nint main() {\n    memset(dp, -1, sizeof(dp));\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        if (s == \"-\") {\n            d[i] = 0;\n        } else if (s == \"U\") {\n            d[i] = 1;\n        } else {\n            d[i] = 2;\n        }\n    }\n    cout << solve(n, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nMod dp[201][202][202];\nint main() {\n\tmemset(dp, 0, sizeof(dp));\n\tint N; cin >> N;\n\tvector<int>vs(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tchar c; cin >> c;\n\t\tif (c == '-') {\n\t\t\tvs[i] = 0;\n\t\t}\n\t\telse if (c == 'U') {\n\t\t\tvs[i] = -1;\n\t\t}\n\t\telse {\n\t\t\tvs[i] = 1;\n\t\t}\n\t}\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int downing = 0; downing < 200; ++downing) {\n\t\t\tfor (int upping = 0; upping < 200; ++upping) {\n\t\t\t\tif (vs[i] == 0) {\n\t\t\t\t\tdp[i + 1][downing][upping] += dp[i][downing][upping];\n\t\t\t\t}\n\t\t\t\telse if (vs[i] == 1) {\n\t\t\t\t\t//??????\n\t\t\t\t\tif (downing >= 1) {\n\t\t\t\t\t\tdp[i + 1][downing - 1][upping - 1] += dp[i][downing][upping] * downing*downing;\n\t\t\t\t\t}\n\t\t\t\t\t//??????\n\t\t\t\t\tdp[i + 1][downing][upping] += dp[i][downing][upping] * downing;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//??????\n\t\t\t\t\tdp[i + 1][downing + 1][upping+1] += dp[i][downing][upping];\n\n\t\t\t\t\t//??????\n\t\t\t\t\tif (upping >= 1) {\n\t\t\t\t\t\tdp[i + 1][downing][upping] += dp[i][downing][upping]*downing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[N][0][0] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\n#include <unordered_map>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 2020000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    rep(i,a.size()) cout << a[i] << \" \";\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n\treturn modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n\treturn modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n\treturn modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n\treturn modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n\ta += rhs.a;\n\tif (a >= Modulus) {\n\t  a -= Modulus;\n\t}\n\treturn *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n\tif (a < rhs.a) {\n\t  a += Modulus;\n\t}\n\ta -= rhs.a;\n\treturn *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n\ta = a * rhs.a % Modulus;\n\treturn *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n\tu64 exp = Modulus - 2;\n\twhile (exp) {\n\t  if (exp % 2) {\n\t\t*this *= rhs;\n\t  }\n\t  rhs *= rhs;\n\t  exp /= 2;\n\t}\n\treturn *this;\n  }\n};\n\nusing mint = modint<mod>;\n\nll modpow(ll x, ll n, ll mod){\n\tll res = 1;\n\twhile(n > 0){\n\t\tif(n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nvector<ll> fac(MAX), finv(MAX), inv(MAX);\n\nvoid comInit(){\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(ll i=2; i<MAX; i++){\n\t\tfac[i] = fac[i-1]*i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod/i) % mod;\n\t\tfinv[i] = finv[i-1] * inv[i] % mod;\n\t}\n}\n\n\nll com(ll n, ll k){\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nmint dp[205][205];\n\nint main(){\n\tint n; cin >> n;\n\tvc c(n); rep(i,n) cin >> c[i];\n\tdp[0][0] = 1;\n\trep(i,n){\n\t\tif(c[i] == '-'){\n\t\t\trep(j,i+1){\n\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t}\n\t\t}\n\t\tif(c[i] == 'U'){\n\t\t\trep(j,i+1){\n\t\t\t\tdp[i+1][j+1] += dp[i][j];\n\t\t\t\tdp[i+1][j] += dp[i][j] * j; \n\t\t\t}\n\t\t}\n\t\tif(c[i] == 'D'){\n\t\t\trep(j,i+1){\n\t\t\t\tdp[i+1][j] += dp[i][j] * j;\n\t\t\t\tif(j > 0) dp[i+1][j-1] += dp[i][j] * j * j;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][0].value() << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint n;\nchar c[205];\nllint dp[205][205];//i番目まで終わった。j個保留。k個あとでUを使わねば;\n\nint main(void)\n{\n  cin >> n;\n  for(int i = 1; i <= n; i++) cin >> c[i];\n\n  dp[0][0] = 1;\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j <= n; j++){\n        if(c[i+1] == 'U'){\n          if(j+1 <= n) (dp[i+1][j+1] += dp[i][j]) %= mod;\n          (dp[i+1][j] += dp[i][j] * j % mod) %= mod;\n        }\n        else if(c[i+1] == 'D'){\n          if(j-1 >= 0)(dp[i+1][j-1] += dp[i][j] * j % mod * j % mod) %= mod;\n          (dp[i+1][j] += dp[i][j] * j % mod) %= mod;\n          //(dp[i+1][j] += dp[i][j] * j % mod) %= mod;\n        }\n        else{\n          (dp[i+1][j] += dp[i][j]) %= mod;\n        }\n      }\n    }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\n\n#include <cstdint>\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\n  u64 a;\n\npublic:\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 val() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr bool operator==(const modint rhs) const noexcept {\n    return modint(*this).val() == rhs.val();\n  }\n  modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\nusing mint = modint<MOD>;\n\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<char> s(n);\n  REP(i,n) cin >> s[i];\n  \n  mint dp[222][222] = {};\n  dp[0][0] = 1;\n  REP(i,n){\n    REP(j,n){\n      if(s[i] == '-'){\n        dp[i+1][j] += dp[i][j];\n      }\n      if(s[i] == 'D'){\n        dp[i+1][j] += dp[i][j]*j;\n        if(j) dp[i+1][j-1] += dp[i][j]*j*j;\n      }\n      if(s[i] == 'U'){\n        dp[i+1][j+1] += dp[i][j];\n        dp[i+1][j] += dp[i][j]*j;\n      }\n    }\n  }\n\n  cout << dp[n][0].val() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i<(n); ++i)\ntypedef long long ll;\n\nconst int mod = 1'000'000'007;\nclass mint {\npublic:\n    ll x;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n    mint& operator+=(const mint a) { if ((x += a.x) >= mod) x -= mod; return *this; }\n    mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this; }\n    mint operator+(const mint a) const { return mint(*this) += a; }\n    mint operator*(const mint a) const { return mint(*this) *= a; }\n    operator ll () const { return x; }\n    operator string () const { return to_string(x); }\n};\n\nmint dp[201][201];\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> c;\n    for (int i=0; i<n; ++i) {\n        char t; cin >> t;\n        if (t == 'U') c.push_back(1);\n        else if (t == 'D') c.push_back(-1);\n    }\n    n = c.size();\n\n    dp[0][0] = 1;\n    rep(i,n) rep(j,n+1) {\n        if ( ! dp[i][j]) continue;\n        if (c[i] < 0) {\n            if (j > 0) dp[i+1][j] += dp[i][j] * mint(j);\n            if (j > 0) dp[i+1][j-1] += dp[i][j] * mint(j) * mint(j);\n        } else {\n            dp[i+1][j+1] += dp[i][j];\n            if (j > 0) dp[i+1][j] += dp[i][j] * mint(j);\n        }\n    }\n    cout << dp[n][0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<1000000007> mint;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\nint N; string C[202];\nmint dp[202][202];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) cin >> C[i];\n\n    dp[0][0] = 1;\n    rep(i, 0, N) {\n        rep(d, 0, N + 1) {\n            if (C[i] == \"-\") dp[i + 1][d] = dp[i][d];\n            else if (C[i] == \"D\") {\n                dp[i + 1][d] += dp[i][d] * d;\n                if (d) dp[i + 1][d - 1] += dp[i][d] * d * d;\n            }\n            else {\n                dp[i + 1][d + 1] += dp[i][d];\n                if (d) dp[i + 1][d] += dp[i][d] * d;\n            }\n        }\n    }\n    cout << dp[N][0].get() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[200010];\n                int inv[200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\nint dp[400][400]={};\n signed main(){\n \t\n \n    \t       cin.tie(0);\n   \t\tios::sync_with_stdio(false);\n\n\tdp[0][0]=1;\n \tint n;\n \tcin>>n;\n \tstring s=\"*\";\n \tfor(int i=1;i<=n;i++){\n \t\tstring r;\n \t\tcin>>r;\n \t\ts+=r;\n \t}\n \tfor(int i=1;i<=n;i++)for(int j=0;j<=i;j++){\n \t\t\n \t\t\n \t\tif(s[i]=='D'){\n \t\t\tif(j-2>=0 && i-1-j+2>=0)dp[i][j]+=dp[i-1][j-2]*(i-1-j+2)*(i-1-j+2)%inf;\n \t\t\tif(j-1>=0 && i-1-j+1>=0)dp[i][j]+=dp[i-1][j-1]*(i-1-j+1)%inf;\n \t\t}\n \t\tif(s[i]=='-'){\n \t\t\tif(j-1>=0)dp[i][j]+=dp[i-1][j-1];\n \t\t}\n \t\tif(s[i]=='U'){\n \t\t\tif(j-1>=0 && i-1-j+1 >=0)dp[i][j]+=dp[i-1][j-1]*(i-1-j+1)%inf;\n \t\t\tif(j  >=0  )dp[i][j]+=dp[i-1][j]%inf;\n \t\t}\n \t\tdp[i][j]%=inf;\n \t\t/*\n \t\tif(j-1  >=0 && h-2*(i-1-j+1)     >=0)dp[i][j][h]+=dp[i-1][j-1][h-2*(i-1-j+1)];\n \t\t//if(i==2&& j==2 && h==0) cout<<dp[i][j][h]<<endl;\n \t\tif(j-2>=0 && h-2*(i-1-j+2) >=0)dp[i][j][h]+=dp[i-1][j-2][h-2*(i-1-j+2)]*(i-1-j+2)*(i-1-j+2)%inf;\n \t\tif(j-1>=0 && h-2*(i-1-j+1) >=0)dp[i][j][h]+=dp[i-1][j-1][h-2*(i-1-j+1)]*(i-1-j+1)%inf;\n \t\tif(j-1>=0 && h-2*(i-1-j+1) >=0)dp[i][j][h]+=dp[i-1][j-1][h-2*(i-1-j+1)]*(i-1-j+1)%inf;\n \t\tif(j  >=0 && h-2*(i-1-j) >=0)dp[i][j][h]+=dp[i-1][j][h-2*(i-1-j)]%inf;\n \t\t//cout<<i<<\" \"<<j<<\" \"<<h<<\" \"<<dp[i][j][h]<<endl;\n \t\tdp[i][j][h]%=inf;\n \t\t*/\n \t}\n \t\n \tcout<<dp[n][n]<<endl;\n \treturn 0;\n \n  }\n \n"
  },
  {
    "language": "C++",
    "code": "typedef long long ll;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <queue>\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint main(){\n  const int n = getInt();\n  vector<vector<ll> > now(n + 1, vector<ll>(n + 1));\n  vector<char> ss(n);\n\n  now[0][0] = 1;\n\n  REP(k,n){\n    char c[2]; scanf(\"%s\", c);\n    ss[k] = c[0];\n  }\n\n  REP(k,n){\n    vector<vector<ll> > next(n + 1, vector<ll>(n + 1));\n    const char c = ss[k];\n\n    REP(i,n + 1) REP(j,n + 1) if(now[i][j]){\n      if(c == 'U'){\n        if(j > 0){\n          // ue\n          next[i][j] += now[i][j] * j;\n          next[i][j] %= mod;\n        }\n        // sita\n        next[i + 1][j + 1] += now[i][j];\n        next[i + 1][j + 1] %= mod;\n      }else if(c == 'D'){\n        if(i > 0){\n          if(j > 0){\n            // ue\n            next[i - 1][j - 1] += now[i][j] * j * i;\n            next[i - 1][j - 1] %= mod;\n          }\n          // sita\n          next[i][j] += now[i][j] * i;\n          next[i][j] %= mod;\n        }\n      }else{\n        next[i][j] += now[i][j];\n        next[i][j] %= mod;\n      }\n    }\n\n    now.swap(next);\n  }\n\n  printf(\"%d\\n\", (int)now[0][0]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=1000000007;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b)%p;\n\telse if(arrays[n]==-1) DP[n][a][b]=(ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b)));\n\telse return DP[n][a][b]=(ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p);\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<stack>\n#include<queue>\n\nusing namespace std;\n\nconst int MOD=1e9+7;\n\ntypedef long long ll;\n\nint main(){\n\tint N;\n\tll dp[201][201];\n\tstring st;\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif(c!='-') st+=c;\n\t}\n\tN=st.size();\n\tdp[0][0]=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(st[i]=='D'){\n\t\t\t\tdp[i+1][j]+=dp[i][j]*j%MOD;\n\t\t\t\tif(j!=0) dp[i+1][j-1]+=dp[i][j]*j*j%MOD;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i+1][j+1]+=dp[i][j]%MOD;\n\t\t\t\tdp[i+1][j]+=dp[i][j]*j%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[N][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint N;\nchar C[222];\nint dp[210][210];\n\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N)cin>>C[i];\n\n    dp[0][0]=1;\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            if(C[i]=='-'){\n                add(dp[i+1][j],dp[i][j]);\n            }\n            else if(C[i]=='U'){\n                add(dp[i+1][j],dp[i][j]*j%mod);\n                add(dp[i+1][j+1],dp[i][j]);\n            }\n            else{\n                if(j)add(dp[i+1][j-1],dp[i][j]*j%mod*j%mod);\n                add(dp[i+1][j],dp[i][j]*j%mod);\n            }\n        }\n    }\n\n    cout<<dp[N][0]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main(){\n    int N;\n    while(cin >> N){\n        vector<long long> dp(N+1, 0);\n        dp[0] = 1;\n        for(int i=0;i<N;i++){\n            char c; cin >> c;\n            if(c == '-') continue;\n            vector<long long> next(N+1, 0);\n            if(c == 'D'){\n                for(int i=1;i<=N;i++){\n                    next[i] += i * dp[i];\n                    next[i] %= MOD;\n                    next[i-1] += i * i * dp[i];\n                    next[i-1] %= MOD; \n                }\n            } else {\n                for(int i=0;i<N;i++){\n                    next[i] += i * dp[i];\n                    next[i] %= MOD;\n                    next[i+1] += dp[i];\n                    next[i+1] %= MOD; \n                }\n            }\n            dp = next;\n        }\n        cout << dp[0] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\n\n#define rep(i,N) for(int i=0;i<(int)(N);++i)\n#define rrep(i,N) for(int i=(int)(N)-1;i>=0;--i)\n#define debug(x) cout<<#x<<\"=\"<<x<<endl;\nconstexpr ll MOD=1000000007;\nconstexpr ll INF=1LL<<60;\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T> void fail(T v){cout << v << endl;exit(0);}\n//template end\n\nvoid solve(){\n    int N;\n    cin>>N;\n    ll dp[N+2][N+2];\n    rep(i,N+2)rep(j,N+2)dp[i][j]=0;\n    dp[0][0]=1;\n    for(int i=1;i<=N;i++){\n        char c;cin>>c;\n        rep(j,N+1){\n            if(c=='-'){\n                dp[i][j]+=dp[i-1][j];\n            }else if(c=='D'){\n                dp[i][j]+=j*dp[i-1][j];\n                dp[i][j]%=MOD;\n                dp[i][j]+=(j+1LL)*(j+1)%MOD*dp[i-1][j+1];\n                dp[i][j]%=MOD;\n            }else{\n                if(j>0)\n                    dp[i][j]+=dp[i-1][j-1];\n                dp[i][j]+=j*dp[i-1][j];\n                dp[i][j]%=MOD;\n            }\n        }\n    }\n    cout<<dp[N][0]<<endl;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\nconst int mod = 1000000007;\nll dp[11][1<<10];\n\nint main() {\n    int n;\n    string in;\n    dp[0][0] = 1;\n    cin>>n;\n    for (int i=0; i<n; ++i) {\n        cin>>in;\n        if (in == \"-\") {\n            for (int S=0; S<(1<<n); ++S) {\n                if ((1<<i)&S) continue;\n                dp[i+1][(1<<i)|S] += dp[i][S];\n                dp[i+1][(1<<i)|S] %= mod;\n            }\n        } else if (in == \"D\") {\n            for (int S=0; S<(1<<n); ++S) {\n                for (int k=0; k<i; ++k) {\n                    if ((1<<k)&S) continue;\n                    dp[i+1][(1<<k)|S] += dp[i][S];\n                    dp[i+1][(1<<k)|S] %= mod;\n                }\n            }\n        } else if (in == \"U\") {\n            for (int S=0; S<(1<<n); ++S) {\n                for (int k=i+1; k<n; ++k) {\n                    if ((1<<k)&S) continue;\n                    dp[i+1][(1<<k)|S] += dp[i][S];\n                    dp[i+1][(1<<k)|S] %= mod;\n                }\n            }\n        }\n    }\n\n    cout<<dp[n][(1<<n)-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nusing ll=long long;\nll dp[202][202];\nll n;\nchar c[200];\nconst ll MOD = 1000000007;\nint main()\n{\n\tcin >> n;\n\tfor (size_t i = 0; i < n; i++)\n\t{\n\t\tcin >> c[i];\n\t}\n\tswitch (c[0])\n\t{\n\tcase 'U':\n\t\tdp[1][0] = 0;\n\t\tdp[1][1] = 1;\n\t\tbreak;\n\tcase 'D':\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\tcase '-':\n\t\tdp[1][0] = 1;\n\t\tdp[1][1] = 0;\n\tdefault:\n\t\tbreak;\n\t}\n\tfor (size_t i = 2; i <= n; i++)\n\t{\n\t\tswitch (c[i-1])\n\t\t{\n\t\tcase '-':\n\t\t\tfor (size_t j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tfor (size_t j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tdp[i][j + 1] = dp[i - 1][j];\n\t\t\t}\n\t\t\tfor (size_t j = 1; j < i; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] += dp[i - 1][j] * j % MOD;\n\t\t\t\tdp[i][j] %= MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tfor (size_t j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = dp[i - 1][j] * j;\n\t\t\t}\n\t\t\tfor (size_t j = 1; j < i; j++)\n\t\t\t{\n\t\t\t\tdp[i][j - 1] += dp[i - 1][j] * j * j % MOD;\n\t\t\t\tdp[i][j - 1] %= MOD;\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i+1][j]+=dp[i][j]*j;\n      if(j)dp[i+1][j-1]+=dp[i][j]*j*j;\n      dp[i+1][j]%=Prime;\n      if(j)dp[i+1][j-1]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1][j+1]+=dp[i][j];\n      dp[i+1][j]+=dp[i][j]*j;\n      dp[i+1][j+1]%=Prime;\n      dp[i+1][j]%=Prime;\n    }else{\n      dp[i+1][j+1]+=dp[i][j];\n      dp[i+1][j+1]%=Prime;\n    }\n  }}\n  printf(\"%d\\n\",dp[i][0]);\n  return 0;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[202][202];\n\nint main(void){\n\n  fill(dp[0],dp[202],0);\n\n  int n;\n  cin >> n;\n\n  string c;\n\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  dp[0][0]=1;\n\n  for(int k=0;k<n;k++){\n    for(int i=0;i<=k;i++){\n      if(c[k]=='-')dp[k+1][i]+=dp[k][i];\n      else if(c[k]=='D'){\n        if(i>0){\n          dp[k+1][i-1]+=(dp[k][i]*i*i)%MOD;\n          dp[k+1][i-1]%=MOD;\n        }\n        dp[k+1][i]+=(dp[k][i]*i)%MOD;\n      }\n      else if(c[k]=='U'){\n        dp[k+1][i]+=(dp[k][i]*i)%MOD;\n        dp[k+1][i+1]+=dp[k][i]%MOD;\n        dp[k+1][i+1]%=MOD;\n      }\n      dp[k+1][i]%=MOD;\n    }\n  }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\nll MOD = 1000000007;\n\nint main() {\n    int n;\n    cin >> n;\n    char c[n+1];\n    srep(i,1,n+1) cin >> c[i];\n\n    ll dp[n+1][n+1];\n    rep(i,n+1)rep(j,n+1)dp[i][j] = 0;\n    dp[0][0] = 1;\n    srep(i,1,n+1){\n        if(c[i] == '-'){\n            rep(j,n+1) dp[i][j] = dp[i-1][j];\n        }else if(c[i] == 'U'){\n            srep(j,1,n+1){\n                dp[i][j] += dp[i-1][j-1];\n            }\n            rep(j,n+1){\n                dp[i][j] += dp[i-1][j] * j;\n            }\n            rep(j,n+1) dp[i][j] %= MOD;\n        }else if(c[i] == 'D'){\n            rep(j,n){\n                dp[i][j] += dp[i-1][j+1] * (j+1) * (j+1);\n            }\n            rep(j,n+1){\n                dp[i][j] += dp[i-1][j] * j;\n            }\n            rep(j,n+1) dp[i][j] %= MOD;\n        }\n        // rep(j,n+1) cout << dp[i][j] << ' ';\n    }\n\n\n    cout << dp[n][0] << endl;\n    return 0;\n}\n \n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\nlong long p = 1e10;\n\nlong long isprime(long long n){\n\tfor( long long i = 2 ; i * i <= n ; i++ ){\n\t\tif( n % i == 0 ) return 0;\n\t}\n\treturn 1;\n}\n\nlong long mul(long long a,long long b){\n\tif( b == 0 ) return 0;\n\tlong long c = mul((a%p+a%p)%p,b/2);\n\tif( b & 1 ) c += a;\n\treturn c % p;\n}\nlong long bpow(long long a,long long b){\n\tif( b == 0 ) return 1;\n\tlong long c = bpow(mul(a,a)%p,b/2);\n\tif( b & 1 ) c = mul(c,a);\n\treturn c % p;\n}\n\n\nint main(){\n\twhile( !isprime(p) ) p++;\n\n\tint N;\n\tcin >> N;\n\tlong long X = 0;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tlong long op,Y;\n\t\tcin >> op >> Y;\n\t\tY=(Y+p)%p;\n\t\tif( op == 1 ){ //+\n\t\t\tX = X + Y;\n\t\t\tX %= p;\n\t\t}else if( op == 2 ){ //-\n\t\t\tX = X - Y;\n\t\t\tX %= p;\n\t\t\tX = (X+p)%p;\n\t\t}else if( op == 3 ){ //*\n\t\t\tX = mul(X,Y);\n\t\t}else{ // /\n\t\t\tX = mul(X,bpow(Y,p-2));\n\t\t}\n\t\tX = (X+p) % p;\n\t}\n\tif( X < (1ll<<31) ){\n\t\tcout << X << endl;\n\t}else{\n\t\tcout << X-p << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\n#define MOD (ll)(1e9+7)\n\n#define REP(i,n) for(ll i=0;i<(n);++i)\n\n#define N_MAX 210\nll dp[N_MAX][N_MAX];\n\nint main(){\n\tll n;\n\tcin>>n;\n\tvl c(n);\n\tREP(i,n){\n\t\tchar x;\n\t\tcin>>x;\n\t\tc[i] = (x=='U'?1:(x=='D'?-1:0));\n\t}\n\t\n\tdp[0][0] = 1ll;\n\tREP(i,n)REP(u,n){\n\t\tif(c[i]==0){\n\t\t\t// no change\n\t\t\tdp[i+1][u] = dp[i][u];\n\t\t}else if(c[i]==1){\n\t\t\t// up\n\t\t\t// add\n\t\t\tdp[i+1][u+1] += dp[i][u];\n\t\t\t// swap\n\t\t\tdp[i+1][u] += dp[i][u]*u;\n\t\t}else if(c[i]==-1){\n\t\t\t// down\n\t\t\t// combinate\n\t\t\tif(u>0)\n\t\t\t\tdp[i+1][u-1] += dp[i][u]*u*u;\n\t\t\t// swap\n\t\t\tdp[i+1][u] += dp[i][u]*u;\n\t\t}\n\t\tdp[i+1][u] %= MOD;\n\t\tdp[i+1][u+1] %= MOD;\n\t\tif(u>0) dp[i+1][u-1] %= MOD;\n\t}\n\tcout << dp[n][0]%MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\n//common\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nll MOD =1000000007;\nclass Main{\npublic:\n\n\tvoid run(){\n\t\tint N;cin >> N;\n\t\tvector<char> cs(N);REP(i,N)cin >> cs[i];\n\n\t\tvector<vector<ll>> dp(N+1,vector<ll>(N+1));\n\t\t//dp[n][x] ... [0,n) でx個のペアを確定する組合せ\n\t\tdp[0][0]=1;\n\t\tfor(int n=1;n<=N;n++){\n\t\t\tfor(int x=0;x<=n;x++){\n\t\t\t\tif(cs[n-1]=='-'){\n\t\t\t\t\tif(IN(0,x-1,N+1))dp[n][x]=dp[n-1][x-1],dp[n][x]%=MOD;\n\t\t\t\t}else if(cs[n-1]=='U'){\n\t\t\t\t\tdp[n][x]+=dp[n-1][x],dp[n][x]%=MOD;\n\t\t\t\t\tif(IN(0,x-1,N+1))dp[n][x]+=dp[n-1][x-1]*((n-1)-(x-1)),dp[n][x]%=MOD;\n\t\t\t\t}else if(cs[n-1]=='D'){\n\t\t\t\t\tif(IN(0,x-1,N+1))dp[n][x]+=dp[n-1][x-1]*((n-1)-(x-1)),dp[n][x]%=MOD;\n\t\t\t\t\tif(IN(0,x-2,N+1))dp[n][x]+=dp[n-1][x-2]*((n-1)-(x-2))*((n-1)-(x-2)),dp[n][x]%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[N][N] <<endl;\n\t}\n};\n\n int main(){\nios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\n#define rep2(i,a,b) for (ll i=(a);i<(b);++i)\n#define debug(x) cout << #x << '=' << x << endl\n#define all(v) (v).begin(),(v).end()\nconst ll MOD=1e9+7;\n//const ll MOD=998244353;\nconst ll INF=1e9;\nconst ll IINF=1e18;\nconst double EPS=1e-8;\nconst double pi=acos(-1);\n\ntemplate<class T> inline bool chmin(T &a,T b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T> inline bool chmax(T &a,T b){\n    if (a<b){a=b; return true;} return false;\n}\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept {\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept {\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    vector<char> rank(n);\n    for (int i=0;i<n;++i) cin >> rank[i];\n    vector<vector<mint>> dp(n+1,vector<mint>(n+1,0));\n    dp[0][0]=1;\n    for (int i=0;i<n;++i){\n        for (int j=0;j<n+1;++j){\n            if (rank[i]=='D'){\n                dp[i+1][j]+=dp[i][j]*j;\n                dp[i+1][j-1]+=dp[i][j]*j*j;\n            }\n            if (rank[i]=='U'){\n                dp[i+1][j+1]+=dp[i][j];\n                dp[i+1][j]+=dp[i][j]*j;\n            }\n            if (rank[i]=='-') dp[i+1][j]+=dp[i][j];\n        }\n    }\n    cout << dp[n][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nconst long long int MOD = 1000000007LL;\nlong long int dp[210][210];\nint main() {\n  int N; cin >> N;\n\n  dp[0][0] = 1;\n  for(int i=0; i<N; i++) {\n    char c; cin >> c;\n    for(int j=0; j<=i+1; j++) { \n      if(c == '-') {\n        dp[i+1][j] = dp[i][j];\n      }\n      else {\n        /*\n        if(c == 'D') {\n          (dp[i+1][j] += dp[i][j] * j) %= MOD;\n        }\n        else {\n          dp[i+1][j] = 1;\n        }\n\n        int is_u = (c == 'U');\n        long long int add = 0;\n        (add += dp[i][j     - is_u]) %= MOD;\n        (add += dp[i][j + 1 - is_u] * (j + 1 - is_u)) %= MOD;\n\n\n        printf(\"i = %d, j = %d, c = %c, add = %lld\\n\", i, j, c, add);\n        (dp[i+1][j] *= add) %= MOD;\n        */\n\n        if(c == 'U') {\n          if(j > 0) (dp[i+1][j] += dp[i][j-1]) %= MOD;\n          (dp[i+1][j] += dp[i][j] * j) %= MOD;\n        }\n        else {\n          (dp[i+1][j] += dp[i][j] * j) %= MOD;\n          (dp[i+1][j] += dp[i][j+1] * (j+1) * (j+1)) %= MOD;\n        }\n      }\n    }\n  }\n\n  /*\n  for(int i=1; i<=N; i++) {\n    for(int j=0; j<=N; j++) {\n      cout << dp[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  */\n  \n  cout << dp[N][0] << endl;\n  return 0;\n}\n\n/*\n5\nU\nU\n-\nD\nD\n1 0 0 0 0 0 \n1 0 0 0 0 0 \n1 0 0 0 0 0 \n0 1 0 0 0 0 \n0 2 1 0 0 0 \n0\n\n3\n-\nU\nD\n1 0 0 0 \n1 0 0 0 \n0 1 0 0 \n0\n\n*/\n\n/*\n\n8\nU\nD\nD\nD\nD\nD\nD\nD\ni = 0, j = 0, c = U, add = 0\ni = 0, j = 1, c = U, add = 1\ni = 1, j = 0, c = D, add = 1\ni = 1, j = 1, c = D, add = 1\ni = 1, j = 2, c = D, add = 0\ni = 2, j = 0, c = D, add = 1\ni = 2, j = 1, c = D, add = 1\ni = 2, j = 2, c = D, add = 0\ni = 2, j = 3, c = D, add = 0\ni = 3, j = 0, c = D, add = 1\ni = 3, j = 1, c = D, add = 1\ni = 3, j = 2, c = D, add = 0\ni = 3, j = 3, c = D, add = 0\ni = 3, j = 4, c = D, add = 0\ni = 4, j = 0, c = D, add = 1\ni = 4, j = 1, c = D, add = 1\ni = 4, j = 2, c = D, add = 0\ni = 4, j = 3, c = D, add = 0\ni = 4, j = 4, c = D, add = 0\ni = 4, j = 5, c = D, add = 0\ni = 5, j = 0, c = D, add = 1\ni = 5, j = 1, c = D, add = 1\ni = 5, j = 2, c = D, add = 0\ni = 5, j = 3, c = D, add = 0\ni = 5, j = 4, c = D, add = 0\ni = 5, j = 5, c = D, add = 0\ni = 5, j = 6, c = D, add = 0\ni = 6, j = 0, c = D, add = 1\ni = 6, j = 1, c = D, add = 1\ni = 6, j = 2, c = D, add = 0\ni = 6, j = 3, c = D, add = 0\ni = 6, j = 4, c = D, add = 0\ni = 6, j = 5, c = D, add = 0\ni = 6, j = 6, c = D, add = 0\ni = 6, j = 7, c = D, add = 0\ni = 7, j = 0, c = D, add = 1\ni = 7, j = 1, c = D, add = 1\ni = 7, j = 2, c = D, add = 0\ni = 7, j = 3, c = D, add = 0\ni = 7, j = 4, c = D, add = 0\ni = 7, j = 5, c = D, add = 0\ni = 7, j = 6, c = D, add = 0\ni = 7, j = 7, c = D, add = 0\ni = 7, j = 8, c = D, add = 0\n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 0 \n0\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\n#define MOD 1000000007LL\n\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[201][201];\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  string c;\n\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  dp[0][0]=1;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=i;j++){\n      if(c[i]=='U'){\n        dp[i+1][j]+=dp[i][j]*j;\n        dp[i+1][j+1]+=dp[i][j];\n        dp[i+1][j]%=MOD;\n        dp[i+1][j+1]%=MOD;\n      }\n      else if(c[i]=='D'){\n        if(j-1>=0)dp[i+1][j-1]+=dp[i][j]*j*j;\n        dp[i+1][j]+=dp[i][j]*j;\n        dp[i+1][j]%=MOD;\n        if(j-1>=0)dp[i+1][j-1]%=MOD;\n      }\n      else if(c[i]=='-'){\n        dp[i+1][j]=dp[i][j];\n        dp[i+1][j]%=MOD;\n      }\n    }\n  }\n  cout << dp[n][0] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define int LL\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef int pqt;\ntypedef vector<pqt> Vpqt;\nconst int INF=1<<30;\nconst int SIZE=201;\nconst LL p=7+1e9;\ntypedef priority_queue<pqt,Vpqt,greater<Vpqt> > PQ;\nint arrays[SIZE];\nint DP[SIZE][SIZE][SIZE];\nint solve(int n,int a,int b){\n\tint ans=1;\n\tif(arrays[n]==1) {ans*=a;a--;}\n\tif(a<0 || b<0) return 0;\n\tif(arrays[n]==-1) b++;\n\tif(n==0) return a==0 && b==0;\n\tif(DP[n][a][b]!=-1) return DP[n][a][b];\n\n\tif(arrays[n]==0) return DP[n][a][b]=solve(n-1,a,b)%p;\n\telse if(arrays[n]==-1) DP[n][a][b]=ans*((b-1)*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n\telse return DP[n][a][b]=ans*(b*solve(n-1,a,b-1)+solve(n-1,a+1,b))%p;\n}\nsigned main() {\n\tint n;\n\tstring s;\n\tcin >> n;\n\tREP(i,SIZE) REP(j,SIZE) REP(k,SIZE) DP[i][j][k]=-1;\n\tFOR(i,1,n+1){\n\t\tcin >> s;\n\t\tif(s==\"U\") arrays[i]=1;\n\t\telse if(s==\"D\") arrays[i]=-1;\n\t\telse arrays[i]=0;\n\t}\n\tcout << solve(n,0,0) << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nconst int MOD = 1000000007;\n\nlong long dp[250][250];\nint n;\nchar c[250];\n\nint main() {\n    while (cin >> n) {\n        for (int i = 0; i < n; ++i) cin >> c[i];\n        \n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = 1;\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= i; ++j) {\n                \n                if (c[i] == '-') {\n                    (dp[i+1][j+1] += dp[i][j]) %= MOD;\n                }\n                else if (c[i] == 'U') {\n                    (dp[i+1][j] += dp[i][j]) %= MOD;\n                    (dp[i+1][j+1] += dp[i][j] * (i-j)) %= MOD;\n                }\n                else if (c[i] == 'D') {\n                    (dp[i+1][j+1] += dp[i][j] * (i-j)) %= MOD;\n                    (dp[i+1][j+2] += dp[i][j] * (i-j) * (i-j)) %= MOD;\n                }\n            }\n        }\n        \n        cout << dp[n][n] << endl;\n    }\n    \n    return 0;\n}\n\n\n\n\n                \n                \n                \n                \n                \n                \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n;\n\nint main(){\n\tcin>>n;\n\tvl dp(n,0);\n\tdp[0]++;\n\tint t=0;\n\tfor(int i=0;i<n;i++){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif(c=='-') continue;\n\t\tvl DP(n);\n\t\tif(c=='U'){\n\t\t\tfor(int j=0;j<n;j++) if(dp[j]){\n\t\t\t\t(DP[j]+=dp[j]*j)%=mod;\n\t\t\t\tif(j+1<n) (DP[j+1]+=dp[j]*(t-j+1))%=mod;\n\t\t\t}\n\t\t\tt++;\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<n;j++) if(dp[j]){\n\t\t\t\t(DP[j]+=dp[j]*(t-j))%=mod;\n\t\t\t\tif(j) (DP[j-1]+=dp[j]*j)%=mod;\n\t\t\t}\n\t\t}\n\t\tdp=DP;\n\t}\n\tcout<<dp[0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nstatic const int MOD = 1000000007;\n\nint main() {\n\n  // Get input data\n  int numTeam;\n  std::cin >> numTeam;\n  std::vector<char> orderChange(numTeam + 1);\n  for (int i = 1; i <= numTeam; ++i) {\n    char c;\n    std::cin >> c;\n    orderChange[i] = c;\n    assert(c == 'D' or c == 'U' or c == '-');\n  }\n\n  // Init\n  std::vector<std::vector<long long>> dp(numTeam + 1);\n  for (int i = 0; i <= numTeam; ++i)\n    dp[i].assign(numTeam + 2, 0);\n  dp[0][0] = 1;\n\n  // Main\n  for (int i = 0; i < numTeam; ++i) {\n    for (int j = 0; j <= i; ++j) {\n      switch (orderChange[i + 1]) {\n      case 'D':\n        dp[i + 1][j + 1] += dp[i][j] * (i - j);\n        dp[i + 1][j + 1] %= MOD;\n        dp[i + 1][j + 2] += dp[i][j] * (i - j) * (i - j);\n        dp[i + 1][j + 2] %= MOD;\n        break;\n      case '-':\n        dp[i + 1][j + 1] += dp[i][j];\n        dp[i + 1][j + 1] %= MOD;\n        break;\n      case 'U':\n        dp[i + 1][j] += dp[i][j];\n        dp[i + 1][j] %= MOD;\n        dp[i + 1][j + 1] += dp[i][j] * (i - j);\n        dp[i + 1][j + 1] %= MOD;\n        break;\n      default:\n        assert(false);\n      }\n    }\n  }\n\n  // Output\n  std::cout << dp[numTeam][numTeam] << std::endl;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\n  char c[202];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\nfor(j=0;j<n+1;j++){\n    if(c[i]=='D'){\n      dp[i+1][j]+=dp[i][j]*j;\n      if(j)dp[i+1][j-1]+=dp[i][j]*i*j;\n      dp[i+1][j]%=Prime;\n      if(j)dp[i+1][j-1]%=Prime;\n    }else if(c=='U'){\n      dp[i+1][j+1]+=dp[i][j];\n      dp[i+1][j]+=dp[i][j]*j;\n      dp[i+1][j+1]%=Prime;\n      dp[i+1][j]%=Prime;\n    }\n  }\n  printf(\"%d\\n\",dp[i][0]);\n  return 0;}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef long long ll;\n\n#define MOD 1000000007\n#define MAX_N 200\n\nll dp[MAX_N][MAX_N+1] = {0}; // dp[n][rest U] = ??´????????°\n\nint main() {\n\tint N;\n\tchar c[MAX_N];\n\tchar buf[100];\n\tint sz = 0;\n\tll ans = -1;\n\tint i, j;\n\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; ++i) {\n\t\tscanf(\"%s\", buf);\n\t\tif (buf[0] != '-') c[sz++] = buf[0];\n\t}\n\tN = sz;\n\n\tif (N == 0) {\n\t\tans = 1;\n\t}\n\telse if (c[0] == 'D') {\n\t\tans = 0;\n\t}\n\telse {\n\t\tdp[0][1] = 1; // c[0] : 'U'\n\t\tfor (i = 0; i < N-1; ++i) {\n\t\t\tfor (j = 0; j < N; ++j) {\n\t\t\t\tif (c[i+1] == 'U') {\n\t\t\t\t\tdp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % MOD;\n\t\t\t\t\tif (j >= 1) {\n\t\t\t\t\t\tdp[i+1][j] = (dp[i+1][j] + j * dp[i][j]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { // D\n\t\t\t\t\tif (j >= 1) {\n\t\t\t\t\t\tdp[i+1][j] = (dp[i+1][j] + j * dp[i][j]) % MOD;\n\t\t\t\t\t\tdp[i+1][j-1] = (dp[i+1][j-1] + j * j * dp[i][j]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = dp[N-1][0];\n\t}\t\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\nint cnt;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\ncnt=0;\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i-cnt+1][j-cnt]+=dp[i-cnt][j-cnt]*(j-cnt);\n      if(j)dp[i+1-cnt][j-1-cnt]+=dp[i-cnt][j-cnt]*(j-cnt)*(j-cnt);\n      dp[i+1-cnt][j-cnt]%=Prime;\n      if(j)dp[i+1-cnt][j-1-cnt]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1-cnt][j+1-cnt]+=dp[i-cnt][j-cnt];\n      dp[i+1-cnt][j-cnt]+=dp[i-cnt][j-cnt]*(j-cnt);\n      dp[i+1-cnt][j+1-cnt]%=Prime;\n      dp[i+1-cnt][j-cnt]%=Prime;\n    }else{\n      cnt++;\n    }\n  }}\n  printf(\"%lld\\n\",dp[i-cnt][0]);\n  return 0;}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\nint cnt;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\ncnt=0;\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i-cnt+1][j-cnt]+=dp[i-cnt][j-cnt]*(j-cnt);\n      if(j)dp[i+1-cnt][j-1-cnt]+=dp[i-cnt][j-cnt]*(j-cnt)*(j-cnt);\n      dp[i+1-cnt][j-cnt]%=Prime;\n      if(j)dp[i+1-cnt][j-1-cnt]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1-cnt][j+1-cnt]+=dp[i-cnt][j-cnt];\n      dp[i+1-cnt][j-cnt]+=dp[i-cnt][j-cnt]*(j-cnt);\n      dp[i+1-cnt][j+1-cnt]%=Prime;\n      dp[i+1-cnt][j-cnt]%=Prime;\n    }else{\n      cnt++;\n    }\n  }}\n  printf(\"%lld\\n\",dp[i-cnt-1][0]);\n  return 0;}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\n  char c;\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  while(n--){\n    scanf(\"%c\",&c);\n    if(c=='D'){\n      dp[i+1][j]+=dp[i][j]*j;\n      dp[i+1][j-1]+=dp[i][j]*i*j;\n      dp[i+1][j]%=Prime;\n      dp[i+1][j-1]%=Prime;\n    }else if(c=='U'){\n      dp[i+1][j+1]+=dp[i][j];\n      dp[i+1][j]+=dp[i][j]*j;\n      dp[i+1][j+1]%=Prime;\n      dp[i+1][j]%=Prime;\n    }\n  }\n  printf(\"%d\\n\",dp[i][j]);\n  return 0;}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\nint cnt;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\ncnt=0;\nfor(i=0;i<n;i++){\nif(c[i][0]=='-')cnt++;\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i+1][j-cnt]+=dp[i][j-cnt]*(j-cnt);\n      if(j)dp[i+1][j-1-cnt]+=dp[i][j-cnt]*(j-cnt)*(j-cnt);\n      dp[i+1][j-cnt]%=Prime;\n      if(j)dp[i+1][j-1-cnt]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1][j+1-cnt]+=dp[i][j-cnt];\n      dp[i+1][j-cnt]+=dp[i][j-cnt]*(j-cnt);\n      dp[i+1][j+1-cnt]%=Prime;\n      dp[i+1][j-cnt]%=Prime;\n    }\n  }}\n  printf(\"%lld\\n\",dp[i][0]);\n  return 0;}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\nint cnt;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\ncnt=0;\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i-cnt+1][j-cnt]+=dp[i-cnt][j-cnt]*(j-cnt);\n      if(j)dp[i+1-cnt][j-1-cnt]+=dp[i-cnt][j-cnt]*(j-cnt)*(j-cnt);\n      dp[i+1-cnt][j-cnt]%=Prime;\n      if(j)dp[i+1-cnt][j-1-cnt]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1-cnt][j+1-cnt]+=dp[i-cnt][j-cnt];\n      dp[i+1-cnt][j-cnt]+=dp[i-cnt][j-cnt]*(j-cnt);\n      dp[i+1-cnt][j+1-cnt]%=Prime;\n      dp[i+1-cnt][j-cnt]%=Prime;\n    }else{\n      cnt++;\n    }\n  }}\n  printf(\"%d\\n\",dp[i-cnt][0]);\n  return 0;}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i+1][j]+=dp[i][j]*j;\n      if(j)dp[i+1][j-1]+=dp[i][j]*j*j;\n      dp[i+1][j]%=Prime;\n      if(j)dp[i+1][j-1]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1][j+1]+=dp[i][j];\n      dp[i+1][j]+=dp[i][j]*j;\n      dp[i+1][j+1]%=Prime;\n      dp[i+1][j]%=Prime;\n    }\n  }}\n  printf(\"%d\\n\",dp[i][0]);\n  return 0;}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i+1][j]+=dp[i][j]*j;\n      if(j)dp[i+1][j-1]+=dp[i][j]*i*j;\n      dp[i+1][j]%=Prime;\n      if(j)dp[i+1][j-1]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1][j+1]+=dp[i][j];\n      dp[i+1][j]+=dp[i][j]*j;\n      dp[i+1][j+1]%=Prime;\n      dp[i+1][j]%=Prime;\n    }\n  }}\n  printf(\"%d\\n\",dp[i][0]);\n  return 0;}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\nint cnt;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\ncnt=0;\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i-cnt+1][j-cnt]+=dp[i-cnt][j-cnt]*(j-cnt);\n      if(j)dp[i+1-cnt][j-1-cnt]+=dp[i-cnt][j-cnt]*(j-cnt)*(j-cnt);\n      dp[i+1-cnt][j-cnt]%=Prime;\n      if(j)dp[i+1-cnt][j-1-cnt]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1-cnt][j+1-cnt]+=dp[i-cnt][j-cnt];\n      dp[i+1-cnt][j-cnt]+=dp[i-cnt][j-cnt]*(j-cnt);\n      dp[i+1-cnt][j+1-cnt]%=Prime;\n      dp[i+1-cnt][j-cnt]%=Prime;\n    }else{\n      cnt++;\n    }\n  }}\n  printf(\"%lld\\n\",dp[i-cnt-2][0]);\n  return 0;}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\nint cnt;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\ncnt=0;\nfor(i=0;i<n;i++){\nif(c[i][0]=='-')cnt++;\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i-cnt+1][j-cnt]+=dp[i-cnt][j-cnt]*(j-cnt);\n      if(j)dp[i+1-cnt][j-1-cnt]+=dp[i-cnt][j-cnt]*(j-cnt)*(j-cnt);\n      dp[i+1-cnt][j-cnt]%=Prime;\n      if(j)dp[i+1-cnt][j-1-cnt]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1-cnt][j+1-cnt]+=dp[i-cnt][j-cnt];\n      dp[i+1-cnt][j-cnt]+=dp[i-cnt][j-cnt]*(j-cnt);\n      dp[i+1-cnt][j+1-cnt]%=Prime;\n      dp[i+1-cnt][j-cnt]%=Prime;\n    }\n  }}\n  printf(\"%lld\\n\",dp[i-cnt][0]);\n  return 0;}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\nfor(j=0;j<n+1;j++){\n    if(c[i][0]=='D'){\n      dp[i+1][j]+=dp[i][j]*j;\n      if(j)dp[i+1][j-1]+=dp[i][j]*i*j;\n      dp[i+1][j]%=Prime;\n      if(j)dp[i+1][j-1]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1][j+1]+=dp[i][j];\n      dp[i+1][j]+=dp[i][j]*j;\n      dp[i+1][j+1]%=Prime;\n      dp[i+1][j]%=Prime;\n    }\n  }\n  printf(\"%d\\n\",dp[i][0]);\n  return 0;}"
  },
  {
    "language": "C",
    "code": "// AOJ 2439: Hakone\n// 2017.11.26 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define M 1000000007\nchar c[202];\nlong long dp[202][202];\n\nint main()\n{\n\tint n, m, i, j;\n\tchar buf[5];\n\n\tscanf(\"%d\", &n);\n\tfor (m = 0, i = 0; i < n; i++) {\n\t\tscanf(\"%s\", buf);\n\t\tif (*buf != '-') c[m++] = *buf;\n\t}\n\t\n\tdp[0][0] = 1;\n\tfor (i = 0; i < m; i++) for (j = 0; j <= i; j++) {\n\t\tif (c[i] == 'U') {\n\t\t\tdp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]    ) % M;\n\t\t\tdp[i+1][j]   = (dp[i+1][j]   + dp[i][j] * j) % M;\n\t\t} else {\n\t\t\tdp[i+1][j]   = (dp[i+1][j]   + dp[i][j] * j) % M;\n\t if (j) dp[i+1][j-1] = (dp[i+1][j-1] + dp[i][j]*j*j) % M;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[m][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define Prime 1000000007\nint main(void){\n  int n,i,j;\n  char c[202][20];\n  long long dp[202][202]={{1}};\n  \n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++)\n    scanf(\"%s\",&c[i]);\nfor(i=0;i<n;i++){\nfor(j=0;j<i+1;j++){\n    if(c[i][0]=='D'){\n      dp[i+1][j]+=dp[i][j]*j;\n      if(j)dp[i+1][j-1]+=dp[i][j]*j*j;\n      dp[i+1][j]%=Prime;\n      if(j)dp[i+1][j-1]%=Prime;\n    }else if(c[i][0]=='U'){\n      dp[i+1][j+1]+=dp[i][j];\n      dp[i+1][j]+=dp[i][j]*j;\n      dp[i+1][j+1]%=Prime;\n      dp[i+1][j]%=Prime;\n    }\n  }}\n  printf(\"%d\\n\",dp[i][0]);\n  return 0;}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final int MOD = 1000000007;\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tlong[][] dp = new long[N + 1][N + 1];\n\t\tdp[0][0] = 1;\n\t\tint idx = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchar v = sc.next().charAt(0);\n\t\t\tif (v == '-') continue;\n\t\t\t++idx;\n\t\t\tif (v == 'D') {\n\t\t\t\tfor (int j = 0; j < idx; ++j) {\n\t\t\t\t\tdp[idx][j] += dp[idx - 1][j] * j % MOD;\n\t\t\t\t\tif (j > 0) dp[idx][j - 1] += dp[idx - 1][j] * j * j % MOD;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int j = 0; j < idx; ++j) {\n\t\t\t\t\tdp[idx][j + 1] += dp[idx - 1][j];\n\t\t\t\t\tdp[idx][j] += dp[idx - 1][j] * j % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[idx][0] % MOD);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final int MOD = 1000000007;\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tlong[][][] dp = new long[N + 1][N + 1][N + 1];\n\t\tdp[0][0][0] = 1;\n\t\tint idx = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchar v = sc.next().charAt(0);\n\t\t\tif (v == '-') continue;\n\t\t\t++idx;\n\t\t\tif (v == 'D') {\n\t\t\t\tfor (int j = 0; j < idx; ++j) {\n\t\t\t\t\tfor (int k = 1; k < idx; ++k) {\n\t\t\t\t\t\tdp[idx][j][k] += dp[idx - 1][j][k] * j;\n\t\t\t\t\t\tif (j > 0) dp[idx][j - 1][k - 1] += dp[idx - 1][j][k] * j * k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int j = 0; j < idx; ++j) {\n\t\t\t\t\tfor (int k = 0; k < idx; ++k) {\n\t\t\t\t\t\tdp[idx][j + 1][k + 1] += dp[idx - 1][j][k];\n\t\t\t\t\t\tdp[idx][j][k] += dp[idx - 1][j][k] * j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < idx; ++j) {\n\t\t\t\tfor (int k = 0; k < idx; ++k) {\n\t\t\t\t\tdp[idx][j][k] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[idx][0][0]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final int MOD = 1000000007;\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tlong[][] dp = new long[2][N + 1];\n\t\tdp[0][0] = 1;\n\t\tint t = 1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchar v = sc.next().charAt(0);\n\t\t\tif (v == '-') continue;\n\t\t\tArrays.fill(dp[t], 0);\n\t\t\tif (v == 'D') {\n\t\t\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\t\t\tdp[t][j] += dp[1 - t][j] * j % MOD;\n\t\t\t\t\tdp[t][j - 1] += dp[1 - t][j] * j * j % MOD;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\t\tdp[t][j + 1] += dp[1 - t][j];\n\t\t\t\t\tdp[t][j] += dp[1 - t][j] * j % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = 1 - t;\n\t\t}\n\t\tSystem.out.println(dp[1 - t][0] % MOD);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic long mod = 1000000007;\n\tstatic int INF = 1000000000;\n \tpublic static void main(String[] args){\n\t\tFastScanner scanner = new FastScanner();\n\t\tint n = scanner.nextInt();\n\t\tString[] s = new String[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ts[i] = scanner.next();\n\t\t}\n\t\tlong[][] dp = new long[210][210];\n\t\tdp[0][0] = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(s[i].equals(\"-\")){\n\t\t\t\t\tdp[i+1][j+1] += dp[i][j];\n\t\t\t\t\tdp[i+1][j+1] %= mod;\n\t\t\t\t}else if(s[i].equals(\"U\")){\n\t\t\t\t\tdp[i+1][j+1] += dp[i][j]*(i-j);\n\t\t\t\t\tdp[i+1][j+1] %= mod;\n\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\tdp[i+1][j] %= mod;\n\t\t\t\t}else if(s[i].equals(\"D\")){\n\t\t\t\t\tdp[i+1][j+2] += dp[i][j]*(i-j)*(i-j);\n\t\t\t\t\tdp[i+1][j+1] += dp[i][j]*(i-j);\n\t\t\t\t\tdp[i+1][j+2] %= mod;\n\t\t\t\t\tdp[i+1][j+1] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[n][n]);\n\t}\n\tstatic class BIT{\n\t\tint n;\n\t\tint[] bit;\n\t\tpublic BIT(int n){\n\t\t\tthis.n = n;\n\t\t\tbit = new int[n+1];\n\t\t}\n\t\tvoid add(int idx, int val){\n\t\t\tfor(int i = idx+1; i <= n; i += i&(-i)) bit[i-1] += val;\n\t\t}\n\t\tint sum(int idx){\n\t\t\tint res = 0;\n\t\t\tfor(int i = idx+1; i > 0; i -= i&(-i)) res += bit[i-1];\n\t\t\treturn res;\n\t\t}\n\t\tint sum(int begin, int end){\n\t\t\tif(begin == 0) return sum(end);\n\t\t\treturn sum(end)-sum(begin-1);\n\t\t}\n\t}\n\tstatic class Edge{\n\t\tint to;\n\t\tEdge(int to){\n\t\t\tthis.to = to;\n\t\t}\n\t}\n\tstatic class Pair implements Comparable<Pair>{\n    int first, second;\n    Pair(int a, int b){\n        first = a;\n        second = b;\n    }\n    @Override\n    public boolean equals(Object o){\n        if (this == o) return true;\n        if (!(o instanceof Pair)) return false;\n        Pair p = (Pair) o;\n        return first == p.first && second == p.second;\n    }\n    @Override\n    public int compareTo(Pair p){\n        return first == p.first ? second - p.second : first - p.first; //firstで昇順にソート\n        //return (first == p.first ? second - p.second : first - p.first) * -1; //firstで降順にソート\n        //return second == p.second ? first - p.first : second - p.second;//secondで昇順にソート\n        //return (second == p.second ? first - p.first : second - p.second)*-1;//secondで降順にソート\n\t\t    //return first * 1.0 / second > p.first * 1.0 / p.second ? 1 : -1; // first/secondの昇順にソート\n\t\t    //return first * 1.0 / second < p.first * 1.0 / p.second ? 1 : -1; // first/secondの降順にソート\n\t\t\t\t//return second * 1.0 / first > p.second * 1.0 / p.first ? 1 : -1; // second/firstの昇順にソート\n\t\t    //return second * 1.0 / first < p.second * 1.0 / p.first ? 1 : -1; // second/firstの降順にソート\n\t\t\t\t//return Math.atan2(second, first) > Math.atan2(p.second, p.first) ? 1 : -1; // second/firstの昇順にソート\n\t\t\t\t//return first + second > p.first + p.second ? 1 : -1; //first+secondの昇順にソート\n\t\t\t\t//return first + second < p.first + p.second ? 1 : -1; //first+secondの降順にソート\n\t\t\t\t//return first - second < p.first - p.second ? 1 : -1; //first-secondの降順にソート\n\t\t}\n  }\n\n\tprivate static class FastScanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\t\tif (ptr < buflen) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t}else{\n\t\t\t\t\t\tptr = 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t}\n\t\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\t\tpublic String next() {\n\t\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tint b = readByte();\n\t\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\t\t\tb = readByte();\n\t\t\t\t}\n\t\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\t\tlong n = 0;\n\t\t\t\tboolean minus = false;\n\t\t\t\tint b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\t\tminus = true;\n\t\t\t\t\t\tb = readByte();\n\t\t\t\t}\n\t\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\t\t\t\tn *= 10;\n\t\t\t\t\t\t\t\tn += b - '0';\n\t\t\t\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb = readByte();\n\t\t\t\t}\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\t\tlong nl = nextLong();\n\t\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\t\t\treturn (int) nl;\n\t\t}\n\t\tpublic double nextDouble() { return Double.parseDouble(next());}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\trun();\n\t}\n\n\tstatic void run() {\n\t\tnew Main().solver();\n\t}\n\n\tlong MOD = 1_000_000_000 + 7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] c = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString s = sc.next();\n\t\t\tif (s.charAt(0) == 'U')\n\t\t\t\tc[i] = 1;\n\t\t\telse if (s.charAt(0) == 'D')\n\t\t\t\tc[i] = -1;\n\t\t\telse if (s.charAt(0) == '-')\n\t\t\t\tc[i] = 0;\n\t\t}\n\t\tc = reduce(c);\n\n\t\ttr(c);\n\n\t\tn = c.length;\n\t\tlong[][] dp = new long[n + 1][n];\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (c[i] == 'D') {\n\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\tdp[i + 1][j] += j * dp[i][j];\n\t\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t\t}\n\t\t\t} else if (c[i] == 'U') {\n\t\t\t\tfor (int j = 0; j <= i + 1; j++) {\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\tdp[i + 1][j] += j * dp[i][j];\n\t\t\t\t\tdp[i + 1][j + 1] %= MOD;\n\t\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[n][0]);\n\t}\n\n\tint[] reduce(int[] c) {\n\t\tint len = 0;\n\t\tfor (int i = 0; i < c.length; i++) {\n\t\t\tif (c[i] != 0)\n\t\t\t\tlen++;\n\t\t}\n\t\tint[] ret = new int[len];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < c.length; i++) {\n\t\t\tif (c[i] != 0) {\n\t\t\t\tret[count++] = c[i];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final int MOD = 1000000007;\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tlong[][] dp = new long[N + 1][N + 1];\n\t\tdp[0][0] = 1;\n\t\tint idx = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchar v = sc.next().charAt(0);\n\t\t\tif (v == '-') continue;\n\t\t\t++idx;\n\t\t\tif (v == 'D') {\n\t\t\t\tfor (int j = 0; j < idx; ++j) {\n\t\t\t\t\tdp[idx][j] += dp[idx - 1][j] * j % MOD;\n\t\t\t\t\tif (j > 0) dp[idx][j - 1] += dp[idx - 1][j] * j * j % MOD;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int j = 0; j < idx; ++j) {\n\t\t\t\t\tdp[idx][j + 1] += dp[idx - 1][j];\n\t\t\t\t\tdp[idx][j] += dp[idx - 1][j] * j % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(Arrays.toString(dp[idx]));\n\t\tSystem.out.println(dp[idx][0] % MOD);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\trun();\n\t}\n\n\tstatic void run() {\n\t\tnew Main().solver();\n\t}\n\n\tlong MOD = 1_000_000_000 + 7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] c = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString s = sc.next();\n\t\t\tif (s.charAt(0) == 'U')\n\t\t\t\tc[i] = 1;\n\t\t\telse if (s.charAt(0) == 'D')\n\t\t\t\tc[i] = -1;\n\t\t\telse if (s.charAt(0) == '-')\n\t\t\t\tc[i] = 0;\n\t\t}\n\t\tc = reduce(c);\n\t\tn = c.length;\n\t\tlong[][] dp = new long[n + 1][n + 1];\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (c[i] == -1) {// D\n\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\tif (j >= 1) {\n\t\t\t\t\t\tdp[i + 1][j - 1] += j * j * dp[i][j];\n\t\t\t\t\t\tdp[i + 1][j - 1] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][j] += j * dp[i][j];\n\t\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t\t}\n\t\t\t} else if (c[i] == 1) {// U\n\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\tdp[i + 1][j] += j * dp[i][j];\n\t\t\t\t\tdp[i + 1][j + 1] %= MOD;\n\t\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[n][0]);\n\t}\n\n\tint[] reduce(int[] c) {\n\t\tint len = 0;\n\t\tfor (int i = 0; i < c.length; i++) {\n\t\t\tif (c[i] != 0)\n\t\t\t\tlen++;\n\t\t}\n\t\tint[] ret = new int[len];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < c.length; i++) {\n\t\t\tif (c[i] != 0) {\n\t\t\t\tret[count++] = c[i];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\trun();\n\t}\n\n\tstatic void run() {\n\t\tnew Main().solver();\n\t}\n\n\tlong MOD = 1_000_000_000 + 7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] c = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString s = sc.next();\n\t\t\tif (s.charAt(0) == 'U')\n\t\t\t\tc[i] = 1;\n\t\t\telse if (s.charAt(0) == 'D')\n\t\t\t\tc[i] = -1;\n\t\t\telse if (s.charAt(0) == '-')\n\t\t\t\tc[i] = 0;\n\t\t}\n\t\tc = reduce(c);\n\t\tn = c.length;\n\t\tlong[][] dp = new long[n + 1][n + 1];\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (c[i] == -1) {// D\n\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\tif (j >= 1) {\n\t\t\t\t\t\tdp[i + 1][j - 1] += j * j * dp[i][j];\n\t\t\t\t\t\tdp[i + 1][j - 1] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][j] += j * dp[i][j];\n\t\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t\t}\n\t\t\t} else if (c[i] == 1) {// U\n\t\t\t\tfor (int j = 0; j <= i + 1; j++) {\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\tdp[i + 1][j] += j * dp[i][j];\n\t\t\t\t\tdp[i + 1][j + 1] %= MOD;\n\t\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[n][0]);\n\t}\n\n\tint[] reduce(int[] c) {\n\t\tint len = 0;\n\t\tfor (int i = 0; i < c.length; i++) {\n\t\t\tif (c[i] != 0)\n\t\t\t\tlen++;\n\t\t}\n\t\tint[] ret = new int[len];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < c.length; i++) {\n\t\t\tif (c[i] != 0) {\n\t\t\t\tret[count++] = c[i];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.function.BiFunction;\n\npublic class Main{\n\tstatic Scanner scn = new Scanner(System.in);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic PrintWriter ot = new PrintWriter(System.out);\n\tstatic Random rand = new Random();\n\tstatic int mod = 1000000007;\n\tstatic long modmod = (long)mod * mod;\n\tstatic long inf = (long)1e17;\n\tstatic int[] dx = {0,1,0,-1};\n\tstatic int[] dy = {1,0,-1,0};\n\tstatic int[] dx8 = {-1,-1,-1,0,0,1,1,1};\n\tstatic int[] dy8 = {-1,0,1,-1,1,-1,0,1};\n\tstatic char[] dc = {'R','D','L','U'};\n\tstatic BiFunction<Integer,Integer,Integer> fmax = (a,b)-> {return Math.max(a,b);};\n\tstatic BiFunction<Integer,Integer,Integer> fmin = (a,b)-> {return Math.min(a,b);};\n\tstatic BiFunction<Integer,Integer,Integer> fsum = (a,b)-> {return a+b;};\n\tstatic BiFunction<Long,Long,Long> fmaxl = (a,b)-> {return Math.max(a,b);};\n\tstatic BiFunction<Long,Long,Long> fminl = (a,b)-> {return Math.min(a,b);};\n\tstatic BiFunction<Long,Long,Long> fsuml = (a,b)-> {return a+b;};\n\tstatic BiFunction<Integer,Integer,Integer> fadd = fsum;\n\tstatic BiFunction<Integer,Integer,Integer> fupd = (a,b)-> {return b;};\n\tstatic BiFunction<Long,Long,Long> faddl = fsuml;\n\tstatic BiFunction<Long,Long,Long> fupdl = (a,b)-> {return b;};\n\tstatic String sp = \" \";\n\t\n\tpublic static void main(String[] args) {\n\t\t//AOJ2439 Hakone\n\t\t//auther:Suunn\n\t\t//有名問題らしい。こういうのは条件が厳しい順番から考えるとできるイメージがあるので、\n\t\t//平面走査的にやる。あとは気合でDPを組む。\n\t\t\n\n\t\tint N = sc.nextInt();\n\t\tchar[] c = new char[N];\n\t\tfor(int i=0;i<N;i++)c[i] = sc.nextChar();\n\t\tlong[][][] dp = new long[N+1][N+1][N+1];\n\t\tdp[0][0][0] = 1;\n\t\t//dp[i][j][k]=(i番目のチームと前の順位表まで見て、j組のUPを当てはめていなくて、前の順位表の今まで見たk箇所に穴がある（あとでDOWNを割り当てる）\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tfor(int j=0;j<=N;j++) {\n\t\t\t\tfor(int k=0;k<=N;k++) {\n\t\t\t\t\tif(c[i]=='-')dp[i+1][j][k] += dp[i][j][k];\n\t\t\t\t\telse if(c[i]=='U') {\n\t\t\t\t\t\tdp[i+1][j][k] += dp[i][j][k] * j;//残したUPを一つ前の順位表の今見てる順位に割り当てる\n\t\t\t\t\t\tdp[i+1][j][k] %= mod;\n\t\t\t\t\t\tif(j<N&&k<N) {\n\t\t\t\t\t\t\tdp[i+1][j+1][k+1] += dp[i][j][k];//残したUPを割り当てない\n\t\t\t\t\t\t\tdp[i+1][j+1][k+1] %= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(c[i]=='D') {\n\t\t\t\t\t\tdp[i+1][j][k] += dp[i][j][k] * k;//残したUPを一つ前の順位表の今見てる順位に割り当てない\n\t\t\t\t\t\tdp[i+1][j][k] %= mod;\n\t\t\t\t\t\tif(j>0&&k>0) {\n\t\t\t\t\t\t\tdp[i+1][j-1][k-1] += dp[i][j][k] * j * k;//残したUPを一つ前の順位表の今見てる順位に割り当てる\n\t\t\t\t\t\t\tdp[i+1][j-1][k-1] %= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[N][0][0]);\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\n\n}\n\n\n\n\nclass FastScanner {\n    private final java.io.InputStream in = System.in;\n    private final byte[] b = new byte[1024];\n    private int p = 0;\n    private int bl = 0;\n    private boolean hNB() {\n        if (p<bl) {\n            return true;\n        }else{\n            p = 0;\n            try {\n                bl = in.read(b);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (bl<=0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\tprivate int rB() { if (hNB()) return b[p++]; else return -1;}\n    private static boolean iPC(int c) { return 33 <= c && c <= 126;}\n    private void sU() { while(hNB() && !iPC(b[p])) p++;}\n    public boolean hN() { sU(); return hNB();}\n    public String next() {\n        if (!hN()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = rB();\n        while(iPC(b)) {\n            sb.appendCodePoint(b);\n            b = rB();\n        }\n        return sb.toString();\n    }\n    public char nextChar() {\n    \treturn next().charAt(0);\n    }\n    public long nextLong() {\n        if (!hN()) throw new NoSuchElementException();\n        long n = 0;\n        boolean m = false;\n        int b = rB();\n        if (b=='-') {\n            m=true;\n            b=rB();\n        }\n        if (b<'0'||'9'<b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0'<=b&&b<='9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1||!iPC(b)){\n                return (m?-n:n);\n            }else{\n                throw new NumberFormatException();\n            }\n            b = rB();\n        }\n    }\n    public int nextInt() {\n        if (!hN()) throw new NoSuchElementException();\n        long n = 0;\n        boolean m = false;\n        int b = rB();\n        if (b == '-') {\n            m = true;\n            b = rB();\n        }\n        if (b<'0'||'9'<b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0'<=b&&b<='9') {\n                n *= 10;\n                n += b-'0';\n            }else if(b==-1||!iPC(b)){\n                return (int) (m?-n:n);\n            }else{\n                throw new NumberFormatException();\n            }\n            b = rB();\n        }\n    }\n    public int[] nextInts(int n) {\n    \tint[] a = new int[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = nextInt();\n    \t}\n    \treturn a;\n    }\n    public int[] nextInts(int n,int s) {\n    \tint[] a = new int[n+s];\n    \tfor(int i=s;i<n+s;i++) {\n    \t\ta[i] = nextInt();\n    \t}\n    \treturn a;\n    }\n    public long[] nextLongs(int n, int s) {\n    \tlong[] a = new long[n+s];\n    \tfor(int i=s;i<n+s;i++) {\n    \t\ta[i] = nextLong();\n    \t}\n    \treturn a;\n\t}\n    public long[] nextLongs(int n) {\n    \tlong[] a = new long[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = nextLong();\n    \t}\n    \treturn a;\n    }\n    public int[][] nextIntses(int n,int m){\n    \tint[][] a = new int[n][m];\n    \tfor(int i=0;i<n;i++) {\n    \t\tfor(int j=0;j<m;j++) {\n    \t\t\ta[i][j] = nextInt();\n    \t\t}\n    \t}\n    \treturn a;\n    }\n\n    public String[] nexts(int n) {\n    \tString[] a = new String[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = next();\n    \t}\n    \treturn a;\n    }\n    void nextIntses(int n,int[] ...m) {\n    \tint l = m[0].length;\n    \tfor(int i=0;i<l;i++) {\n    \t\tfor(int j=0;j<m.length;j++) {\n    \t\t\tm[j][i] = nextInt();\n    \t\t}\n    \t}\n    }\n    void nextLongses(int n,long[] ...m) {\n    \tint l = m[0].length;\n    \tfor(int i=0;i<l;i++) {\n    \t\tfor(int j=0;j<m.length;j++) {\n    \t\t\tm[j][i] = nextLong();\n    \t\t}\n    \t}\n    }\n\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final int MOD = 1000000007;\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tlong[][][] dp = new long[N + 1][N + 1][N + 1];\n\t\tdp[0][0][0] = 1;\n\t\tint idx = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchar v = sc.next().charAt(0);\n\t\t\tif (v == '-') continue;\n\t\t\t++idx;\n\t\t\tif (v == 'D') {\n\t\t\t\tfor (int j = 0; j < idx; ++j) {\n\t\t\t\t\tfor (int k = 1; k < idx; ++k) {\n\t\t\t\t\t\tdp[idx][j][k] += dp[idx - 1][j][k] * j % MOD;\n\t\t\t\t\t\tif (j > 0) dp[idx][j - 1][k - 1] += dp[idx - 1][j][k] * j * k % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int j = 0; j < idx; ++j) {\n\t\t\t\t\tfor (int k = 0; k < idx; ++k) {\n\t\t\t\t\t\tdp[idx][j + 1][k + 1] += dp[idx - 1][j][k];\n\t\t\t\t\t\tdp[idx][j][k] += dp[idx - 1][j][k] * j % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[idx][0][0] % MOD);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\nusing Pi = Pair<int, int>;\nusing PL = Pair<long, int>;\n//using static System.Globalization.CultureInfo;\nusing System.Text;\nclass Program\n{\n    public static bool chmin<T>(ref T num, T val) where T : IComparable<T>\n    { if (num.CompareTo(val) == 1) { num = val; return true; } return false; }\n    public static bool chmax<T>(ref T num, T val) where T : IComparable<T>\n    { if (num.CompareTo(val) == -1) { num = val; return true; } return false; }\n    public static void swap<T>(ref T v1, ref T v2)\n    { var t = v2; v2 = v1; v1 = t; }\n    public static void Fail() => Fail(\"No\");\n    public static void Fail<T>(T s) { WriteLine(s); Console.Out.Close(); Environment.Exit(0); }\n    static void Main(string[] args)\n    {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        Console.SetOut(sw);\n        var p = new Program();\n        for (var i = 1; i > 0; --i)\n            p.Solve();\n        Console.Out.Flush();\n    }\n    void Solve()\n    {\n        var num = Input.num;\n        var dp = new ModInt[num+1];dp[0] = 1;\n        for(var i = 0; i < num; i++)\n        {\n            var c = Input.Next<char>();\n            var newdp = new ModInt[num + 1];\n            for (var j = 0; j <= i + 1; j++)\n                if (c == '-')\n                {\n                    if (j != 0)\n                        newdp[j] = dp[j - 1];\n                }\n                else if (c == 'U')\n                {\n                    if (j != 0)\n                        newdp[j] = dp[j - 1] * (i - j + 1);\n                    newdp[j] += dp[j];\n                }\n                else\n                {\n                    if (j > 1)\n                        newdp[j] = dp[j - 2] * (i - j + 2) * (i - j + 2);\n                    if (j != 0)\n                        newdp[j] += dp[j - 1] * (i - j + 1);\n                }\n            dp = newdp;\n        }\n        WriteLine(dp[num]);\n    }\n}\n\npublic struct ModInt\n{\n    public const long MOD = (int)1e9 + 7;\n    //public const long MOD = 998244353;\n    public long num { get; set; }\n    public ModInt(long n = 0) { num = n; }\n    private static ModInt[] _fac;//階乗\n    private static ModInt[] _inv;//逆数\n    private static ModInt[] _facrev;//1/(i!)\n    public override string ToString()\n        => num.ToString();\n    public static ModInt operator +(ModInt l, ModInt r)\n    {\n        l.num += r.num;\n        if (l.num >= MOD) l.num -= MOD;\n        return l;\n    }\n    public static ModInt operator -(ModInt l, ModInt r)\n    {\n        l.num -= r.num;\n        if (l.num < 0) l.num += MOD;\n        return l;\n    }\n    public static ModInt operator *(ModInt l, ModInt r)\n        => new ModInt(l.num * r.num % MOD);\n    public static ModInt operator /(ModInt l, ModInt r)\n        => l * Pow(r, MOD - 2);\n    public static implicit operator long(ModInt l)\n        => l.num;\n    public static implicit operator ModInt(long n)\n    {\n        n %= MOD; if (n < 0) n += MOD;\n        return new ModInt(n);\n    }\n\n    public static ModInt Pow(ModInt m, long n)\n    {\n        if (n == 0) return 1;\n        if (n % 2 == 0) return Pow(m * m, n >> 1);\n        else return Pow(m * m, n >> 1) * m;\n    }\n\n    public static void CombBuild(int n)\n    {\n        _fac = new ModInt[n + 1];\n        _facrev = new ModInt[n + 1];\n        _inv = new ModInt[n + 1];\n        _inv[1] = 1;\n        _fac[0] = _fac[1] = 1;\n        _facrev[0] = _facrev[1] = 1;\n        for (var i = 2; i <= n; i++)\n        {\n            _fac[i] = _fac[i - 1] * i;\n            _inv[i] = MOD - _inv[MOD % i] * (MOD / i);\n            _facrev[i] = _facrev[i - 1] * _inv[i];\n        }\n    }\n\n    public static ModInt Fac(ModInt n)\n        => _fac[n];\n    public static ModInt Div(ModInt n)\n        => _inv[n];\n    public static ModInt FacRev(ModInt n)\n        => _facrev[n];\n    public static ModInt Part(ModInt n, ModInt r)\n    {\n        if (n < r) return 0;\n        return _fac[n] * _facrev[n - r];\n    }\n    public static ModInt Comb(ModInt n, ModInt r)\n    {\n        if (n < r) return 0;\n        if (n == r) return 1;\n        var calc = _fac[n];\n        calc = calc * _facrev[r];\n        calc = calc * _facrev[n - r];\n        return calc;\n    }\n}\n\npublic class Input\n{\n    public static string read => ReadLine().Trim();\n    public static int[] ar => read.Split(' ').Select(int.Parse).ToArray();\n    public static int num => ToInt32(read);\n    public static long[] arL => read.Split(' ').Select(long.Parse).ToArray();\n    public static long numL => ToInt64(read);\n    public static T[] Create<T>(int n, Func<T> f)\n        => Enumerable.Repeat(0, n).Select(_ => f()).ToArray();\n    public static char[][] grid(int h)\n        => Create(h, () => read.ToCharArray());\n    public static int[] ar1D(int n)\n        => Create(n, () => num);\n    public static long[] arL1D(int n)\n        => Create(n, () => numL);\n    public static string[] strs(int n)\n        => Create(n, () => read);\n    public static int[][] ar2D(int n)\n        => Create(n, () => ar);\n    public static long[][] arL2D(int n)\n        => Create(n, () => arL);\n    public static List<T>[] edge<T>(int n)\n        => Create(n, () => new List<T>());\n    public static void Make<T1, T2>(out T1 v1, out T2 v2)\n    {\n        v1 = Next<T1>();\n        v2 = Next<T2>();\n    }\n    public static void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3)\n    {\n        Make(out v1, out v2);\n        v3 = Next<T3>();\n    }\n    public static void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4)\n    {\n        Make(out v1, out v2, out v3);\n        v4 = Next<T4>();\n    }\n    public static void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5)\n    {\n        Make(out v1, out v2, out v3, out v4);\n        v5 = Next<T5>();\n    }\n    public static void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6)\n    {\n        Make(out v1, out v2, out v3, out v4, out v5);\n        v6 = Next<T6>();\n    }\n    static Input()\n    {\n        sc = new Queue<string>();\n        dic = new Dictionary<Type, Func<string, object>>();\n        dic[typeof(int)] = s => int.Parse(s);\n        dic[typeof(long)] = s => long.Parse(s);\n        dic[typeof(char)] = s => char.Parse(s);\n        dic[typeof(double)] = s => double.Parse(s);\n        dic[typeof(uint)] = s => uint.Parse(s);\n        dic[typeof(ulong)] = s => ulong.Parse(s);\n        dic[typeof(string)] = s => s;\n    }\n    private static Dictionary<Type, Func<string, object>> dic;\n    private static Queue<string> sc;\n    public static T Next<T>() { if (sc.Count == 0) foreach (var item in read.Split(' ')) sc.Enqueue(item); return (T)dic[typeof(T)](sc.Dequeue()); }\n    public const int MOD = 1000000007;\n}\n\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1 { get; set; }\n    public T2 v2 { get; set; }\n    public Pair() { v1 = Input.Next<T1>(); v2 = Input.Next<T2>(); }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public Pair<T1, T2, T3> Push<T3>(T3 val)\n        => new Pair<T1, T2, T3>(v1, v2, val);\n    public override string ToString()\n        => $\"{v1.ToString()} {v2.ToString()}\";\n    public override bool Equals(object obj)\n        => this == (Pair<T1, T2>)obj;\n    public override int GetHashCode()\n        => v1.GetHashCode() ^ v2.GetHashCode();\n    public static bool operator ==(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) == 0;\n    public static bool operator !=(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) != 0;\n    public static bool operator >(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) == 1;\n    public static bool operator >=(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) != -1;\n    public static bool operator <(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) == -1;\n    public static bool operator <=(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) != 1;\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3 { get; set; }\n    public Pair() : base() { v3 = Input.Next<T3>(); }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString()\n        => $\"{base.ToString()} {v3.ToString()}\";\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\n//using System.Numerics;\n//using Point = System.Numerics.Complex;\nusing Number = System.Int32;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var c = sc.Char(n).Where(x => x != '-').ToArray();\n            n = c.Length;\n            //dp[a]=a????????£????????????a??????????????°???????????¨????????????\n            var dp = new ModInteger[n + 2];\n            dp[0] = 1;\n            foreach (var x in c)\n            {\n                var next = new ModInteger[n + 2];\n                if (x == 'D')\n                {\n                    for (int i = 1; i <= n; i++)\n                    {\n                        next[i] += i * dp[i];\n                        next[i - 1] += i * i * dp[i];\n                    }\n                }\n                else\n                {\n                    for (int i = 0; i <= n; i++)\n                    {\n                        next[i + 1] += dp[i];\n                        next[i] += i * dp[i];\n                    }\n                }\n                dp = next;\n            }\n            IO.Printer.Out.WriteLine(dp[0]);\n\n\n        }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\n\n    }\n}\n#region main\nstatic class Ex\n{\n    //static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    //static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer : StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n\n#region ModNumber\npublic partial struct ModInteger\n{\n    public const long Mod = (long)1e9 + 7;\n    public long num;\n    public ModInteger(long n) : this() { num = n % Mod; if (num < 0) num += Mod; }\n    public override string ToString() { return num.ToString(); }\n    public static ModInteger operator +(ModInteger l, ModInteger r) { var n = l.num + r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator -(ModInteger l, ModInteger r) { var n = l.num + Mod - r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator *(ModInteger l, ModInteger r) { return new ModInteger(l.num * r.num); }\n    public static ModInteger operator ^(ModInteger l, long r) { return ModInteger.Pow(l, r); }\n    public static implicit operator ModInteger(long n) { return new ModInteger(n); }\n    public static ModInteger Pow(ModInteger v, long k)\n    {\n        ModInteger ret = 1;\n        var n = k;\n        for (; n > 0; n >>= 1, v *= v)\n        {\n            if ((n & 1) == 1)\n                ret = ret * v;\n        }\n        return ret;\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar n=sc.I;\n\t\tvar dp=new Mint[n+1][];\n\t\tdp[0]=new Mint[n+1];\n\t\tdp[0][0]=1;\n\t\tfor(int i = 1;i<=n;i++) {\n\t\t\tvar e=sc.S;\n\t\t\tdp[i]=new Mint[n+1];\n\t\t\tif(e==\"U\"){dp[i][0]=dp[i-1][0];}\n\t\t\tfor(int j = 1;j<=i;j++) {\n\t\t\t\tif(e==\"-\"){dp[i][j]=dp[i-1][j-1];}\n\t\t\t\telse if(e==\"U\"){\n\t\t\t\t\tif(i>j){\n\t\t\t\t\t\tdp[i][j]+=dp[i-1][j-1]*(i-j);\n\t\t\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j>1){dp[i][j]=dp[i-1][j-2]*((i-1)-(j-2))*((i-1)-(j-2));}\n\t\t\t\t\tdp[i][j]+=dp[i-1][j-1]*((i-1)-(j-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",dp[n][n]);\n\t}\n}\npublic struct Mint{\n\tconst int mod=(int)1e9+7;\n\tprivate long d;\n\tpublic Mint(long d){this.d=d;}\n\tpublic static implicit operator Mint(long d){return new Mint(d);}\n\tpublic static explicit operator long(Mint d){return d.d;}\n\tpublic override string ToString(){return d.ToString();}\n\tpublic static Mint operator+(Mint a,long b){a.d=(a.d+b)%mod;return a;}\n\tpublic static Mint operator+(Mint a,Mint b){a.d=(a.d+b.d)%mod;return a;}\n\tpublic static Mint operator-(Mint a,long b){a.d=(mod+a.d-b)%mod;return a;}\n\tpublic static Mint operator-(Mint a,Mint b){a.d=(mod+a.d-b.d)%mod;return a;}\n\tpublic static Mint operator*(Mint a,long b){a.d=(a.d*b)%mod;return a;}\n\tpublic static Mint operator*(Mint a,Mint b){a.d=(a.d*b.d)%mod;return a;}\n\tpublic static Mint operator/(Mint a,long b){a.d=(a.d*Mi(b))%mod;return a;}\n\tpublic static Mint operator/(Mint a,Mint b){a.d=(a.d*Mi(b.d))%mod;return a;}\n\tprivate static long Mi(long a){\n\t\ta=(a+mod)%mod;\n\t\tlong b=mod,u=1,v=0;\n\t\twhile(b>0){\n\t\t\tlong t=a/b;\n\t\t\ta-=t*b;a^=b;b^=a;a^=b;\n\t\t\tu-=t*v;u^=v;v^=u;u^=v;\n\t\t}\n\t\tu%=mod;\n\t\tif(u<0){u+=mod;}\n\t\treturn u%mod;\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "Ruby",
    "code": "DIV = 1_000_000_007\nn = gets.to_i\nl = n.times.map{ gets.chomp }\nl.delete('-')\ns = l.size\nu = l.count('U')\ndp = (s+1).times.map{ [0]*(s+1) }\ndp[0][0] = 1\ncase_u = 0\ncase_d = 0\nfor i in (0...s)\n  case_d += 1 if l[i] == 'U'\n  for j in (0..i+1)\n    dp[i+1][j] = dp[i][j-1]*(case_u - (j-1)) if j > 0 \n    dp[i+1][j] += dp[i][j]*(case_d - j)\n    dp[i+1][j] %= DIV\n  end\n  case_u += 1 if l[i] == 'U'\nend\np dp[s][u]"
  },
  {
    "language": "Ruby",
    "code": "DIV = 1_000_000_007\nn = gets.to_i\nl = n.times.map{ gets.chomp }\nl.delete('-')\ns = l.size\nu = l.count('U')\ndp = (s+1).times.map{ [0]*(s+1) }\ndp[0][0] = 1\npos = 0\npre = true\nfor i in (0...s)\n  pos += 1 if pre\n  if l[i] == 'U' && !pre\n    pre = true\n  elsif l[i] == 'D' && pre\n    pre = false\n  end\n  for j in (0..i+1)\n    dp[i+1][j] = (j > 0 ? dp[i][j-1]*(pos-j) : 0)\n    dp[i+1][j] += dp[i][j]*(pre ? pos-j : pos-j-1) if j < i+1\n    dp[i+1][j] %= DIV\n  end\nend\np dp[s][u]"
  },
  {
    "language": "Ruby",
    "code": "DIV = 1_000_000_007\nn = gets.to_i\nl = n.times.map{ gets.chomp }\nl.delete('-')\ns = l.size\nu = l.count('U')\ndp = 2.times.map{ [0]*(s+1) }\ndp[0][0] = 1\npos = 0\npre = true\nfor i in (0...s)\n  pos += 1 if pre\n  if l[i] == 'U' && !pre\n    pre = true\n  elsif l[i] == 'D' && pre\n    pre = false\n  end\n  for j in (0..i+1)\n    dp[1][j] = (j > 0 ? dp[0][j-1]*(pos-j) : 0)\n    dp[1][j] += dp[0][j]*(pre ? pos-j : pos-j-1) if j < i+1\n    dp[1][j] %= DIV\n  end\n  dp.rotate!\nend\np dp[0][u]"
  },
  {
    "language": "Ruby",
    "code": "DIV = 1_000_000_007\nn = gets.to_i\nl = n.times.map{ gets.chomp }\nl.delete('-')\ns = l.size\nu = l.count('U')\ndp = (s+1).times.map{ [0]*(s+1) }\ndp[0][0] = 1\ncase_u = 1\ncase_d = 0\nfor i in (0...s)\n  case_d += 1 if l[i] == 'U'\n  for j in (0..i+1)\n    dp[i+1][j] = dp[i][j-1]*(case_u - j) if j > 0 \n    dp[i+1][j] += dp[i][j]*(case_d - j) if j < i+1\n    dp[i+1][j] %= DIV\n  end\n  case_u += 1 if l[i] == 'U'\nend\np dp[s][u]"
  },
  {
    "language": "Ruby",
    "code": "DIV = 1_000_000_007\nn = gets.to_i\nl = n.times.map{ gets.chomp }\nl.delete('-')\ns = l.size\nu = l.count('U')\nd = l.count('D')\npos_u = [0]*s\npos_d = [-d]*s\nl.each_with_index do |str, i|\n  if str == 'U' then (i+1...s).each{ |j| pos_u[j]+= 1 }\n  else               (0...i).each{   |j| pos_d[j]+= 1 }\n  end\nend\ndp = (s+1).times.map{ [0]*(s+1) }\ndp[0][0] = 1\nfor i in (1..s)\n  for j in (0..i)\n    dp[i][j] = dp[i-1][j-1]*(pos_u[i-1]-(j-1)) if j > 0\n    dp[i][j] += dp[i-1][j]*(pos_d[i-1]-(j-i)) if j < i\n    dp[i][j] %= DIV\n  end\nend\np dp[s][u]"
  },
  {
    "language": "Ruby",
    "code": "DIV = 1_000_000_007\nn = gets.to_i\nl = n.times.map{ gets.chomp }\nl.delete('-')\ns = l.size\nu = l.count('U')\ndp = (s+1).times.map{ [0]*(s+1) }\ndp[0][0] = 1\ncase_u = 0\ncase_d = 0\nfor i in (0...s)\n  case_d += 1 if l[i] == 'U'\n  for j in (0..i+1)\n    dp[i+1][j] = dp[i][j-1]*(case_u - (j-1)) if j > 0 \n    dp[i+1][j] += dp[i][j]*(case_d - j)\n    dp[i+1][j] %= DIV\n  end\n  case_u += 1 if l[i] == 'U'\n  puts\nend\np dp[s][u]"
  },
  {
    "language": "Ruby",
    "code": "DIV = 1_000_000_007\nn = gets.to_i\nl = n.times.map{ gets.chomp }.delete('-')\ns = l.size\nu = l.count('U')\ndp = (s+1).times.map{ [0]*(s+1) }\ndp[0][0] = 1\ncase_u = 0\ncase_d = 0\nfor i in (0...s)\n  case_d += 1 if l[i] == 'U'\n  for j in (0..i+1)\n    dp[i+1][j] = dp[i][j-1]*(case_u - (j-1)) if j > 0 \n    dp[i+1][j] += dp[i][j]*(case_d - j)\n    dp[i+1][j] %= DIV\n  end\n  case_u += 1 if l[i] == 'U'\nend\np dp[s][u]"
  },
  {
    "language": "Ruby",
    "code": "DIV = 1_000_000_007\nn = gets.to_i\nl = n.times.map{ gets.chomp }\nl.delete('-')\ns = l.size\nu = l.count('U')\ndp = (s+1).times.map{ [0]*(s+1) }\ndp[0][0] = 1\npos = 0\ncnt = 0\npre = true\nfor i in (0...s)\n  pos += 1 if pre\n  if l[i] == 'U'\n    pre = true\n    cnt += 1\n  else\n    pre = false\n  end\n  for j in (0..i+1)\n    dp[i+1][j] = dp[i][j-1]*(pos-j) if j > 0 \n    dp[i+1][j] += dp[i][j]*(cnt-j) if j < i+1\n    dp[i+1][j] %= DIV\n  end\nend\np dp[s][u]"
  },
  {
    "language": "Ruby",
    "code": "DIV = 1_000_000_007\nn = gets.to_i\nl = n.times.map{ gets.chomp }\nl.delete('-')\ns = l.size\npos_u = [0]*s\npos_d = [0]*s\nu = l.count(\"U\")\nd = l.count(\"D\")\nl.each_with_index do |str, i|\n  if str == \"U\" then (i+1...s).each{ |j| pos_u[j]+= 1 }\n  else               (0...i).each{   |j| pos_d[j]+= 1 }\n  end\nend\ndp = (s+1).times.map{ [0]*(s+1) }\ndp[0][0] = 1\nfor i in (1..s)\n  for j in (0..i)\n    dp[i][j] = dp[i-1][j-1]*(pos_u[i-1]-j+1) if j > 0\n    dp[i][j] += dp[i-1][j]*(pos_d[i-1]-u+(i-j)) if j < i\n    dp[i][j] %= DIV\n  end\nend\np dp[s][d]"
  },
  {
    "language": "Ruby",
    "code": "DIV = 1_000_000_007\nn = gets.to_i\nl = n.times.map{ gets.chomp }\nl.delete('-')\ns = l.size\nu = l.count('U')\nd = l.count('D')\npos_u = [0]*s\npos_d = [0]*s\nl.each_with_index do |str, i|\n  if str == 'U' then (i+1...s).each{ |j| pos_u[j]+= 1 }\n  else (0...i).each{ |j| pos_d[j]+= 1 }\n  end\nend\ndp = 2.times.map{ [0]*(s+1) }\ndp[0][0] = 1\nfor i in (1..s)\n  for j in (0..i)\n    dp[1][j] = j > 0 ? dp[0][j-1]*(pos_u[i-1]-(j-1)) : 0\n    dp[1][j] += dp[0][j]*(pos_d[i-1]-d+(i-j)) if j < i\n    dp[1][j] %= DIV\n  end\n  dp.rotate!\nend\np dp[0][u]"
  },
  {
    "language": "Ruby",
    "code": "DIV = 1_000_000_007\nn = gets.to_i\nl = n.times.map{ gets.chomp }\nl.delete('-')\ns = l.size\nu = l.count('U')\nd = l.count('D')\npos_u = [0]*s\npos_d = [-d]*s\nl.each_with_index do |str, i|\n  if str == 'U' then (i+1...s).each{ |j| pos_u[j]+= 1 }\n  else (0...i).each{ |j| pos_d[j]+= 1 }\n  end\nend\ndp = (s+1).times.map{ [0]*(s+1) }\ndp[0][0] = 1\nfor i in (1..s)\n  for j in (0..i)\n    dp[i][j] = dp[i-1][j-1]*(pos_u[i-1]-(j-1)) if j > 0\n    dp[i][j] += dp[i-1][j]*(pos_d[i-1]-(j-i)) if j < i\n    dp[i][j] %= DIV\n  end\nend\np dp[s][u]"
  },
  {
    "language": "Ruby",
    "code": "DIV = 1_000_000_007\nn = gets.to_i\nl = n.times.map{ gets.chomp }\nl.delete('-')\ns = l.size\nu = l.count('U')\ndp = (s+1).times.map{ [0]*(s+1) }\ndp[0][0] = 1\ncase_u = 1\ncase_d = 0\nfor i in (0...s)\n  case_d += 1 if l[i] == 'U'\n  for j in (0..i+1)\n    dp[i+1][j] = dp[i][j-1]*(case_u - j) if j > 0 \n    dp[i+1][j] += dp[i][j]*(case_d - j)\n    dp[i+1][j] %= DIV\n  end\n  case_u += 1 if l[i] == 'U'\nend\np dp[s][u]"
  },
  {
    "language": "Ruby",
    "code": "DIV = 1_000_000_007\nn = gets.to_i\nl = n.times.map{ gets.chomp }\nl.delete('-')\ns = l.size\npos_u = [0]*s\npos_d = [0]*s\nu = l.count('U')\nd = l.count('D')\nl.each_with_index do |str, i|\n  if str == 'U' then (i+1...s).each{ |j| pos_u[j]+= 1 }\n  else               (0...i).each{   |j| pos_d[j]+= 1 }\n  end\nend\ndp = (s+1).times.map{ [0]*(s+1) }\ndp[0][0] = 1\nfor i in (1..s)\n  for j in (0..i)\n    dp[i][j] = dp[i-1][j-1]*(pos_u[i-1]-j+1) if j > 0\n    dp[i][j] += dp[i-1][j]*(pos_d[i-1]-d+(i-j)) if j < i\n    dp[i][j] %= DIV\n  end\nend\np dp[s][u]"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**3\neps = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n = I()\n    c = [S() for _ in range(n)]\n    dp = [[0]*(n+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(n):\n        ci = c[i]\n        if ci == '-':\n            for j in range(n+1):\n                dp[i+1][j] = dp[i][j]\n        elif ci == 'D':\n            for j in range(n+1):\n                dp[i+1][j] += dp[i][j] * j\n                if j > 0:\n                    dp[i+1][j-1] += dp[i][j] * j * j\n                    dp[i+1][j-1] %= mod\n        else: # 'U'\n            for j in range(n+1):\n                if j < n:\n                    dp[i+1][j+1] += dp[i][j]\n                dp[i+1][j] += dp[i][j] * j\n                dp[i+1][j] %= mod\n\n    return dp[-1][0] % mod\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n# 箱根\n\n\nN = int(sys.stdin.readline())\nC = [sys.stdin.readline().rstrip() for _ in range(N)]\nC = [c for c in C if c != '-']\nN = len(C)\n\n# dp[i][j][k]:\n# iまで見て、\n# j個未割当の人が残ってて、\n# j個未割当の場所が残ってる場合の数\ndp = [[0] * (N + 1) for _ in range(N + 1)]\ndp[0][0] = 1\nfor i, c in enumerate(C):\n    for j in range(N):\n        if c == 'D':\n            if j - 1 >= 0:\n                # 前回i位だった人を今まで見た場所に割り当てる\n                dp[i + 1][j - 1] += dp[i][j] * j * j\n                dp[i + 1][j - 1] %= MOD\n            # 割り当てない\n            dp[i + 1][j] += dp[i][j] * j\n            dp[i + 1][j] %= MOD\n        if c == 'U':\n            # 前回i位だった人を今まで見た場所に割り当てる\n            dp[i + 1][j] += dp[i][j] * j\n            dp[i + 1][j] %= MOD\n            # 割り当てない\n            dp[i + 1][j + 1] += dp[i][j]\n            dp[i + 1][j + 1] %= MOD\nprint(dp[-1][0])\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\ns = [input() for i in range(n)]\ns = \"\".join(s).replace(\"-\",\"\")\nn = len(s)\nmod = 10**9+7\ndp = [[0 for i in range(n+1)] for j in range(n+1)]\ndp[0][0] = 1\nfor i in range(n):\n  si = s[i]\n  if si == \"D\":\n    for j in range(1,n+1):\n      dp[i+1][j] = (dp[i+1][j]+dp[i][j]*j)%mod\n      dp[i+1][j-1] = (dp[i+1][j-1]+dp[i][j]*j**2)%mod\n  else:\n    for j in range(n):\n      dp[i+1][j+1] = (dp[i+1][j+1]+dp[i][j])%mod\n      dp[i+1][j] = (dp[i+1][j]+dp[i][j]*j)%mod\nprint(dp[n][0])\n"
  },
  {
    "language": "Python",
    "code": "MOD = 10**9+7\nn = int(input())\ndp = [[0 for _ in range(n+1)] for _ in range(n+1)]\ndp[0][0] = 1\nfor i in range(1, n+1):\n\ts = input()\n\tfor j in range(n+1):\n\t\tif s == \"U\":\n\t\t\tif j > 0:\n\t\t\t\tdp[i][j] += dp[i-1][j-1]\n\t\t\tdp[i][j] += j * dp[i-1][j]\n\t\telif s == \"-\":\n\t\t\tdp[i][j] += dp[i-1][j]\n\t\telse:\n\t\t\tif j < n:\n\t\t\t\tdp[i][j] += (j+1) * (j+1) * dp[i-1][j+1]\n\t\t\tdp[i][j] += j * dp[i-1][j]\n\t\tdp[i][j] %= MOD\nprint(dp[n][0])\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    MOD = 10**9 + 7\n    N = int(readline())\n    S = []\n    for i in range(N):\n        s = readline().strip()\n        if s == \"-\":\n            N -= 1\n            continue\n        S.append(s == \"D\")\n    memo = {}\n    def dfs(i, a, b):\n        if i == N:\n            return (a == b == 0)\n        key = (i, a, b)\n        if key in memo:\n            return memo[key]\n        r = 0\n        if S[i]:\n            if a > 0:\n                r += dfs(i+1, a, b) * a % MOD\n            if a > 0 and b > 0:\n                r += dfs(i+1, a-1, b-1) * a * b % MOD\n        else:\n            r += dfs(i+1, a+1, b+1)\n            if b > 0:\n                r += dfs(i+1, a, b) * b % MOD\n        memo[key] = r = r % MOD\n        return r\n    write(\"%d\\n\" % dfs(0, 0, 0))\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "MOD = 1000000007\nn = int(input())\ndp = [[0] * (n + 1) for _ in range(n + 1)]\ndp[0][0] = 1\nfor i in range(n):\n    c = input()\n    for j in range(n):\n        if c == \"-\":\n            dp[i + 1][j] += dp[i][j]\n            dp[i + 1][j] %= MOD\n        if c == \"U\":\n            dp[i + 1][j] += j * dp[i][j]\n            dp[i + 1][j] %= MOD\n            if n > j:\n                dp[i + 1][j + 1] += dp[i][j]\n                dp[i + 1][j + 1] %= MOD\n        if c == \"D\":\n            dp[i + 1][j] += j * dp[i][j]\n            dp[i + 1][j] %= MOD\n            if j > 0:\n                dp[i + 1][j - 1] += j * j * dp[i][j]\n                dp[i + 1][j - 1] %= MOD\nprint(dp[n][0])\n                \n        \n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2439\n\n1位から順番に見ていく。\n-ならそこの順位に決めざるを得ない\n\nUなら、左に空いた空きマスから1つ選んでそこに入れる(空きマスは減る)\nDなら、…？\n\ndpであることは分かっている\n重要なのはどの状態をまとめるか…\n\n-は関係ないので無視してUDだけの問題にする\nUDの列に通し番号を付ける。Uはそれより右に、Dは左にもっていかなくてはならない\nそのような並び替えが構成できなくなるのは、左にもとよりUが多い場合・・・\n\nUだけの入れ方を考えてみる(Dはどこに入っても構わない)\n左から見ていくと、入れる・入れないを決め、今までに出たUの中から1つ選んで入れればよい\n→ただのdpで解ける\n\nDだけの入れ方も同様に分かる\n\nあらかじめU,Dにおいてdpをしておく？\n\nudp[左からi番目にUが入る場合のUの入り方][j][k] =\nん～？？？？？\n\n=====解説を見た=====\n\nUならば、それより右に入れなきゃいけない→保留枠に入れ、Uのあったマスを開けておく\nDならば、そこにあったDを左の空きますにぶち込み、保留の中から1つUを選んでぶち込む or　空きますにする\n→空きマスは1つ減る or 減らない\n\n空きマスの数 = 保留の数なので、 O(N**2)で解ける\n\n\"\"\"\n\nn = int(input())\n\ndp = [0] * (n+1)\ndp[0] = 1\nmod = 10**9+7\n\nfor loop in range(n):\n\n    c = input()\n    ndp = [0] * (n+1)\n    if c == \"-\":\n        continue\n\n    \n    elif c == \"U\":\n        for i in range(n+1):\n\n            if i != n: #保留に入れて空きますにする\n                ndp[i+1] = dp[i]\n                ndp[i+1] %= mod\n\n            #保留に入れ、保留から1つ取り出して入れる\n\n            ndp[i] += dp[i] * i\n            ndp[i] %= mod\n            \n\n    else:\n        for i in range(0,n+1):\n\n            if i != 0: #そこにあったのは左の空きますに移動 & そのマスに保留からぶち込む\n                ndp[i-1] += dp[i] * i * i\n                ndp[i-1] %= mod\n\n            #そこにあったのは左の空きますに、そこは空きますにする\n\n            ndp[i] += dp[i] * i\n            ndp[i] %= mod\n    \n\n    dp = ndp\n    #print (dp)\n\nprint (dp[0])\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nc = [input() for i in range(n)]\nMOD = 10 ** 9 + 7\n\n\ndp = [[0] * (n + 1) for i in range(n + 1)]\ndp[0][0] = 1\n\nfor i , char in enumerate(c):\n    if char == \"-\":\n        for j in range(n + 1):\n            if j + 1 < n + 1:\n                dp[i + 1][j + 1] += dp[i][j]\n                dp[i + 1][j + 1] %= MOD\n\n    if char == \"U\":\n        for j in range(n + 1):\n            dp[i + 1][j] += dp[i][j]\n            dp[i + 1][j] %= MOD\n            if j + 1 < n + 1:\n                dp[i + 1][j + 1] += dp[i][j] * (i - j)\n                dp[i + 1][j + 1] %= MOD\n\n    if char == \"D\":   \n        for j in range(n + 1):\n            if j + 1 < n + 1:\n                dp[i + 1][j + 1] += dp[i][j] * (i - j)\n                dp[i + 1][j + 1] %= MOD\n            if j + 2 < n + 1:\n                dp[i + 1][j + 2] += dp[i][j] * (i - j) ** 2\n                dp[i + 1][j + 2] %= MOD\n\nprint(dp[-1][-1])\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\nimport sys\nimport math\nfrom bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nsys.setrecursionlimit(2147483647)\nfrom heapq import heappush, heappop,heappushpop\nfrom collections import defaultdict\nfrom itertools import accumulate\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\nfrom itertools import permutations\nmod = 10**9 + 7\ninf = float('inf')\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\n# 参考にしました(参考というよりほぼ写経)\n# https://drken1215.hatenablog.com/entry/2019/10/05/173700\n\nn = I()\ndp = [[0] * (n+2) for _ in range(n+1)]\n# 今回の順位と前回の順位を結んだグラフを考える\n# dp[i][j] := i番目まで見たときに, j個繋がっているときの場合の数\ndp[0][0] = 1\nfor i in range(n):\n    s = input()\n    if s == 'U':\n        # Uのとき，今回順位から前回順位に向かう辺は必ず下向きなので\n        # i+1番目まで見たときに今回順位からの辺によってjが増加することはない\n        # jが増加するのは前回順位からの辺が上に伸びている場合\n        # このとき，対応するペアを今回順位の中からi-j個の中から選ぶ\n        for j in range(n):\n            dp[i+1][j] += dp[i][j]# 今回順位からも前回順位からも下へ伸びている場合\n            dp[i+1][j+1] += dp[i][j] * (i - j)# 今回順位からは下へ，前回順位からは上へ伸びている場合\n            dp[i+1][j+1] %= mod \n    elif s == '-':\n        # -のとき，今回順位から前回順位に向かう辺は必ず同じ位置であり，\n        # 前回順位から今回順位へ向かう辺も必ず同じ位置である\n        # つまり，jが1だけ増加する\n        for j in range(n):\n            dp[i+1][j+1] += dp[i][j]\n    else:\n        # Dのとき，今回順位から前回順位に向かう辺は必ず上向きなので\n        # i+1番目まで見たときに今回順位からの辺によって必ずjが増加する\n        # 前回順位から今回順位へ向かう辺が上向きの場合は，両方ともjが増加するのでj+2\n        # 前回順位から今回順位へ向かう辺が下向きの場合は，jが増加しないのでj+1\n        for j in range(n):\n            dp[i+1][j+2] += dp[i][j] * (i - j) * (i - j)# 今回順位からも前回順位からも上へ伸びている場合\n            dp[i+1][j+2] %= mod\n            dp[i+1][j+1] += dp[i][j] * (i - j)# 今回順位からは上へ，前回順位からは下へ伸びている場合\n            dp[i+1][j+1] %= mod\nprint(dp[n][n])\n\n\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\ndp=[[0]*(N+1) for i in range(N+1)]\ndp[0][0]=1\nMOD=10**9+7\nfor i in range(N):\n    s=input()\n    for j in range(i+1):\n        if s==\"-\":\n            nj=j\n            dp[i+1][nj]+=dp[i][j]\n            dp[i+1][nj]%=MOD\n        elif s==\"U\":#実際には下がる\n            nj=j+1\n            dp[i+1][nj]+=dp[i][j]\n            dp[i+1][nj]%=MOD\n\n            nj=j\n            x=j\n            dp[i+1][nj]+=dp[i][j]*x\n            dp[i+1][nj]%=MOD\n        elif s==\"D\":#実際には上がる\n            nj=j\n            x=j\n            dp[i+1][nj]+=dp[i][j]*x\n            dp[i+1][nj]%=MOD\n\n            if nj==0:\n                continue\n            nj=j-1\n            x=j*j\n            dp[i+1][nj]+=dp[i][j]*x\n            dp[i+1][nj]%=MOD\nprint(dp[N][0])\n\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\nconst MOD: u32 = 1_000_000_007;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        self.pow(MOD - 2)\n    }\n    pub fn comb(n: u32, k: u32) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        let k = std::cmp::min(k, n - k);\n        let mut nu = ModInt::one();\n        let mut de = ModInt::one();\n        for i in 0..k {\n            nu *= ModInt(n - i);\n            de *= ModInt(i + 1);\n        }\n        nu * de.inv()\n    }\n}\n\n#[allow(dead_code)]\nstruct Precalc {\n    inv: Vec<ModInt>,\n    fact: Vec<ModInt>,\n    ifact: Vec<ModInt>,\n}\n\n#[allow(dead_code)]\nimpl Precalc {\n    pub fn new(n: usize) -> Precalc {\n        let mut inv = vec![ModInt::one(); n + 1];\n        let mut fact = vec![ModInt::one(); n + 1];\n        let mut ifact = vec![ModInt::one(); n + 1];\n        for i in 2..(n + 1) {\n            inv[i] = -inv[MOD as usize % i] * ModInt(MOD / i as u32);\n            fact[i] = fact[i - 1] * ModInt(i as u32);\n            ifact[i] = ifact[i - 1] * inv[i];\n        }\n        Precalc {\n            inv: inv,\n            fact: fact,\n            ifact: ifact,\n        }\n    }\n    pub fn inv(&self, n: usize) -> ModInt {\n        self.inv[n]\n    }\n    pub fn fact(&self, n: usize) -> ModInt {\n        self.fact[n]\n    }\n    pub fn ifact(&self, n: usize) -> ModInt {\n        self.ifact[n]\n    }\n    pub fn comb(&self, n: usize, k: usize) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        self.fact[n] * self.ifact[k] * self.ifact[n - k]\n    }\n}\n// ---------- end ModInt ----------\n//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nfn run() {\n    input! {\n        n: usize,\n        a: [chars; n],\n    }\n    let a: Vec<char> = a.into_iter().map(|s| s[0]).collect();\n    let mut dp = vec![vec![ModInt::zero(); n + 1]; n + 1];\n    dp[0][0] = ModInt::one();\n    for a in a {\n        let mut next = vec![vec![ModInt::zero(); n + 1]; n + 1];\n        for i in 0..n {\n            for j in 0..n {\n                let v = dp[i][j];\n                if a == '-' {\n                    next[i][j] = v;\n                } else if a == 'U' {\n                    next[i + 1][j + 1] += v;\n                    next[i][j] += v * ModInt(i as u32);\n                } else {\n                    next[i][j] += v * ModInt(j as u32);\n                    if i > 0 && j > 0 {\n                        next[i - 1][j - 1] += v * ModInt(j as u32) * ModInt(i as u32);\n                    }\n                }\n            }\n        }\n        dp = next;\n    }\n    println!(\"{}\", dp[0][0].0);\n}\n\nfn main() {\n    run();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\nmod util {\n    use std::fmt::Debug;\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\n#[allow(dead_code)]\npub const M: u64 = 1_000_000_007;\n\nfn solve() {\n    let n = get!(usize);\n    let ss = get!(String; n);\n\n    let mut dp = vec![vec![0; n + 1]; n + 1];\n    dp[0][0] = 1;\n\n    for i in 0..n {\n        for j in 0..n {\n            match ss[i].as_str() {\n                \"U\" => {\n                    dp[i + 1][j] += j as u64 * dp[i][j] % M;\n                    dp[i + 1][j + 1] += dp[i][j];\n                }\n                \"D\" => {\n                    if j > 0 {\n                        dp[i + 1][j - 1] += j as u64 * j as u64 * dp[i][j] % M;\n                    }\n                    dp[i + 1][j] += j as u64 * dp[i][j];\n                }\n                \"-\" => {\n                    dp[i + 1][j] = dp[i][j];\n                }\n                _ => unreachable!(),\n            }\n\n            dp[i + 1][j] %= M;\n        }\n    }\n\n    println!(\"{}\", dp[n][0]);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\nmod util {\n    use std::fmt::Debug;\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\n#[allow(dead_code)]\npub const M: u64 = 1_000_000_007;\n\nfn solve() {\n    let n = get!(usize);\n    let ss = get!(String; n);\n\n    let mut dp = vec![vec![0; n + 1]; n + 1];\n    dp[0][0] = 1;\n\n    for i in 0..n {\n        for j in 0..n {\n            match ss[i].as_str() {\n                \"U\" => {\n                    dp[i + 1][j] += j as u64 * dp[i][j] % M;\n                    dp[i + 1][j + 1] += dp[i][j];\n                }\n\n                \"D\" => {\n                    if j > 0 {\n                        dp[i + 1][j - 1] += j as u64 * j as u64 * dp[i][j] % M;\n                    }\n                    dp[i + 1][j] += j as u64 * dp[i][j];\n                }\n                \"-\" => {\n                    dp[i + 1][j] = dp[i][j];\n                }\n                _ => unreachable!(),\n            }\n\n            dp[i][j] %= M;\n        }\n    }\n\n    println!(\"{}\", dp[n][0]);\n}\n\n"
  }
]