[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 100\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    char S[MAX_N + 1];\n    scanf(\"%s\", S);\n\n    long long dp[MAX_N + 1][MAX_N + 1] = {0};\n    dp[0][0] = 1;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            if (dp[i][j] == 0) continue;\n            if (S[i] == '?') {\n                // Case 1: same rank\n                dp[i + 1][j] = (dp[i + 1][j] + dp[i][j] * j) % MOD;\n                // Case 2: higher rank (new rank is j + 1)\n                if (j + 1 <= N) {\n                    dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD;\n                }\n                // Case 3: lower rank (new rank is j - 1)\n                if (j - 1 >= 0) {\n                    dp[i + 1][j - 1] = (dp[i + 1][j - 1] + dp[i][j] * j) % MOD;\n                }\n            } else if (S[i] == '-') {\n                // Same rank\n                dp[i + 1][j] = (dp[i + 1][j] + dp[i][j] * j) % MOD;\n            } else if (S[i] == 'U') {\n                // Higher rank (new rank is j + 1)\n                if (j + 1 <= N) {\n                    dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD;\n                }\n            } else if (S[i] == 'D') {\n                // Lower rank (new rank is j - 1)\n                if (j - 1 >= 0) {\n                    dp[i + 1][j - 1] = (dp[i + 1][j - 1] + dp[i][j] * j) % MOD;\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", dp[N][0]);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:33:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<string> changes(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> changes[i];\n    }\n\n    vector<vector<long long>> dp(N + 1, vector<long long>(N + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 0; i < N; ++i) {\n        if (changes[i] == \"U\") {\n            for (int j = 0; j <= N; ++j) {\n                if (dp[i][j] == 0) continue;\n                for (int k = j + 1; k <= N; ++k) {\n                    dp[i + 1][k] = (dp[i + 1][k] + dp[i][j]) % MOD;\n                }\n            }\n        } else if (changes[i] == \"D\") {\n            for (int j = 1; j <= N; ++j) {\n                if (dp[i][j] == 0) continue;\n                for (int k = 1; k <= j; ++k) {\n                    dp[i + 1][k - 1] = (dp[i + 1][k - 1] + dp[i][j]) % MOD;\n                }\n            }\n        } else if (changes[i] == \"-\") {\n            for (int j = 0; j <= N; ++j) {\n                if (dp[i][j] == 0) continue;\n                dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD;\n            }\n        }\n    }\n\n    long long result = 0;\n    for (int j = 0; j <= N; ++j) {\n        result = (result + dp[N][j]) % MOD;\n    }\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:34:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class HakoneEkiden {\n    static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        String[] changes = new String[N];\n        for (int i = 0; i < N; i++) {\n            changes[i] = scanner.next();\n        }\n\n        long[][] dp = new long[N + 1][N + 2];\n        dp[0][1] = 1;\n\n        for (int i = 0; i < N; i++) {\n            String s = changes[i];\n            if (s.equals(\"?\")) {\n                for (int j = 1; j <= N; j++) {\n                    if (dp[i][j] == 0) continue;\n                    for (int k = 1; k <= N; k++) {\n                        if (k != j) {\n                            dp[i + 1][k] = (dp[i + 1][k] + dp[i][j]) % MOD;\n                        }\n                    }\n                }\n            } else if (s.equals(\"U\")) {\n                for (int j = 1; j <= N; j++) {\n                    if (dp[i][j] == 0) continue;\n                    for (int k = j + 1; k <= N; k++) {\n                        dp[i + 1][k] = (dp[i + 1][k] + dp[i][j]) % MOD;\n                    }\n                }\n            } else if (s.equals(\"D\")) {\n                for (int j = 1; j <= N; j++) {\n                    if (dp[i][j] == 0) continue;\n                    for (int k = 1; k < j; k++) {\n                        dp[i + 1][k] = (dp[i + 1][k] + dp[i][j]) % MOD;\n                    }\n                }\n            }\n        }\n\n        long result = 0;\n        for (int j = 1; j <= N; j++) {\n            result = (result + dp[N][j]) % MOD;\n        }\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 21:35:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class HakoneEkiden {\n    private static final int MOD = 1_000_000_007;\n\n    public static int countPossibleOrders(int[] currentRanks, int[] previousRanks) {\n        int n = currentRanks.length;\n        \n        // Create inverse rank mapping for current and previous ranks\n        Map<Integer, Integer> currentRankMap = new HashMap<>();\n        Map<Integer, Integer> previousRankMap = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            currentRankMap.put(currentRanks[i], i);\n            previousRankMap.put(previousRanks[i], i);\n        }\n        \n        // Count inversions and track rank changes\n        int inversions = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int currentI = currentRankMap.get(previousRanks[i]);\n                int currentJ = currentRankMap.get(previousRanks[j]);\n                \n                if (currentI > currentJ) {\n                    inversions++;\n                }\n            }\n        }\n        \n        // Calculate possible permutations\n        long result = 1;\n        for (int i = 1; i <= inversions; i++) {\n            result = (result * i) % MOD;\n        }\n        \n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        int[] currentRanks = {3, 1, 4, 2, 5};\n        int[] previousRanks = {1, 2, 3, 4, 5};\n        \n        System.out.println(countPossibleOrders(currentRanks, previousRanks));\n    }\n}",
    "timestamp": "2025-08-05 21:35:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_TEAMS 10\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    int current_ranks[MAX_TEAMS];\n    int prev_ranks[MAX_TEAMS];\n    int rank_changes[MAX_TEAMS];\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &current_ranks[i]);\n    }\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &prev_ranks[i]);\n    }\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &rank_changes[i]);\n    }\n\n    long long ways = 1;\n    int used[MAX_TEAMS] = {0};\n\n    for (int i = 0; i < N; i++) {\n        int possible_positions = 0;\n        for (int j = 0; j < N; j++) {\n            if (!used[j] && \n                abs(current_ranks[i] - prev_ranks[j]) == rank_changes[i]) {\n                possible_positions++;\n            }\n        }\n\n        if (possible_positions == 0) {\n            ways = 0;\n            break;\n        }\n\n        ways = (ways * possible_positions) % MOD;\n\n        for (int j = 0; j < N; j++) {\n            if (!used[j] && \n                abs(current_ranks[i] - prev_ranks[j]) == rank_changes[i]) {\n                used[j] = 1;\n                break;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", ways);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:35:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int TEAMS = 10;\n\nlong long calculatePossibleOrders(vector<int>& currentRanks, vector<int>& previousRanks) {\n    vector<vector<long long>> dp(TEAMS + 1, vector<long long>(TEAMS + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= TEAMS; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (j > 0) {\n                dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % MOD;\n            }\n            if (j < i) {\n                dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD;\n            }\n        }\n    }\n\n    long long possibleOrders = 1;\n    for (int i = 0; i < TEAMS; i++) {\n        int change = currentRanks[i] - previousRanks[i];\n        if (change < 0) {\n            possibleOrders = (possibleOrders * dp[abs(change)][abs(change)]) % MOD;\n        } else if (change > 0) {\n            possibleOrders = (possibleOrders * dp[abs(change)][0]) % MOD;\n        }\n    }\n\n    return possibleOrders;\n}\n\nint main() {\n    vector<int> currentRanks(TEAMS);\n    vector<int> previousRanks(TEAMS);\n\n    for (int i = 0; i < TEAMS; i++) {\n        cin >> currentRanks[i];\n    }\n    for (int i = 0; i < TEAMS; i++) {\n        cin >> previousRanks[i];\n    }\n\n    long long result = calculatePossibleOrders(currentRanks, previousRanks);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:35:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_possible_orders(rank_changes, MOD=1000000007):\n    def factorial(n):\n        result = 1\n        for i in range(2, n + 1):\n            result = result * i % MOD\n        return result\n    \n    num_teams = len(rank_changes)\n    zero_count = rank_changes.count(0)\n    rank_change_counts = [0] * (num_teams + 1)\n\n    for change in rank_changes:\n        if change < 0 or change > num_teams:\n            return 0\n        rank_change_counts[change] += 1\n\n    dp = [0] * (zero_count + 1)\n    dp[0] = 1\n\n    for count in rank_change_counts:\n        if count > 0:\n            next_dp = [0] * (zero_count + 1)\n            for i in range(zero_count + 1):\n                if dp[i] > 0:\n                    if i + count <= zero_count:\n                        next_dp[i + count] = (next_dp[i + count] + dp[i] * factorial(count)) % MOD\n            dp = next_dp\n\n    return dp[zero_count]\n\nrank_changes = [0, 1, -1, 0, 2, -2, 0, 1, 0, 0] # Example input\nresult = count_possible_orders(rank_changes)\nprint(result)",
    "timestamp": "2025-08-13 07:03:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RelayStationOrders {\n\n    private static final int MOD = 1_000_000_007;\n    \n    public static long factorial(int n) {\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result = result * i % MOD;\n        }\n        return result;\n    }\n    \n    public static int possibleOrders(int[] currentPositions, int[] rankChanges) {\n        int n = currentPositions.length;\n        int[] previousPositions = new int[n];\n        List<Integer>[] changes = new List[n];\n\n        for (int i = 0; i < n; i++) {\n            previousPositions[i] = currentPositions[i] - rankChanges[i];\n            if (changes[previousPositions[i]] == null) {\n                changes[previousPositions[i]] = new ArrayList<>();\n            }\n            changes[previousPositions[i]].add(currentPositions[i]);\n        }\n        \n        long orders = 1;\n        \n        for (List<Integer> changeList : changes) {\n            if (changeList != null) {\n                orders = orders * factorial(changeList.size()) % MOD;\n            }\n        }\n        \n        return (int) orders;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        int[] currentPositions = {1, 2, 3, 4, 5};\n        int[] rankChanges = {1, 0, -1, 0, 1};\n        int result = possibleOrders(currentPositions, rankChanges);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 07:04:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#define MOD 1000000007\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 2; i <= n; i++) {\n        result = (result * i) % MOD;\n    }\n    return result;\n}\n\nlong long modular_exponentiation(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nlong long find_arrangements(int* ranks, int n) {\n    int inversion_counts[n];\n    for (int i = 0; i < n; i++) {\n        inversion_counts[i] = 0;\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (ranks[i] > ranks[j]) {\n                inversion_counts[ranks[i] - 1]++;\n            }\n        }\n    }\n\n    long long numerator = factorial(n);\n    long long denominator = 1;\n\n    for (int i = 0; i < n; i++) {\n        if (inversion_counts[i] > 0) {\n            denominator = (denominator * factorial(inversion_counts[i])) % MOD;\n        }\n    }\n\n    long long denom_inv = modular_exponentiation(denominator, MOD - 2, MOD);\n    return (numerator * denom_inv) % MOD;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int ranks[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &ranks[i]);\n    }\n\n    printf(\"%lld\\n\", find_arrangements(ranks, n));\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 07:04:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_ranking_orders(rankings_at_current_station, rankings_at_previous_station):\n    mod = 10**9 + 7\n    n = len(rankings_at_current_station)\n    factorial = [1] * (n + 1)\n    \n    for i in range(1, n + 1):\n        factorial[i] = (factorial[i-1] * i) % mod\n    \n    current_ranks = {team: rank for rank, team in enumerate(rankings_at_current_station)}\n    previous_ranks = {team: rank for rank, team in enumerate(rankings_at_previous_station)}\n    \n    inversions = 0\n    for team in current_ranks:\n        inversions += abs(current_ranks[team] - previous_ranks[team])\n    \n    return factorial[inversions // 2]\n\ndef main():\n    n = int(input())\n    current_station_rankings = list(map(int, input().split()))\n    previous_station_rankings = list(map(int, input().split()))\n    \n    result = count_ranking_orders(current_station_rankings, previous_station_rankings)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 07:04:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    N = int(input())\n    changes = []\n    for _ in range(N):\n        s = input().strip()\n        if s == '-':\n            changes.append(None)\n        else:\n            changes.append(int(s))\n    \n    # dp[i][j] : number of ways up to i-th runner, with j teams ranked higher than current team\n    dp_prev = [0] * (N + 2)\n    dp_prev[0] = 1\n    \n    for i in range(1, N):\n        change = changes[i-1]\n        dp_curr = [0] * (N + 2)\n        if change is None:\n            # Can be any relative order\n            total = sum(dp_prev) % MOD\n            for j in range(N + 1):\n                dp_curr[j] = total\n        elif change == 1:\n            # Current team moved up: previous rank was higher\n            for j in range(N + 1):\n                if j + 1 <= N:\n                    dp_curr[j] = dp_prev[j + 1]\n            # Prefix sum\n            for j in range(1, N + 1):\n                dp_curr[j] = (dp_curr[j] + dp_curr[j - 1]) % MOD\n        elif change == -1:\n            # Current team moved down: previous rank was lower\n            for j in range(N, -1, -1):\n                if j - 1 >= 0:\n                    dp_curr[j] = dp_prev[j - 1]\n            # Suffix sum\n            for j in range(N - 1, -1, -1):\n                dp_curr[j] = (dp_curr[j] + dp_curr[j + 1]) % MOD\n        elif change == 0:\n            # No change in rank\n            for j in range(N + 1):\n                dp_curr[j] = dp_prev[j]\n        dp_prev = dp_curr\n    \n    result = sum(dp_prev) % MOD\n    print(result)\n\nsolve()",
    "timestamp": "2025-08-13 07:04:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1000000007;\n\n// Function to calculate factorial % MOD\nlong long factorial(int n) {\n    long long result = 1;\n    for(int i = 2; i <= n; ++i) {\n        result = (result * i) % MOD;\n    }\n    return result;\n}\n\n// Function to calculate nCr % MOD\nlong long nCr(int n, int r) {\n    if(r > n) return 0;\n    long long numerator = factorial(n);\n    long long denominator = factorial(r) * factorial(n - r) % MOD;\n    \n    // Fermat's Little Theorem for inverse modulo\n    long long inverse = 1;\n    for(long long exponent = MOD - 2; exponent; exponent >>= 1) {\n        if(exponent & 1) {\n            inverse = inverse * denominator % MOD;\n        }\n        denominator = denominator * denominator % MOD;\n    }\n    return numerator * inverse % MOD;\n}\n\nint main() {\n    int N;\n    std::cin >> N; // Number of teams\n    \n    std::vector<int> changes(N);\n    for(int i = 0; i < N; ++i) {\n        std::cin >> changes[i]; // Change in rank from previous station\n    }\n    \n    std::vector<int> frequency(N);\n    for(int change : changes) {\n        if(change >= 0) {\n            frequency[change]++;\n        }\n    }\n    \n    long long result = 1;\n    for(int freq : frequency) {\n        if(freq > 0) {\n            result = (result * factorial(freq)) % MOD;\n        }\n    }\n\n    std::cout << result << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:35:44"
  }
]