[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 1000\n\ntypedef struct {\n    int x, y;\n} Rook;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint isAttacked(Rook rooks[], int n, int x, int y) {\n    for (int i = 0; i < n; i++) {\n        if (rooks[i].x == x || rooks[i].y == y)\n            return 1;\n    }\n    return 0;\n}\n\nint beatRooks(Rook rooks[], int n, int king_x, int king_y) {\n    int beaten = 0;\n    int visited[MAX_N][MAX_N] = {0};\n    \n    for (int i = 0; i < n; i++) {\n        if (rooks[i].x == king_x && rooks[i].y == king_y)\n            continue;\n        \n        int queue[MAX_N * MAX_N][3];\n        int front = 0, rear = 0;\n        \n        queue[rear][0] = king_x;\n        queue[rear][1] = king_y;\n        queue[rear][2] = 0;\n        rear++;\n        \n        memset(visited, 0, sizeof(visited));\n        visited[king_x + MAX_N/2][king_y + MAX_N/2] = 1;\n        \n        int found = 0;\n        while (front < rear) {\n            int x = queue[front][0];\n            int y = queue[front][1];\n            int moves = queue[front][2];\n            front++;\n            \n            if (x == rooks[i].x && y == rooks[i].y) {\n                beaten++;\n                found = 1;\n                break;\n            }\n            \n            for (int j = 0; j < 4; j++) {\n                int nx = x + dx[j];\n                int ny = y + dy[j];\n                \n                if (nx < 0 || ny < 0 || nx >= MAX_N || ny >= MAX_N)\n                    continue;\n                \n                if (visited[nx + MAX_N/2][ny + MAX_N/2])\n                    continue;\n                \n                if (isAttacked(rooks, n, nx, ny))\n                    continue;\n                \n                if (abs(nx - x) == 1 && abs(ny - y) == 1 && \n                    !(x == rooks[i].x && y == rooks[i].y))\n                    continue;\n                \n                queue[rear][0] = nx;\n                queue[rear][1] = ny;\n                queue[rear][2] = moves + 1;\n                rear++;\n                \n                visited[nx + MAX_N/2][ny + MAX_N/2] = 1;\n            }\n        }\n        \n        if (!found) {\n            beaten--;\n        }\n    }\n    \n    return beaten;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    Rook rooks[MAX_N];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &rooks[i].x, &rooks[i].y);\n    }\n    \n    int max_beaten = 0;\n    int min_moves = INT_MAX;\n    \n    for (int i = 0; i < n; i++) {\n        int beaten = beatRooks(rooks, n, rooks[i].x, rooks[i].y);\n        if (beaten > max_beaten || (beaten == max_beaten && rooks[i].x + rooks[i].y < min_moves)) {\n            max_beaten = beaten;\n            min_moves = rooks[i].x + rooks[i].y;\n        }\n    }\n    \n    printf(\"%d\\n\", max_beaten);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:26:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint compareX(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    return (p1->x - p2->x);\n}\n\nint compareY(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    return (p1->y - p2->y);\n}\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint countRooksInDirection(Point *rooks, int n, Point king, int dx, int dy) {\n    int count = 0;\n    int x = king.x + dx;\n    int y = king.y + dy;\n    while (1) {\n        int found = 0;\n        for (int i = 0; i < n; i++) {\n            if (rooks[i].x == x && rooks[i].y == y) {\n                count++;\n                found = 1;\n                break;\n            }\n        }\n        if (!found) break;\n        x += dx;\n        y += dy;\n    }\n    return count;\n}\n\nint maxRooksBeaten(Point *rooks, int n, Point king) {\n    int left = countRooksInDirection(rooks, n, king, -1, 0);\n    int right = countRooksInDirection(rooks, n, king, 1, 0);\n    int up = countRooksInDirection(rooks, n, king, 0, 1);\n    int down = countRooksInDirection(rooks, n, king, 0, -1);\n    return left + right + up + down;\n}\n\nint minMovesToMaxRooks(Point *rooks, int n, Point king, int maxRooks) {\n    if (maxRooks == 0) return 0;\n\n    Point *sortedX = (Point *)malloc(n * sizeof(Point));\n    Point *sortedY = (Point *)malloc(n * sizeof(Point));\n    for (int i = 0; i < n; i++) {\n        sortedX[i] = rooks[i];\n        sortedY[i] = rooks[i];\n    }\n    qsort(sortedX, n, sizeof(Point), compareX);\n    qsort(sortedY, n, sizeof(Point), compareY);\n\n    int minMoves = INT_MAX;\n\n    for (int i = 0; i < n; i++) {\n        if (sortedX[i].x < king.x) {\n            int moves = king.x - sortedX[i].x - 1;\n            Point newKing = {sortedX[i].x + 1, king.y};\n            if (maxRooksBeaten(rooks, n, newKing) == maxRooks) {\n                minMoves = min(minMoves, moves);\n            }\n        } else if (sortedX[i].x > king.x) {\n            int moves = sortedX[i].x - king.x - 1;\n            Point newKing = {sortedX[i].x - 1, king.y};\n            if (maxRooksBeaten(rooks, n, newKing) == maxRooks) {\n                minMoves = min(minMoves, moves);\n            }\n        }\n\n        if (sortedY[i].y < king.y) {\n            int moves = king.y - sortedY[i].y - 1;\n            Point newKing = {king.x, sortedY[i].y + 1};\n            if (maxRooksBeaten(rooks, n, newKing) == maxRooks) {\n                minMoves = min(minMoves, moves);\n            }\n        } else if (sortedY[i].y > king.y) {\n            int moves = sortedY[i].y - king.y - 1;\n            Point newKing = {king.x, sortedY[i].y - 1};\n            if (maxRooksBeaten(rooks, n, newKing) == maxRooks) {\n                minMoves = min(minMoves, moves);\n            }\n        }\n    }\n\n    free(sortedX);\n    free(sortedY);\n    return minMoves == INT_MAX ? 0 : minMoves;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Point *rooks = (Point *)malloc(n * sizeof(Point));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &rooks[i].x, &rooks[i].y);\n    }\n\n    for (int i = 0; i < n; i++) {\n        Point king = rooks[i];\n        Point *tempRooks = (Point *)malloc((n - 1) * sizeof(Point));\n        int idx = 0;\n        for (int j = 0; j < n; j++) {\n            if (j != i) {\n                tempRooks[idx++] = rooks[j];\n            }\n        }\n        int maxRooks = maxRooksBeaten(tempRooks, n - 1, king);\n        int moves = minMovesToMaxRooks(tempRooks, n - 1, king, maxRooks);\n        printf(\"%d\\n\", moves);\n        free(tempRooks);\n    }\n\n    free(rooks);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:27:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x_, int y_) : x(x_), y(y_) {}\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Point> rooks;\n    map<int, int> rowCount, colCount;\n    map<int, vector<int>> rowRooks, colRooks;\n\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        rooks.emplace_back(x, y);\n        rowCount[x]++;\n        colCount[y]++;\n        rowRooks[x].push_back(y);\n        colRooks[y].push_back(x);\n    }\n\n    for (auto &[x, ys] : rowRooks) {\n        sort(ys.begin(), ys.end());\n    }\n    for (auto &[y, xs] : colRooks) {\n        sort(xs.begin(), xs.end());\n    }\n\n    vector<int> res(N, INT_MAX);\n\n    for (int i = 0; i < N; ++i) {\n        int x = rooks[i].x, y = rooks[i].y;\n        int maxRooks = 0;\n\n        // Check horizontal and vertical directions\n        int left = 0, right = 0, up = 0, down = 0;\n\n        if (rowCount[x] > 1) {\n            auto &ys = rowRooks[x];\n            auto it = lower_bound(ys.begin(), ys.end(), y);\n            if (it != ys.begin()) left = 1;\n            if (it + 1 != ys.end()) right = 1;\n        }\n\n        if (colCount[y] > 1) {\n            auto &xs = colRooks[y];\n            auto it = lower_bound(xs.begin(), xs.end(), x);\n            if (it != xs.begin()) down = 1;\n            if (it + 1 != xs.end()) up = 1;\n        }\n\n        maxRooks = rowCount[x] + colCount[y] - 1 + left + right + up + down;\n\n        // Now find the minimal moves to beat maxRooks\n        int minMoves = INT_MAX;\n\n        // Check all possible maxRooks combinations\n        // Since the king can move in 4 directions, we need to find the minimal moves\n        // to cover the required rooks in row and column plus diagonals.\n\n        // The minimal moves is the maximum between the steps needed in row and column.\n        // For diagonals, it's the minimal steps to reach them.\n\n        int rowMin = INT_MAX, colMin = INT_MAX;\n\n        if (rowCount[x] > 1) {\n            auto &ys = rowRooks[x];\n            int leftDist = INT_MAX, rightDist = INT_MAX;\n            auto it = lower_bound(ys.begin(), ys.end(), y);\n            if (it != ys.begin()) {\n                leftDist = y - *(it - 1);\n            }\n            if (it != ys.end() && (it + 1) != ys.end()) {\n                rightDist = *(it + 1) - y;\n            }\n            rowMin = min(leftDist, rightDist);\n        }\n\n        if (colCount[y] > 1) {\n            auto &xs = colRooks[y];\n            int downDist = INT_MAX, upDist = INT_MAX;\n            auto it = lower_bound(xs.begin(), xs.end(), x);\n            if (it != xs.begin()) {\n                downDist = x - *(it - 1);\n            }\n            if (it != xs.end() && (it + 1) != xs.end()) {\n                upDist = *(it + 1) - x;\n            }\n            colMin = min(downDist, upDist);\n        }\n\n        int diagonalMin = INT_MAX;\n        if (left && down) diagonalMin = min(diagonalMin, min(y - (rowRooks[x][lower_bound(rowRooks[x].begin(), rowRooks[x].end(), y) - rowRooks[x].begin() - 1]), \n                                                           x - (colRooks[y][lower_bound(colRooks[y].begin(), colRooks[y].end(), x) - colRooks[y].begin() - 1])));\n        if (left && up) diagonalMin = min(diagonalMin, min(y - (rowRooks[x][lower_bound(rowRooks[x].begin(), rowRooks[x].end(), y) - rowRooks[x].begin() - 1]), \n                                                          (colRooks[y][lower_bound(colRooks[y].begin(), colRooks[y].end(), x) - colRooks[y].begin() + 1]) - x));\n        if (right && down) diagonalMin = min(diagonalMin, min((rowRooks[x][lower_bound(rowRooks[x].begin(), rowRooks[x].end(), y) - rowRooks[x].begin() + 1]) - y, \n                                                            x - (colRooks[y][lower_bound(colRooks[y].begin(), colRooks[y].end(), x) - colRooks[y].begin() - 1])));\n        if (right && up) diagonalMin = min(diagonalMin, min((rowRooks[x][lower_bound(rowRooks[x].begin(), rowRooks[x].end(), y) - rowRooks[x].begin() + 1]) - y, \n                                                          (colRooks[y][lower_bound(colRooks[y].begin(), colRooks[y].end(), x) - colRooks[y].begin() + 1]) - x));\n\n        if (rowMin == INT_MAX && colMin == INT_MAX) {\n            minMoves = 0;\n        } else if (rowMin == INT_MAX) {\n            minMoves = colMin;\n        } else if (colMin == INT_MAX) {\n            minMoves = rowMin;\n        } else {\n            minMoves = max(rowMin, colMin);\n        }\n\n        if (diagonalMin != INT_MAX) {\n            int total = max(minMoves, diagonalMin);\n            minMoves = min(minMoves, total);\n        }\n\n        res[i] = minMoves;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        cout << res[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:29:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RookKingProblem {\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        Point[] rooks = new Point[N];\n        Map<Integer, Integer> xCount = new HashMap<>();\n        Map<Integer, Integer> yCount = new HashMap<>();\n\n        for (int i = 0; i < N; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            rooks[i] = new Point(x, y);\n            xCount.put(x, xCount.getOrDefault(x, 0) + 1);\n            yCount.put(y, yCount.getOrDefault(y, 0) + 1);\n        }\n\n        for (int i = 0; i < N; i++) {\n            Point king = rooks[i];\n            int maxRooks = 0;\n            int minMoves = Integer.MAX_VALUE;\n\n            // Check all four diagonal directions\n            int[][] directions = {{1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\n            for (int[] dir : directions) {\n                int dx = dir[0];\n                int dy = dir[1];\n                int x = king.x + dx;\n                int y = king.y + dy;\n                int rooksBeaten = 0;\n                int moves = 1;\n\n                while (true) {\n                    boolean found = false;\n                    for (Point rook : rooks) {\n                        if (rook.x == x && rook.y == y) {\n                            rooksBeaten++;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) break;\n                    x += dx;\n                    y += dy;\n                    moves++;\n                }\n\n                if (rooksBeaten > maxRooks) {\n                    maxRooks = rooksBeaten;\n                    minMoves = moves - 1;\n                } else if (rooksBeaten == maxRooks && moves - 1 < minMoves) {\n                    minMoves = moves - 1;\n                }\n            }\n\n            // Check horizontal and vertical directions (but no rooks can be beaten)\n            int xRooks = xCount.get(king.x) - 1;\n            int yRooks = yCount.get(king.y) - 1;\n            if (xRooks > 0 || yRooks > 0) {\n                if (maxRooks == 0) {\n                    maxRooks = Math.max(xRooks, yRooks);\n                    minMoves = 0;\n                }\n            }\n\n            System.out.print(minMoves == Integer.MAX_VALUE ? 0 : minMoves);\n            if (i < N - 1) System.out.print(\" \");\n        }\n        System.out.println();\n    }\n}",
    "timestamp": "2025-08-05 22:29:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RookBeating {\n    public static int solve(int[][] rooks) {\n        int n = rooks.length;\n        int maxBeaten = 0;\n        int bestMoves = Integer.MAX_VALUE;\n\n        for (int k = 0; k < n; k++) {\n            int[] beaten = new int[n];\n            int kingX = rooks[k][0];\n            int kingY = rooks[k][1];\n            beaten[k] = 1;\n            \n            int currentBeaten = 1;\n            int moves = 0;\n            \n            Set<Integer> rowsAttacked = new HashSet<>();\n            Set<Integer> colsAttacked = new HashSet<>();\n            rowsAttacked.add(kingX);\n            colsAttacked.add(kingY);\n            \n            for (int i = 0; i < n; i++) {\n                if (i == k) continue;\n                \n                int x = rooks[i][0];\n                int y = rooks[i][1];\n                \n                if (!rowsAttacked.contains(x) && !colsAttacked.contains(y)) {\n                    int dx = Math.abs(kingX - x);\n                    int dy = Math.abs(kingY - y);\n                    \n                    if (dx + dy <= 1) {\n                        beaten[i] = 1;\n                        currentBeaten++;\n                        moves++;\n                        rowsAttacked.add(x);\n                        colsAttacked.add(y);\n                        kingX = x;\n                        kingY = y;\n                    } else {\n                        int movesToRook = dx + dy - 1;\n                        moves += movesToRook;\n                        beaten[i] = 1;\n                        currentBeaten++;\n                        rowsAttacked.add(x);\n                        colsAttacked.add(y);\n                        kingX = x;\n                        kingY = y;\n                    }\n                }\n            }\n            \n            if (currentBeaten > maxBeaten || \n                (currentBeaten == maxBeaten && moves < bestMoves)) {\n                maxBeaten = currentBeaten;\n                bestMoves = moves;\n            }\n        }\n        \n        return bestMoves;\n    }\n    \n    public static void main(String[] args) {\n        int[][] rooks = {{0, 0}, {1, 2}, {2, 1}, {3, 3}};\n        System.out.println(solve(rooks));\n    }\n}",
    "timestamp": "2025-08-05 22:29:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\nint solve(vector<pair<int, int>>& rooks) {\n    int n = rooks.size();\n    int max_beaten = 0;\n    int min_moves = INT_MAX;\n\n    for (int k = 0; k < n; k++) {\n        set<int> rows, cols;\n        for (int i = 0; i < n; i++) {\n            if (i != k) {\n                rows.insert(rooks[i].first);\n                cols.insert(rooks[i].second);\n            }\n        }\n\n        vector<pair<int, int>> remaining_rooks;\n        for (int i = 0; i < n; i++) {\n            if (i != k) {\n                remaining_rooks.push_back(rooks[i]);\n            }\n        }\n\n        int beaten = 0;\n        int moves = 0;\n        int curr_x = rooks[k].first;\n        int curr_y = rooks[k].second;\n\n        while (!remaining_rooks.empty()) {\n            int best_dist = INT_MAX;\n            int best_idx = -1;\n\n            for (int i = 0; i < remaining_rooks.size(); i++) {\n                int dx = abs(curr_x - remaining_rooks[i].first);\n                int dy = abs(curr_y - remaining_rooks[i].second);\n\n                if ((dx == 0 || dy == 0 || dx == dy) && \n                    !rows.count(remaining_rooks[i].first) && \n                    !cols.count(remaining_rooks[i].second)) {\n                    int dist = max(dx, dy);\n                    if (dist < best_dist) {\n                        best_dist = dist;\n                        best_idx = i;\n                    }\n                }\n            }\n\n            if (best_idx == -1) break;\n\n            moves += best_dist;\n            curr_x = remaining_rooks[best_idx].first;\n            curr_y = remaining_rooks[best_idx].second;\n\n            rows.erase(curr_x);\n            cols.erase(curr_y);\n            remaining_rooks.erase(remaining_rooks.begin() + best_idx);\n            beaten++;\n        }\n\n        if (beaten > max_beaten || (beaten == max_beaten && moves < min_moves)) {\n            max_beaten = beaten;\n            min_moves = moves;\n        }\n    }\n\n    return min_moves;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> rooks(n);\n    \n    for (int i = 0; i < n; i++) {\n        cin >> rooks[i].first >> rooks[i].second;\n    }\n\n    int result = solve(rooks);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:29:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef minimum_moves_to_max_rooks(N, rooks):\n    def bfs_replace_and_move(x, y, rooks_set):\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        attack_dirs = [(-1, -1), (-1, 1), (1, -1), (1, 1)]\n        queue = deque([(x, y, 0, set())])\n        max_beaten = 0\n        min_moves = float('inf')\n\n        while queue:\n            curr_x, curr_y, moves, beaten_rooks = queue.popleft()\n\n            # Count number of beaten rooks\n            currently_beaten = len(beaten_rooks)\n            if currently_beaten > max_beaten:\n                max_beaten = currently_beaten\n                min_moves = moves\n            elif currently_beaten == max_beaten:\n                min_moves = min(min_moves, moves)\n\n            # Try to move vertically or horizontally\n            for dx, dy in directions:\n                nx, ny = curr_x + dx, curr_y + dy\n                if (nx, ny) not in rooks_set and not any((nx == rx or ny == ry) for rx, ry in rooks_set):\n                    queue.append((nx, ny, moves + 1, beaten_rooks.copy()))\n\n            # Try to beat rooks diagonally\n            for dx, dy in attack_dirs:\n                ax, ay = curr_x + dx, curr_y + dy\n                if (ax, ay) in rooks_set and (ax, ay) not in beaten_rooks:\n                    new_beaten_rooks = beaten_rooks.copy()\n                    new_beaten_rooks.add((ax, ay))\n                    queue.append((ax, ay, moves + 1, new_beaten_rooks))\n\n        return min_moves, max_beaten\n\n    best_moves = float('inf')\n    max_rooks_beaten = 0\n\n    rooks_set = set(rooks)\n    for x, y in rooks:\n        moves, rooks_beaten = bfs_replace_and_move(x, y, rooks_set)\n        if rooks_beaten > max_rooks_beaten:\n            best_moves = moves\n            max_rooks_beaten = rooks_beaten\n        elif rooks_beaten == max_rooks_beaten:\n            best_moves = min(best_moves, moves)\n\n    return best_moves, max_rooks_beaten\n\n# Example usage\nN = 3\nrooks = [(1, 1), (3, 4), (5, 6)]\nprint(minimum_moves_to_max_rooks(N, rooks))",
    "timestamp": "2025-08-13 10:52:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.Point;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class SuperKing {\n    private static final int[][] DIRECTIONS = {\n        {1, 0}, {-1, 0}, {0, 1}, {0, -1}, // horizontal & vertical\n        {1, 1}, {-1, -1}, {1, -1}, {-1, 1} // diagonal\n    };\n\n    public int minMovesToBeatMaxRooks(int[][] rooks) {\n        int n = rooks.length;\n        int maxRooksBeaten = 0;\n        int minMoves = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < n; i++) {\n            Point[] rookList = new Point[n];\n            for (int j = 0; j < n; j++) {\n                rookList[j] = new Point(rooks[j][0], rooks[j][1]);\n            }\n\n            Point kingStart = rookList[i];\n            Set<Point> beaten = new HashSet<>();\n            beaten.add(kingStart);\n            int rooksBeaten = 1;\n            int moves = findMaxCapturePath(kingStart, rookList, beaten, rooksBeaten, 0);\n\n            if (rooksBeaten > maxRooksBeaten || (rooksBeaten == maxRooksBeaten && moves < minMoves)) {\n                maxRooksBeaten = rooksBeaten;\n                minMoves = moves;\n            }\n        }\n\n        return minMoves == Integer.MAX_VALUE ? -1 : minMoves;\n    }\n\n    private int findMaxCapturePath(Point king, Point[] rooks, Set<Point> beaten, int rooksBeaten, int currentMoves) {\n        int maxBeaten = rooksBeaten;\n        int minMoves = Integer.MAX_VALUE;\n\n        for (int[] dir : DIRECTIONS) {\n            for (int i = 1; i <= rooks.length; i++) {\n                Point newPos = new Point(king.x + dir[0] * i, king.y + dir[1] * i);\n                if (dir[0] != 0 && dir[1] != 0 && i > 1) break; // can't move diagonally to empty\n\n                boolean canCapture = false;\n                for (Point rook : rooks) {\n                    if (!beaten.contains(rook) && rook.equals(newPos)) {\n                        canCapture = true;\n                        break;\n                    }\n                }\n\n                if (canCapture) {\n                    beaten.add(newPos);\n                    int path = findMaxCapturePath(newPos, rooks, beaten, rooksBeaten + 1, currentMoves + i);\n                    if (path < minMoves || (path == minMoves && rooksBeaten + 1 > maxBeaten)) {\n                        maxBeaten = rooksBeaten + 1;\n                        minMoves = path;\n                    }\n                    beaten.remove(newPos);\n                }\n\n                if (dir[0] == 0 || dir[1] == 0) break; // stop exploring this direction if it's an empty cell\n            }\n        }\n\n        return minMoves == Integer.MAX_VALUE ? currentMoves : minMoves;\n    }\n}",
    "timestamp": "2025-08-13 10:52:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Position;\n\nint canBeat(Position king, Position rook) {\n    return abs(king.x - rook.x) <= 1 && abs(king.y - rook.y) <= 1;\n}\n\nint isAttacked(Position king, Position rooks[], int n) {\n    for (int i = 0; i < n; i++) {\n        if (king.x == rooks[i].x || king.y == rooks[i].y)\n            return 1;\n    }\n    return 0;\n}\n\nint maxRooks(Position king, Position rooks[], int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (canBeat(king, rooks[i]) && !isAttacked(king, rooks, n))\n            count++;\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Position rooks[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &rooks[i].x, &rooks[i].y);\n    }\n\n    int minMoves = n; \n    int maxBeaten = 0;\n    for (int i = 0; i < n; i++) {\n        Position king = rooks[i];\n        int beaten = maxRooks(king, rooks, n);\n        if (beaten > maxBeaten) {\n            maxBeaten = beaten;\n            minMoves = 1;\n        } else if (beaten == maxBeaten) {\n            minMoves = (minMoves < 1) ? minMoves : 1;\n        }\n    }\n\n    printf(\"%d %d\\n\", minMoves, maxBeaten);\n    return 0;\n}",
    "timestamp": "2025-08-13 10:52:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minMovesForMaxCaptures(positions) {\n    const directions = [\n        [1, 0], [-1, 0], [0, 1], [0, -1], // horizontal and vertical moves\n        [1, 1], [-1, -1], [1, -1], [-1, 1] // diagonal captures\n    ];\n    \n    function isValidMove(x, y, visited, rooksSet) {\n        return !visited.has(`${x},${y}`) && !rooksSet.has(`${x},${y}`);\n    }\n    \n    function bfs(startX, startY, rooksSet) {\n        let queue = [{ x: startX, y: startY, steps: 0, captures: 0 }];\n        let visited = new Set();\n        visited.add(`${startX},${startY}`);\n        let maxCaptures = 0, minSteps = Infinity;\n\n        while (queue.length > 0) {\n            let { x, y, steps, captures } = queue.shift();\n            \n            if (captures > maxCaptures || (captures === maxCaptures && steps < minSteps)) {\n                maxCaptures = captures;\n                minSteps = steps;\n            } \n            \n            for (let [dx, dy] of directions) {\n                let nx = x + dx, ny = y + dy;\n                let coord = `${nx},${ny}`;\n                \n                if (rooksSet.has(coord)) {\n                    let newRooksSet = new Set(rooksSet);\n                    newRooksSet.delete(coord);\n                    queue.push({ x: nx, y: ny, steps: steps + 1, captures: captures + 1 });\n                } else if (Math.abs(dx) !== Math.abs(dy) && isValidMove(nx, ny, visited, rooksSet)) {\n                    visited.add(coord);\n                    queue.push({ x: nx, y: ny, steps: steps + 1, captures });\n                }\n            }\n        }\n        \n        return { maxCaptures, minSteps };\n    }\n    \n    let result = { maxCaptures: 0, minSteps: Infinity };\n    for (let i = 0; i < positions.length; i++) {\n        let rooksSet = new Set(positions.map(([x, y]) => `${x},${y}`));\n        let [startX, startY] = positions[i];\n        let { maxCaptures, minSteps } = bfs(startX, startY, rooksSet);\n        if (maxCaptures > result.maxCaptures || \n           (maxCaptures === result.maxCaptures && minSteps < result.minSteps)) {\n            result.maxCaptures = maxCaptures;\n            result.minSteps = minSteps;\n        }\n    }\n    \n    return result.minSteps;\n}\n\n// Example usage:\n// let positions = [[0, 0], [2, 2], [5, 6], [6, 5]];\n// console.log(minMovesForMaxCaptures(positions));",
    "timestamp": "2025-08-13 10:52:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(rooks):\n    n = len(rooks)\n    max_rooks_beaten = 0\n    min_moves = float('inf')\n\n    for replace_idx in range(n):\n        beaten_rooks, moves = find_max_rooks_beaten(rooks, replace_idx)\n        if beaten_rooks > max_rooks_beaten or (beaten_rooks == max_rooks_beaten and moves < min_moves):\n            max_rooks_beaten = beaten_rooks\n            min_moves = moves\n\n    return max_rooks_beaten, min_moves\n\ndef find_max_rooks_beaten(rooks, replace_idx):\n    board = {}\n    for i, (x, y) in enumerate(rooks):\n        if i != replace_idx:\n            board[(x, y)] = True\n\n    king_x, king_y = rooks[replace_idx]\n    beaten = set([(king_x, king_y)])\n    moves = 0\n\n    directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (1,-1), (-1,1), (-1,-1)]\n    queue = [(king_x, king_y, set([(king_x, king_y)]), 0)]\n\n    while queue:\n        x, y, visited, curr_moves = queue.pop(0)\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in board and (nx, ny) not in visited:\n                if (nx, ny) in [(rx, ry) for (rx, ry) in rooks if rooks.index((rx, ry)) != replace_idx]:\n                    new_visited = visited.copy()\n                    new_visited.add((nx, ny))\n                    queue.append((nx, ny, new_visited, curr_moves + 1))\n                    beaten.add((nx, ny))\n                elif (dx, dy) in [(0,1), (0,-1), (1,0), (-1,0)]:\n                    queue.append((nx, ny, visited.copy(), curr_moves + 1))\n\n    return len(beaten) - 1, moves\n\ndef main():\n    n = int(input())\n    rooks = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        rooks.append((x, y))\n\n    max_beaten, min_moves = solve(rooks)\n    print(max_beaten, min_moves)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 10:52:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumMovesToBeatRooks(rooks) {\n    const n = rooks.length;\n    let maxBeaten = 0;\n    let minMoves = Infinity;\n\n    for (let replaceIndex = 0; replaceIndex < n; replaceIndex++) {\n        const kingPos = rooks[replaceIndex];\n        const remainingRooks = rooks.filter((_, idx) => idx !== replaceIndex);\n        const [beaten, moves] = beatenRooksFromPosition(kingPos, remainingRooks);\n\n        if (beaten > maxBeaten || (beaten === maxBeaten && moves < minMoves)) {\n            maxBeaten = beaten;\n            minMoves = moves;\n        }\n    }\n\n    return [maxBeaten, minMoves];\n}\n\nfunction beatenRooksFromPosition(kingPos, rooks) {\n    const [kingX, kingY] = kingPos;\n    const attackedRows = new Set();\n    const attackedCols = new Set();\n    rooks.forEach(([x, y]) => {\n        attackedRows.add(x);\n        attackedCols.add(y);\n    });\n\n    const beaten = new Set();\n    const visited = new Set();\n    const queue = [[kingX, kingY, 0]];\n    visited.add(`${kingX},${kingY}`);\n\n    const directions = [\n        [0, 1], [0, -1], [1, 0], [-1, 0],\n        [1, 1], [1, -1], [-1, 1], [-1, -1]\n    ];\n\n    while (queue.length) {\n        const [x, y, moves] = queue.shift();\n\n        rooks.forEach(([rx, ry], idx) => {\n            if (!beaten.has(idx) && x === rx && y === ry) {\n                beaten.add(idx);\n            }\n        });\n\n        for (const [dx, dy] of directions) {\n            const newX = x + dx;\n            const newY = y + dy;\n            const key = `${newX},${newY}`;\n\n            if (visited.has(key)) continue;\n\n            const isDiagonal = dx !== 0 && dy !== 0;\n            const rookAttacking = attackedRows.has(newX) || attackedCols.has(newY);\n\n            if ((!isDiagonal || rooks.some(([rx, ry]) => rx === newX && ry === newY)) && !rookAttacking) {\n                queue.push([newX, newY, moves + 1]);\n                visited.add(key);\n            }\n        }\n    }\n\n    return [beaten.size, queue[queue.length - 1]?.[2] || 0];\n}",
    "timestamp": "2025-08-13 10:53:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    X = []\n    Y = []\n    x_to_ys = {}\n    y_to_xs = {}\n    \n    for _ in range(N):\n        x, y = map(int, input[ptr:ptr+2])\n        ptr += 2\n        X.append(x)\n        Y.append(y)\n        if x not in x_to_ys:\n            x_to_ys[x] = []\n        x_to_ys[x].append(y)\n        if y not in y_to_xs:\n            y_to_xs[y] = []\n        y_to_xs[y].append(x)\n    \n    # Sort the lists for binary search\n    for x in x_to_ys:\n        x_to_ys[x].sort()\n    for y in y_to_xs:\n        y_to_xs[y].sort()\n    \n    res = []\n    \n    for i in range(N):\n        x, y = X[i], Y[i]\n        # The king starts at (x, y)\n        # We need to find all reachable rooks via BFS\n        visited = set()\n        q = deque()\n        q.append((x, y))\n        visited.add((x, y))\n        count = 0\n        \n        while q:\n            cx, cy = q.popleft()\n            # Check if (cx, cy) is a rook (other than the initial one)\n            # Since initial rook is replaced by king, it's not there anymore\n            # So any rook at (cx, cy) is a target\n            # But since initial rook is removed, we need to check if it's any other rook\n            # So we need to check if (cx, cy) is in the list of rooks (excluding the current one)\n            # So for all rooks j != i, if (X[j], Y[j]) == (cx, cy), count it\n            # But this is O(N) per check, which is too slow\n            # So we need a better way\n            # Alternative: precompute a set of all rook positions\n            pass\n        \n        # Alternative approach: BFS and count all reachable rooks\n        # But need to handle the constraints of not moving into attacked squares\n        # So during BFS, for each move, we need to ensure the new position is not under attack\n        # So for any new position (nx, ny), it should not share x or y with any rook (except possibly the initial one)\n        # But the initial rook is removed, so no rook shares x or y with any other rook\n        # So the only constraints are:\n        # - The king cannot move to a cell that shares x or y with any rook (except the initial one, which is removed)\n        # So during BFS, for any move to (nx, ny), we need to ensure that no rook has X_j = nx or Y_j = ny (other than the initial rook)\n        # So for each (nx, ny), we can check if nx is in x_to_ys (excluding the initial x) or ny is in y_to_xs (excluding the initial y)\n        # But initial x and y are no longer occupied, so any other rook sharing x or y is a blocker\n        \n        # So the BFS is constrained to cells (nx, ny) where:\n        # - nx is not in x_to_ys (except possibly x)\n        # - ny is not in y_to_xs (except possibly y)\n        # But x is not in x_to_ys anymore (since the initial rook is removed)\n        # Similarly, y is not in y_to_xs anymore\n        # So the condition simplifies to:\n        # - nx is not in x_to_ys\n        # - ny is not in y_to_xs\n        # So the king can move freely in any direction as long as the new cell's x and y are not occupied by any rook\n        \n        # Now, the BFS can proceed, and whenever the king reaches a cell (a, b) where there is a rook (i.e., (a, b) is in the list of rooks except the initial one), we count it\n        \n        # So first, create a set of all rook positions except the current one\n        rook_pos = set()\n        for j in range(N):\n            if j != i:\n                rook_pos.add((X[j], Y[j]))\n        \n        visited = set()\n        q = deque()\n        q.append((x, y))\n        visited.add((x, y))\n        count = 0\n        \n        while q:\n            cx, cy = q.popleft()\n            if (cx, cy) in rook_pos:\n                count += 1\n            # Explore 4 directions (horizontal/vertical moves)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx = cx + dx\n                ny = cy + dy\n                if (nx, ny) not in visited:\n                    # Check if nx is not in x_to_ys (i.e., no rook has X = nx)\n                    # and ny is not in y_to_xs (i.e., no rook has Y = ny)\n                    if nx not in x_to_ys and ny not in y_to_xs:\n                        visited.add((nx, ny))\n                        q.append((nx, ny))\n            # Check diagonal attacks (no move, just beat)\n            for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n                nx = cx + dx\n                ny = cy + dy\n                if (nx, ny) in rook_pos and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    count += 1\n        \n        res.append(count)\n    \n    # Now, for each i, we need the minimal steps to achieve max_count\n    # But the problem asks for each rook, the minimal moves to beat the maximum number of rooks\n    # But the BFS above counts the maximum number of rooks beatable (count), and the moves are implicit\n    # So for each i, the answer is the minimal steps to beat 'count' rooks\n    # But the BFS gives the count, but not the minimal steps to achieve it\n    # So we need to modify the BFS to track the steps and find the minimal steps to beat the maximum count\n    \n    # So the initial approach is incomplete. We need to find for each i, the minimal steps to beat as many rooks as possible\n    \n    # Alternative approach: For each i, perform BFS and keep track of the number of rooks beaten and the steps taken\n    # The goal is to maximize the number of rooks beaten, and among those, minimize the steps\n    \n    # So during BFS, we need to track for each state (position, rooks_beaten), the minimal steps to reach it\n    # Then, after BFS completes, we find the maximal rooks_beaten, and the minimal steps to achieve it\n    \n    # So let's reimplement the BFS for each i\n    \n    res = []\n    for i in range(N):\n        x, y = X[i], Y[i]\n        rook_pos = set()\n        for j in range(N):\n            if j != i:\n                rook_pos.add((X[j], Y[j]))\n        \n        # BFS state: (x, y, rooks_beaten), steps\n        # We can use a priority queue based on steps, but since BFS explores in order of steps, deque is fine\n        visited = {}\n        q = deque()\n        q.append((x, y, 0))\n        visited[(x, y, 0)] = 0\n        max_rooks = 0\n        min_steps = 0\n        \n        while q:\n            cx, cy, rooks = q.popleft()\n            current_steps = visited[(cx, cy, rooks)]\n            if rooks > max_rooks:\n                max_rooks = rooks\n                min_steps = current_steps\n            elif rooks == max_rooks:\n                if current_steps < min_steps:\n                    min_steps = current_steps\n            \n            # Explore 4 directions (horizontal/vertical moves)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx = cx + dx\n                ny = cy + dy\n                new_rooks = rooks\n                if (nx, ny) in rook_pos:\n                    new_rooks = rooks + 1\n                if (nx, ny, new_rooks) not in visited:\n                    # Check if nx is not in x_to_ys and ny is not in y_to_xs\n                    if nx not in x_to_ys and ny not in y_to_xs:\n                        visited[(nx, ny, new_rooks)] = current_steps + 1\n                        q.append((nx, ny, new_rooks))\n            # Check diagonal attacks (no move, just beat)\n            for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n                nx = cx + dx\n                ny = cy + dy\n                if (nx, ny) in rook_pos:\n                    new_rooks = rooks + 1\n                    if (nx, ny, new_rooks) not in visited:\n                        visited[(nx, ny, new_rooks)] = current_steps\n                        q.appendleft((nx, ny, new_rooks))  # prioritize beating\n        \n        res.append(min_steps if max_rooks > 0 else 0)\n    \n    print('\\n'.join(map(str, res)))\n\nsolve()",
    "timestamp": "2025-08-13 10:54:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, X, Y) {\n    const xMap = new Map();\n    const yMap = new Map();\n    const posMap = new Map();\n\n    for (let i = 0; i < N; i++) {\n        const x = X[i];\n        const y = Y[i];\n        if (!xMap.has(x)) xMap.set(x, []);\n        xMap.get(x).push(y);\n        if (!yMap.has(y)) yMap.set(y, []);\n        yMap.get(y).push(x);\n        posMap.set(`${x},${y}`, i);\n    }\n\n    const sortedX = Array.from(xMap.keys()).sort((a, b) => a - b);\n    const sortedY = Array.from(yMap.keys()).sort((a, b) => a - b);\n\n    const xToIndex = new Map();\n    const yToIndex = new Map();\n    sortedX.forEach((x, idx) => xToIndex.set(x, idx));\n    sortedY.forEach((y, idx) => yToIndex.set(y, idx));\n\n    const xLeft = new Array(sortedX.length).fill(-Infinity);\n    const xRight = new Array(sortedX.length).fill(Infinity);\n    for (let i = 1; i < sortedX.length; i++) {\n        xLeft[i] = sortedX[i - 1];\n    }\n    for (let i = 0; i < sortedX.length - 1; i++) {\n        xRight[i] = sortedX[i + 1];\n    }\n\n    const yLeft = new Array(sortedY.length).fill(-Infinity);\n    const yRight = new Array(sortedY.length).fill(Infinity);\n    for (let i = 1; i < sortedY.length; i++) {\n        yLeft[i] = sortedY[i - 1];\n    }\n    for (let i = 0; i < sortedY.length - 1; i++) {\n        yRight[i] = sortedY[i + 1];\n    }\n\n    const res = new Array(N).fill(Infinity);\n\n    for (let i = 0; i < N; i++) {\n        const x = X[i];\n        const y = Y[i];\n        const xIdx = xToIndex.get(x);\n        const yIdx = yToIndex.get(y);\n\n        const leftX = xLeft[xIdx];\n        const rightX = xRight[xIdx];\n        const leftY = yLeft[yIdx];\n        const rightY = yRight[yIdx];\n\n        let maxRooks = 0;\n        let minMoves = Infinity;\n\n        // Check horizontal and vertical directions\n        const directions = [\n            [leftX, y, x - leftX, 0],  // left\n            [rightX, y, rightX - x, 0], // right\n            [x, leftY, y - leftY, 0],   // down\n            [x, rightY, rightY - y, 0]  // up\n        ];\n\n        for (const [nx, ny, moves, _] of directions) {\n            if (nx === -Infinity || nx === Infinity || ny === -Infinity || ny === Infinity) continue;\n            if (posMap.has(`${nx},${ny}`)) {\n                const count = 1;\n                if (count > maxRooks || (count === maxRooks && moves < minMoves)) {\n                    maxRooks = count;\n                    minMoves = moves;\n                }\n            }\n        }\n\n        // Check diagonal directions\n        const diagonals = [\n            [leftX, leftY, Math.max(x - leftX, y - leftY)],  // bottom-left\n            [leftX, rightY, Math.max(x - leftX, rightY - y)], // top-left\n            [rightX, leftY, Math.max(rightX - x, y - leftY)], // bottom-right\n            [rightX, rightY, Math.max(rightX - x, rightY - y)]  // top-right\n        ];\n\n        for (const [nx, ny, moves] of diagonals) {\n            if (nx === -Infinity || nx === Infinity || ny === -Infinity || ny === Infinity) continue;\n            if (posMap.has(`${nx},${ny}`)) {\n                const count = 1;\n                if (count > maxRooks || (count === maxRooks && moves < minMoves)) {\n                    maxRooks = count;\n                    minMoves = moves;\n                }\n            }\n        }\n\n        // Check if multiple rooks can be beaten in a line\n        const xList = xMap.get(x);\n        const yList = yMap.get(y);\n\n        // Vertical line (same x)\n        if (xList.length > 1) {\n            const idx = xList.indexOf(y);\n            const left = idx > 0 ? xList[idx - 1] : -Infinity;\n            const right = idx < xList.length - 1 ? xList[idx + 1] : Infinity;\n            if (left !== -Infinity) {\n                const moves = y - left;\n                const count = 1;\n                if (count > maxRooks || (count === maxRooks && moves < minMoves)) {\n                    maxRooks = count;\n                    minMoves = moves;\n                }\n            }\n            if (right !== Infinity) {\n                const moves = right - y;\n                const count = 1;\n                if (count > maxRooks || (count === maxRooks && moves < minMoves)) {\n                    maxRooks = count;\n                    minMoves = moves;\n                }\n            }\n        }\n\n        // Horizontal line (same y)\n        if (yList.length > 1) {\n            const idx = yList.indexOf(x);\n            const left = idx > 0 ? yList[idx - 1] : -Infinity;\n            const right = idx < yList.length - 1 ? yList[idx + 1] : Infinity;\n            if (left !== -Infinity) {\n                const moves = x - left;\n                const count = 1;\n                if (count > maxRooks || (count === maxRooks && moves < minMoves)) {\n                    maxRooks = count;\n                    minMoves = moves;\n                }\n            }\n            if (right !== Infinity) {\n                const moves = right - x;\n                const count = 1;\n                if (count > maxRooks || (count === maxRooks && moves < minMoves)) {\n                    maxRooks = count;\n                    minMoves = moves;\n                }\n            }\n        }\n\n        if (maxRooks === 0) {\n            res[i] = 0;\n        } else {\n            res[i] = minMoves;\n        }\n    }\n\n    return res;\n}",
    "timestamp": "2025-08-13 10:54:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct Position {\n    int x, y, moves;\n    set<pair<int, int>> beaten;\n\n    Position(int x, int y, int moves, const set<pair<int, int>>& beaten) \n        : x(x), y(y), moves(moves), beaten(beaten) {}\n};\n\npair<int, int> directions[8] = { \n    {1, 0}, {-1, 0}, {0, 1}, {0, -1}, \n    {1, 1}, {-1, 1}, {1, -1}, {-1, -1} \n};\n\nint minMovesToBeatMaxRooks(int N, vector<pair<int, int>>& rooks) {\n    int minMoves = INT_MAX;\n    int maxBeaten = 0;\n    \n    for (const auto& start : rooks) {\n        queue<Position> q;\n        set<pair<int, int>> start_set;\n        start_set.insert(start); \n        q.emplace(start.first, start.second, 0, start_set);\n\n        set<pair<int, int>> visited;\n\n        while (!q.empty()) {\n            Position pos = q.front();\n            q.pop();\n\n            if (visited.count({pos.x, pos.y})) continue;\n            visited.insert({pos.x, pos.y});\n\n            int beatenCount = pos.beaten.size();\n            if (beatenCount > maxBeaten || (beatenCount == maxBeaten && pos.moves < minMoves)) {\n                maxBeaten = beatenCount;\n                minMoves = pos.moves;\n            }\n\n            for (const auto& dir : directions) {\n                int newX = pos.x + dir.first;\n                int newY = pos.y + dir.second;\n\n                if (newX < 0 || newY < 0) continue;\n\n                if (dir == directions[4] || dir == directions[5] ||\n                    dir == directions[6] || dir == directions[7]) {\n                    // Diagonal movement - only beat\n                    if (find(rooks.begin(), rooks.end(), make_pair(newX, newY)) != rooks.end()) {\n                        set<pair<int, int>> new_beaten = pos.beaten;\n                        new_beaten.insert({newX, newY});\n                        q.emplace(newX, newY, pos.moves + 1, new_beaten);\n                    }\n                } else {\n                    // Horizontal/Vertical movement\n                    if (!visited.count({newX, newY})\n                        && find(rooks.begin(), rooks.end(), make_pair(newX, newY)) == rooks.end()) {\n                        q.emplace(newX, newY, pos.moves + 1, pos.beaten);\n                    }\n                }\n            }\n        }\n    }\n\n    return minMoves;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> rooks(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> rooks[i].first >> rooks[i].second;\n    }\n    cout << minMovesToBeatMaxRooks(N, rooks) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 12:01:03"
  }
]